<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/3" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/3" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="그래프 유형 및 온톨로지 기반 데이터 구조 이해하기" href="/post/2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="그래프 유형 및 온톨로지 기반 데이터 구조 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="그래프 유형 및 온톨로지 기반 데이터 구조 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">그래프 유형 및 온톨로지 기반 데이터 구조 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="LIDA를 활용한 대규모 언어 및 이미지 생성 모델 사용 데이터 시각화 방법" href="/post/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="LIDA를 활용한 대규모 언어 및 이미지 생성 모델 사용 데이터 시각화 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="LIDA를 활용한 대규모 언어 및 이미지 생성 모델 사용 데이터 시각화 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">LIDA를 활용한 대규모 언어 및 이미지 생성 모델 사용 데이터 시각화 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">13<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="LangProp을 사용하여 자율주행 코드 작성 향상시키기" href="/post/2024-06-27-MakingLLMsWriteBetterandBetterCodeforSelf-DrivingUsingLangProp"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="LangProp을 사용하여 자율주행 코드 작성 향상시키기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-MakingLLMsWriteBetterandBetterCodeforSelf-DrivingUsingLangProp_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="LangProp을 사용하여 자율주행 코드 작성 향상시키기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">LangProp을 사용하여 자율주행 코드 작성 향상시키기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AI의 역사 파트 1 인공지능의 기원과 발전" href="/post/2024-06-27-AHistoryofAIPart1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AI의 역사 파트 1 인공지능의 기원과 발전" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-AHistoryofAIPart1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AI의 역사 파트 1 인공지능의 기원과 발전" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">AI의 역사 파트 1 인공지능의 기원과 발전</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="아기들을 위한 로봇 만들기 쉬운 단계별 가이드" href="/post/2024-06-27-RobotMakingforBabies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="아기들을 위한 로봇 만들기 쉬운 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-RobotMakingforBabies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="아기들을 위한 로봇 만들기 쉬운 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">아기들을 위한 로봇 만들기 쉬운 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리눅스 도구 Sed 40 기본 명령어 입문" href="/post/2024-06-27-LinuxToolsSed40CommandsIntro"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리눅스 도구 Sed 40 기본 명령어 입문" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-LinuxToolsSed40CommandsIntro_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리눅스 도구 Sed 40 기본 명령어 입문" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">리눅스 도구 Sed 40 기본 명령어 입문</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Photoshop 및 InDesign 대체 프로그램 TOP 3 알아보기" href="/post/2024-06-27-MyThreeFavoriteAlternativestoPhotoshopandInDesign"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Photoshop 및 InDesign 대체 프로그램 TOP 3 알아보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-MyThreeFavoriteAlternativestoPhotoshopandInDesign_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Photoshop 및 InDesign 대체 프로그램 TOP 3 알아보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Photoshop 및 InDesign 대체 프로그램 TOP 3 알아보기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="임베디드 AI  배터리 충전 상태를 관리하는 방법" href="/post/2024-06-27-EmbeddedAIBatteryStateofCharge"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="임베디드 AI  배터리 충전 상태를 관리하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-EmbeddedAIBatteryStateofCharge_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="임베디드 AI  배터리 충전 상태를 관리하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">임베디드 AI  배터리 충전 상태를 관리하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="레이저, 펩타이드, 성장 호르몬, 줄기 세포를 이용한 생물학적 3D 프린터 만드는 방법" href="/post/2024-06-27-HowtoCreateaBiological3DPrinterUsingLasersPeptidesGrowthHormonesandStemCells"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="레이저, 펩타이드, 성장 호르몬, 줄기 세포를 이용한 생물학적 3D 프린터 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-HowtoCreateaBiological3DPrinterUsingLasersPeptidesGrowthHormonesandStemCells_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="레이저, 펩타이드, 성장 호르몬, 줄기 세포를 이용한 생물학적 3D 프린터 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">레이저, 펩타이드, 성장 호르몬, 줄기 세포를 이용한 생물학적 3D 프린터 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안타레스 이지 제품 개발 비하인드 우수성을 창출하기 위한 도전 극복기" href="/post/2024-06-27-BehindtheProductofAntaresEazyNavigatingChallengestoCreateExcellence"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안타레스 이지 제품 개발 비하인드 우수성을 창출하기 위한 도전 극복기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-27-BehindtheProductofAntaresEazyNavigatingChallengestoCreateExcellence_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안타레스 이지 제품 개발 비하인드 우수성을 창출하기 위한 도전 극복기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">안타레스 이지 제품 개발 비하인드 우수성을 창출하기 위한 도전 극복기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link posts_-active__YVJEi" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"그래프 유형 및 온톨로지 기반 데이터 구조 이해하기","description":"","date":"2024-06-27 19:10","slug":"2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures","content":"\n\n안녕하세요 멋진 분들, 링크드인에서 그래프와 인공지능에 대한 일반적인 오해가 돌고 있다는 것을 알게 되어 몇 가지 통찰을 공유하는 것이 도움이 될 것 같아요. 이 정보가 유익하게 느껴지고 복잡한 AI 시스템을 효과적으로 구축하는 데 도움이 되기를 바라며 이해에 도움이 될 것입니다. 여러분과 함께 이에 대한 관련하여 활발한 토론를 기대하고 있어요 — 제 링크드인 페이지에서 만나요.\n\n그래프는 컴퓨터 과학부터 생명정보학까지 다양한 분야에서 본질적으로 중요합니다. 그러나 서로 다른 유형의 그래프를 구분하고 고유한 특성 및 응용을 이해하는 것이 중요합니다. Directed Acyclic Graphs (DAGs), Label Property Graphs (LPGs), Bipartate Graphs, Semantic Knowledge Graphs에 초점을 맞추어 이러한 구별을 명확히 하고 공간추론의 문맥에서 정보적으로 주도되는 데이터 구조로써의 역할에 대해 설명하려고 합니다.\n\n# Directed Acyclic Graphs (DAGs)는 Flowcharts (요컨대)\n\n플로우차트는 프로세스 또는 워크플로우를 나타내는 다이어그램 유형으로, 종종 Directed Acyclic Graph (DAG)으로 시각화됩니다. DAG는 방향성이 있고 사이클이 없는 그래프로, 한 노드에서 다른 노드로의 단방향 경로가 있지만 루프는 없다는 것을 의미하여 \"비순환적\"이에요. 이는 작업흐름이나 계산과정의 단계와 같이 명확한 선형 진행을 가진 프로세스를 나타내는 데 적합하게 만들어 주어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플로우차트는 DAG를 시각화하는 흔한 방법이지만, DAG 자체가 지식 그래프는 아니라는 점을 알아두는 것이 중요합니다. DAG는 일정정렬과 조합적 열거와 같은 다양한 알고리즘에서 활용되어 일정 조정, 데이터 처리 단계 등과 같은 문제를 해결하는 데 사용됩니다. DAG의 주요 관심사는 작업의 순서와 의존성에 있으며, 의미적 관계나 고수준 추론에 대한 것은 아닙니다.\n\n## 의미 지식 그래프\n\n반면에, 의미 지식 그래프는 추론과 추론을 가능하게 하는 방식으로 지식을 표현하도록 설계되어 있습니다. 이러한 그래프는 엔티티를 나타내는 노드와 관계를 나타내는 엣지를 포함하며 의미 정보로 풍부해집니다. 이를 통해 고수준 쿼리와 추론이 가능해지면서 단순한 데이터 검색을 넘어선다.\n\n의미 지식 그래프의 핵심 기능은 엔티티 간의 관계를 설명하는 요소인 데이터 술어의 사용입니다. 이러한 술어는 상세 정보를 보다 폭넓은 개념에 연결시키는데 기여해 복잡한 쿼리와 추론을 가능케 합니다. DAG와 달리 의미 지식 그래프는 정보를 구조화하는 데 사용되는 체계적인 프레임워크인 온톨로지를 활용합니다. 온톨로지는 엔티티 유형, 관계, 추론 규칙을 정의하고 도메인 간 데이터 지점을 연결하며 하위 도메인 내에서 상호 연결되어 데이터의 보다 깊은 이해를 용이하게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 레이블 속성 그래프 (LPGs)\n\n데이터 및 그 관계를 나타내는 데이터 구조입니다. LPGs에서 노드와 엣지는 각각 다양한 속성을 가질 수 있어 엔티티와 네트워크 내에서의 상호 연결성을 상세히 표현할 수 있습니다. 이 속성이 풍부한 구조는 단순한 쿼리 뿐만 아니라 복잡한 분석도 지원하여 데이터 관계를 심층적으로 탐색해야 하는 애플리케이션에 이상적입니다. 그들의 견고성에도 불구하고 LPGs의 표현 능력은 구조에 의해 제한됩니다. 이는 단순한 이진 관계 이상을 나타내야 하는 시나리오에서 어려움을 겪을 수 있습니다. 이는 맥락적 추론의 기초가 되지 않는 것입니다.\n\n# 이분 그래프\n\n이분 그래프는 교점이 없도록 두 개의 상이한 부분 집합으로 정점의 집합을 나눌 수 있는 특수한 그래프 유형입니다. 즉, 동일 부분 집합 내의 두 정점이 서로 인접하지 않습니다. 이는 그래프의 모든 엣지가 한 부분 집합에 속하는 정점을 다른 부분 집합에 속하는 정점에 연결한다는 것을 의미합니다. 이분 그래프는 노동자와 작업을 나타내는 것과 같이 두 가지 서로 다른 객체 클래스 사이의 관계를 모델링하는 데 특히 유용합니다. 여기서 하나의 부분 집합은 노동자를 나타내고 다른 부분 집합은 작업을 나타내며, 엣지는 어떤 노동자가 어떤 작업에 할당되어 있는지를 나타냅니다. 이분 그래프는 매칭 문제를 해결하거나 네트워크 흐름을 최적화하며, Hopcroft-Karp 알고리즘과 같은 이분 매칭 알고리즘을 위한 알고리즘을 설계하는 데도 필수적입니다. 이분 그래프의 구조는 많은 계산 문제를 단순화하여 많은 실용적 응용분야에서 강력한 도구로 작용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# RDF (Resource Description Framework) 트리플\n\nRDF 트리플은 그래프는 아니지만 시맨틱 웹을 위한 데이터 구조화에 핵심적인 요소로 작용하는 리소스 설명 프레임워크의 중요한 부분입니다. 주어, 술어, 목적어로 구성된 각 RDF 트리플은 특정한 자원에 관한 명세적인 선언을 하여 데이터를 의미 있는 방식으로 연결합니다. 주어는 해당 자원을 나타내고, 술어는 주어와 목적어를 연결하는 관계 유형을 나타내며, 목적어는 다른 자원이나 리터럴 값이 될 수 있습니다. 이러한 구조화된 접근법은 도메인 내에 지식을 형식화하는 온톨로지(ontologies)를 만드는 것을 용이하게 합니다. RDF 트리플은 정확한 시맨틱 관계를 통해 개념을 정의하고 상호 연결하여 복잡한 데이터 검색 및 추론을 가능케 하며, 다양한 정보 시스템이나 도메인 간에 정보를 연결하는 기초를 제공합니다 — 마치 여러 주제 전문가(SME들)의 정보를 한꺼번에 연결할 수 있는 것과 같습니다.\n\n- 시맨틱 관계: RDF 트리플은 URI(Uniform Resource Identifiers)를 사용하여 관계를 표현합니다. URI는 전역적으로 고유하기 때문에 서로 다른 데이터 항목 간에 명확하고 모호하지 않은 연결을 정의하는 데 도움이 됩니다. 이러한 전역 식별 시스템은 서로 다른 데이터 세트에서 동일한 용어가 동일한 개념을 가리키도록 보장하여 다양한 소스에서 데이터를 병합하고 질의하는 작업을 수월하게 합니다.\n- 유연한 스키마: RDF는 데이터가 생성되거나 통합되기 전에 고정된 스키마를 요구하지 않습니다. 이 유연성은 RDF가 다양한 도메인에 적응하고 기존 데이터베이스 구조를 재구성하지 않고도 새로운 유형의 데이터를 통합하는 데 도움을 줍니다. 이러한 적응성은 서로 다른 시스템과 구조에서 기인한 데이터 지점을 연결하는 데 중요합니다.\n- 표준화된 쿼리 언어 (SPARQL): RDF 데이터는 SPARQL을 사용하여 쿼리할 수 있습니다. SPARQL은 RDF 형식으로 저장된 데이터를 검색하고 조작하기 위해 특별히 설계된 강력하고 표준화된 쿼리 언어이며, 여러 데이터 소스에 걸쳐 복잡한 쿼리를 수행할 수 있습니다. 이와 같이 인터넷 상에 흩어져 있는 데이터 소스를 포함한 여러 데이터를 처리하는 것이 가능하여 다양한 도메인 간의 복잡한 추론과 분석을 용이하게 합니다.\n- 온톨로지 추론 제공: RDF는 종종 도메인 지식의 형식화된 어휘인 온톨로지와 함께 사용됩니다. 온톨로지는 개념 사이의 구조화된 관계와 계층을 정의하며, 논리적 추론에 사용될 수 있습니다. 온톨로지에서 RDF를 사용하면 시스템이 명시적인 데이터에서 추가 정보를 추론할 수 있어 더욱 깊은 문맥적 이해와 추론을 가능케 합니다. 예를 들어, \"모든 의사는 의료 전문가이다\"라는 온톨로지가 있고, RDF 트리플이 \"제인은 의사이다\"라고 하면, 시스템은 \"제인은 의료 전문가이다\"를 추론할 수 있습니다.\n- 상호 운용성 및 통합: RDF 프레임워크는 상호 운용성을 지원하도록 설계되었으며, 다양한 도메인에서 데이터를 연결하고 통합하는 것을 쉽게 만듭니다. RDF 형식은 데이터가 서로 다른 시스템에서 동일한 방식으로 이해되고 활용될 수 있도록 보장하여 크로스 도메인 데이터 사용 시 일반적으로 마주치는 장벽을 줄입니다.\n\n온톨로지 생성의 기초를 탐구하고 싶다면 다른 기사를 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 그래프 구조 해제: 그래프 네트워크를 목적에 매핑하는 수학 공식들\n\n![Image](/assets/img/2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures_0.png)\n\n# 맥락적 추론을 위한 주요 공식 (또는 아님)\n\n# DAGs에 대한 선형 프로세스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 무사이클의 정점과 간선:\n\n![Vertices and Edges with no cycles](/assets/img/2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures_1.png)\n\n2. 위상 정렬:\n\n![Topological Sort](/assets/img/2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 선형 관계:\n\n![Image](/assets/img/2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures_3.png)\n\n# 온톨로지 주도 시맨틱 지식 그래프\n\n- 관계를 나타내는 세트:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures_4.png)\n\n2. 온톨로지가 도메인 간 데이터 포인트를 연결:\n   \n   ![이미지](/assets/img/2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures_5.png)\n\nC는 개념을, R은 관계를 나타냅니다. 이러한 온톨로지는 복잡한, 상호 연결된 데이터 표현을 가능하게 하며, 고급 시맨틱 쿼리와 도메인 간 추론을 지원합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 레이블 속성 그래프 (LPG)는 이진 관계로 연결됩니다.\n\n- 속성을 가진 정점과 간선:\n\n![image](/assets/img/2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures_6.png)\n\n2. 속성을 가진 간선:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures_7.png)\n\n선형, 다중 이진 관계를 나타내는 그래프입니다. 이는 Named Entity Recognition (NER) 모델과 같은 애플리케이션에 적합하며, 각 엔티티와 관계가 특정 속성을 가지지만 복잡하지 않고 도메인 간의 연결된 데이터 포인트를 지원하지 않아 문맥적 의미 추론에 한계가 있습니다.\n\n# 이분 그래프에서의 최대 매칭\n\n- 최대 매칭:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![그림](/assets/img/2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures_8.png)\n\n이것은 두 가지 이상의 간선이 공통 정점을 공유하지 않는 최대 가능한 에지 집합을 나타냅니다. 이는 \"최적 맞춤\" 및/또는 자원 할당을 최적화하는 데 중요합니다.\n\n주의할 점: 이러한 개념을 이해하는 것이 중요합니다. DAGs, 이분 그래프 및 기타 그래프 알고리즘은 그래프 이론에서 잘 알려져 있습니다. 각 그래프 유형은 특정한 수학적 속성과 공식을 갖고 있으며, 조합적 열거 및 위상순서와 같은 내용을 포함합니다. 의미론적 지식 그래프의 경우, 데이터 술어와 같은 추가 요소가 있어 고수준 추론을 가능하게 하고 세부 해결책 또는 최종 상태에 연결시킵니다.\n\n워크플로우 및 Named Entity Recognition (NER) 모델의 그래프 표현은 가치가 있으며 특정 사용 사례가 있지만, 올바른 구현과 적용을 인식하는 것이 중요합니다. 이러한 개념을 오해하면 그 기능과 목적에 대해 잘못된 결론을 내릴 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"이것이 AI 그래프를 활용하는 여정에서 도움이 되길 바라며, 읽어주셔서 감사합니다!\"","ogImage":{"url":"/assets/img/2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures_0.png"},"coverImage":"/assets/img/2024-06-27-UnderstandingGraphTypesandOntological-DrivenDataStructures_0.png","tag":["Tech"],"readingTime":7},{"title":"LIDA를 활용한 대규모 언어 및 이미지 생성 모델 사용 데이터 시각화 방법","description":"","date":"2024-06-27 19:07","slug":"2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA","content":"\n\n## LIDA 라이브러리 개요, 시작하는 방법, 예시 및 앞으로 고려 사항\n\n최근에 LIDA라는 라이브러리를 발견했어요 - 문법에 구애받지 않는 라이브러리로, 대형 언어 모델(Large Language Models, LLMs)과 이미지 생성 모델(Image Generation Models, IGMs)을 사용하여 데이터 시각화 및 인포그래픽을 자동으로 생성합니다. LIDA는 OpenAI와 Hugging Face와 같은 다양한 대형 언어 모델 제공 업체와 함께 작동합니다. 이 게시물에서는 이 라이브러리에 대한 고수준 개요를 제공하고 시작하는 방법을 안내하며 몇 가지 예시를 강조하고, 데이터 시각화 및 비즈니스 인텔리전스(Business Intelligence, BI) 분야에서 LLMs 및 IGMs의 사용에 대한 생각과 고려 사항을 공유할 거에요.\n\n![데이터 시각화 및 인포그래픽 생성에 대한 이미지](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_0.png)\n\n# 개요¹\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 시각화를 만드는 것은 종종 복잡한 작업입니다. 데이터 조작, 코딩 및 디자인 기술이 필요한 작업이죠. LIDA는 개발 시간, 오류 발생 횟수, 그리고 전반적인 복잡성을 줄여주는 오픈 소스 라이브러리입니다.\n\nLIDA는 다음 이미지에 표시된대로 4개의 모듈로 구성되어 있습니다. 각 모듈은 본격적인 시각화 생성 과정에서 고유한 목적을 가지고 있습니다.\n\n![LIDA Modules](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_1.png)\n\n- **SUMMARIZER**: 이 모듈은 데이터를 자연어로 요약합니다. 요약은 두 단계로 이루어집니다. 첫 번째 단계인 `Base Summary Generation`에서는 pandas 라이브러리를 사용하여 데이터 집합에서 속성을 추출하는 규칙을 적용하고 일반 통계를 생성하며, 데이터 집합의 각 열에 대해 몇 가지 샘플을 추출합니다. 두 번째 단계인 `Summary enrichment`에서는 `LLM`이나 사용자를 통해 기본 요약 단계의 내용을 보완하여 데이터 집합과 필드에 대한 의미적 설명을 포함합니다.\n- **GOAL EXPLORER**: 이 모듈은 `SUMMARIZER` 모듈이 생성한 요약을 기반으로 데이터 탐색 목표를 생성합니다. 이 모듈에서 생성된 목표는 JSON 데이터 구조로 표시되며, 해당 목표에 대한 질문, 해당 질문에 대한 시각화 및 논리적 근거를 포함합니다.\n- **VIZ GENERATOR**: 이 모듈은 3개의 하위 모듈(코드 프레임워크 생성기, 코드 생성기 및 코드 실행기)로 구성되어 있습니다. 이 모듈의 목표는 `GOAL EXPLORER` 모듈에서 나온 데이터 시각화 목표 또는 사용자가 생성한 새로운 시각화 목표에 따라 시각화 코드를 생성, 평가, 수리, 필터링 및 실행하는 것입니다.\n- **INFOGRAPHER**: 이 모듈은 `VIZ GENERATOR` 모듈의 출력 및 시각화, 스타일 프롬프트를 기반으로 IGM을 활용하여 스타일이 적용된 인포그래픽을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLIDA는 LLM(Large Language Model)의 두 가지 핵심 능력을 활용합니다:\n\n- 언어 모델링 — 이러한 능력은 의미 있는 시각화 목표 생성을 돕습니다.¹\n- 코드 쓰기(즉, 코드 생성) — 이러한 능력은 데이터 시각화를 만드는 데 도움을 주며, 그 후에는 DALL-E나 잠재 확산(Latent Diffusion)과 같은 이미지 생성 모델에 입력으로 사용됩니다. 이 모델들은 스타일화된 인포그래픽을 생성합니다.¹\n\n또한, LIDA 도구 내에서 프롬프트 엔지니어링이 사용됩니다.\n\n\"프롬프트 엔지니어링은 AI 언어 모델과의 상호작용을 위해 설계, 최적화 및 개선된 프롬프트를 사용하는 프로세스입니다. 프롬프트란 AI 시스템에 입력되어 특정 응답이나 출력을 유발하기 위한 질문, 진술 또는 요청입니다.\"²\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLIDA에 프롬프트 엔지니어링 기능을 통합하는 몇 가지 방법 중 하나는 프롬프트를 사용하여 6 가지 평가 차원을 생성하고 정의하는 것이며, 사용자가 시각화를 포맷하는 스타일 프롬프트를 지정할 수 있는 능력을 가지고 있습니다.\n\n이 게시물의 나중에 나오는 예제는 이 섹션에서 언급된 몇 가지 기능에 대한 자세한 내용을 더 보여줍니다. 그리고 LIDA에 대해 더 많은 정보를 읽을 수 있습니다.\n\n# 시작하기\n\nLIDA를 시작하는 방법은 2가지가 있습니다. 파이썬 API를 통해 시작하거나 하이브리드 사용자 인터페이스를 통해 시작할 수 있습니다. 이 섹션에서는 LIDA 라이브러리의 선택적 번들 UI 및 웹 API를 사용하여 로컬 기기에서 사용자 인터페이스를 시작하는 방법을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고: 이 예시에서는 OpenAI를 사용하고 있습니다. 다른 LLM 제공 업체를 사용하거나 Python API를 사용하려면 여기 있는 GitHub 문서를 확인해보세요.\n\n## 단계 1: 필요한 라이브러리 설치\n\n컴퓨터에 다음 라이브러리를 설치하세요.\n\n```js\npip install lida\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\npip install -U llmx openai\n```\n\n## 단계 2: OpenAI API 키를 저장할 변수 생성하기\n\nOpenAI API 키를 만들려면 프로필로 이동하여 `사용자 API 키` 항목을 선택한 다음 + 새 비밀 키 만들기를 선택하십시오.\n\n![이미지](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI 키를 복사하세요. 새 터미널 창에서 다음과 같은 변수인 OPENAI_API_KEY에 API 키를 저장하세요.\n\n```js\nexport OPENAI_API_KEY=\"\"\n```\n\n## 단계 3: UI 웹 앱 시작하기\n\n터미널 창에서 다음 명령어로 LIDA UI 웹 앱을 시작하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\nlida ui --port=8080 --docs\n```\n\n웹 브라우저에서 \"localhost:8080\"으로 이동하면 시작 준비가 완료됩니다! 라이브 데모 또는 데모 탭 중 하나를 선택하여 웹 앱을 확인할 수 있습니다.\n\n![웹 앱 예시](https://miro.medium.com/v2/resize:fit:1400/1*yfIcWLTjCfhmJbeuD4jtOw.gif)\n\n# 웹 앱 예시\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 섹션에서는 Kaggle의 Top 10 Films US Box Office 데이터 세트³를 사용한 몇 가지 예제와 팁을 살펴봅니다.\n\n## 단계 1: 시각화 라이브러리/언어 선택\n\n데이터 시각화 또는 요약을 생성하기 전에 사용할 시각화 라이브러리를 선택하세요. 선택할 수 있는 옵션은 4가지가 있습니다: Altair, Matplotlib, Seaborn, 그리고 GGPlot. 시작하기 전에, Matplotlib을 기반으로 하는 데이터 시각화용 Python 라이브러리인 Seaborn을 선택하세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*6iWPYsaP7Cm-dkerFG_ooQ.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n팁: 어떤 라이브러리부터 시작해야 할지 잘 모르겠으면 하나를 선택하고 나중에 바꿀 수 있어요! 데이터를 업로드한 후에도 시각화 라이브러리/문법을 나중에 바꿀 수 있어요. 데이터를 로드한 후에 바꾸려고 하면 오류가 발생할 수 있는데, 간단히 새로고침하면 문제가 해결될 거예요.\n\n## 단계 2: 생성 설정 검토\n\n오른쪽에 생성 설정을 수정할 수 있는 옵션이 있어요. 여기서 모델 제공 업체를 선택하고 생성에 사용할 모델을 선택하며, 최대 토큰, 온도, 메시지 수 등의 다른 필드를 조정할 수 있어요. 지금은 기본 설정을 유지해 주세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*fJ8MRGf7ip2ATKfAKARs9A.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 3: 데이터 업로드\n\n기본 매개변수를 설정한 후 데이터 세트를 업로드하세요. 파일을 클릭하거나 드래그하여 웹 앱에 데이터 세트를 업로드할 수 있습니다. 또는 제공된 샘플 파일 중 하나를 사용할 수도 있습니다.\n\n![image](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_3.png)\n\n팁: 파일을 업로드하려고 할 때 오류가 발생하면 선택한 모델 공급 업체의 사용량 및 결제 액세스를 확인해보세요. 액세스 문제는 LIDA에서 데이터 파일 업로드 문제로 이어질 수 있습니다. 또한, 터미널 창에 에러 메시지가 표시됩니다. 문제 해결에 유용한 경우가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주의: LIDA 홈페이지로 다시 전환하는 경우 현재 화면의 작업이 손실될 수 있으니 유의하시기 바랍니다!\n\n## 단계 4: 데이터 요약 확인\n\n데이터 요약 섹션은 데이터 세트에 대한 설명과 열 유형, 고유 값 수, 열 설명, 샘플 값 등을 요약한 내용을 제공합니다. 이 결과물은 이전에 언급된 SUMMARIZER 모듈의 결과입니다.\n\n다음 이미지는 미국 박스 오피스 최상위 10개 영화 데이터 세트에 대한 데이터 요약을 보여줍니다. 데이터 세트 전체에 대한 설명과 데이터 세트의 9개 열에 대한 설명이 포함되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_4](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_4.png)\n\nJSON 딕셔너리 형식으로 데이터 요약을 보려면 View raw summary?를 선택하세요.\n\n![Data Visualization](https://miro.medium.com/v2/resize:fit:1400/1*sRCct7rrQbHdof0_esW-qw.gif)\n\n## 단계 5: 목표 탐색 검토\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 섹션에는 업로드된 데이터셋을 기반으로 자동으로 생성된 목표 또는 가설 목록이 표시됩니다. 각 목표는 질문으로 제시되며, 시각화가 무엇을 표시할지 설명이 포함되어 있습니다. 이 출력물은 이전에 언급된 GOAL EXPLORER 모듈의 결과입니다.\n\n여기서 여러 가설을 읽어볼 수 있고, Visualization Generation 섹션에서 시각화할 항목을 선택할 수 있습니다.\n\n![이미지](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_5.png)\n\n## 단계 6: 시각화 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 섹션에서 선택한 목표, Goal Exploration에 따라, 해당 목표를 시각화하는데 사용된 Python 코드와 함께 시각화를 볼 수 있습니다.\n\n다음 이미지는 \"영화 발매 월별 분포는 무엇인가?\"라는 목표에 대한 결과를 보여줍니다. 왼쪽에는 시각화인 수직 막대 차트가 있고, 오른쪽에는 시각화를 생성하는 데 사용된 Python 코드가 있습니다. 이 코드 조각은 외부 사용을 위해 복사할 수 있습니다.\n\n![Visualization](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_6.png)\n\n또는 Goal Exploration 섹션에 나열된 목표 이외에도 새로운 시각화 목표를 입력할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 다음 이미지는 \"가장 큰 평균 예산을 갖는 상위 5개 장르는 무엇인가요?\"에 대한 결과를 보여줍니다.\n\n![image](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_7.png)\n\n참고: 목표 오른쪽에 있는 '생성' 버튼을 선택하면 시각화가 새로 고침됩니다. 이는 색 구성이 변경되는 등의 약간의 변화를 일으킬 수 있습니다.\n\n## 단계 7: 시각화 수정 및 평가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시각화가 생성되면 사용할 수 있는 4개의 탭이 있습니다: 개선(Refine), 설명(Explain), 평가(Evaluate) 및 추천(Recommend).\n\n![image](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_8.png)\n\n첫 번째 탭인 개선(Refine)은 자연어 명령을 사용하여 차트를 수정합니다.\n\n다음 이미지는 \"월별 영화 개봉 분포가 어떻게 되는가?\"라는 차트를 개선 탭을 사용하여 수정한 내용을 보여줍니다. 차트는 월을 날짜 순서대로 정렬하고, 수평 막대 차트로 값을 표시하고, 각 막대에 계수 값을 추가하는 자연어 명령을 사용하여 수정되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Data Visualization Generation Using Large Language and Image Generation Models with LIDA](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_9.png)\n\n팁: 스타일 프롬프트가 명확하고 간결하며 구체적인지 확인하세요! 그렇지 않으면 왜곡된 시각화, 예상치 못한 결과 또는 자연어 명령이 차트로 렌더링되지 않을 수 있습니다. 프롬프트 작성은 예술이므로 효과적인 스타일 프롬프트를 작성하려면 일부 수정이 필요할 수 있습니다.\n\n일부 스타일 프롬프트가 예상대로 나오지 않았다면 몇 가지 스타일 프롬프트 후 시각화를 재설정해야 한다면 시갤 채팅 기록 버튼을 사용하여 시갤 불러오기.\n\n![Data Visualization Generation Using Large Language and Image Generation Models with LIDA](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_10.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 번째 탭 '설명'은 시각화가 어떻게 만들어졌는지에 대한 텍스트 설명을 제공합니다. 데이터 변환, 차트 요소, 코드 등을 설명합니다.\n\n![이미지](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_11.png)\n\n세 번째 탭 '평가'는 생성된 차트를 6가지 차원에서 평가합니다: 버그, 변환, 준수, 유형, 인코딩 및 미적 감각. 각 차원은 5점 만점으로 평가되며, 해당 등급을 받은 이유에 대한 설명이 포함되어 있습니다.\n\n![이미지](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_12.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 이미지에서 볼 수 있듯이, 차트를 자동으로 수정하는 옵션이 있습니다. 오른쪽 하단에 있는 버튼인 \"차트 자동 수정\"을 사용할 수 있습니다. 차트 평가에서 제공된 권장 사항에 동의한다면, 이것은 수정을 적용하는 좋고 빠른 방법입니다! 아래 이미지는 심미성 평가를 기반으로 차트를 자동으로 수정한 후 업데이트된 차트를 보여줍니다.\n\n![image](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_13.png)\n\n네 번째 탭인 \"추천!\"은 유사한 차트와 해당 코드 조각을 생성하며, 초기 목표에 얽매이지 않습니다. 이는 데이터로부터 얻을 수 있는 기타 차트나 통찰을 떠올리는 데 유용할 수 있습니다.\n\n![image](/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_14.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 생각과 고려사항\n\n이 섹션에서는 데이터 시각화 및 비즈니스 인텔리전스 분야에서 LLMs 및 IGMs의 사용에 대한 몇 가지 고려 사항을 강조합니다. 이는 자동 데이터 시각화 생성을 포함하나 이에 한정되지는 않습니다.\n\n## 평가 지표\n\nLIDA는 2가지 지표를 사용합니다 — 시각화 오류율(VER)과 자가평가 시각화 품질(SEVQ).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVER는 생성된 시각화 중 코드 컴파일 오류를 의미하는 백분율을 보여줍니다.\n\nSEVQ는 GPT-4와 같은 LLMs를 사용하여 생성된 시각화의 품질을 평가합니다. 코드 정확성, 데이터 변환, 목표 부합성, 시각화 유형, 데이터 인코딩 및 미적 요소라는 6가지 차원의 평균 점수를 제공합니다. 이러한 차원들은 각각 LLM에 제공된 프롬프트를 기반으로 점수가 생성됩니다. 다음은 사용된 프롬프트의 스케치를 확인할 수 있는 논문 링크입니다¹. LIDA 웹 앱의 평가 탭에 이러한 차원들이 나오는 것을 기억하실 겁니다.\n\n이러한 측정 항목은 시각화 생성을 평가하며, 중요한 점을 제기합니다. LLMs와 IGMs를 데이터 시갖화와 BI 도구에 사용하는 방식을 평가할 때는 이 점을 주의해야 합니다. 이 분야가 계속 발전함에 따라, 실무자들은 조직을 위해 데이터 시갖화와 BI 솔루션에 LLMs와 IGMs를 도입할 때 이러한 점을 염두에 두어야 하며, 앞으로 고려해야 할 메트릭이 무엇인지, 어떤 프로세스가 구축되어야 하는지, 출력물이 정확하고 신뢰할 수 있으며 설명 가능하며 통제되는지를 어떻게 보장할지 스스로에게 물어보아야 합니다.\n\n## 배포 — 환경 설정 고려 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n조직 내 데이터 시각화에 LLM 및 IGM을 활용할 때는 배포에 관련된 몇 가지 사항을 고려해야 합니다.\n\n데이터 시각화를 위해 이러한 모델을 사용하거나 일반적으로 사용할 경우, 모델 크기, 데이터셋 크기, 사용자 수 등과 같은 요소에 따라 많은 리소스가 필요할 수 있습니다. 이를 올바르게 계획하고 효율적으로 수행하지 않으면 높은 비용이 발생할 수 있습니다. 원활한 구현을 위해 올바른 인프라가 마련되어 있는지 확인하는 것이 중요합니다. 특정 사용 사례에 보다 정밀한 LLM을 테스트하면 전반적인 영향을 줄일 수도 있습니다.\n\n또한 데이터 시각화를 위해 LLM 및 IGM을 사용할 때 데이터 보안과 거버넌스가 중요합니다. 어떤 도구를 사용하더라도 도구 내에서 데이터가 안전하고 사용 중에 거버넌스가 지속되도록 보장하는 것이 중요합니다.\n\n## 차트 설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 예제에서 보듯이, LIDA 내에서 생성된 차트 설명은 차트가 생성된 방식에 대한 세부 정보에 초점을 맞추고 있습니다. 데이터 변환, 차트 요소 및 생성된 코드에 대한 내용입니다. 이는 데이터 세트와 함께 차트를 만드는 개발자에게 도움이 됩니다. 그러나 비즈니스 사용자들에게는 이러한 유형의 문맥이 유익하지 않습니다. 비즈니스 사용자와 분석가는 시각화 내 데이터 포인트에 대한 통찰을 포함하는 차트 설명에서 혜택을 받을 것입니다. 그뿐만이 아니라 차트 요소와 구조뿐만 아니라 시각화 내 데이터 포인트에 대한 통찰을 제공하는 자연 언어 텍스트는 개인의 역할과 관계없이 데이터 시각화에서 중요한 통찰력을 제공하는 것에 도움이 될 수 있습니다.\n\n비즈니스 인텔리전스(BI) 도구에 통합 가능한 일부 자연어 생성(NLG) 도구가 오늘날에 개발되어 있습니다. LLMs, IGMs 및 데이터 시각화 솔루션이 계속 발전하는 공간을 관찰하는 것이 흥미로울 것입니다.\n\nBI와 NLG를 함께 본 적이 없나요? 간단한 소개를 보려면 이 GitHub 페이지를 확인해보세요.\n\n앞으로 나아가면서, 최종 사용자를 고려하고 그들의 목표와 관심사에 기반하여 해당 관객에게 적합한 LLM + IGM + 데이터 시각화 솔루션을 고려하는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 프롬프트를 사용한 차트 디자인\n\n이전 예시에서는 LLMs와 IGMs를 사용하여 데이터 시각화를 생성하는 방법을 보여주었습니다. 이러한 차트들은 자동으로 생성되지만, 여전히 완벽하게 디자인되도록 수정이 필요합니다. 종종 첫 번째 차트를 그대로 두지 못할 수도 있습니다. 이때는 LIDA의 Auto Repair 기능이 필요한데, 이 기능은 수정해야 하는 내용 중 일부만 캡처하며, 데이터 시각화 도메인에서의 경험과 지식이 필요한 스타일 프롬프트를 포함합니다.\n\n이러한 스타일 프롬프트는 사용자가 자연어로 입력하며, 차트 제목 수정, 차트 색상 변경, 차트 값 정렬 등의 요청이 포함될 수 있습니다.\n\n이러한 스타일 프롬프트를 사용하면 차트를 개발하는 데 필요한 시간을 절약할 수 있습니다. 코드 작성 시간을 줄이고, 코드 디버그와 형식 지정 시간을 줄일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 데이터 시각화 생성 중 프롬프트가 소개되면, 좋은 프롬프트가 무엇인지 이해하는 것이 중요해집니다. 명확하고 간결하며 구체적인 프롬프트는 다른 것보다 더 나은 결과를 얻게 됩니다. 명확하지 않은 요청은 부적합한 시각화나 예기치 않은 결과를 초래할 수 있습니다.\n\n하지만 이것은 데이터 시각화 생성에서 프롬프트를 활용해서는 안 된다는 것을 의미하지는 않습니다. 대신, 시작할 때 학습 곡선이 존재할 수 있다는 것을 지적하는 것입니다. 적절한 프롬프트를 찾는 것은 일부 테스트를 필요로하며, 명확히 작성된 명령이 필요합니다.\n\n전반적으로, LIDA는 LLMs, IGMs, \u0026 데이터 시각화 분야의 일부 진보를 배우는 데 좋은 오픈 소스 도구입니다. Victor Dibia의 전체 논문을 여기에서 확인하고 웹 앱이나 Python API를 사용하여 LLMs 및 IGMs가 데이터 시각화 생성 방식을 바꾸고 있는 방법을 더 알아보세요.\n\nPayal은 데이터 및 인공 지능 전문가입니다. 여가 시간에는 읽기, 여행, Medium에 글 쓰기를 즐깁니다. 그녀의 작품을 좋아하신다면, 그녀의 목록을 팔로우하거나 구독하여 이야기를 놓치지 마세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상기 기사는 개인적인 의견이며 IBM의 입장, 전략 또는 의견을 반영하는 것은 아닙니다.\n\n참고 자료\n\n[1]: Dibia, Victor. LIDA: A Tool for Automatic Generation of Grammar-Agnostic Visualizations and Infographics Using Large Language Models, Microsoft Research, 8 May 2023, aclanthology.org/2023.acl-demo.11.pdf.\n\n[2]: Vagh, Avinash. “NLP and Prompt Engineering: Understanding the Basics.” DEV Community, DEV Community, 6 Apr. 2023, dev.to/avinashvagh/understanding-the-concept-of-natural-language-processing-nlp-and-prompt-engineering-35hg.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[3]: Films, Will’s. “Top 10 Films at the US Box Office 2000–2023.” Kaggle, 20 Mar. 2024, www.kaggle.com/datasets/willsfilms/top-10-films-at-the-us-box-office-2000-2023. (CC0)","ogImage":{"url":"/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_0.png"},"coverImage":"/assets/img/2024-06-27-DataVisualizationGenerationUsingLargeLanguageandImageGenerationModelswithLIDA_0.png","tag":["Tech"],"readingTime":13},{"title":"LangProp을 사용하여 자율주행 코드 작성 향상시키기","description":"","date":"2024-06-27 19:04","slug":"2024-06-27-MakingLLMsWriteBetterandBetterCodeforSelf-DrivingUsingLangProp","content":"\n\n## 고전적 기계 학습 유추: LLM (Large Language Model) = 옵티마이저; 코드 = 매개변수; LangProp = PyTorch Lightning\n\n아마도 이메일을 쓰거나 문서를 요약하거나 정보를 찾거나 코드 디버깅을 돕는 데에 ChatGPT를 사용해 본 적이 있을 것입니다. 그런데 우리는 ChatGPT가 자동차를 운전하도록 만들 수 있을까요?\n\n작년 3월 Wayve 인턴십을 시작했을 때 이 질문에 답하고 싶었습니다. Wayve는 런던에 위치한 자율 주행차 기업으로 도시 주행이라는 어려운 문제에 end-to-end 학습을 적용하고 있습니다. 당시 회사는 LLM 연구팀을 발대했었고 LINGO-1과 LINGO-2를 성공적으로 개발해냈습니다. AutoGPT는 방금 출시됐고 Voyager는 아직 나오지 않았을 때였습니다. 그런데도 LLM이 일으키는 혼란은 명백했습니다. 질문은, 언어가 주요한 모달리티가 아닌 주행이라는 도메인에 이 새로운 기술을 어떻게 활용할 수 있을까요?\n\n이 블로그 글에서는 작년 5월에 ICLR (국제 학습 표현 연구회의)에서 열린 LLM 에이전트 워크샵에서 발표한 우리의 논문인 LangProp에 대한 개요를 소개하려 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 동기부여: 코드 작성에 ML을 직접 적용합시다.\n\nLLM을 운전에 적용하는 도전은 두 가지 측면에 있습니다. 첫째, LLM은 그 이름대로 말하자면 매우 큰 모델로, 많은 컴퓨팅 자원이 필요하며 실행 속도가 느릴 수 있는 만큼, 자율 주행과 같은 안전 비상 시간 응용에는 적합하지 않아 보일 수 있습니다. 둘째, 언어는 높은 수준의 설명에 좋지만, 관찰을 설명하고 공간 제어 작업을 실행하는 데 필요한 세밀함과 세부 정보가 부족합니다.\n\n그러나 우리는 운전 작업 추론에 반드시 LLM을 사용할 필요가 없다는 것을 깨달았습니다. 대신 LLM이 직접 운전을 위한 코드를 작성하도록 할 수 있습니다.\n\nChatGPT를 사용해 코드를 작성해 본 적이 있다면 이 아이디어가 끔찍한 것처럼 들릴 수 있습니다. ChatGPT가 작성하는 코드는 종종 잘 작동하지 않으며 오류가 포함된 경우도 많습니다. 하지만 우리가 LLM을 사용하여 버그를 감지하고 자동으로 수정하여 코드 품질을 반복적으로 향상시킨다면 어떨까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 이 아이디어를 한 발 더 나아가서 발전시켰어요 - 버그 수정뿐만 아니라, LLM이 생성한 코드를 원하는 목표 함수 방향으로 개선할 수 있는 교육 프레임워크를 설계했답니다. 교육 데이터셋에서 코드를 \"교육\"하여 손실을 감소시키려고 노력할 수 있죠. 코드의 개선은 유효성 검사 데이터셋에서 실행하여 양적으로 확인할 수 있어요.\n\n이게 머신 러닝 같아 보이기 시작했나요? 사실 그렇죠! 하지만 LLM을 적용하는 건 아니에요. 사실, 이 과정에서 적절한 신경망이 미세 조정되는 게 없답니다. 대신, 우리는 코드 자체를 미세 조정하고 있어요!\n\nLangProp에서 \"코드\"란 모델의 매개변수이고, LLM은 매개변수를 손실을 줄이는 방향으로 개선하기 위해 이끄는 최적화 도구예요. 이게 왜 멋진 걸까요? 이런 사고방식을 적용한다면, 이제 우리는 소프트웨어의 최적화를 데이터 기반으로 자동화할 수 있게 될 거예요! 딥러닝을 통해 데이터 기반 접근 방식이 어떻게 어렵게 설명할 수 있는 문제들을 해결하는 데 힘을 보여줬죠. 하지만, 지금까지 머신 러닝의 응용 영역은 숫자 값으로 매개화된 모델로 제한되어 왔어요. 이제 코드로 작성된 시스템들도 다룰 수 있게 된 거죠.\n\n만약 인공 지능의 역사를 따라오셨다면, Symbolic AI와 현대적이면서 성공적인 머신 러닝 접근 방식을 통합하는 이 우아한 방법에 흥미를 느낄 것입니다. Symbolic AI는 인간 전문가가 세계에 대한 완벽한 모델을 논리와 코드 형태로 설명하는 것이었어요. 이는 인간 전문가만으로는 복잡한 작업 (예: 객체 인식)이 로직만으로 설명하기 쉽지 않았단 한계가 있었어요. 반면 머신 러닝은 데이터 자체가 말하도록 하고, 최적의 모델을 자동으로 설계하는 방식으로 작동해요. 이 접근 방식은 패턴 인식, 압축 및 함수 근사화를 포함한 다양한 분야에서 매우 성공적이었어요. 그러나 로직, 추론 및 장기적인 계획은 데이터에 신중하게 신경망을 맞출 때 종종 실패하는 분야에 속해요. 이는 신경망 파라미터 공간의 복잡한 작업을 학습하는 것이 어려운 일이기 때문이에요. LLM과 LangProp을 통해 이제 데이터 기반 학습 방법을 적용하여 상징적인 시스템을 배우고 개선할 수 있게 되었답니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 고지사항\n\n자세히 들어가기 전에, 몇 가지 고지사항이 필요하다고 생각합니다.\n\n- LangProp에 대한 이 작업은 Wayve에서 인턴십 프로젝트로 진행되었으며, 회사의 연구 및 개발 우선순위나 전략을 직접적으로 반영하지 않습니다. 이 블로그 글의 목적은 LangProp을 논문으로 설명하는 것이며, 이 블로그 글의 모든 내용은 제 개인으로서 쓴 것입니다.\n- 우리는 주로 자율 주행의 경우에 LangProp을 시연했지만, (a) 환경의 완벽한 관측이 필요하다는 등의 제한사항을 강조하고 싶습니다., (b) 우리는 단순히 시뮬레이션 환경에서만 작동시켰고 실제 배치로부터는 거리가 먼 것, (c) 생성된 주행 코드가 완벽하거나 정교하지 않으며, 실제 배치에 적합하도록 많은 문제가 있습니다. 우리는 LLM을 데이터 기반 소프트웨어 최적화에 적용한 잠재력을 보여주는 연구 프로토타입으로 LangProp을 보고 있습니다. 제품으로의 배치가 아닙니다.\n\nLangProp의 제한사항에 대한 자세한 정보가 필요하면, 우리 논문의 부록에 있는 제한 섹션을 확인해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그렇다면, LangProp가 어떻게 작동하는지 살펴보겠습니다!\n\n## LangProp는 어떻게 작동하나요?\n\n### ...Symbolic AI와 진화 알고리즘을 다시 가져옵니다\n\n![그림](/assets/img/2024-06-27-MakingLLMsWriteBetterandBetterCodeforSelf-DrivingUsingLangProp_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLangProp은 PyTorch Lightning과 같은 디자인을 가지고 있어요. LangProp 모듈은 훈련되고 추론에 사용되는 매개변수(스크립트의 모음)를 추적합니다. 훈련 모드에서는 정책 추적기가 전방 통과 중에 입력, 출력 및 예외를 기록합니다. 코드의 성능은 목적 함수에 의해 평가됩니다. 점수에 따라 정책 추적기는 현재 있는 스크립트를 다시 순위 지정하고 상위 k개의 스크립트를 LLM으로 보내 세분화를 진행합니다. 추론 시에 예측을 하는 것은 최고 점수의 코드를 호출하는 것만으로 간단합니다.\n\nLangProp 트레이너는 훈련할 LangProp 모듈, 훈련 데이터셋 및 검증 데이터셋을 입력으로 받아요. 데이터셋은 PyTorch Dataset 객체를 포함하여 모든 반복 가능한 객체가 될 수 있어서 기존 작업에 LangProp을 적용하기 쉬워요. 훈련이 완료되면, 우리는 수정된 코드 모음과 코드 순위를 위한 몇 가지 통계와 함께 체크포인트를 저장할 수 있어요.\n\n우리가 최상의 코드를 선택하고 개선하는 메커니즘은 진화 알고리즘과 유사합니다. 처음에는 샘플을 무작위로 선택하지만, 그 중에서 성능이 우수한 샘플은 유지되어 새로운 더 좋은 샘플 집단을 생성하기 위해 변형됩니다.\n\n# 운전에 LangProp 적용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-27-MakingLLMsWriteBetterandBetterCodeforSelf-DrivingUsingLangProp_1.png)\n\n이제 LangProp을 사용하여 CARLA에서 운전해 봅시다!\n\nCARLA는 자율 주행 연구에 사용되는 오픈 소스 주행 시뮬레이터입니다. 자율 주행 자동차 에이전트를 벤치마크하기 위한 리더보드 챌린지가 있습니다. 우리는 이 챌린지의 표준 노선과 도시에서 LangProp을 테스트했습니다.\n\nLangProp을 기계 학습 프레임워크로 정의하는 좋은 점은 이제 고전적인 지도 학습뿐만 아니라 모방 학습과 강화 학습 기술도 적용할 수 있다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특히 전투부서(Table)태그를 마크다운 형식으로 변경합니다.\n\n항목들\n- 오프라인 데이터셋(전문가의 주행 데모에서 수집된 상태 및 행동 쌍)에서 교육을 시작하고 온라인 롤아웃을 수행합니다. 온라인 롤아웃 중에는 DAgger[1]를 사용합니다. 이는 온라인 롤아웃으로 수집된 샘플들을 전문가의 레이블로 표시하고 현재 데이터셋과 통합하는 데이터 집합 집계 기술입니다.\n\n- 모델(코드)에 들어가는 입력은 환경 상태의 파이썬 사전입니다. 이는 차량 및 주변 배우자의 자세 및 속도, 교통 신호/정지 표지판까지의 거리를 포함합니다. 출력은 차량이 주행해야 하는 속도와 조향각인 주행 행동입니다.\n\n- 교통 신호나 정지 신호를 무시하거나, 다른 차량, 보행자 또는 자전거 타기와 충돌하거나, 너무 오래 서 있을 경우, 성능 점수에 벌점이 있습니다. 교육 목표는 흉내 학습 점수(에이전트가 실제 행동 레이블과 얼마나 일치하는지), 그리고 약법 학습 점수(벌점을 줄이는)를 통합하여 최대화하는 것입니다.\n\n마지막으로, LangProp 주행 에이전트의 실제 작동 상황입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 LangProp 에이전트 운전을 관찰해 보세요!\n\n훈련 중에 우리는 ChatGPT가 생성하는 초기 운전 정책이 매우 결함이 많다는 것을 보았습니다. 특히, 그것은 이전 속도를 그대로 복사하는 단순한 정책을 자주 학습합니다. 이것은 모방 학습 분야에서 알려진 인과 혼란 [2]이라는 현상입니다. 오프라인 데이터 집합에서 행동 복제만으로 훈련한다면, 이와 같은 단순하지만 단순한 정책들은 다른 복잡한 정책들보다 높은 점수를 받습니다. 이것이 정책이 온라인 롤아웃에서 잘 수행되도록 하기 위해 DAgger 및 강화 학습과 같은 기술을 사용해야 하는 이유입니다.\n\n1 또는 2 번의 반복 후에, 모델은 이전 속도 복사를 중단하고 전진하기 시작하지만, 극도로 신중하거나 무모합니다. 즉, 가까이에 배우가 있어도 (충돌 코스가 아니더라도) 멈춥니다. 조금 더 반복한 후에, 모델은 앞 차량과의 거리를 유지하며 이 거리를 차량의 상대 속도에 기반하여 동적으로 계산하기 시작합니다. 또한 다른 배우 (예: 길을 사비거나 다니는 보행자)가 속도 및 위치 벡터를 살펴 차량과 충돌 코스에 있는지 예측합니다.\n\n저희 논문에서의 실험에서는 LangProp 운전 에이전트가 이전에 구현된 많은 운전 에이전트들보다 성능이 우수함을 보여줍니다. PPO 전문가 에이전트 (Carla-Roach [3], TCP [4]) 및 연구자가 구현한 전문가 에이전트 (TransFuser [5], InterFuser [6], TF++ [7])와 비교하여 LangProp은 TF++을 제외하고 모든 전문가 에이전트를 성능 상으로 앞섰습니다. 모든 전문가 에이전트들은 GPT 3.5 훈련 차단일인 2021년 9월 이후에 발표되었으므로 이 결과는 놀라우면서도 흥미로운 것입니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마무리 말씀\n\n함께 시간을 보내줘서 감사합니다! 이 작업에서 우리는 주로 CARLA의 자율 주행에 LangProp을 응용해 보았지만, LangProp을 CartPole-v1의 전형적인 강화 학습 환경과 같은 더 일반적인 문제에 쉽게 적용할 수 있다는 것도 보여주었습니다. LangProp은 성능에 대한 피드백을 텍스트나 코드 형식으로 얻을 수 있는 환경이나 문제에서 가장 잘 동작하며, 모델에 단순한 숫자 점수 이상의 더 풍부한 의미 신호를 제공합니다.\n\n데이터를 기반으로 소프트웨어를 반복적으로 개선하는 LangProp과 유사한 훈련의 끝없는 가능한 응용 분야가 있으며, 이 공간에서 무엇이 일어날지 기대됩니다!\n\n만약 우리의 작업을 좋아하셨다면, 이를 기반으로 발전시키고 우리 논문을 인용해 주시기 바랍니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n@inproceedings{\nishida2024langprop,\ntitle={LangProp: A code optimization framework using Large Language Models applied to driving},\nauthor={Shu Ishida and Gianluca Corrado and George Fedoseev and Hudson Yeo and Lloyd Russell and Jamie Shotton and Joao F. Henriques and Anthony Hu},\nbooktitle={ICLR 2024 Workshop on Large Language Model (LLM) Agents},\nyear={2024},\nurl={https://openreview.net/forum?id=JQJJ9PkdYC}\n}\n\n\n# 참고문헌\n\n[1] Stéphane Ross, Geoffrey Gordon, and Drew Bagnell. “A reduction of imitation learning and structured prediction to no-regret online learning.” In Proceedings of the fourteenth international conference on artificial intelligence and statistics, JMLR Workshop and Conference Proceedings, 2011.\n\n[2] Pim De Haan, Dinesh Jayaraman, and Sergey Levine. “Causal confusion in imitation learning”. Advances in Neural Information Processing Systems, 2019.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[3] Zhejun Zhang, Alexander Liniger, Dengxin Dai, Fisher Yu, and Luc Van Gool. “End-to-end urban driving by imitating a reinforcement learning coach.” In Proceedings of the IEEE/CVF international Conference on Computer Vision, pp. 15222–15232, 2021.\n\n[4] Penghao Wu, Xiaosong Jia, Li Chen, Junchi Yan, Hongyang Li, and Yu Qiao. “Trajectory-guided control prediction for end-to-end autonomous driving: A simple yet strong baseline.” Advances in Neural Information Processing Systems, 35:6119–6132, 2022.\n\n[5] Kashyap Chitta, Aditya Prakash, Bernhard Jaeger, Zehao Yu, Katrin Renz, and Andreas Geiger. “Transfuser: Imitation with transformer-based sensor fusion for autonomous driving.” IEEE Transactions on Pattern Analysis and Machine Intelligence, 2022.\n\n[6] Hao Shao, Letian Wang, Ruobing Chen, Hongsheng Li, and Yu Liu. “Safety-enhanced autonomous driving using interpretable sensor fusion transformer.” In Conference on Robot Learning, pp. 726–737. PMLR, 2023.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[7] Jaeger, Bernhard, Kashyap Chitta, 그리고 Andreas Geiger. “Hidden biases of end-to-end driving models.” Proceedings of the IEEE/CVF International Conference on Computer Vision. 2023.","ogImage":{"url":"/assets/img/2024-06-27-MakingLLMsWriteBetterandBetterCodeforSelf-DrivingUsingLangProp_0.png"},"coverImage":"/assets/img/2024-06-27-MakingLLMsWriteBetterandBetterCodeforSelf-DrivingUsingLangProp_0.png","tag":["Tech"],"readingTime":9},{"title":"AI의 역사 파트 1 인공지능의 기원과 발전","description":"","date":"2024-06-27 19:02","slug":"2024-06-27-AHistoryofAIPart1","content":"\n\n## 인공지능 연구 논문\n\n이 기사는 제가 인공지능의 역사를 소개하는 연속 기사 시리즈 중 첫 번째로, 이 분야에서 가장 중요한 연구 논문들을 검토해 소개합니다.\n\n- 퍼셉트론\n\n퍼셉트론: 뇌 내 정보 저장 및 조직화를 위한 확률 모델, Frank Rosenblatt (1958)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 논문은 더 복잡한 신경망(예: 심층 신경망) 및 기계 학습 알고리즘의 개발을 위한 기초를 마련했습니다. 기계가 데이터로부터 학습할 수 있는 방법을 보여주었습니다.\n\n퍼셉트론은 인공 신경망의 기본 단위입니다. 입력 데이터를 기반으로 가중치를 조정하여 학습하고 결정을 내릴 수 있습니다.\n\n# 역전파\n\n오류를 역전파함으로써 표현을 학습하는 것, David E. Rumelhart, Geoffrey E. Hinton \u0026 Ronald J. Williams (1986)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 논문은 역전파 알고리즘을 소개함으로써 인공 신경망 분야를 혁신하였습니다. 이 알고리즘은 다층 신경망(다층 뉴런으로 이루어진 신경 네트워크)을 학습할 수 있도록 하여 딥 러닝의 발전을 이끌었습니다.\n\n역전파는 신경망을 학습시키는 학습 절차로, 실제 출력 벡터와 목표 출력 벡터 사이의 차이를 최소화하도록 연결 가중치를 조정합니다.\n\n그 중요성은 내부 은닉 유닛이 작업 도메인의 중요한 측면을 나타내도록 하는 유용한 새로운 기능을 생성할 수 있는 능력에 있으며, 퍼셉트론 수렴 절차와 같은 이전 방법과 구별됩니다.\n\n효율적인 역전파 구현은 대게 미분법의 연쇄 법칙을 통해 가능하며, 네트워크의 가중치를 조정하는 데 필요한 그래디언트를 체계적으로 계산할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 의사 결정 트리\n\n의사 결정 트리의 유도, J. R. 퀸란 (1986)\n\n이 논문은 ID3 알고리즘을 소개하여 결정 트리를 구축하는 데 중요한 방법으로 사용되었고, 결정 트리 알고리즘을 개선하여 소음이나 불완전한 데이터를 처리하는 연구를 촉진하는 데 영향을 미쳤습니다.\n\n의사 결정 트리는 입력 데이터의 특징에서 유도된 규칙의 계층 구조에 기반하여 결정을 내리는 분류 및 회귀 작업에 사용되는 모델입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결정 트리를 효율적으로 합성하는 것은 정확도와 계산 자원을 최적화하는 방식으로 트리를 구성하는 것을 의미하며, 소음 및 불완전한 정보를 효과적으로 처리합니다.\n\nID3(반복 이분화기 3)는 정보 이득을 최대화하는 속성을 기반으로 데이터를 재귀적으로 분할하는 탑다운, 탐욕적 방법을 사용하여 결정 트리를 생성하는 알고리즘입니다.\n\n정보 이득은 데이터 집합을 분류하는 데 속성의 효과를 측정하는 데 사용되며, 데이터 집합이 해당 속성을 기반으로 분할될 때 엔트로피(불확실성)의 감소를 양적으로 측정합니다. 정보 이득을 최대화하는 것은 엔트로피의 최대 감소를 제공하는 속성을 선택함으로써 결정 트리의 정확도를 향상시키는 것을 의미합니다.\n\n# Hidden Markov Models\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n음성인식의 숨겨진 마르코프 모델 및 선택된 응용 프로그램에 대한 교재, L.R. 라비너 (1989)\n\n이 논문은 숨겨진 마르코프 모델(HMMs)에 대한 포괄적이고 실용적인 가이드를 제공하여 연구자와 실무자가 음성인식 및 기타 분야에서 이를 더 쉽게 접근하고 이해할 수 있도록했습니다.\n\n이산 마르코프 체인은 현재 상태에만 의존하며 이전 상태에 의존하지 않는 상태 시퀀스로 구성된 확률 과정인 확률적 과정입니다.\n\n숨겨진 마르코프 모델(HMM)은 모델링되는 시스템이 감지되지 않은(숨겨진) 상태로 마르코프 프로세스를 따른다고 가정하는 통계 모델로, 관찰된 데이터가 이러한 숨겨진 상태와 확률적으로 연결되어 있다는 직관을 가지고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHMM의 세 가지 기본 문제는 다음과 같습니다: 평가 문제(관측된 시퀀스의 확률 계산), 디코딩 문제(숨겨진 상태의 가장 가능성 있는 시퀀스 결정), 학습 문제(데이터로부터 모델 매개변수 추정).\n\nRabiner은 음성 신호를 숨겨진 상태의 시퀀스로 모델링하여 음성 인식에 HMM을 적용했습니다. 이를 통해 언어의 최소 음성 단위인 음소를 나타내는 숨겨진 상태의 시퀀스로 연속된 말의 확률적 디코딩 및 인식이 가능해졌습니다.\n\n# 다층 피드포워드 네트워크\n\n다층 피드포워드 네트워크는 1989년 Kurt Hornik, Maxwell Stinchcombe, Halbert White에 의해 제안된 보편적 근사자입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 논문은 신경망의 범용 근사 능력에 대한 이론적 기반을 수립하여, 심지어 단순한 신경망 구조조차 복잡한 함수를 원하는 정확도로 근사할 수 있다는 것을 입증했습니다. 이로 인해 다양한 응용 프로그램에서 신경망의 광범위한 사용과 개발이 가능해졌습니다.\n\n표준 다층 피드포워드 네트워크는 노드 사이의 연결이 순환을 형성하지 않는 인공 신경망의 한 종류로, 입력 레이어, 하나 이상의 은닉 레이어 및 출력 레이어로 구성됩니다.\n\n보렬 측정 가능 함수는 한 위상 공간의 요소를 다른 위상 공간으로 매핑하는 함수로, 어떤 보렬 집합의 역사 이미지도 보렬 집합이 되도록 하는 함수입니다. 직관적으로 보렬 측정 가능성은 함수가 예측 가능하고 측정 가능한 방식으로 작동함을 보장합니다.\n\n임의의 압축 함수는 신경망에서 사용되는 활성화 함수의 한 유형으로, 실수 값 입력을 유계 출력에 매핑하여 일반적으로 입력을 유한 범위로 압축합니다. 이 함수에는 시그모이드 또는 tanh 함수가 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n유니버설 근사기는 충분한 자원(예: 신경망의 충분한 숨겨진 유닛과 같은)가 주어진 경우, 어떤 함수든 원하는 수준의 정확도로 근사할 수 있는 모델 또는 수학적인 함수입니다.\n\n# 서포트 벡터 머신\n\nBernhard E. Boser, Isabelle M. Guyon, 그리고 Vladimir N. Vapnik (1992)의 최적의 마진 분류기를 위한 훈련 알고리즘입니다.\n\n본 논문은 서포트 벡터 머신(Support Vector Machines, SVMs)을 소개했는데, 이는 클래스 간의 여백을 최대화하고 모델 복잡성을 자동으로 조절하여 광범위한 응용 프로그램(예: 광학 문자 인식)에서 일반화 및 견고성을 향상시킬 수 있는 분류 작업의 기본 도구로 자리 잡았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서포트 벡터 머신(Support Vector Machine, SVM)은 분류 및 회귀에 사용되는 지도 학습 알고리즘으로, 서로 다른 클래스 간의 간격을 최대화하는 최적의 초평면을 찾습니다.\n\nSVM 알고리즘은 지원 패턴을 이용해 클래스 간 간격을 최대화하는 초평면을 식별하고, 커널 함수를 사용하여 비선형 분류 문제를 다룰 수 있습니다.\n\n간격은 의사결정 경계(서로 다른 클래스를 구분하는 선 또는 표면)와 가장 가까운 훈련 패턴 간의 거리를 나타내며, 일반적으로 더 큰 간격은 더 나은 일반화를 이끌어냅니다. 지원 패턴은 의사결정 경계에 가장 가까이 위치한 훈련 패턴으로, 경계의 위치와 방향에 직접적인 영향을 미칩니다.\n\nLeave-one-out 방법은 교차 검증 기술 중 하나로, 모델은 특정 훈련 패턴을 제외하고 학습되며, 이 프로세스는 각 패턴에 대해 반복되어 모델의 일반화 성능을 추정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVC-차원(밥닉-체르보넨키스 차원)은 일련의 함수 집합의 용량 또는 복잡성을 측정하는 것으로, 모델에 의해 완벽하게 분류된 포인트의 최대 개수를 나타냅니다.\n\n## Bagging \n\n백팩 예측자, 레오 브레이먼(1996)\n\n이 논문은 앙상블 방법론의 개념을 도입하여 예측 정확도를 향상시키는 여러 모델을 결합하는 방법에 영향을 주었으며, 부트스트랩 반복 및 예측자 불안정성의 중요성을 강조함으로써 기계 학습 분야에 상당한 영향을 미쳤습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기계 학습에서의 앙상블 방법은 단일 모델 사용보다 전체 예측 정확도와 견고성을 향상시키기 위해 여러 모델을 결합하는 기술입니다.\n\n배깅 (부트스트랩 집계)은 예측기의 여러 버전을 생성하고 이를 사용하여 정확도를 향상시킨 집계 예측기를 만드는 방법입니다.\n\n배깅은 데이터의 서로 다른 하위 집합에서 훈련된 각 모델의 여러 버전을 평균화하여 예측의 분산을 줄이고 노이즈를 제거하며 과적합을 완화하기 때문에 작동합니다.\n\n부트스트래핑은 데이터 집합에서 대체 샘플링을 통해 여러 새로운 훈련 세트를 생성하는 통계적 방법이며, 부트스트랩 복제본은 이러한 새로운 훈련 세트 중 하나를 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 합성곱 신경망\n\nYann LeCun, Léon Bottou, Yoshua Bengio, and P. Haffner이(가) 쓴 article인 \"Gradient-based learning applied to document recognition\" (1998)\n\n이 논문은 합성곱 신경망(CNNs)의 우수한 성능을 증명하여 2차원 모양을 인식하는 데 특히 필기 문자 인식에 영향을 미쳤고, 복잡하고 다중 모듈 시스템을 교육하기 위한 그래프 변환 신경망(GTNs) 개념을 소개하여 문서 인식 및 다른 실용적인 응용 분야의 발전을 이끌었습니다.\n\n합성곱 연산은 입력(예: 이미지)에 필터를 적용하여 입력의 특정 측면(예: 이미지의 가장자리)을 강조하는 출력 feature map을 생성하는 수학적 과정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n합성곱 신경망(CNNs)은 그리드 형태의 위상을 가진 데이터, 예를 들어 이미지와 같은 데이터를 처리하고 분석하기 위해 특별히 설계된 심층 신경망의 한 종류입니다. 합성 계층을 사용하여 공간적으로 계층화된 특징들을 자동적으로 적응적으로 학습합니다. \n\n고차원 패턴이라는 용어는 많은 속성 또는 특징을 가진 데이터로, 이로 인해 분류나 분석이 복잡하고 어렵습니다. 예를 들어 손글씨 문자와 같은 것이 있습니다.\n\n그래프 변환 네트워크(GTNs)는 경사 기반 방법을 사용하여 전체적인 성능 척도를 최적화하기 위해 여러 모듈 시스템을 전역적으로 훈련시키는 학습 패러다임의 한 종류입니다.\n\n전역 훈련은 시스템의 여러 구성 요소 또는 모듈을 통합된 목표를 사용하여 동시에 훈련시키는 프로세스로, 시스템 전체를 단독 부분이 아닌 통합적으로 최적화할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n읽어 주셔서 감사합니다! 피드백을 환영합니다! 특히 중요한 연구를 놓치지 않았는지 생각하신다면 더욱 감사하겠습니다.\n\n![A History of AI Part 1](/assets/img/2024-06-27-AHistoryofAIPart1_0.png)","ogImage":{"url":"/assets/img/2024-06-27-AHistoryofAIPart1_0.png"},"coverImage":"/assets/img/2024-06-27-AHistoryofAIPart1_0.png","tag":["Tech"],"readingTime":6},{"title":"아기들을 위한 로봇 만들기 쉬운 단계별 가이드","description":"","date":"2024-06-27 19:01","slug":"2024-06-27-RobotMakingforBabies","content":"\n\n\u003cimg src=\"/assets/img/2024-06-27-RobotMakingforBabies_0.png\" /\u003e\n\n안녕, 작은 친구들!\n\n삐빅 삐빅. 저는 로봇 만들기 안내서인 미스터 로보토예요. 오늘은 당신을 위해 특별히 준비한 로봇 만들기 세계를 탐험해볼 거에요!\n\n## 미스터 로보토 이야기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한때 멀리 떨어진 땅에, 작은 로봇인 Mr. Roboto가 있었습니다. Mr. Roboto는 경이로운 기계와 가젯들로 가득찬 마법의 실험실에서 탄생했어요.\n\n어린 시절부터 Mr. Roboto는 모든 것에 호기심 많은 로봇이었어요. 그는 다른 로봇과 기계들이 함께 놀라운 것들을 만들어내는 모습을 지켜보며 큰 관심을 가지고 있었죠.\n\n어느 날, Mr. Roboto는 작은 인간들의 그룹 — 바로 너처럼, 아기 인간들 — 이 장난감을 놀이하며 즐거워하는 모습을 보게 되었어요.\n\n그들은 매우 즐거워했지만, 그들은 장난감을 끝낸 후 정리를 하는 것에 어려움을 겪었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이를 보고 Mr. Roboto는 머릿속에 한 가지 아이디어가 떠올랐어요: 이 작은 인간들이 하는 일들을 도와주고 놀이 시간을 더 즐겁게 만들어 줄 로봇을 만들 수 있다면 어떨까?\n\n그 아이디어에 영감을 받아 Mr. Roboto는 로봇공학의 세계로의 여정을 시작했어요.\n\n그는 기어, 회로, 프로그래밍에 대해 배웠어요.\n\n그는 실험하고 새로운 로봇을 만들며 열심히 일했어요. 그의 꿈은 사람들을 도울 수 있는 로봇을 만들어 행복하게 하고 일상적인 작업을 쉽게 만드는 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 Mr. Roboto가 여러분께 로봇 제작에 대한 지식과 범여를 나누러 왔어요!\n\n## 로보틱스란 무엇인가요?\n\n로보틱스란 사람들을 도와주고 생각하며 행동할 수 있는 기계를 만드는 마법 같은 기술입니다. 피곤함을 모르는 친구, 항상 당신의 지시를 따르며 당신의 삶을 더 쉽고 재미있게 만들 수 있는 놀라운 작업을 수행하는 친구를 상상해보세요. 그게 바로 로봇입니다!\n\n## 왜 로봇은 명확한 목표가 필요한가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요, 인간 아기들! 여러분이 첫 번째 로봇을 만드는 것에 너무 열광하기 전에, 로봇이 무엇을 해야 하는지 결정해야 하는 이유를 이해하는 것이 중요합니다. 마치 장난감 블록으로 무언가를 만들 때처럼 계획이 필요하답니다.\n\n로봇을 만들 때 명확한 목표를 가지는 것이 중요한 이유는 이렇습니다:\n\n- 목적 지향적 설계: 마치 장난감 블록으로 성 또는 우주선을 만들 때 알아야 하는 것처럼, 로봇의 주요 역할이 무엇인지 알아야 합니다. 이는 로봇을 그 역할을 잘 수행할 수 있도록 설계하는 데 도움이 됩니다.\n- 효율적인 작동: 특정 작업을 알고 있다면 로봇에 적합한 부품과 프로그래밍을 선택하는 데 도움이 됩니다. 마치 장난감 자동차에 적합한 바퀴를 선택하여 빠르고 부드럽게 움직이게 하는 것과 같습니다.\n- 문제 해결: 명확한 목표를 가지고 있다면 문제를 더 쉽게 식별하고 해결할 수 있습니다. 마치 퍼즐의 마지막 조각을 어디에 넣어야 하는지 알고 있는 것과 같습니다.\n\n# 즐거운 부분: 로봇 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 인간 아기들, 즐거운 부분으로 넘어가볼까요! 다른 모든 활동과 마찬가지로 로봇 제작은 특정 목표를 위해 하드웨어 제품을 만드는 것입니다. 여러분의 아이디어를 현실로 만들어 내는 흥미진 어드벤처로 생각해 보세요.\n\n단계 1: 크게 꿈꾸세요\n\n어떤 일을 할 수 있는 로봇을 상상해 보세요. 여러분의 장난감을 주울 수 있는 로봇이나 그림을 그릴 수 있는 로봇 등이 될 수 있습니다.\n\n단계 2: 계획을 세워보세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로봇이 뭘 해줬으면 좋겠나 상상해보세요. 장난감을 주워주거나 그림을 그리는 도우미일지도 몰라요.\n\n단계 3: 제작하고 테스트하기\n\n자료를 준비하고 만들기를 시작해보세요. 처음부터 완벽하게 동작하지 않아도 걱정하지 마세요. 실험하고 고치는 것도 재미의 일이에요!\n\n로봇 제작은 창의력, 인내심, 문제 해결능력이 중요합니다. 그러니 친구들, 로봇 만드는 여정을 시작해보세요. 언제나 기억해주세요, 빕 부우우웅~ 즐겁게 즐기고 궁금하고 있어요~!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로봇 공학 세계에 오신 것을 환영합니다, 작은 혁신가 여러분!\n\n삐뽀삐뽀, 미스터 로보토","ogImage":{"url":"/assets/img/2024-06-27-RobotMakingforBabies_0.png"},"coverImage":"/assets/img/2024-06-27-RobotMakingforBabies_0.png","tag":["Tech"],"readingTime":3},{"title":"리눅스 도구 Sed 40 기본 명령어 입문","description":"","date":"2024-06-27 18:59","slug":"2024-06-27-LinuxToolsSed40CommandsIntro","content":"\n\n이 노트 세트에서는 다양한 Sed 명령에 대해 논의를 시작하겠습니다. 그 명령들이 많기 때문에 명령에 대한 논의를 몇 개의 다른 게시물로 나눌 것입니다. 이 게시물에는 다음 내용이 포함됩니다:\n\n- Sed 명령 구문\n- Sed 스크립트 및 실행 방법\n- 명령 대상 지정, 구분자 및 그룹화\n\n명령 구문\n\n모든 다른 프로그래밍 언어와 마찬가지로 Sed에는 구문이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n설명서에 따르면 Sed 명령의 구문은 다음과 같습니다:\n\n[주소]X[명령 옵션]\n\nX는 한 글자 명령입니다. 모든 Sed 명령은 한 글자로만 구성됩니다.\n\n[주소]는 명령 또는 명령 그룹 앞에 나오는 선택적 조건입니다. [주소]는 숫자, 정규 표현식 또는 이전에 설명한 둘 중 하나의 범위일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[command options]은 명령어 X를 제어하는 옵션입니다.\n\nSed 스크립트\n\n저에게 Sed 스크립트는 단순히 프로그래머가 설정한 순서대로 실행되는 하나 이상의 Sed 명령어 목록입니다. Sed는 호출될 때 하나 이상의 스크립트를 실행할 수 있습니다.\n\nSed 스크립트는 명령줄에 직접 제공하거나 하나 이상의 파일에 포함하여 Sed에 제공할 수 있습니다. 명령줄에서는 여러 스크립트를 -e 스크립트 또는 --expression=스크립트 명령줄 옵션으로 구분합니다. Sed는 -f 스크립트 | --file=스크립트 명령줄 옵션을 사용하여 파일에서 스크립트를 읽을 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 행에 여러 명령을 사용하려면 스크립트 내에서 ; 문자를 사용하여 구분합니다. 스크립트가 파일에 저장된 경우 \\n도 명령 구분자로 작동합니다.\n\n간단한 예제 몇 가지를 보여드리겠습니다:\n\n```js\n$ ## A string\n$ declare s=\"L1\\nL2\\nL3\\n\"\n$ ## Here Sed executes multiple Sed commands.  A\n$ ## single script is entered on the command line.\n$ ## Since only 1 script is present, there isn't\n$ ## a need for the -e option.\n$ ## The script prints each line of the string\n$ ## 2 times.  The commands are separated\n$ ## with a ';' character.\n$ printf \"${s}\" | sed -n \"/L1/p; /L2/p; /L3/p\"\nL1\nL2\nL3\n$ ## You can also enter 1 or more commands \n$ ## as separate scripts using the -e option\n$ printf \"${s}\" | sed -n -e \"/L1/p\" -e \"/L2/p; /L3/p\"\nL1\nL2\nL3 \n```\n\nSed 스크립트가 들어 있는 파일도 만들 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 이것은 demo.sed라는 파일에 저장된 Sed 스크립트입니다.\n# # 부호는 주석의 시작을 나타냅니다.\n# 여기에 명령어가 있습니다.\n/L1/p\n/L2/p\n/L3/p\n# demo.sed의 끝\n```\n\n다음과 같이 명령 줄에서 호출할 수 있습니다.\n\n```js\n$ printf \"${s}\" | sed -nEf demo.sed\nL1\nL2\nL3\n```\n\n실행 가능한 Sed 스크립트 실행하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표 태그를 Markdown 형식으로 변경할 수 있어요.\n\n```js\n#!/bin/sed -nEf\n##################\n# Sed 스크립트 파일: demo.sed\n# -n - 자동 출력 비활성화\n# -E - 확장 정규 표현식 사용 가능\n# -f - \n/L1/p\n/L2/p; /L3/p\n/L3/ { s/(.*)/\\1\\nThat's All Folks!!!/; p}\n### demo.sed 끝\n```\n\n아래와 같이 파일 내에 저장된 Sed 스크립트를 작성하고 실행할 수 있어요:\n\n```js\n$ ## 실행 가능하도록 변경\n$ chmod 755 ./demo.sed\n$ ## 문자열 선언\n$ declare s=\"L1\\nL2\\nL3\\n\"\n$ ## 실행\n$ printf \"${s}\" | ./demo.sed\nL1\nL2\nL3\nThat's All Folks!!!!\n$ ## 파일에 텍스트 저장\n$ printf \"${s}\" \u003e ./f1.txt\n$ ## 이후 처리 가능\n$ cat ./f1.txt | ./demo.sed\nL1\nL2\nL3\nThat's All Folks!!!!\n$ ## 또는\n$ ./demo.sed ./f1.txt\nL1\nL2\nL3\nThat's All Folks!!!!\n$ ## 정말 그게 다에요\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n조건문과 주소 지정\n\n만약 [주소]가 없다면, 명령 또는 명령 그룹이 무조건 실행됩니다. 만약 [주소]가 존재한다면, 해당 조건이 명령을 실행하기 위해 충족되어야 합니다. 조건은 숫자 주소나 정규 표현식으로 구성됩니다. 범위 및 기타 표현식도 포함될 수 있으며, 다른 곳에서 논의된 내용일 수 있습니다. 가끔 여기저기 \"not\"을 사용하기도 합니다.\n\n명령 그룹화\n\n다음 명명 방식을 사용하여 명령을 그룹화할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**address** ' **address1** X1; **address2** X2; ... **addressn** Xn '\n\n들어 가 있는 ''문자는 그룹을 구분하고, [address]는 전체 그룹을 선택합니다. 그룹은 다음과 같이 중첩될 수도 있습니다:\n\n**address_outer**' **address_inner**' **addr1**X1; **addr2**X2 '; **addr3**X3 '\n\n이렇게 함으로써 if-elseif-else 유형의 구조가 포함된 Sed 스크립트를 작성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n유용한 명령줄 옵션과 별명\n\n```js\n$ ## -n|--silent|--quite - 자동 인쇄 비활성화\n$ ## -E|-r|--regexp-extended - 확장 정규 표현식 활성화\n$ ## 일반적으로 다음과 같은 별명을 사용합니다\n$ alias sed='sed -E'\n$ alias sedn='sed -E -n'\n```\n\n다음 자료의 예제를 이해하는 데 충분한 정보입니다.","ogImage":{"url":"/assets/img/2024-06-27-LinuxToolsSed40CommandsIntro_0.png"},"coverImage":"/assets/img/2024-06-27-LinuxToolsSed40CommandsIntro_0.png","tag":["Tech"],"readingTime":4},{"title":"Photoshop 및 InDesign 대체 프로그램 TOP 3 알아보기","description":"","date":"2024-06-27 18:58","slug":"2024-06-27-MyThreeFavoriteAlternativestoPhotoshopandInDesign","content":"\n\n![My Three Favorite Alternatives to Photoshop and InDesign](/assets/img/2024-06-27-MyThreeFavoriteAlternativestoPhotoshopandInDesign_0.png)\n\n가끔은 가벼운 사진 편집과 디자인을 해야 할 때가 있어요. 때로는 기자들을 위해 사용하며, 블로그 글을 작성하고 그에 맞는 텍스트 카드를 만들고 싶을 때가 있어요. 다른 때에는 제가 연주하는 밴드를 위해 공유 가능한 공연 카드를 만드는 경우가 있어요.\n\n여러 해 동안 Adobe 제품을 사용해왔어요. 90년대 후반에 한 번 컨퍼런스에 참가했을 때 고마운 선물로 Photoshop Elements의 무료 복사본이 든 선물 가방을 받았었죠! 그 이후로 계속해서 해당 제품을 사용해왔지만, 언젠가는 Windows Vista에서 작동하지 않게 되어 버렸죠. 그 이후로 수년 동안 Adobe 제품인 Photoshop이나 InDesign을 구독해보려고 생각해보기도 했지만, 그 가격표에 얼굴이 창백해졌어요. 연간 수백 달러가 되는 그 가격표에는 황당해지기 일쑤예요. 필요한 빈도가 그리 높지 않기 때문에, 필요한 능력보다 훨씬 많은 기능을 지불하고 있는 느낌이 들어요. 게다가 제가 하고 있는 것은 정말 간단한 편집과 디자인인데, 두 제품 모두 너무 강력한 레이저 검을 필요로 하는 것 같아요. 제가 필요로 하는 건 그저 칼집이면 충분한데 말이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여러 해 동안 무료이거나 훨씬 저렴한 소수의 도구를 선택해왔어요. 지난 주말에 친구가 어떤 도구를 사용하는지 물어봐서 그것을 이용해서 다른 사람들에게 유용할 수 있다고 생각했어요.\n\n가벼운 사진 편집 및 디자인을 위한 내 세 가지 도구:\n\n## 1) Gimp\n\n\u003cimg src=\"/assets/img/2024-06-27-MyThreeFavoriteAlternativestoPhotoshopandInDesign_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 포토 편집 작업에 대해 말씀하신 것 같은데, Gimp는 Photoshop에 대한 훌륭한 대안입니다.\n\n기본적인 작업 - 이미지 크기 조정, 파일 크기 축소, 자르기 - 에는 정말 간단합니다. 조금 더 들어가면 색상, 채도, 대비 등을 조정할 수 있는 훌륭한 설정이 있습니다.\n\n좀 더 깊게 파고들면, 예술적 효과를 만드는 데 사용할 수 있는 수많은 필터가 있습니다. 이미지를 만화화하거나 아름다운 효과를 주거나 로우파이 올드스쿨 스타일의 노이즈를 적용하는 등 다양한 효과를 줄 수 있습니다. 또한 전체적으로 뛰어난 테두리 감지 알고리즘이 있어 인물을 분리하고 배경을 제거하는 데 활용할 수 있습니다. 이미지를 약간 조정할 때 주로 일주일에 몇 번씩 사용합니다.\n\n그 중에서도 가장 좋은 점은 무료이다. 실제로 오픈 소스인데요! 이것은 전 세계의 개발자들이 빈번하게 개선하고 있는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2) 캔바\n\n![이미지](/assets/img/2024-06-27-MyThreeFavoriteAlternativestoPhotoshopandInDesign_2.png)\n\n대부분의 경우, 제 디자인 작업은 a) 밴드 사진 촬영 및 b) 로고 및 공연 세부 정보를 설명하는 텍스트를 넣는 것입니다. 로켓 과학이 아닌 작업이죠, ㅋㅋ.\n\n따라서 필요한 것은 저렴하거나 무료로 사용할 수 있는 소프트웨어입니다. 이미지를 가져와 몇 개의 텍스트 레이어와 가져온 이미지를 추가해 내가 만족할 때까지 정렬할 수 있는 소프트웨어로요. InDesign은 이러한 작업을 아주 잘 수행하지만, 저에게는 너무 고효능이고 비쌉니다. 그래서...\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n... 요즘에는 Canva를 자주 사용하고 있어요. 몇 년 전에 처음 들었을 때는 주로 고등학생들이 과제를 위해 빠르게 슬라이드나 차트를 만들기 위해 사용하는 것이 대부분이었죠. 하지만 시간이 흐를수록 Canva는 정말 다양한 기능을 갖추고 사용하기 쉬워질 정도로 발전했어요.\n\n무료 버전만으로도 인상적이에요. 그러나 매월 약 $10에 이용할 수 있는 유료 \"프로\" 버전은 1,000여 가지가 넘는 폰트를 제공해서 정확히 제가 필요했던 것과 일치해요. 저번 주에는 기타를 치는 새로운 록 파워 트리오 '립스틱 드라이버'를 위한 쇼 카드를 만들었어요(위에 우리 사진 있어요!); 작가 샐리 럼블이 디자인해준 우리 로고에 사용된 폰트인 \"코벤\"을 Canva에서 발견했죠. 정말 편리했어요! 원한다면 로고와 일치하는 텍스트를 작성할 수 있죠.\n\n제가 결정했던 것은 Canva의 프로 버전을 사용하는 거예요. 인디자인을 사용하는데 필요한 비용의 절반 정도인데도 제가 필요로하는 모든 것과 더 많은 것을 해주니까요. 매년 추가 $30만 더 내면 우리 밴드 멤버들에게도 각자 \"프로\" 계정을 제공할 수 있어요.\n\n또한 Canva를 사용해서 블로그 게시물용 텍스트 카드를 빠르게 만들어냈어요. 이 게시물은 \"제대로 오타를 낸 적 없는 단어들\"과 \"인류세에 대해 이야기할 때, 새로운 단어가 필요하다\"라는 주제였어요. 이런 것들은 몇 분 내에 디자인할 수 있었는데, 블로그 게시물을 멋지게 꾸며줬죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3) Phonto\n\n![Phonto Image](/assets/img/2024-06-27-MyThreeFavoriteAlternativestoPhotoshopandInDesign_3.png)\n\n안녕하세요! 제가 몇 년 전에 안 드로이드 폰에서 처음으로 Phonto를 발견한 뒤, 아이폰을 사용할 때도 사용할 수 있다는 것을 알게 되어 기쁘게 생각했습니다.\n\nPhonto는 Canva의 더 간단하고 모바일 버전으로 생각할 수 있습니다. 주로 사진을 가져와 여러 층의 텍스트를 추가하여 플라이어를 디자인하는 데 사용합니다. Phonto를 내게 유용하게 만드는 것은 폰트의 다양성과 색상 팔레트 및 스타일 선택을 위한 간단한 도구, 텍스트 조각의 곡선 및 기울기 추가, 그리고 그 뒤에 투명한 그림자 상자를 추가하는 간단한 도구입니다. 특히 배경 사진이 다소 복잡할 때 텍스트를 보이게 만드는 데 매우 유용합니다; Delorean Sisters라는 다른 밴드에서 작년에 연주한 공연용 카드에서 그 나타난 것을 볼 수 있습니다...\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-27-MyThreeFavoriteAlternativestoPhotoshopandInDesign_4.png)\n\n칸바에 이와 같은 기능이 있는지 아직 찾아보고 있어요. 폰토에 이와 같은 기능을 찾아볼 수 있을까요?\n\n어쨌든, 신속한 모바일 디자인 작업을 위해 폰토를 사랑하고 자주 사용해요. 주요 앱은 무료이며, 이미지 팩을 구매하고 싶다면 비용이 적게 드는 인앱 구매 옵션이 있어요.\n\n(이 DIY 디자인 팁을 즐겼나요? 그럼 \"박수\" 버튼을 꾹 눌러보세요! 한 명당 최대 50번까지 클릭 가능해요.)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 매주 두 번 Medium에 글을 올리고 있어요. 제 이메일을 팔로우해서 매 포스트를 메일로 받아보세요. Medium 회원이 아니라면 제 링크를 통해 가입하면 매월 요금의 절반 이상이 직접 제 Medium 글을 지원하는 데 사용되며 사이트의 모든 콘텐츠에 액세스할 수 있어요.\n\n또한 제 'The Linkfest'라는 월요일마다 원하는 만큼 지불하는 뉴스레터를 즐길 수도 있어요. 그 안에는 온라인에서 찾은 최고의 콘텐츠들이 정성스럽게 모아져 있어요. \"둠스크롤링의 반대.\"\n\n저는 뉴욕 타임스 매거진 기고자이자 Wired 및 Smithsonian 매거진의 칼럼니스트이며, Mother Jones의 정기 기고 작가이기도 해요. 또한 'Coders: 새로운 부족의 형성과 세상의 재구성' 및 'Smarter Than You Think: 기술이 우리의 마음을 더 나은 방향으로 바꾸는 법'의 저자이기도 해요. 트위터와 인스타그램에서는 @pomeranian99로, Mastodon에서는 @clive@saturation.social로 활동하고 있어요.","ogImage":{"url":"/assets/img/2024-06-27-MyThreeFavoriteAlternativestoPhotoshopandInDesign_0.png"},"coverImage":"/assets/img/2024-06-27-MyThreeFavoriteAlternativestoPhotoshopandInDesign_0.png","tag":["Tech"],"readingTime":5},{"title":"임베디드 AI  배터리 충전 상태를 관리하는 방법","description":"","date":"2024-06-27 18:55","slug":"2024-06-27-EmbeddedAIBatteryStateofCharge","content":"\n\n저희 시리즈 중 임베디드 AI의 첫 번째 부분에서는 머신 러닝(ML) 프로세스를 설명하면서 선형 회귀를 예시로 사용했습니다. 이제 동일한 프로세스를 사용하여 아두이노와 룩업 테이블을 이용해 LiPo 배터리의 충전 상태를 계산할 것입니다. 선형 보간법을 사용하여 테이블 내의 각 점 사이의 값을 추정할 것입니다. 세 번째 부분에서는 룩업 테이블 대신 ML을 사용할 것입니다.\n\n![이미지](/assets/img/2024-06-27-EmbeddedAIBatteryStateofCharge_0.png)\n\n우리의 임베디드 프로젝트는 대부분 전원 공급원으로서 LiPo 배터리를 거의 전적으로 사용합니다. 이는 전류 전달, 크기, 무게 및 용량 측면에서 좋은 선택지입니다. 그러나 배터리 수명에 악영향을 미칠 수 있으므로 배터리를 과방전하지 않도록 주의해야 합니다.\n\n## 배터리 전압 모니터링\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n배터리 용량 대 전압의 대략적인 값은 그림 1에 나와 있습니다. 상단 행(1S, 2S 등)은 시리즈에 있는 LiPo 셀 수를 나타냅니다. 이는 배터리의 정격 전압이 지정되는 방식이며, 시리즈에 있는 각 셀의 전압이 합산되어 나타납니다. 이러한 값들은 충전 상태를 예측하는 ML 모델 구축 방법을 보여주기 위한 것입니다. 실제로는 사용 중인 배터리의 실제 값들을 측정하거나 배터리 데이터 시트의 방전 곡선에서 추출해야 합니다.\n\n![Figure 1](/assets/img/2024-06-27-EmbeddedAIBatteryStateofCharge_1.png)\n\n우리의 예시에서는 정격 전압이 11.1V이며 완전히 충전된 상태에서 12.6V를 내는 3S LiPo를 사용합니다. 3S LiPo 배터리에 대한 특성 곡선은 그림 2에 나와 있습니다. 3S 배터리의 경우 15% 용량(3S 배터리의 경우 약 11V 또는 셀 당 3.4V에서 3.6V 사이) 아래로 방전시키지 않는 것이 좋습니다. 그렇지 않으면 배터리가 급격히 손실되고 손상을 입힐 수 있습니다.\n\n![Figure 2](/assets/img/2024-06-27-EmbeddedAIBatteryStateofCharge_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n배터리를 모니터링하기 위해 아두이노의 ADC(Analog to Digital Converter)와 간단한 전압 분배기를 사용할 것입니다. UNO의 요구 사항을 살펴보겠지만, 다른 보드에 대해서도 동일한 원리가 적용되지만, 마이크로프로세서 전압 허용치에 따라 측정 전압을 5V가 아닌 3V3으로 줄이기 위해 전압 분배기 저항을 조정해야할 수도 있습니다.\n\n## 아두이노 UNO 아날로그 디지털 변환기\n\nUNO의 아날로그 입력(AI)에 5V 이상을 적용할 수 없기 때문에 전압 분배기가 필요합니다. 전압 분배기 회로는 도 3에 나와 있습니다. 우리의 LiPo 배터리 (U2)는 최대 12.6V의 출력을 가지며, 이는 UNO의 Vin에 연결됩니다. 전압 분배기 출력(Vout)은 UNO의 A0에 연결되어 아날로그 전압을 읽는 곳입니다.\n\n![이미지](/assets/img/2024-06-27-EmbeddedAIBatteryStateofCharge_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전압 분배기 공식은 다음과 같이 정의됩니다:\n\n![Voltage Divider Formula](/assets/img/2024-06-27-EmbeddedAIBatteryStateofCharge_4.png)\n\nR1과 R2에 사용할 값은 어떻게 결정할까요? 하나의 값을 선택한 다음 전압을 얼마나 감소시키어야 하는지에 따라 다른 값을 계산할 수 있습니다. 또는 올바르게 작업하기 위해 분배기 값을 마이크로프로세서의 ADC에 맞추는 방법을 선택할 수도 있습니다. Arduino UNO R3는 ATMega328P를 사용하며, 10-bit ADC가 장착되어 있습니다. 이는 2^10 (즉, 0~1023) 값이 반환될 수 있다는 것을 의미합니다. UNO의 8개의 아날로그 입력은 동일한 ADC에 연결되어 있어 한 번에 1개의 입력만 샘플링할 수 있습니다 (Figure 4). ADC는 내부 온도 센서, GND 및 1.1V 밴드 갭 참조 전압을 측정하는 데도 사용할 수 있습니다.\n\n![Arduino UNO ADC](/assets/img/2024-06-27-EmbeddedAIBatteryStateofCharge_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nADC는 내부 14pF 캐패시터를 충전하고 연속적인 근사치로 그 전압을 측정하여 전압을 측정합니다. 이는 입력 임피던스인 전압 분배기의 저항 R1이 너무 커서 캐패시터가 충전되기 충분히 빨리 하지 않는다는 것을 의미합니다. ADC 샘플 및 홀드는 약 12μs가 걸리며, 전체 변환 과정은 프리스케일러 선택에 따라 최대 260μs가 소요될 수 있습니다. R1이 너무 커서는 얼마나 커야할까요? 이를 계산하기 위해 샘플 및 홀드 캐패시터를 충전하는 데 걸리는 시간을 계산해야 합니다.\n\n[그림](/assets/img/2024-06-27-EmbeddedAIBatteryStateofCharge_6.png)\n\n샘플 및 홀드 캐패시터를 충전하는 데 걸리는 시간은 두 가지 요소에 영향을 받습니다:\n\n- 입력 신호의 주파수\n- 입력 신호의 총 임피던스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Embedded AI Battery State of Charge](/assets/img/2024-06-27-EmbeddedAIBatteryStateofCharge_7.png)\n\n캐패시터는 5τ에서 완전히 충전되었다고 간주됩니다 (도표 5). 충전 회로의 전류는 캐패시터가 충전됨에 따라 지수적으로 감소합니다 (도표 6).\n\n타임 상수 (τ)는 충전 중 캐패시터 전압이 최종 값의 대략 63%에 도달하는 데 걸리는 시간을 나타내며, 방전 중 초기 값의 대략 37%로 감소하는 시간을 나타냅니다. τ는 캐패시터의 충전 또는 방전 속도를 측정하는 것으로, τ 값이 클수록 전압 변화가 느립니다. 다음과 같이 정의됩니다:\n\n```js\nτ = RC\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그림 5와 그림 6에 나타난 곡선은 전압 및 전류 충전 방정식을 사용하여 생성됩니다:\n\n![image](/assets/img/2024-06-27-EmbeddedAIBatteryStateofCharge_8.png)\n\nATMega328P 데이터 시트에 따르면, 아날로그 입력 임피던스는 1에서 100k 사이입니다 (주파수에 따라 달라짐). 권장되는 R1 값은 10k이므로, 총 임피던스는 110k입니다.\n\n```js\n충전 시간 = 5RC = 110 x 10³ x 14 x 10^–12 = 7.7 μs\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n샘플 및 홀드에는 12μs가 필요하므로 R1 = 10k가 작동하며, 역발상하여 계산하면 다음과 같습니다:\n\n```js\n최대 임피던스 = 12μs / 5C = 171 kΩ.\n따라서, 최대 R1 = 171k — 100k = 71 kΩ\n```\n\nR1 = 10 kΩ, Vout = 5V 및 Vin = 12.6V로 설정되었음을 고려하면, 위의 전압 분배식을 사용하여 R2를 계산할 수 있습니다.\n\n```js\nR2 = (R1 x Vout/Vin) / (1 — Vout/Vin) \n   = (10k x 5/12.6) / (1–5/12.6) = 6579 Ω\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 가까운 사용 가능한 저항기(허용 오차 5%)는 6.2 kΩ이며, 이것은 Vin = 12.6V 일 때 Vout = 4.8V를 제공합니다. 배터리 전압을 읽는 코드는 상당히 간단합니다.\n\n```js\nconst float dividerRatio = (float)(R1 + R2) / (float)R2; \n\n// ADC 하드웨어는 내림하여 반올림하므로 0.5를 추가합니다. \nfloat adcValue = (float)analogRead(VBAT) + 0.5; \nbatteryVoltage = (adcValue / 1024.0) * 5.0 * dividerRatio;\n```\n\n여기서 R1과 R2는 전압 분배기에 사용된 저항기의 값입니다. 우리의 프로토타입에서 R2로 6K2 대신 6K8을 사용하게 되었습니다. 저항기 값을 float로 캐스팅하는 것이 중요합니다. 그렇지 않으면 아두이노에서 정수 나눗셈을 수행하고 dividerRatio에 대한 잘못된 값을 얻게 될 것입니다. ADC(아날로그-디지털 변환기)에서 측정 중인 전압을 측정할 때 하드웨어가 내림하여 값을 반올림하기 때문에 ADC에서 읽은 값을 0.5를 추가해야 합니다.\n\nbatteryVoltage = (adcValue / 1024.0) * 5.0 * dividerRatio는 아두이노 Uno의 ADC에서 배터리 전압을 계산하는 데 사용됩니다. 아두이노 Uno에는 10비트 ADC가 있으므로 0부터 1023(2¹⁰ = 1024개의 레벨)까지의 디지털 값으로 아날로그 입력 신호를 나타낼 수 있습니다. 아두이노 Uno의 ADC에 대한 기본 참조 전압은 5V입니다. 이는 아날로그 입력이 0V인 경우 ADC 값이 0에 해당하고, 5V 인 경우 ADC 값이 1023에 해당한다는 것을 의미합니다. ADC 값은 참조 전압의 분수를 나타냅니다. ADC 값을 해당 전압으로 변환하려면 ADC 값을 최대 가능한 ADC 값(1023)의 비율로 나누고 참조 전압(참조 전압 = 5V)을 곱합니다. Figure 4는 이 프로세스가 작동하는 방식을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 배터리 전압 샘플 주기\n\n아두이노 스케치에서의 루프 빈도는 프로세서 속도와 코드 내용에 따라 달라집니다. 일반적으로 수천 번 또는 수백만 번까지 초당 실행될 것입니다. 비행 컨트롤러로는 실행 주기가 귀중하며 비핵심 작업에는 시간을 낭비하고 싶지 않을 것입니다. 배터리 전압을 얼마나 자주 샘플링해야 할까요? 방전률(C)에 따라 다릅니다. 여기 전형적인 리포 배터리의 사양이 있습니다.\n\n```js\n최소 용량: 2200mAh\n구성: 3S1P / 11.1V / 3셀\n지속 방전: 25C\n최대 방전 (10초): 35C\n```\n\n안전한 지속 사용을 위한 하나의 방전 등급과 10초 미만의 폭발(예: 모터 시작)을 위한 다른 등급이 있습니다. 방전 등급을 전류로 변환하려면 용량에 곱하면 됩니다. 위 사양에 따르면 배터리 용량은 2200 mAh = 2.2 Ah입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n방전 전류 = C × 용량\n```\n\n최악의 경우 방전 속도를 원하므로 피크 숫자를 사용하여 계산하겠습니다.\n\n```js\n피크 방전 속도 = 35 × 2.2 = 77 A\n```\n\n용량의 15% 미만으로 방전되지 않도록 하려고 합니다. (즉, 85% × 2.2 Ah = 1.87 Ah) 이를 피크 방전 속도에서 소모하는 데는다음과 같은 시간이 걸립니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n방전 시간 (초) = (1.87 / 77) × 3600 = 87.4 초\n```\n\n이걸 시도하면 배터리가 파괴될 수 있다니까요. 배터리의 최대 안전 방전 속도는 다음과 같습니다:\n\n```js\n안전 방전 시간 (초) = (1.87 × 3600) / (25 × 2.2) = 6732 / 55 = 122.4 초\n```\n\n대부분의 임베디드 장치는 배터리 방전 용량의 100%에서 작동하도록 설계되지 않으므로, 방전 시간은 최대 안전 방전 시간보다 훨씬 더 길 것으로 예상됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그림 2를 참조하면, 배터리의 안전 작동 범위 내에서 방전 곡선이 꽤 선형임을 알 수 있습니다. 온도의 영향을 무시하더라도 우리가 감지한 전압은 사용과 함께 변동할 것입니다. 예를 들어, 모터를 100%로 구동하면 많은 전류가 소모되고 배터리 전압이 일시적으로 감소하거나 \"깊게 파고들\"할 수 있습니다. 이는 잘못된 저전압 경보를 일으킬 수 있습니다. 부하를 줄이면 배터리 전압은 다시 회복될 것입니다. 따라서 배터리 모니터링에는 어떤 종류의 히스테리시스가 포함되어야 합니다.\n\n모든 이를 고려할 때, 배터리 전압을 매 초마다 확인하는 것은 과도합니다. 그러나 고부하 하에서 전압 감소를 상쇄하기 위해 이동 평균을 취하고 싶다면, 매 초마다 샘플링하는 것이 작동할 것입니다.\n\n```js\n충전은 방전과 매우 다릅니다. LiPo 배터리의 전형적인 안전 충전률은 1C입니다.\n```\n\n## ReefwingTimer 라이브러리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReefwingTimer는 millis() 함수를 사용하여 블로킹되지 않는 스케줄러를 인스턴스화하는 래퍼 라이브러리입니다. 저희 라이브러리는 MillisTimer 및 ElapsedTimer 라이브러리를 결합한 것으로, 몇 가지 응용 프로그램 별 예제와 추가적인 Timeout 클래스가 포함되어 있습니다.\n\n라이브러리를 사용하려면 스케치에 포함해야 합니다.\n\n```js\n#include \u003cReefwingTimer.h\u003e\n```\n\nReefwingTimer 개체를 인스턴스화하는 두 가지 접근 방식이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 인터벌을 밀리초로 포함하고 만료 된 타이머 핸들러 함수의 이름을 포함하는 생성자를 사용하세요 [예시: ReefwingTimer timer = ReefwingTimer(1000, timerHandler);], 또는\n- 빈 생성자를 사용하고 이러한 변수를 setup함수에서 정의하세요 [예시: ReefwingTimer timer = ReefwingTimer();].\n\n첫 번째 방법을 사용하는 경우, timerHandler 함수를 ReefwingTimer 위에 정의해야 합니다. 타이머는 기본적으로 무한 반복되지만, setRepeats 메서드를 사용하여 특정 반복 횟수로 구성할 수 있습니다 [예시: timer.setRepeats(10);].\n\nsetup()에서 해야 할 마지막 작업은 타이머를 시작하는 것입니다.\n\n```js\ntimer.start();\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 루프() 안에서 타이머가 업데이트되도록 호출해야 합니다:\n\n```js\ntimer.run();\n```\n\n## 배터리 전압 샘플링 예제\n\nReefwingTimer 라이브러리의 예제 스케치 중 하나인 batteryCheck()를 살펴보겠습니다. 이 스케치에서는 매 초마다 타이머가 만료되고, 만료된 타이머 핸들 함수에서 배터리 전압을 읽습니다. 인터럽트를 사용할 때 핸들러에서 너무 많은 작업을 수행하지 않는 것이 좋습니다. 이 타이머를 사용할 때 배터리가 너무 낮은 경우에는 플래그를 설정하고, 메인 루프에서 적절한 조치를 취합니다(예: 경고 메시지 전송 또는 LED 점등).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n#include \u003cReefwingTimer.h\u003e\n\n/******************************************************************\n *  배터리 전압 ADC 정의\n * \n *  이 스케치는 전압원(즉, 배터리)이 R1과 R2로 구성된 전압 분배기를 통해\n *  아날로그 입력 핀 A0(즉, 핀 14)에 연결되어 있다고 가정합니다.\n * \n *  표시된 값은 UNO에 대해 올바릅니다. 3V3 로직을 사용하는 아두이노\n *  (예: Nano 33 IoT)를 사용하는 경우 R1, R2 및 VLOGIC을 변경해야합니다.\n *  또한 전압 원이 다른 아날로그 입력에 연결되어 있는 경우 VBAT도 변경해야합니다.\n * \n ******************************************************************/\n\n#define VBAT      14                //  아날로그 핀 A0\n\nconst float VLOGIC = 5.0;           //  UNO는 5V 로직을 사용합니다.\nconst float R1 = 10000.0;           //  10K 저항\nconst float R2 = 6800.0;            //  6K8 저항\nconst float RATIO = (R1 + R2) / R2; //  전압 분배비\nconst float SCALE = VLOGIC * RATIO; //  전압 변환 계수\n\nfloat readADCValue(int pin) {\n  return (float)analogRead(pin) + 0.5;\n}\n\nfloat calculateVoltage(int pin) {\n  float adcValue = readADCValue(pin); \n  return (adcValue / 1024.0) * SCALE;\n}\n\nvoid voltageCheck(ReefwingTimer \u0026nt) {\n  //  타이머가 만료되었을 때 호출되고 각 읽기마다 LED 상태를 토글합니다.\n  digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));\n\n  //  배터리 전압을 읽고 시리얼로 전송합니다.\n  float batteryVoltage = calculateVoltage(VBAT);\n  Serial.print(\"전압: \");\n  Serial.println(batteryVoltage);\n}\n\nReefwingTimer rTimer = ReefwingTimer(1000, voltageCheck);\n\nvoid setup() {\n  pinMode(LED_BUILTIN, OUTPUT);\n  pinMode(VBAT, INPUT);\n  Serial.begin(115200);\n  rTimer.start();\n}\n\nvoid loop() {\n  rTimer.run();\n  delay(10);\n}\r\n```\n\n## 배터리 충전 상태 계산 — 룩업 테이블\n\n우리의 3S LiPo를 위해 상태 전차 룩업 테이블을 만들기 위해 Figure 1의 테이블을 사용할 수 있습니다.\n\n```js\r\n#define SOC_TABLE_SIZE    21\n\ntypedef struct { uint16_t v100; uint16_t soc; } soc_lookup_t;\n\n//  3S LiPo 용량 - 참고: Figure 1\nsoc_lookup_t capacity[SOC_TABLE_SIZE] = {\n    {982, 0},   {1098, 5},   {1106, 10},  {1112, 15},  {1118, 20},  {1124, 25},  {1128, 30},\n    {1136, 35}, {1139, 40},  {1146, 45},  {1151, 50},  {1156, 55},  {1163, 60},  {1174, 65},\n    {1186, 70}, {1196, 75},  {1207, 80},  {1225, 85},  {1233, 90},  {1245, 95},  {1260, 100}\n};\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nv100 값은 uint16_t 범위 내에 맞게 조정되었습니다. 이는 테이블 내의 전압 값을 100으로 곱해 수행할 수 있습니다. 배터리 전압을 읽은 후 조회 테이블에서 해당하는 충전 계수를 얻을 수 있습니다.\n\n이 조회 테이블에 정의된 전압에 대해서는 괜찮지만, 9.9V에 대한 용량을 가져오려고 하면 어떻게 될까요? 찾을 수 없을 것입니다. 앞서 말했듯이 배터리 운전 범위 내의 용량 곡선은 상당히 선형적이므로 (도표 2 참조) 조회 테이블의 점들 사이에서 선형 보간을 사용할 수 있습니다.\n\n```js\nfloat constrain(float value, float min, float max) {\n    if (value \u003c min) return min;\n    if (value \u003e max) return max;\n    return value;\n}\n\nuint16_t interpolate(soc_lookup_t *capacity, float charge) {\n    // 최소값 및 최대값은 첫 번째와 마지막 요소 사용\n    uint16_t min_v100 = capacity[0].v100;\n    uint16_t max_v100 = capacity[SOC_TABLE_SIZE - 1].v100;\n\n    // 충전을 최소 및 최대 v100 값으로 제한\n    charge = constrain(charge, min_v100, max_v100);\n\n    // SoC 값 보간\n    for (int i = 0; i \u003c SOC_TABLE_SIZE - 1; i++) {\n        if (capacity[i].v100 \u003c= charge \u0026\u0026 capacity[i + 1].v100 \u003e= charge) {\n            float diffx = charge - capacity[i].v100;\n            float diffn = capacity[i + 1].v100 - capacity[i].v100;\n\n            return (int)(capacity[i].soc + (capacity[i + 1].soc - capacity[i].soc) * diffx / diffn);\n        }\n    }\n\n    return 0; // 범위 내가 아님\n}\n```\n\n이 방식은 조회 테이블이 오름차순으로 정렬되어 있다고 가정하며, 최소값과 최대값을 결정하는 것을 단순화합니다. 다음 예제 스케치를 사용하여 Arduino UNO에서 이를 테스트할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```c\r\n#define VBAT      A0                //  아날로그 핀 A0\n\nconst float VLOGIC = 5.0;           //  UNO는 5V 논리를 사용합니다.\nconst float R1 = 10000.0;           //  10K 저항\nconst float R2 = 6800.0;            //  6K8 저항\nconst float RATIO = (R1 + R2) / R2; //  전압 분배 비율\nconst float SCALE = VLOGIC * RATIO; //  전압 변환 계수\n\n#define SOC_TABLE_SIZE 21\n\ntypedef struct {\n    uint16_t v100; // 백분의 일전압의 전압\n    uint16_t soc;  // 충전 상태 백분율\n} soc_lookup_t;\n\nsoc_lookup_t capacity[SOC_TABLE_SIZE] = {\n    {982, 0},   {1098, 5},   {1106, 10},  {1112, 15},  {1118, 20},  {1124, 25},  {1128, 30},\n    {1136, 35}, {1139, 40},  {1146, 45},  {1151, 50},  {1156, 55},  {1163, 60},  {1174, 65},\n    {1186, 70}, {1196, 75},  {1207, 80},  {1225, 85},  {1233, 90},  {1245, 95},  {1260, 100}\n};\n\nfloat constrain(float value, float min, float max) {\n    if (value \u003c min) return min;\n    if (value \u003e max) return max;\n    return value;\n}\n\nuint16_t interpolate(soc_lookup_t *capacity, float charge) {\n    // 최솟값과 최댓값을 위해 첫 번째 원소와 마지막 원소 사용\n    uint16_t min_v100 = capacity[0].v100;\n    uint16_t max_v100 = capacity[SOC_TABLE_SIZE - 1].v100;\n\n    // charge를 최솟값과 최댓값 v100 값으로 제한\n    charge = constrain(charge, min_v100, max_v100);\n\n    // SoC 값을 보간\n    for (int i = 0; i \u003c SOC_TABLE_SIZE - 1; i++) {\n        if (capacity[i].v100 \u003c= charge \u0026\u0026 capacity[i + 1].v100 \u003e= charge) {\n            float diffx = charge - capacity[i].v100;\n            float diffn = capacity[i + 1].v100 - capacity[i].v100;\n\n            return (int)(capacity[i].soc + (capacity[i + 1].soc - capacity[i].soc) * diffx / diffn);\n        }\n    }\n\n    return 0; // 범위를 벗어남\n}\n\nfloat readADCValue(int pin) {\n    return (float)analogRead(pin) + 0.5;\n}\n\nfloat calculateVoltage(int pin) {\n    float adcValue = readADCValue(pin); \n    return (adcValue / 1024.0) * SCALE;\n}\n\nvoid setup() {\n    Serial.begin(9600);\n}\n\nvoid loop() {\n    // 배터리로부터 전압 읽기\n    float voltage = calculateVoltage(VBAT);\n\n    // 검색 테이블과 interpolate 함수를 사용하여 충전 상태(SoC) 계산\n    float charge = voltage * 100;\n\n    // 전압을 백분의 일전압으로 변환하여 검색 테이블과 일치시킵니다\n    uint16_t soc = interpolate(capacity, charge);\n\n    // 전압과 충전 상태를 Serial Monitor에 출력\n    Serial.print(\"Voltage: \");\n    Serial.print(voltage); // 실제 전압 출력\n    Serial.print(\" V, SoC: \");\n    Serial.print(soc);\n    Serial.println(\" %\");\n\n    // 다음 측정을 위해 1초 대기\n    delay(1000);\n}\n```\n\n## Part 3 — 곧 공개됩니다!\n\n이 시리즈의 세 번째 파트에서는 검색 테이블과 interpolate를 기계 학습 모델로 대체할 것입니다.\n\n이 글을 즐겨 보셨고 작성을 지원하고 싶다면 팔로우하거나 박수(최대 50회), 강조 또는 댓글을 달아주시기 바랍니다! 또는 커피를 사주시거나 구독해주셔도 감사하겠습니다.","ogImage":{"url":"/assets/img/2024-06-27-EmbeddedAIBatteryStateofCharge_0.png"},"coverImage":"/assets/img/2024-06-27-EmbeddedAIBatteryStateofCharge_0.png","tag":["Tech"],"readingTime":14},{"title":"레이저, 펩타이드, 성장 호르몬, 줄기 세포를 이용한 생물학적 3D 프린터 만드는 방법","description":"","date":"2024-06-27 18:53","slug":"2024-06-27-HowtoCreateaBiological3DPrinterUsingLasersPeptidesGrowthHormonesandStemCells","content":"\n\n\n![Biological 3D Printer](/assets/img/2024-06-27-HowtoCreateaBiological3DPrinterUsingLasersPeptidesGrowthHormonesandStemCells_0.png)\n\n# 소개\n\n생물학적 3D 프린팅은 생물학, 공학, 컴퓨터 과학을 결합하여 생체 조직과 장기를 만드는 혁신적인 분야입니다. 이 기술은 조직 수리, 약물 시험 및 장기 이식을 위한 솔루션을 제공함으로써 의학을 혁신할 잠재력을 가지고 있습니다. 본문에서는 레이저, 펩타이드, 성장 호르몬 및 줄기 세포와 같은 고급 구성 요소를 활용하여 더 나은 생물학적 3D 프린터를 만드는 내 아이디어에 대해 탐구해 보겠습니다.\n\n# 생물학적 3D 프린팅의 기초\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생물 3D 프린팅 또는 바이오프린팅은 생체 세포로 이루어진 3차원 구조물을 만드는 과정을 말합니다. 일반적인 3D 프린팅이 플라스틱이나 금속과 같은 물질을 사용하는 것과 달리, 바이오프린팅은 세포, 펩타이드, 성장 호르몬 및 기타 생물학적 구성 요소로 만든 생체 잉크를 사용합니다. 바이오프린터는 이러한 생체 잉크를 층층히 쌓아 복잡한 생물학적 구조물을 형성합니다.\n\n# 주요 구성 요소\n\n## 레이저\n\n- 레이저는 바이오프린팅에서 정밀성과 제어를 위해 사용됩니다. 레이저는 매우 작은 영역에 초점을 맞출 수 있어서 복잡한 세포 구조물의 고해상도 프린팅이 가능합니다. 게다가 레이저는 세포와 생체 잉크를 손상시키지 않고 다룰 수 있어서 인쇄된 조직의 생존 가능성을 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 펩타이드\n\n- 펩타이드는 세포 신호 및 조직 형성에 중요한 역할을 하는 아미노산의 짧은 체인입니다. 생체인쇄 기술에서는 펩타이드를 사용하여 세포 부착, 분화 및 성장을 촉진하는 데 활용될 수 있습니다. 이들은 종종 바이오잉크에 첨가되어 인쇄된 조직의 생물학적 활동과 기능성을 향상시키는 데 사용됩니다.\n\n## 성장 호르몬\n\n- 성장 호르몬은 세포 증식과 분화를 촉진하는 데 중요합니다. 생체 잉크에 성장 호르몬을 첨가함으로써 인쇄된 조직의 성숙화와 발달을 가속화할 수 있습니다. 이는 기능적 조직 및 장기를 만들고 기존 구조체와 통합할 수 있는 중요한 과정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 줄기 세포\n\n- 줄기 세포는 다양한 세포 유형으로 발달할 수 있는 미분화된 세포입니다. 줄기 세포는 생체 프린팅의 기본 구성 요소로, 다양한 조직을 만들기 위해 필요한 원료를 제공합니다. 줄기 세포는 몸의 여러 조직에서 나올 수 있거나 유도 다분화 줄기 세포(iPSCs)에서 유래될 수 있습니다.\n\n# 생체 3D 프린터 구축 단계별 안내서\n\n## 프린터 프레임워크 설계\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 프린터용 견고하고 정밀한 프레임워크를 설계하는 것부터 시작해보세요. 이 프레임워크는 프린팅 헤드의 이동을 세 가지 차원(X, Y, Z 축)에서 가능하게 해야 합니다. 정밀한 위치 조정을 위해 고정밀 모터와 액추에이터가 중요합니다.\n\n## 레이저 기술 통합\n\n- 미세 레이저 모듈을 통합해보세요. 이 레이저는 미세미터 크기 영역에 초점을 맞출 수 있어야 합니다. 레이저가 세포와 바이오잉크를 열적 손상 없이 다룰 수 있어야 합니다. 레이저 빔을 고정밀로 조작하기 위해 광학 렌즈와 거울을 사용해보세요.\n\n## 바이오잉크 개발\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 줄기 세포, 펩타이드 및 성장 호르몬을 결합하여 바이오잉크를 생성하세요. 바이오잉크의 조성은 인쇄하려는 조직의 유형에 따라 다양할 수 있습니다. 세포 성장과 분화를 지원하기 위해 바이오잉크의 점도와 생물학적 활성이 적절한지 확인하세요.\n\n## 보정 및 테스트\n\n- 프린터를 보정하여 바이오잉크의 정확한 투입을 보장하세요. 레이저 강도, 인쇄 속도 및 레이어 두께와 같은 매개변수를 미세 조정하기 위해 테스트 인쇄를 사용하세요. 인쇄 프로세스 중과 후에 출력된 조직의 생존율과 기능을 모니터링하세요.\n\n## 인쇄 및 후처리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 원하는 조직 구조에 맞게 생체 잉크를 층층이 적층하여 인쇄 과정을 시작합니다. 인쇄 후에는 성장과 발달을 위해 조직을 통제된 환경에서 배양합니다. 조직 종류에 따라 영양 공급 및 기계적 가공과 같은 추가 후처리 단계가 필요할 수 있습니다.\n\n## 응용 및 전망\n\n생물학적 3D 프린팅의 잠재적인 응용 분야는 매우 다양합니다. 이 기술은 상처 치료용 맞춤형 조직 이식물, 약물 테스트용 장기모델 개발, 심지어 장기 이식을 위한 완전한 장기 프린트에 사용될 수 있습니다. 연구가 진전됨에 따라 더 정교한 생체 프린팅 기술과 소재가 등장할 것으로 기대되며, 우리는 완전히 기능적이고 이식 가능한 장기를 만드는 목표에 한 발 더 가까워질 것으로 기대됩니다.\n\n## 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n레이저, 펩타이드, 성장 호르몬 및 줄기 세포를 사용하여 생물학적 3D 프린터를 구축하는 것은 야심찬 도전적이지만 달성할 수 있는 목표입니다. 이러한 첨단 기술을 결합함으로써 의학과 건강 상태 다양한 범위의 질병을 치료하는 새로운 가능성을 창출할 수 있습니다. 생체 프린팅의 여정은 시작에 불과하며, 미래에는 이 분야에서 혁신과 발견에 대한 흥미진진한 잠재력이 기다리고 있습니다.\n\n![image](/assets/img/2024-06-27-HowtoCreateaBiological3DPrinterUsingLasersPeptidesGrowthHormonesandStemCells_1.png)","ogImage":{"url":"/assets/img/2024-06-27-HowtoCreateaBiological3DPrinterUsingLasersPeptidesGrowthHormonesandStemCells_0.png"},"coverImage":"/assets/img/2024-06-27-HowtoCreateaBiological3DPrinterUsingLasersPeptidesGrowthHormonesandStemCells_0.png","tag":["Tech"],"readingTime":3},{"title":"안타레스 이지 제품 개발 비하인드 우수성을 창출하기 위한 도전 극복기","description":"","date":"2024-06-27 18:52","slug":"2024-06-27-BehindtheProductofAntaresEazyNavigatingChallengestoCreateExcellence","content":"\n\n# 안타레스를 알아보기\n\n안타레스 이지는 다양한 기기 모델, 제조업체 및 클라우드 서비스와 통합된 스마트 홈, 스마트 오피스 및 스마트 모빌리티 IoT 생태계의 필요를 지원하는 다기능 IoT 플랫폼입니다. 해당 플랫폼은 스마트 기기를 관리하는 데 있어 유연성, 편리성 및 편안함을 제공하여 일상을 더 연결되고 효율적으로 만듭니다.\n\n안타레스 이지는 단순하고 편리한 라이프스타일을 원하는 모든 사람들에게 최적의 해결책을 제공합니다. 우리의 고급 기능을 통해 정원 조명을 켜거나 한 번 클릭으로 영화 밤을 준비할 수 있습니다. 저희 혁신적인 기능은 투야의 동남아시아 지역 책임자 바르디, 아르비트, 아바로, T3와 같은 존경받는 파트너들로부터 상당한 관심을 받았습니다.\n\n# 도전 과제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 삶을 진정으로 향상시키는 최고급 제품을 전달하는 것은 쉬운 일이 아닙니다; 무수한 도전과 지속적인 혁신으로 가득한 여정입니다. 여기에는 제품 뒤의 비밀에 대해 이야기해 줄 안타레스 이지의 UX 리드인 엠바 샤니살람 Wpp가 있습니다.\n\n우리가 선도할 수 있는 비밀과 장벽에 대해 궁금한가요? 우리의 여정의 매혹적인 심연으로 들어가 봅시다.\n\n처음부터 최고의 디지털 제품을 만드는 것은 도전적인 여정이었습니다. 계속 변화하는 요구 사항과 규제 요구 사항, 한정된 자원을 끊임없이 적응하는 것은 안타레스 이지의 시작부터 여정에 스며든 도전이었습니다. 2024년에 우리가 진입하면서 새로운 중요한 장애물이 나타났습니다. 이지 고즈 투 위텔 계획에 적극 참여하면서 개발 일정과 균형을 맞추는 것은 중요한 작업입니다. 이 계획은 팀원들이 베카시, 보고르, 동자카르타, 서밴둥 등 다양한 위텔 지역을 방문하여 피드백을 수집하고 필요한 향상을 구현하는 것을 포함합니다. 올해 기술적 제품 개발과 우리의 활동적인 위텔 활동이 교차되는 점에서 흥미로운 도전이 발생했습니다.\n\n# 우리 팀이 도전을 어떻게 극복했는지\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어려움을 극복하는 일은 도전적일 수 있지만 걱정하지 마세요. 최고의 팀이 이 도전을 정복하기 위해 노력할 거에요. 팀 간의 원활한 커뮤니케이션을 확립하고 모든 이해관계자가 문제 상황을 정확히 이해하는 것이 중요합니다. 긴급도에 따라 작업을 우선순위에 따라 정하는 것이 매우 효과적인 전략임이 입증되었습니다. Telkom의 PDP Law 과제 팀과 밀접히 협력하여 규정을 완전히 준수하도록 하는 등의 부서들과의 긴밀한 협력은 팀이 문제를 효과적으로 관리하고 해결할 수 있도록 돕고 있습니다.\n\n# 안타레스의 미래 비전: 목표를 현실로 변환하기\n\n당신의 삶에 최상의 솔루션이 되기를 원할 뿐만 아니라 다양한 서비스와 IoT 장치를 연결하고 플랫폼으로 만들기를 원합니다. 현재로서는,\n\n# 최신 안타레스 혁신 소개!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안타레스에서 여러분의 만족도를 극대화하기 위한 흥미진진한 업데이트를 공개하게 되어 기쁩니다. 함께 살펴봅시다.\n\n![이미지](/assets/img/2024-06-27-BehindtheProductofAntaresEazyNavigatingChallengestoCreateExcellence_0.png)\n\n- 렌탈 서비스 제공: 안타레스는 인도네시아에서 IP 카메라를 Rp35,000에 제공하는 렌탈 옵션을 선도합니다.\n- 수익성 높은 제휴 프로그램: 안타레스 제품을 손쉽게 홍보하고 상당한 커미션을 벌 수 있는 제휴 프로그램에 가입하고, 헌신적인 팀으로부터 전문적인 지도를 받아보세요.\n- 설치 서비스 번들링 제공: 인도네시아 130곳에서 제공되는 설치 서비스가 포함된 번들링 구매 옵션으로 편리함을 경험해보세요.\n- Eazy가 지원하는 장치 지속적으로 추가: 안타레스는 최신 기능을 지속적으로 통합하여 여러분의 경험이 무척나도 탁월하게 유지되도록 합니다.\n\n![이미지](/assets/img/2024-06-27-BehindtheProductofAntaresEazyNavigatingChallengestoCreateExcellence_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 편의성과 연결성을 재정의하는 이러한 획기적인 오퍼링을 소개합니다!\n\n# 안타레스 이지 업적\n\n안타레스 이지는 사용자의 편의성을 향상시키는 제품뿐만 아니라 혁신적인 IoT 플랫폼으로 두 가지 독특한 범주에서 존경받고 있는 제품으로, 2024년 제품 대상의 귀한 수상을 이끌었습니다. 연구된 제품 혁신 범주의 최도 탁월한 제품으로, 아주 좋은 평점을 받았으며, 혁신적인 혁신 범주입니다. 이러한 영예는 MIX Marcomm 잡지 (SWA 미디어 그룹)에서 선정했습니다. 이행사에서 브랜드들을 지난해의 혁신적인 제품 진보로 인정하고자 하는 3회 연례 이벤트에서 수여되었습니다. 혁신 전문가와 빅 데이터 크롤링 분석가들이 주도한 평가로 안타레스 이지의 인상적인 성과를 강조했으며 심사 패널에 오랫동안 인상을 남겼습니다.\n\n\u003cimg src=\"/assets/img/2024-06-27-BehindtheProductofAntaresEazyNavigatingChallengestoCreateExcellence_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIoT 제품 디자인에 관련된 더 많은 통찰력을 찾고 계신가요? 운좋게도! 텔콤 디자인(Telkom Design)에서 인도네시아를 위한 솔루션을 어떻게 만드는지 뒷이야기를 더 확인하려면 저희 웹사이트, Instagram, LinkedIn 또는 YouTube를 esearch하십시오. #TakeALeap를 이해하고 #DigitizeTheNation에 기여하여 디지털 변형을 가속화하는 방법을 지속적으로 업데이트하십시오!","ogImage":{"url":"/assets/img/2024-06-27-BehindtheProductofAntaresEazyNavigatingChallengestoCreateExcellence_0.png"},"coverImage":"/assets/img/2024-06-27-BehindtheProductofAntaresEazyNavigatingChallengestoCreateExcellence_0.png","tag":["Tech"],"readingTime":3}],"page":"3","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"3"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>