<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/11" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/11" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/960f1fe994a0ab5c.css" as="style"/><link rel="stylesheet" href="/_next/static/css/960f1fe994a0ab5c.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/873-2d104a861d88ea21.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-498da29379dd58dc.js" defer=""></script><script src="/_next/static/kNTo-t2jvQG5kfHDWIcB-/_buildManifest.js" defer=""></script><script src="/_next/static/kNTo-t2jvQG5kfHDWIcB-/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="해킹 보안 대전  티어 0미야옹" href="/post/2024-05-27-HackTheBoxTIER0Meow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="해킹 보안 대전  티어 0미야옹" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-HackTheBoxTIER0Meow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="해킹 보안 대전  티어 0미야옹" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">해킹 보안 대전  티어 0미야옹</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="bashrc, bash-profile, 그리고 profile의 차이점" href="/post/2024-05-27-DifferenceBetweenbashrcbash-profileandprofile"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="bashrc, bash-profile, 그리고 profile의 차이점" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-DifferenceBetweenbashrcbash-profileandprofile_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="bashrc, bash-profile, 그리고 profile의 차이점" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">bashrc, bash-profile, 그리고 profile의 차이점</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="모든 개발자를 위해 도움이 되는 5가지 Bash 문자열 조작 방법" href="/post/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="모든 개발자를 위해 도움이 되는 5가지 Bash 문자열 조작 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="모든 개발자를 위해 도움이 되는 5가지 Bash 문자열 조작 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">모든 개발자를 위해 도움이 되는 5가지 Bash 문자열 조작 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리눅스에서 Windows 가상 머신Docker을 실행하는 대안적인 방법" href="/post/2024-05-27-AlternativewaytorunWindowsVMonLinuxDocker"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리눅스에서 Windows 가상 머신Docker을 실행하는 대안적인 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-AlternativewaytorunWindowsVMonLinuxDocker_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리눅스에서 Windows 가상 머신Docker을 실행하는 대안적인 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">리눅스에서 Windows 가상 머신Docker을 실행하는 대안적인 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Traefik 역방향 프록시 만들기 쉽게 이해하기 - 궁극의 안내" href="/post/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Traefik 역방향 프록시 만들기 쉽게 이해하기 - 궁극의 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Traefik 역방향 프록시 만들기 쉽게 이해하기 - 궁극의 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Traefik 역방향 프록시 만들기 쉽게 이해하기 - 궁극의 안내</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">18<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link posts_-active__YVJEi" href="/posts/11">11</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"해킹 보안 대전  티어 0미야옹","description":"","date":"2024-05-27 12:18","slug":"2024-05-27-HackTheBoxTIER0Meow","content":"\n## 소개\n\n## 작업 1\n\nVM 약자는 무엇을 나타내나요?\n\n답: 가상 머신\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 작업 2\n\n운영 체제와 상호 작용하기 위해 명령 줄을 통해 명령을 내릴 때 사용하는 도구는 무엇인가요? 이것은 콘솔 또는 셸로도 알려져 있습니다.\n\n답: 터미널\n\n## 작업 3\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHTB 랩으로의 VPN 연결을 구성하는 데 어떤 서비스를 사용하나요?\n\n답: OpenVpn\n\n## TASK 4\n\n대상에 대한 연결을 테스트하기 위해 ICMP echo 요청을 사용하는 도구는 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표 태그를 Markdown 형식으로 변경해주세요.\n\nAns: ping\n\n## TASK 5\n\n대상의 열린 포트를 찾는 데 가장 일반적인 도구의 이름은 무엇인가요?\n\nAns: nmap\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 작업 6\n\n저희의 스캔 중에 23/tcp 포트에서 식별한 서비스는 무엇인가요?\n\n답변: Telnet\n\n![이미지](/assets/img/2024-05-27-HackTheBoxTIER0Meow_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 작업 7\n\n빈 암호로 대상에 텔넷을 통해 로그인할 수 있는 사용자 이름은 무엇인가요?\n\n답변: root\n\n![이미지](/assets/img/2024-05-27-HackTheBoxTIER0Meow_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![HackTheBoxTIER0Meow_2](/assets/img/2024-05-27-HackTheBoxTIER0Meow_2.png)\n\nSUBMIT FLAG\n\nAns: b40abdfe23665f766f9c61ecba8a4c19\n\n![HackTheBoxTIER0Meow_3](/assets/img/2024-05-27-HackTheBoxTIER0Meow_3.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로세스 요약\n","ogImage":{"url":"/assets/img/2024-05-27-HackTheBoxTIER0Meow_0.png"},"coverImage":"/assets/img/2024-05-27-HackTheBoxTIER0Meow_0.png","tag":["Tech"],"readingTime":2},{"title":"bashrc, bash-profile, 그리고 profile의 차이점","description":"","date":"2024-05-27 12:17","slug":"2024-05-27-DifferenceBetweenbashrcbash-profileandprofile","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-DifferenceBetweenbashrcbash-profileandprofile_0.png\" /\u003e\n\n# 1. 개요\n\nBash 쉘은 환경을 설정하기 위해 몇 가지 시작 파일을 사용합니다. 이러한 파일은 쉘 자체와 시스템 사용자를 위한 일부 Bash 쉘 구성을 결정합니다.\n\n이 튜토리얼에서는 .bashrc, .bash-profile 및 .profile과 같은 시작 파일 및 그들의 차이에 대해 알아보겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 대화형 쉘과 비대화형 쉘\n\nBash는 대화형 쉘에서 두 가지 모드 옵션을 제공합니다: 로그인과 비로그인입니다.\n\nssh를 사용하여 시스템에 로그인하면 대화형 로그인 쉘을 얻게 됩니다. 이 쉘은 호출될 때 시작 파일을 읽습니다.\n\n그러나 이미 로그인한 쉘에서 새 쉘을 호출하면 대화형 비로그인 쉘을 얻게 됩니다. 이 유형의 쉘은 .bashrc 파일만 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n명령을 실행하기 위해 인간의 개입이 필요하지 않은 셸을 비대화(non-interactive) 셸이라고 부릅니다. 예를 들어, 스크립트가 명령을 실행하기 위해 자식 셸을 생성할 때, 그 자식 셸은 비대화 셸입니다. 이 셸은 시작 파일을 실행하지 않습니다. 그것은 생성된 셸로부터 환경 변수를 상속합니다.\n\n## 3. Bash 시작 파일\n\n시작 파일은 셸 시동 시 실행되어야 하는 명령을 포함합니다. 결과적으로, 셸은 이 파일에 있는 명령을 셸을 설정하기 위해 자동적으로 실행합니다. 이는 명령 프롬프트를 표시하기 전에 발생합니다.\n\n## 3.1. .bash_profile의 중요성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n.bash_profile 파일에는 환경 변수를 설정하는 명령이 포함되어 있습니다. 따라서 이러한 변수는 이후의 쉘에서 상속됩니다.\n\n대화식 로그인 쉘에서 Bash는 먼저 /etc/profile 파일을 찾습니다. 발견되면 Bash는 해당 파일을 현재 쉘에서 읽고 실행합니다. 결과적으로 /etc/profile은 모든 사용자를 위한 환경 설정을 구성합니다.\n\n마찬가지로, Bash는 그 다음 홈 디렉토리에 .bash_profile 파일이 있는지 확인합니다. 존재한다면 Bash는 현재 쉘에서 .bash_profile을 실행합니다. 그러면 Bash는 .bash_login이나 .profile과 같은 다른 파일을 찾지 않습니다.\n\n만약 Bash가 .bash_profile을 찾지 못하면, .bash_login과 .profile 순으로 찾아 첫 번째로 읽을 수 있는 파일을 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n샘플 .bash_profile 파일을 살펴보겠습니다. 여기서는 PATH 변수를 설정하고 내보내고 있습니다:\n\n```js\necho \"Bash_profile execution starts..\"\nPATH=$PATH:$HOME/bin;\nexport PATH;\necho \"Bash_profile execution stops..\"\n```\n\n대화식 로그인 셸에서 명령 프롬프트 바로 앞에 다음과 같은 출력이 표시됩니다:\n\n```js\nBash_profile execution starts..\nBash_profile execution stops..\n[dsuser@cygnus ~]$\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3.2. .bashrc의 중요성\n\n.bashrc에는 Bash 쉘에 특정한 명령이 포함되어 있습니다. 모든 대화형 비로그인 쉘은 일반적으로 먼저 .bashrc를 읽습니다. 보통 .bashrc는 별칭(alias)과 Bash 관련 함수를 추가하는 가장 좋은 장소입니다.\n\nBash 쉘은 홈 디렉토리에서 .bashrc 파일을 찾아서 source를 사용하여 현재 쉘에서 실행합니다.\n\n이제 샘플 .bashrc 파일 내용을 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\necho \"Bashrc 실행 시작..\"\nalias elui='top -c -u $USER'\nalias ll='ls -lrt'\necho \"Bashrc 실행 종료..\"\n```\n\n인터랙티브 비로그인 셸에서 명령 프롬프트 바로 앞에 아래 출력을 볼 수 있습니다:\n\n```bash\n[dsuser@server ~]$ bash\nBashrc 실행 시작..\nBashrc 실행 종료..\n[dsuser@server ~]$\n```\n\n# 3.3. .profile 파일의 중요성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대화형 쉘 로그인 중 홈 디렉토리에 .bash_profile이 없으면 Bash는 .bash_login을 찾습니다. 발견되면 Bash가 실행합니다. 만일 홈 디렉토리에 .bash_login이 없다면 Bash는 .profile을 찾아 실행합니다.\n\n.profile에는 .bash_profile 또는 .bash_login에 있는 것과 동일한 구성을 저장할 수 있습니다. 이 파일은 프롬프트 모양, 키보드 소리, 열 쉘 및 /etc/profile 파일에서 설정한 변수를 무시하고 개별 프로필 설정을 제어합니다.\n\n# 4. 차이점\n\n대화형 로그인 시마다 Bash 쉘은 .bash_profile을 실행합니다. 만일 홈 디렉토리에 .bash_profile이 없다면 Bash는 .bash_login과 .profile 중 첫 번째로 읽을 수 있는 파일을 실행합니다. 한편, 대화형 비 로그인 쉘 시작 시마다 Bash는 .bashrc를 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적으로 환경 변수는 .bash_profile에 넣습니다. 대화식 로그인 쉘은 첫 번째 쉘이므로 환경 설정에 필요한 모든 기본 설정을 .bash_profile에 넣습니다. 결과적으로 이러한 설정은 한 번만 설정되지만 모든 하위 쉘에서 상속됩니다.\n\n마찬가지로 별칭 및 함수는 항상 기존 환경에서 셸을 시작할 때 로드되도록 .bashrc에 넣습니다.\n\n그러나 로그인 및 비로그인 대화식 셸 설정 차이를 피하기 위해 .bash_profile에서 .bashrc를 호출합니다. 결과적으로 아래 코드 조각이 .bash_profile에 삽입되어 매 대화식 로그인 셸에서 .bashrc도 동일한 셸에서 실행되도록 합니다:\n\n```js\nif [ -f ~/.bashrc ];\nthen\n    .  ~/.bashrc;\nfi\nPATH=$PATH:$HOME/bin export PATH\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. 결론\n\n결론적으로, 쉘은 환경을 설정하기 위해 시작 파일이 필요합니다. 환경을 사용하기 전에 쉘 환경을 구성해야 합니다.\n\n이 글에서는 다양한 쉘 모드를 확인했습니다. 그리고 다양한 Bash 시작 파일의 중요성을 배웠습니다. 마지막으로 이러한 시작 파일 간의 차이를 확인했습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-DifferenceBetweenbashrcbash-profileandprofile_0.png"},"coverImage":"/assets/img/2024-05-27-DifferenceBetweenbashrcbash-profileandprofile_0.png","tag":["Tech"],"readingTime":4},{"title":"모든 개발자를 위해 도움이 되는 5가지 Bash 문자열 조작 방법","description":"","date":"2024-05-27 12:16","slug":"2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper","content":"\n![Bash String Manipulation Methods](/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png)\n\n배시는 모든 유닉스류 또는 유닉스 기반 운영 체제의 기본 자동화 언어가 되었습니다. 시스템 관리자, 데브옵스 엔지니어 및 프로그래머는 일반적으로 반복적인 명령 시퀀스를 사용하여 셸 스크립트를 작성하는 데 Bash를 사용합니다. Bash 스크립트에는 일반적으로 다른 프로그램 이진 파일을 실행하는 명령이 포함되어 있습니다. 대부분의 시나리오에서 데이터를 처리하고 셸 스크립트 내에서 논리적 흐름을 생성해야 할 수 있습니다. 따라서 우리는 종종 셸 스크립트에 조건문과 텍스트 조작 문을 추가해야 합니다.\n\n전통적인 Bash 스크립트와 이전 버전의 Bash 해석기를 사용한 이전 프로그래머들은 텍스트 조작을 위해 awk, sed, tr 및 cut 명령을 일반적으로 사용했습니다. 이들은 별개의 프로그램입니다. 이 텍스트 처리 프로그램들은 좋은 기능을 제공하지만 각 명령마다 상당한 프로세스 생성 시간이 소요되기 때문에 Bash 스크립트를 느리게 만듭니다. 현대의 Bash 버전은 잘 알려진 매개변수 확장 기능을 통해 내장된 텍스트 처리 기능을 제공합니다.\n\n본 기사에서는 Bash 스크립트에서 효율적으로 텍스트를 처리하는 데 사용할 수 있는 내장 문자열 조작 구문 몇 가지에 대해 설명하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 부분 문자열 추출 및 대체\n\n부분 문자열은 특정 문자열의 연속된 세그먼트 또는 일부를 가리킵니다. 다양한 스크립팅 시나리오에서 문자열 세그먼트에서 부분 문자열을 추출해야 하는 경우가 있습니다. 예를 들어, 파일 확장자가 포함된 완전한 파일 이름에서 파일 이름 세그먼트만 얻어야 하는 경우가 있습니다. 또한 부분 문자열을 특정 문자열 세그먼트로 대체해야 할 수도 있습니다 (즉, 파일 이름의 확장자를 변경하는 경우).\n\n문자의 위치와 길이를 제공함으로써 부분 문자열을 추출하는 것은 매우 쉽습니다:\n\n```js\n#!/bin/bash\n\nstr=\"2023-10-12\"\n\necho \"${str:5:2}\" # 10\necho \"${str::4}\" # 2023\necho \"2022-${str:5}\" # 2022-10-12\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음과 같이 오른쪽 기준으로 부분 문자열 계산도 할 수 있습니다.\n\n```js\n#!/bin/bash\n\nstr=\"backup.sql\"\n\necho \"original${str:(-4)}\" # original.sql\n```\n\nBash는 부분 문자열을 대체하는 데 유용한 내장 구문도 제공합니다.\n\n```js\n#!/bin/bash\n\nstr=\"obin-linux_x64_bin\"\n\necho \"${str/x64/armhf}\" # obin-linux_armhf_bin\necho \"${str/bin/dist}\" # odist-linux_x64_bin\necho \"${str//bin/dist}\" # odist-linux_x64_dist\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 문자열(예: 파일 이름, 경로 등)을 작업할 때는 문자열의 접두사와 접미사를 대체해야 할 수도 있습니다. 파일 확장자를 다른 확장자로 바꾸는 것이 좋은 예시입니다. 다음 예시를 살펴보세요:\n\n```bash\n#!/bin/bash\n\nstr=\"db_config_backup.zip\"\n\necho \"${str/%.zip/.conf}\" # db_config_backup.conf\necho \"${str/#db/settings}\" # settings_config_backup.zip\n```\n\n위의 부분 문자열 대체 예시에서 일치시키기 위해 정확한 부분 문자열 세그먼트를 사용했지만, 다음과 같이 '\\*' 와일드카드 문자를 사용하여 부분 문자열을 사용할 수도 있습니다:\n\n```bash\n#!/bin/bash\n\nstr=\"db_config_backup.zip\"\n\necho \"${str/%.*/.bak}\" # db_config_backup.bak\necho \"${str/#*_/new}\" # newbackup.zip\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 방법은 정확한 부분 문자열을 모를 때 도움이 됩니다.\n\n# 정규 표현식 일치, 추출 및 치환\n\n이미 많은 유닉스 또는 GNU/Linux 사용자들이 알고 있는 대로, grep과 sed를 사용하여 정규 표현식 기반 텍스트 검색이 가능합니다. sed는 우리에게 정규 표현식 치환을 도와줍니다. 당신은 내장된 Bash 정규 표현식 기능을 사용하여 이러한 외부 이진 파일보다 빠르게 텍스트 처리를 처리할 수 있습니다.\n\n다음의 코드 스니펫에서 보여지는 것처럼, if 조건문과 =~ 연산자를 사용하여 정규 표현식 일치를 수행할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n#!/bin/bash\n\nstr=\"db_backup_2003.zip\"\n\nif [[ $str =~ 200[0-5]+ ]]; then\n    echo \"regex_matched\"\nfi\n```\n\n만약 원하시면 if 문을 인라인 조건문으로 바꿀 수도 있어요:\n\n```js\n[[ $str =~ 200[0-5]+ ]] \u0026\u0026 echo \"regex_matched\"\n```\n\nBash 해석기가 정규 표현식을 찾은 후에는 일반적으로 모든 일치 항목을 BASH_REMATCH 쉘 변수에 저장합니다. 이 변수는 읽기 전용 배열이며, 전체 일치 데이터를 첫 번째 인덱스에 저장합니다. 서브 패턴을 사용하는 경우, Bash는 그에 해당하는 일치 항목을 다른 인덱스에 차례대로 보관합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n#!/bin/bash\n\nstr=\"db_backup_2003.zip\"\n\nif [[ $str =~ (200[0-5])(.*)$ ]]; then\n    echo \"${BASH_REMATCH[0]}\" # 2003.zip\n    echo \"${BASH_REMATCH[1]}\" # 2003\n    echo \"${BASH_REMATCH[2]}\" # .zip\nfi\n```\n\n이전에 substring matching을 wildcard와 함께 사용했던 것을 기억하시나요? 비슷하게, 다음 예시에서 보여지는 것처럼 파라미터 확장 내에서 regex 정의를 사용할 수 있습니다.:\n\n```js\n#!/bin/bash\n\nstr=\"db_backup_2003.zip\"\nre=\"200[0-3].zip\"\n\necho \"${str/$re/new}.bak\" # db_backup_new.bak\n```\n\n# Substring Removal Techniques\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자주 텍스트 처리 요구 사항에서는 원하는 부분 문자열을 제거하여 텍스트 세그먼트를 사전 처리해야 할 때가 있습니다. 예를 들어, v 접두사와 일부 빌드 번호를 포함한 버전 번호를 추출하고 주 버전 번호를 찾으려면 일부 부분 문자열을 제거해야 합니다. 똑같은 부분 문자열 교체 구문을 사용할 수 있지만, 문자열 제거를 위해 교체 문자열 매개변수를 생략할 수도 있습니다.\n\n```js\n#!/bin/bash\n\nstr=\"ver5.02-2224.e2\"\n\nver=\"${str#ver}\"\necho $ver # 5.02-2224.e2\n\nmaj=\"${ver/.*}\"\necho $maj # 5\n```\n\n위 예제에서는 정확한 부분 문자열과 와일드카드를 사용하여 부분 문자열을 제거했지만, 정규 표현식을 사용할 수도 있습니다. 과도한 문자 없이 깔끔한 버전 번호를 추출하는 방법을 확인해보세요.\n\n```js\n#!/bin/bash\n\nstr=\"ver5.02-2224_release\"\n\nver=\"${str//[a-z_]}\"\necho $ver # 5.02-2224\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 대 소문자 변환 및 대 소문자 기반 변수\n\n심지어 표준 C 언어에는 문자의 대 소문자를 변환하는 함수가 있습니다. 대부분의 현대적인 프로그래밍 언어들은 대소문자 변환을 위한 내장 함수를 제공합니다. 셸 스크립트 언어인 Bash는 대소문자 변환을 위한 함수를 제공하지는 않지만, 매개변수 확장과 변수 선언을 통해 대소문자 변환 기능을 제공합니다.\n\n다음 예제를 살펴보세요. 이 예제는 글자의 대소문자를 변환합니다:\n\n```bash\n#!/bin/bash\n\nstr=\"안녕 Bash!\"\n\nlower=\"${str,,}\"\nupper=\"${str^^}\"\n\necho $lower # 안녕 bash!\necho $upper # 안녕 BASH!\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음처럼 특정 문자열의 첫 글자만 대문자 또는 소문자로 변경할 수도 있습니다:\n\n```js\n#!/bin/bash\n\nver1=\"V2.0-release\"\nver2=\"v4.0-release\"\n\necho \"${ver1,}\" # v2.0-release\necho \"${ver2^}\" # V4.0-release\n```\n\n만약 특정 변수를 엄격하게 대문자 또는 소문자로 만들어야 할 경우에는 매번 케이스 변환 함수를 실행할 필요가 없습니다. 대신, 다음 예시와 같이 내장된 declare 명령을 사용하여 특정 변수에 케이스 속성을 추가할 수 있습니다:\n\n```js\n#!/bin/bash\n\ndeclare -l ver1\ndeclare -u ver2\n\nver1=\"V4.02.2\"\nver2=\"v2.22.1\"\n\necho $ver1 # v4.02.2\necho $ver2 # V2.22.1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 ver1 및 ver2 변수는 선언 시 case 속성을 받기 때문에 특정 변수에 값을 할당할 때마다 Bash는 변수 속성을 기반으로 텍스트 case를 변환합니다.\n\n# 문자열 분할 (문자열을 배열로 변환하기)\n\nBash는 declare 내장을 사용하여 색인 배열과 연관 배열을 정의할 수 있습니다. 대부분의 범용 프로그래밍 언어는 문자열 객체의 분할 메서드나 표준 라이브러리 함수를 통해 분할 기능을 제공합니다 (예: Go의 strings.Split 함수). Bash에서는 다양한 방법으로 문자열을 분할하고 배열을 생성할 수 있습니다. 예를 들어 필요한 구분 기호를 IFS로 변경하고 read 내장을 사용할 수 있습니다. 또는 tr 명령어를 루프와 함께 사용하여 배열을 구성할 수도 있습니다. 내장 매개변수 확장을 사용하는 방법도 있습니다. Bash에서는 문자열을 분할하는 다양한 방법이 있습니다.\n\nIFS와 read를 사용하는 것은 문자열을 분할하는 가장 간단하고 오류가 적은 방법 중 하나입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n#!/bin/bash\n\nstr=\"C,C++,JavaScript,Python,Bash\"\n\nIFS=',' read -ra arr \u003c\u003c\u003c \"$str\"\n\necho \"${#arr[@]}\" # 5\necho \"${arr[0]}\" # C\necho \"${arr[4]}\" # Bash\n```\n\n위의 코드 스니펫은 쉼표를 구분자로 사용하며 read 내장 명령어를 사용하여 IFS를 기반으로 배열을 생성합니다.\n\nread를 사용하지 않고 쉽게 분할할 수 있는 방법이 있더라도, 숨겨진 문제가 없는지 확인해야 합니다. 예를 들어, 다음 분할 구현은 매우 간단하지만 \\* (현재 디렉토리의 내용으로 확장)을 요소로 포함하고 구분 기호로 공백을 사용하는 경우에 작동하지 않습니다:\n\n```bash\n#!/bin/bash\n\n# 경고: 이 코드에는 여러 숨겨진 문제가 있습니다.\n\nstr=\"C,Bash,*\"\n\narr=(${str//,/ })\n\necho \"${#arr[@]}\" # 현재 디렉토리의 내용이 포함되어 있음\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n지금까지 읽어 주셔서 감사합니다.\n\n# 레벨 업 코딩\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 마지막으로 하고 가기 전에:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 👏 이야기에 박수를 보내고 저자를 팔로우하세요 👉\n- 📰 Level Up Coding 게시물에서 더 많은 콘텐츠 확인하기\n- 💰 무료 코딩 면접 코스 ⇒ 코스 보기\n- 🔔 팔로우하기: Twitter | LinkedIn | 뉴스레터\n\n🚀👉 Level Up 팀의 멤버가 되어 멋진 직업을 찾아보세요\n","ogImage":{"url":"/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png"},"coverImage":"/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png","tag":["Tech"],"readingTime":7},{"title":"리눅스에서 Windows 가상 머신Docker을 실행하는 대안적인 방법","description":"","date":"2024-05-27 12:15","slug":"2024-05-27-AlternativewaytorunWindowsVMonLinuxDocker","content":"\n\n리눅스 사용자로서 주로 윈도우용 소프트웨어를 실행하거나 다양한 윈도우 전용 애플리케이션을 테스트해야 하는 경우가 많이 있어요.\n\n안타깝게도 VMware와 VirtualBox를 사용해 윈도우 가상 머신을 실행하는 것이 이상적이지 않다고 느꼈습니다. 제 노트북에서 이러한 애플리케이션을 사용할 때 성능이 꽤 느린 것을 경험했는데, 부드러운 경험을 보장하기에 필요한 자원이 부족했거든요. 그래서 리눅스에서 윈도우를 실행하기 위한 대안적인 방법을 찾기 시작했습니다.\n\n# 해결책\n\n그래서 발견한 해결책을 소개하려고 해요: 도커(Docker)에서 윈도우를 실행하는 방법이 바로 그것이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 도커\n\n도커는 컨테이너화 기술을 사용하여 애플리케이션을 격리된 환경인 컨테이너에서 실행하는 플랫폼입니다. 전통적인 가상 머신과 달리 도커 컨테이너는 호스트 시스템의 커널을 공유하므로 무게가 가볍고 효율적이며 최소한의 오버헤드로 애플리케이션을 실행할 수 있습니다. 시스템에 설치하려면:\n\n```js\n# Debian / Ubuntu\nsudo apt install docker.io\n# 저는 아치를 사용합니다\nyay -S docker\n# 다른 배포판의 경우, 다음 링크를 확인하세요\n# https://docs.docker.com/engine/install/\n```\n\n그리고 다음 이미지를 사용할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- https://hub.docker.com/r/dockurr/windows\n\n도커 컨테이너 내에서 실행되는 Windows!\n\n## Windows 설치\n\ndocker-compose.yml이라는 파일을 만든 다음 (선택 사항으로) Windows 이미지 파일을 저장할 storage 폴더를 만들고 호스트 및 가상 머신간에 공유되는 폴더를 위한 shared 폴더를 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, docker-compose.yml을 수정해야 합니다. 제 구성은 아래와 같습니다:\n\n```js\nservices:\n  windows:\n    image: dockurr/windows\n    container_name: windows\n    environment:\n      VERSION: \"win10\" # 실행할 Windows 버전을 지정합니다\n      DISK_SIZE: \"25G\" # 선택 사항입니다. 할당할 디스크 크기를 지정할 수 있습니다\n      RAM_SIZE: \"3G\" # RAM도 마찬가지로 지정할 수 있습니다\n      CPU_CORES: \"2\" # CPU 코어도 지정 가능합니다\n    devices:\n      - /dev/kvm # KVM이 있을 경우\n    volumes:\n      - ./storage:/storage # 윈도우 이미지는 이 폴더에 저장됩니다 (호스트 머신과 컨테이너 모두)\n      - ./shared:/shared # 공유 폴더도 동일합니다\n    cap_add:\n      - NET_ADMIN # 컨테이너에 네트워크 관련 작업을 위한 관리자 권한을 부여합니다\n    ports:\n      - 8006:8006 # 웹 인터페이스\n      - 3389:3389/tcp # 원격 데스크톱 연결 (RDP)\n      - 3389:3389/udp\n    stop_grace_period: 2m\n```\n\n다음 명령어로 실행해 주세요:\n\n```js\ndocker compose up -d\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n( 이 테이블 태그를 Markdown 형식으로 변경하세요. )\n\n개발자가 되신 것을 축하드립니다! 여기서는 한국어 번역을 지원해 드립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹에서 머신을 사용하거나 더 선호되는 RDP로 연결할 수 있습니다. 도커로 머신의 IP를 가져오려면 도커 inspect 47bb78f908a0 | grep IPAddress를 사용하시면 됩니다.\n\n![이미지](/assets/img/2024-05-27-AlternativewaytorunWindowsVMonLinuxDocker_0.png)\n\n저는 xfreerdp 도구를 사용하여 RDP를 통해 연결할 것입니다. 사용자 이름은 docker이며, 아래 명령어를 사용하세요:\n\n```js\nxfreerdp /u:docker /v:172.18.0.2 /dynamic-resolution\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기, 도커 컨테이너에서 Windows를 실행하는 법입니다:\n\n![Image](/assets/img/2024-05-27-AlternativewaytorunWindowsVMonLinuxDocker_1.png)\n\n공유 폴더는 \\\\host.lan 입니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 다른 구성을 위한 도커 이미지의 설명서를 확인하는 것을 제안합니다. 또한, Windows를 시작 및 중지하는 두 개의 스크립트를 포함하는 https://github.com/ElnurBDa/win10dockerconfig 레포지토리를 확인해보세요. 이를 키보드 단축키에 바인딩할 수 있습니다.\n\n읽어 주셔서 감사합니다!! Linux에서 Windows를 실행하는 다른 대안이 있다면 댓글로 알려주세요 :)","ogImage":{"url":"/assets/img/2024-05-27-AlternativewaytorunWindowsVMonLinuxDocker_0.png"},"coverImage":"/assets/img/2024-05-27-AlternativewaytorunWindowsVMonLinuxDocker_0.png","tag":["Tech"],"readingTime":3},{"title":"Traefik 역방향 프록시 만들기 쉽게 이해하기 - 궁극의 안내","description":"","date":"2024-05-27 12:08","slug":"2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide","content":"\n![Traefik 설치하기 쉽게 만든 Reverse Proxy의 최종 가이드](/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_0.png)\n\n셀프 호스팅 세계에서 많은 사람들이 Traefik의 설정이 어렵고 문서를 이해하기 어렵다고 불평한다는 것을 알았어요. 또한 기존 가이드 중 많은 것들이 Traefik가 어떻게 작동하는지 설명하지 않고 구성 예시만 제공하는 것을 알았어요.\n\nTraefik 가이드에 대한 저의 접근 방식은 ELI5 스타일로 Traefik에 대해 절대 모든 것을 이해하게 해줄 테니 기대해주세요.\n\nMedium 유료 회원이 아니신가요? 무료로 여기서 읽어보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기초로 돌아가 — 반전 프록시란 무엇인가요?\n\n반전 프록시는 다른 서버들 앞에 위치한 서버로, 요청을 이러한 서버들로 전달할 수도 있고 수정하거나 거부할 수도 있습니다.\n\n예를 들어, 밥이가 있습니다. 밥이는 라즈베리 파이에 웹사이트를 배포했습니다. 그 라즈베리의 IP는 192.168.0.50이며, 그의 사이트는 http://192.168.0.50:8080 페이지로 접속할 수 있습니다. 그러나 그는 https://mysite.imbob.com을 입력하여 접속하고 싶어합니다. \"imbob.com\" 도메인을 소유하고 있다면, 반전 프록시를 이용하여 이를 할 수 있습니다. 더불어 IP를 화이트리스트로 추가하거나 인증을 추가하는 등의 보안 메커니즘을 추가할 수도 있습니다.\n\n\u003cimg src=\"/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n역방향 프록시는 로드 밸런서 역할을 할 수도 있습니다. 단일 서버가 처리할 수 있는 트래픽보다 많은 트래픽을 받으면, 역방향 프록시는 요청을 다른 서버들 사이에 분배할 수 있습니다.\n\n## Traefik 최소 구성\n\n당신이 Traefik을 설정할 때 Docker Compose를 사용한다고 가정하겠습니다. 여기 Traefik 문서에서 가져온 최소 예제가 있습니다:\n\nservices:\nreverse-proxy: # The official v3 Traefik docker image\nimage: traefik:v3.0 # Enables the web UI and tells Traefik to listen to docker\ncommand: --api.insecure=true --providers.docker\nports: # The HTTP port - \"80:80\" # The Web UI (enabled by --api.insecure=true) - \"8080:8080\"\nvolumes: # So that Traefik can listen to the Docker events - /var/run/docker.sock:/var/run/docker.sock\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기, 이해해야 할 몇 가지 사항이 있어요. --api.insecure=true은 API를 traefik 엔트리포인트에서 사용 가능하게 만들고 (--entrypoint에 대한 더 자세한 내용은 몇 분 후에 있습니다), --providers.docker은 도커 프로바이더를 활성화시켜 호스트에서 도커 서비스를 자동으로 발견할 수 있게 합니다. 이를 위해 Traefik 컨테이너에 도커 소켓을 마운트해야 하는데, 이는 볼륨 섹션에서 수행됩니다. 마지막으로 몇 가지 포트를 노출해야도 해요:\n\n- 80: 표준인 포트 80에서 HTTP 트래픽을 전달하기 위해\n- 8080: 웹 UI에 액세스하기 위해\n\n모든 것이 작동하는지 확인할 수 있어요. 웹 UI를 열어 http://your-ip:8080 (http://192.168.0.50:8080은 Bob의 경우)으로 접속할 수 있어요.\n\n## 설정 파일\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTraefik을 구성하는 방법은 많이 있어요. 여기서 우리는 설정 매개변수를 컨테이너에 명령으로 전달했음을 볼 수 있어요. 이를 구성 파일을 통해 전달하거나 환경 변수를 통해 전달할 수도 있어요.\n\n우리의 간단한 예제를 위한 구성 파일은 다음과 같아요:\n\n```js\napi: insecure: true;\n\nproviders: docker: endpoint: \"unix:///var/run/docker.sock\";\n```\n\n이건 YAML 파일이에요. 이 파일을 사용하려면 간단히 컨테이너에 마운트하시면 돼요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n```\n\n그리고 모든 것이 이전과 같이 작동해야 합니다. 설정을 원하는대로 자유롭게 할 수 있으며, 이를 컨테이너 설정 파일을 통해하거나 Traefik 설정 파일을 통해하거나 환경 변수를 통해 할 수 있습니다. 개인적으로 Traefik 설정 파일을 통해 하는 것을 선호하므로 그대로 진행할 겁니다.\n\n그런데 말이야, 지금 이야기하고 있는 설정은 정적 설정이라고 알려져 있어요. 이 설정을 변경할 때마다 Traefik을 재시작해야 합니다. 나중에 동적 설정에 대해 이야기할 거에요.\n\n## EntryPoints\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEntryPoints의 역할은 특정 포트의 트래픽을 캡처하는 것입니다. 일반적인 Traefik 설치에서는 보통 포트 80과 포트 443의 트래픽을 캡처하고 싶을 것입니다. 하지만 가능한 모든 것이 있습니다. 예를 들어, 저는 포트 222를 통해 통과하는 SSH 트래픽을 리다이렉트하는 데에도 Traefik을 사용합니다.\n\nEntryPoints는 정적 구성에서 정의됩니다. 예를 들어:\n\n```js\nentryPoints: web: address: \":80\";\n\nwebsecure: address: \":443\";\n\nssh: address: \":222\";\n```\n\nEntryPoints의 이름은 원하는 대로 지정할 수 있습니다. 표준은 없습니다. EntryPoints를 구성하는 다양한 옵션들이 많이 있습니다. 이 안내서에서 모든 세부 내용을 다룰 수는 없으니, 기본 사항을 설명해 드리겠습니다. 더 알고 싶다면 문서를 참조해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적으로 HTTP 트래픽을 모두 HTTPS 트래픽으로 리디렉션하여 연결을 보안하는 것이 좋습니다. 이를 수행하는 한 가지 방법은 EntryPoint에 리디렉션을 추가하는 것입니다:\n\n```js\nentryPoints: web: address: \":80\";\nhttp: redirections: entryPoint: to: websecure;\n```\n\n여기서 모든 HTTP 트래픽이 websecure EntryPoint로 리디렉션되어야 함을 나타냅니다. 현재 TLS 인증서를 구성하지 않았으므로 이것을 구성에 유지하지 않는 것이 좋습니다.\n\n또한, 각 EntryPoint에 대해 컴퓨터의 포트를 열어야 합니다. 그래서 우리의 새로운 docker-compose.yml 파일은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\" # web\n      - \"443:443\" # websecure\n      - \"1234:222\" # ssh\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n```\n\n알 수 있듯이, ssh 엔트리 포인트의 포트 매핑은 1234입니다. 즉, 포트 1234로 전송된 트래픽은 ssh 엔트리 포인트를 통해 전송됩니다. 제가 보여주려는 것은 포트를 원하는 대로 매핑할 수 있으며, 다른 포트를 80번 포트와 443번 포트로 매핑할 수도 있지만, 이는 표준이 아니므로 서비스에 액세스할 때 포트를 지정해야 합니다. 예를 들어, https://radarr.imbob.com:4430이라고 지정해야 하며, 443번 포트가 아닌 다른 포트로 매핑한 경우에는 https://radarr.imbob.com 대신에 이렇게 지정해야 할 것입니다.\n\n## DNS 레코드\n\n도메인을 소유하고 있다고 가정하겠습니다. 소유하고 있지 않다면, PiHole과 같은 DNS 서버로 자체 도메인을 만들고 여기에 DNS 레코드를 추가할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"저는 원하는 것이 'something.mydomain'을 입력하면 Traefik이 호스팅된 머신에 도달하도록 하고 싶어요. 어디에서든 서비스를 이용할지, 또는 집에서만 이용할지에 따라 사용해야 하는 IP가 다릅니다. 예를 들어, 저는 집에서만 서비스에 접속하고 싶다고 가정해봅시다.\n\n해야 할 일은 로컬로 서버에 접속할 때 사용하는 IP를 가져와서 도메인 호스트에서 이 IP를 가리키는 A 레코드를 생성하는 것뿐입니다.\n\n예를 들어, Bob은 DNS에 다음 레코드를 가지고 있습니다:\n\n````js\nA  *.imbob.com  192.168.0.50\n```\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 Bob이 자신의 서비스를 어디서든 접근할 수 있게 하고 싶다면, 공용 IP를 사용하고 라우터 구성에서 포트 80 및 443을 전달해야 했을 것입니다. 예를 들어 다음과 같은 결과가 나오게 됩니다:\n\n```js\nA  *.imbob.com  84.154.65.110\n````\n\n84.154.65.110이 그의 공용 IP인 것으로 가정합니다.\n\n또 다른 예를 들어보겠습니다. 저는 VPN을 사용합니다. 이 VPN에 연결되어 있을 때, VPN에 할당된 다른 IP를 통해 내 기기에 접근할 수 있습니다. VPN에서 연결될 때 보이는 IP를 사용하여 내 서비스를 VPN에 속한 누구에게든 접근 가능하게 하고 싶다면, 다음과 같이 할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nA  *.imbob.com  100.81.0.50\n```\n\n## 첫 번째 서비스 추가하기\n\n예를 들어, Dozzle를 사용해보겠습니다. Dozzle에 http://dozzle.imbob.com에서 액세스하고 싶습니다.\n\n이제 docker-compose.yml에 Dozzle를 추가하겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n      - \"1234:222\"\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n\n  dozzle:\n    container_name: dozzle\n    image: amir20/dozzle:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    ports:\n      - 8081:8080\n    labels:\n      - traefik.enable=true # 해당 서비스를 위해 Traefik를 활성화합니다\n      - traefik.http.routers.dozzle.entrypoints=web # 엔트리포인트를 명시합니다\n      - traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`) # 서비스에 액세스하는 규칙을 명시합니다\n```\n\n또한, Traefik 구성 파일을 아래에서 확인하실 수 있습니다:\n\n```yaml\napi:\n  insecure: true\n\nentryPoints:\n  web:\n    address: \":80\"\n\n  websecure:\n    address: \":443\"\n\n  ssh:\n    address: \":222\"\n\nproviders:\n  docker:\n    endpoint: \"unix:///var/run/docker.sock\"\n```\n\n이제 http://dozzle.imbob.com을 열어 사용하실 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 왜 이것이 작동하는 걸까요? 저희 서비스는 Traefik 서비스와 동일한 파일에 있기 때문에 동일한 Docker 네트워크에 속합니다. 이 네트워크는 포트 80과 443을 통해 노출되어 있습니다. 따라서 우리가 컴퓨터의 포트 80으로 요청을 보내면, 이는 Dozzle이 속한 Docker 네트워크로 진입하게 됩니다.\n\n이제 우리가 우리의 서비스를 해당 서비스를 자체 파일로 옮기고 싶다고 상상해 봅시다. 이 서비스를 Traefik의 Docker 네트워크에 연결해야 합니다. 다음과 같이 생성해 시작해 보죠:\n\n```js\ndocker network create traefik\n```\n\n이제 우리의 두 서비스, Traefik과 Dozzle이 이 네트워크에 속한다는 것을 밝혀야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n      - \"1234:222\"\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n    networks:  # required\n      - traefik\n\nnetworks:\n  traefik:\n    external: true\n```\n\n```js\nservices:\n  dozzle:\n    container_name: dozzle\n    image: amir20/dozzle:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    ports:\n      - 8081:8080\n    labels:\n      - traefik.enable=true  # 해당 서비스에 대해 Traefik을 활성화합니다.\n      - traefik.http.routers.dozzle.entrypoints=web  # 엔트리포인트를 지정합니다.\n      - traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`)  # 서비스에 액세스하는 규칙을 지정합니다.\n    networks:  # required\n      - traefik\n\nnetworks:\n  traefik:\n    external: true\n```\n\n그러면 작동합니다. 그렇지 않으면, Traefik은 Dozzle 컨테이너의 IP로 리다이렉팅하겠지만, 이 IP는 서버에서 노출된 네트워크 바깥에 있는 Dozzle 컨테이너로 이어지지 않습니다.\n\n## 라우터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라우터는 적절한 서비스로 요청을 전달하는 역할을 합니다. 이는 동적 구성의 일환입니다.\n\n도즐(Dozzle)의 경우, 다음 라우터를 정의했습니다:\n\n```js\n- traefik.http.routers.dozzle.entrypoints=web  # 우리는 엔트리포인트를 지정합니다\n- traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`)  # 저희 서비스에 접근하는 규칙을 지정합니다\n```\n\n또한 Docker 레이블 대신 파일에서도 구성할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nhttp: routers: dozzle: entrypoints: -web;\nrule: Host(`dozzle.imbob.com`);\n```\n\n그런 다음 정적 구성 파일에서 파일 제공자로 추가하십시오:\n\n```js\nproviders:\n  docker:\n    ...\n  file:\n    filename: /dynamic.yml\n```\n\n당연히 이 파일을 컨테이너에 마운트해야 합니다:```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nservices:\n  reverse-proxy:\n    ...\n    volumes:\n      - ./dynamic.yml:/dynamic.yml:ro\n```\n\nTraefik을 사용하는 것은 Docker 레이블을 사용하는 큰 장점이죠. 그러니 일단 이것을 사용하도록 하겠습니다. Middleware를 정의할 때 이 파일을 다시 살펴볼 거에요.\n\nEntryPoints와 마찬가지로, Routers에도 많은 구성 옵션이 있습니다. 가장 중요한 것은 Rule 옵션입니다. 이 옵션을 사용하면 라우터가 요청을 서비스로 전달하기 위한 규칙을 정의할 수 있습니다.\n\nDozzle에 사용한 규칙은 다음과 같았습니다:```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```javascript\n호스트(`dozzle.imbob.com`);\n```\n\n예를 들어 다음과 같이 사용할 수 있습니다:\n\n```javascript\n호스트(`dozzle1.imbob.com`) || 호스트(`dozzle2.imbob.com`);\n```\n\nDozzle에 http://dozzle1.imbob.com 또는 http://dozzle2.imbob.com에서 액세스할 수 있습니다. 규칙에 대한 자세한 내용은 Traefik 문서를 참조하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 미들웨어\n\n미들웨어는 서비스로 전송되기 전에 요청을 조정하는 데 사용됩니다. 미들웨어는 동적 구성에 정의됩니다.\n\n도즐에 인증을 추가해 보겠습니다. 먼저, 패키지 apache2-utils에 포함된 htpasswd를 사용하여 비밀번호를 생성해야 합니다.\n\n```js\nhtpasswd -nB test\n새 암호:\n새 암호 다시 입력:\ntest:$2y$05$kLDHhc5ntBoHwAyp5S48U.wN.u2eQJYWpfYvRWSilayuAe5oF2xqy\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고: docker-compose.yml에서 사용할 때 해시 내의 모든 달러 기호는 이스케이핑을 위해 두 배로 사용되어야 합니다. 따라서 대신 다음 명령을 사용하여 이를 자동으로 수행할 수 있습니다:\n\n```js\necho $(htpasswd -nB test) | sed -e s/\\\\$/\\\\$\\\\$/g\n새 암호:\n새 암호 다시 입력:\ntest:$$2y$$05$$uo7dTQpudzoJtmAhXLesxudke9edoGlxC6oaOL9zStHVayoVZ6xwm\n```\n\n이제 docker-compose.yml 파일에 인증 미들웨어를 추가할 수 있습니다:\n\n```js\nservices:\n  dozzle:\n    ...\n    labels:\n      ...\n        # 패스워드는 \"test\" 입니다\n      - traefik.http.middlewares.my-middleware.basicauth.users=test:$$2y$$05$$x4VT4lRFCy2.z/Ic3BQYbOgEzDILEqyhaStkuzykurT9KAuWKTSF.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서는 미들웨어를 만들라고만 되어 있어요. 라우터에 그것을 사용하도록 지시해야 해요. 그래서 다음 레이블을 추가해요:\n\n```js\n- traefik.http.routers.dozzle.middlewares=my-middleware\n```\n\n참고로 동적 구성 파일을 사용해서도 똑같은 작업을 할 수 있어요.\n\n전체 Docker compose 파일은 다음과 같아요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n\n  dozzle:\n    container_name: dozzle\n    image: amir20/dozzle:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    ports:\n      - 8081:8080\n    labels:\n      - traefik.enable=true\n      - traefik.http.routers.dozzle.entrypoints=web\n      - traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`)\n      - traefik.http.middlewares.my-middleware.basicauth.users=test:$$2y$$05$$x4VT4lRFCy2.z/Ic3BQYbOgEzDILEqyhaStkuzykurT9KAuWKTSF.\n      - traefik.http.routers.dozzle.middlewares=my-middleware\n```\n\n그리고 이제 http://dozzle.imbob.com 으로 이동하여 웹앱에 액세스하려면 기본 HTTP 인증을 요구할 것입니다.\n\n참고: Traefik이 이해하는 설정을 언제든지 웹 UI를 통해 확인할 수 있습니다:\n\n![Traefik Reverse Proxy 설정 화면](/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## HTTPS 활성화\n\n오늘날, 사용자들에게 신뢰감을 줄 수 있는 가장 기본적인 작업은 암호화된 연결을 제공하는 것입니다. Traefik을 사용하면 HTTPS 트래픽을 쉽게 제공할 수 있습니다.\n\nTraefik을 구성하여 정적 인증서를 사용하거나 ACME 공급자에 의해 자동으로 생성된 인증서를 사용하도록 설정할 수 있습니다.\n\n두 번째 옵션인 자동 생성 인증서를 사용하는 것이 가장 좋고 간단합니다. 그러니 이렇게 설정해 봅시다. Traefik의 정적 구성에 추가할 구성은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncertificatesResolver:\n  letsEncrypt:\n    acme:\n      email: bob@gmail.com  # 여러분의 이메일을 입력해주세요\n      storage: /tls/acme.json\n      httpChallenge:\n        entryPoint: web\n```\n\n여기서 \"letsEncrypt\"라는 인증서 리졸버를 선언하고 있습니다. 우리는 이를 위해 이메일 주소, 인증서를 저장할 위치 및 이 리졸버와 관련된 엔트리포인트를 제공해야 합니다.\n\n기본적으로 우리는 무료이면서 접근성이 좋은 Let's Encrypt를 사용하고 있습니다. 위의 구성은 일반적으로 여러분의 도메인에 관계없이 작동할 것입니다. 하지만 Porkbun과 같은 다른 제공업체를 지정할 수도 있습니다:\n\n```js\ncertificatesResolvers:\n  porkbun:\n    acme:\n      email: bob@gmail.com\n      storage: /tls/porkbun.json\n      dnsChallenge:\n        provider: porkbun\n        delayBeforeCheck: 0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용하는 공급업체에 따라 특정 옵션을 수정할 수 있어요. 예를 들어 Porkbun의 경우 환경 변수로 전달하는 API 키와 비밀 값을 제공해야 해요:\n\n```js\nservices:\n  reverse-proxy:\n    ...\n    environment:\n      PORKBUN_SECRET_API_KEY: my-secret\n      PORKBUN_API_KEY: my-key\n```\n\n자세한 내용은 문서에서 확인해주세요.\n\n컨테이너가 종료되어도 인증서가 유지되어야 여러 API에서 제한을 받지 않아요. 그래서 docker-compose.yml 파일에 볼륨을 추가해봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n서비스:\n  reverse-proxy:\n    ...\n    볼륨:\n      - tls:/tls\n\n볼륨:\n  tls:\n```\n\n마지막으로, 우리는 인증서 리졸버를 사용하고자 한다고 명시해야 합니다 (이것은 자동으로 이루어지지 않습니다). 그리고 우리의 EntryPoint를 HTTPS 트래픽과 관련된 하나를 사용하도록 수정해야 합니다 (우리의 경우에는 websecure), 그래서 우리의 라우터를 수정합니다:\n\n```js\n서비스:\n  dozzle:\n    ...\n    레이블:\n    ...\n      - traefik.http.routers.dozzle.entrypoints=websecure\n      - traefik.http.routers.dozzle.tls.certresolver=letsEncrypt\n```\n\n그래서 이제, 여기가 전체 파일이에요, docker-compose.yml:```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"8080:8080\"\n      - \"443:443\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n      - tls:/tls\n\n  dozzle:\n    container_name: dozzle\n    image: amir20/dozzle:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    ports:\n      - 8081:8080\n    labels:\n      - traefik.enable=true\n      - traefik.http.routers.dozzle.entrypoints=websecure\n      - traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`)\n      - traefik.http.routers.dozzle.middlewares=my-middleware\n      - traefik.http.middlewares.my-middleware.basicauth.users=test:$$2y$$05$$x4VT4lRFCy2.z/Ic3BQYbOgEzDILEqyhaStkuzykurT9KAuWKTSF.\n      - traefik.http.routers.dozzle.tls.certresolver=letsEncrypt\n\nvolumes:\n  tls:\n```\n\n그리고 traefik.yml:\n\n```yaml\napi:\n  insecure: true\n\nentryPoints:\n  web:\n    address: \":80\"\n\n  websecure:\n    address: \":443\"\n\n  ssh:\n    address: \":222\"\n\nproviders:\n  docker:\n    endpoint: \"unix:///var/run/docker.sock\"\n\ncertificatesResolver:\n  letsEncrypt:\n    acme:\n      email: bob@gmail.com\n      storage: /tls/acme.json\n      httpChallenge:\n        entryPoint: web\n```\n\n## 마무리하는 손짓```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n완료하려면 먼저 Traefik을 우리 도메인 이름을 통해 쉽게 접근할 수 있도록 만들어야 합니다. 몇 가지 레이블을 추가하겠습니다:\n\n```js\nservices:\n  reverse-proxy:\n    ...\n    labels:\n      - traefik.enable=true\n      - traefik.http.routers.traefik-secure.entrypoints=websecure\n      - traefik.http.routers.traefik-secure.rule=Host(`traefik.imbob.com`)\n      - traefik.http.routers.traefik-secure.service=api@internal\n      - traefik.http.routers.traefik-secure.tls.certresolver=letsEncrypt\n```\n\nTraefik의 장점은 초기 구성이 완료된 후 리버스 프록시 뒤에 서비스를 쉽게 추가할 수 있다는 것입니다. 몇 가지 Docker 레이블로 가능합니다.\n\ntraefik.yml에서 api.insecure를 비활성화하고 api.dashboard를 활성화할 수도 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\napi:\n  insecure: false\n  dashboard: true\n```\n\n마지막으로, HTTP 트래픽을 HTTPS로 리디렉션하는 설정 블록을 추가해봅시다. traefik.yml에서 web 엔트리포인트를 수정하면 됩니다:\n\n```yaml\nweb:\n  address: \":80\"\n  http:\n    redirections:\n      entryPoint:\n        to: websecure\n```\n\n## TCP 트래픽 전달하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작 부분의 예시를 다시 가져오겠습니다. SSH EntryPoint와 함께:\n\n```js\nentrypoints: ssh: address: \":222\";\n```\n\n도메인 이름 뒤에 SSH 트래픽을 전달하려고 합니다. EntryPoint가 있습니다. 호스트에서 포트를 노출해야 합니다:\n\n```js\nservices:\n  reverse-proxy:\n    ...\n    ports:\n      - 222:222\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제, 우리는 SSH 서버를 정의하는 docker-compose.yml 파일에 TCP 라우터를 정의할 수 있습니다:\n\n```js\nservices:\n  server:\n    ...\n    ports:\n      - 222:22\n    labels:\n      - traefik.enable=true\n      - traefik.tcp.routers.ssh.entrypoints=ssh\n      - traefik.tcp.routers.ssh.rule=HostSNI(`*`)\n```\n\nHostSNI(\\*)은 모든 요청을 일치시킬 것이라고 말합니다. 올바른 엔트리 포인트로 전송된다면 모든 요청을 일치시킵니다. 따라서 이는 example.mydomain.com:222뿐만 아니라 anything.mydomain.com:222도 일치시킵니다. 이는 TCP 트래픽에 대해 TLS를 사용하지 않는 경우 필수적이며, HTTP 및 HTTPS 포트가 아닌 표준 TCP 포트를 사용하지 않는 경우에는 실제로 문제가 되지 않습니다.\n\n이것으로 끝입니다! 참고로, 저는 이를 Gitea와 함께 사용하여 다음과 같은 원격 URL을 가지고 있습니다: ssh://git@gitea.mydomain.com:222/estebanthi/my-repo.git.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아무것이나 원하는 대로 할 수 있습니다. 저는 SQL 데이터베이스와 함께도 이를 사용해요.\n\n## 보너스: 여러 호스트\n\n이 부분은 여러 대의 서버를 사용하는 사람들에게만 관련됩니다.\n\n서비스가 Traefik을 통해 접근 가능하도록 하려면 도커 네트워크에 속해 있어야 한다고 말씀드렸죠? 만약 여러 대의 서버를 가지고 있다면 이것이 문제가 될 수 있습니다. 적어도 도커 레이블을 더 이상 사용할 수 없게 되며, 서비스를 노출하고 파일 공급자를 통해 Traefik에 추가해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대안으로 traefik-kop을 사용할 수 있습니다. 이제 \"서버 1\" (192.168.0.50)에 Traefik이 있고 \"서버 2\" (192.168.0.51)에 Dozzle이 있다고 가정해 봅시다.\n\n먼저 Traefik에 Redis 공급자를 추가해 보겠습니다.\n\n```js\nproviders:\n  docker:\n    ...\n  redis:\n    endpoints:\n      - \"redis:6379\"\n```\n\n여기에서 Traefik을 실행 중인 호스트와 동일한 호스트에 Redis를 만들어 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nservices:\n  reverse-proxy: ...\n\n  redis:\n    image: redis:latest\n    restart: unless-stopped\n    ports:\n      - \"6379:6379\"\n```\n\n이제 \"서버 2\"에서 traefik-kop을 배포할 것입니다.\n\n```yaml\nservices:\n  traefik-kop:\n    image: \"ghcr.io/jittering/traefik-kop:latest\"\n    restart: unless-stopped\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n      - \"REDIS_ADDR=192.168.0.50:6379\" # Redis 호스트의 IP\n      - \"BIND_IP=192.168.0.51\" # 현재 호스트의 IP\n```\n\n그러면 이제 \"server 2\"에서 계속해서 사용해오던 라벨들을 사용할 수 있게 됩니다.```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그런데 Redis 호스트의 TCP 트래픽을 노출하고 redis.mydomain.com:6379을 통해 접근할 수 있도록 설정할 수 있어요. 그러면 \"REDIS_ADDR\"이 \"redis.mydomain.com:6379\"로 변경돼요 (저는 이렇게 했어요). 이제는 알고 계시잖아요.\n\n## 마지막으로\n\n제가 설명을 명확히 전달했기를 바랍니다. Traefik은 처음에는 조금 혼란스러울 수 있지만 최대한 간단하게 설명하려고 노력했어요. 이해에 어려움이 있다면 언제든지 댓글을 달아 주세요!\n\n읽어 주셔서 감사합니다! 더 많은 내용을 보고 싶으시다면 아래에서 제 모든 게시물을 찾아보세요.\n","ogImage":{"url":"/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_0.png"},"coverImage":"/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_0.png","tag":["Tech"],"readingTime":18}],"page":"11","totalPageCount":11,"totalPageGroupCount":1,"lastPageGroup":11,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"11"},"buildId":"kNTo-t2jvQG5kfHDWIcB-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>