<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/13" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/13" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Docker와 QEMU 엣지 컴퓨팅 개발 가속화 및 코드 컴파일 최적화를 위한 강력한 조합" href="/post/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Docker와 QEMU 엣지 컴퓨팅 개발 가속화 및 코드 컴파일 최적화를 위한 강력한 조합" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Docker와 QEMU 엣지 컴퓨팅 개발 가속화 및 코드 컴파일 최적화를 위한 강력한 조합" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Docker와 QEMU 엣지 컴퓨팅 개발 가속화 및 코드 컴파일 최적화를 위한 강력한 조합</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Ubuntu에서 웹사이트 구축하는 방법" href="/post/2024-06-23-BuildingyourownwebsiteinUbuntu"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Ubuntu에서 웹사이트 구축하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Ubuntu에서 웹사이트 구축하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Ubuntu에서 웹사이트 구축하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Raspberry Pi 5 온도 측정 가이드" href="/post/2024-06-23-GuidetoMeasureRaspberryPi5Temperature"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Raspberry Pi 5 온도 측정 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-GuidetoMeasureRaspberryPi5Temperature_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Raspberry Pi 5 온도 측정 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Raspberry Pi 5 온도 측정 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Raspberry Pi 5와 Coral TPU로 컴퓨터 비전 가속화 Part 1" href="/post/2024-06-23-AcceleratingCVwithaRaspberryPi5andCoralTPUPart1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Raspberry Pi 5와 Coral TPU로 컴퓨터 비전 가속화 Part 1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AcceleratingCVwithaRaspberryPi5andCoralTPUPart1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Raspberry Pi 5와 Coral TPU로 컴퓨터 비전 가속화 Part 1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Raspberry Pi 5와 Coral TPU로 컴퓨터 비전 가속화 Part 1</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="포트 포워딩 없이 어디서든 라즈베리 파이에 원격 접속하는 방법" href="/post/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="포트 포워딩 없이 어디서든 라즈베리 파이에 원격 접속하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="포트 포워딩 없이 어디서든 라즈베리 파이에 원격 접속하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">포트 포워딩 없이 어디서든 라즈베리 파이에 원격 접속하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="라즈베리 파이 피코 W 무료 시뮬레이터 사용 방법" href="/post/2024-06-23-RaspberryPiPicoPicoWFreeSimulator"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="라즈베리 파이 피코 W 무료 시뮬레이터 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-RaspberryPiPicoPicoWFreeSimulator_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="라즈베리 파이 피코 W 무료 시뮬레이터 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">라즈베리 파이 피코 W 무료 시뮬레이터 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="라즈베리 파이로 LED 깜빡이기 초보자용 간단 가이드" href="/post/2024-06-23-FoolproofBlinkaLedWithYourRaspberryPi"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="라즈베리 파이로 LED 깜빡이기 초보자용 간단 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FoolproofBlinkaLedWithYourRaspberryPi_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="라즈베리 파이로 LED 깜빡이기 초보자용 간단 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">라즈베리 파이로 LED 깜빡이기 초보자용 간단 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="블루투스를 사용하여 헤드리스 라즈베리 파이에 연결하는 방법" href="/post/2024-06-23-ConnecttoaheadlessRaspberryPiusingBluetooth"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="블루투스를 사용하여 헤드리스 라즈베리 파이에 연결하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ConnecttoaheadlessRaspberryPiusingBluetooth_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="블루투스를 사용하여 헤드리스 라즈베리 파이에 연결하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">블루투스를 사용하여 헤드리스 라즈베리 파이에 연결하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="라즈베리 파이 Cloudflare 터널 - DNS 라우팅을 사용해 내부 웹 서비스를 외부에 공개하는 방법" href="/post/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="라즈베리 파이 Cloudflare 터널 - DNS 라우팅을 사용해 내부 웹 서비스를 외부에 공개하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="라즈베리 파이 Cloudflare 터널 - DNS 라우팅을 사용해 내부 웹 서비스를 외부에 공개하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">라즈베리 파이 Cloudflare 터널 - DNS 라우팅을 사용해 내부 웹 서비스를 외부에 공개하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="라즈베리 파이 클러스터 설정 Kubernetes와 Airflow, Ansible 사용 방법" href="/post/2024-06-23-RaspberryPiClusterwithKubernetesandAirflowConfiguringAnsible"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="라즈베리 파이 클러스터 설정 Kubernetes와 Airflow, Ansible 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-RaspberryPiClusterwithKubernetesandAirflowConfiguringAnsible_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="라즈베리 파이 클러스터 설정 Kubernetes와 Airflow, Ansible 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">라즈베리 파이 클러스터 설정 Kubernetes와 Airflow, Ansible 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link posts_-active__YVJEi" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Docker와 QEMU 엣지 컴퓨팅 개발 가속화 및 코드 컴파일 최적화를 위한 강력한 조합","description":"","date":"2024-06-23 18:22","slug":"2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation","content":"\n\n![Docker \u0026 QEMU: 강력한 조합](/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png)\n\nQEMU는 호스트 시스템에서 가상 머신을 실행할 수 있는 타입-2 하이퍼바이저입니다. x86 및 ARM을 포함한 다양한 아키텍처를 에뮬레이트할 수 있습니다. qemu-system-aarch64 패키지는 AArch64 (ARM64) 시스템 에뮬레이터를 제공하며 CPU 및 다양한 주변장치를 에뮬레이트할 수 있습니다.\n\nRaspberry Pi용 코드를 컴파일하거나 테스트할 때, QEMU를 사용하여 x86 머신에서 AArch64 시스템을 모의 실행할 수 있습니다. 이는 개발자가 실제 Raspberry Pi를 가지고 있지 않아도 해당 코드를 컴파일하고 테스트할 수 있다는 것을 의미합니다. 이는 Jetson, Beaglebone 등 다른 엣지 디바이스에도 적용됩니다.\n\nRaspberry Pi용 코드를 컴파일하기 위해 QEMU를 사용하는 프로세스에는 qemu-system-aarch64 패키지를 사용하여 가상 머신을 설정한 다음 가상 머신에 필요한 도구 및 종속성을 설치하는 과정이 포함됩니다. ARM 아키텍처용 코드를 컴파일하는 데 필요한 GCC 컴파일러 및 기타 도구가 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라즈베리 파이용 코드를 컴파일하기 위해 QEMU를 사용하는 장점 중 하나는 일반적으로 라즈베리 파이보다 강력한 x86 머신에서 코드를 테스트하고 디버깅할 수 있다는 것입니다.\n\n![이미지](/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_1.png)\n\n도커 이미지 내에서 QEMU를 사용하면 라즈베리 파이용 코드를 컴파일하고 테스트하는 방법이 더욱 효율적이고 효율적해질 수 있습니다.\n\n도커 이미지는 가벼우며 휴대 가능하며 독립적인 컨테이너로, 어떤 머신에서도 쉽게 배포하고 실행할 수 있습니다. 라즈베리 파이용 코드를 컴파일하기 위한 필수 도구 및 종속성을 포함한 QEMU와 함께 도커 이미지를 생성하면 Docker가 설치된 모든 머신에서 이미지를 쉽게 실행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, PyTorch의 C++ 인터페이스 인 libtorch와 같은 대규모 라이브러리를 컴파일하는 것은 Raspberry Pi나 다른 엣지 장치에서 자원이 제한되기 때문에 상당한 시간이 소요될 수 있습니다. QEMU를 사용하여 Docker 이미지 내에서 AArch64 시스템을 x86 머신에서 에뮬레이션함으로써, 개발자는 x86 머신에서 사용 가능한 빠른 처리 속도와 코어 수를 활용하여 컴파일 시간을 크게 줄일 수 있습니다.\n\n예를 들어, 고속 CPU를 탑재한 10코어 x86 머신에서 Raspberry Pi에서 보통 4~5시간 소요되는 libtorch의 컴파일 시간이 30분으로 단축될 수 있습니다. 이는 개발자들에게 상당한 시간을 절약해줄 수 있습니다.\n\n이제 Raspberry Pi 4를 위한 libtorch 라이브러리 빌드 프로세스 예제를 살펴보겠습니다.\n\n호스트 머신 설정:\nDocker 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# QEMU 및 크로스 플랫폼 패키지 설치\nsudo apt-get install -y gcc-arm-linux-gnueabihf libc6-dev-armhf-cross qemu-user-static qemu-system-i386\n```\n\n```js\nFROM arm64v8/ubuntu:focal\n# 참고:\n# /usr/bin/qemu-system-aarch64를 로컬 bin 폴더로 복사\nCOPY ./bin/qemu-system-aarch64 /usr/bin/qemu-system-aarch64\n\nARG DEBIAN_FRONTEND=noninteractive\n\n# 기본적인 apt 업데이트\nRUN apt-get update \u0026\u0026 DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends locales ca-certificates \n \n# 로캘을 en_US.UTF-8로 설정(로캘이 없으면 Yocto 빌드 실패함)\nRUN locale-gen en_US.UTF-8 \u0026\u0026 update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nENV LANG en_US.UTF-8\nENV LC_ALL en_US.UTF-8\n\n# 기본 패키지 설치\nRUN apt-get update \u0026\u0026 apt-get install -y \\\n    apparmor \\\n    aufs-tools \\\n    automake \\\n    bash-completion \\\n    build-essential \\\n    cmake \\\n    curl \\\n    dpkg-sig \\\n    g++ \\\n    gcc \\\n    git \\\n    iptables \\\n    jq \\\n    libapparmor-dev \\\n    libc6-dev \\\n    libcap-dev \\\n    libsystemd-dev \\\n    libyaml-dev \\\n    mercurial \\\n    net-tools \\\n    parallel \\\n    pkg-config \\\n    golang-go \\\n    iproute2 \\\n    iputils-ping \\\n    vim-common \\\n    vim \\\n    --no-install-recommends \\\n    \u0026\u0026 apt-get clean \\\n    \u0026\u0026 rm -rf /var/lib/apt/lists/*\n\nRUN apt-get update \u0026\u0026 apt install -y software-properties-common \u0026\u0026 add-apt-repository main \u0026\u0026 add-apt-repository universe \u0026\u0026 add-apt-repository restricted \u0026\u0026 add-apt-repository multiverse\n\n# libtorch 의존성 설치\nRUN apt-get install -y clang ninja-build git cmake libjpeg-dev libopenmpi-dev libomp-dev ccache \\\n    libopenblas-dev libblas-dev libeigen3-dev \nRUN apt-get install -y python3-pip\nRUN pip3 install -U --user wheel mock pillow\nRUN pip3 install setuptools==58.3.0\n\n# 소스 코드 다운로드\nRUN mkdir ~/torch/ \u0026\u0026 cd ~/torch/ \u0026\u0026 \\\n    git clone -b v1.13.0 --depth=1 --recursive https://github.com/pytorch/pytorch.git \u0026\u0026 \\\n    cd pytorch \u0026\u0026 pip3 install -r requirements.txt\n\n# 컴파일 환경 변수 설정\nENV BUILD_CAFFE2_OPS=OFF\nENV USE_FBGEMM=OFF\nENV USE_FAKELOWP=OFF\nENV BUILD_TEST=OFF\nENV USE_MKLDNN=OFF\nENV USE_NNPACK=ON\nENV USE_XNNPACK=ON\nENV USE_QNNPACK=ON\nENV MAX_JOBS=12\nENV USE_NUMPY=ON\nENV USE_OPENCV=OFF\nENV USE_NCCL=OFF\nENV BUILD_SHARED_LIBS=ON\nENV PATH=/usr/lib/ccache:$PATH\nENV CC=clang\n\n# C++ torch 인터페이스 라이브러리(.so) 파일 빌드\nRUN cd ~/torch/pytorch/ \u0026\u0026 python3 tools/build_libtorch.py\n```\n\n```js\n# Docker 이미지 빌드\nsudo docker build --rm --tag arm64v8_libtorch -f arm64v8.Dockerfile .\n\n# 터미널 1\n# 컴파일된 패키지 실행 및 복사\nmkdir libtorch\nsudo docker run -v /etc/localtime:/etc/localtime:ro --rm -it -e http_proxy -e https_proxy -e ftp_proxy -v `pwd`:/work arm64v8_libtorch\n\n# 터미널 2\n# 실행 중인 컨테이너 ID 가져오기\nsudo docker ps\n\n# 터미널 3\n# 컨테이너에서 호스트 머신으로 파일 복사\nsudo docker cp 389143f92f85:~/torch/pytorch/torch/bin/ libtorch/\nsudo docker cp 389143f92f85:~/torch/pytorch/torch/lib/ libtorch/\nsudo docker cp 389143f92f85:~/torch/pytorch/torch/include/ libtorch/\nsudo docker cp 389143f92f85:~/torch/pytorch/torch/share/ libtorch/\n\n# 권한 설정\nsudo chmod -R 755 libtorch/* \n\n# 소유자 변경(scp용)\nsudo chown -R username:username libtorch\n\n# 이제 libtorch 폴더를 RPI로 복사할 수 있습니다\nscp -r libtorch/ ubuntu@static_ip_address:/home/ubuntu/\n``` \n\nDocker 이미지인 \"arm64v8_libtorch\"를 \"arm64v8.Dockerfile\" 파일을 사용하여 빌드합니다. \"--rm\" 플래그는 컨테이너가 종료될 때 자동으로 제거되도록 사용됩니다.\n\n터미널 1:\n\"arm64v8_libtorch\"이라는 빌드된 Docker 이미지를 실행하고 현재 디렉토리를 컨테이너 내의 볼륨으로 마운트합니다.\n\n터미널 2:\n실행 중인 컨테이너의 ID를 가져옵니다.\n\n터미널 3:\n1. 컨테이너에서 호스트 머신으로 파일을 복사합니다.\n2. \"libtorch\" 폴더 내의 모든 파일의 권한을 755로 변경합니다.\n3. \"libtorch\" 폴더 내의 모든 파일의 소유권을 현재 사용자 이름으로 변경합니다.\n\n터미널 4:\n\"libtorch\" 폴더를 scp를 통해 원격 머신[RPI4]으로 복사합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nROS2를 X86 호스트 시스템에서 RPI용으로 빌드하는 또 다른 예제를 확인해보세요.\n\n```js\nFROM arm64v8/ubuntu:focal\nCOPY ./bin/qemu-system-aarch64 /usr/bin/qemu-system-aarch64\n\nARG DEBIAN_FRONTEND=noninteractive\n\n# 기본적인 apt 업데이트\nRUN apt-get update \u0026\u0026 DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends locales ca-certificates \n \n# Yocto 빌드에 로캘이 설정되어 있지 않으면 빌드에 실패할 수 있으므로 로캘이 en_US.UTF-8로 설정됩니다.\nRUN locale-gen en_US.UTF-8 \u0026\u0026 update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nENV LANG en_US.UTF-8\nENV LC_ALL en_US.UTF-8\n\n# 기본 패키지 가져오기\nRUN apt-get update \u0026\u0026 apt-get install -y \\\n    apparmor \\\n    aufs-tools \\\n    automake \\\n    bash-completion \\\n    build-essential \\\n    cmake \\\n    curl \\\n    dpkg-sig \\\n    g++ \\\n    gcc \\\n    git \\\n    iptables \\\n    jq \\\n    libapparmor-dev \\\n    libc6-dev \\\n    libcap-dev \\\n    libsystemd-dev \\\n    libyaml-dev \\\n    mercurial \\\n    net-tools \\\n    parallel \\\n    pkg-config \\\n    golang-go \\\n    iproute2 \\\n    iputils-ping \\\n    vim-common \\\n    vim \\\n    --no-install-recommends \\\n    \u0026\u0026 apt-get clean \\\n    \u0026\u0026 rm -rf /var/lib/apt/lists/*\n\n...\n\n# 전체 흐름을 간략하게 말하자면, Docker와 QEMU는 엣지 컴퓨팅 개발을 가속화하고 코드 컴파일을 최적화하는 강력한 조합입니다. 이 설정을 통해 개발자들은 x86 기계의 빠른 처리 능력과 리소스를 활용하면서도 라즈베리파이나 젯슨과 같은 ARM 기반 에뮬레이터에서 코드를 테스트하고 디버깅할 수 있습니다. 이 접근 방식은 컴파일 시간을 크게 단축하고 개발 주기를 가속화할 수 있습니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 몇 가지 도커 예제를 여기에 만들어 놨어요. 참고용으로 활용하시면 좋을 것 같아요! 설정 프로세스에 대해 궁금한 점이 있거나 추가 도움이 필요하면 언제든지 알려주세요.\n\n흥미로운 기사나 업데이트는 항상 LinkedIn에 공유하고 있어요. 최신 소식을 받아보고 싶으시면 편하게 저를 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png"},"coverImage":"/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png","tag":["Tech"],"readingTime":7},{"title":"Ubuntu에서 웹사이트 구축하는 방법","description":"","date":"2024-06-23 18:21","slug":"2024-06-23-BuildingyourownwebsiteinUbuntu","content":"\n\n요즘 오렌지 파이를 샀는데 취미로 웹 서버를 만들어보기로 결정했어요. 만약 당신의 ISP가 공인 IP를 허용한다면, 온라인으로 접속할 수도 있을 거에요.\n\n# 프레임워크\n\n첫 번째로 해야 할 일은 서버를 실행할 웹 프레임워크를 설정하는 것이에요. 이 경우 빠른 테스트를 위해 파이썬을 사용하여 플라스크를 선택했어요. 다른 프레임워크인 장고, 노드.js나 다른 것을 이미 알고 계시다면 그것을 사용해도 돼요.\n\n저는 루트 디렉토리에 폴더를 만들어 시작하는 것부터 시작해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```shell\ncd /\nsudo mkdir sww\ncd /sww\nmkdir scripts\ncd /sww/scripts\nmkdir webserver\ncd /sww/scripts/webserver\n```\n\n다음으로 아래를 실행하여 파이썬 가상 환경을 만들 수 있어요\n\n```shell\npython3 -m venv .venv\n```\n\n다음으로 원하는 IDE(통합 개발 환경)나 텍스트 편집기를 사용할 수 있어요. 저는 Visual Studio Code를 사용해서 폴더를 여는 게 좋아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncode .\n```\n\n방금 만든 Python 가상 환경을 사용하도록 vscode를 설정할 거에요. ctrl+shift+p를 눌러 Python: Select Interpreter를 선택하면 이렇게 선택 목록이 열릴 거예요.\n\n![image](/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_0.png)\n\n현재 폴더에 있는 가상 환경을 선택한 후 터미널을 열면 (ctrl+shift+`) 이 접두사가 나와야 해요 (.venv)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 표현된 코드입니다.\n\n\n\u003cimg src=\"/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_1.png\" /\u003e\n\n다음은 터미널에서 이 코드를 실행하여 flask를 설치하는 방법입니다.\n\n```python\npython -m pip install flask\n```\n\n이 가이드를 따라하여 hello.py 파일을 생성합니다. 파일 내용은 아래와 같습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello_world():\n    return \"\u003cp\u003eHello, World!\u003c/p\u003e\"\n```\n\n그런 다음 이 명령어를 실행하여 플라스크를 시작하십시오.\n\n```bash\nflask run --app hello\n```\n\n웹 브라우저에서 localhost:5000을 열어주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_2.png\" /\u003e\n\n대박! 잘 됐어요! 안녕, 세계여!\n\n# Nginx\n\n다음으로는 Nginx를 설정하여 역방향 프록시를 처리할 거에요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 단계는 Nginx를 설치하는 것입니다.\n\n```js\nsudo apt update\nsudo apt install nginx\nsudo nginx -V\n```\n\n또한 웹 브라우저에서 localhost 또는 로컬 IP를 열어서 작동 여부를 확인할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n반드시 보안을 위해 방화벽을 설치하는 것을 잊지 마세요.\n\n```js\nsudo apt install ufw\nsudo ufw enable\nsudo ufw allow from \u003crouter_ip\u003e to any port 80\nsudo ufw allow from \u003crouter_ip\u003e to any port 443\n```\n\n라우터 IP를 입력해야 보안을 높일 수 있지만, 확실하지 않다면 'any'로 설정할 수 있어요. 어쨌든 나중에 액세스하려면 라우터 IP가 필요하답니다.\n\n다음으로, 서버를 온라인에서 액세스할 수 있도록 포트를 열어야 해요. 라우터 IP 주소로 이동해서 로컬 머신 IP 주소를 찾으세요. 저의 경우에는 192.168.20.4예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_4.png\" /\u003e\n\n그런 다음 라우터가 가지고 있는 포트 포워딩 또는 NAT(라우터에 따라 다를 수 있음) 중 하나로 이동합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_5.png\" /\u003e\n\n서비스 이름, 로컬 머신 IP 주소 및 포트를 입력한 후 저장을 누릅니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Screenshot](/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_6.png)\n\nOnce done, it should look like this. Please note that the display may vary depending on the router and brand.\n\n# Test\n\nAfter setting up nginx and opening the port, you can test accessing your machine online by searching for your public IP on Google as shown below:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_7.png)\n\n만약 작동하면 nginx 환영 페이지를 가리켜야합니다.\n\n# Nginx 사이트\n\nNginx가 작동하면 사이트를 설정할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\ncd /etc/nginx/sites-enabled\nsudo touch webserver\nsudo gedit webserver\n```\n\n위 명령을 입력하면 gedit 텍스트 편집기에서 webserver 파일이 열릴 겁니다. 아래 코드를 입력하고 저장하세요.\n\n```js\nserver {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n    server_name _;\n\n    root /sww/scripts/webserver;\n\n    location / {\n        proxy_pass http://localhost:5000/;\n        proxy_buffering off;\n        proxy_http_version 1.1;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection $http_connection;\n    }\n}\n```\n\n그런 다음 Nginx 서버를 재시작하고 브라우저를 새로고침하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nsudo systemctl restart nginx.service\n\n\n![Building your own website in Ubuntu](/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_8.png)\n\n지금은 플라스크 웹 서버를 가리키도록 설정되어 있습니다. 그러면 계속 작업을 계속할 수 있어요 :)\n\n다음 단계는 기억에 남을 주소로 이를 도메인에 연결하는 것인데, 이에 대해 다른 문서에서 다룰 것입니다. 그때까지 안녕히 계세요! 👋\n","ogImage":{"url":"/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_0.png"},"coverImage":"/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_0.png","tag":["Tech"],"readingTime":5},{"title":"Raspberry Pi 5 온도 측정 가이드","description":"","date":"2024-06-23 18:20","slug":"2024-06-23-GuidetoMeasureRaspberryPi5Temperature","content":"\n\n라즈베리 파이 5의 온도를 이해하는 것은 중요합니다, 특히 고부하 작업 중일 때에는 더욱 중요합니다. 라즈베리 파이 5의 온도를 측정하는 데 도움이 되는 단계별 안내서가 여기 있습니다:\n\n# 소개:\n\n- 라즈베리 파이 5는 일반적으로 자주 사용하는 조건 하에서 이전 모델인 라즈베리 파이 4보다 더 적게 발열합니다. 그러나 지속적인 고부하 과업 시에는 열 쓰로틀링이 발생할 수 있습니다.\n- 열 쓰로틀링은 소프트웨어가 일정한 온도 이상일 때 CPU 속도를 제한하는 기능입니다. 쓰로틀링 상태에서도 라즈베리 파이 5는 라즈베리 파이 4보다 우수한 성능을 발휘합니다.\n\n# CPU 온도 측정 방법:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nvcgencmd 명령어 사용하기:\n\n- vcgencmd 명령어를 사용하면 Raspberry Pi의 성능에 관한 소중한 정보를 얻을 수 있습니다.\n- Python 바인딩을 사용하면 온도를 포함한 다양한 매개변수를 프로그래밍 방식으로 모니터링할 수 있습니다.\n\nPython 스크립트:\n\n- 제공된 코드를 사용하여 온도, CPU 클록 속도 및 현재 쓰로틀링 상태를 모니터링하고 기록하는 Python 스크립트를 작성합니다.\n- 이 스크립트는 readings.txt라는 파일에 측정값을 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nimport sys\nimport os\nimport time\nfrom vcgencmd import Vcgencmd\n\ndef main():\n    start_time = time.time()\n    fb = open(\"/home/pi/readings.txt\",\"a+\")\n    fb.write(\"경과 시간 (초),온도 (°C),클럭 속도 (MHz),쓰로틀\\n\")\n    vcgm = Vcgencmd()\n    while True:\n        temp = vcgm.measure_temp()\n        clock = int(vcgm.measure_clock('arm')/1000000)\n        throttled = vcgm.get_throttled()['breakdown']['2']\n\n        string = '%.0f,%s,%s,%s\\n' % ((time.time() - start_time),temp,clock,throttled)\n        print(string, end='')\n        fb.write(string)\n        time.sleep(1)\n\nif __name__ == '__main__':\n    main()\n```\n\n스트레스 테스팅:\n\n- 터미널 창을 열고 스크립트를 실행합니다.\n- 다른 터미널 창에서 stress 도구를 사용하여 모든 CPU 코어에 대한 스트레스 테스트를 시작합니다:\n\n```bash\n$ sudo apt install stress\n$ stress --cpu 4\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 무거운 작업을 가하며 CPU 온도가 증가합니다.\n\n쓰로틀링 제한:\n\n- 라즈베리 파이 보드는 프로세서를 80°C에서 쓰로틀링합니다.\n- 85°C에서 추가 쓰로틀링이 발생하여 손상을 방지합니다.\n\n냉각 없는 경우 관측:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 냉각 없이 Raspberry Pi 5의 유휴 온도는 약 65°C 정도입니다.\n- 스트레스 테스트와 같은 강도 높은 활동 중에는 온도가 상승하여 85°C 열 한계를 약간 넘어서 안정화되기도 합니다. 이는 지속적인 열 추소를 유발할 수 있습니다.\n\n# 결론:\n\n동영상 시청 또는 데스크톱 작업과 같은 일반적인 활동은 CPU에 크게 부담을주지 않을 수 있지만, 냉각 없이 중대하고 지속적인 부하를 가할 경우 Raspberry Pi 5를 열 한계에 끌어올릴 수 있습니다. 온도를 모니터링하면 냉각 솔루션을 추가할 필요가 있는지에 대한 판단을 내릴 수 있습니다.\n\n본문의 저자는 Amazon Services LLC Associates Program의 참여자로, 이는 광고 수익을 제공하기 위해 디자인된 제품을 Amazon.com에 광고하고 링크하는 제휴 광고 프로그램입니다. 이 말은 우리의 링크를 통해 제품을 구매할 때마다 추가 비용없이 소액의 커미션을 벌 수 있다는 뜻입니다.","ogImage":{"url":"/assets/img/2024-06-23-GuidetoMeasureRaspberryPi5Temperature_0.png"},"coverImage":"/assets/img/2024-06-23-GuidetoMeasureRaspberryPi5Temperature_0.png","tag":["Tech"],"readingTime":3},{"title":"Raspberry Pi 5와 Coral TPU로 컴퓨터 비전 가속화 Part 1","description":"","date":"2024-06-23 18:18","slug":"2024-06-23-AcceleratingCVwithaRaspberryPi5andCoralTPUPart1","content":"\n\nRaspberry Pi 5은 PCIe 인터페이스를 갖추고 있어 주변 장치에 고속 하드웨어 연결이 가능합니다. 이는 이제 Google의 Coral TPU를 Pi에 연결하고 초고속 컴퓨터 비전을 얻는 것이 가능하다는 것을 의미합니다. 이 튜토리얼에서는 TPU를 구성하고 TPU에 MobileNet을 배포하여 224x224 크기의 이미지에 대한 추론 속도를 2.5밀리초(!)로 얻는 과정을 안내해 드리겠습니다.\n\n우리는 pineboard의 Hat AI 보드를 사용하여 TPU를 Pi에 PCIe로 연결했습니다:\n\n![이미지](/assets/img/2024-06-23-AcceleratingCVwithaRaspberryPi5andCoralTPUPart1_0.png)\n\n이 첫 번째 튜토리얼에서는 Pi가 Coral TPU를 인식할 수 있도록 커널을 구성하는 과정을 안내해 드리겠습니다. 이 내용은 Jeff Geerling의 작업을 요약한 것이며 저 자신이 작동시키기 위해 몇 가지 조정이 필요했습니다. 그의 작업이 없었더라면 저는 결코 이것을 이해하지 못했을 것입니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코랄 TPU는 호스트 OS가 4K 페이지 크기여야한다고 요구합니다. 나는 그 이유가 코랄이 직접 메모리 액세스(DMA)를 수행할 수 있어서 Pi의 RAM에 CPU 개입없이 직접 접근할 수 있기 때문일 것으로 의심합니다. 이는 고정된 페이지 크기가 필요하기 때문에 발생합니다. 기본 라즈베리 파이 OS는 16k 페이지 크기로 제공되지만, 다음 명령어로 확인할 수 있습니다: getconf PAGE_SIZE .\n\n이제 4K 커널을 설치하기 위해 여러 옵션이 있습니다:\n\n- 아마도 4K 커널은 이미 Pi에 16K 커널과 함께 설치되어 있을 것이므로, /boot/firmware에 kernel8.img 파일이 있는지 확인할 수 있습니다. 이 파일이 있다면, /boot/firmware/config.txt 파일 가장 아래에 kernel=kernel8.img 라인을 추가하여 Pi가 이 커널을 부팅하도록 지시할 수 있습니다. 다음으로 시스템에 커널 헤더를 설치해야 합니다: 나중에 gasket 드라이버를 컴파일하기 위해 sudo apt install linux-headers-$(uname -r) 명령어를 실행해 주세요.\n- 또는 공식 지침을 따라 Pi에 새로운 4K 커널을 다운로드, 빌드 및 설치할 수 있습니다. 이 옵션은 Pi 내에서 언제든지 커널을 빌드할 수 있어 가장 유연합니다. 나중에 TPU 드라이버를 빌드하기 위해 필요한 커널 헤더도 자동으로 설치됩니다.\n- 마지막으로, PI 웹 사이트에서 설명하는 대로 커널을 크로스 컴파일할 수도 있습니다. 작동하는 커널을 얻지만, 데비안 도커 컨테이너 내에서 크로스 컴파일할 때 컴파일러 불일치로 인해 나중에 TPU 드라이버를 컴파일하는 데 문제가 있었습니다. 크로스 컴파일 중에 정확히 동일한 컴파일러를 사용해도 형식 실행 오류로 인해 드라이버를 성공적으로 컴파일할 수 없었습니다. 이 옵션을 작동시킨 경우 댓글로 남겨주세요 :)\n\n라즈베리 파이는 하드웨어를 커널에 설명하기 위해 디바이스 트리를 사용합니다. 우리는 커널에 PCIe 인터페이스를 사용하고 싶다고 알리기 위해 dtparam(디바이스 트리 매개변수)를 설정해야합니다. 다음과 같은 라인을 /boot/firmware/config.txt 파일에 추가하여 이 작업을 수행할 수 있습니다(가장 아래에 추가):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n해당 테이블은 마크다운 형식으로 변경되었습니다.\n\n```js\ndtparam=pciex1\ndtparam=pciex1_gen=2 # 이는 속도를 설정합니다. 최대 3까지 설정할 수 있습니다.\n```\n\nTPU를 위해 활성 상태 전원 관리(ASPM)를 비활성화해야 한다고 하는군요. 이를 위해 /boot/firmware/cmdline.txt 파일에서 rootwait 바로 앞에 pcie_aspm=off를 추가하여 수행할 수 있습니다.\n\n재부팅한 후 lspci 명령을 실행하면 TPU가 목록에 표시될 것입니다.\n\n이제 커널이 TPU의 존재를 인식했지만, 상호 작용하려면 커널 드라이버가 필요합니다. 이는 사용자 응용 프로그램이 안전 상의 이유로 하드웨어와 직접 통신하는 것을 허용하지 않기 때문에 필요한 조치입니다. 모든 하드웨어 상호 작용은 시스템 호출을 통과해야 하며, 이를 통해 프로그램 실행이 커널 모드로 이동하여 하드웨어에 안전하게 액세스할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코랄 TPU 드라이버는 Google Gasket(Google ASIC 소프트웨어, 커널 익스텐션 및 도구) 드라이버와 TPU 드라이버 소프트웨어인 libedgetpu로 구성됩니다.\n\nLibedgetpu는 APT(Advanced Package Tool) 패키지 관리자를 통해 설치할 수 있습니다. libedgetpu의 소스를 소스 목록 파일에 추가하면 apt가 패키지를 찾을 때 스캔하는 것이 필요합니다. 또한 패키지의 무결성을 확인하기 위해 SHA 키를 추가해야 합니다:\n\n```bash\nsudo apt update\necho \"deb https://packages.cloud.google.com/apt coral-edgetpu-stable main\" | sudo tee /etc/apt/sources.list.d/coral-edgetpu.list\ncurl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -\nsudo apt-get update\nsudo apt-get install libedgetpu1-std\n```\n\n그런 다음 시스템에 Gasket 커널 모듈을 설치해야 합니다. 이를 위한 하나의 방법은 커널 소스 트리에 소스 코드를 추가하고 커널 드라이버로 컴파일하는 것입니다(이 방법으로 성공하지 못했지만 가능할 것으로 생각됩니다). 그러나 이를 수행하는 선호되는 방법은 DKMS(Dynamic Kernel Support Module)를 사용하는 것입니다. DKMS를 사용하면 소스 코드가 기본적인 커널 소스 외부에 있는 커널 모듈을 빌드할 수 있습니다. 이 방법의 추가적인 장점은 새 커널이 설치될 때 자동으로 모듈을 다시 빌드한다는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsudo apt install -y devscripts debhelper  # dkms 종속성 설치\nsudo apt install dkms \nsudo apt-get install dh-dkms # dkms 도우미 모듈\n```\n\n이제 공식 가스켓 드라이버를 다운로드하고 설치하기 위해 필요한 모든 종속성이 준비되었습니다:\n\n```js\n# 가스켓 드라이버 리포지토리 복제\nsudo git clone https://github.com/google/gasket-driver.git\ncd gasket-driver\nsudo debuild -us -uc -tc -b # 가스켓 드라이버 패키지 빌드\ncd .. \nsudo dpkg -i gasket-dkms_1.0-18_all.deb\n```\n\nexec 포맷 오류(컴파일러 불일치)로 .deb 패키지를 여러 번 설치하는 데 문제가 생겼다고 해요. 나는 Pi에서 커널을 빌드하고 로컬로 설치하여 이 문제를 해결했다고 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n커널 드라이버는 하드웨어를 응용 프로그램에 노출시켜 /dev 하위에 장치로 노출시킴으로써 하드웨어를 노출합니다. TPU에 대한 사용자 프로그램의 액세스를 수동으로 허용해야 합니다. /dev/apex 장치를 통해 TPU에 접근할 수 있도록 해야 합니다. (왜 'apex'이라고 불리는지 전혀 모르겠습니다):\n\n```js\nsudo sh -c \"echo 'SUBSYSTEM==\\\"apex\\\", MODE=\\\"0660\\\", GROUP=\\\"apex\\\"' \u003e\u003e /etc/udev/rules.d/65-apex.rules\"\nsudo groupadd apex\nsudo adduser $USER apex\n```\n\n이 과정의 마지막 단계는 TPU로부터 인터럽트를 처리하는 인터럽트 컨트롤러를 변경하는 것입니다. TPU는 MSI (Message Signaled Interrupts)를 사용하는데, 이는 일반적인 인터럽트 (IRQ)와 다르게 인터럽트 레지스터가 CPU의 IO 레지스터로 메모리 매핑된다는 면에서 다릅니다 (제대로 이해했다면요). 커널 6.6.30부터는 이를 /boot/firmware/config.txt 파일에 추가할 dtoverlay를 통해 쉽게 변경할 수 있습니다: dtoverlay=pineboards-hat-ai . 재부팅하면 CV 모델을 TPU에 배포할 준비가 끝납니다!\n\n그러나 이전 버전의 커널을 사용하고 있다면, 장치 트리 소스 코드에서 msi-parent 속성을 수동으로 변경해야 합니다. 커널을 처음부터 컴파일했다면 커널 소스 코드에서 직접 소스 코드를 변경할 수 있지만, 그렇지 않으면 먼저 컴파일된 .dtb (장치 트리 바이너리) 파일을 .dts (장치 트리 소스) 파일로 디컴파일해야 합니다. 그런 다음 msi-parent를 phandle의 값으로 변경해야 합니다. 제 경우에는 0x6e였지만, 이 값은 변경될 수 있습니다. 소스 코드를 찾아보면 해당 값이 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-23-AcceleratingCVwithaRaspberryPi5andCoralTPUPart1_1.png)\n\n```js\nsudo cp /boot/firmware/bcm2712-rpi-5-b.dtb /boot/firmware/bcm2712-rpi-5-b.dtb.bak\nsudo dtc -I dtb -O dts /boot/firmware/bcm2712-rpi-5-b.dtb -o ~/test.dts\nsudo sed -i '/pcie@110000 {/,/};/{/msi-parent = \u003c[^\u003e]*\u003e;/{s/msi-parent = \u003c[^\u003e]*\u003e;/msi-parent = \u003c0x6e\u003e;/}' ~/test.dts\nsudo dtc -I dts -O dtb ~/test.dts -o ~/test.dtb\nsudo mv ~/test.dtb /boot/firmware/bcm2712-rpi-5-b.dtb\nsudo reboot now\n```\n\n다음 튜토리얼에서 TPU에서 Mobilenet을 훈련하고 실행할 거에요.\n\n소스:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- [https://gist.github.com/dataslayermedia/714ec5a9601249d9ee754919dea49c7e](https://gist.github.com/dataslayermedia/714ec5a9601249d9ee754919dea49c7e)\r\n- [https://www.jeffgeerling.com/blog/2023/pcie-coral-tpu-finally-works-on-raspberry-pi-5](https://www.jeffgeerling.com/blog/2023/pcie-coral-tpu-finally-works-on-raspberry-pi-5)","ogImage":{"url":"/assets/img/2024-06-23-AcceleratingCVwithaRaspberryPi5andCoralTPUPart1_0.png"},"coverImage":"/assets/img/2024-06-23-AcceleratingCVwithaRaspberryPi5andCoralTPUPart1_0.png","tag":["Tech"],"readingTime":6},{"title":"포트 포워딩 없이 어디서든 라즈베리 파이에 원격 접속하는 방법","description":"","date":"2024-06-23 18:17","slug":"2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding_0.png\" /\u003e\n\n안녕하세요! 이 블로그에서는 포트 포워딩 없이 인터넷을 통해 어디서나 안전하게 Raspberry Pi나 IoT 장치에 원격으로 연결하는 방법에 대해 알아보겠습니다. 이를 통해 장치를 더 효과적으로 원격으로 관리할 수 있습니다.\n\nRaspberry Pi는 인기 있는 싱글 보드 컴퓨터(SBC)로 다양한 프로젝트에 적합한 소형, 저전력 장치입니다.\n\n하지만 제대로 관리되지 않으면 이러한 장치는 부담이 될 수 있고 고객 이탈을 야기하여 수익 손실로 이어질 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNAT 라우터나 방화벽을 통한 포트 포워딩은 외부 네트워크에서 인터넷을 통해 라즈베리 파이에 원격으로 액세스하는 것에 안전하지 않은 방법입니다. 포트 스캐너와 해커들이 당신의 라즈베리 파이나 IoT 디바이스에 접근할 수도 있습니다.\n\n이 글에서는 다음을 설정하지 않고 원격 액세스를 위한 라즈베리 파이를 구성하는 방법을 설명하겠습니다:\n\n- 포트 포워딩 없이 인터넷을 통해 SSH를 이용한 라즈베리 파이 원격 액세스\n- 포트 포워딩 없이 VNC를 이용한 라즈베리 파이 GUI 데스크톱 원격 액세스\n- 포트 포워딩 없이 RDP를 이용한 라즈베리 파이 GUI 데스크톱 원격 액세스\n- 포트 포워딩 없이 웹 애플리케이션을 통한 라즈베리 파이 원격 액세스\n- 포트 포워딩 없이 라즈베리 파이에 원격으로 명령어 실행\n- 포트 포워딩 없이 라즈베리 파이에 원격으로 명령어 실행\n\n우리는 SocketXP IoT 관리 및 원격 액세스 플랫폼을 사용하여 포트 포워딩 없이 인터넷을 통해 라즈베리 파이에 원격으로 연결할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSocketXP를 사용하면 NAT 라우터 및 방화벽 뒤에 있는 Raspberry Pi에 대해 외부 네트워크(인터넷과 같은)에서 원격으로 연결할 수 있어요.\n\n# SocketXP란\n\nSocketXP는 Raspberry Pi, Nvidia Jetson 또는 IoT 기기와 같은 임베디드 리눅스 장치를 인터넷을 통해 엑세스, 관리 및 디버그할 수 있도록 하는 클라우드 기반 안전한 원격 액세스 솔루션입니다. SocketXP는 안전한 SSL/TLS 연결을 통해 Raspberry Pi에 안전한 원격 액세스를 제공해요.\n\nSocketXP 솔루션을 작동시키려면 집이나 사무실 라우터에서 구성 변경이 필요하지 않아요. 공용 IP가 필요하지 않아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그냥 상자에서 작동합니다.\n\nSocketXP는 SSL/TLS 역방향 프록시 터널을 만들어 원격 장치에 안전하게 연결합니다.\n\nSocketXP는 라즈베리 파이에 원격 액세스를 제공하기 위해 포트 포워딩 기술이나 다이내믹 DNS(DDNS)와 같은 보안이 취약한 방법을 사용하지 않습니다.\n\nSocketXP는 안정된 원격 액세스를 제공하기 위해 전 세계 수천 명의 고객에게 신뢰받는 기업용 IoT 원격 액세스 및 관리 플랫폼입니다.네트워크 외부의 어디에서나 인터넷을 통해 라즈베리 파이에 안전하게 원격 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작해 봅시다.\n\n## 1. NAT 라우터 또는 방화벽 뒤에 있는 Raspberry Pi에 SSH를 사용하여 인터넷을 통해 원격으로 연결하기\n\n**Secure Shell (SSH)**는 인터넷과 같은 보안되지 않은 네트워크를 통해 라즈베리 파이의 터미널에 안전하게 연결할 수 있는 네트워크 프로토콜입니다.\n\nSSH는 클라이언트 서버 모델을 따릅니다. SSH 서버는 라즈베리 파이에서 실행되고 SSH 클라이언트는 사용자 노트북이나 PC에서 실행됩니다. SSH 서버는 기본적으로 TCP 포트 22에서 수신 대기합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOpenSSH은 SSH 서버 및 클라이언트 소프트웨어의 오픈 소스 구현을 제공합니다.\n\n참고: 라즈베리 파이에는 SSH 서버 소프트웨어가 설치되어 있습니다.\n\nSSH 클라이언트는 SSH 서버가 실행되는 기기의 IP 주소를 알아야하므로 해당 기기에 연결할 수 있습니다.\n\n인터넷에서 라즈베리 파이의 터미널에 SSH를 통해 원격으로 연결하려면 NAT 라우터와 방화벽 뒤에 설치된 라즈베리 파이 장치는 인터넷에서 액세스할 수 없습니다. SocketXP 라즈베리 파이 원격 액세스 솔루션을 사용하여 어디서든 인터넷을 통해 라즈베리 파이 터미널에 원격으로 연결할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding_1.png)\n\n자세한 내용을 알아보려면 인터넷을 통해 Raspberry Pi에 대한 원격 SSH 액세스를 설정하고 구성하는 방법을 참조하십시오.\n\n# 2. VNC를 사용하여 인터넷을 통해 Raspberry Pi에 원격으로 연결하기\n\n가상 네트워크 연결(VNC)은 Raspberry Pi의 그래픽 사용자 인터페이스(GUI) 또는 데스크톱에 안전하게 액세스하는 프로토콜입니다. VNC는 일반적으로 Raspberry Pi와 같은 Linux 기반 플랫폼의 GUI에 원격으로 액세스하는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVNC은 클라이언트 서버 모델을 따릅니다. VNC 서버는 라즈베리 파이에서 실행되고 VNC 클라이언트는 사용자 노트북이나 PC에서 실행됩니다. VNC 서버는 기본적으로 TCP 포트 5901에서 수신 대기합니다.\n\nTightVNC은 라즈베리 파이에 설치할 수 있는 오픈 소스 기반 VNC 소프트웨어입니다. 원격 데스크톱 액세스를 위해 사용됩니다.\n\n인터넷에서 어디에서나 VNC를 통해 라즈베리 파이 GUI 데스크톱에 원격으로 연결하려면 네트워크 주소 변환 라우터(NAT router)와 방화벽 뒤에 설치된 라즈베리 파이 장치에 대한 액세스를 SocketXP 라즈베리 파이 원격 액세스 솔루션을 사용하여 실행해야 합니다.\n\n![이미지](/assets/img/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같이 참조하세요: Raspberry Pi를 인터넷을 통해 원격 VNC 접속을 설정하고 구성하는 방법에 대해 알아보세요.\n\n# 3. xrdp를 사용하여 인터넷을 통해 Raspberry Pi 원격 데스크톱(RDP)에 연결하기\n\n원격 데스크톱 프로토콜(RDP)은 마이크로소프트에서 발명한 프로토콜로, 지역 네트워크에서 한 Windows 기기의 Windows 데스크톱에 다른 Windows 기기에서 액세스하는 데 사용됩니다.\n\nRDP는 클라이언트-서버 모델을 따릅니다 - RDP 서버는 라즈베리 파이에서 실행되며 RDP 클라이언트는 사용자의 노트북이나 PC에서 실행됩니다. RDP 서버는 기본적으로 TCP 포트 3389에서 수신 대기합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마이크로소프트가 타사가 동일한 것을 구현할 수 있도록 RDP를 개방했습니다. xrdp는 Microsoft RDP의 오픈 소스 구현입니다. xrdp는 주로 라즈베리 파이와 같은 리눅스 기반 플랫폼의 GUI 데스크톱에 원격으로 접속하는 데 사용됩니다.\n\n인터넷에서 Raspberry Pi 장치에 액세스 할 수 없는 NAT 라우터 및 방화벽 뒤에 설치된 경우, SocketXP Raspberry Pi 원격 액세스 솔루션을 사용하여 어디에서나 인터넷을 통해 xrdp를 사용하여 Raspberry Pi GUI 데스크톱에 원격으로 연결할 수 있습니다.\n\n자세한 내용은 다음을 참조하십시오: xrdp를 사용하여 인터넷을 통한 라즈베리 파이 원격 데스크톱 액세스 설정 및 구성 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 웹 앱을 사용하여 NAT 라우터 또는 방화벽 뒤에 있는 Raspberry Pi 원격 제어하기\n\n라즈베리 파이에 IoT 웹 애플리케이션을 설치하고 실행하면 웹 클라이언트를 사용하여 Raspberry Pi에 원격으로 연결하고 제어할 수 있습니다.\n\n예를 들어, 간단한 파이썬 Flask 웹 서버 애플리케이션을 작성하여 원격으로 파일에 액세스할 수 있습니다. 이미지, 웹캠에서 비디오, 구성 파일, 로그 파일 등을 가져올 수 있습니다.\n\n```js\n$ cat get_files.py\nfrom flask import Flask, send_from_directory\n\napp = Flask(__name__) @app.route('/')\n\ndef send_report(path):\n    return send_from_directory('/', path)\n\nif __name__ == '__main__':\n    app.run(host='127.0.0.1', port=3000, debug=True)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라즈베리 파이에서 실행 중인 웹 서버 애플리케이션에 로컬 네트워크에서 웹 브라우저를 사용하여 액세스할 수 있습니다. http://localhost:3000 주소로 브라우저를 열어보세요.\n\n다만, NAT 라우터와 방화벽 뒤에 설치된 라즈베리 파이는 인터넷에서 액세스할 수 없습니다.\n\nSocketXP 라즈베리 파이 원격 액세스 솔루션을 사용하여 어디서나 인터넷을 통해 파이썬 플라스크 웹 서버 애플리케이션에 원격으로 연결할 수 있습니다.\n\nSocketXP는 라즈베리 파이에서 실행 중인 로컬 웹 앱을 위한 안전한 공개 웹 URL(HTTPS)을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 변경되었습니다.\n\n\n![Raspberry Pi Remote Access](/assets/img/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding_4.png)\n\nTo learn more, refer to: [how to remote access Raspberry Pi web app over the internet]\n\n## 5. Send Remote Commands to Raspberry Pi over the Internet from Outside Network\n\nRemote Command Execution: the ability to send one-off shell commands to your Raspberry Pi to quickly fetch crucial information or take some corrective action on your remote Raspberry Pi is immensely important.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라즈베리 파이에 항상 로그인하고 명령이나 프로그램을 실행하기 위해 로그인과 비밀번호를 사용하는 것은 번거로울 수 있습니다.\n\n특히 라즈베리 파이 편대에 동일한 스크립트나 명령을 실행해야 하는 경우 더욱 귀찮아집니다.\n\nSocketXP 라즈베리 파이 원격 액세스 솔루션을 통해 인터넷을 통해 하나의 라즈베리 파이나 라즈베리 파이 편대에 대해 원격으로 셸 스크립트, 명령 또는 Python 프로그램을 실행할 수 있습니다.\n\n자세한 내용은 인터넷을 통한 원격 명령 실행을 위해 라즈베리 파이를 설정하고 구성하는 방법을 참조하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론:\n\n이 글에서는 SSH, VNC, RDP, 웹 앱 및 원격 명령 실행을 사용하여 포트 포워딩 없이 어디서든 Raspberry Pi에 원격으로 액세스할 수 있는 5가지 다양한 옵션을 살펴보았습니다.\n\n또한 SocketXP의 Raspberry Pi 원격 액세스 솔루션이 포트 포워딩을 활성화하지 않고 Raspberry Pi 기기를 원격으로 관리하고 제어하는 안전하고 강력하며 편리한 방법을 제공한다는 것에 대해 논의했습니다.\n\n사용하기 쉬운 인터페이스, 고급 기능 및 타의 추종을 불허하는 유연성을 갖춘 이 혁신적인 솔루션은 Raspberry Pi 애호가에게 꼭 필요한 도구입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 절삭 즉석 솔루션을 활용하고 Raspberry Pi 장치의 모든 잠재력을 발휘해보세요. 어디에서나 Raspberry Pi 프로젝트를 제어할 수 있는 SocketXP의 Raspberry Pi 원격 액세스 솔루션을 시도해보세요.\n\n원문은 https://www.socketxp.com/iot/access-raspberry-pi-remotely-over-the-internet/에서 확인하실 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding_0.png"},"coverImage":"/assets/img/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding_0.png","tag":["Tech"],"readingTime":7},{"title":"라즈베리 파이 피코 W 무료 시뮬레이터 사용 방법","description":"","date":"2024-06-23 18:16","slug":"2024-06-23-RaspberryPiPicoPicoWFreeSimulator","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-RaspberryPiPicoPicoWFreeSimulator_0.png\" /\u003e\n\n요즘, 라즈베리 파이 Pico 및 Pico W에서 코딩을 더 쉽게할 수 있는 유용한 도구를 발견했어요. wokwi.com에서 제공하는 무료 온라인 시뮬레이터인 Wokwi를 이용하면 물리 하드웨어가 필요하지 않은 채로 프로젝트를 쉽게 시뮬레이션할 수 있어요.\n\n이 시뮬레이터를 통해 코드를 작성하고 테스트할 뿐만 아니라 다양한 외부장치 추가, 인터넷 연결, 그리고 어느 정도 실제 환경을 모방하여 전체적인 리얼 라이프 설정을 시뮬레이션할 수 있어요. 이는 프로젝트를 실제 하드웨어에 배포하기 전 가상 환경에서 실험하고 디버깅하여 완벽하게 만들 수 있게 해줍니다. 때로는 시간과 자원을 절약할 수도 있어요. 초보자든 숙련된 개발자든, Wokwi는 라즈베리 파이 Pico와 Pico W 개발 경험을 향상시킬 수 있는 강력한 플랫폼을 제공해요.\n\n이 주제를 탐구하기 전, 우리의 지속적인 노력을 지원하고 여러분의 IoT 프로젝트를 향상시키기 위해 전용 플랫폼을 탐험해보라고 여러분을 초대해요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- YouTube 채널을 구독해주세요: Shilleh의 YouTube 채널에서 최신 튜토리얼과 프로젝트 통찰력을 확인하고 업데이트 받아보세요.\n- 저희를 지원해주세요: 여러분의 지원은 소중합니다. Buy Me A Coffee에서 커피 한 잔 사주시면 품질 높은 콘텐츠 제작을 이어갈 수 있습니다.\n- 전문 IoT 서비스를 고용해보세요: IoT 프로젝트에 대한 맞춤 지원이 필요하시다면 UpWork에서 저를 고용해주세요.\n\nShillehTek 웹사이트 (특별 할인):\n\n[ShillehTek 웹사이트로 이동](https://shillehtek.com/collections/all)\n\nShillehTek 아마존 스토어:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nShillehTek 아마존 스토어 — 미국\n\nShillehTek 아마존 스토어 — 캐나다\n\nShillehTek 아마존 스토어 — 일본\n\n# 단계 1: Wokwi에 접속하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Wokwi 방문: wokwi.com에 방문하여 무료 계정을 생성하세요. 이미 한 번도 방문한 적이 없다면 계정없이 시작할 수도 있습니다.\n- Simulator 살펴보기: 인터페이스를 익히세요. 새 프로젝트 생성, 템플릿 보기, 예제 탐색 옵션을 볼 수 있습니다. Pico만 선택해야 하는 것은 아니며 다른 컨트롤러도 선택할 수 있습니다.\n\n![그림](/assets/img/2024-06-23-RaspberryPiPicoPicoWFreeSimulator_1.png)\n\n# 단계 2: 프로젝트 만들기\n\n다양한 템플릿 프로젝트를 선택할 수 있습니다. 이 중 하나는 Pico SDK를 사용한 Blink LED 프로젝트입니다. C 언어를 위한 Pico SDK 설정은 초보자에게는 어려울 수 있지만 설정이 쉽게 가능한 환경에 액세스할 수 있다면, 시작하는 사람들에게 상당한 이점이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-RaspberryPiPicoPicoWFreeSimulator_2.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-RaspberryPiPicoPicoWFreeSimulator_3.png\" /\u003e\n\n스크립트를 실행하면 오른쪽의 라즈베리 파이가 코드 지시에 따라 주기적으로 깜빡입니다.\n\n그런 다음 IDE에서 MicroPython으로 동일한 기능을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1-) 다음 코드를 복사하여 붙여넣으세요:\n\n```js\n# Raspberry Pi Pico에서 LED를 깜박이게 하는 MicroPython 스크립트\n\nfrom machine import Pin\nimport time\n\n# 기본 LED 핀을 사용할 수 있는지 확인합니다.\ntry:\n    LED_PIN = Pin(Pin.PICO_DEFAULT_LED_PIN, Pin.OUT)\nexcept AttributeError:\n    # PICO_DEFAULT_LED_PIN이 정의되어 있지 않으면 Pico의 기본 LED 핀인 핀 25를 사용합니다.\n    LED_PIN = Pin(25, Pin.OUT)\n\n# LED를 깜박입니다.\nwhile True:\n    LED_PIN.value(1)  # LED 켜기\n    time.sleep(0.25)  # 250밀리초 동안 기다리기\n    LED_PIN.value(0)  # LED 끄기\n    time.sleep(0.25)  # 250밀리초 동안 기다리기\n```\n\n2-) 파일 이름을 .py 확장자로 변경해주세요\n\n\u003cimg src=\"/assets/img/2024-06-23-RaspberryPiPicoPicoWFreeSimulator_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 동일한 결과를 확인하고 쉽게 코딩 언어를 전환할 수 있게 되었어요! 이것은 실제 Raspberry Pi Pico로는 쉽게 할 수 없는 일이죠.\n\n# 단계 3: 주변 기기 사용하기\n\n이 시뮬레이터의 멋진 점은 LED, 저항, 가속도계 등과 같은 다양한 일반 센서와 부품을 추가할 수 있다는 것이에요. 플러스 버튼을 사용하여 이러한 부품을 쉽게 추가하거나 이미 포함된 다른 프로젝트를 탐색할 수도 있어요.\n\n![Raspberry Pi Pico with Free Simulator](/assets/img/2024-06-23-RaspberryPiPicoPicoWFreeSimulator_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 간단한 프로젝트인 NeoPixel 링을 선택할 수 있습니다. 작동 방식은 다음을 참조해 보세요: [이 링크](https://wokwi.com/projects/314265138001609280)\n\n![image1](/assets/img/2024-06-23-RaspberryPiPicoPicoWFreeSimulator_6.png)\n\n![image2](/assets/img/2024-06-23-RaspberryPiPicoPicoWFreeSimulator_7.png)\n\n실행을 시작하면 색상이 변경되는 것을 확인할 수 있습니다. 이는 아직 장치를 가지고 있지 않거나 NeoPixels를 구매하고 싶지 않은 초보자들에게 좋은 기회입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 또 다른 흥미로운 기능은 가속도계 입력 또는 일반적인 물리적 입력을 시뮬레이션하는 기능입니다. 가속도계는 데이터를 생성하기 위해 움직임이 필요하므로, 시뮬레이터는 수동으로 입력을 조절할 수 있는 슬라이딩 바를 제공합니다. 이 기능은 유용하지만, 실제 프로토 타입처럼 장치를 물리적으로 움직이지 못하는 제한점을 강조합니다. 아두이노와 MPU6050를 사용한 예제를 여기에서 볼 수 있습니다. 이 예제는 외부 코드를 가져오기도 하며, 시뮬레이터를 사용하여 모든 프로젝트에서 활용할 수 있는 기능입니다. 이 예제는 아두이노를 사용하지만, Pico 또는 Pico W로 동일한 기능을 달성할 수 있습니다. 코드가 실행되는 동안 MPU6050을 클릭하여 가속도 값을 조절하고 실제 생활 변화를 시뮬레이할 수 있습니다.\n\nhttps://wokwi.com/projects/305937156771152449c\n\n![image](/assets/img/2024-06-23-RaspberryPiPicoPicoWFreeSimulator_8.png)\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 시뮬레이터는 가속도계, LED 등 다양한 센서와 구성 요소를 사용하기 편리하고 유연한 방법을 제공합니다. 외부 코드를 가져오고 센서 입력을 수동으로 시뮬레이션하는 기능은 소중한 학습 및 프로토타입 기회를 제공합니다. 그러나 정확한 물리적 움직임을 재현할 수 없는 등 제한 사항이 있습니다. 이러한 단점들을 감안해도, 이것은 초보자와 숙련된 개발자 모두에게 강력한 도구로 남아 있습니다.\n만약 이 정보가 유용하다고 생각된다면, 더 많은 자습서 및 통찰력을 위해 저의 Medium과 YouTube를 팔로우하세요!","ogImage":{"url":"/assets/img/2024-06-23-RaspberryPiPicoPicoWFreeSimulator_0.png"},"coverImage":"/assets/img/2024-06-23-RaspberryPiPicoPicoWFreeSimulator_0.png","tag":["Tech"],"readingTime":5},{"title":"라즈베리 파이로 LED 깜빡이기 초보자용 간단 가이드","description":"","date":"2024-06-23 18:14","slug":"2024-06-23-FoolproofBlinkaLedWithYourRaspberryPi","content":"\n\n## 스텝별 가이드\n\n라즈베리 파이를 설정한 후, 흥미로운 프로젝트에 착수할 수 없을 정도로 설레이고 있었어요. 그런데, 한 가지 큰 문제가 있었어요:\n\n이 작은 컴퓨터를 어떻게 상호 작용해야 할까요?\n\nIT 학생으로써, 시스템이 튜링 완전한지 여부를 감지하는 것과 같은 유용한 것들을 배웠어요. 하지만 라즈베리 파이를 제어하는 것? 그건 정말 너무 복잡해 보였어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-FoolproofBlinkaLedWithYourRaspberryPi_0.png\" /\u003e\n\n의문을 해결하기 위해 나는 확실한 작업으로 시작하기로 결정했다: LED 깜박임.\n\n이 프로젝트는 초보자에게 좋은 과제인데, Pi의 핀 및 기본 프로그래밍에 익숙해지게되며, 시간이나 돈을 많이 소비하지 않는다. 모든 재료(PI 및 멀티미터 제외)는 약 10유로 정도 든다. 그리고 기술 수준(및 발생하는 버그에 따라)에 따라 최대 1시간 30분 정도 소요된다.\n\n# 요구 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 라즈베리 파이 설정이 완료된 상태\n- 솔더가 필요 없는 브레드보드\n- 2개의 메스-퍼더 메일 점퍼 와이어\n- 1개의 LED\n- 작은 저항기 (330Ω 사용)\n- 멀티미터 (디버깅에 옵션)\n\n![이미지](/assets/img/2024-06-23-FoolproofBlinkaLedWithYourRaspberryPi_1.png)\n\n저는 라즈베리 파이 제로 W를 사용했지만, 이 튜토리얼은 GPIO 핀이 있는 모든 파이에 작동합니다. 파이 제로의 경우, 핀을 직접 납땜해야 합니다. 작업이 편리해지도록 다채로운 핀을 추천합니다.\n\n아직 라즈베리 파이를 설정하지 않았다면, 머릿속 작은 컴퓨터를 사용하는 방법에 대한 내 튜토리얼을 읽어보세요. 모니터로 시작하려면 공식 문서를 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자극으로 바쁜 손들을 준비하고 회로를 설치하는 방법\n\n## Raspberry Pi의 GPIO 핀들:\n\n회로를 설명하기 전에, 먼저 Raspberry Pi의 중요한 부분인 GPIO 핀을 살펴보겠습니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-FoolproofBlinkaLedWithYourRaspberryPi_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGPIO는 General-Purpose Input/Output의 약자입니다. 이 핀들을 사용하면 Raspberry Pi와 전기 구성 요소를 연결하여 소프트웨어를 통해 상호 작용할 수 있습니다. 그림에서 보듯이, 모든 40개의 핀은 특정한 역할을 합니다.\n\n우리의 회로를 위해 GND(0V)와 녹색, 파란색 또는 빨간색 GPIO 핀이 필요합니다. GPIO 핀은 전압을 켜고 끌 수 있도록 도와줍니다.\n\n## 회로:\n\n마지막으로, 회로를 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-23-FoolproofBlinkaLedWithYourRaspberryPi_3.png)\n\n우리는 LED를 GND에 연결하고 어떤 GPIO 핀에도 연결해야 합니다 (저는 GPIO 4를 사용했습니다).\n\n안전을 위해, GPIO 핀과 LED 사이에 저항을 연결해야 합니다. 너무 많은 전기는 좋은 경험이 아닙니다 — 특히 작은 LED에게는 특히 그렇습니다. 하지만 기억하세요: 저항이 강할수록 LED가 약하게 켜집니다.\n\n그렇지만, 330Ω로 저항을 선택하면 안전합니다. LED에 필요한 적절한 저항값을 계산하는 방법에 대해 더 알아보려면 다음 비디오를 확인해보세요:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잘 했어요, 회로는 여기까지입니다!\n\n# 파티 시작: 깜박이는 LED\n\nLED가 1초 간격으로 깜박이는 리듬을 만들어주는 것이 이번 스크립트의 작업입니다. 스크립팅에 매우 편리한 파이썬으로 프로그램을 선택했어요.\n\n우선, 라즈베리 파이에 연결하고 터미널을 엽니다. 코딩을 시작하기 전에 라즈베리 파이의 핀과 상호작용할 수 있게 해주는 라이브러리를 설치해요. 항상처럼, 패키지를 업데이트해주어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ sudo apt update \u0026\u0026 sudo apt upgrade\n$ sudo apt install python-rpi.gpio python3-rpi.gpio\n```\n\n그런 다음 좋아하는 편집기로 빈 파일을 엽니다. 저는 ‘vim’을 선호합니다.\n\n```js\n$ vim partyLED.py\n```\n\n이제 실제 프로그램으로 넘어갑니다. GPIO 핀의 초기화 및 LED 구성으로 나뉘어집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 초기화를 살펴봅시다. 필요한 라이브러리를 스크립트에 가져온 후, GPIO 핀을 위한 변수를 만듭니다.\n\n다른 GPIO 핀을 연결했다면 4를 해당 GPIO 핀 번호로 바꿔주세요.\n\n더불어 GPIO 핀 대신 물리적 핀을 사용하도록 지정하고 전압을 제어하기 위해 GPIO 핀을 출력 핀으로 설정합니다.\n\n```js\nimport RPi.GPIO as GPIO         # 라즈베리파이 GPIO 라이브러리 가져오기\nfrom time import sleep          # sleep 함수 가져오기 \n\npinLED = 4                      # LED GPIO 핀 번호\n\nGPIO.setmode(GPIO.BCM)          # GPIO 핀 번호 사용\nGPIO.setwarnings(False)         # 경고 무시\nGPIO.setup(pinLED, GPIO.OUT)    # GPIO 핀을 출력 핀으로 설정\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLED가 실제로 깜박이도록 하려면 GPIO 핀을 HIGH(전압이 켜짐)으로 설정한 후 LOW(전압이 꺼짐)으로 설정하는 루프를 만듭니다. while 루프로 인해 우리의 프로그램은 콘솔을 통해 중지할 때까지 실행됩니다.\n\n```js\nwhile True:                          # 무한 루프\n    GPIO.output(pinLED, GPIO.HIGH)   # 켜기\n    print(LED 켜짐)                   # 상태를 콘솔에 출력\n    sleep(1)                         # 1초 동안 일시정지\n    GPIO.output(pinLED, GPIO.LOW)    # 끄기\n    print(LED 꺼짐)                  # 상태를 콘솔에 출력\n    sleep(1)                         # 1초 동안 일시정지\n```\n\n모두 함께 넣으면 프로그램은 다음과 같이 보입니다:\n\n```js\nimport RPi.GPIO as GPIO         # 라즈베리파이 GPIO 라이브러리 import\nfrom time import sleep          # sleep 함수 import\n\npinLED = 4                      # LED GPIO 핀\n\nGPIO.setmode(GPIO.BCM)          # GPIO 핀 번호 사용\nGPIO.setwarnings(False)         # 우리 경우 경고 무시\nGPIO.setup(pinLED, GPIO.OUT)    # GPIO 핀을 출력 핀으로 설정\n\nwhile True:                          # 무한 루프\n    GPIO.output(pinLED, GPIO.HIGH)   # 켜기\n    print(LED 켜짐)                   # 상태를 콘솔에 출력\n    sleep(1)                         # 1초 동안 일시정지\n    GPIO.output(pinLED, GPIO.LOW)    # 끄기\n    print(LED 꺼짐)                  # 상태를 콘솔에 출력\n    sleep(1)                         # 1초 동안 일시정지\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 다 됐어요! 이 몇 줄이 모든 마법을 부릅니다.\n\n이제 파일을 저장하고 Pi에서 실행하세요:\n\n```js\n$ python partyLED.py\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:800/1*t3lO_bC7qHuqHf5sYxsXiA.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로그램을 중지하려면 터미널에서 CTRL+C를 눌러주세요.\n\n# 일반적인 문제\n\n- LED의 긴 다리(+)를 GPIO 핀에 연결하고 짧은 다리(-)를 GND에 연결해야 합니다. 전기는 한 방향으로만 흐릅니다.\n- 멀티미터가 있다면 각 전기 부품의 전압을 확인하고 LED와 저항기를 통해 전류가 흐르는지 확인할 수 있습니다.\n- 저항을 더 약한 것으로 바꿔보세요 (하지만 100Ω 미만은 사용하지 마세요). 전압이 너무 낮아지면 LED가 꺼집니다.\n\n만약 멀티미터가 없다면, LED가 제대로 작동하는지 확인하려면 플러스극을 GPIO 핀 대신 3.3V에 연결해보세요. 그러면 LED가 계속 켜질 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n요컨대: Pi로 시작하는 것은 예상했던 것보다 훨씬 쉽습니다. 작은 회로, 약간의 Python 프로그래밍 — 그게 다 필요한 것뿐이에요!\n\n전자 부품을 다뤄본 것이 즐거우셨다면, 회로에 더 많은 LED를 추가하거나 각기 다른 간격으로 깜박이게 하거나 작은 신호등을 만들어보세요. 이 과정은 Pi와 코딩을 더 익숙하게 만들어줄 거예요.\n\n또한, 처음에 잘 되지 않았다고 걱정하지 마세요. 믿으시든지 말든지 저는 저도 내 저항이 너무 강하다는 걸 알지 못해서 모든 것을 작동시키기 위해 1시간 이상이 걸렸어요(... 알겠어요). 고난을 겪는 것도 괜찮아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어쨌든, LED 깜박임을 마스터해서 기뻐요. 라즈베리 파이를 시작하는 방법을 알아내고 나니, 더 멋진 프로젝트에 더 흥분하고 있어요.\n\n그리고 당신도 그렇기를 바라요.\n\n더 멋진 프로젝트를 찾고 계신가요? 초보자를 위한 내 간단한 자동식 식물 관수 시스템 만들기 튜토리얼에서 배워보세요.","ogImage":{"url":"/assets/img/2024-06-23-FoolproofBlinkaLedWithYourRaspberryPi_0.png"},"coverImage":"/assets/img/2024-06-23-FoolproofBlinkaLedWithYourRaspberryPi_0.png","tag":["Tech"],"readingTime":6},{"title":"블루투스를 사용하여 헤드리스 라즈베리 파이에 연결하는 방법","description":"","date":"2024-06-23 18:13","slug":"2024-06-23-ConnecttoaheadlessRaspberryPiusingBluetooth","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-ConnecttoaheadlessRaspberryPiusingBluetooth_0.png\" /\u003e\n\n헤드리스 Raspberry Pi 기반 솔루션을 배포하는 데 있어서의 한 가지 어려움은 고객 네트워크에 라우터 액세스 없이 장치를 구성하는 것입니다. 종종 기계의 무선 설정을 변경해야 하지만 클라이언트 환경에서 설정을 변경할 수 있는 방법이 없습니다. 한 가지 솔루션은 장치에 Bluetooth 시리얼 포트를 구성하여 PC에서 실행 중인 Putty SSH 세션과 통신을 허용하는 것입니다. 연결이 설정되면 Bluetooth 검색을 끄어 다른 사람이 심지어 인식하지 못하도록 할 수 있습니다. 기계에서 액세스 포인트를 여는 것보다 안전하며 훨씬 간단합니다. 사실, 이 솔루션을 사용하려면 설치할 새 소프트웨어가 필요하지 않습니다. 대부분의 Bluetooth 기능을 포함하는 빌드와 함께 제공되는 소프트웨어의 구성만 필요합니다. 이를 Raspberry Pi 3+ 및 OrangePi Zero 3에서 시험했습니다. 한 가지 주의할 점은, 이 솔루션은 미래 릴리스에서 폐기될 예정이라는 RFCOMM 소프트웨어에 기반을 두고 있습니다. 다른 패키지를 사용한 (간단한) 대체 방법을 찾지 못했고, 제 개인적인 구성 도구에서만 사용하고 있기 때문에 미래의 구식화 위험을 감수할 의향이 있습니다. 웹에서 솔루션을 연구하는 동안 해결책에 대한 기술적인 기사를 많이 찾았지만 단계별 가이드는 찾지 못했습니다. 그래서 여기에 있습니다...\n\n- 개발이나 구성을 위해 일반적으로 수행하는 것처럼 Windows PC의 PuTTY를 사용하여 알려진 네트워크의 헤드리스 장치에 연결합니다.\n- RFCOMM 서비스를 위한 서비스 시작 파일을 추가합니다. 이는 /etc/systemd/system 디렉토리에 있어야하며 파일 이름은 rfcomm.service 여야합니다.\n\n```js\nsudo nano /etc/systemd/system/rfcomm.service\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 내용을 입력해주세요:\n\n\n[Unit]\nDescription=RFCOMM 서비스\nAfter=bluetooth.service\nRequires=bluetooth.service\n[Service]\nExecStart=/usr/bin/rfcomm watch hci0 1 getty rfcomm0 115200 xterm -a \u003c로그인이름\u003e\n[Install]\nWantedBy=multi-user.target\n\n\n`\u003c로그인이름\u003e` 자리에 기기에 로그인하려는 사용자 이름을 입력해주세요. 만약 자동 로그인을 원치 않는다면, `ExecStart` 줄의 `xterm` 이후에 있는 모든 내용을 제거해주세요.\n\n3. 다음 명령어를 사용하여 재부팅 시 실행되도록 이 서비스를 설치해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsudo systemctl enable rfcomm\n```\n\n4. 다음과 같이 맨 위에 \"DisbablePlugins = pnat\" 문을 추가하여 파일 /etc/bluetooth/main.conf를 수정하십시오:\n\n```js\n[General]\nDisablePlugins = pnat\n```\n\n5. 사용하고 싶은 Bluetooth 이름을 가진 파일 /etc/machine-info를 추가하거나 수정하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nPRETTY_HOSTNAME=\u003c블루투스이름\u003e\n```\n\n원하는 장치 이름으로 표시하고 싶다면 `블루투스이름`을 대체하세요.\n\n6. 블루투스 서비스 파일을 수정하세요.\n\n```js\nsudo nano /etc/systemd/system/bluetooth.target.wants/bluetooth.service\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 두 줄로 대체해주세요:\n\n```js\nExecStart=/usr/libexec/bluetooth/bluetoothd -C\nExecStartPost=/usr/bin/sdptool add SP\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n7. 이제 구성이 완료되어 장치를 다시 부팅하여 서비스를 다시 시작하세요.\n\n8. 이제 PC와 Bluetooth 연결을 수동으로 설정할 수 있습니다. 이 작업은 한 번만 수행하면 됩니다. 기기가 근접할 때마다 연결이 다시 설정됩니다. 라즈베리 파이 장치에서 다음 명령을 입력하세요:\n\n```js\nsudo bluetoothctl\ndiscoverable on\nagent on\npairable on\nscan on\n```\n\n이제 아래와 같이 Bluetooth 장치 ID가 표시됩니다. 통신하는 기기의 16진수 값을 찾아 작동 중인지 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-ConnecttoaheadlessRaspberryPiusingBluetooth_1.png\" /\u003e\n\n9. 이제 Windows PC로 이동하여 \"Bluetooth 및 기타 장치 설정\"을 열어주세요. 그런 다음 \"Bluetooth 또는 기타 장치 추가\"를 선택한 후 \"Bluetooth\"를 선택합니다. 그러면 장치 목록이 표시됩니다. 해당 장치를 선택하면 페어링 키가 표시되고 확인 메시지가 나타납니다. PC에서 확인한 후 라즈베리 파이에서 두 가지 메시지에 \"예\"로 답하세요. 이 시점에서 두 장치가 페어링되었으며 이제 라즈베리 파이 창으로 돌아가서 다음과 같이 입력해주세요:\n\n```js\nDiscoverable off\nexit\n```\n\n10. 올바른 연결을 확인하려면 PC로 돌아가주세요. \"Bluetooth 및 기타 장치\" 창에서 아래로 스크롤하여 \"장치 및 프린터\"를 찾아 선택해주세요. 여기에 따라 \"Unspecified\" 항목 하위에 장치 목록이 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-23-ConnecttoaheadlessRaspberryPiusingBluetooth_2.png\" /\u003e\n\n이제 디바이스에 마우스 오른쪽 버튼을 클릭한 다음 \"속성\"을 선택하세요. 그런 다음 \"서비스\" 탭을 선택하세요. 다음과 같은 화면이 나타날 것입니다:\n\n\u003cimg src=\"/assets/img/2024-06-23-ConnecttoaheadlessRaspberryPiusingBluetooth_3.png\" /\u003e\n\n시리얼 포트 항목이 여러분의 디바이스에 연결해야 하는 포트입니다. 다음 단계에서 사용할 COM 포트 번호를 기록해주세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n11. 이제 PC에서 새 PuTTY 창을 열고 표시된대로 연결 매개변수를 입력하세요. \"Serial\" 연결 유형을 선택하고 COM 포트 및 속도 값을 입력하세요.\n\n![이미지](/assets/img/2024-06-23-ConnecttoaheadlessRaspberryPiusingBluetooth_4.png)\n\n이제 \"열기\"를 선택하고 잠시 후에...\n\n![이미지](/assets/img/2024-06-23-ConnecttoaheadlessRaspberryPiusingBluetooth_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신이 있네요!\n\n이제 raspi-config를 사용하여 다른 네트워크를 설정하거나 필요한 다른 구성 변경을 할 수 있습니다.\n\n여기까지 왔으니, 두 장치를 모두 전원을 끄고 다시 키고, 다시 구성하지 않고도 연결할 수 있는 능력을 테스트해보는 것이 좋습니다. 두 기기가 재부팅된 후 PC에서 \"Bluetooth 및 기타 장치\"로 이동하여 장치가 식별되고 시리얼 포트 서비스가 실행 중인지 확인하세요. 그렇다면 준비된 것입니다. 이제 두 장치를 Wifi 접속이 없는 위치로 옮기고 여전히 PuTTY와 Bluetooth를 통해 무선 장치와 통신할 수 있습니다.\n\n그게 다에요! 마지막으로 한 가지 덧붙이자면, 몇 년간 Medium에서 독자로 활동해 왔지만, 이번이 처음으로 글을 게시하는 시도입니다. 건성적인 피드백을 환영할게요.","ogImage":{"url":"/assets/img/2024-06-23-ConnecttoaheadlessRaspberryPiusingBluetooth_0.png"},"coverImage":"/assets/img/2024-06-23-ConnecttoaheadlessRaspberryPiusingBluetooth_0.png","tag":["Tech"],"readingTime":5},{"title":"라즈베리 파이 Cloudflare 터널 - DNS 라우팅을 사용해 내부 웹 서비스를 외부에 공개하는 방법","description":"","date":"2024-06-23 18:11","slug":"2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting","content":"\n\n클라우드플레어 터널을 사용하여 홈랩에 있는 서비스를 공용으로 노출할 수 있습니다. 이것은 포트 포워딩의 대안이 될 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_0.png)\n\n# 중요 사항!!\n\n자신이 하는 일의 결과와 위험을 알지 못한 채, 개인 서비스를 노출하는 것은 위험합니다!!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 지침을 따를 때 주의하세요.\n\nCloudflare 터널은 구성된 DNS 또는 IP에 대해서만 트래픽을 라우팅하지만, 트래픽은 클라우드플레어 터널 구성에 따라 개인 네트워크 어디에서든 발생할 수 있습니다.\n\n보안을 높이기 위해 방화벽을 사용하여 클라우드플레어 터널이 설치된 Raspberry Pi의 네트워크를 격리했습니다.\n\n# 소개\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHomeLab를 운영하는 주된 이유 중 하나는 자체 구축한 웹 서비스를 사설 네트워크에서 호스팅하는 것입니다. 이 웹 서비스를 구축하고 나면 많은 사용자들이 사용할 수 있도록 공용 네트워크에 노출되어야 합니다. (그것이 제 목표입니다.)\n\n과거에는 포트 포워딩이 사설 웹 서비스를 공개 네트워크에 노출하는 유일한 옵션이라고 생각했습니다.\n\n최근에 몇몇 영상과 기사를 보고 클라우드플레어 터널이 포트 포워딩 대안으로 사용될 수 있다는 것을 알게 되었습니다.\n\n# 클라우드플레어는 어떻게 작동하나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_1.png)\n\n안녕하세요! 클라우드플레어 터널은 클라우드플레어가 제공하는 서비스로, 웹 서버나 다른 리소스와 같은 인프라를 클라우드플레어의 글로벌 네트워크에 안전하게 연결할 수 있게 해줍니다. 이런 방식으로 작동합니다:\n\n- 설치: 클라우드플레어 터널 클라이언트 소프트웨어를 웹 서버나 연결하고자 하는 장치에 설치합니다. 이 클라이언트 소프트웨어는 클라우드플레어 네트워크와 안전한 연결을 설정합니다.\n- 인증: 설치 후 클라이언트 소프트웨어는 API 토큰이나 다른 인증 방법을 사용하여 클라우드플레어와 인증을 수행합니다. 이를 통해 권한이 있는 클라이언트만 클라우드플레어와 연결을 설정할 수 있습니다.\n- 연결 설정: 클라이언트 소프트웨어는 클라우드플레어의 엣지 위치 중 하나로 안전하고 암호화된 터널을 설정합니다. 이 터널은 인프라와 클라우드플레어 네트워크 간의 개인 연결 역할을 합니다.\n- 라우팅: 터널이 설정되면 인프라로의 트래픽이 클라우드플레어 네트워크를 통해 라우팅됩니다. 클라우드플레어의 글로벌 네트워크는 콘텐츠 전달을 최적화하여 성능과 신뢰성을 향상시킵니다.\n- 보안: 터널은 인프라와 클라우드플레어 간의 모든 트래픽을 암호화하여 제3자에 의한 가로채기나 변조로부터 보호합니다. 추가로, 클라우드플레어 네트워크는 DDoS 보호 및 다른 보안 기능을 제공하여 인프라를 공격으로부터 안전하게 보호합니다.\n- 관리: 클라우드플레어 대시보드를 통해 터널을 관리하고 모니터링할 수 있습니다. 이는 터널 상태 모니터링, 라우팅 설정 구성, 로그 및 분석에 접근하는 것을 포함합니다.\n\n요약하면, 클라우드플레어 터널은 프라이빗 인프라를 클라우드플레어의 글로벌 네트워크에 안전하고 효율적으로 연결하는 방법을 제공하여 성능, 신뢰성 및 보안을 향상시킵니다. (물론 여러분의 기대에 따라 달라집니다!)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# DNS 라우트와 IP 라우트 비교\n\nCloudflare 터널은 DNS 라우트와 IP 라우트 두 가지 라우팅 옵션을 제공합니다. 아래는 두 가지의 비교입니다:\n\n## DNS 라우트 동작 방식\n\nDNS 라우팅을 사용하면 Cloudflare 터널 클라이언트가 호스트 이름을 Cloudflare에 등록하고 해당 호스트 이름에 대한 DNS 요청이 가장 가까운 Cloudflare 데이터 센터로 라우팅됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## DNS 라우트의 장점\n\n- 간편한 구성: IP 주소를 관리할 필요가 없습니다; DNS가 라우팅을 자동으로 처리합니다.\n- 동적 IP 주소: 서버의 IP 주소가 변경되어도 구성을 업데이트할 필요가 없습니다; Cloudflare가 동적 IP 변경을 처리합니다.\n- 부하 분산: Cloudflare의 글로벌 애니캐스트 네트워크가 트래픽을 자동으로 가장 가까운 데이터 센터로 라우팅하여 성능과 신뢰성을 향상시킵니다.\n\n## DNS 라우트 고려 사항\n\n- DNS 전파: DNS 레코드의 변경 사항은 전파되는 데 시간이 걸 수 있으며, 라우팅 변경이 적용되는 데 걸리는 시간에 영향을 줄 수 있습니다.\n- 제한된 제어: IP 라우트와 비교하여 라우팅에 대한 세밀한 제어가 적습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## IP 경로 작동 방식\n\nIP 라우팅을 사용하면 Cloudflare 터널 클라이언트가 특정 IP 주소를 Cloudflare에 등록하고, 해당 IP 주소로 전송된 트래픽은 Cloudflare 네트워크를 통해 서버로 라우팅됩니다.\n\n## IP 경로의 장점\n\n- 직접 라우팅: 트래픽이 서버의 IP 주소로 직접 라우팅되어 DNS 라우팅보다 지연 시간을 단축할 수 있습니다.\n- 상세한 제어: 라우팅에 대해 더 많은 제어권을 가지고 서버에 연결할 수 있는 IP 주소를 지정할 수 있습니다.\n- 즉시 트래픽: IP 경로에 대한 변경 사항이 DNS 전파를 기다리지 않고 즉시 적용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## IP 경로 고려 사항\n\n- 정적 IP 주소: 서버에 정적 IP 주소가 필요합니다. IP 경로는 특정 IP 주소에 연결되어 있기 때문입니다.\n- 구성 관리: 서버의 IP 주소가 변경되면 IP 경로를 수동으로 업데이트해야 합니다.\n- DNS 해결 문제 가능성: 클라이언트의 DNS 해결에 실패하면 서버에 연결할 수 없게 됩니다.\n\n## DNS 경로 또는 IP 경로를 사용해야 하는 경우\n\n- DNS 경로: 간편함, 동적 IP 주소, 그리고 클라우드플레어가 부하 분산과 트래픽 라우팅을 자동으로 처리하길 원하는 경우 DNS 라우팅을 사용하세요.\n- IP 경로: 라우팅 제어가 필요하거나 정적 IP 주소가 필요하거나 DNS 전파를 기다릴 필요 없이 즉시 트래픽 라우팅 변경이 필요한 경우 IP 라우팅을 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최종적으로 DNS 라우팅과 IP 라우팅 사이의 선택은 특정 사용 사례, 요구 사항 및 제어, 유연성 및 관리 용이성에 대한 선호도에 따라 다릅니다.\n\n# DNS 라우팅 또는 cloudflared CLI를 사용하기로 결정했습니다\n\n먼저, 홈랩의 정적 IP를 노출시키고 싶지 않았습니다 (심지어 정적 IP조차 아닙니다). ISP에서 할당한 IP는 변경되지 않을 수 있지만, 이것이 정적 IP라는 것은 아닙니다. ISP가 원하는 경우 언제든지 IP가 변경될 수 있습니다.\n\n둘째, 저는 단순히 특정 도메인 이름으로의 트래픽을 홈랩으로 라우팅하길 원했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 번째로, 클라우드플레어 터널 구성을 만들기 위해 클라우드플레어 클라이언트 명령줄 인터페이스(cloudflared CLI)를 사용하기로 결정했어요. 어떻게 작동하는지 알아내는 데 조금 더 시간이 걸렸지만, 구성을 자동화하는 데 도움이 되었어요 (실제로는 클라우드플레어 패키지 설치뿐이지만). 안시블 플레이북에서 자동화되고 스크립팅된 것들이 있었지만, 내가 개입해야 했던 몇 가지 단계들이 있었기 때문에 많이 도움이 되지는 않았어요.\n\n# 클라우드플레어 터널은 어떻게 구성되나요?\n\n클라우드플레어에 대한 게시물과 문서를 읽고, 비디오를 시청한 후, 내가 가지고 있는 라즈베리 파이 5 중 하나에 클라우드플레어 터널을 설치하고 구성했어요.\n\n클라우드플레어 터널을 통한 DNS 라우트를 위해 나에게는 세 가지 엔티티가 있었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 도메인 이름의 CNAME 레코드\n- Cloudflare의 Cloudflare 터널 데몬/구성\n- 내 HomeLab 기기에 Cloudflare 터널 데몬/구성\n\n클라우드플레어 터널은 사용한 라즈베리 파이와 클라우드플레어 간의 VPN처럼 보였어요.\n\n# Ansible Playbook을 작성했습니다\n\n라즈베리 파이에 클라우드플레어드(클라이언트)를 여러 번 설치했습니다. 이 작업은 간단했지만 실험 중에 반복되어 수행되었기 때문에, 라즈베리 파이에 클라우드플레어드를 설치하는 Ansible Playbook을 작성했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앤서블 플레이북을 사용하면 GPG 키와 Cloudflared가 간단히 설치됩니다. (현재 Debian + Bookworm만 지원됩니다.)\n\n```js\n# moon-rapi 레포지토리 클론\ngit clone https://github.com/Gatsby-Lee/moon-rapi.git\n\n# 하위 디렉토리로 이동\ncd ansible_playbook\n\n# 1. 대상 머신 IP 주소, 로그인 사용자 이름, 개인 SSH 키를 변경하세요.\n# 2. 플레이북 실행\n# 이 작업은 cloudflared를 설치합니다. (아직 구성하지는 않음)\nansible-playbook --inventory \u003c대상 머신 IP 주소\u003e, \\\n  --user \u003c로그인 사용자 이름\u003e \\\n  --private-key ~/.ssh/\u003c개인 SSH 키\u003e \\\n  install-cloudflared-on-debian.yaml\n```\n\n![라즈베리파이와 Cloudflare Tunnel 및 DNS 라우팅을 사용하여 2024년 6월 23일에 개인 웹 서비스를 공개하는 방법](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_2.png)\n\n# Cloudflared CLI를 사용하여 Cloudflare 터널 구성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 1: 로그인하고 루트로 전환하기\n\n저는 Cloudflare Tunnel이 인프라의 일부였기 때문에 서비스를 구성하고 시작하기 위해 \"root\" 사용자를 사용했습니다.\n\n```js\n# 설치된 cloudflared 버전 확인\ncloudflared --version\n# root 사용자로 전환\nsudo -s\n# root 사용자의 홈 디렉토리로 이동\ncd ~ \n```\n\n![이미지](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 2: 클라우드플레어에 로그인하여 클라우드플레어 터널 승인하기\n\nCloudflared CLI를 사용하려면 클라우드플레어 로그인 및 승인을 거쳐 클라우드플레어 터널을 활성화해야 했습니다.\n\n시작 명령어는 \"cloudflared login\"입니다.\n\n해당 명령은 아래 스크린샷과 같은 https 링크를 출력했습니다. URI는 복사하여 브라우저에 붙여넣어 클라우드플레어 터널 승인을 진행해야 했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n과정 중에 Cloudflare Tunnel과 구성하고 싶은 도메인을 선택해야 했어요. (저는 소유한 도메인 중 하나를 선택했어요.)\n\n과정이 끝난 후에, 로그인을 수행한 기기에 /root/.cloudflared/cert.pem 파일이 제공되었어요.\n\n```js\ncloudflared login\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Step 3: Create Cloudflare Tunnel](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_5.png)\n\n![Step 3: Create Cloudflare Tunnel](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_6.png)\n\n![Step 3: Create Cloudflare Tunnel](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_7.png)\n\n## Step 3: Create Cloudflare Tunnel\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"wowamazon\"이라는 이름의 터널을 생성했어요. Cloudflare 터널을 생성한 후에는 `/root/.cloudflared` 경로 아래에 `uuid`.json 형식의 터널 전용 자격 증명이 생성되었어요.\n\nCloudflare 웹 UI에서 아래 스크린샷처럼 생성된 터널을 확인할 수 있었어요.\n\n```js\ncloudflared tunnel list\ncloudflared tunnel create \u003c터널 이름\u003e\n\n# 터널 정보 가져오기\ncloudflared tunnel info \u003c터널 이름\u003e\n\n# 터널을 삭제해야 하는 경우.\n# -f를 사용하여 강제로 삭제할 수 있어요\ncloudflared tunnel delete \u003c터널 이름\u003e\ncloudflared tunnel delete \u003c터널 이름\u003e -f\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_8.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_9.png)\n\n## 단계 4: DNS 경로 만들기 — 공개 도메인을 통한 트래픽 라우팅\n\nCloudflare 터널을 생성한 후, Cloudflare 터널을 통해 라우팅하고자 하는 도메인으로 DNS 경로를 만들었습니다.\n\nDNS 경로 생성은 wowamazon.party와 같은 도메인 아래 CNAME 레코드를 생성했습니다. 아래 스크린샷을 참조해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 방금 추가한 Routes로 Cloudflare Tunnel이 업데이트되었습니다. 아래 스크린샷처럼요.\n\n```js\ncloudflared tunnel route dns \u003ctunnel-name\u003e \u003cdomain\u003e\n\n# for myself.\ncloudflared tunnel route dns wowamazon wowamazon.party\ncloudflared tunnel route dns wowamazon *.wowamazon.party\n```\n\n![이미지1](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_10.png)\n\n![이미지2](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_12.png\" /\u003e\n\n생성된 CNAME의 내용은 아래의 형식을 따릅니다.\n\n```js\n\u003ctunnle-uuid\u003e.cfargotunnel.com\n```\n\n## 단계 5: Cloudflare 터널 구성 파일 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클라우드플레어 터널 구성 파일을 생성했어요. 경로는 /root/.cloudflared/config.yml 입니다.\n\n다음과 같은 내용을 사용했어요. 인그레스를 구성하여 모든 트래픽을 로컬 \"http://127.0.0.1:8080\"으로 보내도록 설정했어요. 도커가 실행되고 수신 대기 중인 곳이에요. (내용은 당신의 환경에 맞게 변경해주세요.)\n\n```js\ntunnel: \u003c터널-ID\u003e\ncredentials-file: /root/.cloudflared/\u003c터널-ID\u003e.json\n\n# ref: https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/configure-tunnels/local-management/configuration-file/\ningress:\n  - hostname: wowamazon.party\n    service: http://127.0.0.1:8080\n  - hostname: \"*.wowamazon.party\"\n    service: http://127.0.0.1:8080\n\n  - service: http_status:404\n```\n\n![이미지](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_13.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 6: 구성으로 클라우드플레어 터널 실행하기\n\n클라우드플레어 터널 구성이 완료되고 나서, 아래 명령어로 수동으로 클라우드플레어 터널을 시작할 수 있었습니다.\n\n클라우드플레어 터널이 시작되면, 웹 UI에서 클라우드플레어 터널 상태가 \"정상\"으로 표시됩니다.\n\n또한, https://wowamazon.party로 이동하여 아래 스크린샷처럼 클라우드플레어 터널이 귀하의 홈랩에서 서비스로 트래픽을 라우팅하기 시작했음을 확인할 수 있었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncloudflared 터널 --config /root/.cloudflared/config.yml 실행 \u003c터널-이름\u003e\n\n# 모든 구성이 기본 이름을 사용하므로 이 축약된 명령어도 가능합니다.\ncloudflared 터널 실행\n\n# 제 경우에는 구성과 터널 이름을 명시하는 것이 더 좋습니다.\ncloudflared 터널 --config /root/.cloudflared/config.yml 실행 wowamazon\n```\n\n![이미지 1](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_14.png)\n\n![이미지 2](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_15.png)\n\n![이미지 3](/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_16.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 7: 클라우드플레어 터널을 서비스로 실행하기\n\n이전 단계인 6단계에서 특정 구성과 클라우드플레어 터널 이름으로 클라우드플레어드를 수동으로 시작했습니다. (수동 방식은 모든 것이 예상대로 작동하는지 확인하기 쉽고 간단했습니다)\n\n클라우드플레어 터널 시작은 내장된 \"서비스로 클라우드플레어드\"로 자동화할 수 있습니다.\n\n\"cloudflared service install\" 명령어를 사용하여 cloudflared 서비스를 설치할 수 있습니다. \"cloudflared service\"가 설치되면 /root/.cloudflared/config.yml의 사본이 /etc/cloudflared/config.yml로 복사됩니다. 아래 스크린샷과 같이요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 \"cloudflared service\"가 문제없이 설치되었다면, 서비스는 자동으로 실행됩니다. 아래 명령어를 사용하여 서비스 상태를 확인할 수 있습니다.\n\n```js\ncloudflared service install\n\n# 서비스를 제거하려면,\ncloudflared service uninstall\nrm /etc/cloudflared/config.yml\n\n===\n\n# cloudflared 서비스 상태 확인\nsystemctl status cloudflared.service\n# cloudflared 서비스 수동 정지/시작\nsystemctl stop cloudflared.service\nsystemctl start cloudflared.service\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_17.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_18.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마무리\n\n몇 주 전에 라즈베리 파이 5대에 클라우드플레어 터널을 설치했어요. 그런데 이 단계별 포스트를 작성하는 데 시간이 걸렸네요. 몇 가지가 제게 명확하지 않아서 그랬던 것 같아요.\n\n이 게시물이 클라우드플레어 터널에 참여하는 데 도움이 되길 바래요 😃\n\n# 다음부턴","ogImage":{"url":"/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_0.png"},"coverImage":"/assets/img/2024-06-23-RaspberryPiHowtoexposeWebServicesinPrivatetoPublicwithCloudflareTunnelDNSrouting_0.png","tag":["Tech"],"readingTime":12},{"title":"라즈베리 파이 클러스터 설정 Kubernetes와 Airflow, Ansible 사용 방법","description":"","date":"2024-06-23 18:09","slug":"2024-06-23-RaspberryPiClusterwithKubernetesandAirflowConfiguringAnsible","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-RaspberryPiClusterwithKubernetesandAirflowConfiguringAnsible_0.png\" /\u003e\n\n아래는 Ansible을 Raspberry Pi 클러스터에서 작동시키기 위해 취한 단계를 요약한 것입니다. 이 프로젝트의 동기는 Kubernetes 및 Airflow를 실행하는 작은 규모이면서 효율적이고 유연한 클러스터 환경을 만드는 것입니다. 목표는 다양한 웹 스크래핑 스크립트를 자동으로 예약하고 서핑 조건을 확인하는 스크래핑을 포함한 DAG 스케줄링을 자동화하는 것입니다.\n\n시작하기 전에 필요한 하드웨어 구성 요소를 모두 준비했는지 확인해 주세요. 자세한 목록 및 설정 지침은 다음에서 확인할 수 있습니다:\n\n# 시작하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 초기화 스크립트에 접근하기 위해 Git 저장소를 복제하세요\n\n- 저장소를 복제하고 해당 폴더로 이동하세요:\n\n```js\ngit clone https://github.com/robronayne/PiClusterFlow.git\ncd PiClusterFlow\n```\n\n## microSD 카드에 Raspberry Pi OS 설치하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. Raspberry Pi Imager 다운로드하기:\n\n- 먼저 raspberrypi.org/software에서 Raspberry Pi Imager를 다운로드하세요.\n\n2. Imager를 사용하여 OS 설치하기:\n\n- SanDisk 32GB microSD 카드를 컴퓨터에 삽입하세요.\n- microSD 카드를 boot로 이름을 변경하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-RaspberryPiClusterwithKubernetesandAirflowConfiguringAnsible_1.png\" /\u003e\n  \n- Raspberry Pi Imager를 열고 Raspberry Pi OS (32비트)를 선택합니다.\n- 삽입된 SD 카드를 선택합니다.\n\n3. 호스트, 사용자 이름 및 비밀번호 구성:\n\n- Pi OS의 최근 변경 사항은 SSH용 비밀번호 설정을 필요로 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-RaspberryPiClusterwithKubernetesandAirflowConfiguringAnsible_2.png\" /\u003e\n\n- OS 맞춤 설정 메뉴에서 호스트 이름, 사용자 이름 및 암호 구성하세요.\n- 모든 Raspberry Pi 노드의 사용자 이름을 \"pi\"로 설정하고 각각의 암호를 일관되게 유지하세요. 호스트 이름도 노드의 의도된 역할과 일치하도록 설정해주세요.\n- 프롬프트가 나타날 때 기존 데이터를 지울 것인지 확인하세요.\n- 각각의 microSD 카드에 대해 이 프로세스를 반복하세요.\n\n## Prepare microSD Cards\n\n1. microSD 카드 장착:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 컴퓨터에 microSD 카드를 삽입하세요.\n- diskutil list를 사용하여 디스크 식별자(/dev/diskX)를 확인하세요.\n\n![이미지](/assets/img/2024-06-23-RaspberryPiClusterwithKubernetesandAirflowConfiguringAnsible_3.png)\n\n- /Volumes/에 카드의 부트 파티션을 마운트하세요. 다음 명령어를 사용하여 마운트하고 마운트를 확인할 수 있습니다:\n\n```js\ndiskutil mountDisk /dev/diskX\nls /Volumes\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. setup_node.sh 스크립트 실행\n\n- setup_node.sh에 실행 권한을 부여하세요:\n\n```js\nchmod +x setup_node.sh\n```\n\n- 각 microSD 카드가 어떤 노드에 해당하는 지에 따라 스크립트를 한 번씩 실행하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 마스터 노드 마이크로SD 카드용\nsudo ./setup_node.sh master \n```\n\n```js\n# 워커 노드 마이크로SD 카드용\nsudo ./setup_node.sh worker1 \nsudo ./setup_node.sh worker2 \nsudo ./setup_node.sh worker3\n```\n\n![이미지](/assets/img/2024-06-23-RaspberryPiClusterwithKubernetesandAirflowConfiguringAnsible_4.png)\n\n3. 마이크로SD 카드를 추출하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 스크립트가 완료되면 마이크로SD 카드를 제거해 주세요\n\n```js\ndiskutil unmountDisk /dev/diskX\n```\n\n## 라즈베리 파이 기기에 마이크로SD 카드 삽입\n\n- 각 준비된 마이크로SD 카드를 해당 라즈베리 파이 기기에 넣어주세요.\n- 각 라즈베리 파이를 켜고 이더넷으로 네트워크에 연결해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 의존성 설치\n\n1. Homebrew 설치: Homebrew가 설치되어 있지 않은 경우, Homebrew를 설치하세요:\n\n```js\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n2. Ansible 설치:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbrew install ansible\n```\n\n3. 라즈베리 파이 IP 주소를 가져 오기 위해 nmap 설치:\n\n```js\nbrew install nmap\n```\n\n3. Ansible과의 SSH 인증을 위해 sshpass 설치하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbrew install sshpass\n```\n\n4. Ansible을 초기화합니다:\n\n- 각 Raspberry Pi에 대한 Ansible 호스트 파일 및 SSH 액세스를 구성해야 합니다.\n- init_ansible.sh 스크립트를 실행해주세요.\n\n```js\nchmod +x ./init_ansible.sh\nsudo ./init_ansible.sh\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이 스크립트는 Pi의 IP 주소를 동적으로 검색하여 ansible/hosts 파일에 저장합니다. 또한 각 IP 주소의 SSH 키를 ~/.ssh/known_hosts 파일에 추가합니다.\n\n![이미지](/assets/img/2024-06-23-RaspberryPiClusterwithKubernetesandAirflowConfiguringAnsible_5.png)\n\n- 마지막으로, 우리가 만든 Raspberry Pi 암호를 환경 변수에 추가할 수 있습니다. 스크립트는 이미 ansible/hosts 파일이 SSH 암호를 위한 환경 변수를 참조하도록 하였습니다. 이렇게 함으로써 Ansible 명령을 실행할 때마다 암호를 입력할 필요가 없어집니다.\n\n```js\nexport ANSIBLE_SSH_PASS='여러분의_ssh_암호_여기에'\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 확인\n\n## 모든 노드에 핑 보내기\n\n- 이제 Ansible이 구성되었으므로 호스트 파일에 존재하는 모든 노드에 핑을 시도할 수 있습니다. 다음 명령어를 사용하여 디렉토리로 이동한 후 노드에 핑을 보낼 수 있습니다:\n\n```js\ncd ansible\nansible all -m ping\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n아래는 마크다운 형식으로 변경한 표입니다.\n\n\n![Raspberry Pi Cluster](/assets/img/2024-06-23-RaspberryPiClusterwithKubernetesandAirflowConfiguringAnsible_6.png)\n\n지금까지 여러 Pi 노드를 구성하고 Ansible을 사용하여 설정 작업을 자동화하여 Raspberry Pi Cluster를 성공적으로 구축했습니다. 이러한 단계를 따라, 추가적인 사용자 정의 및 자동화를 위한 준비가 된 일관된 클러스터 환경을 만들었습니다. 각 Raspberry Pi 노드는 협력하여 작동할 수 있도록 준비되었으며, 분산 컴퓨팅 및 자동화에 대한 미래 프로젝트와 실험을 위한 길을 열었습니다.\n\n이 프로젝트의 현재 상태는 GitHub에서 확인할 수 있습니다:\n","ogImage":{"url":"/assets/img/2024-06-23-RaspberryPiClusterwithKubernetesandAirflowConfiguringAnsible_0.png"},"coverImage":"/assets/img/2024-06-23-RaspberryPiClusterwithKubernetesandAirflowConfiguringAnsible_0.png","tag":["Tech"],"readingTime":5}],"page":"13","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"13"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>