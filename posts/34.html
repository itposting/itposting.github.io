<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/34" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/34" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="Arduino를 사용하여 RC 수신기 신호 읽는 방법" href="/post/2024-06-22-HowtoreadRCreceiversignalwithArduino"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Arduino를 사용하여 RC 수신기 신호 읽는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowtoreadRCreceiversignalwithArduino_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Arduino를 사용하여 RC 수신기 신호 읽는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Arduino를 사용하여 RC 수신기 신호 읽는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TCS3200 센서를 이용한 NPK질소, 인산, 칼륨 검출 방법" href="/post/2024-06-22-NPKDetectionusingTCS3200sensor"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TCS3200 센서를 이용한 NPK질소, 인산, 칼륨 검출 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TCS3200 센서를 이용한 NPK질소, 인산, 칼륨 검출 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">TCS3200 센서를 이용한 NPK질소, 인산, 칼륨 검출 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="두통 없이 WiFi 모듈 ESP-01 ESP8266 사용하는 방법" href="/post/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="두통 없이 WiFi 모듈 ESP-01 ESP8266 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="두통 없이 WiFi 모듈 ESP-01 ESP8266 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">두통 없이 WiFi 모듈 ESP-01 ESP8266 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ESP32로 SD 카드 IO 성능 최적화하는 방법" href="/post/2024-06-22-OptimizingSDCardIOPerformancewithESP32"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ESP32로 SD 카드 IO 성능 최적화하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-OptimizingSDCardIOPerformancewithESP32_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ESP32로 SD 카드 IO 성능 최적화하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">ESP32로 SD 카드 IO 성능 최적화하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="레진 3D 프린팅 vs 필라멘트 프린팅 장단점 비교" href="/post/2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="레진 3D 프린팅 vs 필라멘트 프린팅 장단점 비교" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="레진 3D 프린팅 vs 필라멘트 프린팅 장단점 비교" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">레진 3D 프린팅 vs 필라멘트 프린팅 장단점 비교</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안의 미스터리 4부" href="/post/2024-06-22-MysteriesofAnPart4"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안의 미스터리 4부" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-MysteriesofAnPart4_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안의 미스터리 4부" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">안의 미스터리 4부</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="오픈소스 IC 셀을 3D 프린터로 출력하는 방법 간단 가이드" href="/post/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="오픈소스 IC 셀을 3D 프린터로 출력하는 방법 간단 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="오픈소스 IC 셀을 3D 프린터로 출력하는 방법 간단 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">오픈소스 IC 셀을 3D 프린터로 출력하는 방법 간단 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="3D 모델링의 7가지 주요 용도" href="/post/2024-06-22-Whatis3Dmodelingusedfor"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="3D 모델링의 7가지 주요 용도" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Whatis3Dmodelingusedfor_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="3D 모델링의 7가지 주요 용도" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">3D 모델링의 7가지 주요 용도</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PLA 필라멘트 매트 3D 프린트와 글로시 3D 프린트, 어떤 것을 선택해야 할까" href="/post/2024-06-22-3dMattevsGlossyPLAFilamentWhichShouldYouChoose"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PLA 필라멘트 매트 3D 프린트와 글로시 3D 프린트, 어떤 것을 선택해야 할까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-3dMattevsGlossyPLAFilamentWhichShouldYouChoose_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PLA 필라멘트 매트 3D 프린트와 글로시 3D 프린트, 어떤 것을 선택해야 할까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">PLA 필라멘트 매트 3D 프린트와 글로시 3D 프린트, 어떤 것을 선택해야 할까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안디노 만들기 - 오픈 소스 로봇 2부 하드웨어 조립 및 테스트 방법" href="/post/2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안디노 만들기 - 오픈 소스 로봇 2부 하드웨어 조립 및 테스트 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안디노 만들기 - 오픈 소스 로봇 2부 하드웨어 조립 및 테스트 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">안디노 만들기 - 오픈 소스 로봇 2부 하드웨어 조립 및 테스트 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link posts_-active__YVJEi" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"Arduino를 사용하여 RC 수신기 신호 읽는 방법","description":"","date":"2024-06-22 18:46","slug":"2024-06-22-HowtoreadRCreceiversignalwithArduino","content":"\n\n![img](/assets/img/2024-06-22-HowtoreadRCreceiversignalwithArduino_0.png)\n\nRC 송신기와 수신기를 서보 모터 또는 비행 제어기와 함께 사용하는 방법에 대한 문서를 쉽게 찾을 수 있지만, Arduino를 사용하여 RC 신호를 읽는 예제를 찾기는 그렇게 쉽지 않습니다. 그래서 매우 직관적인 자습서를 작성하기로 결정했습니다.\n\n저는 FlySky FS-I6X 송신기와 FS-iA10B 수신기를 사용하고 있지만, PWM(Pulse With Modulation)을 지원하는 모든 수신기에서 작동해야 합니다. 이는 Arduino가 ~ 기호로 표시된 핀을 통해 아날로그 값을 출력하기 위해 사용하는 프로토콜과 동일합니다(그러나 우리는 Arduino를 사용하여 읽을 것이므로 이러한 핀만 사용할 필요는 없습니다).\n\n의도는 읽고자 하는 각 채널의 수신기 핀을 Arduino의 디지털 포트에 연결하는 것입니다. 매우 직관적입니다. Arduino 핀은 입력 포트로 작동하고 수신기도 Arduino의 5V에서 전원을 공급받아야 합니다. 이것은 수신기의 5개 채널, 짐벌을 위한 4개 채널, 그리고 온/오프 스위치를 위한 1개 채널을 읽기 위한 배선 스키마입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![How to read RC receiver signal with Arduino](/assets/img/2024-06-22-HowtoreadRCreceiversignalwithArduino_1.png)\n\nArduino 스케치에서는 사용 중인 핀을 입력 핀으로 설정해야 하며 `pinMode(pin, INPUT)`과 같이 값을 읽을 때 `pulseIn(inputPort, HIGH, 2500)` 함수를 사용하여 값을 읽을 것입니다. 이는 실전에서 1000에서 2000 사이의 숫자를 의미하는 펄스의 지속 시간을 반환합니다. 짐벌에 대한 부정적인 값의 경우 1000에서 1499까지의 숫자를 읽을 것입니다. 0의 경우 1500을 읽습니다. 양수 값의 경우 1501에서 2000까지의 숫자를 읽습니다. 물론 송신기 구성에 따라 약간 달라질 수 있습니다. 이 범위로 작업하는 대신 다음과 같은 매우 편리한 함수를 사용할 수 있습니다. `map(channelValue, 1000, 2000, -100, 100)`. 이는 수신기에서의 모든 입력을 -100에서 100 사이의 비례적인 숫자로 변환할 것입니다. 수신기가 꺼져 있으면 아마도 값이 0이 되므로 이를 방지하기 위해 코드를 보호해야 합니다.\n\n다른 주의해야 할 점은 송신기의 반전 기능입니다. 사용 가능한 스위치 중 하나에 대해 이를 사용했습니다. FlySky 송신기는 수신기에 연결하기 전에 모든 스위치를 올리도록 강제하므로 `off` 값은 실제로 최고 값인 2000입니다. 따라서 이 채널을 반전시키면 `off` 값이 최소값인 1000이 되도록 할 수 있을 것입니다. 그러나 실수로 송신기를 끈 채 수신기를 켰을 때, 신호가 읽히지 않는 `on` 상황이 발생할 수 있습니다. 송신기를 끈 채로 수신기를 켜면 절대 안 되는 것은 알지만 개발 중에는 사고가 발생하기도 합니다. 따라서 반전 신호 기능을 사용하기보다는 사전에 예방하는 것이 좋습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-HowtoreadRCreceiversignalwithArduino_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoreadRCreceiversignalwithArduino_0.png","tag":["Tech"],"readingTime":2},{"title":"TCS3200 센서를 이용한 NPK질소, 인산, 칼륨 검출 방법","description":"","date":"2024-06-22 18:45","slug":"2024-06-22-NPKDetectionusingTCS3200sensor","content":"\n\nNPK는 질소, 인 및 칼륨으로 토양에서 가장 기본적인 영양소입니다. 이 무기 성분들은 식물 성장에 도움이 되는 토양의 비옥도를 유지하는 데 중요합니다. 전통적인 NPK 센서는 토양 속 질소, 인 및 칼륨 함량을 결정하는 데 적합하며, 토양 내 질소, 인 및 칼륨 농도에 의해 유도된 전도도 변화를 검출하여 토양의 비옥도를 평가합니다. 그러나 이 센서의 단점은 토양에 삽입되어 값을 테스트해야 하며, 이 값은 특정 영역에만 적용되며 이 센서로 얻은 값은 토양 내 NPK 함량의 정확한 양을 측정할 수는 없지만 작농가들이 비료를 적용하는 데 도움이 되는 경험적 및 이론적 값이 제공됩니다. 따라서 현장 테스트는 수행할 수 없습니다. 이때 TCS3200 센서가 도움이 될 수 있습니다. NPK 센서보다 효율적이며 현장 토양 테스트를 쉽게 수행할 수 있습니다.\n\n# TCS3200 센서:\n\n![TCS3200](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_0.png)\n\n위 이미지는 TCS3200 색상 센서입니다. 이 센서는 기본적으로 RGB 색상 센서이며 이미지에서 볼 수 있듯이 회로 기판의 각 모서리에 4개의 흰색 조명 LED와 4개의 단자가 있지만, 실제 센서는 중앙에 위치해 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![TCS3200 Sensor](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_1.png)\n\n이전에 언급했듯이, RGB 강도를 감지하는 데 사용되고 원리는 다음과 같습니다. TCS3200 센서는 빛 강도 및 색에 해당하는 주파수를 가진 제곱파(50% 듀티사이클)를 출력하며, 이 주파수는 빛 강도에 직접적으로 비례합니다. TCS3200D의 전형적인 출력 주파수 범위는 2Hz에서 500KHz입니다.\n\n- RGB 감지용 TCS3200 센서\n이 분석에서는 TCS3200 센서와 LED를 연결하는데 Arduino Uno를 마이크로컨트롤러 보드로 사용했습니다.\n\n![TCS3200 Sensor with Arduino Uno](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 회로는 TCS3200 센서를 통해 RGB 검출을 위한 것이며, 결과는 아두이노 Uno 마이크로컨트롤러 보드에 연결된 LED로 표시됩니다.\n\n2. NPK 검출 및 균일한 비료 분사를 위한 TCS3200 센서\n\n먼저 ppm을 기반으로 NPK 양을 분석해야 합니다. 이에 따라 많은 연구 끝에 질소, 인 및 칼륨이 아래에 나와 있는 것처럼 Blue, Green 및 Red에 민감하다는 것이 밝혀졌습니다.\n\n![NPKDetectionusingTCS3200sensor](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 로직에 기반하여 색 감지 및 기타 작업을 위한 분석을 수행했습니다:\n\n빨강 값:\n\nredValue=pulseIn(sensorOut, LOW)\n\n초록 값:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ngreenValue = pulseIn(sensorOut, LOW)\n\n파란색 값:\n\nblueValue = pulseIn(sensorOut, LOW)\n\n빨간색이 우세할 때:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n파란색 값을 pulseIn(sensorOut, LOW) 으로 가져옵니다.\n\nR ` B and R ` G\n\n만약 파란색이 우세하다면:\n\nblueValue=pulseIn(sensorOut, LOW)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nB ` R 와 B ` G\n\nRGB 값 읽기:\n\nredValue = pulseIn(sensorOut, LOW)\n\ngreenValue = pulseIn(sensorOut, LOW)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nblueValue = pulseIn(sensorOut, LOW)\n\nR = pulseIn(sensorOut, LOW)\n\nG = pulseIn(sensorOut, LOW)  \n\nB = pulseIn(sensorOut, LOW)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n색상 감지:\n\n- R 밴드 R과 G ⟹ θ = 0도\n- B(R) and B(G) ⟹ θ = 90도\n- B와 G ⟹ θ = 90도\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 표는 탐지를 위해 수행된 연구, 분석 및 연구에 대한 내용입니다. 그러나 비료 분사 부분에는 Arduino Uno 및 3개의 서보 모터가 TCS3200 빛 센서와 통합되었습니다. 이러한 구성요소 간의 연결은 다음과 같습니다:\n\nTCS3200 및 Arduino Uno\n\n![이미지](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_4.png)\n\nArduino Uno 및 서보 모터\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 제안된 아이디어입니다.\n\n아래의 링크에서 코드를 확인해보세요: https://github.com/SumukhJK","ogImage":{"url":"/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_0.png"},"coverImage":"/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_0.png","tag":["Tech"],"readingTime":3},{"title":"두통 없이 WiFi 모듈 ESP-01 ESP8266 사용하는 방법","description":"","date":"2024-06-22 18:43","slug":"2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache","content":"\n\n요즘, ESP32와 Arduino UNO 보드를 통합하여 스마트 홈 시스템을 만드는 것을 시도해보고 있어요. 집의 식물을 위한 보습 장치 같은 거 말이죠. 여기에는 그 여정과 그 과정에서 주요한 고충 포인트에 대해 설명하겠어요. 그리고 왜 NodeMCU의 ESP8266을 사용하게 된 이유에 대해서도 언급할게요.\n\n그래서 원하던 흐름은 다음과 같아요:\n\n- 시스템을 처음 시작할 때, 액세스 포인트 시작.\n- AP에 연결하고 로컬 네트워크의 SSID와 비밀번호를 요청하는 웹 페이지를 열기.\n- 데이터가 전달된 후, 시스템은 SSID와 비밀번호를 EEPROM에 저장하고 액세스 포인트를 중지하고 로컬 Wi-Fi에 클라이언트로 연결해야 해요.\n\n# ESP-01\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것을 조사하기 시작했을 때, ESP-01에 대한 아주 좋은 아이디어라고 생각했어요. 작고 저렴하면서 필요한 기능을 모두 갖추고 있거든요.\n\nESP-01은 Arduino를 이용해 RX/TX 핀을 통해 AT 프로토콜을 사용하여 제어할 수 있어요.\n\n하지만 UART AT 명령어를 사용하는 동안 약간의 조사를 한 후, Arduino의 메모리는 코딩을 끝내기 전에 사라질 것 같다는 사실을 알게 되었어요. ESP8266은 훨씬 더 많은 메모리를 가지고 있어요. 비교해 보면 ESP8266은 80kB의 메모리를 가지고 있고, Arduino Uno는 2kB를 갖고 있어요. 이는 계산기로부터 PC를 제어하려는 것과 비슷해요. 이런 방식은 작동하지 않아요.\n\n게다가, ESP 기반 컨트롤러는 IO 핀을 가지고 있어요. 이러한 핀을 Arduino에 연결하는 수고를 덜며 문제를 해결할 수 있어요. 그래서 ESP를 Arduino에서 제어해야 할까요? 그렇지 마세요! 이렇게 하지 마세요. 반드시 그렇게 해야 하는 것은 아니에요. 이 글이 다른 사람들이 제 실수를 반복하는 것을 막아줄 수 있기를 바라요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에서 ESP를 올바르게 사용하는 방법을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache_0.png)\n\n# NodeMCU의 ESP8266\n\nESP-01의 사용은 Arduino와 함께 여러 문제가 위에서 설명된 것과 맞닿아 있습니다 !!!!!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n반면에, NodeMCU의 ESP8266은 쉽게 다가갈 수 있는 친구에요. ESP 모듈이 내장되어 있고 좋은 컴퓨팅 성능을 갖추고 있습니다. 또한 배선이 필요하지 않아요.\n\n## 단계 1. 설정.\n\n가장 먼저, NodeMCU 칩과 작업할 수 있도록 Arduino IDE와 OS를 설정해야 합니다.\n\n시스템에서 시리얼을 보이도록 CH340G 드라이버를 설치해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- macOS\n- Linux\n- Windows\n\n도구 - 보드 - 보드 관리자로 이동하세요. esp8266 보드 관리자를 설치하세요.\n\n\u003cimg src=\"/assets/img/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache_1.png\" /\u003e\n\n그 후, ESPAsyncTCP와 ESPAsyncWebServer 라이브러리를 설치해야 합니다. 저장소를 복제하고 이름에서 \"-master\"를 제거하세요. 그 폴더들을 Arduino/libraries/ 폴더로 이동하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코딩을 시작할 준비가 모두 완료되었어요.\n\n## 단계 2. 코딩.\n\n접속 지점 SSID/비밀번호를 설정 중입니다.\n\n```js\nconst char* ssid = \"ESP8266-Access-Point\";\nconst char* password = \"123456789\";\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서버 액세스시 반환할 HTML 페이지:\n\n```js\nconst char index_html[] PROGMEM = R\"rawliteral(\n\u003c!DOCTYPE HTML\u003e\n\u003chtml\u003e\n  \u003chead\u003e\n    \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e\n    \u003cstyle\u003e\n      html {\n        font-family: Arial;\n        display: inline-block;\n        margin: 0px auto;\n        text-align: center;\n      }\n      h2 {\n        font-size: 3.0rem;\n      }\n      p { \n        font-size: 3.0rem;\n      }\n      .units {\n        font-size: 1.2rem;\n      }\n      .input {\n        font-size: 20px;\n        margin-bottom: 10px;\n      }\n      .wifi-form {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: space-around;\n      }\n    \u003c/style\u003e\n  \u003c/head\u003e\n  \u003cbody\u003e\n    \u003cdiv class=\"wifi-form\"\u003e\n      \u003ch1\u003e테스트\u003c/h1\u003e\n      \u003cinput id=\"ssid\" class=\"input\" type=\"text\" maxlength=\"32\"\u003e\n      \u003cinput id=\"password\" class=\"input\" type=\"password\"\u003e\n      \u003cbutton onclick=\"connectToWifi()\"\u003e연결\u003c/button\u003e\n    \u003c/div\u003e\n  \u003c/body\u003e\n  \u003cscript\u003e\n    function connectToWifi() {\n      var ssid = document.getElementById(\"ssid\").value;\n      var password = document.getElementById(\"password\").value;\n      var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"/\", true);\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      xhr.send(ssid + \":\" + password);\n    }\n  \u003c/script\u003e\n\u003c/html\u003e)rawliteral\";\n```\n\n로컬 Wi-Fi의 SSID와 비밀번호를 요청하는 간단한 양식입니다.\n\nconnectToWifi 함수는 POST 요청으로 데이터를 서버로 전송합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요청을 처리할 서버를 설정해 봅시다.\n\n다음을 글로벌 변수로 추가해 주세요.\n\n```js\nAsyncWebServer server(80);\n```\n\n접속 지점 함수를 만들어 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvoid createAccessPoint() {\n  WiFi.softAP(ssid, password);\n  IPAddress IP = WiFi.softAPIP();\n  Serial.print(\"AP IP address: \");\n  Serial.println(IP);\n  // Print ESP8266 Local IP Address\n  Serial.println(WiFi.localIP());\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request) {\n    request-\u003esend_P(200, \"text/html\", index_html);\n  });\n  server.on(\"/\", HTTP_POST, [](AsyncWebServerRequest *request){},NULL, [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {\n    ssidWifi = \"\";\n    passwordWifi = \"\";\n    String res((char *)data);\n    int sepIndex = -1;\n    for (int i = 0; i \u003c len; ++i) {\n      if (res[i] != ':') {\n        if (sepIndex == -1) {\n          ssidWifi.concat(res[i]);\n        }\n        if (i \u003e sepIndex \u0026\u0026 sepIndex != -1) {\n          passwordWifi.concat(res[i]);\n        }\n      }\n      else {\n        sepIndex = i;\n      }\n    }\n    writeEEPROM(ssidWifi, ssidIndex);\n    writeEEPROM(passwordWifi, passwordIndex);\n    request-\u003esend(200, \"text/plain\", \"SUCCESS\");\n  });\n  server.begin();\n}\n```\n\n우리가 이걸 살펴보자.\n\n```js\nWiFi.softAP(ssid, password);\n```\n\n이 부분은 시작 시 SSID 및 비밀번호가 전달되어 액세스 포인트를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nIPAddress IP = WiFi.softAPIP();\nSerial.print(\"AP IP 주소: \");\nSerial.println(IP);\n// ESP8266 로컬 IP 주소 출력\nSerial.println(WiFi.localIP());\n```\n\n로그 기능입니다. 디버깅에 필요합니다.\n\n```js\nserver.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request) {\n    request-\u003esend_P(200, \"text/html\", index_html);\n});\n```\n\nHTTP GET 요청을 처리하고 HTML 페이지를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nserver.on(\"/\", HTTP_POST, [](AsyncWebServerRequest *request){},NULL, [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {\n    ssidWifi = \"\";\n    passwordWifi = \"\";\n    String res((char *)data);\n    int sepIndex = -1;\n    for (int i = 0; i \u003c len; ++i) {\n      if (res[i] != ':') {\n        if (sepIndex == -1) {\n          ssidWifi.concat(res[i]);\n        }\n        if (i \u003e sepIndex \u0026\u0026 sepIndex != -1) {\n          passwordWifi.concat(res[i]);\n        }\n      }\n      else {\n        sepIndex = i;\n      }\n    }\n    writeEEPROM(ssidWifi, ssidIndex);\n    writeEEPROM(passwordWifi, passwordIndex);\n    request-\u003esend(200, \"text/plain\", \"SUCCESS\");\n  });\n```\n\n위 코드는 포스트 요청을 처리합니다. AsyncWebServer 요청을 받아들이기 위해 다섯 번째 매개변수를 AsyncWebServer 요청으로 추가해야 합니다. 알고리즘은 매우 간단합니다. 글로벌 변수인 ssidWifi와 passwordWifi를 지웁니다. SSID:password를 이런 형식으로 구문 분석하고 데이터를 EEPROM에 저장합니다.\n\n그 후에 서버를 시작합니다.\n\nssidIndex는 0이며, 이는 데이터의 시작 주소입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패스워드 인덱스는 33입니다. 이는 SSID 최대 길이가 32바이트이며, 하나의 바이트가 문자열의 길이로 예약되어 있기 때문입니다. 이를 writeEEPROM 함수에서 확인할 수 있습니다:\n\n```js\nvoid writeEEPROM(String value, int address) {\n  int len = value.length();\n  EEPROM.put(address, len);\n  for (int i = address + 1; i \u003c len + address + 1; ++i) {\n    EEPROM.put(i, value[i - address - 1]);\n  }\n  EEPROM.commit();\n}\n```\n\n이제 이러한 데이터를 EEPROM에서 읽을 수 있어야 합니다:\n\n```js\nString readEEPROM(int address) {\n  uint8_t len = EEPROM.read(address);\n  if (len == 255) return \"\";\n  String res;\n  for (int i = address + 1; i \u003c len + address + 1; ++i) {\n    char c = (char)EEPROM.read(i);\n    res.concat(c);\n  }\n  return res;\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n255- 이는 비어 있는 데이터를 나타냅니다. 여기서는 먼저 데이터 길이에 할당된 첫 번째 바이트를 받아 그 후의 데이터를 읽고 결과를 반환합니다.\n\n이제 모든 것을 함께 묶어 보겠습니다.\n\n```js\nvoid setup() {\n  Serial.begin(9600);\n  EEPROM.begin(128);\n  ssidWifi = readEEPROM(ssidIndex);\n  passwordWifi = readEEPROM(passwordIndex);\n  if (ssidWifi.length() \u003e 0 \u0026\u0026 passwordWifi.length() \u003e 0 \u0026\u0026 WiFi.status() != WL_CONNECTED) {\n    WiFi.softAPdisconnect(true);\n    server.end();\n    WiFi.begin(ssidWifi, passwordWifi);\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(1000);\n    }\n  }\n  else\n  {\n    createAccessPoint();\n  }\n}\nvoid loop() {\n  if (ssidWifi.length() \u003e 0 \u0026\u0026 passwordWifi.length() \u003e 0 \u0026\u0026 WiFi.status() != WL_CONNECTED) {\n    WiFi.softAPdisconnect(true);\n    server.end();\n    WiFi.begin(ssidWifi, passwordWifi);\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(1000);\n    }\n  }\n}\n```\n\n여기까지입니다. 하드코딩 없이 wifi 자격 증명을 설정할 수 있는 웹페이지가 있는 서버를 시작하는 작동하는 시스템이 준비되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 GitHub의 작동 예제 링크를 변경하십시오.","ogImage":{"url":"/assets/img/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache_0.png"},"coverImage":"/assets/img/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache_0.png","tag":["Tech"],"readingTime":8},{"title":"ESP32로 SD 카드 IO 성능 최적화하는 방법","description":"","date":"2024-06-22 18:42","slug":"2024-06-22-OptimizingSDCardIOPerformancewithESP32","content":"\n\n# 저에 대해\n\n안녕하세요, 저는 지위 마오입니다. 지반공학 기술자이자 IoT 시스템에 열정을 가진 사람입니다. 저는 저전력 마이크로컨트롤러와 LoRa 통신 시스템을 연구하여 취미로 사용할 수 있는 원격 모니터링 솔루션부터 산업용 모니터링 또는 제어 시스템을 구축하고 있습니다. 제 웹사이트를 방문해주세요: https://www.qiweimao.dev/blog\n\nLinkedIn | Github | Reddit | X\n\n# 많은 파일로 인해 SD 카드 I/O 속도가 느려지는 이유\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSD 카드의 단일 폴더에 대량의 파일을 축적하면 파일 시스템(FAT32 또는 exFAT과 같은 SD 카드용)이 파일을 찾거나 열기 위해 디렉터리 항목을 검색해야 합니다. 파일이 증가함에 따라 이 디렉터리 검색 프로세스는 느려질 수 있습니다. 그 이유는 다음과 같습니다:\n\n- 디렉터리 항목: FAT32와 exFAT은 디렉터리 항목을 선형 목록에 저장합니다. 파일이 늘어날수록 이 목록을 검색하는 시간이 선형적으로 증가하므로 특정 파일을 찾거나 열 때 상당히 더 많은 시간이 걸릴 수 있습니다.\n- 단편화: 파일이 생성되고 삭제되며 수정되면 시간이 지남에 따라 단편화가 발생할 수 있습니다. 이는 파일의 일부가 SD 카드의 다른 물리적 위치에 퍼져 있을 수 있어 파일을 읽는 데 걸리는 시간을 증가시킬 수 있습니다.\n- 클러스터 할당: 각 파일 및 디렉터리 항목에는 클러스터 할당이 필요하며, 이는 파일 할당 테이블(FAT)에 의해 관리됩니다. 많은 파일을 처리할수록 이러한 할당을 업데이트하고 관리하는 과정이 더 복잡하고 시간이 많이 소요됩니다.\n\n# 입출력 테스트\n\n다음은 단일 디렉터리의 모든 파일을 기록하는 것과 하위 폴더 전략을 사용하는 것 사이의 속도 차이를 비교하는 두 테스트 프로그램에 대한 개요입니다. 이 프로그램은 각 쓰기 동작에 걸리는 시간을 기록하고 이 정보를 로그 파일에 저장할 것입니다. ESP32는 500ms마다 파일 쓰기 동작을 시작할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Optimizing SD Card I/O Performance with ESP32](/assets/img/2024-06-22-OptimizingSDCardIOPerformancewithESP32_0.png)\n\nESP32에서 SD 카드 I/O의 성능 분석 결과, 파일을 하나의 폴더에 저장하는 것과 분 단위로 서브폴더에 구성하는 것 사이에 명확한 추세 차이가 나타납니다.\n\n하나의 폴더에 순차적으로 파일을 저장하는 경우 파일 수가 증가함에 따라 파일 I/O 시간이 선형적으로 증가하는 것을 확인할 수 있습니다. 이는 대량 디렉토리 내의 파일 접근 및 관리가 검색 및 검색 시간이 증가하여 점진적으로 느려진다는 것을 시사합니다. 반면에, 서브폴더 접근 방식은 초기에는 I/O 시간이 비슷하게 증가하지만 새 파일이 새로운 서브폴더로 이동함에 따라 접근 시간이 간헐적으로 감소합니다.\n\n이 현상은 파일을 작은 시간 기반 클러스터로 조직화하는 것이 단일 폴더 저장 과정에서 관찰된 성능 하락을 완화하는 것을 나타냅니다. 이러한 조직 전략은 액세스 속도를 최적화할 뿐만 아니라 저장 부하를 관리 가능한 하위 집합에 분산하여 전체 시스템 효율성을 향상시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 프로그램 1: 단일 디렉토리 로깅\n\n```cpp\n#include \u003cArduino.h\u003e\n#include \u003cSD.h\u003e\n#include \u003cSPI.h\u003e\n\nconst int chipSelect = 5;\nconst String dataFolder = \"/data\";\nconst String logFileName = \"/io_time_log_single.txt\";\nconst int interval = 500; // 1분 간격\nunsigned long previousMillis = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  if (!SD.begin(chipSelect)) {\n    Serial.println(\"카드 연결 실패 또는 없음\");\n    while (1);\n  }\n  if (!SD.exists(dataFolder)) {\n    SD.mkdir(dataFolder);\n  }\n}\n\nvoid logData() {\n  unsigned long start = millis();\n  String fileName = dataFolder + \"/data_\" + String(start) + \".txt\";\n  File dataFile = SD.open(fileName, FILE_WRITE);\n\n  if (dataFile) {\n    dataFile.println(\"더미 시계열 데이터\");\n    dataFile.close();\n  }\n\n  unsigned long end = millis();\n  File logFile = SD.open(logFileName, FILE_APPEND);\n  if (logFile) {\n    logFile.println(String(start) + \",\" + String(end - start));\n    logFile.close();\n  }\n}\n\nvoid loop() {\n  unsigned long currentMillis = millis();\n  if (currentMillis - previousMillis \u003e= interval) {\n    previousMillis = currentMillis;\n    logData();\n  }\n}\n```\n\n### 프로그램 2: 서브폴더 전략 로깅\n\n```cpp\n#include \u003cArduino.h\u003e\n#include \u003cSD.h\u003e\n#include \u003cSPI.h\u003e\nconst int chipSelect = 5;\nconst String dataFolder = \"/data\";\nconst String logFileName = \"/io_time_log_subfolder.txt\";\nconst int interval = 500; // 1분 간격\nunsigned long previousMillis = 0;\nvoid setup() {\n Serial.begin(115200);\n if (!SD.begin(chipSelect)) {\n Serial.println(\"카드 연결 실패 또는 없음\");\n while (1);\n }\n if (!SD.exists(dataFolder)) {\n SD.mkdir(dataFolder);\n }\n}\nvoid createDirectories(String path) {\n String subPath = \"\";\n int start = 0;\n int end = path.indexOf('/', start);\nwhile (end != -1) {\n subPath = path.substring(0, end);\n if (!SD.exists(subPath)) {\n SD.mkdir(subPath);\n }\n start = end + 1;\n end = path.indexOf('/', start);\n }\nif (!SD.exists(path)) {\n SD.mkdir(path);\n }\n}\nvoid logData() {\n unsigned long start = millis();\n \n // 현재 밀리초 단위 시간을 기준으로 서브폴더 생성\n unsigned long totalMinutes = start / 60000;\n unsigned long totalHours = totalMinutes / 60;\n unsigned long totalDays = totalHours / 24;\nString day = String(totalDays);\n String hour = String(totalHours % 24);\n String minute = String(totalMinutes % 60);\nString subFolder = dataFolder + \"/\" + day + \"/\" + hour + \"/\" + minute;\n createDirectories(subFolder);\nString fileName = subFolder + \"/data_\" + String(start) + \".txt\";\n \n start = millis();\n File dataFile = SD.open(fileName, FILE_WRITE);\n if (dataFile) {\n dataFile.println(\"더미 시계열 데이터\");\n dataFile.close();\n }\n unsigned long end = millis();\n \n File logFile = SD.open(logFileName, FILE_APPEND);\n if (logFile) {\n logFile.println(String(start) + \",\" + String(end - start));\n logFile.close();\n }\n}\nvoid loop() {\n unsigned long currentMillis = millis();\n if (currentMillis - previousMillis \u003e= interval) {\n previousMillis = currentMillis;\n logData();\n }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n파일을 하위 디렉터리로 구성하고, 바이너리 형식을 사용하며, 메모리 내 메타데이터를 유지하고, 쓰기와 읽기 모두 최적화된 파일 구조를 사용함으로써 ESP32 데이터 로거의 I/O 성능을 크게 향상시킬 수 있습니다. 이러한 전략은 많은 수의 파일을 관리하고 LoRa 네트워크를 통해 효율적인 데이터 검색 및 전송을 보장하는 데 도움이 될 것입니다.","ogImage":{"url":"/assets/img/2024-06-22-OptimizingSDCardIOPerformancewithESP32_0.png"},"coverImage":"/assets/img/2024-06-22-OptimizingSDCardIOPerformancewithESP32_0.png","tag":["Tech"],"readingTime":5},{"title":"레진 3D 프린팅 vs 필라멘트 프린팅 장단점 비교","description":"","date":"2024-06-22 18:41","slug":"2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting","content":"\n\n![이미지](/assets/img/2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting_0.png)\n\n# I. 소개:\n\n3D 프린팅은 부가 제조라고도 하는데, 연속적인 재료 층을 쌓아 세 가지 차원의 물체를 만드는 과정입니다. 프로토타이핑, 제품 개발부터 제조 및 예술 표현까지 다양한 작업에 널리 사용되고 있습니다.\n\n3D 프린팅에 사용되는 다양한 재료 중 일반적으로 사용되는 것은 플라스틱 필라멘트와 레진입니다. 필라멘트 프린팅은 녹은 플라스틱을 노즐을 통해 압출하여 단계별로 물체를 쌓는 과정을 포함합니다. 반면 레진 프린팅은 미세한 소재로 만들어진 광반응성 액체 레진을 UV 광선(일반적으로 레이저 또는 LED)을 사용하여 층별로 경화시키고 고체화합니다. 필라멘트와 레진 프린팅은 각각 고유한 장단점이 있으며, 본 문서에서 자세히 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# II. 수지 3D 프린팅의 장점:\n\n수지 3D 프린팅의 주요 이점 중 하나는 높은 정도의 세부 사항과 섬세함을 달성할 수 있다는 것입니다. 수지 프린팅은 빔 광선을 사용하여 물질을 단계별로 경화하고 고체화하는데, 이는 필라멘트 프린팅으로는 세밀하거나 얻기 어려운 매우 섬세하고 정확한 특징을 만들기에 적합합니다. 이는 보석이나 치과 임플란트와 같이 정교하고 놀랍도록 섬세한 물체를 만드는 데 수지 프린팅이 이상적이라는 것을 의미합니다.\n\n수지 프린팅의 또다른 장점은 사용 가능한 다양한 소재의 범위입니다. 3D 프린팅에 사용할 수 있는 다양한 종류의 수지가 있으며, 각각 고유한 특성과 응용 분야를 갖고 있습니다. 예를 들어, 의료 또는 치과 수술용으로 특별히 공식화된 수지뿐만 아니라, 다양한 금속이나 세라믹 속성을 모방한 수지도 있습니다. 이를 통해 특정 요구 사항 및 운용에 가장 적합한 소재를 선택할 수 있습니다.\n\n세부 사항과 정밀성 뿐만 아니라, 수지 프린트는 강하고 내구성이 뛰어난 것으로도 알려져 있습니다. 수지가 단계별로 경화되고 고체화되므로 층 간 강력한 결합을 유발하고 파괴나 왜곡에 저항하는 프린트물을 만들어낼 수 있습니다. 이는 응력이나 마모에 시달리는 기능적인 부품이나 물체를 만드는 데 좋은 선택이 되도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# III. Resin 3D 프린팅의 단점:\n\n레진 3D 프린팅의 주요 단점 중 하나는 비용입니다. 레진 프린터는 필라멘트 프린터보다 가격이 더 비싸며, 레진 재료 자체도 일반적으로 필라멘트보다 비싸다. 이는 예산이 촉박한 사람들에게는 더 어렵게 만들 수 있습니다.\n\n비용 외에도, 레진 프린팅은 전문 장비와 레진 프린터가 필요합니다. 이 프린터는 일반적으로 필라멘트 프린터보다 더 복잡하고 유지보수가 더 많이 필요하기 때문에 일부 사용자에게는 장애물이 될 수 있습니다.\n\n레진 프린팅의 또 다른 묵시적 문제는 프린트물이 인쇄 과정 중에 왜곡되거나 수축하는 경향이 있다는 것입니다. 이는 사용되는 레진의 종류, 프린트가 이루어지는 환경 또는 물체의 디자인과 같은 여러 요인에 의해 발생할 수 있습니다. 왜곡과 수축은 변형되거나 불균일한 프린트물로 이어질 수 있으며, 원하는 결과를 얻기 위해 추가 후처리 또는 보조 구조물이 필요할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# IV. 필라멘트 프린팅의 장점:\n\n필라멘트 3D 프린팅의 주요 장점 중 하나는 널리 보급되어 비용 효율적이라는 것입니다. 필라멘트는 레진보다 훨씬 일반적이며 비용도 낮아 많은 사용자에게 더 접근하기 쉬운 옵션이 됩니다. 필라멘트 프린터는 또한 일반적으로 레진 프린터보다 더 저렴하여 3D 프린팅을 시작하는 개인 또는 소기업에게 더 쉽게 접근할 수 있습니다.\n\n필라멘트 프린팅의 또 다른 이점은 사용할 수 있는 프린터의 종류에 대한 유연성입니다. 필라멘트 프린터는 다양한 크기와 가격대로 제공되어, 특정 요구 사항과 예산에 맞는 프린터를 쉽게 찾을 수 있습니다. 또한, 필라멘트는 FDM(융착 퓨전 성형), SLA(스테레오리소그래피) 및 기타 다양한 유형의 프린터와 함께 사용할 수 있습니다.\n\n필라멘트 프린팅은 사용하기 쉽고 사용자 정의하기 쉽다는 점으로도 알려져 있습니다. 필라멘트는 프린터에서 쉽게 로드하고 언로드할 수 있으며, 다양한 색상, 속성 및 응용 프로그램을 지원하는 다양한 종류의 필라멘트가 있습니다. 이를 통해 출력물을 사용자 정의하고 다양한 제품을 생산하는 것이 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# V. 필라멘트 프린팅의 단점:\n\n필라멘트 프린팅의 주요 제한 사항 중 하나는 수지 프린팅과 비교하여 상세함과 섬세함의 수준이 낮다는 것입니다. 필라멘트 프린팅은 녹은 플라스틱을 노즐을 통해 내출하는 과정이 포함되기 때문에, 수지 프린팅만큼 미세한 세부 사항과 정확도를 달성하기에는 적합하지 않습니다. 이는 상세하거나 정확한 출력물이 필요한 사람들에게는 단점일 수 있습니다.\n\n상세함과 정확도가 낮다는 점 외에, 필라멘트 프린팅은 수지 프린팅과 비교하여 사용 가능한 재료 범위도 더 한정적입니다. 필라멘트의 종류는 다양하지만, 일반적으로 수지 프린팅에서 사용할 수 있는 수지와 같이 다양하거나 특수화된 것들은 아닙니다. 이는 출력물로부터 특정한 속성이나 기능이 필요한 사람들에게 제한이 될 수 있습니다.\n\n필라멘트 프린팅은 또한 출력물 사이에 얇은 플라스틱 줄이 남아있는 스트링핑(stringing)과 출력물에 갭이나 구멍이 남는 등의 결함에 취약합니다. 이러한 결함은 필라멘트의 품질, 프린터의 보정, 또는 출력하려는 제품의 설계와 같은 다양한 요소로 인해 발생할 수 있습니다. 프린터를 신중하게 설정하고 조정함으로써 이러한 결함을 최소화하거나 제거할 수는 있지만, 일부 사용자에게는 여전히 답답함을 줄 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# VI. 결론:\n\n결론적으로, 수지 인쇄와 필라멘트 인쇄는 각자 고유한 장단점을 갖고 있습니다. 수지 인쇄는 높은 정밀도와 정확성, 다양한 소재 선택, 강력하고 내구성 있는 출력물을 제공하지만, 비용이 높고 기술적인 장비가 필요할 수 있습니다. 반면에 필라멘트 인쇄는 보편적으로 사용 가능하고 가격이 덜 비싸며 다양한 프린터와 함께 사용할 수 있으며 쉽고 사용자 정의가 가능하지만, 낮은 정밀도와 정확성 및 제한된 소재 범위가 있습니다.\n\n수지 인쇄와 필라멘트 인쇄 중 어느 것을 선택할지 결정할 때, 본인의 특정 요구사항과 예산을 고려하는 것이 중요합니다. 그러나, 만약 상세하거나 정확한 출력물이 필요하고 필요한 장비와 소재에 투자할 용의가 있다면, 수지 인쇄가 더 나은 선택일 수 있습니다. 반면에, 예산이 제약되어 있거나 최고 수준의 세부 정보가 필요하지 않다면, 필라멘트 인쇄가 비용 효율적인 선택일 수 있습니다. 최종적으로, 여러분에게 가장 적합한 선택은 본인의 구체적인 목표와 상황에 달려 있을 것입니다.","ogImage":{"url":"/assets/img/2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting_0.png"},"coverImage":"/assets/img/2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting_0.png","tag":["Tech"],"readingTime":4},{"title":"안의 미스터리 4부","description":"","date":"2024-06-22 18:40","slug":"2024-06-22-MysteriesofAnPart4","content":"\n\n시리즈 \"Mysteries of An\"에 오신 걸 환영합니다. 각각의 디지털 아트 작품은 알 수 없는 신비한 세계를 엿보게 해주는 창을 엽니다. 신비한 대기와 매혹적인 풍경을 가진 행성 An은 이 시리즈의 영감의 원천으로서의 역할을 합니다.\n\n\"Mysteries of An\" 에서의 각 작품은 다른 작품들과 함께 일관된 흥미로운 이야기를 이루는 거대한 캔버스의 한 부분입니다. 이 그림 속에서 Anomalites들은 생명을 얻어 고대 이야기와 신비한 전설을 전합니다. 마법의 생물, 환상적인 풍경, 풀리지 않은 미스터리가 펼쳐지며 당신을 위해 마법과 기술이 조화롭게 공존하는 세계에 몰입시킵니다.\n\n각 작품은 행성 An의 탐험되지 않은 구석으로 이끄는 세부사항으로 가득차며, 그 안에 숨겨진 진리와 비밀을 발견하게 합니다. 이 시리즈에는 완성된 그림 뿐만 아니라 스케치, 초고, 그리고 미래 작품의 개별 요소도 포함돼 있어 창조와 발견의 과정을 목격할 수 있게 해줍니다. \"Mysteries of An\"을 탐험하고 디지털 캔버스마다 감춰진 마법을 발견해보고, 판타지와 경이로운 세계로 빠져들어 보세요.\n\n이 지도 상의 가이드 마크를 따라가면 여행자들은 행성 An의 숨겨진 구석을 탐험할 수 있고, 놀라운 발견과 마법적인 모험으로 가득한 곳을 발견할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에 들러주셔서 너무 고마워요! 제 작품 세상에 대해 알아가셨군요!\n\n더 많은 정보는 제 웹사이트나 트위터 / 워프캐스트에서 찾아보실 수 있어요.\n\n오늘 하루도 행복하길 바라요!","ogImage":{"url":"/assets/img/2024-06-22-MysteriesofAnPart4_0.png"},"coverImage":"/assets/img/2024-06-22-MysteriesofAnPart4_0.png","tag":["Tech"],"readingTime":1},{"title":"오픈소스 IC 셀을 3D 프린터로 출력하는 방법 간단 가이드","description":"","date":"2024-06-22 18:39","slug":"2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide","content":"\n\n![이미지](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_0.png)\n\n## 아이디어와 어떤 배경:\n\n집적 회로(IC)와 오픈 소스가 한 문장에? 수십 년 동안 칩 디자인은 라이선스 수수료, 사용 요금, 비밀 유지 계약(NDA) 및 생산에 매우 높은 초기 재정적 장벽을 포함하는 폐쇄 도구의 영역이었습니다. 이것은 천천히 오픈 소스 도구 및 공유 생산 비용 방향으로 바뀌고 있지만, 여전히 오픈 소스 칩 디자인(오픈 소스 EDA)의 초기에 있습니다.\n\nGoogle과 Skywater Technology가 발표한 오픈 소스 프로세스 디자인 키트(PDK) \"SKY130\" 이후로 모든 사람이 실제 마이크로칩을 생산하기 위한 \"실제 표준 셀\"들을 더 깊이 살펴볼 수 있게 되었습니다. 여러분은 어떠한 NDA를 위반하는 걱정없이 그들에 대해 이야기하고 쓸 수 있습니다. 우리는 심지어 이 셀들을 3D 프린터로 출력할 수도 있습니다. 그리고 저는 그렇게 했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내가 인쇄한 3D 세포의 사진을 몇 개 트윗한 후 How-to 가이드를 작성하라는 요청을 받았어요. 이 안내서는 몇 단계로 나뉜 대략적인 계획으로, \"혼자서 아주 쉽게 5분 안에 따라 할 수 있는\" 가이드는 아니니까요. 이 점 주의하세요! 3D 프린터에 답답함을 느낄 수도 있고, 성공하기 위해 실리콘 칩의 구조에 대해 배워야 할 수도 있습니다.\n\n그리고, 제가 한 것처럼 손가락을 실수로 초고리액으로 붙이지 말아 주세요.\n\n모든 경고에도 불구하고: 즐기세요.\n\n## 테스트 완료:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 노트북 우분투 22.04\n- Ultimaker S5 + 자재 창고\n\n# 1: SKY130 OpenPDK에서 셀 선택하기\n\nSKY130 PDK 문서를 살펴보세요, 특히 7개의 SKY130 셀 라이브러리 개요를 살펴보고 라이브러리 중 하나를 선택하세요. 이 안내서에서는 고밀도 라이브러리 sky130_fd_sc_hd를 선택하겠습니다.\n\n인쇄할 표준 셀을 결정하세요. 쉬운 셀부터 시작하는 것이 좋습니다. 예를 들어 인버터입니다. 간단한 CMOS 인버터 셀은 두 개의 트랜지스터를 포함하고 다음과 같이 보입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_1.png)\n\nPDKs Github Repository에서 선택한 셀의 .gds 파일을 다운로드하세요. 단일 인버터의 경우 sky130_fd_sc_hd__inv_1.gds 파일입니다:\n\n# 2. GDS3D를 사용하여 셀의 .gds 파일 검토\n\n셀의 .gds 파일을 조사 가능한 3D 렌더링으로 보려면 Viewer 소프트웨어가 필요합니다. trilomix의 GDS3D를 사용하는 것을 제안합니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저장소를 다운로드하거나 복제하세요. /linux 폴더에는 미리 컴파일된 우분투 버전의 GDS3D가 있습니다. 실행 가능하게 만드세요:\n\n```js\nchmod +x linux/GDS3D\n```\n\nSKY130 셀과 함께 GDS3D를 실행하려면 프로세스 정의 파일이 필요합니다. 이를 위해 /techfiles 폴더 내의 sky130.txt 파일을 사용하세요. 이들을 결합하여 아래와 같은 콘솔 시작 명령어를 얻을 수 있습니다:\n\n```js\n./linux/GDS3D -p techfiles/sky130.txt -i \u003cgds-파일_경로\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGDS3D 창에서 인버터 셀을 3D 모델로 표시해야 합니다. 마우스로 이를 이동, 회전 및 확대할 수 있습니다. 이는 위의 3D 프린트 사진과 동일한 셀 (sky130_fd_sc_hd__inv_1.gds)입니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_2.png\" /\u003e\n\n이제 SKY130 오픈 소스 PDK에서 표준 셀을 고르고 GDS3D에서 볼 수 있는 방법을 알게 되었습니다. 혹시 이 가이드를 계속하기 전에 화면에서 몇 가지 더 많은 셀들 (AND 게이트, XOR, 더하기기, 멀티플렉서 등)을 둘러보고 싶을 수도 있습니다.\n\n# 3. .gds를 .stl로 변환하기: gdsiistl\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3D 프린팅을 위해서 GDS 파일을 프린트 가능한 .stl 파일 세트로 변환해야 합니다. mbalestrini가 SKY130 PDK용으로 적용한 gdsiistl 버전이 있습니다:\n\n저장소를 다운로드하거나 복제하여 README를 확인하여 gdsiistl 사용 방법을 참조하세요. 이는 Python으로 작성되어 있어 실행하기 어렵지 않을 것입니다. 저는 다음과 같이 진행했습니다 (python 3.10):\n\n```js\npip install numpy\npip install gdspy\npip install numpy-stl\npip install triangle\npython gdsiistl.py \u003cpath_to_gds_file\u003e\n```\n\ngdsiistl을 실행한 결과는 프로세스 레이어의 일부를 이름에 접미사로 가진 .stl 파일 세트가 생성됩니다 ( _diff, _li1, _licon, _mcon, _met1, _nwell 및 _poly).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_3.png\" /\u003e\n\n이 .stl 파일들은 이미 3D 프린트가 가능합니다. 하지만 프린트 버튼을 누르기 전에 세포의 3D 모델을 인쇄하고 조립하는 방법을 탐색해보고 싶을 것입니다.\n\n# 4: .stl 파일 쌓아서 인쇄하기\n\n여기서부터는 좋아하는 소프트웨어를 실행하여 .stl 파일을 보고, 편집하고, 슬라이스하고 인쇄해야 합니다. 저는 Tinkercad와 Cuda의 조합을 사용합니다. 하지만 이는 완전히 당신과 당신의 3D 프린터에 달렸습니다. 오픈 소스 솔루션을 선호할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기는 방금 .stl 파일로 받은 레이어들과 실제 마이크로칩에 어떻게 \"쌓이는지\" 보여주는 다이어그램이 있습니다. 이 다이어그램의 출처는 SKY 130 PDK 문서입니다.\n\n![다이어그램](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_4.png)\n\n그리고 여기는 위의 다이어그램처럼 쌓인 .stl 파일들의 분해된 렌더링입니다:\n\n![렌더링](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n선택을 해야 할 시점이 도래했습니다. 세포의 3D 모델에 대한 다음 단계는 실제 칩 생산 과정과 프린터의 출력 가능성 또는 제한 사항과의 정확성 등급에 달려 있습니다. 제가 그림과 함께 다음 문제를 설명하겠습니다.\n\n## 라이콘 레이어:\n\n.stl 렌더링의 라이콘 레이어를 GDS3D 렌더링과 비교하십시오. 그런 다음 내 모델에서 라이콘 레이어를 어떻게 출력했는지 살펴보십시오 (위의 사진 참조). 라이콘 레이어는 적어도 li1, poly 및 확산을 함께 연결합니다. 어떻게 출력할지 결정해야 합니다. 제 의견으로는 라이콘이 poly나 확산의 하단에서 나오지 않아야 하며(li1 레이어와만 연결), 두 레이어를 위쪽으로만 연결해야 합니다.\n\n![이미지](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 부족한 기판층:\n\n.stl 파일 세트에 기판층이 포함되어 있지 않습니다. GDS3D에서는 큰 검은 상자로 렌더링됩니다. 내 세포 모델에서는 AND-Gate의 최상단 사진처럼 큰 흰 판을 출력합니다.\n\n![이미지](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_7.png)\n\n## 확산을 nwell로 하위 기판에 포함하시겠습니까?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 낮은 층을 서로 쌓지 않고 내포된 구조로 만들었어요: 확산이 엔웰(nwell)로 스며들어 p-기판으로 들어가요.\n\n![이미지](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_8.png)\n\n내 모델에서는 확산을 엔웰로 내포시키고 그것을 기판 위에 쌓습니다.\n\n![이미지](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 하나 또는 두 개의 프린트 헤드? 색상?\n\n프린터에 따라 한 번의 인쇄량으로 두 개의 층을 함께 출력할 수 있습니다. 두 개의 헤드와 따라서 두 색상으로 인쇄할 경우 층을 다음과 같이 병합했습니다:\n\n![image](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_10.png)\n\n각 인쇄 작업에는 두 개 이상의 색상이 없으며 서포트 채움이 없습니다. 층을 인쇄한 후에는 슈퍼 접착제를 사용하여 단일 모델로 결합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 입력 및 출력 레이블:\n\n다른 프린트 작업으로 인해, 입력 및 출력, 전원 및 접지 레일에 대한 레이블이 많이 만들어졌어요.\n\n![이미지](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_11.png)\n\n# 5: 조립\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째: 손가락을 서로 붙이지 마세요!\n\n두 번째: AND 셀 조립의 단계별 사진 몇 장\n\n지금까지는 가이드가 이 만큼이에요. 즐겁게 만들고 인쇄된 셀로 행운을 빕니다. 만약 인쇄했다면 저에게 알려주세요 (트위터?!)!\n\n# 이제는...\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- ...모델을 축척에 맞추어 출력하는 중입니다. 그리고 그 축척은 무엇인가요?\n- ... `SKY130 PDK에 200개 더 레이어가 있습니다.\n- ... 셀이 실리콘에서 실제로 어떻게 보이는지.\n- ... 내가 잊거나 그냥 모르는 모든 것들 (많습니다!).\n\n## 크레딧 (완벽하지는 않지만 시작):\n\n매튜 벤(Matthew Venn)과 그의 환상적인 제로에서 ASIC으로 코스.\n\nHochschule RheinMain (Ultimaker S5)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스테펜 라이테가 이런 미친 짓을 할 수 있도록 도와줘서 고마워요.","ogImage":{"url":"/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_0.png"},"coverImage":"/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_0.png","tag":["Tech"],"readingTime":6},{"title":"3D 모델링의 7가지 주요 용도","description":"","date":"2024-06-22 18:37","slug":"2024-06-22-Whatis3Dmodelingusedfor","content":"\n\n3D 모델은 영화, 게임, 건축, 제품 디자인 등에서 사용됩니다. 엔터테인먼트 산업과 가상 현실에서 3D 모델을 예상할 수 있지만, 많은 다른 산업에서도 3D 모델이 사용된다는 사실에 놀라실지도 모릅니다.\n\n![이미지](/assets/img/2024-06-22-Whatis3Dmodelingusedfor_0.png)\n\n# 3D 모델링이 오늘날 어디에 사용되는지\n\n다음은 일반적인 3D 모델링 예시입니다. 이러한 모델들은 때로는 너무 사실적하여 처음에 렌더링된 이미지를 보고 있다는 것을 알아차리기 어려울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3D 모델링 Fiverr에서 전문 프리랜서를 고용해보세요!\n\nWorkpaa에서 데이터 분석가 전문 프리랜서를 고용하세요!\n\n# 1. 엔터테인먼트 및 미디어\n\n3D 모델링은 VFX, 비디오 게임, 영화 및 TV에서 광범위하게 활용됩니다. 3D 소프트웨어를 사용하여 완전히 만들어진 제작물을 자주 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 건축 및 부동산\n\n건축가와 디자이너들은 건물, 실내 및 풍경의 상세한 가상 표현을 만들기 위해 3D 모델링을 활용합니다. 이러한 모델은 디자이너의 비전을 잠재 투자자, 고객 및 대중에게 전달하는 데 매우 유용합니다.\n\n# 3. 제품 디자인과 제조\n\n3D 모델링은 프로토타입을 개발하고 제품 아이디어를 시각화하며 생산 전 기능을 시뮬레이션하기 위한 효율적이고 환경 친화적인 방법입니다. 디자이너들은 제품이 확정되기 전에 아이디어를 정제하고 무수히 많은 반복을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 자동차 및 항공우주 산업\n\n3D 모델링은 차량 및 그 구성 요소의 설계 및 시험, 그리고 광고 및 마케팅에서 사용됩니다. 많은 자동차 및 항공기 광고에는 거의 진짜 카메라 영상이 아닌 것으로 구별하기 거의 불가능한 3D 생성 이미지가 특징으로 나타납니다. 3D는 현실적인 시뮬레이션을 가능하게 하여 아이디어나 차량을 건설하기 전에 테스트하는 데 사용될 수 있습니다.\n\n3D 모델링 전문가를 고용하세요 on Fiverr\n\n데이터 분석가 전문가를 고용하세요 on Workpaa\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5. 의료 및 보건\n\n의료 영상 및 수술 계획에 3D 모델링이 활용됩니다. 장기, 뼈 및 조직의 정확한 재현은 진단, 치료 계획, 의학 연구를 지원하는 데 사용될 수 있습니다.\n\n# 6. 가상 현실 (VR) 및 증강 현실 (AR)\n\n3D 모델링은 몰입형 경험을 만드는 데 중요합니다. VR 및 AR은 여러 산업에서 활용되며 거의 모든 분야에서 사용될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7. 교육 및 훈련\n\n3D 모델링은 생물학, 지리, 심지어 역사와 같은 다양한 주제의 개념을 가르치는 데 교육적 환경에서 사용됩니다. 이를 통해 학생과 전문가들은 안전하고 통제된 환경에서 가상 모델과 시뮬레이션과 상호 작용할 수 있습니다. 이의 훌륭한 예로 비행 시뮬레이터에서 비행하는 비행사들이 있습니다.\n\n![Image 1](/assets/img/2024-06-22-Whatis3Dmodelingusedfor_1.png)\n\n![Image 2](/assets/img/2024-06-22-Whatis3Dmodelingusedfor_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 한눈에 보는 3D 모델링 과정.\n\n이 단계들은 3D 모델링 과정의 일반적인 개요를 제공합니다. 실제 사용하는 워크플로우는 소프트웨어나 작가의 선호도, 프로젝트의 특정 요구 사항에 따라 다를 수 있습니다. 함께 알아보겠습니다:\n\n# 개념화\n\n아이디어 떠올리기에서 시작하여 소프트웨어로 직접 들어가서 기본 모양을 사용하여 아이디어를 블록 처리하는 것이든, 이 단계에서 시간을 보내는 것은 중요합니다. 아이디어에 너무 많은 시간을 들이기 전에 해당 아이디어에 헌신할 수 있는지 확인하는 것이 매우 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3D 모델링을 위해 전문 프리랜서를 고용하세요.\n\n**Fiverr**에서 전문 프리랜서를 고용하세요.\n\n**Workpaa**에서 3D 모델링 전문가를 고용하세요.\n\n# 모델링\n\n이 단계에서는 선택한 소프트웨어를 사용하여 실제 3D 모델링 작업이 진행됩니다. 폴리곤 모델링을 사용하는 경우, 버텍스, 엣지, 그리고 면을 조작하여 면체를 구축해야 합니다. 또 다른 접근 방식은 Substance 3D Modeler와 같은 소프트웨어를 사용하는 것인데, 이를 통해 다양한 도구와 조각 방법을 사용하여 디지털 클레이를 정확하게 조각할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 텍스처링\n\n모델의 형태가 완성되면, 텍스처와 재질이 모델 표면에 적용되어 현실적이거나 스타일화된 외관을 부여합니다. 텍스처에는 색상, 패턴, 그리고 돌기와 반사 같은 표면 세부 사항이 포함될 수 있습니다. 이들은 손으로 그림을 그릴 수도 있고, 절차적으로 생성되거나 고화질 사진에서 유래될 수 있습니다.\n\n# 렌더링 \u0026 처리\n\n모델이 완성되고 텍스처가 적용되면, 3D 모델링 과정의 마지막 단계는 조립 및 렌더링입니다. 렌더링은 조명, 음영 및 다른 시각 효과를 고려한 고품질 이미지 또는 시퀀스 애니메이션을 생성하는 것을 포함합니다. 이는 계산적으로 매우 요구되는 프로세스일 수 있습니다. 후처리는 렌더 이후에 최종 출력을 더욱 향상시키기 위해 사용될 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-Whatis3Dmodelingusedfor_3.png\" /\u003e\n\n# 가능한 것을 확인해보세요.\n\n3D 모델링의 모든 단계가 결합되면 예술가와 디자이너들은 놀라운 작품을 만들어낼 수 있습니다. 다양한 산업에서 3D 모델링이 어떤 일을 할 수 있는지 보여주는 현실 세계의 예시들을 확인해보세요.\n\n\u003cimg src=\"/assets/img/2024-06-22-Whatis3Dmodelingusedfor_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프리랜서 전문가를 고용해보세요. Fiverr에서 3D 모델링을, Workpaa에서 3D 모델링을 해보세요.\n\n# 1. 패션.\n\nHugo Boss가 3D를 사용하여 프로세스를 향상하는 방법을 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 제품 디자인.\n\nPuma와 INDG가 Substance 3D 앱과 AR을 활용하여 놀라운 신발을 디자인하는 방법을 살펴보세요.\n\n# 3. 엔터테인먼트.\n\n아름다운 프로젝트 'End of Summer'는 Adobe의 재능 있는 아티스트들이 주로 Substance 3D 도구를 사용하여 어떤 것이 가능한지 보여주는 작품입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3D 모델링에 대한 팁.\n\n3D 모델링을 진행할 때 고려해야 할 몇 가지 팁입니다:\n\n# 1. 기본을 마스터하세요.\n\n기본 3D 모델링 원칙에 견고한 기반을 다지고 소프트웨어에서 제공되는 도구를 효율적으로 사용하는 법을 배우는 것은 필수적입니다. 모델이 더 깔끔해지고 시간도 더 효과적으로 사용할 수 있게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 2. 키보드 단축키와 워크플로우 최적화에 대해 배워보세요.\n\n3D 소프트웨어는 매우 복잡할 수 있습니다. 창조자들에게 사용 가능한 많은 도구와 방법이 있기 때문에, 단축키에 익숙해지는 것은 창작에 있어서 삶의 질을 크게 향상시킬 것입니다. 이를 통해 작업 흐름이 빨라지고 생산성이 향상되며, 전체 과정이 더 효율적으로 느껴질 것입니다.\n\n# 3. 참조 자료 활용하기.\n\n참조 자료를 사용하는 것은 프로젝트를 계획하고 시각화하는 데 도움을 주는 좋은 방법일뿐만 아니라, 3D 모델이 현실적이고 정확한 비율, 모양 및 디테일을 갖추도록 보장하는 데도 도움이 됩니다. 참조 자료는 견고한 기반을 제공하고 시각적 충실성을 유지하는 데 도움을 줍니다. 창의성을 자극하고 아이디어 생성을 장려하기 위해 여러 다양한 참조 자료로 이루어진 모드 보드를 작성하는 것도 고려해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 다양한 기술들을 탐험해보세요.\n\n좋은 3D 아티스트는 끊임없이 배우고 있습니다. 3D 기술을 계속 연습하고 새로운 도구와 기술을 배우면 예술가로서와 디자이너로서成長할 수 있습니다. 포리모델링이나 조각과 같은 다양한 기술과 소프트웨어를 탐험하여 더 다양한 기술을 개발하는 데 도움이 될 것입니다.\n\n당신의 3D 모델링을 위해 전문 프리랜서를 고용하세요. Fiverr에서\n\n당신의 3D 모델링을 위해 전문 프리랜서를 고용하세요. Workpaa에서\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 콘텐츠를 얻고 영감을 얻고 창의성을 발휘하세요.\n\n![이미지](/assets/img/2024-06-22-Whatis3Dmodelingusedfor_5.png)\n\n3D 제작을 시작하고 싶으시거나 접근 방식을 새롭게 하고 싶으시다면 Adobe Substance 3D를 소개해 드립니다. 이 강력한 도구 세트를 통해 익숙한 Adobe 작업 환경을 경험할 수 있으며, 모델링, 질감 입히기, 소재 생성, 무대 설정 및 렌더링 등 3D 프로세스의 여러 측면을 더욱 효율적으로 처리할 수 있는 강력한 도구를 사용할 수 있습니다. Substance 3D의 가능성을 발견하고 오늘부터 모든 3D 앱의 30일 무료 평가판을 이용하여 3D 프로젝트에서 창의성을 높이세요.\n\n# 자주 묻는 질문\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3D 모델링은 무엇에 사용되나요?\n\n# 3D 모델의 예시는 무엇이 있나요?\n\n# 3D 모델링의 다양한 종류는 무엇이 있나요?","ogImage":{"url":"/assets/img/2024-06-22-Whatis3Dmodelingusedfor_0.png"},"coverImage":"/assets/img/2024-06-22-Whatis3Dmodelingusedfor_0.png","tag":["Tech"],"readingTime":5},{"title":"PLA 필라멘트 매트 3D 프린트와 글로시 3D 프린트, 어떤 것을 선택해야 할까","description":"","date":"2024-06-22 18:36","slug":"2024-06-22-3dMattevsGlossyPLAFilamentWhichShouldYouChoose","content":"\n\n폴리락틱산(PLA) 필라멘트를 사용한 3D 프린팅은 프로토타입, 취미 프로젝트 등을 위한 선명하고 세밀한 출력물을 만들어냅니다. PLA는 광택과 무광 타입 두 가지로 나누어집니다. 무광과 일반 PLA의 차이점은 무엇이며, 다음 3D 프린팅 프로젝트에 어떤 것을 선택해야 할까요?\n\n![이미지](/assets/img/2024-06-22-3dMattevsGlossyPLAFilamentWhichShouldYouChoose_0.png)\n\n무광 PLA란 무엇인가요?\n\n무광 PLA 필라멘트는 반짝반짝하지 않고 반사되지 않는 표면을 갖추고 있습니다. 광택있는 PLA가 하는 것과는 달리, 빛을 반사하는 대신 흩뿌립니다. 주의할 점은 광택이 있는 표면을 만들려면 일반 PLA 3D 출력물을 이소프로필 알코올의 구름 속에 넣어 레이어 라인을 부드럽게 만들고 반짝이는 효과를 만들어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매트 PLA의 장점:\n\n- 윤곽선과 프린트 불완전함을 반짝이는 플라스틱보다 더 잘 감춥니다. 매트 질감은 프린트가 더 부드럽게 보이도록 돕습니다.\n- 사납지 않은 반짝임 대신 벨벳처럼 부드러운 마감을 제공합니다. 이 미적 요소는 특정 용도에 더 선호될 수 있습니다.\n- 윤광 표면보다 매트 페인트된 디테일을 더 잘 보여줍니다. 매트 PLA는 반짝이는 반사로 색상을 약화시키지 않고 페인트와 잉크를 보여줍니다.\n- 윤광 PLA보다 광선을 더 고르게 흩뿌려 반짝임이 줄어듭니다.\n\n매트 PLA의 단점:\n\n- 정말 작은 세부 사항과 텍스트를 윤광 플라스틱보다 뚜렷하게 표현하지 못할 수 있습니다. 작은 특징이 더 어둵고 같은 배경에 돋보이지 않을 수 있습니다.\n- 윤광 대조로 색상이 약간 어두워 보일 수 있습니다. 매트 마감은 선명한 색조를 아주 강간으로 제공하지 않습니다.\n- 윤광 필라멘트보다 먼지와 먼지를 더 빨리 끌어들일 수 있습니다. 프린트를 더 많이 청소하고 유지보수해야 할 수 있습니다.\n- 투명 프로토타입과 같은 시각적 모델에는 권장되지 않습니다. 여기서는 명료성과 빛 전달이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하자면, 매트 PLA는 층 간 선을 잘 숨기며 일반 광택이 있는 PLA보다 보다 부드럽고 더 어두운 미학을 제공합니다. 광택이 있는 PLA는 더 날카로운 세부 사항과 더 강렬한 색상을 만들어 냅니다. 귀하의 특정 3D 프린팅 프로젝트의 요구 사항을 고려하여 어떤 마감이 해당 응용 프로그램에 가장 적합한지 결정하세요. 매트 PLA는 빛을 반사하지 않고 그립감 있는 질감이 장점인 부드럽게 보이는 취미 미니어처, 소품, 코스프레 갑옷, 및 기능성 인쇄물에 적합합니다.","ogImage":{"url":"/assets/img/2024-06-22-3dMattevsGlossyPLAFilamentWhichShouldYouChoose_0.png"},"coverImage":"/assets/img/2024-06-22-3dMattevsGlossyPLAFilamentWhichShouldYouChoose_0.png","tag":["Tech"],"readingTime":2},{"title":"안디노 만들기 - 오픈 소스 로봇 2부 하드웨어 조립 및 테스트 방법","description":"","date":"2024-06-22 18:34","slug":"2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting","content":"\n\n이전 글에서는 호스트 컴퓨터 및 RPi를 설정하여 시뮬레이션 모드에서 로봇을 실행할 수 있는지 확인했습니다. 이번 글에서는 안디노 로봇의 하드웨어 구성에 중점을 두겠습니다. 안디노 로봇 하드웨어의 GitHub 저장소에는 상당히 좋은 다이어그램과 부품 목록이 있지만, 모든 것을 어떻게 조립하거나 조립하는 방법에 대한 구체적인 내용은 제공되지 않습니다. 또한 연결 다이어그램은 매우 고수준이며, 로봇을 처음으로 만들어 보는 사람들에게는 매우 혼란스러울 것입니다.\n\n안디노 로봇의 하드웨어 구성에 필요한 부자재 목록 및 일부 수정과 코멘트:\n\n- Raspberry Pi 4 B (4 Gb)\n- Chassis 2 x Print 3d Chassis 또는 GitHub 저장소에서 추천하는 WheelsRobot Smart Car Kit과 같은 제품을 구입할 수 있습니다. 여기는 DFRobot 모터를 사용하는 내가 수정한 버전의 샤시 플레이트 STL 파일 링크입니다. 이 모터는 L-Shape DFRobot 모터를 사용합니다.\n- 모터 2 x Hobby Motor with Encoder. 정밀도와 신뢰성을 높이기 위해 임베디드 인코더가 권장됩니다. 이미 가지고 있었기 때문에 GitHub 저장소에서 추천한 모터 대신 DFRobot 모터를 사용했습니다. 이 모터는 내장된 인코더가 장착되어 있습니다. 이들은 L-Shape과 I-Shape이 있으며, L-Shape를 사용했으며, 이에 따라 샤시 플레이트를 재설계해야 했습니다.\n- Arduino Uno\n- 모터 드라이버 L298N 듀얼 H 브릿지\n- RPLidar A1M8\n- Raspi Camera Module V2, 8 MP\n- Powerbank 5V — 어느 파워뱅크든 적합합니다. 크기/무게/출력 전류에 주의하세요(≥2A). RPi용 파워뱅크와 6V 정도의 전원을 공급할 4xAA 배터리 홀더를 사용했습니다. 이렇게 하면 RPi와 모터에 전원을 분리하여 모터가 배터리 전원을 많이 소비할 경우 RPi에 브라운아웃을 유발하지 않습니다.\n- (옵션) 파워 스텝 업 DC — 모터가 5V보다 높은 전압을 지원하는 경우(예: 9V로 스탭업) 파워 뱅크(5V)와 모터 드라이버 사이에 추가할 수 있습니다.\n- 고정 및 장착 — M3 볼트/고정부품 — M3 스페이서 — SBC용 M2.5/2.0 볼트/고정부품\n- 다양한 길이의 스탠드오프\n\n게다가 몇 가지 더 필요한 것이 있을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다양한 조합의 추가 디유폰트 와이어(수컷-수컷, 수컷-수메스 또는 수메스-수메스)가 함께 제공됩니다. 연결 방식에 따라 선택하세요.\n- 두 베이스 플레이트 사이의 높이를 늘리기 위해 추가 스탠드오프가 필요할 수 있습니다. 이렇게 하면 다양한 보드에서 튀어나오는 디유폰트 와이어가 들어갈 공간이 확보됩니다.\n- 베이스 플레이트에 배터리가 꽉 조이도록 하려면 이와 같은 벨크로 타이 또는 실리콘 타이가 필요할 수 있습니다.\n- 우리는 단순함을 유지하기 위해 디유폰트 와이어와 나사 터미널을 사용하여 배선을 하고 있지만, 솔더링에 능숙하다면 더 많은 퍼마 보드를 사용하고 와이어를 솔더링할 수 있습니다. 저는 솔더링에 능숙하지 않아서 여러 연결점을 솔더링하는 대신 PCB를 제작하고 인쇄해야 한다고 생각합니다.\n\n## 조립 및 테스트를 위한 고수준 계획\n\n기본적인 조립은 다음과 같은 고수준 단계로 진행됩니다:\n\n- 하단 샤시 플레이트 — 모터를 하단 샤시 플레이트 아래에 부착합니다.\n- RPi4, L298N 및 Arduino UNO를 하단 샤시 플레이트 위에 설치합니다. UNO의 경우 케이스를 직접 샤시에 부착하는 대신 케이스를 사용하여 홀 패턴을 일관성 있게 만들었습니다. 링크는 사실 SCAD 파일이므로 OpenSCAD를 설치하고 STL 파일을 내보내어야 합니다.\n- 상단 샤시 플레이트를 높은 스탠드오프를 사용하여 부착하여 모든 구성 요소의 높이를 맞추고, 디유폰트 와이어에 추가 공간을 제공합니다.\n- RPLidar, RPi 카메라, RPi 배터리 및 모터 배터리를 상단 샤시 플레이트 위에 부착합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 제품의 각 층에 구성 요소를 부착하시는 경우, 아래 배선도에 따라 전선 연결을 시작하는 것이 좋습니다.\n\nTop chassis plate를 추가하기 전에 다음 사항들이 작동하는지 확인할 때까지 모든 테스트를 실행하는 것을 강력히 권장합니다:\n\n- Arduino를 호스트 컴퓨터에 직접 연결하면 Arduino 프로그램을 모터 컨트롤러용으로 업로드하고 테스트할 수 있습니다. Arduino UNO에 직접 시리얼 명령을 사용하여 모터를 구동할 수 있도록 확인\n- 그 다음 RPi 및 Arduino UNO를 연결하고 호스트 컴퓨터가 아닌 RPi에서 직접 시리얼 명령 테스트를 반복할 수 있는지 확인\n- 마지막으로 ROS2를 사용하여 조이스틱 제어로 모터를 구동할 수 있는지 확인\n\n이 시점에서 Top chassis plate를 추가하고 RPLidar, RPi Camera를 부착하고 두 배터리를 설치할 수 있습니다. 이제 로봇을 케이블에 묶이지 않은 이동식으로 테스트할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 시점에서 실제로 이러한 일들을 시도해볼 수 있습니다:\n\n- 조이스틱을 사용하여 배터리로 구동되는 로봇을 방 안을 주행시키기\n- 주변을 매핑하기 시작하고 실제로 지도를 저장할 SLAM 실행\n- 생성된 지도를 사용하여 장애물을 피하면서 Nav2를 기반으로 한 자율 주행 실행\n\n## 조립 지시서 및 사진\n\nAndino 로봇을 조립하려고 할 때, DFRobot의 나만의 L-Shape 모터와 그림 레포지토리의 Andino 챠시를 사용할 것을 알고 있었지만 그것은 내게 적합하지 않았습니다. 그래서 나는 FreeCAD를 사용하여 전체 챠시 플레이트를 처음부터 만들었고 이 STL 파일들을 내 Andino git 레포지토리의 내 분기에 추가할 것입니다. 또한, 어떤 구성 요소를 어디에 장착해야 하는지 식별하는 것이 어려워서, 다음 다이어그램에서 각 구성 요소에 대한 구멍을 색상 코드로 표시했습니다. 이렇게 하면 특정 구성 요소를 어디에 장착해야 하는지 따라갈 누군가에게 편리할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잊지 말아야 할 몇 가지 추가 지점\n\n- 상단 및 하단 샤시 플레이트는 동일하며, 서로 분리되어있는 많은 스탠드오프로 구별된 같은 플레이트가 두 번 인쇄된 것입니다.\n- UNO는 매우 이상한 부착 패턴을 가지고 있어서 원래 CAD 디자인에서 구축했지만, 더 직사각형 모양의 구멍 패턴이 있는 무료로 제공되는 UNO 홀더를 사용하여 결정하여 이 Chassis에 그 플레이트를 설치하기 전에 UNO 베이스 플레이트를 3D로 출력해야 합니다. 여기서 디자인 파일을 다운로드하고 OpenSCAD를 설치하여 직접 STL 파일을 생성할 수 있습니다.\n- RPLidar의 경우, 리다가 어느 방향을 향하고 있는지를 모르기 때문에 먼저 이중 홀 패턴을 만들었으므로 큰 회전 실린더가 로봇의 전방 둥근 부분을 향하고 작은 풀리가 로봇의 뒷면을 향하도록 하는 패턴을 사용할 수 있습니다.\n- 뒷면의 슬롯은 RPi와 모터의 배터리를 고정하기 위해 벨크로 스트랩이나 집게띠를 통과시킬 수 있도록 제공됩니다.\n- 사용한 캐스터 휠은 주 휠보다 약간 짧았기 때문에 로봇 샤시가 수평으로 유지되도록 캐스터 휠의 높이를 조정하기 위해 스페이서를 3D로 출력해야 했습니다. 이것은 좋지만, 3D 프린트를 하기 싫다면 나사 구멍이 뚫린 목재 조각을 사용하여 높이를 조절할 수 있습니다.\n- RPi 카메라는 PiHut에서 구입했으며, RPi 카메라를 설치하기 위한 마운팅 플레이트도 구입했습니다. 정면의 샤시에 그 마운트를 부착하기 위해 두 구멍이 있는 작은 조각을 인쇄해야 했습니다. 이를 달성하기 위해 나사 구멍이 있는 목재 조각이나 플렉시 글라스 조각을 사용할 수 있습니다.\n\n아래 두 이미지는 여러 구성 요소의 부착 홀을 보여줍니다. 이미지는 상단과 하단 샤시 플레이트를 나타내는 것이 아니며, 각각의 마운팅 홀을 명확히 표시하기 위해 두 개의 별도 이미지로 표시됩니다. 상단 및 하단 플레이트는 동일한 사본이며, 위에 설명된 대로 반드시 설치해야합니다. 다시 말해, 이것은 제가 시도한 것이 잘 작동했던 것이고 가이드라인이며, 모든 구성 요소를 플레이트에 부착하고 로봇이 균형을 잘 유지할 수 있다면 그게 중요한 부분입니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting_0.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n바텀 샤시 플레이트 위에 구성 요소를 기계적으로 설치한 후, 즉 모터, RPi, L298N, 그리고 아두이노 UNO를 설치한 후에는 배선도와 아래 표를 따라서 모든 구성 요소가 올바르게 연결되었는지 확인하세요.\n\n아래에서 제안된 핀 번호를 사용하는 경우, andino_firmware/src/hw.h 파일을 업데이트하여 사용된 핀 번호와 일치시키는 것이 좋습니다.\n\n또 다른 기억할 점은, 모터를 3초 이상 테스트하고 있다면, constants.h 파일에서 정의된 3000 밀리초 제한 시간 상수인 kAutoStopWindow 때문에 모터가 멈출 수 있습니다. 테스트 중에 충분한 시간을 확보할 수 있도록 나는 테스트 중에 30000으로 변경했습니다.\n\n## 배선도\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Building Andino Opensource Robot](/assets/img/2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting_1.png)\n\n## Wiring Table\n\nI used different pin numbers than specified in the Andino repository, as these pins worked for me. However, you can easily change them in the header file of Andino hardware if you decide to use different pin numbers.\n\n![Building Andino Opensource Robot](/assets/img/2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n조립 중인 사진들\n\n![image1](/assets/img/2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting_3.png)\n\n![image2](/assets/img/2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting_4.png)\n\n![image3](/assets/img/2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 6](/assets/img/2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting_6.png)\n\n![Image 7](/assets/img/2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting_7.png)\n\n## 독립 모드에서 모터 테스트 [Arduino 직접 제어]\n\n호스트 컴퓨터 [노트북이나 데스크탑]을 USB 케이블을 사용하여 아두이노 UNO에 연결하세요. 그리고 아두이노 UNO에 andino_firmware를 업로드했는지 확인해주세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 간단한 방법은 플랫폼IO 명령줄 버전을 설치하는 것입니다. [아두이노 IDE를 사용하여 동일한 작업을 수행할 수도 있습니다].\n\n플랫폼IO를 설치했다고 가정하고, 아니라면 여기에 있는 단계를 따르세요. 그리고ino_firmware/src/constants.h 안의 Constants.h 헤더 파일에 정의된 보레이트를 확인해보세요. Andino 저장소에는 57600으로 설정되어 있습니다 [연결을 시작할 때 나중에 명령에서 동일한 보레이트를 사용하도록하세요].\n\n아두이노 UNO가 호스트 컴퓨터에 연결되어 있는 경우 아래 명령을 실행하세요.\n\n```bash\n# 터미널을 열고, andino_robot_ws/src/andino/andino_firmware 폴더로 이동하세요.\n\n# 다음 명령을 실행하여 andino_firmware를 아두이노 UNO에 업로드하세요.\npio run --target upload -e uno\n\n# 업로드 성공 메시지를 본 후에 다음 명령을 실행하여 연결하세요.\npio device monitor -p /dev/ttyACM0 -b 57600\n\n# 이것은 시작하여 직렬 명령을 입력할 수 있는 프롬프트를 보여줍니다.\n\n# 엔코더 읽기\ne [ENTER]\n\n# 모터를 700 틱/초로 전진시키기\nm 700 700\n\n# 모터 정지\nm 0 0\n\n# 모터를 후진시키기\nm -700 -700\n\n# 모터 정지\nm 0 0\n```\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 모터의 회전 방향을 확인해야 합니다. 모터의 방향이 올바르지 않은 경우, M1 또는 M2 모터의 IN 핀을 교환하여 수정할 수 있습니다. 두 모터가 동일한 방향으로 이동할 때 엔코더 값 부호 [+ 또는 -]가 동일하지 않으면, 해당 모터의 엔코더 핀 [채널 A 및 B]을 교환하여 전진할 때 부호가 +이고 후진할 때 부호가 -가 되도록 설정할 수 있습니다.\n\n모터의 틱 속도 측정:\n\n각 바퀴에 유사한 위치에 테이프를 붙입니다. 모터가 아두이노에 연결되어 있고 멈춰있는지 확인하세요 [엔코더가 전원에 연결되어 있는지 확인하세요].\n\n아래 두 명령어를 시리얼 모니터를 통해 아두이노 UNO에 전송해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 다음과 같이 마크다운 형식으로 변경해주세요.\n\n|r|\n|---|\n|e|\n|r — 해당 명령은 인코더를 재설정하고, e — 해당 명령은 즉시 바로 실행하여 현재 값을 0 0으로 출력합니다. 이것이 우리가 원하는 바입니다.\n\n이제, 한 번에 한 바퀴씩 바퀴를 대략적으로 10번 회전해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그런 다음 명령 `e`을 다시 실행하고 각 바퀴에 대한 값들을 기록하세요. 각 바퀴에 대한 틱 수를 구하기 위해 마지막 틱수를 10으로 나누세요. 이제 각 모터의 초당 틱 수를 얻을 수 있습니다. 모터 명세서를 참고하여 초당 틱 수를 구할 수도 있습니다. [또는 광학적 RPM 측정기를 이용하여 모터 속도를 측정하고 틱 당 회전수에 분당 회전수를 곱할 수 있습니다.] 이렇게 계산하세요:\n\ntpr [틱 당 회전수] — DFRobot에서 제시된 명세서에 따르면 1회전 당 960틱\n\nrpm [모터의 회전수] — DFRobot에서 제시된 명세서에 따르면 160 rpm\n\n초당 틱 수 = (tpr * rpm)/60 = (960 * 160)/60 = 2560 틱/초 최대\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAndino 리포지토리의 루트 디렉토리에서 RPi에서 모터를 테스트할 때 최대 틱 수를 사용하는 m 명령을 사용할 수 있습니다.\n\n## 스탠드얼론 모드에서 모터 테스트 [RPi로부터]\n\n이제 Arduino 시리얼 모니터 명령을 사용하여 모터를 직접 실행하는 모터 컨트롤러를 테스트했으므로, Raspberry Pi가 Arduino에 연결된 상태에서 동일한 테스트를 반복할 수 있습니다. 호스트 컴퓨터와 RPi의 USB 포트 사이에 연결된 USB 케이블을 제거하고 Arduino UNO 사이에 연결하세요. 그리고 다음 단계를 따르세요:\n\nRPi의 Andino 리포지토리 루트 디렉토리에 있을 때 ROS2 워크스페이스를 빌드하고 소스를 만드십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고: 안디노 레포에 문서화된대로 \"o\" 명령어를 시도해 보았지만 어떤 이유로 인해 작동하지 않아서 \"m\" 명령어를 계속 사용하고 있습니다.\n\n터미널에서 다음 명령어를 실행하여 RPi에 연결된 모터를 테스트하세요.\n\n```js\ncolcon build\nsource install/setup.bash\n```\n\n```js\n# 1. 양 모터의 현재 엔코더 판독 값을 얻기\nmotor_driver_demo --serial_port=/dev/ttyACM0 --msg='e'\n\n# 결과는 다음과 유사할 것입니다\n모터 드라이버가 연결되어 있습니다: True\n마이크로컨트롤러가 준비되기까지 2초 기다립니다...\n메시지 전송: e\n응답: 0 0\n\n# 2. 모터를 지정된 틱 수(예: 700)로 전진 방향으로 이동시키기\nmotor_driver_demo --serial_port=/dev/ttyACM0 --msg='m 700 700'\n\n# 3. 모터 정지 \nmotor_driver_demo --serial_port=/dev/ttyACM0 --msg='m 0 0'\n\n# 4. 모터를 지정된 틱 수(예: -700)로 후진 방향으로 이동시키기\nmotor_driver_demo --serial_port=/dev/ttyACM0 --msg='m -700 -700'\n\n# 5. 모터 정지 \nmotor_driver_demo --serial_port=/dev/ttyACM0 --msg='m 0 0'\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ROS2와 조이스틱으로 모터 테스트하기\n\n로봇을 안전하게 테스트하기 위해 지면에 바퀴가 닿지 않은 채로 조이스틱을 사용하여 로봇을 테스트하고자 합니다. 조이스틱을 사용하여 원격으로 바퀴를 제어할 수 있는지 확인하려면 RPi에서 아래와 같이 설명된 명령을 실행해야 합니다. 여기서 가정은 조이스틱 컨트롤러의 USB 키포트 중 하나에 조이스틱을 연결하고 해당 조이스틱이 블로그 게시물에서 설명된 프로세스를 사용하여 joy 명령을 생성하는지 테스트했다는 것입니다.\n\n```js\ncd andino_ws\n\ncolcon build\n\n# RPi 터미널 창 1에서\nsource install/setup.bash\nros2 launch andino_bringup andino_robot.launch.py include_rplidar:=false include_camera:=false\n\n# RPi 터미널 창 2에서\nsource install/setup.bash\nros2 launch andino_bringup teleop_joystick.launch.py\n\n# 호스트 컴퓨터에서 호스트 컴퓨터에서 rqt를 실행하여 모든 노드의 노드 그래프를 확인할 수도 있습니다\nrqt\u0026\n```\n\nrqt 그래프는 다음과 같이 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting_8.png)\n\n위에서 보듯이 twist_mux는 teleop_twist, teleop_keyboard 및 Nav2를 통해 직접 cmd_vel 토픽에서 입력을 받을 수 있습니다. 또한 어떤 명령이 최종 cmd_vel 토픽으로 보내질지를 우선 순위를 정할 수 있습니다.\n\n여기에는 로봇이 서 있는 상태로 움직이는 동영상도 있습니다:\n\n다음 기사에서는 이번 단계가 끝나면 로봇을 이동하고 SLAM 및 Nav2를 시도해 볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n즐거운 빌딩하세요!!!\n\n## 참고 자료\n\n[PlatformIO 설치 방법](https://docs.platformio.org/en/stable/core/installation/methods/installer-script.html#super-quick-macos-linux)","ogImage":{"url":"/assets/img/2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingAndinoOpensourcerobotPart2HardwareAssemblyTesting_0.png","tag":["Tech"],"readingTime":10}],"page":"34","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"34"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>