<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/35" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/35" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="안드로이드에서 Network Service DiscoveryNSD 알아보기 및 LAN에서 서비스 발견하는 방법" href="/post/2024-06-22-KnowmoreaboutNetworkServiceDiscoveryNSDinAndroidandapproachestodiscoverservicesinLAN"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안드로이드에서 Network Service DiscoveryNSD 알아보기 및 LAN에서 서비스 발견하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-KnowmoreaboutNetworkServiceDiscoveryNSDinAndroidandapproachestodiscoverservicesinLAN_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안드로이드에서 Network Service DiscoveryNSD 알아보기 및 LAN에서 서비스 발견하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">안드로이드에서 Network Service DiscoveryNSD 알아보기 및 LAN에서 서비스 발견하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ISO IEC 20546와 AI에서의 빅 데이터 미래 산업 40에 대한 영향" href="/post/2024-06-22-ISOIEC20546andtheFutureofBigDatainAIImplicationsforIndustry40"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ISO IEC 20546와 AI에서의 빅 데이터 미래 산업 40에 대한 영향" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ISOIEC20546andtheFutureofBigDatainAIImplicationsforIndustry40_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ISO IEC 20546와 AI에서의 빅 데이터 미래 산업 40에 대한 영향" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">ISO IEC 20546와 AI에서의 빅 데이터 미래 산업 40에 대한 영향</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CVE-202120090 취약점을 이용한 Arcadyan 라우터 인증 우회 및 Buffalo 라우터 루팅 방법" href="/post/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CVE-202120090 취약점을 이용한 Arcadyan 라우터 인증 우회 및 Buffalo 라우터 루팅 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CVE-202120090 취약점을 이용한 Arcadyan 라우터 인증 우회 및 Buffalo 라우터 루팅 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">CVE-202120090 취약점을 이용한 Arcadyan 라우터 인증 우회 및 Buffalo 라우터 루팅 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="인턴십 여정 회고 내 인생의 변화를 불러온 경험" href="/post/2024-06-22-ReflectingonMyInternshipJourneyATransformativeExperience"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="인턴십 여정 회고 내 인생의 변화를 불러온 경험" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ReflectingonMyInternshipJourneyATransformativeExperience_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="인턴십 여정 회고 내 인생의 변화를 불러온 경험" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">인턴십 여정 회고 내 인생의 변화를 불러온 경험</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS IoT Core  꼭 알아야 할 모든 것" href="/post/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS IoT Core  꼭 알아야 할 모든 것" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS IoT Core  꼭 알아야 할 모든 것" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">AWS IoT Core  꼭 알아야 할 모든 것</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">25<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="미래를 여는 열쇠 IoT와 홀로그램 기술의 최전선 이해하기" href="/post/2024-06-22-UnlockingtheFutureUnderstandingIoTandItsHolographicFrontier"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="미래를 여는 열쇠 IoT와 홀로그램 기술의 최전선 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-UnlockingtheFutureUnderstandingIoTandItsHolographicFrontier_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="미래를 여는 열쇠 IoT와 홀로그램 기술의 최전선 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">미래를 여는 열쇠 IoT와 홀로그램 기술의 최전선 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="오픈 소스 맥박산소측정기, 직접 만들어보기" href="/post/2024-06-22-OpenSourcePulseOximeter"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="오픈 소스 맥박산소측정기, 직접 만들어보기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-OpenSourcePulseOximeter_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="오픈 소스 맥박산소측정기, 직접 만들어보기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">오픈 소스 맥박산소측정기, 직접 만들어보기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 프로젝트에서 벽에 부딪혔다면 이제 어떻게 해야 할까요" href="/post/2024-06-22-YouveHitaWallinYourDataProjectNowWhat"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 프로젝트에서 벽에 부딪혔다면 이제 어떻게 해야 할까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-YouveHitaWallinYourDataProjectNowWhat_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 프로젝트에서 벽에 부딪혔다면 이제 어떻게 해야 할까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">데이터 프로젝트에서 벽에 부딪혔다면 이제 어떻게 해야 할까요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="본 글에서는 Python, SQL, Power BI를 사용해 특정 소프트웨어 엔지니어링 분야의 국가별 연봉 및 평점 분석 프로젝트를 다루었습니다" href="/post/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="본 글에서는 Python, SQL, Power BI를 사용해 특정 소프트웨어 엔지니어링 분야의 국가별 연봉 및 평점 분석 프로젝트를 다루었습니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="본 글에서는 Python, SQL, Power BI를 사용해 특정 소프트웨어 엔지니어링 분야의 국가별 연봉 및 평점 분석 프로젝트를 다루었습니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">본 글에서는 Python, SQL, Power BI를 사용해 특정 소프트웨어 엔지니어링 분야의 국가별 연봉 및 평점 분석 프로젝트를 다루었습니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SQL에서 중앙값 계산하는 5가지 방법" href="/post/2024-06-22-5WaysToCalculateMedianInSQL"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SQL에서 중앙값 계산하는 5가지 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SQL에서 중앙값 계산하는 5가지 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">SQL에서 중앙값 계산하는 5가지 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link posts_-active__YVJEi" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"안드로이드에서 Network Service DiscoveryNSD 알아보기 및 LAN에서 서비스 발견하는 방법","description":"","date":"2024-06-22 18:08","slug":"2024-06-22-KnowmoreaboutNetworkServiceDiscoveryNSDinAndroidandapproachestodiscoverservicesinLAN","content":"\n\n**테이블** 태그를 마크다운 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFing과 NetX Network Tools 앱과 같이, 우리 앱도 로컬 네트워크의 동적 IP 주소를 찾아내고(동일한 로컬 Wi-Fi 네트워크), 개인 IP 주소를 사용하여 로컬 네트워크 서버에 연결할 수 있습니다.\n\n어떤 일을 시작하기 전에, 우리는 주제의 기초를 알아야 합니다. 그러니 로컬 영역 네트워크(LAN)에서 시작하겠습니다.\n\nCisco에 따르면 로컬 영역 네트워크(LAN)는 건물, 사무실 또는 가정과 같이 한 곳에서 함께 연결된 장치의 집합입니다. LAN은 한 명의 사용자가 있는 홈 네트워크부터 수천 명의 사용자와 장치가 있는 사무실이나 학교의 기업 네트워크까지 다양할 수 있습니다. 더 많은 정보를 보려면 여기를 확인하세요.\n\n# 접근 방법 1\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 개발자들은 로컬 네트워크 내의 IP 주소를 찾기 위해 리눅스 머신에서 이 방법을 따릅니다. 안드로이드 플랫폼 아키텍처는 리눅스 커널에 기반합니다. 안드로이드 앱에서 안드로이드 개발자들은 이 방법을 사용할 수 있습니다. 이 방법은 더 나은 방법은 아니지만, 어떤 안드로이드 개발자들에게는 유용할 수도 있습니다. 이 질문에 대한 답변은 스택 오버플로우에서 찾아볼 수 있습니다. 이를 살펴보기 전에, 자세한 내용을 알아보기 위해 이 질문들을 방문해보시기를 권장합니다.\n\n- 로컬 네트워크 내 시스템(서버)의 IP 주소를 찾는 방법은?\n- 호스트 이름을 통해 로컬 네트워크에서 IP 주소를 찾는 방법은?\n\n```js\nString commandToRun = \"adb shell netcfg\";//장치 IP 주소 찾기\nRuntime.getRuntime().exec(commandToRun);\n```\n\n이를 달성하기 위해 저는 스택 오버플로우의 답변을 추천합니다. 아래 스택 오버플로우 질문을 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 안드로이드에서 IP를 스캔하는 방법은 무엇인가요?\n\n이 방법은 IP 주소와 호스트 이름을 얻는 좋지 않은 접근 방식입니다. 몇몇 안드로이드 개발자들에게 도움이 될 수 있도록 설명했습니다.\n\n# 접근 방법 2\n\n첫 번째 방법에서는 애플리케이션이 LAN에서 각 IP 주소를 핑합니다. 실행하는 데 너무 많은 시간이 걸립니다. 때로는 첫 번째 방법이 호스트 이름을 구성하는 데 실행을 10회 중 2-3회 실패합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 개발자들은 항상 프로그램을 실행하면 빠른 결과를 얻을 수 있는 좋은 알고리즘을 작성하고 싶어합니다. 이 접근법을 통해 어떻게 성취할 수 있는지 배울 수 있습니다. Network Service Discovery (NSD)는 LAN에서 호스트 이름, 서비스를 제공합니다. NSD에서 개발자들은 각 IP 주소 인스턴스를 핑하거나 호스트 이름을 구성하는 데 신경 쓸 필요가 없습니다. Network Service Discovery (NSD)에 대해 알기 전에 mDNS, ZeroConfig 및 Bonjour에 대해 알아야 합니다.\n\nStackOverflow 질문에서는 mDNS 구성에 대해 알아야 했습니다.\n\n컴퓨터 네트워킹에서 멀티캐스트 DNS (mDNS) 프로토콜은 로컬 이름 서버를 포함하지 않는 소규모 네트워크 내에서 호스트 이름을 IP 주소로 해석합니다. 이는 제로 구성 서비스로, 유니캐스트 도메인 이름 서비스 (DNS)와 본질적으로 동일한 프로그래밍 인터페이스, 패킷 형식 및 작동 의미론을 사용합니다. 독립 프로토콜로 작동하거나 표준 DNS 서버와 호환되도록 설계되었습니다.\n\n더 많은 정보를 위해 위키피디아를 참조하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터넷 프로토콜 스위트(TCP/IP)를 기반으로 사용 가능한 컴퓨터 네트워크를 자동으로 생성하는 기술 세트입니다. 컴퓨터나 네트워크 주변 장치들이 연결될 때 수동 운영자 개입이나 특별한 구성 서버가 필요하지 않습니다.\n\n더 많은 정보는 위키피디아에서 확인해보세요.\n\n로컬 네트워크에서 산업 표준 IP 프로토콜을 사용하여 장치와 서비스를 자동으로 발견할 수 있게 해주는 것으로 알려진 제로-구성 네트워킹(Zero-configuration networking)입니다. Bonjour는 Cocoa, Ruby, Python 및 기타 언어에서 접근할 수 있는 정교하고 사용하기 쉬운 프로그래밍 인터페이스로 네트워크 서비스를 발견, 발행 및 해결하기 쉽게 만들어 줍니다.\n\nBonjour은 Apple의 Zero-configuration networking(zeroconf) 구현입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위키백과를 더 자세히 읽어보세요. \n\n그래서 mDNS, Zeroconfig, Bonjour과 같은 것을 Android에서 검색했어요. 여기서 더 나은 방법을 발견했어요. NSD(Network Service Discovery).\n\nNSD를 알기 전에, 개발자는 시스템의 로컬 서버 서비스 구성에 대해 알아야 해요. Avahi는 Linux/Ubuntu 시스템에 설치되어 실행되는 발견 서비스 중 하나에요.\n\nAvahi는 mDNS/DNS-SD 프로토콜 스위트를 통해 로컬 네트워크에서 서비스 검색을 용이하게 해주는 시스템이에요. 이는 노트북이나 컴퓨터를 네트워크에 연결하면 즉시 다른 사람들을 볼 수 있고 채팅할 수도 있고, 프린터를 찾아서 인쇄할 수도 있고, 파일을 공유하고 있는 사람들을 찾을 수 있게 해줘요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 정보를 얻으려면 Avahi와 위키피디아를 참조하세요. \n\n개발자는 프린터를 찾는 것과 같은 사용자 정의 검색 서비스를 개발하고 실행할 수 있습니다. 이러한 검색 서비스는 매우 가벼워요. 이를 위해 개발자는 서비스를 발견하기 위해 서비스 유형을 정의해야 합니다. 국제 할당 번호 기관(IANA)은 NSD와 Bonjour와 같은 서비스 검색 프로토콜에서 사용하는 서비스 유형의 중앙 집중식, 권위 있는 목록을 관리합니다. IANA 서비스 이름 및 포트 번호 목록에서 이 목록을 다운로드할 수 있습니다. 새로운 서비스 유형을 사용할 계획이라면, IANA 포트 및 서비스 등록 양식을 작성하여 예약해야 합니다.\n\nNSD는 로컬 네트워크에서 다른 장치가 제공하는 서비스에 앱 액세스를 제공합니다. NSD를 지원하는 장치에는 프린터, 웹캠, HTTPS 서버 및 기타 모바일 장치가 포함됩니다.\n\nNSD는 DNS 기반 서비스 검색(DNS-SD) 메커니즘을 구현하며, 이를 통해 앱은 서비스 유형과 원하는 서비스 유형을 제공하는 장치 인스턴스의 이름을 지정하여 서비스를 요청할 수 있습니다. DNS-SD는 Android 및 다른 모바일 플랫폼에서 모두 지원됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nZeroConfig, Bonjour, 그리고 NSD의 정의를 읽어 보신 후에 알겠죠? 이 세 가지는 비슷한 기능을 하지만 서로 다른 아키텍처에서 사용됩니다. Bonjour은 주로 Apple 기기에서 사용되고, NSD는 안드로이드 기기에서 사용됩니다.\nNSD 개발을 위해 안드로이드는 개발자 가이드라인을 제공합니다.\n\n- 네트워크 서비스 검색 사용\n\n개발자들은 위 안드로이드 문서를 사용하여 안드로이드 애플리케이션에서 NSD를 구현할 수 있습니다.\n\n로컬 네트워크에서 NSD 구현을 테스트할 때, 안드로이드 5.0 (롤리팝 - API 레벨 21) 및 이 버전보다 낮은 버전에서는 로컬 네트워크에서 서비스를 발견하는 문제가 있습니다. 이에 대해 StackOverflow에서 질문을 했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 네트워크 서비스 탐색(Network Service Discovery)이 발견 서비스 유형이 아닌가요?\n\n안드로이드는 각 버전 수준마다 개선되고 있어요. 구글은 안드로이드 6.0(마시멜로 - API 레벨 23) 이상에서 위 문제를 해결했어요(이 부분은 확실하지 않아서 직접 테스트를 해봐야 해요). 어떻게 이 문제를 해결할 수 있을까요, 다음 접근법에서 설명할게요.\n# 접근법 3\n\n위 접근법에서 언급한대로, 안드로이드 5.0 및 이하 버전에서는 NSD가 잘 작동하지 않아요. 이 접근법은 위 문제를 해결할 거예요. 클라이언트 애플리케이션은 UDP(Universal Datagram Protocol)를 사용하여 서버를 LAN에서 찾을 수 있어요. 이를 위해 둘 다 특정 키를 알아야 하며 발행-구독 기능을 사용하여 이를 달성할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴퓨터 네트워킹에서, User Datagram Protocol (UDP)은 인터넷 프로토콜 슈트의 주요 구성원 중 하나입니다. UDP를 사용하면 컴퓨터 애플리케이션은 데이터그램이라고 불리는 메시지를 다른 호스트에게 인터넷 프로토콜(IP) 네트워크에서 전송할 수 있습니다. 통신 경로나 데이터 경로를 설정하기 위해 이전에 통신할 필요는 없습니다.\n\n더 많은 정보를 위해 위키피디아를 참조하세요.\n\nUDP를 사용하면 지역 네트워크에서 특정 호스트 이름의 IP 주소를 즉시 찾을 수 있습니다. 이를 위해 한 가지 간단한 UDP 서버 코드를 작성해 보겠습니다(Python을 선호합니다. Linux/Ubuntu에는 이미 패키지가 설치되어 있기 때문입니다. Java 언어의 경우, JDK를 설치하고 JRE를 구성해야 합니다). 아래의 Python 코드를 살펴보세요.\n\n```python\nimport socket\nlocalIP = \"127.0.0.1\"\nlocalPort = 20001\nbufferSize = 1024\nmsgFromServer = \"Hello UDP Client\"\nbytesToSend = str.encode(msgFromServer)\n# Datagram 소켓 생성\nUDPServerSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)\n# 주소와 IP에 bind\nUDPServerSocket.bind((localIP, localPort))\nprint(\"UDP 서버 실행 중\")\n# 수신 대기\nwhile True:\n    bytesAddressPair = UDPServerSocket.recvfrom(bufferSize)\n    message = bytesAddressPair[0]\n    address = bytesAddressPair[1]\n    clientMsg = \"클라이언트로부터 메시지: {}\".format(message)\n    clientIP = \"클라이언트 IP 주소: {}\".format(address)\n    \n    print(clientMsg)\n    print(clientIP)\n    # 클라이언트에 응답 보내기\n    UDPServerSocket.sendto(bytesToSend, address)\n```\n\nDefaultCellStyle를 테이블 태그에서 Markdown 형식으로 변경해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로컬 시스템에서 이 코드를 실행하여 IP 주소를 찾으세요. 이 코드는 호스트명/IP 주소 예: server-hostname을 브로드캐스트합니다. 위 코드는 여기에서 확인할 수 있습니다.\n\n이제 안드로이드에서 로컬 네트워크에서 IP 주소나 호스트명을 찾기 위해 UDP 클라이언트 애플리케이션을 작성해야 합니다. 코드 작성을 위해서는 스택 오버플로우 질문과 답변을 확인하세요.\n\n- 안드로이드 — 네트워크에서 서버 찾기?\n\n이 기능은 100% 작동합니다. 1~5초 안에 IP 주소, 호스트명, 서비스를 함께 제공합니다. 이 접근 방식을 사용할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n로컬 네트워크에서 서버의 IP 주소를 찾거나 시스템에서 실행 중인 서비스를 발견하려면 Fing 및 NetXnetwork 도구 앱과 같은 NSD, Zeroconfig, Bonjour 구성을 사용하면 번거로움이 없습니다.\n\n그러나 서비스 이름과 서비스 유형을 사용하여 올바른 IP 주소를 구성하지 못하는 경우가 있습니다. 그런 경우 UDP를 통해 이동하십시오. NSD와 UDP를 결합하여 모든 문제를 극복하는 최상의 접근 방식입니다. 이 구현에 대해 백엔드 개발자도 동의해야 합니다. Rosemary Wang가 잘 설명해 주었습니다. 한 번 확인해 보세요.\n\n# 참고  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 모든 방법에 대해,\n\n- 코루틴, WorkManager, RxJava, RxAndroid와 같은 백그라운드 스레드에서 코드를 실행합니다.\n- Android 기기 WiFi가 Wifi 라우터에 연결되어 있는 경우에만 이 코드를 실행합니다. 이를 위해 Android Manifest 파일에 애플리케이션의 ACCESS_NETWORK_STATE 및 ACCESS_WIFI_STATE를 추가합니다 (모바일 데이터에서는 로컬 서버를 찾을 수 없습니다).\n- IP 주소 또는 서비스 검색 결과를 얻는 데 시간이 걸립니다. Wifi 네트워크나 인터넷 사용 가능 여부에 따라 달라집니다.\n\n이 연구를 공유했습니다. 이를 통해 사람들이 사물 인터넷 (IoT) 구현 문제를 해결하는 데 도움이 되기를 바랍니다. Fing은 이미 사물 인터넷 (IoT)에 착수했습니다. 현재 사물 인터넷은 정보 기술 분야에서 급속히 발전하고 있습니다. 많은 기업이 이에 대해 연구하고 있습니다. 이 분야에 대해 더 많은 이해를 얻으려면 여기를 읽어보실 수 있습니다.\n\n이 기사가 마음에 드시기를 바랍니다. 제 작품을 좋아해 주시면 치얼소리를 낼 수 있습니다. 의견을 남겨주시면 감사하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLinkedIn에서 저와 연결하고 전문적인 관계를 형성할 수 있어요.\n\n내 게시물을 더 많이 보고 싶다면 Mangesh Sambare Profile을 방문해주세요.","ogImage":{"url":"/assets/img/2024-06-22-KnowmoreaboutNetworkServiceDiscoveryNSDinAndroidandapproachestodiscoverservicesinLAN_0.png"},"coverImage":"/assets/img/2024-06-22-KnowmoreaboutNetworkServiceDiscoveryNSDinAndroidandapproachestodiscoverservicesinLAN_0.png","tag":["Tech"],"readingTime":7},{"title":"ISO IEC 20546와 AI에서의 빅 데이터 미래 산업 40에 대한 영향","description":"","date":"2024-06-22 18:06","slug":"2024-06-22-ISOIEC20546andtheFutureofBigDatainAIImplicationsforIndustry40","content":"\n\n디지턉 시대에 있어서 데이터는 종종 새로운 석유로 불리곤 합니다. 그러나 날인 데이터는 정제되어야만 진정으로 가치 있는 것이 되죠. 이 때 등장하는 것이 대용량 데이터 분석입니다. 이 분야는 현대 AI 및 기계 학습 응용 프로그램의 중추가 되었습니다. 기업들이 방대한 양의 데이터를 관리하고 활용하는 문제에 직면하면서, 국제표준화기구(ISO)와 국제전기기술위원회(IEC)가 ISO/IEC 20546: 정보 기술 - 대용량 데이터 - 개요 및 용어를 통해 나섰습니다. 이 표준은 또 다른 기술 문서가 아니라, 대용량 데이터 시대를 위한 ‘로제타 스톤’ 역할을 하며, AI의 발전에 있어 중요한 공통 언어와 프레임워크를 제공합니다.\n\n먼저, ISO/IEC 20546이 무엇을 제공하는지 알아보겠습니다. 이 표준은 대용량 데이터에 대한 정의와 개념적인 프레임워크를 제공합니다. 이 표준은 대용량 데이터를 “부피, 속도, 다양성 및/또는 가변성 특성에서 주로 나타나는 광범위한 데이터 세트로, 효율적인 저장, 조작, 관리 및 분석을 위한 확장 가능한 기술이 필요한 것”으로 정의합니다. 이 정의는 실제 응용에서 데이터의 동적인 특성을 인정하기 위해 변동성을 포함한 기존의 “3Vs”(부피, 속도, 다양성)를 넘어선 중요한 요소입니다.\n\n이제 산업혁명 4.0에 대한 영향을 살펴보겠습니다. 디지털, 물리 및 생물학적 시스템이 융합된 네 번째 산업 혁명으로 특징 지어지는 이 시대에는 스마트 공장에서 사물 인터넷(IoT) 센서가 기계 성능부터 환경 조건까지 다양한 데이터를 생성합니다. 디지털 트윈, 물리자산의 가상 복제본은 프로세스를 시뮬레이션하고 최적화하기 위해 데이터를 생성하고 사용합니다. 또한 AI 기반 예측적인 유지보수 시스템은 과거 및 실시간 데이터를 분석하여 장비 고장을 예측합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n큰 데이터에 대한 표준화된 접근 방식이 없다면, 이러한 4차 산업혁명 기술들은 나침반이 없는 배와 같을 것입니다. ISO/IEC 20546은 그 나침반이 됩니다. 공통 어휘를 제공함으로써 독일 자동차 제조업체가 일본 로봇 기업과 \"데이터 속도\"에 대해 이야기할 때, 둘 모두가 동일한 페이지에서 이야기하도록 보장합니다. 이러한 표준화는 현대 산업의 글로벌하고 연결된 지형에서의 협업과 상호 운용성을 가속화시킵니다.\n\n게다가, 이 표준의 확장성에 대한 강조는 AI 응용 프로그램에 증가할 가능성을 제공합니다. 특히 딥러닝 알고리즘을 포함한 기계 학습 모델은 데이터를 필요로 합니다. 그들이 소비하는 데이터가 많을수록 예측이 더 정확해집니다. 그러나 모든 데이터가 동일하지는 않습니다. 소셜 미디어, 이미지 또는 센서 로그와 같은 소스에서 나오는 비정형 데이터(큰 데이터의 \"다양성\")는 풍부한 통찰력을 제공하지만 처리가 어렵습니다. ISO/IEC 20546의 프레임워크는 이 다양성을 처리할 수 있는 확장 가능한 기술의 개발을 장려하며, 이는 더 견고하고 적응 가능한 AI 모델로 이어집니다.\n\n실제 사례를 살펴보겠습니다: 예측 정비를 위해 AI를 사용하는 풍력 터빈 농장. 각 터빈은 풍속, 날개 온도 및 진동과 같은 변수를 측정하는 센서로 장착되어 있습니다. 데이터는 다양한 형식으로(다양성) 실시간으로(속도) 스트림되어 옵니다. 시간이 경과함에 따라 축적된 데이터는 페타바이트 규모에 달하게 되며(용량), 또한 계절에 따라 데이터 특성이 변경되거나 터빈이 노후화됩니다(가변성). ISO/IEC 20546 호환되는 대규모 데이터 아키텍처는 이러한 이질적인 데이터를 효율적으로 저장하고 실시간 분석을 통해 즉각적인 조치(예: 날개 각도 조정)를 취할 수 있게 해주며, 기계 학습 모델에 예측 실패를 몇 주 앞선 시점에 예측할 수 있는 히스토리컬 데이터를 제공합니다. \n\n효율성과 지속 가능성에 미치는 영향은 엄청납니다. McKinsey는 AI 기반의 예측 정비가 기계 다운타임을 최대 50% 줄이고 기계 수명을 20~40% 연장할 수 있다고 추정합니다. 풍력 농장 사례에서는 이를 통해 더 규칙적인 재생 에너지 생산과 유지 보수 비용 절감이 이루어지며, 경제성과 기후 목표에 기여합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 ISO/IEC 20546의 혜택은 운영 효율성을 넘어서 더 많은 이점을 제공해요. GDPR과 CCPA와 같은 증가하는 데이터 개인정보 보호 규정 시대에, 이 표준은 데이터 거버넌스에 중점을 두고 있어요. AI 시스템이 개인에게 영향을 미치는 결정을 내릴 때 데이터의 기원, 품질, 보안을 고려하도록 조직을 격려해요. 데이터 거버넌스에 대한 표준화된 접근 방식은 기업이 규제 요구사항을 탐색하고 벌금과 평판 훼손을 피할 수 있도록 도와줄 수 있어요.\n\n뿐만 아니라, 자동화된 AI 시스템이 4차 산업혁명 환경에서 더 독립적으로 작동하는 상황에서는, 생산물의 출처와 품질이 중요해져요. 잘 관리되지 않은 데이터로 내린 결정은 비용이 많이 들거나 심지어 안전 위험을 초래할 수 있어요. ISO/IEC 20546은 좋은 데이터 관행을 촉진함으로써 더 안전하고 신뢰할 수 있는 AI 시스템의 기초를 마련해줘요.\n\n이 표준은 또한 AI 인재 파이프라인에도 영향을 미쳐요. ISO/IEC 20546과 교육 계획을 맞추는 대학과 교육 프로그램은 \"산업에 적합한\" 데이터 과학자와 AI 엔지니어를 배출하게 될 거예요. 그들은 알고리즘 뿐만 아니라 실제로 크고 복잡한 데이터와 작업하는 방법도 이해할 거에요. 이 조정은 4차 산업혁명 채택의 중요 장벽인 AI 기술 역량 부족을 극복하는 데 도움을 줄 수 있어요.\n\n앞으로 보면, ISO/IEC 20546이 형성하는 AI에서의 큰 데이터의 미래는 흥미롭습니다. 우리는 \"인지형 제조\"로 나아가고 있어요. AI 시스템이 예측하고 최적화하는 것뿐만 아니라 학습하고 이유를 파악하며 인간과 유사한 방식으로 추론하는 시대에요. 기계가 언제 고장날지만 예측하는 AI가 아니라 그 이유를 이해하고 설계 개선을 제안하며 심지어 인간 엔지니어들과 자연어 대화를 나누는 AI를 상상해보세요. 이러한 발전은 단순히 더 많은 데이터만이 아니라, 잘 이해되고 잘 관리되며 상호 운용 가능한 데이터가 필요합니다. 바로 ISO/IEC 20546이 옹호하는 것과 일치하는 바에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론:-\n\n마지막으로, ISO/IEC 20546은 표준 이상을 나타내는 바가 있습니다; 이것은 AI 주도적 미래의 기본적인 요소입니다. 대용량 데이터에 대한 공통 언어와 프레임워크를 제공함으로써, 이것은 산업 4.0에서 AI 채택을 가속화하고 협력을 강화하며 데이터 거버넌스를 개선하고 인지 시스템을 위한 길을 열어줍니다. 비즈니스 리더에게는 강력한 데이터 인프라에 투자해야 할 필요성을 강조하는 호소입니다. 기술자에게는 확장 가능하고 상호 운용 가능한 시스템을 구축하기 위한 안내서입니다. 그리고 사회에게는 강력하면서도 신뢰성 있고 투명하며 인간의 가치와 일치하는 AI 시스템의 한 걸음입니다. 4차 산업 혁명의 큰 이야기에서, ISO/IEC 20546은 우리에게 데이터의 초기 상을 지식의 정제된 연료로 바꾸는 데 도움이 되었던 표준으로 기억될 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-ISOIEC20546andtheFutureofBigDatainAIImplicationsforIndustry40_0.png"},"coverImage":"/assets/img/2024-06-22-ISOIEC20546andtheFutureofBigDatainAIImplicationsforIndustry40_0.png","tag":["Tech"],"readingTime":4},{"title":"CVE-202120090 취약점을 이용한 Arcadyan 라우터 인증 우회 및 Buffalo 라우터 루팅 방법","description":"","date":"2024-06-22 18:04","slug":"2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo","content":"\n\n얼마 전에 아마존 일본을 둘러보다가 베스트셀러인 네트워킹 장비/라우터를 찾아보았습니다(사람들이 하는 일종의 활동이죠). 라우터의 안을 열어본 적도 없고 취약점을 찾아본 적도 없는데, 한번 시도해보고 싶다는 생각이 들었습니다. 리스트에서 세 번째로 잘 팔리는 Buffalo WSR-2533DHP3를 발견했습니다. 하지만 판매자가 캐나다로 배송을 해주지 않아서, 관련된 Buffalo WSR-2533DHPL2를 구매했어요(결국 WSR-2533DHP3도 손에 넣었습니다).\n\n다음 장에서는 Buffalo 장비를 해체하는 과정, 그리고 조금 건드린 솔더 작업과 함께 UART에서 제공된 셸을 사용해서 웹 인터페이스의 인증 우회 및 텔넷에서 루트 BusyBox 셸을 활성화할 수 있는 버그를 찾는 과정을 살펴볼 것입니다.\n\n마지막으로, Buffalo 라우터에만 해당되지 않는 인증 우회 취약점의 발견과 열 년 이상의 기간에 걸쳐 다양한 공급업체의 적어도 12개 모델에 영향을 미치는 것을 발견한 과정도 짧게 살펴보겠습니다.\n\n# UART에서 루트 셸\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 Buffalo 라우터와 같은 기기들이 회로 기판의 Universal Asynchronous Receiver/Transmitter (UART)를 통해 시리얼 연결을 통해 쉘을 제공하는 것은 상당히 일반적입니다. 제조업체들은 주로 제조 과정 중에 기기를 디버깅하거나 테스트하는 데 사용하기 위해 UART에 액세스하기 위한 테스트 포인트나 비파괴된 패드를 회로 기판에 남겨 둡니다. 이러한 방법들은 제조 도중에 기기를 테스트하거나 디버깅할 때 자주 사용됩니다. 이번 경우에는, 몇 가지 마찰로 인해 실종된 후에 WSR-2533DHPL2가 BusyBox 쉘을 루트로 UART를 통해 제공하게 되었다면서 우리는 굉장히 운이 좋았습니다.\n\n이 내용이 처음이면, 이 과정을 빠르게 알아보겠습니다 (하드웨어 해킹 및 UART 쉘에 대한 더 자세한 안내가 있는 웹 사이트들도 많이 있습니다).\n\n첫 번째 단계는 라우터의 케이스를 열고 UART에 액세스할 방법이 있는지 확인하는 것입니다.\n\n![이미지](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 J4로 레이블링된 헤더를 볼 수 있습니다. 아마도 우리가 찾고 있는 것일지도 모릅니다. 다음 단계는 멀티미터를 사용하여 접촉을 테스트하여 전원(VCC), 접지(GND), 그리고 전송/수신(TX/RX) 핀을 식별하는 것입니다. 이러한 것들을 식별하면 핀을 몇 개 납땜하고 JTAGulator와 같은 도구에 연결하여 통신할 핀과 속도를 식별할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_1.png)\n\n다른 방법으로도 식별할 수 있지만, JTAGulator를 사용하면 훨씬 쉬워집니다. 우리가 사용할 전압(이전에 멀티미터를 사용하여 찾은 3.3V)을 설정한 후 UART 스캔을 실행할 수 있습니다. 이를 통해 개별 핀에서 캐리지 리턴(또는 다른 지정된 바이트)을 전송하고 다양한 속도로 수신하여, 어떤 조합이 디바이스와의 통신을 가능하게 할지 식별할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUART 스캔 결과, TX로 핀 0을 통해 캐리지 리턴을 보내고, RX로 핀 2를 사용하며, 속도는 57600으로 설정하면, BusyBox v1 출력이 나타납니다. 이는 셸을 획득한 것 같습니다.\n\n![이미지](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_3.png)\n\n확실한 증거로, JTAGulator를 UART 통과 모드로 설정한 후 (이를 통해 UART 포트와 통신할 수 있음), UART 스캔으로 찾은 설정을 사용하여 기기의 루트 셸에 진입하게 됩니다.\n\n![이미지](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제이 쉘을 사용하여 장치를 탐색하고 장치의 웹 인터페이스를 제공하는 httpd 이진 파일과 같은 흥미로운 이진 파일을 다른 기계로 전송할 수 있습니다.\n\n# Httpd 및 웹 인터페이스 인증\n\nhttpd 이진 파일에 액세스할 수있는 것은 웹 인터페이스의 취약점을 찾는 작업을 훨씬 쉽게 만들어 줍니다. 이를 Ghidra에 넣어서 코드의 흥미로운 부분을 식별할 수 있습니다. 웹 응용 프로그램이나 인터페이스를 분석할 때 가장 먼저 검토하는 항목 중 하나는 인증 정보가 처리되는 방식입니다.\n\n웹 인터페이스를 검토하는 동안 로그인 한 후에도 세션 쿠키가 설정되지 않고 로컬/세션 스토리지에 토큰이 저장되지 않는 것을 발견했습니다. 그래서 인증된 사용자를 추적하는 방법은 무엇일까요? Ghidra에서 httpd를 열어보면 evaluate_access()라는 함수를 찾을 수 있으며, 이 함수는 다음 스니펫으로 이어집니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 스크린샷에서 FUN_0041f9d0()는 현재 요청을 하는 호스트의 IP가 이전 유효한 로그인의 IP와 일치하는지 확인합니다.\n\nevaluate_access()가 무엇을 하는지 알게 되었으니, 이를 우회할 수 있는지 살펴봅시다. Ghidra에서 언급된 위치를 검색해보면, 이 함수가 들어오는 HTTP 요청을 처리하는 다른 함수 process_request()에서만 호출된다는 것을 알 수 있습니다.\n\n아래 화면 스크린샷에서 확인할 수 있듯이, 큰 if 문 안에 논리 OR이 있고 (스크린샷 상의 45~48 라인), uVar1의 값을 확인함에 있어 evaluate_access()의 출력을 확인하기 전에 uVar1의 값을 확인합니다(43 라인에 설정됨). 이는 bypass_check(__dest)의 출력이 0이 아닌 다른 값이 반환된다면 인증이 필요 없이 요청이 처리되어 process_get() 또는 process_post()로 전달될 수 있다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nbypass_check()을 살펴봅시다.\n\n# bypass_check()으로 체크 우회하기\n\n위 스크린샷에서 bypass_check()를 살펴보면 bypass_list를 순회하며 _dest의 처음 n바이트를 bypass_list에서 가져온 문자열과 비교하는 것을 볼 수 있습니다. 여기서 n은 bypass_list에서 가져온 문자열의 길이입니다. 일치하는 것이 없으면 0을 반환하고 evaluate_access()에서 체크를 통과해야 합니다. 그러나 문자열이 일치하면 evaluate_access()의 결과가 중요하지 않으며 서버는 우리 요청을 예상대로 처리할 것입니다.\n\n우회 목록을 살펴보면 login.html, loginerror.html 및 다른 경로/페이지가 있습니다. 인증되지 않은 사용자도 해당 URL에 액세스할 수 있어야 하기 때문에 이는 합리적으로 보입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에 버그를 이미 발견하신 것 같아요. bypass_check() 함수는 bypass_list 문자열에 있는 바이트 수만큼만 확인하고 있습니다. 이는 사용자가 http://router/images/someimage.png에 액세스하려고 할 때, 비교가 일치할 것이라는 것을 의미합니다. 왜냐하면 /images/가 bypass 리스트에 있기 때문에 우리가 액세스하려는 URL은 /images/로 시작하기 때문이에요. 그러나 bypass_check() 함수는 \"someimage.png\"과 같이 이후에 오는 문자열에는 신경쓰지 않아요. 그래서 우리가 /images/../`somepagehere`에 도달하려고 하면 어떻게 될까요? 예를 들어, /images/..%2finfo.html을 시도해 봅시다. 일반적으로 /info.html URL은 우리가 기기에 처음 로그인할 때의 모든 LAN/WAN 정보를 포함하고 있으나 인증되지 않은 사용자들을 로그인 화면으로 돌려보냅니다. 특별한 URL로 우리는 인증 요구사항을 우회할 수 있을지도 모르겠어요.\n\n상대 경로를 고려한 일부 매치/치환 후에도 여전히 별로 흥미로운 내용이 나타나지 않아요. 우리는 경로 트래버설을 사용하여 인증을 우회했지만 뭔가 부족한 것 같아요.\n\nBurp 트래픽을 살펴보면, /cgi/`various_nifty_cgi`.js로의 여러 요청이 404를 반환하는 것을 볼 수 있는데, 일반적으로 우리가 원하는 모든 정보를 반환합니다. 또한 이 파일들에 대한 요청을 만들 때 전달되는 몇 가지 매개변수도 볼 수 있어요.\n\n그 중 하나인 (_t)은 날짜 및 시간 스탬프에요. 다른 하나는 CSRF 토큰처럼 작동하는 httoken인데, 이러한 토큰들이 어디에서 어떻게 생성되는지 알아내는 것은 다음 섹션에서 논의할 것입니다. 지금은 이 특정 요청들이 실패하는 이유에 초점을 맞춰봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래의 텍스트를 Markdown 형식으로 변경하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금까지의 빠른 요약:\n\n- 인증을 우회하여 인증된 사용자만 액세스할 수 있는 페이지에 액세스할 수 있습니다.\n- 해당 페이지에는 민감한 정보를 요청하거나 포스트 요청을 만들 수 있는 httoken에 액세스할 수 있습니다. 그리고 설정 변경을 할 수 있는 권한을 부여받을 수 있습니다.\n- 우리는 httoken이 수락되기 위해 Referer 헤더를 적절히 설정해야 한다는 것을 알고 있습니다.\n\n# 적절한 httoken을 얻는 모험\n\n우리는 접근한 페이지에서 어느 시점에서 httoken이 얻어진다는 것을 알지만, 그들이 어디서 나오는지 또는 어떻게 생성되는지는 알지 못합니다. 이것은 장치에서 민감한 작업을 수행하거나 액세스하기 위해 필요한 요소이기 때문에, 이 부정행위를 더 이어나가고 싶다면 이러한 토큰이 어디서 발급되어지는지를 파악하는 것이 중요할 것입니다. 웹 인터페이스가 이 토큰을 생성하는 방법을 추적하는 것은 Capture-the-Flag 이벤트에서 하는 것처럼 느껴졌습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 경로 순회로 접근한 info.html 페이지는 /cgi/ 디렉토리 아래에 있는 .js 파일에서 데이터를 가져와 정보 테이블을 채우고 있었으며, 두 개의 매개변수를 전달하고 있었습니다. 하나는 날짜 및 시간 스탬프(_t)이고, 다른 하나는 파악하려는 httoken입니다.\n\n/cgi/에서 정보를 가져오기 위해 사용되는 링크들이 URLToken() 함수를 사용하여 생성되고 있음을 알 수 있습니다. 이 함수는 httoken을 설정하고(get_token()을 이용하여) 있는데, 페이지에서 사용된 스크립트 중 어디에도 get_token() 함수가 정의되어 있지 않은 것 같습니다.\n\nURLToken()이 정의된 바로 위에는 아래와 같이 이상한 문자열이 정의되어 있는 것을 볼 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_8.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당하는 위치를 살펴보면 다음과 같은 조각을 찾을 수 있습니다.\n\n위 코드를 실행하면 페이지에 다음 스크립트가 추가됩니다:\n\ngetToken() 함수를 찾았지만 여기로 이어진 스니펫들과 마찬가지로 뭔가 이상한 일을 하고 있습니다. 모든 페이지에 존재하는 이미지 태그에서 또 다른 인코딩된 문자열을 가져 오고 있습니다 (인코딩된 문자열이 다릅니다). 여기에서 무슨 일이 벌어지고 있는 걸까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"이 공간 화상 img src 문자열에서 httoken이 가져와져 민감한 리소스에 요청을 만드는 데 사용됩니다.\n\nGhidra에서 httoken이 img 태그에 삽입되는 함수를 찾을 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_10.png\" /\u003e\n\nhttoken의 설정/반환 및 GET 및 POST 요청에 대한 검사에 대한 모든 세부 정보에 대해 다루지 않고, 다음과 같이 말할 수 있습니다:\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 웹 인터페이스의 다양한 부분에 GET 및 POST 요청을 보내기 위해 필요한 httokens은 서버 측에서 생성됩니다.\n- 페이지가 로드될 때 img 태그에 인코딩되어 저장됩니다.\n- 그런 다음 클라이언트 측 자바스크립트에서 디코딩됩니다.\n\n요청 중에 사용되는 토큰과 Referer가 일치하는 한 원하는 요청에 토큰을 사용할 수 있습니다. 로그인.html에서 얻은 토큰을 사용하여 민감한 페이지로 요청을 보낼 수 있지만 구성 변경과 같은 일부 작업에 액세스하려면 여전히 인증 우회가 필요합니다.\n\n특히 WSR-2533DHPL2에서 토큰의 이러한 지식만으로도 장치의 관리자 암호에 액세스할 수 있습니다. 같은 시기에 출시된 펌웨어를 가진 WSR-2533DHP3에서는 이미 수정된 취약점이 있는 것으로 보입니다.\n\n이제 인증되지 않고 기기에서 어떤 작업이든 효과적으로 수행할 수 있다는 것을 알게 되었으니, 그것으로 무엇을 할 수 있는지 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 설정 옵션을 삽입하고 telnetd를 활성화합니다\n\n웹 인터페이스 또는 애플리케이션에서 핑 기능과 같은 유틸리티를 갖고 있는 경우, 저희가 먼저 확인하는 곳 중 하나는 이러한 유틸리티가 어떻게 구현되었는지입니다. 왜냐하면 단순히 Google에서 라우터 핑 유틸리티가 명령 삽입 취약점에 취약하다는 많은 사례들이 나옵니다.\n\n핑 명령에서 쉽게 취약한 명령 삽입이 없었지만, 핑 명령이 웹 인터페이스에서 실행될 때 핑할 호스트의 입력을 받게 됩니다. 이것이 어떻게 실행되는지 살펴보는 것으로 다른 취약점을 발견했습니다.\n\n![이미지](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요청이 성공적으로 이루어지면, ARC_ping_ipaddress가 전역 구성 파일에 저장됩니다. 이를 기억하며, 제가 먼저 해본 것은 새 줄/개행 문자(%0A로 URL 인코딩)를 삽입한 후 일부 텍스트를 입력하여 구성 설정을 주입할 수 있는지 확인하는 것이었습니다. 확인 결과, 구성 파일을 확인할 때 %0A 뒤에 입력한 텍스트가 새 줄에 나타납니다.\n\n![image](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_12.png)\n\n이를 고려하여, 우리는 볼 수 있는 흥미로운 구성 설정을 살펴보고, ARC_ping_ipaddress 매개변수를 주입하여 그 값을 덮어쓸 수 있기를 희망합니다. 구성 파일에서 여러 옵션을 볼 수 있지만, 내 관심을 끈 하나는 ARC_SYS_TelnetdEnable=0이었습니다. Telnetd를 활성화하는 것은 기기에 원격 쉘을 획들할 수 있는 좋은 후보로 보였습니다.\n\nARC_SYS_TelnetdEnable=1로 구성 파일에 간단히 주입해도 ARC_SYS_TelnetdEnable=0이 파일 끝부분에 나타나기 때문에 충돌 설정이 발생할 수 있을지 애매했습니다. 하지만, Burp Suite에서 다음 요청을 보낸 후 재부팅 요청을 보내면 (일부 구성 변경이 적용되려면 필요합니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_13.png\" /\u003e\n\n재부팅이 완료되면 텔넷이 수신 대기 중인 포트 23에서 장치에 연결할 수 있고, UART를 통해 얻는 것과 마찬가지로 root BusyBox 쉘로 환영받습니다.\n\n# 전부 함께\n\n만약 우리가 이 쉽게 악용할 수 있는 기회를 이용하려면, 파이썬 스크립트에서 함께 조합해야 할 부분들은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 페이지의 img 태그에서 올바른 httokens을 가져옵니다.\n- 이러한 httokens을 경로 이탈과 결합하여 apply_abstract.cgi에 유효한 요청을 보냅니다.\n- apply_abstract.cgi에 ARC_SYS_TelnetdEnable=1 설정 옵션을 삽입합니다.\n- 장치를 다시 부팅하기 위해 또 다른 유효한 요청을 보냅니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*qT0xv6hfMHDf0BDm5bqAqw.gif)\n\n# 놀라운 사실: 더 많은 영향을 받는 장치\n\n이 블로그에서 논의된 취약점의 90일 공개 날짜 직전에 Shodan 및 BinaryEdge를 통해 온라인에서 보이는 잠재적으로 영향을 받을 수 있는 장치 수를 결정하려고 했습니다. 검색 중에 버팔로 장치에서 본 것과 유사한 웹 인터페이스를 갖춘 여러 장치를 발견했습니다. 사실상 똑같았는데, 거의 모든 img 태그에서 동일한 이상한 방법으로 httokens을 숨기고 \"enkripsi\" 문자열에 은식화된 자바스크립트 함수를 사용하는 것으로 보였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공통점은 모든 장치가 Arcadyan에 의해 제조되었다는 것입니다. 사실, 버팔로 제품 라인 외의 영향을 받는 장치를 찾기 위해 더 많이 살펴볼 필요가 있었을 것으로 생각됩니다. 왜냐하면 버팔로 펌웨어의 많은 부분이 Arcadyan에 의해 제작되었다는 것이 분명했기 때문입니다. 그러나 일련의 Arcadyan 제조 장치를 입수하고 테스트한 결과, 모든 장치가 동일하게 작성되지 않았으며 장치들이 항상 정확히 동일한 방식으로 영향을 받는 것은 아니라는 것도 분명했습니다.\n\n그럼에도 불구하고, 우리가 테스트할 수 있었거나 제3자를 통해 테스트된 모든 장치들이 적어도 하나의 취약성을 공유했습니다: 공격자가 인증을 우회할 수 있는 경로 이동(CVE-2021-20090로 할당됨)입니다. 이는 거의 모든 Arcadyan 제조 라우터/모뎀에서 발견된 것으로 보이며, 이는 원래 2008년까지 판매된 장치들도 포함하여 찾을 수 있었습니다.\n\n2021년 4월 21일, Tenable은 CVE-2021-20090를 4개 추가 업체(Hughesnet, O2, Verizon, Vodafone)에 보고하였으며, 이 문제를 4월 22일에 Arcadyan에 보고하였습니다. 시간이 흘러간 결과로 많은 업체들이 영향을 받았고, 모든 업체들과 연락을 취하고 추적하는 것은 매우 어려워졌습니다. 그래서 5월 18일, Tenable은 이 문제를 처리하기 위해 CERT 조정 센터에 문제를 보고하였습니다. 영향을 받는 장치 목록은 Tenable의 고발서 또는 문제를 추적하는 CERT 페이지에서 확인할 수 있습니다.\n\nArcadyan 펌웨어의 이러한 취약성이 최소 10년 동안 존재했으며, 그 결과 공급망을 통해 적어도 17개의 다른 제조업체의 20개 모델에 이르기까지 길을 찾았다는 점에 대해 훨씬 더 큰 대화가 있을 수 있으며, 이에 대한 논의는 Tenable이 발표한 백서에서 짚여져 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 배운 점\n\n버팔로 WSR-2533DHPL2는 취약점을 발견하기 위해 구매한 첫 번째 라우터였는데, 정말 재미있는 경험이었어요. 이상한 가려움 작업과 버그의 단순함으로 인해 내 소중한 CTF처럼 느껴졌어요. 하나의 취약점(CVE-2021–20090)이 얼마나 널리 퍼져 있는지 알게 되어 예상 이상의 것을 얻었지만, 이는 소비자 전자제품에 대한 연구 방법을 접근하는 방법에 대한 중요한 교훈이었어요: 기기를 판매하는 공급 업체가 제조한 것은 아니라는 것, 소비자 라우터의 펌웨어에 버그를 발견하면 단지 연구 중인 기기만이 아니라 수많은 업체와 기기에 영향을 줄 수 있다는 점을 알 수 있었어요.\n\n또한, 20개 이상의 영향을 받는 기기 중 하나를 손에 넣을 수 있는 보안 연구자들이 구성 주입과 같은 사후 인증 취약성을 찾아보고(보고)하는 것을 장려하고 싶어요. 이 기기 세트에서 더 많은 문제가 발견될 것으로 의심하지만, 각 기기는 약간 다르며 해당 국가에 거주하지 않는 연구원들에게 구하기 어렵다는 점을 알 수 있어요.\n\n읽어주셔서 감사합니다. 해킹 즐기세요!","ogImage":{"url":"/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_0.png"},"coverImage":"/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_0.png","tag":["Tech"],"readingTime":11},{"title":"인턴십 여정 회고 내 인생의 변화를 불러온 경험","description":"","date":"2024-06-22 18:03","slug":"2024-06-22-ReflectingonMyInternshipJourneyATransformativeExperience","content":"\n\n인턴십을 통해 전문가로 성장하는 여정에 돌입하면서 발견하고 배우고 성장하는 과정과 유사합니다. 인턴십 경험을 되돌아보면, 선택한 분야에 대한 시야와 나의 개인 발전에 얼마나 큰 영향을 미쳤는지 깨닫게 됩니다.\n\n## 시작: 기대와 열정\n\n많은 포부 있는 전문가들과 마찬가지로, 인턴십을 시작할 때 흥분과 긴장이 섞인 감정을 가졌습니다. 이는 교실에서 배운 지식을 실무 환경에 적용하는 첫 번째 실제 기회였기 때문입니다. 처음 몇 날은 오리엔테이션 세션, 새로운 동료들을 만나는 시간, 그리고 회사 문화에 적응하는 것으로 가득 찼습니다. 각종 상호작용과 소개는 앞으로 일어날 일에 대한 기대를 더했습니다.\n\n## 현실 세계의 도전에 몰입하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n든 딱 정착한 직후, 제 학문적 배경과 직업적 목표와 부합하는 다양한 프로젝트를 맡게 되었습니다. 이러한 프로젝트들을 통해 실제 세계에서 발생하는 도전들에 직면하게 되었는데, 이를 해결하기 위해 기술적 전문 지식 뿐만 아니라 비판적 사고와 창의성이 필요했습니다. 프로젝트 목표를 달성하기 위해 협력과 의사 소통의 중요성을 빨리 깨달았습니다. 경험 많고 전문적인 전문가들과 함께 일하는 것은 교과서로는 완벽히 담을 수 없는 산업 관행과 표준을 소중한 통찰력을 제공해 주었습니다.\n\n## 업무 기술 외의 배움\n\n인턴십에서 가장 보람찼던 점 중 하나는 책임 범위를 벗어나 다양한 활동에 참여할 수 있는 기회였습니다. 산업 컨퍼런스 참석, 네트워킹 이벤트, 점심 시간 세미나 참여 등, 각 경험들은 더 넓은 산업 환경에 대한 이해를 넓히는 데 도움이 되었습니다. 경력이 풍부한 전문가들과 토론하고 그들의 경력 이야기를 듣는 것은 이 분야 내에서 갈 수 있는 다양한 길을 엿볼 수 있게 해 주었습니다.\n\n## 도전은 성장의 기회로 변환\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인턴십 도중에 마주한 여러 어려움을 극복하며 저는 탄력성과 적응력을 키웠어요. 때로는 어려워 보이는 과제나 처음에 기대한 것보다 어려운 상황을 만날 때도 있었죠. 하지만 각 어려움은 학습하고 지식을 쌓을 수 있는 기회로 바뀌었어요. 이러한 도전들을 극복하는 과정은 제 자신의 자신감을 높였을 뿐 아니라 계속해서 배우는 열정을 더욱 강화시켰어요. \n\n# 멘토십과 안내\n\n인턴십 경험에서 중요한 역할을 한 것은 시니어 동료들로부터 받은 멘토십과 안내였어요. 그들의 멘토십은 기술적인 조언뿐만 아니라 직업에 대한 통찰력, 개인적인 발전 팁, 새로운 아이디어를 탐험하도록 격려해주는 것까지 포함되었어요. 그들이 저의 성장에 시간을 투자해주고 건설적인 피드백을 제공해준 것은 제 전문적인 견해 형성에 중요한 역할을 했어요.\n\n# 개인 성장과 반성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전문적인 기술 능력을 넘어서, 인턴십 경험은 개인적인 성장의 시기였어요. 나의 강점과 개선할 부분을 발견하고, 시간 관리 능력을 개발하며, 일을 효과적으로 우선순위를 정하는 능력을 향상했어요. 더 나아가, 이 경험을 통해 긍정적인 태도를 유지하는 것의 중요성, 빠르게 변화하는 환경에서 적응하며 지속적인 성장을 위한 마음가짐을 기를 수 있었어요.\n\n# 결론: 미래를 위한 기반\n\n인턴십이 막을 내리면서, 이 기간 동안 형성된 경험과 관계에 대한 깊은 감사의 마음을 가지고 떠납니다. 기술적인 능력과 산업 지식뿐만 아니라, 미래 경력을 위한 목적과 방향을 나에게 심어준 것이죠. 앞으로, 배운 것을 적용하고 내가 선택한 분야에 의미 있는 기여를 하고자 합니다.\n\n요컨대, 인턴십 경험은 변화의 시간이었어요. 전문적인 세계의 복잡성을 자신 있고 열정적으로 탐험할 수 있도록 제 준비를 해주었죠. 새로운 경력 여정을 시작할 때, 인턴십에서 배운 교훈과 만들어진 인연이 저를 이끌고 영감을 주며 계속해서 나를 이끌어줄 것이라고 확신합니다.","ogImage":{"url":"/assets/img/2024-06-22-ReflectingonMyInternshipJourneyATransformativeExperience_0.png"},"coverImage":"/assets/img/2024-06-22-ReflectingonMyInternshipJourneyATransformativeExperience_0.png","tag":["Tech"],"readingTime":2},{"title":"AWS IoT Core  꼭 알아야 할 모든 것","description":"","date":"2024-06-22 17:59","slug":"2024-06-22-AWSIoTCoreEverythingYouNeedToKnow","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_0.png\" /\u003e\n\n## 사물 인터넷 / AWS / IoT 코어 / 파트 I\n\n인터넷의 사물은 계속해서 증가하고 그 영향이 모든 산업에서 느껴지고 있습니다. 2025년까지 기대되는 가치가 1.6조 달러가 넘는 인터넷의 사물이 기업에 어떤 이점을 제공할 수 있는지 탐색하기 시작하는 것이 중요합니다. 그리고 그것이 AWS IoT 코어와 같은 IoT 플랫폼이 등장하는 곳입니다.\n\n창립자로써, 우리는 항상 제품을 빠르게 시장에 출시하길 원합니다. 백만 달러 제품으로 변할 아이디어가 떠오르면, 그 아이디어를 실현으로 바꿔야 합니다. 그리고 빨리! 기술은 시간이 지남에 따라 발전해 왔습니다. 요즘에는 기술적 발전 덕분에 비즈니스가 제품을 과거보다 훨씬 빠르게 시장에 출시할 수 있습니다. 특히 클라우드 기술은 응용 프로그램을 배포하는 데 더 간단하고 빠르게 만들어 주었습니다. 이제는 어디에서나 컴퓨팅 파워 및 다양한 저장소에 액세스할 수 있어 제품을 신속하게 시장에 출시하기가 더 쉬워졌습니다. 따라서 제품 개발 주기를 단축하려면 더 이상 볼 것이 없습니다 - 클라우드가 해답입니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비슷하게, 센서와 같은 물리적 장치가 있는 경우 다른 장치와 데이터를 교환하고 싶다면, 해당 센서와 동일한 위치에 존재할 수도 있고 그렇지 않을 수도 있는 다른 장치와 데이터를 교환하고 싶다면, 다시 말하면 — 클라우드가 해답입니다! 세계 한쪽에 센서를 설치하고 세계 다른 지역에 설치된 장치와 손쉽게 통신할 수 있습니다. 이것이 \"사물 인터넷\"의 세계입니다.\n\n클라우드 서비스 사용의 추세는 제품 개발 방식의 변화로 이어졌습니다. 몇 년 전에 사물 인터넷을 기반으로 한 제품에 착수했을 때, 우리는 모든 서비스를 처음부터 개발해야 했습니다. 인증, 권한 부여, 보안 등의 서비스를 만들어야 했습니다. 그러나 이제는 클라우드 서비스를 사용하면 모든 서비스를 개발할 필요가 없습니다. 대부분은 클라우드 상에서 구성하고 응용 프로그램과 통합하는 것뿐입니다.\n\n이 블로그에서는 AWS IoT Core에 대해 모두 가르쳐드립니다. 이 서비스를 사용하면 IoT 인프라를 빠르게 설정할 수 있습니다. AWS IoT Core를 사용하면 IoT 인프라와 관련된 거의 모든 것을 걱정할 필요가 없습니다. 백엔드이든 인증, 보안 등의 프로세스든, AWS IoT Core에서 제공하는 기능을 자세히 살펴볼 것입니다. 이 블로그의 개요는 다음과 같습니다:\n\n- 사물 인터넷 인프라\n- 사물 인터넷 인프라와 관련된 문제\n- AWS IoT Core\n- AWS IoT Core 기능 탐색\n- 장치 모니터링 — 사용자 친화적 대시보드\n- 워드파드 사용하여 IoT 노드 프로비저닝 — 쉬운 방법\n- 다중 노드 프로비저닝 — 대량 등록\n- 단일 노드 프로비저닝의 대체 방법 — 모든 단계 구성\n- 정책 문서 — 장치 권한 부여\n- 장치 쉐도우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 사물 인터넷 인프라\n\n사물 인터넷에서 가장 일반적으로 사용되는 아키텍처는 다른 기기나 노드 간에 데이터를 교환하기 위한 발행-구독 또는 Pub-Sub 모델입니다. Pub-Sub 모델에서 데이터를 생성하거나 발생시키는 모든 기기는 게시자(Publishers)라고 합니다. 온도 센서, 움직임 센서 등과 같은 센서 노드일 수 있습니다. 이러한 기기는 HumiditySensor\\Sensor1과 같은 다양한 주제에 데이터를 발행합니다. 반면에, 발행된 데이터를 원하는 기기나 노드는 구독자(Subscribers)라고합니다. 이들은 어떤 주제에든 구독하고 해당 노드로부터 데이터를 검색할 수 있습니다. 이를 가능하게 하기 위해서 우리는 Pub-Sub 모델의 핵심인 MQTT 브로커를 사용합니다.\n\n모든 노드가 MQTT 브로커에 데이터를 발행하고, 해당 주제에 구독한 다른 노드에게 데이터를 전송한다는 점을 명심해 주세요. 특정 주제에 구독한 모든 노드는 브로커에 알려주어야 합니다. 노드가 한번 구독하면 해당 주제에 발행된 데이터를 수신하기 시작합니다. MQTT 브로커가 다운되면 통신이 중단되어 노드는 데이터를 교환할 수 없게 됩니다.\n\n![](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMQTT 브로커는 컴퓨터에 설치할 수 있는 애플리케이션입니다. 장치들은 MQTT 프로토콜을 사용하여 MQTT 브로커에 연결할 수 있습니다. \"Mosquito MQTT 브로커\"는 매우 일반적으로 사용되는 서비스로, 여러분의 컴퓨터에 설치할 수 있습니다. 설치하고 한 번 시도해보고 싶다면 이 링크를 따를 수 있습니다. 서버와 통신하기 위해 여러 라이브러리가 사용 가능하며(MQTT 프로토콜을 구현하는 여러 프로그래밍 언어에 따라), 예를 들어, Python을 좋아한다면 \"paho-mqtt\"를 설치하고 브로커와 통신을 시작할 수 있습니다. 아래는 MQTT 브로커에 연결하고 그런 다른 노드에서 데이터를 수신하기 시작할 Python 코드의 예시입니다. \n\n```js\nimport paho.mqtt.client as mqtt\n\n# 이 함수는 이 기기나 노드가 MQTT 브로커와 성공적으로 연결되었을 때 호출됩니다.\ndef on_connect(client, userdata, flags, rc):\n    print(\"Connected with result code \"+str(rc))\n    # 다른 노드가 데이터를 게시할 토픽을 구독합니다.\n    client.subscribe(\"HumiditySensor\\Sensor1\")\n\n# 이 함수는 이 기기가 구독한 토픽에 데이터가 게시될 때 호출됩니다.\ndef on_message(client, userdata, msg):\n    print(msg.topic+\" \"+str(msg.payload))\n# MQTT 클라이언트 구성\nclient = mqtt.Client()\nclient.on_connect = on_connect\nclient.on_message = on_message\n# MQTT 브로커를 로컬 머신의 192.168.0.13에 구성했다고 가정\n# 1883 --\u003e MQTT 포트\n# 60   --\u003e 타임아웃 인터벌\nclient.connect(\"192.168.0.13\", 1883, 60)\n# 서버가 계속 실행되도록 유지\nclient.loop_forever()\n```\n\n# IoT 인프라의 관련 문제\n\n위에서 설명한 대로 MQTT 브로커를 사용하여 수백만 달러 짜리 IoT 아이디어를 구현하려는 것에 너무 마음이 고요해지기 전에 고려해야 할 사항이 여러 가지 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 모든 노드는 통신하기 위해 MQTT 브로커에 액세스해야 합니다. 브로커가 설치된 기계는 공개되어 있고 보안이 강화되어 있어야 합니다. 일반적으로, 우리는 이를 위해 AWS EC2 인스턴스와 같은 가상 머신을 사용합니다.\n- 가상 서버를 사용할 때에도 서버 보안은 중요합니다. 서버가 공개되어 있다면 아무나 연결하여 남용할 수 있어 매달 큰 클라우드 요금이 발생할 수 있습니다.\n- 서버 보안 이외에도, IoT 노드의 보안은 어떻게 보장하시나요? 기기가 정품이고 인가된 것임을 어떻게 확인하시겠습니까? MQTT 브로커는 비밀번호 인증을 지원합니다. 그러나 노드에 암호를 하드 코딩하는 것은 좋은 해결책이 아닙니다. 누군가가 MQTT 서버 비밀번호에 액세스하면 시스템 전체가 위험에 처할 수 있습니다.\n- 시스템의 확장성은 어떻게 되나요? 각 EC2 인스턴스나 가상 서버는 제한된 컴퓨팅 및 메모리 양을 가지고 있습니다. 수백만 대의 기기를 수용하기 위해 서버를 확장하려면 더 많은 서버를 추가해야 하며, 이로 인해 추가 비용이 발생할 수 있습니다.\n- 가상 서버가 다운되면 MQTT 브로커와 기기가 데이터 교환을 중지합니다. 서버는 지속적인 유지보수가 필요하며 팀은 항상 서버가 건강한지 확인해야 합니다.\n- IoT 기기 중 일부가 침해됐을 때는 어떻게 대응하시겠습니까? Mosquito MQTT 브로커는 기기를 블랙리스트에 올릴 수 있지만, 이를 위해 일부 파일을 수정해야 합니다. 이는 최상의 해결책이 아닙니다.\n- IoT 노드가 게시할 수 있는 주제를 제한하고 싶다면 어떻게 할까요? 예를 들어, 움직임 센서가 MotionSensor\\Sensor1에서만 데이터를 게시하길 원하고, 습도 센서가 HumiditySensor\\Sensor1에서만 게시하길 원한다고 가정해보죠. 또한 움직임 센서가 HumiditySensor\\Sensor1에서 데이터를 게시하지 못하도록 하고 싶습니다. — 기기가 많다면 이를 관리하기 어려울 수 있습니다.\n- 노드 정보를 모두 볼 수 있는 대시보드를 만들고 싶다면 어떻게 할까요? 예를 들어, 게시된 메시지 수, 연결 실패 횟수 등을 볼 수 있는 대시보드가 있다면 좋겠죠. 물론 모든 것을 직접 개발할 수 있지만, 그 개발에 들어갈 비용과 시간도 고려해야 합니다.\n- 노드 정보나 통계를 추적하고 싶다면 어떻게 할까요? 예를 들어, 게시된 메시지 수나 연결 실패 횟수를 추적하고 싶을 때 언제든 React/Angular 등의 기술로 나만의 대시보드를 개발할 수 있습니다. 그러나 이러한 개발에 필요한 비용과 시간을 염두에 두어야 합니다.\n- IoT 기기의 주요 요구 사항 중 하나는 원격으로 펌웨어 업데이트가 가능해야 한다는 것인데, 이를 \"오버 더 에어 (OTA)\" 펌웨어 업데이트라고 합니다. 이는 보안, 신뢰성 및 필요한 경우 업데이트 롤백 능력을 신중하게 고려해야 하는 어려운 작업일 수 있습니다.\n\n모든 문제에는 해결책이 있습니다. 팀원들과 함께 모여 상기된 모든 문제를 해결할 방법을 찾아보세요. 많은 시간과 노력이 필요할 것입니다. 그렇지만 AWS IoT Core가 모든 것을 처리해줄 수 있다면 어떻게 될까요? 아마도 AWS의 이 놀라운 서비스를 탐구해볼 예정입니다. 이 블로그의 파트-I에서는 노드 프로비저닝 및 노드 관리 방법을 살펴볼 것입니다.\n\n상기된 모든 문제에 해결책이 있습니다. 팀원들이 모여서 의심 없이 모든 문제를 해결할 방법을 고안할 수 있습니다. 그러나 이는 많은 노력과 비용이 필요할 것이며, 원하는 바가 아닐 수 있습니다 — 맞나요? 그래서 AWS IoT Core를 탐구할 것인데, 이는 AWS의 놀라운 서비스입니다.\n\n# AWS IoT Core\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAWS IoT Core의 랜딩 페이지에 따르면 \"AWS IoT Core를 사용하면 인프라를 관리하지 않고 수조 개의 IoT 장치를 연결하고 수십억 개의 메시지를 AWS 서비스로 라우팅할 수 있습니다.\" 이 개념은 \"서버리스(Serverless)\"라고도 합니다.\n\nAWS IoT Core는 당신에게 IoT 네트워크 전반에 걸쳐 복잡한 기능을 신속하게 구현할 수 있는 기능을 제공합니다.\n\n## AWS IoT Core 기능 탐색\n\nAWS IoT에 액세스하려면 AWS 계정에 로그인해야 합니다. AWS를 처음 사용하는 경우 무료로 새 계정을 등록할 수 있습니다. 그러나 등록에는 신용카드가 필요합니다. 등록하면 대부분의 서비스에 무료로 액세스할 수 있는 12개월 무료 티어 계정을 받게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신의 계정에 로그인 한 후, 검색 창에서 \"IoT Core\"를 검색할 수 있어요. 그런 다음 \"IoT Core\"를 클릭하세요.\n\n![AWS IoT Core 이미지](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_2.png)\n\n이렇게 하면 여기에 표시된대로 AWS IoT Core 콘솔 화면으로 이동하게 됩니다. 좌측 네비게이션 바에서 다양한 옵션이 기능에 따라 그룹화되어 있어요.\n\n![AWS IoT Core 이미지](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAWS IoT Core은 본질적으로 추가 기능을 갖춘 MQTT 브로커입니다. 이전에 MQTT 브로커를 다뤘던 것처럼 AWS IoT Core는 저지연과 고처리량을 제공하는 관리형 MQTT 브로커를 제공합니다. 이 브로커의 설치, 유지 보수 또는 보안을 관리할 필요가 없습니다. 장치가 인가되면 안전하게 메시지를 송수신할 수 있습니다. IoT 네트워크의 확장성을 걱정할 필요가 없습니다. AWS에 의해 자동으로 관리되기 때문에 기본 리소스의 용량을 늘릴 필요 없이 IoT 장치의 수를 늘릴 수 있습니다. AWS IoT Core에서 제공하는 다양한 기능에 대한 개요는 다음과 같습니다:\n\n- Connect: 몇 번의 클릭으로 단일 또는 여러 장치를 프로비저닝/구성하는 데 도움이 되는 위저드를 제공합니다.\n- Manage: 여러 가지 옵션을 제공하여 장치를 관리하고, 새로운 장치를 생성하며, 노드 그룹을 만들어 노드 청구를 관리하고, IoT 장치에서 실행할 작업을 생성할 수 있습니다.\n- Fleet Hub: 노드 또는 그룹을 선택하여 모든 통계를 볼 수 있는 플릿 허브 애플리케이션을 생성할 수 있습니다. 대시보드를 볼 수 있는 외부 사용자 계정을 생성할 수 있습니다.\n- Greengrass: 이 서비스를 사용하면 IoT 노드가 엣지 장치로 변할 수 있습니다. 클라우드에서 다른 작업이나 기능을 생성한 다음 엣지 노드에서 실행할 수 있습니다. 분산 컴퓨팅을 찾고 있다면 Greengrass가 완벽한 해결책이 될 것입니다.\n- 무선 연결: LoRaWAN 기술을 사용하는 경우 이 기능이 적합합니다. 이를 사용하면 LoRaWAN을 AWS 클라우드와 연결하여 관리할 수 있습니다. AWS에서 선택한 지역에 따라 이 기능이 표시되지 않을 수 있습니다.\n- 보안: 인증서, 정책, 권한 등과 같이 다양한 옵션을 제공합니다. 이러한 기능은 IoT 노드가 클라우드와 인증되고, 발행할 수 있는 토픽 및 구독할 수 있는 토픽과 같은 권한을 제공하며, AWS 람다 함수를 사용하여 사용자 정의 인증을 생성할 수 있습니다.\n\n- Defend: 인프라 및 구성의 보안을 감사하고, 클라우드에서 장치 활동을 모니터링하고, 사용자 정의 규칙에 따라 이상을 감지하는 옵션을 제공합니다. 이상 감지에 머신 러닝 모델을 사용할 수도 있습니다.\n- Act: 클라우드에서 다양한 규칙을 구성하고 클라우드에서 다양한 기능을 실행할 수 있습니다. 예를 들어, `HumiditySensor\\Sensor1`에 디바이스가 발행할 때마다 데이터베이스에 레코드를 삽입하거나 람다 함수를 실행하거나 REST API를 호출하는 규칙을 쉽게 구성할 수 있습니다. 룰을 작성하기 위해 SQL 기반의 구문을 사용합니다. 예를 들어, 다음 규칙을 고려해 보세요: `topic/subtopic`에 있는 색상과 온도에 대해 `50보다 큼`의 값을 갖는 경우 규칙은 일치합니다. 이 경우 AWS CloudWatch에 로그를 기록하는 AWS Lambda 함수(임의의 사용자 정의 백엔드 기능을 구현할 수 있음)를 호출합니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 테스트: 이 카테고리의 기능들은 미리 제공된 또는 사용자 정의 테스트 스위트로 IoT 노드를 테스트할 수 있습니다. 또한 원하는 페이로드를 어떤 주제로든 게시할 수 있는 인터페이스를 제공합니다. 구독을 직접 설정할 수도 있습니다. 이는 테스트용으로만 사용됩니다.\n\n![AWS IoT Core](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_5.png)\n\n## 기기 모니터링 — 사용자 친화적 기본 대시보드\n\nAWS IoT Core는 매우 사용자 친화적인 대시보드를 제공하여 기본적인 IoT 메트릭을 제공합니다. 좌측 탐색 막대에서 \"모니터\"를 클릭하여 성공적인 연결, 실행된 규칙 등과 같은 통계를 제공하여 IoT 네트워크의 문제를 식별하는 데 도움이 되는 다양한 메트릭을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![AWS IoT Core](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_6.png)\n\n## 마법사를 사용한 기기 프로비저닝\n\n첫 번째 노드를 설정하는 것부터 시작해보겠습니다. 이러한 마법사들은 사용자로부터 노드를 프로비저닝하기 위해 필요한 모든 추가 옵션을 숨깁니다. 단일 기기 또는 여러 기기를 동시에 프로비저닝할 수 있습니다. \"연결\"을 네비게이션 바에서 확장하고 \"시작하기\"를 클릭하면 두 가지 옵션이 제공됩니다.\n\n- 디바이스에 등록 — 노드를 하나씩 설정하려면 이 옵션을 선택하십시오. 단일 기기를 프로비저닝하려면 하단의 \"시작하기\" 버튼을 클릭할 수 있습니다.\n- 여러 기기에 등록 — 한 번에 여러 노드를 설정하려면 \"템플릿\"을 생성하여 노드가 어떻게 프로비저닝될지에 대한 모든 세부 정보를 제공할 수 있습니다. \"템플릿 생성\"을 클릭하여 프로세스를 시작할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_7.png]\n\n한 기기를 등록해 보겠습니다. \"기기 등록\" 아래의 \"시작\" 버튼을 클릭하세요. 지침 화면이 표시됩니다. 원한다면 읽어보세요. 화면 우측 하단의 \"시작\" 버튼을 클릭하여 계속 진행하세요.\n\n![2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_8.png]\n\n다음 화면에서 플랫폼과 SDK를 선택할 수 있습니다. 이러한 옵션들은 필요한 라이브러리를 구성하고 설치하는 데 도움이 되도록 스크립트를 생성합니다. 마이크로 컨트롤러를 사용 중이라면 필요한 조합을 선택하고 \"다음\"을 클릭하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_9.png](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_9.png)\n\n다음 화면에서는 노드를 식별하기 위한 다양한 구성을 제공합니다. 가장 중요한 것은 기기의 이름입니다. 현재는 \"MyFirstThingName\"이라고 부르도록 합시다.\n\n![2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_10.png](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_10.png)\n\n기본적으로 일부 선택적 구성은 숨겨져 있습니다. 이를 확장하려면 \"선택적 구성 보기\"를 클릭하면 됩니다. 이러한 옵션은 이 프로세스를 완료한 후에도 수정할 수 있습니다. 따라서 지금은 안심하고 무시해도 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_11.png\" /\u003e\n\n- 장치 유형: 비슷한 장치를 그룹화하려면 유형을 만들 수 있습니다. 예를 들어 “모션 센서”라는 그룹을 만들어 해당 유형에 해당하는 모션 센서를 모두 배치할 수 있습니다.\n- 검색 가능한 장치 속성: 이는 장치 정보, 공장 데이터 등을 저장하는 데 사용할 수 있는 키-값 쌍입니다. 라이트 불(전구)의 예를 들어보면, \"제조사\", \"와트수\", \"카테고리\" 등과 같은 다양한 속성 또는 속성 키가 있을 수 있습니다. 이 정보는 구현 중에 비즈니스 로직을 작성하는 동안 언제든지 검색할 수 있습니다.\n- 장치 그림자: 이는 다른 노드에서 조회할 수 있는 정보를 저장하기 위해 장치에 연결된 작은 데이터베이스입니다. 이 섹션인 \"장치 그림자\"에서 이 주제에 대해 자세히 알아보려면 이동하세요.\n\n“다음 단계”를 클릭하세요. 잠시 후, 장치가 성공적으로 프로비저닝되었다는 화면이 표시됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_12.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n화면에서 확인하실 수 있듯이, 자동으로 \"MyFirstThingName-Policy\"라는 정책 문서가 생성되었습니다.이 문서는 노드가 MQTT 브로커에 연결하고 허용된 주제에 발행/구독할 수 있는 권한을 제공합니다. 정책 문서에 대해 더 알고 싶다면, 이 블로그의 \"정책 문서 — 장치 인가\" 섹션으로 이동해 보세요.\n\n또한 인증 및 안전한 통신에 필요한 인증서, 공개 및 개인 키를 생성했습니다. 선택한 OS에서 실행할 수 있는 스크립트 파일도 제공됩니다. 이 스크립트 파일은 AWS IoT Core와 통신하기 위해 필요한 종속성을 설치하는 데 사용할 수 있습니다. 연결 키트를 컴퓨터로 다운로드하세요. 이 ZIP 파일은 어느 폴더에든 추출할 수 있습니다. 내용은 다음과 같습니다:\n\n\u003cimg src=\"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_13.png\" /\u003e\n\n네 개의 파일이 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- MyFirstThingName.cert.pem — 인증용 클라이언트 인증서\n- MyFirstThingName.private.key — IoT Core와의 안전한 통신을 위한 개인 키\n- MyFirstThingName.public.key — IoT Core와의 안전한 통신을 위한 공개 키\n- start.ps1 — 이는 모든 필수 라이브러리를 설치하고 AWS IoT Core와 디바이스를 테스트할 수 있는 샘플 코드를 생성하는 파워셸 스크립트입니다. 핵심 라이브러리는 AWS IoT Core와 통신하는 데 필요한 모든 기능을 제공하는 aws-iot-device-sdk입니다. 스크립트 파일의 내용은 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_14.png)\n\n파일을 다운로드하면 \"다음 단계\" 버튼이 사용 가능해지며 이를 클릭하면 안내 화면으로 이동합니다. \"완료\"를 클릭하세요.\n\n축하합니다! 몇 번의 클릭만으로 첫 번째 IoT 디바이스를 성공적으로 프로비저닝했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_15.png) \n\n만약 자체 IoT 인프라를 구축한다면, 기기의 인증 및 보안이 꽤 어려울 수 있습니다. 보셨듯이, AWS IoT Core에서 기기 프로비저닝은 매우 쉽습니다. IoT 코어에 등록되거나 프로비저닝되지 않은 기기는 AWS IoT Core와 통신할 수 없습니다.\n\n## 여러 노드 프로비저닝 — 대량 등록\n\n수백 대 또는 수백만 대의 기기가 있다면, 각 기기를 개별적으로 프로비저닝하는 것은 고통스럽고 시간이 많이 소요될 수 있습니다. 주로 AWS IoT Core는 여러 기기를 프로비저닝하는 두 가지 방법을 제공합니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Just-in-time provisioning (JITP): JITP는 장치가 처음으로 AWS IoT에 연결될 때 장치를 프로비저닝하는 템플릿과 함께 이루어집니다. 많은 장치를 등록해야 하지만 대량 프로비저닝 목록으로 구성할 수 있는 정보가 없는 경우 이 옵션이 좋습니다. 이를 구성하려면 인증서, 인증서 서명 요청 및 AWS Lambda 함수에 대한 좋은 이해가 필요합니다. JITP에 대해 자세히 설명하는 곳이 있는데 이 블로그를 참고해보세요.\n- Bulk registration: 이 옵션을 사용하면 S3 버킷에 저장된 파일에서 단일 항목 프로비저닝 템플릿 값 목록을 지정할 수 있습니다. 이 접근 방식은 원하는 특성이 알려진 많은 장치들이 목록으로 구성될 때 잘 작동합니다.\n\n대량 등록 화면에 접근하려면 “Activity” → “Start registration”을 클릭하시면 됩니다.\n\n![이미지1](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_16.png)\n\n![이미지2](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_17.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 가지씩 모든 필드에 대해 이야기해봐요.\n\n- 매개변수 파일: 매개변수 파일은 노드의 모든 속성을 포함한 JSON 파일입니다. 예를 들어, 두 개의 장치를 프로비저닝할 매개변수 파일 예시가 있습니다. \"foo\"와 \"bar\"라는 두 장치를 프로비저닝하겠다는 내용이 담겨 있습니다. 사용되는 변수 두 가지는 \"일련번호\"와 \"인증서 ID\"입니다. 이 파일을 AWS S3 버킷에 업로드해야 합니다. AWS S3는 파일 저장 서비스입니다. S3에 파일을 업로드한 후 \"S3 검색\" 버튼을 클릭하여 JSON 파일을 선택할 수 있습니다. JSON 파일의 내용은 다음과 같습니다:\n\n```js\n{\"ThingName\": \"foo\", \"SerialNumber\": \"123\", \"CertificateId\": \"1805e1f631a11fa4097d9307ec103d343111902ef29ba3e3fa00e63d570fa47a\"}\n{\"ThingName\": \"bar\", \"SerialNumber\": \"456\", \"CertificateId\": \"294cd70210ab6a1000069882d1f8ba33b8075825176569770031b5b9c329b283\"}\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_18.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- IAM Role: 이 옵션은 AWS의 작동 방식에 특화되어 있습니다. IAM 콘솔에 이동하여 새 역할을 생성하고 AWSIoTThingRegistration 및 AmazonS3FullAccess 정책을 연결할 수 있습니다. 역할의 이름을 자유롭게 지정할 수 있습니다. 이 예시에서는 역할 이름을 \"TestRole\"로 사용합니다. IAM 콘솔에서 TestRole의 세부 정보는 다음과 같습니다:\n\n![TestRole](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_19.png)\n\n이제 모든 준비가 완료되었으니, AWS IoT Core에 JSON 템플릿을 사용하여 새 장치를 프로비저닝하는 방법을 알려주어야 합니다. \"Ref\" 키워드는 프로비저닝 템플릿에서 값들을 참조하는 데 사용됩니다. 이 템플릿은 AWS가 노드를 프로비저닝하고 인증에 사용되는 인증서 및 권한 부여에 사용되는 정책을 자동으로 연결하는 데 사용됩니다. 이 예시에서 사용할 프로비저닝 템플릿은 다음과 같습니다:\n\n```javascript\n{\n    \"Parameters\" : {\n        \"ThingName\" : {\n            \"Type\" : \"String\"\n        },\n        \"SerialNumber\" : {\n            \"Type\" : \"String\"\n        },\n        \"Location\" : {\n            \"Type\" : \"String\",\n            \"Default\" : \"LA\"\n        },\n        \"CertificateId\" : {\n            \"Type\" : \"String\"    \n        }\n    },\n    \"Resources\" : {\n        \"thing\" : {\n            \"Type\" : \"AWS::IoT::Thing\",\n            \"Properties\" : {\n                \"ThingName\" : {\"Ref\" : \"ThingName\"},\n                \"AttributePayload\" : { \"version\" : \"v1\", \"serialNumber\" :  {\"Ref\" : \"SerialNumber\"}\n            },\n            \"OverrideSettings\" : {\n                \"AttributePayload\" : \"MERGE\",\n                \"ThingTypeName\" : \"REPLACE\",\n                \"ThingGroups\" : \"DO_NOTHING\"\n            }\n        },  \n        \"certificate\" : {\n            \"Type\" : \"AWS::IoT::Certificate\",\n            \"Properties\" : {\n                \"CertificateId\": {\"Ref\" : \"CertificateId\"}\n            }\n        },\n        \"policy\" : {\n            \"Type\" : \"AWS::IoT::Policy\",\n            \"Properties\" : {\n                \"PolicyDocument\" : \"{ \\\"Version\\\": \\\"2012-10-17\\\", \\\"Statement\\\": [{ \\\"Effect\\\": \\\"Allow\\\", \\\"Action\\\":[\\\"iot:Publish\\\"], \\\"Resource\\\": [\\\"arn:aws:iot:\u003cYourRegion\u003e:\u003cAccountID\u003e:topic/foo/bar\\\"] }] }\"\n            }\n        }\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 화면처럼 최종 구성이 보입니다. 작업을 완료하면 \"등록 시작\"을 클릭하세요.\n\n![이미지](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_20.png)\n\n모든 정보를 올바르게 입력했다면 프로비저닝 프로세스가 시작될 것입니다. 노드 수에 따라 시간이 소요될 수 있습니다. 우리는 두 개의 노드만 프로비저닝하고 있으므로 거의 즉시 완료될 것입니다. 언제든지 \"활동\" 페이지로 돌아가서 대량 등록 상태를 확인할 수 있습니다. 오류가 있는 경우 TaskID를 선택하고 작업 → 실패 로그를 클릭하세요. 이를 통해 오류 이유가 포함된 텍스트 파일이 다운로드됩니다. 최신 TaskID에는 노드 프로비저닝 원하는 수와 동일한 두 개의 성공 카운트가 포함되어 있기 때문에 성공한 것을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_21.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n확인하려면 \"foo\"와 \"bar\"가 성공적으로 생성되었는지를 확인할 수 있습니다. Manage → Things로 이동해주세요.\n\n\u003cimg src=\"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_22.png\" /\u003e\n\n프로비저닝 템플릿의 세부 정보를 확인하려면 https://docs.aws.amazon.com/iot/latest/developerguide/provision-template.html을 참조해주세요.\n\n## 노드 프로비저닝을 위한 대체 방법 — 모든 단계를 구성하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정한 요구 사항이 있고 각 항목을 수동으로 구성하려면 '관리 → 사물'로 이동한 후 '사물 만들기' 버튼을 클릭해야 합니다. 이전에 따라한 과정과 유사하지만 더 많고 유연한 구성 옵션을 제공합니다. 이는 더 고급 사용자를 위한 것입니다.\n\n![이미지](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_23.png)\n\n다음 화면에서는 단일 항목 또는 여러 항목을 생성할 수 있는 두 가지 옵션이 제공됩니다. '다수의 사물 만들기'를 선택하면 이미 살펴본 '대량 등록' 옵션으로 이동하게 됩니다.\n\n![이미지](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_24.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"하나의 항목 생성\"으로 진행해보겠습니다. 새 장치의 이름을 입력해주세요. \"MySecondDevice\"라고 부르겠습니다. 나머지 옵션은 기본값으로 남겨두세요.\n\n\u003cimg src=\"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_25.png\" /\u003e\n\n장치 섀도우를 확인할 수 있는 부분까지 스크롤 다운해주세요. 단순히 기능을 살펴보기 때문에 지금은 \"섀도우 없음\"으로 남겨둘게요. 나중에 장치에 섀도우를 연결할 수 있어요. \"다음\"을 클릭해서 계속 진행해주세요.\n\n\u003cimg src=\"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_26.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 화면에서는 인증서를 구성해야 합니다. 여기서는 AWS가 인증서를 생성하거나 사용자 지정 인증서를 사용하거나 별도의 인증서 기관을 등록하고 인증서를 생성할 수 있는 옵션이 있습니다. 이 과정이 비용이 많이든다고 하니 AWS가 새로운 인증서를 자동으로 생성하게 두는 것이 좋습니다. 나중에 인증서를 생성하고 Thing에 연결할 수 있습니다. 계속하려면 \"다음\"을 클릭하세요.\n\n![AWS IoT Core](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_27.png)\n\n다음 화면에서는 장치에 정책을 연결해야 합니다. 새로운 정책을 생성하려면 \"정책 생성\" 버튼을 누르세요. 이전에 마법사가 자동으로 정책 문서를 생성했었는데, 우리는 이 새로운 장치에 동일한 정책을 사용할 것입니다. \"MyFirstThingName-Policy\"를 선택하려면 왼쪽에 있는 확인란을 클릭하고 \"Thing 생성\"을 클릭하세요.\n\n![AWS IoT Core](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_28.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 팝업이 나타납니다. 제공된 모든 인증서를 컴퓨터의 안전한 위치에 다운로드해야 합니다.\n\n중요: 공개 및 개인 키는 이 화면에서만 다운로드할 수 있습니다. 이러한 키 중 하나를 분실한 경우, 새로운 장치를 처음부터 설정해야 합니다.\n\n![이미지](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_29.png)\n\n모든 인증서와 키를 다운로드한 후 “완료” 버튼을 누르세요. 이제 새로운 장치를 수동으로 성공적으로 생성했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 따라오셨다면, 지금 화면에 4개의 장치가 보일 것입니다.\n\n![Device Authorization](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_30.png)\n\n# 정책 문서 — 장치 승인\n\nAWS IoT Core에서 장치를 프로비저닝 할 때, 프로비저닝되는 모든 Thing 또는 노드에 \"정책\" 문서를 첨부합니다. 정책 문서는 단순히 해당 장치에 연결하는 JSON 구조의 파일로, 해당 장치가 다음 작업을 수행하도록 승인합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- AWS IoT Core 브로커에 연결합니다 (iot:Connect 동작) — 필요에 따라 클라이언트ID 형식 등 다양한 조건을 추가할 수 있습니다.\n- 특정 노드가 MQTT 브로커에서 주어진 주제에서 발행/구독/수신할 수 있게 합니다. 동일한 노드가 발행할 수 없는 주제에 구독하는 동안 다른 주제에 발행할 수 있습니다.\n- AWS는 '$'iot:Connection.Thing.ThingName'과 같은 일부 IoT 변수를 제공하여 정책 문서에 추가하여 노드가 다른 노드에 발행하는 것을 제한할 수 있습니다.\n\n다음은 정책의 예시입니다. 이 예시 정책에서 노드는 $'iot:Connection.Thing.ThingName'/room*에서 데이터를 발행, 구독 및 수신할 수 있습니다.\n\n```js\n{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"iot:Connect\"\n            ],\n            \"Resource\": [\n                \"arn:aws:iot:us-east-1:123456789012:client/${iot:Connection.Thing.ThingName}\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"iot:Subscribe\"\n            ],\n            \"Resource\": [\n                \"arn:aws:iot:us-east-1:123456789012:topicfilter/${iot:Connection.Thing.ThingName}/room*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"iot:Receive\"\n            ],\n            \"Resource\": [\n                \"arn:aws:iot:us-east-1:123456789012:topic/${iot:Connection.Thing.ThingName}/room*\"\n            ]\n        },\n        {\n            \"Effect\": \"Allow\",\n            \"Action\": [\n                \"iot:Publish\"\n            ],\n            \"Resource\": [\n                \"arn:aws:iot:us-east-1:123456789012:topic/${iot:Connection.Thing.ThingName}/room*\"\n            ]\n        }\n    ]\n}\n```\n\n이미 생성된 정책을 확인하려면 Secure → Policies로 이동하세요. 따라왔다면, \"MyFirstThingName-Policy\"는 위자드를 사용하여 단일 장치를 프로비저닝할 때 생성된 정책입니다. 두 번째 정책은 대량 등록 프로세스를 통해 생성된 정책입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지 태그를 다음과 같이 변경해주세요.\n\n\n![AWS IoT Core](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_31.png)\n\n\n\"MyFirstThingName-Policy\"를 클릭하세요. 다음 화면에서 \"JSON\" 토글 버튼을 클릭하여 정책 문서를 JSON 형식으로 볼 수 있습니다. 여기에서 정책을 수정하고 새 버전의 정책 문서를 게시할 수 있습니다. 이를 통해 이전 버전으로 되돌아가는 것이 가능합니다.\n\n![AWS IoT Core](/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_32.png)\n\n\"MyFirstThingName-Policy\"의 정책 문서를 수정하지 않았다면 다음과 같이 나타날 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"iot:Publish\",\n        \"iot:Receive\",\n        \"iot:RetainPublish\"\n      ],\n      \"Resource\": [\n        \"arn:aws:iot:us-east-2:906961234567:topic/sdk/test/java\",\n        \"arn:aws:iot:us-east-2:906961234567:topic/sdk/test/Python\",\n        \"arn:aws:iot:us-east-2:906961234567:topic/topic_1\",\n        \"arn:aws:iot:us-east-2:906961234567:topic/topic_2\"\n      ]\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"iot:Subscribe\"\n      ],\n      \"Resource\": [\n        \"arn:aws:iot:us-east-2:906961234567:topicfilter/sdk/test/java\",\n        \"arn:aws:iot:us-east-2:906961234567:topicfilter/sdk/test/Python\",\n        \"arn:aws:iot:us-east-2:906961234567:topicfilter/topic_1\",\n        \"arn:aws:iot:us-east-2:906961234567:topicfilter/topic_2\"\n      ]\n    },\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": [\n        \"iot:Connect\"\n      ],\n      \"Resource\": [\n        \"arn:aws:iot:us-east-2:906961234567:client/sdk-java\",\n        \"arn:aws:iot:us-east-2:906961234567:client/basicPubSub\",\n        \"arn:aws:iot:us-east-2:906961234567:client/sdk-nodejs-*\"\n      ]\n    }\n  ]\n}\n```\n\n위 정책의 요약은 다음과 같습니다:\n\n- AWS IoT Core에 연결하기 위해서는 디바이스의 clientID는 sdk-java, basicPubSub 또는 sdk-nodejs-* 여야 합니다. 여기서 *는 와일드카드 문자로, sdk-nodejs- 뒤에 문자 조합이 허용된다는 것을 의미합니다.\n- 디바이스는 지정된 주제(topic)만 구독할 수 있습니다. 즉, sdk/test/java, sdk/test/Python, topic_1 및 topic_2 주제만 가능합니다.\n- 디바이스는 지정된 주제만 발행할 수 있습니다. 즉, sdk/test/java, sdk/test/Python, topic_1 및 topic_2 주제만 가능합니다.\n\nAWS IoT Core 정책을 사용하면 각 노드에 대해 별도의 정책을 생성하거나 응용 프로그램의 필요에 따라 여러 노드에 동일한 정책을 공유할 수 있습니다. 이 기능은 매우 유용하며 콘솔을 사용하여 이러한 정책을 쉽게 관리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 장치 그림자\n\nAWS IoT Core의 매우 유용한 기능 중 하나는 장치 그림자입니다. 그림자는 각각의 독립된 노드에 특화된 데이터베이스입니다. 이는 장치의 최신 (보고된) 상태를 저장하는 데 사용될 수 있으며 필요할 때 인프라 내의 다른 장치에서 읽거나 액세스할 수 있습니다. 따라서 노드가 오프라인 상태가 되더라도 다른 노드는 여전히 해당 그림자에서 보고된 상태를 액세스할 수 있습니다. 그림자의 정보는 \"원하는\" 상태와 \"보고된\" 상태로 저장됩니다. 특정 노드의 상태를 변경하려는 장치가 있는 경우, 그 장치는 그림자에서 원하는 상태에 키-값 쌍을 추가하여 요청을 보냅니다. 그림자 문서가 변경되면 해당 IoT 노드는 그림자에서 원하는 정보를 읽어들여 정보를 처리하고 보고된 상태의 업데이트를 보냅니다. 데이터 요청을 초기에 한 장치는 보고된 상태가 업데이트되었음을 알립니다. 이 데이터는 수동으로 삭제되거나 어떤 프로세스에 의해 삭제될 때까지 계속 유지됩니다. 그림자에 데이터가 저장되는 일반적인 예시는 다음과 같습니다.\n\n```js\n{\n    \"state\": {\n        \"desired\": {\n            \"attribute1\": integer2,\n            \"attribute2\": \"string2\",\n            ...\n            \"attributeN\": boolean2\n        },\n        \"reported\": {\n            \"attribute1\": integer1,\n            \"attribute2\": \"string1\",\n            ...\n            \"attributeN\": boolean1\n        }\n    },\n    \"clientToken\": \"토큰\",\n    \"version\": 버전\n}\n```\n\n\"Thing\"에 그림자를 추가하려면, 관리 → Things로 이동하여 이미 프로비저닝한 장치 중에서 선택하십시오. \"장치 그림자\"를 클릭하십시오. 이 서비스 없이 \"MySecondDevice\"를 만든 경우 기존의 그림자를 찾을 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_33.png\" /\u003e\n\n\"Create Shadow\"을 클릭하면 새로운 것이 추가됩니다. 두 가지 옵션이 포함된 팝업이 표시됩니다:\n\n- 이름 지정된 Shadow: 여러 장치 쉐도우를 생성하고 다른 이름으로 식별할 수 있습니다. 노드의 기능에 따라 문서를 분류하려면 유용합니다.\n- 이름 지정되지 않은 (고전적인) Shadow: 이것은 고전적인 쉐도우라고도 불립니다. 장치당 하나의 이름이 지정되지 않은 쉐도우만 생성할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_34.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"Unnamed (classic) Shadow\"을 선택하고 \"만들기\"를 클릭하세요.\n\n\u003cimg src=\"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_35.png\" /\u003e\n\n또한 MQTT 주제 $aws/things/MySecondDevice/shadow가 생성되었습니다. 이 주제를 통해 장치가 \"MySecondDevice\" 노드의 이 그림자 서비스와 통신할 수 있습니다. 즉, 정책문에 의해 허용된 디바이스는 이 그림자에 발행하거나 구독할 수 있습니다. 그림자 서비스에 대해 더 알고 싶다면, 아래 링크를 참조하여 API 및 자세한 내용을 확인하세요. https://docs.aws.amazon.com/iot/latest/developerguide/iot-device-shadows.html\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAWS IoT 코어는 제품을 위한 IoT 인프라를 신속하게 배포할 수 있도록 하는 여러 기능을 제공합니다. 인프라, 보안 및 관리에 대해 걱정할 필요 없이 제품의 핵심 비즈니스 로직에 집중하세요. 이 블로그에서는 노드 프로비저닝, 대량 등록, 정책 구성, 그림자 등과 같은 중요한 기능을 논의했습니다.\n\nAWS IoT Core의 요금 페이지에 따르면, 유럽(아일랜드) 지역에서 매일 AWS IoT Core에 지속적으로 연결된 10만대의 기기가 있고 각 기기가 사이즠 1KB의 325개의 메시지를 보내는 경우 한 달에 대략 $1,876.60의 비용이 발생합니다. 이는 매우 합리적인 가격입니다. 매일 보내는 325개의 메시지 중 100개는 장치 그림자 업데이트를 트리거하고 200개는 규칙을 실행하여 한 가지 작업을 실행합니다.\n\n이 블로그에 나열된 모든 혜택을 고려할 때, 기술 회사의 CEO 또는 CTO라면 다음 백만 달러 제품에 AWS IoT Core를 고려해야 합니다.\n\n## 저자와 연락하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n👋 만나서 반가워요! 저랑 소통하고 싶으시면 저의 LinkedIn 계정에서 연락해주세요: [https://www.linkedin.com/in/umerfarooqai/](https://www.linkedin.com/in/umerfarooqai/). 질문이 있으면 언제든지 물어봐주세요! 함께 소통해요! ✨","ogImage":{"url":"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_0.png"},"coverImage":"/assets/img/2024-06-22-AWSIoTCoreEverythingYouNeedToKnow_0.png","tag":["Tech"],"readingTime":25},{"title":"미래를 여는 열쇠 IoT와 홀로그램 기술의 최전선 이해하기","description":"","date":"2024-06-22 17:56","slug":"2024-06-22-UnlockingtheFutureUnderstandingIoTandItsHolographicFrontier","content":"\n\n\u003ctable\u003e 태그를 Markdown 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n의료 분야에서는 홀로그래픽 시뮬레이션이 정교한 수술을 가상 환경에서 연습할 수 있도록 함으로써 수술 기술과 의료 교육을 변화시킬 수 있습니다. 소매업에서 홀로그래픽 디스플레이를 활용하면 제품을 구매하기 전에 집 안에서 아이템을 볼 수 있어 쇼핑 경험을 향상시킬 수 있습니다. 홀로그래픽 IoT는 대화형 시뮬레이션과 가상 현장 여행을 제공함으로써 교육 혁신의 가능성을 제공할 수 있습니다.\n\nIoT와 홀로그래픽 기술이 함께 제공하는 매력적인 새로운 가능성이 있지만 단점도 있습니다. 기술적 도전, 개인정보 문제 및 윤리적 문제를 해결하려면 어려움이 있습니다. 그러나 창의적 사고와 적절한 안전 대책으로 이러한 장애물을 극복할 수 있어 더 통합되고 지능적이며 몰입적인 미래로의 문을 열 수 있습니다.\n\n요약하면, IoT와 홀로그래픽 기술의 결합은 우리의 디지털 환경에서 통신과 참여를 재정의합니다. 우리는 변형되는 시너지를 받아들이면서 상상력이 유일한 한계인 미래로 나아가는 여정을 떠납니다. IoT와 홀로그래픽 기술의 힘을 활용하여 보다 연결된 사회를 만들며 생산성을 증가시키고 삶의 질을 향상시킬 수 있습니다.\n\n이 글은 알로카 페레라가 작성했습니다.","ogImage":{"url":"/assets/img/2024-06-22-UnlockingtheFutureUnderstandingIoTandItsHolographicFrontier_0.png"},"coverImage":"/assets/img/2024-06-22-UnlockingtheFutureUnderstandingIoTandItsHolographicFrontier_0.png","tag":["Tech"],"readingTime":1},{"title":"오픈 소스 맥박산소측정기, 직접 만들어보기","description":"","date":"2024-06-22 17:55","slug":"2024-06-22-OpenSourcePulseOximeter","content":"\n\n이 프로젝트에서 사용된 항목\n\n전체 장치는 44mm x 30mm 퍼프 보드에 부착된 Arduino Nano를 중심으로 설계되었습니다. 먼저, 센서의 VIN, GND, SDA 및 SCL 핀에 전선을 납땜한 다음, 그 전선은 침대 부품 아래를 따라 Arduino Nano로 연결됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, OLED에 대한 커넥터를 Nano에 연결한 다음 디스플레이에 연결합니다. 마지막으로, 전체 전자 어셈블리를 하우징에 밀어 넣고 몇 개의 3mm 나사로 고정합니다.\n\n![이미지](/assets/img/2024-06-22-OpenSourcePulseOximeter_2.png)\n\n전자기기가 삽입된 후에 OLED 화면을 상단 부분에 연결하고 나머지 샤시에 몇 개의 3mm 나사로 고정합니다. 뚜껑을 부드럽게 위아래로 움직여 움직임을 테스트할 수 있습니다.\n\n포함된 스케치는 사용자의 현재 심박수와 산소 포화도를 표시하기 위해 몇 가지 작업을 수행합니다. 업로드하려면 필요한 라이브러리를 설치하고 도구 메뉴에서 Arduino Nano를 보드 목록에서 선택한 다음 업로드를 클릭하면 됩니다. 스케치 자체는 OLED 및 MAX30102를 초기화하고 에러가 발생할 경우 보고합니다. 그런 다음 센서를 보정하기 위해 100개의 값을 읽고 이를 표시하기 시작합니다. 장치는 그런 다음 25개의 새 값들을 읽고 이들로 이동 평균을 계산하는 루프에 진입합니다. 마지막으로 값이 유효한지 확인하고 유효하다면 화면에 인쇄합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n펄스 옥시미터를 사용하려면 손가락 끝을 센서 위에 올려놓고 부드럽게 뚜껑을 닫으세요. 그런 다음 전원 공급원을 꽂고 데이터가 표시될 때까지 기다리기만 하면 됩니다.\n\n![이미지](/assets/img/2024-06-22-OpenSourcePulseOximeter_3.png)\n\n![이미지](/assets/img/2024-06-22-OpenSourcePulseOximeter_4.png)\n\n![이미지](/assets/img/2024-06-22-OpenSourcePulseOximeter_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 펄스 옥시미터 코드\n\nC/C++\n\n```js\n/*\n  하드웨어 연결 (Breakoutboard to Arduino):\n  -5V = 5V (3.3V 사용 가능)\n  -GND = GND\n  -SDA = A4 (또는 SDA)\n  -SCL = A5 (또는 SCL)\n  -INT = 연결하지 않음\n\n  MAX30105 브레이크아웃은 5V 또는 3.3V I2C 로직을 처리할 수 있습니다. 보드를 5V로 전원 공급하는 것을 권장하지만 3.3V에서도 작동합니다.\n*/\n\n#include \u003cWire.h\u003e\n#include \"MAX30105.h\"\n#include \"spo2_algorithm.h\"\n#include \"SSD1306Ascii.h\"\n#include \"SSD1306AsciiWire.h\"\n\nMAX30105 particleSensor;\nSSD1306AsciiWire oled;\n\n#define MAX_BRIGHTNESS 255\n\n#if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)\n// 아두이노 Uno에는 50개의 IR LED 데이터 및 빨간 LED 데이터를 32비트 형식으로 저장할 충분한 SRAM이 없습니다.\n// 이 문제를 해결하기 위해 샘플 데이터의 16비트 MSB가 잘립니다. 샘플이 16비트 데이터로 변환됩니다.\nuint16_t irBuffer[50]; // 적외선 LED 센서 데이터\nuint16_t redBuffer[50];  // 빨간색 LED 센서 데이터\n#else\nuint32_t irBuffer[50]; // 적외선 LED 센서 데이터\nuint32_t redBuffer[50];  // 빨간색 LED 센서 데이터\n#endif\n\nint32_t spo2; // SPO2 값\nint8_t validSPO2; // SPO2 계산이 유효한지를 나타내는 표시기\nint32_t heartRate; // 심박수 값\nint8_t validHeartRate; // 심박수 계산이 유효한지를 나타내는 표시기\n\nvoid setup()\n{\n  Serial.begin(115200); // 초당 115200비트로 시리얼 통신 초기화:\n\n  oled.begin(\u0026Adafruit128x64, 0x3C);\n  oled.setFont(Arial14);\n\n  // 센서 초기화\n  if (!particleSensor.begin(Wire, I2C_SPEED_FAST)) // 기본 I2C 포트, 400kHz 속도 사용\n  {\n    Serial.println(F(\"MAX30105를 찾을 수 없습니다. 배선/전원을 확인하세요.\"));\n    while (1);\n  }\n\n  particleSensor.setup(55, 4, 2, 200, 411, 4096); // 이러한 설정으로 센서 구성\n}\n\nvoid loop()\n{\n\n  // 처음 50개 샘플을 읽고 신호 범위를 결정합니다.\n  for (byte i = 0 ; i \u003c 50 ; i++)\n  {\n    while (particleSensor.available() == false) // 새 데이터가 있는지 확인\n      particleSensor.check(); // 새 데이터가 있는지 확인\n\n    redBuffer[i] = particleSensor.getRed();\n    irBuffer[i] = particleSensor.getIR();\n    particleSensor.nextSample(); // 이 샘플은 완료되었으므로 다음 샘플로 이동\n    Serial.print(F(\"빨강=\"));\n    Serial.print(redBuffer[i], DEC);\n    Serial.print(F(\", 적외선=\"));\n    Serial.println(irBuffer[i], DEC);\n  }\n\n  // 처음 50개 샘플(총 4초의 샘플) 후에 심박수 및 SpO2 계산\n  maxim_heart_rate_and_oxygen_saturation(irBuffer, 50, redBuffer, \u0026spo2, \u0026validSPO2, \u0026heartRate, \u0026validHeartRate);\n\n  // MAX30102에서 지속적으로 샘플을 채취합니다. 1초마다 심박수와 SpO2를 계산합니다.\n  while (1)\n  {\n    // 메모리에 처음 25개 세트의 샘플을 버리고 마지막 25개 세트의 샘플을 맨 위로 이동합니다.\n    for (byte i = 25; i \u003c 50; i++)\n    {\n      redBuffer[i - 25] = redBuffer[i];\n      irBuffer[i - 25] = irBuffer[i];\n    }\n\n    // 심박수를 계산하기 전에 25개 세트의 샘플을 채취합니다.\n    for (byte i = 25; i \u003c 50; i++)\n    {\n      while (particleSensor.available() == false) // 새 데이터가 있는지 확인\n        particleSensor.check(); // 새 데이터가 있는지 확인\n\n      redBuffer[i] = particleSensor.getRed();\n      irBuffer[i] = particleSensor.getIR();\n      particleSensor.nextSample(); // 이 샘플은 완료되었으므로 다음 샘플로 이동\n      Serial.print(F(\"빨강=\"));\n      Serial.print(redBuffer[i], DEC);\n      Serial.print(F(\", 적외선=\"));\n      Serial.print(irBuffer[i], DEC);\n\n      Serial.print(F(\", 심박수=\"));\n      Serial.print(heartRate, DEC);\n\n      Serial.print(F(\", 심박수유효=\"));\n      Serial.print(validHeartRate, DEC);\n\n      Serial.print(F(\", SPO2=\"));\n      Serial.print(spo2, DEC);\n\n      Serial.print(F(\", SPO2유효=\"));\n      Serial.println(validSPO2, DEC);\n      \n    }\n\n    // 25개의 새로운 샘플을 수집한 후 HR 및 SP02를 재계산합니다.\n    maxim_heart_rate_and_oxygen_saturation(irBuffer, 50, redBuffer, \u0026spo2, \u0026validSPO2, \u0026heartRate, \u0026validHeartRate);\n    printToScreen();\n  }\n}\n\nvoid printToScreen() {\n  oled.clear();\n  oled.setCursor(0,0);\n  if(validSPO2 \u0026\u0026 validHeartRate) {\n    oled.print(F(\"HR: \")); oled.println(heartRate, DEC);\n    oled.print(F(\"SPO2: \")); oled.println(spo2, DEC);\n  } else {\n    oled.print(F(\"유효하지 않습니다\"));\n  }\n}\n```","ogImage":{"url":"/assets/img/2024-06-22-OpenSourcePulseOximeter_0.png"},"coverImage":"/assets/img/2024-06-22-OpenSourcePulseOximeter_0.png","tag":["Tech"],"readingTime":5},{"title":"데이터 프로젝트에서 벽에 부딪혔다면 이제 어떻게 해야 할까요","description":"","date":"2024-06-22 17:53","slug":"2024-06-22-YouveHitaWallinYourDataProjectNowWhat","content":"\n\n![img](/assets/img/2024-06-22-YouveHitaWallinYourDataProjectNowWhat_0.png)\n\n우리 모두가 익숙한 시나리오를 경험했을 것입니다: SQL 쿼리를 개발하거나 데이터 파이프라인을 구축하거나 예측 모델을 작성 중이면서 최종 출력 데이터 집합이라고 생각되는 지점에서 코드를 실행하면 의도하지 않은 결과가 나오는 것이다. 레코드 수가 이상하게 반환된다거나, 필드가 올바르게 채워지지 않는다거나, 모델이 예상치 못한 결과를 생성할 수도 있습니다.\n\n어떤 문제가 발생했음을 알지만 코드에는 문제가 발생한 원인에 대한 오류 메시지나 명확한 표시가 없을 때 어떻게 문제 해결에 접근해야 할까요? \n\n지난 6년 이상의 다양한 분석 업무에서 얻은 경험으로 말씀드리면, 새로운 개발 문제를 해결하며 자주 벽에 부딪힐 것이라고 확신합니다. 그러나 이러한 장애물을 극복하고 더 강인한 전문가로 나아가기 위해 채택한 효과적인 전략이 있습니다. 다음 섹션에서는 내게 가장 성공적으로 입증된 몇 가지 기술을 공유하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## \"재부팅을 시도해 보셨나요?\"\n\n저는 컴퓨터를 껐다 켜는 것을 의미하는 게 아니라, 오히려 뇌를 재설정하는 것을 말하고 있어요. 다시 말해, 몇 분 동안 책상에서 멀어지는 걸 시도해 보세요.\n\n이게 얼마나 효과가 좋은지 믿을 수 없을 정도로 도움이 됐던 적이 많아요. 때로는 간단한 산책만으로도 문제에 대한 해결책이나 새로운 접근 방법이 스스로 떠오르곤 해요. 너무 오래 동안 같은 문제를 바라보고 있으면, 문제의 한 부분에만 집중하다가 더 큰 그림을 잊고 만다는 점이 쉽게 발생할 수 있어요.\n\n예를 들어, 파이썬 함수를 사용해서 데이터 포인트를 올바르게 출력하려는 문제를 겪고 있을 수도 있어요. 하지만 더 중요한 것은, 함수가 왜 필요한지, 어떤 종속성이 있는지, 그리고 함께 상호작용해야 하는 다른 데이터들이 무엇인지에 대한 초점을 잃었을 수 있다는 거죠. 때때로 이러한 방법이 문제를 해결하는 길로 다시 돌아가는 가장 좋은 방법일 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 가정을 다시 바라보기\n\n제 개인적인 경험으로 보면, 제 경력에서 부딪힌 대부분의 장애물은 데이터나 코드에 대해 잘못된 가정을 한 것에서 비롯되었습니다.\n\n어느 한 역할에서, 퇴사한 다른 데이터 분석가가 만든 대시보드 지표를 복제하는 업무를 맡았습니다. 이전 SQL과 해당 지표를 생성하는 데 사용된 Power BI 워크북에 접근할 수 있었습니다. 나는 비슷한 방식으로 비즈니스 로직을 복제했지만, 결과물을 출력했을 때 약 5% 정도 다르게 나타났습니다. 문법의 정확성, 필드 호출, 및 조인에서 의도하지 않은 데이터 필터링을 철저히 검토하기 위해 상당한 시간을 보냈지만, 이러한 접근 방식들 중 어느 것도 작동하지 않았습니다. 더 철저한 검토를 거친 후, 우리 둘 다 다른 원본 테이블에서 필드명이 customer_active로 필터링하는 것으로 밝혀졌으며, 이 두 필드는 백엔드에서 서로 다르게 계산되었습니다.\n\n위의 장애물의 근본 원인은 내가 호출한 필드에 대해 가정을 한 점이었습니다. 내가 생각했던 대로 데이터를 쿼리했지만, 잘못된 데이터에 대한 내 가정이 결국 우리 둘 간의 지표와의 5% 차이의 원인이었습니다. 되돌아보면, 차이가 발생하는 곳을 이해하기 위해 소스 테이블로 역추적하는 것이 더 나은 방법이었을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적으로 이 단계에 있을 때 다음을 고려해보세요:\n\n- 작업 중인 데이터의 기본 정보는 무엇인가요? 즉, 각 행이 나타내는 내용은 무엇인가요? 예를 들어 매일 스냅샷되는 고객 테이블과 작업 중이라면 — 테이블의 기본 정보는 고객과 날짜입니다. 의도한 테이블의 기본 정보가 실제로 출력되는 것인지 확인하세요.\n- 검토 중인 코드가 전체 그림을 나타내는가요? 데이터가 상류 어딘가에 잘못된 부분이 있는지 이해해야 할 필요가 있나요? 파이프라인 또는 데이터 수집 문제가 있을 수 있나요?\n- 비즈니스와 관련된 x 테이블의 문맥을 정확히 이해하고 있나요? 관련 데이터가 시스템과 프로세스 관점에서 어떻게 유래되는지 이해하는 것이 중요합니다. 명확하지 않다면 전문가와 협업하세요.\n\n## 코드의 개별 세그먼트를 분리하세요\n\nSQL 작업 시, 나의 즐겨찾는 방법은 코드 세그먼트를 공통 테이블 표현으로 분리하고 각각을 개별적으로 쿼리하는 것입니다. 이 형식은 처음에 DBT를 사용할 때 발견했고, 그들의 문서에서 더 많은 정보를 확인할 수 있습니다. 다음과 같은 예시를 살펴보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nWITH customer_acq AS (\n  SELECT\n  *\n  , CASE\n      WHEN first_order_date IS NOT NULL\n        THEN first_order_date\n      ELSE salesforce_date_created\n    END AS acquisition_date\n  FROM customers\n)\n\n, main AS (\n  SELECT\n  *\n  FROM customer_acq\n  WHERE acquisition_date \u003e= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)\n)\n\nSELECT * FROM main\n```\n\n마지막 줄에 있는 SELECT * FROM main 부분이 불필요해 보일 수 있지만, 이 구조를 통해 코드 세그먼트의 문제 해결을 쉽게 할 수 있음을 보증할 수 있어요. 여기서 마지막 줄에서 우리는 각 CTE의 출력을 쿼리하여 각각에서 무엇이 잘못되고 있는지 확인할 수 있어요. 이 기술은 특히 쿼리의 출력이 의도치 않게 0개의 레코드를 반환할 때 매우 효과적으로 증명되었어요. 여기서 \"main\"이라는 마지막 단어를 다른 CTE 이름으로 변경함으로써 모든 레코드를 필터링하는 원인 CTE를 결정할 수 있어요.\n\nCTE가 쿼리 최적화에 부담을 준다는 것은 일반적인 오해입니다. 실제로 (적어도 눈에 띄는 차이를 만들 만큼만이라도) 현대 클라우드 데이터 웨어하우스 공급업체와 함께 작업하는 경우 CTE가 쿼리 최적화에 미칠 영향은 상당하지 않아요.\n\n## 하나의 예시 레코드 격리하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기술을 사용하여 원본 시스템의 한 예제 레코드, 원본 데이터베이스 테이블 및 코드의 출력에서 하나의 예제 레코드를 살펴보고자 합니다. 이를 통해 A.) 원본 시스템에서 데이터베이스로 데이터가 이동하는 과정에 어떤 문제가 있는지와 B.) 적용한 로직이 이 한 레코드에 어떤 영향을 미치는지를 결정할 수 있습니다. 하나를 분리함으로써 우리는 개별 입력이 개발한 코드를 통해 어떻게 흐르는지 더 명확하게 이해할 수 있습니다. 이 단계에서 다음 사항을 평가할 수 있습니다:\n\n- 이 레코드가 의도한 대로 코드를 통해 흐르고 있는가?\n- 그렇지 않다면, 이 레코드가 제대로 작동하는 다른 레코드와 어떤 점이 다른가요?\n\n위에서 언급한 기술과 결합하여, 코드의 개별 부분에서 개별 레코드를 분리할 수도 있습니다. 예를 들어, 위에서 정의한 CTE를 사용하여 코드의 각 세그먼트를 통해 특정 레코드가 어떻게 출력되는지 확인해보세요. 여기에서는 코드 중 어떤 섹션이 레코드를 잘못 조작하고 있는지를 정확히 식별할 수 있어야 합니다.\n\n## 더 이상 추측하지 마세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제 명세서에 대해 포괄적인 시각을 가져야 합니다. 대시보드가 올바르게 채워지지 않는 상황에 처해 있을 때, 소규모 수정(필터 조건 변경 등)을 하고 대시보드를 새로고침하여 최선을 바라는 습관에 빠지기 쉬울 수 있습니다. 이것은 마치 주사위를 던지는 것과 다를바 없으며, 여러 계층의 문제를 효과적으로 해결하는 방법이 아닙니다.\n\n문제 명세서를 해체하고 다시 구성해보세요. 다음과 같은 질문을 스스로에게 던져보세요:\n\n- 어떤 비즈니스 질문에 답하려고 하는가요?\n- 이에 대한 답변을 위해 어떤 데이터가 사용 가능한가요? 각 관련 데이터 테이블이 무엇을 나타내는지 알아야 합니다. 최소 가치 제품을 제공하기 위해 필요한 데이터와 사용 가능한 데이터에 대한 명확한 가이드라인을 가져야 합니다.\n- 소스 데이터 위에 BI 레이어를 구축하기 위해 필요한 변확 필요한 변환은 무엇인가요?\n- 사용 중인 데이터 소스 또는 데이터 파이프라인의 미묘한 점은 무엇인가요?\n- 데이터 품질 — 널 값이 어디에 존재하나요? 데이터의 지연에 대한 우려사항은 없나요?\n\n이러한 질문에 대답할 수 없다면, 도움을 요청하거나 데이터에 대한 팀원 또는 전문가와 소통하는 것도 괜찮습니다. 데이터에 대한 친숙함은 가치 있는 해결책을 제공하는 데 중요하므로 필요하다면 비즈니스 컨텍스트를 더 잘 이해하기 위해 필요한 시간을 투자하는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n시니어리티 레벨에 관계없이, 발전하는 과정에서 어려움을 겪게 될 것입니다. 때때로 이미 알고 있는 지식을 잊고 문제에 새로운 시각으로 접근해야 합니다. 예상치 못한 결과나 어려움에 부딪힐 때는 체계적인 방법을 채택하고 차분한 마음가짐을 유지하는 것이 중요합니다.\n\n어떤 데이터 프로젝트에서도 어려움에 부딪히는 것은 실패의 징후가 아니라 성장의 기회입니다. 이러한 전략을 적용하고 프로젝트에 대해 종합적인 시각을 유지함으로써 문제 해결 능력을 향상시키고 더욱 신뢰할 수 있고 효율적인 결과를 이룰 수 있습니다. 그러니 다음 번 데이터 프로젝트에서 어려움을 겪을 때는 이 기술들을 포용하고 시각을 재설정하며, 각 어려움이 더 강력한 데이터 전문가로 발전하는 한 걸음 다가가는 과정임을 기억해주세요.","ogImage":{"url":"/assets/img/2024-06-22-YouveHitaWallinYourDataProjectNowWhat_0.png"},"coverImage":"/assets/img/2024-06-22-YouveHitaWallinYourDataProjectNowWhat_0.png","tag":["Tech"],"readingTime":5},{"title":"본 글에서는 Python, SQL, Power BI를 사용해 특정 소프트웨어 엔지니어링 분야의 국가별 연봉 및 평점 분석 프로젝트를 다루었습니다","description":"","date":"2024-06-22 17:52","slug":"2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry","content":"\n\n현재 정보 시대에서 데이터 분석의 중요성은 이전보다 더 커졌어요. 이 글에서는 Python, SQL 및 Power BI를 사용하여 진행한 데이터 분석 프로젝트에 대해 자세히 설명할 거예요. Kaggle에서 얻은 데이터셋은 특정 소프트웨어 직종의 채용 공고, 채용자 회사의 평가 비율, 그리고 직원들에게 제공되는 최저, 평균 및 최고 연봉 범위 등의 데이터를 포함하고 있어요. 이 프로젝트는 기존 데이터를 정리하고 구성하는 데 초점을 맞추며 필요한 데이터를 추출하고 이를 시각화하여 통계 비율을 생성합니다. 이 프로젝트의 주요 목표는 나만의 로드맵을 개요화하여 완전한 데이터 엔지니어링 프로젝트를 만드는 것이에요.\n\n이 프로젝트에서:\n\n- Python을 사용한 데이터 정리와 구성,\n- Oracle SQL을 사용한 데이터베이스 관리 및 쿼리, 그리고 일부 데이터 업데이트,\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 시각화 및 의미 있는 보고서 작성에 Power BI를 사용합니다.\n\n프로젝트에서 사용된 각 기술이 어떻게 통합되었는지와 이 프로세스의 끝에서 얻은 결과를 단계별로 공유할 것입니다. 이 글이 데이터 분석 프로젝트에 참여하거나 관심을 가지고 있는 모든 분들에게 유용하길 바랍니다.\n\n프로젝트 로드맵 및 사용된 기술\n\n이 프로젝트에서는 구체적인 목표를 달성하기 위한 단계별 로드맵을 개요로 작성했습니다. 이제, 프로젝트에서 사용한 Python, SQL 및 Power BI 기술을 자세히 설명하고 이들을 어떻게 통합했는지 시작하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_0.png)\n\n프로젝트에서 사용된 모든 코드는 GitHub 링크(https://github.com/Revealis)를 통해 확인할 수 있습니다.\n\n1. Python: 데이터 정리 및 분석\n\n프로젝트의 첫 단계에서는 Python을 사용하여 데이터세트를 정리하고 예비 분석을 수행했습니다. Python의 강력한 라이브러리 중 하나인 Pandas를 사용하여 데이터를 정리하고 예비 분석을 수행하며 오류를 해결했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. SQL: 데이터베이스 관리 및 쿼리\n\n프로젝트의 두 번째 단계에서는 SQL을 사용하여 데이터를 저장하고 빠르게 액세스했습니다. SQL의 강력한 쿼리 기능 덕분에 대량 데이터 세트에서 복잡한 쿼리를 수행했고, 전송 단계에서 문제가 발생한 열을 재검토하며 필요한 작업을 수행했습니다.\n\n3. Power BI: 데이터 시각화 및 보고\n\n마지막 단계에서는 Power BI를 사용하여 SQL 데이터베이스에서 데이터를 검색하고 분석된 데이터를 시각화했습니다. Power BI의 대화식 시각화 도구 덕분에 데이터를 더욱 이해하기 쉽고 인상적으로 제시할 수 있었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 파이썬: 데이터 정제 및 분석\n\n첫 번째 단계로 캐글에서 데이터셋을 다운로드합시다. (https://www.kaggle.com/datasets/imbishal7/glassdoor-salary)\n\n먼저, 데이터셋을 파이썬으로 불러오고 내용을 확인해봅시다. 먼저, Pandas 라이브러리를 import 해주세요:\n\n![Dataset](https://www.example.com/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, Python에서 데이터셋을 읽어봅시다:\n\n```python\nimport pandas as pd\nfile_path = 'glassdoor-salaries.csv'\ndata = pd.read_csv(file_path)\ndata.info()\n```\n\n코드를 실행했는데, 실행 후에 CSV 파일에서 호환성 오류가 발생했습니다. 불량 행을 건너뛰도록 데이터셋을 다시 읽으려고 했습니다:\n\n```python\nimport pandas as pd\nfile_path = 'glassdoor-salaries.csv'\ndata = pd.read_csv(file_path, delimiter='\\t', on_bad_lines='skip')\nprint(data.head())\nprint(data.info())\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과에서 추가 열을 식별했고 데이터 유형을 확인했습니다:\n\n![이미지](/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_2.png)\n\n![이미지](/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_3.png)\n\n추가 및 불필요한 열을 삭제하는 코드에 한 줄을 추가했습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndata = data.drop(columns=['Unnamed: 9'])\n```\n\n그런 다음, 다시 확인하기 위해 CSV 파일을 원시 상태로 읽어 오류가 있는 열이 있는지 확인했습니다:\n\n```js\nimport csv\n\nfile_path = 'glassdoor-salaries.csv'\nwith open(file_path, 'r', encoding='utf-8') as file:\n    reader = csv.reader(file, delimiter='\\t')\n    for i, row in enumerate(reader):\n        if len(row) != 9: \n            print(f' Bad line: {i+1}, Content: {row}')\n```\n\n![이미지](/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_4.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 출력을 확인했고, 오직 열 이름만 잘못된 행으로 계산되었다는 것을 알았습니다. 그래서 첫 번째 행을 \"헤더\"로 표시했습니다. 먼저 데이터셋의 특수 문자를 공백으로 대체했습니다. 그런 다음 데이터셋에서 누락된 값을 식별하고 해당 열을 수정했습니다:\n\n```js\nimport pandas as pd\n\ndata = pd.read_csv('glassdoor-salaries.csv',header=0, delimiter='\\t')\npd.set_option('display.max_column', None)\npd.set_option('display.max_rows', None)\ndata = data.replace('\\xa0', ' ', regex=True) \ndata = data.drop(columns=['Unnamed: 9'])\nmean_rating = data['company_rating'].mean()\ndata['company_rating'].fillna(mean_rating, inplace=True)\nif 'company' in data.columns:\n    data['company'] = data['company'].fillna(\"No Company\")\n```\n\n그런 다음 단위 열을 더 읽기 쉽게 만드는 함수를 작성했습니다:\n\n```js\ndef chg_unit(unit):\n    if unit == ' / yr':\n        return 'Yearly'\n    elif unit == ' / mo':\n        return 'Monthly'\n    elif unit == ' / hr':\n        return 'Hourly'\ndata['unit'] = data['unit'].apply(chg_unit)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프로세스 후에 데이터셋의 낮은, 평균 및 높은 급여 열의 숫자 데이터가 통화 단위와 결합되어 분석 과정에서 문제가 될 수 있습니다. 따라서 통화 단위를 추출하여 \"통화\"라는 다른 열에 할당했습니다:\n\n```js\ndef clmn_currency(x):\n    units = x.split(' ')\n    if len(units) == 1:\n        return x[0]\n    else:\n        return units[0]\ndata['currency'] = data['median'].apply(clmn_currency)\n```\n\n```js\ndef format_salary(x):\n    x = str(x)\n    unit = clmn_currency(x)\n    x = x.replace(unit,'')\n    x = x.replace(',','')\n    x = x.replace('M','000000')\n    x = x.replace('K','000')\n    return x              \n\ndata['median'] = data['median'].apply(format_salary)\ndata['low'] = data['low'].apply(format_salary)\ndata['high'] = data['high'].apply(format_salary)\n```\n\n또한 열에 있는 수백만, 수천 등을 나타내는 문자를 숫자로 변환했습니다. SQL 전의 마지막 단계는 정리된 데이터를 저장하는 것이었습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndata.to_csv('cleaned_glassdoor-salaries.csv', index=False)\n```\n\n2. SQL: 데이터베이스 관리 및 쿼리\n\n두 번째 단계에서는 정제된 데이터를 Oracle SQL 데이터베이스로 전송하였습니다. 첫 번째 단계로, SQL Developer를 사용하여 `employee_data`라는 테이블을 생성해보겠습니다:\n\n\u003cimg src=\"/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_5.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, 컴퓨터에 텍스트 파일을 생성하여 SQL 명령을 작성하고, 데이터를 정리한 경로, 데이터가 로드될 대상 테이블, 파일 내에서 데이터가 구분되는 방법을 포함하여 저장하세요:\n\n![이미지](/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_6.png)\n\n그런 다음, 컴퓨터의 시작 메뉴에서 명령줄을 열고 저장된 텍스트 파일 안에 있는 SQL 명령을 실행하세요. 명령줄에 작성한 코드에는 사용자 이름, 비밀번호, 데이터베이스 문자열 (TNS 이름) 및 데이터베이스에 연결할 파일의 경로가 포함됩니다:\n\n![이미지](/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 단계를 거친 후에 내가 데이터를 테이블에 넣어 두었음을 확인했다. DML을 사용하여 쿼리했을 때, 데이터를 CSV 파일로 변환했기 때문에 다시 오류가 발생했다. 통화를 확인했을 때, 특수 문자가 데이터베이스 문자 설정 때문에 나오지 않았음을 발견했다.\n\n페이지를 마크다운 형식으로 변경해주세요:\n\n|Header1|Header2|Header3|\n|-------|-------|-------|\n|Data1  |Data2  |Data3  |\n\nSQL 명령어로 문제를 해결하고 세계 각국의 통화를 국가 코드로 변경했다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그런 다음, 평균 열을 쿼리하고 정렬했을 때 문자에 오류가 있는 것을 발견했습니다:\n\n![이미지](/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_10.png)\n\n이 열 및 기타 열의 오류를 수정하기 위해 SQL의 REPLACE 명령을 사용하여 불필요한 문자를 공백으로 대체했습니다:\n\n![이미지](/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 작업을 수행한 후에는 문제가 있는지 확인하기 위해 열을 확인하고 필요한 최종 조정을 했습니다. 회사 열에서 문제가 있는 열을 삭제하는 대신 효율성을 위해 이름을 바꿔주었습니다:\n\n![Company Column](/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_12.png)\n\n계산에서 혼란을 방지하기 위해 Round 명령을 사용하여 평점 열을 소수점 한 자리로 반올림했습니다:\n\n![Rating Column](/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_13.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 파워 BI: 데이터 시각화와 보고서\n\n파워 BI 부분에서는 프로젝트의 시각화와 마지막 단계로, 데이터를 가져와서 내 테이블에서 데이터가 들어왔는지 확인했습니다. 필요한 필터를 만들고, 오른쪽 메뉴에서 시각화할 데이터를 선택하고, 보고서에 맞게 그래프를 조정했습니다:\n\n![이미지](/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_14.png)\n\n그런 다음 차트를 만들기 시작했고, 첫 번째 차트에서는 회사들이 직무 역할에 대한 고용 비율을 보여주는 파이 차트를 만들었습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_15.png\" /\u003e\n\n참고: 숫자의 단위는 터키어로 제공됩니다. 이를 설정 섹션에서 사용자 정의할 수 있습니다.\n\n제가 두 번째 차트를 만들었고 회사 수의 분포를 국가별로 막대 차트로 조사했습니다:\n\n\u003cimg src=\"/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_16.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 세 번째 차트를 만들었고, 기업들의 평가 분포율을 막대 그래프를 사용하여 분석했어요:\n\n![Company Rating Distribution Rates](/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_17.png)\n\n네 번째 차트를 만들었는데, 이 차트에는 통화 단위를 선택하여 전문직의 평균 연봉을 플롯했어요. 이 표에 카드를 추가하여 정확한 수치를 볼 수도 있어요. 우리는 표 옆의 슬라이서로 원하는 통화를 선택할 수 있어요:\n\n![Average Salaries of Professions by Currency Units](/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_18.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최종 차트에서 이해를 돕기 위해 행렬을 사용했습니다. 이 표에서는 회사들이 직무별로 제공하는 결제 방법의 분포 백분율을 조사했습니다:\n\n| 구분 | 시간당 | 월별 | 연간 |\n|---|---|---|---|\n| 엔지니어 | 20% | 50% | 30% |\n| 디자이너 | 30% | 40% | 30% |\n| 분석가 | 25% | 45% | 30% |\n| 기타 | 20% | 50% | 30% |\n\n프로젝트의 종합 평가\n\n얻은 결과\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 클린징: 파이썬을 사용하여 데이터셋에서 누락된 데이터와 오류 데이터를 성공적으로 정리했습니다. 이 단계는 분석을 위한 견고한 기반을 마련했습니다.\n\n데이터 분석: SQL 쿼리를 통해 데이터베이스의 데이터에 복잡한 분석을 수행할 수 있었습니다. 이러한 분석을 통해 조정해야 하는 불필요한 행과 열에 대한 유용한 정보를 얻을 수 있었습니다.\n\n데이터 시각화: Power BI를 사용하여 만든 시각화를 통해 데이터를 더 명확하고 효과적으로 표현할 수 있었습니다. 이러한 시각화는 다음 단계의 결정을 지원하는 명확하고 설득력 있는 결과를 제공했습니다.\n\n## 이 포괄적인 데이터 엔지니어링 프로젝트와 로드맵 그리고 전적으로 제 자신의 코드에 관심을 가져 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_0.png"},"coverImage":"/assets/img/2024-06-22-DataAnalysisProjectUsingPythonSQLandPowerBISalaryandRatingAnalysisofCertainSoftwareEngineeringFieldsbyCountry_0.png","tag":["Tech"],"readingTime":10},{"title":"SQL에서 중앙값 계산하는 5가지 방법","description":"","date":"2024-06-22 17:50","slug":"2024-06-22-5WaysToCalculateMedianInSQL","content":"\n\n![이미지](/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_0.png)\n\n3년 전, 데이터 과학의 세계에 들어갈 것 같았을 때, 여러 가지가 너무 압도적으로 보였어요. 딱 한 번의 인생 안에 배워야 할 것들이 너무 많았죠! 데이터 과학자가 되기 위해 필요한 기술을 탐험하면서 저를 안심시켜준 것 중 하나는 통계학이었어요. 저는 고등학교 때부터 대학 시절까지 통계학을 좋아했거든요. 통계학을 배울 때 우리가 초기에 배운 것 중 하나는 데이터의 평균, 중앙값 그리고 최빈값을 계산하는 것이었어요. 전문 용어로는 중심 경향성 측정값이라고 부르기도 해요.\n\n# 빠른 복습\n\n평균: \"평균치\"라고도 불리며, 모든 데이터 점수를 더하고 데이터 점수의 수로 나누어 찾을 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중앙값: 중간 숫자; 모든 데이터 포인트를 정렬하고 중간에 있는 숫자를 선택하여 찾음 (또는 두 개의 중간 숫자가 있는 경우, 그 두 숫자의 평균을 취함).\n\n최빈값: 가장 빈도가 높은 숫자 - 즉, 가장 자주 발생하는 숫자.\n\n![이미지](/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_1.png)\n\nMeasure of Central Tendency에 대한 마이크로블로그를 보유하고 있습니다. 여기에서 그들의 필요성과 사용 사례가 더 자세히 설명되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://www.linkedin.com/posts/subhralina-nayak_data-statistics-datascience-activity-6977655040274522112-bvR6?utm_source=share\u0026utm_medium=member_desktop\n\n# SQL: 나의 진정한 사랑\n\n말할 것도 없이, 나는 \"SQL이 모든 것보다 중요\" 운동의 기수입니다!\n\n데이터 분석에 필수인 최고의 도구가 SQL이죠. SQL을 사용하면 가능한 모든 분석을 수행할 수 있습니다. 하지만 중심 경향성 측정은 할 수 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 당연히 가능해요!\n\n평균을 계산하는 것은 매우 간단해요. AVG() 집계 함수를 사용할 수 있어요.\n\n최빈값을 계산하는 것은 각 카테고리의 레코드 수를 세고, MAX() 함수를 사용하여 가장 많은 수의 그룹을 구할 수 있어요.\n\n하지만, 중앙값을 계산하는 것은 약간 까다로울 수 있어요. 그렇지만 중앙값을 SQL에서 계산하는 것은 여전히 가능해요. 한 가지 방법이 아니라, 5가지 방법으로 가능해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# SQL을 사용하여 중앙값 계산해보기\n\n먼저, 중앙값을 계산하는 데 사용되는 수학 공식을 이해해야 합니다.\n\nN개의 요소를 가진 데이터셋이 있을 때, 작은 순서대로 정렬된 경우,\n\n중앙값 = (N+1)/2번째 요소, 만약 N이 홀수인 경우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중앙값 = (N/2번째 요소 + (N/2 + 1)번째 요소)/2, 단, N이 짝수인 경우\n\n위의 공식에 따르면 데이터셋은 정렬되어 있어야 하며 홀수와 짝수 개수의 데이터포인트를 고려해야 합니다.\n\n## 변수와 OFFSET — FETCH를 사용하여\n\n```js\nDECLARE @c BIGINT = (SELECT COUNT(*) FROM sales.order_items)\n\nSELECT AVG(list_price) AS \"Median\"\nFROM (\n SELECT list_price\n FROM sales.order_items\n ORDER BY list_price\n OFFSET (@c - 1)/2 ROWS\n FETCH NEXT 1 + (1 - @c%2) ROWS ONLY\n) data\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n변수 @c는 sales.order_items 테이블의 전체 행 수로 할당됩니다. 내부 서브쿼리는 목록 가격을 오름차순으로 정렬합니다. OFFSET (@c - 1)/2 ROWS 절은 첫 번째 절반의 행 (단 @c가 홀수인 경우) 또는 정확히 중간 행 (단 @c가 짝수인 경우)을 건너뜁니다. FETCH NEXT 1 + (1 - @c%2) ROWS ONLY 절은 @c가 홀수인 경우 다음 행을 가져오거나 @c가 짝수인 경우 추가 행을 가져오지 않습니다. 마지막으로 외부 쿼리는 검색된 행의 평균을 계산하여 중앙값을 구합니다.\n\n## ROW_NUMBER() 윈도우 함수 사용하기\n\n```js\nSELECT AVG(list_price) AS \"Median\"\nFROM\n(\n   SELECT list_price,\n      ROW_NUMBER() OVER (ORDER BY list_price ASC, order_id ASC) AS RowAsc,\n      ROW_NUMBER() OVER (ORDER BY list_price DESC, order_id DESC) AS RowDesc\n   FROM sales.order_items\n) data\nWHERE\n   RowAsc IN (RowDesc, RowDesc - 1, RowDesc + 1)\n```\n\n위 쿼리는 먼저 각 행에 대해 목록 가격과 주문 ID에 따라 오름차순 및 내림차순으로 순서를 지정합니다. 서브쿼리는 목록 가격 및 해당하는 오름차순 및 내림차순 순서의 행 번호를 검색합니다. 외부 쿼리는 오름차순 순서의 행 번호가 내림차순 순서의 행 번호와 동일하거나 하나 차이 나는 경우의 목록 가격의 평균을 계산합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ORDER BY, MIN() 및 MAX() 함수 사용\n\n```js\nSELECT (\n(SELECT MAX(list_price)\nFROM (\n SELECT list_price\n FROM sales.order_items\n ORDER BY list_price\n OFFSET (SELECT COUNT(*)\n FROM sales.order_items) / 2 ROWS\n FETCH NEXT 1 ROW ONLY) AS BottomHalf) +\n(SELECT MIN(list_price)\nFROM (\n SELECT list_price\n FROM sales.order_items\n ORDER BY list_price DESC\n OFFSET (SELECT COUNT(*)\n FROM sales.order_items) / 2 ROWS\n FETCH NEXT 1 ROW ONLY) AS TopHalf)\n) / 2 AS Median\n```\n\n데이터셋을 list_price를 기준으로 두 부분 (상위 및 하위)으로 분할합니다. 내부 서브쿼리는 각각 list 가격의 상위 50%와 하위 50%를 찾습니다. MAX(list_price) 및 MIN(list_price) 함수는 각각 각 반의 최대값과 최소값을 검색합니다. 최종 결과는 하위 반의 최댓값과 상위 반의 최솟값을 더한 다음 그 합을 2로 나누어 중앙값을 얻습니다.\n\n## NTILE() 윈도우 함수 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nSELECT MAX(list_price) AS \"중앙값\"\nFROM (\n SELECT list_price,\n NTILE(4) OVER(ORDER BY list_price) AS Quartile \n FROM sales.order_items\n) X\nWHERE Quartile = 2\n```\n\nNTILE 함수는 결과 집합을 4개의 동일한 부분(사분위수)으로 나눕니다. ORDER BY list_price는 목록 가격을 오름차순으로 정렬합니다. 외부 쿼리는 Quartile이 2인 서브쿼리에서 최대 목록 가격을 선택하는데, 이는 중간값인 두 번째 사분위수를 나타냅니다.\n\n## PERCENTILE_CONT() 윈도우 함수 사용하기\n\n```js\nSELECT DISTINCT PERCENTILE_CONT(0.5) \n  WITHIN GROUP (ORDER BY list_price) OVER() AS \"중앙값\"\nFROM sales.order_items\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPERCENTILE_CONT 함수는 그룹 내에서 주어진 열의 특정 백분위수를 계산합니다. 0.5 인수는 우리가 50번째 백분위수인 중앙값을 찾고 싶다는 것을 나타냅니다. ORDER BY list_price 절은 중앙값을 계산하기 전에 목록 가격이 오름차순으로 정렬되도록 합니다. DISTINCT 키워드는 중앙값이 동일한 값이 여러 개 있는 경우에도 전체 중앙값에 대해 한 결과만 얻도록 합니다. OVER() 함수는 어떤 분할도 없이 사용되므로 PERCENTILE_CONT가 전체 결과 집합에 적용됩니다.\n\n참고: 모든 쿼리는 MS SQL Server에서 작성되었습니다.\n\n이 쿼리들은 SQL에서 중앙값을 계산하는 다양한 방법을 제공하며, 그 효과는 데이터셋 크기와 사용 중인 데이터베이스 시스템에 따라 달라질 수 있습니다. 데이터셋에서 가장 효율적이고 정확한 중앙값 계산 방법을 찾기 위해 이 쿼리들을 특정 데이터셋에서 테스트하는 것이 좋은 실천법입니다.\n\nSQL에서 중앙값을 계산하는 다른 방법이 있을 것으로 확신합니다. 발견하면 코멘트로 남겨주시기 바랍니다. 위에서 소개한 방법 중에서 여러분의 즐겨찾는 또는 선호하는 방법을 알려주세요. 이 블로그가 여러분의 SQL 역량을 향상시키는 데 도움이 되기를 바랍니다. 네, \"모든 것은 SQL로 시작한다\"고 말씀합니다.","ogImage":{"url":"/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_0.png"},"coverImage":"/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_0.png","tag":["Tech"],"readingTime":5}],"page":"35","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"35"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>