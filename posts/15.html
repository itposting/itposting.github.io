<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/15" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/15" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="정전용량 토양 습도 센서 보호 방법" href="/post/2024-06-23-ProtectingCapacitiveSoilMoistureSensors"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="정전용량 토양 습도 센서 보호 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="정전용량 토양 습도 센서 보호 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">정전용량 토양 습도 센서 보호 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NodeMCU ESP8266과 LM35 온도 센서를 사용해 웹 서버 구축하는 방법" href="/post/2024-06-23-BuildingaWebServerwithNodeMCUESP8266andLM35TemperatureSensor"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NodeMCU ESP8266과 LM35 온도 센서를 사용해 웹 서버 구축하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-BuildingaWebServerwithNodeMCUESP8266andLM35TemperatureSensor_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NodeMCU ESP8266과 LM35 온도 센서를 사용해 웹 서버 구축하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">NodeMCU ESP8266과 LM35 온도 센서를 사용해 웹 서버 구축하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ESP32OV7670  WebSocket 비디오 카메라 설정하는 방법" href="/post/2024-06-23-ESP32OV7670WebSocketVideoCamera"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ESP32OV7670  WebSocket 비디오 카메라 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ESP32OV7670WebSocketVideoCamera_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ESP32OV7670  WebSocket 비디오 카메라 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">ESP32OV7670  WebSocket 비디오 카메라 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="프로그래머블 보드가 정말 하고 싶은 말 " href="/post/2024-06-23-Whatyourprogrammableboardwantstotellyou"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="프로그래머블 보드가 정말 하고 싶은 말 " loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Whatyourprogrammableboardwantstotellyou_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="프로그래머블 보드가 정말 하고 싶은 말 " loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">프로그래머블 보드가 정말 하고 싶은 말 </strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Arduino에서 Quectel EC200을 사용해 HTTP POST 요청 보내는 방법" href="/post/2024-06-23-QuectelEC200HTTPpostinArduino"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Arduino에서 Quectel EC200을 사용해 HTTP POST 요청 보내는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-QuectelEC200HTTPpostinArduino_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Arduino에서 Quectel EC200을 사용해 HTTP POST 요청 보내는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Arduino에서 Quectel EC200을 사용해 HTTP POST 요청 보내는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="해상 통신을 위한 LoRa 기술 활용법 범선에서의 새로운 가능성" href="/post/2024-06-23-BeyondtheGridLoRaforSailboatCommunication"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="해상 통신을 위한 LoRa 기술 활용법 범선에서의 새로운 가능성" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="해상 통신을 위한 LoRa 기술 활용법 범선에서의 새로운 가능성" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">해상 통신을 위한 LoRa 기술 활용법 범선에서의 새로운 가능성</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CH340 칩이 탑재된 비공식 Arduino 클론에서 Arduino IDE 사용하는 방법" href="/post/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CH340 칩이 탑재된 비공식 Arduino 클론에서 Arduino IDE 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CH340 칩이 탑재된 비공식 Arduino 클론에서 Arduino IDE 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">CH340 칩이 탑재된 비공식 Arduino 클론에서 Arduino IDE 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Proteus와 Arduino IDE를 사용하여 벽돌깨기 게임 만드는 방법" href="/post/2024-06-23-CreatingaBrick-BreakingGameUsingProteusandArduinoIDE"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Proteus와 Arduino IDE를 사용하여 벽돌깨기 게임 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-CreatingaBrick-BreakingGameUsingProteusandArduinoIDE_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Proteus와 Arduino IDE를 사용하여 벽돌깨기 게임 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Proteus와 Arduino IDE를 사용하여 벽돌깨기 게임 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="저항 밴드 색상 읽는 방법 쉽게 배우기" href="/post/2024-06-23-HowToReadResistorBandColors"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="저항 밴드 색상 읽는 방법 쉽게 배우기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowToReadResistorBandColors_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="저항 밴드 색상 읽는 방법 쉽게 배우기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">저항 밴드 색상 읽는 방법 쉽게 배우기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법" href="/post/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link" href="/posts/14">14</a><a class="link posts_-active__YVJEi" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"정전용량 토양 습도 센서 보호 방법","description":"","date":"2024-06-23 17:46","slug":"2024-06-23-ProtectingCapacitiveSoilMoistureSensors","content":"\n\n화분 식물의 토양 수분을 측정하려고 했었는데, 일단 저항성 토양 수분 센서 몇 개를 구입했습니다. 그러나 프로브 다리, 전자 부품 및 커넥터 주변 등이 빨리 부식되어 망가졌습니다. 완전히 망가졌어요. 그 후 내가 '부식 방지'로 홍보된 적응형 센서를 보게 되었고, 싸게 여러 개를 구입했습니다. 안타깝게도 비슷한 문제가 발생했습니다. 이 기사에서는 적응형 토양 수분 센서가 입은 손상과 그것을 해결하려고 시도한 내 경험을 적었습니다.\n\n![이미지](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_0.png)\n\n# 1. 센서\n\n내가 구입한 적응형 토양 수분 센서들은 'DFRobot'의 아날로그 적응형 토양 수분 센서와 기능적으로 동일한 것 같습니다. 정확히 센서가 어떻게 작동하는지는 내 현재 지식의 범위를 벗어납니다. 그럼에도 불구하고, electronicclinic.com에서 이에 대해 훌륭한 기사가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 진행하기 전에 중요한 사항이 있습니다: 몇몇 센서가 고장났습니다. 이 글은 센서의 1MΩ 저항기(R4)가 제대로 접지되어 있으며, 중앙에 칩이 TLC555인 것을 전제로 합니다. 더 많은 정보를 위해 여기를 읽어주세요.\n\n## 2. 손상\n\n화분에 센서를 넣기 전에, PCB의 맨 앞부에 노출된 전자 부품들을 고려하여 환경(및 나의 식물 관수)로부터 어떤 종류의 보호가 필요할 것으로 보였습니다. 이를 위해 일부 보호책을 찾아보고, 손에 있는 것으로 전자 부품 및 연결부를 핫-글루건의 접착제로 덮고, 그 위에 일반적인 히트 수축 튜브를 덧대어 보호하기로 결정했습니다. 그 후 센서가 토양에 들어가 원하는 대로 작동했습니다.\n\n약 6개월 뒤, 읽기가 다소 이상하다는 것을 알게 되었습니다. 토양이 완전히 건조한 상태일 때에도 센서가 이전보다 훨씬 더 높은 습도 수준을 나타내고 있었습니다. 센서를 꺼내어 히트 수축 튜브와 접착제를 벗기고, 전자 부품들의 아랫부분 주변에 부식이 있음을 관찰했습니다. 특히 캐패시터 C1, C2, C3, 그리고 C4 부분 주변이었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Soil Moisture Sensor Image 1](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_1.png)\n\nI also noticed that the solder mask covering the ground plate, which runs along the outer edge of the sensor, was wrinkled. I assumed this was due to water infiltrating underneath. Additionally, there were small breaks on the outside of the solder mask, revealing the ground plate.\n\n![Soil Moisture Sensor Image 2](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_2.png)\n\nTo assess the sensor's functionality, I connected it to an Arduino Uno to collect data. I utilized the pin connections and program provided below. I did not include any additional components such as resistors or capacitors.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nSENSOR                  ARDUINO\n-------------------------------\nVCC (RED)               5V\nGND (BLACK)             GND\nAOUT (YELLOW)           A0\n```\n\n결과적으로 대략 일정한 값을 23 얻었어요. 물이나 흙에 넣어도 효과가 없었어요. 도대체 고장난 것 같았어요.\n\n우선 그것을 분리하고 전자 부품 위에 WD-40을 조금 떨어뜨려 부식을 제거하고 고치기를 희망했어요. 하루 뒤에 돌아와서 휴지로 닦아낼 수 있는 것을 닦았어요.\n\n아두이노에 다시 연결했을 때 처음에 유망한 결과를 얻었어요. 읽히는 값은 약 530이었어요. 그러나 그 값들은 환경 변화가 없는 상황에서도 빠르고 점진적으로 약 120 정도로 떨어지기 시작했어요. 그러나 유망한 점은, 센서를 물에 넣었을 때 올바른 방향으로 약간의 변화가 있었어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n센서를 다시 청소하기로 결정했어요. 이번에는 WD-40을 전체 센서에 뿌려 위에서부터 아래까지 덮어두고 하루 동안 적셔놓았어요. 종이 타월로 닦아낼 수 있는 것은 다 닦았지만, 안타깝게도 접지 플레이트를 덮고 있던 솔더 마스크를 손상시켜 버린 것 같아요. 그래서 구리가 노출된 채 벗겨진 거예요.\n\n![이미지](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_3.png)\n\n아두이노로 테스트한 결과는 이전보다 훨씬 좋았어요. 센서가 어느 정도 624를 보여주고 일정하게 읽혔어요. WD-40에 센서를 \"적셔놓은\" 데가 있었던 심해에 갇혀 있던 물을 쫓아냈을 것이라고 가정해봤어요. 거기서 주름진 것을 발견했었거든요.\n\n# 3. 테스트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n손상된 센서가 이제 어느 정도 작동한다는 점에서 그 상태가 무엇인지 확인해 보았습니다. 다음 다섯 가지 환경을 테스트하기로 결정했습니다:\n\n- 건조한 공기 (책상 위에 노출된 채로)\n- 건조한 토양 (500g 유리병에 넣은 건조한 토양)\n- 촉촉한 토양 (500g 유리병에 125ml 수돗물과 섞은 건조한 토양)\n- 촉촉한 토양 (500g 유리병에 250ml 수돗물과 섞은 건조한 토양)\n- 물 (500g 유리병에 있는 수돗물)\n\n그러나 비교할 기준 측정값이 필요했습니다. ESD 안전 가방에서 새로운 센서를 개봉하고 해당 센서를 테스트했습니다. 또한 DF Robot의 \"Value 1\" 및 \"Value 2\" 값 (건조 및 물)도 포함했습니다. 여기에 결과가 있습니다:\n\n![image](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n조금 같아 보이지만, 손상된 센서는 다시 읽을 수 있도록 고쳐졌을 수도 있습니다. 그러나 몇 가지 주목할 점이 있습니다:\n\n- 두 센서가 동시에 같은 아두이노에 연결되어 있었습니다. 이 결과에 어떤 영향을 미쳤는지 확실하지 않습니다.\n- 결과를 얻을 때 두 센서를 동시에 같은 유리병에 넣었습니다. 예외는 물 테스트이며 전자 부품이 손상되는 것을 피하기 위해 센서를 (커넥터로 고정하여) 고정했습니다.\n- 물이나 물이 섞인 토양에 센서를 놓을 때, 센서의 값을 안정화되도록 허용했으며, 거의 변동되지 않았습니다. 이 작업을 얼마나 오랜 시간 동안 수행했는지 측정하지 않았으므로 예견하지 못했지만, 흥미로운 측정 항목일 수 있습니다.\n- 새 센서는 손상된 센서보다 안정화된 값을 얻기까지 훨씬 더 오랜 시간이 걸렸습니다. 손상된 센서보다 두세 배 정도 오래 걸린 것으로 추정됩니다.\n- 센서가 습기의 높은 수준을 감지함에 따라 읽기가 낮아질 것으로 예상되므로, 새 센서의 젖은 토양 측정치는 이론상 이상할 수 있습니다.\n- DFRobot의 위키에서는 \"건조(dry)\", \"습기(wet)\", \"물(water)\"에 대한 값 범위를 나열하고 있습니다. DFRobot의 \"건조\"가 이 시험의 건조 토양과 비교할 만하다고 가정하면, \"습기\"가 습기가 있는 토양, \"물\"이 물과 비슷하다면, 손상된 센서의 젖은 토양 측정치만 범위를 벗어나며 312로 나타납니다. 이는 DFRobot의 \"물\" 범주로 분류됩니다. 센서의 손상된 솔더 마스크가 습기에 민감해지도록 하는 것일 수도 있습니다. 센서가 이전보다 훨씬 높은 습기 수준을 잘못 보고하는 것으로 처음 관찰한 것을 지지하는 이론입니다.\n- 보다 견고한 실험은 센서의 값을 안정화될 때까지 읽은 후 토양의 수분 함량을 높이고 반복하여 수행하는 것일 수 있습니다.\n\n# 4. 제안된 수정 사항\n\n내 가설은 센서가 손상된 이유는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 전자 부품의 부식\n- 센서를 덮고 있는 솔더 마스크 아래에 물이 갇히는 문제가 있습니다.\n\n따라서 이 두 문제를 해결하려고 합니다.\n\n## 4a. 전자 부품의 부식\n\n이전에 설명한 대로 핫 글루 건에서 나온 접착제로 부식을 방지하려고 시도했습니다. 그러나 이것이 부품을 충분히 보호하지 못했을 것으로 생각합니다. 핫 글루를 벗겼을 때 PCB에서 일관되게 마르지 않았다는 것을 발견했습니다. 이로 인해 한쪽이 다른 쪽보다 더 나빠 보였을 수 있습니다. PCB에 대한 접착제의 더 나은 적용은 덜 점성이 높은 것이었을 수도 있지만 다시 그것에 의존하지 않겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다행히도, 전기용량 수분 센서 부식을 방지하는 것은 새로운 문제가 아닙니다. 일반적인 접근 방법은 전자 부품과 커넥터를 코팅하거나 덮는 것입니다. 사용되는 화합물과 재료로는 매니큐어, 요연, 에폭시, 그리고 접착제가 발린 및 발림이 없는 열 수축 튜브가 포함되는 것으로 보입니다.\n\n콜로라도 주립대학의 제이 해머 교수는 자신의 instructables.com 기사에서 모든 전자 부품을 매니큐어로 앞뒤로 코팅한 뒤 센서 윗부분을 접착제가 발린 열 수축 튜브로 덮는 과정을 설명하고 있습니다.\n\nswitchdoc.com에서는 동일한 과정을 실리콘 시랑만으로 덮는 기사가 있습니다 (즉, 열 수축 튜브 없음). 또한 주입 코팅이 특히 이 문제를 해결하도록 설계된 것임을 언급합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_6.png)\n\nAdosia specifically makes and sells “ruggedized” capacitive moisture sensors and provides a video on their process. Note their use of urethane to coat the PCB.\n\nAn article on thecavepearlproject.org describes using heat-shrink as a container, filling it with epoxy, and heating it from the bottom to cover the components.\n\n![image](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_7.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 기사에는 또 다음과 같이 언급되어 있습니다:\n\nthecavepearlproject.org의 기사에는 접착제가 칠해진 히트 슈린크만 사용해도 \"꽤 괜찮은 일\"을 할 것이라고 언급하지만, 아마도 이 경우 단순히 히트 슈린크만 사용한 것일 것입니다. 따라서 이 상황에서 우레탄과 히트 슈린크에 추가로 에폭시를 사용하는 것이 유지재로서 더 효과적인지 아닌지에 대한 질문이 있습니다. 그러나 아쉽게도 그 질문에 대한 답을 알지 못합니다. 보호층의 양이 적용된 지점에서는 이제 실제로 더 중요하지 않을 수도 있습니다.\n\n그러나 제 간략한 조사에서 알 수 있듯이, 경화된 에폭시와 같은 \"단단한\" 소재는 환경 온도가 극단적인 온도(-40°C에서 +85°C 사이)로 변할 때 전기적 결함을 일으킬 수 있습니다. 해당 기사는 \"극한 또는 가혹한 환경\"에서는 더 부드러운 소재를 사용하는 것이 좋다고 언급합니다.\n\n나는 토양 수분 센서를 식물이 자라는 곳 어디에든 설치할 수 있을 것으로 예상하며, 그것은 지구상 거의 모든 곳에 해당한다는 것은 말할 것도 없습니다. 이는 다양하고 적대적인 환경을 포함하고 있습니다. 그 부드러운 특성을 감안할 때, 나는 따라서 우레탄을 사용하고 Adosia가 설명한 과정을 따를 것으로 결정했습니다. 그러나 일부 수정을 가할 예정입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 유레탄 코팅을 몇 겹 해야 하는지에 대한 불일치가 있습니다. Adosia의 비디오에서는 PCB에 유레탄 코팅을 두 겹 하지만 제품 설명에는 \"세 겹 코팅\"이라고 명시되어 있습니다. 장기간 야외에서 전자 부품을 보호해야 하는 경우를 고려하면, 사실상 세 겹이 권장될 것으로 가정하고 조심스럽게 처리하기로 결정했습니다.\n\n둘째, 이전의 instructables.com 기사에서는 센서의 윗면 가장자리를 갈아내어 히트 수축이 관통되는 것을 피하는 것이 좋다고 권장했습니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_8.png\" /\u003e\n\n따라서, 저는 동일한 작업을 선택했지만, 가장자리를 둥글게 만들어 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 번째로, Adosia는 열 수축 후에 다른 보호 조치를 취하지 않은 것으로 보입니다. instructables.com 기사에서는 열 수축물의 아래쪽에 \"추가 방수 보호를 제공하기 위해\" 매니큐어를 바른 것으로 나와 있습니다.\n\n![image](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_9.png)\n\n이 자리에서 매니큐어가 실제로 어떤 차이를 만들었는지 여부와는 무관하게, 바르기는 불편하지 않고 그 원리는 타당합니다.\n\n마지막으로, 그리고 가장 중요한 것은 Adosia가 커넥터를 제거하지 않았다는 점입니다. 반면에 instructables.com 기사에서는 다른 와이어를 연결할 수 있도록 커넥터를 제거했습니다. Adosia 튜토리얼 비디오에서는 커넥터를 제거하지 않은 것이 단순히 \"견고화\" 과정을 보여주기 위한 것이었을 수도 있습니다. 그렇지만, 커넥터가 여전히 존재하는 것에 대한 내 우려는 열 수축물이 커버해야 하는 영역과 이에 따른 \"프주문\"이 발생할 수 있는 부분입니다. 아래의 Adosia 이미지에서는 PCB 주변의 일부 열 수축물 부분이 평평하게 놓이지 않는 것이 보입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\n![이미지](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_10.png)\n\n열 수축 튜브를 자르고 다른 케이블을 연결하고 더 많은 열 수축을 적용해야 한다는 것을 상상할 수가 없어요. 대신에 그것을 제거하고 직접 PCB에 선을 납땜할 거에요.\n\n## 4b. 납 마스크 아래 갇힌 물\n\n먼저 납 마스크를 손상시키지 않는 방법에 대해 몇 가지 방법을 논의하고 싶어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 토양에 삽입하거나 제거할 때(또는 일반적으로) 센서를 거친 표면에 긁히지 않도록 주의하세요. 돌의 날카로운 가장자리만으로도 솔더 마스크에 찢김을 일으킬 수 있습니다. 가능하다면 작은 도랑을 파고 센서를 안에 놓은 후 토양을 밀어넣는 것이 좋습니다.\n\n둘째, 어떤 이유로든 센서를 청소해야 할 경우(이소프로필 알코올 사용), 솔더 마스크에 찢기거나 걸릴 수 있는 것은 피하십시오. 부드러운 천과 같은 비요철적인 것으로 가볍게 눌러주는 것이 더 안전합니다. 특히 이미지의 솔더 마스크에 주름이 생긴 경우에는 더욱 그렇습니다.\n\n셋째, 솔더 마스크 아래에 물이 갇혀 있다는 의심이 든다면 정상 작동을 복원하기 위해 제거해야 합니다. 가능한 최소한으로 파괴적이지 않은 방법으로 제거해야 합니다. 저는 WD-40를 사용했지만 대안이 있을 수 있습니다. 열을 사용하여 물을 증발하는 방법이 도움이 될 수 있지만 이미 손상된 솔더 마스크가 반응하는 방식에 대해 우려됩니다. 지면 판에서 솔더 마스크가 물러날 수 있습니다. 어떤 방법을 사용하더라도 먼저 센서를 분리해야 합니다.\n\n넷째, PCB의 가장자리 보호가 충분히 고려되지 않은 것으로 보입니다. 그러나 이전에 인용한 thecavepearlproject.com 기사에서는 \"[PCB가 갈려 있으면 수%의 물을 흡수할 수 있다]\"고 설명하며 가장자리에 에폭시를 바를 것을 언급했습니다. 게다가 Adosia는 YouTube에 남긴 댓글에 따르면 \"전체 보드를 밀봉하는 것\"을 테스트했지만 \"아날로그 작동 범위가 축소되었다\"고 밝혔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Soil moisture sensor](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_11.png)\n\n아도시아는 전체 보드를 밀봉했다고 하지만 가장자리만 밀봉하는 방법에 대한 언급은 없었습니다. 저는 우레탄으로 가장자리를 밀봉해보겠습니다. 실패할 경우 네일 폴리쉬를 사용할 예정입니다. 다른 사람들은 대안으로 슈퍼글루나 플라스티딥을 추천했습니다.\n\n또한, 땅 및 구리 판을 덮고 있는 솔더 마스크도 손상과 누출 가능성을 줄이기 위해 보호제로 코팅하는 것을 고려하고 있습니다. 즉, 솔더 마스크의 가장자리 부분이 파손되어 물이 침투하는 것을 막기 위함입니다. 용도에 따라 네일 폴리쉬, 우레탄, 에폭시 또는 다른 적합한 물질을 사용하되 작동 범위를 충분히 유지하며 전체 PCB를 코팅하는 대신 손상될 수 있는 부분만 코팅하는 것이 합리적인 대안이 될 수 있습니다.\n\n또 다른 해결책이 있을 수 있습니다. 보호제를 미리 적용하지 않은 상태에서 솔더 마스크가 손상된 경우 해당 보호제를 대체로 사용하여 솔더 마스크를 복원할 수 있습니다. 예를 들어, 이 기사 초반의 이미지에서 노출된 지면 판 위에 우레탄 코팅을 하는 것이 적합한 수정 방법이 될 수 있습니다. 우란을 사용하여 센서의 노출 부분을 분리하여 다른 부분에 우레탄이 적용되는 것을 피할 수 있습니다. 이것이 아도시아가 비디오에서 한 방법입니다. 솔더 마스크가 이미 느슨한 경우 테이프(전기 테이프 포함)를 사용하지 않는 것이 좋습니다. 테이프를 제거하는 과정에서 솔더 마스크가 떨어져 더 많은 손상을 입을 수 있기 때문입니다.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n따라서 지켜보았던 찢어짐을 피하기 위해 지면 판의 안쪽과 바깥쪽 가장자리에 아주 작은 양의 네일 폴리시를 직접 발라보려고 합니다. 또한 손상된 센서를 수리하기 위해 노출된 지면 판에 우레탄을 코팅해 보려고 합니다.\n\n# 5. 보호 및 절차\n\n## 5a. 선택한 보호책 요약\n\n제 계획은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 전자 부품에 우레탄 코팅을 3번 발라주세요. CRC Red Urethane Seal Coat를 구매했는데, 색상은 중요하지 않습니다. 열 수축 튜브에 가려질 것이기 때문이죠.\n- 전자 부품에 3/4인치 (19.1mm) 3:1비율의 내부 접착제가 들어간 열 수축 튜브를 사용해주세요.\n- PCB 전체 가장자리에 우레탄 코팅을 3번 발라보세요. 이것이 현실적으로 불가능한 경우, PCB 전체 가장자리에 매니큐어를 3번 발라주세요. Sally Hansen Hard As Nails 매니큐어를 구매했습니다.\n- 접지 플레이트의 내부와 외부 가장자리에 매니큐어를 1번 발라주세요.\n\n## 5b. 제안된 절차\n\n- 커넥터 제거.\n- 센서 윗부분의 모서리를 둥글게 깎기.\n- GND, VCC, AOUT에 전선 납땜.\n- 센서 연결부에 전선에 열 수축 튜브 적용 (이전에 언급하지 않았지만, 별도의 전선을 묶어두기 위해 적용합니다).\n- PCB 가장자리에 우레탄 또는 매니큐어 3번 발라주세요.\n- 접지 플레이트의 내부와 외부 가장자리에 매니큐어 1번 발라주세요.\n- 전자 부품의 전면과 뒷면에 우레탄 3번 발라주세요.\n- 전자 부품과 우레탄에 열 수축 튜브 적용.\n- 센서에 연결되는 열 수축 튜브 하단에 매니큐어 1번 발라주세요.\n\n또한, 손상된 센서의 경우:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 노출된 구리판을 종이로 분리하고 노출된 구리판에 요소 우레탄 한 층을 바르는 처리.\n\n## 6. 결과 및 관측\n\n이전에 설명한 손상된 센서를 보호하기로 결정했습니다.\n\n### 6a. 커넥터 제거\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 세 번째 손 악어 클립이 솔더 마스크를 손상시키는 것을 방지하기 위해, 나는 다른 크기의 골판지 조각 두 장을 잘라서 센서 사이에 넣었습니다. 그런 다음 PCB에서 커넥터를 탈거하고 제물질을 깨끗이 클린업하기 위해 솔더 사커를 사용했습니다.\n\n![이미지1](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_12.png)\n\n![이미지2](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_13.png)\n\n![이미지3](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_14.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에 놓친 PCB 가장자리의 변색을 주목했습니다. 또한, 납땜기가 그 부근에 가까워짐에 따라 PCB 윗면의 중심에서 거품이 형성되는 것이 신기했습니다. JST 커넥터를 제거한 후에 거품이 형성되었습니다. 유감스럽게도, 이 시점에서 센서를 더 망가뜨리고 말았습니다. 그 결과로 땜 마스크가 땅판에서 떨어지기도 했습니다.\n\n## 6b. 모서리의 깎는 방법\n\n센서의 모서리에 PCB에 표시하거나 작은 조각 종이를 붙이는 것으로 센서의 얼마만큼 깎아야 하는지 가이드하기로 계획했습니다. 그러나 실제로 제거해야 할 양은 극히 미미하여 눈으로 판단할 수 있다는 것을 깨달았습니다. 아래 이미지는 신용카드의 모서리가 센서의 모서리 위에 올려놓은 상황을 보여줍니다. 이것을 센서에서 얼마나 깎아내야 하는지 확인하는 가이드로 활용했습니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_15.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n체인지된 마크 다운 형식의 코드 예시:\n\n\nI placed the sensor in a bench vice — again sandwiched between plenty of cardboard — and gently and slowly filed the corners.\n\n![Sensor Image](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_16.png)\n\n![Sensor Image](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_17.png)\n\n## 6c. Solder the Wires\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n센서와 함께 제공된 케이블을 사용하기로 결정했습니다 (이 기사의 처음 이미지를 참조하세요). 이 기사의 목적에 있어 어떤 끝을 제거해도 상관없습니다; 여성 JST(화이트) 또는 여성 Dupont(블랙) 커넥터를 잘라낼 수도 있습니다. 저는 단순히 센서에서 이전에 제거한 남성 JST 헤더에 여성 JST 커넥터를 연결하기 위해 Dupont 커넥터를 제거하기로 결정했습니다. 참고로, 와이어는 24 AWG 입니다. 또한, 다음 단계를 위한 히트 수축을 준비했다는 점을 유의하세요.\n\n![이미지1](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_18.png)\n\n![이미지2](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_19.png)\n\n![이미지3](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_20.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_21.png\" /\u003e\n\n한 가지 더 알려드릴 점이 있어요. 여기까지 말입니다. 남은 와이어를 잘라내고 센서 뒷면에 남은 부분을 약간 깎아내었어요. 솔더링된 부분에 남아 있는 날카로운 솔더나 와이어 조각이 히트 수축 튜브를 찔러 뚫을까봐 걱정이 돼서 그랬어요.\n\n## 6d. 와이어에 히트 수축 튜브 적용\n\n센서에서 나온 와이어를 결합하기 위해 작은 지름의 히트 수축 튜브를 사용했어요. 저는 가지고 있던 히트 수축 튜브 세트에서 가져왔는데, 지름이 약 3mm(1/25\") 정도라고 측정했어요. 저는 1.5cm(0.6\") 길이로 잘라서 이전 단계처럼 센서에 납땜하기 전에 와이어 위에 끼웠어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n열애하는 고객님,\n\n열 수축 소재를 가열할 히트건이 없어서 대신 헤어 드라이어를 사용했어요.\n\n![이미지](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_22.png)\n\n## 6e. 우레탄 또는 매니큐어로 PCB 가장자리 처리\n\n종이팩으로 센서를 살짝 덮어주어 센서의 가장자리만 노출시키기로 결정했어요. 가장자리만 노출시킴으로써 우레탄 스프레이를 가장자리에만 뿌려 흘러나가지 않게 할 수 있을 것 같았어요. 하지만 이 방법은 너무 까다로워서 센서 주위의 종이팩을 계속 옮겨야 했어요. 실제로 이를 하다가 더 많은 솔더 마스크가 벗겨지는 일도 발생했어요. 결국 매니큐어를 사용하기로 했어요.\n\n언제든지 궁금한 점이 있으면 저에게 물어보세요. 감사합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장자리에는 네 개의 마포를 바르기로 결정했다. 각각의 코트를 바른 후, 잘 통풍되는 곳에서 30분씩 마르도록 했다. 네일 폴리시를 바를 때, 센서를 케이블을 세로로 잡고 윗부분부터 아랫부분까지 각각의 가장자리에 발라주는 것이 편하다는 것을 발견했다. 또한 센서 아래쪽의 점을 이용해서 작업대에 대고 쉬었다. 세 번의 코트를 바른 결과, 대부분의 부분이 부드럽고 매끈해졌다.\n\n![이미지](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_23.png)\n\n### 6. 가라 앵코르 프레이트 가장자리에 맞는 마포\n\n이 단계는 내가 예상했던 것보다 조금 더 어려웠다. 네일 폴리시 브러시의 크기로 인해 의도치 않게 PCB에 더 많은 네일 폴리시가 발려버렸다. 그러나 현재 이 시점에서 아날로그 신호에 어떤 유의미한 차이를 만들지는 알 수 없다. 마포를 바른 목적은 여전히 솔더 마스크를 보호하기 위함이었으므로, 아마도 그 대가가 미미할 것이라 생각된다. 어쨌든, 가라 앵코르 프레이트 가장자리에 가벼운 코팅을 하나만 발라주고, 잘 통풍되는 곳에서 30분간 마르도록 했다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_24.png)\n\n그 외 주목할 사항 두 가지가 있습니다. 첫째, PCB 위에 묻은 네일 폴리시를 닦아야 했는데, 실행중에 그것이 한 덩어리로 남아있지 않도록 했습니다. 둘째, 센서에 매우 가까이 다가가서 네일 폴리시를 가능한 한 정확하고 적게 바르도록 노력했습니다. 그라운드 플레이트의 가장자리에만 바르도록 했습니다. 무독성 마스크를 착용하거나 통풍이 잘되는 곳에서 사용하는 것을 강력히 권장합니다.\n\n## 6g. 전자 부품의 앞뒤에 우레탄 코팅\n\n센서 위에 우레탄 스프레이를 준비하기 위해 종이를 덮을 때, 갈색 포장지를 사용할 수 있음을 발견했습니다. 센서를 감쌀 정도로 넓게 잘라서 뒷면에 종이 클립으로 고정했습니다. 클립은 센서를 바닥에서 치우치게 해 주는 추가적인 혜택이 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Protecting Capacitive Soil Moisture Sensors 25](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_25.png)\n\n![Protecting Capacitive Soil Moisture Sensors 26](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_26.png)\n\n다음으로, 센서의 앞면에 운칠을 세 층 바르고 각 코팅 사이에 적어도 30분씩 건조시켰어요. 이 일을 통풍이 잘 되는 곳에서 하고 마스크와 장갑을 사용하는 걸 강력히 추천합니다. 충분한 환기가 없는 실내에 하지 마세요. 운칠이 건조되었는지 확인하기 위해 장갑을 끼고 PCB를 가볍게 눌렀어요. 장갑이 깨끗하게 남아 있으면 건조되었다고 판단했어요. 이전에 언급한 바와 같이, 투명한 운칠 대신 빨간색 운칠을 구입했습니다. 열 수축이 적용되면 차이가 없을 거예요.\n\n![Protecting Capacitive Soil Moisture Sensors 27](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_27.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_28.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_29.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_30.png\" /\u003e\n\nI then flipped the paper over and applied three layers of urethane to the rear of the sensor and let it dry for at least 30 minutes between each coat.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 1](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_31.png)\n\n![Image 2](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_32.png)\n\n![Image 3](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_33.png)\n\n![Image 4](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_34.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n앞면과 뒷면을 살펴보세요.\n\n![이미지](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_35.png)\n\n![이미지](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_36.png)\n\n### 6시. 전자 부품 위에 히트 수축 튜브 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막 유레탄 코팅이 발라진 지 약 18시간이 지났어요. 3:1 비율의 접착제가 라인 처리된 3/4인치(19.1mm) 길이의 40mm(1.6인치) 열 수축 튜브를 잘라 센서 위에 장착했어요.\n\n![이미지](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_37.png)\n\n그런 다음 헤어 드라이어로 열 수축을 시켜, 여전히 뜨거운 상태에서 오븐 장갑을 사용해 압축했어요. 여기 결과물이에요.\n\n![이미지](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_38.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지1](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_39.png)\n\n![이미지2](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_40.png)\n\n안타깝게도 Adosia의 제품과 비교해본 결과, 히트 수축 소재가 제대로 수축되지 않은 것으로 나타났습니다. 나는 헤어 드라이어가 충분한 열을 발생시키지 못했을 것으로 가정했습니다, 특히 히트건과 비교했을 때. 솔더링 아이언의 배럴을 사용하여 더 수축시켰는데, 이는 매우 지루한 과정이었고, 결과적으로 히트 수축 소재에 몇 개의 화재 흔적이 남았습니다.\n\n![이미지3](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_41.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Capacitive Soil Moisture Sensor 1](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_42.png)\n\n![Capacitive Soil Moisture Sensor 2](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_43.png)\n\n## 6i. Nail Polish to Heat-Shrink-to-Sensor Join\n\nAfter the heat-shrink had completely cooled to room temperature, I inverted the sensor and applied one coat of nail-polish completely around the join. I then left it to dry for 30 minutes in a well-ventilated area.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Protecting Capacitive Soil Moisture Sensor 44](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_44.png)\n\n![Protecting Capacitive Soil Moisture Sensor 45](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_45.png)\n\n## 6j. 노출된 구리 판에 우레탄 도장 [손상된 센서 수리 단계]\n\n우레탄 스프레이를 사용한 후, 센서의 노출된 구리에 적용을 시도하지 않기로 결정했습니다. 스프레이가 무작위이고 통제할 수 없는 것을 감안하면 너무 어려운 작업이라고 판단했습니다. 나중에 시도해볼 수도 있겠지만, 일단은 대신 손톱 매니큐어를 사용하기로 결정했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노출된 구리 판에 네일 폴리시 한 층을 발라 건조가 완료되도록 환기가 잘 되는 곳에 30분 동안 두었습니다. 이전과 마찬가지로 센서에 가까이 다가가야 할 것으로 예상되어 마스크를 착용하여 증기를 피했습니다.\n\n![sensor](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_46.png)\n\n이것이 제가 해야 할 마지막 부분이라고 생각하여 앞뒤로 이소프로필 알코올을 뿌려 센서를 깨끗이 닦고, 마이크로 섬유 천으로 살짝 닦은 후 ESD 안전 가방에 저장했습니다. 이 작업은 환기가 잘 되는 곳에서 수행하며, 마스크와 장갑을 착용했습니다.\n\n# 7. 재시험\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에 보호된 센서를 동일한 조건에서 다시 테스트했지만 한 가지 주의할 사항이 있었습니다. 원래 테스트 사이에 시간이 지난 후에 사용한 토양을 폐기했기 때문에 이번 테스트에서 사용한 것은 자연 복숭아였습니다. 그러나 양은 동일했습니다. 이전 결과와 겹쳐 보호된 센서의 결과는 다음과 같습니다.\n\n![이미지](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_47.png)\n\n## 8. 결론 및 의견\n\n결과로부터 결론을 얻는 데에 대해 신중해야 합니다. 미래에 이를 다시 실행하고 모든 테스트에서 토양, 자연복숭아 또는 어떤 매체가 일관되도록 유지하고 싶습니다. 또한 초기 테스트 시간에 작성한 메모를 고려하여보다 효과적인 방법론을 설계하고자 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어쨌든, 건조 및 수분 결과만 보면 (흙이나 마루치를 사용하지 않았기 때문에 영향을 받지 않을 것이라는 전제 하에) 새로운 센서와 손상된 센서 결과와 매우 일관된 것으로 나타납니다. 이는 센서에 적용된 보호층이 결과적으로 아날로그 신호에 별다른 영향을 미치지 않았음을 보여주어 매우 흥미로운 점입니다. 그러나 더 중요한 것은 이 기사의 맥락에서 손상된 커패시티브 토양 수분 센서를 수리하는 것인데, 센서 가장자리, 접지판 가장자리 및 노출된 구리판에 네일 폴리시를 바른 것도 결과적으로 영향을 미치지 않는 것으로 보입니다.\n\n일부 문제를 제외하고 (특히 추가로 이탈된 솔더 마스크), 센서의 상태에 대해 일반적으로 만족스럽다고 생각합니다. 처음에는 기능이 없었고 거의 분해될 가능성이 높았기 때문에 이제 그 내구성에 대해 높은 기대를 가지고 있습니다. 상처 입은 센서에 적용한 보호층의 효과가 시간이 지난 후 어떻게 나타날지에 특히 관심이 있습니다. 미래에 노력한 내용을 업데이트할 계획이며, 사용할 기존 및 새로운 센서에 이러한 보호층을 적용할 것입니다. 추가적으로 다룰 포인트가 몇 가지 있습니다.\n\n보호층이 순차적으로 적용되기 전에 이소프로필 알코올로 센서를 가볍게 청소하는 것도 좋을 수 있습니다. 예를 들어, 요염 및 네일 폴리시를 바르는 것은 이미 존재하는 것을 밀폐하는 효과가 있습니다. 이는 머리카락, 먼지, 기름(즉, 피부 기름) 및 기타 이물질 및 유물이 센서와 작동에 영향을 줄 수 있음을 의미할 수 있습니다.\n\n나는 많은 단계에서 센서를 \"삼켜주기\" 위해 쇠지를 사용했을 때보다 부드러운 천을 사용하는 것이 더 적막일 수 있습니다. 부드럽고 두꺼운 천 경련이 벤치 바이스에서 더 쉬웠을 것입니다. 일반적으로 소포에서 찾을 수 있는 얇은 폴리에틸렌 폼 시트가 좋은 선택일 수 있습니다. 솔더 마스크 위를 부드럽게 지나가며 끌지 않고 미끄러울 것입니다. 만약 다른 이물질이나 잔여물이 있는지 확인하려면 카드보드나 비슷한 재질을 사용할 때 소포를 센서에 부드럽게 밀착시키고 냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에 언급한 PCB의 변색은 특히 새 센서의 가장자리와 비교했을 때 뚜렷하게 보입니다.\n\n![image](/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_48.png)\n\n이 변색이 PCB가 물을 흡수한 것을 나타내는 지 궁금합니다. 이것이 납땜용 열이 존재할 때 거품이 생기는 것을 관찰한 이유일지도 모릅니다. 가장자리에 발라둔 네일 폴리시가 이런 사태를 방지하는 데 도움이 되기를 희망합니다.\n\nPCB 모서리를 깎기 위해 라우터 부착용 드레멜을 사용하는 것을 고려했지만 PCB의 작은 부분만 둥글게 깍아내야 했습니다. 손으로 갈아 내는 것이 매우 쉬웠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n센서 상단의 전선에 적용한 열 수축 튜브에는 접착제가 없었습니다. 이것은 외부에 있는 접착제가 있는 열 수축 튜브의 효과를 줄일 수 있습니다. 왜냐하면 효율적으로 '터널'을 만들기 때문입니다. 이러한 이유로 '터널' 끝 부분을 포함하는 접착제가 있는 열 수축 튜브를 자르기로 선택했습니다. 전선 주변에 접착제가 없는 열 수축 튜브를 사용할 경우 이 사실을 인식하십시오. 다음 옵션 중 하나를 선택하십시오:\n\n- 내부 열 수축 튜브를 사용하지 마십시오;\n- 외부 열 수축 튜브가 덮을 수 있도록 짧은 길이를 사용하십시오; 또는\n- 접착제가 있는 열 수축 튜브를 사용하십시오.\n\n차후 센서에 대해 외부 열 수축 튜브 상단을 뛰어넘는 내부 길이의 접착제가 있는 열 수축 튜브를 사용하기로 결정했습니다. 이렇게 함으로써 절연된 전선 이상의 대상 주변에 더 큰 외부 밀봉이 형성되기를 희망합니다.\n\n열 수축 튜브 내부의 접착제가 헤어 드라이어를 사용하여 충분히 녹지 않으면 실마리를 올바르게 만들 수 없을 것입니다. 이 경우 센서 주변에 제대로 밀봉이 형성되지 않을 것입니다. 발생하면 물과 습기를 멀리하도록하는 능력이 심각하게 저하될 수 있습니다. 절대적으로 열건을 사용하는 것을 강력히 권장드립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n열 수축체 위에 어떤 종류의 “뚜껑”을 만들어 센서 상단에 놓을 수 있을까 궁금해졌어요. 아마도 3D 프린트된 것일 수도 있어요. 기존 상태로 둘 경우보다 미학적인 면에서 더 나을 뿐만 아니라 해당 부위를 더 잘 보호해줄 수도 있을 거예요. 비올 때 식물 화분 바깥에 있는 센서를 상상해봤을 때, 물이 열 수축체의 개구 부위를 맞을 것 같아 걱정이 돼요. 시간이 지나면 이것이 열 수축체의 보호 기능 (특히 접착제)에 어떻게 영향을 미칠지에 대해 고민이 들어요. 다른 전자 부품들을 수용할 수 있는 것이 만들어질 수 있다면 흥미롭겠죠.\n\n센서가 열 수축체와 접합되는 부위에 매니큐어를 사용하는 데 대한 몇 가지 우려가 있어요. 아마도 여기서 레드 색상을 사용하지 않겠지만 대신 더 많은 유레탄을 사용할 수 있었을지 궁금해요. 그러나 이곳에 어떤 보호 조치를 취하더라도 궁극적으로는 필요 없을지도 모르겠죠. 이미 접합 부위의 아래쪽과 뒤쪽에는 이미 유레탄이 있고, 열 수축체에서 나온 접착제가 있어요. 그러나 좀 더 생각해본 결과, 이 접합 부위가 전자 부품에 가장 가까운 데라는 것을 깨달았어요. 맘의 안정을 위해 추가적인 보호 조치가 유익할 수도 있겠네요.\n\n경제적으로 비현실적하지 않다면, 다시 레드 유레탄을 사용하지 않겠어요. 센서 오른쪽 가장자리에 있는 “유출물”은 상당히 눈에 띄고 미학적으로도 매력적이지 않아요. 대신 투명한 유레탄을 사용할 거에요. 물론, 필요한 부위에만 효과적으로 적용할 수 있는 능력에 따라 달려 있겠죠. 그렇게 하면 열 수축체가 유레탄을 완전히 가리고 있을 거예요, 색깔에 상관없이요.","ogImage":{"url":"/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_0.png"},"coverImage":"/assets/img/2024-06-23-ProtectingCapacitiveSoilMoistureSensors_0.png","tag":["Tech"],"readingTime":22},{"title":"NodeMCU ESP8266과 LM35 온도 센서를 사용해 웹 서버 구축하는 방법","description":"","date":"2024-06-23 17:43","slug":"2024-06-23-BuildingaWebServerwithNodeMCUESP8266andLM35TemperatureSensor","content":"\n\n환경 데이터를 간단한 웹 인터페이스를 통해 모니터링할 수 있는 능력은 굉장히 유용할 수 있습니다. 이 기사에서는 저가 참여한 프로젝트에 대해 소개하려고 합니다. NodeMCU ESP8266 모듈과 LM35 온도 센서를 사용하여 온도를 표시하는 웹 서버를 만들었습니다. 이 프로젝트는 IoT 원칙의 실용적인 응용뿐만 아니라 센서, 마이크로컨트롤러 및 웹 기술을 통합하는 쉬움을 보여줍니다.\n\n# 프로젝트 개요\n\n![프로젝트 이미지](/assets/img/2024-06-23-BuildingaWebServerwithNodeMCUESP8266andLM35TemperatureSensor_0.png)\n\n이 프로젝트의 목표는 LM35 센서에서 온도 데이터를 읽고 해당 데이터를 지역 네트워크 내에서 접근 가능한 웹 페이지에 표시할 수 있는 NodeMCU ESP8266 웹 서버를 설정하는 것이었습니다. LM35 센서는 섭씨 온도에 직접 상응하는 간단한 출력으로 선택되어, 복잡한 보정이 필요하지 않은 우리의 요구에 이상적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 필요한 재료\n\n- NodeMCU ESP8266 보드\n- LM35 온도 센서\n- 브레드보드와 연결용 와이어\n- 프로그래밍 및 전원 공급을 위한 미니 USB 케이블\n\n# LM35 온도 센서 이해\n\nLM35 온도 센서는 사용 편의성과 정확한 온도 측정으로 널리 애용되는 정밀 통합 회로 장치입니다. 복잡한 계산이나 교정 없이 온도를 직접 출력하기 때문에 저희 프로젝트와 같은 작업에 매우 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLM35 센서는 섭씨 온도에 비례하는 아날로그 전압을 출력하여 온도를 측정합니다. 스케일 팩터는 10 mV/°C이며, 이는 1도 섭씨 증가당 출력 전압이 10 밀리볼트 증가한다는 것을 의미합니다. 이 특성은 NodeMCU ESP8266과 같은 마이크로콘트롤러와 간편하게 통합할 수 있습니다.\n\n# 전압을 온도로 변환하기\n\nLM35에서의 아날로그 전압 측정값을 온도로 변환하기 위해 우리는 다음 공식을 사용합니다:\n\n\n![이미지](/assets/img/2024-06-23-BuildingaWebServerwithNodeMCUESP8266andLM35TemperatureSensor_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 NodeMCU ESP8266 세팅에서 ADC(아날로그-디지털 변환기) 참조 전압이 3.3V이고 해상도가 10비트인 경우, 최대 읽을 수 있는 전압은 3.3V(또는 3300mV)이며 1024등분(2¹⁰ = 1024)할 수 있습니다. 따라서 각 ADC 값을 나타내는 단위는 3300/1024 mV가 됩니다. 아래는 코드에서 이를 구현하는 방법입니다:\n\nA0 핀에 연결된 LM35에서 아날로그 값을 읽습니다.\n\n이 값을 전압으로 변환합니다:\n\n\u003cimg src=\"/assets/img/2024-06-23-BuildingaWebServerwithNodeMCUESP8266andLM35TemperatureSensor_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전압을 온도로 변환해 주세요:\n\n![온도 변환 참조 이미지](/assets/img/2024-06-23-BuildingaWebServerwithNodeMCUESP8266andLM35TemperatureSensor_3.png)\n\n이 계산 결과는 섭씨로 온도를 나타내며 웹 서버에 표시할 수 있습니다.\n\n# LM35 대체 옵션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLM35 센서는 간단하고 정확한 온도 감시가 필요한 프로젝트에 우수한 선택입니다. 이는 우리가 단순성과 비용 효율성이 주요 고려 사항인 시나리오에 완벽하게 맞습니다.\n\nLM35는 많은 응용 분야에 적합하지만 DS18B20 및 DHT11 / DHT22 센서와 같은 대체품도 온도 측정 기능을 제공합니다:\n\n- DS18B20: 이 센서는 디지털 온도 측정 값을 제공하며 1-선 버스를 통해 통신하여 아날로그-디지털 변환을 필요로하지 않습니다. 정확하고 디지털 통신이 필요한 응용프로그램에 적합합니다.\n- DHT11/DHT22: 이러한 센서는 온도와 습도를 모두 측정하여 환경 모니터링에 유용합니다. 그러나 LM35와 비교해 응답 속도가 느리고 온도 측정에서는 덜 정확합니다.\n\n# 단계 1: 회로 조립\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLM35를 NodeMCU에 연결하는 방법:\n\n![LM35 Wiring](/assets/img/2024-06-23-BuildingaWebServerwithNodeMCUESP8266andLM35TemperatureSensor_4.png)\n\n- LM35의 첫 번째 핀(평평한 쪽을 보고 왼쪽 핀)을 NodeMCU의 3V 핀에 연결합니다.\n- LM35의 중간 핀을 NodeMCU의 A0(아날로그 입력) 핀에 연결합니다.\n- LM35의 세 번째 핀(오른쪽 핀)을 NodeMCU의 GND 핀에 연결합니다.\n\n이 간단한 설정을 통해 LM35는 감지한 온도에 비례하는 아날로그 전압을 NodeMCU로 전송할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 2: NodeMCU 프로그래밍\n\n## 설정 및 네트워크 연결\n\nESP8266 모듈은 내장 WiFi 기능을 이용하여 WiFi 네트워크에 연결하도록 프로그래밍될 수 있습니다. 이는 Arduino IDE를 사용하여 간단한 프로그래밍 단계를 거쳐 수행됩니다. 아래는 일반적인 작업 흐름입니다:\n\n- 필요한 WiFi 네트워크에 연결하기 위한 함수를 제공하는 ESP8266WiFi 라이브러리를 포함합니다.\n- WiFi 자격 증명 설정: 네트워크 이름 (SSID)과 암호를 코드에서 상수로 설정합니다.\n- 연결을 시작합니다: WiFi.begin() 함수를 사용하여 SSID 및 암호를 매개변수로 사용합니다.\n- 연결 상태를 모니터링합니다: 연결 시도를 WiFi.status()를 사용하여 연결이 설정될 때까지 반복문에서 관찰합니다.\n- 웹 서버의 인스턴스를 특정 포트에 생성하고, HTTP의 경우 보통 포트 80을 사용합니다.\n- ESP8266가 전송된 연결을 수신하기 위해 server.begin()을 사용하여 서버를 시작합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```cpp\n#include \u003cESP8266WiFi.h\u003e\n#include \u003cWiFiClient.h\u003e\n#include \u003cESP8266WebServer.h\u003e\n#include \u003cESP8266mDNS.h\u003e\n\nconst char* ssid = \"여러분의_WIFI_SSID\";\nconst char* password = \"여러분의_WIFI_비밀번호\";\nESP8266WebServer server(80);\n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.print(\"연결된 WiFi: \");\n  Serial.println(ssid);\n  Serial.print(\"IP 주소: \");\n  Serial.println(WiFi.localIP());\n\n  if (MDNS.begin(\"esp8266\")) {\n    Serial.println(\"MDNS 응답기 시작됨\");\n  }\n\n  server.on(\"/\", handleRoot);\n  server.begin();\n  Serial.println(\"HTTP 서버 시작됨\");\n}\n```\n\n## 웹 서버로 설정하는 방법\n\nESP8266는 ESP8266WebServer 라이브러리를 사용하여 웹 서버로 작동할 수 있습니다. 이는 서버가 HTTP 요청에 어떻게 응답할지를 결정하는 다른 엔드포인트에 대한 핸들러를 정의하는 것을 포함합니다. 저희 프로젝트에서는 루트 URL에 액세스할 때 온도 데이터를 제공하는 handleRoot() 핸들러 함수가 사용됩니다.\n\n웹 서버는 온도를 표시하는 간단한 HTML 페이지를 제공합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst char MAIN_page[] PROGMEM = R\"=====(\n\u003cHTML\u003e\n  \u003cHEAD\u003e\n    \u003cmeta http-equiv=\"refresh\" content=\"2\"\u003e\n    \u003cTITLE\u003eTemperature Sensor LM35\u003c/TITLE\u003e\n  \u003c/HEAD\u003e\n  \u003cBODY\u003e\n    \u003cCENTER\u003e\n      \u003cp1\u003e\u003cb\u003eTemperature Sensor LM35\u003c/b\u003e\u003c/p1\u003e\n      \u003cbr/\u003e\n      \u003cp2\u003eTemperature: #TEMPERATURE_VAL# \u0026deg;C\u003c/p2\u003e\n    \u003c/CENTER\u003e  \n  \u003c/BODY\u003e\n\u003c/HTML\u003e\n)=====\";\n\nvoid handleRoot() {\n  float reading = analogRead(A0);\n  float voltage = reading * (3.30 / 1024.0);\n  temperatureC = voltage * 100;\n\n  Serial.print(\"analog read -\u003e \");\n  Serial.print(reading);\n\n  Serial.print(\" | voltage -\u003e \");\n  Serial.print(voltage);\n\n  Serial.print(\" | temperature (celcius) -\u003e \");\n  Serial.println(temperatureC);\n\n  String s = MAIN_page;\n  s.replace(\"#TEMPERATURE_VAL#\", String(temperatureC));\n\n  server.send(200, \"text/html\", s);\n}\n```\n\n웹페이지 헤더의 HTML meta 태그인 `meta http-equiv=\"refresh\" content=\"2\"`은 웹페이지를 2초마다 새로고침하여 가장 최신의 온도를 표시합니다.\n\n작업이 완료되면, 서버에게 웹 서버를 호스팅하도록 지시하기 위해 server.handleClient()와 MDNS.update()를 반복하도록 하세요. 서버에 약간의 500ms 딜레이를 제공해야 합니다.\n\n```js\nvoid loop(void) {\n  server.handleClient();\n  MDNS.update();\n  delay(500);\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 3: 회로 및 웹 서버 실행\n\n![이미지](/assets/img/2024-06-23-BuildingaWebServerwithNodeMCUESP8266andLM35TemperatureSensor_5.png)\n\n결과적으로, ESP8266 웹 서버의 IP 주소를 입력하면 LM35 센서에 의해 감지된 온도 값이 표시되고 0.5초마다 새로고침됩니다.\n\n이 프로젝트는 IoT 하드웨어 및 소프트웨어에 대한 실습 경험이 제공되었을뿐만 아니라 NodeMCU ESP8266과 같은 마이크로컨트롤러가 유용한 웹 기반 응용 프로그램을 생성하는 데 어떻게 사용될 수 있는지를 보여주었습니다. 실시간 온도 데이터를 제공하는 웹 서버를 배포함으로써, 동일한 네트워크에 연결된 어떤 기기를 통해 환경 상황을 편리하게 모니터링할 수 있습니다. 이는 가정 자동화, 환경 모니터링 및 더 많은 가능성을 열어줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"table\" 태그를 Markdown 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-06-23-BuildingaWebServerwithNodeMCUESP8266andLM35TemperatureSensor_0.png"},"coverImage":"/assets/img/2024-06-23-BuildingaWebServerwithNodeMCUESP8266andLM35TemperatureSensor_0.png","tag":["Tech"],"readingTime":6},{"title":"ESP32OV7670  WebSocket 비디오 카메라 설정하는 방법","description":"","date":"2024-06-23 17:41","slug":"2024-06-23-ESP32OV7670WebSocketVideoCamera","content":"\n\n# 소개\n\n지난 몇 주 동안 OV7670에서 첫 의미 있는 명확한 이미지를 얻으려고 노력했습니다. 그리고 오늘, 드디어 소규모 감시 비디오 카메라를 만들었습니다. OV7670은 온라인에서 가장 저렴한 카메라 모듈입니다. 그래서 실험해볼 첫 번째 선택이었습니다. 사실, 작은 감시 비디오 카메라를 만드는 데 더 관심이 있었습니다. OV7670의 해상도는 0.3mp 이므로 HD 품질을 기대하고 있지는 않았습니다 :). 하지만 0.3mp 해상도에서 물체/사람 또는 움직임을 구분할 수 있다면 그것만으로도 충분히 좋을 것 같았습니다. 이 프로젝트를 진행하면서 많은 어려움을 인지하고 있었습니다. 그래서 이를 목표로 나열해 봅시다.\n\n# 목표\n\n- 저렴한 카메라 모듈 사용\n- WiFi에 연결할 수 있는 능력\n- PC 및 스마트폰에서 비디오 스트림 보기 가능\n- 플랫폼에 독립적인 표시 소프트웨어\n- 저전력 소모. 배터리 사용 가능\n- 휴대용\n- 쉽게 구성 가능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마이크로컨트롤러\n\n라즈베리 파이\n\n카메라 프로젝트를 위해 라즈베리 파이가 가장 인기 있는 선택이 됩니다. RAM이 많고 우수한 CPU를 가지고 있습니다. 그러나 설정을 완료하기 위해 추가로 SD 카드, 와이파이 동글(라즈베리 파이 2)과 같은 액세서리가 필요합니다. 이는 비용을 늘려서 좀 더 비싸지게 만듭니다. 저는 더 저렴한 대안이 필요했습니다.\n\n아두이노 우노\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아두이노 Uno를 실험해 보았어요. 하드웨어에서 이미지를 가져오는 것은 복잡한 작업이에요. Ethernet Shield가 없으면 캡처된 프레임을 SD 카드에 먼저 쓰고 Serial 포트를 통해 전송해야 해요... 그러면 비디오를 만들기에는 너무 느려요. 또한 8MHZ에서 이미지를 가져오는 것도 조심스러워요.\n\nESP32\n\nESP32는 제 상황에 매우 유망해 보였어요. CPU는 카메라 클럭 (XCLK)인 10MHZ 이상의 클럭 신호를 제공하기에 충분히 빠르고, QQVGA(160x120x2)의 전체 프레임을 캡처하기에 충분한 RAM을 가지고 있어요. 또한 Wifi 기능을 갖추고 있어요.\n\nESP32에서 OV7670을 사용하는 우수한 라이브러리를 제공하는 http://bitluni.net/esp32-i2s-camera-ov7670/를 발견했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 비디오 기능이 없으며 메모리 제약으로 320x240 프레임을 지원하지 않습니다.\n\nOV7670+ESP32 회로 인터페이스 및 라이브러리 구현에 대한 세부 정보는 다루지 않겠습니다. 대신 열악한 연속 이미지 촬영에서 캡처된 이미지로 비디오 스트림을 어떻게 만들 수 있는지에 초점을 맞출 거에요.\n\n# 비디오 스트리밍 사전 준비 사항\n\n- 비디오 스트리밍에는 캡처된 이미지 프레임의 고속 전송이 필요할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 지연 시간을 낮추려면 데이터 전송은 비동기적이어야 합니다.\n\n3. 데이터는 FIFO 방식으로 표시 장치에 도달해야 합니다.\n\n4. 화면 장치는 깜박임을 방지하기 위해 변경된 픽셀을 매우 빨리 새로고쳐야 합니다.\n\n# 웹소켓\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 웹소켓은 실시간으로 데이터를 전송할 수 있어서 오버헤드가 낮습니다.\n- 클라이언트나 서버는 서로 기다릴 필요 없이 대화를 시작할 수 있습니다.\n- 텍스트와 바이너리 데이터 전송을 지원합니다. 이는 사용자 정의 명령 및 바이너리 이미지를 교환하는 데 도움이 됩니다.\n- 통신 암호화도 가능합니다.\n\n# HTML5 캔버스\n\n- HTML5 캔버스를 통해 화소 조작을 통해 HTML 웹 페이지에서 이미지를 표시하고 직접 업데이트할 수 있습니다.\n- 캔버스는 연결된 ImageData 객체를 가진 HTML 요소입니다.\n- ImageData의 화소 조작은 HTML 캔버스에 변경 사항을 반영합니다.\n\n# 웹소켓을 사용한 비디오 스트리밍 알고리즘\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 브라우저 클라이언트와 ESP32 간에 웹소켓 연결을 설정합니다.\n- 브라우저가 \"start\" 메시지를 ESP32로 보냅니다. 시작 메시지에는 이미지 해상도 유형인 80x60, 160x120 또는 320x240가 포함됩니다.\n- ESP32는 프레임을 캡처하고 webSocket.sendBIN을 사용하여 브라우저로 보냅니다. 이미지 형식은 RGB565입니다. 따라서 전체 프레임 크기는 (픽셀 당 프레임 크기) X 2바이트입니다. 이 솔루션에서는 160x120x2 바이트(QQVGA) 크기의 프레임을 수용할 수 있는 메모리가 할당됩니다.\n- 320x240 해상도의 경우 프레임이 2번 캡처됩니다. 첫 번째 캡처에서는 프레임의 전반부가 전송되고, 두 번째 캡처에서는 나머지 부분이 웹소켓을 통해 전송됩니다. 부분적인 프레임 순서에 대해 브라우저에 알리기 위해 시작 플래그와 종료 플래그가 사용됩니다.\n- 종료 플래그를 수신한 후, 브라우저가 다음 프레임을 요청하기 위해 ESP32에 요청합니다. ESP32는 단계 3과 같이 계속됩니다.\n\n# 구현 세부사항\n\n- ESP32를 5V 전원에 연결합니다. ESP32가 부팅되고 액세스 포인트 및 워크 스테이션으로 자신을 구성합니다. 제공된 옵션 중 가장 좋은 Wi-Fi 네트워크에 연결합니다.\n- PC/스마트폰을 Esp32AP 액세스 포인트에 연결합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-23-ESP32OV7670WebSocketVideoCamera_0.png\" /\u003e\n\n3. Open Google Chrome browser and type 192.168.4.1.\n\nQQ-VGA (120x160) is the default display canvas.\n\n\u003cimg src=\"/assets/img/2024-06-23-ESP32OV7670WebSocketVideoCamera_1.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. ESP32는 웹 서버 역할을 하며, 웹 페이지를 제공하여 JavaScript 프로그램을 포함하고 있습니다. 이 프로그램은 웹 소켓을 통해 ESP32에 연결하고 바이너리 이미지 데이터를 캡처하여 HTML5 캔버스에 표시합니다.\n\n웹 소켓이 열릴 때 ESP32에서 Wi-Fi Station IP 주소가 제공됩니다. ESP32는 스테이션 IP 주소를 웹 클라이언트에 보냅니다.\n\n따라서 카메라에는 두 개의 IP가 있을 수 있습니다. AP를 생성할 때 고정된 192.168.4.1과 ESP32가 다른 Wi-Fi 네트워크에 연결할 때 라우터에서 할당한 스테이션 IP가 있습니다.\n\n웹 소켓 클라이언트는 웹 브라우저입니다. 따라서 표시 장치는 크로스 플랫폼입니다. PC와 HTML5 캔버스를 지원하는 스마트폰에서 볼 수 있습니다. 아래 코드는 웹 클라이언트가 웹 소켓을 처리하는 방법을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내 HTML 캔버스가 픽셀 조작을 통해 이진 데이터를 표시하는 방법을 확인해 봅시다. 캡처 형식은 RGB565입니다. 따라서 각 픽셀은 16비트로 표시됩니다. RGB565은 픽셀을 조작하기 전에 RGB888 형식으로 변환됩니다.\n\n![이미지](/assets/img/2024-06-23-ESP32OV7670WebSocketVideoCamera_2.png)\n\n5. 이제 Wifi 인터넷 네트워크로 전환해 봅시다.\n\n비디오는 80x60(QQQ-VGA), 160x120(QQ-VGA), 320x240(Q-VGA)입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![ESP32OV7670WebSocketVideoCamera_3](/assets/img/2024-06-23-ESP32OV7670WebSocketVideoCamera_3.png)\n\n# Screenshot from Android Phone\n\n![ESP32OV7670WebSocketVideoCamera_4](/assets/img/2024-06-23-ESP32OV7670WebSocketVideoCamera_4.png)\n\n# PCB Board\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-ESP32OV7670WebSocketVideoCamera_5.png\" /\u003e\n\n# 비디오 데모\n\n이 글에서는 모든 목표를 달성했습니다. 저렴한 하드웨어, 크로스 플랫폼 디스플레이 장치(웹 브라우저), 웹 소켓을 통한 빠른 비동기 데이터 전송, 와이파이 연결, 사용 편의성 및 휴대성을 구현했습니다.","ogImage":{"url":"/assets/img/2024-06-23-ESP32OV7670WebSocketVideoCamera_0.png"},"coverImage":"/assets/img/2024-06-23-ESP32OV7670WebSocketVideoCamera_0.png","tag":["Tech"],"readingTime":5},{"title":"프로그래머블 보드가 정말 하고 싶은 말 ","description":"","date":"2024-06-23 17:39","slug":"2024-06-23-Whatyourprogrammableboardwantstotellyou","content":"\n\n## 안녕하세요! 제 이름은 프라탐이고, 나는 주변에서 권장하는 공학의 길을 걷고 있는 학부생이에요. 어린 시절, 제 무한한 호기심은 어른들을 재미있게 만들기도 했고 가끔 짜증나게도 했어요. '테스트 주제'로써 가장 주된 전자 장난감을 돌아보면, 그것들이 전기의 신비한 세계에 대한 제 흥미를 자극했다는 것을 깨달았어요. 제 블로그를 통해 세계적으로 사람들과 연결하고, 제 이야기를 공유하고, 그들의 이야기를 듣고 싶어해요.\n\n![이미지](/assets/img/2024-06-23-Whatyourprogrammableboardwantstotellyou_0.png)\n\n시작하기 전에, 세계적인 사람들과 연결하고, 제 이야기를 공유하고, 그들의 이야기를 듣기 위해 단순한 프로그래밍의 신비를 해석해 보겠습니다.\n\n# 프로그래밍이란 무엇이며 그 필요성은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인간은 의사 소통을 통해 번영합니다. 이것은 정보를 공유하고 사회적 조화를 이루는 주요 수단이죠. 그런데 상대방이 우리와 같은 언어를 구사하지 않는다면 어떻게 될까요? 그것은 상당한 장벽입니다. 두 사람 사이를 이어주고 양쪽을 유창하게 번역하는 통역사가 있다고 상상해보세요. 이 상황은 프로그래밍의 본질을 반영하고 있습니다. 당신은 컴퓨터에 작업을 수행하도록 지시하지만, 컴퓨터는 이진수, 즉 0과 1로 구성된 언어만 이해합니다. 여기에 컴파일러가 개입하여 당신의 지시사항을 이진수로 번역합니다. 그러나 컴파일러는 일반어를 이해하지 못합니다. 특정 키워드와 프레임워크를 필요로 하며, 이를 인식하도록 프로그래밍되어 있습니다. 이것이 코딩의 기초를 형성하며, 인간의 지시사항을 컴퓨터가 이해할 수 있는 언어로 변환하는 것을 가능하게 합니다.\n![image](/assets/img/2024-06-23-Whatyourprogrammableboardwantstotellyou_1.png)\n\n프로그래밍을 배우는 것의 중요성은 아주 큽니다. 여기에 그 이유가 있죠:\n\na) 디지털 시대: 주변의 디지털 세계를 완전히 이해하기 위해서는 프로그래밍을 이해하는 것이 중요합니다. 클라우드 서비스, 검색 엔진, 전자상거래 플랫폼과 같이 흔히 사용되는 제품들의 기초를 형성하기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nb) 문제 해결: 프로그래밍은 복잡한 문제를 작은 해결 가능한 부분으로 분해하는 능력을 키우는 데 도움이 되며, 코딩을 넘어서 삶의 다양한 도전에 적용할 수 있는 기술입니다.\n\nc) 기회: 프로그래밍 언어에 능숙하다면 다양한 직업 기회를 열 수 있습니다.\n\nd) 창의성과 혁신: 프로그래밍은 창의적인 비전을 현실로 만드는 도구입니다.\n\ne) 지속적인 학습: 프로그래밍 언어의 끊임없는 진화는 한 가지를 배우는 것이 계속되는 교육적 여정의 시작이라는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로그래밀 보드란 무엇인가요?\n\n프로그래밀 보드는 사용자 요구에 따라 재구성할 수 있는 디지털 회로입니다. 기술적으로 PLD(프로그래밀 논리 장치)로 알려져 있습니다. 이러한 보드의 설계 및 개발은 주로 \"컴퓨터 아키텍처\"라는 컴퓨터과학 하위 분야인 \"재구성 가능 컴퓨팅\"에 주로 속합니다.\n\n![프로그래밀보드 이미지](/assets/img/2024-06-23-Whatyourprogrammableboardwantstotellyou_2.png)\n\nPLD에는 세 가지 구성 요소가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 논리 장치: 이것들은 PLD의 모든 작업의 기본 요소입니다. 사용자가 구성할 수 있는 플립플롭과 게이트를 포함합니다. 예시로 PROM, PAL, PLA, EPLD 등이 있습니다. (처음에는 약간 어려워 보일지 모르지만, 알게 되면 머릿속에 갇힌 오래된 노래만큼 익숙해질거에요😜.) 이러한 장치들은 CD511(이진 코드 10진수; 곧 블로그에서 다룰 예정)와 같이 다양한 애플리케이션에서 사용됩니다. 7세그먼트 디스플레이에 사용되는데, 이 부분에 대해 이후에 자세히 다룰 것입니다.\n\n![PLD](/assets/img/2024-06-23-Whatyourprogrammableboardwantstotellyou_3.png)\n\n2. 디지털 회로: 이것은 PLD가 제작된 기초입니다. 이 디지털 회로 기판은 디지털 전자 회로를 작동시키는 인쇄회로 기판입니다. 이 디지털 회로에는 PCB(인쇄회로 기판) 및 이를 디자인하는 것이 포함됩니다.\n\n— PCB란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n회로 기판, 또는 배선 기판으로도 알려진 회로 기판은 전기 공학의 중요한 요소이며 회로에 손상을 입히거나 자신에게 해를 끼치지 않고 전자 장비를 안전하게 연결하는 방법을 제공합니다. 이러한 기판은 의도된 작업을 수행하기 위해 특정 순서로 배치된 도체 및 절연 재료의 층으로 구성되어 있습니다.\n\n각 유달한 단위마다 이러한 기판을 수작업으로 제작하는 것은 회로의 복잡한 레이아웃 때문에 매우 정밀하고 많은 노력을 필요로 합니다. 인간 노동을 절약하고 일관된 품질을 보장하기 위해 인쇄 회로 기판은 전자 설계 자동화라고 알려진 공정을 사용하여 제조됩니다. 이 방법은 반도체 칩 디자이너들이 반도체 칩을 효율적으로 설계하고 평가할 수 있는 전자 시스템을 만드는 데 도움이 되는 소프트웨어 도구 모음을 활용합니다.\n\n\"`3. 프로그래밍 언어: 이 언어를 HDL (하드웨어 기술 언어)라고 하며 몇 가지 변형이 있습니다. 간단한 장치의 경우, PALASM, ABEL, CUPL과 같은 HDL이 정기적으로 사용되지만, 보다 복잡한 장치의 경우 Verilog와 VHDL과 같은 HDL이 사용됩니다. 이러한 언어들은 하드웨어 설계에 효율적이라고 입증되었지만 사용자 친화적이지는 않으며 종종 도구 지원이 부족할 뿐 아니라 그 문법을 이해하는 것도 큰 어려움을 야기할 수 있습니다. 게다가 이러한 언어들은 때로는 완벽하지 못한, 오류가 많은 하드웨어를 생성할 수 있으며 이는 디버깅 과정에서 상당한 어려움을 일으킬 수 있습니다.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 우리 친구들이 두 가지 새로운 솔루션 세트를 고안했어요 (저주단지만 해서 너무 다행이에요)\n\n![이미지](https://miro.medium.com/v2/resize:fit:996/1*gVwgllpNy4xfEcXmDLbzvA.gif)\n\n- HLS (High Level Synthesis): HLS 도구들은 기존 프로그래밍 언어를 입력으로 받아 해당 HDL (하드웨어 기술 언어)을 생성하려고 노력합니다. 일부 예시로는 CatapultC, Matlab HDL coder 등이 있지만, 매우 비싼 편이에요. 🤑🤑 \n\n몇 번의 클릭만으로 기존 C/Matlab 소프트웨어를 사용하여 하드웨어를 생성할 수 있어 이 기술이 꽤 신비롭다고 할 수 있어요. 지난 몇 년 동안 myHDL, PSHDL과 같은 무료 오픈소스 HDL 대체재가 등장했어요. 이 도구들은 더 간단한 구문과 많은 기능을 제공하는 도구들을 활용함으로써, 하드웨어를 행동적 설명에서 생성하려고 하기보다 디지털 논리 설계의 학습 곡선을 줄이려는 목표를 가지고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-23-Whatyourprogrammableboardwantstotellyou_5.png)\n\n![image](https://miro.medium.com/v2/resize:fit:996/1*rJzxNqPA-FfkNsMlYem26A.gif)\n\n2. 사용자 정의 구문 접근법 - PSDHL (plain and simple hardware description language): PSHDL은 고유한 구문을 사용하는 하드웨어 설명 언어입니다. C/SystemC 프로그래밍 언어의 일부 기능을 활용하면서 하드웨어 모듈을 나타내기 위한 사용자 정의 키워드와 요소를 추가합니다. PSHDL의 주요 장점은 그 간단함에 있습니다. 모듈에서 순차 논리를 나타내기 위한 키워드 하나만 사용합니다. 구문은 불필요한 복잡성 없이 매우 직관적입니다. 주요 이점 중 하나는 PSHDL이 완전히 웹 브라우저 내에서 실행될 수 있다는 것입니다! ARM 마이크로컨트롤러용 mBED 프로젝트 및 온라인에서 디자인을 편집, 컴파일 및 디버깅할 수 있는 pshdl.org 등의 예가 있습니다.\n\n마이크로컨트롤러용 프로그래밍 언어 생태계는 활기차며 끊임없이 성장하고 있습니다. C 및 어셈블리가 임베디드 소프트웨어 설계를 주도했던 시대는 끝났습니다. 이제 C/C++, 아두이노, 자바스크립트 및 파이썬과 같은 언어가 무한한 기회를 제공하고 있습니다. 이 다양성은 HDL에게도 혜택이 될 수 있으며, 더 많은 사용자를 유치하고 혁신적인 응용 프로그램을 구현할 수 있게 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-23-Whatyourprogrammableboardwantstotellyou_6.png)\n\n**CREDITS:**\n\n- FPGA HDL Basics | Arduino\n- ADI™ Reference Designs HDL User Guide [Analog Devices Wiki]\n- Printed circuit board — Wikipedia\n- CD4511 — A BCD to 7-Segment Display Driver Chip (build-electronic-circuits.com)\n- Hardware Description Language — GeeksforGeeks\n- Hardware description language — Wikipedia\n","ogImage":{"url":"/assets/img/2024-06-23-Whatyourprogrammableboardwantstotellyou_0.png"},"coverImage":"/assets/img/2024-06-23-Whatyourprogrammableboardwantstotellyou_0.png","tag":["Tech"],"readingTime":5},{"title":"Arduino에서 Quectel EC200을 사용해 HTTP POST 요청 보내는 방법","description":"","date":"2024-06-23 17:38","slug":"2024-06-23-QuectelEC200HTTPpostinArduino","content":"\n\n![image](/assets/img/2024-06-23-QuectelEC200HTTPpostinArduino_0.png)\n\nQuectel HTTP 애플리케이션 노트에서는 데이터를 보내는 두 가지 방법을 제공합니다.\n옵션 1. POST 본문에서 포스트 데이터와 함께 요청 헤더를 보냅니다. 따라서 데이터 길이에는 헤더와 포스트 데이터 크기가 모두 포함됩니다.\n옵션 2: HTTPCFG를 사용하여 요청 헤더를 설정하고 QHTTPPOST AT 명령을 사용하여 포스트 데이터만을 보냅니다.\n\n# HTTP POST 요청을 보내는 방법\n\n## 1. HTTP 구성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. HTTP context id를 설정하세요: AT+QHTTPCFG=\"contextid\",1\n2. 포스트 URL을 설정하세요: AT+QHTTPCFG=\"url\",\"`URL`\"\nURL은 꼭 프로토콜인 HTTP 또는 HTTPS를 포함해야 합니다. 그렇지 않으면 에러 메시지가 전송됩니다.\n3. 요청 헤더를 설정하세요: AT+QHTTPCFG=\"header\",\"`header`\"\n\n## 2. 포스트 데이터 전송\n\n- 포스트 본문의 데이터 길이를 구하고 AT+QHTTPPOST=`data_length`를 통해 설정하세요.\n\n추가로 입력 시간 초과 및 응답 시간 초과를 설정하는 데 사용할 수 있는 선택적 매개변수로 AT+QHTTPPOST=`data_length`[,`input_time`,`rsptime`]을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 만약 위 단계에서의 응답이 \"CONNECT\"인 경우, 페이로드를 입력하시면 됩니다.\n\n# 아두이노 예제 코드\n\n```js\n#include \u003cSoftwareSerial.h\u003e\n\n#define MCU_RXD D5 // EC200U_TXD에 연결됨\n#define MCU_TXD D6 // EC200U_RXD에 연결됨\n\nSoftwareSerial quectel_serial(MCU_RXD, MCU_TXD);\n\nString myurl = \"api.example.com/post-endpoint/\"; // 이 예제에서는 프로토콜이 포함되어 있지 않습니다\nString token = \"8434jn3i2sdhsy32uau3tjna\";\nString node_id = \"dev-12345\";\nString user_agent= \"Quectel Modem\";\n\nvoid QUECTEL_POST(String url, String headers[], int header_size, const String \u0026data, int data_length);\n\nvoid setup()\n{ \n  delay(10000); // 모뎀이 네트워크에 등록될 때까지 대기\n\n  Serial.begin(57600);\n  quectel_serial_serial.begin(115200);\n\n  // HTTP 헤더 설정\n  String Quectel_headers[4];\n  Quectel_headers[0] = \"User-Agent\" + user_agent;\n  Quectel_headers[1] = \"Authorization: Token \" + token;   \n  Quectel_headers[2] = \"X-node: \" + node_id;\n  Quectel_headers[3] = \"Content-Type: \" + String(contentType); // 30\n\n  int header_size = sizeof(Quectel_headers) / sizeof(Quectel_headers[0]);\n\n  String data= \"{\\\"sensor_data\\\":[{\\\"data_type\\\":\\\"CO\\\",\\\"value\":\\\"7.80\\\"},{\\\"data_type\\\":\\\"temperature\\\",\\\"value\\\":\\\"32.780\\\"},{\\\"data_type\\\":\\\"humidity\\\",\\\"value\\\":\\\"13.40\\\"}]}\";\n\n  QUECTEL_POST(myurl, Quectel_headers, header_size, data, data.length());\n\n}\n\nvoid loop(){\n// 아무 작업도 수행하지 않음\n}\n\n\nvoid QUECTEL_POST(String url, String headers[], int header_size, const String \u0026data, int data_length)\n{\n   \n    String HTTP_CFG = \"AT+QHTTPCFG=\\\"url\\\",\\\"http://\" + url + \"\\\"\"; // URL 앞에 프로토콜을 설정해야 함\n    Serial.print(\"Quectel URL 설정: \");\n    Serial.println(HTTP_CFG);\n    quectel_serial.println(HTTP_CFG);\n\n    quectel_serial.println(\"AT+QHTTPCFG=\\\"contextid\\\",1\");      // 컨텍스트 ID 설정\n    quectel_serial.println(\"AT+QHTTPCFG=\\\"requestheader\\\",0\");  // POST 본문에 요청 헤더 비활성화\n    quectel_serial.println(\"AT+QHTTPCFG=\\\"responseheader\\\",1\"); // 응답 헤더 사용\n    quectel_serial.println(\"AT+QHTTPCFG=\\\"rspout/auto\\\",1\");    // 자동 응답 및 HTTPREAD \"비활성화\"\n    \n    // 사용자 지정 헤더 설정\n    for (int i = 0; i \u003c header_size; i++)\n    {\n        HTTP_CFG = \"AT+QHTTPCFG=\\\"header\\\",\\\"\" + headers[i] + \"\\\"\";\n        quectel_serial.println(HTTP_CFG);\n    }\n\n    // 데이터 전송\n    HTTP_CFG = \"AT+QHTTPPOST=\" + String(data_length) + \",30,60\";\n    quectel_serial(HTTP_CFG);\n    Serial.print(\"Quectel POST 본문: \");\n    Serial.println(data);\n    quectel_serial(data);\n}\n```\n\n문제가 없다면 20x HTTP 응답 코드를 수신해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 참고 자료\n\n- EC200U 및 EG915U 시리즈 HTTP(S) 애플리케이션 노트\n- EC200T-CN AT 명령어 메뉴얼","ogImage":{"url":"/assets/img/2024-06-23-QuectelEC200HTTPpostinArduino_0.png"},"coverImage":"/assets/img/2024-06-23-QuectelEC200HTTPpostinArduino_0.png","tag":["Tech"],"readingTime":4},{"title":"해상 통신을 위한 LoRa 기술 활용법 범선에서의 새로운 가능성","description":"","date":"2024-06-23 17:37","slug":"2024-06-23-BeyondtheGridLoRaforSailboatCommunication","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_0.png\" /\u003e\n\n# 배경\n\n내 아내와 나는 40피트 카타마란에 살고 있으며 자주 휴대용 VHF 해양 무선기로 통하지 않는 지역에 있습니다. 휴대용 VHF 해양 무선기는 좋지만 범위가 제한되고 배터리 수명은 사용에 따라 일수보다는 시간으로 더 정확히 측정됩니다. 게다가, 해양 VHF 주파수는 156-174 MHz 사이이기 때문에 시야 통제 밖이면 신호가 빠르게 약해집니다. 일반적으로 주파수가 높을수록 건물, 언덕 또는 산과 같은 물체를 통과하거나 주위를 휘젓는 데 있어 침투하는 능력이 떨어집니다.\n\n그래서 나는 이에 대한 대안적인 통신 수단을 찾고 있었습니다. 그래서 나왔다고 하는 것이 LoRa와 Meshtastic입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 가능한 해결책\n\nLoRa (Long Range)은 미국에서 915MHz 주파수에서 작동하는 라디오 유형입니다. 해양용 VHF보다 훨씬 높은 주파수에서 작동하지만, CSS (chirp spread spectrum) 기술을 사용하여 신호 무결성을 유지하는 데 훨씬 효율적입니다. CSS는 915MHz 주변을 중심으로 한 주파수 범위에 퍼져있는 신호를 방송합니다.\n이로써 전파가 소음과 간섭, 도플러 이동 (신호가 이동할 때, 예를 들어 보트 딩기에서)에 민감하지 않고 수신기 성능도 더 우수합니다. 이 문장을 읽고 계시다면 트랜시버가 어떻게 작동하는지에 대한 기본적인 지식이 있거나 몇 가지 사항을 찾아보는 것이 상관 없다고 가정하겠습니다.\n\n# 우리에게 어떤 점이 도움이 될까요?\n\n첫째, 이것이 우리의 요구 사항을 충족시킬 것이라는 보장은 없지만, 시도할 가치가 있는 실험이라고 생각됩니다. 또한, 어릴 때 해머디오 라이선스를 취득했기 때문에 라디오 하드웨어와 노는 것을 즐겼던 시절로 돌아가는 향수 여행이기도 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 시나리오를 고려해 봅시다; 우리는 휴대폰 수신이 가능한 지역 가장자리에 정박해 있고, 우리 중 한 명이 보트를 타고 마을로 가서 장보러 가야 합니다. 마을은 가깝지만 몇 건물만 떨어져 있어도 휴대용 VHF 라디오를 사용할 수 없을 수 있습니다. \n우리가 리스트에 팝콘을 잊어먹었다는 걸 어떻게 알려줄까요? 이럴 때 LoRa가 필요합니다.\n\n# 장비\n\n![image](/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_1.png)\n\n저는 LoRa 보드를 아마존에서 주문했는데, 편리하게도 2개 팩키지로 판매하고 있습니다. 저는 WiFi와 블루투스가 장착된 제품을 선택했으나 GPS는 없는 제품입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUSB-C 커넥터로 전원을 공급할 수 있는데, 동시에 내장형 LiPo 배터리 관리자가 있어서 이에 맞는 배터리를 구입했습니다. 보드의 전체 사양을 원하신다면 여기서 찾아볼 수 있어요.\n\n사알과 함께 사용할 배터리가 감쪽같이 들어가지 않아서 사례에는 맞지 않는다는 사실을 깨달았습니다. 하지만 사례가 그리 단단하지 않다고 생각해서 크게 상관하지 않았어요. muziWORKSlab에서 이 사례를 몇 개 주문했으니 곧 도착할 거예요. 거기서 일이 잘 풀리지 않는다고 느꼈기 때문에 이 같은 상황이 발생했어요. 그리고 동일한 상점에서 와이파이 안테나도 주문했어요. 사실상, 같은 상품으로 부터 공급을 받은 안테나는 최적의 성능을 내기에는 크기가 적절하지 않은 듯하더라고요. 주문한 애는 길이 등을 고려하여 계산해 보았을 때 훨씬 나아보여서, 915MHz 대역에서 전송할 때 측정된 SWR이 좋아졌어요. 이 대역은 미국의 주파수대 조건이죠.\n\n선택한 배터리는 이미 SH1.25×2 배터리 커넥터가 부착되어 있어 배터리 포트에 직접 연결할 수 있습니다. 라디오와 함께 제공된 헤더 핀들은 좋은 것 같지만, 나는 아직 신기한 하드웨어 실험을 하고 싶진 않아요. 적어도 아직은요.\n\n\u003cimg src=\"/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 조각들을 모두 맞추기\n\n조그만하지만 정말 라디오인데, 모든 라디오들처럼 안테나를 사용하지 않고 방송하면 라디오 전송 회로에 손상을 입힐 수 있습니다. 그래서 장치에 전원을 공급하기 전에 안테나를 설치해야 했습니다. 이것은 실제로 시도해보기 전에는 간단한 과정처럼 보였습니다. 커넥터를 딱 맞추고 눌러야 하는데, 제 뚱뚱한 소세지 손가락은 작은 OLED 디스플레이의 정확한 가장자리와 싸우고 있었습니다. 이미지에서 얼마나 간격이 좁은지 볼 수 있습니다.\n수정하는 데 몇 분이 걸렸지만, 마침내 제대로 끼울 수 있었습니다. 진짜 안테나가 이번 주에 도착할 때 신경 쓰이지 않기를 바랍니다.\n\n![이미지](/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_3.png)\n\n# 라디오 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안테나가 설치되어 있어 라디오를 설정해야 했습니다. USB-C 커넥터를 사용하는 라디오와 노트북 및 USB 케이블이 있어 전원을 공급하는 것은 쉬웠어요. 부팅 시퀀스가 완료되면 위의 화면이 표시됩니다. 이제 메스타스틱 플랫폼을 장치에 플래시해야 했어요. 메스타스틱은 장치를 메쉬 네트워크의 노드로 변환하는 소프트웨어 및 하드웨어 통신 프로토콜을 제공합니다.\n\n복잡성 수준이 다른 몇 가지 방법으로 이 작업을 수행할 수 있지만, 현재는 어떤 실험도 하지 않고(적어도 현재는) 게으르기 때문에 브라우저 기반의 USB 플래셔를 사용하기로 선택했습니다.\n\n다행히도 이 프로세스는 원하던 대로 매우 간단했습니다. 단순히 설치하고 싶은 메스타스틱 버전을 선택하고 플래싱하는 것으로 요약됩니다. 그것뿐이에요. 장치에 대한 많은 구성이 있지만, 플래시된 후에는 라디오가 작동하도록 장치가 작동하는 지역을 구성해야 합니다.\n\n구성은 웹 클라이언트, iOS 또는 Android 클라이언트 또는 CLI를 사용하여 설정할 수 있습니다. 블루투스, 무선 또는 시리얼 연결을 받아들입니다. 저는 간단한 텍스트 메시지를 보내기 위해 사용할 것이므로 안드로이드 클라이언트를 설치하고 블루투스로 연결했어요. 이제 첫 번째 작동하는 라디오가 준비되었습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 배터리와 두 번째 라디오\n\n구성 옵션을 몇 분 동안 살펴본 후, 배터리 중 하나를 꽂아 충전할 시간이라고 결정했습니다. 배터리 소켓 앞에 골치 아픈 칩이 위치해 있어서 손가락이 뚱뚱해서 귀찮은 문제를 마주했죠. 소켓 정렬하는 데 고통스러움을 겪었지만 결국 해내서 배터리를 꽂을 수 있었습니다. USB 케이블을 다시 연결하고 완전히 충전될 때까지 약 2시간 동안 충전한 후 검을 뽑고 전원을 끄었습니다.\n\n![이미지](/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_6.png)\n\n이제 두 번째 라디오에 대한 라디오 설정을 반복해야 했습니다. 두 번째 시도 때는 확실히 빨랐어요. 금방 충전했습니다. 두 장치 간에 작은 텍스트 메시지를 주고받도록 실험한 뒤 결국 핸드폰의 GPS 위치를 라디오와 공유하는 방법을 찾았습니다. 그래서 통신하는 노드와의 거리를 나타내는 작은 화살표가 보이게 했습니다. 정확하지는 않지만 귀엽고, 내가 배에서 얼마나 떨어져 있는지 알고 싶을 때 유용할 것 같았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_7.png\" /\u003e\n\n# 실험 시간입니다\n\n집 안에서 간단히 살펴 보았지만, 실제 실험이 시작되는 것은 케이스가 도착하고 범위 테스트를 시작할 수 있는 때입니다. 희망적으로 케이스가 도착하면 다음 주에 그에 대한 보고를 할 수 있을 것입니다.\n데이터가 있으면 설정과 설명에 대해 자세히 이야기할 예정입니다.","ogImage":{"url":"/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_0.png"},"coverImage":"/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_0.png","tag":["Tech"],"readingTime":5},{"title":"CH340 칩이 탑재된 비공식 Arduino 클론에서 Arduino IDE 사용하는 방법","description":"","date":"2024-06-23 17:35","slug":"2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip","content":"\n\n사용되지 않는 Arduino 복제품의 예측할 수 없는 세계로 한 발 들어보세요\n\n![image](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_0.png)\n\n아두이노는 많은 DIY 프로젝트에 매우 인기가 높은 플랫폼이며 오픈 디자인 덕분에 많은 비공식 복제품이 있습니다. 그중 일부는 원래 아두이노 디자인을 완전히 복제하고 있지만, 일부는 더 저렴하게 만들려고 노력하고 있습니다.\n\n![image](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 비공식 아두이노 Uno R3 클론을 구매하고 Windows 기기에 연결했을 때 \"USB 장치를 인식하지 못했습니다\" 오류가 발생했다면, 이 기사가 도움이 될 것입니다. 아래에서는 공식 및 일부 비공식 아두이노 보드 간의 차이와 일부 비공식 보드가 Windows에서 인식되기 위해 설치해야 하는 것에 대해 살펴보겠습니다.\n\n## USB 어댑터\n\n우선, 아래에서 공식 아두이노 UNO R3를 살펴보겠습니다:\n\n![아두이노 UNO R3 이미지](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 사진의 칩 넘버 1은 아두이노의 두뇌입니다: 이것은 ATmega328P로, 아두이노 IDE를 통해 프로그래밍합니다. 이것이 보드의 핵심이며, 이 칩은 모든 스케치를 실행시킵니다 — CPU, 메모리를 포함하고 아두이노 핀들을 모두 제어합니다.\n\n하지만 더 자세히 살펴보면, 이 보드에 실제로 다른 칩이 하나 더 있음을 알 수 있습니다. 번호가 매겨진 칩은 2입니다. 이것은 ATmega16U2이며 이 보드에서 유일한 역할은 USB to 시리얼 변환기로서 일합니다. 다시 말해 — 이것은 이 보드에 USB 연결성을 제공하고 컴퓨터 USB 포트와 아두이노 시리얼 포트 사이의 다리 역할을 합니다.\n\n그러니까, 본질적으로 원래 아두이노 보드에 USB를 꼽으면 실제로 ATmega16U2로 꽂히게 되고, 이것이 컴퓨터에 통신하여 운영 체제가 인식하고 설치된 드라이버 목록에서 해당 드라이버를 로드합니다. 그런 다음 드라이버가 시스템에 새로운 COM 포트를 등록하고, 아두이노를 프로그래밍할 때 아두이노 IDE에서 선택할 수 있습니다. 아래 스크린샷을 보면 올바른 포트가 해당되는 이름으로 표시될 것임을 주의하세요 — 목적에 따라 드라이버가 수행하는지 아니면 ATmega16U2 칩의 펌웨어가 수행하는지는 확실하지 않습니다. 알고 계신다면 코멘트로 알려주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 위에서 설명한 모든 것은 공식 아두이노 Uno R3 보드에 대해서만 해당되며, 비공식 보드에는 항상 그렇지 않을 수 있습니다. 그러나 일부 비공식 보드는 아두이노의 완벽한 복제품이며, 보드 색상과 로고만 다를 뿐입니다.\n\n![이미지](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_4.png)\n\n이 Elegoo UNO R3 보드를 살펴보세요: 원본 아두이노 보드와 동일한 칩을 쉽게 찾을 수 있습니다. 보드 상에서 가장 큰 칩은 ATmega328P이며, TX 및 RX LED 옆 왼쪽에 있는 작은 칩은 ATmega16U2입니다. 따라서 Windows 드라이버에서 이 보드는 원본과 정확히 동일하게 보입니다. 드라이버는 동일한 ATmega16U2 칩과 통신하기 때문에 Arduino IDE에서 인식되어 정상적으로 작동할 것입니다.\n\n## CH340G 칩이 장착된 비공식 보드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 Windows에서 인식하지 않는 일부 비공식 보드도 있습니다. 따라서 장치가 종료됩니다. COM 포트가 표시되지 않으며 결과적으로 Arduino IDE에서 이러한 보드를 사용할 수 없습니다. COM 포트가 없으면 통신 방법이 없으므로 스케치를 업로드할 수 없습니다.\n\n![이미지](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_5.png)\n\n이 보드를 살펴보겠습니다. 첫눈에 차이점을 볼 수 있습니다. ATmega328P가 어디로 사라졌나요?! 걱정하지 마세요. 여기 있습니다. 이 그림에서 번호로 표시된 것입니다. 네, 훨씬 작아졌습니다. 하지만 동일한 칩이며, 다른 케이스로 포장되었습니다. 시각적으로 큰 차이가 있더라도 내부에는 여전히 동일한 ATmega328P가 있으므로 모든 스케치가 정확히 동일한 방식으로 작동할 것입니다.\n\n진짜 차이점은 번호로 표시된 칩에 있습니다. 공식 아두이노에서 ATmega16U2가 있었던 위치에, 이 보드에는 CH340G가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**CH340**은 USB-시리얼 변환기로 기능하는 전용 칩 시리즈입니다. 이 고도로 전문화된 특성으로 인해 공식 보드에 사용된 강력하고 다용도인 ATmega16U2보다 간단하고 더 저렴합니다. 그러나 이 ATmega16U2의 모든 잠재적인 성능과 가능성이 공식 보드에서는 소홀히 다뤄지므로 이 칩이 장착되어 있더라도 그 잠재력은 활용되지 않습니다. 따라서 전반적인 성능과 아두이노 보드의 기능 면에서는 USB-시리얼 어댑터로 어떤 칩이 사용되든 차이를 거의 느끼지 못할 것입니다.\n\n## CH340 드라이버\n\n하지만 CH340에는 한 가지 문제가 있습니다: Windows에는 이를 위한 내장 드라이버가 없습니다. 엄밀히 말하면 이는 CH340의 문제가 아니라 Windows의 문제이지만, 우리 사용자들에게는 모두 같은 문제입니다. 이 보드를 USB에 연결하면 Windows가 \"USB 장치 인식 안됨\"이라는 내용으로 오류를 표시하고 해당 보드에 대한 COM 포트가 생성되지 않을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제 해결은 매우 간단해요 — 그냥 올바른 드라이버를 설치하세요!\n\n- 단계 1: 드라이버를 찾아보세요. “Arduino CH340 driver”를 구글에 검색하면 많은 링크가 나올 거예요. 저에게는 구글에서 첫 번째로 나온 것이 있는데, 이 링크 외에도 다른 링크를 사용해도 됩니다. 이 드라이버는 여러 곳에서 사용 가능해요.\n- 단계 2: 파일을 임시 위치에 압축을 푼 다음 설치 프로그램을 실행하세요.\n- 단계 3: Arduino 보드를 연결하고 장치 관리자에서 새 COM 포트를 확인하세요. 아래 그림에서는 COM3인데, 여러분의 컴퓨터에선 다른 포트 번호를 사용할 수 있어요.\n\n![이미지](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_7.png)\n\n- 단계 4: Arduino IDE에서 올바른 포트를 선택하세요. 이번에는 “Arduino Uno”와 같이 레이블이 아니라 포트 번호로 표시될 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Image](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_8.png)\n\n## 끝\n\nCH340는 Arduino 클론뿐만 아니라 많은 다른 보드에서도 사용됩니다. 따라서 이 드라이버는 언젠가는 어쩌면 바로 필요할 지도 모릅니다.\n\n호기심을 갖고 다른 Arduino 클론을 시도해보세요 (가격이 싸요!) 그리고 즐겁게 즐기세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 자료\n\n- CH340 드라이버는 [여기](https://sparks.gogo.co.nz/ch340.html)에서 다운로드할 수 있어요. 하지만 다양한 다른 위치에서도 이용 가능하니, 구글에서 검색해보세요!","ogImage":{"url":"/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_0.png"},"coverImage":"/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_0.png","tag":["Tech"],"readingTime":5},{"title":"Proteus와 Arduino IDE를 사용하여 벽돌깨기 게임 만드는 방법","description":"","date":"2024-06-23 17:33","slug":"2024-06-23-CreatingaBrick-BreakingGameUsingProteusandArduinoIDE","content":"\n\n본문에서 프로테우스와 아두이노 IDE를 사용하여 벽돌 깨기 게임을 만들어 보겠습니다. 필요한 절차를 단계별로 공유할 예정이에요. 시뮬레이션에서의 게임 모습은 다음과 같을 거에요.\n\n![게임 이미지](/assets/img/2024-06-23-CreatingaBrick-BreakingGameUsingProteusandArduinoIDE_0.png)\n\n우선 내용을 간단히 설명해보려고 해요.\n\n## 시작 화면 및 메뉴 옵션:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 사용자에게 시작 화면이 표시됩니다. 이 화면에는 \"시작\" 및 \"종료\" 옵션이 포함되어 있습니다. 사용자는 버튼을 사용하여 이 옵션들 사이를 이동하고, \"선택\" 버튼으로 선택을 집니다.\n\n## 게임 시작 및 종료 절차:\n\n사용자가 \"시작\" 옵션을 선택하면 게임 화면이 열리고 게임이 시작됩니다. \"종료\" 옵션이 선택된 경우 \"저희 게임에 관심 가져 주셔서 감사합니다\"와 같은 메시지가 화면에 표시됩니다.\n\n## 패들 조절:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n게임이 시작되면 사용자가 제어하는 패들이 포텐티오미터로 좌우로 움직입니다.\n\n**공의 움직임과 벽돌 파괴:**\n\n위에 위치한 패들에 의해 이뤄지는 공이 벽돌에 부딪혀 파괴됩니다. 동시에 공은 오른쪽, 왼쪽, 그리고 위쪽 벽에 부딪힐 때 방향을 바꿉니다.\n\n**점수 계산 절차:**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매 벽돌이 깨질 때마다 플레이어의 점수가 1점씩 올라갑니다. 이 점수는 플레이어의 성과를 추적하는 데 사용됩니다.\n\n## 체력 게이지:\n\n게임이 시작될 때 각 플레이어는 3개의 목숨을 가지고 있습니다. 공이 팔레트에서 빠져 떨어질 때마다 플레이어의 체력이 감소합니다. 목숨은 LED로 사용자에게 표시됩니다.\n\n## 특별 아이템 및 체력 증가:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매번 벽돌이 깨질 때마다 특별한 물건이 10%의 확률로 떨어집니다. 이 물건을 받은 플레이어는 체력이 1 증가합니다. 이 상태는 LED 표시기로 동시에 표시됩니다.\n\n## 배경색 변경:\n\n게임의 배경과 벽돌의 색상은 빛 센서가 감지한 빛의 양에 따라 변합니다. 빛이 켜지면 배경은 흰색이 되고 벽돌은 검은색이 됩니다.\n\n## 레벨 변화와 속도 증가:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매 레벨을 클리어할 때마다 벽돌 배치가 변경되고, 공의 속도도 이전 라운드 대비 20% 증가합니다.\n\n## 게임 종료:\n\n모든 목숨을 소진하면, 플레이어의 점수가 화면에 출력되고 그 후에 메뉴로 이동됩니다.\n\n## 시뮬레이션에 필요한 도구들:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 아두이노 Uno\n- Oled 스크린\n- 버튼\n- LED\n- 가변 저항\n- 7 세그먼트 디스플레이\n- 광 센서\n\n프로테우스에 위의 부품들을 추가하고 필요한 곳에 사용해야 합니다.\n\n이제 프로젝트를 자세히 설명하겠습니다.\n\n## 라이브러리 및 정의:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 섹션에서는 사용할 라이브러리와 상수들이 정의되어 있습니다.\n\n화면에 사용할 벽돌, 패들, 공, 및 객체들의 크기와 값을 여기에서 지정합니다.\n\n```js\n#include \u003cWire.h\u003e\n#include \u003cAdafruit_GFX.h\u003e\n#include \u003cAdafruit_SSD1306.h\u003e     \n#include \u003cSPI.h\u003e\n\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\n#define SCREEN_ADDRESS 0x3D\n#define OLED_RESET 1 \n\n#define BRICK_WIDTH 31\n#define BRICK_HEIGHT 10\n#define BRICK_GAP_X 1\n#define BRICK_GAP_Y 1\n#define NUM_BRICKS_X 4\n#define NUM_BRICKS_Y 2\n\n#define PADDLE_WIDTH 40 \n#define PADDLE_HEIGHT 3\n#define PADDLE_SPEED 5 \n\n#define BALL_SIZE 2\n#define BALL_SPEED_X 3 \n#define BALL_SPEED_Y 3 \n\n#define OBJECT_SIZE 7\n#define OBJECT_SPEED 2\n\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, \u0026Wire, OLED_RESET);\n\nint paddlePosition = 50;\nint paddleDirection = 0; // 패들 이동 방향을 유지합니다: -1 왼쪽, 1 오른쪽, 0 가만히\nint ballPositionX ;\nint ballPositionY;\nint ballDirectionX;\nint ballDirectionY;\n\n// 7 세그먼트 디스플레이 핀 연결\nconst int segmentPins[] = {2,3,4,5,6,7,8,9};\n\n// 버튼 핀 연결\nconst int upButton = 10;\nconst int downButton = 11;\nconst int selectButton = 12;\n\nint counter = 0;\nint score = 0;\nint menu = 1;\nint currentLevel = 1;\n\nint ballSpeedX = BALL_SPEED_X;\nint ballSpeedY = BALL_SPEED_Y;\n\n// 각 벽돌의 상태를 추적하는 2D 배열 정의\nbool bricks[NUM_BRICKS_Y][NUM_BRICKS_X];\n\n// 각 레벨별 벽돌 레이아웃 정의\nconst int levelBricksLayouts[][NUM_BRICKS_Y][NUM_BRICKS_X] = {\n  // 레벨 1\n  {\n    {1,1,1,1},\n    {1,1,1,1}\n  },\n  // 레벨 2\n  {\n    {1,0,1,0},\n    {0,1,0,1}\n  },\n  // 레벨 3\n  {\n    {1,1,0,1},\n    {0,1,1,0}\n  },\n  // 레벨 4\n  {\n    {1,0,0,1},\n    {0,1,1,0}\n  },\n  // 레벨 5\n  {\n    {1,0,1,0},\n    {0,1,0,1}\n  }\n};\n\nint lives = 3; \nconst int lifeLEDs[] = {13,A2,A3}; \n\nbool objectActive = false;\nint objectX, objectY;\n\nuint16_t backgroundColor, brickColor, paddleColor, ballColor, objectColor;\r\n```\n\n## 설정 함수:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n설정 함수는 초기 설정을 수행합니다. 화면 초기화, 입력/출력 핀 설정, 메뉴 표시 등의 작업이 여기서 수행됩니다.\n\n```js\nvoid setup() {\n  display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS);\n  \n  display.clearDisplay();\n  display.display();\n  display.setTextColor(SSD1306_WHITE, SSD1306_BLACK);\n\n  // 포텐셔미터 핀을 입력으로 설정\n  pinMode(A0, INPUT);\n\n  for(int i = 0; i\u003c8; i++) {\n    pinMode(segmentPins[i], OUTPUT);\n  }\n\n  // 버튼 핀을 입력으로 설정\n  pinMode(upButton, INPUT);\n  pinMode(downButton, INPUT);\n  pinMode(selectButton, INPUT);\n\n  digitalWrite(upButton, HIGH);\n  digitalWrite(downButton, HIGH);\n  digitalWrite(selectButton, HIGH);\n  delay(1000);\n  updateMenu();\n\n  // 초기에 모든 벽을 솔리드로 설정\n  for (int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n    for (int j = 0; j \u003c NUM_BRICKS_X; j++) {\n      bricks[i][j] = true;\n    }\n  }\n\n  for(int i = 0; i\u003c3; i++) {\n    pinMode(lifeLEDs[i], OUTPUT);\n  }\n\n  // 광센서의 핀을 입력으로 설정\n  pinMode(A1, INPUT);\n}\n```\n\n## 루프 함수:\n\n이 함수는 버튼 상태를 확인하고 필요한 기능을 제공합니다. 각 사이클마다 7세그먼트 디스플레이에 카운터의 값을 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n## 숫자 표시 함수:\n\n이 함수는 7세그먼트 디스플레이에 특정 숫자를 표시하는 데 사용됩니다. 이 숫자는 0에서 9 사이여야 합니다.\n\n```js\nvoid displayNumber(int num) {\n  const int numbers[][8] = {\n    {1,1,1,1,1,1,0,0}, //0\n    {0,1,1,0,0,0,0,0}, //1\n    {1,1,0,1,1,0,1,0}, //2\n    {1,1,1,1,0,0,1,0}, //3\n    {0,1,1,0,0,1,1,0}, //4\n    {1,0,1,1,0,1,1,0}, //5\n    {1,0,1,1,1,1,1,0}, //6\n    {1,1,1,0,0,0,0,0}, //7\n    {1,1,1,1,1,1,1,0}, //8\n    {1,1,1,1,0,1,1,0}  //9\n  };\n\n  for(int i = 0; i\u003c8; i++) {\n    digitalWrite(segmentPins[i], numbers[num][i]);\n  } \n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메뉴 업데이트 기능:\n\n이 함수는 메뉴를 업데이트하는 데 사용됩니다. 사용자가 선택한 메뉴를 강조합니다.\n\n```js\nvoid updateMenu() {\n  switch(menu) {\n    case 0:\n      menu = 1;\n      break;\n    case 1:\n      display.clearDisplay();\n      display.setCursor(0,0);\n      display.println(\"\u003e 시작\");\n      display.setCursor(0,10);\n      display.println(\"  종료\");\n      display.display();\n      break;\n    case 2:\n      display.clearDisplay();\n      display.setCursor(0,0);\n      display.println(\"  시작\");\n      display.setCursor(0,10);\n      display.println(\"\u003e 종료\");\n      display.display();\n      break;\n    case 3:\n      menu = 2;\n      break;\n  }\n}\n```\n\n## 동작 실행 함수:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 선택한 작업을 수행하는 함수입니다. 시작 및 종료 옵션에 따라 서로 다른 작업을 수행합니다.\n\n```js\nvoid executeAction() {\n  switch(menu) {\n    case 1:\n      action1();\n      break;\n    case 2:\n      action2();\n      break;\n    default:\n      break;\n  }\n}\n\n// 시작 작업\nvoid action1() {\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  playGame();\n  display.display();\n  delay(1500);\n}\n\n// 종료 작업\nvoid action2() {\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.print(\"Thank you for your interest in our game....\");\n  display.display();\n  delay(1500);\n}\n```\n\n## 벽돌 그리기 함수:\n\n게임 화면에 벽돌을 그리는 함수입니다. 특정 색상의 벽돌을 그립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvoid drawBricks(uint16_t color) {\n  for(int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n    for(int j = 0; j \u003c NUM_BRICKS_X; j++) {\n      int brickX = j * (BRICK_WIDTH + BRICK_GAP_X);\n      int brickY = i * (BRICK_HEIGHT + BRICK_GAP_Y);\n      if (bricks[i][j]) { // Only draw solid bricks\n        display.fillRect(brickX + 1, brickY + 1, BRICK_WIDTH - 1, BRICK_HEIGHT - 1, color);\n      }\n    }\n  }\n}\n```\n\n## 패들 그리기, 삭제 및 업데이트 기능:\n\n```js\n// 화면에 패들을 그리는 함수\nvoid drawPaddle(uint16_t color) {\n  display.fillRect(paddlePosition, display.height() - PADDLE_HEIGHT - 2, PADDLE_WIDTH, PADDLE_HEIGHT, color);\n}\n\n// 이전 패들 위치를 지우는 함수\nvoid clearPaddle() {\n  display.fillRect(paddlePosition, display.height() - PADDLE_HEIGHT - 2, PADDLE_WIDTH, PADDLE_HEIGHT, SSD1306_BLACK);\n}\n\n// 패들의 위치를 포텐셔미터에서 받은 데이터에 따라 업데이트하는 함수\nvoid updatePaddle() {\n  int potValue = analogRead(A0);\n\n  paddlePosition = map(potValue, 0, 1023, 0, display.width() - PADDLE_WIDTH);\n}\n```\n\n## 공 그리기, 삭제 및 업데이트 기능:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 화면에 공을 그리는 함수\nvoid drawBall(uint16_t color) {\n  display.fillCircle(ballPositionX, ballPositionY, BALL_SIZE, color);\n}\n\n// 이전 공 위치를 지우는 함수\nvoid clearBall() {\n  display.fillCircle(ballPositionX - ballDirectionX * BALL_SPEED_X, ballPositionY - ballDirectionY * BALL_SPEED_Y, BALL_SIZE, SSD1306_BLACK);\n}\n\n// 공의 위치와 움직임을 업데이트하는 함수\nvoid updateBall() {\n  ballPositionX += ballDirectionX * ballSpeedX;\n  ballPositionY += ballDirectionY * ballSpeedY;\n\n  // 왼쪽 가장자리 충돌 확인 및 방향 전환\n  if(ballPositionX \u003c= 0) {\n    ballDirectionX *= -1;\n  } \n  // 오른쪽 가장자리 충돌 확인 및 방향 전환\n  else if(ballPositionX \u003e= display.width() - BALL_SIZE) {\n    ballDirectionX *= -1;\n  }\n\n  // 위쪽 가장자리 충돌 확인\n  if(ballPositionY \u003c= 0) {\n    ballDirectionY *= -1;\n  } \n\n  checkPaddleCollision();\n\n  // 아래쪽 가장자리 충돌 확인\n  if(ballPositionY \u003e= display.height()) {\n    loseLife();\n  }\n}\r\n```\n\n## 생명과 생명을 잃은 상태를 보여주는 함수:\n\n```js\r\n// 사용자의 생명을 표시하는 함수\nvoid displayLives() {\n  for (int i = 0; i \u003c 3; i++) {\n    digitalWrite(lifeLEDs[i], i \u003c lives ? HIGH : LOW); // 건강 상태에 따라 LED 켜기/끄기\n  }\n}\n\n// 사용자의 생명을 잃는 상황을 처리하는 함수\nvoid loseLife() {\n  lives--;\n  for (int i = 0; i \u003c 3; i++) {\n    digitalWrite(lifeLEDs[i], i \u003c lives ? HIGH : LOW); // 건강 상태에 따라 LED 켜기/끄기\n  }\n\n  // 사용자가 건강 상태가 낮을 때 공을 트랙 위에 시작하도록 함\n  delay(100);\n  ballPositionX = paddlePosition + PADDLE_WIDTH / 2;\n  ballPositionY = display.height() - PADDLE_HEIGHT - BALL_SIZE - 3;\n  ballDirectionX = 0;\n  ballDirectionY = 0;\n  displayLives();\n  objectActive = false;\n  display.fillRect(objectX, objectY, OBJECT_SIZE, OBJECT_SIZE, SSD1306_BLACK);\n  delay(100); \n}\r\n```\n\n## 패들과 공의 충돌 함수: \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n볼이 패들에 닿았는지 확인하는 함수입니다.\n\n```js\nvoid checkPaddleCollision() {\n    // 패들과 볼의 충돌 확인\n    if (ballPositionY + BALL_SIZE \u003e= display.height() - PADDLE_HEIGHT - BALL_SPEED_Y \u0026\u0026 ballPositionX + BALL_SIZE \u003e= paddlePosition \u0026\u0026 ballPositionX \u003c= paddlePosition + PADDLE_WIDTH) {\n        // 패들의 왼쪽 부분\n        if (ballPositionX \u003c= paddlePosition + PADDLE_WIDTH / 3) {\n            ballDirectionX = -1; // 왼쪽으로 볼 진행\n            ballDirectionY = -1; // 볼의 방향을 위쪽으로 전환\n        }\n        // 패들의 중간 부분\n        else if (ballPositionX \u003c= paddlePosition + 2 * PADDLE_WIDTH / 3) {\n            ballDirectionX = 0; // 볼의 방향을 바꾸지 않음\n            ballDirectionY = 0;\n        }\n        // 패들의 오른쪽 부분\n        else {\n            ballDirectionX = 1; // 오른쪽으로 볼 진행\n            ballDirectionY = -1; // 볼의 방향을 위쪽으로 전환\n        }  \n    }\n}\n```\n\n## 볼이 패들과 충돌하는지 확인하는 함수:\n\n볼이 패들과 충돌하는지 확인하고 true 또는 false를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbool ballHitsPaddle() {\n  // 패들과 공의 충돌 제어\n  if (ballPositionY + BALL_SIZE \u003e= display.height() - PADDLE_HEIGHT - BALL_SPEED_Y \u0026\u0026 ballPositionX + BALL_SIZE \u003e= paddlePosition \u0026\u0026 ballPositionX \u003c= paddlePosition + PADDLE_WIDTH) {\n    return true;\n  } else {\n    return false;\n  }\n}\n```\n\n## 객체 그리기, 업데이트 함수:\n\n```js\n// 화면에 특별한 객체를 그리는 함수\nvoid drawObject(uint16_t color) {\n  display.fillRect(objectX, objectY, OBJECT_SIZE, OBJECT_SIZE, color);\n}\n\n// 특별한 객체의 위치를 업데이트하는 함수\nvoid updateObject() {\n  // 객체가 활성화되어 있고 화면 아래로 떨어지는 방향으로 이동하지 않으면 이동\n  if (objectActive \u0026\u0026 objectY \u003c display.height() - OBJECT_SIZE) {\n    // 객체 지우기\n    display.fillRect(objectX, objectY, OBJECT_SIZE, OBJECT_SIZE, SSD1306_BLACK);\n    // 새로운 위치 업데이트\n    objectY += OBJECT_SPEED;\n\n    // 플레이어가 객체를 잡았을 경우\n    if (objectY \u003e= display.height() - PADDLE_HEIGHT - OBJECT_SIZE \u0026\u0026 objectX \u003e= paddlePosition \u0026\u0026 objectX \u003c= paddlePosition + PADDLE_WIDTH) {\n      objectActive = false;\n      lives++; // 생명 카운트 증가\n\n      // LED로 생명 수 표시\n      for (int i = 0; i \u003c 3; i++) {\n        digitalWrite(lifeLEDs[i], i \u003c lives ? HIGH : LOW);\n      }\n      display.fillRect(objectX, objectY, OBJECT_SIZE, OBJECT_SIZE, SSD1306_BLACK);\n    }\n\n    // 객체가 화면 하단 가장자리에 도착했을 경우\n    if (objectY \u003e= display.height() - OBJECT_SIZE) {\n      display.fillRect(objectX, objectY, OBJECT_SIZE, OBJECT_SIZE, SSD1306_BLACK);\n    }\n    drawObject(objectColor);\n  }\n}\n```\n\n## 벽돌 충돌 확인:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n볼이 벽돌에 충돌하는지 확인합니다.\n\n```js\nvoid checkBrickCollision() {\n  for(int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n    for(int j = 0; j \u003c NUM_BRICKS_X; j++) {\n      if (bricks[i][j]) { // Check to only crash into solid bricks\n        int brickX = j * (BRICK_WIDTH + BRICK_GAP_X);\n        int brickY = i * (BRICK_HEIGHT + BRICK_GAP_Y);\n\n        if (ballPositionX + BALL_SIZE \u003e= brickX \u0026\u0026 ballPositionX \u003c= brickX + BRICK_WIDTH \u0026\u0026 ballPositionY + BALL_SIZE \u003e= brickY \u0026\u0026 ballPositionY \u003c= brickY + BRICK_HEIGHT) {\n          ballDirectionY *= -1; \n          bricks[i][j] = false; // Mark the brick as broken\n          incrementCounter(); // Increase score\n          display.fillRect(brickX + 1, brickY + 1, BRICK_WIDTH - 1, BRICK_HEIGHT - 1, SSD1306_BLACK);\n        \n          // Creating an object every time a brick is broken\n          if(random(100) \u003c 10) { // 10 percent probability of creating an object\n            objectActive = true;\n            objectX = brickX + (BRICK_WIDTH - OBJECT_SIZE) / 2;\n            objectY = brickY + (BRICK_HEIGHT - OBJECT_SIZE) / 2;;\n            drawObject(objectColor);\n          }\n        \n        }\n      }\n    }\n  }\n}\n```\n\n## 다음 레벨 전환 함수:\n\n레벨의 모든 벽돌이 깨졌을 때 다음 레벨로 이동을 허용하는 함수입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvoid nextLevel() {\n  if(currentLevel \u003c 5) {\n    currentLevel++;  \n    // Increase your ball speed by 20% for the next level\n    ballSpeedX += ballSpeedX * 0.2;\n    ballSpeedY += ballSpeedY * 0.2;\n\n    // Reset ball position and direction\n    ballPositionX = paddlePosition + PADDLE_WIDTH / 2;\n    ballPositionY = display.height() - PADDLE_HEIGHT - BALL_SIZE - 3;\n    ballDirectionX = 0;\n    ballDirectionY = 0;\n\n    // Reset bricks\n    for(int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n      for(int j = 0; j \u003c NUM_BRICKS_X; j++) {\n        bricks[i][j] = true;\n      }\n    }\n\n    // Clear screen and reset lives\n    display.clearDisplay();\n    display.setCursor(0, 0);\n    display.print(\"Level \");\n    display.print(currentLevel);\n    display.display();\n    delay(20);\n    playGame();\n  }\n}\n```\n\n## 게임 시작 기능:\n\n게임이 시작될 때와 진행 중인 게임에서 필요한 작업을 제공하는 함수입니다.\n\n```js\nvoid playGame() {\n  // Adjust brick layout depending on level\n  int currentLevelLayout[NUM_BRICKS_Y][NUM_BRICKS_X];\n  for (int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n    for (int j = 0; j \u003c NUM_BRICKS_X; j++) {\n      currentLevelLayout[i][j] = levelBricksLayouts[currentLevel - 1][i][j];\n    }\n  }\n\n  // Reset brick array\n  for (int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n    for (int j = 0; j \u003c NUM_BRICKS_X; j++) {\n      bricks[i][j] = currentLevelLayout[i][j];\n    }\n  }\n\n  ballPositionX = paddlePosition + PADDLE_WIDTH / 2 - 6; \n  ballPositionY = display.height() - PADDLE_HEIGHT - BALL_SIZE - 3;\n  ballDirectionX = 0;\n  ballDirectionY = 0;\n\n  while (lives \u003e 0) {\n    int lightSensorValue = analogRead(A1);\n    if (lightSensorValue \u003c 15) {\n      backgroundColor = SSD1306_BLACK;\n      brickColor = SSD1306_WHITE;\n      paddleColor = SSD1306_WHITE;\n      ballColor = SSD1306_WHITE;\n      objectColor = SSD1306_WHITE;\n    } else { \n      backgroundColor = SSD1306_WHITE;\n      brickColor = SSD1306_BLACK;\n      paddleColor = SSD1306_BLACK;\n      ballColor = SSD1306_BLACK;\n      objectColor = SSD1306_BLACK;\n    }\n  \n    display.fillScreen(backgroundColor);\n\n    clearPaddle();\n    updatePaddle();\n    updateBall();\n    clearBall();\n    drawBricks(brickColor);\n    drawPaddle(paddleColor);\n    drawBall(ballColor);\n    checkBrickCollision();\n    updateObject(); \n    displayNumber(counter);\n    displayLives();\n    display.display();\n    \n    // Reads the potentiometer value and controls the movement of the paddle\n    int potValue = analogRead(A0);\n    int newPaddlePosition = map(potValue, 0, 1023, 0, display.width() - PADDLE_WIDTH);\n    \n    // If you move the paddle the ball starts to move\n    if (newPaddlePosition != paddlePosition \u0026\u0026 ballHitsPaddle()) {\n      // Determine the direction of movement of the paddle\n      if (paddlePosition \u003e 50) {\n        ballDirectionX = -1; // Move right\n      } else if (paddlePosition \u003c 50) {\n        ballDirectionX = 1; // Move left\n      } else {\n        ballDirectionX = 1; // Move left\n      }\n      ballDirectionY = -1; // Make the ball go up\n    }\n    clearPaddle();\n    // Update the position of the palette\n    paddlePosition = newPaddlePosition;\n\n    // Check if all bricks are broken\n    bool allBricksDestroyed = true;\n      for (int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n        for (int j = 0; j \u003c NUM_BRICKS_X; j++) {\n          if (bricks[i][j]) {\n            allBricksDestroyed = false;\n            break;\n          }\n        }\n        if (!allBricksDestroyed) {\n          break;\n        }\n      }\n\n      // If all the bricks are broken go to the next level\n      if (allBricksDestroyed) {\n        display.clearDisplay();\n        display.display();\n        delay(5000);\n        nextLevel();\n        break;\n      }\n  }\n\n  if(lives == 0) {\n    // End game\n    gameOver();\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 게임 종료 함수:\n\n게임이 종료될 때 호출되는 함수입니다.\n\n```js\nvoid gameOver() {\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.println(\"Game Over!\");\n  display.print(\"Score: \");\n  display.print(score);\n  display.display();\n  delay(3000); // 3초 대기\n  // 메인 메뉴로 돌아가기\n  menu = 1;\n  updateMenu();\n  lives = 3;\n}\n```\n\n프로젝트의 모든 코드를 포함한 소스 코드:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n절차 상 표를 마크다운 형식으로 변경하였습니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에 아래 사항을 고려해 주세요:\n\n- 저자를 박수로 응원하고 팔로우하기를 고려해 주세요! 👏\n- 저희를 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- Stackademic.com에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-23-CreatingaBrick-BreakingGameUsingProteusandArduinoIDE_0.png"},"coverImage":"/assets/img/2024-06-23-CreatingaBrick-BreakingGameUsingProteusandArduinoIDE_0.png","tag":["Tech"],"readingTime":17},{"title":"저항 밴드 색상 읽는 방법 쉽게 배우기","description":"","date":"2024-06-23 17:32","slug":"2024-06-23-HowToReadResistorBandColors","content":"\n\n\n![Resistor](/assets/img/2024-06-23-HowToReadResistorBandColors_0.png)\n\n저항은 회로 내의 전기 흐름을 제어하는 데 사용되는 필수 전자 부품입니다. 저항은 옴(Ω)으로 측정되는 저항으로 특징 지어집니다.\n\n![Resistor Color Bands](/assets/img/2024-06-23-HowToReadResistorBandColors_1.png)\n\n저항기의 저항은 저항기 본체의 색 조각을 읽어서 식별할 수 있습니다. 이 기사에서는 4, 5, 6 밴드 저항에 대한 저항기 밴드 색상 읽는 방법에 대해 설명하겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1096/0*He1_5wkKjnFY2Qm5.gif)\n\n비록 이것은 유용한 기술이지만, 매번 이러한 차트를 참조하는 것이 귀찮았습니다. 그래서 나는 무료 iOS 앱을 만들어 이러한 계산을 관리하기로 했어요:\n\n# 4 밴드 저항기 색상 코드\n\n4밴드 저항기에서 첫 두 밴드는 저항 값의 첫 번째와 두 번째 숫자를 나타냅니다. 세 번째 밴드는 배율을 나타내고, 네 번째 밴드는 허용 편차를 나타냅니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4밴드 저항기 색 코드를 읽을 때 따라야 할 단계를 알려드리겠어요:\n\n- 첫 번째 두 밴드의 색과 해당 값을 확인하세요. 저항기 색 코드 차트를 사용해주세요 (위를 참조하세요).\n- 세 번째 밴드의 색을 사용하여 곱수를 결정하세요. 이는 첫 두 자리 수 뒤에 따라오는 0의 개수를 나타냅니다.\n- 다음 공식을 사용하여 저항 값을 계산하세요:\n\n## 저항 (Ω) = (1번째 숫자 값 x 10 + 2번째 숫자 값) x 곱수\n\n그다음으로, 네 번째 밴드의 색을 식별하여 허용 편차를 결정하세요. 허용 편차는 지정된 저항 값에서 허용되는 저항기의 편차를 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5-Band 저항기 색상 코드\n\n5-Band 저항기의 처음 세 개의 밴드는 저항값의 첫 번째, 두 번째 및 세 번째 자리수를 나타냅니다. 네 번째 밴드는 배수기를 나타내며, 다섯 번째 밴드는 허용 편차를 나타냅니다.\n\n다음은 5-Band 저항기 색상 코드를 읽을 때 따라야 할 단계입니다:\n\n- 저항기 색상 코드 차트를 사용하여 처음 세 개의 밴드의 색상과 해당 값을 식별합니다.\n- 네 번째 밴드의 색상을 사용하여 배수기를 결정하십시오. 이는 첫 세 자리 숫자 뒤에 따라오는 0의 개수를 나타냅니다.\n- 다음 공식을 사용하여 저항값을 계산합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 저항 (Ω) = (첫 번째 숫자 값 x 100 + 두 번째 숫자 값 x 10 + 세 번째 숫자 값) x 배율\n\n마지막으로 다섯 번째 밴드의 색으로 공차를 결정합니다.\n\n# 6 밴드 저항기 색코드\n\n6 밴드 저항기의 첫 세 밴드는 저항값의 첫 번째, 두 번째, 세 번째 숫자를 나타냅니다. 네 번째 밴드는 배율을, 다섯 번째 밴드는 공차를, 여섯 번째 밴드는 온도 계수를 나타냅니다. 6밴드 저항기 색코드를 읽을 때 따라야 할 단계는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 저항기 밴드 색상 차트를 사용하여 첫 번째 세 밴드의 색상과 해당 값 식별\n- 네 번째 밴드 색상을 사용하여 0을 뒤따르는 숫자를 나타내는 곱산자 결정\n- 다음 공식을 사용하여 저항값 계산:\n\n## 저항 (Ω) = (1번째 숫자 값 x 100 + 2번째 숫자 값 x 10 + 3번째 숫자 값) x 곱산자\n\n이후, 5번째 밴드의 색상을 식별하여 허용 편차를 결정합니다. 마지막으로, 6번째 밴드의 색상을 식별하여 온도 계수를 결정합니다. 온도 계수는 온도가 변할 때 저항기의 저항 변화를 나타냅니다.\n\n저항기 밴드 색상을 읽는 것은 혼란스러울 수 있지만, 올바른 도구와 지식이 있다면 간단한 작업이 됩니다. 4, 5 또는 6 밴드 저항기를 사용하든, 저항값, 곱산자, 허용 편차 및 온도 계수를 정확히 결정하기 위해 저항기 색상코드 차트를 사용하는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에 제시된 단계를 따라가면 저합리로 저항을 다루고 회로가 의도대로 작동하는지 확인할 수 있어요. 귀찮다면, 저처럼 온라인/모바일 계산기 중 하나를 자유롭게 사용하세요.\n\n일반적으로 iOS 개발에 대해 쓰지만, 최근에 부수적으로 전기 공학 프로젝트를 탐색하고 있어요.\n\n전통적인 프로그래밍보다 더 즐겁다고 느끼고 있어요.\n\n소프트웨어가 작동하는 만족감을 경험할 뿐만 아니라, 하드웨어가 올바르게 작동하는 것을 볼 수 있는 추가적인 혜택도 얻을 수 있어요. 두 가지가 매끄럽게 동작할 때, 이 느낌은 전혀 다른 만족감을 줘요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n누가 알겠어요, 아마 나의 미래에는 직업 전환이 있을지도 몰라요...\n\n저항체 밴드 색상을 읽는 것은 전자제품을 다루는 사람에게 필수적인 기술이에요. 이 글에서는 저항체 색상 밴드를 사용하는 방법에 대해 간단히 소개할 거예요. 초보자이든 경험 많은 엔지니어이든, 저항체 밴드 코드를 이해하는 것은 정확하고 효율적인 회로를 구축하는 데 중요해요.","ogImage":{"url":"/assets/img/2024-06-23-HowToReadResistorBandColors_0.png"},"coverImage":"/assets/img/2024-06-23-HowToReadResistorBandColors_0.png","tag":["Tech"],"readingTime":3},{"title":"FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법","description":"","date":"2024-06-23 17:31","slug":"2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup","content":"\n\n\n![Image](/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png)\n\n웹 소프트웨어 엔지니어인 저와 같은 경우에는 실시간 프로그래밍 개념을 이해하기 어려울 수 있습니다. \n이 짧은 기사에서는 여러 멀티스레딩 작업의 완료를 기다리기 위한 세마포어 패턴을 구현하는 쉬운 기술을 소개하겠습니다.\n\n# 정의\n\n- FreeRTOS 작업\nFreeRTOS 작업은 FreeRTOS 실시간 운영 체제 내에서 실행되는 작고 독립적인 프로그램 세그먼트입니다. 각 작업은 특정 작업을 수행하도록 설계되었으며 FreeRTOS 스케줄러에 의해 관리되는 다른 작업과 준동시에 작동합니다. FreeRTOS의 작업은 우선 순위를 부여할 수 있어, 스케줄러가 작업 우선 순위에 따라 실행 흐름을 관리하고 시간에 민감한 작업을 효과적으로 처리할 수 있게 합니다. 이를 통해 응용 프로그램은 여러 작업 간에 작업을 나누어 다루므로 다양한 응용 프로그램 요구 사항을 처리할 수 있습니다.\n\n- 카운팅 세마포어\nFreeRTOS의 카운팅 세마포어는 공유 리소스에 대한 액세스를 관리하거나 가용성에 따라 작업을 동기화하는 동기화 메커니즘입니다. 두 가지 상태만을 갖는 이진 세마포어와 달리 카운팅 세마포어는 가용 리소스의 개수나 이벤트가 발생하기 전에 실행 흐름을 차단/해제하는 횟수를 나타내는 값을 유지합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# TL;DR — The code\n\n데모 코드는 \"xTaskCreate\"를 사용하여 세 가지 작업을 실행하며 \"xEventGroupCreate\"로 생성된 이벤트 그룹을 사용하여 카운팅 세마포어를 구현합니다. 메인 작업은 생성된 모든 작업이 실행된 후에만 종료되도록 기다립니다.\n\n```js\n#include \u003cArduino.h\u003e\n\n// 카운팅 세마포어를 구현하는 그룹 핸들\nstatic EventGroupHandle_t eventGroup;\n\n// 각 작업에 대한 비트 마스크 정의\nconst EventBits_t TASK_1_BIT = (1 \u003c\u003c 0); // 00000001\nconst EventBits_t TASK_2_BIT = (1 \u003c\u003c 1); // 00000010\nconst EventBits_t TASK_3_BIT = (1 \u003c\u003c 2); // 00000100\n\nvoid taskFunction(void *pvParameters) {\n    int taskNumber = ((int)pvParameters);\n    // 작업 번호를 기반으로 설정할 비트 계산\n    EventBits_t taskBit = (1 \u003c\u003c (taskNumber - 1));\n\n    for(int i = 0; i \u003c 5; i++) {\n        Serial.printf(\"Task %d is executing...\\n\", taskNumber);\n        vTaskDelay(pdMS_TO_TICKS(1000)); // 작업 활동 시뮬레이션\n    }\n\n    // 이 작업을 위해 이벤트 그룹에 적합한 비트 설정\n    Serial.printf(\"Task %d completed and bit set.\\n\", taskNumber);\n    xEventGroupSetBits(eventGroup, taskBit);\n    // 완료되면 이 작업 삭제\n    vTaskDelete(NULL);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    while (!Serial);\n\n     // 이벤트 그룹 생성\n    eventGroup = xEventGroupCreate();\n    if (eventGroup == NULL) {\n        Serial.println(\"이벤트 그룹 생성 실패. 힙 부족일 수 있습니다.\");\n        return;\n    }\n\n    // 작업에 전달할 매개변수, 작업 번호를 나타냄\n    static int taskParams[3] = {1, 2, 3};\n    for (int i = 0; i \u003c 3; i++) {\n        xTaskCreate(\n            taskFunction,            // 작업 함수\n            \"Task\",                  // 작업 이름\n            2048,                    // 스택 크기\n            \u0026taskParams[i],          // 매개변수 (작업 번호)\n            1,                       // 우선순위\n            NULL                     // 사용하지 않는 작업 핸들\n        );\n    }\n\n    // 모든 작업이 비트를 설정할 때까지 기다림\n    Serial.println(\"작업 완료 대기 중...\");\n    xEventGroupWaitBits(\n        eventGroup,                          // 테스트할 이벤트 그룹.\n        TASK_1_BIT | TASK_2_BIT | TASK_3_BIT, // 기다릴 이벤트 그룹 내 비트.\n        pdTRUE,                              // 종료 시 비트 지우기.\n        pdTRUE,                              // 모든 비트를 기다림.\n        portMAX_DELAY                        // 무기한 대기.\n    );\n\n    Serial.println(\"모든 작업 완료됨.\");\n    // 이벤트 그룹 정리\n    vEventGroupDelete(eventGroup);\n}\n\nvoid loop() {}\n```\n\n# 자세한 설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이벤트 그룹 핸들이 선언되었습니다.\n\n```js\n// 카운팅 세마포어를 구현하는 그룹 핸들\nstatic EventGroupHandle_t eventGroup;\n```\n\n- 각 작업은 숫자 ID에 연결되며, 이는 비트 시퀀스의 인덱스를 나타냅니다. 작업이 완료되었는지 확인하는 데 세 개의 비트 마스크가 사용됩니다.\n\n```js\n// 각 작업을 위한 비트 마스크 정의\nconst EventBits_t TASK_1_BIT = (1 \u003c\u003c 0); // 00000001\nconst EventBits_t TASK_2_BIT = (1 \u003c\u003c 1); // 00000010\nconst EventBits_t TASK_3_BIT = (1 \u003c\u003c 2); // 00000100\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 주요 작업은 작업 번호를 매개변수로 전달하여 세 가지 작업을 생성합니다.\n\n```js\n// 작업에 전달할 매개변수, 작업 번호를 나타냄\nstatic int taskParams[3] = {1, 2, 3};\nfor (int i = 0; i \u003c 3; i++) {\n    xTaskCreate(\n        taskFunction,            // 작업 함수\n        \"Task\",                  // 작업 이름\n        2048,                    // 스택 크기\n        \u0026taskParams[i],          // 매개변수 (작업 번호)\n        1,                       // 우선 순위\n        NULL                     // 작업 핸들은 사용하지 않음\n    );\n}\n```\n\n- 작업 번호는 \"EventBits_t\" 변수를 생성하는 데 사용되며 해당하는 양 만큼 비트를 왼쪽으로 이동시킵니다.\n\n```js\nint taskNumber = ((int)pvParameters);\n// 작업 번호를 기반으로 설정할 비트를 계산\nEventBits_t taskBit = (1 \u003c\u003c (taskNumber - 1));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작업이 완료되면 그룹에 신호를 보내고 자체를 삭제합니다.\n\n```js\n// 이벤트 그룹에서이 작업에 대한 적절한 비트 설정\nSerial.printf(\"작업 %d가 완료되었고 비트가 설정되었습니다.\\n\", taskNumber);\nxEventGroupSetBits(eventGroup, taskBit);\n// 완료되면이 작업 삭제\nvTaskDelete(NULL);\n```\n\n- 주 작업은 비트 마스크를 사용하여 그룹 내 세 개의 비트가 1로 설정될 때까지 기다리고 즉시 실행을 다시 시작합니다.\n\n```js\n// 모든 작업이 비트를 설정 할 때까지 대기\nSerial.println(\"작업이 완료 될 때까지 대기 중 ...\");\nxEventGroupWaitBits(\n    eventGroup,                          // 테스트되는 이벤트 그룹.\n    TASK_1_BIT | TASK_2_BIT | TASK_3_BIT, // 대기해야 하는 이벤트 그룹 내의 비트.\n    pdTRUE,                              // 종료시 비트 지우기.\n    pdTRUE,                              // 모든 비트를 대기합니다.\n    portMAX_DELAY                        // 무기한 대기.\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 마침내 이벤트 그룹이 삭제되었습니다.\n\n```js\nSerial.println(\"모든 작업이 완료되었습니다.\");\n// 이벤트 그룹 정리\nvEventGroupDelete(eventGroup);\n```\n\n# 결론\n\n이 유용한 기술은 FreeRTOS 기능만을 사용하여 동기화를 강제하는 간단한 방법입니다. 따라서 무분별한 코드 부하를 피할 수 있습니다. 여러분의 프로젝트에 유용하게 활용하시기를 바랍니다. 읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png"},"coverImage":"/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png","tag":["Tech"],"readingTime":5}],"page":"15","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"15"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>