<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/103" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/103" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_buildManifest.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="리눅스의 Crontab 오래된 파일 삭제 일정 설정 초보자 가이드" href="/post/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리눅스의 Crontab 오래된 파일 삭제 일정 설정 초보자 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리눅스의 Crontab 오래된 파일 삭제 일정 설정 초보자 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">리눅스의 Crontab 오래된 파일 삭제 일정 설정 초보자 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="쉘 스크립팅" href="/post/2024-06-19-ShellScripting"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="쉘 스크립팅" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-ShellScripting_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="쉘 스크립팅" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">쉘 스크립팅</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="도커는 실제로 어떻게 작동하나요 하드웨이 포괄적인 기술적 심층 탐구" href="/post/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="도커는 실제로 어떻게 작동하나요 하드웨이 포괄적인 기술적 심층 탐구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="도커는 실제로 어떻게 작동하나요 하드웨이 포괄적인 기술적 심층 탐구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">도커는 실제로 어떻게 작동하나요 하드웨이 포괄적인 기술적 심층 탐구</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">34<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="러스트 배우기 베어 쓰레딩" href="/post/2024-06-19-LearningRustBareThreading"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="러스트 배우기 베어 쓰레딩" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-LearningRustBareThreading_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="러스트 배우기 베어 쓰레딩" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">러스트 배우기 베어 쓰레딩</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">50<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Portainer로 Docker 관리를 간단히 하기" href="/post/2024-06-19-SimplifyDockerManagementwithPortainer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Portainer로 Docker 관리를 간단히 하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Portainer로 Docker 관리를 간단히 하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Portainer로 Docker 관리를 간단히 하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="개인정보 보호, 정치, 그리고 포르노" href="/post/2024-05-27-Privacypoliticsandporn"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="개인정보 보호, 정치, 그리고 포르노" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-Privacypoliticsandporn_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="개인정보 보호, 정치, 그리고 포르노" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">개인정보 보호, 정치, 그리고 포르노</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="슈프림 코트의 슈퍼매이져리티는 2024년 대통령 선거에서 조 바이든을 지지해야 하는 주요한 이유입니다" href="/post/2024-05-27-TheSupermajorityontheSupremeCourtistheOverarchingReasontoVoteforPresidentBidenin2024"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="슈프림 코트의 슈퍼매이져리티는 2024년 대통령 선거에서 조 바이든을 지지해야 하는 주요한 이유입니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-TheSupermajorityontheSupremeCourtistheOverarchingReasontoVoteforPresidentBidenin2024_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="슈프림 코트의 슈퍼매이져리티는 2024년 대통령 선거에서 조 바이든을 지지해야 하는 주요한 이유입니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">슈프림 코트의 슈퍼매이져리티는 2024년 대통령 선거에서 조 바이든을 지지해야 하는 주요한 이유입니다</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="주리안 어쌘지 사건이 전 세계 언론인들에게 왜 중요한지" href="/post/2024-05-27-WhyJulianAssangesCaseMattersforJournalistsWorldwide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="주리안 어쌘지 사건이 전 세계 언론인들에게 왜 중요한지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-WhyJulianAssangesCaseMattersforJournalistsWorldwide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="주리안 어쌘지 사건이 전 세계 언론인들에게 왜 중요한지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">주리안 어쌘지 사건이 전 세계 언론인들에게 왜 중요한지</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Z-검사 AI 신뢰성 평가 방법" href="/post/2024-05-27-TheZ-InspectionamethodtoevaluateanAIstrustworthiness"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Z-검사 AI 신뢰성 평가 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-TheZ-InspectionamethodtoevaluateanAIstrustworthiness_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Z-검사 AI 신뢰성 평가 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Z-검사 AI 신뢰성 평가 방법</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="그들이 진심으로 사랑할 때 남자들이 숨기는 비밀" href="/post/2024-05-27-TheSecretsMenKeepWhenTheyLoveYouDeeply"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="그들이 진심으로 사랑할 때 남자들이 숨기는 비밀" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-05-27-TheSecretsMenKeepWhenTheyLoveYouDeeply_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="그들이 진심으로 사랑할 때 남자들이 숨기는 비밀" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">그들이 진심으로 사랑할 때 남자들이 숨기는 비밀</strong><div class="PostList_meta__VCFLX"><span class="date">May 27, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/101">101</a><a class="link" href="/posts/102">102</a><a class="link posts_-active__YVJEi" href="/posts/103">103</a><a class="link" href="/posts/104">104</a><a class="link" href="/posts/105">105</a><a class="link" href="/posts/106">106</a><a class="link" href="/posts/107">107</a><a class="link" href="/posts/108">108</a><a class="link" href="/posts/109">109</a><a class="link" href="/posts/110">110</a><a class="link" href="/posts/111">111</a><a class="link" href="/posts/112">112</a><a class="link" href="/posts/113">113</a></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"리눅스의 Crontab 오래된 파일 삭제 일정 설정 초보자 가이드","description":"","date":"2024-06-19 01:02","slug":"2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles","content":"\n\n![Image](/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_0.png)\n\n## 우리의 시나리오:\n\n고객이 서비스의 디스크 공간이 100%로 가득찬 것을 알아차리고, 가장 쉬운 솔루션은 공급자 캐시였습니다. 이 캐시에는 PR에서 사용된 모든 공급자 버전이 포함되어 있으며 매주 안전하게 삭제할 수 있습니다.\n\n크론 작업을 설정하여 매주 월요일 오전 7시에 실행하고 폴더에서 파일을 삭제하십시오. 폴더 자체는 삭제하지 않도록 주의하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시작해 봅시다!\n\n## Cron 소개\n\nCron은 리눅스 환경에서 사용자가 일정 시간에 반복적으로 작업을 예약할 수 있게 해주는 응용 프로그램입니다. Cron은 주로 예약된 백업 실행, 디스크 공간 모니터링, 파일 삭제, 시스템 유지 보수 작업 실행 등에 사용됩니다.\n\nCron 작업을 사용하면 서버에서 특정 작업을 예약하고 실행할 수 있습니다. Cron 작업은 백그라운드에서 실행되는 작업을 자동화하는 데 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 cron 작업에는 세 가지 구성 요소가 있습니다:\n\n- 호출하거나 실행할 스크립트입니다.\n- 주기적으로 스크립트를 실행하는 명령입니다.\n- 호출되는 스크립트가 하는 작업 또는 출력이 있습니다. 일반적으로 스크립트는 파일이나 데이터베이스를 수정합니다. 그러나 서버의 데이터를 수정하지 않는 다른 작업도 수행할 수 있습니다. 예를 들어 이메일 알림을 보내는 등의 작업이 있을 수 있습니다.\n\n한 개의 Cron 작업 개체는 crontab(크론 테이블) 파일의 한 줄과 같습니다. 지정된 일정에 주기적으로 작업을 실행하며, 크론 형식으로 작성됩니다. \n\nCrontab 구문에는 다음과 같은 다섯 가지 필드가 포함되며 가능한 값을 가집니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 분. 명령이 실행될 시간(0–59 사이)을 나타냅니다.\n- 시간. 명령이 실행될 시간(24시간제, 0–23 사이)을 나타냅니다.\n- 월별 날짜. 명령이 실행될 날짜(1–31 사이)를 나타냅니다.\n- 월. 명령이 실행될 월(1–12 사이, 즉 1월부터 12월까지)을 나타냅니다.\n- 요일. 명령이 실행될 요일(0–6 사이, 일요일부터 토요일까지)을 나타냅니다. 일부 시스템에서 값 7은 일요일을 나타냅니다.\n- 별표(*)는 해당 필드의 모든 값을 나타냅니다. 예를 들어, 4번째 필드(월)에 별표를 사용하면 매월을 의미합니다.\n\n중요: 필드를 비워두지 마세요.\n\n\u003cimg src=\"/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_1.png\" /\u003e\n\n## 크론 제한사항:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작업 간 최단 간격은 60초입니다. cron을 사용하면 59초 미만으로 작업을 실행할 수 없습니다.\n- 한 대의 컴퓨터에 집중화되어 있습니다. cron 작업을 네트워크 내의 여러 대의 컴퓨터로 분산할 수 없습니다. 그러므로 cron을 실행하는 컴퓨터가 충돌하면 예약된 작업이 실행되지 않고 누락된 작업을 수동으로만 실행할 수 있습니다.\n- 자동 재시도 메커니즘이 없습니다. cron은 엄격히 지정된 시간에 실행되도록 설계되었습니다. 작업이 실패하면 다음 예약된 시간까지 다시 실행되지 않습니다. 이로 인해 cron은 점진적 작업에 적합하지 않습니다.\n\n이러한 제한 사항으로 인해 cron은 특정 시간에 정기적인 간격으로 실행되는 간단한 작업에는 훌륭한 솔루션입니다.\n\n## cron이 수행할 수 있는 기본 작업:\n- crontab -e: crontab 파일을 생성 또는 편집합니다. 시스템에 crontab 파일이 없는 경우 해당 명령은 자동으로 새 파일을 생성합니다. crontab -e를 사용하면 cron 작업을 추가, 편집 및 삭제할 수 있습니다.\n- crontab -l: 시스템에 있는 활성 예약된 작업 목록을 볼 수 있습니다.\n- crontab -u username -l: 시스템에 여러 사용자가 있는 경우 su를 입력하여 해당 명령으로 사용자의 crontab 파일 목록을 볼 수 있습니다.\n- sudo su crontab -u username -e: 다른 사용자의 예약된 작업을 편집합니다. 루트 권한을 부여하려면 명령의 시작 부분에 sudo su를 추가하십시오. 이 명령을 포함한 일부 명령은 관리자 사용자만 실행할 수 있습니다.\n- crontab -r: crontab 파일의 모든 예약된 작업을 삭제하고 새로 시작합니다.\n- crontab -i: 해당 명령은 crontab -r과 동일하지만 사용자에게 crontab을 제거하기 전에 yes/no 옵션을 제시합니다.\n- man crontab: cron의 매뉴얼 페이지\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1| 명령어 테스트\n\n크론 작업을 예약하기 전에 명령을 테스트하기 위해 몇 가지 파일이 들어 있는 새 디렉토리를 만들어 보겠습니다:\nmkdir: 새 디렉토리 만들기에 사용됩니다\ntouch: 일반 파일 생성에 사용됩니다\n\n![이미지](/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_2.png)\n\n이제 test_script의 모든 파일을 삭제해 보겠습니다. 실행할 명령어는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ 찾기 ./test_script -mindepth 1 -delete\n```\n\nfind 명령어는 파일의 이름을 입력하여 특정 파일을 검색할 수 있습니다. -name 옵션을 사용하여 원하는 파일 이름을 입력한 후 find 명령어를 사용할 수 있습니다.\n\nmaxdepth vs. mindepth:\n-maxdepth levels\n시작점 아래의 디렉토리에서 최대 levels(0 이상의 정수)까지 이동합니다. -maxdepth 0은 시작점 자체에 대해 테스트 및 작업을 적용합니다.\n\n-mindepth levels\nlevels(0 이상의 정수)보다 작은 수준에서는 어떤 테스트나 작업도 적용하지 않습니다. -mindepth 1은 시작점을 제외한 모든 파일을 처리합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 화면 캡처에서 확인할 수 있듯이 스크립트가 정확히 작동했습니다! 성공!\n\n## 2. 스크립트 만들기\n\n시작하려면 Step 1에서 한 것과 똑같은 단계를 따를 것입니다. 폴더 내에 디렉터리를 만들고 더미 파일을 생성하세요. 이번에는 다른 이름으로 만들어 보겠습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, vim을 사용하여 동일한 스크립트를 사용하여 파일을 삭제할 수 있는 스크립트를 만듭니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_5.png\" /\u003e\n\n리눅스에서 스크립트를 실행 가능하게 하려면 \"chmod\" 명령을 사용하여 파일에 \"실행\" 권한을 할당하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표 태그를 마크다운 형식으로 변경하면 됩니다.\n\n```js\n$ chmod u+x script\n\n또는 \n\n$ chmod 744 script\n```\n\n\u003cimg src=\"/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_6.png\" /\u003e\n\n자, 이제 스크립트를 실행해보고 제대로 작동하는지 확인해봅시다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 Markdown 형식으로 table 태그를 변경하세요.\n\n\n\u003cimg src=\"/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_7.png\" /\u003e\n\n성공입니다! 모든 것이 파일에서 지워졌고 실제 파일은 삭제하지 않았습니다! 이제 마지막 퍼즐 조각으로 넘어가 봅시다!!\n\n# 3| Cron 작업 추가\n\n다시 한 번, 위와 같은 단계를 따라하여 폴더 내에 파일을 생성하실 겁니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 표를 표시합니다.\n\n\n![Crontab Image 8](/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_8.png)\n\n다음으로, 매주 월요일 오전 7시에 실행되는 cron 작업을 만들어야 합니다. 이를 위해 https://crontab-generator.org/ 로 이동하여 약간의 안내를 받겠습니다.\n\n![Crontab Image 9](/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_9.png)\n\n다음 명령을 실행하여 crontab을 엽니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ crontab -e\n```\n\n파일의 맨 끝에 다음 줄을 추가하세요:\n\n```js\n0 7 * * 1 ./Users/kparham/cron_test_folder/cron_delete_files.sh \u003e/dev/null 2\u003e\u00261\n```\n\n˚*•̩̩͙✩•̩̩͙*˚＊성공!!!! ＊ ˚*•̩̩͙✩•̩̩͙*˚\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마크다운 형식으로 테이블 태그를 변경해주세요.","ogImage":{"url":"/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_0.png"},"coverImage":"/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_0.png","tag":["Tech"],"readingTime":5},{"title":"쉘 스크립팅","description":"","date":"2024-06-19 01:00","slug":"2024-06-19-ShellScripting","content":"\n\n셸 스크립팅이란 무엇인가요?\n\n터미널에 리눅스 명령어를 입력하는 것과 마찬가지로, 텍스트 파일에 명령어들을 나열하고 그 파일의 확장자를 .sh로 지정하여 실행할 수 있습니다.\n\n셸 스크립팅을 사용하면 파일 관리 작업 등 리눅스의 작업을 자동화할 수 있습니다.\n\n서버에서 파일을 백업하는 것과 같이 일상적인 작업에서 인간의 노력을 줄여줄 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n종류별 쉘:\n\n보른 쉘(sh):\n\n일부 시스템에서 기본 해석기지만, 많은 현대 리눅스 배포판에서는 \"dash\" 등 다른 쉘로의 심볼릭 링크로 대체됩니다.\n\n이식 가능하고 대부분 선호되는 쉘입니다. 그러나 산술 및 논리 표현 처리 등 일부 고급 기능이 부족합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nC 셸 (csh):\n\nC 언어에서 영감을 받았지만 bash보다는 오늘날에는 사용량이 적습니다. 그러나 일부 사용자들은 그 문법을 선호합니다.\n\nTENEX C 셸 (tcsh):\n\n철자 교정 및 프로그래밍 가능한 단어 완성과 같은 고급 기능을 갖춘 C 셸의 확장판입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nC 셸 사용자에게 친숙한 경험을 제공하면서 추가 기능이 있습니다.\n\nZ 셸:\n\n더 많은 고급 기능 및 플러그인 지원과 더 많은 사용자 정의 옵션을 갖춘 bash 셸의 확장입니다.\n\n효율적인 셸과 매우 구성 가능한 환경을 원하는 사용자들 사이에서 인기가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n셸의 여러 종류가 있어요. 우리의 필요와 선호에 따라 그 중에서 선택할 수 있어요.\n\n셸 스크립팅 기초:\n\n사용자 입력을 어떻게 받을까요?\n\n![이미지](/assets/img/2024-06-19-ShellScripting_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 이미지에서 볼 수 있듯이, 우리는 사용자로부터 입력을 받기 위해 \"read\"를 사용할 수 있습니다.\n\n이 스크립트는 두 개의 숫자를 입력으로 받고 그것들을 출력으로 출력합니다.\n\n입력으로 어떤 숫자를 주면, 그들은 변수 num1과 num2에 저장됩니다.\n\necho 명령어에서 변수를 출력하려면 변수 앞에 \"$\" 기호를 사용해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![스크립트 실행 전 사용자 입력을 받을 수 있습니다](/assets/img/2024-06-19-ShellScripting_1.png)\n\n스크립트 실행 전에 사용자 입력을 받을 수 있습니다.:\n\n![스크립트 실행 전 사용자 입력 받기](/assets/img/2024-06-19-ShellScripting_2.png)\n\n여기서 num1=$1은, 우리가 bash scriptname.sh라는 명령어로 스크립트를 실행할 때 변수에 값을 제공할 것으로 예상됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저의 스크립트 이름을 med.sh로 지었기 때문에 이 bash med.sh value1 value2를 따를 수 있어요. 이렇게 하면 두 값이 num1과 num2에 할당됩니다.\n\n![image](./assets/img/2024-06-19-ShellScripting_3.png)\n\n변수의 또 다른 사용 사례를 살펴보죠:\n\n아래 이미지처럼 쉘에서 \"t\"라는 변수를 값 10으로 초기화해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-ShellScripting_4.png)\n\n출력할 수 있을까요? echo 명령어로 시도해 봅시다:\n\n![이미지](/assets/img/2024-06-19-ShellScripting_5.png)\n\necho 문이 작동하고 변수 값이 출력된 것을 확인할 수 있었어요. 이제 스크립트로 시도해 볼게요:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![ShellScripting_6](/assets/img/2024-06-19-ShellScripting_6.png)\n\n![ShellScripting_7](/assets/img/2024-06-19-ShellScripting_7.png)\n\nIt gives nothing, because variable \"t\" is not global. So, to make it global, we should export the variable with the command `export t`.\n\n![ShellScripting_8](/assets/img/2024-06-19-ShellScripting_8.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위와 같이 보시다시피, 스크립트 내 echo 문은 \"t\" 값을 출력할 수 있습니다.\n\nFor 루프:\n\n![이미지](/assets/img/2024-06-19-ShellScripting_9.png)\n\n여기에서 for 루프는 C 언어로 작성한 것과 동일합니다. 이 스크립트는 변수 n의 값들을 출력합니다. 매 반복마다 조건 n≤5를 확인하며, 참이면 해당 값을 출력합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-ShellScripting_10.png)\n\nbash 배열을 만드는 방법은 무엇인가요?\n\nBash 배열은 매우 특별합니다. 다른 프로그래밍 언어와 달리 문자열, 정수 등과 같은 다양한 유형의 요소를 저장할 수 있습니다.\n\n구문: array_name=()\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-ShellScripting_11.png\" /\u003e\n\n여기에서 우리는 gokul이라는 배열을 만들었고, 그 안에 값을 넣었습니다.\n\n그리고 for 루프를 사용하여 배열을 반복하고 해당 값을 출력할 수 있습니다.\n\n'gokul[@]'은:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ngokul은 우리가 참조하는 배열 이름입니다. @는 중괄호 내부에 있는 특수한 자리 표시자로, 배열을 공백으로 구분된 개별 요소로 확장하는 역할을 합니다. 'gokul[*]'도 사용할 수 있습니다.\n\n![image](/assets/img/2024-06-19-ShellScripting_12.png)\n\n함수:\n\n함수를 사용하여 입력된 숫자를 더하고 빼고 나누는 스크립트를 만들어 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nsyntax : function_name()' — — — — — Code — — — — -'\n\nfunction_name 함수를 통해 해당 함수를 필요한 곳 어디서든 호출할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-ShellScripting_13.png\" /\u003e\n\n저희는 각각 덧셈, 뺄셈, 나눗셈을 위한 sum, sub, div 3개의 함수를 생성했습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 함수 안에는 위 스크립트에 표시된 대로 논리 연산을 수행하는 논리가 포함되어 있습니다. 그리고 결과가 출력됩니다.\n\nread 명령어를 사용하여 입력값으로 2개의 숫자를 받고, read 명령어에 -p를 사용하여 콘솔에 인쇄할 메시지를 호출할 수 있습니다.\n\n그리고 입력 받은 두 변수를 모든 함수에 전달하기 위해 각각의 이름을 호출합니다.\n\n![이미지](/assets/img/2024-06-19-ShellScripting_14.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCase :\n\n테이블 태그를 마크다운 형식으로 변경하면 됩니다.\n\n\\\nIt allows you to compare an expression against a list of patterns and execute specific code blocks based on the match.\n\\\n\nLets see example below.\n\n![Shell Scripting Example](/assets/img/2024-06-19-ShellScripting_15.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스크립트는 기분 조건을 인수로 사용합니다.\n\n- case 문은 기분 변수를 다른 패턴과 비교합니다.\n- \"Happy\", \"Sad\", 또는 \"Depressed\"와 일치하는 경우 해당 코드 블록이 실행됩니다.\n\n그리고 \"esac\"은 case의 반대로, case 블록의 끝을 나타냅니다.","ogImage":{"url":"/assets/img/2024-06-19-ShellScripting_0.png"},"coverImage":"/assets/img/2024-06-19-ShellScripting_0.png","tag":["Tech"],"readingTime":5},{"title":"도커는 실제로 어떻게 작동하나요 하드웨이 포괄적인 기술적 심층 탐구","description":"","date":"2024-06-19 00:52","slug":"2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving","content":"\n\n도커. 컨테이너. 오케스트레이션의 혁명. 산업을 선도하는 PaaS 제품. 빌드, 공유 및 실행. 어떤 앱이든 어디에서든... 그냥 그렇게. “도커는 어떻게 작동할까?”라고 궁금해 해 본 적 있나요? 마법이 아니에요. 재능과 땀 머금은 기술이랍니다.\n\n![이미지](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_0.png)\n\n이 기사에서는 다음 질문에 대한 답을 찾아보겠습니다:\n\n- 컨테이너화가 세계를 어떻게 바꿨는가?\n- 컨테이너가 클라우드 생태계를 어떻게 장악했는가?\n- “컨테이너”가 정확히 무엇을 의미하는가?\n- “도커”는 실제로 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n본 기사의 목적은 \"도커\"에 대해 더 많이 배우고 이해하고 싶어하는 개발자들을 위해 고수 수준에서 초보 수준까지 포괄적인 학습 경로를 만드는 것입니다. 대상 독자는 다음을 원하는 분들입니다:\n\n- 도커가 내부적으로 어떻게 사용되는지 배우기\n- 컨테이너화에 대해 깊게 이해하기\n- 구성 요소 간의 관계 파악하기\n- 전반적인 멘탈 모델 습득하기\n- 전체적인 그림을 보기\n\n4년 전에는 컨테이너에 대해 거의 아무것도 몰랐습니다. 요즘에는 컨테이너 세계에 푹 빠져 있습니다. 4년 간의 지식을 한 자리에 모아 도커에 관심이 있는 모든 분들이 정렬되어 있도록 도와주기로 결심했습니다. 저는 4년 이상 Trendyol에서 컨테이너에 청년했습니다. \n\n# 이 기사를 읽는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사는 조금 길 수 있습니다. 여기에서는 읽는 방법에 대한 안내가 있습니다:\n\n- 높은 수준의 개요로 시작하여 컨셉을 간단히 설명합니다.\n- 그런 다음 디자인 세부 정보를 소개하면서 전체 개념을 설명합니다.\n- 높은 수준의 디자인이 완전히 설명된 후에는 일부 구성 요소를 살펴보고 구현과 관련된 몇 가지 이슈와 PR을 제공하며, 기사와 저자에 대한 교차 참조를 제공합니다.\n- 이어서 내부의 저평가된 구성 요소, 명세, 뒷면, 내부 세부 정보에 대한 깊은 탐구를 합니다.\n- 기사를 기존 정리하며 다룬 주요 포인트를 요약합니다.\n\n# 노트\n\n- 버즈워드 주의: 외부 소스 및 중요 키워드에 대한 교차 참조가 많이 나옵니다. 각각은 자세히 살펴볼 가치가 있습니다.\n- No-AI: 이 문서에는 GPT 또는 AI로 생성된 내용이 포함되어 있지 않습니다! 커피를 한 잔 들고 즐겁게 읽으세요!\n- 그림: 모든 그림은 저가 Excalidraw에서 직접 그린 것이며, 모든 권리를 보유합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 개요\n\n최근 몇 년 동안 컨테이너 관련 기술은 몇 가지 명령어로 빠르게 소프트웨어를 전달하기 위해 다양한 맥락에서 사용되어왔습니다. 본 문서는 컨테이너화 기술을 깊이 있게 개념화하고 검토합니다. 특정 용어들을 단계적으로 설명하고, 전반적인 아키텍처, 동기 및 사고 모델을 설명합니다. 우리는 Docker 아키텍처와 구성 요소를 질적으로 조사합니다. 본 문서에서는 모든 작은 세부사항을 다루지 않겠지만, 대신 뒷면에서 무슨 일이 일어나는지에 대해 알려드릴 것입니다. 이 문서에서는 많은 언급, 외부 리다이렉션, 교차 참조가 있을 것입니다.\n\n# 동기\n\n객관적으로 양적으로 측정하기 어려우며 주관적 해석에 크게 개방되어 있지만, 원숭이처럼 문서를 뛰어넘는 것보다 더 유익한 것은 전체 코드베이스를 이해하는 것입니다. 우리가 엔지니어로써 미래를 구축하려는 길에 있다면, 우리가 사용하는 기술이 어떻게 만들어졌는지 알아야 한다고 생각합니다. 누가 만들었는지. 어디에서. 어떻게. 그래서 어떠한 것이든 깊게 파고들어야 하는데, 아무데서나 어디서든지요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컨테이너 세계에 심취해본 적이 없어요. 여기서 중요한 점은 교육적인 목적으로 무언가를 할 수 있는 능력을 갖추는 것이며, 전체 아키텍처를 이해하고 모든 다양한 맥락을 하나의 장소에 편하게 정리하는 것입니다! 함께, 우리는 이를 하는 법을 배우게 될 거예요. 게다가, 이 편지를 쓰며 가치 있는 정보를 배울 수 있을 거예요. 게다가, 이는 기여할 수 있는 좋은 기회가 될 수 있어요. 커뮤니티에서 새로운 사람들을 만나고, 뒷담화를 듣는 분들, 건축가들, 의사 결정을 내리는 사람들도 만날 수 있는 기회일 거예요!\n\n기술은 변화합니다. 늘 그렇죠. 우리의 지식이 바로 우리의 가치입니다. 최신 기술 변화와 업데이트를 따라가야 합니다. 그래서, 암기 대신에 이해하고, 듣는 대신에 보고, 무시하는 대신에 배우고, 가정 대신에 증명해 봅시다. 이러한 동기 부여는 여기서부터 더 나아갈 충분한 이유가 될 거예요!\n\n# 1. 소개\n\n컨테이너는 오늘날 인프라에서 언어를 제공하는 정말 유용한 존재가 되었어요. 다양한 환경의 복잡성을 초월하며 매끄러운 배포와 확장성을 제공하는 보편적인 언어를 제공하죠. 가벼우면서도 모듈식 디자인 덕분에 컨테이너는 응용 프로그램과 그 의존성을 캡슐화하여 다양한 플랫폼 간의 일관성과 이식성을 보장합니다. 컨테이너의 채택은 계속해서 급격히 증가하며 오늘날의 동적이고 빠른 기술적 환경에서 응용 프로그램이 개발되고 배포되고 관리되는 방식을 재정의하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 애플리케이션을 개발, 배포 및 실행하는 방식을 혁신한 솔루션 중 하나가 Docker입니다. 소프트웨어를 컨테이너라고 불리는 자체 포함 단위로 패키징할 수 있는 능력으로, Docker는 소프트웨어 개발 및 배포의 세계를 변화시켰습니다.\n\nDocker가 부상하는 원동력과 개발자, 운영팀 및 모든 크기의 기관들 사이에서 엄청난 인기를 얻게 된 이유를 알아봅시다.\n\n## 2. Docker란?\n\nDocker는 컨테이너 내부에서 애플리케이션을 개발, 배포 및 실행하기 위한 오픈 플랫폼입니다. Docker는 컨테이너화 기술을 활용하여 애플리케이션을 생성, 배포 및 실행하는 프로세스를 간소화합니다. Docker를 사용하면 애플리케이션을 인프라에서 분리하여 소프트웨어를 신속하게 전달할 수 있습니다. Docker를 통해 인프라와 애플리케이션을 동일한 방식으로 관리할 수 있습니다. Docker는 기저 인프라를 추상화하고 소프트웨어를 패키징하고 배포하는 표준화된 방법을 제공합니다. Docker의 배포, 테스트 및 코드 신속 배포 방법을 활용하여 코드 작성과 프로덕션에서 실행 간의 지연을 크게 줄일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2.1. 컨테이너의 부상\n\n지난 수십 년 동안 거의 모든 소프트웨어 애플리케이션들은 큰 단일 모노리틱으로 구축되었습니다. 목표는 모든 과정과 모든 기능을 하나의 서비스 내에서 처리하는 것이었습니다. 전체 시스템은 단일 시스템 방식으로 관리되고 사용되었기 때문에 모노리틱 빌드가 드물게 업데이트되었던 것입니다. 모든 시스템은 동시에 패키징되어 운영팀에 전달되어야 했습니다. 전체 시스템은 건강 서비스를 개발하고 모니터링한 운영팀에 의해 완전하게 운영되었습니다. 이 유산 방식은 여전히 소규모 프로젝트와 팀에 사용되고 있습니다.\n\n배포하는 데 어려움을 겪고 새로운 기능에 대응하지 못하는 오래된 구조는 개발자들이 새로운 서비스 디자인을 찾도록 강요하게 만들었습니다. 이 때, 마이크로서비스가 나타납니다. 마이크로서비스 아키텍처는 사실 상을 더 작은 부분으로 분할한 모노리틱 구조입니다. 모든 서비스가 독립적으로 작동합니다. 마이크로서비스는 서로 분리되어 실행되며, 개별적으로 업데이트, 활용 및 확장될 수 있습니다. 이것은 개발팀과 운영팀이 소프트웨어를 최신 상태로 유지하고 제품을 신속히 배포할 수 있는 기회를 제공합니다. 이러한 구조를 사용하는 회사의 수는 날이 갈수록 증가하고 있습니다. 넷플릭스, 구글, 아마존 등이 가장 일반적으로 사용하는 사용자입니다.\n\n마이크로서비스에는 긍정적인 측면이 있지만, 작은 서비스의 수가 더 많아지면서 업무량이 증가하고 이를 하나의 소프트웨어처럼 제어하고 병합하기가 어려워집니다. 이를 원활하게 운영하고 하드웨어 비용을 절감하는 것이 훨씬 어려워집니다. 그 때, 운영팀의 임무는 인간의 실수나 실패를 방지하고 확장 가능한 소프트웨어를 개발하기 위해 자동화를 극대화하는 것입니다. [17]\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2.2. 컨테이너 대 가상 머신\n\n가상화는 컴퓨터 시스템의 가상 인스턴스를 하드웨어 시스템으로부터 추상화된 레이어에서 실행하는 프로세스입니다. 가상화는 가상 머신(Virtual Machines)을 통해 한 컴퓨터에서 동시에 여러 가상 운영 체제를 실행할 수 있도록 한다.\n\n가상 머신(VMs)은 하나의 서버를 여러 대로 변환하는 물리 하드웨어의 추상화입니다. VM은 하나의 기계에서 여러 VM을 실행할 수 있게 한다. 각 VM은 완전한 운영 체제, 응용 프로그램, 필요한 바이너리 및 라이브러리 및 모든 종속성을 포함한다. 각 VM을 관리하고 구성해야 하기 때문에 VM은 비용을 절감하고 낭비되는 하드웨어 자원을 피하는 최선의 방법은 아니다. 이러한 이유로 가상화에서 컨테이너 기술로의 이전이 날이 갈수록 증가하고 있다.\n\n리눅스 컨테이너 기술은 각 서비스에 대해 별도의 환경을 준비하지 않고도 개발자들이 동일한 기계에서 여러 마이크로서비스를 실행할 수 있게 한다. 또한 컨테이너를 사용하여 서로를 격리시킬 수 있다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"Learning Containers From The Bottom Up\" 기사를 읽어보세요. 그 기사는 컨테이너 학습 경로를 제시합니다.\n\n\n![2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_1](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_1.png)\n\n\n## 3. Docker 아키텍처\n\n도커 아키텍처는 클라이언트-서버 모델로, 컨테이너화된 응용 프로그램의 생성, 배포, 및 배포를 가능하게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3.1. 고수준 아키텍처\n\n도커의 고수준 아키텍처는 클라이언트-서버 모델을 중심으로 구성되어 있습니다. 여기서 클라이언트는 컨테이너 및 관련 리소스를 관리하기 위해 도커 데몬(서버)과 상호 작용합니다. 도커의 핵심 구성 요소로는 클라이언트, 데몬, 그리고 이미지가 있습니다. 클라이언트와 데몬은 REST API를 사용하여 통신하며 UNIX 소켓이나 네트워크 인터페이스를 통해 통신합니다.\n\n![도커 아키텍처](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_2.png)\n\n- 도커 클라이언트: 사용자가 명령어를 입력하고 도커 리소스를 관리하기 위해 상호 작용하는 명령줄 도구, API 또는 그래픽 인터페이스입니다. 클라이언트는 도커 데몬에 요청을 보내고 해당 명령어를 실행하게끔 조율합니다.\n- 도커 데몬: 도커 엔진이라고도 불리며 호스트 머신에서 실행되는 백그라운드 서비스 및 장기 실행 프로세스로서 컨테이너 및 컨테이너 이미지를 실행하고 관리하는 작업을 실제로 수행합니다. 도커 데몬은 컨테이너의 수명주기를 관리하고 작동을 조율하는 역할을 담당합니다. 도커 클라이언트로부터 요청을 수신하고 컨테이너를 관리하며 다양한 도커 작업을 조율합니다. 데몬은 호스트 운영 체제의 커널과 상호 작용하여 컨테이너화, 네트워킹 및 저장소를 위한 커널 기능 및 모듈을 활용합니다.\n- 도커 데스크톱: 맥, 윈도우 또는 리눅스 환경에 쉽게 설치할 수 있는 응용 프로그램으로, 컨테이너화된 애플리케이션 및 마이크로서비스를 빌드하고 공유할 수 있습니다. Docker Extensions를 사용하면 제3자 도구를 Docker 데스크톱 내에서 확장하여 기능을 추가할 수 있습니다.\n- 도커 레지스트리: 컨테이너 이미지를 저장하는 레지스트리입니다. Docker Hub는 누구나 사용할 수 있는 공개 레지스트리이며, Docker는 기본적으로 Docker Hub에서 이미지를 찾도록 설정되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3.2. Low-level Architecture\n\n각 기술에 대해 자세히 알아볼 것이지만, 먼저 30,000피트의 시점에서 아키텍처를 살펴보겠습니다:\n\n![Architecture](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_3.png)\n\n- Docker Desktop은 필요한 Linux 환경을 제공하기 위해 가상 머신(VM)을 사용합니다.\n- VM 내에서 Docker 클라이언트는 RESTful API를 통해 Docker 데몬(dockerd)과 상호작용합니다.\n- 그것은 컨테이너를 실행하는 데 사용되는 Containerd를 내부적으로 사용합니다. Containerd는 물리적 또는 가상 머신에서 컨테이너의 수명 주기를 관리하는 산업 표준 런타임입니다. 컨테이너를 생성하고 시작하며 중지하고 제거하는 데 사용되는 데몬 프로세스입니다.\n- Containerd 플러그인을 추가하여 기능을 확장할 수 있습니다.\n- 컨테이너가 시작되면 containerd의 일부인 shim (runtime v2) API가 containerd와 OCI 런타임 사이에 중개자 역할을 합니다.\n- OCI 런타임은 컨테이너의 네임스페이스, 제어 그룹(cgroups), 기능 및 컨테이너화에 필요한 기타 설정을 설정하는 역할을 담당합니다. Linux 커널의 능력을 활용하여 리소스를 격리하고 제어하며 보안을 강화하고 컨테이너의 동작을 관리합니다. 프로세스에 대한 고도로 세분화된 리소스 할당 및 제어를 가능케 하는 Linux 커널 기능인 Cgroups은 컨테이너에 권한을 부여하여 권한과 시스템 자원에 대한 액세스를 정의하는 Linux 커널 내에서 권한을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Docker CLI\n\nDocker CLI 도구는 dockerd 데몬과 상호 작용하는 데 사용되는 명령줄 응용 프로그램입니다. 여러 유용한 기능을 포함하고 있습니다. 표준 UNIX 스타일의 인수를 처리하며 많은 경우 짧은 형식과 긴 형식을 모두 제공합니다.\n\n깊이 관심이 있는 경우 저장소에서 모든 명령을 찾을 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 도커 레지스트리\n\n도커 레지스트리는 사용자가 컨테이너 이미지를 저장하고 배포할 수 있는 서비스입니다. 사용자는 이미지를 푸시하여 다른 팀 멤버나 시스템이 배포할 수 있도록 공개적으로 이용할 수 있는 중앙화된 또는 분산된 위치로 레지스트리를 활용할 수 있습니다.\n\nOpenRegistry와 같이 분산된 레지스트리도 있습니다. 몇 달 전에 @kotokunaga.mail이 \"P2P Container Image Distribution on IPFS With Containerd\"에 관한 블로그 글을 작성했습니다. IPFS 지원은 nerdctl v0.14에서 소개되었습니다.\n\n레지스트리 API와 상호 작용할 수 있는 다양한 도구가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 크레인: 원격 이미지 및 레지스트리와 상호 작용하는 도구입니다.\n- 스코페오: 컨테이너 이미지 및 이미지 저장소에서 다양한 작업을 수행하는 명령 줄 유틸리티입니다.\n- 레지스트리 API를 위한 클라이언트 인터페이스인 레그컨트롤입니다.\n\n## BuildKit\n\nBuildKit은 동시성, 캐시 효율성, Dockerfile에 독립적인 빌더 툴킷입니다.\n\nBuildKit을 통합함으로써 사용자는 성능, 저장 공간 관리, 기능 기능성 및 보안 측면에서 개선을 볼 수 있어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBuildKit 빌드를 활성화하려면 클라이언트 측에서 $ docker build를 호출할 때 DOCKER_BUILDKIT=1 환경 플래그를 전달하거나 /etc/docker/daemon.json 파일에서 '“features”: ' “buildkit”: true '를 설정한 후 데몬을 다시 시작하면 됩니다. 현재 리눅스 컨테이너 빌드만 지원됩니다.\n\nBuildKit에는 두 가지 주요 구성 요소가 있습니다: buildctl과 buildkitd. buildctl은 gRPC 서버를 통해 buildkitd와 통신합니다. 시작할 때 sdnotify를 통해 init 데몬 (systemd)에 메시지를 보냅니다. 서비스 관리자에 서비스 시작이 완료되었음을 알리기 위해 sddaemon.SdNotify(거짓, sddaemon.SdNotifyReady)를 보내며 나중에 SdNotifyStopping을 보냅니다.\n\nBuildKit은 여러 플랫폼용 빌드에서 잘 작동하도록 설계되었으며, 사용자가 빌드를 실행하는 아키텍처 및 운영 체제뿐만 아니라 여러 플랫폼을 위한 빌드도 지원합니다.\n\nBuildKit은 실행하는 빌드에 대한 SLSA Provenance의 생성을 지원합니다. BuildKit이 생성하는 provenance 형식은 SLSA Provenance 형식에 의해 정의됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Buildx\n\n도커 Buildx는 Moby BuildKit 빌더 툴킷에서 제공하는 기능을 완벽히 지원하는 도커 명령어를 확장하는 CLI 플러그인입니다. 도커 Buildx는 항상 BuildKit을 활성화합니다. 도커 빌드와 동일한 사용자 경험을 제공하며 생성된 스코프 빌더 인스턴스를 만들거나 여러 노드에 동시에 빌드하는 기능과 같은 많은 새로운 기능을 제공합니다.\n\n아래는 예시 멀티 플랫폼 멀티 스테이지 이미지를 빌드하는 방법입니다:\n\n```js\ndocker buildx build --platform \u003cplatform1\u003e,\u003cplatform2\u003e,... --tag \u003c이미지_이름\u003e --file \u003cDockerfile\u003e .\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컨테이너 이미지를 만드는 대안 방법\n\n컨테이너 이미지를 만들기 위해 오직 \"Docker\"만 사용할 필요는 없습니다. OCI 규격을 준수하는 컨테이너 이미지를 만드는 다양한 방법이 있습니다:\n\n- google/ko\n\nGitLab CI/CD 파이프라인에서 ko를 사용하고 싶으신가요? 아주 간단합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ KO_DEFAULTBASEIMAGE: gcr.io/distroless/static:nonroot\n$ KO_DOCKER_REPO: ${CI_REGISTRY}/${CI_PROJECT_NAMESPACE}\n$ ko login $CI_REGISTRY -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD\n$ ko apply -B --bare -f your_deployment.yaml\n```\n\n취약점이 없는 컨테이너 이미지를 생성하고 싶나요? apko로 간단하게 만들 수 있어요!\n\n여기 컨테이너 이미지 빌더 목록입니다:\n\n- GoogleContainerTools/kaniko\n- GoogleContainerTools/jib\n- containers/podman (데몬 없이!)\n- containers/buildah (데몬 없이!)\n- moby/buildkit\n- docker/buildx\n- genuinetools/img\n- uber/makisu (사용 중단)\n- pivotal/kpack\n- openshift/source-to-image\n- buildpacks\n- nix/ocitools\n- rancher/kim\n- shipwright\n- earthly\n- bazelbuild (rules_docker)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보너스: 도커를 사용하지 않고 go-containerregistry 모듈을 사용하여 레이어 및 이미지 매니페스트를 프로그래밍 방식으로 작성하여 OCI 컨테이너 이미지를 작성하는 데 관심이 있다면 @ahmetb의 블로그 포스트를 확인해보세요.\n\n## 컨테이너 런타임 인터페이스 (CRI)\n\nKubernetes (K8s)에 대해 들어봤나요? 아니라면 괜찮아요. 이 기사에서는 지금까지 이에 대해 언급하지 않았어요. Kubernetes에 대해 들어보지 못했다면 이 섹션을 건너뛰세요.\n\nKubernetes에는 \"kubelet\"이라는 구성 요소가 있습니다. 이는 Kubernetes 클러스터의 모든 노드(물리적인 머신)에서 실행되는 에이전트입니다. 컨테이너 런타임은 현대적인 컨테이너화된 아키텍처의 기본 구성 요소입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컨테이너 런타임 인터페이스(CRI)를 통해 Kubernetes는 CRI 규격을 준수하는 런타임을 사용할 수 있습니다. 모든 도커 이미지는 모든 컨테이너 런타임에서 실행할 수 있습니다.\n\n다양한 컨테이너 런타임이 있습니다. 각각은 특별한 기능을 갖고 있으며 성능, 보안 및 기능성 사이에서 한정된 선택을 내립니다.\n\n- containerd (CNCF 기준화)\n- CRI-O (CNCF 인큐베이팅)\n- gVisor\n- Firecracker\n- kata\n- lxd\n- Singularity (apptainer)\n- SmartOS\n\ndockershim\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도커셈은 도커를 위한 CRI 지원을 구현합니다. 과거에 쿠버네티스에는 도커셈이라 불리는 브릿지가 포함되어 있었는데, 이는 도커가 CRI와 함께 작동할 수 있도록 했습니다. v1.20부터 도커셈은 더 이상 유지되지 않을 것이며, 이는 쿠버네티스에서 도커가 더 이상 지원되지 않는다는 것을 의미합니다. 현재 쿠버네티스는 앞으로의 버전(아마도 v1.22)에서 도커에 대한 지원을 완전히 제거할 계획입니다.\n\n## 컨테이너드\n\n컨테이너드는 간단함, 견고함, 이식성에 중점을 둔 산업 표준 컨테이너 런타임입니다. 컨테이너드는 호스트 시스템의 완전한 컨테이너 라이프사이클을 관리할 수 있습니다: 이미지 전송 및 저장, 컨테이너 실행 및 감독, 저수준 저장 및 네트워크 연결 등을 포함합니다.\n\n컨테이너드는 개발자나 최종 사용자가 직접 사용하는 대신, 더 큰 시스템에 임베드된 형태로 설계되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ncontainerd는 Docker 데몬에서 사용하도록 설계되었으며, 컨테이너 런타임을 새 프로젝트로 분리했습니다.\n\ncontainerd에 의해 컨테이너가 직접 스케줄링되므로 Docker에서 볼 수 없습니다.\n\n![이미지](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_5.png)\n\ncrictl\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컨테이너 런타임 명령줄 인터페이스(CLI)는 시스템 및 응용 프로그램 문제 해결에 유용한 도구입니다. 컨테이너드 및 모든 다른 CRI 호환 컨테이너 런타임을 위해, 예를 들어 dockershim인 경우, 도커 CLI 대신 사용할 수 있는 대체 CLI로 crictl을 권장합니다. crictl은 모든 CRI 호환 컨테이너 런타임에서 일관되게 작동합니다. crictl은 사용자에게 더 나은 전환 경험을 제공하기 위해 도커 CLI와 유사하게 디자인되었지만 정확히 동일하지는 않습니다. \n\n많은 명령어는 이름까지 직접 매핑됩니다. 출력 형식도 유사합니다. 일부 실험적인 도커 명령어는 아직 매핑되지 않았습니다.\n\ncrictl의 범위는 문제 해결에 제한되어 있으며, 도커 CLI를 대체하는 것은 아닙니다. 도커의 CLI는 다양한 명령어 세트를 제공하여 매우 유용한 개발 도구인 반면, crictl은 노드 문제 해결에 충분한 명령어만을 제공합니다. 이는 생산 노드에서 사용하기에 더 안전할 것으로 생각됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nnerdctl (contaiNERD CTL)는 containerd를 위한 Docker 호환 CLI로, compose, rootless, lazy pulling (eStargz), OCIcrypt, P2P 이미지 배포 (IPFS), 이미지 서명 및 검증 지원이 포함되어 있습니다...\n\nnerdctl의 목적은 Docker에 없는 containerd의 최첨단 기능을 실험하는 것을 용이하게 하는 것입니다. 부차적인 목표는 Kubernetes 클러스터의 디버깅에 유용할 수도 있습니다.\n\nctr\n\ncontainerd 명령 줄 클라이언트는 ctr입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 컨테이너 이미지를 가져오기:\n`$ ctr images pull nginx:latest`\n\n- 보유한 이미지 목록 표시:\n`$ ctr images list`\n\n- 이미지를 기반으로 컨테이너 실행:\n`$ ctr container create nginx:latest nginx`\n\n- 실행 중인 컨테이너 목록 표시:\n`$ ctr container list`\n\n- 컨테이너를 중지:\n`$ ctr container delete nginx`\n\nhands-on 경험으로 ctr에 대해 더 알아보세요!\n\n## 컨테이너드 알아보기\n\ncontainerd에 대해 더 알고 싶다면, /docs 폴더로 이동하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✨ 이미지 첨부:\n\n![Docker image](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_6.png)\n\n**서비스**\n\n- containerd는 몇 가지 서비스를 초기화하고 클라이언트를 위해 gRPC 서비스 API를 제공합니다.\n\n**플러그인**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ncontainerd는 사용자 지정 런타임, 스냅샷터, 콘텐츠 스토어 및 gRPC와 같이 정의된 인터페이스를 사용하여 기능을 확장할 수 있습니다.\n\ncontainerd는 내부적으로 플러그인을 사용하여 내부 구현을 분리하고 안정적이며 외부 플러그인과 동등하게 처리할 수 있도록 합니다. containerd에 설치된 모든 플러그인을 확인하려면 다음 명령을 사용하십시오: $ ctr plugins ls:\n\n```js\nTYPE                            ID                PLATFORMS   STATUS\nio.containerd.content.v1        content           -           ok\nio.containerd.snapshotter.v1    btrfs             linux/amd64 ok\nio.containerd.snapshotter.v1    aufs              linux/amd64 error\nio.containerd.snapshotter.v1    native            linux/amd64 ok\nio.containerd.snapshotter.v1    overlayfs         linux/amd64 ok\nio.containerd.snapshotter.v1    zfs               linux/amd64 error\nio.containerd.metadata.v1       bolt              -           ok\nio.containerd.differ.v1         walking           linux/amd64 ok\n...\n```\n\n위 출력에서 모든 플러그인과 로드하지 못한 플러그인을 확인할 수 있습니다. 특정 플러그인에 대한 자세한 정보를 얻으려면 다음 명령을 사용하십시오: $ ctr plugins ls -d id==aufs id==zfs\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ncontainerd는 서버에서 모든 플러그인을 가져오기 위해 Introspectation Service를 호출합니다. 서비스 서버의 초기화 중에 LoadPlugins() 함수를 통해 모든 플러그인이 설정됩니다. Overlayfs 플러그인 등록이 작동하는 예시를 찾을 수 있습니다.\n\nttrpc\n\n저 메모리 환경을 위한 GRPC입니다. HTTP, HTTP2, TLS를 필요로 하지 않는 가벼운 프로토콜입니다. Go stdlib context 패키지를 사용합니다.\n\nttrpc 클라이언트를 초기화하고 싶으신가요? 이렇게 하면 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconn, err := dialer.ContextDialer(context.TODO(), timeout)\nclient := ttrpc.NewClient(conn)\n```\n\n연속성\n\n연속성은 전송에 중립적인 파일 시스템 메타데이터 매니페스트 시스템 저장에 대한 실험을 위한 스테이징 영역입니다.\n\n연속성을 사용하여 AtomicWriteFile()를 호출하는 간단한 예제가 여기 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// AtomicWriteFile은 먼저 임시 파일에 데이터를 쓰고 rename을 호출하여 파일에 원자적으로 쓰는 함수입니다.\ncontinuity.AtomicWriteFile(filename, bytes, 0666)\n```\n\n# 컴포넌트 깊은 탐구\n\n이미 알고 계실 수도 있지만, Docker는 하드웨어 아래에서 수행되는 모든 마법을 하는 유일한 컴포넌트가 아닙니다.\n\n## 컨테이너 이미지\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컨테이너 이미지가 무엇인지, Docker가 이미지를 빌드하고 저장하는 방식, 이러한 이미지가 컨테이너에서 어떻게 사용되는지를 알아야 합니다.\n\n컨테이너 이미지는 실행 가능한 코드를 포함한 변경할 수 없는, 즉 정적인 파일이며, 일관되게 배포되어 임의의 환경에서 격리된 프로세스를 실행할 수 있도록 해줍니다. 부모-자식 관계와 이미지 레이어링의 개념이 있습니다. 이것은 파일 시스템이 내장된 아카이브로 볼 수 있습니다.\n\n컨테이너 이미지는 JSON 매니페스트와 개별 파일 시스템 레이어의 조합으로, 부모 또는 기본 이미지 위에 구축됩니다. 이러한 레이어는 다양한 구성 요소 및 환경 설정을 재사용할 수 있도록 하여 사용자가 모든 것을 다시 만들 필요가 없게 합니다. 최적의 방식으로 레이어를 구성하면 컨테이너 크기를 줄이고 성능을 향상시킬 수 있습니다.\n\n컨테이너 이미지는 클래스/객체 개념과 약간 유사합니다. 이미지는 클래스 또는 템플릿과 같으며 해당 템플릿의 인스턴스를 여러 개 생성할 수 있으며 OCI Runtime Specification이 있습니다. 이는 표준 컨테이너의 정의입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컨테이너 이미지는 오픈 표준을 사용하며 태그가 지정될 수도 있고 되지 않을 수도 있어서 진정한 식별자를 통해서만 검색될 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_7.png)\n\n기술적으로 이미지 없이 컨테이너를 실행할 필요는 없습니다! 궁금하신가요? 더 자세히 다룰 예정입니다.\n\n저장소\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`containers/storage`는 Go 라이브러리로, 레이어, 이미지 및 컨테이너를 저장하고 관리하기 위한 메서드를 제공하는 것을 목표로 합니다.\n\n도커 이미지는 여러 레이어로 구성됩니다. 각 레이어는 Dockerfile에서 특정 명령에 해당합니다.\n\nDockerfile\n\n기본적으로 텍스트 파일에서 환경을 나타냅니다. 우리는 FROM으로 구성하려는 원하는 것들을 실행할 수 있습니다. Dockerfile은 최종적으로 우리가 컨테이너를 생성하는 데 사용할 수 있는 컨테이너 이미지를 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도커 이니셜라이즈 명령어로 새로운 도커 파일을 쉽게 만들 수 있어요.\n\n위의 개요는 최소한의 Dockerfile을 시각화한 것입니다:\n\n![도커 파일](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_8.png)\n\n레이어는 Copy-on-Write(CoW) 파일 시스템입니다. 각 레이어는 이전 레이어와의 차이점 집합입니다. 어떤 레이어든 서로 쌓을 수 있어요. 파일을 추가하거나 제거하면 새로운 레이어가 생성돼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지는 여러 개의 레이어로 구성됩니다. 각 레이어는 Dockerfile에서의 한 명령을 나타냅니다. 여러 이미지가 동일한 레이어를 참조할 수 있습니다. 매우 마지막 레이어를 제외한 각 레이어는 읽기 전용입니다. 이미지는 상태를 저장하지 않습니다.\n\n컨테이너는 읽기-쓰기 (RW) 레이어입니다. 이미지의 최상위 쓰기 가능한 레이어의 자식입니다. 컨테이너에 새로운 데이터를 추가하거나 기존 데이터를 수정하는 모든 쓰기 작업은 이 쓰기 가능한 레이어에 저장됩니다. 컨테이너가 삭제되면 쓰기 가능한 레이어도 삭제됩니다. 기본 이미지는 변경되지 않습니다. 각 컨테이너는 자체의 쓰기 가능한 컨테이너 레이어를 갖습니다. 하나의 이미지에서 여러 컨테이너를 파생할 수 있습니다. 모든 변경 사항(새 파일 작성, 기존 파일 수정, 파일 삭제 등)은 이 얇은 쓰기 가능한 컨테이너 레이어에 저장되며, 여러 컨테이너가 동일한 기본 이미지에 접근할 수 있으면서 자체 데이터 상태를 갖게 됩니다.\n\n컨테이너 레이어에서는 Docker가 저장 드라이버를 사용하여 이미지 레이어 및 쓰기 가능한 컨테이너 레이어의 내용을 관리합니다. 각 저장 드라이버는 구현을 다르게 처리하나, 모든 드라이버는 쌓을 수 있는 이미지 레이어와 복사-온-라이트(CoW) 전략을 사용합니다.\n\n레이어들은 내부적으로 이미지와 유사하게 저장됩니다. 각 레이어는 /var/lib/docker/`driver`/layerdb/`algorithm`에 별도의 디렉토리를 갖습니다. Docker는 모든 캐시를 /var/lib/docker/`driver`에 저장하며, 여기서 `driver`는 다시 저장 드라이버 overlay2를 가리킵니다. 자세한 내용은 여기를 참조하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n$ docker ps -s 명령을 사용하여 실행 중인 컨테이너의 크기를 확인할 수 있습니다.\n\n각 컨테이너의 쓰기 가능한 레이어에 사용된 디스크의 총 데이터 양은 크기이고, 가상 크기는 컨테이너에 의해 사용되는 읽기 전용 이미지 데이터와 컨테이너의 쓰기 가능한 레이어 크기의 데이터 양입니다.\n\n다음은 최소한의 Go 파일을 작성해 봅시다:\n\n```go\npackage main\n\nfunc main() {\n    println(\"Hello, World!\")\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 명령을 실행하여 이미지를 빌드하세요:\n\n```js\n$ docker image build --tag minimal .\n```\n\n그러면 이 이미지를 미래의 예제에서 사용할 수 있습니다.\n\n도커 매니페스트\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도커 Manifest는 이미지를 설명하고 태그, 이미지의 원본을 확인하기 위한 디지턼 서명, 그리고 문서와 같은 메타데이터를 제공하는 JSON 형식의 파일입니다. Manifest는 컨테이너 런타임에서 사용하기 위해 만들어졌습니다.\n\nManifest Lists(또는 “fat manifest”)는 v2.2 이미지 명세서에서 정의되었으며, 이미지 레지스트리 내에서 다중 아키텍처 및 다중 플랫폼 이미지를 지원하는 주된 목적으로 존재합니다. 도커가 현재 지원하는 IANA 미디어 유형이 여러 가지 있습니다. 새로운 manifest 목록 객체 유형을 보고, 생성하고, 푸시하려면 manifest-tool이 당신이 찾고 있는 도구입니다.\n\n온라인에서 컨테이너 이미지와 해당 Manifest를 검사하려면 다음 링크를 사용하세요: https://oci.dag.dev/\n\n더 깊이 이해하고 싶다면, dive 도구를 사용하여 컨테이너 이미지를 살펴볼 수 있습니다. $ dive minimal 명령을 실행하여 이미지에 대한 다음 정보를 얻을 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지의 총 크기가 316MB인 것은 golang:1.17.3-alpine3.14 이미지의 불필요한 종속성 때문입니다. 이미지를 최적화하기 위해 다중 단계 빌드를 사용할 수 있습니다.\n\n여기서 scratch를 사용하고 있음을 주목해 주세요. FROM scratch는 Dockerfile에서 no-op이며 이미지에 추가적인 레이어를 만들지 않습니다. Docker에서 가장 작은 가능한 이미지이며 비어 있습니다 (폴더나 파일이 포함되어 있지 않음) 이미지를 빌드하기 위한 시작점입니다. scratch 이미지를 가져오거나 실행하거나 이름을 달아 다른 이미지에 태그를 붙일 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다이브 도구를 다시 실행하여 새 이미지 크기를 확인해보세요. 이제 1.2MB입니다!\n\n또한, 디스트로리스 이미지에 대해 언급해보는 것이 좋습니다:\n\nDrawbacks of Container Images\n\nSecurity\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컨테이너 보안은 컨테이너 세계에서 중요한 역할을 합니다. IT 조직들은 사기성 이미지를 모니터링하고, 개발자들에게 최상의 실행 방법을 가르쳐야 합니다. 이미지에 대한 엔터프라이즈 강화를 원하신다면 Docker CIS 보안 기준을 확인해보세요. 보안을 위해 컨테이너 이미지를 분석하고 최상의 실행 방법 이미지를 만들기 위해 dockle, hadolint 등과 같은 도구를 사용할 수 있습니다.\n\n예를 들어, 이미지의 사용자 라이브러리에 특정 취약점이 발견되었다고 가정해봅시다. 어떻게 스캔하고 어떻게 수정할 수 있을까요? 영향을 받는 영역은 무엇인가요?\n\n감염된 베이스 이미지를 찾아 교체해야 합니다. 노드의 모든 하위 자식은 그 취약점에 영향을 받을 것입니다. 우리는 모든 이러한 레이어가 해당 레이어에서 상속되었음을 알고 있습니다. 따라서, 취약점에 영향을 받을 컨테이너들을 모두 이해해야 합니다.\n\n컨테이너 이미지의 보안 취약점을 찾기 위해서는 정의된 패키지와 의존성을 분석하고, 알려진 보안 취약점을 확인해야 합니다. Aqua Security의 Trivy와 Quay의 Clair과 같은 스캐너는 최신 vuln-list를 사용하고 적극적으로 개발 중이므로 훌륭한 선택입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도커 스카우트는 이미지 내용을 분석하고 감지된 패키지와 취약점에 대한 자세한 보고서를 생성합니다. 또한 이미지 분석에서 발견된 문제를 해결하는 방법에 대한 제안도 제공할 수 있습니다.\n\n@lizrice의 Container Security 도서도 꼭 확인해보세요! Batuhan은 보안 및 클라우드 네이티브 관점에서 도커 뉴스를 자신의 substack에서 공유하고 있어요.\n\n기본적으로 안전한 컨테이너 이미지를 사용하세요: Chainguard Images by Chainguard는 최소주의와 보안을 위해 설계된 컨테이너 이미지 모음입니다. 이러한 이미지 중 많은 이미지는 distroless입니다. 즉, 애플리케이션 및 런타임 종속성만 포함하고 있으며 셸이나 패키지 관리자가 없습니다.\n\n저장 요구량\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지는 컨테이너 레지스트리에 저장됩니다. 컨테이너 레지스트리는 Open Container Initiative (OCI) 규격을 준수하는 레지스트리입니다. 개발자로서 컨테이너 이미지를 저장, 공유 및 관리하기 쉽게 만들어줍니다. 컨테이너 레지스트리는 사실상 \"Tarballs As A Service\"입니다.\n\n도커 레지스트리 HTTP API V2 규격은 Open Container Initiative (OCI)에서 distribution-spec으로 채택되었습니다.\n\n스토리지 자원을 최적화하기 위해 사용하지 않는 컨테이너 이미지를 제거하는 것이 좋을 것입니다. 완료된 컨테이너는 자동으로 제거되지 않습니다.\n\n컨테이너 이미지를 다운로드 크기를 줄이고 속도를 높이기 위해 eStargz를 사용하여 게으른 다운로드를 할 수 있습니다. (여기에 깊이 파헤친 노트가 있습니다.)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가비지 수집은 컨테이너 자원을 효율적으로 관리하는 중요한 측면이며, containerd에는 사용되지 않는 리소스를 회수하기 위한 가비지 수집 메커니즘이 포함되어 있습니다.\n\n또한, 컨테이너 이미지의 레이어를 암호화함으로써 빌드부터 런타임까지 끝간의 암호화를 보장할 수 있는 엄격한 신뢰 요구 사항을 얻을 수 있습니다. @lumjjb가 오픈컨테이너/image-spec에 Encrypted Layer Mediatype를 추가하는 아이디어를 제안했습니다. 이에 대해 더 알아보고 싶으시다면 CNCF 웨비나를 확인해보세요!\n\n결국, 우리는 왜 컨테이너 레지스트리에서 레이어 암호화를 지원하지 않을까 생각했고, Harbor 레지스트리를 위한 제안서를 작성하기로 결정했습니다! SBOM 지원을 위해 다른 제안서를 제출했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서명\n\n보안 중심 단계를 포함하는 것이 중요합니다. 이미지를 스캔하여 이미지의 무결성을 확인하여 변조로부터 보호합니다. 이미지 내용을 빌드 시 디지털로 서명하고 사용 전에 서명된 데이터를 확인하여 빌드와 실행 시의 이미지 데이터를 변조로부터 보호하여 발행자와 소비자 간의 무결성과 출처를 보장합니다. 여기서 도커의 Content Trust가 필요하며, Sigstore/Cosign 및 Notary와 같은 도구들이 등장하는 이유입니다! cosign에 대해 자세히 알고 싶다면 @dlorenc의 \"Signed Container Images\"를 읽어보세요! Notary와 Cosign의 차이가 궁금하신가요?\n\nLinux Foundation, BastionZero 및 Docker가 최근 발표한 OpenPubkey 프로젝트에 대해 자세히 알아보세요 - OpenPubkey와 Sigstore에 대해 더 알아보세요.\n\ncosign, rekor, fulcio 및 gitsign에 대해 더 알아보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSoftware 구성품 목록\n\n소프트웨어 공급망을 보호하기 위해서는 반드시 사용 중인 소프트웨어를 파악하는 것부터 시작해야 합니다. 라이브러리, 의존성, 패키지 등으로 구성된 소프트웨어 구성요소 목록을 작성해야 합니다. 우리는 이를 소프트웨어 재료라고 부를 수 있습니다. 이 \"재료\" 목록은 소프트웨어 부품 목록(Software Bill of Materials, SBOM)이라고 알려져 있습니다. SBOM은 주어진 소프트웨어를 빌드(컴파일 및 링크)하는 데 필요한 컴포넌트, 라이브러리 및 모듈의 완전하고 형식적인 구성 목록이며 공급망입니다.\n\nAnchore의 syft 도구를 사용하여 컨테이너 이미지의 SBOM을 쉽게 생성한 후 grype로 취약점을 찾아 스캔할 수 있습니다!\n\n실험적인 docker sbom 명령을 사용하여 컨테이너 이미지의 SBOM을 생성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 컨테이너\n\n리눅스 컨테이너는 리눅스에서 실행되는 하나 이상의 프로세스를 실행하기 위한 격리되고 제약된 상자일 뿐입니다. 여기서 '상자'라는 말은 독립된 프로세스가 자체 프로세스 이름공간을 가지고 시작한다는 것을 의미합니다. 컨테이너화된 프로세스는 시스템 호출을 통해 커널과 상호작용하며, 일반적인 프로세스와 마찬가지로 권한이 필요합니다. 컨테이너는 호스트 시스템의 커널을 공유하며 (선택적으로) 시스템 내의 다른 컨테이너로부터 격리됩니다. 최소한의 컨테이너는 그 안에 단일 실행 파일만 포함하고 있습니다.\n\n컨테이너로 진입하면 해당 컨테이너 내에서 실행 중인 프로세스만 볼 수 있습니다. 일반적으로 컨테이너 당 한 프로세스를 사용합니다. 컨테이너 프로세스는 컨테이너 자체의 수명주기와 바인딩되어 있습니다: 컨테이너 시작/종료 시 컨테이너 프로세스도 시작/종료됩니다. 전체 수명주기가 엄격하게 결합되어 있습니다.\n\n컨테이너를 사용하면 모든 종속성이 포함됩니다. 커널 상위에 필요한 것들이 모두 컨테이너 내에 패키지화되어 있습니다. 컨테이너는 호스트의 커널을 공유합니다. 컨테이너 내에서는 호스트의 전체 파일 시스템을 볼 수 없으며, 대신 루트 디렉토리가 만들어진 컨테이너에 맞게 변경됩니다. 컨테이너를 OS에서 실행할 때, 실제로는 아무 것도 설치하지 않습니다. 컨테이너는 OS 위에 위치하고 자체의 세계에서 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n멋진 참고 자료: 컨테이너는 리눅스 프로세스가 아닙니다!\n\n**네임스페이스**\n\n리눅스 커널은 많은 응용 프로그램들이 시스템 상에서 실행될 수 있도록 공통 기능을 제공하는 개념을 갖고 있습니다. 이 개념은 네임스페이스라고 불립니다. 이것은 컨테이너 기술의 기반이 됩니다.\n\n리눅스 네임스페이스는 파일 시스템, 사용자 관리, 마운트된 장치, 프로세스, 네트워크를 포함한 다양한 추상화를 위해 존재합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNamespace는 6 + 1단계에서 컨테이너가 격리를 가지도록 합니다. 각 네임스페이스의 목적은 특정 전역 시스템 자원을 추상화하여 네임스페이스 내 프로세스들이 전역 자원의 격리된 인스턴스를 갖는 것처럼 보이게 하는 것입니다.\n\n![이미지](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_11.png)\n\n사용자(USER): [CLONE_NEWUSER]: 사용자와 그룹 ID를 격리합니다. 프로세스의 사용자 ID와 그룹 ID는 사용자 네임스페이스 내외에서 다를 수 있습니다.\n\nPID: (프로세스 ID): [CLONE_NEWPID]: 프로세스 ID를 격리하여 각 컨테이너가 자체 init을 갖도록 합니다. 프로세스는 네임스페이스 내부와 호스트 시스템 외부에서 두 개의 PID를 갖습니다. Docker 컨테이너 내에서 Init 시스템을 확인하세요. - @BeNitinAgarwal\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUTS(UNIX 시간 공유 시스템): [CLONE_NEWUTS]: 호스트 이름 (uname() 시스템 콜)과 네트워크 정보 서비스 (NIS) 도메인 이름을 격리합니다.\n\nNET(네트워크): [CLONE_NEWNET]: 네트워크 인터페이스 컨트롤러를 격리합니다. (예: 장치, IP 주소, IP 라우팅 테이블, /proc/net 디렉토리, 포트 번호 등)\n\nMNT(마운트): [CLONE_NEWNS]: 파일 시스템 마운트 지점을 격리합니다. (mount() 및 umount() 시스템 콜)\n\nIPC(프로세스 간 통신): [CLONE_NEWIPC]: 시스템 V IPC 객체 및 POSIX 메시지 큐를 격리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시간 네임스페이스에 대해 논의가 있었습니다.\n\n네임스페이스 격리는 프로세스 그룹이 분리되어 다른 그룹의 리소스를 \"보지\" 못하게 하는 것을 의미합니다: [11]\n\n- 다른 UTS 네임스페이스의 프로세스는 각각의 전용 호스트 이름을 볼 수 있고 독립적으로 호스트 이름을 편집할 수 있습니다.\n- 다른 사용자 네임스페이스의 프로세스는 사용자 목록을 각자 가지고 있고 다른 프로세스에 영향을 주지 않고 사용자를 추가하거나 제거할 수 있습니다.\n- 각 PID 네임스페이스의 프로세스는 해당 네임스페이스에 속한 각 PID에 대해 다른 PID를 받으며, 각 PID 네임스페이스는 자체 PID 트리를 가지고 있습니다.\n- 프로세스는 항상 각 유형의 하나의 네임스페이스에 정확히 속해 있습니다.\n\n프로세스를 네임스페이스에 넣음으로써 해당 프로세스에 표시되는 리소스를 제한할 수 있습니다. 네임스페이스의 기원은 Plan 9로 거슬러 올라갑니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네임스페이스 개념은 리소스 관리와 우선 순위 설정을 적용하기 위해 cgroups의 도움으로 확장되었습니다: Linux 컨테이너는 제한된 리소스(예: 메모리, CPU, I/O, 네트워크 등)를 사용하도록 제어 그룹(cgroups)을 활용합니다. 이를 통해 컨테이너가 호스트 리소스를 모두 소비하는 것을 방지할 수 있습니다. 따라서 적절히 조정된 cgroups가 보안 관점에서 중요합니다.\n\n제어 그룹 (cgroups)\n\nCgroups를 사용하면 격리의 특정 정도를 적용하고 프로세스가 수행할 수 있는 작업을 제한할 수 있습니다: 기능, 리소스 한도 등. 이것은 컨테이너의 런타임 정의의 기본 개념입니다. 컨테이너를 시작할 때 런타임은 새 cgroups를 생성합니다.\n\nCgroup은 CPU 및 메모리 사용량을 제한하는 것뿐만 아니라 /dev/sda1과 같은 장치 파일에 대한 액세스를 제한합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로세스 그룹 내에서 허용된 총 프로세스 수를 제한하려면 pid라는 제어 그룹이 있습니다. 이는 포크 폭탄의 효과를 방지할 수 있습니다.\n\n리눅스 커널은 cgroups에 관한 정보를 /sys/fs/cgroup에 주로 위치하는 의사 파일 시스템 세트를 통해 송수화합니다. 컨테이너 내부에서는 /proc에서 사용 가능한 자체 cgroup 목록이 있습니다. 각 cgroup은 cgroup.procs라는 인터페이스 파일을 갖고 있는데, 이 파일은 cgroup에 속한 모든 프로세스의 PID를 한 줄씩 나열합니다. [12]\n\n루트리스 컨테이너\n기본적으로 컨테이너는 루트로 실행됩니다. 그러나 컨테이너 내의 프로세스를 제어할 수 있는 공격자도 어떤 식으로든 컨테이너를 탈출해야 하며, 결국 호스트 머신에서 루트 권한을 가질 수밖에 없습니다.\n\nLinux 커널의 사용자 네임스페이스(UserNS)를 사용하여 가짜 권한을 에뮬레이션하는 루트리스 컨테이너가 생성됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRootless containers는 권한이 없는 사용자가 컨테이너를 생성, 실행 및 관리할 수 있는 능력을 의미합니다. 권한이 없는 사용자는 관리자 권한이 없고 추가 권한을 요청할 수도 없습니다. 권한이 없는 사용자는 컨테이너가 실행될 사용자 및 그룹 범위를 관리합니다.\n\n도커 19.03에서는 루트리스 모드 (루트리스 runc, containerd 및 BuildKit)의 거의 모든 기능을 제공하며 포트 포워딩 및 다중 컨테이너 네트워킹을 지원합니다. 리소스 제한 기능은 도커 20.10에서 Control Group v2를 사용하여 구현되었습니다. 즉, Control Group v1에서는 루트리스 컨테이너를 관리할 수 없습니다. cgroup v2 컨트롤러를 비루트 사용자에게 활성화하고 위임하는 것은 최신 버전 (≥ 244)의 systemd를 권장합니다. 이전 systemd는 cpuset 컨트롤러의 위임을 지원하지 않습니다. 버전 5.2보다 낮은 커널은 freezer 부족으로 권장되지 않습니다.\n\n사용자 공간에서 특권 작업을 제한하는 몇 가지 라이브러리가 있습니다.\n\n- rootless-containers/slirp4netns: 루트리스 네트워크 네임스페이스에 대한 사용자 모드 네트워킹(\"slirp\")을 제공하여 네트워크 생성/상호 작용을 제한합니다.\n- containers/fuse-overlayfs: rootless 컨테이너용 FUSE에서 overlay+shiftfs의 구현: 루트 파일 시스템 및 사용자 ID, 그룹 ID 처리를 상호 작용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도커와 다른 컨테이너 엔진은 가능한 컨테이너 탈출 공격으로부터 호스트의 실제 루트를 보호하기 위해 RootlessKit을 사용합니다.\n\n## 네임스페이스\n\n네임스페이스는 리눅스 컨테이너의 기본적인 측면입니다!\n\n리눅스 네임스페이스는 2002년 2.4.19 커널에서 원본이 되었습니다! 2006년부터 시작되어 미래에 이르기까지 추가 네임스페이스가 계속해서 추가되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n적절한 컨테이너 지원 기능은 사용자 네임스페이스의 도입을 통해 커널 버전 3.8에서 완료되었습니다.\n\n## 커널\n\n커널은 \"항상 메모리에 상주하는 운영 체제 코드 부분\"으로, 하드웨어와 소프트웨어 구성 요소 간의 상호 작용을 용이하게 합니다. 전체 커널은 장치 드라이버를 통해 모든 하드웨어 리소스(예: I/O, 메모리, 암호화)를 제어하며, 이러한 리소스에 관한 프로세스 간 충돌을 조정하고 CPU 및 캐시 사용, 파일 시스템 및 네트워크 소켓의 공통 리소스 활용을 최적화합니다.\n\n커널의 인터페이스는 저수준 추상화 계층입니다. 프로세스가 커널에 서비스를 요청할 때는 일반적으로 래퍼 함수를 통해 시스템 호출을 호출해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도커 커널 모듈\n\n커널 모듈은 Linux 커널에 동적으로 로드되어 기능을 확장하거나 특정 기능을 제공하는 코드 조각입니다. 도커의 경우 컨테이너화 및 저장 기능을 구현하기 위해 커널 기능과 모듈을 활용합니다.\n\noverlay2 스토리지 드라이버는 여러 레이어의 컨테이너 이미지를 서로 쌓을 수 있는 복사본-쓰기(CoW) 메커니즘입니다. 이 드라이버는 Linux 커널이 제공하는 overlay 파일 시스템을 활용하여 여러 디렉토리를 단일 마운트 포인트 위에 쌓아서 파일 시스템의 통합적이고 레이어드된 뷰를 만듭니다.\n\n모듈 overlay 경로를 확인하려면: $ modprobe overlay. 모듈 폴더는 /lib/modules/5.11.0–38-generic와 같은 위치에 저장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 오픈 컨테이너 이니셔티브\n\n오픈 컨테이너 이니셔티브(OCI)는 컨테이너 형식과 런타임에 대한 오픈 산업 표준을 만들기 위한 목적으로 구성된 경량의 오픈 거버넌스 구조(프로젝트)로, 리눅스 재단의 보호 아래 형성되었습니다. OCI는 2015년 6월 22일 Docker, CoreOS 및 기타 컨테이너 산업의 선도 업체들에 의해 시작되었습니다.\n\nOCI는 현재 두 가지 명세를 포함하고 있습니다: 런타임 명세(runtime-spec) 및 이미지 명세(image-spec). 런타임 명세는 디스크에 풀어 헤처진 \"파일 시스템 번들\"을 실행하는 방법에 대해 기술합니다. 상위 수준에서, OCI 구현은 OCI 이미지를 다운로드한 다음 그 이미지를 OCI 런타임 파일 시스템 번들로 풀어 헤칩니다. 이 시점에서 OCI 런타임 번들은 OCI 런타임에 의해 실행됩니다.\n\nOCI Slack 채널에 가입하여 최신 정보를 받아보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## OCI Runtime Spec\n\n오픈 컨테이너 이니셔티브는 운영 체제 프로세스 및 응용 프로그램 컨테이너에 대한 표준 사양을 개발합니다. 오픈 컨테이너 이니셔티브 런타임 사양(opencontainers/runtime-spec)은 컨테이너의 구성, 실행 환경 및 수명 주기를 명시하는 것을 목표로 합니다.\n\n컨테이너의 구성은 지원되는 플랫폼의 config.json으로 지정되며, 컨테이너를 생성할 수 있게 하는 필드를 설명합니다. 구성에 대한 JSON 스키마를 유효성 검사하려면 validate.go 파일을 사용하세요. 여기에는 일부 스키마 레이아웃이 있습니다:\n\n- config-schema.json — 구성 스키마의 주요 진입점\n- state-schema.json — 상태 JSON 스키마의 주요 진입점\n- defs.json — 일반 유형에 대한 정의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실행 환경은 컨테이너 내에서 실행되는 응용 프로그램이 런타임 중에 일관된 환경을 갖도록 지정되었으며, 컨테이너의 라이프사이클을 정의하는 공통 작업이 포함되어 있습니다. \n\n런타임은 다음 작업을 반드시 지원해야 합니다:\n\n- 상태 `container-id`\n- 생성 `container-id` `path-to-bundle`\n- 시작 `container-id`\n- 종료 `container-id` `signal`\n- 삭제 `container-id`\n\nrunc\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nrunc은 OCI 사양에 따라 Linux 컨테이너를 생성하고 실행하는 CLI 도구입니다. runc는 컨테이너 이미지에 포함된 파일을 사용하여 컨테이너를 시작하고, Linux 커널에게 적절한 네임스페이스, cgroups 컨텍스트 등에서 프로세스를 시작하도록 지시합니다.\n\n도커는 OCI에 그 새로운 노력의 중심이 되기 위해 컨테이너 형식 및 런타임인 runc을 기부하고 있습니다.\n\nGo 자체의 런타임은 멀티 스레드입니다. setns(2)는 멀티 스레드 프로세스에 사용할 수 없습니다. 따라서 runC는 언어 런타임이 시작되기 전에 C 프로세스를 실행합니다. 그러나 이 작업은 Go의 main 함수에 도달하기 전에 수행되어야 합니다. 따라서 create 하위 명령어는 init 하위 명령어를 호출하고, init 하위 명령어는 init() 함수에서 C 프로세스를 호출합니다. nsenter 패키지는 Go 런타임이 부팅될 기회가 생기기 전에 호출되는 특별한 init 생성자를 등록합니다.\n\nrunc은 컨테이너 프로세스가 시작되기 전에 환경 설정을 위해 C로 작성된 libcontainer 모듈을 사용하여 자체를 다시 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## crun\n\ncrun은 컨테이너를 실행하는 빠르고 가볍고 완전한 기능을 제공하는 OCI 런타임 및 C 라이브러리입니다. Red Hat이 주도하는 C로 완전히 작성된 OCI Runtime Spec의 또 다른 구현체입니다. 수 년간 함께해 왔으며, cri-o의 기본 런타임입니다.\n\ncrun은 OCI 컨테이너를 관리하는 외부 프로세스를 필요로 하지 않고도 프로그램에 쉽게 포함될 수 있는 라이브러리로도 사용할 수 있도록 목표로 합니다.\n\ncrun은 /bin/true를 100번 실행하는 데 runc보다 49.4% 빠르며, 훨씬 낮은 메모리 풋프린트를 갖추고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nrailcar (archieved)\n\nrailcar은 OCI 런타임 사양의 Rust 구현입니다. 참조 구현인 runc과 유사하지만, Rust로 완전히 구현되어 있어 메모리 안전성을 위해 가비지 컬렉터나 여러 스레드가 필요하지 않습니다.\n\n@vishvananda의 \"Rust로 컨테이너 런타임 빌드하는 방법\" 기사를 놓치지 않는 것이 좋습니다.\n\nyouki\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nyouki는 Rust에서 OCI 런타임 사양을 구현한 프로젝트입니다! 프로젝트의 동기는 정말 멋집니다: 메모리 안정성, 더 빠르고 덜 메모리를 사용할 수 있는 가능성! 이 프로젝트는 railcar에서 영감을 받았습니다. 프로젝트의 설계 및 구현 세부 정보를 확인하는 것을 잊지 마세요.\n\n## OCI 런타임 도구\n\nruntime-tools는 OCI 런타임 사양과 함께 작업하는 도구 모음입니다:\n\n-  $ oci-runtime-tool generate: OCI 번들을 위한 구성 JSON을 생성합니다. runc와 같은 OCI 호환 런타임은 구성을 config.json에서 읽을 것으로 예상합니다.\n-  $ oci-runtime-tool validate: OCI 번들을 검증합니다. OCI 번들이 유효성 검사 과정에 실패하면 오류 메시지가 인쇄됩니다.\n-  $ sudo RUNTIME=runc validation/default/default.t: 런타임 검증 스위트를 실행합니다. 예를 들어, youki의 integration_test.sh로 이동하여 테스트 케이스를 실행하는 방법을 확인할 수 있습니다. crun은 테스트를 실행하기 위해 oci-runtime-validation을 사용합니다. runc는 대부분 통합 테스트 케이스를 실행하기 위해 bats-core를 사용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n도커의 내부 작업을 탐구하면 복잡하고 복잡한 기술 생태계와 협력이 드러나게 됩니다. 도커 데스크톱부터 리눅스 cgroups까지 고수준과 저수준 아키텍처에 대한 심층적인 탐구를 통해 컨테이너 세계가 처음에 보이던 것보다 간단하지 않음이 분명해졌습니다.\n\n도커를 이해하는 여정은 다음과 같은 많은 가치 있는 통찰과 배움으로 가득했습니다:\n\n- 컨테이너를 강력하고 다양하게 만드는 다양한 구성 요소를 원활하게 통합하기 위해 필요한 노력과 전문 지식에 대한 깊은 이해를 얻었습니다.\n- 이 기술에 대한 이해력이 향상되었을 뿐만 아니라 끝에서 끝까지 프로세스를 원활하게 만드는 데 끊임없이 노력하는 무수히 많은 개인들의 협력을 강조했습니다.\n- 복잡성을 수용하고 지속적인 학습에 투자하는 것은 우리가 컨테이너의 힘을 이용하고 번성하는 컨테이너화 생태계에 기여하는 데 도움이 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n바투한 아페이딘과 야신 타하 에롤에게 기여해줘서 감사합니다!\n\n# 다음 단계\n\n최신 업계 뉴스, 프로젝트 및 새로운 릴리스에 대해 계속해서 최신 정보를 유지하는 중요성을 강조하는 것이 중요합니다. 컨테이너화 분야는 지속적으로 발전하고 있으며 개선과 혁신이 지속적으로 이루어지고 있습니다. 업계 트렌드를 적극적으로 따라가면 우리의 지식이 현재의 것이며 관련성을 유지할 수 있습니다.\n\n뉴스를 따르고 Slack 및 메일 그룹에 참여하여 항상 최신 상태를 유지하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Docker: [Blog](https://www.aquasec.com/cloud-native-academy/docker-container/docker-containers-vs-virtual-machines/) — [GitHub](https://www.tiejiang.org/23394.html) — [Twitter](https://www.pngegg.com/en/png-pbils) — [Slack](https://stackoverflow.com/a/47023753/5685796) — [HNRSS](https://ops.tips/blog/dockerfile-golang/) — [Reddit](https://blog.ramlot.eu/containers/)\n- OCI: [GitHub](https://github.com/opencontainers/runtime-spec/blob/main/spec.md) — [Twitter](https://iximiuz.com/en/posts/oci-containers/) — [Slack](https://www.oreilly.com/library/view/kubernetes-in-action/9781617293726/) — [Mail Group](https://www.oreilly.com/library/view/container-security/9781492056690/)\n- Containerd: [GitHub](https://github.com/containerd/containerd) — [Twitter](https://twitter.com/containerd) — [CNCF Slack](https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/#crictl)\n\n쿠버네티스와 같은 컨테이너 오케스트레이션 플랫폼을 배우면서 여러분의 스킬셋을 확장해보세요. 제가 강력히 권장하는 부분이죠. 이를 통해 실무 능력을 더욱 향상하고 복잡한 환경 내에서 컨테이너를 효율적으로 관리하고 오케스트레이션하는 방법에 대한 더 깊은 이해를 얻을 수 있을 거에요.\n\n# 참고 자료\n\n[0]: https://www.aquasec.com/cloud-native-academy/docker-container/docker-containers-vs-virtual-machines/\n[1]: https://www.tiejiang.org/23394.html\n[2]: https://www.pngegg.com/en/png-pbils\n[3]: https://opencontainers.org/about/overview/\n[4]: https://stackoverflow.com/a/47023753/5685796\n[5]: https://ops.tips/blog/dockerfile-golang/\n[6]: https://iximiuz.com/en/posts/oci-containers/\n[7]: https://en.wikipedia.org/wiki/Linux_namespaces\n[8]: https://man7.org/linux/man-pages/man7/namespaces.7.html\n[9]: https://rootlesscontaine.rs/\n[10]: https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html/managing_containers/signing_container_images\n[11]: https://blog.ramlot.eu/containers/\n[12]: https://facebookmicrosites.github.io/cgroup2/docs/create-cgroups.html\n[13]: https://github.com/opencontainers/runtime-spec/blob/main/spec.md\n[14]: https://www.reddit.com/r/rust/comments/pweqkb/comment/hejdot0\n[15]: https://www.aquasec.com/cloud-native-academy/container-security/container-runtime-interface/\n[16]: https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/#crictl\n[17]: https://www.oreilly.com/library/view/kubernetes-in-action/9781617293726/\n[18]: https://developpaper.com/practice-of-docker-file-system/\n[19]: https://www.alibabacloud.com/blog/cri-and-shimv2-a-new-idea-for-kubernetes-integrating-container-runtime_594783\n[20]: https://vitalflux.com/docker-images-containers-internals-for-beginners/\n[21]: https://www.oreilly.com/library/view/container-security/9781492056690/\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 게시물이 유익했고 도커의 내부 작업을 종합적으로 탐구하는 것을 즐겁게 경험하셨기를 바랍니다. 언제든지 트위터나 GitHub에서 연락주세요.\n\n![image](https://miro.medium.com/v2/resize:fit:292/0*KGm2_fqSSkfEfZbJ.gif)\n\n푸르칸 튀르칼","ogImage":{"url":"/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_0.png"},"coverImage":"/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_0.png","tag":["Tech"],"readingTime":34},{"title":"러스트 배우기 베어 쓰레딩","description":"","date":"2024-06-19 00:46","slug":"2024-06-19-LearningRustBareThreading","content":"\n\n\n![이미지](/assets/img/2024-06-19-LearningRustBareThreading_0.png)\n\n리눅스에서 스레드를 생성하는 방법을 아시나요? CPU에서 작업을 스케줄링하기 위해 원시 파이프를 사용하는 방법은 어떤가요? 스레드 간에 클로저를 전달할 수 있을까요?\n\n시스템 프로그래밍에서 Concurrency와 Multi-threading은 중요합니다. Concurrency는 여러 I/O 바운드 작업을 동시에 관리하는 능력을 가리키며, 하나의 스레드 내에서 실행되더라도 동시에 진행 중인 것처럼 보이게 합니다. Multi-threading은 CPU 바운드 작업을 처리하기 위해 여러 스레드를 생성하는 것을 의미하며, CPU가 여러 코어를 가지고 있는 경우 진정한 병렬성을 달성할 수 있습니다. 이 두 용어는 종종 혼동되는데, 둘 다 작업을 동시에 실행하는 문제를 다루기 때문입니다.\n\nConcurrency를 만드는 한 가지 방법은 이벤트 루프입니다. 최근에 리눅스의 uring을 사용하여 작업한 경험이 있습니다. no-std 환경에서 async/await 런타임의 작동 버전을 만들었습니다. 이것은 주 스레드에서 실행되며 병렬로 실행되는 작업의 느낌을 줍니다. 다음 예시를 살펴보겠습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\npub struct HelloCommand {\n    pub msg: \u0026'static [u8],\n}\n\nimpl HelloCommand {\n    pub async fn execute(self) -\u003e Option\u003c\u0026'static [u8]\u003e {\n        let stdout = open_stdout();\n        let written = match write_stdout(\u0026stdout, self.msg).await {\n            StdOutWriteResult::Succeeded(_, written) =\u003e written,\n            StdOutWriteResult::OperationFailed(_, _) =\u003e return Some(APP_STDOUT_FAILED),\n            StdOutWriteResult::InternallyFailed() =\u003e return Some(APP_INTERNALLY_FAILED),\n        };\n\n        if written as usize != self.msg.len() {\n            return Some(APP_STDOUT_INCOMPLETE);\n        }\n\n        None\n    }\n}\n```\n\n이 예제에서는 표준 출력에 메시지를 출력하는 것을 보여줍니다. 주목할만한 중요한 점은 이것이 비동기 함수로 실행되며 차단되지 않는다는 것입니다. 내부적으로 I/O Ring 런타임을 사용합니다.\n\n이미 std-out에 쓰는 방법을 알고 있으므로 쉽게 파이프에 쓸 수 있습니다. Linux의 많은 구성 요소는 Linux에서 파일 디스크립터로 추상화되어 있기 때문에 유사한 메커니즘을 공유합니다. 그렇다면 파이프는 무엇일까요.\n\n파이프는 메시지를 한 방향으로만 전달할 수 있는 마법 버퍼 터널입니다. 구체적으로 작성자와 리더 엔드포인트가 있습니다. 두 엔드포인트 모두 별도의 파일 디스크립터를 가지고 있습니다. pipe2 시스템 호출을 사용하여 이를 만들 수 있습니다. 만들어진 디스크립터에 대한 두 개의 32비트 정수 배열을 인수로 받습니다. 선택적으로 플래그도 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\npub fn sys_pipe2(pipefd: *mut u32, flags: u32) -\u003e isize {\n    unsafe {\n        let ret: isize;\n\n        asm!(\n            \"syscall\",\n            in(\"rax\") 293,\n            in(\"rdi\") pipefd,\n            in(\"rsi\") flags,\n            lateout(\"rcx\") _,\n            lateout(\"r11\") _,\n            lateout(\"rax\") ret,\n            options(nostack)\n        );\n\n        ret\n    }\n}\n```\n\n시스템 호출은 두 개의 파일 기술자로 파이프를 전달합니다. 첫 번째 파일 기술자는 리더이며, 다른 한쪽은 라이터여야 합니다. 파이프에 메시지를 쓸 때 커널에 의해 버퍼링됩니다. 커널 설정 뒤에 기본 크기를 확인할 수 있습니다:\n\n```bash\n# cat /proc/sys/fs/pipe-max-size\n1048576\n```\n\n위의 사실들을 고려하여 Hello World 응용 프로그램을 작성할 수 있습니다. 이 응용 프로그램은 메시지를 파이프에 쓰고, 해당 메시지를 읽어서 최종적으로 std-out에 인쇄합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\npub struct PipeCommand {\n    pub msg: \u0026'static [u8],\n}\n\nimpl PipeCommand {\n    pub async fn execute(self) -\u003e Option\u003c\u0026'static [u8]\u003e {\n        let stdout = open_stdout();\n        let (reader, writer) = match create_pipe() {\n            CreatePipe::Succeeded((reader, writer)) =\u003e (reader, writer),\n            _ =\u003e return Some(APP_PIPE_CREATING_FAILED),\n        };\n\n        let reader = spawn(async move {\n            let buffer = match mem_alloc(1 * 4096) {\n                MemoryAllocation::Failed(_) =\u003e return Some(APP_MEMORY_ALLOC_FAILED),\n                MemoryAllocation::Succeeded(value) =\u003e value.droplet(),\n            };\n\n            let (buffer, cnt) = match read_pipe(\u0026reader, buffer).await {\n                PipeReadResult::Succeeded(buffer, cnt) =\u003e (buffer, cnt),\n                _ =\u003e return Some(APP_PIPE_READING_FAILED),\n            };\n\n            let slice = match buffer.between(0, cnt as usize) {\n                HeapSlicing::Succeeded(value) =\u003e value,\n                _ =\u003e return Some(APP_MEMORY_SLICE_FAILED),\n            };\n\n            let written = match write_stdout(\u0026stdout, \u0026slice).await {\n                StdOutWriteResult::Succeeded(_, written) =\u003e written,\n                _ =\u003e return Some(APP_STDOUT_FAILED),\n            };\n\n            if written as usize != self.msg.len() {\n                return Some(APP_STDOUT_INCOMPLETE);\n            }\n\n            match close_pipe(reader).await {\n                PipeCloseResult::Succeeded() =\u003e None,\n                _ =\u003e Some(APP_PIPE_CLOSING_FAILED),\n            }\n        });\n\n        let writer = spawn(async move {\n            match write_pipe(\u0026writer, self.msg).await {\n                PipeWriteResult::Succeeded(_, _) =\u003e (),\n                _ =\u003e return Some(APP_PIPE_WRITING_FAILED),\n            }\n\n            match close_pipe(writer).await {\n                PipeCloseResult::Succeeded() =\u003e None,\n                _ =\u003e Some(APP_PIPE_CLOSING_FAILED),\n            }\n        });\n\n        match reader.await {\n            SpawnResult::Succeeded() =\u003e (),\n            _ =\u003e return Some(APP_IO_SPAWNING_FAILED),\n        }\n\n        match writer.await {\n            SpawnResult::Succeeded() =\u003e (),\n            _ =\u003e return Some(APP_IO_SPAWNING_FAILED),\n        }\n\n        None\n    }\n}\n```\n\n위 목록은 내가 개발한 비동기/대기 런타임에 완전히 의존하기 때문에 조금 혼란스러울 수 있습니다. 이는 파이프가 I/O Ring과 잘 작동한다는 것을 보여줍니다.\n\n파이프는 동기화 도구에 의존하지 않고 간소화된 IPC에 좋습니다. 몇 개의 스레드가 있으면 주 스레드와 워커 스레드 간에 메시지를 전달할 수 있습니다. 리눅스에서 스레드는 흥미로운 것입니다. 우리는 스레드를 만들지 않습니다. 우리 자신의 프로세스를 복제하고 가상 메모리, 파일 디스크립터, 시그널 핸들러 또는 스레드 그룹을 공유할 것임을 커널에 지시합니다.\n\n새 스레드를 생성하면 가장 흥미로운 부분은 자식 스레드가 시작하는 곳입니다. 우리가 고수준 라이브러리가 우리를 위해 추상화한 대로 함수 포인터를 전달하지 않습니다. 새 스레드는 정확히 우리가 자신을 복제하는 시스템 콜을 호출한 시점에서 계속됩니다. 부모 스레드와 자식 스레드를 구분짓는 것은 무엇인가요? 스택과 시스템 콜 결과입니다. 시스템 콜을 호출하기 전에 스택을 미리 생성해야 하며, 시스템 콜은 부모 스레드에서는 양수를 반환하고 자식 스레드에서는 0을 반환합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클론 생성 및 쓰레드를 구별하기 위해 코드에서 if 문을 사용하는 아이디어가 약간 이상하고 안타깝게도 권장되는 방법 중 하나입니다. 이 경우 부모 스택에서만 사용할 수 있는 일부 변수를 사용하려 하면 문제가 발생할 수 있습니다. 컴파일러가 이를 올바르게 처리하지 못할 수 있습니다. 다행히 Chris Wellons의 멋진 블로그 포스트가 있습니다. 그는 사용자 코드 분기를 피하고 프로세서가 자동으로 올바른 함수를 호출하고 점프하도록 스택을 준비하는 훌륭한 속임수를 설명합니다.\n\n더 깊게 설명해 드리겠습니다. 클론 후 두 스택을 생각해 보겠습니다:\n\n```js\n       +-----------------------------+  +-----------------------------+\n       |          부모               |  |           자식              |\n0x1000 +-----------------------------+  +-----------------------------+ 0xa000\n       |                             |  |                             |\n       |                             |  |                             |\n   RSP |                             |  |                             |\n0x1d00 |-----------------------------|  |                             |\n       | 반환: 0xb700                |  |                             |\n0x1e00 |-----------------------------|  |                             |\n       | 반환: 0xb980                |  |                             |\n       |   변수: val3               |  |                             |\n       |   변수: val4               |  |                             |\n0x1f00 |-----------------------------|  |                             |\n       | 반환: 0xb120                |  |                             |\n       |   변수: val1               |  |                             |\n       |   변수: val2               |  |                             | RSP\n0x2000 +-----------------------------+  +-----------------------------+ 0xb000\n```\n\n스택이 아래쪽으로 성장한다는 것을 기억하면, 현재 부모 RSP 레지스터가 0x1d00을 가리키는 것을 관찰할 수 있습니다. 이 위치에는 모든 로컬 스택 변수가 들어 있고 RET 명령이 실행될 경우 계속할 함수(0xb700)를 가리키는 포인터가 저장되어 있습니다. RET 명령은 스택에서 값을 팝하여 RIP 레지스터에 넣습니다. 자식 쪽에는 아무 것도 없으므로 자식 코드는 어떤 변수도 참조하거나 호출자에게 반환할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 표를 마크다운 형식으로 변경해드릴게요.\n\n\n|       Parent       |       Child       |\n|---------------------|-------------------|\n| 0x1000             | 0xa000               |\n|---------------------|-------------------|\n|                     |                   |\n|                     |                   |\n|                     |                   |\n|                     |                   |\n| return: 0xb700      |                   |\n|---------------------|                   |\n| return: 0xb980      |                   |\n| variable: val3      |                   |\n| variable: val4      |                   |\n|---------------------|                   |\n| return: 0xb120      |                   |\n| variable: val1      |                   |\n| variable: val2      |                   |\n|---------------------|-------------------|\n\n\n리턴(call) 명령을 실행할 때 0xb700부터 실행될 것이라는 정보가 0x1d00에 저장되어 있다고 상상해봐요. 현재 부모 호출에 있으며 스택이 0x1d00을 가리키고 있습니다. 우리가 현재 실행 중인 코드가 쓰레드로 프로세스를 복제하고, 새로운 RSP로 0xaf80을 전달한다면, 새로운 스택도 RET 명령을 만날 것이지만, 이번에는 0xb800부터 계속될 것입니다. 스택이 가리키고 있기 때문이죠. 아름다운 것 같죠?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 한 걸음 더 나아가서 스택을 더 깊게 준비할 수 있습니다. 0xb800 뒤에 있는 코드도 워커 인자를 포함하는 구조체에 대한 포인터를 사용할 수 있으면 좋겠습니다. 구조체를 스택의 끝에 (바닥에) 배치하고, 그 포인터를 RDI 레지스터에 넣고 싶습니다 (System V ABI). 최종 메모리 레이아웃은 다음과 같이 보일 것입니다:\n\n```js\n       +-----------------------------+  +-----------------------------+\n       |          Parent             |  |           Child             |\n0x1000 +-----------------------------+  +-----------------------------+ 0xa000\n       |                             |  |                             |\n   RSP |                             |  |                             |\n0x1c00 |-----------------------------|  |                             |\n       | current RDI value           |  |                             | RSP\n0x1d00 |-----------------------------|  |-----------------------------| 0xad00\n       | return: 0xb700              |  | 0xae80                      |\n0x1e00 |-----------------------------|  |-----------------------------| 0xae00\n       | return: 0xb980              |  | return: 0xb800              |\n       |   variable: val3            |  |-----------------------------| 0xae80\n       |   variable: val4            |  | struct:                     |\n0x1f00 |-----------------------------|  |   field: val1               |\n       | return: 0xb120              |  |   field: val2               |\n       |   variable: val1            |  |   field: val3               |\n       |   variable: val2            |  |   field: val4               |\n0x2000 +-----------------------------+  +-----------------------------+ 0xb000\n```\n\n현재 스택의 맨 위에는 반환하기 전에 RDI 레지스터에 넣을 값이 포함되어 있습니다. 이런 방식으로, 부모 스레드의 이전 변경되지 않은 RDI 값과 0xae80 메모리 주소에 있는 함수의 첫 번째 매개변수로 볼 구조체에 대한 포인터가 포함됩니다.\n\n이제 rust와 어셈블리 코드를 작성할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\narch::global_asm!(\n    \"\n    .global _start_thread;\n\n    _start_thread:\n        push rdi;           // flags\n        sub rsi, 16;        // stack\n        mov [rsi], rcx;     // seed\n        mov [rsi + 8], rdx; // func\n        mov rax, 56;\n        syscall;\n        pop rdi;\n        ret\n\"\n);\n\n#[repr(C)]\nstruct WorkerArgs {\n    ...\n}\n\nextern \"C\" {\n    fn _start_thread(flags: u64, stack: *mut (), func: extern \"C\" fn(\u0026WorkerArgs) -\u003e !, seed: u64) -\u003e isize;\n}\n\nunsafe fn start_thread(heap: \u0026Heap, func: extern \"C\" fn(\u0026WorkerArgs) -\u003e !, args: WorkerArgs) -\u003e isize {\n    // 쓰레드로 복제하기 위해 플래그 준비\n    let flags = CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND | CLONE_THREAD;\n\n    // 생성된 스택의 끝을 가리킴\n    let size = mem::size_of::\u003cWorkerArgs\u003e();\n    let stack = (heap.ptr as *mut u8).add(heap.len - size);\n\n    // 새 스택에 작업자 매개변수 복사\n    *(stack as *mut WorkerArgs) = args;\n\n    // 여기서 음수 결과 처리에 대해서는 신경 쓰지 않음\n    _start_thread(flags, stack as *mut (), func, stack as u64)\n}\n```\n\n시스템 V ABI를 기억한다면, 네 개의 매개변수가 RDI, RSI, RDX, 그리고 RCX 레지스터에 배치될 것을 알 수 있습니다. 따라서 메모리를 마법같이 재배열할 수 있습니다. 부모 쓰레드는 start_thread 함수 호출자에게 반환하고, 자식 쓰레드는 전달된 함수를 시작하고 결코 반환하지 않을 것입니다.\n\n우리 방정식의 세 번째 구성 요소는 Rust의 클로저입니다. Rust에서 이를 다룰 때, 함수 포인터와 같다는 인상을 받을 수 있습니다. 그러나 실제로 클로저는 트레이트 뒤에 제공된 단일 함수와 함께 조금 더 구조체와 유사합니다. 이를 곰곰이 생각해보면, 그들이 Rust의 futures와 비슷한 상태를 갖고 있다는 것을 상상할 수 있습니다. 상태는 주변 환경으로부터 컴파일러에 의해 자동으로 가로채어지며, 때로는 참조로, 때로는 값으로 나타납니다. 이것이 우리에게 무슨 의미인가요? 정확히 futures와 같이, 우리는 그들을 힙에 복사하려고 시도할 수 있습니다. 다음 데이터가 포함된 힙을 상상해보세요:\n\n```rust\n#[repr(C)]\nstruct CallableHeader {\n    data: [usize; 4],\n    call: fn(\u0026Heap) -\u003e Option\u003c\u0026'static [u8]\u003e,\n}\n\n#[repr(C)]\nstruct CallableArgs\u003cF, R, E\u003e\nwhere\n    F: FnOnce() -\u003e Result\u003cR, E\u003e,\n{\n    header: CallableHeader,\n    target: Option\u003cF\u003e,\n    result: Option\u003cResult\u003cR, E\u003e\u003e,\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n헤더에 임의의 32바이트와 함수 포인터가 포함되어 있습니다. 이것은 힙의 맨 위에 고정됩니다. 이는 캡처된 클로저로 확장되며 실행이 끝날 때 결과가 모여집니다. 헤더는 고정된 크기를 가지며 클로저의 유형이나 반환 값 크기에 의존하지 않습니다.\n\n힙의 데이터는 다음 구조체로 래핑될 수 있습니다:\n\n```js\npub struct CallableTarget {\n    target: Heap,\n    call: fn(\u0026Heap) -\u003e Option\u003c\u0026'static [u8]\u003e,\n}\n\npub enum CallableTargetAllocate {\n    Succeeded(CallableTarget),\n    AllocationFailed(isize),\n}\n\nimpl CallableTarget {\n    pub fn allocate\u003cF, R, E\u003e(target: F) -\u003e CallableTargetAllocate\n    where\n        F: FnOnce() -\u003e Result\u003cR, E\u003e + Send,\n    {\n        fn call\u003cF, R, E\u003e(target: \u0026Heap) -\u003e Option\u003c\u0026'static [u8]\u003e\n        where\n            F: FnOnce() -\u003e Result\u003cR, E\u003e,\n        {\n            let mut args: View\u003cCallableArgs\u003cF, R, E\u003e\u003e = target.view();\n            let result: Option\u003c\u0026[u8]\u003e = args.call();\n\n            result\n        }\n\n        let len = mem::size_of::\u003cCallableArgs\u003cF, R, E\u003e\u003e();\n        trace1(b\"allocating callable; size=%d\\n\", len);\n\n        let ((ptr, len), mut data) = match mem_alloc(len) {\n            MemoryAllocation::Succeeded(heap) =\u003e (heap.as_ptr(), heap.boxed::\u003cCallableArgs\u003cF, R, E\u003e\u003e()),\n            MemoryAllocation::Failed(err) =\u003e return CallableTargetAllocate::AllocationFailed(err),\n        };\n\n        data.result = None;\n        data.target = Some(target);\n        data.header = CallableHeader {\n            data: [ptr, len, 0, 0],\n            call: call::\u003cF, R, E\u003e,\n        };\n\n        CallableTargetAllocate::Succeeded(Self {\n            target: data.into(),\n            call: call::\u003cF, R, E\u003e,\n        })\n    }\n}\n\nimpl\u003cF, R, E\u003e CallableArgs\u003cF, R, E\u003e\nwhere\n    F: FnOnce() -\u003e Result\u003cR, E\u003e,\n{\n    pub fn call(\u0026mut self) -\u003e Option\u003c\u0026'static [u8]\u003e {\n        self.result = match self.target.take() {\n            None =\u003e return Some(b\"calling callable; failed\"),\n            Some(target) =\u003e Some(target.call_once(())),\n        };\n\n        None\n    }\n}\n```\n\n이 구조체는 새로운 호출 가능한 것을 할당하며, 두 구조체에 대해 충분한 메모리를 할당하고 클로저를 힙으로 이동시킵니다. 모든 유형을 지워버리지만 모든 일반 유형을 기억하는 함수 포인터는 보존합니다. 호출 가능한 것을 호출하고 수집된 결과를 가져올 수도 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\nimpl CallableTarget {\n    pub fn call(\u0026mut self) -\u003e Option\u003c\u0026'static [u8]\u003e {\n        trace2(\n            b\"dispatching callable; target=%x, size=%d\\n\",\n            self.target.ptr,\n            self.target.len,\n        );\n\n        (self.call)(\u0026mut self.target)\n    }\n\n    pub fn result\u003cF, R, E\u003e(self) -\u003e Option\u003cResult\u003cR, E\u003e\u003e\n    where\n        F: FnOnce() -\u003e Result\u003cR, E\u003e,\n    {\n        let value = self.target.view::\u003cCallableArgs\u003cF, R, E\u003e\u003e().result.take();\n        self.release();\n        value\n    }\n\n    pub fn release(mut self) {\n        trace1(b\"releasing callable; addr=%x\\n\", self.target.ptr);\n        mem_free(\u0026mut self.target);\n    }\n}\n```\n\n지금까지 바이트를 보낼 수 있는 파이프가 있다는 것을 알게 되었습니다. 같은 스레드 내 또는 I/O 링과 함께 작동할 수 있음을 확인했지만, 파이프는 여러 스레드에서도 작동할 것입니다. 시스템 호출을 사용하여 새 스레드를 생성하는 방법을 배웠습니다. 스마트 어셈블리 코드를 작성함으로써 분기를 피할 수 있었습니다. 마지막으로, 호출 가능한 것을 가져와서 타입을 지운 다음에도 호출할 수 있는 구조체를 만들었습니다. 이제 이들을 모두 연결하여 사용 가능한 스레드에서 클로저를 실행시킬 수 있는 엔진을 구축하는 준비가 되었습니다.\n\n작업 스레드에서 호출 가능한 작업을 실행해 봅시다. 다음과 같은 구조체로 시작하겠습니다:\n\n```rust\npub struct Worker {\n    incoming: u32,\n    outgoing: u32,\n}\n\n#[repr(C)]\nstruct WorkerArgs {\n    stack_ptr: usize,\n    stack_len: usize,\n    incoming: u32,\n    outgoing: u32,\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 작업자는 두 파이프에 대한 파일 디스크립터를 포함하고 있습니다. 하나는 쓰레드로 페이로드를 전송하기 위한 것이고, 다른 하나는 쓰레드로부터 페이로드를 수신하기 위한 것입니다. 두 쌍의 파이프를 가지고 있으면 양방향 통신이 가능해집니다. 쓰레드를 만들 때, 쓰레드 관점에서 두 개의 파일 디스크립터도 받게 됩니다. 작업자 쓰레드는 자신의 스택을 관리하는 것도 책임져야 합니다. 왜냐하면 작업자의 수명이 끝나면 스택을 파괴해야 하기 때문입니다. 그렇다면 작업자를 어떻게 생성할까요? 함께 분석해봅시다:\n\n```js\npub enum WorkerStart {\n    Succeeded(Worker),\n    StartFailed(isize),\n    StackFailed(isize),\n    PipesFailed(isize),\n}\n\nimpl Worker {\n    pub fn start() -\u003e WorkerStart {\n        let mut pipefd = [0; 4];\n        let ptr = pipefd.as_mut_ptr();\n\n        fn release_pipes(result: isize, pipefd: [u32; 4]) -\u003e WorkerStart {\n            for fd in pipefd {\n                if fd \u003e 0 {\n                    sys_close(fd);\n                }\n            }\n\n            WorkerStart::PipesFailed(result)\n        }\n\n        match sys_pipe2(unsafe { ptr.add(0) }, O_DIRECT) {\n            result if result \u003c 0 =\u003e return release_pipes(result, pipefd),\n            _ =\u003e (),\n        }\n\n        match sys_pipe2(unsafe { ptr.add(2) }, O_DIRECT) {\n            result if result \u003c 0 =\u003e return release_pipes(result, pipefd),\n            _ =\u003e (),\n        }\n\n        // we need to have a stack\n        let mut heap = match mem_alloc(4096) {\n            MemoryAllocation::Succeeded(heap) =\u003e heap,\n            MemoryAllocation::Failed(err) =\u003e {\n                release_pipes(err, pipefd);\n                return WorkerStart::StackFailed(err);\n            }\n        };\n\n        // args will be passed directly to newly created thread\n        // and must contain incoming and outgoing pipes\n        let args = WorkerArgs {\n            stack_ptr: heap.ptr,\n            stack_len: heap.len,\n            incoming: pipefd[0],\n            outgoing: pipefd[3],\n        };\n\n        // now we can start a thread\n        let tid = match unsafe { start_thread(\u0026heap, worker_callback, args) } {\n            result if result \u003e 0 =\u003e result as u32,\n            result =\u003e {\n                mem_free(\u0026mut heap);\n                release_pipes(result, pipefd);\n\n                return WorkerStart::StartFailed(result);\n            }\n        };\n\n        trace4(\n            b\"worker spawned; tid=%d, heap=%x, in=%d, out=%d\\n\",\n            tid,\n            heap.ptr,\n            pipefd[3],\n            pipefd[1],\n        );\n\n        let worker = Worker {\n            incoming: pipefd[2],\n            outgoing: pipefd[1],\n        };\n\n        WorkerStart::Succeeded(worker)\n    }\n\n    pub fn release(self) {\n        sys_close(self.incoming);\n        sys_close(self.outgoing);\n    }\n}\n```\n\n이 코드는 두 쌍의 파이프, 4096바이트의 스택, 그리고 작업자 인자를 만듭니다. 그리고 마법같은 함수가 호출되어 스택을 재배치하고 인자를 복사하며 커널을 호출합니다. 모든 것이 예상대로 작동하면, 아래 함수가 쓰레드의 진입점이 됩니다:\n\n```js\nextern \"C\" fn worker_callback(args: \u0026WorkerArgs) -\u003e ! {\n    ...\n\n    let res = sys_close(args.incoming);\n    trace2(b\"terminating thread; in=%d, res=%d\\n\", args.incoming, res);\n\n    let res = sys_close(args.outgoing);\n    trace2(b\"terminating thread; out=%d, res=%d\\n\", args.outgoing, res);\n\n    // releasing stack memory and exiting current thread\n    trace2(b\"terminating thread; heap=%x, len=%d\\n\", args.stack_ptr, args.stack_len);\n    unsafe { _stop_thread(args.stack_ptr, args.stack_len) }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 어떤 일이 일어날까요? 결과를 검사하지 않고 두 파이프를 모두 닫습니다. 결과가 부정적인 경우 전혀 반응할 수가 없어요. 주어진 어셈블리 코드 스니펫을 살펴봐서 어떻게 해야 하는지 알아보아요.\n\n아래 어셈블리 코드는 메모리 할당 해제를 담당하며 munmap (11) 시스템 호출을 사용하여 메모리를 해제 한 후에 exit (60) 시스템 호출을 통해 스레드를 종료합니다. 스택이 한 번 해제되면 스택에 의도치 않은 액세스를 피하기 위해 어셈블리로 수행됩니다.\n\n작업자 스레드에 무엇을 놓을 수 있을까요? 비동기 코드를 넣지는 않겠어요. 모든 것을 복잡하게 만들 것이기 때문이죠. 그렇다면 호출 가능한 작업이 실행될 때까지 기다리는 간단한 루프를 놓는 것은 어떨까요? 이 아이디어를 다음 스니펫에서 확인해보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 스니펫은 거의 무한 루프에 진입하여 16바이트의 데이터를 기다립니다. 이는 힙 포인터와 힙 길이의 쌍이 호출 가능한 구조체를 재구성할 것으로 기대합니다. 실제로 가능합니다. 쉽죠, 호출 가능한 구조체를 호출하고 1바이트를 반환 파이프로 다시 씁니다. 이 1바이트는 준비되었다는 신호로만 사용됩니다. 호출 가능한 객체를 해제하지 않고 결과를 해석하지 않습니다. 그런데 포인터만 가지고 호출 가능한 구조체를 재구성하는 방법은 무엇일까요? 이를 살펴보겠습니다:\n\n```js\n#[repr(C)]\nstruct CallableHeader {\n    data: [usize; 4],\n    call: fn(\u0026Heap) -\u003e Option\u003c\u0026'static [u8]\u003e,\n}\n\n#[repr(C)]\nstruct CallableArgs\u003cF, R, E\u003e\nwhere\n    F: FnOnce() -\u003e Result\u003cR, E\u003e,\n{\n    header: CallableHeader,\n    target: Option\u003cF\u003e,\n    result: Option\u003cResult\u003cR, E\u003e\u003e,\n}\n\nimpl CallableTarget {\n    fn new(target: Heap, call: fn(\u0026Heap) -\u003e Option\u003c\u0026'static [u8]\u003e) -\u003e Self {\n        Self { target, call }\n    }\n\n    pub fn from(heap: Heap) -\u003e Self {\n        let header: View\u003cCallableHeader\u003e = heap.view();\n        let target: CallableTarget = CallableTarget::new(heap, header.call);\n\n        target\n    }\n}\n```\n\n헤더가 고정된 크기이며 힙의 시작 부분에 있는 것을 기억하시나요? 단순히 그것을 읽어서 호출 필드를 추출할 수 있어서 힙과 함께 호출 가능한 타겟을 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 무한 루프를 포함하는 워커를 생성하는 방법과, 이를 포함한 익명 함수를 감싼 콜러블 타겟 오브젝트를 받는 방법을 배웠어요. 이제 그 워커에 일을 몇 가지 보내는 시간이에요. 우리의 워커 구조는 두 개의 파일 디스크립터가 있는 것을 기억하고 있죠? 이들은 이전 단락에서 구성한 루프와 통신할 목적으로 사용됩니다.\n\n```js\npub enum WorkerExecute {\n    Succeeded(IORingSubmitEntry\u003c*const u8\u003e),\n    OutgoingPipeFailed(isize)\n}\n\nimpl Worker {\n    pub fn execute(\u0026mut self, callable: \u0026CallableTarget) -\u003e WorkerExecute {\n        let ((ptr, _), len) = (callable.as_ptr(), 16);\n\n        // 여기서는 블로킹 작업이 없을 것으로 예상되며, 워커는 이를 기다립니다.\n        trace2(b\"worker sends bytes; ptr=%x, len=%d\\n\", ptr, len);\n        let res = sys_write(self.outgoing, ptr as *mut (), len);\n\n        // (ptr, len) 값을 갖고 있는 16바이트를 정확히 전송합니다.\n        trace3(b\"worker sends bytes; fd=%d, size=%d, res=%d\\n\", self.outgoing, len, res);\n        if res != len as isize {\n            return WorkerExecute::OutgoingPipeFailed(res);\n        }\n\n        // 비동기 작업은 콜러블의 헤더를 참조하여 반환되어야 합니다.\n        WorkerExecute::Succeeded(IORingSubmitEntry::read(self.incoming, (ptr + 16) as *const u8, 1, 0))\n    }\n}\n```\n\n우선적으로 호출 가능한 함수의 힙에 대한 포인터를 얻은 다음, 첫 16바이트를 외부 파이프로 전송합니다. 그런데 왜 16바이트인 걸까요? 아마도 파이프의 다른 끝에서 읽을 때도 이 숫자를 사용하는 것을 기억하실 겁니다. 파이프의 다른 끝은 16바이트가 힙의 포인터와 길이의 쌍임을 예상하고 있습니다. 이 값들은 어디에서 설정되나요? 이는 호출 가능한 함수가 할당될 때 이루어집니다.\n\n```js\nimpl CallableTarget {\n    pub fn allocate\u003cF, R, E\u003e(target: F) -\u003e CallableTargetAllocate\n    where\n        F: FnOnce() -\u003e Result\u003cR, E\u003e + Send,\n    {\n        ...\n\n        let ((ptr, len), mut data) = match mem_alloc(len) {\n            MemoryAllocation::Succeeded(heap) =\u003e (heap.as_ptr(), heap.boxed::\u003cCallableArgs\u003cF, R, E\u003e\u003e()),\n            MemoryAllocation::Failed(err) =\u003e return CallableTargetAllocate::AllocationFailed(err),\n        };\n\n        data.result = None;\n        data.target = Some(target);\n        data.header = CallableHeader {\n            data: [ptr, len, 0, 0],\n            call: call::\u003cF, R, E\u003e,\n        };\n\n        CallableTargetAllocate::Succeeded(Self {\n            target: data.into(),\n            call: call::\u003cF, R, E\u003e,\n        })\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스케줄 중 최종으로 반환된 작업은 호출 가능한 힙의 어딘가로의 비동기 읽기 작업입니다. 우리는 해석될 것이 아니라 단지 uring을 트리거하는 신호인 하나의 바이트만 읽어야 합니다. 이는 어떠한 동기화 도구도 사용하지 않도록 합니다. 어떻게 할까요? I/O Ring은 작업이 완료되었을 때 우리에게 알립니다.\n\n단일 워커를 어떻게 관리하는지 알고 있다면 풀 구조체를 사용하여 해당 워커를 인스턴스화해 봅시다. 이 풀은 여러 워커를 관리하고 작업이 블로킹되지 않는 방식으로 대기열에 들어가고 나오도록 보장합니다. 다음 목록과 같이 시작할 수 있습니다:\n\n```js\nconst WORKERS_COUNT: usize = 8;\n\npub struct IORuntimePool {\n    workers_completers: [Option\u003cu64\u003e; WORKERS_COUNT],\n    workers_array: [Option\u003cWorker\u003e; WORKERS_COUNT],\n    workers_slots: [usize; WORKERS_COUNT],\n    workers_count: usize,\n    queue_incoming: u32,\n    queue_outgoing: u32,\n    queue_counter: usize,\n}\n```\n\n이 코드는 8개의 스레드를 사용한다고 가정합니다. 또한 카운터와 내부 파이프를 갖는 대기열을 선언합니다. 왜 파이프를 사용할까요? 더 많은 CPU 작업이 요청되었을 때 사용 가능한 워커보다 더 많은 작업이 스케줄링되지 않도록 블로킹되는 작업을 피하기 위해 사용됩니다. 어떻게 할당하는지 살펴봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\npub enum IORuntimePoolAllocation {\n    Succeeded(Boxed\u003cIORuntimePool\u003e),\n    AllocationFailed(isize),\n    ThreadingFailed(isize),\n    QueueFailed(isize),\n}\n\nimpl IORuntimePool {\n    pub fn allocate() -\u003e IORuntimePoolAllocation {\n        let queue = match PipeChannel::create() {\n            Ok(value) =\u003e value,\n            Err(err) =\u003e return IORuntimePoolAllocation::QueueFailed(err),\n        };\n\n        let mut instance: Boxed\u003cIORuntimePool\u003e = match mem_alloc(mem::size_of::\u003cIORuntimePool\u003e()) {\n            MemoryAllocation::Succeeded(heap) =\u003e heap.boxed(),\n            MemoryAllocation::Failed(err) =\u003e return IORuntimePoolAllocation::AllocationFailed(err),\n        };\n\n        for i in 0..WORKERS_COUNT {\n            let worker = match Worker::start() {\n                WorkerStart::Succeeded(worker) =\u003e worker,\n                WorkerStart::StartFailed(err) =\u003e return IORuntimePoolAllocation::ThreadingFailed(err),\n                WorkerStart::PipesFailed(err) =\u003e return IORuntimePoolAllocation::ThreadingFailed(err),\n                WorkerStart::StackFailed(err) =\u003e return IORuntimePoolAllocation::AllocationFailed(err),\n            };\n\n            instance.workers_array[i] = Some(worker);\n            instance.workers_slots[i] = i;\n        }\n\n        let (incoming, outgoing) = queue.extract();\n\n        instance.queue_counter = 0;\n        instance.workers_count = 0;\n\n        instance.queue_incoming = incoming;\n        instance.queue_outgoing = outgoing;\n\n        IORuntimePoolAllocation::Succeeded(instance)\n    }\n}\n```\n\n함수는 먼저 파이프를 생성한 다음 자체를 위해 힙에 메모리를 할당하고 마지막으로 N개의 워커를 시작합니다. 파괴에 대해서는 넘어가고 어떻게 일정 작업을 예약할 수 있는지에 초점을 맞춰봅시다. 예약 알고리즘은 두 단계로 수행될 것입니다. 첫 번째는 워커를 획득하는 것이고, 두 번째 단계는 작업을 실행하는 것입니다. 두 단계 모두 블로킹될 수 있으며, 이것은 이벤트 루프에서 실행되어야 하기 때문에 우리는 이를 원치 않습니다. 블로킹을 피하기 위해 I/O Ring을 사용할 것입니다.\n\n첫 번째 케이스를 고려해봅시다. 워커가 사용 가능하고 callable을 실행하도록 호출하면 됩니다. 이 함수는 I/O Ring 제출자(submitter), 이미 준비된 두 완료자(completers) 및 호출할 callable을 인자로 받습니다. 완료자는 I/O 런타임에서 소개한 가벼운 구조체로, 예약된 진행 중인 I/O 작업에 대한 정보를 전달하기 위한 것입니다. 항상 각 I/O Ring 작업에서 사용자 데이터로 전달됩니다. 첫 번째 완료자는 작업을 대기열에 넣는 것이 완료된 것을 알립니다. 두 번째 것은 callable이 실행된 경우에만 완료됩니다.\n\n```rust\npub enum IORuntimePoolExecute {\n    Queued(),\n    Executed(),\n    ScheduleFailed(),\n    ExecutionFailed(),\n    InternallyFailed(),\n}\n\nimpl IORuntimePool {\n    pub fn execute(\n        \u0026mut self,\n        submitter: \u0026mut IORingSubmitter,\n        completers: [\u0026IORingCompleterRef; 2],\n        callable: \u0026CallableTarget,\n    ) -\u003e IORuntimePoolExecute {\n        // 워커 획득\n        if let Some(slot) = self.workers_slots.get(self.workers_count) {\n            let worker = match self.workers_array.get_mut(*slot) {\n                Some(Some(worker)) =\u003e worker,\n                _ =\u003e return IORuntimePoolExecute::InternallyFailed(),\n            };\n\n            // 대기열 확인\n            let op = IORingSubmitEntry::noop();\n            match submitter.submit(completers[0].encode(), [op]) {\n                IORingSubmit::Succeeded(_) =\u003e (),\n                _ =\u003e return IORuntimePoolExecute::ScheduleFailed(),\n            }\n\n            // 실행 작업 준비\n            let op = match worker.execute(callable) {\n                WorkerExecute::Succeeded(op) =\u003e op,\n                _ =\u003e return IORuntimePoolExecute::InternallyFailed(),\n            };\n\n            // 실행 확인\n            match submitter.submit(completers[1].encode(), [op]) {\n                IORingSubmit::Succeeded(_) =\u003e (),\n                _ =\u003e return IORuntimePoolExecute::ExecutionFailed(),\n            }\n\n            // 내부 카운터 업데이트 및 워커와 완료자 연결\n            self.workers_count += 1;\n            self.workers_completers[*slot] = Some(completers[1].encode());\n\n            return IORuntimePoolExecute::Executed();\n        }\n\n        ...\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드에서는 worker를 성공적으로 획득한 후, 첫 번째 completor와 함께 noop 작업을 예약합니다. worker를 기다릴 필요는 없지만 완료해야 합니다. 실제 작업 - worker의 execute 함수가 반환한 I/O Ring 작업을 두 번째 completor와 연결하여 즉시 예약할 수 있습니다.\n\n사용 가능한 worker가 없는 경우, 내부 파이프를 사용하여 callable을 대기열에 넣어야 합니다. worker가 준비되면 나중에 읽히게 됩니다:\n\n```js\nimpl IORuntimePool {\n    pub fn execute(\n        \u0026mut self,\n        submitter: \u0026mut IORingSubmitter,\n        completors: [\u0026IORingCompleterRef; 2],\n        callable: \u0026CallableTarget,\n    ) -\u003e IORuntimePoolExecute {\n        ...\n\n        // callable 헤더에 completer를 추가\n        let (ptr, len) = unsafe {\n            let (ptr, _) = callable.as_ptr();\n            let encoded = (ptr + 16) as *mut u64;\n\n            *encoded = completors[1].encode();\n            (ptr as *const u8, 24)\n        };\n\n        // 대기열화 작업을 알림\n        let op = IORingSubmitEntry::write(self.queue_outgoing, ptr, len, 0);\n        match submitter.submit(completors[0].encode(), [op]) {\n            IORingSubmit::Succeeded(_) =\u003e (),\n            _ =\u003e return IORuntimePoolExecute::ScheduleFailed(),\n        }\n\n        return IORuntimePoolExecute::Queued();\n    }\n}\n```\n\n이 코드는 completer를 callable의 힙 헤더에 추가하고 메시지가 소비될 때 I/O Ring을 사용하여 알립니다. worker의 가용성을 감지하면 대칭적인 읽기가 발생합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\npub enum IORuntimePoolTrigger {\n    Succeeded(bool),\n    ExecutionFailed(),\n    InternallyFailed(),\n}\n\nimpl IORuntimePool {\n    pub fn trigger(\u0026mut self, submitter: \u0026mut IORingSubmitter) -\u003e IORuntimePoolTrigger {\n        if self.queue_counter \u003c= 0 {\n            return IORuntimePoolTrigger::Succeeded(false);\n        }\n\n        if let Some(slot) = self.workers_slots.get(self.workers_count) {\n            trace1(b\"acquired worker; slot=%d\\n\", *slot);\n\n            // worker still theoretically may fail\n            let worker = match self.workers_array.get_mut(*slot) {\n                Some(Some(worker)) =\u003e worker,\n                _ =\u003e return IORuntimePoolTrigger::InternallyFailed(),\n            };\n\n            // buffer is needed to collect data from the pipe\n            let mut buffer: [u8; 24] = [0; 24];\n            let ptr = buffer.as_mut_ptr() as *mut ();\n\n            // we expect to read ptr, len, encoded completer triple from a queue\n            let result = sys_read(self.queue_incoming, ptr, 24);\n            trace1(b\"acquired callable; res=%d\\n\", result);\n\n            if result != 24 {\n                return IORuntimePoolTrigger::InternallyFailed();\n            } else {\n                self.queue_counter -= 1;\n            }\n\n            // decoding payload\n            let ptr = ptr as *const usize;\n            let len = unsafe { ptr.add(1) };\n            let encoded = unsafe { ptr.add(2) as *const u64 };\n\n            // rebuilding callable\n            let heap = unsafe { Heap::at(*ptr, *len) };\n            let callable: CallableTarget = CallableTarget::from(heap);\n\n            // then we try to follow known path\n            let op = match worker.execute(\u0026callable) {\n                WorkerExecute::Succeeded(op) =\u003e op,\n                _ =\u003e return IORuntimePoolTrigger::InternallyFailed(),\n            };\n\n            // by registering it within I/O Ring\n            match submitter.submit(unsafe { *encoded }, [op]) {\n                IORingSubmit::Succeeded(_) =\u003e (),\n                _ =\u003e return IORuntimePoolTrigger::ExecutionFailed(),\n            }\n\n            // not forgetting about maintaining the state\n            self.workers_completers[*slot] = unsafe { Some(*encoded) };\n            self.workers_count += 1;\n        }\n\n        IORuntimePoolTrigger::Succeeded(true)\n    }\n}\n```\n\nThis code reads 24 bytes from a pipe and decodes them as a callable to directly send it to a worker with an already walked path.\n\nYou might be curious if reading and writing to a pipe could lead to message fragmentation. No worries, it won’t. Linux pipes are POSIX.1 compliant and offer guarantees about certain behaviors. Let's take a look at what the `man 7 pipe` manual says about it:\n```rust\nPIPE_BUF\n   POSIX.1 says that writes of less than PIPE_BUF bytes  must  be  atomic:\n   the  output  data  is  written  to  the  pipe as a contiguous sequence.\n   Writes of more than PIPE_BUF bytes may be nonatomic: the kernel may in‐\n   terleave the data with data written by other  processes.   POSIX.1  re‐\n   quires  PIPE_BUF to be at least 512 bytes.  (On Linux, PIPE_BUF is 4096\n   bytes.)  The precise semantics depend on whether the file descriptor is\n   nonblocking (O_NONBLOCK), whether there are  multiple  writers  to  the\n   pipe, and on n, the number of bytes to be written:\n\n   O_NONBLOCK disabled, n \u003c= PIPE_BUF\n          All  n bytes are written atomically; write(2) may block if there\n          is not room for n bytes to be written immediately\n\n   O_NONBLOCK enabled, n \u003c= PIPE_BUF\n          If there is room to write n bytes to  the  pipe,  then  write(2)\n          succeeds  immediately,  writing  all n bytes; otherwise write(2)\n          fails, with errno set to EAGAIN.\n\n   O_NONBLOCK disabled, n \u003e PIPE_BUF\n          The write is nonatomic: the data given to write(2) may be inter‐\n          leaved with write(2)s by other process; the write(2) blocks  un‐\n          til n bytes have been written.\n\n   O_NONBLOCK enabled, n \u003e PIPE_BUF\n          If  the pipe is full, then write(2) fails, with errno set to EA‐\n          GAIN.  Otherwise, from 1 to n bytes  may  be  written  (i.e.,  a\n          \"partial  write\"  may  occur; the caller should check the return\n          value from write(2) to see how many bytes  were  actually  writ‐\n          ten),  and  these  bytes may be interleaved with writes by other\n          processes.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n패킷이 나뉘는 것에 대해 걱정할 필요가 없습니다. 왜냐하면 PIPE_BUF가 페이지보다 작지 않고(4096바이트) 우리는 딱 24바이트를 보내기 때문입니다.\n\n풀이 작동하면 I/O 런타임 내에서 사용할 수 있습니다. 아래와 같이 몇 가지 바인딩을 컨텍스트에 정의해야 합니다:\n\n```js\nimpl IORingRuntime {\n    fn trigger(\u0026mut self, completer: \u0026IORingCompleterRef) {\n        // 먼저 완료자 뒤에 있는 워커를 해제합니다\n        self.pool.release_worker(completer);\n\n        // 그런 다음 아마도 대기 중인 호출 가능을 트리거합니다\n        self.pool.trigger(\u0026mut self.submitter);\n    }\n}\n\nimpl IORingRuntimeContext {\n    pub fn trigger(\u0026mut self, completer: \u0026IORingCompleterRef) {\n        unsafe { (*self.runtime).trigger(completer) }\n    }\n}\n\npub enum IORingRuntimeExecute {\n    Queued(IORingCompleterRef, IORingCompleterRef),\n    Executed(IORingCompleterRef, IORingCompleterRef),\n    NotEnoughSlots(),\n    InternallyFailed(),\n}\n\nimpl IORingRuntime {\n    fn execute(\u0026mut self, task: \u0026IORingTaskRef, callable: \u0026CallableTarget) -\u003e IORingRuntimeExecute {\n        let queued = match self.registry.append_completer(task.clone()) {\n            IORingRegistryAppend::Succeeded(completer) =\u003e completer,\n            IORingRegistryAppend::NotEnoughSlots() =\u003e return IORingRuntimeExecute::NotEnoughSlots(),\n            IORingRegistryAppend::InternallyFailed() =\u003e return IORingRuntimeExecute::InternallyFailed(),\n        };\n\n        let executed = match self.registry.append_completer(task.clone()) {\n            IORingRegistryAppend::Succeeded(completer) =\u003e completer,\n            IORingRegistryAppend::NotEnoughSlots() =\u003e return IORingRuntimeExecute::NotEnoughSlots(),\n            IORingRegistryAppend::InternallyFailed() =\u003e return IORingRuntimeExecute::InternallyFailed(),\n        };\n\n        match self.pool.execute(\u0026mut self.submitter, [\u0026queued, \u0026executed], callable) {\n            IORuntimePoolExecute::Queued() =\u003e IORingRuntimeExecute::Queued(queued, executed),\n            IORuntimePoolExecute::Executed() =\u003e IORingRuntimeExecute::Executed(queued, executed),\n            IORuntimePoolExecute::ScheduleFailed() =\u003e IORingRuntimeExecute::InternallyFailed(),\n            IORuntimePoolExecute::ExecutionFailed() =\u003e IORingRuntimeExecute::InternallyFailed(),\n            IORuntimePoolExecute::InternallyFailed() =\u003e IORingRuntimeExecute::InternallyFailed(),\n        }\n    }\n}\n\nimpl IORingRuntimeContext {\n    pub fn execute(\u0026mut self, callable: \u0026CallableTarget) -\u003e IORingRuntimeExecute {\n        unsafe { (*self.runtime).execute(\u0026self.task, callable) }\n    }\n}\n```\n\n이러한 바인딩을 사용하면 I/O Ring Task Token을 조절할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\nimpl IORingTaskToken {\n    pub fn execute(waker: \u0026Waker, task: \u0026CallableTarget) -\u003e Option\u003c(IORingTaskToken, IORingTaskToken)\u003e {\n        match Self::context(waker).execute(task) {\n            IORingRuntimeExecute::Queued(queued, executed) =\u003e Some((\n                IORingTaskToken::from_queue(queued),\n                IORingTaskToken::from_execute(executed),\n            )),\n            IORingRuntimeExecute::Executed(queued, executed) =\u003e Some((\n                IORingTaskToken::from_op(queued),\n                IORingTaskToken::from_execute(executed),\n            )),\n            IORingRuntimeExecute::NotEnoughSlots() =\u003e None,\n            IORingRuntimeExecute::InternallyFailed() =\u003e None,\n        }\n    }\n\n    pub fn extract(self, waker: \u0026Waker) -\u003e IORingTaskTokenExtract {\n        let context = Self::context(waker);\n        let value = match context.extract(\u0026self.completer) {\n            IORingRuntimeExtract::Succeeded(value) =\u003e value,\n            IORingRuntimeExtract::NotCompleted() =\u003e return IORingTaskTokenExtract::Failed(self),\n            IORingRuntimeExtract::NotFound() =\u003e return IORingTaskTokenExtract::Failed(self),\n        };\n\n        if let IORingTaskTokenKind::Queue = self.kind {\n            // enqueue sent callable\n            context.enqueue(\u0026self.completer);\n        }\n\n        if let IORingTaskTokenKind::Execute = self.kind {\n            // trigger awaiting callable\n            context.trigger(\u0026self.completer);\n        }\n\n        IORingTaskTokenExtract::Succeeded(value)\n    }\n}\n```\n\n우리는 언제나 두 개의 토큰을 받고, 둘 다 완료를 보고할 것입니다. 두 번째 토큰은 대기 중인 호출 가능한 것들이 스케줄링을 위해 사용 가능하다는 것을 알리려고 할 것입니다.\n\n이것으로 어떻게 이득을 얻을 수 있을까요? CPU에 미래 생성 작업을 작성했다고 상상해 봅시다:\n\n```rust\npub fn spawn_cpu\u003c'a, F, R, E\u003e(target: F) -\u003e Option\u003cSpawnCPU\u003c'a, F, R, E\u003e\u003e\nwhere\n    F: FnOnce() -\u003e Result\u003cR, E\u003e + Unpin + Send + 'a,\n    R: Unpin + Send,\n    E: Unpin + Send,\n{\n    let task = match CallableTarget::allocate(target) {\n        CallableTargetAllocate::Succeeded(target) =\u003e target,\n        CallableTargetAllocate::AllocationFailed(_) =\u003e return None,\n    };\n\n    Some(SpawnCPU {\n        queued: None,\n        executed: None,\n        phantom: PhantomData,\n        task: Some(task),\n    })\n}\n\npub struct SpawnCPU\u003c'a, F, R, E\u003e\nwhere\n    F: Unpin,\n    R: Unpin,\n{\n    task: Option\u003cCallableTarget\u003e,\n    queued: Option\u003cIORingTaskToken\u003e,\n    executed: Option\u003cIORingTaskToken\u003e,\n    phantom: PhantomData\u003c(\u0026'a F, R, E)\u003e,\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나중에 토큰을 사용하여 투표를 할 수 있습니다:\n\n```js\npub enum SpawnCPUResult\u003cR, E\u003e {\n    Succeeded(Option\u003cResult\u003cR, E\u003e\u003e),\n    OperationFailed(),\n    InternallyFailed(),\n}\n\nimpl\u003c'a, F, R, E\u003e Future for SpawnCPU\u003c'a, F, R, E\u003e\nwhere\n    F: FnOnce() -\u003e Result\u003cR, E\u003e + Unpin,\n    R: Unpin,\n    E: Unpin,\n{\n    type Output = SpawnCPUResult\u003cR, E\u003e;\n\n    fn poll(self: Pin\u003c\u0026mut Self\u003e, cx: \u0026mut Context\u003c'_\u003e) -\u003e Poll\u003cSelf::Output\u003e {\n        let this = self.get_mut();\n        trace0(b\"# polling spawn-cpu\\n\");\n\n        if let Some(token) = this.queued.take() {\n            trace0(b\"# polling spawn-cpu; extracting queued\\n\");\n            let result = match token.extract(cx.waker()) {\n                IORingTaskTokenExtract::Succeeded(value) =\u003e Some(value),\n                IORingTaskTokenExtract::Failed(token) =\u003e {\n                    this.queued = Some(token);\n                    None\n                }\n            };\n\n            if let Some(result) = result {\n                return if result \u003c 0 {\n                    Poll::Ready(SpawnCPUResult::OperationFailed())\n                } else {\n                    trace1(b\"# polling spawn-cpu; stage=queued, res=%d\\n\", result);\n                    Poll::Pending\n                };\n            }\n        }\n\n        if let Some(token) = this.executed.take() {\n            trace0(b\"# polling spawn-cpu; extracting executed\\n\");\n            let result = match token.extract(cx.waker()) {\n                IORingTaskTokenExtract::Succeeded(value) =\u003e Some(value),\n                IORingTaskTokenExtract::Failed(token) =\u003e {\n                    this.executed = Some(token);\n                    return Poll::Pending;\n                }\n            };\n\n            if let Some(result) = result {\n                return if result \u003c 0 {\n                    Poll::Ready(SpawnCPUResult::OperationFailed())\n                } else {\n                    trace1(b\"# polling spawn-cpu; stage=executed, res=%d\\n\", result);\n                    let result = match this.task.take() {\n                        None =\u003e SpawnCPUResult::InternallyFailed(),\n                        Some(task) =\u003e SpawnCPUResult::Succeeded(task.result::\u003cF, R, E\u003e()),\n                    };\n\n                    Poll::Ready(result)\n                };\n            }\n        }\n\n        if this.queued.is_some() || this.executed.is_some() {\n            return Poll::Pending;\n        }\n\n        let task = match \u0026this.task {\n            Some(task) =\u003e task,\n            None =\u003e return Poll::Ready(SpawnCPUResult::InternallyFailed()),\n        };\n\n        match IORingTaskToken::execute(cx.waker(), task) {\n            Some((queued, executed)) =\u003e {\n                trace2(b\"callable; scheduled, qid=%d, eid=%d\\n\", queued.cid(), executed.cid());\n                this.queued = Some(queued);\n                this.executed = Some(executed);\n                Poll::Pending\n            }\n            None =\u003e {\n                trace0(b\"callable not scheduled\\n\");\n                Poll::Ready(SpawnCPUResult::OperationFailed())\n            }\n        }\n    }\n}\n\nimpl\u003c'a, F, R, E\u003e Drop for SpawnCPU\u003c'a, F, R, E\u003e\nwhere\n    F: Unpin,\n    R: Unpin,\n{\n    fn drop(\u0026mut self) {\n        if let Some(task) = self.task.take() {\n            let (ptr, len) = task.as_ptr();\n            trace2(b\"callable; releasing task, heap=%x, size=%d\\n\", ptr, len);\n            task.release();\n        }\n    }\n}\n```\n\n이를 통해 비동기/대기 코드 내에서 단일 스레드 동시성 모델을 유지하면서 스레드에 직접 코드 일부를 예약할 수 있게 해줍니다. 다음 예제를 살펴보겠습니다:\n\n```js\npub struct ThreadCommand {\n    pub ios: u32,\n    pub cpus: u32,\n}\n\nimpl ThreadCommand {\n    pub async fn execute(self) -\u003e Option\u003c\u0026'static [u8]\u003e {\n        for j in 0..self.ios {\n            let task = spawn(async move {\n                for i in 0..self.cpus {\n                    let value = match spawn_cpu(move || -\u003e Result\u003cu32, ()\u003e { Ok(i + j) }) {\n                        None =\u003e return Some(APP_CPU_SPAWNING_FAILED),\n                        Some(task) =\u003e match task.await {\n                            SpawnCPUResult::Succeeded(value) =\u003e value,\n                            SpawnCPUResult::OperationFailed() =\u003e return Some(APP_INTERNALLY_FAILED),\n                            SpawnCPUResult::InternallyFailed() =\u003e return Some(APP_INTERNALLY_FAILED),\n                        },\n                    };\n\n                    if let Some(Ok(val)) = value {\n                        trace3(b\"completed %d %d %d\\n\", i, j, val);\n                    }\n                }\n\n                None\n            });\n\n            match task.await {\n                SpawnResult::Succeeded() =\u003e (),\n                SpawnResult::OperationFailed() =\u003e return Some(APP_INTERNALLY_FAILED),\n                SpawnResult::InternallyFailed() =\u003e return Some(APP_INTERNALLY_FAILED),\n            }\n        }\n\n        None\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드 조각은 시각적 결과에서는 뚜렷한 변화를 주지 않습니다. 두 매개변수가 모두 100과 같을 때, 10,000개의 기본 합계를 계산합니다. 각 작업 내에서 100번의 스레드 호출을 가진 100개의 비동기 작업을 시도합니다. 가장 중요한 관찰은 이 작업이 이벤트 루프를 실행하는 주 스레드를 차단하지 않아 우리 애플리케이션을 매우 반응적으로 만든다는 것입니다.\n\nCPU 및 I/O에서 동시에 이점을 얻을 수 있는 코드를 만들어 보겠습니다. sha1sum을 알고 계십니까? 여러 파일의 해시를 계산하기 위한 명령 줄 도구입니다. 다음과 같이 사용될 수 있습니다:\n\n```js\nvscode ➜ /workspaces/learning-rust (async-await-pipes) $ ls -la en*\n-rw-r--r-- 1 vscode vscode  1013471918 Sep  2  2023 enwiki-20230901-pages-articles-multistream1.xml-p1p41242\n-rw-r--r-- 1 vscode vscode  3854846248 Sep  6  2023 enwiki-20230901-pages-meta-history10.xml-p5136726p5137515.7z\n-rw-r--r-- 1 vscode vscode   259750638 May  2 04:25 enwiki-20240501-pages-articles-multistream-index.txt.bz2\n-rw-r--r-- 1 vscode vscode 23184900944 May  2 04:23 enwiki-20240501-pages-articles-multistream.xml.bz2\n-rw-r--r-- 1 vscode vscode 23648605741 Jun  8 16:01 enwiki-20240601-pages-articles-multistream.xml.bz2\n-rw-r--r-- 1 vscode vscode 41513214739 Jun  8 20:27 enwiki-20240601-pages-meta-current.xml.bz2\n\nvscode ➜ /workspaces/learning-rust (async-await-pipes) $ time sha1sum en*\n55375e89bccfb6851c9a60b933c6e1e458114ca3  enwiki-20230901-pages-articles-multistream1.xml-p1p41242\nf020288be05a1e18da944b8df154ce84976f9b2a  enwiki-20230901-pages-meta-history10.xml-p5136726p5137515.7z\n134239721b29faa9264ecb7f59740444f640ec77  enwiki-20240501-pages-articles-multistream-index.txt.bz2\n1412bbb2eb36d7d119b2f13a93ff9818db14cd3f  enwiki-20240501-pages-articles-multistream.xml.bz2\n54ee62ce7111daffd5be267ec863dc5f54360ed8  enwiki-20240601-pages-articles-multistream.xml.bz2\n450dba4f17de7870cc088d800632e385fd6524a6  enwiki-20240601-pages-meta-current.xml.bz2\n\nreal    2m20.681s\nuser    1m54.684s\nsys     0m25.853s\n```\n\n현재 디렉토리에는 상당히 큰 위키피디아 파일이 몇 개 있습니다. 이 도구는 한 개의 코어를 100% 사용하여 매우 빠르게 해시를 계산할 수 있습니다. 파일 시스템은 병목이 되지 않는 한 파일 단위로 읽습니다. 이론적으로 더 빠르게 수행할 수 있습니다. 대안을 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\npub struct Sha1Command {\n    pub args: \u0026'static ProcessArguments,\n}\n\nimpl Sha1Command {\n    pub async fn execute(self) -\u003e Option\u003c\u0026'static [u8]\u003e {\n        for arg in 2..self.args.len() {\n            // 각 인수마다 작업이 생성됩니다.\n            let task = spawn(async move {\n                // 버퍼에 대한 자동 해제 메모리\n                let buffer: Droplet\u003cHeap\u003e = match mem_alloc(32 * 4096) {\n                    MemoryAllocation::Succeeded(value) =\u003e value.droplet(),\n                    MemoryAllocation::Failed(_) =\u003e return Some(APP_MEMORY_ALLOC_FAILED),\n                };\n\n                // 해시할 파일 경로\n                let path: ProcessArgument = match self.args.get(arg) {\n                    None =\u003e return Some(APP_ARGS_FAILED),\n                    Some(value) =\u003e value,\n                };\n\n                // 열린 파일에 대한 파일 디스크립터\n                let file: FileDescriptor = match open_file(\u0026path).await {\n                    FileOpenResult::Succeeded(value) =\u003e value,\n                    _ =\u003e return Some(APP_FILE_OPENING_FAILED),\n                };\n\n                let mut file_offset = 0;\n                let mut buffer_offset = 0;\n                let mut sha1 = Sha1::new();\n\n                loop {\n                    while buffer_offset \u003c buffer.len {\n                        // 버퍼를 슬라이스하여 끝까지 채우려고 시도합니다.\n                        let buffer: HeapSlice = match buffer.between(buffer_offset, buffer.len) {\n                            HeapSlicing::Succeeded(value) =\u003e value,\n                            _ =\u003e return Some(APP_MEMORY_SLICE_FAILED),\n                        };\n\n                        // 파일 오프셋에서 슬라이스된 메모리로부터 바이트를 읽습니다.\n                        let read = match read_file(\u0026file, buffer, file_offset).await {\n                            FileReadResult::Succeeded(_, read) =\u003e read as usize,\n                            _ =\u003e return Some(APP_FILE_READING_FAILED),\n                        };\n\n                        // 두 카운터 모두 증가해야 합니다.\n                        buffer_offset += read;\n                        file_offset += read as u64;\n\n                        // 파일 끝에 도달한 경우 읽은 양을 반환합니다.\n                        if read == 0 {\n                            break;\n                        }\n                    }\n\n                    // sha1이 필요로 하는 512비트 경계까지 슬라이스합니다.\n                    let slice = match buffer.between(0, buffer_offset / 64 * 64) {\n                        HeapSlicing::Succeeded(val) =\u003e val,\n                        _ =\u003e return Some(APP_MEMORY_SLICE_FAILED),\n                    };\n\n                    // 이를 이벤트 루프 외부에서 처리합니다.\n                    let task = spawn_cpu(move || -\u003e Result\u003cSha1, ()\u003e {\n                        // 슬라이스를 처리하고 새로운 sha1을 반환합니다.\n                        Ok(sha1.update(slice.ptr() as *const u8, slice.len()))\n                    });\n\n                    // cpu 작업을 대기합니다.\n                    sha1 = match task {\n                        None =\u003e return Some(APP_CPU_SPAWNING_FAILED),\n                        Some(task) =\u003e match task.await {\n                            SpawnCPUResult::Succeeded(Some(Ok(sha1))) =\u003e sha1,\n                            _ =\u003e return Some(APP_CPU_SPAWNING_FAILED),\n                        },\n                    };\n\n                    // 버퍼가 완전히 채워지지 않은 경우 파일이 완료된 것으로 간주합니다.\n                    if buffer_offset \u003c buffer.len {\n                        break;\n                    }\n\n                    // 그렇지 않은 경우 버퍼를 처음부터 다시 채우기 시작합니다.\n                    buffer_offset = 0;\n                }\n\n                // 버퍼에 남은 바이트 양이 0과 63 사이일 수 있습니다.\n                let slice: HeapSlice = match buffer.between(buffer_offset / 64 * 64, buffer_offset) {\n                    HeapSlicing::Succeeded(slice) =\u003e slice,\n                    _ =\u003e return Some(APP_MEMORY_SLICE_FAILED),\n                };\n\n                // 완료해야 할 작업\n                let task = move || -\u003e Result\u003c[u32; 5], ()\u003e {\n                    // 최종 해시를 [u32; 5]로 반환합니다.\n                    Ok(sha1.finalize(slice.ptr() as *mut u8, slice.len(), file_offset))\n                };\n\n                // cpu 작업을 대기합니다.\n                let hash: [u32; 5] = match spawn_cpu(task) {\n                    None =\u003e return Some(APP_CPU_SPAWNING_FAILED),\n                    Some(task) =\u003e match task.await {\n                        SpawnCPUResult::Succeeded(Some(Ok(hash))) =\u003e hash,\n                        _ =\u003e return Some(APP_CPU_SPAWNING_FAILED),\n                    },\n                };\n\n                // sha1sum 출력과 유사한 메시지가 구성됩니다.\n                let mut msg = [0; 160];\n                let len = format6(\n                    \u0026mut msg,\n                    b\"%x%x%x%x%x  %s\\n\",\n                    hash[0],\n                    hash[1],\n                    hash[2],\n                    hash[3],\n                    hash[4],\n                    path.as_ptr(),\n                );\n\n                // stdout에 비동기적으로 출력됩니다.\n                let stdout = open_stdout();\n                match write_stdout(\u0026stdout, (msg, len)).await {\n                    StdOutWriteResult::Succeeded(_, _) =\u003e (),\n                    _ =\u003e return Some(APP_STDOUT_FAILED),\n                }\n\n                // 파일을 닫습니다.\n                match close_file(file).await {\n                    FileCloseResult::Succeeded() =\u003e (),\n                    _ =\u003e return Some(APP_FILE_CLOSING_FAILED),\n                }\n\n                None\n            });\n\n            // 작업을 실행하기 위해 대기합니다.\n            match task.await {\n                SpawnResult::Succeeded() =\u003e (),\n                _ =\u003e return Some(APP_IO_SPAWNING_FAILED),\n            }\n        }\n\n        None\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 높은 목표를 가진 PoC를 끝냈어요. No-std와 no-main 환경을 유지하면서 작동하는 예제를 만들었죠. 우리는 pipes를 다루는 법과 스레드를 실행하기 위해 우리 자신을 복제하는 방법을 배웠어요. 마지막으로, 우리는 클로저에 손을 대고 그것을 스레드 간에 이동시켜 I/O에 전념한 실행 이벤트 루프를 차단하지 않고 CPU 집약적 작업을 수행하는 방법을 알아냈어요. 이 모든 기능을 사용하면서 우리는 동기화 도구를 전혀 사용하지 않았어요! 이게 바로 이상적인 동시성 모델이 아닌가요?\n\nhttps://github.com/amacal/learning-rust/tree/async-await-pipes","ogImage":{"url":"/assets/img/2024-06-19-LearningRustBareThreading_0.png"},"coverImage":"/assets/img/2024-06-19-LearningRustBareThreading_0.png","tag":["Tech"],"readingTime":50},{"title":"Portainer로 Docker 관리를 간단히 하기","description":"","date":"2024-06-19 00:45","slug":"2024-06-19-SimplifyDockerManagementwithPortainer","content":"\n\n## 도커용 포트에이너 설정. 이미지와 컨테이너 관리를 위한 GUI 사용.\n\n![Portainer](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_0.png)\n\n## 포트에이너란:\n\n포트에이너는 도커 환경을 관리하는 데 도움이 되는 유틸리티입니다. GUI를 통해 모든 도커 작업을 간편하게 관리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 준비 사항:\n\n도커\n\n## 도커에서 Portainer 실행하기:\n\n먼저 Portainer를 위한 볼륨을 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n도커 볼륨을 생성하려면 다음 명령어를 실행하세요.\n\ndocker volume create portainer_volume\n\n위 볼륨을 마운트하여 포테이너 도커 이미지를 실행하세요.\n\ndocker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest\n\n→ -v /var/run/docker.sock:/var/run/docker.sock\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Portainer 컨테이너는 호스트에서 실행 중인 Docker 데몬과 통신합니다.\n\n→ -v portainer_data:/data\n\n- 이 볼륨은 Portainer 데이터를 지속적으로 유지하는 데 사용됩니다.\n\n![이미지](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포트 노출된 앱을 둘러보세요.\n\n일정 시간 이내에 상호 작용하지 않으면 이 위자드가 만료되어 포테이너 컨테이너를 다시 시작해야 합니다.\n\n![Portainer Image](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_2.png)\n\n시작하기를 클릭하고 Live connect를 클릭하여 로컬 도커에 연결하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![2024-06-19-SimplifyDockerManagementwithPortainer_3](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_3.png)\n\n![2024-06-19-SimplifyDockerManagementwithPortainer_4](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_4.png)\n\n그리고 모든 데이터가 있는 대시보드가 나타납니다.\n\n왼쪽 패널의 메뉴를 탐색하면 App 템플릿, 컨테이너, 이미지 등이 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 활성 컨테이너 목록이 나타납니다. 새로운 컨테이너를 추가해보세요.\n\n'컨테이너 추가'를 클릭하세요. 이 페이지에서 Docker 허브도 검색할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컨테이너에 이름을 지정하고, 위의 방법처럼 무작위 포트를 할당하거나 직접 설정할 수 있습니다.\n\n앱을 둘러보세요:\n\n![Screenshot](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_7.png)\n\n모든 컨테이너와 상태를 볼 수 있습니다 (docker ps -a). 상태 뱃지 옆에는 로그 보기, 검사 또는 컨테이너로 실행하는 버튼이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_8.png)\n\n컨테이너를 선택하시고, 이제 중지, 시작, 재시작 또는 제거 등의 조작을 할 수 있습니다.\n\n이미지도 마찬가지로 모든 이미지를 리스트업합니다 (docker image ls), 태그 등.\n\n![이미지](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_9.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 이미지에 대한 컨테이너가 존재하지 않으면 사용되지 않음을 보여줍니다.\n\n코드를 업로드하고 편집기를 사용하여 이미지를 빌드하는 옵션입니다.\n\nApp Templates를 사용하면 준비된 컨테이너를 시작하거나 사용자 정의 템플릿을 만들 수 있습니다.\n\n![Portainer Image](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_10.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 원격 Docker 환경에 연결하기:\n\n여기는 Docker가 설치되어 있고 nginx 컨테이너가 실행 중인 또 다른 기계입니다.\n\nEnvironment를 클릭하고 Environment 추가를 선택한 다음 환경을 선택하세요 (나의 경우에는 docker).\n\n![이미지](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에이전트를 선택하고 두 번째 기계에 명령 스니펫을 복사하여 붙여넣으세요. 이름을 지정하고 IP를 사용하며, 포테이너 에이전트 포트와 연결하세요.\n\n![이미지](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_12.png)\n\n이는 '포테이너 에이전트'라는 컨테이너를 실행하며, 이를 사용하여 환경과 통신할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_13.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 홈페이지로 이동하여 2번 환경에서 연결을 클릭해주세요.\n\n![이미지](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_14.png)\n\n이렇게하면 환경이 전환되어 2번 컴퓨터에있는 모든 이미지와 컨테이너가 표시됩니다.\n\n![이미지](/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_15.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에지 에이전트를 통해 연결하면 IP를 입력할 필요가 없습니다. 그냥 코드를 복사해서 원격 기기에서 실행해보세요.\n\n## 마무리:\n\n깔끔한 UI로 도커 관리를 쉽게 할 수 있는 훌륭한 유틸리티입니다. 도커 컴포즈 관리와 같은 스택을 더 탐구해보거나 k8s와 같은 다른 환경에 연결해보세요.\n\n참고: Portainer.io","ogImage":{"url":"/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_0.png"},"coverImage":"/assets/img/2024-06-19-SimplifyDockerManagementwithPortainer_0.png","tag":["Tech"],"readingTime":4},{"title":"개인정보 보호, 정치, 그리고 포르노","description":"","date":"2024-05-27 15:45","slug":"2024-05-27-Privacypoliticsandporn","content":"\n캐나다 정치가 아이스크림이라면, 저당량 네오폴리탄 맛일 것 같아요. 쇼콜라, 바닐라, 딸기 같은 세 가지 서로 다른 옵션이 있는데, 실제 맛과는 다르게 느껴질 수 있고 인공적인 후맛을 남길 수 있어요.\n\n보수당, 자유당, 신민당이 있지만, 마음이나 취향에 따라 아이스크림을 선택하는 것처럼, 캐나다 유권자들도 자신의 가치관과 포부를 가장 잘 대변하는 정당을 선택해요. 다른 정당들도 있지만, 이들은 열매맛 사탕처럼 인기가 없어요; 좋아하는 사람들은 정말로 좋아하지만, 대부분의 사람들은 시식조차 시도하지 않아요.\n\n우리 시스템은 매우 진한 바닐라 맛같아요; 캐나다는 입헌 군주국가이자 입헌 민주주의국가에요. 여왕과 총리가 있어요. 대통령도 선거단과 2차 개정안도 없어요. 북쪽 이웃국가는 미국의 양당 정치의 광적인 보도나 멜로드라마 같은 것은 없지만, 때로는 열기를 내고, 섭씨로도 측정하니 그리 나쁘게 보이지 않아요.\n\n1982년부터 시행된 우리의 비교적 새로운 권리와 자유 헌장은 우리의 표현의 자유가 절대적이지 않다고 규정해요. 헌장은 자유롭고 민주적인 사회에서 정당화된다면 특정 제약을 허용해요. 이는 캐나다 법이, 예를 들어 혐오 발언, 공공안전, 다른 권리와 자유를 보호하기 위해 필요하다면 표현에 제한을 가할 수 있다는 것을 의미해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리베럴당이 최근에 온라인 해심법안(C-63)을 도입하여 온라인 표현 규제를 확대하고 범죄 처벌을 강화했습니다. 이 법안은 성적 피해를 주거나 아동을 괴롭히는 콘텐츠, 폭력적 편견을 부추기거나 테러주의를 부추기는 콘텐츠, 즉 혐오를 조장하는 콘텐츠에 중점을 둔 디지털 안전위원회를 설립할 것입니다.\n\n그러나 이 법안의 타이밍은 더 이상 나빠질 수 없습니다.\n\n저스틴 트뤼도 총리의 인기 하락은 묵시적으로 못 박고, 그의 리베럴 정부는 온라인 Safety Comission의 체제를 구축하기 위해 5950만 캐나다 달러를 낭비했습니다. 이 돈은 캐나다 국경경비청이 COVID-19 시기에 여행자를 위해 세관 및 이민 신고를 용이하게 하고 백신 요구 사항을 정리하기 위해 사용하는 간단한 ArriveCan 앱에 소비된 것입니다. 이 모바일 어플리케이션의 초기 버전은 2년 전에 8만 달러만 사용되었는데, 이는 국가 기관의 매우 나쁜 관리 기록 뿐만 아니라 디지털 신원증명과 디지털 안전위원회의 미래 관리에 대한 어떠한 선의의 의지도 침해했다고 생각됩니다.\n\n보수당 지도자인 피에르 폴리에브르는 이 법안을 \"표현의 자유를 침해하는 공격\"으로 보기 때문에 이를 좋아하지 않습니다. 이 부분은 정당의 일부인 \"소수의 소수 집단\"이 \"결코 받아들일 수 없는 견해\"(예: Freedom Convoy)를 가지고 있을 수 있는데, 이미 그의 정당은 아동 보호에 대한 다른 영향을 가진 다른 접근 방식에 투자하고 있기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보수당과 신민주당의 지지를 받아 독립적인 퀘벡 센터인 미빌드샤느가 S-210이라는 법안을 발의했습니다. 이 법안은 사용자가 사이트를 이용하기 전에 나이 확인을 하지 않아도 포르노 사이트를 형사상 책임을 물을 수 있도록 하는 내용이 포함되어 있습니다. 이 법안은 일부 식별 부분을 해석에 맡기기 때문에, 입법적으로 매우 문제가 될 수 있습니다. 현재 이 법안은 하원에서 검토를 기다리고 있습니다.\n\n이러한 논리는 외관상 설득력이 있지만, 이미 플레이보이 잡지를 구매할 수 없는 어린이들이 있기 때문에 문제가 됩니다. 2020년부터 플레이보이 사가 종이 재판판을 출판하지 않았기 때문이죠. COVID로 인해 센터폴드를 비롯한 많은 것들이 사라졌습니다.\n\n이 두 법안은 좋은 의도를 가지고 있으며, 아이들을 위한 온라인 안전 문제에 전념하는 것은 찬양 받을 만 합니다. 그러나 악마는 세부 사항에 있습니다. 시스템 설계적인 관점에서 보면, 선형 시스템(정부)이 혼돈된 시스템(인터넷)을 통제하려고 할 때 필요한 자원의 양이 거대하며 의도치 않은 결과를 예측하기 어렵습니다.\n\n다시 말해, 캐나다 정치인이 시민을 위한 디지털 신분증에 대해 이야기할 때마다 러시아 해커들은 날개를 달 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 위험한 곳, \"인터넷.\"\n\n왜 외계인들이 지구를 방문하지 않을까요?\n\n순진한 사람들은 제3종 접촉이 발생하지 않은 이유로 우주가 너무 방대하고, 우리가 알고 있는 삶이 적을 뿐만 아니라, 일부 문명만 화성 간 탐사에 관심이 있기 때문이라고 생각합니다.\n\n오, 페르미, 순수한 너드! 외계인들이 우리를 피하는 이유는 인터넷에 접근할 수 있기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사이버 공간에 대한 것은, 당신이 더 큰 참혹한 악당과 악당들의 둥지를 더 이상 찾을 수 없다고 생각할 때, 더 나쁜 것으로부터 두 번의 클릭만 떨어져 있다는 점입니다. 만약 당신이 어둠의 레딧에 떨어진다면, E.T.의 충고를 따라 가능한 빨리 \"집으로 돌아가\"세요.\n\n인터넷을 위한 설명서는 없습니다.\n\n우리 대부분은 기술이 발전하는 동안 디지털 리터러시를 형성해야 했던 GenXer입니다. 옛날 AOL 트라이얼과 404 에러. 우리는 디지털 이민자였습니다. 우리 자식들과 손자, 손녀들은 디지털 네이티브였습니다. 그것이 그들이 물려받은 땅입니다; 많은 양육 결정처럼, 기술에 대한 접근과 우리 집 앞에 가져올 수 있는 것에 대한 접근은 정서적이고 편향적일 수 있습니다.\n\n당신이 당신이 이미 살고 있는 것보다 더 복잡한 성인 생활에 대비하기 위해 아이들에게 세계의 위험을 어떻게 노출시키나요? 현재의 보호장치와 더 많은 보호장치가 해답인가요, 아니면 모든 것이 교육, 기준 개발 및 자녀와 성숙한 대화에 관한 것인가요? 디자이너, 정부, 그리고 사회가 멈추고 부모들이 결정할 수 있는 지점은 어디인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나이와 교육수준은 디지털 소양(source)과 정치적 견해를 예측하는 좋은 지표입니다. 캐나다에서는 63%의 노인이 인터넷과 디지털 기술을 사용하지 않거나 기초적인 사용자로 분류되며, 고등학교 졸업생도 40%가 해당됩니다. 반면, 15~34세의 사용자 중 77%는 숙련이나 고급 사용자로 분류되며, 총주의자 학위 이상을 가진 캐나다인의 76%도 해당됩니다.\n\n![그림](/assets/img/2024-05-27-Privacypoliticsandporn_0.png)\n\n민주주의에서 이 디지털 격차는 오류인가 특징인가요? 기술에 대한 불신과 두려움을 자본화하는 어떤 당이 이길 수 있는 주장을 갖게 되겠죠. 결국, 누가 화소화된 성기로부터 어린이를 보호하지 않겠습니까?\n\n\"내 견해로는\" = 편향을 인정하는 것.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n진짜 문제는 그들이 그것에 접근하는 방식이 정말로 좋은 의도, 비교립 체제가 아니며, 미래 중심적인지입니다.\n\n어린이들의 안전 뿐만 아니라 일관되게 요구, 창조 및 인터넷의 어두운 구석을 가능하게 하는 사회의 종류를 분석하는 논리적인 논쟁이 가능할까요?\n\n당신이 입법을 추진할 권한이 있다면, 무엇을 제안하겠습니까? 범죄화, 자아 표현, 혹은 치료?\n\n# 통계에 따르면: 포르노가 존재합니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n온라인 세계의 어느 정도가 포르노에 전념되어 있는지 어떻게 생각하십니까? 섹스와 관련된 모든 것과 마찬가지로, 현실은 종종 우리의 상상력과는 거리가 멉니다.\n\n웹 페이지 중 포르노가 차지하는 비율은 약 4%로 추정됩니다 (출처). 포르노허브는 추정 방문자 수가 월간 643백만 명인 세계에서 7번째로 많이 방문되는 웹사이트로, 아마존의 600백만 명 방문자를 압도해 그 자리를 차지했습니다 (출처). 이것은 사람들이 조금은 Jeff Bezos보다 Johnny Sins를 약간 더 선호한다는 것을 암시할 정도입니다.\n\n참고로, 1분마다 55,000 기가바이트의 성인 콘텐츠가 업로드된다고 합니다 (출처). YouTube, 온라인에서 가장 많이 방문되는 페이지인 만큼 1분마다 2.815 테라바이트를 받는데, 매월 45억 명 방문자를 유치합니다.\n\n글로벌로 가장 자주 방문되는 상위 100개의 웹사이트 중 4개가 성인 콘텐츠 플랫폼이라고 합니다. 포르노 관련 주제는 웹 검색량의 13%와 모바일 검색의 20%를 이끌고 있어서 아직 사람들이 북마크를 사용하는 방법을 잘 모르는 것 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Privacy, Politics, and Porn](/assets/img/2024-05-27-Privacypoliticsandporn_1.png)\n\n포르노 그라피티에 따르면, 전체 트래픽의 79%는 20개 국가에서 기여하는 것으로 나타났어요. 이 통계는 'America #1' 슬로건을 재구성했고 미국 다음으로 영국, 일본, 프랑스, 이탈리아가 뒤를 이었습니다.\n\n캐나다는 7위네요! 알겠어요, 캐나다친구들, 그건 초보 숫자야! Mindgeek (Pornhub)는 몬트리올에 있으니까 국가 경제를 지원해야죠, 알겠죠?\n\n포르노 사이트 방문은 보통 짧고 달콤하죠. 미국인들의 평균 방문 시간은 9분 44초예요. \"이탈률\"에게 완전히 새로운 의미를 부여하고 있네요. (출처)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위오밍, 미시시피 및 알라바마는 포르노를 가장 오래 시청하는 미국 주입니다. 위오밍은 놀라운 평균 11분 3초를 소비하며, 미시시피와 알라바마는 각각 10분 51초와 10분 46초를 소비합니다.\n\n이러한 주가 가장 긴 시청 시간을 보이는 이유는 알 수 없습니다. 내구력 때문인가요? 줄거리를 위해 머물러 있는 걸까요? 아니면 보수당을 지지하고 있어서 이러는 걸까요? 이것은 이제 그대로 남아 있을 것입니다.\n\n자유의 땅에서는 루이지애나의 2022년 성인 사이트 연령 확인을 위한 규정이 아이디 앱 사용 증가로 이어졌고, 아칸소 및 유타를 비롯한 여러 주가 2023년에 이어 관련 법률을 시행했습니다. 법률은 소년 소녀들 사이의 소셜 미디어 중독과 포르노 액세스를 규제하기 위한 것이었으며, 이에 관한 헌법적 타당성에 대한 다양한 법원 판결과 법적 도전이 있었습니다 (출처).\n\n유타의 규정이 초래한 부작용 가운데, PornHub는 전체 주의 IP 주소를 차단하여 가상 사설망 (VPN) 사용이 967% 증가했습니다. (출처).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-27-Privacypoliticsandporn_2.png)\n\n텍사스와 몬타나도 곧 유사한 입법을 추진할 것으로 예상되며, 이에 따른 VPN 사용량이 증가할 것으로 예상됩니다. 하지만 추적하기 어려운 것은 이들 사용자 중 얼마나 많은 사람이 성인 콘텐츠를 찾기 위해 다른 경로를 선택하는지입니다.\n\n# 표면 웹, 딥 웹 및 다크 웹에서의 신원\n\n가상 사설망은 웹의 표면 수준에서 익명성을 유지하는 방법입니다. 그러나 많은 사람들의 놀라움으로, 인터넷에는 공공 검토를 벗어나 익명성의 추가적인 층을 제공하는 영역인 딥 웹과 다크 웹이 발전해 왔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![프라이버시, 정치 그리고 포르노그래피](/assets/img/2024-05-27-Privacypoliticsandporn_3.png)\n\n깊은 웹은 검색 엔진 인덱싱되지 않은 인터넷의 모든 부분을 포함하며, 개인 데이터베이스 및 구독 기반 서비스를 포함합니다. 깊은 웹에는 의료 기록, 법률 문서, 과학 보고서, 구독 정보, 학술 저널, 은행 및 금융 기록, 개인 이메일 계정, 그리고 기업 웹 페이지와 같은 개인 데이터베이스가 포함됩니다. 이러한 자료에는 특정 자격 증명 또는 권한이 필요합니다.\n\n이 데이터는 일반적인 검색 엔진에 인덱싱되지 않으므로 대다수의 인터넷이 일반 대중에게 숨겨진 상태입니다. 그리고 만약 제3자에 의해 악용된다면 모든 관련자들은 심각한 문제에 직면하여 대규모 소송과 돌이킬 수 없는 개인 피해를 입을 수 있습니다.\n\n다크 웹은 깊은 웹의 일부이지만 동일하지는 않습니다. 자세한 내용은 생략하고, 사용자의 개인 정보보호와 익명성 유지로 잘 알려져 있으며 연결을 여러 서버를 통해 라우팅하고 각 단계에서 데이터를 암호화하여 처리합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다크 웹은 특별한 익명성을 제공합니다. 독재 정부에서의 언론의 자유를 위한 포럼, 부도덕한 행위에 대한 고발, 개인 보복이나 차별을 두려워하지 않고 커뮤니티에 참여하는 등 합법적인 활동을 지원할 수 있습니다. 또한 암호 화폐 개발의 기반을 마련해 주었습니다. 그들이 어떤 목적으로 사용했는지는 묻지 마세요.\n\n반면, 마약 거래, 해킹 서비스, 장기 밀매, 신용카드 사기, 테러리즘 및 기타 불법 상품 및 소모적인 활동에 대해 악명이 높습니다. 2014년 포츠머스 대학교의 Gareth Owen은 Tor에서 가장 흔히 호스팅된 콘텐츠가 아동 포르노그래피였음을 발견했습니다.\n\n주로 추적이 어려우므로, VPN에 돈을 지불하고 정부의 디지털 신분증을 믿지 않는 만성 포르노 사용자가 얼마나 많이 다크 웹으로 향할지 알기 어려울 것입니다. 얼마나 많은 기술에 능숙한 14세 소년들이 있을지요?\n\n# 알고리즘은 후회가 아닌 참여를 추적합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인터넷이 우리로부터 정보를 수집하는 데 더 능동해지면 우리의 개인 및 전문적인 삶을 우리의 아바타와 분리하는 것은 거의 불가능해집니다. 그 논리는 간단합니다: 훌륭한 네티즌이라면 두려워할 것이 없고, 당신은 온라인 잘못 행동의 현실적인 결과를 피하기가 거의 불가능하므로 좋은 네티즌이 되어야 합니다.\n\n착안과 악에 대해, 인터넷의 디지털 익명성은 우리에게 그런 잘못된 길을 걷게 했는데, 온라인에서 발생하는 일은 온라인에 남는다고 느끼게 했습니다. 그러나 모든 것이 추적되는 시대에선, 어떻게 우리의 브라우저 히스토리에게 실수로 링크를 클릭했고 본 건 원치 않았고 다시 보고 싶지 않은 것이라고 말할 수 있을까요? 유튜브에게 예를 들자면, 나는 조던 피터슨에게는 전혀 신경 쓰지 않겠다고 말하고 싶은데, 그 알고리즘이 그를 권장해 주기를 그만두라고 요청해도 계속해서 나타나는 것처럼 말이죠.\n\n이제 어느 날 디지털 범죄를 우연히 목격해야 하는 상황에 처해 있다면, 온라인 피해법에 중요한 부분 중 하나인 디지털 안전 위원회가 준수 기록을 유지할 권한이 있는 것을 알고 있는 상황에서, 당신이 범죄를 신고한 사람임을 혼동하지 않도록 정보가 안전하게 전달되며 제대로 이해될 수 있을까요?\n\n우리의 정의 개념은 디지털 무게에 대처하는 데 더 잘 적응되어야 합니다. 어떤 범죄, 예를 들어 상대방의 동의 없이 친밀한 사진을 공개하는 것과 같은 하나의 범죄는 수백만 번 복제되어 영원히 서버에 저장될 수 있습니다. 그런 결과가 어디서 일어났는지를 알 수 있을까요? 일반인들의 대답은 확실한 평생 수감 및 매년 소변마려운 일들을 받아들이는 세션이겠지만, 법적으로 맥락이 중요합니다. 이러한 위반사항들은 일반적으로 민형사적 범죄로 분류되며 벌금, 벌칙 피해배상 및 징역형이 가능합니다. 그러나 이들은 여전히 충분히 심각하게 대해주지 않아 많은 사례들이 신고되지 않습니다. (출처)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-Privacypoliticsandporn_4.png\" /\u003e\n\n테일러 스위프트가 최근 비극적으로 X에서 성적으로 음란한 AI 생성 이미지가 유포되어 피해자가 되었습니다 (물론, X에서 일어나다니요). 이미지는 계정이 정책을 위반하여 최종적으로 정지되기 전에 17 시간 만에 사이트에서 4500만 회 이상 조회되고 24,000번 이상 재게시되었습니다. 이러한 영향은 그의 영토 내에서 관련된 모든 사람들에 대한 적절한 법적 자원이 충분히 있었던 경우에 무척 어려운 것이기 때문에 상상하기 어려워집니다. AI는 암을 치료하는 데 사용될 수도 있지만 사회적 암이 되어서는 안 된다.\n\n우리 연방 법은 공정한 처벌의 목적을 정의하지만 벌은 즉시 어떤 영토나 주를 횡단할 수 있습니다. 지역에서 저지른 행위가 다른 곳에서는 큰 문제가 아닐 수도 있지만 다른 곳에서는 반드시 처벌이 보장됩니다. 캐나다의 경우, 음주 법적 연령이 표준화되지 않습니다:\n\n- 앨버타, 매니토바, 온타리오, 프린스 에드워드 아일랜드, 퀘벡, 사스카처외에는 18세\n- 브리티시컬럼비아, 뉴브런즈윅, 뉴펀들랜드 래브라도, 노스웨스트테리토리즈, 노바스코샤, 누나부트, 요콘 외에는 19세입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지역 간 불일치에 대한 통치법은 어떻게 합니까? 이전히 존재하는 잘못된 부분에 대한 설계는 어떻게 하나요? 디지털 정책의 미래를 탐색하는 데는 많은 주의가 필요하며 가끔은 민감한 대화와 잘 알고 있는 봉양이 필요합니다.\n\n사용자 경험 디자이너로서, 우리는 합법적이고 도덕적이며 윤리적인 범위를 벗어나는 활동이 존재한다는 사실과 조율해야 합니다. 우리는 존재하는 세계를 위해 디자인하며, 언젠가는 우리의 작업이 사회에 순수 가치를 가져다 줄 것을 희망합니다.\n\n우리는 디지털 환경의 엄청난, 혼돈스러운 성격과 해당 사용자의 다양한 요구와 권리를 고려하는 세심한 접근 방식을 주장해야 합니다. 기술적으로 유익하거나 가치 중심적인 정책 뿐만 아니라 디지털 격차의 깊은 이해, 의도하지 않은 결과의 가능성 및 안전하면서도 자유로운 온라인 환경 조성의 중요성에 기반을 둔 정책이 요구됩니다.\n\n이 미묘한 균형은 계속되는 대화, 혁신적 사고, 정부, 기술 기업 및 시민사회 간의 협력이 필요하며, 우리의 집단적 안전과 시민의 자유를 존중하면서도 디지털 정책의 미래를 탐색해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결백함과 개인 정보 보호는 하나의 공통점이 있습니다: 한 번 상실되면 다시 되찾을 수 없다는 것입니다.\n","ogImage":{"url":"/assets/img/2024-05-27-Privacypoliticsandporn_0.png"},"coverImage":"/assets/img/2024-05-27-Privacypoliticsandporn_0.png","tag":["Tech"],"readingTime":9},{"title":"슈프림 코트의 슈퍼매이져리티는 2024년 대통령 선거에서 조 바이든을 지지해야 하는 주요한 이유입니다","description":"","date":"2024-05-27 15:42","slug":"2024-05-27-TheSupermajorityontheSupremeCourtistheOverarchingReasontoVoteforPresidentBidenin2024","content":"\n\n![image](/assets/img/2024-05-27-TheSupermajorityontheSupremeCourtistheOverarchingReasontoVoteforPresidentBidenin2024_0.png)\n\n슈퍼매이저리티는 십사번째 수정안 \"자유\"에서 개인의 개인 정보 보호와 자율성을 깎아내리고 있습니다.\n\n돕스(Dobbs) 사건에서 대법원 슈퍼매이저리티는 “개인의 존엄과 자율성에 중요한 역할을 하는 개인 선택”을 하는 개인 권리를 확고히 하는 헌법적 교리를 훼손하는 과정을 시작했습니다. 이는 “개인의 정체성과 신념을 정의하는 가까운 선택을 포함한 개인 존엄과 자율성을 강화하는 권리”로, 대부분의 미국인들의 삶의 다반사를 차지하고 있는 권리입니다.\n\n대법원이 돕스로로 르 전환하여 50년의 생식 자율성을 정부의 개입에서 제거하기 전에, 트럼프와 대법원 판사들은 를 결정된 사법라는 것을 의심하게 만들었습니다. 돕스에서는 제도적인 타당한 절차의 소멸을 볼 수 있으며 이것은 \"결혼, 생식, 피임, 가족 관계, 육아 및 교육과 관련된 개인적인 결정을 보호하는 헌법 교리\"입니다. 대법원의 수렴점에서 \"생활 중에서 사람이 할 수 있는 가장 가까운 또는 개인적인 선택 사항들, 존엄과 자율성의 핵심, ...자유의 중추\"는 이제 의심의 대상이 될 뿐만 아니라 \"십사번째 수정안에 의해 보호받을 수 없게 되었으며 ... 자유의 핵심\"은 더 이상 \"자신의 존재, 의미, 우주, 그리고 생명의 미스터리를 정의하는 권리\"를 보장하지 않습니다. 앤트니 케네디 재판관, 남동부 펜실베니아 계획모성단체. 케시.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 법정의 초과다수는 정부의 간섭으로부터 개인 자율권의 중요한 추가적인 권리, 즉 피임권(최근 트럼프가 의문을 제기한), 인종간 결혼, 성적 활동, 동의하는 성인 간의 성관계, 동성 결혼, 그리고 부모가 자녀의 보호, 양육, 교육, 보살핌, 그리고 통제를 지시하는 권리를 위협하고 있습니다. 만일 토마스 대법관의 의견이 받아들여진다면, 법정은 1965년에 판결된 커네티컷 주 그리스월드 대 커네티컷 사건부터 시작하여 모든 중요한 정당한 절차/사생활권 사건을 재검토하고 뒤집을 것입니다. (그리스월드 사건에서 법정은 결혼한 부부가 주의 간섭 없이 피임에 대한 헌법적 사생활권을 갖고 있다고 판결했습니다.)\n\n![이미지](/assets/img/2024-05-27-TheSupermajorityontheSupremeCourtistheOverarchingReasontoVoteforPresidentBidenin2024_1.png)\n\n초과다수는 대통령으로부터 권력을 차지하여 미국 국민의 건강, 안전, 복지를 약화시키고 있습니다.\n\n보수주의자들은 대사법 판사들을 혐오하지만, 그렇지 않을 때도 있습니다. 법정의 보수파 다수는 \"주요 질문 규범\"을 통해 기존 입법의 해체와 강화를 가속화하고 있으며, 수십 년 동안 유지된 권력 구조를 실질적으로 변화시키고 있어 의회에서 더 많은 교착 상태를 초래하고 있으며 미국 국민의 건강, 안전, 복지를 위협하고 있습니다. 행정부가 법률을 제정하고 행정하고 이를 \"활동주의적 보수파 초과다수\"의 만족에 어울리게 하는 연방 정부의 능력은 심각하게 손상되어 있거나 불가능하게 되어가고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n“주요 질문 주의”는 미국 행정법 사례에 적용되는 법률 해석 원칙으로, 법원이 의회가 주요 정치적 또는 경제적 중요성으로 라벨링한 문제들을 행정 기관에 위임하지 않는다고 가정합니다. 만일 슈퍼마이어리티가 연방 기관이 마음에 들지 않는 규제를 집행하고 있다면, 법원은 단지 집행물의 주제가 의회가 행정 기관에 위임하지 않은 “주요 질문”에 속한다고 결론지을 필요가 있습니다.\n\n미국 의회는 대부분의 연방 기관을 창설하며 의회가 정의한 정책 시행을 실행하고 강제하기 위한 규정을 제정하도록 합니다. 대부분의 이러한 기관들은 행정부의 일부이며, 의회가 제정한 법률을 집행하는 기관입니다. 연방 기관은 법률, 기술, 산업 및 과학 정책 감독을 총괄하므로, 특수 분야의 잘 교육받고 높은 기술을 가진 인력들을 고용합니다. 많은 사람들은 세계적으로 인정받는 학자들 및 전문가입니다.\n\n당연히 의회는 자신의 정책 시행에 필요한 세부 사항을 파악하고 채워넣기 위한 전문성, 시간, 인내심 또는 능력을 갖추지 않습니다. 결국 의회의 구성원으로 들어가는 유일한 요구 조건은 후보자가 25세 이상이거나 미국 시민권자로 적어도 일곱 년간 미국 시민이어야 하고, 대표하려는 주에 거주하고 있어야 한다는 것입니다. 상원의 구성원이 되려면 후보자가 30세 이상이어야 하며, 적어도 아홉 년간 미국 시민이어야 하고, 대표하려는 주에 거주하고 있어야 합니다.\n\n“조 바이든 대통령이 취임한 이후로 연방 주택 정책을 효과적으로 통제해 왔으며, 어떤 근로자가 코로나바이러스 19 예방접종을 받아야 하는지 결정하고, 환경문제 대응을 위한 EPA의 권한을 상당 부분 박탈하였으며, 교육 장관이 학생 대출을 수정하거나 사면할 수 있는 연방 법률을 다시 쓰기도 하였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"현재 다수파로 이해되는 대법원의 주요 질문 원칙은 지난 몇 년 동안 거의 공중에서 나타났습니다. 민주당 행정부가 만든 정책을 무효화하기 위해 공화당 임명 판사들에 의해 거의 배타적으로 사용되었습니다. 이 원리는 헌법 어디에도 언급되지 않았습니다. 연방 법령에도 언급되어 있지 않습니다. 선출되지 않은 판사들이 연방 정책에 지나친 통제력을 행사하려는 것으로 보입니다.\n\n이 원리의 결과는 놀라울 정도로 큽니다. 실제로, 주요 질문 원칙은 대법원을 국회가 행정부 기관에 위임한 어떤 정책 문제에 대한 최종 결정권으로 만들어, 선출되지 않은 판사들이 연방 정부의 두 선출 권력을 모두 무시할 권한을 부여합니다.\"\n\n대법원이 행정부를 주도권으로 뒤 바꿨을 때의 상황입니다.\n\n![image](/assets/img/2024-05-27-TheSupermajorityontheSupremeCourtistheOverarchingReasontoVoteforPresidentBidenin2024_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n미국의 슈퍼매이조리티는 인종 중심의 지역구 획정을 승인하는 등 소수결정을 유지하고 보존합니다.\n\n몇 주 전에 저는 미국 대법원 변호사 협회 멤버십을 포기하기로 결정했습니다. 그 이후로 정부의 제3조 지점에 대한 뉴스가 악화되었습니다. 네, 알리토 장관의 명백한 정치적이고 극단적인 이기주의 행동에 대한 보도는, 이전에 그가 법정 앞에서 사안을 갖고 있는 사람들로부터 사치스러운 선물을 받은 사실을 우리에게 더 명백히 보여주었으며, 그것을 연방법에 위반한 채 보고하지 않았다는 이전 뉴스와 결합하여, 우리가 이미 그의 글, 연설, 설교, 법정 외부 단체와의 연게에 대해 알고 강력히 의심했던 것을 더욱 확실히 확인했습니다. Jamelle Bouie가 말한 것처럼, \"사무엘 알리토 장관을 둘러싼 상황에 대한 미국 역사에는 진정한 전례가 없습니다.\" 알리토 가족의 '하늘에 호소(주님의 심판)'.\n\n(비록 이에 대해 갈렬하지만) 우선, 그가 뉴저지 집 밖에 게양한 '하늘에 호소' 깃발(\"깃발\")을 처음엔 1987년 유타주 솔트레이크시티에서 설립된 몰몬교와 밀접한 관계를 맺은 에버그린 인터내셔날 주식회사 심볼로 오인했습니다. 그 회사는 \"동성애자 감소 및 동성애 행동 극복을 원하는 사람들을 돕기 위한\" 명시적인 임무를 갖고 있었습니다. 이 회사는 2014년 폐쇄되었습니다.\n\n1월 6일 폭동에서 '하늘에 호소' 깃발이 기독교 국민주의의 상징으로서 부각되고 있다는 사실을 배우고 있으며, 기독교 국민주의가 폭동을 계획하고 실행하는 데 중추적인 역할을 한 사실을 알고 있습니다. 최고법원판사 알리토, 연방주의회 회장 레오 루시, 하원의원 마이클 존슨을 비롯한 더 많은 지지자들에 대해 더 많은 정보를 알게 되고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알리토의 신념 체계와 2023년 5월 23일 목요일 발표된 연방 대법원 판결인 Alexander v. South Carolina State Conference of the NAACP에 공통된 주제는 엘리 마이스탈이 이야기한 것처럼, 이렇다: 유일하게 자격 있는 미국 시민, 즉 백인들만이 완전한 시민권과 책임을 부여받아야 하며, 희석되지 않은 투표권, 존중받을 가치 있는 목소리를 가지고 있어야 한다는 것입니다. 알리토의 공개된 백인 크리스찬 국민주의를 기반으로 한 나는 한 걸음 더 나가서, 낙태, 동성 결혼, 트랜스젠더 권리, 그리고 정부에서 종교를 배제하는 것을 지지하는 사람들, 각성한 자유주의자, 이념주의자, 무신론자, 그리고 하위 품종, 인종, 민족, 종교를 가진 사람들은 자격 없다고 생각합니다.\n\n미국 헌법은 미국 선거인단의 소수를 통해 대통령을 선출할 수 있게 하며, 미국 선거인들의 소수를 통해 대통령이 후보자를 임명한 대법관들을 승인하게 합니다. 이 결함이 있는 시스템은 연방 및 주 의회가 정치적 지시도정을 통해 소수의 지배를 연장할 수 있으며, 대법관들은 이를 헌법과 완벽하게 일치한다고 여깁니다. 연방 대법원 정의로 나아가는 법률 원칙 설명.\n\n이번 주에도 대법원은 다시 한 번 그의 인종주의적이고 반민주적인 사법 기반을 확실하게 보여주었습니다. 2013년에 Shelby County v. Holder 사례에서 대법원은 1965년 투표권법의 중요한 부분인 Section 5를 약화시켰는데, 이는 투표에 대한 차별적 장벽을 극복해야만 했던 남부 주 및 카운티들이 미국 법무부장관이나 워싱턴 D.C.의 연방 지방 법원과 의결되는 선권 제안 입법을 사전에 승인받게 했습니다. Shelby County 사례에서의 결정을 확장시켜, 이번 주의 초과 다수가 인종주의적 지시도정에 대한 도전을 거의 불가능하게 만들 것으로 예상됩니다.\n\nAlexander 사례에서 사우스 캐롤라이나 의회는 2020년 인구조사를 기반으로 국회 의석구역을 다시 그렸습니다. 재선거는 20만 명의 흑인 유권자를 새로운 선거구로 분산시켰으며, \"[제1 국회의 지역]을 대부분의 찰스턴으로부터 제거함으로써 도시의 120년 역사를 끊었습니다.\" NAACP는 이 지도가 헌법적으로 인종주의적 지시도정이라고 주장했습니다. 대법원은 사우스 캐롤라이나 지도 사례에 대해 판결했습니다. 아프하한 증거 청취 후, 세 명의 연방 지방법원 패널은 NAACP의 주장을 받아들이며, 사실이 지도가 헌법에 위반되는 인종주의적 지시도정임을 압도적으로 입증했다고 결정했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알리토 재판관이 쓴 6-3 다수결 의견에 따르면, 상급 법원은 하급 법원이 사실적인 결정을 뒤엎었는데, 이를 “분명히 잘못되었던 사실적인 판단”이라 하며 상급 법원이 일반적으로 하지 않는 일을 했습니다. 그들은 사실을 재검토하고 “극명하게 다른 결론”에 이른 것입니다. 2019년 5-4 다수결에 근거하여 정치적인 아웃라이어 재구획을 허용한 것이 연방 법원의 관할 범위를 벗어난다고 판단한 알리토의 다수파는 재구획이 정치적인 것으로 규정하고 이에 따라 합법적이라고 명명했습니다. 남부 지역에서 흑인과 백인 유권자가 역사적으로 높은 극성을 띄고 있음에도 불구하고, 그들의 투표 패턴은 강력하게 인종과 관련이 있으며 증거가 분명하게 그 재구획이 인종을 기반으로 한 것임을 입증했습니다. 그리고 투표권 보호 법 1965년은 특히 다수파가 사우스캐롤라이나에게 흑인 투표권을 약화시키는 것을 허용한 것과 정확히 반대하도록 통과됐습니다. 남부 의원 중 누군가가 지도를 다시 그릴 때 인종이 고려되지 않았다고 주장한다면, 법원에 충분할 것입니다. 최고 법원은 인종적 재구획 선례를 해체했습니다.\n\n알리토의 결정이 '인종 차별적인 재구획을 방지하는데 있어 일련의 선례를 약화시키는 것으로 나쁜 것이라 할지라도, 다수파는 단독 강조 의견을 쓴 토마스 재판관에게 충분하지 않았습니다. 그는 법원이 “투표구획을 제한하는 모든 선례를 무효화해야 한다고 주장했으며, ‘한 사람 한 표’를 수립하거나 확인하는 공정한 사례를 제시한 것은 첫째부터 지도를 바꿀 권한이 없기 때문이라고 말했습니다. 그리고 그는 법원이 재구획에 불법적으로 개입했다고 주장하는 것 중 상당 부분을 놀라운 가해자인 ‘브라운 대 교육청 대 퀸’에 책임을 돌렸습니다. 클라렌스 토마스, 인종적 재구획을 위한 충분한 주장을 제시합니다.\n\n카건 재판관은 \"오늘의 다수파가 청구인들에게 불리한 결론을 내리기 위해 사실과 법률을 왜곡할 수 있는 사례를 찾은 것 이외에는 목격한 모든 합리적인 법정 구경꾼들이 알고 있는 것을 기초로 원념 참배를 포함한 반대 의견을 마무리했습니다. 그분의 의견은 이렇게 말합니다: ‘다양한 방법으로, 오늘의 다수파는 도전자들을 상대로 덱을 쌓습니다. 상태가 ‘인종을 고력하지 않은’ 대해 가능한 이야기를 갖고 있었다는 것 때문에 도전자들이 패배해야 한다, 다수파는 말합니다 — 심지어 반대 이야기가 더 타당했을 경우라도. 그리고 다시 한번, 다수파는 말합니다, 그들이 본증명의 특정 형태를 제시하지 않았기 때문에 (이들에게는 그것이 중요할 것인지를 알아차리지 못한 상태에서이기도 하고 최근 이 법원이 원고로 하여금 필요하지 않다고 말한 것) 패배해야 한다. 도전자들이 주장한 것처럼 주 재구획 계획이 인종적 분류의 결과임을 증명하기 위해 전문적인 통계 분석을 포함한 방대한 증거를 제시했음에도 상태가 그것을 인종적 분류의 결과로 생각하기 위해 노력하고 어렵고 서투른 부인 이상의 것을 제시한 사실에도 불구하고. 상태의 거짓 주장을 믿기 어려운 것으로 생각한 세 명의 판사들이 그 논백이 사실상 믿을 수 없는 것이며, 원고의 증거에 덧입히지 않았다고 생각했다. 투표에서 인종적 분류가 논의되면, 다수파는 말합니다, 모든 의심은 상태의 편을 들어주는 것으로 해결되어야 하며, 그렇지 않으면 (하느님 금지인) ‘책망적이고 멸시적인’ 행태를 벌릴 수밖에 없다고 하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주 의회 의원들과 지도 제작자들에게 인종적 선거구 재편에 대한 메시지네요. 저는 이미 언급한 이유들로, 이러한 행위자들은 종종 정당 목적을 달성하기 위해 인종을 대리인으로 사용하는 동기를 갖는 경우가 많습니다. 때로는 소수 선거인플루언스를 직접 억제하고 싶을 수도 있습니다. 이번에는 이 법정이 주들에게 말합니다. 오늘 주들아, 앞으로 나아가세요. 인종을 사용하는 합법적인 이유, 예를 들어 평등한 투표권을 보장하는 법률을 준수하기 위한 것 같은 인정받는 사유가 없다 하더라도 앞으로 나아가세요. 당신이 (최선의 경우) 인종을 파티 이익을 가져오기 위한 단순한 수단으로 사용하고 있다 할지라도, 각각의 경우에 더 많은 공화당당원이든 더 많은 민주당당원이든 더 많은 정당원을 선출하기 위한 단축으로 인종을 사용할지라도 앞으로 나아가세요. 최종적으로 당신의 행적을 알리는 것은 충분히 쉽습니다: 인종 기반의 결정이 아닌 가능성을 제기하면 결정적입니다. 그래서 이 '혐오스러운' 시민 분류의 관행은 계속될 것입니다. 이 것은 인종 일반화에 근거를 두고 인종적 분할을 이용하는 것입니다. 특히 선거 영역에서는 '만연한 인종차별의 추악한 양상'이길래, 우리 스스로, 우리의 정치 대표자들, 특히 이 법정에게는 더 나은 것을 요구해야 합니다. 존경히 반대를 표합니다.\"\n\n반대 의견 33~34.\n\nR.VanWagoner는 https://medium.com/@richardvanwagoner에 게시합니다. https://richardvanwagoner.medium.com/subscribe\n\n\\*나의 형제인 매우 재능 있는 소설 작가이자 소설가, 로버트 호드슨 밴 왜너,가 https://medium.com/@richardvanwagoner에 대한 실용적이고 기술적 제안을 제공한 데에 상당한 공로가 있습니다. 로브의 두 번째 소설인 서스펜스 드라마는 2020년 11월 17일 출시되었습니다. 아마존, 바른스 앤 노블, 애플 북스토어, 그리고 여러분이 선호하는 지역 서점에서 이 소설인 \"The Contortionists\"는 농담적으로 몰몬지역 아동의 실종에 대해 다룬 심리적 페이지 터너입니다. 저는 이 소설을 두 번 읽고 오디오 버전을 두 번 들었습니다. 그것은 문학적 걸작입니다. 그러나 'The Contortionists'는 마음이 약한 사람들에겐 권하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**Richard J Van Wagoner**은 제 아버지입니다. 그의 영예, 상, 그리고 전문 협회 목록은 광범위합니다. 그는 웨버 주립 대학교의 명예 교수 (회화 및 드로잉)로 총 3회 시각 예술 학과 의장을 맡은 경력이 있습니다. 그는 다수의 대학에서 초청 강의와 지도를 하였으며 다수의 전시 및 전시회 심사위원도 역임했습니다. 그의 작품은 국내외 다수의 전시와 전시회로부터 초대를 받아 전시되었으며 그의 작품은 국내외로 다수의 여행전시에 참가했습니다. 저의 딸 Angela Van Wagoner는 프로 사진작가로서, 제 아버지 작품 중 500개 이상을 촬영했습니다. https://medium.com/@richardvanwagoner 에 게재된 아버지의 작품 사진은 그녀가 찍은 것입니다.\n","ogImage":{"url":"/assets/img/2024-05-27-TheSupermajorityontheSupremeCourtistheOverarchingReasontoVoteforPresidentBidenin2024_0.png"},"coverImage":"/assets/img/2024-05-27-TheSupermajorityontheSupremeCourtistheOverarchingReasontoVoteforPresidentBidenin2024_0.png","tag":["Tech"],"readingTime":9},{"title":"주리안 어쌘지 사건이 전 세계 언론인들에게 왜 중요한지","description":"","date":"2024-05-27 15:41","slug":"2024-05-27-WhyJulianAssangesCaseMattersforJournalistsWorldwide","content":"\n\n![Why Julian Assange's Case Matters for Journalists Worldwide](/assets/img/2024-05-27-WhyJulianAssangesCaseMattersforJournalistsWorldwide_0.png)\n\n위키리크스 창립자 줄리언 어샌지스는 지금 감옥에서 너무 오랜 시간을 보내 왔기 때문에 그가 왜 그곳에 있는지 점점 기억하기가 힘들어지고 있습니다.\n\n그는 2019년부터 런던의 벨마시 감옥에 수감되어 있었습니다. 미국이 기밀 정보를 배포한 혐의로 그를 인도하려고 해올 동안 그는 거기서 억류되어 있었습니다. 그 이전에는 성 폭행 조사 및 기소를 피하기 위해 스웨덴으로 인도되는 것을 피하기 위해 에콰도르 대사관 (런던에 위치)에서 7년간 망명을 구하고 있었습니다. 그 시절에는 그 혐의가 최종적으로 철회되었습니다.\n\n이번 주에 어샌지스와 그의 변호팀은 중요한 승리를 거뒀습니다: 그는 미국으로의 인도를 항소할 권리를 부여받았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n승리일지 모르지만, 어쌍지는 여전히 감옥에 수감 중이며, 그의 사건은 언론인과 언론 자유 옹호자들이 알아야 할 중요한 사안입니다. 그가 미국으로 송환돼 재판을 받게 된다면, \"대중의 이익을 위한 정보\"를 공유한 것으로 처음으로 감옥에 가게 될 수도 있습니다.\n\n## 어쌍지의 (거의) 20년 요약\n\n어쌍지의 법적 문제는 2006년 웹사이트 위키리크스를 창설할 때 시작되었지만, 그 당시에는 그것이 전형적인 뉴스 기관으로 여겨지지 않았습니다. 위키리크스는 규제되고 비밀스러운 정보를 게시하여 전 세계에서 불법행위, 부패, 전쟁 범죄를 폭로하는 것을 사명으로 삼았습니다.\n\n위키리크스는 2010년에 악명을 얻게 되었는데, 미국군이 2007년 배그다드에서 미군에 의해 11명의 민간인이 살해당한 사건을 보여주는 분류된 미국 군사 비디오를 온라인으로 공유했습니다. 이 비디오와 수천 건의 다른 문서는 군 정보 분석관인 첼시 매닝에 의해 어쌍지와 위키리크스에 제공되었습니다. 매닝 자신도 기밀 정보를 공개한 혐의로 스파이법에 따라 기소되어 여러 해 동안 감옥에 있게 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어느 날 어쌍지는 1917년 스파이기법에 따른 17개 혐의와 \"컴퓨터 침입 공모\" 1개 혐의로 기소될 것이며, 매닝의 폭로를 발표한 것이 이로 이어질 것입니다.\n\n그 과정에서 어쌍지는 성폭행 혐의로 기소될 것이기도 합니다. 그는 그 혐의에 대해 무죄를 주장하며 스웨덴으로 이송되어 법정에 출석하는 것을 피하기 위해 에콰도르 대사관에 망명을 청했습니다. 결국 에콰도르 대사관 당국은 어쌍지를 내쫓았으며 그는 미국으로 이송을 기다리기 위해 구금되었습니다. 2019년부터 그는 런던의 교도소에 수감되어 있습니다.\n\n## 그러나 이 모든 일들이 어떤 의미를 지니며 언론의 자유와 언론에게 미치는 영향은 무엇일까요?\n\n어쌍지는 영국이 미국으로의 이송을 승인한 결정에 대한 항소 소송을 계속할 것입니다. 그의 변호인팀은 어쌍지는 미국 시민이 아닌 호주 시민이기 때문에 언론의 자유를 보호받지 못할 것이라는 점에 중점을 둘 것으로 예상됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n방에 있는 코끼리는, Assange가 미국 시민이었다고 해도 스파이법에 따른 기소로 인해 제1 수정안의 보호를 받기 어렵다는 것입니다. 이 법은 1917년부터 시행되어 왔으며, 비밀 및 기밀 정부 정보를 누설한 사람들에게 심각한 처벌을 부과합니다.\n\n스파이법에 따라 기소된 사람들은 분류된 정보를 왜 누설했는지 배심원에게 설명할 수 없습니다. 첼시 매닝, 에드워드 스노든, 리얼리티 유니어 등의 폭로자들은 미국 국민이 그들의 정부가 무엇을 하는지 알 권리가 있다고 믿어서 기밀 정보를 폭로했다고 진술했었습니다.\n\n언론 자유옹호자와 저널리즘 운동가들은 Assange에게 175년의 징역형을 위협하는 것이 “얼음 효과”를 일으킬 것이며 이는 미국과 세계 언론에 발표된 뉴스 기사에 “매우 냉담한 영향”을 미칠 것이라고 우려를 나타냈습니다. 이 편집 전문가들은 “정부 책임을 진다는 것은 민주주의 속에서 자유 언론의 핵심 임무 일부임을 밝히겠다”라고 밝히고 있습니다.\n\n## 안보의 나무들을 위해 언론의 숲을 잊지 마세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEspionage Act를 사용하여 국가 및 기밀 비밀 정보의 유출자를 기소하는 주장자들은 국가 안보를 보호하기 위해 해당 법률을 사용한다고 시민들에게 종종 말합니다.\n\n국가 안보는 유효한 우려사안이며 항상 심각하게 다뤄져야 합니다. 그러나 공개해야 할 권리가 있다고 믿는 정보를 유출하는 사람들은 종종 다른 사람에게 위험을 초래하지 않은 채로 그렇게 행동합니다. 예를 들어 미국 국방부는 첼시 매닝의 정보 유출이 \"미국의 이익에 실제 피해를 끼치지 않았다\"고 보고하였습니다. (그 정보들을 줄리안 어쌩지가 아직 공개했을 때 기소받고 있는 것들입니다.)\n\n줄리안 어쌩지의 법적 사건은 오랜 기간 복잡하고 다른 문제로 인해 복잡해졌습니다. 그 문제는 그의 반대로 성폭행 혐의를 포함합니다.\n\n그러나 세계의 시민들은 어떠한 경우에는 오늘날 사회에서 어떤 일을 하는지 알려줘야 하는 기자와 발행인들의 역할과 자유한 군림의 중요성을 믿는지 결정해야 합니다. 그렇게 믿는 경우, 어쌩지, 언론의 역할, 자유한 군림 권리들에 대해 더 알고 싶어할 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-27-WhyJulianAssangesCaseMattersforJournalistsWorldwide_0.png"},"coverImage":"/assets/img/2024-05-27-WhyJulianAssangesCaseMattersforJournalistsWorldwide_0.png","tag":["Tech"],"readingTime":3},{"title":"Z-검사 AI 신뢰성 평가 방법","description":"","date":"2024-05-27 15:39","slug":"2024-05-27-TheZ-InspectionamethodtoevaluateanAIstrustworthiness","content":"\n\n\u003cimg src=\"/assets/img/2024-05-27-TheZ-InspectionamethodtoevaluateanAIstrustworthiness_0.png\" /\u003e\n\n간략 요약: AI의 전체 잠재력을 실현하기 위해서는 신뢰성이 필요하며, 이를 위해 투명성, 공정성 및 보안에 주의를 기울여야 합니다. 편향과 개인 정보 보호에 대한 과제를 해결하기 위해서는 AI 수명 주기 전반에 걸쳐 종합적인 접근 방식이 필요합니다. Z-Inspection 방법은 윤리적, 기술적, 법적 고려사항을 연결하여 AI의 신뢰성을 평가하고 강화하는 실용적인 프레임워크로 나타나고 있습니다. 이 종합적인 접근 방식을 통해 우리는 신뢰를 불러일으키며 책임 있는 혁신을 이끌어내는 AI 시스템의 길을 열어갑니다.\n\n신뢰할 만한 AI란 무엇을 의미할까요? 정책 제정자와 AI 개발자들은 전 세계적으로 이 질문을 다루기 위해 수백만을 쏟아부었습니다. 이 노력 뒤에 있는 원동력은 사회가 AI의 전체 잠재력을 실현할 수 있는 믿음이 AI의 개발, 배포 및 사용에 신뢰가 내재되어야만 가능하다는 것입니다. 예를 들어, 의사와 환자가 AI 기반 시스템의 진단이나 치료 권고를 신뢰하지 않으면, 이러한 권고가 환자의 복지를 개선할 수 있다 하더라도 따를 가능성이 낮습니다. 마찬가지로 대중이 자율주행 차량을 신뢰하지 않는다면, 이들은 전통적인 수동 운전 차량을 대체하지 않을 것입니다.\n\n그러나 현재 많은 AI 시스템은 인지할 수 없는 공격에 취약하며, 소수 그룹에 편향이 있고, 사용자 프라이버시 보호가 부족합니다. 이러한 위반 사항은 채용 및 대출 결정에서 자동 시스템의 편향적 대우부터 인간 목숨의 손실에 이르기까지 다양합니다. 이러한 문제는 모든 AI 시스템에 대한 사용자 경험을 감소시키고 신뢰를 손상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전통적으로 인공지능 실무자들인 연구자, 개발자, 의사결정자들은 시스템 성능(즉, 정확도)을 주요 지표로 삼아왔습니다. 그러나 이 지표만으로는 인공지능 시스템의 신뢰성을 반영하는 데 충분하지 않습니다. 신뢰성을 향상시키려면 로버스트성, 알고리즘 공정성, 설명 가능성, 투명성 등 성능 이외의 여러 요인을 고려해야 합니다.\n\n인공지능 신뢰성에 대한 학계 연구는 주로 모델의 알고리즘적 속성에 중점을 두었습니다. 그러나 알고리즘적 연구만 진전시키는 것으로는 신뢰성 있는 인공지능 제품을 만들기에 부족합니다. 산업적 관점에서 보면, 인공지능 제품의 수명주기는 다양한 단계를 거치며 각 단계에서 신뢰성을 향상시키기 위한 특별한 노력이 필요합니다. 이러한 단계에는 데이터 준비, 알고리즘 설계, 개발, 배포, 운영, 모니터링, 그리고 거버넌스 등이 포함됩니다. 예를 들어, 로버스트성을 향상시키려면 데이터 살균, 강력한 알고리즘 개발, 이상 감지 모니터링, 위험 감사 등이 필요합니다. 반대로, 어느 한 단계에서 신뢰 손실이 발생하면 전체 시스템의 신뢰성이 훼손될 수 있습니다.\n\n따라서 인공지능 신뢰성은 시스템의 전체 수명주기 동안 체계적으로 세워지고 평가되어야 합니다.\n\n# 신뢰성 있는 컴퓨팅의 여정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컴퓨팅에서 신뢰성 개념은 중요한 사건에서 비롯되었습니다. 마이크로소프트의 공동 창업자인 빌 게이츠가 2002년 회사의 모든 직원에게 보낸 이메일에서 시작되었습니다. 이 이메일은 컴퓨팅 역사상 중요한 순간으로, 디지털 시스템에서의 신뢰성 개념을 위한 기초를 마련했습니다.\n\n이 신뢰성 컴퓨팅 방식은 컴퓨터 과학과 시스템 공학 분야 일부에서 계속해서 채택되고 있습니다 (예: 전기전자공학회 (IEEE) 및 국제전기기술위원회 (IEC)).\n\n국제표준화기구 (ISO) 및 IEEE 표준의 신뢰성 정의는 게이츠의 시스템 신뢰성 속성을 중심으로 구축되어 있습니다:\n\n- 컴퓨터 시스템의 신뢰성은 제공하는 서비스에 정당한 신뢰를 둘 수 있는 정도의 신뢰성\n- 특정 항목의 성능에 대한 믿음성 및 요구 시 수행할 수 있는 능력.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2024년 3월 13일, 유럽 의회가 인공지능 법안 (AI Act)을 채택했습니다. 이 법안은 세계 최초의 포괄적 수평적 인공지능 법적 프레임워크로 간주되며, 데이터 품질, 투명성, 인간 감시 및 책임성에 대한 EU 전체적인 규칙을 제정합니다. 이는 AI 시스템의 신뢰성 원칙을 더욱 발전시키는데 일조하고 있습니다.\n\n# AI 신뢰성에 대한 실용적 접근방식\n\n그러나 언급된 요구 사항 목록은 실제 응용에는 너무 추상적으로 보입니다. 이러한 지침은 AI 신뢰성 이해를 위한 기초를 제공하지만, 실세계에서의 구현을 위해 더 실용적인 접근 방식이 필요합니다.\n\nAI 신뢰성을 평가해야 할 주 배우자들뿐만 아니라 설계 및 개발 과정에 참여하지 않은 사용자들이 신뢰성을 평가하는 것 또한 좋은 실천 방법입니다. 이는 어떠한 우려 사항도 해소하고 시스템에 대한 신뢰를 높이는데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문맥에서 Z-Inspection과 같은 더 실용적인 평가 프로세스가 중요해집니다. Z-Inspection은 현실 세계 시스템 개발의 문제와 요구 사항에 맞춰 설계되었으며 AI 시스템의 협업, 자가평가 또는 외부 감사에 활용할 수 있습니다.\n\n이는 AI 시스템의 신뢰성을 평가하고 향상시키는 데 일반 목적 방법론으로 적합하게 만듭니다.\n\n- 설계 단계에서 Z-Inspection은 신뢰할 수 있는 AI 시스템을 설계하는 방법에 대한 통찰력을 제공할 수 있습니다.\n- 개발 중에는 윤리적 시스템 개발을 확인하고 테스트하고 관련 사용자 그룹의 수용을 평가하는 데 사용할 수 있습니다.\n- 배포 후에도 이 프로세스는 변화하는 모델, 데이터 또는 환경의 영향을 검사하는 지속적인 모니터링 노력으로 사용할 수 있습니다.\n\nZ-Inspection은 두 가지 완성된 접근 방식을 신중하게 결합한 방법론입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 전체 시스템을 이해하려는 종합적인 접근방식,\n- 문제 영역의 각 구성 요소를 신중하게 조사하는 분석적인 접근방식.\n\n이 통합은 “Responsible AI — Two frameworks for ethical design practice” 논문의 저자들의 관점과 일치합니다:\n\n# Z-Inspection의 단계별 가이드\n\n이 프로세스는 세 가지 주요 단계로 구성됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 사전 조건이 명확하게 파악되고 평가팀이 식별되며 경계에 동의하는 설정 단계\n- AI 시스템이 분석되는 것이 평가 단계\n- 식별된 문제와 긴장을 해소하고 권고사항을 제공하는 결과 단계.\n\n# 설정 단계\n\n설정 단계는 사전 조건을 명확히하고 조사팀을 선정하며 평가의 경계를 정의하고 프로토콜을 작성하는 데 도움을 줍니다.\n\nZ-검사 과정은 AI의 영향을 다루는 전문가들의 다학제적 팀을 구성하여 시작됩니다. 이 팀에는 도메인 전문가, 기술 전문가, 사용자, 법률 자문자 및 윤리학자가 포함되어야 합니다. 도메인 전문가는 AI의 기본 가정을 확인하고, 기술 전문가는 적절한 구현을 보증합니다. 사용자는 시스템과 관련된 우려를 표명하고, 법률 및 윤리 전문가는 가능한 도전에 대비하여 팀을 안내합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스테이크홀더 간의 기대치를 조율하는 것이 중요합니다. 검사 요청자가 누구인지, 결과가 어떻게 활용될지(예: 공중 홍보, 시스템 개선, 또는 최종 사용자와의 커뮤니케이션 등) 명확히 해야 합니다.\n\n이 단계는 또한 평가 범위를 정의하는 과정을 포함하며, AI 시스템이 더 넓은 사회 기술적 맥락 내에서 운영됨을 인식해야 합니다. 이 환경을 철저히 평가하는 것은 포괄적인 평가에 필요합니다.\n\n# 평가 단계\n\n평가 단계는 네 가지 작업으로 구성되어 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- AI 시스템 사용 분석;\n- 잠재적 윤리적 문제 및 기술적, 법적 문제 식별;\n- 해당 문제를 신뢰할 수 있는 AI 윤리적 가치 및 요구 사항에 매핑;\n- 해당 요구 사항의 검증.\n\n평가 단계의 첫 번째 단계는 AI 시스템을 사용하는 사람들의 가능한 일상적인 경험을 설명하는 사회 기술적 시나리오를 정의하는 것입니다. 이러한 시나리오는 발생할 수 있는 문제를 예측하고 강조하기 위해 사용됩니다. 이들은 공급 업체가 제공한 정보, 참가자의 개인 경험 및 이전에 정의된 평가의 한계를 기반으로 합니다.\n\n다음으로, 이러한 시나리오는 다른 팀 구성원들에 의해 분석됩니다. 각 팀 구성원은 다양한 배경을 통해 보완적인 시각을 제공할 수 있으므로 자신의 시각을 기여하도록 권장됩니다. 예를 들어, AI 엔지니어는 방사선과의 타겟마커와 간호사와는 달리 시스템의 다른 측면에 중점을 둘 것이며, 그들의 초점은 간호사의 것과 다를 것입니다.\n\n각 참가자 또는 동일한 배경을 가진 참가자 그룹은 시스템에서 보이는 문제점을 각자의 시각에서 설명하고 이러한 문제가 실제 문제인 이유에 대한 증거를 제시합니다. 이 증거는 수립된 모범 사례, 과학 보고서 또는 관찰된 행동과 공급 업체 시스템 설명 사이의 충돌과 같은 다양한 형태로 나타날 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 단계는 신뢰성 높은 AI 요구 사항과 충돌하는 문제를 식별하고 시스템 행동과 신뢰성 사이의 긴장을 강조하는 것입니다. 이 프로세스는 이러한 문제가 AI 시스템의 신뢰성에 미치는 영향을 강조하는 데 도움이 됩니다.\n\n그 후에 식별된 문제를 통합합니다. 각 이해관계자 또는 그룹은 발견한 결과를 제시하여 관련 문제를 결합하여 간결한 목록을 작성할 수 있습니다.\n\n# 해결 단계\n\n해결 단계는 이전에 식별된 윤리적, 기술적, 법적 문제에 대해 대응하며 가능한 경우 윤리적 긴장을 해소합니다. 참가자들은 이러한 문제를 논의하고 우선순위를 정하며 실행 가능한 해결책을 찾기 위해 협력합니다. 이 과정에서 시스템 및 구체적인 문제에 따라 원칙 간의 잠재적인 갈등이 발생할 수 있습니다. 이러한 경우 시간이 흐른 후 윤리적 AI 유지 보수 계획이 권장될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 중 세 가지 케이스 중 하나가 발생할 수 있습니다.\n\n- 긴장 상태가 해결되지 않을 수 있습니다.\n- 추가 리소스 할당을 통해 긴장 상태를 극복할 수 있거나\n- 두 가지 상충하는 원칙 사이에서 선택할 수 있는 해결책이 있을 수 있습니다.\n\n경우에 따라 충돌의 명백한 해결책이 있을 수도 있습니다. 그러나 다른 케이스에서는 트레이드오프가 필요하거나 현실적으로 해결책이 없을 수도 있습니다. 이 단계에서 참가자들은 윤리적 긴장을 직접 다루고 이해 관계자들과 트레이드오프를 논의하여 잠재적인 영향을 완화하기 위한 권고안을 제시합니다.\n\n# 최종 생각\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n원래는 AI 시스템의 신뢰성을 평가하기 위해 들어가기로 한 적은 없었어요. 처음에 제 초점은 디자이너가 사용자들이 회의를 극복하고 새로운 기술을 받아들이는 데 어떻게 도와줄 수 있는지였죠. 하지만 더 깊게 파고들수록, 시스템이 정말로 신뢰할 만한지 확인하는 것이 단지 그렇게 인식되는 것보다 훨씬 중요하다는 것을 깨달았어요.\n\nAI 시스템의 윤리적, 사회적 영향은 상당한 우려를 불러일으킵니다. 그리고 안타깝게도, 디자이너와 일반 사용자 모두에게 AI 신뢰성을 평가하는 방법에 대한 접근 가능한 정보가 부족합니다.\n\nAI 시스템의 신뢰성을 평가하는 경험이 있으시다면, 사용한 방법에 대해 알려주시면 정말 좋겠어요. 여러분의 통찰력을 공유해주시면 우리 모두가 투명하고 공정하며 안전한 AI 기술의 미래를 향해 함께 나아갈 수 있습니다.","ogImage":{"url":"/assets/img/2024-05-27-TheZ-InspectionamethodtoevaluateanAIstrustworthiness_0.png"},"coverImage":"/assets/img/2024-05-27-TheZ-InspectionamethodtoevaluateanAIstrustworthiness_0.png","tag":["Tech"],"readingTime":6},{"title":"그들이 진심으로 사랑할 때 남자들이 숨기는 비밀","description":"","date":"2024-05-27 15:38","slug":"2024-05-27-TheSecretsMenKeepWhenTheyLoveYouDeeply","content":"\n\n# 남자가 여러분을 더 사랑할수록 “공유”하기를 덜할 수도 있습니다. 잘못된 사람 찾지 않도록 주의하세요\n\n![image](/assets/img/2024-05-27-TheSecretsMenKeepWhenTheyLoveYouDeeply_0.png)\n\n작년에 유럽 영화와 미국 영화를 보았습니다. 거기에서:\n\n남자 주인공이 여자 주인공에게 우연히 사랑에 빠지게 되었습니다. 사랑에 빠졌을 때 남자 주인공은 몇 가지를 숨겼습니다. 여자 주인공은 남자 주인공이 항상 존경했던 군인이라고 잘못 생각하여 함께 하게 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 그들이 관계를 가진 후 여주가 남주가 그 사람이 아니라는 것을 발견했습니다. 이전에 남주는 히어로의 역할을 맡았었습니다.\n\n그래서 여주는 그 순간 매우 화를 내고 갑작스럽게 남주를 떠나버렸어요.\n\n남주는 여주를 계속 찾아다니며 사과하고 그 역시 이유가 있었음을 전하려고 했어요.\n\n사실 남자가 여자를 더욱 깊게 사랑할수록, 그는 여자와 일부 비밀을 공유하지 않을 수도 있습니다. 때로는 그녀를 잃을까봐 무서워해서 아예 숨길 수도 있죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결국, 관계에서 지나치게 솔직한 것은 상대방의 진심뿐만 아니라 비난과 이별을 불러올 수도 있습니다.\n\n남성들은 지는 것을 두려워하기 때문에 상대방에게 너무 많은 것을 말하지 않습니다. 따라서 여성들은 남성이 사랑이 부족해 당신에게 진실을 말하거나 특정한 사생활을 공유하지 않을 것이라고 생각해서는 안 됩니다. 때로는 상반된 상황일 수도 있습니다.\n\n남성이 당신을 더 사랑할수록 그런 사생활을 공유할 가능성은 더 적습니다. 잘못된 사람을 찾았다고 오해하지 마세요.\n\n# 가정에서의 어려움\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"모든 가족은 자신만의 어려움이 있어요.”\n \n모든 가족은 자신만의 도전이 있어요. 가족이 매우 부유해 보이더라도, 그들의 관계가 행복하지 않을 수 있어요.\n\n가끔은 훌륭한 관계를 가진 가족을 보아도 조용한 순간에는 여전히 몇 가지 문제로 논쟁할 수 있어요.\n\n남자가 여자를 정말 좋아한다면 그가 집에서 겪는 어려움 중 일부를 전혀 공유하지 않을 거예요. 이 어려움을 그녀와 공유한다면 그녀를 상처받게 할 수 있어요. 남자가 여자를 진심으로 사랑한다면 그녀에게 그렇게 많은 부담을 지우지 않을 거예요.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한편, 두 사람이 함께 있지 않거나 아직 결혼하지 않았다면, 대부분의 경우 남성은 집에서의 어려움을 상대방과 공유하는 것을 꺼려합니다. 상대방을 놀래킬까봐 두려워하기 때문입니다.\n\n그래서 때로는 남성들은 이런 식이죠. 상대방을 잃을까 봐 두려울 때, 집안의 금전적 문제와 같은 일부 어려움을 공유하지 않을 수 있습니다.\n\n여성으로서, 남성과 부드럽게 소통해보세요. 그러면 그가 마음을 열기 쉬워질지 모릅니다.\n\n# 전 여자친구에게 준 사랑\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여성들은 보통 예민할 때가 많아요. 그들이 자신의 남자가 이전에 누군가에게 많은 사랑을 줬다는 것을 알게 되면, 그들은 불안해하고 전 여자친구와 자신을 비교할 수 있어요.\n\n만약 남자가 정말 전 여자친구와 결별했다면, 당신과 함께 보내는 모든 순간에는 그의 마음에는 당신이 있어야 하고, 전 여자친구가 아니어야 해요.\n\n만약 남자가 당신을 깊이 사랑하고 전 여자친구에 대해 이야기하고 싶어하지 않는다면, 그것은 그가 당신을 충분히 사랑하지 않는다는 이유가 아니라, 그가 당신 덕분에 과거를 잊은 것 때문일 수 있어요.\n\n여성으로서는, 항상 남자의 과거 연애에 대해 꺼내지 말아주세요. 그것은 쉽게 그를 전 여자친구에 대해 생각하게 만들 수 있고, 당신끼리의 관계에 손상을 줄 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 직업 걱정\n\n남자가 여자를 깊이 사랑한다면, 자신의 직업 걱정을 그녀와 공유하지 않을 수도 있습니다. 그는 이러한 걱정을 공유하는 것이 그녀를 불안하게 만들 수 있음을 알고 있습니다. 여자를 사랑하는 남자로서, 그는 그녀에게 안전감을 주고 평온하고 부정적인 감정 없이 안정된 삶을 살도록 하고 싶어합니다.\n\n따라서 남자가 여자와 자신의 직업 걱정을 공유하지 않을 때, 그가 진심이 없는 것이 아니라 그녀의 감정과 이후의 상황을 걱정하기 때문일 수 있습니다.\n\n가끔은 집 밖에서 문제가 생겼을 때 집에 있는 가족들에게 알리지 않아 걱정하지 않도록 하는 경우도 있습니다. 비슷하게, 남자가 여자를 깊이 사랑할 때도 그녀를 걱정시키기를 두려워하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n남성이 직업적으로 어려움을 겪을 때, 항상 여성에게 말하는 것이 도움이 되지 않을 수 있습니다. 최대한으로, 그녀는 감정적 안정을 제공할 수 있을 뿐입니다. 그래도 그녀도 당황할 수 있고, 무엇을 해야 할지 모를지도 모릅니다.","ogImage":{"url":"/assets/img/2024-05-27-TheSecretsMenKeepWhenTheyLoveYouDeeply_0.png"},"coverImage":"/assets/img/2024-05-27-TheSecretsMenKeepWhenTheyLoveYouDeeply_0.png","tag":["Tech"],"readingTime":3}],"page":"103","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":13,"currentPageGroup":5},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"103"},"buildId":"kkckKPyxcjJp_o8wb2unW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>