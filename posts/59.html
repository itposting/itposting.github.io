<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/59" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/59" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_buildManifest.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="macOS Sonoma DMG 파일을 구글 드라이브에서 무료 다운로드하세요" href="/post/2024-06-20-FreeDownloadmacOSSonomaDMGFilefromGoogleDrive"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="macOS Sonoma DMG 파일을 구글 드라이브에서 무료 다운로드하세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-FreeDownloadmacOSSonomaDMGFilefromGoogleDrive_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="macOS Sonoma DMG 파일을 구글 드라이브에서 무료 다운로드하세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">macOS Sonoma DMG 파일을 구글 드라이브에서 무료 다운로드하세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="앱 v013가 공식으로 출시되었습니다" href="/post/2024-06-20-appv013isOfficiallyReleased"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="앱 v013가 공식으로 출시되었습니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-appv013isOfficiallyReleased_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="앱 v013가 공식으로 출시되었습니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">앱 v013가 공식으로 출시되었습니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Kube-Ops-View 탐험 Kubernetes 클러스터를 시각화하는 강력한 도구" href="/post/2024-06-20-ExploringKube-Ops-ViewAPowerfulToolforVisualizingKubernetesClusters"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Kube-Ops-View 탐험 Kubernetes 클러스터를 시각화하는 강력한 도구" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ExploringKube-Ops-ViewAPowerfulToolforVisualizingKubernetesClusters_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Kube-Ops-View 탐험 Kubernetes 클러스터를 시각화하는 강력한 도구" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Kube-Ops-View 탐험 Kubernetes 클러스터를 시각화하는 강력한 도구</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="TailsOS 세상에서 사라지고 싶다면 사용할 운영 체제" href="/post/2024-06-20-TailsOSAnOperatingSystemIWouldUseIfIWantedToDisappearFromTheWorld"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="TailsOS 세상에서 사라지고 싶다면 사용할 운영 체제" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-TailsOSAnOperatingSystemIWouldUseIfIWantedToDisappearFromTheWorld_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="TailsOS 세상에서 사라지고 싶다면 사용할 운영 체제" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">TailsOS 세상에서 사라지고 싶다면 사용할 운영 체제</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="구름을 들어봤어요" href="/post/2024-06-20-EverHeardOfTheCloud"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="구름을 들어봤어요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-EverHeardOfTheCloud_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="구름을 들어봤어요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">구름을 들어봤어요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리눅스의 Debian 또는 다른 리눅스에서 명령 줄을 사용하여 NerdFont또는 다른 글꼴을 설치해 보세요" href="/post/2024-06-20-InstallNerdFontoranyfontsusingthecommandlineinDebianorotherLinux"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리눅스의 Debian 또는 다른 리눅스에서 명령 줄을 사용하여 NerdFont또는 다른 글꼴을 설치해 보세요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-InstallNerdFontoranyfontsusingthecommandlineinDebianorotherLinux_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리눅스의 Debian 또는 다른 리눅스에서 명령 줄을 사용하여 NerdFont또는 다른 글꼴을 설치해 보세요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">리눅스의 Debian 또는 다른 리눅스에서 명령 줄을 사용하여 NerdFont또는 다른 글꼴을 설치해 보세요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="명령 줄 정복하기 필수 리눅스 CLI 명령어 9가지" href="/post/2024-06-20-ConquertheCommandLine9EssentialLinuxCLICommands"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="명령 줄 정복하기 필수 리눅스 CLI 명령어 9가지" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-ConquertheCommandLine9EssentialLinuxCLICommands_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="명령 줄 정복하기 필수 리눅스 CLI 명령어 9가지" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">명령 줄 정복하기 필수 리눅스 CLI 명령어 9가지</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Docker 컨테이너의 심층 탐구  아키텍처와 기능" href="/post/2024-06-20-DeepDiveintoDockerContainersArchitectureandFeatures"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Docker 컨테이너의 심층 탐구  아키텍처와 기능" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-DeepDiveintoDockerContainersArchitectureandFeatures_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Docker 컨테이너의 심층 탐구  아키텍처와 기능" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Docker 컨테이너의 심층 탐구  아키텍처와 기능</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="유닉스 리눅스 wc 도구 만들기 최종 파트 표준 입력 지원 추가하기" href="/post/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="유닉스 리눅스 wc 도구 만들기 최종 파트 표준 입력 지원 추가하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="유닉스 리눅스 wc 도구 만들기 최종 파트 표준 입력 지원 추가하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">유닉스 리눅스 wc 도구 만들기 최종 파트 표준 입력 지원 추가하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시스템디 systemd를 사용하여 리눅스 서비스 만들기" href="/post/2024-06-20-CreatingaLinuxservicewithsystemd"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시스템디 systemd를 사용하여 리눅스 서비스 만들기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-20-CreatingaLinuxservicewithsystemd_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시스템디 systemd를 사용하여 리눅스 서비스 만들기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">시스템디 systemd를 사용하여 리눅스 서비스 만들기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 20, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/41">41</a><a class="link" href="/posts/42">42</a><a class="link" href="/posts/43">43</a><a class="link" href="/posts/44">44</a><a class="link" href="/posts/45">45</a><a class="link" href="/posts/46">46</a><a class="link" href="/posts/47">47</a><a class="link" href="/posts/48">48</a><a class="link" href="/posts/49">49</a><a class="link" href="/posts/50">50</a><a class="link" href="/posts/51">51</a><a class="link" href="/posts/52">52</a><a class="link" href="/posts/53">53</a><a class="link" href="/posts/54">54</a><a class="link" href="/posts/55">55</a><a class="link" href="/posts/56">56</a><a class="link" href="/posts/57">57</a><a class="link" href="/posts/58">58</a><a class="link posts_-active__YVJEi" href="/posts/59">59</a><a class="link" href="/posts/60">60</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"macOS Sonoma DMG 파일을 구글 드라이브에서 무료 다운로드하세요","description":"","date":"2024-06-20 14:28","slug":"2024-06-20-FreeDownloadmacOSSonomaDMGFilefromGoogleDrive","content":"\n\nmacOS 부팅 가능 USB를 만드는 두 가지 방법이 있습니다. 하나는 애플에서 제공하는 macOS 설치 앱을 사용하는 것인데, 이 앱은 맥 앱 스토어에서 다운로드할 수 있습니다. 주로 작동하는 맥이 있을 때 가장 이상적인 해결책입니다.\n\n다른 방법은 dmg 파일을 사용하는 것입니다. 이 방법은 PC만 있고 macOS 부팅 가능 USB를 만들어야 할 때 유일한 방법입니다. 맥이 부팅되지 않거나 헤킨토시를 구축할 때 권장되는 방법입니다.\n\n# 목차:\n\n- DMG 파일이란 무엇인가요?\n- macOS Sonoma로 업그레이드해야 하는 이유\n- macOS Sonoma의 무료 다운로드 링크\n- 보너스: 윈도우 PC에서 맥 Sonoma 부팅 가능 USB 만드는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 먼저, macOS DMG 파일이 무엇인가요?\n\n간단히 말해서, macOS 설치 .dmg 파일은 Apple의 macOS 운영 체제에서 사용되는 디스크 이미지 파일입니다. .dmg 파일은 가상 CD 또는 DVD로 생각할 수 있습니다. 이를 \"열기\" 또는 \"마운트\"하면 컴퓨터에 실제 디스크를 삽입하는 것과 유사하게 작동합니다.\n\n![macOS DMG File](/assets/img/2024-06-20-FreeDownloadmacOSSonomaDMGFilefromGoogleDrive_0.png)\n\nApp Store에서 macOS를 다운로드하여 OS를 업데이트하거나 다시 설치할 목적으로 사용할 때, 종종 \"Install macOS Sonoma.app\"과 같은 .app 파일로 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![맥 macOS 소노마 DMG 파일을 Google 드라이브에서 무료로 다운로드하세요](/assets/img/2024-06-20-FreeDownloadmacOSSonomaDMGFilefromGoogleDrive_1.png)\n\n맥 macOS 설치 .dmg 파일을 사용하는 일반적인 방법 중 하나는 Windows PC에서 부팅 가능한 설치 파일을 만드는 것입니다. 이 방법은 설치 프로그램을 매번 다시 다운로드하지 않아도 여러 대의 기기에 macOS를 설치하는 데 유용하거나 깨끗한 설치를 수행하는 데 사용할 수 있습니다.\n\n# macOS 소노마로 업그레이드해야 하는 이유\n\n맥 macOS를 소노마로 업그레이드하면 다양한 이점을 제공받을 수 있습니다. 소노마는 맥이 더 부드럽고 빠르게 실행되도록 최적화되고 개선되었습니다. 애플은 때로 기존 하드웨어에서 더 나은 성능을 보장하기 위해 OS의 기본 코드를 개선합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n애플은 macOS 소노마에 여러 가지 새로운 기능을 소개했어요. 이는 새로운 앱, 기존 앱의 기능 개선, 새로운 사용자 인터페이스 디자인 및 기타 사용성 향상을 포함할 수 있어요.\n\n주요한 새로운 기능 이외에도, 업데이트는 이전 버전에서 발생한 버그나 글리치를 수정해 줘요. 현재 버전에서 문제를 겪고 있다면, 업데이트로 문제가 해결될 수 있어요.\n\n또한, macOS의 구 버전은 결국 애플의 공식 지원을 받지 못하게 되어요. 이는 더 이상의 보안 업데이트나 버그 수정을 받지 못한다는 의미에요. 업그레이드를 통해 시스템을 지원 받을 수 있도록 유지할 수 있어요.\n\n## macOS 소노마 DMG 다운로드 링크\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사실, Apple은 각 macOS 버전에 대한 dmg 다운로드 링크를 제공하지 않습니다. 일반적으로 macOS dmg 파일은 소프트웨어 개발자와 기술 애호가들에 의해 생성됩니다. 아래는 신뢰할 수 있는 소스로부터의 Sonoma dmg 다운로드 링크 목록입니다:\n\n## Sonoma 14.0 Stable DMG 다운로드:\n\n## Sonoma Beta 7 DMG 다운로드:\n\n# 보너스: Windows PC에서 맥 Sonoma 부팅 가능 USB 만드는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPC에서 macOS 부팅 가능한 USB를 만드는 것은 OS 아키텍처의 차이로 인해 간단한 작업이 아닙니다. 그러나 UUByte DMG Editor와 같은 타사 도구를 사용하면 이 작업을 간단히 할 수 있습니다.\n\n다음은 UUByte DMG Editor를 사용하여 PC에서 Mac Sonoma 부팅 가능한 USB를 만드는 방법에 대한 단계별 가이드입니다.\n\n# 사전 준비 사항:\n\n- USB 드라이브 (최소 16GB 권장)\n- macOS .dmg 설치 파일\n- PC에 설치된 UUByte DMG Editor 소프트웨어\n- Windows PC\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- UUByte의 공식 웹사이트를 방문하여 DMG Editor를 다운로드하세요.\n\n- 화면 안내에 따라 소프트웨어를 설치하세요.\n\n- USB 드라이브를 컴퓨터에 연결하고 PC에서 UUByte DMG Editor 소프트웨어를 실행하세요.\n\n- 주 화면에서 \"Burn\"과 \"Extract\" 두 가지 옵션이 표시됩니다. 부팅 가능한 USB를 만들려면 \"Burn\" 옵션을 선택하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5. \"찾아보기\" 버튼을 클릭하여 PC에서 macOS Sonoma .dmg 설치 파일을 찾아 선택하세요.\n\n![이미지](/assets/img/2024-06-20-FreeDownloadmacOSSonomaDMGFilefromGoogleDrive_2.png)\n\n6. \"목적지\" 섹션에서 올바른 USB 드라이브가 선택되었는지 확인해주세요. 여러 개의 USB 드라이브나 장치가 연결되어 있는 경우, 데이터 손실을 피하기 위해 올바른 것을 선택해야 합니다.\n\n7. 모든 설정이 완료되면 \"작성\" 버튼을 클릭하여 프로세스를 시작하세요. 소프트웨어가 이제 .dmg 파일에서 파일을 추출하고 USB 드라이브를 부팅 가능하게 만들 것입니다. 이 프로세스는 시간이 걸릴 수 있으니 조급해하지 마세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-20-FreeDownloadmacOSSonomaDMGFilefromGoogleDrive_3.png\" /\u003e\n\n이제 Windows PC를 사용하여 만든 macOS 부팅 가능한 USB가 있습니다. 이 USB 드라이브를 사용하여 Mac 컴퓨터에서 USB 드라이브로 부팅하여 macOS를 설치할 수 있습니다.\n\nUUByte DMG Editor와 같은 도구를 사용하면 PC에서 macOS 부팅 가능한 USB를 만드는 것이 더 쉬워지지만, 항상 정품 macOS 설치 파일을 사용하고 전체 지침을 따라 잠재적인 문제나 데이터 손실을 방지하도록 유의하세요.\n","ogImage":{"url":"/assets/img/2024-06-20-FreeDownloadmacOSSonomaDMGFilefromGoogleDrive_0.png"},"coverImage":"/assets/img/2024-06-20-FreeDownloadmacOSSonomaDMGFilefromGoogleDrive_0.png","tag":["Tech"],"readingTime":4},{"title":"앱 v013가 공식으로 출시되었습니다","description":"","date":"2024-06-20 14:27","slug":"2024-06-20-appv013isOfficiallyReleased","content":"\n\n크로스 플랫폼 패키지 관리 도우미\n\n![이미지](/assets/img/2024-06-20-appv013isOfficiallyReleased_0.png)\n\n작년 크리스마스 때, 나는 워크스테이션, 서버, VM, 도커 컨테이너 및 LXD 컨테이너의 재현 가능한 빌드를 어떻게 만들지 못했는지에 대한 가장 오랫동안 지속된 문제를 해결하기 위해 토끼굴로 들어갔다. 이번에는 Ansible과 같은 시간 낭비 솔루션이나 대량의 NAS 파괴 이미지를 유지하는 것과 같은 번거로운 방법을 사용하지 않고 작업하는 것이다.\n\n이 프로젝트는 나만이 관심을 가질 것으로 생각했던 매우 특수한 것이어야 한다고 생각했지만, 뜻밖의 반응을 받았다. 참여한 사람들은 많지 않았지만, 예상을 뛰어넘는 반응이었다. 프로젝트를 계속 진행할수록 다양한 배경을 가진 사람들로부터 조금씩 더 많은 관심을 받고 있다는 것을 알게 되었다. 또한 실제로 기여하고자 하는 능력과 의지를 가진 개인을 끌어들였다는 점에서 굉장히 운이 좋았다. Richard Frevrier at GOLE TECH님에게 감사 말씀을 전합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한편, 어플리케이션이 크게 발전했습니다. 이제 다음을 지원합니다:\n\n- Linux\n- Mac\n- FreeBSD\n\n그리고 다음 패키지 매니저를 지원합니다:\n\n- apt, 3rd party repos 및 다운로드 된 .deb\n- dnf, 3rd party repos 및 다운로드 된 .rpm\n- pacman\n- yay\n- zypper, 3rd party repos 및 다운로드 된 .rpm\n- pkg\n- Homebrew\n- Flatpak 및 3rd party repos\n- Snap\n- AppImage (사실상 패키지 매니저는 아니지만... 알고 있습니다)\n- go\n- pip\n- cargo\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n죄송합니다, Windows 사용자 여러분들. scoop과 chocolatey로 이동하는 데까지는 시간이 걸릴 수 있습니다. 그러나 그동안 WSL 기차에 타곤 이미 환경 속에서 작동하는 앱은 여러분에게 문제가 없어야 합니다.\n\n리처드와 제퍼슨(내 친한 홈랩 친구) 사이에서 알게 된 사실은 앱을 접근성 있게 하는 것이 처음에 생각했던 것보다 더 중요하다는 것입니다. 결국, 앱을 사용하는 모든 사람이 개발자가 아니며, 아마도 앱을 사용하기 위해 모든 개발 의존성을 설치하고 싶어하지 않을 것입니다. 그래서 기능 해킹에서 잠시 쉬는 게 편안하다고 느낀 순간, 앱을 더 쉽게 설치하고 업데이트할 수 있도록 집중했습니다.\n\n그 결과로 v0.12가 나오게 되었는데, 이 아마추어인 나는 FreeBSD와 macos에서 v0.12 버전에 일부 오류가 있었다는 걸 인지하게 되었습니다. 그래서 그 중대한 문제를 즉시 수정하고 v0.13을 릴리스했습니다.\n\nv0.13에서 일어난 크고 작은 수정 사항 가운데, 아마 가장 주목할 만한 것은 이제 터미널에서 한 줄의 명령으로 앱을 설치할 수 있다는 점입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nbash \u003c(curl -sL https://hkdb.github.io/app/getapp.sh)\n\n\n![2024-06-20-appv013isOfficiallyReleased_1](/assets/img/2024-06-20-appv013isOfficiallyReleased_1.png)\n\n만약 명령어를 잊어버렸다면 걱정하지 마세요! 이제는 터미널에 명령어를 복사하여 붙여넣을 수 있는 빠르고 간편한 랜딩 페이지가 있습니다:\n\n또한 Richard의 제안을 고려하여 사용자가 최신 릴리스로 앱을 업그레이드하는 유일한 작업은 다음 명령어를 실행하는 것뿐입니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n앱 -m 앱 업데이트\n```\n\n\u003cimg src=\"/assets/img/2024-06-20-appv013isOfficiallyReleased_2.png\" /\u003e\n\n이게 너무 쉽다는 게 좋네요. 또한 이 새로운 코드 일부를 재사용하여 저장소에 오랫동안 있던 \"컴파일해서 설치하기\" 스크립트를 다시 만드는 데도 좋은 부가 효과가 있었어요. 현재 기여자와 사용자들 모두가 같은 생각을 가지기를 바랍니다.\n\n이미 app을 시도해 보신 적이 있나요? 생각을 알려주세요!\n","ogImage":{"url":"/assets/img/2024-06-20-appv013isOfficiallyReleased_0.png"},"coverImage":"/assets/img/2024-06-20-appv013isOfficiallyReleased_0.png","tag":["Tech"],"readingTime":3},{"title":"Kube-Ops-View 탐험 Kubernetes 클러스터를 시각화하는 강력한 도구","description":"","date":"2024-06-20 14:26","slug":"2024-06-20-ExploringKube-Ops-ViewAPowerfulToolforVisualizingKubernetesClusters","content":"\n\n쿠버네티스는 컨테이너 오케스트레이션의 사실상 표준이 되었으며, 팀이 애플리케이션을 신속하게 배포, 관리 및 확장할 수 있도록 지원합니다. 그러나 이 강력함에는 복잡성도 따릅니다. 쿠버네티스 클러스터를 모니터링하고 관리하는 것은 특히 플랫폼 엔지니어링 팀에게 어려울 수 있습니다. 이들은 이 클러스터의 건강 상태와 성능을 유지하는 역할을 맡고 있습니다. Kube-Ops-View가 등장합니다. 이 오픈 소스 도구는 쿠버네티스 클러스터의 시각화를 간편하게 만들기 위해 설계되었습니다. 이 기사에서는 Kube-Ops-View의 기능을 살펴보고 시작하는 데 필요한 코드 조각을 제공하며, 몇 가지 현업 사례에 대해 논의할 것입니다.\n\n# Kube-Ops-View란?\n\nKube-Ops-View는 여러 쿠버네티스 클러스터를 위한 읽기 전용 시스템 대시보드입니다. 노드 및 포드 상태, 리소스 이용률, 클러스터 이벤트를 포함한 클러스터 상태를 직관적이고 시각적으로 표현합니다. 이 도구는 특히 쿠버네티스 인프라가 원할하고 효율적으로 작동하는지 확인해야 하는 플랫폼 엔지니어링 팀에게 유용합니다.\n\n# Kube-Ops-View의 주요 기능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 멀티 클러스터 지원: 하나의 대시보드에서 여러 Kubernetes 클러스터를 볼 수 있고 관리할 수 있습니다.\n- 실시간 시각화: 노드 및 포드 상태를 포함한 클러스터 상태의 실시간 업데이트를 확인할 수 있습니다.\n- 자원 활용도: 클러스터 전체에서 CPU 및 메모리 사용량을 모니터링할 수 있습니다.\n- 클러스터 이벤트: 클러스터 내에서 발생하는 이벤트를 추적하여 문제를 신속하게 식별하고 해결하는 데 도움이 됩니다.\n\n# Kube-Ops-View 시작하기\n\nKube-Ops-View를 시작하려면 Kubernetes 클러스터를 구축하고 실행해야 합니다. 다음 단계를 따라 설치 및 설정 과정을 안내해 드리겠습니다.\n\n## 단계 1: 저장소 복제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저 Codeberg에서 Kube-Ops-View 저장소를 복제하세요:\n\n```js\ngit clone https://codeberg.org/hjacobs/kube-ops-view.git\ncd kube-ops-view\n```\n\n## 단계 2: Kube-Ops-View 배포하기\n\n이제 Kube-Ops-View를 Kubernetes 클러스터에 배포해보세요. 제공된 Kubernetes 매니페스트를 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nkubectl apply -f kubernetes/kube-ops-view.yaml\n```\n\n클러스터에 Kube-Ops-View를 배포하고 필요한 서비스와 배포본을 생성합니다.\n\n## 단계 3: 대시보드에 액세스하기\n\n배포가 완료되면 Kube-Ops-View 대시보드에 액세스할 수 있습니다. 기본적으로 클러스터 내에서 서비스로 노출됩니다. 로컬로 액세스하려면 kubectl port-forward를 사용하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nkubectl port-forward svc/kube-ops-view 8080:80\n```\n\n브라우저를 열고 http://localhost:8080 으로 들어가서 대시보드를 확인하세요.\n\n# 플랫폼 엔지니어링 사용 사례\n\nKube-Ops-View는 다양한 시나리오에서 플랫폼 엔지니어링 팀에게 유용한 도구가 될 수 있습니다. 여기에는 몇 가지 사용 사례가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 1. 클러스터 건강 모니터링\n\n플랫폼 엔지니어들은 Kube-Ops-View를 사용하여 Kubernetes 클러스터의 전반적인 건강 상태를 모니터링할 수 있습니다. 노드와 팟 상태의 시각적 표현은 노드 장애나 팟 크래시와 같은 문제를 빠르게 식별하는 데 도움이 됩니다. 이를 통해 신속한 대응과 해결이 가능하며, 애플리케이션의 다운타임을 최소화할 수 있습니다.\n\n## 2. 자원 활용 분석\n\n자원 활용 이해는 Kubernetes 클러스터의 성능을 최적화하는 데 중요합니다. Kube-Ops-View는 노드와 팟 간의 CPU 및 메모리 사용량에 대한 통찰력을 제공하여 플랫폼 엔지니어가 자원 병목 현상을 식별하고 자원 할당을 최적화할 수 있도록 도와줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 3. 이벤트 추적 및 문제 해결\n\nKube-Ops-View의 이벤트 추적 기능을 통해 플랫폼 엔지니어들은 클러스터 내에서 발생하는 이벤트를 확인할 수 있습니다. 이는 문제 해결에 매우 유용합니다. 클러스터 내의 변경 사항 및 사건에 대한 맥락을 제공하여 배포 실패와 같은 문제가 발생했을 때, 구성 오류나 자원 제한과 같은 원인을 파악하는 데 도움이 됩니다.\n\n## 4. 수용량 계획\n\n자원 이용률과 클러스터 상태를 지속적으로 모니터링하여 플랫폼 엔지니어들이 Kube-Ops-View를 활용해 수용량 계획 결정에 참고할 수 있습니다. 이를 통해 인프라가 현재 및 미래의 워크로드를 처리할 수 있도록 보장하고, 자원을 과다하게 할당하지 않아 비용 절감을 이끌어낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 5. 다중 클러스터 관리\n\n여러 개의 Kubernetes 클러스터를 운영하는 조직에 대해, Kube-Ops-View의 다중 클러스터 지원은 매우 중요합니다. 플랫폼 엔지니어들은 단일 대시보드에서 모든 클러스터를 관리하고 모니터링할 수 있어 운영을 간소화하고 다중 클러스터 환경에서 발생하는 복잡성을 줄일 수 있습니다.\n\n# 결론\n\nKube-Ops-View는 Kubernetes 클러스터의 시각화 및 관리를 간소화하는 강력한 도구입니다. 실시간 모니터링 기능과 직관적인 대시보드를 통해 플랫폼 엔지니어 팀에게 우수한 선택지가 됩니다. Kube-Ops-View를 활용함으로써 팀은 Kubernetes 인프라가 건강하고 효율적이며 확장 가능하도록 유지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만일 쿠버네티스 클러스터 관리를 개선하고자 한다면, Kube-Ops-View를 한 번 시도해보세요. 오픈 소스로 제공되는 강력한 기능들은 어떤 플랫폼 엔지니어의 도구상자에 가치 있는 추가물이 될 것입니다.\n\n지금 바로 Kube-Ops-View를 시도하고 쿠버네티스 모니터링을 한 단계 끌어올려보세요!\n\n아래 댓글에서 여러분의 경험을 공유하거나 추가적인 팁을 자유롭게 남기세요.\n\n더 많은 세부 정보 및 프로젝트에 기여하려면, Codeberg의 Kube-Ops-View 저장소를 방문해주세요.","ogImage":{"url":"/assets/img/2024-06-20-ExploringKube-Ops-ViewAPowerfulToolforVisualizingKubernetesClusters_0.png"},"coverImage":"/assets/img/2024-06-20-ExploringKube-Ops-ViewAPowerfulToolforVisualizingKubernetesClusters_0.png","tag":["Tech"],"readingTime":4},{"title":"TailsOS 세상에서 사라지고 싶다면 사용할 운영 체제","description":"","date":"2024-06-20 14:25","slug":"2024-06-20-TailsOSAnOperatingSystemIWouldUseIfIWantedToDisappearFromTheWorld","content":"\n\n에드워드 스노든에 대해서 들어보셨나요?\n\n스노든은 미국 역사상 가장 중요한 고발자 중 하나로 기록될 것입니다.\n\n그는 NSA와 통신 회사 및 유럽 정부들이 협력하여 운영한 광범위한 글로벌 감시 프로그램을 폭로한 사람입니다.\n\n이제 그에 대해 알게 되었으니, 이 모든 기간 동안 인터넷상에서 익명으로 유지하는 방법에 대해 알고 계신가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 그의 말로 번역한 것입니다:\n\n“T\nor \u0026 Tails” — 예!\n\n## TailsOS란 무엇인가요?\n\nTailsOS는 감시와 검열에 대처하는 Debian 기반의 휴대용 운영 체제입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n누구든지 자신의 신원을 숨기고, 검열을 피하며 안전하게 소통하고 싶어하는 사람을 위해 설계되었습니다.\n\n이에는 다음이 포함됩니다:\n\n- 활동가\n- 저널리스트\n- 가정 폭력 생존자\n- 또는 직장이나 일상에서 추가적인 개인 정보 보호를 원하는 모든 사람\n\n# Tails의 장점은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"테일즈는 The 'Amnesic' Incognito Live System의 약자입니다.\n\nUSB 스틱이나 DVD를 사용하여 컴퓨터의 원래 운영 체제와 독립적으로 실행되도록 설계된 운영 체제입니다.\n\n일반적인 운영 체제에서는 수행한 작업들이 컴퓨터에 자취를 남깁니다.\n\n이러한 자취에는 —\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 은익 모드에서 브라우저에서 열린 링크\n- 삭제된 파일\n- 비밀번호 관리자에 저장된 비밀번호\n- 연결된 네트워크\n\n하지만 Tails에는 해당되지 않습니다.\n\n작동 방식은 다음과 같습니다:\n\n- 본인 또는 다른 사람의 컴퓨터를 다시 시작합니다.\n- TailsOS를 포함한 USB 드라이브/ DVD로 컴퓨터를 부팅합니다.\n- 컴퓨터에서 작업을 수행합니다.\n- 작업을 마치고 컴퓨터를 종료하면 트레이스가 전혀 남지 않고 모든 작업이 자동으로 삭제됩니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테일즈는 하드 디스크에 아무것도 쓰지 않고 컴퓨터의 메모리에서만 실행됩니다.\n\n이 메모리는 컴퓨터를 종료할 때 완전히 지워집니다.\n\n하지만 컴퓨터가 꺼진 후에 메모리(RAM)에 있는 데이터는 빠르게 사라지지만 종료 후 몇 분 동안 그대로 남을 수 있다는 사실을 알고 계셨나요?\n\n메모리에 중요한 데이터가 남아 있는 상태에서 공격자가 컴퓨터에 접근한다면 세션에서 중요한 데이터를 복구할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n치명적인 것으로 알려진 것이 있습니다. \n\n테일즈는 이러한 종류의 사이버공격으로부터 당신을 보호합니다. 종료할 때 램 데이터를 임의 데이터로 덮어씌움으로써 이를 방지합니다.\n\n이로써 해당 컴퓨터에서의 세션에 대한 모든 흔적을 지우게 됩니다.\n\n# 인터넷 상에서의 흔적에 대해서는 어떻게 생각하세요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테일즈 OS는 모든 통신에 Tor 네트워크를 사용합니다.\n\nTor는 세계 각지에 위치한 서로 다른 업체가 소유한 3개의 릴레이 서버를 통해 연결을 암호화하고 익명화합니다.\n\n당신이 있는 나라에서 Tor가 차단되거나 사용하기 위험할 때도 Tor 브릿지를 사용하여 Tor 네트워크에 연결되었다는 사실을 숨길 수 있습니다.\n\n# 몇 가지 더 멋진 (그리고 안전한) 기능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 지속적인 저장: 부팅 가능한 USB 스틱에서 파일을 암호화하여 보관하고 싶은 파일이 사라지지 않도록 안전하게 보관할 수 있습니다.\n- Tor 브라우저와 uBlock: 통합 광고 차단 기능으로 안전한 탐색 경험을 제공합니다.\n- Thunderbird: 암호화된 이메일을 보내고 받을 수 있게 합니다.\n- KeePassXC: 강력한 비밀번호 생성 및 저장을 지원합니다.\n- LibreOffice: MS Office와 유사한 포괄적인 오피스 스위트입니다.\n- OnionShare: Tor 네트워크를 통해 파일을 공유할 수 있게 해줍니다.\n- Metadata Cleaner 및 mat2: 공유하거나 저장하는 파일에서 메타데이터를 제거하는 데 도움을 줍니다.\n- Electrum: 사용하기 쉬운 비트코인 클라이언트/지갑입니다.\n- GNOME 스크린 키보드: 온스크린 키보드를 제공하여 키로거로부터 보호합니다.\n- Kleopatra: 인증서 관리자 및 범용 암호화 GUI로 사용됩니다.\n- GtkHash: 파일 무결성 확인을 위한 체크섬 계산을 가능하게 합니다.\n- Aircrack-ng: 무선 네트워크 감사에 사용됩니다.\n- Pidgin 및 OTR: 안전한 통신을 위한 암호화 메시징을 지원합니다.\n\n그리고 그 밖에 많은 기능들이 있습니다!\n\n# 하지만 설치와 사용이 쉬울까요?\n\n네! TailsOS를 설치하고 실행하는 것은 매우 쉽습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n얼마나 쉬웠나요?\n\n![image 0](/assets/img/2024-06-20-TailsOSAnOperatingSystemIWouldUseIfIWantedToDisappearFromTheWorld_0.png)\n\n![image 1](/assets/img/2024-06-20-TailsOSAnOperatingSystemIWouldUseIfIWantedToDisappearFromTheWorld_1.png)\n\nTailsOS 다운로드 페이지를 열고 컴퓨터에서 실행하는 데 20분이 걸렸어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 잘못 될 수 있는 일들\n\n테일즈는 개인정보 보호를 위해 정말 잘 설계되었지만 완벽하지는 않아요.\n\n여전히 익명성이 노출될 수 있어요 만약에:\n\n- 날짜, 시간, 위치 및 장치 정보와 같은 메타데이터가 포함된 파일을 공유한다면.\n- 여러 목적으로 동시에 Tails를 사용하는 경우, 공격자가 당신의 다른 활동을 연관시킬 수 있어요.\n- 사용 중인 Tor 회로에서 세 개의 릴레이를 모두 제어하는 공격자를 만나면, 그들이 당신을 식별할 가능성이 있어요.\n- compromise된 운영 체제에서 Tails를 설치하는 경우, 손상된 설치로 이어질 수 있어요.\n- 기기에 하드웨어 변경이 있는 경우, 당신의 신원을 노출시킬 수 있어요.\n- compromise된 BIOS 또는 펌웨어가 있는 컴퓨터에서 Tails를 실행하는 경우, 보안 침해를 초래할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 내 개인 정보를 보호해주는 휴대용 운영 체제입니다.\n\n만약 여러분도 비슷한 것을 사용 중이라면 댓글로 알려주세요! 여러분이 인터넷에서 개인 정보 보호와 보안을 위해 취하는 다른 조치들도 궁금해요.\n\n![TailsOS](/assets/img/2024-06-20-TailsOSAnOperatingSystemIWouldUseIfIWantedToDisappearFromTheWorld_2.png)\n\n## 아래에서 내 Substack 뉴스레터를 구독하세요:","ogImage":{"url":"/assets/img/2024-06-20-TailsOSAnOperatingSystemIWouldUseIfIWantedToDisappearFromTheWorld_0.png"},"coverImage":"/assets/img/2024-06-20-TailsOSAnOperatingSystemIWouldUseIfIWantedToDisappearFromTheWorld_0.png","tag":["Tech"],"readingTime":4},{"title":"구름을 들어봤어요","description":"","date":"2024-06-20 14:24","slug":"2024-06-20-EverHeardOfTheCloud","content":"\n\n안녕하세요, 클라우드 열정가👋🏼💜\n\n![image](/assets/img/2024-06-20-EverHeardOfTheCloud_0.png)\n\n잠깐만요!\n\n혹시 클라우드 열정가가 아니신가요? 이 글을 우연히 발견하셨거나 왜 이 글을 아직도 읽고 계신지 이해가 안 가시는 분 일 수도 있겠네요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼요 (손을 비벼들며 악의적인 웃음을 짓습니다), 만약 그렇다면, 구름이란 무엇인지 알려드릴게요.😌\n\n당신이 머릿속으로 그리는 것이 바로 “푸른 하늘”, 맞죠?\n\n아닙니다. 전혀 그렇지 않아요.\n\n오늘날의 디지턀 시대에 있어서, 구름이란 하늘의 한 곳뿐만이 아니라, 우리의 삶과 일하는 방식을 혁신하는 강력한 기술입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWhatsApp부터 Instagram, Twitter (죄송해요, X🌚)까지 LinkedIn, Slack, TikTok, Discord...인터넷에 액세스하는 모든 것이 클라우드를 사용합니다.\n\n클라우드는 원격 서버에 비유될 수 있으며 데이터를 저장, 관리 및 처리하여 인터넷 연결만 있다면 어디서든 정보 및 응용프로그램에 쉽게 액세스할 수 있습니다. 심지어 화장실에서도요 (물론 인터넷 연결이 있는 경우).\n\n클라우드를 통해 보다 쉬운 협업, 유연성 및 비용 효율성이 가능해지며, 이로써 전 세계적으로 산업별 혁신을 촉진하고 혜택을 줍니다.\n\n그래서 여러분... 클라우드를 활용한 컴퓨팅의 미래로 여러분을 초대합니다! 🚀","ogImage":{"url":"/assets/img/2024-06-20-EverHeardOfTheCloud_0.png"},"coverImage":"/assets/img/2024-06-20-EverHeardOfTheCloud_0.png","tag":["Tech"],"readingTime":1},{"title":"리눅스의 Debian 또는 다른 리눅스에서 명령 줄을 사용하여 NerdFont또는 다른 글꼴을 설치해 보세요","description":"","date":"2024-06-20 14:23","slug":"2024-06-20-InstallNerdFontoranyfontsusingthecommandlineinDebianorotherLinux","content":"\n\n\n![이미지](/assets/img/2024-06-20-InstallNerdFontoranyfontsusingthecommandlineinDebianorotherLinux_0.png)\n\n요즘 LazyVim을 설치하고 있는데 NerdFonts를 설치해야 해요. 인터넷에서 알아보니 터미널을 사용해서 편하게 설치할 수 있다는 걸 알게 됐어요. 아래는 설치 방법입니다.\n\n- NerdFonts 웹사이트에 들어가서 원하는 글꼴을 다운로드 섹션에서 선택하세요.\n- 다운로드 버튼을 마우스 오른쪽 버튼으로 클릭하고 링크 주소 복사를 선택하세요 (브라우저에 따라 조금 다르지만 글꼴 링크를 얻는 건 중요합니다).\n- 터미널을 열어주세요.\n- 아래 명령어를 복사하신후 방금 복사한 링크로 업데이트해주세요.\n\n```js\nwget -P ~/.local/share/fonts https://github.com/ryanoasis/nerd-fonts/releases/download/v3.0.2/JetBrainsMono.zip \\\n\u0026\u0026 cd ~/.local/share/fonts \\\n\u0026\u0026 unzip JetBrainsMono.zip \\\n\u0026\u0026 rm JetBrainsMono.zip \\\n\u0026\u0026 fc-cache -fv\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그것이에요. 그것은 글꼴을 다운로드하고 설치할 것입니다.\n\n그런 다음, 효과를 보기 위해 LazyVim을 다시로드할 수 있어요.\n\n이 게시물이 유용했기를 바래요. 건배!","ogImage":{"url":"/assets/img/2024-06-20-InstallNerdFontoranyfontsusingthecommandlineinDebianorotherLinux_0.png"},"coverImage":"/assets/img/2024-06-20-InstallNerdFontoranyfontsusingthecommandlineinDebianorotherLinux_0.png","tag":["Tech"],"readingTime":1},{"title":"명령 줄 정복하기 필수 리눅스 CLI 명령어 9가지","description":"","date":"2024-06-20 14:22","slug":"2024-06-20-ConquertheCommandLine9EssentialLinuxCLICommands","content":"\n\n리눅스 명령줄 인터페이스(CLI)는 처음 보는 사람에게는 어렵게 보일 수 있습니다. 암호화된 텍스트와 깜박이는 커서가 기술 마법사들을 위해 예약된 것처럼 보입니다. 그러나 걱정하지 마세요! 이 복잡해 보이는 외부 아래에는 잠재력 가득한 강력한 도구가 숨어 있습니다. 필수 명령어 몇 가지만 습득하면 시스템을 쉽게 탐색하고 파일을 효율적으로 관리하며 작업을 자동화할 수 있습니다. 이 안내서는 여러분을 당혹스러운 초보자에서 숙련된 CLI 닌자로 변몽해주는 20가지 기본 리눅스 CLI 명령어로 여러분을 장비시킵니다.\n\n- pwd: 현재 위치 스카우트\n\n리눅스 시스템의 디렉토리 미로에 잃혀진 적이 있나요? pwd (print working directory)가 신뢰할 수 있는 스카우트처럼 도와줍니다. 이 명령은 즉시 현재 디렉토리의 절대 경로를 표시하여 방대한 파일 시스템 내에서 위치를 명확히 알 수 있게 해줍니다. 예를 들어 다운로드 폴더에서 문서를 작업 중이라고 상상해보세요. 터미널에 pwd를 입력하면 \"/home/사용자명/Downloads\"와 같은 내용이 나타납니다. 디지털 세계에서의 현재 위치가 엿보이는 것이죠.\n\n- cd: 정확히 이동하는 디렉토리 미로\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n복잡한 디렉터리 미로를 탐험하는 것은 cd(디렉터리 변경)로 간단합니다. 이 명령어와 목표 디렉터리 경로를 가지고 있으면 파일 시스템의 계층 구조를 순찰하며 원하는 위치로 정확하게 이동할 수 있습니다. 마치 마법의 순간이동 장치 같은 느낌이죠 – cd Documents를 입력하여 즉시 Documents 폴더로 전환하거나, /usr/local/bin을 입력하여 실행 가능한 프로그램을 포함한 시스템 디렉토리로 이동할 수 있습니다.\n\n- ls: 보물 지도처럼 디렉터리 내용 공개\n\n현재 디렉터리의 내용이 궁금한가요? ls(list)만큼 좋은 대답은 없습니다. 이 다재다능한 명령어는 보물 지도처럼 작용하여 현재 위치에 있는 파일 및 하위 디렉터리 목록을 공개합니다. 홈 디렉터리에서 ls를 입력하면 \"resume.docx\"와 \"Pictures\", \"Music\"과 같은 폴더가 파일 목록을 보여줄 수 있습니다. 그렇게 함으로써 저장된 내용에 대한 빠른 개요를 얻을 수 있습니다.\n\n- mkdir: 새 디렉터리 생성 — 디지털 요새 구축\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파일 시스템의 조직적 경계를 확장하는 것은 mkdir (make directory)를 사용하면 간단합니다. 이 명령어를 사용하면 새 디렉토리를 만들어 파일과 프로젝트를 보관할 구조적인 계층을 만들 수 있습니다. 디지털 요새를 건설하는 것과 같습니다. mkdir projects를 사용하여 작업용 새 폴더를 만든 다음 mkdir projects/webdev를 사용하여 웹 개발 프로젝트를 위한 하위 폴더를 만들어보세요.\n\n- touch: 빈 파일 생성 — 플레이스홀더 마법\n\ntouch를 사용하면 빈 파일을 손쉽게 생성할 수 있습니다. 이 명령어는 디지털 완드와 같이 작동하여 빈 파일을 만들어냅니다. 이 파일들은 미래 콘텐츠를 위한 플레이스홀더로 사용하거나 조직적 목적을 위한 표식으로도 활용할 수 있습니다. 새 프로젝트를 계획 중이지만 아직 콘텐츠가 준비되지 않았다면 touch README.md를 사용하여 아직 내용을 작성하지 않아도 프로젝트 readme를 위한 빈 파일을 만들어보세요.\n\n- cp: 복제 마법 — 파일 복제의 기술\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파일 복제는 cp (복사)로 아주 간단합니다. 이 명령은 복제의 마스터로 파일 또는 전체 디렉토리를 매끄럽게 복제하여 백업, 배포 또는 여러분의 편의를 위해 복사본을 만들 수 있습니다. 다른 채용 지원을 위해 이력서 복사본이 필요하다고 상상해보세요. cp resume.docx backup_resume.docx를 사용하여 다른 이름으로 복제본을 만들어보세요.\n\n- mv: 이름 변경 및 이동 - 두 마리 트릭 포니\n\n파일 이름 바꾸기와 디렉토리 간 이동은 mv (이동/이름 바꾸기)로 아주 간단합니다. 이 다재다능한 명령은 두 마리 트릭 포니처럼 작동하여 파일에 새로운 이름을 부여하거나 파일을 파일 시스템 내에서 더 적합한 위치로 옮길 수 있습니다. \"report_draft.docx\"란 이름의 문서를 작업 중이라면 mv report_draft.docx final_report.docx를 사용하여 이름을 변경하세요. 다른 폴더로 이동해야 한다면 mv final_report.docx /home/username/Documents를 사용하여 이동하세요.\n\n- cat: 파일 내용 공개 - 텍스트 보관소 내부 엿보기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n텍스트 파일 내용을 별도의 편집기를 열지 않고 엿보고 싶나요? cat (concatenate)이 여러분의 동반자가 될 거예요. 이 명령은 열고자 하는 파일의 텍스트 보관고를 열고 해당 내용을 원시 상태 그대로 터미널 화면에 표시해줍니다. important_message.txt라는 파일의 내용을 읽고 싶다면 cat important_message.txt를 사용하세요.\n\n- grep: 텍스트의 심층을 탐험하라 — 텍스트 탐정\n\n파일 내에서 특정 텍스트 단편을 발굴하는 것은 grep(global search for regular expression)를 통해 가능한 강력한 작업입니다. 이 명령은 파일을 한 줄씩 꼼꼼히 살펴가며 지정한 패턴의 인스턴스를 찾아내는데, 당신을 텍스트 탐정으로 변신시켜줍니다. 마치 여러분이 파일을 뒤져가는 듯한 생각이 들지 않나요?","ogImage":{"url":"/assets/img/2024-06-20-ConquertheCommandLine9EssentialLinuxCLICommands_0.png"},"coverImage":"/assets/img/2024-06-20-ConquertheCommandLine9EssentialLinuxCLICommands_0.png","tag":["Tech"],"readingTime":3},{"title":"Docker 컨테이너의 심층 탐구  아키텍처와 기능","description":"","date":"2024-06-20 14:21","slug":"2024-06-20-DeepDiveintoDockerContainersArchitectureandFeatures","content":"\n\n\n![Container Architecture](/assets/img/2024-06-20-DeepDiveintoDockerContainersArchitectureandFeatures_0.png)\n\n# 개요\n\n컨테이너는 코드와 모든 의존성을 포장하여 응용 프로그램이 한 컴퓨팅 환경에서 다른 환경으로 빠르고 신뢰성 있게 실행되도록 하는 표준 소프트웨어 단위입니다. VM과의 주요 차이점은 컨테이너가 자체 완전한 OS를 필요로하지 않는다는 것입니다. 사실, 동일 호스트의 모든 컨테이너는 호스트의 OS를 공유합니다. 이로써 CPU, RAM 및 저장소와 같은 대규모 시스템 리소스가 확보됩니다.\n\n![Container Features](/assets/img/2024-06-20-DeepDiveintoDockerContainersArchitectureandFeatures_1.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n컨테이너는 시작 속도가 빠르고 매우 휴대적입니다. 노트북에서 클라우드로 컨테이너 워크로드를 이동하고, 그리고 VM이나 데이터 센터의 베어 메탈로 이동하는 것도 쉽습니다.\n\n마이크로소프트는 윈도우 플랫폼에 Docker와 컨테이너 기술을 도입하기 위해 매우 노력했습니다. 그러나, 윈도우 컨테이너를 개발하는 데 모든 노력을 기울였지만, 대부분의 컨테이너는 Linux 컨테이너입니다. 이는 Linux 컨테이너가 더 작고 빠르기 때문이며, 대부분의 도구가 Linux용으로 제공되기 때문입니다.\n\n# Docker 기술\n\n대부분의 사람들이 Docker에 대해 이야기할 때, 그들은 컨테이너를 실행하는 기술을 의미합니다. 그러나 Docker 기술이라고 언급할 때 주의해야 할 적어도 세 가지 사항이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 런타임\n- 데몬 (엔진)\n- 오케스트레이터\n\n![Diagram](/assets/img/2024-06-20-DeepDiveintoDockerContainersArchitectureandFeatures_2.png)\n\n이 다이어그램을 살펴보겠습니다:\n\n- 런타임은 가장 낮은 수준에서 작동하며 컨테이너의 시작 및 중지를 담당합니다(이 과정에는 namespaces 및 cgroups와 같은 모든 OS 구성요소를 작성하는 것이 포함됩니다).\n- 하위 수준 런타임은 runc라고 하며 Open Containers Initiative (OCI) 런타임 사양의 참조 구현입니다. 그 역할은 기저 OS와 상호 작용하고 컨테이너를 시작 및 중지하는 것입니다. Docker 노드의 모든 컨테이너는 runc의 인스턴스에 의해 생성되고 시작되었습니다.\n- 상위 수준 런타임은 containerd라고 합니다. 이것은 이미지를 가져오고 runc 인스턴스를 관리하는 등 전체 컨테이너 라이프사이클을 관리합니다.\n- 전형적인 Docker 설치에는 runc에게 컨테이너의 시작 및 중지를 지시하는 단일 장기 프로세스인 containerd 프로세스가 있습니다. runc는 장기 프로세스가 아니며 컨테이너가 시작되자마자 종료됩니다.\n- Docker 데몬 (dockerd)은 containerd 상위에 있으며 Docker API 노출, 이미지 관리, 볼륨 관리, 네트워크 관리 등과 같은 상위 수준 작업을 수행합니다. Docker 데몬의 주요 역할 중 하나는 하위 수준을 추상화하는 사용하기 쉬운 표준 인터페이스를 제공하는 것입니다.\n- Docker는 또한 Docker를 실행하는 노드 클러스터를 관리하기 위한 기본 지원을 제공합니다. 이 클러스터들을 Docker Swarm이라고 하며 해당 기술은 Docker Swarm입니다. Docker Swarm은 사용하기 쉽고 많은 회사가 실제 제품에서 사용하고 있습니다. Kubernetes보다 간단하게 설치하고 관리할 수 있지만, Kubernetes의 고급 기능과 생태계를 많이 포함하지는 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 도커 CLI 명령을 실행할 때 무슨 일이 벌어지나요\n\n도커를 설치하면 두 가지 주요 구성 요소를 얻게 됩니다:\n\n- 도커 클라이언트\n- 도커 엔진 (가끔 \"도커 데몬\"이라고도 함)\n\n엔진은 컨테이너를 실행하는 데 필요한 런타임, API 및 기타 모든 것을 구현합니다. 기본적인 리눅스 설치에서 클라이언트는 /var/run/docker.sock에있는 로컬 IPC/Unix 소켓을 통해 데몬과 통신합니다. 윈도우에서는 npipe:////./pipe/docker_engine을 통해 통신합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"Docker run\"과 같은 명령을 Docker CLI에 입력할 때:\n\n![image](/assets/img/2024-06-20-DeepDiveintoDockerContainersArchitectureandFeatures_3.png)\n\n1. Docker 클라이언트는 이를 적절한 API 데이터로 변환하여 Docker 데몬이 노출한 API 엔드포인트에 POST합니다. API는 데몬에 구현되어 있으며 로컬 소켓(리눅스 및 Windows에 대해 앞서 언급한 것과 같이) 또는 네트워크를 통해 노출될 수 있습니다.\n\n2. 데몬이 새 컨테이너를 생성하는 명령을 받으면, containerd에 요청합니다. 더 이상 데몬에는 컨테이너를 생성하는 코드가 포함되어 있지 않습니다! 데몬은 gRPC를 통해 CRUD 스타일 API를 통해 containerd와 통신합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 이름에서 알 수 있듯이 containerd는 실제로 컨테이너를 만들 수 없어요. 그 작업은 runc가 처리해요. containerd는 필요한 Docker 이미지를 OCI 번들로 변환하고 이를 사용하여 새 컨테이너를 만들도록 runc에 알려줍니다.\n\n4. runc은 OS 커널과 상호작용하여 컨테이너를 만들기 위해 필요한 모든 구성요소(네임스페이스, cgroups 등)를 모아냅니다. 컨테이너 프로세스는 runc의 하위 프로세스로 시작되며 시작되자마자 runc는 종료됩니다.\n\n데몬으로부터 컨테이너 시작 및 관리 로직 및 코드를 모두 제거함으로써 전체 컨테이너 런타임이 Docker 데몬으로부터 분리되었습니다. 때로는 이를 \"데몬 없는 컨테이너\"라고 부르며, Docker 데몬을 유지보수 및 업그레이드할 때 실행 중인 컨테이너에 영향을주지 않도록 합니다.\n\n이전 모델에서는 모든 컨테이너 런타임 로직이 데몬에 구현된 곳에서 데몬을 시작하고 중지하면 호스트의 모든 실행 중인 컨테이너가 제거되었습니다. 이것은 프로덕션 환경에서 큰 문제였어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 네임스페이스, cgroups 및 쉼은 무엇인가요?\n\n**쉼**\n\n위 다이어그램에서 쉼이라는 구성 요소를 주목했을 것입니다.\n\n쉼은 데몬 없는 컨테이너의 구현에 필수적입니다 - 데몬 업그레이드와 같은 작업을 위해 실행 중인 컨테이너와 데몬을 분리하는 것을 방금 언급한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 이전에 containerd가 새로운 컨테이너를 만들 때 runc를 사용한다고 언급했습니다. containerd는 생성되는 각 컨테이너에 대해 runc의 새로운 인스턴스를 포크합니다. 그러나 각 컨테이너가 생성되면 runc 프로세스가 종료됩니다. 이는 수백 개의 컨테이너를 실행할 수 있지만 수백 개의 runc 인스턴스를 실행할 필요가 없다는 것을 의미합니다. 컨테이너의 부모인 runc 프로세스가 종료되면 관련된 containerd-shim 프로세스가 컨테이너의 부모가 됩니다.\n\n컨테이너의 부모인 shim이 수행하는 책임 중 일부는 다음과 같습니다:\n\n- 데몬이 다시 시작되어도 컨테이너가 파이프가 닫히는 등의 이유로 종료되지 않도록 STDIN 및 STDOUT 스트림을 열어두는 것\n- 컨테이너의 종료 상태를 데몬에 다시 보고하는 것.\n\n네임스페이스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n커널 네임스페이스는 컨테이너를 구축하는 데 사용되는 주요 기술입니다. 이 기술은 하이퍼바이저가 물리 자원(예: CPU 및 디스크)을 가상화하는 방식과 같이 운영 체제 구성 요소인 프로세스 트리와 파일 시스템을 가상화합니다.\n\n컨테이너 모델에서 네임스페이스는 가상 프로세스 트리, 가상 파일 시스템 및 가상 네트워크 인터페이스와 같은 것들을 묶어 가상 운영 체제를 생성합니다. 각 가상 운영 체제는 컨테이너라고 불리며 일반적인 운영 체제와 똑같이 보이고 느껴집니다.\n\n이 가상 운영 체제(\"컨테이너\")를 사용하면 동일한 호스트에서 여러 웹 서버를 포트 충돌 없이 실행할 수 있는 멋진 기능을 제공합니다. 또한 동일한 호스트에서 여러 앱을 실행하면서 공유 구성 파일 및 라이브러리 간의 충돌 문제를 피할 수 있습니다.\n\n![image](/assets/img/2024-06-20-DeepDiveintoDockerContainersArchitectureandFeatures_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리눅스의 도커는 현재 다음 커널 네임스페이스를 활용합니다:\n\n- 프로세스 ID (pid)\n- 네트워크 (net)\n- 파일 시스템/마운트 (mnt)\n- 프로세스 간 통신 (ipc)\n- 사용자 (user)\n- UTS (uts)\n\n그러나 가장 중요한 것은 컨테이너가 네임스페이스의 조직화된 모음이라는 점을 이해하는 것입니다. 예를 들어, 각 컨테이너는 자체 pid, net, mnt, ipc, uts 및 아마도 사용자 네임스페이스를 갖습니다. 실제로 이러한 네임스페이스의 조직화된 모음을 우리는 \"컨테이너\"라고 부릅니다.\n\n호스트는 \"루트 네임스페이스\"라고 하는 자체 네임스페이스 모음을 갖고 있습니다. 각 컨테이너에는 격리된 네임스페이스 모음이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-20-DeepDiveintoDockerContainersArchitectureandFeatures_5.png\" /\u003e\n\n지배 그룹 (cgroups)\n\n네임스페이스가 격리에 관한 것이라면, 제어 그룹(cgroups)은 제한에 관한 것입니다. 컨테이너를 호텔의 객실과 유사하다고 생각해보세요. 각각의 객실은 격리되어 있는 것처럼 보일 수 있지만, 모든 객실은 공통의 인프라 자원을 공유합니다. 즉, 수도 공급, 전기 공급, 수영장, 체육관, 엘리베이터, 조식 바와 같은 것들입니다.\n\nCgroups를 사용하면 (호텔 비유를 계속 사용할 때) 단일 컨테이너가 모든 물을 사용하거나 조식 바에서 모든 음식을 다 먹는 것을 막을 수 있습니다. 실제 세계에서 호텔 비유가 아닌 컨테이너는 서로 격리되어 있지만 CPU, RAM, 네트워크 및 디스크 I/O와 같은 공통의 리소스를 공유합니다. Cgroups를 사용하면 단일 컨테이너가 모든 리소스를 소비하고 서비스 거부(DoS) 공격을 유발하지 못하게 제한을 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 보안 계층 개요\n\n모든 좋은 컨테이너 플랫폼은 이름 공간과 cgroups를 사용하여 컨테이너를 구축합니다. 최상의 컨테이너 플랫폼은 기능(Capabilities), SELinux 및 AppArmor와 같은 의무적 접근 제어 시스템, 그리고 seccomp과 같은 다른 리눅스 보안 기술과 통합됩니다. 당연히 Docker도 이러한 기술들과 통합됩니다.\n\n![이미지](/assets/img/2024-06-20-DeepDiveintoDockerContainersArchitectureandFeatures_6.png)\n\n이미 지네임스페이스와 cgroups에 대해 논의했지만, 살펴볼 사항이 더 많습니다. 더 자세히 알아보고 싶다면 제공된 출처를 사용해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n소스: What is a Container? | Docker\nNigel Poulton의 \"Docker Deep Dive\"","ogImage":{"url":"/assets/img/2024-06-20-DeepDiveintoDockerContainersArchitectureandFeatures_0.png"},"coverImage":"/assets/img/2024-06-20-DeepDiveintoDockerContainersArchitectureandFeatures_0.png","tag":["Tech"],"readingTime":6},{"title":"유닉스 리눅스 wc 도구 만들기 최종 파트 표준 입력 지원 추가하기","description":"","date":"2024-06-20 14:20","slug":"2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput_0.png\" /\u003e\n\n지금까지 시리즈의 이전 부분을 읽지 않으셨다면, 먼저 읽어보시는 것을 권장합니다 :)\n\n1. Part I: 이 부분에서는 wccommand의 기본 구성, 파일 크기 계산만을 지원하는 데 중점을 뒀습니다.\n   \n2. Part II: Part II에서는 라인 카운터 플래그를 지원하도록 추가하는 데 중점을 뒀습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. Part III: 이번 글은 최신 글로, 단어 카운터 플래그를 지원하는 데 초점을 맞추었습니다.\n\n이제 현재 목표로 돌아가 봅시다. 이 목표에는 두 단계가 있습니다:\n\n- 기본 옵션을 지원하는 것, 즉 어떤 옵션이 제공되지 않았을 때입니다. 이는 -c, -l 및 -w 옵션과 동등합니다.\n\n```js\ngo run main test.txt\n// 결과: 7145   58164  342190 test.txt\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 입력 파일 이름이 지정되지 않은 경우 표준 입력에서 읽어 들일 수 있는 지원 추가\n\n```js\ncat test.txt | go run main.go -l\n// 결과: 7145\n```\n\n## 1. 기본 옵션 지원\n\n파일 내 라인 수, 단어 수 등을 얻는 서로 다른 로직을 처리하는 함수가 이미 있었습니다. 이 목표를 달성하기 위한 접근 방법은 ProcessFile 함수에 콜백 함수를 전달하여 파일의 바이트 수, 파일 내 라인 수 및 파일 내 단어 수를 얻는 데 책임이 있는 세 가지 함수를 호출하고 그 결과를 출력하는 것이었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nProcessFile(args[0], func(s string) {\n    byteNumber := getByteNumber(\u0026s, nil)\n    lineNumber := getNumberOfLines(\u0026s, nil)\n    wordNumber := countWords(s)\n\n    fmt.Println(byteNumber, lineNumber, wordNumber, s)\n})\n```\n\n## 2. 표준 입력 지원\n\n이 목표를 달성하는 것은 조금 복잡했습니다. 이전 구현에서 빈 플래그를 가져올 수 없는 이유를 알아내려고 몇 시간을 보냈습니다.\n\n다음 코드를 고려해보겠습니다. 이 코드는 파일의 바이트 수를 얻는 데 사용되는 c 플래그를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbyteNumber := flag.String(byteNumberFlag, \"\", \"파일 바이트 수를 얻는 플래그\")\n```\n\n만약 플래그에 어떤 인자도 전달하지 않는다면, 해당 플래그의 기본값을 빈 문자열로 설정했기 때문에 빈 문자열이 반환될 것으로 생각했습니다. 그러나 실제 상황은 다릅니다. 파싱 로직에서, 플래그에 인자가 없는 경우 flag.Parse는 자동으로 도움말 플래그가 있는 경우 해당 플래그를 반환하거나, 2의 종료 상태를 갖는 패닉을 발생시키도록 구현되어 있습니다.\n\n이 문제에 직면하여, 파싱하기 전에 인수에 액세스할 다른 방법을 찾았습니다. 표준 라이브러리인 os의 도움을 통해 예상보다 쉽게 해결했습니다. 접근 방식은 다음과 같습니다:\n\n- 입력 파일을 스캔하고 해당 내용을 반환합니다.\n- 전달된 인수를 가져옵니다.\n- 전달된 인수의 길이를 확인합니다.\n- 길이가 하나인 경우, 다른 플래그와 비교합니다.\n- 각 플래그에 대해 해당 함수를 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```go\n// 명령줄 인수 가져오기\nargs := os.Args[1:]\n\nif len(args) == 1 { // 정확히 하나의 인수가 제공되었는지 확인\n    // 플래그의 \"-\" 문자를 피하기 위해 단일 인수의 마지막 문자를 가져와서 플래그를 결정\n    flag_ := args[0][len(args[0])-1:]\n\n    // 플래그 값에 따라 다른 경우 처리\n    switch flag_ {\n    case byteNumberFlag: // 바이트 수 세는 경우\n        // 표준 입력에서 읽기\n        stdin := handleStandardInput()\n        fmt.Println(getByteNumber(nil, \u0026stdin))\n    case linesCounterFlag: // 줄 수 세는 경우\n        stdin := handleStandardInput()\n        fmt.Println(getNumberOfLines(nil, \u0026stdin))\n    case wordsCounterFlag: // 단어 수 세는 경우\n        stdin := handleStandardInput()\n        wordsSlice := strings.Fields(stdin)\n        fmt.Println(len(wordsSlice))\n    case characterCounterFlag: // 문자 수 세는 경우\n        stdin := handleStandardInput()\n        // 입력의 UTF-8 룬 수 세기\n        runes := utf8.RuneCountInString(stdin)\n        fmt.Println(runes)\n    default: // 파일 처리의 기본 경우\n        ProcessFile(args[0], func(s string) {\n            byteNumber := getByteNumber(\u0026s, nil)\n            lineNumber := getNumberOfLines(\u0026s, nil)\n            wordNumber := countWords(s)\n\n            // 바이트, 줄, 단어 수를 문자열과 함께 출력\n            fmt.Println(byteNumber, lineNumber, wordNumber, s)\n        })\n    }\n    return // 인수 처리 후 종료\n}\n```\n\n참고: 이 마지막 단계를 작동하도록 도우미 함수에 일부 변경을 가했습니다.\n\n읽어주셔서 감사합니다! 다음 도전에 주목해주세요. 이 도전의 전체 소스 코드는 여기에서, 도전 설명은 여기에서 찾을 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput_0.png"},"coverImage":"/assets/img/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput_0.png","tag":["Tech"],"readingTime":4},{"title":"시스템디 systemd를 사용하여 리눅스 서비스 만들기","description":"","date":"2024-06-20 14:19","slug":"2024-06-20-CreatingaLinuxservicewithsystemd","content":"\n\n\n![이미지](/assets/img/2024-06-20-CreatingaLinuxservicewithsystemd_0.png)\n\n웹 애플리케이션을 작성하는 동안, 계산이 많이 드는 작업을 비동기식 작업자 스크립트로 옮기거나 나중에 작업을 예약하거나, 심지어 클라이언트와 직접 통신하기 위해 소켓을 수신하는 데몬을 작성해야 하는 경우가 종종 있습니다.\n\n가끔 더 나은 도구가 있을 수도 있지만—항상 기존 소프트웨어를 먼저 사용하는 것을 고려하십시오—직접 서비스를 작성함으로써 제약사항에 바인딩되어 있을 때 얻을 수 없는 유연성을 얻을 수 있습니다.\n\n멋진 점은 리눅스 서비스를 만들기가 상당히 쉽다는 것입니다: 원하는 프로그래밍 언어로 장기 실행 프로그램을 작성하고, systemd를 사용하여 서비스로 변환하십시오.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로그램\n\nPHP를 사용하여 작은 서버를 만들어 봅시다. 놀라실 거예요, 하지만 상당히 잘 작동합니다. UDP 포트 10000에서 수신 대기하고, 받은 메시지를 ROT13 변환하여 반환할 거에요.\n\n시작해 볼까요?\n\n```js\n$ php server.php\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 다른 터미널에서 테스트해보세요:\n\n```js\n$ nc -u 127.0.0.1 10000\nHello, world!\nUryyb, jbeyq!\n```\n\n와우, 잘 작동하네요. 이제 우리는 이 스크립트가 항상 실행되도록 하고, 실패(예기치 않은 종료)할 경우 다시 시작되며 서버 재부팅 후에도 살아남을 수 있기를 원합니다. 그럴 때 systemd가 필요합니다.\n\n# 서비스로 변경\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n/etc/systemd/system/rot13.service이라는 파일을 만들어보겠습니다:\n\n```js\n[Unit]\nDescription=ROT13 데모 서비스\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=always\nRestartSec=1\nUser=여러분의_사용자이름\nExecStart=/usr/bin/env php /스크립트/경로/server.php\n\n[Install]\nWantedBy=multi-user.target\n```\n\n다음을 수행해야 합니다:\n- User= 뒤에 실제 사용자 이름 설정하기\n- ExecStart=에 스크립트의 적절한 경로 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그게 다에요. 이제 서비스를 시작할 수 있어요:\n\n```js\n$ systemctl start rot13\n```\n\n그리고 부팅 시 자동으로 시작되도록 설정할 수 있어요:\n\n```js\n$ systemctl enable rot13\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 나아가기\n\n이제 서비스가 (아마도) 작동되므로 구성 옵션을 조금 더 심층적으로 탐색하여 항상 예상대로 작동하는지 확인하는 것이 중요할 수 있습니다.\n\n## 올바른 순서로 시작하기\n\nAfter= 지시문이 무엇을 하는 지 궁금해할 수도 있습니다. 이는 단순히 서비스가 네트워크가 준비되자마자 시작되어야 한다는 것을 의미합니다. 만약 프로그램이 MySQL 서버가 가동되고 작동 중인 것을 기대한다면 다음을 추가해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n## 종료 시 재시작\n\n기본적으로 systemd는 프로그램이 어떤 이유로든 종료되면 서비스를 다시 시작하지 않습니다. 일반적으로 항상 사용 가능해야 하는 서비스에 대해 원하는 동작이 아니므로 종료 시 항상 다시 시작하도록 지시합니다:\n\n```js\nRestart=always\n``` \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 마크다운 형식으로 바꿀 수도 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 개인적으로 이 부분에 두 번 이상 빠져들었어요. 기본적으로 우리가 하는 것처럼 Restart=always를 설정하면 systemd가 서비스가 10초 간격 내에 5번 이상 시작하지 못하면 다시 시작하는 것을 포기합니다. 영원히요.\n\n이에 대한 두 가지 [Unit] 구성 옵션이 있어요:\n\n```js\nStartLimitBurst=5\nStartLimitIntervalSec=10\n```\n\n또한 RestartSec 지시문은 결과에 영향을 줍니다: 3초 후에 다시 시작하도록 설정하면 10초 내에 5번의 실패한 재시도에 도달할 수 없어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n항상 작동하는 간단한 해결책은 StartLimitIntervalSec=0로 설정하는 것입니다. 그렇게 하면 systemd가 서비스를 영원히 다시 시작하려고 시도할 것입니다.\n\n그러나 너무 많은 스트레스를 서버에 가하지 않기 위해 RestartSec를 적어도 1초로 설정하는 것이 좋습니다.\n\n대안으로는 기본 설정을 그대로 두고 StartLimitAction=reboot를 사용하여 시작 제한이 도달했을 때 systemd에 서버를 다시 시작하도록 요청할 수 있습니다.\n\n# 정말 그게 다인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요즘에는 RHEL/CentOS, Fedora, Ubuntu, Debian 등에서 systemd가 기본 init 시스템으로 사용되고 있으므로, 아마도 귀하의 서버는 홈브류 서비스를 호스팅할 준비가 되어 있을 겁니다!","ogImage":{"url":"/assets/img/2024-06-20-CreatingaLinuxservicewithsystemd_0.png"},"coverImage":"/assets/img/2024-06-20-CreatingaLinuxservicewithsystemd_0.png","tag":["Tech"],"readingTime":3}],"page":"59","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"59"},"buildId":"kkckKPyxcjJp_o8wb2unW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>