<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/40" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/40" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="맥에서 게임 즐기는 법 Crossover 사용 방법" href="/post/2024-06-22-CrossoverForMacGaming"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="맥에서 게임 즐기는 법 Crossover 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-CrossoverForMacGaming_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="맥에서 게임 즐기는 법 Crossover 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">맥에서 게임 즐기는 법 Crossover 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="클라우드 스토리지 시스템으로 macOS 타임 머신 사용하기 OneDrive 방식" href="/post/2024-06-22-macOSTimeMachineonyourCloudStoragesystemOneDriveforme"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="클라우드 스토리지 시스템으로 macOS 타임 머신 사용하기 OneDrive 방식" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-macOSTimeMachineonyourCloudStoragesystemOneDriveforme_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="클라우드 스토리지 시스템으로 macOS 타임 머신 사용하기 OneDrive 방식" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">클라우드 스토리지 시스템으로 macOS 타임 머신 사용하기 OneDrive 방식</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Swift 6 시대의 새벽 무엇이 달라졌을까" href="/post/2024-06-22-TheDawnoftheSwift6Era"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Swift 6 시대의 새벽 무엇이 달라졌을까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-TheDawnoftheSwift6Era_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Swift 6 시대의 새벽 무엇이 달라졌을까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Swift 6 시대의 새벽 무엇이 달라졌을까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="MacOS에서 Docker로 SQL 서버 설정하는 방법  단계별 가이드" href="/post/2024-06-22-SettingUpSQLServerwithDockeronMacOSAStep-by-StepGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="MacOS에서 Docker로 SQL 서버 설정하는 방법  단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-SettingUpSQLServerwithDockeronMacOSAStep-by-StepGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="MacOS에서 Docker로 SQL 서버 설정하는 방법  단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">MacOS에서 Docker로 SQL 서버 설정하는 방법  단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ChatGPT MacOS 앱 PDF 문서 분석하는 방법 가이드" href="/post/2024-06-22-ChatGPTMacOSAppGuidetoAnalysingPDFDocuments"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ChatGPT MacOS 앱 PDF 문서 분석하는 방법 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ChatGPTMacOSAppGuidetoAnalysingPDFDocuments_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ChatGPT MacOS 앱 PDF 문서 분석하는 방법 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">ChatGPT MacOS 앱 PDF 문서 분석하는 방법 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Stable Diffusion 설치 및 실행 방법 MacOS용" href="/post/2024-06-22-HowtoInstallandRunStableDiffusiononyourMacOS"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Stable Diffusion 설치 및 실행 방법 MacOS용" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowtoInstallandRunStableDiffusiononyourMacOS_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Stable Diffusion 설치 및 실행 방법 MacOS용" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Stable Diffusion 설치 및 실행 방법 MacOS용</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리눅스에서 LVM 사용하여 논리 볼륨 생성 및 확장하는 방법" href="/post/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리눅스에서 LVM 사용하여 논리 볼륨 생성 및 확장하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리눅스에서 LVM 사용하여 논리 볼륨 생성 및 확장하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">리눅스에서 LVM 사용하여 논리 볼륨 생성 및 확장하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="자정에 크론 작업을 절대 예약하면 안 되는 이유" href="/post/2024-06-22-WhyYouShouldNeverScheduleCronJobsExactlyatMidnight"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="자정에 크론 작업을 절대 예약하면 안 되는 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-WhyYouShouldNeverScheduleCronJobsExactlyatMidnight_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="자정에 크론 작업을 절대 예약하면 안 되는 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">자정에 크론 작업을 절대 예약하면 안 되는 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안전한 원격 접속 간소화 리눅스 서버 간 패스워드 없는 SSH 연결 가이드" href="/post/2024-06-22-StreamliningSecureRemoteAccessAGuidetoPasswordlessSSHConnectionsBetweenLinuxServers"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안전한 원격 접속 간소화 리눅스 서버 간 패스워드 없는 SSH 연결 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-StreamliningSecureRemoteAccessAGuidetoPasswordlessSSHConnectionsBetweenLinuxServers_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안전한 원격 접속 간소화 리눅스 서버 간 패스워드 없는 SSH 연결 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">안전한 원격 접속 간소화 리눅스 서버 간 패스워드 없는 SSH 연결 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="방어 무력화 T1562012 Linux 감사 로그 변조 탐지 방법 2부" href="/post/2024-06-22-ImpairDefensesT1562012DetectLinuxAuditLogsTamperingPart2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="방어 무력화 T1562012 Linux 감사 로그 변조 탐지 방법 2부" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ImpairDefensesT1562012DetectLinuxAuditLogsTamperingPart2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="방어 무력화 T1562012 Linux 감사 로그 변조 탐지 방법 2부" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">방어 무력화 T1562012 Linux 감사 로그 변조 탐지 방법 2부</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link posts_-active__YVJEi" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"맥에서 게임 즐기는 법 Crossover 사용 방법","description":"","date":"2024-06-22 16:21","slug":"2024-06-22-CrossoverForMacGaming","content":"\n\n## Crossover을 사용하여 Mac에서 게임하는 방법을 가르쳐 드릴게요\n\n![CrossoverForMacGaming](/assets/img/2024-06-22-CrossoverForMacGaming_0.png)\n\n안녕하세요! 여러분, 맥에서 게임을 즐기기를 기대하고 계신가요? 저는 여러분께 macOS에서 Crossover를 사용하여 게임을 설정하고 플레이하는 방법을 가르쳐 드리겠습니다.\n\n# Crossover이 뭔가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCrossover는 맥 게임을 할 수 있게 도와주는 애플리케이션입니다. 이는 Windows 게임을 Wine 및 Apple 게임 툴킷을 통해 macOS로 변환해 줍니다.\n\n기술적인 내용까지는 심층적으로 알아볼 필요 없어요.\n\n## 어떤 게임을 할 수 있을까요?\n\n우선, Crossover로는 모든 게임을 할 수 있는 것은 아니에요. 여기 Crossover에서 지원하는 게임 목록이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n게임을 플레이하기 전에 해당 게임이 Crossover와 호환되는지 확인해보세요.\n\n![Crossover for Mac Gaming](/assets/img/2024-06-22-CrossoverForMacGaming_1.png)\n\n# Crossover로 작동하는 게임은 부드럽게 작동하나요?\n\n게임이 얼마나 부드럽게 작동하는지는 Mac 구성에 따라 달라집니다. 더 많은 RAM, CPU 및 GPU는 보다 부드러운 게임 경험을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n적어도 16GB RAM, 8개의 CPU 및 10개의 GPU가 필요합니다. 그러면 성능이 꽤 좋게 느껴질 거에요.\n\n제가 사용하는 것은 64GB RAM, 12개의 CPU 및 38개의 GPU입니다. 제 경우에는 게임 성능이 정말 놀라울 만큼 좋아요.\n\n# 설정 방법 및 플레이 방법\n\nMac에서 GTA 5를 플레이하는 방법에 대한 튜토리얼을 아래에 제공하고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 제 지원을 받으시려면 crossover를 구매하실 수 있어요 :)\n\n위의 동영상을 시청한 후에는 어떤 게임이든 설정하고 플레이하는 방법을 배울 수 있어요.\n\n이제 위의 동영상을 보셨겠죠? 그렇다면 다른 지원되는 게임을 다운로드하여 crossover로 플레이하실 수 있어요.\n\n이 이야기를 좋아하신다면 박수를 치시고 제 페이지를 팔로우해주세요 :)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 Mac 게이밍 채널을 운영하고 있어요. 거기서는 다양한 게임들을 Mac에서 테스트해보고 있어요. 그래서 구독도 부탁드릴게요. 만약 여러분이 Mac 게이밍을 더 발전시키고 싶다면요.\n\n# 💰 Mac 게임 기부\n\n- 여러분의 기부로 인해, 저는 Mac에서 다양한 게임을 구매하고 테스트할 수 있어요.\n- 그 후에는 그 게임의 설정 방법을 단계별로 보여주는 YouTube 튜토리얼을 제작할 거에요.\n\n관심이 있으시다면 여기로 기부해주세요.","ogImage":{"url":"/assets/img/2024-06-22-CrossoverForMacGaming_0.png"},"coverImage":"/assets/img/2024-06-22-CrossoverForMacGaming_0.png","tag":["Tech"],"readingTime":2},{"title":"클라우드 스토리지 시스템으로 macOS 타임 머신 사용하기 OneDrive 방식","description":"","date":"2024-06-22 16:19","slug":"2024-06-22-macOSTimeMachineonyourCloudStoragesystemOneDriveforme","content":"\n\n\n![image](/assets/img/2024-06-22-macOSTimeMachineonyourCloudStoragesystemOneDriveforme_0.png)\n\n# TLDR\n\n만약 TimeMachine을 사용하여 맥을 이전 상태로 빠르게 복원하거나, 저장 드라이브가 손상되었거나 기계를 잃었을 때 새로운 맥을 구성하려면 아래 지침을 따르세요. 왜 이것을 하게 되었는지에 관한 전체 이야기는 아래 지침 섹션에서 읽을 수 있습니다.\n\n## 요구 사항\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 원드라이브, 드롭박스, 구글 드라이브, 아이클라우드 등의 macOS 애플리케이션을 가지고 있는 클라우드 스토리지 시스템이 필요합니다. 이 애플리케이션은 로컬 파일을 클라우드로 자동 동기화하고 그 반대도 할 수 있습니다.\n- 해당 클라우드 서비스에 충분한 공간 또는 적절한 구독이 필요합니다.\n\n## 설명\n\n- 맥에서 디스크 유틸리티를 엽니다 (스포트라이트, 런처 또는 선호하는 3rd 파티 도구를 사용하여 '디스크 유틸리티'를 입력합니다).\n- 파일 = 새 이미지 = 빈 이미지를 클릭합니다.\n- 다음에 나열된 순서대로이 새 이미지를 구성합니다:\n\n- 이름 저장 = 원하는 이름으로 저장하세요. 저는 제 이름을 \"타임머신백업\"이라고 지었습니다.\n- 이름 = 이름 저장에 쓴 것과 동일하게 입력합니다.\n- 이미지 형식 = 스파스 번들 디스크 이미지\n- 크기 = 백업 크기의 상한을 고려하여 설정하세요. 제 크기는 300GB로 설정했습니다. 미리 300GB를 예약하지는 않지만 이 값이 상한이 될 것입니다. 나중에 작은 터미널 번거로움으로 크기를 조정할 수 있습니다.\n- 형식 = 기본값인 APFS로 유지합니다.\n- 암호화 = 128비트 AES. 이 선택에 대한 자세한 내용은 아래의 긴 버전 기사에서 확인할 수 있습니다.\n- 파티션 = 기본값인 단일 파티션 — GUID 파티션 맵으로 유지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 새로운 스파스 번들 디스크 이미지를 저장할 위치를 선택하세요. 저는 OneDrive에 저장했습니다. 이 파일을 \"이 장치에 항상 보관\"으로 설정하여 OneDrive와 가장 좋은 경험을 얻을 수 있도록 해야 했습니다.\n\n5. 저장을 클릭하세요.\n\n6. 터미널을 열고 다음 명령을 입력한 후 Enter 키를 누르세요. 암호를 요청받으면 입력하세요:\n\n```js\nsudo tmutil setdestination /Volumes/{마운트된-디스크-이미지}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로 타임 머신을 구성해야 합니다.\n\n- 왼쪽 상단의 Apple 로고로 이동 = 시스템 환경 설정 = 일반 = 타임 머신\n- 마운트된 디스크 이미지와 동일한 이름인 타임 머신 볼륨을 클릭합니다. 제 경우에는 TimeMachineBackups라고 이름이 지어져 있습니다.\n- 백업이 발생하는 빈도를 구성하려면 옵션을 클릭하십시오.\n\n마지막으로, 맥에 로그인할 때마다 이전에 만들었던 .sparsebundle을 자동으로 마운트할 수 있는 스크립트를 빠르게 설정하기 위해 이 가이드를 따라야 합니다. 그렇지 않으면 백업이 없는 상태가 될 수 있습니다:\n\nmacOS에 로그인할 때 암호화된 드라이브(sparsebundle)를 자동으로 마운트하기.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 선택 사항이지만 **강력 추천**\n\n타임머신이 시스템 전체를 백업하여 엄청나게 큰 백업 파일을 만들지 않도록 하려면 우수한 \"제외 목록(Exclusion List)\"을 구성해야 합니다. 그렇지 않으면 맥과 클라우드 스토리지 서비스 양쪽 모두 저장 공간을 두 배 사용하게 될 거에요. 이 작업은 앞서 본 '백업에서 제외' 테이블에 항목을 추가하여 수행합니다.\n\n저의 제외 목록에는 80개 이상의 항목이 포함되어 있습니다. 이 중 일부를 보려면 cmd+shift+.을 눌러야 합니다. 가장 중요한 몇 가지는 다음과 같습니다:\n\n- 게임과 같은 대규모 애플리케이션 전체, Logic Pro X, Final Cut Pro, Xcode 및 나중에 수동으로 쉽게 설치할 수 있는 모든 것.\n- 클라우드 스토리지 파일 전체. 이 파일들을 찾아야 합니다. 제 것은 다음 위치에 있었어요: ~/Library/Group Containers/UBF8T346G9.OneDriveStandaloneSuite 그리고 ~/Library/Cloud Storage\n- ~/Library/Application Support/Steam, ~/Library/Application Support/Blizzard 등의 게임이 저장된 모든 위치.\n- ~/Downloads\n- /bin\n- /Library/Caches\n- ~/Library/Caches\n- /sbin\n- /System\n- /usr\n- /tmp\n- /etc\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 과정을 거친 후, 제 첫 번째 백업 파일 크기는 약 120GB였어요. Time Machine은 매번 새로운 백업을 실행할 때 깃(Git)처럼 첫 번째 백업 위에 변경 사항만 추가하는 똑똑한 기능을 갖고 있어요. 이제 업데이트가 빨라졌고, 내 컴퓨터에 문제가 생겨도 많은 설정, 유틸리티 앱 및 구성을 되찾을 수 있다는 안전함을 느껴요.\n\n이제, 이러한 결정을 내리게 된 이유와 방식에 대한 더 긴 이야기가 이어집니다...\n\n# 김 때문에 Time Machine 백업을 클라우드에 저장하는 이유\n\n## 왜 Time Machine 백업을 클라우드에 저장해야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n나는 맥을 사용하기 시작한 지 얼마 되지 않았는데, 윈도우와 리눅스에서 온 나로써는 작지만 유용한 많은 기능이 누락되었음을 알았어. 그 중에서도 내가 정기적으로 의존하는 기능 중 하나는 화면의 왼쪽 반과 오른쪽 반에 창을 배치하는 기능이다. 맥에 정통한 친구들로부터 작은 응용 프로그램인 Magnet이 그 문제를 해결해 줄 수 있다는 것을 알았어. 나는 즉시 구매하고 문제를 충분히 해결했어. 이후에 내 맥을 최적화하는 방법에 대해 좀 더 탐구하다가 YouTube의 Snazzy Labs 채널을 발견했어. 이 두 영상을 통해 내가 매일 효과적으로 작업하는 데 많은 훌륭한 도구들을 얻을 수 있었어:\n\n아래 비디오 설명의 타임스탬프를 사용하여 터미널 팁으로 건너뛸 수 있어.\n\n유용한 앱 비디오\n\n누구도 나에게 이러한 도구들이나 Snazzy Labs YouTube 채널을 홍보하기 위해 돈을 주지 않았어, 나는 그저 내 경험을 공유하고 싶었을 뿐이야. 나는 이제 Alfred, Bartender, Magnet, Dropzone, Hotkey 등의 작은 맥 유틸리티 애플리케이션들에 의존하고 있어. 나는 또한 새로운 맥으로 이동해야 하거나 내 기기에 문제가 생기는 경우에 다시 그 모든 단계를 거치고 내가 한 사용자 정의사항을 기억해야 하는 것을 원하지 않아.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 나는 클라우드 상의 타임 머신을 탐험하기 시작했어. 이미 Microsoft Office 365 패밀리 구독을 통해 OneDrive에서 1TB를 사용할 수 있었기 때문에, 그게 내가 가진 것이기 때문에 그냥 그것을 사용하기로 했지.\n\n## 온라인 완전한 안내서의 부재\n\n나는 나가야 할 것을 간결하게 구글에 타이핑해서 유용한 안내서에 쉽게 접근하는 것에 익숙하다. 하지만 이번에는 그렇게 되지 않았어. StackOverflow, SuperUser, Quora, Reddit, Apple의 지원 포럼 등에서 정보를 얻고, 이 문제를 해결하는 방법을 보여주는 완전한 안내서를 찾는 대신 조각조각만 얻었어. 그래서 Bing Chat을 사용해 GPT-4와 대화를 시도했지만, 별 도움이 되지 않았어. 그것은 계속해서 동일한 자료로 되돌아오게 하고 별로 도움되지 않는 내용의 짧은 요약을 제공했어. 최근 다른 많은 순간들 중 하나였어, 나는 GPT를 검색 엔진으로 사용하려고 하면 얼마나 어리석었는지 깨달았어. 분명히, 나는 그것을 위한 다양한 실용적인 용도를 찾았지만, 이런 것에는 사용하지 않는다.\n\n그래서 나는 이것을 해결하기 위해 옷소매를 걷어차고 조각조각을 모아 이 문제를 해결해야 한다는 것을 깨달았어. 몇 시간 동안 파헤친 뒤, 결과에 만족하게 되어 이 문제를 해결하는 방법을 여러분에게 보여주기 위해 이 글을 쓰기로 결심했어.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## AES 암호화 토끼굴\n\n이미 알고 계시진 않았나요? 백업할 때는 항상 암호화해야 합니다. 컴퓨터에 어떤 종류의 데이터가 백업 파일로 저장될지 예측하기가 어렵기 때문에 원하는 파일을 명시적으로 포함하는 대신 제외 대상을 처리하는 경우가 많습니다. 미래의 공격자가 여러분이나 백업 파일을 어떻게 공격할지, 그리고 어떤 정보를 찾을지 상상하기는 더 어렵습니다. 개인 정보는 개인만 볼 수 있게 지키세요!\n\n256비트 AES를 사용해 백업할 때 최고의 보안 선택이 될 것으로 생각했지만, 생각보다 속도가 느렸습니다. 벤치마킹이 필요하며, 이에 대해 더 통찰을 가진 다른 사람의 기여를 원합니다.\n\n그 후 128비트 AES 암호화로 'sparse bundle 디스크 이미지'를 다시 만들었습니다. 더 빠르게 실행되었지만, macOS 자체에서 권장하는 것임에도 암호화가 충분히 안전하지 않을까 걱정했습니다. 확인하기 위해 구글링을 시작했고, crypto.stackexchange.com의 Lery가 브루스 슈나이어의 책 \"Applied Cryptography\"를 참조한 멋진 답변을 발견했습니다. 거기서 AES 256비트 키를 무차별 공격해도 더이상 단순한 연산만으로는 해독할 수 없다고 주장합니다. 다이슨 스피어에 대해 알지 못한다면, 즐거운 경험이 될 것입니다... 다이슨 스피어는 태양을 완전히 에워싸고 방출하는 에너지를 100% 캡처하기 위한 태양열 패널로 만들어진 이론적 공간입니다. 즐거운 시간을 보내려면 위키피디아 글을 확인하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요즘은 다이슨 구의를 사용하여 128비트 AES를 무차별 대입해 볼 수도 있을 거에요. 하지만 음... 나는 내 백업을 미래의 과학 소설 수준 문명에게서 보호하는 것을 계획하지 않았어요. 일단은 태양의 에너지를 이용해 나의 키를 얻으려고 할 만큼 오래 잡기 좋아할 필요는 없을 것 같아요.\n\n하지만 개그는 이만하고, 백업 주변의 보안을 꼼꼼히 살피고 128비트 AES가 풀린다면 예전 백업을 삭제하거나 다시 암호화하는 것이 최선일 거에요.\n\n## 제외 목록\n\n이 부분은 꽤 귀찮은 작업이었어요. 수동으로 다양한 캐시, 복구할 필요가 없다고 판단한 애플리케이션 등을 찾아야 했어요. Finder에서 크기별로 파일과 폴더를 정렬하고 주변을 둘러보는 방식으로 이를 수행했답니다. 놓친 몇 가지 흥미로운 시스템 및 숨겨진 파일 및 폴더를 추가해야 한다고 알려준 퀘어 답변도 발견했어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n80개 항목까지 입력한 후, 뭔가 잘못했을 때 쉽게 복구할 수 있도록 목록을 내보낼 방법을 찾기로 결정했어요. 이렇게 하시면 됩니다:\n\n```js\n기본값 읽기 /Library/Preferences/com.apple.TimeMachine SkipPaths\n```\n\n그 방법을 알려준 Gilby에게 감사드려요!\n\n루니 툰즈 엔딩 음악이 들리면서요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그거면 됐어요!","ogImage":{"url":"/assets/img/2024-06-22-macOSTimeMachineonyourCloudStoragesystemOneDriveforme_0.png"},"coverImage":"/assets/img/2024-06-22-macOSTimeMachineonyourCloudStoragesystemOneDriveforme_0.png","tag":["Tech"],"readingTime":6},{"title":"Swift 6 시대의 새벽 무엇이 달라졌을까","description":"","date":"2024-06-22 16:18","slug":"2024-06-22-TheDawnoftheSwift6Era","content":"\n\n![image](/assets/img/2024-06-22-TheDawnoftheSwift6Era_0.png)\n\n1. 소개\n최근 Apple WorldWide Developers Conference(WWDC)에서, 많이 기대되었던 Apple Intelligence 발표에 이어 Apple이 공식적으로 Swift 6.0을 발표했습니다.\n\n2. Swift 개발의 10년\n\n2014년 데뷔 이후, Swift는 놀라운 진전을 이루며 10년을 건너왔습니다. 처음 논란을 빚었지만 현재 인기 있는 프로그래밍 언어 중 하나로 발전한 Swift의 개발 속도는 놀라운 속도로 진행되고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 2015년: Apple이 Swift를 오픈 소스로 공개하고 개발 속도를 가속화했습니다.\n- 2016년: Swift 3 및 Swift Package Manager가 출시되었습니다.\n- 2017년: Swift 4가 출시되었으며 더 큰 견고함과 안정성을 제공했씁니다.\n- 2018년: Swift 4.2가 일반화에서 중요한 발전을 이루었습니다.\n- 2019년: Swift 5.0이 출시되었고, 응용 프로그램 이진 인터페이스(ABI)의 안정한 버전을 도입했습니다.\n- 2020년: Swift 5.3이 출시되었으며, 공식 플랫폼 지원 확장 기능을 Windows 및 기타 Linux 배포판을 포함하여 제공했습니다.\n- 2021년: Swift 5.5가 표준 라이브러리에 Concurrency를 추가했습니다.\n- 2022년: Swift가 분산 액터 기능을 도입했습니다.\n- 2023년: Swift 5.9가 출시되어 C++ 상호 운용성 기능을 지원했습니다.\n\n2.1. 2024년 Swift 6의 새로운 변경 사항\n\nSwift 6에는 다양한 새로운 변경 사항이 포함되어 있습니다. Swift 6의 주요 변경 사항은 다음과 같습니다:\n\n2.1.1 Concurrency Support\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSwift 6는 새로운 기능과 개선사항을 도입하여 동시성 프로그래밍을 더 간단하고 안전하게 만들었습니다. 이러한 변경 사항은 다음과 같습니다:\n\n- 기본값으로 허용된 전체 동시성 확인: 많은 잘못된 양의 레이스 경고를 제거하여 코드 품질을 향상시킵니다.\n- Sendable 개념: 어떤 유형이 동시 환경에서 안전하게 전달될 수 있는지 명확히하며, 동시성 프로그래밍의 어려움을 줄입니다.\n- async/await 메커니즘 및 actor: 비동기 프로그래밍을 지원하여 동시성 프로그래밍을 보다 직관적이고 효율적으로 만듭니다.\n\n![이미지](/assets/img/2024-06-22-TheDawnoftheSwift6Era_1.png)\n\n2.1.2. Typed Throws\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSwift 6에서는 typed throws를 도입하여 개발자가 함수가 던질 수 있는 오류의 종류를 더 명시적으로 지정할 수 있게 되었습니다. 이는 코드의 가독성과 탄탄함을 향상시키며 잠재적인 오류를 줄입니다.\n\n![이미지](/assets/img/2024-06-22-TheDawnoftheSwift6Era_2.png)\n\n2.1.3. 제네릭 제약조건에 대한 새로운 구문\n\nSwift 6.0에서는 제네릭 제약조건에 대한 새로운 구문을 소개하며, `where` 키워드를 사용하여 제네릭 매개변수가 충족해야 하는 조건을 지정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 1](/assets/img/2024-06-22-TheDawnoftheSwift6Era_3.png)\n\n2.1.4. Property Wrappers\n\nSwift 6.0 introduces property wrappers, allowing developers to encapsulate the storage and access logic of properties, enhancing code modularity and reusability.\n\n![Image 2](/assets/img/2024-06-22-TheDawnoftheSwift6Era_4.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2.1.5. 기능 빌더\n\nSwift 6.0에서는 기능 빌더를 소개하여 개발자들이 식의 파싱 및 변환 프로세스를 사용자 정의할 수 있게 하여 더 복잡한 구문 구조를 생성할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-TheDawnoftheSwift6Era_5.png)\n\n2.1.6. 새로운 SwiftUI 뷰 빌더\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSwift 6.0은 SwiftUI를 위한 새로운 뷰 빌더를 도입하여 개발자들이 더 유연하게 사용자 인터페이스를 만들고 관리할 수 있게 했습니다.\n\n![이미지](/assets/img/2024-06-22-TheDawnoftheSwift6Era_6.png)\n\n2.1.7. 기타 중요 변경 사항\n\nSwift 6는 동시성 지원과 타입드 쓰로우에 추가로 다음과 같은 새로운 기능을 도입합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Parameter Pack Iteration: Swift 5.9에서 소개된 매개변수 팩에 대해 반복하는 기능으로 코드의 유연성을 향상시킵니다.\n- Non-Copyable Type Upgrades: 전이 중에 비복사 가능한 유형을 빌릴 수 있도록 하여 비복사 가능한 유형의 사용을 간단화합니다.\n- 128비트 정수 유형: Int128 및 UInt128 유형을 소개하여 특정 시나리오 요구 사항을 충족시킵니다.\n\nSwift 6의 출시는 Swift를 위한 새로운 시대의 시작을 알립니다. 강력한 새로운 기능과 크로스 플랫폼 지원을 통해 Swift는 미래에 주류 프로그래밍 언어가 될 전망입니다.\n\n3. 크로스 플랫폼 지원\n\n3.1. 크로스 플랫폼 개발 전략\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSwift의 프로모션은 애플 플랫폼에만 국한되지 않습니다. 애플은 오픈 소스 커뮤니티와 밀접히 협력하여 Swift를 더 많은 플랫폼과 분야로 확장하려고 노력하고 있습니다. 다음과 같은 것들을 포함합니다:\n\n- 우분투, CentOS, Amazon Linux, 레드햇을 포함한 리눅스 플랫폼에서 Swift 지원\n- 윈도우에서의 Swift 지원 개선으로 더 많은 운영 체제에서 Swift 실행 가능\n\n3.2. 개발자 도구와 생태계 개발\n\n- swift-evolution: 변경 제안을 유지하여 Swift의 지속적인 개선을 보장\n- 공식 VS Code 확장 프로그램: 비주얼 스튜디오 코드에서 Swift 지원을 제공하여 개발자가 윈도우와 기타 플랫폼에서 Swift를 사용하기 쉽게 함\n- Swiftly: 명령줄에서 Swift 툴체인을 관리하여 Rust의 rustup과 유사한 경험을 제공\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. 결론\n\nSwift 6의 출시는 이 프로그래밍 언어의 새로운 시대를 알리는 것뿐만 아니라, Apple의 지속적인 혁신과 프로그래밍 언어 분야에서의 진보도 보여줍니다. Swift 6은 동시성 지원, 타입드 스로우, 일반적인 제약 조건의 새로운 구문, 프로퍼티 래퍼, 함수 빌더, 그리고 새로운 SwiftUI 뷰 빌더 등을 통해 개발자의 프로그래밍 경험과 코드 품질을 크게 향상시켰습니다.\n\n게다가, Swift의 크로스 플랫폼 지원 전략은 어플리케이션 적용 범위를 확장하여, Apple 생태계뿐만 아니라 Linux 및 Windows와 같은 다양한 플랫폼에서도 실행할 수 있도록 합니다. swift-evolution, 공식 VS Code 익스텐션, 그리고 Swiftly 툴체인 관리 도구와 같은 계속 발전하는 개발자 도구 및 생태계 개발과 결합된 이 크로스 플랫폼 기능은 Swift를 미래의 주요 프로그래밍 언어 중 하나로 만들어 줍니다.\n\nSwift 6의 출시를 통해 개발자들에게 더 많은 가능성과 편의를 제공합니다. 강력한 새로운 기능과 광범위한 크로스 플랫폼 지원으로, Swift가 미래 주요 프로그래밍 언어 중 하나로 자리매김할 것으로 기대됩니다. 개발자들은 Swift 6의 도움으로 더 효율적이고 안전하며 혁신적인 애플리케이션을 만들 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5. Codia AI 제품들\nCodia AI는 다중 모달, 이미지 처리, 개발 및 AI 분야에서 풍부한 경험을 갖고 있어요.\n1. Codia AI Figma to code: HTML, CSS, React, Vue, iOS, Android, Flutter, Tailwind, Web, Native,...\n\n![이미지](/assets/img/2024-06-22-TheDawnoftheSwift6Era_7.png)\n\n2. Codia AI DesignGen: 웹사이트, 랜딩 페이지, 블로그를 위한 UI 제작 도구\n\n![이미지](/assets/img/2024-06-22-TheDawnoftheSwift6Era_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. Codia AI Design: 스크린샷을 편집 가능한 Figma 디자인으로 변경\n\n![이미지](/assets/img/2024-06-22-TheDawnoftheSwift6Era_9.png)\n\n4. Codia AI VectorMagic: 이미지를 풀 컬러 벡터/PNG를 SVG로 변환\n\n![이미지](/assets/img/2024-06-22-TheDawnoftheSwift6Era_10.png)","ogImage":{"url":"/assets/img/2024-06-22-TheDawnoftheSwift6Era_0.png"},"coverImage":"/assets/img/2024-06-22-TheDawnoftheSwift6Era_0.png","tag":["Tech"],"readingTime":5},{"title":"MacOS에서 Docker로 SQL 서버 설정하는 방법  단계별 가이드","description":"","date":"2024-06-22 16:17","slug":"2024-06-22-SettingUpSQLServerwithDockeronMacOSAStep-by-StepGuide","content":"\n\n# 단계 1: Docker와 Azure Data Studio 다운로드하기\n\n먼저 docker.com에서 작업 중인 운영 체제와 프로세서에 적합한 Docker 버전을 다운로드하세요. 추가로 이 링크에서 Azure Data Studio를 얻으세요.\n\n# 단계 2: Docker 계정 만들기\n\nDocker를 시작하고 사용자 계정을 만들어 시작하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 3: SQL Server 이미지 다운로드하기\n\n터미널을 열고 다음 명령을 사용하여 SQL Server 이미지를 다운로드하세요:\n\n```js\ndocker pull mcr.microsoft.com/azure-sql-edge\n```\n\n![이미지](/assets/img/2024-06-22-SettingUpSQLServerwithDockeronMacOSAStep-by-StepGuide_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다운로드가 완료되면 확인 메시지가 나타납니다.\n\n# 단계 4: SQL Server 컨테이너 실행\n\n다음 명령어를 사용하여 SQL Server 컨테이너를 시작하세요:\n\n```js\ndocker run -e \"ACCEPT_EULA=1\" -e \"MSSQL_SA_PASSWORD=reallyStrongPwd123\" -e \"MSSQL_PID=Developer\" -e \"MSSQL_USER=SA\" -p 1433:1433 -d --name=sql mcr.microsoft.com/azure-sql-edge\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-SettingUpSQLServerwithDockeronMacOSAStep-by-StepGuide_1.png)\n\n실행 중인 컨테이너를 확인하려면:\n\n```bash\ndocker container ls\n```\n\n이미지 섹션에는 생성된 컨테이너가 표시됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 5: Azure Data Studio와 연결하기\n\nAzure Data Studio를 열고 \"Create a Connection\" 옵션을 사용하여 다음 세부 사항을 입력하세요:\n\n- 서버: localhost\n- 사용자 이름: SA\n- 암호: reallyStrongPwd123\n\n\"Remember Password\" 옵션을 확인하고 \"Connect\"를 클릭하세요. 연결 확인은 왼쪽 상단에 나타날 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 6: 컨테이너 중지\n\n컨테이너를 중지하려면 다음 명령을 실행하세요:\n\n```js\ndocker container stop container_id\n```\n이제 SQL Server가 Docker에서 가동 중이며, Azure Data Studio를 사용하여 연결을 설정할 수 있습니다. 이 지침을 따라 개발 또는 테스트 환경을 빠르게 구축하고 관리할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-SettingUpSQLServerwithDockeronMacOSAStep-by-StepGuide_0.png"},"coverImage":"/assets/img/2024-06-22-SettingUpSQLServerwithDockeronMacOSAStep-by-StepGuide_0.png","tag":["Tech"],"readingTime":2},{"title":"ChatGPT MacOS 앱 PDF 문서 분석하는 방법 가이드","description":"","date":"2024-06-22 16:16","slug":"2024-06-22-ChatGPTMacOSAppGuidetoAnalysingPDFDocuments","content":"\n\n\n![ChatGPT MacOS App Guide](/assets/img/2024-06-22-ChatGPTMacOSAppGuidetoAnalysingPDFDocuments_0.png)\n\n만약 맥 사용자이자 ChatGPT의 팬이라면 기쁜 소식이 있습니다. OpenAI가 MacOS용 ChatGPT 앱을 출시했으며, 이를 통해 컴퓨터에서 AI의 능력을 활용하는 것이 더욱 쉬워졌습니다. 이 앱은 무료 및 유료 사용자 모두에게 제공되며, 여기에서는 특히 PDF 문서를 분석하는 방법에 대해 다운로드, 설치 및 사용 방법을 안내해 드리겠습니다.\n\n# ChatGPT MacOS 앱 시작하기\n\n우선, 시스템이 요구 사항을 충족하는지 확인하십시오. MacOS 14 이상과 Apple 실리콘 칩(M1 이상)이 필요합니다. OpenAI 웹사이트로 이동하여 앱을 다운로드하고, 설치 프로세스는 기타 MacOS 응용 프로그램과 마찬가지로 간단합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 인터페이스 탐색\n\n설치가 완료되면 앱을 열어 사용하기 편리한 인터페이스를 찾을 수 있습니다. ChatGPT 모델을 선택하고 플러스 구독을 등록했다면 플러그인을 통합할 수도 있습니다. 앱에는 음성 명령을 사용하여 ChatGPT와 상호 작용할 수 있도록 마이크 버튼이 포함되어 있습니다.\n\n# PDF 문서 업로드 및 분석\n\nChatGPT MacOS 앱의 한 가지 뛰어난 기능은 PDF 문서를 업로드하고 분석할 수 있는 기능입니다. 아래는 단계별 안내서입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 문서 업로드하기: PDF 문서를 앱으로 끌어 놓기만 하면 됩니다. 이 기능은 학술 및 비학술 목적에 모두 유용한 다양한 문서를 다룰 수 있어요.\n\n2. 문서 분석하기: 업로드 후에 ChatGPT에 요약과 주요 통찰을 제공하도록 요청할 수 있어요. 예를 들어, 저는 제 연구 논문을 업로드하고 요약을 요청했습니다. ChatGPT는 본문의 핵심 포인트와 통찰을 강조한 간결하고 정확한 개요를 제공해 주었어요.\n\n# 전체 튜토리얼 보기\n\n# 실용적인 용도\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n학술 논문 이상으로 다양한 목적으로이 기능을 활용할 수 있습니다. 예를 들어, 식물 사진을 찍어 ChatGPT에게 식물을 식별하고 관리 지침을 제공하도록 요청할 수 있습니다. 이러한 넓은 기능은 이 앱을 일상 업무에 매우 유용하게 만듭니다.\n\n# 마무리의 말\n\nChatGPT MacOS 앱은 ChatGPT의 기능을 직접 컴퓨터로 가져오는 강력한 도구입니다. 학술 논문을 분석하거나 일상적인 질문에 빠른 답변을 찾고 싶을 때 이 앱이 도와줄 것입니다. OpenAI가 계속해서 더 많은 기능을 개발하고 추가함에 따라 잠재적인 사용 영역은 계속 확장될 것입니다.\n\n3시간 웨비나로 학술 성공을 위한 Pro AI 도구 배우기 (참가자들이 사랑하는 웨비나):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://offers.lennartnacke.com/ai-academics-webinar-recording\n\n프로페서 레나트 낙케와 함께 다양한 전략, 전술, 프롬프트 샘플 및 AI 도구의 명확한 사용 사례와 함께 라이브 데모를 다루었습니다.\n\nChatGPT MacOS 앱을 시도해 보셨나요? 댓글에서 사용 경험을 공유해 주세요. 이 기사에 박수를 보내고 최신 기술 도구에 대한 통찰력과 업데이트를 더 받으려면 구독하세요.\n\n읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-22-ChatGPTMacOSAppGuidetoAnalysingPDFDocuments_0.png"},"coverImage":"/assets/img/2024-06-22-ChatGPTMacOSAppGuidetoAnalysingPDFDocuments_0.png","tag":["Tech"],"readingTime":2},{"title":"Stable Diffusion 설치 및 실행 방법 MacOS용","description":"","date":"2024-06-22 16:15","slug":"2024-06-22-HowtoInstallandRunStableDiffusiononyourMacOS","content":"\n\n안녕하세요, 독자 여러분! 저는 AI 및 LLM(언어 모델) 기술의 흥미로운 세계를 안내해 드리는 탈립입니다. 이것은 흥미진진한 여정이며, 제가 여러분과 제 경험과 발견을 공유할 수 있어 정말 기쁩니다.\n\n# 목차\n\n- Stable Diffusion이란 무엇인가요?\n- 맥에 Stable Diffusion 웹 UI 설치하기\n- 맥에서 Stable Diffusion 웹 UI 실행하기\n- 맥에서 Stable Diffusion 웹 UI 종료하기\n- 맥에서 Stable Diffusion 웹 UI 업데이트하기\n\n# Stable Diffusion이란 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안정적인 확산은 Stability AI에서 2022년에 출시된 텍스트-이미지 확산 모델입니다. 이 모델은 이미지에 점진적으로 잡음을 추가하여 완전히 무작위로 만들어지는 확산 과정에 기반을 두고 있습니다. 안정적인 확산은 반대 방향으로 작동하여, 잡음이 많이 섞인 이미지에서 시작하여 점진적으로 잡음을 제거하여 선명한 이미지를 생성합니다.\n\n이 모델은 텍스트와 이미지의 대량 데이터셋으로 훈련되어 있어 텍스트 설명으로 실제적이고 고품질의 이미지를 생성할 수 있습니다. 안정적인 확산은 매우 다재다능하며, 사실적인, 예술적인 및 추상적인 이미지 스타일 등 다양한 이미지 스타일을 생성하는 데 사용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-HowtoInstallandRunStableDiffusiononyourMacOS_0.png)\n\n# 맥에서 안정적인 확산 웹 UI 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 1 — Homebrew 설치하기\n\n- 먼저 터미널 애플리케이션을 열어주세요. 이 앱은 Applications 디렉토리 내의 Utilities 하위폴더에 있습니다. 또는 Spotlight 검색을 이용하여 Command + Space를 눌러 \"터미널\"을 입력해도 됩니다.\n- 터미널을 열었으면, 다음 명령어를 붙여넣어 실행합니다. 이 명령어는 Homebrew 설치 스크립트를 다운로드하고 실행합니다.\n\n```js\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n- 스크립트는 설치를 계속할지 여부를 묻고, Homebrew를 설치하려면 관리자 권한이 필요하므로 비밀번호를 요청합니다. 비밀번호를 입력하고 (입력할 때는 보이지 않습니다) Enter 키를 누릅니다. 설치 과정은 몇 분 정도 소요되며 필요한 파일과 종속성을 다운로드하고 설치합니다.\n- 설치가 완료되면, Homebrew가 성공적으로 설치되었다는 메시지가 표시됩니다.\n- 터미널에서 어느 디렉토리에서든 Homebrew 명령어를 인식하고 사용할 수 있도록 하려면, PATH 환경 변수를 조정해야 합니다. 프롬프트에서 제공된 명령어를 복사하여 붙여넣고 Enter 키를 눌러 환경 변수를 설정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-HowtoInstallandRunStableDiffusiononyourMacOS_1.png\" /\u003e\n\n## 단계 2 — Homebrew를 사용하여 필요한 애플리케이션 설치하기\n\n터미널 앱에서 다음 명령어를 실행하세요:\n\n```js\nbrew install cmake protobuf rust python@3.10 git wget\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n홈브루가 Mac에 다운로드하고 설치할 패키지 목록입니다:\n\n- CMake: CMake은 오픈 소스이며 크로스 플랫폼 빌드 시스템입니다. 이를 통해 소프트웨어 프로젝트의 빌드 프로세스를 관리하는 것이 간편화되며, 플랫폼 독립적인 방법으로 소프트웨어를 구성, 빌드 및 테스트할 수 있습니다.\n- Protocol Buffers (protobuf): Protocol Buffers는 Google에서 개발한 언어에 상관없는 직렬화 포맷입니다. 간단한 언어를 사용하여 데이터 구조를 정의한 다음 다양한 프로그래밍 언어의 코드를 생성할 수 있습니다. 생성된 코드를 통해 효율적으로 직렬화, 역직렬화 및 데이터 조작을 수행할 수 있습니다.\n- Rust: Rust는 메모리 안정성, 동시성 및 성능에 중점을 둔 시스템 프로그래밍 언어로 유명합니다. 운영 체제, 장치 드라이버 및 임베디드 시스템을 포함한 저수준 소프트웨어를 개발하는 신뢰할 수 있고 효율적인 방법을 제공합니다.\n- Python@3.10: 이 패키지는 Homebrew를 사용하여 Python 버전 3.10을 설치합니다. Python은 간결함과 다재다능성으로 유명한 인기 있는 프로그래밍 언어입니다. 이 경우의 특정 버전 번호인 3.10은 시간이 지남에 따라 변경될 수 있으며 필요에 따라 다른 버전으로 대체할 수 있습니다.\n- Git: Git은 다수의 개발자가 프로젝트에서 동시에 작업하고 코드의 다른 버전을 관리하며 변경 사항을 원활하게 병합할 수 있도록 돕는 널리 사용되는 버전 관리 시스템입니다.\n- Wget: Wget은 웹에서 파일을 다운로드하는 명령 줄 유틸리티입니다. HTTP, HTTPS 및 FTP를 포함한 다양한 프로토콜을 지원하며 재귀적 다운로드, 중단된 다운로드 재개, 백그라운드 파일 검색 등의 기능을 제공합니다.\n\n## 단계 3 - 안정적인 확산 웹 UI 설치\n\nMac에서 GitHub 저장소 AUTOMATIC1111/stable-diffusion-webui에서 \"Stable Diffusion Web UI\"를 설치하려면 다음 단계를 따라주십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1. 맥에서 터미널 애플리케이션을 엽니다.\n\n2. 리포지토리를 복제할 디렉토리를 선택하려면 cd 명령을 사용하세요. 예를 들어, 리포지토리를 \"문서\" 폴더에 복제하려는 경우 다음 명령을 실행하십시오:\n\n```js\ncd Documents\n```\n\n3. 이 명령을 실행하면 \"문서\" 디렉토리로 이동합니다. 그러나 리포지토리를 복제할 다른 디렉토리로 경로를 대체할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ngit clone https://github.com/AUTOMATIC1111/stable-diffusion-webui\n```\n\nGit이 복제 작업을 시작하여 저장소를 가져와 현재 디렉토리에 저장할 것입니다.\n\n4. 터미널에서 프로세스를 확인할 수 있습니다. 복제가 완료되면 Mac에 \"Stable Diffusion Web UI\" 저장소의 로컬 복제본이 생성됩니다.\n\n축하합니다! 이제 Mac에 \"stable-diffusion-webui\" 저장소를 복제하였습니다. 내용을 살펴보려면 `cd` 명령을 사용하여 복제된 저장소로 이동하여 필요한 파일 및 폴더에 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 모델 다운로드\n\n- 링크를 클릭하여 안정적인 확산 모델 버전 1.5를 다운로드하세요.\n- 다운로드한 파일을 클론한 GitHub 저장소의 다음 폴더에 넣어주세요.\n\n```js\nstable-diffusion-webui/models/Stable-diffusion\n```\n\n잘 했어요! 이제 Mac에 Stable Diffusion Web UI를 성공적으로 설치하였으며 이미지 생성을 시작할 준비가 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Mac에서 Stable Diffusion Web UI 실행하기\n\n- Mac에서 터미널 애플리케이션을 엽니다.\n- 복제한 저장소가 있는 디렉토리에 액세스하려면 현재 디렉토리를 변경하려면 `cd` 명령을 사용합니다. 예를 들어, \"stable-diffusion-webui\" 폴더로 이동하려면 아래 명령을 실행하세요:\n\n```bash\ncd stable-diffusion-webui\n```\n\n3. 원하는 디렉토리에 들어간 후에는 다음 명령을 실행하여 Stable Diffusion Web UI를 시작합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sh\n./webui.sh\n```\n\n이 명령은 안정적인 확산을 웹 브라우저에서 실행할 수 있는 Python 가상 환경을 설정합니다. 이 가상 환경에 직접 액세스할 수 있는 링크가 터미널 앱에서 제공됩니다.\n\n4. 터미널 앱에서 제공된 URL을 복사하여 웹 브라우저에 붙여넣기합니다. Python은 항상 동일한 URL을 생성하므로 이를 즐겨찾기로 저장할 수 있습니다. 그러나 이 가상 환경이 활성화된 경우에만 기능합니다.\n\n![이미지](/assets/img/2024-06-22-HowtoInstallandRunStableDiffusiononyourMacOS_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 맥에서 Stable Diffusion Web UI 종료\n\nStable Diffusion Web UI를 사용 중인 가상 환경은 단순히 브라우저 창을 닫는 것으로는 종료되지 않습니다. 이를 올바르게 종료하려면 다음 단계를 따라주십시오:\n\n- 맥에서 여전히 열려 있는 터미널 애플리케이션으로 돌아갑니다.\n- 키보드에서 CONTROL + C를 동시에 누릅니다. 이 동작은 가상 환경 세션을 중단시켜 종료할 것입니다.\n\n# 맥에서 Stable Diffusion Web UI 업데이트하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMac에서 Stable Diffusion 웹 UI를 업데이트하려면 GitHub 저장소 AUTOMATIC1111/stable-diffusion-webui에서 최신 변경 사항을 가져오는 다음 단계를 따르세요:\n\n1. Mac에서 Terminal 애플리케이션을 엽니다.\n\n2. 원래 복제된 저장소가 있는 디렉토리로 이동합니다. `cd` 명령을 사용하여 디렉토리를 변경할 수 있습니다. 예를 들어 \"stable-diffusion-webui\" 폴더로 이동하려면 다음 명령을 사용하세요:\n\n```sh\ncd stable-diffusion-webui\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n진행하기 전에 올바른 디렉토리에 있는지 확인해주세요.\n\n3. 원하는 디렉토리에 들어간 후 (이 경우 \"stable-diffusion-webui\"), 다음 명령을 실행하여 최신 변경 사항이 반영된 Stable Diffusion Web UI를 GitHub 저장소에서 업데이트하세요:\n\n```js\ngit pull\n```\n\n이 명령은 Stable Diffusion Web UI의 로컬 사본에 가장 최근 업데이트를 가져와 적용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 맥에서 Stable Diffusion Web UI를 성공적으로 업데이트했습니다. 로컬 사본이 GitHub 리포지토리의 최신 변경 사항과 동기화됩니다.\n\n블로그를 마무리하며, 다음에 어떤 주제를 탐구하고 싶은지 알고 싶습니다. 여러분의 의견은 중요하니 댓글로 의견을 자유롭게 공유해 주세요. 함께해 주셔서 감사합니다. 호기심을 유지하세요!\n\n즐겁게 보내세요!!\n\nLinkedIn에서 연락해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-22-HowtoInstallandRunStableDiffusiononyourMacOS_3.png\" /\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-HowtoInstallandRunStableDiffusiononyourMacOS_4.png\" /\u003e\n\n이 이야기는 Generative AI에서 발행되었습니다. 최신 AI 이야기에 대해 알아가기 위해 LinkedIn에서 저희와 연락을 유지하고 Zeniteq를 팔로우해 주세요.\n\n최신 뉴스 및 Generative AI 업데이트를 받으려면 뉴스레터를 구독해 주세요. 함께 AI의 미래를 함께 만들어 가요!\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![HowtoInstallandRunStableDiffusiononyourMacOS_5.png](/assets/img/2024-06-22-HowtoInstallandRunStableDiffusiononyourMacOS_5.png)\n","ogImage":{"url":"/assets/img/2024-06-22-HowtoInstallandRunStableDiffusiononyourMacOS_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoInstallandRunStableDiffusiononyourMacOS_0.png","tag":["Tech"],"readingTime":7},{"title":"리눅스에서 LVM 사용하여 논리 볼륨 생성 및 확장하는 방법","description":"","date":"2024-06-22 16:12","slug":"2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume","content":"\n\n## XFS 파일 시스템에 LVM 논리 볼륨을 생성하고 확장하는 방법 안내서\n\n![image](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_0.png)\n\n## LVM에 대해 간단히 알아봅시다\n\n논리 볼륨 관리자는 기존의 디스크 관리보다 훨씬 더 효율적인 방식으로 저장소를 다룹니다. 표준 디스크 파티션은 각 디스크의 용량에 기반하여 저장 공간을 할당하지만 LVM은 사용 가능한 모든 물리 하드 드라이브를 하나의 풀의 일부인 것처럼 결합하여 저장 공간을 효율적으로 관리하며 개별적으로 다루는 대신 전체로 사용할 수 있게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가정 해 보겠습니다. 4개의 1TB 드라이브가 있습니다. 전통적인 디스크 체계에서는 개별적으로 처리하지만 LVM을 사용하면 이 4개의 1TB 드라이브가 4TB 단일 청크 또는 집계된 저장 용량으로 간주됩니다. 이를 통해 디스크 레이아웃에 대한 더 큰 유연성과 제어권을 얻을 수 있으며 디스크를 더 쉽게 조작할 수 있습니다. LVM을 사용하는 주요 이점 중 하나는 파일 시스템을 쉽게 확장할 수 있는 능력입니다.\n\nLVM을 이해하고 사용하기 위해서 우리는 세 가지 주요 구성 요소를 이해해야 합니다. 이들은 서로 연결되어 있으며 함께 하나의 논리적 볼륨이라는 것을 만듭니다. 이러한 구성 요소는 다음과 같습니다:\n\n- 물리적 볼륨\n- 볼륨 그룹\n- 논리적 볼륨\n\n물리적 볼륨: 이들은 LVM을 만들기 위해 사용되는 기본 블록입니다. 물리적 볼륨 또는 \"PVs\"는 단순히 물리적 저장 장치인 SSD 또는 HDD 드라이브입니다. 하드 드라이브가 물리적 볼륨로 간주되려면 물리적 볼륨로 초기화되어야 하므로 LVM에서 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVolume Group: 우리는 볼륨 그룹 \"VG\"를 물리적 볼륨으로 구성된 풀로 생각할 수 있습니다. 예를 들어, 1TB SSD 하드 드라이브 세 개가 볼륨 그룹의 일부인 경우, 이 \"VG\"는 총 저장 용량이 3TB로 나타나며, 논리적 볼륨을 생성하는 데 사용됩니다.\n\n논리적 볼륨: 우리의 VG가 생성되면, 마침내 논리적 볼륨을 생성할 수 있습니다. 단일 볼륨 그룹에서 하나 이상의 논리적 볼륨을 생성할 수 있습니다. 논리적 볼륨은 디렉터리에 마운트된 기존 파티션으로 처리되고 사용될 것입니다.\n\n아래 그림은 논리적 볼륨의 구조를 설명합니다:\n\n![논리적 볼륨 구조](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n(특정 예시에서 우리가 사용하는 데모 서버가 구성된대로, 여러 논리 볼륨 및 볼륨 그룹이 있습니다.)\n\n물리 장치인 하드 드라이브로부터 시작해요, 이들은 물리 볼륨 또는 PVs를 만드는 데 사용됩니다. 이 예에서, 우리는 세 개의 별도 HDD가 있으며, 각각은 하나의 물리 볼륨을 만드는 데 사용됩니다. 파티션 /dev/sda2는 첫 번째 PV를 만들고, /dev/sdb1은 두 번째이며 sdc1은 세 번째입니다.\n\n이어서 두 개의 별도 볼륨 그룹이 있고, 각각에는 개별적인 논리 볼륨이 있습니다. 언급한 대로, LVs는 볼륨 그룹에서 잘려 나온 것입니다. 한 VG에서 하나 이상의 논리 볼륨이 올 수 있습니다.\n\n이 추상화에서 최종 계층은 논리 볼륨입니다. 예를 들어, vg-data 볼륨 그룹에서 나온 lv-data가 있습니다. lv-data가 준비되면 포맷하여 마운트 지점으로 사용할 수 있습니다. 이 경우: /dev/vg-data/lv-data.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## LVM 논리 볼륨 만드는 방법:\n\n기존 논리 볼륨을 확장/확장하는 것에 대한 내용을 살펴보기 전에, 이전에 설정되지 않은 시스템에서 처음부터 하나를 만드는 방법을 살펴보고, 그 다음 섹션에서 확장하는 방법을 살펴보겠습니다. 이미 존재하는 LV를 확장하고 싶다면, 이 섹션을 건너뛰시면 됩니다.\n\n새로운 논리 볼륨을 설정하려면 다음 순서대로 진행해야 합니다:\n\n- 기존 하드 드라이브에서 물리 볼륨을 생성합니다.\n- 볼륨 그룹을 생성하고 물리 볼륨을 추가합니다.\n- 볼륨 그룹에서 논리 볼륨을 생성합니다.\n- 필요에 따라 논리 볼륨을 포맷합니다 — xfs, ext4 등.\n- 마지막으로 새 파일 시스템을 마운트합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n— 물리 볼륨을 생성하려면 디스크 공간을 사용할 수 있어야 합니다. 이 서버(가상 머신)에서는 논리 볼륨 생성 데모에 사용할 두 개의 별도의 원시 하드 드라이브가 있습니다.\n\n![이미지](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_2.png)\n\n/dev/sdb 및 /dev/sdc 두 개의 원시 디스크가 있는 것을 확인할 수 있습니다. 아직 사용할 수 없으므로 이를 포맷해야 합니다.\n\n이 새 디스크 /dev/sdb를 사용할 수 있게 하는 방법을 빠르게 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*XLof11Om75NHy4PY2-2S2Q.gif)\n\n저희가 한 몇가지에 대해 몇 가지 소식을 전합니다:\n\n- 새로운 드라이브 /dev/sdb를 사용할 수 있도록 새로운 파티션을 생성하고 적절한 레이블을 할당함으로써 진행되고 있습니다.\n- 이 파티션의 특정 크기를 지정하지 않았지만, 기본값을 선택하여 전체 디스크를 사용할 수 있습니다. 크기를 지정하지 않고 엔터를 누르면 사용 가능한 전체 공간이 할당됩니다.\n- 여기서 중요한 부분은 이 새로운 파티션을 레이블링하여 LVM 유형으로 지정하는 “8e” 16진수 코드를 선택하는 것입니다. ext4 파티션을 만들고자 한다면 레이블 코드가 다를 것입니다. 새로운 파티션을 만들 때, 사용하기 전에 레이블링해야 합니다.\n- 우리가 한 변경 사항을 저장하기 위해 “w”를 입력해야 합니다.\n\n이제 디스크가 준비되었으니, pvcreate로 물리적 볼륨을 생성하는 것부터 시작해보겠습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n피지컬 볼륨이 성공적으로 생성되었습니다! 이제 pvdisplay를 사용하여 PV가 만들어졌는지 확인해봅시다 (pvs도 사용할 수 있습니다):\n\n\n[itadmin@localhost ~]$ sudo pvdisplay\n[sudo] password for itadmin:\n  --- Physical volume ---\n  PV Name               /dev/sda2\n  VG Name               centos\n  PV Size               \u003c19.00 GiB / not usable 3.00 MiB\n  Allocatable           yes (but full)\n  PE Size               4.00 MiB\n  Total PE              4863\n  Free PE               0\n  Allocated PE          4863\n  PV UUID               sa3xFR-jbDb-SKuS-yQN1-VzzW-bveG-aA0yha\n\"/dev/sdb1\"은 \"\u003c30.00 GiB\"의 새로운 피지컬 볼륨입니다\n  --- NEW Physical volume ---\n  PV Name               /dev/sdb1\n  VG Name\n  PV Size               \u003c30.00 GiB\n  Allocatable           NO\n  PE Size               0\n  Total PE              0\n  Free PE               0\n  Allocated PE          0\n  PV UUID               Q54fqC-Np3X-XUaF-j5vE-Px29-pT9H-JYsDUh\n[itadmin@localhost ~]$\n\n\n이미 /dev/sda2에 PV가 있습니다. 이는 루트 파티션도 논리 볼륨 위에 구축되어 있음을 의미합니다. 새로운 디스크 /dev/sdb1은 이제 피지컬 볼륨입니다. 이 새로운 피지컬 볼륨의 VG 이름이 비어있는 것을 알 수 있습니다! 이는 이제까지 볼륨 그룹에 추가되지 않았기 때문입니다! 이를 바로 해결해봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n[itadmin@localhost ~]$ sudo vgcreate vg-data /dev/sdb1\n  Volume group \"vg-data\" successfully created\n[itadmin@localhost ~]$\n```\n\n- 새 볼륨 그룹을 만들 때 vgcreate를 사용하며, 새 볼륨 그룹에 이름을 할당하고 물리 볼륨 또는 볼륨을 추가합니다. 이 경우에는 /dev/sdb1을 이 VG의 일부로 만듭니다.\n\n새로 만든 볼륨 그룹을 확인해봅시다:\n\n```bash\n[itadmin@localhost ~]$ sudo vgs\n  VG      #PV #LV #SN Attr   VSize   VFree\n  centos    1   2   0 wz--n- \u003c19.00g      0\n  vg-data   1   0   0 wz--n- \u003c30.00g \u003c30.00g\n[itadmin@localhost ~]$\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- vg-data은 실제로 존재하며 30GB의 여유 공간이 있어요 — 이는 이전에 추가한 물리 볼륨(새로운 파티션)의 크기입니다.\n\n이제 lvcreate을 사용하여 논리 볼륨을 생성합니다:\n\n```bash\n[itadmin@localhost ~]$ sudo lvcreate --name lv-data -l 100%FREE vg-data\n논리 볼륨 \"lv-data\"이(가) 생성되었습니다.\n[itadmin@localhost ~]$\n```\n\n- -l : 우리가 볼륨 그룹에서 얼마의 공간을 사용할지를 지정하는 데 사용됩니다. 여기서는 해당 그룹의 100%를 할당합니다. 명령어에 볼륨 그룹 이름을 명시해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 Logical Volume을 lvdisplay로 확인하고 있어요:\n\n![LV](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_3.png)\n\n우리의 Logical Volume이 성공적으로 생성되었어요!\n\n이제 사용할 수 있도록 이 논리적 볼륨을 포맷해야 해요. 새로운 LV를 포맷하는 방법은 mkfs.xfs 명령을 사용하는 거에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n[itadmin@localhost ~]$ sudo mkfs.xfs /dev/vg-data/lv-data\n[sudo] itadmin 님의 암호:\nmeta-data=/dev/vg-data/lv-data   isize=512    agcount=4, agsize=1965824 블록\n         =                       sectsz=512   attr=2, projid32bit=1\n         =                       crc=1        finobt=0, sparse=0\ndata     =                       bsize=4096   블록=7863296, imaxpct=25\n         =                       sunit=0      swidth=0 블록\nnaming   =version 2              bsize=4096   ascii-ci=0 ftype=1\nlog      =internal log           bsize=4096   블록=3839, version=2\n         =                       sectsz=512   sunit=0 blks, lazy-count=1\nrealtime =none                   extsz=4096   블록=0, rtextents=0\n[itadmin@localhost ~]$\n```\n\n.mkfs는 \"파일 시스템 생성\"을 의미하며, 이를 수행합니다. 이 경우에는 xfs 파일 시스템을 생성하려고 하므로 mkfs.xfs를 사용합니다. xfs 파일 시스템은 여러 측면에서 ext4보다 업그레이드된 것이며 RHEL 서버에서 기본 파일 시스템입니다. 그럼에도 불구하고 상황에 따라 ext4를 사용하는 것이 xfs보다 우위를 가질 수 있습니다.\n\n새로 생성된 논리 볼륨을 마운트하려면 해당 마운트 포인트를 만들고 다음 단계를 수행합니다:\n\n```bash\n[itadmin@localhost ~]$ sudo mkdir /data\n[itadmin@localhost ~]$ sudo mount /dev/vg-data/lv-data /data\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 새 파일 시스템이 마운트될 새로운 디렉토리를 생성했어요. /data 하위에 있는 모든 것들은 이 새 논리 볼륨에 속합니다.\n\n— 부가적인 사항으로 — 새로운 마운트 포인트를 /etc/fstab 파일에 추가해야 부팅 중에도 지속되도록 해야 해요.\n\n새롭게 마운트된 /data 디렉토리를 df 명령어로 살펴봅시다:\n\n![이미지](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 파일 시스템이 실제로 XFS인지 확인해야 하기 때문에 df 명령에 \"T\" 스위치가 필요합니다. 이 스위치는 파일 시스템 유형을 보여주는 데 사용됩니다.\n- 우리의 논리 볼륨 lv-data는 모두 준비되어 있고 /data에 마운트되어 있습니다!\n\n작업이 완료되었습니다!\n\n## 논리 볼륨 확장 방법\n\n우리는 처음부터 논리 볼륨을 만드는 방법을 보았지만, 대부분의 경우 이미 존재하는 논리 볼륨의 크기를 늘려야 하므로 더 많은 데이터를 수용할 수 있게 할 필요가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_5.png)\n\n- 우리는 Volume Group vg-data에 사용 가능한 빈 공간이 없음을 확인할 수 있습니다. 새 물리 볼륨을 추가해 보겠습니다.\n\n먼저, 이 새 드라이브를 사용할 수 있도록 새 파티션을 만들고 \"LVM\" 레이블을 할당해야 합니다. 이를 위해 아래와 같이 fdisk를 사용하여 수행합니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*qB2R3x5Zc2Lt46xIq-bEFQ.gif)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- fdisk를 사용하여 새 파티션을 만들고, 크기를 지정하지 않은 전체 크기를 할당했어요 (값을 지정하지 않고 Enter를 누르면 사용 가능한 크기를 할당합니다).\n- 정확한 라벨을 지정해야 해요, \"LVM 타입\"으로 만들기 위해 필요한 라벨은 8e에요.\n\n디스크가 준비되었고, 이제 물리 볼륨을 생성할 수 있어요:\n\n```js\n[root@localhost ~]$ pvcreate /dev/sdc1\n  Physical volume \"/dev/sdc1\" successfully created.\n[root@localhost ~]$\n```\n\n생성 완료! 이제 vg-data 볼륨 그룹에 추가하려면, vgextend 명령어를 사용해요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n[root@localhost ~]$ vgextend vg-data /dev/sdc1\n  Volume group \"vg-data\" successfully extended\n[root@localhost ~]$\n```\n\nVG가 확장되었습니다! 한 번 더 확인해 봐요:\n\n![이미지](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_6.png)\n\n훌륭해요! 이제 vg-data에 25GB의 여유 공간이 있는 것을 확인할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 Logical Volume에 뛰어들어 보겠습니다. 지금 상태는 다음과 같습니다:\n\n![Logical Volume Status](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_7.png)\n\n우리는 lvextend 명령어로 lv-data Logical Volume을 확장했습니다:\n\n```js\n[root@localhost ~]$ lvextend -l +100%FREE /dev/vg-data/lv-data\n  Size of logical volume vg-data/lv-data changed from \u003c30.00 GiB (7679 extents) to 54.99 GiB (14078 extents).\n  Logical volume vg-data/lv-data successfully resized.\n[root@localhost ~]$\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- lvextend 명령은 lv-data 논리 볼륨을 확장하며, +100%FREE 옵션은 해당 볼륨을 볼륨 그룹에서 남아있는 모든 가능한 크기로 확장합니다.\n- 만약 우리가 논리 볼륨을 특정 크기로 확장하고 싶었다면, 예를 들어 5GB로 확장하고 싶다면 다음과 같이 진행할 것입니다:\n\n```js\n[root@localhost ~]$ lvextend -L +5G /dev/vg-data/lv-data\n```\n\n이제 우리의 논리 볼륨 상태를 확인해봅시다:\n\n![논리 볼륨 상태](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n출력을 통해 LSize가 실제로 증가했고, 논리 볼륨이 확장되었습니다!\n\n아직 끝나지 않았어요! 마지막 단계는 새로 추가된 저장 용량을 사용할 수 있도록 파일 시스템의 크기를 조정하는 것입니다. 이 작업은 xfs_growfs 명령으로 수행할 수 있어요:\n\n```js\n[root@localhost ~]$ xfs_growfs /dev/vg-data/lv-data\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*yu72eMpz12FUdIOTeL0qgg.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터 블록이 변경되고 파일 시스템이 확장되었음을 알 수 있습니다.\n- 여기서 언급해야 할 또 다른 훌륭한 점은 파일 시스템을 확장할 때 마운트 포인트인 /data를 해제할 필요가 없었다는 것입니다!\n\ndf -kh 명령의 출력에서 /data 마운트 포인트가 확장되었음을 확인할 수 있습니다. 여기에는 lv-data 논리 볼륨이 마운트된 곳입니다:\n\n![Image](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_9.png)\n\n모두 완료되었습니다. 논리 볼륨이 성공적으로 확장되었습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글은 Linux에서 논리 볼륨 매니저에 대해 간략히 다룬 내용이었습니다. 논리 볼륨을 생성하고 확장하는 방법에 대해 설명했습니다. 궁금한 점이나 의견, 추가할 내용이 있으면 자유롭게 남겨주세요.\n\n읽어주셔서 감사합니다! 다음 포스트에서 만나요 :)","ogImage":{"url":"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_0.png"},"coverImage":"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_0.png","tag":["Tech"],"readingTime":10},{"title":"자정에 크론 작업을 절대 예약하면 안 되는 이유","description":"","date":"2024-06-22 16:11","slug":"2024-06-22-WhyYouShouldNeverScheduleCronJobsExactlyatMidnight","content":"\n\n제 개발자로서, 제가 직접 체험한 바에 의하면 새벽 정각에(0 0 * * *) cron 작업을 예약하는 것이 일으킬 수 있는 혼란에 대해 알고 있습니다. 왜 그렇게 하는 것이 좋지 않은지, 그리고 보다 효과적으로 cron 작업을 예약하는 방법에 대한 팁을 소개하겠습니다.\n\n![Why You Should Never Schedule Cron Jobs Exactly at Midnight](/assets/img/2024-06-22-WhyYouShouldNeverScheduleCronJobsExactlyatMidnight_0.png)\n\n새벽의 신비\n\n이전 직무 중 하나에서, 우리 팀은 심각한 시스템 업데이트를 밤 12시에 예약했을 때 수수께끼 같은 문제에 직면했습니다. 작업이 무작위로 실패하고 시스템이 크게 느려져 서비스 중단을 야기했습니다. 수없이 많은 디버깅 시간 끝에, 우리는 여러 작업이 밤 12시에 실행되도록 설정되어 있음을 발견했습니다. 동시에 발생한 부하로 리소스 충돌과 예측할 수 없는 동작이 발생하여 근본 원인을 식별하는 데 매우 어려워졌습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 배운 교훈\n\n## 크론 작업 예약을 위한 최상의 실천 방법\n\n1. 일정 시간을 무작위로 설정: 작업을 동시에 설정하는 대신 무작위 시간을 사용하여 부하를 분산시킵니다. 이렇게 하면 사용량이 많은 시기를 피할 수 있고 충돌 가능성을 줄일 수 있습니다.\n\n2. 지수 백오프 및 지터 사용: 지수 백오프와 지터를 사용하여 재시도를 구현하면 크론 작업이 능률적으로 수행될 수 있습니다. Marc Brooker의 AWS에서 제공하는 멋진 '지수 백오프와 지터' 아티클을 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-WhyYouShouldNeverScheduleCronJobsExactlyatMidnight_1.png)\n\n3. 라이브러리 활용: 파이썬을 사용한다면, Tenacity 라이브러리를 사용하여 백오프와 지터 지연을 가진 재시도를 고려해보세요. 이는 프로세스를 간단화하고 크론 작업을 더욱 강화할 수 있습니다.\n\n# 주기적인 작업을 더 견고하게 만들기\n\n크론 작업은 작업을 자동화하는 데 좋지만 부적절한 예약은 큰 문제를 일으킬 수 있습니다. 자정 예약을 피하고 이러한 팁을 따른다면 더욱 신뢰성이 높고 효율적인 작업 실행을 보장할 수 있습니다. 기억하세요, 약간의 무작위성은 \"0 0 * * *\"의 함정을 피하는 데 큰 도움이 됩니다.\n","ogImage":{"url":"/assets/img/2024-06-22-WhyYouShouldNeverScheduleCronJobsExactlyatMidnight_0.png"},"coverImage":"/assets/img/2024-06-22-WhyYouShouldNeverScheduleCronJobsExactlyatMidnight_0.png","tag":["Tech"],"readingTime":2},{"title":"안전한 원격 접속 간소화 리눅스 서버 간 패스워드 없는 SSH 연결 가이드","description":"","date":"2024-06-22 16:10","slug":"2024-06-22-StreamliningSecureRemoteAccessAGuidetoPasswordlessSSHConnectionsBetweenLinuxServers","content":"\n\n---markdown\n![SSH Connection](/assets/img/2024-06-22-StreamliningSecureRemoteAccessAGuidetoPasswordlessSSHConnectionsBetweenLinuxServers_0.png)\n\n두 대의 Linux 서버 간에 비밀번호 없는 SSH 연결을 설정하는 것은 안전한 원격 액세스를 간편하게하는 일반적인 방법입니다. 본 자습서는 비밀번호 없는 SSH 인증을 설정하는 단계를 안내하며, 연결이 예상대로 작동하지 않을 경우 해결 방법을 제공합니다.\n\n# 전제 조건\n\n- 두 대의 Linux 서버 (서버 A 및 서버 B)\n- 두 서버 모두에 대한 관리 액세스\n---\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 1: 서버 A에서 SSH 키 쌍 생성하기\n\n- SSH 또는 물리적으로 서버 A에 로그인합니다.\n- 터미널 창을 엽니다.\n- 다음 명령을 실행하여 SSH 키 쌍을 생성합니다:\n\n```js\nssh-keygen -t rsa\n```\n\n키 쌍의 기본 위치를 사용하려면 Enter를 누르시고, 인증을 위해 암호를 비워둘 경우 비밀번호 없는 인증을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4. Enter 키를 눌러 키 생성을 확인해주세요.\n\n5. 이 작업은 ~/.ssh/ 디렉토리에 개인 키 (id_rsa) 및 공개 키 (id_rsa.pub)를 생성합니다.\n\n## 단계 2: 공개 키를 서버 B로 복사\n\n- ssh-copy-id 명령어를 사용하여 공개 키를 서버 B로 복사하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nssh-copy-id user@serverB_IP\n```\n\n- 사용자를 서버 B의 사용자 이름으로, serverB_IP를 서버 B의 IP 주소 또는 호스트 이름으로 바꿔주세요.\n- 서버 B의 사용자 계정 암호를 입력하라는 메시지가 표시됩니다.\n- 공개 키를 성공적으로 복사한 후, 키가 추가되었음을 확인하는 메시지가 표시됩니다.\n\n# 단계 3: 무비밀번호 연결 테스트\n\n서버 A에서 서버 B로 SSH 연결을 시도해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nssh user@serverB_IP\n```\n\n이제 암호를 묻지 않고 서버 B에 액세스할 수 있어야 합니다.\n\n# 문제 해결 팁\n\n암호없는 연결이 작동하지 않는 경우, 다음 문제 해결 단계를 따라주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 권한 확인: Server A 및 Server B의 .ssh 디렉토리가 올바른 권한을 가지고 있는지 확인해주세요. 사용자의 소유이어야 하며 제한된 권한을 가져야 합니다:\n\n```js\nchmod 700 ~/.ssh \nchmod 600 ~/.ssh/authorized_keys\n```\n\n- 키 파일 이름: 기본 키 이름(id_rsa 및 id_rsa.pub) 또는 키 생성 중에 지정한 이름을 사용하는지 확인하세요.\n- SSH 에이전트: Server A에서 프라이빗 키를 SSH 에이전트에 추가했는지 확인해주세요. 다음 명령을 사용하여 추가할 수 있습니다:\n\n```js\nssh-add ~/.ssh/id_rsa\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 방화벽 및 SELinux: 각 서버의 방화벽이 SSH 액세스를 차단하는지 확인하고 SELinux 권한이 문제를 일으키지 않도록 합니다.\n\n4. 로그: Server B의 SSH 서버 로그에서 오류 메시지를 확인하세요:\n\n```js\ntail -f /var/log/auth.log  # Ubuntu/Debian에서\ntail -f /var/log/secure    # CentOS/RHEL에서\n```\n\n5. 디버깅 모드: 더 많은 정보를 얻기 위해 SSH를 디버깅 모드로 실행할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nssh -v user@serverB_IP\n```\n\n이 명령어는 자세한 디버그 출력을 제공하여 문제의 원인을 파악하는 데 도움이 될 것입니다.\n\n이러한 단계를 따르고 문제 해결 팁을 고려한다면, Linux 서버간의 안전하고 편리한 원격 액세스를 위한 비밀번호 없는 SSH 연결을 설정할 수 있을 것입니다.","ogImage":{"url":"/assets/img/2024-06-22-StreamliningSecureRemoteAccessAGuidetoPasswordlessSSHConnectionsBetweenLinuxServers_0.png"},"coverImage":"/assets/img/2024-06-22-StreamliningSecureRemoteAccessAGuidetoPasswordlessSSHConnectionsBetweenLinuxServers_0.png","tag":["Tech"],"readingTime":3},{"title":"방어 무력화 T1562012 Linux 감사 로그 변조 탐지 방법 2부","description":"","date":"2024-06-22 16:09","slug":"2024-06-22-ImpairDefensesT1562012DetectLinuxAuditLogsTamperingPart2","content":"\n\n![이미지](/assets/img/2024-06-22-ImpairDefensesT1562012DetectLinuxAuditLogsTamperingPart2_0.png)\n\n이 시리즈의 첫 번째 파트에서는 리눅스 감사 데몬(auditd)이 시스템 이벤트의 상세 로그를 기록하여 시스템 보안을 유지하는 중요한 역할을 강조했습니다. 이 핵심 기능은 악의적 활동을 숨기려는 공격자들에게 auditd를 주요 대상으로 삼게합니다.\n\n이전 토론은 auditd의 지속적인 작동을 보증하는 데 중점을 둔 반면, 본 기사에서는 auditd 규칙의 삭제와 설정 변경을 감지하는 데 깊이 파고들었습니다. 이러한 설정의 무결성을 보장하는 것은 효과적인 보안 모니터링에 중요합니다.\n\n본 기사에서는 auditd 규칙 및 설정에 대한 무단 변경을 감지하는 중요성을 다룰 것입니다. 이러한 변경사항을 식별하고 감사 로그의 신뢰성을 확보할 수 있는 방법과 도구, 예를 들어 auditd 규칙 및 Splunk 쿼리 등을 소개하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n끝나면 공격자가 시스템 보안을 강화하는 데 필요한 지식과 도구로 장착될 것입니다. 이를 위해 auditd 규칙과 설정을 감지하여 조작하는 것을 탐지할 수 있습니다.\n\n## 우리가 해결하려는 문제\n\n공격자는 종종 auditd 규칙을 삭제하거나 구성을 수정하여 로깅을 비활성화하고 활동을 숨깁니다. 이러한 무단 변경 사항을 감지하는 것은 공격자가 사용하는 다양한 방법 때문에 어려울 수 있습니다.\n\n우리의 목표는 auditd 규칙과 설정에 대한 무단 삭제 또는 수정을 감지하는 것입니다. 효과적인 감지 메커니즘을 구현함으로써 감사 로그의 신뢰성을 유지하고 시스템 보안을 강화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 해결책: 오디트드 규칙 및 설정 변경 감지하기\n\n저희의 해결책은 공격자가 오디트드를 대상으로 하는 도전에 대응하기 위해 두 가지 주요 구성 요소를 활용합니다:\n\n- 오디트드 규칙 삭제 감지: 오디트드에 의해 기록된 감사 레코드 유형(예: CONFIG_CHANGE)을 활용하여 오디트드 규칙의 삭제를 감지하는 모니터링을 구현할 것입니다. 이러한 레코드 유형은 규칙 삭제의 내장 로깅을 제공하여 시스템 보안을 저해할 수 있는 미승인 변경을 사전에 식별하고 대응할 수 있도록 합니다.\n- 오디트드 구성 및 중요 파일 변경 모니터링: 중요한 오디트드 구성 변경을 모니터링하기 위해 새로운 오디트드 규칙을 구현할 것입니다. 이러한 규칙은 필수적인 구성 파일의 수정 또는 삭제를 캡처하여 언제든지 미승인 변경이 즉각적으로 조사 대상으로 표시되도록 보장합니다.\n\n## 로그 활동 이해하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nauditd는 감사 시스템 구성 변경 시 CONFIG_CHANGE 이벤트를 기록합니다. 이는 감사 규칙을 포함한 구성 변경이 있을 때 발생합니다. 이 레코드 유형은 수정의 타임스탬프와 성격과 같은 세부 정보를 캡처하여 감사 규칙의 무단 삭제를 모니터링하고 감지하는 데 이상적입니다.\n\n![Image](/assets/img/2024-06-22-ImpairDefensesT1562012DetectLinuxAuditLogsTamperingPart2_1.png)\n\n## 로그 검토\n\n감사 규칙 삭제를 감지하기 위한 상관 검색을 확인하기 위해 먼저 Splunk에서 필요한 로그를 생성하기 위해 규칙 삭제 시뮬레이션을 수행했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 패턴을 찾기 매우 쉽습니다. type=CONFIG_CHANGE 및 op=remove_rule을 찾아야 합니다.\n\n![이미지](/assets/img/2024-06-22-ImpairDefensesT1562012DetectLinuxAuditLogsTamperingPart2_2.png)\n\n# Splunk에서 오디트된 규칙 삭제 감지 개발\n\n## 설명:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**검색 기준 (index, sourcetype, type, op, res):**\n\n- linux_audit 인덱스에서 type이 CONFIG_CHANGE이고 op이 remove_rule이며 res가 1인 linux:audit 이벤트를 검색합니다. (성공을 나타냄)\n\n**필드 평가 (eval key):**\n\n- key가 \"(null)\"인 경우 key를 \"unknown\"으로 설정하여 필드 일관성을 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 집계 (통계 값(key) AS deleted_rules):\n\n   - _time, host, type, auid, ses 및 op에 따라 이벤트를 집계하고, 삭제된 auditd 규칙의 모든 key 값(이름)을 deleted_rules로 모음.\n\n4. 시간 변환 (convert ctime(_time)):\n\n   - _time의 Unix 타임스탬프를 사람이 읽을 수 있는 날짜 및 시간 형식으로 변환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n5. 삭제된 규칙 수 세기 (eval count=mvcount(deleted_rules)):\n\n- 삭제된 규칙 발생 횟수를 세줍니다.\n\n6. 이벤트 설명 (eval event_info):\n\n- 삭제된 규칙의 개수를 기반으로 event_info를 구성합니다.\n- 삭제된 auditd 규칙의 수와 타임스탬프를 지정합니다.\n- 규칙 삭제의 예기치 못한 성격으로 인해 조사를 권장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n7. 최종 결과 (표 _time, 호스트, 유형, auid, ses, 작업, deleted_rules, 이벤트_정보):\n\n- 타임스탬프(_time), 호스트, 이벤트 유형 (유형), 감사 사용자 ID (auid), 세션 ID (ses), 작업 (op), 삭제된 규칙 (deleted_rules) 및 이벤트 세부정보 (이벤트_정보)를 포함한 구조화된 테이블 형식으로 결과를 제시합니다.\n\n# auditd 구성 수정/삭제를 모니터링하기 위한 탐지 개발\n\n## 단계 1: 구성 수정을 모니터링하기 위한 auditd 규칙 생성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n설정 중인 auditd 규칙은 Linux 감사 인프라에 필수적인 핵심 구성 파일을 모니터링하기 위해 전략적으로 설계되었습니다. 이러한 파일에는 /etc/audit/auditd.conf, /etc/audit/rules.d/test.rules, /etc/audisp/audispd.conf 및 /etc/libaudit.conf이 포함됩니다. 각각이 중요한 이유는 다음과 같습니다:\n\n- /etc/audit/auditd.conf: 감사 데몬 (auditd)의 전역 설정을 제어하며 로그 위치, 보존 정책 및 시스템 전체 감사 구성을 포함합니다.\n- /etc/audit/rules.d/test.rules: 특정 이벤트 및 조건을 정의하는 감사 규칙을 포함합니다.\n- /etc/audisp/audispd.conf: 감사 이벤트 디스패처 (audispd)를 구성하며 감사 이벤트를 처리하고 전달하는 역할을 담당합니다.\n- /etc/libaudit.conf: 감사 프레임워크 (libaudit)의 라이브러리 수준 설정을 관리하며 그 동작과 기능성에 영향을 줍니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-ImpairDefensesT1562012DetectLinuxAuditLogsTamperingPart2_3.png\" /\u003e\n\n이 auditd 규칙의 논리는 다른 설정 파일 간에 일관성을 유지합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 각 규칙은 관련 작업이 발생할 때마다 감사 이벤트가 생성되도록 항상 -a를 사용합니다.\n- 모두 -F path=를 지정하여 감시되는 특정 구성 파일의 경로를 정의합니다.\n- -F perm=wa는 쓰기(w) 및 속성 변경(a) 권한에 대해 이벤트가 트리거되도록 지정합니다.\n- -F success=1은 작업이 성공했을 때에만 이벤트가 기록되도록 합니다.\n- -k 매개변수는 auditd 규칙의 이름을 지정합니다.\n- 차이점은 지정된 경로(-F path=)에만 있으며, 다른 구성 파일(/etc/audit/auditd.conf, /etc/audit/rules.d/test.rules, /etc/audisp/audispd.conf, /etc/libaudit.conf)을 가리킵니다.\n\n구성 파일을 모니터링하기 위해 auditd 규칙을 구성하면 감지된 모든 수정 사항에 대한 로그가 생성됩니다. 이러한 로그는 Splunk에서 침입 탐지 규칙을 생성하기 위한 입력으로 사용됩니다.\n\n이러한 감사 로그를 상호 연관시키고 분석함으로써 Splunk는 무단 변경에 대한 예방적인 모니터링 및 경고를 제공합니다.\n\n## 단계 2: Splunk에서 상호 연관 검색 개발\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새 감사 규칙을 테스트하여 auditd.conf에 다양한 수정 사항을 시뮬레이션하여 올바르게 작동하는지 확인했습니다.\n\n첫 번째 테스트에서는 rm 명령어를 사용하여 auditd.conf를 삭제하는 것을 포함했습니다. 두 번째 테스트에서는 설정 파일을 다른 디렉토리로 이동하고, 세 번째 테스트에서는 vim 텍스트 편집기를 사용하여 수정했습니다.\n\n## 설명:\n\n- 검색 기준 (인덱스, 소스 유형, 유형, 키):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- linux_audit 인덱스에서 linux:audit 소스 유형 및 type이 SYSCALL인 이벤트를 검색합니다.\n- 키 필드가 생성한 특정 감사 규칙 (auditrule_modification, auditd_conf_modification, audispd_conf_modification, libauditd_conf_modification) 중 하나와 일치하는 이벤트를 필터링합니다.\n\n2. 집계 (transaction host maxpause=1s):\n\n- 1초 시간 간격 내(최대 일시 중지 = 1초) 동일 호스트에서 연속된 이벤트 (SYSCALL 항목)를 그룹화합니다.\n- 이 집계는 위협 행위자의 특정 작업에 대한 추가 컨텍스트를 제공할 수 있는 시스템 호출 순서를 분석하는 데 도움이 됩니다.\n\n3. 통계 요약 (stats count by _time, host, key, comm, exe, uid, gid, _raw):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다양한 필드별로 그룹화된 카운트를 계산합니다: _time (타임스탬프), host (컴퓨터 이름), key (감사 키), comm (명령어 이름), exe (실행 파일 경로), uid (사용자 ID), gid (그룹 ID) 및 _raw (원시 로그 항목). 이 요약은 트랜잭션 내에서 이러한 속성의 각 고유한 조합의 빈도수를 나타냅니다.\n\n## SYSCALL 이벤트의 중요 역할\n\nSYSCALLs (시스템 콜)은 Linux 시스템의 감사 로그 내에서 이벤트를 탐지하고 이해하는 데 중요한 역할을 합니다. 이것이 어떻게 이벤트 탐지에 기여하는지 살펴보겠습니다:\n\n기본 시스템 작업: SYSCALLs는 Linux 시스템에서 프로세스가 수행하는 기본 작업을 나타내기 때문에 필수적입니다. 이러한 작업에는 파일 시스템 접근 (예: open, read, write, unlink), 프로세스 관리 (예: fork, execve, exit), 그리고 네트워크 통신 (예: socket, connect, sendmsg)이 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAudit Logging: Linux 시스템은 SYSCALL 이벤트를 기록하기 위해 감사 메커니즘을 사용합니다. 감사 로그에 기록된 각 SYSCALL 이벤트에는 작업 유형 (시스템 호출), 성공 또는 실패 여부 (성공=yes/no), 관련된 프로세스 ID (pid, ppid), 사용자 및 그룹 ID (uid, gid), 그리고 실행 가능한 경로 (exe)와 같은 세부 정보가 포함됩니다.\n\n## Raw Log Entry 분석:\n\n- type=SYSCALL: 로그 항목이 시스템 호출 이벤트와 관련되어 있음을 나타냅니다.\n- msg=audit(1715771488.665:75612745): 감사 이벤트의 타임스탬프 및 일련 번호.\n- syscall=263: 시스템 호출 번호를 지정합니다.\n- success=yes: 시스템 호출이 성공했음을 나타냅니다 (yes).\n- a0, a1, a2, a3: 감사 로그 항목의 이 필드는 시스템 호출 (syscall=263) 실행 시 전달된 인수 (a0부터 a3)를 나타냅니다. 이들은 시스템 호출 작업에 대한 구체적인 세부 정보를 제공합니다.\n- exit=0: 시스템 호출의 종료 상태 (0은 성공을 나타냅니다).\n- auid=*****: 감사 사용자 ID.\n- uid=0, gid=0, euid=0, suid=0, fsuid=0, egid=0, sgid=0, fsgid=0: 프로세스와 관련된 사용자 및 그룹 ID (사용자 ID에 대한 uid 및 그룹 ID에 대한 gid).\n- comm=”rm”: 프로세스에 의해 실행된 명령 이름 (이 경우 'rm').\n- exe=”/usr/bin/rm”: 명령과 관련된 실행 가능 경로 (/usr/bin/rm).\n- key=”auditd_conf_modification”: 이 이벤트와 관련된 감사 키를 식별합니다 (auditd_conf_modification은 감사 구성에 관련된 수정을 나타냅니다).\n\n## 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리눅스 감사 로그 변조를 탐지하는 이 두 부작에서는 auditd 규칙과 구성의 무결성을 보호하는 필수 전략을 탐구했습니다. 우선, 우리는 보안 모니터링에서의 auditd의 중요 역할과 악의적인 변조에 대한 취약성을 강조했습니다. 이를 통해 auditd 규칙의 삭제와 구성 변경을 탐지하는 것에 중점을 두었는데, 이는 견고한 보안 관행을 유지하는 데 중요합니다.\n\nauditd 규칙과 Splunk 쿼리를 활용한 실용적인 구현을 통해 무단 수정을 모니터링하고 감지하는 효과적인 방법을 시연했습니다. CONFIG_CHANGE 및 SYSCALL과 같은 audit 레코드 유형을 활용하여 의심스러운 활동을 신속하게 식별할 수 있는 탐지 메커니즘을 개발했습니다. 이러한 노력은 사건 대응과 규정 준수에 중요한 감사 로그의 신뢰성을 보장합니다.\n\n## 다음 단계:\n\n앞으로의 다음 단계는:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 지속적 모니터링: auditd 규칙과 설정을 계속 모니터링하여 향후 무단 변경을 감지합니다.\n- 향상된 경보 설정: Splunk에서 경보 메커니즘을 세밀하게 조정하여 auditd와 관련된 수상한 활동에 대한 실시간 알림을 제공합니다.\n- 사고 대응 준비: 신속하게 수사할 수 있도록 사고 조치를 준비하고 식별된 보안 위반 사항에 대해 대응합니다.\n- 주기적 검토: 진화하는 보안 위협과 조직적 요구에 적응하기 위해 auditd 설정과 규칙을 정기적으로 검토하고 업데이트합니다.\n\n이러한 실천 방법을 보안 운영에 통합함으로써 Linux 환경의 변경 방지 방어를 강화하고 효과적인 보안 모니터링과 규정 준수를 보장할 수 있습니다.\n\nAleksandar Matev 작성","ogImage":{"url":"/assets/img/2024-06-22-ImpairDefensesT1562012DetectLinuxAuditLogsTamperingPart2_0.png"},"coverImage":"/assets/img/2024-06-22-ImpairDefensesT1562012DetectLinuxAuditLogsTamperingPart2_0.png","tag":["Tech"],"readingTime":8}],"page":"40","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"40"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>