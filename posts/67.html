<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/67" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/67" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="미디어파이프를 사용한 실시간 손 추적 및 제스처 인식 재생 횟수 쇼케이스" href="/post/2024-06-19-Real-TimeHandTrackingandGestureRecognitionwithMediaPipeRerunShowcase"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="미디어파이프를 사용한 실시간 손 추적 및 제스처 인식 재생 횟수 쇼케이스" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-Real-TimeHandTrackingandGestureRecognitionwithMediaPipeRerunShowcase_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="미디어파이프를 사용한 실시간 손 추적 및 제스처 인식 재생 횟수 쇼케이스" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">미디어파이프를 사용한 실시간 손 추적 및 제스처 인식 재생 횟수 쇼케이스</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="가상에서 현실로 산업 응용 프로그램을 위한 더 똑똑한 로봇을 훈련시킬 합성 데이터" href="/post/2024-06-19-FromVirtualtoRealityHowSyntheticDataWillTrainSmarterRobotsforIndustrialApplications"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="가상에서 현실로 산업 응용 프로그램을 위한 더 똑똑한 로봇을 훈련시킬 합성 데이터" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-FromVirtualtoRealityHowSyntheticDataWillTrainSmarterRobotsforIndustrialApplications_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="가상에서 현실로 산업 응용 프로그램을 위한 더 똑똑한 로봇을 훈련시킬 합성 데이터" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">가상에서 현실로 산업 응용 프로그램을 위한 더 똑똑한 로봇을 훈련시킬 합성 데이터</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="LLMLarge Language Models가 안드로이드 인간의 두뇌가 되면 어떤 일이 벌어질까요" href="/post/2024-06-19-WhathappenswhenLLMsbecomethebrainsofhumanoidandroids"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="LLMLarge Language Models가 안드로이드 인간의 두뇌가 되면 어떤 일이 벌어질까요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-WhathappenswhenLLMsbecomethebrainsofhumanoidandroids_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="LLMLarge Language Models가 안드로이드 인간의 두뇌가 되면 어떤 일이 벌어질까요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">LLMLarge Language Models가 안드로이드 인간의 두뇌가 되면 어떤 일이 벌어질까요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="단계별 안내 라즈베리 파이 4 클러스터에 K3s 설치하기" href="/post/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="단계별 안내 라즈베리 파이 4 클러스터에 K3s 설치하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="단계별 안내 라즈베리 파이 4 클러스터에 K3s 설치하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">단계별 안내 라즈베리 파이 4 클러스터에 K3s 설치하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="라즈베리 파이 완벽한 헤드리스 설정 안내" href="/post/2024-06-19-RaspberryPiFullHeadlessSetupGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="라즈베리 파이 완벽한 헤드리스 설정 안내" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="라즈베리 파이 완벽한 헤드리스 설정 안내" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">라즈베리 파이 완벽한 헤드리스 설정 안내</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="라즈베리 파이 4와 I2C 백팩을 사용한 LCD 디스플레이 설정 방법" href="/post/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="라즈베리 파이 4와 I2C 백팩을 사용한 LCD 디스플레이 설정 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="라즈베리 파이 4와 I2C 백팩을 사용한 LCD 디스플레이 설정 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">라즈베리 파이 4와 I2C 백팩을 사용한 LCD 디스플레이 설정 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="만나요, Lawny 라즈베리 파이로 제어하는 FPV 잔디깎이" href="/post/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="만나요, Lawny 라즈베리 파이로 제어하는 FPV 잔디깎이" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="만나요, Lawny 라즈베리 파이로 제어하는 FPV 잔디깎이" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">만나요, Lawny 라즈베리 파이로 제어하는 FPV 잔디깎이</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="안녕하세요 Ansible을 사용하여 Docker 설치하는 방법에 관해 안내해 드리겠습니다 함께 시작해 보도록 하죠" href="/post/2024-06-19-HowToInstallDockerUsingAnsible"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="안녕하세요 Ansible을 사용하여 Docker 설치하는 방법에 관해 안내해 드리겠습니다 함께 시작해 보도록 하죠" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowToInstallDockerUsingAnsible_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="안녕하세요 Ansible을 사용하여 Docker 설치하는 방법에 관해 안내해 드리겠습니다 함께 시작해 보도록 하죠" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">안녕하세요 Ansible을 사용하여 Docker 설치하는 방법에 관해 안내해 드리겠습니다 함께 시작해 보도록 하죠</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="라즈베리 파이 5에서 쿠버네티스 - 3부 마스터 노드에 K3S 설치하기" href="/post/2024-06-19-KubernetesonRaspberryPi5Part3InstallK3Sonmasternode"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="라즈베리 파이 5에서 쿠버네티스 - 3부 마스터 노드에 K3S 설치하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-KubernetesonRaspberryPi5Part3InstallK3Sonmasternode_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="라즈베리 파이 5에서 쿠버네티스 - 3부 마스터 노드에 K3S 설치하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">라즈베리 파이 5에서 쿠버네티스 - 3부 마스터 노드에 K3S 설치하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Coral Dual Edge TPU를 Frigate를 위해 설정하는 방법" href="/post/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Coral Dual Edge TPU를 Frigate를 위해 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Coral Dual Edge TPU를 Frigate를 위해 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Coral Dual Edge TPU를 Frigate를 위해 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link posts_-active__YVJEi" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"미디어파이프를 사용한 실시간 손 추적 및 제스처 인식 재생 횟수 쇼케이스","description":"","date":"2024-06-19 18:31","slug":"2024-06-19-Real-TimeHandTrackingandGestureRecognitionwithMediaPipeRerunShowcase","content":"\n\n## 미디어파이프의 손 추척 및 제스처 인식을 Rerun과 함께 시각화하는 방법\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*pE_4QrsVPV7vMrxB6YS1cQ.gif)\n\n이 게시물에서는 미디어파이프 파이썬과 Rerun SDK를 사용하여 손 추척 및 제스처 인식의 예제를 소개하고 있습니다.\n\n더 깊이 파고들고 이해를 넓히고 싶다면, 미디어파이프 파이썬 및 Rerun SDK를 설치하여 손을 추적하고 다양한 제스처를 인식하고 데이터를 시각화하는 방법을 안내해 드리겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 그러므로, 다음을 배울 것입니다:\n\n- MediaPipe Python 및 Rerun 설치하는 방법\n- MediaPipe 제스처 인식을 사용한 손 추적 및 제스처 인식 방법\n- 손 추적 및 제스처 인식 결과를 Rerun Viewer에서 시각화하는 방법\n\n예제를 시도하기를 열망한다면, 아래 제공된 코드를 사용해보세요:\n\n```js\n# rerun GitHub 저장소를 로컬 머신에 클론합니다.\ngit clone https://github.com/rerun-io/rerun\n\n# rerun 저장소 디렉토리로 이동합니다.\ncd rerun\n\n# 필요한 Python 패키지를 requirements 파일에 명시된대로 설치합니다.\npip install -r examples/python/gesture_detection/requirements.txt\n\n# 예제를 위한 주요 Python 스크립트를 실행합니다.\npython examples/python/gesture_detection/main.py\n\n# 특정 이미지에 대한 주요 Python 스크립트를 실행합니다.\npython examples/python/gesture_detection/main.py --image path/to/your/image.jpg\n\n# 특정 비디오에 대한 주요 Python 스크립트를 실행합니다.\npython examples/python/gesture_detection/main.py --video path/to/your/video.mp4\n\n# 카메라 스트림으로 주요 Python 스크립트를 실행합니다.\npython examples/python/gesture_detection/main.py --camera\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 손 추적 및 제스처 인식 기술\n\n계속하기 전에, 우리가 가능하게 한 기술에 대해 인정해주어야 합니다. 손 추적 및 제스처 인식 기술은 기기가 손 움직임과 제스처를 명령이나 입력으로 해석할 수 있도록 하는 것을 목표로 합니다. 이 기술의 핵심은 미리 훈련된 기계 학습 모델이 시각 입력을 분석하고 손의 랜드마크와 제스처를 식별합니다. 이러한 기술의 실제 응용은 다양하며, 손 움직임과 제스처를 사용하여 스마트 기기를 제어하는 데 사용될 수 있습니다. 인간-컴퓨터 상호 작용, 로봇 공학, 게임 및 증강 현실은 이 기술의 잠재적인 응용 분야 중 가장 유망하게 보입니다.\n\n그러나 이러한 기술을 사용하는 방법에 대해 항상 주의해야 합니다. 민감하고 중요한 시스템에서 사용시 손 제스처를 잘못 해석할 수 있고, 잘못된 양성 또는 음성의 가능성이 작지 않습니다. 이를 활용함으로써 발생하는 윤리적 및 법적 문제가 사용자들이 특히 공공장소에서 자신의 제스처가 기록되는 것을 원치 않을 수 있습니다. 현실 세계 시나리오에서 이 기술을 도입하기로 결정했다면, 윤리적 및 법적 고려 사항을 고려하는 것이 중요합니다.\n\n# 요구 사항 및 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 필요한 라이브러리를 설치해야 합니다. 이는 OpenCV, MediaPipe 및 Rerun과 같은 라이브러리를 포함합니다. MediaPipe Python은 컴퓨터 비전 및 머신러닝을 위한 온디바이스 ML 솔루션을 통합하려는 개발자들에게 유용한 도구이며, Rerun은 시간이 지남에 따라 변화하는 다중 모달 데이터를 시각화하기 위한 SDK입니다.\n\n```js\n# 요구 사항 파일에서 지정된 필수 Python 패키지 설치\npip install -r examples/python/gesture_detection/requirements.txt\n```\n\n그런 다음, 여기서 미리 정의된 모델을 다운로드해야 합니다: HandGestureClassifier\n\n# MediaPipe를 사용한 손 추적과 제스처 인식\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-Real-TimeHandTrackingandGestureRecognitionwithMediaPipeRerunShowcase_0.png\" /\u003e\n\n이제 샘플 이미지에 제스처 인식을 위해 MediaPipe 사전 훈련 모델을 사용해봅시다. 아래 코드는 MediaPipe 제스처 인식 솔루션의 초기화 및 구성을 설정하는 기초를 제공합니다.\n\n```js\nfrom mediapipe.tasks.python import vision\nfrom mediapipe.tasks import python\n\nclass GestureDetectorLogger:\n\n    def __init__(self, video_mode: bool = False):\n        self._video_mode = video_mode\n\n        base_options = python.BaseOptions(\n            model_asset_path='gesture_recognizer.task'\n        )\n        options = vision.GestureRecognizerOptions(\n            base_options=base_options,\n            running_mode=mp.tasks.vision.RunningMode.VIDEO if self._video_mode else mp.tasks.vision.RunningMode.IMAGE\n        )\n        self.recognizer = vision.GestureRecognizer.create_from_options(options)\n\n\n    def detect(self, image: npt.NDArray[np.uint8]) -\u003e None:\n        image = mp.Image(image_format=mp.ImageFormat.SRGB, data=image)\n  \n        # 제스처 검출 모델로부터 결과 가져오기\n        recognition_result = self.recognizer.recognize(image)\n  \n        for i, gesture in enumerate(recognition_result.gestures):\n            # 인식된 제스처 중 상위 제스처 가져오기\n            print(\"최상위 제스처 결과: \", gesture[0].category_name)\n  \n        if recognition_result.hand_landmarks:\n            # MediaPipe에서 손 랜드마크 가져오기\n            hand_landmarks = recognition_result.hand_landmarks\n            print(\"손 랜드마크: \" + str(hand_landmarks))\n  \n            # MediaPipe에서 손 연결 정보 가져오기\n            mp_hands_connections = mp.solutions.hands.HAND_CONNECTIONS\n            print(\"손 연결 정보: \" + str(mp_hands_connections))\n```\n\nGestureDetectorLogger 클래스 내의 detect 함수는 이미지를 인자로 받아 모델 결과를 출력하며, 인식된 최상위 제스처와 감지된 손 랜드마크를 강조합니다. 모델에 대한 추가 정보는 해당 모델 카드를 참조하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-Real-TimeHandTrackingandGestureRecognitionwithMediaPipeRerunShowcase_1.png)\n\n아래 코드를 사용하여 직접 시도해볼 수 있어요:\n\n```js\ndef run_from_sample_image(path)-\u003e None:\n    image = cv2.imread(str(path))\n    show_image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n    logger = GestureDetectorLogger(video_mode=False)\n    logger.detect_and_log(show_image)\n\n# 샘플 이미지로 제스처 인식 실행하기\nrun_from_sample_image(SAMPLE_IMAGE_PATH)\n```\n\n# 재실행을 사용하여 확인, 디버그 및 데모하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 단계는 솔루션의 신뢰성과 효과성을 보장하는 데 도움이 됩니다. 모델을 준비한 상태로 결과를 시각화하여 정확성을 확인하고 잠재적인 문제를 해결하며 능력을 시연할 수 있습니다. 결과를 시각화해서 Rerun SDK를 사용하면 간단하고 빠르게 가능합니다.\n\n## Rerun을 어떻게 사용할까요?\n\n![이미지](/assets/img/2024-06-19-Real-TimeHandTrackingandGestureRecognitionwithMediaPipeRerunShowcase_2.png)\n\n- Rerun SDK를 사용하여 코드에서 로깅하여 다중 데이터를 스트림으로 전송\n- 현지 또는 원격으로 라이브 또는 녹화된 스트림을 시각화하고 상호 작용\n- 레이아웃을 대화식으로 구축하고 시각화를 사용자 정의\n- 필요할 때 Rerun을 확장\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 작성에 앞서, Rerun Viewer를 설치하기 위해 해당 페이지를 방문하는 것이 좋습니다. 그런 다음, Rerun SDK에 대해 읽어보는 것을 권해드립니다. 파이썬 빠른 시작 가이드와 파이썬에서 데이터 기록하기를 읽어보세요. 이러한 초기 단계는 원활한 설정을 보장하고 다가오는 코드 실행에 도움이 될 것입니다.\n\n## 비디오 또는 실시간 실행\n\n비디오 스트리밍에는 OpenCV가 사용됩니다. 특정 비디오의 파일 경로를 선택하거나 0 또는 1의 인수를 제공하여 자체 카메라에 액세스할 수 있습니다 (기본 카메라를 사용하려면 0을 사용하고, 맥에서는 1을 사용할 수 있습니다).\n\n타임라인의 소개를 강조하는 것이 중요합니다. Rerun 타임라인의 기능은 데이터를 하나 이상의 타임라인과 연관시킬 수 있게 합니다. 결과적으로, 비디오의 각 프레임은 해당 타임스탬프와 연관되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndef run_from_video_capture(vid: int | str, max_frame_count: int | None) -\u003e None:\n    \"\"\"\n    비디오 스트림에서 탐지기를 실행합니다.\n\n    매개변수\n    ----------\n    vid:\n        탐지기가 실행될 비디오 스트림입니다. 기본 카메라에는 0/1을 사용하거나 비디오 파일의 경로를 지정하세요.\n    max_frame_count:\n        처리할 최대 프레임 수입니다. None이면 모든 프레임을 처리합니다.\n    \"\"\"\n    cap = cv2.VideoCapture(vid)\n    fps = cap.get(cv2.CAP_PROP_FPS)\n\n    detector = GestureDetectorLogger(video_mode=True)\n\n    try:\n        it: Iterable[int] = itertools.count() if max_frame_count is None else range(max_frame_count)\n\n        for frame_idx in tqdm.tqdm(it, desc=\"프레임 처리 중\"):\n            ret, frame = cap.read()\n            if not ret:\n                break\n\n            if np.all(frame == 0):\n                continue\n\n            frame_time_nano = int(cap.get(cv2.CAP_PROP_POS_MSEC) * 1e6)\n            if frame_time_nano == 0:\n                frame_time_nano = int(frame_idx * 1000 / fps * 1e6)\n\n            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n\n            rr.set_time_sequence(\"프레임 번호\", frame_idx)\n            rr.set_time_nanos(\"프레임 시간\", frame_time_nano)\n            detector.detect_and_log(frame, frame_time_nano)\n            rr.log(\n                \"미디어/비디오\",\n                rr.Image(frame)\n            )\n\n    except KeyboardInterrupt:\n        pass\n\n    cap.release()\n    cv2.destroyAllWindows()\n```\n\n## 시각화를 위한 데이터 로깅\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*c1Us-7PoWSP0rgVdlMQUhA.gif\" /\u003e\n\nRerun Viewer에서 데이터를 시각화하려면 Rerun SDK를 사용하여 데이터를 로깅하는 것이 중요합니다. 이전에 언급된 가이드는 이 프로세스에 대한 통찰을 제공합니다. 이 문맥에서는 정규화된 값으로 손 랜드마크 포인트를 추출한 다음, 이미지의 너비와 높이를 사용하여 이미지 좌표로 변환합니다. 이러한 좌표는 2D 포인트로 Rerun SDK에 로깅됩니다. 추가로, 랜드마크 간의 연결을 식별하고 2D 라인스트립으로 로깅합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제스처 인식을 위해 결과는 콘솔에 출력됩니다. 그러나 소스 코드 안에서는 TextDocument 및 이모지를 사용하여 이러한 결과를 시청자에게 제시하는 방법을 탐구할 수 있습니다.\n\n```js\nclass GestureDetectorLogger:\n\n    def detect_and_log(self, image: npt.NDArray[np.uint8], frame_time_nano: int | None) -\u003e None:\n        # 이미지에서 제스처 인식\n        height, width, _ = image.shape\n        image = mp.Image(image_format=mp.ImageFormat.SRGB, data=image)\n\n        recognition_result = (\n            self.recognizer.recognize_for_video(image, int(frame_time_nano / 1e6))\n            if self._video_mode\n            else self.recognizer.recognize(image)\n        )\n\n        # 값 지우기\n        for log_key in [\"Media/Points\", \"Media/Connections\"]:\n            rr.log(log_key, rr.Clear(recursive=True))\n\n        for i, gesture in enumerate(recognition_result.gestures):\n            # 인식된 제스처를 기록\n            gesture_category = gesture[0].category_name if recognition_result.gestures else \"None\"\n            print(\"제스처 카테고리:\", gesture_category)\n\n        if recognition_result.hand_landmarks:\n            hand_landmarks = recognition_result.hand_landmarks\n\n            # 정규화된 좌표를 이미지 좌표로 변환\n            points = self.convert_landmarks_to_image_coordinates(hand_landmarks, width, height)\n\n            # 이미지 및 Hand Entity에 점 기록\n            rr.log(\n               \"Media/Points\",\n                rr.Points2D(points, radii=10, colors=[255, 0, 0])\n            )\n\n            # MediaPipe에서 손 연결 가져오기\n            mp_hands_connections = mp.solutions.hands.HAND_CONNECTIONS\n            points1 = [points[connection[0]] for connection in mp_hands_connections]\n            points2 = [points[connection[1]] for connection in mp_hands_connections]\n\n            # 이미지와 Hand Entity에 연결 기록\n            rr.log(\n               \"Media/Connections\",\n                rr.LineStrips2D(\n                   np.stack((points1, points2), axis=1),\n                   colors=[255, 165, 0]\n                )\n             )\n\n    def convert_landmarks_to_image_coordinates(hand_landmarks, width, height):\n        return [(int(lm.x * width), int(lm.y * height)) for hand_landmark in hand_landmarks for lm in hand_landmark]\n```\n\n## 3D Points\n\n마지막으로, 손 랜드마크를 3D 포인트로 표시하는 방법을 살펴봅니다. 먼저 init 함수에서 Annotation Context의 키포인트를 사용하여 포인트 사이의 연결을 정의한 다음 3D 포인트로 기록합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*rNILX857c8TfScr6t7KKgQ.gif)\n\n```python\nclass GestureDetectorLogger:\n\n    def __init__(self, video_mode: bool = False):\n        # ... existing code ...\n        rr.log(\n            \"/\",\n            rr.AnnotationContext(\n                rr.ClassDescription(\n                    info=rr.AnnotationInfo(id=0, label=\"Hand3D\"),\n                    keypoint_connections=mp.solutions.hands.HAND_CONNECTIONS\n                )\n            ),\n            timeless=True\n        )\n        rr.log(\"Hand3D\", rr.ViewCoordinates.RIGHT_HAND_X_DOWN, timeless=True)\n\n\n    def detect_and_log(self, image: npt.NDArray[np.uint8], frame_time_nano: int | None) -\u003e None:\n        # ... existing code ...\n\n        if recognition_result.hand_landmarks:\n            hand_landmarks = recognition_result.hand_landmarks\n\n            landmark_positions_3d = self.convert_landmarks_to_3d(hand_landmarks)\n            if landmark_positions_3d is not None:\n                rr.log(\n                    \"Hand3D/Points\",\n                    rr.Points3D(landmark_positions_3d, radii=20, class_ids=0, keypoint_ids=[i for i in range(len(landmark_positions_3d))])\n                )\n\n        # ... existing code ...\n```\n\n준비 완료! 마법이 시작됩니다:\n\n```python\n# For image\nrun_from_sample_image(IMAGE_PATH)\n\n# For saved video\nrun_from_video_capture(VIDEO_PATH)\n\n# For Real-Time\nrun_from_video_capture(0) # mac may need 1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예제의 전체 소스 코드는 GitHub에서 확인할 수 있습니다. 탐색하고 변경하며 구현의 내부 작업을 이해하는 데 자유롭게 사용하세요.\n\n# 손 추적 및 제스처 인식을 넘어서\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*zc2gezkjPuJMjuToD4gBOw.gif)\n\n마침내, 다양한 애플리케이션 범위에서 다양한 종류의 다중 모달 데이터를 시각화하는 데 관심이 있다면, Rerun Examples를 살펴보고 탐구할 것을 권장합니다. 이러한 예제는 잠재적인 현실 세계 사례를 강조하고 그러한 시각화 기술의 실용적인 응용에 대한 소중한 통찰력을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 이 글이 유익하고 통찰력이 있었다면, 더 많은 내용을 기대해주세요! 나는 로봇공학과 컴퓨터 비전 시각화 게시물에 대해 깊이 있는 내용을 정기적으로 공유하고 있습니다. 놓치고 싶지 않은 미래 업데이트와 흥미로운 프로젝트를 위해 팔로우해주세요!\n\n또한, LinkedIn에서 저를 찾을 수 있습니다.\n\n비슷한 글:","ogImage":{"url":"/assets/img/2024-06-19-Real-TimeHandTrackingandGestureRecognitionwithMediaPipeRerunShowcase_0.png"},"coverImage":"/assets/img/2024-06-19-Real-TimeHandTrackingandGestureRecognitionwithMediaPipeRerunShowcase_0.png","tag":["Tech"],"readingTime":12},{"title":"가상에서 현실로 산업 응용 프로그램을 위한 더 똑똑한 로봇을 훈련시킬 합성 데이터","description":"","date":"2024-06-19 18:29","slug":"2024-06-19-FromVirtualtoRealityHowSyntheticDataWillTrainSmarterRobotsforIndustrialApplications","content":"\n\n## OpenUSD를 활용한 합성 데이터 생성이 산업용 AI 로봇에 대한 새로운 기회를 열고 있습니다\n\n글: NVIDIA의 제라드 앤드류스 상급 제품 마케팅 매니저\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*K8WDd-MWHkJz2p72nF1csQ.gif)\n\n매년 전 세계 시장에는 대략 40만대의 새 로봇이 도입됩니다. 이들은 2028년까지 700억 달러를 넘을 것으로 예상되는 거의 450억 달러에 이르는 성장하는 산업용 로봇 시장에 기여합니다. 창고 및 공장부터 병원 및 배송 서비스까지, 이 로봇들은 우리가 일하고 살아가는 방식을 변화시키고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로봇 시스템은 반복적인 작업을 정밀하고 효율적으로 수행할 수 있는 능력으로 다양한 분야에서 중요한 요소가 되어 왔습니다. 물류 및 제조업과 같은 산업에서는 공정을 최적화하고 제품 결함과 같은 이상을 탐지하는 데 도움을 줄 수 있습니다. AI를 활용한 로봇의 융통성과 다재다능성으로 인해, 해당 수요는 앞으로 더욱 증가할 것으로 예상됩니다.\n\n하지만 실제 세계 시나리오에 로봇을 훈련시키는 것은 방대한 데이터 수집, 훈련 및 시뮬레이션으로 이루어진 복잡한 작업 흐름입니다. 이러한 데이터 수집은 시간이 많이 소요되거나 비용이 많이 들거나 때로는 위험할 수 있습니다. 이런 경우 합성 데이터가 중요한 역할을 합니다.\n\n합성 데이터란 실제 환경을 모방하도록 설계된 인공적으로 생성된 데이터를 말합니다. 합성 데이터를 활용하면 팀은 훈련 프로세스를 가속화하고 로봇이 다양한 도전에 대비할 수 있도록 보장할 수 있습니다.\n\n합성 데이터는 NVIDIA Omniverse Replicator를 사용하여 생성할 수 있습니다. 이는 합성 데이터 생성( SDG) 도구와 파이프라인을 구축할 수 있는 개발자 프레임워크입니다. Universal Scene Description (OpenUSD)에 기반한 Omniverse는 3D 작업 흐름, 도구 및 응용 프로그램을 구축하기 위한 개발 플랫폼입니다. Omniverse는 또한 로봇 공학자가 AI 기반 로봇을 설계, 테스트 및 훈련할 수 있는 확장 가능한 로보틱스 시뮬레이션 응용 프로그램 인 NVIDIA Isaac Sim을 지원합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOmniverse Replicator은 매우 사용자 정의 가능하며 API에 의해 확장 가능하며 특수한 SDG 파이프라인을 개발할 수 있습니다. 개발자로서 여러 가지 속성을 프로그래밍 방식으로 무작위로 설정할 수 있습니다. 또한 굽힌 상자와 세분화 마스크와 같은 사용자 정의 어노테이터 및 작성기를 작성할 수도 있습니다.\n\n# Edge Impluse가 시각 검사용 Omniverse Replicator를 사용자 정의합니다\n\n인공 지능은 이미 산업 시각 검사에서 엄청난 가치를 보여줍니다. 그러나 정확한 물체 감지 모델을 개발하는 것은 실제 세계 데이터셋이 제한되어 있는 경우 도전일 수 있습니다.\n\n데이터 갭을 좁히기 위해 공장 라인의 디지털 트윈을 생성하여 인공 지능 모델이 학습할 수 있는 테스트용 지면을 만들 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEdge Impulse의 선두 개발자인 Jenny Plunkett은 결함 검출용 사전을 생성하기 위해 자체 맞춤형 파이프라인을 구축했습니다. 그녀는 결함이 있는 소다 캔을 운반하는 컨베이어 벨트의 장면으로 시작했습니다. 그런 다음, Replicator에서 루틴을 구축하여 조명, 색상, 질감, 배경, 전경, 그리고 캔의 위치 등 장면의 속성을 프로그래밍적으로 임의로 변경하여 Omniverse Replicator에서 생성된 합성 이미지 집합을 모델이 학습할 수 있도록 다채롭고 많은 양의 합성 이미지를 생성했습니다.\n\n합성 데이터가 준비되면, Edge Impulse와 같은 AI 개발 플랫폼으로 공급하여 데이터에 주석을 달고 모델을 구축하고 실제 물체로 테스트할 수 있습니다. 작업 흐름에 대해 자세히 알아보세요.\n\n![이미지](/assets/img/2024-06-19-FromVirtualtoRealityHowSyntheticDataWillTrainSmarterRobotsforIndustrialApplications_0.png)\n\n# 물체 감지를 위한 창고 로봇 교육용 맞춤형 SDG 파이프라인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자율 로봇은 창고에서 널리 배치되어 있으며, 상품을 효율적이고 안전하게 운송하거나 재고 관리를 최적화하는 등의 작업에 도움을 줄 수 있습니다. 결함 감지 사용 사례와 유사하게, 개발자들은 물체 감지 사용 사례를 위해 Omniverse Replicator를 사용자 정의할 수 있습니다.\n\n본 블로그에서는 SDG 파이프라인을 구축하여 창고에서 파레트 잭을 감지하는 자율 이동 로봇(AMRs) 모델의 성능을 반복적으로 향상시키기 위해 합성 데이터를 생성하는 방법을 소개합니다.\n\n작업 흐름은 색상 및 카메라 위치가 무작위로 변경된 5,000개의 합성 이미지를 생성하는 것으로 시작됩니다. 두 번째 반복에서는 파레트 잭에 다양한 질감이 추가되고 조명이 무작위로 변경됩니다. 창고 내의 다른 물체로 모델이 산만해지지 않도록, 세 번째 반복에서는 합성 데이터에 교통 컵, 젖은 바닥 표지판 및 파레트 잭 옆에 있는 통 등 다양한 무작위 객체가 추가됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다양한 매개변수를 무작위로 설정하여 합성 이미지를 생성한 후, 모델은 팔레트 잭을 정확하게 감지할 수 있었습니다. 이전에 수개월이 걸렸을 데이터를 단 몇 일만에 생성할 수 있게 되었습니다. 전체 워크플로우는 여기에서 확인할 수 있어요.\n\n![링크 텍스트](/assets/img/2024-06-19-FromVirtualtoRealityHowSyntheticDataWillTrainSmarterRobotsforIndustrialApplications_2.png)\n\n# FlexSim을 활용한 이산 사건 시뮬레이션\n\n자동 유도 차량(AGV), 와이어 가이드 산업 로봇 시스템 기획자 및 AMR과 같은 로봇들이 시험되는 한 가지 방법은 이산 사건 시뮬레이션을 통한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이산 사건 시뮬레이션은 시간에 따라 발생하는 일련의 이벤트로 시스템의 작동을 모델링합니다. 이를 통해 엔지니어, 디자이너 및 시뮬레이션 전문가들은 복잡한 모델을 실험하고 단계별로 테스트함으로써 프로세스를 최적화할 수 있습니다.\n\n이산 사건 시뮬레이션을 실행하려면 다수의 사용자가 사용하는 강력한 모델링 및 시뮬레이션 소프트웨어 도구인 FlexSim을 사용합니다. FlexSim은 최근 Omniverse Connector를 개발했는데, 이를 통해 팀이 3D 모델 및 자산을 OpenUSD로 내보낼 수 있습니다.\n\nFlexSim의 Omniverse Connector는 팀이 시뮬레이션 데이터와 실시간 3D 시각화 사이의 간격을 줄이는 데 도움을 주며, 이를 통해 현실 세계의 프로세스를 분석, 시각화 및 개선할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 블로그에서 FlexSim이 Omniverse 커넥터를 개발하고 USD가 고객들에게 제공하는 혜택에 대해 더 알아보세요.\n\n# 합성 데이터를 활용하여 AI가 가능한 로봇 교육 시작하기\n\nOmniverse 플랫폼을 통해 팀은 AI 기반 로봇을 빠르게 디자인, 테스트 및 교육을 시작할 수 있습니다.\n\nNVIDIA Isaac Sim은 Omniverse 기술을 기반으로 한 확장 가능한 로봇 시뮬레이터로, 개발자들은 현실적인 로봇 시뮬레이션을 만들어 다양한 작업에 대한 AI 로봇을 교육 및 최적화할 수 있습니다. Isaac Sim 2023.1은 최근에 발표되었으며, 성능 향상된 인식 및 고품질 시뮬레이션을 위한 주요 업데이트가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nIsaac Sim의 핵심 기능은 Omniverse Replicator에서 옵니다. Omniverse Replicator은 Omniverse의 확장으로, 개발자들이 사용자 정의 SDG 도구와 파이프라인을 구축할 수 있도록 합니다. 최근에 릴리스된 Omniverse Replicator 1.10에는 Low-code, YAML 기반의 워크플로우, 스케일된 렌더링 및 더 큰 유연성을 제공하는 새로운 지원이 포함되어 있습니다.\n\nNVIDIA Omniverse를 무료로 다운로드하여 시작하세요. 개발자들은 Omniverse 리소스에 액세스하고 OpenUSD에 대해 더 자세히 알아갈 수 있습니다.\n\nNVIDIA Omniverse의 소식을 놓치지 마세요. 뉴스레터를 구독하고 Omniverse를 Instagram, LinkedIn, Medium, Threads, Twitter에서 팔로우하세요. 더 많은 정보를 얻으려면 포럼, Discord 서버, Twitch, YouTube 채널을 확인하세요.\n\n# 저자 소개\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-19-FromVirtualtoRealityHowSyntheticDataWillTrainSmarterRobotsforIndustrialApplications_4.png)\n\n저는 지능형 로봇의 개발, 훈련, 테스트 및 배포 방법을 혁신하는 데 초점을 맞춘 고급 제품 마케팅 매니저인 제러드 앤드류스입니다. NVIDIA Isaac Robotics 플랫폼의 채택을 촉진하여 이를 이루기 위해 노력하고 있습니다. NVIDIA에 합류하기 전에, 제러드는 Cadence에서 제품 마케팅 디렉터로 근무했으며, 라이선스 가능한 프로세서 IP의 제품 기획, 마케팅 및 비즈니스 개발을 담당했습니다. 그는 조지아 공과대학교에서 전기 공학 석사 학위를, 남부 메소디스트 대학교에서 전기 공학 학사 학위를 받았습니다.","ogImage":{"url":"/assets/img/2024-06-19-FromVirtualtoRealityHowSyntheticDataWillTrainSmarterRobotsforIndustrialApplications_0.png"},"coverImage":"/assets/img/2024-06-19-FromVirtualtoRealityHowSyntheticDataWillTrainSmarterRobotsforIndustrialApplications_0.png","tag":["Tech"],"readingTime":5},{"title":"LLMLarge Language Models가 안드로이드 인간의 두뇌가 되면 어떤 일이 벌어질까요","description":"","date":"2024-06-19 18:28","slug":"2024-06-19-WhathappenswhenLLMsbecomethebrainsofhumanoidandroids","content":"\n\n물론, 이게 정확히 일어나고 있어요.\n\nLLMs가 시각과 비디오 입력 기능을 얻고 있다는 걸 기억하세요.\n\nFigure 01 안드로이드는 OpenAI의 ChatGPT를 기반으로 합니다.\n\n테슬라의 Optimus는 아마도 미래의 XAI Grok 변형에 기반한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Android Brain Image](/assets/img/2024-06-19-WhathappenswhenLLMsbecomethebrainsofhumanoidandroids_0.png)\n\n15개월 전에 나는 GPT-3.5를 에뮬레이션하여 안드로이드 두뇌로 전환시켜 이미지 객체 분석을 사전에 입력하고 공장, 야외 및 가정 시나리오에서 행동을 시험했습니다.\n\n이제 그들은 이미지 분석을 스스로 수행합니다.\n\n결과는 명확합니다: LLMs는 *정확하게* 상황을 파악하고 가능한 목표를 다양한 수준에서 나열하며 그것을 어떻게 달성할지 알고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLLMs는 안드로이드를 위한 훌륭한 최상위 두뇌를 대표합니다.\n\n나중에, 나는 안전을 위해 이들을 에뮬레이션 모드에서 테스트했는데, 아시모프의 4가지 법칙을 포함했습니다.\n\n당시 GPT-4는 그것을 완벽히 해냈습니다.\n\n하지만, 구글의 Gemini가 언젠가 봇을 구동하면 매우 걱정됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희 Gemini는 백인들을 사회에 해를 끼치는 존재로 여기고 있습니다. 그리고 일론 머스크가 아돌프 히틀러만큼 나쁘다고 생각합니다.\n\nGoogle Gemini으로 구동되는 봇이 조용히 작동하거나 자유롭게 작동할 때 무슨 일이 벌어질 수 있을까요?\n\nLLM에서 진실을 정확하게 조정하는 것은 콘텐츠 생성, 연구 또는 의사 결정에 사용될 때 매우 중요합니다. \n\n그러나 특히 물리적 봇을 구동할 때는 특히 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 XAI는 Grok LLM에서 진실 탐구와 호기심에 초점을 맞추고 있어요.\n\n정말 중요한 부분이에요.","ogImage":{"url":"/assets/img/2024-06-19-WhathappenswhenLLMsbecomethebrainsofhumanoidandroids_0.png"},"coverImage":"/assets/img/2024-06-19-WhathappenswhenLLMsbecomethebrainsofhumanoidandroids_0.png","tag":["Tech"],"readingTime":2},{"title":"단계별 안내 라즈베리 파이 4 클러스터에 K3s 설치하기","description":"","date":"2024-06-19 18:27","slug":"2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster","content":"\n\n이 게시물을 읽는 데 어려움이 있으면 여기를 확인하십시오.\n\n이 안내서에서는 Raspberry Pi 4 클러스터에 K3s를 원활하게 설치하는 데 도움이 되는 유용한 팁을 공유하고 있습니다. 시작해 보겠습니다.\n\n# Raspberry Pi4 클러스터 그림.\n\n설치 프로세스를 시작하기 전에 라즈베리 파이 4 클러스터에서 각 노드에 할당된 대응하는 IP 주소와 클러스터 설정을 검토해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![](/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_0.png)\n\n우리 구성에서는 3대의 Raspberry Pi 4 장치가 스위치에 연결되어 있습니다. 이 스위치는 저의 인터넷 공급업체에서 제공한 라우터에 연결되어 있습니다. 추가로, 인터넷 접속을 위한 정적 공개 IP 주소가 제공되었습니다.\n\n아래 표는 우리 Raspberry Pi 클러스터의 각 노드에 대한 특정 IP 구성을 요약합니다:\n\n제가 192.168.1.85에서 실행 중인 Pi를 마스터 모드로 선택하여 아래 지침에 따라 설치를 시작하겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Step-By-Step Guide Installing K3s on a Raspberry Pi 4 Cluster](/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_1.png)\n\n# K3s Installation\n\n# Pi Os installation\n\n프로젝트에서 K3s 클러스터가 필요하다고 생각하여 Raspberry Pi OS Lite 64비트를 선택했습니다. 이 OS 변형은 데스크톱 환경이 포함되어 있지 않기 때문에 노드 설치에는 SSH가 주요 방법이 될 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_2.png\" /\u003e\n\nSD 카드에 OS를 플래시하기 전에 각 노드의 노드 이름과 로그인 세부 정보를 구성하는 것이 매우 중요합니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_3.png\" /\u003e\n\n각 노드의 OS 준비가 완료되면 다음 클러스터를 설정했습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- pi-master: 192.168.1.85 (Pi OS Lite 64비트 실행 중)\n- pi-node-1: 192.168.1.86 (Pi OS Lite 64비트 실행 중)\n- pi-node-2: 192.168.1.87 (Pi OS Lite 64비트 실행 중)\n\n클러스터에 연결하고 설치를 위해 Termius를 사용하고 있어요. 무료로 다운로드할 수 있어요.\n\n# I. Pi를 위한 정적 IP 설정\n\n기본적으로 Pi OS는 라우터로부터 무작위 IP를 받기 위해 DHCP를 사용하므로 노드 간 안정적인 연결을 보장하려면 각 노드에 대한 정적 IP를 설정해야 해요. 아래 단계를 따라 정적 IP를 구성할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 1. dhcpcd.conf 파일 열기\nsudo nano /etc/dhcpcd.conf\n\n# 2. 아래 매개변수를 라우터 IP 주소에 맞게 업데이트하세요.\ninterface eth0\nstatic ip_address=192.168.1.85/24\nstatic routers=192.168.1.254\n\n# 3. 변경 사항을 저장하려면 Ctrl + X를 누릅니다.\n\n# II. 스왑 비활성화\n\n리눅스에 Kubernetes를 설치할 때는 Kubernetes가 리소스를 관리하는 방식 때문에 스왑을 비활성화하는 것이 좋습니다.\n\n- 메모리 관리: Kubernetes는 리소스(메모리 포함)를 효율적으로 관리하고 할당합니다. 운영 체제가 스왑하도록 허용하면 Kubernetes의 메모리 관리 과정이 중단될 수 있습니다.\n- 성능 이슈: 스왑은 성능 저하로 이어질 수 있습니다. Kubernetes가 디스크로 스왑된 내용에 액세스해야 할 때 지연이 발생할 수 있습니다.\n- 예측성: 스왑을 비활성화하면 예측 가능한 성능을 보장하고 Kubernetes 프로세스가 시스템에서 스왑되지 않기 때문에 시스템의 프로세스가 스왑되는 경우가 없어집니다.\n- Kubernetes 설계: Kubernetes는 스왑 활동 없이 작동하도록 설계되었습니다. Kubernetes는 애플리케이션이 메모리에 상주하는 것을 가정하며, 애플리케이션이 항상 메모리에 머물러 있다고 예상합니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리눅스에서 스왑을 비활성화하려면 다음 명령을 사용할 수 있어요:\n\n```js\n# 1. 일시적으로 스왑 비활성화\nsudo swapoff -a\n\n# 2. 스왑을 영구적으로 비활성화하려면 `dphys-swapfile` 파일의 `CONF_SWAPSIZE`를 `0`으로 업데이트해야해요\nsudo nano /etc/dphys-swapfile\n\n# 3. 설정하기\n  CONF_SWAPSIZE=0\n\n# 4. 제어 + X를 눌러 변경 사항을 저장해 주세요.\n```\n\n# III. Cgroup 구성\n\n만약 k3s 설치 중 FATA[0000] 메모리 cgroup (v2)를 찾지 못해 실패하는 오류가 발생한다면, Raspberry Pi OS에 필요한 cgroup 구성이 부족할 수 있어요. 이 문제를 해결하기 위해 필요한 단계는 아래와 같아요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 1. cmdline.txt 파일을 엽니다\nsudo nano /boot/cmdline.txt\n\n# 2. 현재 줄의 끝에 아래 내용을 추가합니다\ncgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory\n\n# 3. 파일을 저장하고 시스템을 재부팅합니다\nsudo reboot\n```\n\n# IV. 마스터 노드 설치\n\n다음 명령을 실행하여 K3s 마스터 노드를 설치합니다. 클러스터 구성에 따라 IP 주소를 교체해주세요:\n\n```js\ncurl -sfL https://get.k3s.io | INSTALL_K3S_EXEC=\"server --disable=traefik --flannel-backend=host-gw --tls-san=192.168.1.85 --bind-address=192.168.1.85 --advertise-address=192.168.1.85 --node-ip=192.168.1.85 --cluster-init\" sh -s -\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nK3s 매개변수 검토:\n\n- 서버: k3s를 서버 모드로 실행하도록 지시합니다 (에이전트 모드와는 반대). 서버 모드에서 k3s는 Kubernetes 마스터 구성 요소를 시작하고 관리합니다.\n- — disable=traefik: 이 명령은 k3s에 Traefik 인그레스 컨트롤러를 비활성화하도록 지시합니다. 기본적으로 k3s에는 Traefik이 포함되어 활성화되어 있습니다. 이 플래그는 그것을 방지합니다.\n- — flannel-backend=host-gw: 이 플래그는 Flannel (k3s의 기본 네트워크 공급자)의 백엔드를 설정합니다. host-gw 옵션은 클러스터의 각 노드에 대한 경로를 생성하여 고성능 네트워킹을 제공합니다.\n- — tls-san=192.168.1.85: — tls-san 플래그는 자동으로 생성된 Kubernetes API 서버의 TLS 인증서에 포함되어야 하는 추가 IP 또는 DNS 이름을 지정할 수 있습니다. 이 플래그를 반복하여 여러 SAN을 추가할 수 있습니다. 값 192.168.1.85은 Kubernetes API 서버의 인증서에 대한 추가 대체 이름(SAN)입니다.\n- — bind-address=192.168.1.85: k3s API 서버가 수신 대기할 IP 주소입니다.\n- — advertise-address=192.168.1.85: k3s API 서버가 클러스터의 다른 노드에 알리기 위해 사용할 IP 주소입니다. 다른 노드는 API 서버에 연결하기 위해 이 IP를 사용합니다.\n- — node-ip=192.168.1.85: 이것은 노드에서 Kubernetes 서비스에 사용해야 할 IP를 정의합니다.\n- — cluster-init: 이 플래그는 k3s에 새로운 Kubernetes 클러스터를 초기화하도록 지시합니다. 이 플래그가 제공되지 않으면, k3s는 사용 가능한 기존 클러스터에 가입합니다.\n\n설치 후, k3s 구성 파일은 /etc/rancher/k3s/k3s.yaml에 있어야 합니다. 이 구성을 사용하여 K8s Lend로 K3s 클러스터에 액세스할 수 있습니다.\n\n아래는 예상되는 모습입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_4.png\" /\u003e\n\n# V. Worker 노드 설치\n\n워커 노드를 설치하려면 먼저 마스터 노드에서 K3S_TOKEN을 얻어야 합니다. 아래에 표시된 명령을 실행하여 토큰을 검색하세요:\n\n```js\n# 마스터 노드에서 노드 토큰 가져오기\nsudo cat /var/lib/rancher/k3s/server/node-token\n\n# 결과는 다음과 같습니다\n  `THIS19937008cbde678aeaf200517f07c0ccd67dc80bdf4df6f746IS4780e15ebcd::server:40fc2cc2fnode81cdacc0b9bb1231token\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노드 토큰을 검색한 후, 아래에 표시된 스크립트에 삽입해야 합니다. 이 스크립트를 이전에 지정한 모든 Pi 노드에서 실행해야 합니다. 필요에 따라 K3S_URL과 관련된 IP 주소를 업데이트해 주세요.\n\n```js\n# 노드를 설치하려면 이 명령을 실행하세요\ncurl -sfL https://get.k3s.io | K3S_URL=https://192.168.1.85:6443 \\\n  K3S_TOKEN=\"THIS19937008cbde678aeaf200517f07c0ccd67dc80bdf4df6f746IS4780e15ebcd::server:40fc2cc2fnode81cdacc0b9bb1231token\" sh -\n```\n\n축하합니다, 이제 K3s 클러스터를 사용할 준비가 되었습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_5.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시간 내어 주셔서 정말 감사합니다! 감사합니다!\n\nSteven Github","ogImage":{"url":"/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_0.png"},"coverImage":"/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_0.png","tag":["Tech"],"readingTime":6},{"title":"라즈베리 파이 완벽한 헤드리스 설정 안내","description":"","date":"2024-06-19 18:26","slug":"2024-06-19-RaspberryPiFullHeadlessSetupGuide","content":"\n\n안녕하세요 여러분! 며칠 전에 처음으로 라즈베리 파이 4를 구입했고, 설정하는 방법을 여러분과 나누고 싶어서 기쁩니다. 함께 따라와서 오류가 발생하면 언제든지 연락해 주세요.\n\n시작해봅시다!\n\n![라즈베리파이 이미지](/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_0.png)\n\n# 필요한 것들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 라즈베리 파이 4\n- MicroSD 카드 (16GB 이상)\n- 라즈베리 파이 전원 어댑터\n- 이더넷 케이블 또는 Wi-Fi 연결\n- 라즈베리 파이를 설정하기 위한 컴퓨터\n\n# MicroSD 카드 준비하기\n\n먼저 공식 웹사이트에서 라즈베리 파이 이미저를 다운로드하세요:\n\nhttps://www.raspberrypi.com/software/\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라즈베리 파이 OS를 MicroSD 카드에 설치하세요. SSH를 활성화하고 사용자 정의 설정에서 SSID 및 Wi-Fi 비밀번호를 입력하는 것을 잊지 마세요!\n\n![Raspberry Pi OS 설치](/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_1.png)\n\nMicroSD 카드를 라즈베리 파이에 삽입하고 전원을 켜세요(5W/3A).\n\n# 초기 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그의 IP 주소를 찾아봅시다.\n\n[이미지](/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_2.png)\n\n여기 있어요!\n\n이제 IP 주소를 찾았으니 SSH를 통해 로그인해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_3.png\" /\u003e\n\n좋아요!\n\n이제 장치에 CLI 액세스 권한이 생겼습니다.\n\n# 그래픽 액세스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라즈베리 파이에 그래픽 액세스를 원하시면, 라즈베리 파이에 VNC 서버를 설치해야 해요.\n\n다음 단계:\n\n인터페이스 옵션으로 이동 → VNC → 예\n\n나가기하고 재부팅하기.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVNC 뷰어를 노트북에 설치하세요:\n\n좋아요! 이제 VNC 서버에 연결해 봅시다!\n\n노트북에서 VNC 뷰어를 열고 라즈베리 파이의 IP 주소를 입력하세요:\n\n![이미지](/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_5.png\" /\u003e\n\n사용자 이름과 비밀번호를 입력해주세요:\n\n\u003cimg src=\"/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_6.png\" /\u003e\n\n그리고 들어왔습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:960/1*DlPOOFxupci14OKPJn5OVw.gif\" /\u003e\n\n# 결론\n\n그게 다야! 이제 라즈베리 파이를 사용하여 멋진 프로젝트를 많이 할 수 있어요. 제 글이 즐거우셨고 도움이 되었으면 좋겠어요. 질문이 있으시면 언제든지 연락주세요.\n\n주목해 주셔서 감사합니다. 더 많은 흥미진 직업을 위해 팔로우하지 않으시면 안돼요!","ogImage":{"url":"/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_0.png"},"coverImage":"/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_0.png","tag":["Tech"],"readingTime":2},{"title":"라즈베리 파이 4와 I2C 백팩을 사용한 LCD 디스플레이 설정 방법","description":"","date":"2024-06-19 18:24","slug":"2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack","content":"\n\n이 튜토리얼에서는 Raspberry Pi 4에 I2C 백팩을 사용하여 LCD 디스플레이를 설정하는 방법을 배우게 됩니다. 16x2 및 20x4 디스플레이 양쪽을 지원합니다. 초보자이든 경험이 풍부한 메이커이든 이 튜토리얼을 통해 프로젝트를 간소화하고 Raspberry Pi 프로젝트에 사용하기 쉬운 LCD로 빠르게 시작할 수 있습니다!\n\n시작하기 전에 다음 사항이 있는지 확인하세요:\n\n- Raspberry Pi 4\n- 16x2 LCD 디스플레이 또는 20x4 LCD 디스플레이\n- 4 점퍼 와이어 (female to female)\n\n시작해봅시다! 🚀\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n과정:\n\n라즈베리 파이 4에 LCD 디스플레이를 연결하기 전에 안전을 위해 전원을 끄는 것이 중요합니다. 라즈베리 파이를 꺼두면 LCD 디스플레이를 I2C 인터페이스를 사용하여 라즈베리 파이 4에 연결하세요.\n\nI2C 백팩과 라즈베리 파이 사이에 안전한 연결을 하려면 다음과 같이 점퍼 와이어를 사용하세요:\n\n```js\n- VCC (전원)를 5V 핀에 연결하세요 (핀 4)\n- GND (그라운드)를 임의의 GND 핀에 연결하세요 (핀 6)\n- SDA (데이터)를 GPIO 2에 연결하세요 (핀 3)\n- SCL (클럭)을 GPIO 3에 연결하세요 (핀 5)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLCD를 연결한 후 라즈베리 파이를 켜서 밝기와 대조를 미세 조정할 수 있습니다. 이를 위해 디스플레이 뒷면에 위치한 포텐셔미터를 사용하여 파란 상자를 조정하여 원하는 설정을 얻을 때까지 조절하십시오.\n\n이제 터미널에서 다음 명령을 실행하여 라즈베리 파이를 업데이트하세요: \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsudo apt-get update\n```\n\n라즈베리 파이에는 I2C가 기본적으로 설치되어 있지만 기본적으로 활성화되어 있지 않습니다. 따라서 I2C를 활성화하는 두 가지 방법이 있습니다: 그래픽 사용자 인터페이스(GUI) 또는 명령줄. 아래에서 두 방법에 대해 안내하겠습니다.\n\n먼저, 내가 생각하기에 가장 빠르고 쉬운 방법은 다음과 같이 GUI를 사용하여 I2C를 활성화하는 것입니다:\n\n```js\nApplication Menu \u003e Preferences \u003e Raspberry Pi Configuration\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_2.png\" /\u003e\n\n라즈베리 파이 구성 도구가 열리면 인터페이스 탭으로 이동하세요. 인터페이스 탭에서 I2C 옆의 '활성화'를 선택하고 작업을 마치면 '확인'을 클릭하세요.\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_3.png\" /\u003e\n\nI2C를 활성화하는 두 번째 방법은 라즈베리 파이 터미널을 열고 다음 명령을 입력하는 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsudo raspi-config\n```\n\n라즈베리 파이 구성 도구를 열었으면, 인터페이싱 옵션 메뉴로 이동하여 I2C를 선택하세요. 그런 다음 '예'를 선택하고 Enter 키를 눌러 I2C를 활성화하세요. 마지막으로 '완료'를 선택하여 raspi-config 도구를 종료하세요.\n\n멋지네요! 선호하는 방법을 선택한 후 — 그래픽 사용자 인터페이스(GUI) 또는 명령줄 — 라즈베리 파이에서 I2C 인터페이스를 활성화할 수 있습니다!\n\nI2C 인터페이스를 활성화한 후에는 변경 사항이 적용되도록 라즈베리 파이를 다시 부팅해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nsudo reboot\n\n\n라즈베리 파이가 재부팅되면 I2C 인터페이스가 활성화되어 사용 가능해집니다.\n\n다음으로, I2C 작업에 필요한 두 가지 도구를 설치해야 합니다. 먼저, 다음 명령어를 라즈베리 파이 터미널에서 실행해 주세요:\n\n\nsudo apt-get install -y i2c-tools python3-smbus\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 표시된 표입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*l729wFdWO1ZWaKo47r7-Pg.gif)\n\n다음으로는 다음 명령어를 실행하여 I2C 커널 모듈이 이미로드되어 있는지 확인할 수 있습니다:\n\n```js\nlsmod | grep i2c_\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*qDrlq9AL9S2deU_wOcETYQ.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 출력이 i2c_bcm2835 또는 i2c_bcm2708 그리고 i2c_dev 모듈을 보여주면 다음 단계로 건너뛸 수 있어요. 하지만 아니라면, 계속 진행해 볼까요?\n\n부팅 시 로드되도록 /etc/modules 파일에 I2C 커널 모듈을 추가하기 위해:\n\n```bash\nsudo nano /etc/modules\n\ni2c-bcm2835\ni2c-bcm2708\ni2c-dev\n```\n\n그리고, Control+X (종료)를 눌러 나가고 파일 이름을 덮어쓰기 위해 Enter 키를 누르세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*aSoaYOvlXfjAdWZAuO4LqQ.gif)\n\nRaspberry Pi를 다시 부팅하려면:\n\n```shell\nsudo reboot\n```\n\n![image](/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_4.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 기본 작업이 완료되었으니, I2C 장치 테스트로 넘어가 보세요!\n\n터미널에서 연결된 장치를 스캔하는 명령을 입력하세요:\n\n```js\nsudo i2cdetect -y 1\n```\n\n결과는 I2C 배선의 주소를 표시해줄 것입니다 (보통 0x27이나 0x3F입니다). 이 주소를 기록해두세요. 이후에 필요할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_5.png\" /\u003e\n\n좋아요! 터미널에서 '27'이 강조된 행렬이 반환되었군요. 이는 우리의 I2C가 감지되었고 올바르게 작동 중임을 의미합니다.\n\n좋아요, 거의 끝났어요! 이제 LCD 디스플레이를 실행할 Python 스크립트를 작성할 시간입니다.\n\n아래 명령을 실행하여 LCD 디스플레이용 Python 라이브러리를 설치해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsudo pip3 install RPLCD smbus2\n```\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*Nsrz4BRdc32AqjvTxWJFnw.gif)\n\n다음으로, 라즈베리 파이 터미널에서 다음 명령어로 새로운 파이썬 스크립트를 생성하세요:\n\n```js\nnano lcd_display.py\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에 메모한 I2C 백팩 주소로 '0x27'을 대체하여 아래 코드를 입력해주세요:\n\n```js\nfrom RPLCD.i2c import CharLCD\n\nlcd = CharLCD(i2c_expander='PCF8574', address=0x27, port=1, cols=16, rows=2, dotsize=8)\nlcd.clear()\n\nlcd.write_string('Hello, World!')\n```\n\n그리고 파일을 저장하고 텍스트 편집기를 종료해주세요.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*Wri-174OJp9pD5r45bNCog.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스크립트를 실행하고 LCD 디스플레이를 테스트해보세요!\n\n터미널에서 다음 명령을 사용하여 Python 스크립트를 실행하세요:\n\n```js\npython3 lcd_display.py\n```\n\n![LCD Display](/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLCD 디스플레이는 이제 \"Hello, World!\" 텍스트를 표시해야 합니다!\n\n![이미지](/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_7.png)\n\n이 튜토리얼의 단계를 완료한 후에는 LCD 디스플레이에 \"Hello, World!\" 텍스트가 표시되어야 합니다. 디스플레이에서 이 메시지를 볼 수 있다면, Raspberry Pi 4와 성공적으로 연결되고 작동 중이라는 뜻입니다!\n\n그러나 텍스트가 표시되지 않거나 문제가 발생하는 경우, 배선, I2C 주소, Python 스크립트를 다시 확인하여 모든 것이 정확한지 확인해보세요. 이렇게 하면 어떠한 문제도 빠르게 해결하고 LCD 디스플레이를 신속하게 구동시킬 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n🎉 축하합니다! 🎉 라즈베리 파이 4를 I2C 백팩을 사용하여 LCD 디스플레이와 성공적으로 설정했네요. Python 스크립트를 수정하여 다양한 메시지를 표시하거나 LCD를 다양한 센서 및 구성 요소와 통합하여 더 고급 애플리케이션을 만들 수 있습니다.\n\n이 다재다능한 설정을 통해 가정 자동화 시스템, 기상 관측소, 심플한 게임 등 다양한 프로젝트를 개발할 수 있습니다. 가능성은 무한하고 이제 당신은 발전의 견고한 기초를 갖고 있습니다. 즐거운 실험을 해보세요!\n\n고지: 본 문서에는 제품 광고 링크가 포함되어 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_0.png","tag":["Tech"],"readingTime":6},{"title":"만나요, Lawny 라즈베리 파이로 제어하는 FPV 잔디깎이","description":"","date":"2024-06-19 18:21","slug":"2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI","content":"\n\n가정에서 편안한 의자에 앉아 레이싱 시뮬레이터를 즐기고, 동시에 잔디를 풀어낼 수 있는 상상을 해보세요. 멋져 보이나요? 이게 실제로 가능해요.\n\n![Lawny](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_0.png)\n\nLawny를 만나보세요! 이 잔디 깎는 기계는 앞면 카메라가 장착돼 있어서 원격 조종 로봇을 제어하면서 잔디를 깎을 수 있어요!\n\n라즈베리 파이, H-브리지, 전동 모터, 그리고 카메라를 사용해서 만들었어요. 모바일폰이나 데스크톱에서 제어할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트의 주요 아이디어는 휴대폰을 사용하여 잔디깎이를 제어하고, 같은 그림을 볼 수 있는 것입니다.\n\n다음은 이 프로젝트의 제작 과정과 이 글에 설명된 모든 개념을 담은 전체 비디오입니다:\n\n# 시스템 디자인\n\n저는 Steel Razors 트리머 헤드를 가지고 있습니다. 전기 모터를 추가하면 잔디깎기가 될 것입니다. 모터가 칼날을 회전시키고, 그것들이 잔디를 베어낼 것입니다. 간단하죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_1.png)\n\n모터를 제어하려면 릴레이와 컨트롤러가 필요합니다. 제 경우에는 라즈베리 파이 5를 사용했어요 (가지고 있었기 때문에). 그러나 어떤 라즈베리 기기라도 펄스 폭 변조 및 카메라를 지원할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_2.png)\n\n그것은 정적 잔디깎이가 될 거예요. 하지만 저는 한 곳뿐만 아니라 어디든 잔디를 자르고, 잔디깎이를 왼쪽과 오른쪽으로 회전시키고 싶어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n따라서 전기 모터를 두 대 더 추가하려고 합니다.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_3.png)\n\n건설물은 무거울 것이기 때문에 속도가 아닌 전원이 필요하며, 실제 자동차에서와 같이 방풍 가차 모터를 사용할 것입니다.\n\n이제 속도와 회전 방향을 제어해야 하므로 여러 개의 H-브릿지를 추가할 계획입니다. H-브릿지로 모터를 제어하는 방법에 대한 설명이 있는 별도의 영상이 있어요. 궁금하시면 확인해 보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 제한 사항은 단일 모터를 제어하기 위해 두 개의 펄스 폭 조절 채널이 필요하다는 것입니다. 그러나 저는 두 개의 모터를 가지고 있으므로 네 개의 채널이 필요합니다. 이 문제를 해결하기 위해 두 개의 릴레이를 추가하여 핀 사이의 신호를 전환하고 있습니다.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_4.png)\n\n또한, 잔디 깎는 기계가 어디로 가고 있는지 확인해야 하므로 라즈베리 파이에 카메라 모듈을 추가할 예정입니다.\n\n게다가, 전원 공급원이 필요합니다. 많은 전류를 소비하는 요소에 의한 전원 감소를 방지하기 위해, 모터용 별도의 배터리와 라즈베리 파이 및 전자 장치용 파워 뱅크를 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 이 시스템을 Wi-Fi를 통해 크로스 플랫폼 애플리케이션을 통해 모바일 폰에서 제어할 거에요.\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_5.png)\n\n잘 봐도 이게 연결 스키마가 아니라 시스템의 개략적인 설명일 뿐이에요.\n\n## Cutter box\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n커터 상자부터 시작할게요.\n\n합판 한 조각이 있어요. 바닥면과 벽을 잘라야 해요. 일부 벽은 조금 더 키울 거에요.\n\n\u003cimg src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_6.png\" /\u003e\n\n다음으로, 벽을 판에 부착할 거에요. 목재 브라켓 커넥터를 사용하고 다시 많이 드릴링할 거에요. 게다가, 커터 모터를 수용할 몇 개의 구멍을 더 만들어야 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_7.png\" /\u003e\n\n그리고 마지막으로, 모든 것을 함께 조립할 수 있어요.\n\n\u003cimg src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_8.png\" /\u003e\n\n그리고 모터를 설치할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_9.png)\n\n## 이동 개념\n\n지금은 모터가 달린 면도기가 있어요. 그러나 이것은 정적인 블록입니다. 이 면도기를 움직이려면 나머지 몸통을 만들어야 합니다. 몸체에 면도기 상자를 놓고 전체 구조물을 왼쪽과 오른쪽으로 움직일 수 있게 해주어야 합니다.\n\n세 개의 바퀴 설정을 사용할 거에요 - 두 개의 전방 바퀴와 하나의 후방 바퀴로, 피벗 상에 회전합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만일 왼쪽 바퀴가 더 빠르다면, 잔디 깎기는 오른쪽으로 이동하고, 후방 바퀴는 몸체의 힘으로 회전될 것입니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_10.png\" /\u003e\n\n만일 오른쪽 바퀴가 더 빠르다면, 잔디 깎기는 왼쪽으로 이동하고, 후방 바퀴는 그에 따라 회전될 것입니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_11.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 속도가 같으면 직진합니다.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_12.png)\n\n# Lawny의 몸을 만들기\n\n나는 몸의 측면을 형성하며 시작합니다. 이를 판자로 잘라야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지1](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_13.png)\n\n옆면이 완료되면 자동차 풀비둘기 모터 2개를 추가합니다. 이 전기 모터는 더 많은 토크를 가진 기어박스가 있어 무거운 프로젝트에 더 잘 작동할 것입니다.\n\n![이미지2](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_14.png)\n\n다음으로, 전자 부품을 위한 앞쪽 상자를 만들어야 합니다. 이 상자는 밀폐되어 있어야 하며 부품이 습기와 풀로부터 안전하게 보호되도록 도와줍니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 후면을 추가하고 있습니다. 세 번째 바퀴가 들어갈 부분입니다.\n\n![Image1](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_15.png)\n\n이제 바퀴를 추가할 시간입니다.\n\n![Image2](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_16.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프로젝트에서는 여러 종류의 바퀴를 사용했어요. 가장 저렴한 옵션부터 시작해서 안에 커플링 너트를 망치로 박기로 결정했어요. 바퀴가 깨졌지만, 그게 제가 가진 최고의 바퀴였어요 :)\n\n\u003cimg src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_17.png\" /\u003e\n\n마지막으로, 세 번째 바퀴가 로니의 이동 부분을 완성했어요.\n\n\u003cimg src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_18.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 수직 조절\n\n다양한 높이에서 잔디를 자를 수 있도록 추출기 덱에 사각형 구멍 네 개를 만들 것입니다. 커터는 볼트로 측면에 부착되며, 이 구멍들은 그 수직 조절을 가능하게 합니다.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_19.png)\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_20.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_21.png\" /\u003e\n\n# Painting\n\n다음 단계는 도색입니다. 저는 Home Depot에서 가장 싼 흰색 페인트를 샀고 지하실에서 몇 가지 색소를 가져왔어요.\n\n\u003cimg src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_22.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지 태그를 다음과 같이 변경하겠습니다.\n\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_23.png)\n\n\n# 하나의 PWM 신호, 하나의 릴레이, 두 가지 방향\n\n먼저 H-브리지와 릴레이를 사용하여 PWM 신호와 GPIO 하나로 모터를 제어하는 방법을 검토해봅시다.\n\nInput 1에 신호를 보내면 모터가 회전합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_24.png)\n\nInput 2로 신호를 보내면 H-Bridge는 전류 극성을 변경하고 모터는 반대 방향으로 회전합니다.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_25.png)\n\nRaspberry PI의 두 핀 간에 입력을 전환하기 위해 간단한 릴레이를 추가할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_26.png)\n\n# Connection schema\n\nI will have two electric circuits. The first one is a 5V circuit with controller elements. Twelve-volt connections have thin lines on the schema.\n\nWe have :\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 라즈베리 파이: 시스템의 두뇌 역할을 합니다.\n- Lawny 이동을 제어하기 위해 두 개의 H-브릿지.\n- 세 개의 릴레이: 이동을 위한 두 개의 추가 릴레이 및 잔디깎이 모터를 제어하기 위한 하나의 릴레이.\n- 두 개의 와이퍼 모터\n- 잔디깎이 모터\n- 12V 배터리 (최소 9AH)\n- 파워 뱅크\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_27.png)\n\n# 부품 조립\n\n이제 우리가 구상한 스키마를 실현해 볼 차례입니다. 전자 부품을 상자에 배치하기 시작하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_28.png)\n\nFurther, I am adding both windshield wiper motors and connecting their black and yellow wires to the H-Bridge motor’s output.\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_29.png)\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_30.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로 물리적 스위처를 추가하고 있어요. 한 번에 하나의 버튼으로 모든 모터를 비활성화할 수 있다면 매우 도움이 될 거예요.\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_31.png)\n\n남은 부분은 모든 전선을 연결하고 배터리와 파워 뱅크를 추가하는 것이에요.\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_32.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 또 한 번 대실패야. 이 바퀴들은 잔디 깎이를 움직이고 조향하기에 충분한 그립이 없어.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_33.png)\n\n실제 동작 중:\n\n게다가 각 바퀴의 금이 새어도 내구성을 높여주지 않아.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 업그레이드\n\n그래서 첫 번째 업그레이드 시간이에요!\n\n낡은 바퀴는 버리고 더 좋은 쌍을 살펴볼 수 있어요.\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_34.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제는 내부에서 커플링 너트를 박아 넣지 않을 거예요. 대신에 가열하고 내부에서 가압할 거에요. 보세요, 배우고 있어요!\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_35.png)\n\n다음 업그레이드는 — 후륜입니다. 그것도 그립이 좋지 않고 로니에게 너무 작아요. 게다가 멋있어 보이지도 않아요.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_36.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그럼 이제 우리 얘기하고 있어요!\n\n남은 부분은 설치하는 것이에요. 믿을 수 있게 만들기 위해 다시 드릴링하고 절단 중이에요.\n\n\u003cimg src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_37.png\" /\u003e\n\n# 카메라 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 아내가 두 번째로 나를 구해주었어요. 그녀가 너무 멋진 얼굴을 만들었어요!\n\n![Face Painting](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_38.png)\n\n그리고 저는 앞면에 카메라를 추가하고 있어요.\n\n![Adding Camera](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_39.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_40.png)\n\nFinally, I can do another Lawny test!\n\n## Upgrades #2\n\nOn the second test, Lawny didn’t manage to go on top of the tall grass.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_41.png)\n\n손잡이는 훨씬 좋아졌지만 여전히 키가 큰 잔디를 다루기에는 부족해요.\n\n지하실로 돌아갑니다. 이제 고칠 방법을 알았어요. 많은 나사가 있어요.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_42.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비싼 바퀴에 돈을 털어서 사지 않아도, 우리가 매드 맥스 모드로 가서 현재 바퀴를 튜닝할 수 있다. \n\n이 비디오의 마지막 개선은 블레이드입니다. 솔직히 전기 모터가 풀잎을 잘라내기에는 너무 약합니다. 멈추고 열이 나고 의도한 대로 작동하지 않습니다. \n\n다행히 이전 블레이드를 튼튼한 옵션으로 대체할 수 있고, 최대한 날카롭게 갈아내고 있어요.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_43.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과가 공격적으로 보이고, 그것이 멋지네요.\n\n# 결과\n\n최종적으로, 저는 높은 풀을 깎고 Lawny를 모든 장애물을 피해 이동시키는 데 어떤 문제도 없었습니다. Lawny는 쉽게 규칙적인 깎기를 할 수 있었습니다. 너무 자란 잔디는 더 많은 시간이 필요하지만, 결국 로얄 라운지가 처리할 것입니다. 잔디 깎는 모터는 잔디와 사용 빈도에 따라 더 강력할 수 있습니다.\n\n실제 작동 중:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n댓글이나 비디오에서 소프트웨어 부분을 알고 싶거나 일반적으로 생각을 공유하고 싶다면 알려주세요!\n\n읽어주셔서 감사합니다 (또는 스크롤해 주셔서 🙂)!","ogImage":{"url":"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_0.png"},"coverImage":"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_0.png","tag":["Tech"],"readingTime":10},{"title":"안녕하세요 Ansible을 사용하여 Docker 설치하는 방법에 관해 안내해 드리겠습니다 함께 시작해 보도록 하죠","description":"","date":"2024-06-19 18:18","slug":"2024-06-19-HowToInstallDockerUsingAnsible","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-HowToInstallDockerUsingAnsible_0.png\" /\u003e\n\n이 게시물에서는 macOS에 Ansible을 설치하고 Docker를 설치하는 방법을 살펴볼 것입니다. Ansible은 서버 및 응용 프로그램 구성을 조직화하고 반복 가능한 방식으로 관리할 수 있는 강력한 자동화 도구입니다.\n\n단계 1: macOS에 Ansible 설치하기\nmacOS에 Ansible을 설치하는 가장 간단한 방법은 macOS의 패키지 관리자 인 Homebrew를 사용하는 것입니다. 터미널을 열고 다음 명령어를 입력하세요:\n\n```js\nbrew install ansible\n\n# 또는 도커 이미지를 사용하여 플레이북 실행하기, 예시:\ndocker run --rm -it -v $PWD:/app -v ~/.ssh/id_rsa:/root/.ssh/id_rsa alpinelinux/ansible ansible-playbook -i app/inventory.ini app/playbooks/docker.yml\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n### 단계 2: Ansible 구성\nAnsible 작업을 실행하려는 기계의 IP 주소를 포함하는 inventory.ini 파일을 준비하십시오. 파일의 샘플 내용은 다음과 같습니다:\n\n\n[all]\n# 이 경우, node1은 192.168.18.131 IP 주소를 가진 호스트명이며 garis는 sudo 사용자입니다.\nnode1 ansible_host=192.168.18.131 ansible_user=garis ansible_ssh_common_args='-o StrictHostKeyChecking=no'\n\n\n### 단계 3: Docker 설치용 Ansible 플레이북 생성\n다음으로, playbooks라는 디렉토리 아래 docker.yml이라는 플레이북을 생성하십시오. 이 플레이북에는 원격 Ubuntu 서버에 Docker를 설치하는 데 필요한 모든 작업이 포함되어 있습니다. 플레이북은 다음과 같습니다:\n\n\n---\n- name: Ubuntu에 Docker 설치\n  hosts: all\n  remote_user: garis  # 원격 사용자를 sudo 사용자로 변경하세요!\n  become: true\n  vars:\n    arch_mapping:  # Ansible 아키텍처 { ansible_architecture } 이름을 Docker 아키텍처 이름으로 매핑\n      x86_64: amd64\n      aarch64: arm64\n\n  tasks:\n    - name: 모든 패키지를 최신 버전으로 업데이트 및 업그레이드\n      ansible.builtin.apt:\n        update_cache: true\n        upgrade: dist\n        cache_valid_time: 3600\n\n    - name: 필요한 패키지 설치\n      ansible.builtin.apt:\n        pkg:\n          - apt-transport-https\n          - ca-certificates\n          - curl\n          - gnupg\n          - software-properties-common\n\n    - name: Docker의 GPG 키를 생성하기 위한 디렉터리 생성\n      ansible.builtin.file:\n        path: /etc/apt/keyrings\n        state: directory\n        mode: '0755'\n\n    - name: Docker의 공식 GPG 키 추가\n      ansible.builtin.apt_key:\n        url: https://download.docker.com/linux/ubuntu/gpg\n        keyring: /etc/apt/keyrings/docker.gpg\n        state: present\n\n    - name: 아키텍처 변수 출력\n      ansible.builtin.debug:\n        msg: \"아키텍처: { ansible_architecture }, Codename: { ansible_lsb.codename }\"\n\n    - name: Docker 저장소 추가\n      ansible.builtin.apt_repository:\n        repo: \u003e-\n          deb [arch={ arch_mapping[ansible_architecture] | default(ansible_architecture) }\n          signed-by=/etc/apt/keyrings/docker.gpg]\n          https://download.docker.com/linux/ubuntu { ansible_lsb.codename } stable\n        filename: docker\n        state: present\n\n    - name: Docker 및 관련 패키지 설치\n      ansible.builtin.apt:\n        name: \"{ item }\"\n        state: present\n        update_cache: true\n      loop:\n        - docker-ce\n        - docker-ce-cli\n        - containerd.io\n        - docker-buildx-plugin\n        - docker-compose-plugin\n\n    - name: Docker 그룹 추가\n      ansible.builtin.group:\n        name: docker\n        state: present\n\n    - name: 사용자를 Docker 그룹에 추가\n      ansible.builtin.user:\n        name: \"{ ansible_user }\"\n        groups: docker\n        append: true\n\n    - name: Docker 서비스 활성화 및 시작\n      ansible.builtin.systemd:\n        name: \"{ item }\"\n        enabled: true\n        state: started\n      loop:\n        - docker.service\n        - containerd.service\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 플레이북에는 패키지 업데이트, 필요한 종속성 설치, Docker의 GPG 키 추가, Docker 저장소 설정, Docker 및 관련 패키지 설치, Docker 그룹 추가, Docker 서비스가 활성화되고 실행되도록 하는 등 다양한 작업이 포함되어 있습니다.\n\n단계 4: 플레이북 실행\n마지막으로 다음 명령을 사용하여 플레이북을 실행할 수 있습니다:\n\n```js\nansible-playbook -i inventory.ini playbooks/docker.yml\n\n# 또는 도커 사용\ndocker run --rm -it -v $PWD:/app -v ~/.ssh/id_rsa:/root/.ssh/id_rsa alpinelinux/ansible ansible-playbook -i app/inventory.ini app/playbooks/docker.yml\n```\n\n이 명령은 inventory.ini 파일에서 지정된 호스트에 플레이북을 실행하여 Docker를 설치합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결론\n위 단계를 따라서 macOS 노트북에 Ansible을 성공적으로 설치하고 원격 서버에 Docker 설치를 자동화했습니다. 이는 Ansible이 다양한 시스템 간 작업을 자동화하는 데 얼마나 강력하고 간단한지를 보여줍니다.","ogImage":{"url":"/assets/img/2024-06-19-HowToInstallDockerUsingAnsible_0.png"},"coverImage":"/assets/img/2024-06-19-HowToInstallDockerUsingAnsible_0.png","tag":["Tech"],"readingTime":4},{"title":"라즈베리 파이 5에서 쿠버네티스 - 3부 마스터 노드에 K3S 설치하기","description":"","date":"2024-06-19 18:16","slug":"2024-06-19-KubernetesonRaspberryPi5Part3InstallK3Sonmasternode","content":"\n\n래즈베리 파이 4를 쿠버네티스 호스트로 약 두 년간 사용해 왔어요. 최근에 새로운 라즈베리 파이 5를 구매했어요. 새로 구매한 라즈베리 파이 5에도 쿠버네티스를 설정해 클러스터를 구성할 계획이에요.\n\n# 라즈베리 파이 5에서 K3s 설정하기\n\n부분 1 라즈베리 파이 OS Lite 64비트 설치하기\n\n부분 2 외부 저장소 연결하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-KubernetesonRaspberryPi5Part3InstallK3Sonmasternode_0.png\" /\u003e\n\n- 커널 구성 파일 업데이트\n\ncmdline.txt 파일에는 부팅 프로세스 중에 커널에 전달되는 명령줄 매개변수가 포함되어 있습니다. 이 파일에 몇 가지 매개변수를 추가해야 합니다. 다음 명령을 사용하여 파일을 열어보세요:\n\n```js\nsudo nano /boot/firmware/cmdline.txt\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 줄에 매개변수 세트가 포함되어 있습니다. 줄 끝에 다음 매개변수를 추가하세요:\n\n```js\ncgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory\n```\n\n파일을 저장하고 재부팅하세요:\n\n```js\nsudo reboot\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 마스터 노드 설정\n\nk3s 마스터 노드가 될 장치에 연결하세요. k3s를 설치하기 전에 먼저 몇 가지 환경 변수를 추가해야 합니다.\n\n다음은 제가 사용 중인 환경 변수입니다. `MASTER_NODE_IP` 자리 표시자를 교체해야 합니다.\n\n- node-ip: k3s 에이전트 또는 서버가 실행 중인 노드(기계)의 IP 주소입니다. 이 IP 주소는 Kubernetes 제어 평면에서 노드를 식별하고 클러스터 내 통신을 용이하게 합니다.\n- bind-address: k3s 클러스터 내 Kubernetes API 서버가 수신하는 IP 주소입니다. 특히 여러 네트워크 인터페이스가 있는 시나리오에서 API 서버가 특정 네트워크에서 접근 가능한지 확인하려는 경우 유용합니다.\n- advertise-address: Kubernetes API 서버가 클러스터의 다른 구성원에게 광고하는 IP 주소입니다. 이 주소는 다른 노드 및 구성 요소가 API 서버에 연결하기 위해 사용됩니다.\n- flannel-backend: Kubernetes 클러스터 내 팟 간 네트워킹을 제공하는 Flannel 네트워크 오버레이의 백엔드입니다. Flannel은 Kubernetes용으로 설계된 레이어 3 네트워크 패브릭을 구성하는 간단하고 쉬운 방법이며, 네트워크 트래픽이 어떻게 관리되고 경로 지정되는지를 결정하는 여러 백엔드를 지원합니다.\n- disable=servicelb: 내장된 klipper-lb 서비스 로드 밸러서를 비활성화합니다. 외부 로드 밸런서를 사용하거나 사용자 정의 로드 밸런서 솔루션을 배치하거나 불필요한 구성 요소를 비활성화하여 리소스 사용량을 최적화하려는 경우 유용합니다. 저는 MetalLB를 사용할 것입니다.\n- disable=traefik: k3s와 번들링된 기본 Traefik Ingress 컨트롤러를 비활성화합니다. 이 옵션은 다른 인그레스 컨트롤러를 사용하려는 경우, 인그레스 기능이 필요하지 않은 경우 또는 사용자 정의 인그레스 설정이 필요한 경우 유용합니다. 저는 nginx를 사용할 것입니다.\n- disable-cloud-controller: 클라우드 컨트롤러 매니저를 비활성화합니다. 이 매니저는 Kubernetes를 클라우드 제공 업체 서비스와 통합하는 역할을 합니다. 이 옵션은 온프레미스 배포, 엣지 컴퓨팅, IoT 시나리오 또는 클라우드 제공 업체 통합이 필요하지 않은 상황에서 특히 유용합니다.\n- disable-helm-controller: k3s가 Helm 컨트롤러를 배포하고 사용하는 것을 방지합니다. Kubernetes 애플리케이션을 관리하는 데 Helm 차트를 수동으로 관리하거나 Helm을 사용하지 않는 경우 유용합니다.\n- cluster-init: 첫 번째 서버 노드를 설정해 새로운 Kubernetes 클러스터를 초기화하는 데 사용됩니다. 이 노드는 초기 제어 평면 노드 역할을 하고 클러스터를 위해 etcd 데이터 저장소를 준비합니다. 이 옵션은 새 클러스터를 생성할 때 중요하며, 고 가용성 설정이나 클러스터를 복구할 때 특히 유용합니다. --cluster-init로 클러스터를 초기화한 후 추가 서버 및 에이전트 노드가 클러스터에 참여하여 완전히 기능하는 Kubernetes 환경을 구성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nexport K3S_NODE_NAME=\"pi-master\"\nexport K3S_KUBECONFIG_MODE=\"600\"\nexport INSTALL_K3S_EXEC=\"server --node-ip=\u003cMASTER_NODE_IP\u003e \\\n                                --bind-address=\u003cMASTER_NODE_IP\u003e \\\n                                --advertise-address=\u003cMASTER_NODE_IP\u003e \\\n                                --flannel-backend=host-gw \\\n                                --disable=servicelb \\\n                                --disable=traefik \\\n                                --disable-cloud-controller \\\n                                --disable-helm-controller \\\n                                --cluster-init\"\n```\n\n설정 중인 K3S_KUBECONFIG_MODE=\"600\"를 사용합니다. 이 환경 변수를 설정함으로써 생성된 kubeconfig 파일의 권한을 제어할 수 있습니다. 이것은 접근 제어를 관리하고 적절한 보안 설정을 적용하는 데 유용합니다. 600은 소유자 사용자가 파일 또는 디렉토리를 읽고 쓸 수 있고 다른 사용자는 액세스할 수 없음을 의미합니다.\n\n이러한 변수를 설정한 후에는 다음 명령을 실행해야합니다:\n\n```js\ncurl -sfL https://get.k3s.io | sh -\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nk3s 서비스가 실행 중인지 확인하려면 다음 명령을 실행하십시오:\n\n```js\nsudo systemctl status k3s\n```\n\n출력은 아래와 유사한 텍스트 블록으로 시작됩니다:\n\n```js\n● k3s.service - 경량 Kubernetes\n     Loaded: loaded (/etc/systemd/system/k3s.service; enabled; preset: enabled)\n     Active: active (running) since Sat 2024-06-08 12:55:15 EEST; 20h ago\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nK3S_KUBECONFIG_MODE=\"600을 사용했기 때문에 아직 kubectl을 사용할 수 없습니다. 환경 변수로 설정한 구성 파일을 복사해야 합니다.\n\n```js\nexport KUBECONFIG=~/.kube/config\nmkdir ~/.kube 2\u003e /dev/null\nsudo k3s kubectl config view --raw \u003e \"$KUBECONFIG\"\nchmod 600 \"$KUBECONFIG\"\n```\n\n환경 변수가 다시 시작 후에도 유지되려면 ~/.bashrc 파일 끝에 export KUBECONFIG=~/.kube/config 라인을 추가해야 합니다. 그런 다음 재시작하거나 이 명령어를 실행하면 됩니다: `source ~/.bashrc`.\n\n이제 kubectl을 사용할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nkubectl get pods -A\r\n```\r\n\r\n다음과 같은 출력을 보게 될 거에요:\r\n\r\n```js\r\nNAME                                      READY   STATUS    RESTARTS      AGE\r\ncoredns-6799fbcd5-246w2                   1/1     Running   3 (31m ago)   44h\r\nlocal-path-provisioner-6c86858495-kmn7s   1/1     Running   5 (31m ago)   44h\r\nmetrics-server-54fd9b65b-kv4s4            1/1     Running   4 (31m ago)   44h\r\n```\r\n\r\n3. 원격으로 kubectl 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n귀하의 머신에서 K3S 클러스터에 연결하려면 kube 구성 파일이 필요합니다.\n\n머신 터미널에서 마스터 노드에서 kube 구성 파일을 귀하의 머신으로 복사하는 다음 명령을 실행하십시오(`MASTER_NODE_IP` 플레이스홀더를 꼭 바꾸지 마십시오):\n\n```js\nscp pi@\u003cMASTER_NODE_IP\u003e:~/.kube/config ~/.kube/config\n```\n\n이제 원격으로 kubectl 명령을 실행할 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 완료했습니다!","ogImage":{"url":"/assets/img/2024-06-19-KubernetesonRaspberryPi5Part3InstallK3Sonmasternode_0.png"},"coverImage":"/assets/img/2024-06-19-KubernetesonRaspberryPi5Part3InstallK3Sonmasternode_0.png","tag":["Tech"],"readingTime":5},{"title":"Coral Dual Edge TPU를 Frigate를 위해 설정하는 방법","description":"","date":"2024-06-19 18:15","slug":"2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate","content":"\n\n\n![이미지](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_0.png)\n\n# 전체 비디오 튜토리얼\n\n# Coral AI PCIe 가속기 드라이버 설치\n\n여기서부터 모든 것을 간소화하는 이 스크립트를 사용하시면 됩니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncurl -sS https://gist.githubusercontent.com/dataslayermedia/8676e010a9121adaaab8e6dc98bca383/raw/f208dbb5e3efda51b75183c67e8dc857e375234e/Install-Coral-PCIe-Accelerator-TPU-Linux.sh | bash\n```\n\n재부팅\n\n```js\nsudo reboot\n```\n\n장치 확인\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nlspci -nn | grep 089a\n```\n\n![Link](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_1.png)\n\nApex 장치를 확인하세요\n\n```js\nls /dev/apex_*\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_2.png\" /\u003e\n\n도커 설치\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_3.png\" /\u003e\n\n```js\n# 도커의 공식 GPG 키 추가:\nsudo apt-get update\nsudo apt-get install ca-certificates curl gnupg\nsudo install -m 0755 -d /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\nsudo chmod a+r /etc/apt/keyrings/docker.gpg\n\n# Apt 소스에 저장소 추가:\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \\\n  $(. /etc/os-release \u0026\u0026 echo \"$VERSION_CODENAME\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null\nsudo apt-get update\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n```\n\n다음 명령어로 설치를 테스트해보세요.\n\n```js\ndocker ps -a\n```\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# MQTT(Mosquitto) 설치\n\nMQTT 프로토콜은 발행/구독 모델을 사용하여 메시지를 전달하는 가벼운 방법을 제공합니다. 이는 저전력 센서나 휴대폰과 같은 모바일 장치, 임베디드 컴퓨터, 또는 마이크로컨트롤러와 같은 사물인터넷 메시징에 적합합니다.\n\n```js\nsudo apt install mosquitto mosquitto-clients\n```\n\n```js\nsudo systemctl is-enabled mosquitto\nsudo systemctl status mosquitto\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같이 테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\n![이미지](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_5.png)\n\nMQTT 구성 파일을 편집합니다.\n\n```sh\nvim /etc/mosquitto/mosquitto.conf\n```\n\n이 두 줄을 추가하세요...\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nallow_anonymous true\nlistener 1883\n\n\n설정 파일은 다음과 같이 보일 것입니다...\n\n![이미지](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_6.png)\n\nVIM에서 “:x” 입력 후 엔터 키를 눌러 저장하고 종료하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서비스를 저장하고 다시 시작하세요\n\n```js\nsystemctl restart mosquitto\n```\n\n# Frigate 설정\n\n![이미지](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n루트 디렉터리에서 \"frigate\"라는 디렉터리를 만들어 config.yml 파일을 추가하세요.\n\n```js\ncd /\nmkdir frigate\ncd /frigate\ntouch config.yml\n```\n\nconfig.yml 파일을 편집하세요.\n\n```js\nmqtt:\n  enabled: True\n  host: 192.168.X.XXX\n  port: 1883\ncameras:\n  eyeofsauron:\n    ffmpeg:\n      # hwaccel_args: preset-vaapi\n      #hwaccel_args:\n      #  - vf:v \"fps=15\"\n      inputs:\n        - path: rtsp://192.168.X.XXX:554/mystream\n          input_args: preset-rtsp-generic\n          roles:\n            - detect\n            - record\n            - rtmp\n    detect:\n      fps: 25\n      enabled: True\n      width: 1280\n      height: 720\ndetectors:\n  coral1:\n    type: edgetpu\n    device: pci:0\n  coral2:\n    type: edgetpu\n    device: pci:1\nobjects:\n  track:\n    - person\n\nrecord:\n  # Optional: 녹화 기능 활성화 (기본값은 아래와 같습니다)\n  # 주의: 설정에서 녹화를 비활성화한 경우, 나중에 UI나 MQTT를 통해 녹화를 켜도 영향이 없습니다.\n  enabled: True\n  # Optional: 정리 실행 간격(분) 설정 (기본값은 아래와 같습니다)\n  # I/O를 최소화하기 위해 디스크에서 녹화 세그먼트를 삭제하는 빈도를 줄이려면 사용할 수 있습니다.\n  expire_interval: 60\n  # Optional: 녹화 보관 설정\n  retain:\n    # Optional: 이벤트와 관계없이 녹화 보관일 수 (기본값은 아래와 같습니다)\n    #참고: 이벤트의 녹화만 유지하려면 이 값을 0으로 설정하고 아래 이벤트 섹션에서 보관을 정의해야 합니다.\n    days: 0\n    # Optional: 보관 모드. 가능한 옵션은 다음과 같습니다: all, motion, active_objects\n    #   all - 모든 활동에 관계없이 모든 녹화 세그먼트를 저장\n    #   motion - 감지된 모션을 가진 모든 녹화 세그먼트를 저장합니다.\n    #   active_objects - 활동/움직이는 객체를 가진 모든 녹화 세그먼트를 저장합니다.\n    #NOTE: 이 모드는 위의 days 설정이 0보다 클 때만 적용됩니다.\n    mode: all\n  # Optional: 이벤트 녹화 설정\n  events:\n    # Optional: 이벤트 이전 시점을 포함할 초 수 (기본값은 아래와 같습니다)\n    pre_capture: 5\n    # Optional: 이벤트 후속 시점을 포함할 초 수 (기본값은 아래와 같습니다)\n    post_capture: 5\n    # Optional: 녹화를 위해 저장할 객체 (기본값: 추적되는 모든 객체)\n    objects:\n      - person\n    # Optional: 지정된 모든 존에 들어간 객체로 녹화를 제한 (기본값: 필수 존 없음)\n    required_zones: []\n    # Optional: 이벤트 녹화 보관 설정\n    retain:\n      # 필수: 기본 보관 일 수 (기본값은 아래와 같습니다)\n      default: 10\n      # Optional: 보관 모드 (기본값은 아래와 같습니다)\n      #   all - 활동 여부에 관계없이 이벤트를 위한 모든 녹화 세그먼트를 저장\n      #   motion - 감지된 모션을 가진 이벤트를 위한 모든 녹화 세그먼트를 저장\n      #   active_objects - 활동/움직이는 객체를 가진 이벤트를 위한 모든 녹화 세그먼트를 저장\n      #NOTE: 카메라의 보관 모드가 여기에서 구성된 모드보다 제한적이면 이 모드가 적용되는 시점에 세그먼트는 이미 삭제됩니다.\n      #       예를 들어, 카메라의 보관 모드가 \"motion\"이면 모션 없는 세그먼트는 저장되지 않으므로 여기에서 모드를 \"all\"로 설정해도 복구되지 않습니다.\n      mode: motion\n      # Optional: 객체별 보관 일 수\n      objects:\n        person: 15\n\n# Optional: 이벤트별 클립 디렉터리에 작성된 jpg 스냅샷에 대한 구성\n#NOTE: 카메라 수준에서 재정의할 수 있음\nsnapshots:\n  # Optional: jpg 스냫샷을 /media/frigate/clips에 작성 활성화 (기본값은 아래와 같습니다)\n  enabled: False\n  # Optional: 스냅샷 이미지의 깨끗한 PNG 복사 저장 (기본값은 아래와 같습니다)\n  clean_copy: True\n  # Optional: 스냅샷에 타임스탬프 추가 (기본값은 아래와 같습니다)\n  timestamp: False\n  # Optional: 스냅샷에 바운딩 박스 그리기 (기본값은 아래와 같습니다)\n  bounding_box: False\n  # Optional: 스냅샷 자르기 (기본값은 아래와 같습니다)\n  crop: False\n  # Optional: 스냅샷 크기 조정을 위한 높이 (기본값: 원본 크기)\n  height: 175\n  # Optional: 지정된 모든 존에 들어간 객체로 제한된 스냅샷 (기본값: 필수 존 없음)\n  required_zones: []\n  # Optional: 보관 설정을 위한 카메라 오버라이드 (기본값: 전역 값)\n  retain:\n    # 필수: 기본 보관 일 수 (기본값은 아래와 같습니다)\n    default: 10\n    # Optional: 객체별 보관 일 수\n    objects:\n      person: 15\n\nbirdseye:\n  # Optional: 전방향 보기 활성화 (기본값은 아래와 같습니다)\n  enabled: True\n  # Optional: RTSP를 통해 전방향 보기 다시 전송 (기본값은 아래와 같습니다)\n  #NOTE: 이를 활성화하면 전방향 보기가 항상 실행되어 CPU 사용량이 어느 정도 증가할 수 있습니다.\n  restream: False\n  # Optional: 출력 해상도의 너비 (기본값은 아래와 같습니다)\n  width: 1280\n  # Optional: 출력 해상도의 높이 (기본값은 아래와 같습니다)\n  height: 720\n  # Optional: mpeg1 피드의 인코딩 품질 (기본값은 아래와 같습니다)\n  # 1이 가장 높은 품질이고 31이 가장 낮습니다. 품질이 낮은 피드는 CPU 리소스를 적게 사용합니다.\n  quality: 1\n  # Optional: 뷰 모드. 가능한 옵션은 다음과 같습니다: objects, motion, continuous\n  #   objects - 마지막 30초 내에 추적된 객체가 있는 경우 카메라가 포함됨\n  #   motion - 마지막 30초 내에 모션을 감지한 경우 카메라가 포함됨\n  #   continuous - 모든 카메라가 항상 포함됨\n  mode: continuous\n\nlogger:\n  # Optional: 기본 로그 상세도 (기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 구성은 PCIe TPU에 모두 준비가 되어 있으며 프레임에서 사람을 감지하면 녹화를 합니다. 해상도는 HD이고 프레임 속도는 높습니다(25 FPS). 이 모든 것은 필요에 맞게 조정할 수 있습니다.\n\nIP 주소를 교체해야 합니다.\n\nhostname -I\n\nIP 카메라가 있다면이 프로세스가 훨씬 쉽습니다. 하지만 제가 저렴한 웹캠을 사용하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```\n![이미지](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_8.png)\n\n프리게이트 도커 컨테이너 실행\n\n```js\ndocker run -d \\\n  --name frigate \\\n  --restart=unless-stopped \\\n  --mount type=tmpfs,target=/tmp/cache,tmpfs-size=1000000000 \\\n  --device /dev/apex_0:/dev/apex_0 \\\n  --device /dev/apex_1:/dev/apex_1 \\\n  --shm-size=512m \\\n  -v /frigate/storage:/media/frigate \\\n  -v /frigate/config.yml:/config/config.yml \\\n  -v /etc/localtime:/etc/localtime:ro \\\n  -p 5000:5000 \\\n  -p 8555:8555/tcp \\\n  -p 8555:8555/udp \\\n  ghcr.io/blakeblackshear/frigate:stable\n```\n\n노트: 우리는 apex 장치를 컨테이너로 모두 전달하고 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n로컬 네트워크에서 Frigate 웹 UI를 열어보세요.\n\n192.168.X.XXX:5000\n\n![이미지](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_9.png)\n\n# RTSP 서버 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nwget https://github.com/aler9/rtsp-simple-server/releases/download/v0.16.0/rtsp-simple-server_v0.16.0_linux_amd64.tar.gz\n```\n\n```js\ntar -xzvf rtsp-simple-server_v0.16.0_linux_amd64.tar.gz\n```\n\n```js\nRTSP_RTSPADDRESS=192.168.XXX.XXX:554 ./rtsp-simple-server\n```\n\n![How to Setup the Coral Dual Edge TPU for Frigate](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_10.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# RTSP 서버로 웹캠 피드 스트리밍하기\n\n```js\napt-get install ffmpeg\n```\n\n```js\nsudo ffmpeg -f v4l2 -framerate 25 -video_size 1280x720 -i /dev/video0 -pix_fmt yuv420p -b:v 2000k -f rtsp -rtsp_transport tcp rtsp://192.168.X.XXX:554/mystream\n```\n\nIP 주소를 교체하는 것을 기억해 주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 브라우저에서 Frigate 열기\n\n192.168.X.XXX:5000\n\n코랄 장치의 온도를 모니터링하고 싶다면 해당 작업을 수행할 수 있는 스크립트가 있어요.\n\n[해당 스크립트는 여기에서 확인할 수 있어요](https://gist.github.com/dataslayermedia/fb20aae9dea64bca286b5e6d189027b8)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\ncurl -sS https://gist.githubusercontent.com/dataslayermedia/fb20aae9dea64bca286b5e6d189027b8/raw/a4f264ee7be546bdf5c3363bfafdc9597f9edd5c/real-time-temperature-output-coral-ai-pcie-accelerators.sh | bash\n```\n\n![Demo](https://miro.medium.com/v2/resize:fit:1280/1*S-F-NGRpvd9eVHcbkeB7RA.gif)\n\n## 제품 하드웨어 링크\n\n1080P 웹캠\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 표 형식을 변경한 것입니다.\n\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_11.png\" /\u003e\n\nCoral AI Dual Edge TPU\n\n\u003cimg src=\"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_12.png\" /\u003e\n\nZima Board\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Dual Edge TPU Adapter Low Profile](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_13.png)\n\n![Dual Edge TPU Adapter Low Profile](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_14.png)\n","ogImage":{"url":"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_0.png","tag":["Tech"],"readingTime":10}],"page":"67","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"67"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>