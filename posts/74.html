<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/74" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/74" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_buildManifest.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label=" SQL 조인 마스터하기" href="/post/2024-06-19-MasteringSQLJoins"><div class="PostList_thumbnail_wrap__YuxdB"><img alt=" SQL 조인 마스터하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-MasteringSQLJoins_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt=" SQL 조인 마스터하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl"> SQL 조인 마스터하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">31<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략" href="/post/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="드디어 7B 파라미터 모델이 GPT-4를 이겼어요" href="/post/2024-06-19-Finally7BParameterModelbeatsGPT-4"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="드디어 7B 파라미터 모델이 GPT-4를 이겼어요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-Finally7BParameterModelbeatsGPT-4_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="드디어 7B 파라미터 모델이 GPT-4를 이겼어요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">드디어 7B 파라미터 모델이 GPT-4를 이겼어요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="PostgreSQL 및 데이터베이스 시스템을 포괄적으로 다루는 PostgreSQL 학습 안내서 파트 2" href="/post/2024-06-19-LearningPostgresAComprehensiveGuidetoPostgreSQLandDatabaseSystemsPart2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="PostgreSQL 및 데이터베이스 시스템을 포괄적으로 다루는 PostgreSQL 학습 안내서 파트 2" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-LearningPostgresAComprehensiveGuidetoPostgreSQLandDatabaseSystemsPart2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="PostgreSQL 및 데이터베이스 시스템을 포괄적으로 다루는 PostgreSQL 학습 안내서 파트 2" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">PostgreSQL 및 데이터베이스 시스템을 포괄적으로 다루는 PostgreSQL 학습 안내서 파트 2</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="NoSQL을 사용하는 이유와 SQL을 선택하는 3가지 이유" href="/post/2024-06-19-3ReasonstoUseNoSQLoverSQL"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="NoSQL을 사용하는 이유와 SQL을 선택하는 3가지 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-3ReasonstoUseNoSQLoverSQL_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="NoSQL을 사용하는 이유와 SQL을 선택하는 3가지 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">NoSQL을 사용하는 이유와 SQL을 선택하는 3가지 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="BigQuery 비용을 dbt 증분 모델로 100-200배 절감하기" href="/post/2024-06-19-ReducingBigQueryCostsby100200xwithdbtIncrementalModels"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="BigQuery 비용을 dbt 증분 모델로 100-200배 절감하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-ReducingBigQueryCostsby100200xwithdbtIncrementalModels_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="BigQuery 비용을 dbt 증분 모델로 100-200배 절감하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">BigQuery 비용을 dbt 증분 모델로 100-200배 절감하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬에서 SQLite3를 활용하여 시작하기 테이블 생성 및 행 추출하기" href="/post/2024-06-19-GetStartedwithSQLite3inPythonCreatingTablesandFetchingRows"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬에서 SQLite3를 활용하여 시작하기 테이블 생성 및 행 추출하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-GetStartedwithSQLite3inPythonCreatingTablesandFetchingRows_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬에서 SQLite3를 활용하여 시작하기 테이블 생성 및 행 추출하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">파이썬에서 SQLite3를 활용하여 시작하기 테이블 생성 및 행 추출하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">11<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 과학 채용 면접이 오지 않나요 시각성 문제가 있을 수 있습니다" href="/post/2024-06-19-NotGettingDataScienceJobInterviewsYouHaveAVisibilityProblem"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 과학 채용 면접이 오지 않나요 시각성 문제가 있을 수 있습니다" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-NotGettingDataScienceJobInterviewsYouHaveAVisibilityProblem_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 과학 채용 면접이 오지 않나요 시각성 문제가 있을 수 있습니다" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">데이터 과학 채용 면접이 오지 않나요 시각성 문제가 있을 수 있습니다</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 엔지니어가 직면하는 다섯 가지 무자비한 진실" href="/post/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 엔지니어가 직면하는 다섯 가지 무자비한 진실" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 엔지니어가 직면하는 다섯 가지 무자비한 진실" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">데이터 엔지니어가 직면하는 다섯 가지 무자비한 진실</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="클래스워드 - 데이터베이스 열 이름 짓는데 내가 가장 좋아하는 컨벤션" href="/post/2024-06-19-ClasswordsMyFavoriteConventionforNamingDatabaseColumns"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="클래스워드 - 데이터베이스 열 이름 짓는데 내가 가장 좋아하는 컨벤션" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-19-ClasswordsMyFavoriteConventionforNamingDatabaseColumns_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="클래스워드 - 데이터베이스 열 이름 짓는데 내가 가장 좋아하는 컨벤션" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">클래스워드 - 데이터베이스 열 이름 짓는데 내가 가장 좋아하는 컨벤션</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 19, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/61">61</a><a class="link" href="/posts/62">62</a><a class="link" href="/posts/63">63</a><a class="link" href="/posts/64">64</a><a class="link" href="/posts/65">65</a><a class="link" href="/posts/66">66</a><a class="link" href="/posts/67">67</a><a class="link" href="/posts/68">68</a><a class="link" href="/posts/69">69</a><a class="link" href="/posts/70">70</a><a class="link" href="/posts/71">71</a><a class="link" href="/posts/72">72</a><a class="link" href="/posts/73">73</a><a class="link posts_-active__YVJEi" href="/posts/74">74</a><a class="link" href="/posts/75">75</a><a class="link" href="/posts/76">76</a><a class="link" href="/posts/77">77</a><a class="link" href="/posts/78">78</a><a class="link" href="/posts/79">79</a><a class="link" href="/posts/80">80</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":" SQL 조인 마스터하기","description":"","date":"2024-06-19 16:31","slug":"2024-06-19-MasteringSQLJoins","content":"\n\n![SQL Join](/assets/img/2024-06-19-MasteringSQLJoins_0.png)\n\n저희의 최신 SQL 데이터 과학 탐험에 오신 것을 환영합니다. 이전 글에서는 단일 테이블 내에서 데이터 세트를 조작하는 것에 대해 자세히 다뤘습니다. 데이터 추출, 변환, 계산, 필터링을 통해 통찰과 패턴을 발견했습니다.\n\n이러한 기본적인 기술은 중요하지만, SQL의 실제 응용은 종종 보다 복잡한 접근을 요구합니다. 특히 다중 테이블에서 데이터를 통합해야 하는 경우가 많습니다. 이는 관계형 데이터베이스에 데이터가 일반적으로 저장되는 방식을 반영한 것으로, 서로 다른 테이블 간에 특정 키와 속성을 통해 관련되어 있습니다.\n\n본 문서에서는 단일 테이블 작업을 넘어서서 다중 테이블 조인에 대한 이해와 적용을 다룰 것입니다. 조인 작업은 SQL에서 중요한데, 서로 다른 테이블에서 데이터를 통합하고 교차 참조하여 정보를 종합적으로 파악할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 조인 연산의 기본 개념을 다룰 것이며, 다양한 종류의 조인과 그 응용에 대해 다룰 것입니다. 이 글을 마칠 때쯤이면, 현실 세계의 데이터 과학적 도전의 복잡성을 반영하는 정교한 데이터 조작을 수행하는 데 필요한 실용적인 노하우를 갖추게 될 것입니다. 데이터 과학을 위해 관계형 데이터베이스의 전체 잠재력을 탐색하고 활용하기 위한 전략을 발견하는 다중 테이블 관련의 복잡성에 대해 파고들어 봅시다.\n\n# 데이터 관련성 이해\n\n테이블 조인과 SQL에 대한 우리의 탐험의 핵심에는 기본 개념이 있습니다: 데이터 관계. 테이블을 조인하는 메커니즘을 깊이 파헤치기 전에, 데이터가 관련되어 있는지와 이러한 관계가 관계형 데이터베이스의 기반이 되는 방식을 이해하는 것이 중요합니다.\n\n거의 모든 제품을 판매하는 거의 모든 비즈니스에서 흔히 볼 수 있는 기본적인 예제를 고려해 보겠습니다 — 제품 카탈로그 테이블입니다. 이 테이블은 회사 데이터베이스의 중요한 구성 요소로, 판매 가능한 제품들의 구조화된 개요를 제공합니다. 일반적으로 제품 코드, 제품 이름, 판매 가격, 제품 카테고리와 같은 필드가 포함되어 있습니다. 이러한 각 필드는 특정 목적을 제공합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 제품 코드: 각 제품에 대한 고유 식별자입니다.\n- 제품 이름: 제품의 이름으로, 사용자들이 식별하는 데 도움이 됩니다.\n- 판매 가격: 제품이 고객에게 판매되는 가격입니다.\n- 제품 카테고리: 제품을 더 넓은 범주로 그룹화하는 분류입니다.\n\n이 표는 제품 정보를 관리 가능한 방식으로 구성하는 데 도움이 되며, 데이터가 어떻게 상호 연결될 수 있는지 이해하는 데 기초를 제공합니다.\n\n예를 들어, 제품 카테고리 필드는 개별 제품을 더 큰 범주에 연결하여 데이터 내에서 간단하지만 강력한 관계를 암시합니다. 진행하면서 이러한 관계가 단일 표를 넘어 확장되어 다중 소스에서 데이터를 결합하여 더 풍부한 통찰과 포괄적인 분석을 제공할 수 있음을 알게됩니다.\n\n다음 섹션에서는 테이블 조인의 메커니즘에 대해 깊이 있게 다룰 것인데, 이 기술은 이러한 관계를 활용하여 두 개 이상의 테이블에서 데이터를 병합하여 데이터를 질의하고 분석할 수 있는 능력을 향상시키는 데 활용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 관계의 기본 개념을 이해하면 데이터 과학에서 SQL의 강력함을 더욱 실감할 수 있어요.\n\n![MasteringSQLJoins_1.png](/assets/img/2024-06-19-MasteringSQLJoins_1.png)\n\n쿼리 분석 및 시각화 생성 측면에서 PRODUCTS 테이블은 잘 구성되어 있어서 SQL 작업에 적합해 보여요.\n\nPRODUCTS 테이블에서 카테고리가 특히 `가정용 가전제품`인 제품 이름을 검색하려면 다음과 같은 SQL 쿼리를 실행할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sql\nSELECT product_name \nFROM PRODUCTS \nWHERE category = 'Home Appliances'\n```\n\n우리 예제 테이블에서 이 쿼리를 실행하면 'Home Appliances' 카테고리에 세 개의 제품이 있다는 것을 나타내는 세 개의 행이 반환됩니다.\n\n따라서 이 데이터 하위 집합을 가져오는 데 문제가 없습니다. 더 나아가, 우리는 카테고리 당 제품 평균 가치를 계산하는 분석을 확장할 수 있습니다.\n\n이러한 작업을 위해서는 AVG 함수를 사용하여 평균 제품 가치를 계산합니다. SQL 명령을 구조화하는 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nSELECT category, AVG(product_value)\nFROM PRODUCTS\nGROUP BY category;\n```\n\n이 명령어는 두 가지 업무를 수행합니다:\n\n- 출력에 포함될 카테고리 열을 선택하여 각 카테고리의 평균 값에 대한 고유한 식별자를 제공합니다.\n- AVG 함수를 사용하여 제품 가치의 평균을 계산합니다. 이는 저희 다음 장에서 더 자세히 살펴볼 집계 함수입니다.\n\nGROUP BY category를 사용하여 각 고유 카테고리에 대한 평균 값을 PRODUCTS 테이블 내에서 계산합니다. 이러한 집계는 데이터 분석에서 핵심 역할을 합니다. 다른 제품 세그먼트 내에서의 패턴과 트렌드를 식별하는 데 도움이 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 더 자세히 살펴보면, 카테고리 열에서 비효율성이 드러납니다: 용어 '가전제품'이 여러 번 반복됩니다. 처음에는 각 제품의 카테고리를 나타내는 것이 필요해 보일 수 있지만, 이 중복은 몇 가지 문제로 이어질 수 있습니다:\n\n- 데이터 저장: 중복 데이터는 저장면에서 비용이 소모될 수 있습니다. '가전제품'의 각 반복은 디스크 공간을 추가로 차지하는데, 이는 이 정보를 표현하는 더 효율적인 방법이 없는 한 불필요합니다.\n- 성능: 자주 업데이트되는 테이블은 이러한 중복이 포함되어 있을 경우 로드하는 데 시간이 오래 걸릴 수 있습니다. 수백만 또는 수십억 개의 레코드로 확장된 이 테이블을 상상해보세요. 반복된 카테고리 항목으로 인해 성능에 미치는 영향은 상당할 수 있습니다.\n- 쿼리 효율성: 대규모 테이블을 쿼리할 때 중복된 카테고리가 있는 경우, 데이터베이스 엔진은 필요 이상의 데이터를 스캔해야 하는 일이 늘어날 수 있습니다.\n\n따라서, 보고 목적으로는 테이블이 충분해 보일지라도, 관리 및 운영 측면에서는 상당한 비효율성이 드러납니다.\n\n이러한 도전에 대처하려면, 데이터베이스를 재구성하여 중복을 줄이고 데이터 무결성을 개선하는 정규화(Normalization)이라는 해결책이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 문제를 해결하는 일반적인 방법 중 하나는 고유한 카테고리 이름과 해당 식별자를 보유하는 별도의 CATEGORIES 테이블을 생성하는 것입니다.\n\n그럼으로써, PRODUCTS 테이블의 각 제품은 식별자를 통해 적절한 카테고리를 참조하게 됩니다. 이 방법을 외부 키 참조라고 합니다.\n\n이 변경은 저장 공간을 절약하는 데 도움이 되는 것뿐만 아니라 데이터 작업과 쿼리의 성능을 최적화합니다.\n\n다음은 이러한 비효율성을 해결하기 위해 데이터베이스를 구조화하는 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n-- 카테고리에 대한 새 테이블 생성\nCREATE TABLE CATEGORIES (\n    category_id INT PRIMARY KEY,\n    category_name VARCHAR(255)\n);\n\n-- 고유한 카테고리를 CATEGORIES 테이블에 삽입\nINSERT INTO CATEGORIES (category_id, category_name)\nVALUES (1, '가전제품'), (2, '가구'), (3, '식품');\n\n-- PRODUCTS 테이블을 수정하여 CATEGORIES에 대한 외부 키 참조를 추가\nALTER TABLE PRODUCTS\nADD COLUMN category_id INT,\nADD FOREIGN KEY (category_id) REFERENCES CATEGORIES(category_id);\r\n```\n\n![이미지](/assets/img/2024-06-19-MasteringSQLJoins_2.png)\n\n이 접근 방식은 여러 문제를 해결해 줍니다. 'Home Appliances'라는 단어를 더 이상 반복하지 않아도 되므로, 수십억 개의 레코드가 있는 테이블에서 중요합니다.\n\nCATEGORIES 테이블을 자주로드할 필요가 없으므로로딩 시간이 줄어들 확률이 높습니다. 이 테이블은 한 번 생성되고 시간이 지남에 따라 거의 변경되지 않습니다. PRODUCTS 테이블은 카테고리 관련 텍스트를 반복할 필요가 없으므로 로드 및 업데이트 속도가 빨라집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쿼리를 실행하는 과정은 두 테이블을 조인해야 하므로 약간 복잡할 수 있습니다. 그러나 이런 교체는 쿼리가 텍스트 기반의 카테고리 열이 아닌 ID를 참조하고, 해당 카테고리가 반복되지 않는 CATEGORIES 테이블에 조인하여 성능이 더 우수해질 수 있도록 도와줍니다.\n\n아래는 카테고리가 '가전제품'인 제품 이름을 검색하는 쿼리의 예시입니다:\n\n```js\nSELECT p.product_name, p.product_value\nFROM PRODUCTS p\nJOIN CATEGORIES c ON p.category_id = c.category_id\nWHERE c.category_name = 'Home Appliances';\n```\n\n이 SQL 문은 PRODUCTS 테이블과 CATEGORIES 테이블을 공유된 category_id를 기준으로 조인합니다. 이렇게 함으로써 'Home Appliances' 카테고리와 연관된 제품 이름과 값을 효율적으로 검색합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- p 및 c는 각각 PRODUCTS 및 CATEGORIES의 별칭으로, 쿼리를 간단하게 만듭니다.\n- ON 절은 category_id를 일치시켜 두 테이블을 연결합니다.\n- WHERE 절은 결과를 '가정용 가전제품' 만 포함하도록 필터링합니다.\n\n테이블 별칭이 없는 열 이름은 한 테이블에만 고유한 열에서 나온 것으로, 별칭이 필요 없어집니다. 그러나 쿼리가 복잡해지면 명확성을 위해 별칭을 사용하는 것이 일반적인 관행입니다.\n\n저희는 앞으로 LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN 및 CROSS JOIN과 같은 다양한 종류의 조인을 다룰 것입니다.\n\n# SQL 조인 이해하기: 개념적 접근\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQL 영역에서 테이블을 결합하는 능력은 복잡한 데이터 검색을 가능하게 하는 강력한 기능입니다.\n\n시작하기 전에 한 가지 조언을 드리겠습니다: 유혹에 넘어가지 말고 조인 규칙을 암기하려는 욕구를 억제하세요. 진정한 이해는 단순 암기가 아니라 근본적인 원리를 이해하는 데서 나옵니다.\n\n이 섹션에서는 SQL 조인에 대한 개요를 제시하고 일반적인 개념을 파악하기 위한 다이어그램을 보완합니다. 실제 연습으로 이동하면서 목표지향적인 방법으로 SQL 조인 학습을 강조할 것입니다.\n\n조인을 마스터하는 핵심은 원하는 결과에 초점을 맞추는 것입니다: 어떤 데이터가 필요한가요? 얼마나 많은 데이터가 필요한가요? 어떤 테이블에서요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 질문들이 있습니다. 해당 조인 유형을 결정하는 데 도움이 됩니다. 조인이란 본질적으로 세트 이론 규칙의 적용이며, 이 개념을 이해하는 것은 단순 외움보다 전략적입니다.\n\n그럼에도 불구하고 이는 하나의 관점에 불과합니다. 우리가 다가올 수업에서 INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN 등을 포함한 다양한 조인 유형을 탐색하면서 직접 결론을 도출하는 것을 장려합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQL 조인은 본질적으로 집합 이론의 실용적 적용입니다. 이 개념은 대부분 사람들이 초등 교육을 받을 때 소개 받는 개념입니다. 이 아이디어는 간단합니다: 조인을 통해 하나의 세트, 다른 세트 또는 둘 다에 속하는 데이터를 검색할 수 있습니다. SQL에서 이러한 세트는 우리의 데이터를 포함하는 테이블입니다.\n\n다음 시각화를 고려해보세요: 각 원은 데이터 세트 또는 테이블을 나타냅니다. 우리는 다음과 같은 데이터를 검색할 수 있습니다:\n\n## Inner Join\n\n\"조인\"에 대해 들으면, 그것은 일반적으로 사용되는 조인 유형 중 하나인 내부 조인을 가리키는 것입니다. 이는 두 테이블에서 일치하는 값을 가진 레코드를 반환합니다. 아래 다이어그램은 이해를 돕습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Left Join (또는 Left Outer Join)\n\n가끔 \"Outer\"를 생략하여 \"Left Join\"이라고도 불리며, 이는 왼쪽 테이블의 모든 레코드와 오른쪽 테이블의 해당 레코드를 반환합니다. SQL 쿼리에서 테이블의 순서는 결과에 중대한 영향을 미칩니다. 따라서 쿼리에서 테이블의 순서를 지정하는 것이 중요합니다.\n\n## Right Join (또는 Right Outer Join)\n\n이 조인은 오른쪽 테이블의 모든 레코드와 왼쪽 테이블의 일치하는 레코드를 반환합니다. 아래 다이어그램은 이 개념을 시각적으로 설명합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## Full Join (또는 Full Outer Join)\n\n왼쪽, 오른쪽 또는 두 테이블에서 일치하는 항목이있을 때 모든 레코드를 반환하여 모든 것을 검색합니다.\n\n## Cross Join\n\n성능 이슈로 인해 덜 사용되지만, 두 테이블의 모든 레코드의 카테시안 곱을 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예시는 단순성을 위해 두 개의 테이블을 사용했지만, 실제로는 몇 개의 테이블이든 상관없이 동일한 원칙이 적용됨을 알아두는 것이 중요합니다. 3개, 4개, 5개 또는 100만 개의 테이블을 조인하든 상관없이 논리는 일관적으로 유지됩니다.\n\n## Self Join\n\n이 기술은 재귀를 활용하여 테이블을 자신에 조인하는 것으로, 컴퓨터 프로그래밍에서 널리 사용되는 개념입니다.\n\n다음 다이어그램은 제공된 설명을 요약하였습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-MasteringSQLJoins_4.png\" /\u003e\n\n위 요약은 방금 논의한 조인 유형을 요약한 것이지만, 각 조인 유형마다 쿼리에서 필터를 구성하는 방식에 대한 주요한 차이점이 있다는 점을 기억하는 것이 중요합니다.\n\n우리는 이전에 필터에 대해 탐구했었죠. 필터는 사실 SQL 개념의 기초입니다.\n\n조인을 구성하는 방식은 적용하는 필터에 따라 완전히 변경될 수 있습니다. 그래서 이러한 조인 및 약간의 변형을 소개했지만, 개인적으로는 조인의 이름을 기억하는 데 신경 쓰지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 대신, 제가 집중하는 것은 필요한 것을 이해하는 데 있어요:\n\n- 나는 왼쪽과 오른쪽 테이블에서 데이터를 반환하고 싶은가?\n- 한 테이블에만 존재하고 다른 테이블에는 없는 데이터를 검색하려고 하는가?\n- 아니면 동일한 테이블 내에서 관계가 있는 데이터를 반환하고 싶은가?\n\n이것들은 제가 고민하는 질문들이며, 이러한 실용적인 수업을 통해 안내해 드릴 거에요. 이 방법은 최적의 조인 전략을 정의하는 데 도움이 돼요. 물론, 이 모든 것을 즉시 이해하는 것은 쉽지 않을 수 있어요; 연습이 중요하죠.\n\n나는 다가오는 세션에서 여러 예시들을 제공하여 여러분이 이러한 개념을 이해하고 적용할 수 있도록 강화할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# SQL에서 Table Joins 탐색하기\n\nSQL에서 Table Joins에 대해 자세히 살펴보겠습니다. 이 섹션은 최대한 가르치기 쉬운 방법으로 기초부터 순서대로 명확하게 설명하려는 목적으로 강조합니다.\n\n나의 목표는 여러분이 개념을 명확히 이해하도록 돕는 것입니다. Table Joins는 점차적으로 복잡해지는 쿼리를 다룰 때 다음 장에서 활용될 것입니다.\n\n가상 데이터셋을 활용하여 SQL Joins를 마스터하는 여정을 수월하게 진행해 보겠습니다. 시작해 봅시다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sql\nCREATE SCHEMA `chapter04`;\n```\n\n먼저 일부 허구 데이터로 테이블을 로드한 다음, 두 번째 테이블을 만들고 데이터를 로드하고, 그리고 데이터로드를 적용하기 전에 세 번째 테이블을 만들겠습니다.\n\n인터페이스에서 마우스 오른쪽 버튼을 클릭하여 \"스키마 생성\"을 선택할 수는 있지만, 실행을 위해 모든 명령을 하나의 스크립트로 제공하고 있습니다. 실행하면 로그에 성공 메시지가 표시됩니다.\n\n그런 다음 좌측 사이드바에서 마우스 오른쪽 버튼을 클릭하고 새로 고침을 누르면 \"Chapter 04\" 스키마가 나타납니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 고객 테이블 생성하기\n\n아래의 SQL DDL (데이터 정의 언어) 명령문을 복사하여 붙여넣어서 고객 테이블을 생성하세요:\n\n```js\nCREATE TABLE `chapter04`.`CUSTOMERS` (\n  `customer_id` INT NULL,\n  `customer_name` VARCHAR(50) NULL,\n  `customer_address` VARCHAR(50) NULL,\n  `customer_city` VARCHAR(50) NULL,\n  `customer_state` VARCHAR(2) NULL);\n```\n\n이 섹션의 최종 목표는 데이터베이스 내에서 객체를 생성하는 것입니다. 따라서 CUSTOMERS 테이블을 만드는 것은 DDL (데이터 정의 언어) 명령입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDDL은 데이터베이스에 무언가를 생성할 때 사용됩니다. 예를 들어, 테이블을 만들 때 사용됩니다. 이 경우에는 chapter04 스키마에 CUSTOMERS 테이블을 만들 예정이며, 이 테이블에는 고객 ID, 고객 이름, 고객 주소, 도시 및 주(지역)를 위한 열이 포함될 것입니다.\n\n자, 이제 이를 실행해 봅시다. 성공적으로 실행하면 로그에 확인 메시지가 표시될 것입니다. 화살표를 클릭한 다음 '테이블' 섹션을 클릭하면, 우리의 첫 번째 테이블이 생성된 것을 확인할 수 있습니다. 이제 이 테이블에 INSERT 문을 사용하여 가상 데이터를 채워넣는 시간입니다.\n\n# CUSTOMERS 테이블 채우기\n\nCUSTOMERS 테이블에 데이터를 추가하기 위해 INSERT INTO 문을 사용합니다. 이 문은 테이블에 새 레코드를 추가하는 데이터 조작 언어(DML)의 중요한 구성 요소입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가상 고객 데이터를 시스템적으로 삽입하는 방법은 다음과 같습니다:\n\n```js\n-- CUSTOMERS 테이블에 데이터 삽입\n\nINSERT INTO `chapter04`.`CUSTOMERS` \n(`customer_id`, `customer_name`, `customer_address`, `customer_city`, `customer_state`)\nVALUES \n(1, 'John Smith', '123 Maple Street', 'Orlando', 'FL');\n\nINSERT INTO `chapter04`.`CUSTOMERS` \n(`customer_id`, `customer_name`, `customer_address`, `customer_city`, `customer_state`)\nVALUES \n(2, 'Susan Johnson', '456 Oak Avenue', 'Austin', 'TX');\n\nINSERT INTO `chapter04`.`CUSTOMERS` \n(`customer_id`, `customer_name`, `customer_address`, `customer_city`, `customer_state`)\nVALUES \n(3, 'Robert Brown', '789 Pine Lane', 'Phoenix', 'AZ');\n\nINSERT INTO `chapter04`.`CUSTOMERS` \n(`customer_id`, `customer_name`, `customer_address`, `customer_city`, `customer_state`)\nVALUES \n(4, 'Linda Davis', '321 Birch Blvd', 'Raleigh', 'NC');\n\nINSERT INTO `chapter04`.`CUSTOMERS` \n(`customer_id`, `customer_name`, `customer_address`, `customer_city`, `customer_state`)\nVALUES \n(5, 'Michael Miller', '654 Cedar Place', 'Atlanta', 'GA');\n```\n\n각 INSERT INTO 명령은 CUSTOMERS 테이블에 새로운 행을 추가하며 customer_id, customer_name, customer_address, customer_city, customer_state의 값을 지정합니다.\n\n이 방법을 사용하면 각기 다른 항목을 가진 다양한 항목으로 테이블이 체계적으로 채워지며, SQL 쿼리 및 작업을 위한 기반을 마련할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 명령을 실행한 후에는 샘플 레코드가 채워진 CUSTOMERS 테이블이 생성되어서, 이후 레슨에서 SQL 함수 및 테이블 조인을 탐색하는 데 도움이 될 것입니다.\n\n# ORDERS 테이블 생성 및 채우기\n\nCUSTOMERS 테이블을 설정한 후, 다음 단계는 동일한 chapter04 스키마 내에서 ORDERS 테이블을 설정하는 것입니다.\n\n이 테이블은 고객 주문에 관한 다양한 세부 정보를 기록하며, 관련된 영업 직원 및 배송 정보가 포함됩니다. ORDERS 테이블을 생성하는 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nCREATE TABLE `chapter04`.`ORDERS` (\n  `order_id` INT NULL,\n  `customer_id` INT NULL,\n  `salesperson_id` INT NULL,\n  `order_date` DATETIME NULL,\n  `delivery_id` INT NULL);\n```\n\n이 테이블 스키마에는 다음이 포함되어 있습니다:\n\n- order_id: 각 주문의 고유 식별자입니다.\n- customer_id: 주문을 접수한 고객을 가리키는 CUSTOMERS 테이블과 연결된 참조입니다.\n- salesperson_id: 주문을 처리한 영업 담당자의 식별자입니다.\n- order_date: 주문이 접수된 날짜와 시간으로 DATETIME 형식을 사용합니다. 주문의 정확한 타이밍을 기록하기 위해 DATETIME 형식을 사용하는 것이 중요합니다.\n- delivery_id: 주문과 관련된 배송 세부 정보를 식별하는 식별자입니다.\n\nORDERS 테이블을 만들기 위해 이 명령을 실행한 후, MySQL Workbench(또는 선택한 SQL 관리 도구)에서 스키마 view를 새로 고침하여 chapter04 스키마 아래에 새로 생성된 테이블을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, 이 ORDERS 테이블에 데이터를 채워넣을 것입니다. 레코드를 삽입할 때 order_date 열의 DATETIME 형식에 유의해주세요.\n\n# 현재 데이터로 ORDERS 테이블 채우기\n\nORDERS 테이블을 채우기 위해 INSERT INTO 문을 사용하여 레코드를 추가하고 있습니다.\n\n각 주문의 고유 ID, 고객 ID, 판매자 ID, 주문의 현재 날짜 및 시간, 배송 ID를 지정하는 것을 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요거교과 자료에있는 DATETIME 유형의 order_date 컬럼에 정확한 현재 날짜와 시간을 캡처하는 SQL NOW() 함수 사용 방법을 확인해보세요:\n\n```js\nINSERT INTO `chapter04`.`ORDERS` (`order_id`, `customer_id`, `salesperson_id`, `order_date`, `delivery_id`)\nVALUES (1001, 1, 5, now(), 23);\n\nINSERT INTO `chapter04`.`ORDERS` (`order_id`, `customer_id`, `salesperson_id`, `order_date`, `delivery_id`)\nVALUES (1002, 1, 7, now(), 24);\n\nINSERT INTO `chapter04`.`ORDERS` (`order_id`, `customer_id`, `salesperson_id`, `order_date`, `delivery_id`)\nVALUES (1003, 2, 5, now(), 23);\n```\n\nNOW() 함수는 SQL에서 현재 날짜와 시간을 데이터베이스 서버가 실행 중인 시스템에서 가져오는 편리한 기능으로, 각 데이터 삽입 시 주문 날짜 컬럼이 정확하게 타임스탬프가 찍히는 것을 보장합니다.\n\n이 명령을 실행한 후, 각 레코드가 삽입 순간의 정확한 시간으로 타임스탬프가 찍히며, 현재 날짜와 시간 입력에 대한 NOW() 함수의 유용성을 잘 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQL 기능은 각기 다른 데이터베이스 관리 시스템(DBMS)마다 약간 다를 수 있습니다. 사용 중인 SQL 방언(MYSQL, PostgreSQL 등)에 대한 고유한 기능과 구문을 이해하기 위해 해당 문서를 참고하는 것이 중요합니다.\n\n이 단계는 데이터베이스에 데이터를 삽입하는 방법을 보여주는 것뿐만 아니라, 다양한 DBMS 환경에서 SQL 기능 및 응용 프로그램을 익히는 중요성을 강조합니다.\n\n다음으로, SELECT 쿼리를 실행하여 삽입된 데이터를 검토하고, 세 번째이자 마지막 테이블을 생성하고 채우기로 넘어갑니다.\n\n# SALESPERSON 테이블 생성 및 채우기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQL 여행을 계속하면서, 이제는 SALESPERSON 테이블 설정에 초점을 맞춥니다. 이 테이블은 영업 직원에 관한 정보를 저장하는 데 사용됩니다. 그들의 ID 및 이름을 포함합니다. 아래는 SALESPERSON 테이블을 생성하는 SQL 명령문입니다:\n\n```js\nCREATE TABLE `chapter04`.`SALESPERSON` (\n  `salesperson_id` INT NULL,\n  `salesperson_name` VARCHAR(50) NULL);\n```\n\n이 명령을 실행한 후에는 SALESPERSON 테이블이 설정되어, 영업 직원에 관한 데이터를 채울 준비가 되어 있습니다.\n\n# SALESPERSON 테이블 채우기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"SALESPERSON\" 테이블에 데이터를 입력하려면 각 판매원 레코드에 대해 INSERT INTO문을 사용합니다.\n\n`INSERT` 명령의 구체적인 내용은 안내서엔 포함되어 있지 않지만, 해당 명령의 일반적인 형태는 다음과 같습니다:\n\n```js\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (1, \"판매원 1\");\n\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (2, \"판매원 2\");\n\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (3, \"판매원 3\");\n\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (4, \"판매원 4\");\n\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (5, \"판매원 5\");\n\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (6, \"판매원 6\");\n\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (7, \"판매원 7\");\n```\n\n# 주문 ID 및 고객 이름 가져오기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n고객 이름은 CUSTOMERS 테이블에 있고 주문 ID는 ORDERS 테이블에 있습니다. 이 두 가지 다른 테이블에서 데이터를 추출해야 하는 상황입니다.\n\n이 시나리오는 SQL에서 테이블 조인의 필요성을 완벽하게 보여줍니다. 이를 통해 테이블 간의 관계를 형성하여 결합된 데이터를 검색할 수 있습니다.\n\n각 주문이 특정 고객과 연결되어 있다는 것은 ORDERS 테이블의 고객 ID로 확인할 수 있었습니다. 이 두 테이블 간에 관계형 열이 있는 것이 분명합니다.\n\n이 연결은 무작위가 아니라, 데이터베이스 설계의 의도적인 측면으로, 주문이 고객과 연관이 있는 것을 나타냅니다. 실제적으로 주문은 관련된 고객이 없이는 존재할 수 없다는 논리적인 규칙이 데이터베이스 모델링 단계에서 설정되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n손님 ID가 일반적으로 기본 키로 작용하는 이유는 각 손님을 고유하게 식별하여 동일한 ID를 가진 두 명의 손님이 없도록 하는 것입니다. 이는 개인이 고유한 식별 번호를 갖는 것과 유사합니다.\n\n필요한 정보를 가져 오기 위해 ORDERS 및 CUSTOMERS 테이블 간의 Inner Join을 실행할 것입니다. 이 쿼리를 어떻게 구성하는지 살펴보겠습니다:\n\n```js\nSELECT o.order_id, c.customer_name\nFROM `chapter04`.`ORDERS` o\nINNER JOIN `chapter04`.`CUSTOMERS` c \nON o.customer_id = c.customer_id;\n```\n\n- o 및 c는 각각 ORDERS 및 CUSTOMERS 테이블에 대한 별칭으로, 우리의 표기법을 간단하게하는 데 도움이 됩니다.\n- SELECT 문은 주문 테이블(o)에서 order_id 및 고객 테이블(c)에서 customer_name을 가져 오겠다고 지정합니다.\n- INNER JOIN 절은 두 테이블을 공통 customer_id 열에 연결하여 해당 고객 레코드가있는 주문 만 검색됨을 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 접근 방식은 SQL에서 Inner Join의 강점을 보여줍니다. 이는 공통 관계에 따라 여러 테이블에서 데이터를 결합하여 분석이나 보고 목적으로 포괄적인 데이터 집합을 편집하는 데 도움이 됩니다.\n\n```js\nSELECT o.order_id, c.customer_name\nFROM ORDERS o\nINNER JOIN chapter04.CUSTOMERS c ON o.customer_id = c.customer_id;\n```\n\n이 쿼리는 주문 ID와 해당 주문을 한 고객의 이름을 반환합니다. 이는 주문 및 고객 테이블 간의 공통 customer_id 필드를 기반으로 Inner Join을 수행하여 가능합니다.\n\nSQL 쿼리에서 'o'를 ORDERS 테이블과 'c'를 CUSTOMERS 테이블에 대한 별칭으로 사용하면 구문을 간소화할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 주문 ID와 고객 이름을 검색하려면 INNER JOIN을 사용하여 customer_id와 같은 공통 열을 기준으로 이러한 테이블을 연결할 수 있습니다.\n\n```js\nSELECT p.order_id, c.customer_name\nFROM ORDERS p\nINNER JOIN CUSTOMERS c ON p.customer_id = c.customer_id;\n```\n\n이 쿼리는 WHERE 절을 사용하여 두 테이블을 연결하는 대안으로 INNER JOIN 구문을 활용하여 customer_id에 따라 주문과 고객을 효과적으로 매칭합니다.\n\nINNER JOIN의 사용법을 보여드린 것은, 명확한 관계가 존재하는 데이터를 가져오는 능력 때문에 널 값이 발생하지 않습니다. INNER JOIN 대신 WHERE 절을 사용하여 직접 열을 비교할 수 있어 이와 동일한 결과를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 개의 쿼리를 옆으로 배치하면 차이가 명확해집니다. 두 쿼리를 실행하면 동일한 결과가 나옵니다. INNER JOIN이 교집합 집합 이론에서의 역할을 강조합니다 — 이는 초등 교육에서 소개된 개념입니다.\n\n테이블 조인을 위해 INNER JOIN 또는 WHERE를 사용하는 것은 개인적인 선택입니다. WHERE를 선호하는 사람도 있을 수 있습니다. 이는 직접적인 연결 이해와 일치하기 때문에 테이블 연결을 간편하게 만들 수 있습니다. 그러나 두 방법 간에는 문법적인 차이가 있으므로 문법 인식이 중요합니다.\n\n```js\n# 주문 ID, 고객 이름, 영업 담당자 이름 반환\n# 3개의 테이블과의 Inner Join\n\nSELECT O.order_id, C.customer_name, S.salesperson_name\nFROM chapter04.ORDERS AS O\nINNER JOIN chapter04.CUSTOMERS AS C ON O.customer_id = C.customer_id\nINNER JOIN chapter04.SALESPERSON AS S ON O.salesperson_id = S.salesperson_id;\n```\n\n이 쿼리는 ORDERS, CUSTOMERS, SALESPERSONS 세 개의 테이블에서 INNER JOIN을 실행하여 각 주문의 주문 ID, 고객 이름 및 영업 담당자 이름을 검색합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nORDERS 테이블에서 시작하여 customer_id를 매칭하여 CUSTOMERS와 조인한 다음, salesperson_id를 기준으로 SALESPERSONS와 또 다른 조인을 수행합니다.\n\n이 쿼리는 데이터를 교차시켜 테이블 간 관련 레코드의 가장 작은 집합으로 결과를 제한하며, 세 주문과 해당하는 고객 및 영업사원을 리턴합니다.\n\n이 접근 방식은 정확하지만 INNER JOIN을 사용하지 않고 대안적인 방법으로 적용할 수도 있어 이해를 간소화할 수 있습니다.\n\n```js\nSELECT O.order_id, C.customer_name, S.salesperson_name\nFROM chapter04.ORDERS AS O, \nchapter04.CUSTOMERS AS C, \nchapter04.SALESPERSONS AS S\nWHERE O.customer_id = C.customer_id\nAND O.salesperson_id = S.salesperson_id;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 쿼리는 WHERE 절을 사용하여 customer_id와 salesperson_id를 일치시켜 ORDERS, CUSTOMERS, 그리고 SALESPERSON 테이블을 조인하고, 괄호 없이 주문 ID, 고객 이름, 그리고 영업 직원 이름을 검색합니다.\n\n이 접근 방식은 ID를 직접 비교하여 이해를 단순화하고, 필요한 데이터 관계를 설정하여 다수의 테이블에 확장 가능한 논리적 방식으로 INNER JOIN을 수행하는 간단한 방법을 보여줍니다.\n\n이 방법은 가장 일반적인 테이블 조인 기법 중 하나를 보여주며, 이 코스에서 더 자세히 탐구할 다양한 조인 방법을 시사합니다.\n\n# INNER JOIN 사용 및 구문에 대한 심층적 탐색\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nINNER JOIN에 대해 더 깊이 들어가 봅시다. INNER JOIN은 WHERE, ORDER BY, GROUP BY 등의 SQL 절과 결합할 수 있는 가장 일반적인 조인 유형입니다.\n\n```js\n# Inner Join - ANSI 표준\nSELECT O.order_id, C.customer_name\nFROM chapter04.ORDERS AS O\nJOIN chapter04.CUSTOMERS AS C ON O.customer_id = C.customer_id;\n```\n\n위 쿼리는 ANSI 표준 INNER JOIN을 보여주며, 이는 이전에 사용한 것으로, ANSI 표준을 준수하는 데이터베이스 관리 시스템(DBMS) 전반에서 보편적으로 지원되는 형식입니다.\n\n거의 모든 최신 DBMS가 이 표준을 지원하여 호환성을 확보합니다. 흥미로운 점은 INNER를 생략하고 JOIN만 사용하면 동일한 결과를 얻는다는 것이며, 이는 JOIN 만으로도 기본적으로 INNER JOIN으로 간주됨을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 LEFT JOIN 또는 RIGHT JOIN의 경우 \"left\" 또는 \"right\" 특정 키워드를 명시적으로 사용해야합니다.\n\n# USING 절을 사용한 INNER JOIN 단순화\n\n동일한 이름의 열을 사용하여 테이블을 조인할 때, USING 절은 간편한 방식을 제공합니다. ON 절에서 각 테이블의 열을 명시하는 대신, USING은 조인을 위한 공통 열을 직접 식별합니다. 이 방법은 코드 가독성을 향상시키며, SQL뿐만 아니라 모든 프로그래밍 관행에서 중요합니다. 명확하고 이해하기 쉬운 코드를 유지하면 향후 검토나 수정이 보다 쉬워지며, 여러분이나 다른 사람들이 코드를 유지할 때 도움이 됩니다.\n\n다음은 테이블 간에 동일한 이름을 갖는 열에 대해 USING을 사용하여 INNER JOIN을 적용하고, 결과를 필터링하고 정렬하는 방법입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sql\n# INNER JOIN과 WHERE, ORDER BY 사용한 쿼리\nSELECT O.order_id, C.customer_name\nFROM chapter04.ORDERS AS O\nINNER JOIN chapter04.CUSTOMERS AS C USING (customer_id)\nWHERE C.customer_name LIKE 'Bob%'\nORDER BY O.order_id DESC;\n```\n\n이 쿼리는 주문 및 고객 이름을 추출하는 데 초점을 맞추며, 구체적으로 \"Bob\"이라는 이름을 가진 고객을 대상으로 하고 주문 ID를 기준으로 내림차순으로 결과를 정렬합니다.\n\n테이블 간의 관계를 customer_id를 사용하여 활용함으로써, 이 쿼리는 근사적인 일치를 나타내는 LIKE 연산자를 사용하여 \"Bob\"으로 시작하는 모든 이름을 캡처하는 데이터를 능숙하게 필터링합니다.\n\n이 체계적인 방법은 SQL의 INNER JOIN의 적응성과 깊이를 강조하며, 다른 절과 결합될 때 데이터 분석의 범위를 크게 확장시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쿼리가 여러 테이블을 조인하고 필터를 적용하거나 정렬 또는 그룹화를 실행하는 등 보다 정교한 데이터 조작 기술로 진화하는 방식을 보여줍니다. 이어지는 장에서는 더 복잡한 데이터 조작 기법을 약속합니다.\n\n# SQL에서 LEFT JOIN 탐색\n\nINNER JOIN을 탐색한 후에 이제 LEFT JOIN에 주목해 보겠습니다.\n\n이 유형의 조인은 오른쪽 테이블에 일치하는 항목이 있는지 여부와 관계없이 왼쪽 테이블의 모든 레코드를 포함하여 테이블 간 관계를 보다 폭넓게 이해할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법을 사용하면 이론에서 실제 SQL 코드 구현으로 원활하게 전환하여 개념을 포괄적으로 이해할 수 있습니다.\n\n```js\n# WHERE 및 ORDER BY를 사용한 Inner Join\n\nSELECT O.order_id, C.customer_name\nFROM chapter04.ORDERS AS O\nINNER JOIN chapter04.CUSTOMERS AS C USING (customer_id)\nWHERE C.customer_name LIKE 'Bob%'\nORDER BY O.order_id DESC;\n```\n\n# 데이터 검색을 위한 LEFT JOIN 활용\n\nMySQL Workbench에서 INNER JOIN을 활용한 주문 ID와 고객명을 가져오는 시나리오입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 일부 고객이 아직 주문을하지 않았을 수 있다는 점을 인식하여, 주문 상태에 관계없이 모든 고객을 포함하는 쿼리를 찾고 있습니다. 이 경우 INNER JOIN은 목적에 부합하지 않습니다. 왜냐하면 주문이 있는 고객만 반환하기 때문입니다.\n\n이를 해결하기 위해 LEFT JOIN이 선택된 도구가 되어, 왼쪽 테이블에서 일치 항목이 없는 고객까지 모두 검색할 수 있도록 해줍니다. 따라서 보고서나 관리 인사이트를 위한 완전한 데이터 세트를 제공합니다.\n\n```js\n# Left Join – 오른쪽 테이블에서 일치 항목이 없어도 왼쪽 테이블의 모든 데이터를 가져오고자 함\nSELECT C.customer_name, O.order_id\nFROM chapter04.CUSTOMERS AS C\nLEFT JOIN chapter04.ORDERS AS O ON C.customer_id = O.customer_id;\n```\n\n# LEFT JOIN으로 쿼리 순서에 미치는 영향\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쿼리에서 테이블의 순서는 결과에 큰 영향을 미칩니다.\n\n이를 보여주기 위해, 'C'를 CUSTOMERS에, 'P'를 CORDERS에 별칭으로 사용하여 고객 이름과 주문 ID를 가져오는 쿼리를 설정했습니다.\n\nLEFT JOIN을 실행하여, 모든 주문과 관련이 있는지 없는지와 상관없이 모든 고객을 포함하는 것이 목표였습니다. 이 기술을 사용하면 주문을 한 고객 및 주문이 없는 고객을 NULL로 나타낼 수 있습니다.\n\nNULL을 설명적인 값으로 대체하기 위해 CASE 문을 사용하는 등의 조정을 통해 출력을 더 정제할 수 있습니다. 궁극적으로 LEFT JOIN(또는 LEFT OUTER JOIN으로 교차 사용 가능)을 사용하면 왼쪽 테이블의 모든 항목이 반환되어 오른쪽 테이블에서 일치하는 레코드 여부에 관계없이 데이터 무결성을 유지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sql\nSELECT C.customer_name, O.order_id\nFROM chapter04.CUSTOMERS AS C\nLEFT OUTER JOIN chapter04.ORDERS AS O \nON C.customer_id = O.customer_id;\n```\n\n# LEFT JOIN vs. LEFT OUTER JOIN\n\nLEFT OUTER JOIN을 사용하면 LEFT JOIN과 동일한 결과가 나오며 SQL에서 두 용어가 서로 바꿔 사용될 수 있음을 강조합니다. 그러나 \"LEFT\"를 제거하면 쿼리의 동작이 근본적으로 변경되어 INNER JOIN으로 기본 설정되어 오른쪽 테이블과 일치하는 레코드에만 중점이 맞춰집니다.\n\n이 차이점은 \"LEFT\"를 명시하여 왼쪽 테이블의 모든 레코드를 포함시킬 중요성을 강조합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOUTER 옵션을 사용하는 것은 주로 간소화를 위해 생략되는 경우가 많습니다. 쿼리에서 테이블 순서를 변경해 보는 것은 더 많은 통찰력을 제공할 수 있으며, 해당 조정이 쿼리 결과에 미치는 영향을 완전히 이해하기 위해 실험하는 것을 촉구합니다.\n\n```js\n# 테이블 순서를 바꾸면 결과가 달라집니다\nSELECT C.customer_name, O.order_id\nFROM chapter04.ORDERS AS P\nLEFT JOIN chapter04.CUSTOMERS AS C \nON C.customer_id = P.customer_id;\n```\n\n# LEFT JOIN 쿼리에서 테이블 순서의 영향\n\n위에 표시된 LEFT JOIN 쿼리를 실행하면, 모든 고객이 올바르게 반환되며, 그들이 주문을 한 여부에 상관없이 모두 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 순서를 반전하여 LEFT JOIN을 유지하더라도 결과가 크게 바뀐다는 것을 알 수 있습니다. 이는 INNER JOIN의 동작과 유사한 모습을 보여줍니다.\n\nLEFT 또는 RIGHT JOIN을 사용할 때 테이블의 순서가 중요하며, 방향(왼쪽 또는 오른쪽)은 어떤 테이블의 레코드가 결과에 완전하게 포함될지를 지정합니다.\n\n다음 수업에서는 이 개념을 더 깊이 탐구하여 RIGHT JOIN을 살펴보고, SQL 조인 작업 및 테이블 순서에 대한 의존성을 이해하는 데 도움이 될 것입니다.\n\n# RIGHT JOIN을 사용하여 테이블 순서 문제 해결하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 비디오에서는 주문이 있는 경우에도 고객을 모두 포함하는 LEFT JOIN을 탐색했어요. 표의 순서를 바꾸면 INNER JOIN과 유사한 동작을 나타냈죠.\n\n표를 재배열하지 않고 이를 해결하기 위해 RIGHT JOIN이 해답이에요. 이는 오른쪽 테이블(이 경우 CUSTOMERS)의 모든 항목이 포함되도록 합니다. 왼쪽 테이블(ORDERS)에서 일치하는 값이 없어도요. 이 접근 방식은 초기 LEFT JOIN 전략을 반대로 하여 포괄적 데이터 검색을 위해 오른쪽 테이블에 중점을 둡니다.\n\n```js\n# Right Join – 왼쪽 테이블에서 일치하는 값이 없어도 오른쪽 테이블의 모든 데이터를 가져오고 싶다는 것을 나타냅니다\nSELECT C.customer_name, O.order_id\nFROM chapter04.ORDERS AS P\nRIGHT JOIN chapter04.CUSTOMERS AS C \nON C.customer_id = P.customer_id;\n```\n\n# 표준 접근법을 이용한 JOIN 전략 최적화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 순서를 변경하는 것은 번거로울 수 있습니다. 따라서 포괄적인 보고서를 위해 항상 LEFT JOIN을 사용하는 선호도가 있습니다.\n\n이 개인적인 전략은 일관된 패턴을 확립하여 쿼리 실행을 간소화하고 학습 및 기억을 향상시킵니다. 일상 업무에서 이러한 표준을 채택하면 SQL 개념을 신속하게 이해하고 적용하는 데 도움이 됩니다. LEFT 또는 RIGHT JOIN 선택은 테이블 위치 및 모든 데이터를 포함해야 하는 요구에 따라 다릅니다.\n\n이 체계적인 방법론은 효율적이고 효과적인 데이터 검색을 위해 SQL 실습에서 일관성의 중요성을 강조합니다.\n\n# 포괄적 데이터 분석을 위한 쿼리 작성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 작업은 주문 날짜, 고객 이름 및 모든 판매원을 반환하는 쿼리를 작성하는 것입니다. 주문과 연관이 있는 여부에 관계 없이 모든 판매원을 고객 이름순으로 정렬하여야 합니다.\n\nLEFT JOIN, RIGHT JOIN 또는 INNER JOIN을 사용할지 여부는 특정 데이터 검색 목표에 따라 결정되며, 학습 과정에서 문제 해결 능력의 중요성을 강조합니다. 아래는 이 작업을 수행하는 방법입니다:\n\n```js\n# 주문 날짜, 고객 이름 및 모든 판매원을 고객 이름순으로 확인\nSELECT O.order_date, C.customer_name, S.salesperson_name\nFROM chapter04.ORDERS AS O\nJOIN chapter04.CUSTOMERS AS C ON O.customer_id = C.customer_id\nRIGHT JOIN chapter04.SALESPERSON AS S ON O.salesperson_id = S.salesperson_id\nORDER BY C.customer_name;\n```\n\n이 해결책은 모든 관련 데이터를 포함해야 하는 요구사항에 따라 적절한 JOIN 유형을 선택해야 함을 보여줍니다. 여기서는 주문과 관련이 있는지 여부에 관계 없이 모든 판매원이 나열되고 결과를 고객 이름으로 정렬합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 쿼리는 정확한 데이터 쿼리 기술을 통해 비즈니스 요구 사항을 해결하는 SQL의 전략적 측면을 강조합니다.\n\n이 쿼리는 모든 주문에 대한 주문 날짜와 고객 이름을 제공하며, 모든 영업사원을 포함합니다. 연관된 주문이 있는 경우와 없는 경우 모두 결과를 정렬하여 고객 이름을 기준으로 정렬합니다. 영업사원이 연관된 주문이 없는 경우 결과에서 주문 날짜와 고객 이름 필드는 NULL일 것입니다.\n\n```js\n# 주문 날짜, 고객 이름, 모든 영업사원을 반환하며, 연관된 주문이 있는지 여부에 관계없이 결과를 고객 이름을 기준으로 정렬합니다.\nSELECT\n  CASE\n    WHEN O.order_date IS NULL THEN '주문 없음'\n    ELSE O.order_date\n  END AS order_date,\n  CASE\n    WHEN C.customer_name IS NULL THEN '주문 없음'\n    ELSE C.customer_name\n  END AS customer_name,\n  S.salesperson_name\nFROM chapter04.ORDERS AS O\nJOIN chapter04.CUSTOMERS AS C ON O.customer_id = C.customer_id\nRIGHT JOIN chapter04.SALESPERSON AS S ON O.salesperson_id = S.salesperson_id\nORDER BY C.customer_name;\n```\n\n# 조건부 서식을 사용하여 결과 향상하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCASE 문을 사용하여 조건부 논리를 실행함으로써 보고서에는 널 값이 표시되지 않도록 보장합니다.\n\n그 대신, 누락된 주문 날짜 또는 고객 이름은 '주문 없음'으로 레이블이 지정되어, 임원 검토를 위해 명확성과 유틸리티를 향상시켜줍니다.\n\n이 쿼리는 주문 결과를 고객 이름별로 철저하게 정렬하여, 조직적이고 정보를 얻기 쉬운 출력을 제공하여 추가 분석이나 프레젠테이션에 적합합니다.\n\n```js\nSELECT\n  CASE\n    WHEN O.order_date IS NULL THEN '주문 없음'\n    ELSE O.order_date\n  END AS order_date,\n  CASE\n    WHEN C.customer_name IS NULL THEN '주문 없음'\n    ELSE C.customer_name\n  END AS customer_name,\n  S.salesperson_name\nFROM chapter04.ORDERS AS O\nRIGHT JOIN chapter04.CUSTOMERS AS C ON O.customer_id = C.customer_id\nRIGHT JOIN chapter04.SALESPERSON AS S ON O.salesperson_id = S.salesperson_id\nORDER BY C.customer_name;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방식은 철저한 데이터 수집의 즉각적인 요구 사항 뿐만 아니라 널 값(null values)을 의미 있는 자리 표시자로 대체함으로써 보고서의 표현을 개선하여, 경영 총괄 또는 분석 처리에 대비한 완전히 형식화된 뷰를 제공합니다.\n\n# 참조 무결성 오류 해결\n\nORDERS 테이블에 “고아(orphans)” 레코드를 추가하는 것 — 해당 고객이나 판매원과 연관이 없는 주문 —은 관계형 데이터베이스에서 참조 무결성을 유지하는 도전을 강조합니다.\n\n이 개념은 데이터베이스의 모든 레코드가 적절하게 연결되어 있어 고아 데이터의 존재를 방지하는 것을 보장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 이 예제는 이러한 제약 조건을 우회하여 SQL이 이러한 불일치를 식별하는 데 어떻게 사용될 수 있는지 보여주기 위해 일부러 만들어졌습니다.\n\n```js\nINSERT INTO `chapter04`.`ORDERS` (`order_id`, `customer_id`, `salesperson_id`, `order_date`, `delivery_id`)\nVALUES (1004, 10, 6, NOW(), 23);\n```\n\n성공적으로 실행된 이 삽입은 참조 무결성 검사가 적용되지 않았음을 나타내며, 유효한 고객 링크가 없는 주문을 만들 수 있게 했습니다.\n\n이 시나리오는 성능 저하와 데이터 불일치로 이어질 수 있는 일반적인 데이터베이스 문제를 나타냅니다. 성능 문제를 해결하기 위해 일시적으로 참조 무결성을 비활성화하는 경우도 있지만, 속도를 위해 데이터 무결성이 더 손상될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오늘은 주체 없는 레코드를 식별하는 SQL 전략에 대해 살펴보겠습니다. 데이터 신뢰성과 시스템 무결성을 보장하기 위해 견고한 데이터베이스 관리 관행의 중요성을 강조할 것입니다.\n\n# SQL 조인을 활용한 주체 없는 레코드 식별\n\n의도적으로 데이터베이스에 도입된 주체 없는 레코드를 식별하는 과제에 대처하기 위해 SQL 조인의 사용법을 살펴보겠습니다.\n\n이러한 문제를 생성하고 해결하는 일련의 과정은 SQL 지식을 실제 시나리오에서 실용적으로 적용하는 가치 있는 학습 도구로 작용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLEFT JOIN을 사용하여 고객 및 해당 주문 ID를 모두 검색하여 주문이 존재하지 않는 경우에는 주문이 없는 상태인 NULL 값을 사용하여 고아 레코드를 감지하려고 시도했습니다:\n\n```js\n# 누락된 주문 식별을 위한 Left Join\nSELECT C.customer_name, O.order_id\nFROM chapter04.CUSTOMERS AS C\nLEFT OUTER JOIN chapter04.ORDERS AS O ON C.customer_id = O.customer_id;\n```\n\n이 쿼리는 모든 고객을 성공적으로 나열하며, 주문이 누락될 때 NULL 주문 ID로 나타냅니다. 그러나 모든 종류의 고아 레코드를 감지하는 문제를 완전히 해결하지는 않습니다. RIGHT JOIN으로 전환하면 고객이 없는 주문을 제외하고 연결된 고객이 없는 주문을 나열할 수 있습니다.\n\n모든 불일치 사항을 종합적으로 식별하기 위한 논리적 단계는 LEFT 및 RIGHT JOIN의 통찰을 결합하려고 하는 FULL OUTER JOIN을 사용하는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFULL OUTER JOIN은 모든 SQL 데이터베이스 관리 시스템에서 일반적으로 지원되지 않으므로 MySQL을 포함한 SQL에서 모든 고아 레코드를 식별하는 포괄적인 솔루션을 제공하기 위해 분리된 LEFT 및 RIGHT JOIN 쿼리의 결과를 병합하기 위해 UNION을 사용하는 것이 논리적인 다음 단계입니다. 이 방법은 다음 레슨에서 자세히 다룰 예정입니다.\n\n# UNION과 UNION ALL 데이터 검색 활용하기\n\n주문 및 고객을 모두 식별하는 도전을 해결하기 위해 관련이 없는 것을 포함하여 SQL은 UNION과 UNION ALL 명령을 제공합니다. 이러한 명령은 별도의 쿼리 결과를 병합하여 완전한 데이터 세트를 형성합니다.\n\n- LEFT OUTER JOIN: 주문이 없는 모든 고객을 검색하며, NULL로 표시된 미배치 주문을 포함합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nSELECT C.customer_name, O.order_id\n FROM chapter04.CUSTOMERS AS C\n LEFT OUTER JOIN chapter04.ORDERS AS O ON C.customer_id = O.customer_id;\n```\n\n- RIGHT OUTER JOIN: 연결된 고객이 없어도 모든 주문을 포착합니다.\n\n```js\nSELECT C.customer_name, O.order_id\n FROM chapter04.CUSTOMERS AS C\n RIGHT OUTER JOIN chapter04.ORDERS AS O ON C.customer_id = O.customer_id;\n```\n\n- UNION ALL: 위의 조인 결과를 결합하여 중복을 허용합니다.\n- UNION: UNION ALL과 유사하지만 중복 레코드를 제거하여 고유한 결과만 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUNION과 UNION ALL의 주요 차이점은 중복 핸들링에 있습니다: UNION ALL은 중복을 포함하여 모든 레코드를 포함하고, UNION은 중복을 필터링하여 고유한 결과만 표시합니다.\n\n이 차이는 종합적인 데이터 포함이 필요한 작업 또는 정제된, 고유한 결과가 필요한 작업에 중요합니다.\n\nUNION 명령을 사용할 때 중요한 고려 사항은 결합된 쿼리 전체에 걸친 열의 개수와 유형을 일치시키고 데이터 무결성 및 쿼리 성능을 보장하기 위해 일관된 열 순서를 유지하는 것입니다.\n\nUNION 작업은 성능에 영향을 미칠 수 있지만, FULL OUTER JOIN을 지원하지 않는 환경에서 원하는 데이터 컴파일을 달성하는 유일한 해결책일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 테이블 조인 요약\n\n이번 개요는 SQL Server 커뮤니티에서 주목받는 인물인 Steve Stedman이 작성한 차트를 참조하고 있습니다. 해당 차트는 SQL Server 및 MySQL와 같은 다른 SQL 데이터베이스 시스템에서 적용 가능한 다양한 조인 유형을 설명하고 있습니다.\n\nStedman의 블로그는 데이터베이스 지식을 널리 보급해 왔으며 SQL Server의 미묘한 점들을 강의 및 참고 자료를 통해 제공하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 기본 선택 및 조인: 두 테이블에서 데이터를 선택하는 것으로 시작하여 INNER JOIN(교차), LEFT 및 RIGHT OUTER JOINS를 다루며 'OUTER' 키워드 없이도 동등성을 강조합니다.\n- 고급 조인 개념: SEMI-JOIN 및 ANTI-SEMI-JOIN을 소개하며 SQL의 EXISTS 연산자를 사용하여 데이터를 고유하게 필터링하고, 한 테이블에서 부분 또는 배타적 데이터 집합을 검색하는 방법을 보여줍니다.\n- CROSS 및 FULL OUTER JOINS: CROSS JOIN(카테시안 곱)과 FULL OUTER JOIN(일치하는 항목이 있는 경우와 없는 모든 레코드를 결합)을 구별하며, 그래픽 표현에서 보이는 유사성에 대해 경계를 주의합니다.\n- 연합 작업: UNION 및 UNION ALL을 사용하여 직접적인 지원이 없는 시스템에서 FULL OUTER JOIN 효과를 모방하는 방법을 설명하며 포괄적인 데이터 통합을 달성합니다.\n- 복잡한 관계: 다양한 조인 유형을 통해 다중 테이블 관계를 처리하는 것으로 마무리되며, 질의 복잡성 및 데이터 검색 능력을 향상시킵니다.\n\n이 차트는 기본부터 복잡한 시나리오까지 SQL 조인을 적용하는 실용적인 가이드로, SQL에서 테이블 조인 기술을 숙달하기 위해 실습을 장려합니다.\n\n# *SQL 테이블 조인에 대한 결론\n\n이 글을 통해 SQL에서 테이블 조인의 세계로 들어가 보았습니다. 관계형 데이터베이스를 다루는 데 중요한 측면 중 하나입니다. Steve Stedman의 블로그와 MySQL Workbench와 같은 도구에서의 실습을 통해, 다양한 조인 유형을 통해 효과적인 데이터 조작을 둘러싼 복잡성의 층을 해제해 나갔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nINNER JOIN과 LEFT 및 RIGHT OUTER JOIN의 적응성부터 직접적인 지원이 없는 시스템에서 FULL OUTER JOIN을 구현하는 도전에 대처하는 기본 조작부터, 조인 유형의 선택이 쿼리 결과와 성능에 직접적 영향을 미친다는 것을 배웠습니다. 우리는 참조 무결성의 가치를 강조했고 고아 레코드를 감지하고 해결하는 방법을 강조하여 데이터 일관성과 신뢰성을 보장했습니다.\n\nUNION 및 UNION ALL을 결합하여 완전한 조인을 시뮬레이트하고 CROSS JOIN을 특정 시나리오에 적용함으로써 SQL의 다양성을 강조하여 복잡한 데이터 분석 요구를 충족시키는 능력을 보여주었습니다. 반 조인과 안티-반 조인과 같은 고급 개념을 소개하여 SQL이 특정 데이터 필터링과 선택을 위해 능력을 강조하여 전통적인 조인 경계를 넘어섰습니다.\n\n이 기사는 쿼리 표준을 설정하고 코드 가독성을 유지하며 데이터베이스 유지, 이해 및 확장을 시간이 지남에 걸쳐 용이하게 하는 중요성을 재확인했습니다. 우리는 계속된 학습과 실험을 촉구하며, 마주한 각 도전을 극복함으로써 SQL 능력을 향상시키고 전문가들이 복잡한 비즈니스 문제를 효율적으로 정확하게 해결할 수 있도록 장비를 되찾습니다.\n\n요약하자면, 테이블 조인은 단순히 기술적 도구가 아니라, 원시 데이터를 가치 있는 통찰로 변환하는 의미 있는 쿼리를 만드는 기본입니다. 우리가 향향할 미래 챕터로 나아가면서, 자신감과 전문지식을 갖춘 방대한 데이터베이스 세계를 탐색하는 데 필요한 견고한 지식 기반과 실무 경험을 지속적으로 가지고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n감사합니다! 🐼❤️","ogImage":{"url":"/assets/img/2024-06-19-MasteringSQLJoins_0.png"},"coverImage":"/assets/img/2024-06-19-MasteringSQLJoins_0.png","tag":["Tech"],"readingTime":31},{"title":"파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략","description":"","date":"2024-06-19 16:29","slug":"2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement","content":"\n\n프로젝트에서 데이터베이스와 상호 작용하는 프로그래밍을 할 때, 쿼리를 어떻게 조직화하고 재사용할지 고민하는 일이 종종 있어요. 이럴 때 몇몇 개발자는 쿼리를 보다 동적으로 만들기 위해 문자열을 연결하는 함수를 만들기도 하고, 다른 사람들은 이 쿼리를 정의하는 변수를 만들기를 선호하기도 해요. 일부 더 고급 개발자들은 쿼리를 정의할 때 SQLAlchemy 객체 선언을 사용하기도 하는데, 이 방법은 배우는 곡선이 있어서 더 복잡한 쿼리를 다룰 때 개발 프로세스를 어렵게 만들 수 있어요.\n\n어느 날, 저는 코드를 지나치게 복잡하게 만들지 않고도 조직적이고 재사용 가능한 방식으로 작업하기 위한 해결책을 찾던 중 흥미로운 라이브러리인 aiosql을 우연히 발견했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 기사에서는 aiosql 라이브러리를 어떻게 사용하는지를 검토하고 문서에서 설명되는 내용과 함께 다른 컨텍스트에서 구현하는 데 사용한 몇 가지 방법을 공유하겠습니다.\n\n# ⚙️ aiosql 라이브러리란 무엇인가요?\n\nAiosql은 🐍파이썬 라이브러리로, SQL 쿼리를 주요 파이썬 프로젝트 코드와 분리된 파일에 쉽게 작성할 수 있도록 도와줍니다. 이러한 쿼리는 SQL 파일에 저장되며, 이후에는 🐍파이썬 객체 내의 메서드로 변환됩니다.\n\nAiosql의 또 다른 주목할 만한 기능은 매개변수를 받아들이는 동적 메서드를 생성할 수 있는 능력으로, 유연한 쿼리 실행과 기본 데이터베이스와의 효과적인 상호 작용을 가능케합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQL 쿼리를 Python 코드에서 분리함으로써 코드를 더 깔끔하고 모듈식으로 유지하는 데 도움이 됩니다. 이는 프로젝트의 가독성과 유지보수성을 향상시킵니다.\n\n# ⚙️ aiosql의 작동 방식\n\n다이어그램에서 볼 수 있듯이 SQL 파일에서 모든 쿼리를 가져와서 Python 코드에서 쿼리 헤더에 정의된 이름으로 호출하여 사용할 수 있습니다. 이후에 Python 코드에서 필요한 매개변수를 직접 전달하여 쿼리를 실행할 수 있습니다. 이를 통해 쿼리를 재사용하고 유지보수하기 쉽게 만들 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ⚙️ Aiosql 라이브러리 핵심 기능\n\n아래에서는 이 라이브러리가 이미 갖고 있거나 사용에 기반한 기능을 가질 수 있는 일련의 기능을 공유하겠습니다:\n\n- 데이터베이스 작업을 위한 CRUD 기능 제공 (Create: Insert, Read: Select, Update, Delete).\n- Python 코드와 SQL 코드를 분리하여 여러 데이터베이스가 있는 프로젝트에서 쿼리를 찾기 쉽게 함.\n- 각 쿼리에 설명적인 이름과 독스트링을 할당할 수 있어 Python 함수와 유사하게 쿼리를 문서화할 수 있음.\n- 프로젝트 내에서 쿼리 카탈로그를 작성하도록 지원하여 엔터티, 데이터베이스 또는 기타 그룹별 식별을 용이하게 함.\n- 동적 값 전달과 필요에 따라 수정할 수 있는 동적 쿼리를 쉽게 생성할 수 있음.\n\n![PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2](/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ⚙️ Aiosql 튜토리얼\n\n## 🔧 사전 준비 사항\n\n- 🐳 도커\n- 🐙 도커 컴포즈\n- 🐍 Python 라이브러리 설치:\n\n```js\npip install aiosql pandas\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 🚀 빠른 시작\n\n## 🛠️ 포스트그레스 데이터베이스 만들기\n\n- 1️⃣ — 이 저장소를 복제합니다: aiosql-tutorial\n\n```js\ngit clone https://github.com/r0mymendez/aiosql-tutorial.git\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 2️⃣ 'postgres' 폴더로 디렉토리 변경해주세요\n\n```js\ncd aiosql-tutorial/postgres\n```\n\n- 3️⃣ PostgreSQL 데이터베이스를 생성해주세요 → 터미널에서 실행하세요:\n\n```js\ndocker-compose -f docker-compose.yml up --build\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 4️⃣ 이제 컨테이너가 실행 중인지 확인하세요 → 터미널에서 다음을 실행해보세요:\n\n```js\ndocker ps\n```\n\n- 5️⃣ CSV 파일을 로드하세요 → 컨테이너 내에서 CSV 파일을 로드하려면 다음 명령어를 실행하세요:\n\n```js\ncd src\npython3 etl.py\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 🏥 병원 데이터\n\naiosql을 구현하기 위해 Synthea에서 제공하는 데이터셋을 사용할 것입니다. 이 데이터는 매사추세츠 지역 인구의 다양한 변수를 고려한 시뮬레이션에서 생성된 합성 데이터입니다. 이 데이터셋에서는 `conditions`, `encounters`, `patients` 테이블을 사용할 것입니다.\n\n# 👥 사용자 이야기\n\n실제 상황을 반영하기 위해 3가지 사용 사례를 만들어보겠습니다:\n* 1️⃣ — 데이터 분석가로서, 방문 횟수가 90번 백분위 이상인 환자 목록을 검색할 수 있기를 원합니다. 이를 통해 병원에서 가장 활발한 환자들을 식별할 수 있습니다. 또한 나중에 쉽게 조정할 수 있도록 이 백분위를 구성할 수 있기를 원합니다.\n* 2️⃣ — **연구원 또는 데이터 분석가**로서, 일정 기간 동안 가장 빈도가 높은 10가지 진단을 받은 환자 데이터에 액세스하고, 추세를 분석하고 의료 서비스의 품질을 개선하기 위해 사용하고 싶습니다.\n* 3️⃣ — **마케팅 분석가**로서, 환자 만족도 조사용 테이블을 작성하고, 의료 서비스의 품질에 대한 피드백을 수집하여 개선 조치를 취하고자 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 🚀 구현\n\n우리가 만들 것인 사용자 스토리에 기반하여, 실행해야 하는 쿼리와 스크립트를 로드할 두 개의 파일을 정의할 것입니다:\n\n- patients.sql: 회복 중인 환자 데이터에 관련된 모든 쿼리가 있는 곳입니다.\n- visits.sql: 설문 조사와 같은 방문에 관련된 모든 쿼리가 있는 곳입니다.\n\n그러므로 우리 프로젝트에서는 이러한 폴더 및 파일 구조를 가지게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n📁 db\n\n    - 📁 queries\n        - 📄 patients.sql\n        - 📄 visits.sql\n\n📄 main.ipynb\n```\n\n1️⃣ — Python 라이브러리를 가져옵시다.\n\n```js\nimport aiosql\nimport psycopg2\nimport pandas as pd\n```\n\n2️⃣ — SQL 쿼리를 가져와 데이터베이스 드라이버를 설정합시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsql = aiosql.from_path('src/db/queries', 'psycopg2')\n```\n\n3️⃣ — PostgreSQL 데이터베이스에 연결합니다.\n\n```js\npostgres_secrets = {'host': 'localhost','port': 5432, 'user': 'postgres', 'password': 'postgres', 'dbname': 'postgres'}\nconn = psycopg2.connect(**postgres_secrets)\nconn.autocommit = True\n```\n\n## 👥 사용자 이야기 I: 정적 값들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 사용자 스토리를 기반으로, 먼저 90번째 백분위수 이상의 방문 빈도를 가진 환자 목록을 검색할 수 있는 쿼리를 생성할 것입니다.\n\n1️⃣ — sql 파일에서 첫 번째 사용자 스토리에 대한 쿼리가 있습니다.\n\n다음은 aiosq에서 SQL 문이 구성되는 세 가지 구성 요소입니다:\n\n- 📗 Name: 이는 Python 코드에서 쿼리를 호출하는 데 사용되는 서술적인 이름입니다. 다음 예제에서 이름은 “fn_get_patients_adove_90th_percentile\" 입니다.\n- 📗 Description: 이는 문서 문자열을 생성하는 데 사용되는 자세한 설명입니다. 쿼리의 목적과 맥락에 대해 더 포괄적으로 설명합니다. 다음 예제에서 설명은 “90번째 백분위수 이상의 방문보다 더 많은 환자를 가져옵니다…\" 입니다.\n- 📗 Query: 여기에는 데이터베이스에서 실행될 SQL 쿼리가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n📄 sql: db/queries/patients.sql\n\n```js\n-- 이름: fn_get_patients_adove_90th_percentile\n-- 모든 환자 중 방문이 90 번째 백분위수보다 많은 환자들을 가져옵니다. 모든 데이터는 encounters 테이블에 저장되어 있습니다.\n WITH patient_visits AS (\n     SELECT\n         patient,\n         COUNT(*) AS visit_count\n     FROM\n         hospital.encounters\n     GROUP BY\n         patient\n ),\n percentil_n AS (\n   SELECT\n     percentile_cont(0.9) WITHIN GROUP (ORDER BY visit_count) AS p_visits\n   FROM\n   patient_visits\n )\n SELECT \n     pv.patient, \n     pv.visit_count\n FROM \n     patient_visits pv\n CROSS JOIN \n     percentil_n pn\n WHERE \n     pv.visit_count \u003e= pn.p_visits;\n```\n\n2️⃣ — 'fn_get_patients_above_90th_percentile' SQL 함수를 데이터베이스 연결 'conn'을 사용하여 실행합니다.\n\n```js\nresponse = sql.fn_get_patients_above_90th_percentile(conn)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3️⃣ — 이제 응답 객체를 판다스 데이터프레임으로 변환하여 데이터 조작을 더 쉽게 할 수 있습니다.\n\n```python\ndata = pd.DataFrame([item for item in response], columns=['patient_id', 'num_visit'])\n# 데이터프레임 표시.\ndata\n```\n\n![이미지](/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_3.png)\n\n쿼리를 확인하고 싶으면 다음 코드를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nprint(sql.fn_get_patients_adove_90th_percentile.sql)\n```\n\n## 👥 사용자 스토리 I: 동적 값\n\n이제 우리는 다른 백분위 값들을 받아들일 수 있는 쿼리를 생성하여 전달된 값에 기반하여 동적으로 수정될 수 있도록 할 것입니다. 우리의 경우, 75번째 백분위 이상의 환자 목록을 얻는 예시를 제공할 것입니다.\n\n```js\n-- name: fn_get_patients_above_n_percentile\n WITH patient_visits AS (\n     SELECT\n         patient,\n         COUNT(*) AS visit_count\n     FROM\n         hospital.encounters\n     GROUP BY\n         patient\n ),\n percentil_n AS (\n   SELECT\n     percentile_cont(:percentil_value) WITHIN GROUP (ORDER BY visit_count) AS p_visits\n   FROM\n   patient_visits\n )\n SELECT \n     pv.patient, \n     pv.visit_count\n FROM \n     patient_visits pv\n CROSS JOIN \n     percentil_n pn\n WHERE \n     pv.visit_count \u003e= pn.p_visits;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1️⃣ - 다음 코드는 입력값으로 다른 백분위 값을 허용하는 동적 SQL 쿼리를 실행합니다.\n\n```js\n# 이 경우에는 75 백분위 이상의 환자들을 얻습니다.\nresponse = sql.fn_get_patients_above_n_percentile(conn, percentil_value=0.75)\ndata = pd.DataFrame([item for item in response], columns=['patient_id', 'num_visit'])\n```\n\n## 👥 사용자 스토리 II\n\n이 사용자 스토리를 해결하기 위해 지정된 기간 내에서 가장 일반적인 질환이 있는 환자들을 검색하는 쿼리를 생성할 것입니다. 이 쿼리는 동적이며, 향후 관심 있는 질환 수의 변화를 허용할 것입니다.\n이 쿼리는 세 개의 매개변수를 받습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- num_condition: 우리가 관심 있는 조건의 수를 제한할 수 있게 해줄 것입니다 (예: 가장 일반적인 상위 10개 조건).\n- period_start_date와 period_start_end는 데이터를 검색하려는 시간 창을 정의할 것입니다.\n\n```js\n--name: fn_get_patients_top_conditions\n--주어진 기간 동안 최상위 조건을 가진 환자 가져오기, 환자는 조건을 가진 날 수와 데이터 소스가 병원 스키마인 기준으로 정렬됩니다.\nwith top_n_conditions as(\n  SELECT code, description, COUNT(*) \n   FROM hospital.CONDITIONS \n  GROUP BY code,description \n  ORDER BY COUNT(*) DESC \n  LIMIT :num_condition\n),\ntop_n_condition_patients as (\n  SELECT \n     p.ID, \n     p.FIRST, \n     p.LAST, \n     p.CITY, \n     p.GENDER, \n     EXTRACT(YEAR FROM AGE(p.BIRTHDATE)) AS age,\n     c.start condition_start_date,\n     c.stop condition_stop_date,\n     EXTRACT(DAY FROM (c.stop - c.start )) AS condition_days, \n     c.encounter,\n     c.code,\n     c.description\n   from hospital.patients p \n   inner join hospital.conditions c on c.patient = p.id\n   inner join top_n_conditions t on t.code=c.code\n)\nselect * \n from top_n_condition_patients\n where condition_start_date between :period_start_date and :period_start_end;\n```\n\n```js\nresponse = sql.fn_get_patients_top_conditions(conn, num_condition_days=10, \n period_start_date='2022–01–01', \n period_start_end='2022–12–31')\ncolumn_name=['id', 'first','last','city','gender',\n'age','condition_start_date','condition_stop_date','condition_days','encounter','code','description']\ndata = pd.DataFrame([item for item in response], columns=column_name)\ndata.head()\n```\n\n## 👥 사용자 이야기 III\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 aiosql을 사용하여 테이블을 생성할 것입니다. 만약 SQL 코드를 살펴보시면 # 기호가 추가된 것을 보실 수 있습니다. 이러한 기호들은 aiosql이 다양한 작업을 식별하는 데 사용됩니다.\n\n```js\n--name: fn_create_survey_table#\nCREATE TABLE HOSPITAL.VISIT_SURVEY(\n ID SERIAL PRIMARY KEY,\n PATIENT_ID VARCHAR(50),\n SURVEY_DATE TIMESTAMP,\n RATING INT,\n COMMENTS TEXT,\n CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n\u003cimg src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_4.png\" /\u003e\n\n1️⃣ — 'fn_create_survey_table' SQL 함수를 실행하여 데이터베이스에 새 테이블을 만드세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsql.fn_create_survey_table(conn)\n```\n\n```js\n# output\nCREATE TABLE\n```\n\n2️⃣ — 테이블이 생성되면 아래 삽입문을 사용하여 환자의 리뷰를 삽입할 수 있습니다.\n\n```js\n-- name: fn_add_one_visit_survey\u003c!\ninsert into HOSPITAL.VISIT_SURVEY(PATIENT_ID,SURVEY_DATE,RATING,COMMENTS) \n values (:patient_id, :survey_date, :rating,:comments) returning ID;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 새로운 방문 조사 레코드 추가\nsql.fn_add_one_visit_survey(conn, \n patient_id='8b9a93f6-3df3-203d-932f-f456e00d2c01', \n survey_date='2022-01-01', \n rating=5,\n comments='이 병원 정말 좋아요!' )\n```\n\n3️⃣ — 이제 여러 리뷰를 로드하기 위해 새로운 삽입문을 활용할 것입니다. 이 리뷰들은 딕셔너리 목록에 저장되어 있습니다 (파이썬의 각 딕셔너리는 리뷰에 해당합니다). 이를 수행하기 위해 비슷한 쿼리를 활용하겠지만 그 이름을 수정해야 합니다.\n\n```js\n-- name: fn_add_many_visit_survey*!\n insert into HOSPITAL.VISIT_SURVEY(PATIENT_ID,SURVEY_DATE,RATING,COMMENTS) \n values (:patient_id, :survey_date, :rating ,:comments) returning ID;\n```\n\n```js\n# 여러 방문 조사 레코드 추가\nresponse_survey = [\n     {\n       'patient_id': '8b9a93f6-3df3-203d-932f-f456e00d2c01',\n       'survey_date': '2022-01-01',\n       'rating': 3,\n       'comments': '서비스는 좋았어요. 다만 대기 시간이 조금 길었습니다.'\n     },\n     {\n       'patient_id': '7c8a93f6-4df3-203d-932f-f456e00d2c02',\n       'survey_date': '2022-02-01',\n       'rating': 4,\n       'comments': '직원들이 매우 친절했어요!'\n     },\n     {\n       'patient_id': '6b7a93f6-5ef3-203d-932f-f456e00d2c03',\n       'survey_date': '2022-03-01',\n       'rating': 3,\n       'comments': '대기 시간이 조금 길었습니다.'\n     }\n]\nsql.fn_add_many_visit_survey(conn, response_survey)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 📚 프로젝트 쿼리 카탈로그\n\n튜토리얼 초반에는 프로젝트용 쿼리 카탈로그를 만들 수 있는 가능성을 언급했습니다. 이 라이브러리는 이 기능을 직접 제공하지는 않지만, 나의 GitHub 저장소에서 이 튜토리얼의 완전한 코드와 데이터에 액세스하여 이를 수행하는 방법을 확인할 수 있습니다.\n\n유용하게 사용하시면, ⭐️ 스타를 남겨주시고 새로운 글 알림을 받기 위해 팔로우해주시면 저에게 큰 도움이 됩니다. 기술 커뮤니티에서 성장하고 더 많은 콘텐츠를 제작할 수 있게 될 것입니다.\n\n# 🔍 최종 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다양성과 유틸리티: 저는 aiosql이 다른 프로젝트에서 쿼리를 효율적으로 구현할 수 있게 해주는 유용한 라이브러리라고 생각합니다. 이 라이브러리는 SQL 쿼리를 관리하고 실행하는 구조적인 방법을 제공하여 본 코드베이스와 별도로 처리할 수 있어 가독성과 유지 보수성을 향상시킵니다.\n- 유연한 쿼리 처리: aiosql은 데이터베이스 연결을 통해 쿼리를 직접 실행할 수 있는 환경을 제공하지만, 저의 프로젝트에서는 주로 Python 코드로 이미 설정한 클래스를 사용하여 SQL 코드를 반환하고 실행합니다.\n- 다른 데이터베이스: 쿼리를 저장하고 관리할 수 있는 기능은 SQL 데이터베이스를 넘어서기도 합니다. 예를 들어 이 접근 방식은 Neo4j와 같은 NoSQL 데이터베이스에도 적용할 수 있습니다. 구조적인 방식으로 쿼리를 구성하고 처리함으로써 다양한 유형의 데이터베이스와의 상호 작용을 최적화할 수 있습니다.\n\n## 📚 참고 자료\n\n학습하고 싶다면...","ogImage":{"url":"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_0.png"},"coverImage":"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_0.png","tag":["Tech"],"readingTime":12},{"title":"드디어 7B 파라미터 모델이 GPT-4를 이겼어요","description":"","date":"2024-06-19 16:28","slug":"2024-06-19-Finally7BParameterModelbeatsGPT-4","content":"\n\n우리는 작고 매우 효율적인 모델의 시대로 접어들고 있어요!\n\n![Image](/assets/img/2024-06-19-Finally7BParameterModelbeatsGPT-4_0.png)\n\n# 문맥\n\n몇 일 전 새로운 최첨단 오픈소스 모델에 대해 보도했었죠. 이 모델은 GPT-4를 비롯한 다른 모델들을 능가하는 것으로 나타났습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 모델은 SQLCoder-70B입니다.\n\n간략히 말해서, 최근 Meta의 CodeLlama-70B를 기반으로, Defog는 자체 수작업 데이터셋을 활용하여 새로운 섬세하게 조정된 모델을 만들었습니다.\n\n결과는? 직접 확인해보세요:\n\n![image](/assets/img/2024-06-19-Finally7BParameterModelbeatsGPT-4_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모델은 GPT-4 및 다양한 SQL 작업들을 크게 개선했습니다!\n\n더 알아보기: 여기에서 모든 내용을 읽고 모델을 테스트할 수 있어요.\n\n# SQLCoder-70B에서 SQLCoder-7B로\n\n안타깝게도, 70B 파라미터 모델은 아직 오프라인 통합이나 노트북에서 실행하는 것에는 너무 크다고 생각됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 모델 증류\n\n모델 증류는 작고 간단한 \"학생\" 모델에게 크고 복잡한 \"선생님\" 모델처럼 행동할 수 있도록 가르치는 기계 학습 과정입니다. 선생님의 결과를 배우면서 학생은 비슷한 결정을 내릴 수 있으며, 그 크기나 복잡성이 커질 필요 없이 사용을 빠르고 저렴하게 만들어줍니다. 특히 핸드폰이나 태블릿과 같은 장치에서 사용할 때 유용합니다.\n\n# SQLCoder-7B\n\n모델 증류를 활용하여 Defog는 작은 7B 매개변수 모델을 훈련시키고 표준 벤치마크에서 평가했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과\n\n- 콤팩트 모델\n- SQLCoder 70B 파라미터 모델보다 약간 성능이 떨어지지만,\n- 그래도 전반적으로 GPT-4를 이긴다!\n- SQLCode-7B-2 (7B 모델의 두 번째 반복)와 비교한 성능은 90.5%입니다!\n\n# 결론\n\nSQLCoder-7B의 성공은 특정 도메인에서 프로프리어터리 모델인 GPT-4의 성능을 능가할 수 있는 대규모 기초 모델 위에 세밀하게 조정된 niche, 오픈 소스 모델의 타당한 예입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n메타의 70B 매개변수 CodeLlama에서 파생된 이 모델은 전문 데이터 세트와 대상 지정된 세세한 조정을 통해 SQL 작업과 같은 분야에서 우수한 성능을 달성할 수 있는 잠재력을 보여줍니다!\n\n다가올 몇 달 동안 더 많은 모델이 등장할 것으로 기대되며, 이들은 작고 효율적인 오픈 소스 모델을 사용하여 특정 문제를 해결하기 위해 개발될 것입니다. 이러한 추세는 강력하면서도 다양한 기기와 애플리케이션에 접근 가능하고 적응 가능한 AI 솔루션을 만들기로 대표적인 변화를 보여줍니다.","ogImage":{"url":"/assets/img/2024-06-19-Finally7BParameterModelbeatsGPT-4_0.png"},"coverImage":"/assets/img/2024-06-19-Finally7BParameterModelbeatsGPT-4_0.png","tag":["Tech"],"readingTime":2},{"title":"PostgreSQL 및 데이터베이스 시스템을 포괄적으로 다루는 PostgreSQL 학습 안내서 파트 2","description":"","date":"2024-06-19 16:26","slug":"2024-06-19-LearningPostgresAComprehensiveGuidetoPostgreSQLandDatabaseSystemsPart2","content":"\n\n![그림을 표시할 수 없습니다](/assets/img/2024-06-19-LearningPostgresAComprehensiveGuidetoPostgreSQLandDatabaseSystemsPart2_0.png)\n\nPostgreSQL(줄여서 Postgres)는 신뢰성, 견고함, 다양한 기능으로 유명한 강력한 오픈 소스 객체-관계형 데이터베이스 시스템입니다. 이는 캘리포니아 대학 버클리 캠퍼스의 post-Ingres 프로젝트의 일환으로 개발되었으며, 1996년 처음으로 공개되었습니다.\n\n## SQL이란?\n\nCodd 박사는 관계형 테이블에서 데이터를 조작하기 위한 DSL/Alpha라는 언어를 제안했습니다. Codd의 논문이 발표된 후, IBM은 그의 아이디어를 기반으로 한 프로토타입을 구축하기 위해 그룹을 위임했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 그룹은 DSL/Alpha의 간소화된 버전인 SQUARE를 개발했습니다. SQUARE의 추가 세부 조정으로 SEQUEL이라는 언어가 만들어졌고, 이 언어는 결국 SQL로 줄여졌습니다.\n\nSQL은 처음에 관계형 데이터베이스에서 데이터를 조작하는 데 사용되던 언어였지만, 지금은 다양한 데이터베이스 기술을 통해 데이터를 조작하기 위해 발전해 왔습니다.\n\n## PostgreSQL의 간단한 역사\n\nPostgreSQL은 선조인 Ingres에서 이름을 따왔습니다. Ingres는 Michael Stonebraker 교수가 개발한 관계형 데이터베이스였습니다. 1986년에 Stonebraker 교수는 Ingres 이후의 새로운 기능을 개발하기 위한 프로젝트를 시작했고, 이 프로젝트를 POSTGRES (Post-Ingres의 약어)라고 명명했습니다. 목표는 객체-관계형 데이터베이스를 만들어 사용자가 자신의 객체(데이터 유형 및 함수와 같은)로 데이터베이스를 확장할 수 있게 하는 것이었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1994년에 MIT 라이선스 하에 POSTGRES 버전 4.2가 출시되어 전 세계 개발자들과의 협업이 가능해 졌습니다. 그 당시 POSTGRES는 QUEL이라는 내부 쿼리 언어를 사용했습니다. 버클리 대학의 두 학생 Andrew Yu와 Jolly Chen은 QUEL을 더 현대적인 SQL 언어로 대체했습니다. 이 혁신으로 프로젝트는 중요한 업데이트를 강조하기 위해 Postgre95로 이름이 변경되었습니다.\n\n1996년에는 프로젝트가 코드를 호스팅할 공개 서버를 구축하고 Marc G. Fournier, Tom Lane, Bruce Momjian을 포함한 다섯 명의 개발자가 새롭게 명명된 PostgreSQL에서 작업하기 시작했습니다. 그 이후로 프로젝트는 적극적으로 유지보수되고 업데이트되어 왔습니다.\n\n# 데이터베이스 유형\n\n## 관계형 데이터베이스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터를 쿼리하고 관리하기 위해 SQL을 사용하세요.\n- MySQL, PostgreSQL, Oracle, Microsoft SQL Server\n\n### NoSQL 데이터베이스\n\n- 비구조화된 데이터와 확장성을 위해 설계되었습니다.\n- 문서 저장소: 데이터를 문서 형식으로 저장하며 일반적으로 JSON 또는 BSON 형식으로 저장됩니다 (MongoDB, CouchDB)\n- 키-값 저장소: 데이터를 키-값 쌍으로 저장합니다 (Redis, DynamoDB)\n- 열 패밀리 저장소: 행 대신 열에 데이터를 저장합니다 (Cassandra, HBase)\n- 그래프 데이터베이스: 노드와 엣지로 데이터를 저장하며 상호 연결된 데이터에 적합합니다. (Neo4j, Amazon Neptune)\n\n### 객체 지향 데이터베이스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 객체 지향 프로그래밍과 유사하게 객체로 데이터 저장\n- db4o, ObjectDB\n\n## 계층형 데이터베이스\n\n- 부모-자식 관계를 가진 트리 구조로 데이터 구성\n- IBM 정보 관리 시스템 (IMS)\n\n## 네트워크 데이터베이스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 계층적 데이터베이스와 유사하지만 여러 부모 노드와의 복잡한 관계를 허용합니다.\n- 통합 데이터 저장소 (IDS)\n\n## 시계열 데이터베이스\n\n- 시간 기록 데이터를 저장하고 조회하는 데 최적화됨\n- InfluxDB, TimescaleDB\n\n## 공간 데이터베이스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 지리적 위치와 같은 공간 데이터를 저장하고 쿼리하는 데 사용됨\n- PostGIS (PostgreSQL의 확장), Oracle Spatial\n\n## 멀티모델 데이터베이스\n\n- 단일 데이터베이스 엔진 내에서 다중 데이터 모델 (문서, 그래프, 키-값)을 지원함\n- ArangoDB, OrientDB\n\n## NewSQL 데이터베이스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- NoSQL 시스템의 확장성과 전통적인 RDBMS의 ACID 보장을 결합해 보세요!\n- Google Spanner, CockroachDB\n\n## In-Memory Databases\n\n- 빠르고 효율적인 읽기 및 쓰기 성능을 달성하기 위해 주로 메모리에 데이터를 저장해 보세요!\n- 예시: Redis, SAP HANA\n\n## 클라우드 데이터베이스\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 클라우드 플랫폼에서 호스팅되며 확장성, 고가용성 및 관리 서비스를 제공합니다\n- Amazon RDS, Google Cloud SQL, Microsoft Azure SQL Database\n\n## 열 지향 데이터베이스\n\n- 행이 아닌 열별로 데이터를 저장하여 읽기 중심 작업 및 분석 쿼리에 최적화되어 있습니다\n- Amazon Redshift, Google BigQuery, Apache HBase\n\n## 포스트그레스 기능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 오픈 소스: PostgreSQL은 PostgreSQL 라이선스에 따라 배포되어 무료로 사용, 수정, 및 배포가 가능합니다.\n- SQL 표준 지원: PostgreSQL은 SQL 표준과 완전히 호환되며 기본 SQL을 넘어서 많은 확장 기능을 제공합니다.\n- 객체-관계 모델: 전통적인 관계형 모델 외에도 PostgreSQL은 테이블 상속 및 사용자 정의 데이터 유형과 같은 객체 지향 기능도 지원합니다.\n- 확장성: 사용자는 사용자 정의 데이터 유형, 함수, 연산자, 및 인덱스를 생성할 수 있습니다. PostgreSQL은 데이터베이스에 새로운 기능을 추가할 수 있는 확장도 지원합니다.\n- 트랜잭션 지원: PostgreSQL은 트랜잭션 안정성을 보장하기 위해 ACID 속성(원자성, 일관성, 고립성, 지속성)을 지원합니다.\n- JSON 및 XML 지원: JSON 및 XML 형식으로 데이터를 저장하고 처리할 수 있어 반구조적 데이터 작업에 유용합니다.\n- 복제 및 고가용성: PostgreSQL은 비동기 및 동기식 복제, 논리적 복제, 클러스터링 등 다양한 복제 및 고가용성 옵션을 제공합니다.\n\n## 용어\n\n- 테이블: 메모리나 디스크(영구 저장소)에 저장될 수 있는 행과 열의 집합\n- 행: 단일 특정 데이터 항목(엔티티)을 설명하는 열의 집합\n- 열: 개별 데이터 항목\n- 기본 키: 테이블 내에서 값이 고유하고 null일 수 없는 하나 이상의 열\n- 외래 키: 다른 테이블을 참조하는 하나 이상의 열\n\n## 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 포스트그레SQL에 대한 소개로 시작했습니다. 이를 통해 캘리포니아 대학 버클리 캠퍼스의 post-Ingres 프로젝트에서 발전한 객체-관계형 데이터베이스 시스템의 기원을 강조했어요.\n\n1986년 마이클 스톤브레이커 교수가 처음 시작한 이래로, PostgreSQL이란 이름으로 변경된 중요한 업데이트를 거쳐 다양한 발전 과정을 거친 이야기를 전해왔습니다.\n\n또한 SQL의 기원에 대해 살펴보았습니다. 이 언어는 관계형 데이터베이스를 관리하고 쿼리하는 데 중요한 역할을 하는데, 1970년 E. F. Codd 박사가 제안한 데이터를 테이블 집합으로 표현하는 혁신적인 작업부터 시작하여 DSL/Alpha, SQUARE, SEQUEL, 그리고 최종적으로 SQL까지 데이터베이스 쿼리 언어의 발전 과정을 따라갔습니다.\n\n우리는 MySQL, PostgreSQL, Oracle과 같은 전통적인 관계형 데이터베이스에서부터 MongoDB, Redis, Cassandra, Neo4j와 같은 비구조화 데이터용 NoSQL 데이터베이스, 그리고 객체지향, 계층형, 네트워크, 시계열, 공간, 다중모델, NewSQL, 인메모리, 클라우드, 열 지향 데이터베이스 등을 포괄하는 다양한 데이터베이스 시스템의 풍요로운 풍경도 살펴보았습니다. 각각은 서로 다른 사용 사례와 데이터 요구 사항에 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그런 다음 PostgreSQL의 강력한 기능을 강조했습니다. 이는 오픈 소스 성격, SQL 표준 준수, 객체-관계 기능, 확장성, 트랜잭션 지원 및 JSON, XML, 복제, 및 고 가용성을 처리하기 위한 고급 기능을 강조했습니다.\n\n마지막으로, 테이블, 행, 열, 주 키 및 외래 키와 같은 데이터베이스와 관련된 중요 용어를 설명하여 이러한 핵심 개념에 대한 기본적인 이해를 제공했습니다.","ogImage":{"url":"/assets/img/2024-06-19-LearningPostgresAComprehensiveGuidetoPostgreSQLandDatabaseSystemsPart2_0.png"},"coverImage":"/assets/img/2024-06-19-LearningPostgresAComprehensiveGuidetoPostgreSQLandDatabaseSystemsPart2_0.png","tag":["Tech"],"readingTime":5},{"title":"NoSQL을 사용하는 이유와 SQL을 선택하는 3가지 이유","description":"","date":"2024-06-19 16:25","slug":"2024-06-19-3ReasonstoUseNoSQLoverSQL","content":"\n\n`\u003cimg src=\"/assets/img/2024-06-19-3ReasonstoUseNoSQLoverSQL_0.png\" /\u003e`\n\nNoSQL과 SQL 데이터베이스 중에서 결정하는 것은 매우 어려운 선택일 수 있습니다.\n\n둘 다 장단점이 있지만, 오늘은 NoSQL이 SQL에 비해 확실한 3가지 장점에 초점을 맞출 것입니다.\n\nDISCLAIMER ⚠️: SQL 데이터베이스에 대해 반대 의견을 제시하는 것이 아니며, 이 자리는 이러한 훌륭한 기술들에 대한 공식적인 토론을 촉발하는 것을 목표로 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러니 더 이상 망설일 필요 없어요... 바로 시작해 봅시다!\n\n# 1. 샤딩\n\n샤딩은 데이터베이스의 데이터를 여러 서버에 분산시키는 기술입니다.\n\n샤딩은 수평 확장으로도 알려져 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대안은 수직 스케일링이며, 이는 데이터베이스를 업그레이드하여 스케일을 조정하는 기술로 단일 서버를 업그레이드하는 것을 의미합니다(예: RAM 추가, CPU 업그레이드).\n\nNoSQL 데이터베이스는 자연적으로 수평 스케일링(Sharding)에 더 적합하며, SQL 데이터베이스는 수직 스케일링에 더 적합합니다.\n\nNoSQL이 샤딩에 더 적합한 이유는 데이터가 자체를 포함하고 있기 때문에 데이터와 해당 테이블 간의 의존성이 없다는 점입니다.\n\nNoSQL에서 샤딩이 더 쉬운 이유를 이해하기 위해 다음 예제를 살펴보십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마치 미디엄처럼 블로깅 플랫폼을 상상해보세요. 블로그 게시물 객체에는 댓글과 좋아요가 포함됩니다.\n\n![2024-06-19-3ReasonstoUseNoSQLoverSQL_1 이미지](/assets/img/2024-06-19-3ReasonstoUseNoSQLoverSQL_1.png)\n\nNoSQL에서는 이 객체가 다른 서버에 있는 다른 테이블에서 데이터를 조인할 필요 없이 그대로 저장됩니다.\n\n그러나 SQL 데이터베이스에서는 게시물, 댓글 및 좋아요를 조인해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQL 데이터베이스가 샤드로 분할되면 어렵습니다. 서로 다른 서버에 위치한 코멘트와 조회수를 JOIN하는 것이 훨씬 어려워집니다.\n\n## 2. 규모별 성능\n\n간단한 데이터 몇 천 개를 다룬다면, NoSQL과 SQL 데이터베이스 간의 성능은 비슷해야 합니다.\n\n이제 수십억 개의 복잡한 관계형 데이터로 확장해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 상황에서 NoSQL은 여러 서버에 걸쳐 행을 분할할 수 있기 때문에 성능이 유지됩니다.\n\n게다가, NoSQL 쿼리는 데이터의 복잡성이 증가함에 따라 매우 잘 확장되며, 실제로 쿼리 시간은 비교적 일관적이고 빠릅니다.\n\n반면에 대규모 SQL 데이터베이스를 분할하는 것은 악몽이며, 수직 확장은 가능하지만 샤딩과 비교했을 때 비용 효율적이고 확장 가능하지 않습니다.\n\n더 나쁜 것은 SQL 스키마가 복잡해지면 여러 JOIN 쿼리가 쌓여 데이터베이스의 성능을 떨어뜨릴 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 간편함\n\nNoSQL의 핵심 목적은 사전 정의된 구조를 준수하지 않고 대량의 비구조화된 데이터를 저장할 수 있게 하는 것입니다.\n\n결과적으로 NoSQL 데이터베이스는 SQL 데이터베이스처럼 엄격한 스키마를 강제하지 않습니다.\n\n이는 프로젝트가 시작되기 전에 스키마를 계획하는 시간을 적게 소비하게 되어 빠른 개발을 이끌어낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래도 이렇게 계획을 다 해놓았음에도 불구하고, 데이터베이스 스키마를 언젠가는 더 다듬어야 할 가능성이 높습니다.\n\n기존 필드를 제거하거나 수정하여 SQL 스키마를 개선하는 것도 문제가 될 수 있습니다.\n\n기존 테이블에서 데이터를 업데이트된 스키마를 기반으로 새 테이블로 이관해야 하기 때문에 시간이 많이 소요될 수 있습니다.\n\n그러나 NoSQL을 사용하면 간단히 열을 제거하거나 수정할 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\n우리는 SQL 대안 대신 NoSQL 데이터베이스를 사용하는 3가지 이유를 탐색했습니다.\n\nNoSQL의 간결함과 성능 장점은 대부분의 애플리케이션에 대해 유망한 선택지로 만들어 주며, 특히 빠르게 확장될 것으로 예상되는 애플리케이션에는 특히 적합합니다.\n\n이는 SQL 데이터베이스가 나쁘다는 것을 의미하는 것이 아니라, 데이터를 확장하는 방법을 다시 생각하고 작업에 적합한 도구를 선택하도록 고려해야 한다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 제휴사\n\n- All-in-One SaaS 프로젝트 템플릿\n- Figma 홈: 제가 모든 프로젝트에서 사용하는 UI 디자인 툴\n- Figma 프로페셔널: 당신이 필요로 하는 유일한 UI 디자인 툴\n- FigJam: 직관적인 다이어그램 및 아이디어 도출로 마음을 자유롭게 펼치세요\n- Notion: 제 인생 전반을 조직하는 데 사용되는 도구\n- Notion AI: ChatGPT보다 더 나은 AI 도구로 Notion 업무 흐름을 업그레이드하세요\n\n# 참고 자료\n\n- NoSQL vs RDBMS와 확장성\n- 샤딩(Sharding)이란 무엇인가요?","ogImage":{"url":"/assets/img/2024-06-19-3ReasonstoUseNoSQLoverSQL_0.png"},"coverImage":"/assets/img/2024-06-19-3ReasonstoUseNoSQLoverSQL_0.png","tag":["Tech"],"readingTime":3},{"title":"BigQuery 비용을 dbt 증분 모델로 100-200배 절감하기","description":"","date":"2024-06-19 16:23","slug":"2024-06-19-ReducingBigQueryCostsby100200xwithdbtIncrementalModels","content":"\n\n템퍼스(Temporus)에서 제 팀이 다루는 많은 모델은 크지만 \"빅 데이터\" 수준은 아닙니다. 보통 우리의 테이블은 수억 행 정도를 갖고 있으며, 가끔 10억 행을 넘기기도 하지만 성능에 대해 걱정할 만큼 자주 발생하지는 않습니다. 그러나 최근에 쿼리 중 하나가 2시간 후에 타임 아웃되었고, 한 테이블이 각 실행에 거의 9,000 슬롯 시간을 사용하고 있다는 것을 깨달았습니다.\n\n결국 데이터 로드 접근 방식을 변경하여 슬롯 사용량을 8,970시간에서 1.4시간으로 줄였습니다. 앞으로 몇 달 동안 다른 데이터 마트에서도 높은 성능의 점진적 모델을 전개할 예정입니다. 아래에서는 발생한 문제와 그 해결 방법에 대해 설명하겠습니다.\n\n제 팀이 다루는 대부분의 데이터는 구조화되지 않은 텍스트입니다. 해당 텍스트를 분류하기 위해 알고리즘을 실행하면 구조화되지 않은 텍스트의 하나의 항목이 이름이 지정된 entity(개체)의 수십 행으로 팽창될 수 있습니다.\n\n여러 해 동안 소스 데이터가 빅 데이터에서 Big Data로 커졌습니다. 수십억 건의 구조화되지 않은 텍스트 페이지와 그 결과로 더 많은 행의 테이블 데이터가 포함되어 있습니다. 우리가 많은 양의 데이터를 생성하고 있기 때문에, dbt에서 일반적으로 사용하는 완전 갱신(full-refresh) 방식에서 벗어나 점진적인 방식을 활용해야 한다고 가정했었으나, 그로 인한 결과를 고려하지 않았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 dbt 제한 시간인 2시간을 초과하면서, 우리는 원시 예측 이후의 테이블을 완전히 잘라내고 로드하는 현재 방식을 다시 검토해야 했습니다.\n\n# 문제 해결 진단\n\n우리의 테이블을 생성하는 SQL 쿼리는 절대 효율적이 아니었습니다 — 문제가 심각해지기 전까지는 그것을 깨닫지 못했습니다. 하지만 어떤 부분이 비효율적이었을까요? 쿼리를 수정함으로써 성능을 개선할 수 있을까요? 아니면 우리 전체 접근법을 바꿔야 했을까요?\n\n아래는 우리가 실행하던 쿼리의 단순화된 버전입니다 —\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n  config(\n    alias=\"ner_model\",\n    cluster_by=[\"label\"],\n    materialized=\"incremental\",\n    schema=\"warehouse\",\n    unique_key=[\"attachment_id\", \"page_index\", \"ent_char_start\"]\n  )\n}\n\nWITH\n\nlake AS (\n  SELECT\n    *\n  FROM { source('lake', 'source_ner_predictions') }\n  { if is_incremental() }\n    WHERE _predicted_at \u003e (SELECT MAX(_predicted_at) FROM { this } )\n  { endif }\n),\n\n-- TMO 우선적 리터럴 형식을 위한 열 추가\nSELECT distinct\n  *\nFROM lake\nLEFT JOIN { ref('tmo') } AS tmo on tmo.key = lake.key\nLEFT JOIN { ref('other_table') } AS cw on lake.id = cw.id\r\n```\n\n위 쿼리에서 지연에 기여할 수 있는 별도 요소들은 다음과 같습니다:\n\n- 하나의 열에 Clustering.\n- 세 개의 열에 Compound Unique Keys.\n- DISTINCT 문.\n- 다양한 JOIN 연산.\n- WHERE 절 필터링이 있는 dbt is_incremental() 구문.\n\n이 중 주요 원인으로 눈에 띄는 항목이 있기를 바라며, 이미 dbt의 incremental 기능을 사용 중이라면 왜 쿼리에 시간이 오래 걸릴 수 있는지 살펴봅시다. 각각이 지연에 기여할 수 있는 이유를 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 열 클러스터링\n\n클러스터링은 특정 열을 기준으로 표 내에서 정렬하는 것을 말합니다. 클러스터링을 통해 스캔/필터링 작업의 성능을 향상시킬 수 있습니다. 그러나 데이터베이스가 쓰기 작업 중에 클러스터 순서를 유지해야 하기 때문에 스캔이 발생하고 데이터의 처리 속도가 느려집니다. BigQuery 클러스터링은 쓰기 작업을 느리게 만들지만 읽기 작업을 빠르게 합니다.\n\n# 복합 고유 키 제약 조건\n\n고유 키는 BigQuery에서 기본적으로 지원되지 않는 기능입니다. 그러나 증분 모델을 사용하는 경우 dbt를 사용하여 이를 구성할 수 있습니다. 이후 dbt는 고유 키에 따라 삽입을 통해 주 키 제약 조건을 효과적으로 적용하는 코드를 컴파일합니다. dbt/BigQuery에서 고유 키의 문제는 증분 로드 시 고유 키를 가진 모든 새로운 데이터를 기존 데이터의 고유 키와 비교하기 위해 전체 테이블 스캔을 수행한다는 점입니다. 전체 테이블 스캔 및 따라서 dbt의 고유 키 제약 조건은 비용이 많이 발생하며 실행 시간이 급격히 느려집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# DISTINCT 문\n\nBigQuery의 DISTINCT 문은 각 열에 대해 GROUP BY를 실행하는 것보다 훨씬 빠릅니다. 그러나 기본적으로 똑같은 일을 수행합니다. 그러나 DISTINCT는 여전히 전체 테이블 스캔을 호출합니다. BigQuery에서 각 행이 고유하다/유일하다는 것을 어떻게 더 확실히 할 수 있을까요?\n\n# 조인 및 WHERE 절\n\n조인에는 전체 테이블 스캔이 필요하며 WHERE 절도 필요합니다. 이 부분은 조금 더 명백하며 아마도 대부분의 사람들이 처음에 찾을 곳입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 WHERE 절이 is_incremental() 블록 안에 중첩되어 있기 때문에 쿼리가 효율적일 것으로 생각했어요. 이론적으로 BigQuery는 런타임에서 기존 테이블을 스캔하고 is_incremental() 블록에서 들어오는 새로운 데이터의 작은 하위 집합과 비교하게 될 거에요!\n\n하지만 실제로는 이런 일이 벌어지고 있어요 —\n\n![이미지](/assets/img/2024-06-19-ReducingBigQueryCostsby100200xwithdbtIncrementalModels_0.png)\n\n쿼리의 다른 구성 요소 때문에 새로운 약 15백만 개의 행이 고유 키 절을 위반하는지 확인하기 위해 BigQuery가 거의 500억 개의 데이터 행을 계속 스캔하게 된 거예요. 새로운 접근 방식이 필요했답니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 문제 해결하기\n\n성능에 영향을 미치는 조합을 찾기 위해 몇 가지 실험을 진행했지만,\n\n최종적으로는 내 실험 중 어느 것도 최종 솔루션을 밝혀내지 못했어요 — 단지 약간의 힌트만 주었을 뿐이에요.\n\n첫째, 우리의 실험은 파티션을 사용하는 것이 병합 작업을 돕는다는 점을 시사했습니다. 파티션을 사용하지 않은 실행의 성능이 느린 것을 볼 수 있었어요 (가장 오른쪽 및 상단 왼쪽 셀). 둘째, 데이터에서는 클러스터링이 성능을 저하시킬 수 있지만, 절대적으로 성능에 해를 끼치는 것은 아닌 것 같았어요. 마지막으로, BigQuery가 결정론적이지 않을 수 있다는 직관을 가졌는데, 여기서 일부 실행에서의 재현성 부족을 통해 그 대안을 확인했어요. 몇 가지 빠른 구글 검색 결과, LIMIT 절은 결정론적인 결과를 도출하지 않는다는 것을 알 수 있었고, 이것이 여기 일부 이상 현상을 설명해 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최종적으로 이러한 실험들은 우리 문제를 즉각적으로 해결할 수 있는 내용을 밝혀내지 않았어요. 우리가 의존할 수 있는 단 하나의 해결책은 없었죠.\n\n문제에 대한 회고를 하며, 우리는 테이블의 모든 데이터가 고유해야 한다는 요구사항이 성능 저하의 주요 요인임을 깨달았어요. 우리는 그 요구사항을 의심한 적이 없었죠. 대신, 중복 데이터가 있을 것이라고 가정하고 제거해야 한다고 생각했어요.\n\n그러나 근본적으로 BigQuery는 삽입/갱신/삭제 트랜잭션을 다루는 것에 적합하게 설계되지 않았어요. BigQuery는 대량 데이터에 대해 완전 갱신만 또는 추가만을 사용할 때 가장 잘 작동하는 OLAP 데이터 웨어하우스에요. DML 할당량 제한이 없어진 것은 2020년에 이루어진 일이었구요, 그 전까지는 24시간 동안 1,000개의 DML 문만 실행할 수 있었어요. 우리의 초기 설계는 BigQuery를 데이터 웨어하우스가 아닌 트랜잭션 데이터베이스처럼 취급한 것이었어요.\n\n우리는 데이터 프로파일링을 수행했고, 중복 데이터가 발생한 것은 24시간 단위였음을 발견했어요. 그래서 우리는 전날 데이터를 수정할 필요가 없었고, 그 데이터를 스캔할 필요도 없었을지도 몰라요! 대부분의 경우, 우리는 unique_key라는 개념을 버리고, 대신에 가장 최신 데이터가 고유하다는 것을 확실히 하는 데 집중할 수 있었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 솔루션 구현\n\n우리의 솔루션은 세 가지 주요 구성 요소가 있었습니다:\n\n- 타임스탬프를 기반으로 파티셔닝을 강제하는 것으로, 데이터의 각 날짜를 파티션에 저장했습니다. 이렇게 하면 최신 데이터 로드에만 집중하면 되므로 효율적입니다.\n- dbt의 is_incremental() 매크로를 활용하여 최신 데이터만 가져오도록 합니다.\n- 전체 테이블 스캔을 유발하는 요소를 제거하고, 작업 중인 특정 파티션에 대해 스캔을 집중합니다.\n\n그 결과는 다음과 같았습니다 —\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n{\n  config(\n    cluster_by=[\"label\"],\n    materialized=\"incremental\",\n    partition_by={\n        \"field\": \"_rwde_predicted_at\",\n        \"data_type\": \"timestamp\",\n        \"granularity\": \"day\"\n    },\n    incremental_strategy = 'insert_overwrite'\n  )\n}\n\nlake_base AS (\n  SELECT\n    primary_key,\n    other_columns,\n    MAX(_rwde_predicted_at) OVER (PARTITION BY primary_key) as _rwde_predicted_at\n  FROM { source('lake', 'ner_model') }\n  { if is_incremental() }\n      WHERE _rwde_predicted_at \u003e (select max(_rwde_predicted_at) from {this})\n  { endif }\n)\n\nSELECT DISTINCT * from lake_base\n```\n\n여기 중요한 구성 요소가 있습니다:\n\n- 클러스터링 — 여전히 downstream 중요성을 향상시키는 라벨이라는 컬럼을 기준으로 클러스터링을 원합니다. 기억하세요, 클러스터링은 쓰기 및 삽입 작업에는 성능에 악영향을 미치지만 읽기 작업에는 큰 도움이 됩니다. 새로운 증분 접근 방식을 사용하여 처리되는 데이터 양을 줄였기 때문에 이제 런타임을 크게 늦출 필요 없이 클러스터화 할 수 있습니다.\n- 분할 — 일별로 분할함으로써 예측값을 매일 다른 테이블로 분리하게 됩니다. 테이블을 분할하고 dbt에 기본으로 내장된 is_incremental() 플래그를 사용하여 dbt가 작은 데이터 서브셋만 읽고 스캔하도록 강제할 수 있으며 이전 데이터를 다시 처리하지 않을 수 있습니다.\n- 증분 전략 — dbt에는 여기 및 여기에 증분 전략에 대한 훌륭한 문서가 있지만 insert_overwrite를 선택함으로써 전체 파티션을 교체하여기존 파티션에 스캔 및 병합하지 않도록 합니다.\n\n참고: 매일 데이터를 한 번만 가져오고 따라서 매일 예측값을 생성하는 것입니다. dbt labs의 Jerco가 가르쳐준 것처럼 —\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인크리멘탈 전략은 구현하기 전에 면밀히 검토하는 것이 중요합니다. 아래 다이어그램은 insert_overwrite 전략이 무엇을 하는지 보여줍니다 —\n\n![이미지](/assets/img/2024-06-19-ReducingBigQueryCostsby100200xwithdbtIncrementalModels_1.png)\n\n위 코드를 구현하면 이 특정 테이블의 BigQuery 스캔 시간이 32,295,356,894 ms (8,970 슬롯 시간)에서 5,024,974 ms (1.4 슬롯 시간)으로 줄어듭니다!!\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빅쿼리 비용은 슬롯 사용량을 기준으로 계산됩니다. 이는 일반적으로 쿼리 실행 시간과 밀접한 관련이 있습니다. 여기에는 일부 쿼리가 병렬 처리되어 더 많은 슬롯 시간을 사용할 수 있는 경우가 있는데요. 1시간 쿼리가 30분 쿼리보다 비싼 것은 아니지만, 대부분의 경우 그렇습니다.\n\n빅쿼리의 사용 방식으로 인해 매일 테이블을 스캔하여 변경된 행이나 추가된 행을 확인하는 것보다 전체 데이터를 삭제한 후 다시 로드하는 것이 훨씬 저렴할 수 있습니다. 이는 직감과 반대되는 방식일 수 있습니다. 새로운 데이터를 삽입하지 않더라도, 생성된 쿼리가 전체 테이블 스캔보다 성능이 우수하다면 해당 전체 테이블 스캔을 피해 비용을 절약할 수 있습니다.\n\n우리의 경우, 비용을 줄일 것으로 가정하고 문제 모델을 점진적으로 전환했지만, 실제로는 전체 새로고침이 더 저렴했을 것입니다. 스캔을 최소화하면서 시간은 걸리지만, 비용은 더 저렴했을 것입니다. 그러나 우리의 새로운 접근 방식은 더 빠르고 저렴하기까지 합니다. 커피 한 잔 사는 것보다 더 나은 선택입니다.\n\n빅쿼리 최적화에 더 관심이 있다면, 제가 작성한 이전 기사를 확인해보세요. 몇 가지 빠른 수정 사항을 강조하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Stackademic\n\n끝까지 읽어 주셔서 감사합니다. 가기 전에:\n\n- 작가를 칭찬하고 팔로우해 주시면 감사하겠습니다! 👏\n- 다음 계정을 팔로우해 주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해 주세요: In Plain English | CoFeed | Venture","ogImage":{"url":"/assets/img/2024-06-19-ReducingBigQueryCostsby100200xwithdbtIncrementalModels_0.png"},"coverImage":"/assets/img/2024-06-19-ReducingBigQueryCostsby100200xwithdbtIncrementalModels_0.png","tag":["Tech"],"readingTime":8},{"title":"파이썬에서 SQLite3를 활용하여 시작하기 테이블 생성 및 행 추출하기","description":"","date":"2024-06-19 16:21","slug":"2024-06-19-GetStartedwithSQLite3inPythonCreatingTablesandFetchingRows","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-GetStartedwithSQLite3inPythonCreatingTablesandFetchingRows_0.png\" /\u003e\n\n# 개요\n\n- 소개 — SQLite 및 SQLite3이란 무엇인가?\n- 첫 번째 SQLite 데이터베이스 만들기\n- 커넥터 및 커서\n- 테이블 생성\n- 데이터베이스에 행 삽입\n- 데이터베이스에서 행 가져오기\n- 마무리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현대 IT 전문가들에게 가장 중요한 핵심 기술 중 하나는 구조화된 질의 언어(SQL)입니다. 이는 관계형 데이터베이스와 상호 작용하기 위해 사용되는 선언형 언어입니다. 데이터 엔지니어와 분석가들은 주로 SQL을 사용하여 데이터 파이프라인을 실행하고 데이터 내에서 유용한 관계를 조사합니다.\n\nSQL 경험이 없을 때는 PostgreSQL 또는 MySQL과 같은 일반적인 데이터베이스 관리 시스템(DBMS)으로 넘어가는 것이 다소 무섭습니다. 다행히 SQLite는 SQL 기초를 배우기에 좋은 옵션입니다. 별도의 서버 프로세스가 없기 때문에 설정하기 쉽고 관리하기 쉽습니다. 따라서 데이터 엔지니어와 데이터 분석가들은 일반적으로 SQLite보다 다른 데이터베이스 관리 시스템을 사용하지만 SQL을 배우기 좋은 장소입니다. 실제로 SQLite는 세계에서 가장 널리 사용되는 DBMS입니다!\n\n게다가, Python 라이브러리인 sqlite3은 SQLite와 상호 작용하기 위한 간단한 인터페이스입니다. 이 블로그 포스트에서는 SQLite와 sqlite3 라이브러리를 사용하여 두 가지 주요 개념을 배웁니다:\n\n- CREATE TABLE, INSERT INTO, 그리고 SELECT — FROM과 같은 가장 기본적이고 유용한 SQL 명령어 사용 방법.\n- 어떻게 프로그래밍 언어(우리의 경우 Python)를 사용하여 관계형 데이터베이스와 상호 작용할 수 있는지.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQLite 데이터베이스를 설정하고 Python에서 sqlite3를 사용하여 데이터베이스 연결을 만들고 데이터범들을 삽입/검색할 것입니다. SQL 전문가가 되는 것이 목표는 아니고, SQL이 어떻게 사용되는지 보고 시작하기 위한 몇 가지 기본 명령을 배우는 것입니다. 더 배우고 싶다면, 이 블로그 포스트와 같이 시작하는 8개의 무료 YouTube 비디오가 있습니다.\n\n# 우리 첫 번째 SQLite 데이터베이스 생성\n\nSQLite 공식 웹페이지에서 SQLite 다운로드에 대한 정보를 찾을 수 있습니다. 그러나 대부분의 경우 SQLite는 이미 대부분의 기기에 포함되어 있으므로 필요하지 않습니다. 또한 Python에서 sqlite3 라이브러리가 필요하지만, 이것은 표준 라이브러리에 포함되어 있고 대부분의 Python 배포판에 포함되어 있습니다. 따라서 대부분의 경우 설치할 것이 없을 것입니다 😃\n\n이미 모든 것이 설치되어 있는지 확인하려면 새로운 Python 파일을 열고 다음 단일 명령어를 작성하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nimport sqlite3\r\n```\r\n\r\n만약 위의 파일이 잘 실행된다면, SQLite와 Python 라이브러리 sqlite3이 모두 설치된 것입니다. 준비가 된 것입니다!\r\n\r\nimport 단계 이후, 데이터베이스에 연결을 생성해야 합니다. 이는 sqlite3 라이브러리의 connect() 함수를 사용하여 수행됩니다:\r\n\r\n```js\r\n# 데이터베이스에 연결 생성\r\nconnection = sqlite3.connect(\"music.db\")\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nconnect() 함수에 전달된 인수는 데이터베이스의 이름이 될 것입니다. 아직 데이터베이스가 없기 때문에, 이는 우리를 위해 새 데이터베이스를 단순히 생성할 것입니다. 이제 Python 파일을 실행하면, 작업 중인 디렉토리에 music.db라는 새 파일이 나타날 것입니다. 이것이 우리의 데이터베이스입니다!\n\n관계형 데이터베이스는 여러 테이블로 구성됩니다. 이것이 처음이시라면, 이를 엑셀 시트 모음과 같다고 생각할 수 있습니다. 이는 관계형 데이터베이스가 얼마나 강력한지를 과소평가하지만, 처음에는 좋은 정신적 모델입니다.\n\n연결 객체를 만든 후에는 커서를 만들어야 합니다. 커서는 데이터베이스에 대해 SQL 명령을 실행할 수 있습니다. 이를 만들기 위해, 연결 객체에서 .cursor() 메서드를 사용합니다.\n\n```js\n# 커서 만들기\ncursor = connection.cursor()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재 변수 cursor에는 데이터베이스에서 데이터를 삽입하고 가져올 수 있는 커서 개체가 포함되어 있습니다. 지금까지 다음 코드를 작성했어야 합니다:\n\n```js\nimport sqlite3\n\n# 데이터베이스 연결 생성\nconnection = sqlite3.connect(\"music.db\")\n\n# 커서 생성\ncursor = connection.cursor()\n```\n\n# 테이블 생성\n\n우선 데이터베이스에 테이블이 필요합니다. 우리는 80년대 노래를 나타내는 데이터를 사용할 것입니다. 커서 개체에서 execute() 메서드를 호출하여 SQL 문을 실행할 수 있습니다. 우리가 배울 첫 번째 문은 CREATE TABLE 문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 테이블 만들기\ncursor.execute(\"CREATE TABLE IF NOT EXISTS songs(name, artist, album, year, duration)\")\n```\n\n위 명령어에서 볼 수 있듯이, 우리는 노래라는 테이블을 생성합니다. 이 테이블은 이름, 아티스트, 앨범, 연도 및 재생 시간 다섯 가지 열을 가지고 있습니다. 옵션인 IF NOT EXISTS는 테이블이 이미 존재하지 않을 경우에만 테이블을 생성하도록 보장합니다. 테이블이 이미 존재하는 경우에는 명령이 실행되지 않습니다.\n\n지금은 테이블이 비어 있지만, 스키마는 명확합니다. 우리는 각 노래의 이름, 아티스트, 앨범, 연도 및 재생 시간과 같은 관련 정보를 기록하는 테이블을 설정하고 있습니다. 곧 이 테이블을 다양한 노래를 나타내는 행으로 채워 넣을 것입니다.\n\nPython 파일을 실행한 후에 당신의 첫 번째 생각은 현재 디렉토리에 있는 music.db 데이터베이스 파일을 열어서 어떤 일이 발생했는지 조사하는 것이 될 것입니다. 그러나 music.db 파일의 정보는 이렇게 직접 열어서 확인할 목적으로는 설정되지 않았습니다. 여기에 있는 정보는 열람하려는 목적으로는 표시되지 않은 형식으로 보일 것입니다. 우리는 데이터베이스의 정보를 읽기 위해 더 많은 SQL 명령어를 작성해야 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQL 명령어를 처음 배우셨군요! SQL 명령어와 Python 라이브러리 sqlite3을 구분해야 합니다. SQL 명령어는 CREATE TABLE ... 이라는 문장 뿐입니다. 연결(connection)과 커서(cursor)는 데이터베이스와 상호 작용하는 데 사용되는 Python 객체입니다.\n\n# 데이터베이스에 행 삽입하기\n\n이제 단일 테이블이 있는 데이터베이스를 가지게 되었어요. 하지만 테이블은 비어 있습니다! 데이터베이스를 유용하게 활용하기 위해서는 데이터가 필요합니다. 이제 SQL 키워드 INSERT INTO을 사용하여 데이터를 데이터베이스 테이블에 삽입하는 방법을 살펴봅시다. 먼저 각 노래를 정보 튜플로 나타낸 노래 목록을 만듭니다:\n\n```js\n# 노래 테이블의 행\nsongs = [\n    (\"I Wanna Dance with Somebody (Who Loves Me)\", \"Whitney Houston\", \"Whitney\", 1987, 291),\n    (\"Dancing in the Dark\", \"Bruce Springsteen\", \"Born In The U.S.A.\", 1984, 241),\n    (\"Take On Me\", \"a-ha\", \"Hunting High and Low\", 1985, 225),\n    (\"Africa\", \"TOTO\", \"Toto IV\", 1982, 295),\n    (\"Never Gonna Give You Up\", \"Rick Astley\", \"Whenever You Need Somebody\", 1987, 213)\n]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 튜플에는 노래 테이블의 열과 대응하는 다섯 부분이 있음을 확인할 수 있습니다. 첫 번째 노래에 대해 다음과 같습니다:\n\n- 이름: I Wanna Dance with Somebody (Who Loves Me)\n- 아티스트: Whitney Houston\n- 앨범: Born In The U.S.A.\n- 발매 연도: 1987년\n- 재생 시간 (초): 291\n\n이제 준비된 행이 있으니, 이를 music.db 데이터베이스의 songs 테이블에 삽입해야 합니다.\n\n이 작업을 수행하는 한 가지 방법은 한 번에 한 개의 행을 테이블에 삽입하는 것입니다. 다음 코드는 첫 번째 노래를 테이블에 삽입합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 데이터베이스에 단일 값을 삽입합니다\ncursor.execute(\"INSERT INTO songs VALUES(?, ?, ?, ?, ?)\", songs[0])\nconnection.commit()\n```\n\n여기서는 노래 목록에서 첫 번째 노래를 선택하여 이를 테이블 songs에 삽입합니다. 테이블을 삽입할 때는 SQL 명령어 INSERT INTO table VALUES를 사용합니다. 마지막으로 .commit() 메소드를 사용하여 트랜잭션이 완전히 완료되도록 합니다.\n\n이 접근법을 Python의 for 루프로 반복하면 다음 코드를 사용하여 테이블에 모든 행을 삽입할 수 있습니다:\n\n```js\n# 루핑을 통해 모든 값들을 테이블에 삽입합니다\nfor song in songs:\n    cursor.execute(\"INSERT INTO songs VALUES(?, ?, ?, ?, ?)\", song)\n    connection.commit()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이곳에는 새로운 SQL 명령이 없습니다. 노래 테이블에 모든 행이 삽입되도록 하는 몇 가지 Python 논리만 있습니다.\n\n위 방법의 단점은 많은 행을 삽입해야 할 때 상당히 느리다는 것입니다. 우리의 예제에서는 노래가 몇 곡뿐이기 때문에 모든 것이 빠릅니다. 그러나 관계형 데이터베이스의 테이블에는 수백만 또는 심지어 수십억 개의 행이 들어갈 수 있습니다. 그런 경우에는 Python에서 루핑이 삽입 작업을 느리게 만들 수 있습니다.\n\n이를 해결하기 위한 방법은 한꺼번에 모든 행을 삽입하는 것이며, 순환하지 않는 것입니다. 지금까지 사용한 .execute() 메서드 대신 커서 객체의 .executemany() 메서드를 사용하여이 작업을 수행할 수 있습니다. 다음 코드는 모든 행을 한 번에 삽입하는 방식입니다:\n\n```js\n# 일괄 처리 방식으로 한꺼번에 모든 값을 삽입할 수 있음\ncursor.executemany(\"INSERT INTO songs VALUES(?, ?, ?, ?, ?)\", songs)\nconnection.commit()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터베이스 music.db에 테이블 songs가 있고 몇 개의 행이 이미 삽입되어 있습니다. 지금까지 작성한 코드(주석 제외)는 다음과 같습니다:\n\n```js\nimport sqlite3\n\nsongs = [\n    (\"I Wanna Dance with Somebody (Who Loves Me)\", \"Whitney Houston\", \"Whitney\", 1987, 291),\n    (\"Dancing in the Dark\", \"Bruce Springsteen\", \"Born In The U.S.A.\", 1984, 241),\n    (\"Take On Me\", \"a-ha\", \"Hunting High and Low\", 1985, 225),\n    (\"Africa\", \"TOTO\", \"Toto IV\", 1982, 295),\n    (\"Never Gonna Give You Up\", \"Rick Astley\", \"Whenever You Need Somebody\", 1987, 213)\n]\n\nconnection = sqlite3.connect(\"music.db\")\n\ncursor = connection.cursor()\n\ncursor.execute(\"DROP TABLE IF EXISTS songs\")\n\ncursor.execute(\"CREATE TABLE IF NOT EXISTS songs(name, artist, album, year, duration)\")\n\ncursor.executemany(\"INSERT INTO songs VALUES(?, ?, ?, ?, ?)\", songs)\nconnection.commit()\n```\n\n자세히 살펴보면 코드에 새 줄을 sneaked했습니다. 이 줄은 SQL 명령문 DROP TABLE IF EXISTS songs를 실행하는 줄입니다. 위의 코드를 실행하면 먼저 테이블이 있으면 삭제한 다음 다시 만듭니다.\n\n이렇게 하면 다른 결과가 나오지 않도록 합니다. 위의 Python 파일을 실행하면 데이터베이스 상태를 재설정하고 다음 섹션에서 동일한 결과를 얻어야 합니다. 프로덕션 시스템에서 이런 문을 사용하면 행을 삽입할 때마다 전체 테이블이 다시 만들어져 매우 비용이 발생할 수 있습니다. 그러나 여기서 하는 실험에는 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터베이스에서 행을 불러오는 중\n\n![이미지](/assets/img/2024-06-19-GetStartedwithSQLite3inPythonCreatingTablesandFetchingRows_1.png)\n\n이제 데이터베이스에서 행을 다시 불러오는 시간이에요. 이를 위해 SQL 키워드 SELECT와 FROM을 사용할 거에요. 데이터베이스에서 한 곡을 가져오는 것부터 시작해볼까요:\n\n```js\n# 한 곡 가져오기\nsingle_song = cursor.execute(\"SELECT * FROM songs\").fetchone()\nprint(single_song)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보통은 SQL 문을 실행하기 위해 커서 개체에 .execute() 메서드를 사용합니다. 문 SELECT * FROM songs는 데이터베이스에서 모든 열과 모든 행을 불러옵니다. 그러므로 이는 모든 것을 우리에게 제공합니다. 그러나 sqlite3에서 .fetchone() 메서드를 사용하여 이러한 행 중 하나만 불러옵니다. 이렇게 하면 우리가 Python 파일을 실행할 때 하나의 노래만 출력하게 됩니다.\n\n와일드카드 심볼 *을 사용하여 모든 열을 다시 검색했습니다. 일부 열만 필요한 경우 다음과 같이 지정할 수 있습니다:\n\n```js\n# 하나의 노래의 이름과 아티스트 열만 불러오기\nname_and_artist = cursor.execute(\"SELECT name, artist FROM songs\").fetchone()\nprint(name_and_artist)\n```\n\n.fetchone() 메서드 외에도 .fetchmany(number_of_rows) 및 .fetchall() 메서드를 사용하여 더 많은 행을 가져올 수 있습니다. 다음 코드는 .fetchall() 메서드를 사용하여 모든 노래를 선택합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 모든 행과 열을 다시 가져오기\nfull_songs = cursor.execute(\"SELECT * FROM songs\").fetchall()\nprint(full_songs)\n```\n\n파이썬으로 정보를 가져온 후에는 유용한 통찰을 얻기 위해 표준 파이썬 논리를 사용할 수 있습니다. 다음 코드는 데이터베이스의 모든 노래에 대한 평균 재생 시간을 찾아내는 예시입니다.\n\n```js\n# Python 논리로 평균 재생 시간 얻기\naverage_duration = 0\nfor song in full_songs:\n    average_duration += song[-1]\naverage_duration = average_duration / len(full_songs)\nprint(f\"평균 80년대 노래 재생 시간은 {int(average_duration // 60)}분 {int(average_duration % 60)}초 입니다.\")\n```\n\n우리는 조금 많이 오고 간다고 생각할 수도 있습니다. 이미 파이썬 스크립트에 원본 노래 목록이 있으므로, 왜 먼저 이를 데이터베이스에 삽입한 다음 다시 검색해야 할까요? 이것은 튜토리얼이 조금 인위적인 부분입니다. 실제로 데이터베이스로부터 데이터를 삽입하고 검색하는 파이썬 스크립트가 동일하지는 않습니다. 데이터베이스에 데이터를 삽입하는 여러 파이썬 스크립트(또는 다른 인터페이스)가 있을 수도 있습니다. 따라서 데이터베이스에서 데이터를 가져오고 평균 재생 시간을 계산하는 것이 이 정보를 얻는 유일한 방법일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 작업을 마무리하기 전에 데이터베이스 연결을 닫아야 합니다. 이전에 connection() 함수로 데이터베이스에 연결을 열었습니다. 이를 닫지 않으면 계속 열려 있어 복잡한 애플리케이션에서 성능 및 지속성 문제를 일으킬 수 있습니다. 데이터베이스 연결이 항상 닫혀 있는지 확인하는 것이 좋은 관행입니다. sqlite3에서는 연결 객체의 .close() 메서드를 사용하여 이 작업을 수행할 수 있습니다:\n\n```js\n# 연결 닫기\nconnection.close()\n```\n\n다음 코드는 우리가 수행한 모든 작업을 보여줍니다:\n\n```js\nimport sqlite3\n\nsongs = [\n    (\"I Wanna Dance with Somebody (Who Loves Me)\", \"Whitney Houston\", \"Whitney\", 1987, 291),\n    (\"Dancing in the Dark\", \"Bruce Springsteen\", \"Born In The U.S.A.\", 1984, 241),\n    (\"Take On Me\", \"a-ha\", \"Hunting High and Low\", 1985, 225),\n    (\"Africa\", \"TOTO\", \"Toto IV\", 1982, 295),\n    (\"Never Gonna Give You Up\", \"Rick Astley\", \"Whenever You Need Somebody\", 1987, 213)\n]\n\nconnection = sqlite3.connect(\"music.db\")\n\ncursor = connection.cursor()\n\ncursor.execute(\"DROP TABLE IF EXISTS songs\")\n\ncursor.execute(\"CREATE TABLE IF NOT EXISTS songs(name, artist, album, year, duration)\")\n\ncursor.executemany(\"INSERT INTO songs VALUES(?, ?, ?, ?, ?)\", songs)\nconnection.commit()\n\nfull_songs = cursor.execute(\"SELECT name, artist, album, year, duration FROM songs\").fetchall()\n\naverage_duration = 0\nfor song in full_songs:\n    average_duration += song[-1]\naverage_duration = average_duration / len(full_songs)\nprint(f\"평균 80년대 노래의 재생 시간은 {int(average_duration // 60)}분 {int(average_duration % 60)}초 입니다.\")\n\nconnection.close()\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마무리\n\n![이미지](/assets/img/2024-06-19-GetStartedwithSQLite3inPythonCreatingTablesandFetchingRows_2.png)\n\n이 블로그 포스트가 SQL 명령어와 파이썬의 sqlite3 라이브러리에 대해 이해하는 데 도움이 되었기를 바랍니다. 만약 AI, 데이터 과학, 또는 데이터 엔지니어링에 관심이 있다면 저를 팔로우하거나 LinkedIn에서 연락을 취해 주세요.\n\n제 글이 마음에 드셨나요? 더 많은 콘텐츠를 보시려면 제 다른 글도 확인해보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터 과학자로 성공하기 위해 필요한 소프트 스킬\n- 데이터 과학자로서 고품질 파이썬 쓰는 법\n- 아름다운 타입 힌트를 활용하여 파이썬 코드 현대화하기\n- 파이썬으로 결측값 시각화는 놀랍게 쉬워요\n- PyOD로 파이썬에서 이상 감지/이상 값 탐지 소개하기 🔥","ogImage":{"url":"/assets/img/2024-06-19-GetStartedwithSQLite3inPythonCreatingTablesandFetchingRows_0.png"},"coverImage":"/assets/img/2024-06-19-GetStartedwithSQLite3inPythonCreatingTablesandFetchingRows_0.png","tag":["Tech"],"readingTime":11},{"title":"데이터 과학 채용 면접이 오지 않나요 시각성 문제가 있을 수 있습니다","description":"","date":"2024-06-19 16:19","slug":"2024-06-19-NotGettingDataScienceJobInterviewsYouHaveAVisibilityProblem","content":"\n\n취업중이신가요? 무료 5페이지 프로젝트 아이디어 안내서를 활용하여 개인 프로젝트를 개발하여 경쟁력을 확보하세요.\n\n다음에 데이터 과학 직무에 지원할 때 모든 것을 시도해봤다고 생각할 때, 기억해 두세요. 제가 한테서 일했던 사람 중 한 명이 작업 후... 웃기죠. 패러디 랩으로 직장을 구한 사람이 있었어요. 그 후보자는 이민엠이나 칠디시 감비노와 협업을 희망하지는 않지만 작업은 저명한 인턴쉽을 획들하는 데에 성공했어요. 이 작업은 10,000명 이상의 지원자들 중에서 선발되었습니다.\n\n엔터테인먼트 제작이라는 엄청난 경쟁이 일상인 세계에 파도를 쳐들기 위해 산업 경험(혹은 엘리트 컨택트)이 부족하다고 인식한 지원자 Jake는 도전적인 프로젝트에 착수했어요. 그는 Blackalicious의 \"알파벳 에어로빅\"을 샷-포-샷으로 재창작할 것이라고 결심했습니다.\n\n2014년 다니엘 래드클리프가 쇼에서 이 노래를 부르는 모습을 봤었기 때문에 이 노래를 선택한 게 아니었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n물론, 예기치 못한 일이 있었습니다. 제이크는 쇼 직원들의 일에 관심을 갖고 가사를 재작성했습니다.\n\n그가 관례적인 인터뷰 요청을 기다리는 동안, 예상치 못한 반응을 받았습니다; 주인공 지미 팰런이 직접 그를 고용했습니다.*\n\n이 이야기를 비관적으로 해석하면: 그가 극단적인 조치를 취하지 않았다면 그 직업을 얻지 못했을 것이라는 겁니다.\n\n저는 보다 낙천적인 태도를 취하여, 그가 목적을 가지고 창의적이고, 무엇보다 중요한 점은 그가 노력했다는 것을 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 과학 직무에 지원하는 모든 사람은 Jake의 예를 통해 자신만의 독특한 명함을 활용해 볼 수 있고, 당신을 뒷받침하는 업무가 없는 상태에서 어떤 대담한 내기도 무례하게 들릴 수 있다는 것을 깨닫게 될 거예요.\n\n![Jake's Example](/assets/img/2024-06-19-NotGettingDataScienceJobInterviewsYouHaveAVisibilityProblem_0.png)\n\n솔직히 말해서, 제이크와 저는 2017년 가을 Tonight에서 잠깐 겹쳤어요.\n\n만약 10,000명의 지원자 풀이 당신에게 와 닿는다면, 아마도 LinkedIn에서 많은 시간을 취업 지원에 사용했고 아마도 이 프롬프트를 본 적이 있을 거예요: \"다른 지원자 100명 (또는 1,000명 또는 10,000명)과 어떻게 비교되는지 확인해 보세요.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n거의 모든 삶의 측면에서 경쟁 분석에 대한 자리가 있지만, 구직자가 너무 많은 정보(TMI)를 제공하는 것도 있습니다.\n\n그런 측정치가 후보자들의 유효성에 대해 투명하지 않다는 것도 말이죠. 기본 자격 요건을 충족하는 사람은 누구이며, 실제로 회사 사이트에 방문했는지, 그리고 “지금 신청”을 한 사람은 누군지, 아마도 가장 중요한 것은 봇인가요.\n\n좋은 소식은 대부분의 직업의 기본 자격 요건을 충족했다면 좋은 상태에 있습니다. 하지만, 당신이 그러하듯이, 특히 입문자 포지션은 경험을 얻기 위해서는 경험이 필요한 악순환입니다.\n\n특히 데이터 과학 시장이 점점 더 빡빡해지고 있는 상황에서, 혼자서도 존중받을만한 지원자로 자리잡기 위해서는 자기 인식과 균형이 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n근무자 유리한 채용 주기에서는, 단지 무슨 일을 잘하거나 하고자하는 데 있어 개인적으로 뛰어나다는 것만으로 충분하지 않습니다.\n\n이제 공개적으로 활동해 보세요. 커뮤니티의 중심 지점에 참여하거나 시작하여, 자신을 채용 관리자와 채용 담당자들에게 눈에 띄게 만들어 주세요. 이를 통해 이력서를 던지거나 자동 거부 이메일을 발송하고 있는 채용 담당자와 차별화되어 보일 수 있습니다.\n\n명확하게 이렇게 말하고 싶어요. 더 많은 시야를 확보해야 한다고 할 때, LinkedIn 제목을 넣어서 프로필의 순위를 높여야 하는 의미가 아닙니다. 솔직히 말하자면, 당신이 자격이 없는 일이나 관심 없는 직무에 대해 연락을 받는 것은 원하는 것이 아닐 것입니다.\n\n그것은 모두의 시간을 낭비하는 일이 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n졸업 후 하루만에 링크드인에 먼저 자리를 구할 것을 의미하지는 않아요. 데이터 과학 분야의 적임자로서 인식받기 위한 다음 단계는 다음과 같아요:\n\n- 데이터 과학 분야에서 돋보이는 독특한 기술 또는 가치 제안을 식별해 보세요.\n- 능력을 과시하는 (이 부분에 대해 의도적으로 개방적으로 말하고 있어요) 어떤 일을 하고, 그 결과물을 명함처럼 활용해 보세요.\n- 관리자들이 자주 방문할 것으로 예상되는 커뮤니티나 포럼을 식별하고 연결하세요. 링크드인도 좋지만, 매니저들이 머물 수 있는 많은 다른 플랫폼이 있어요. 예를 들어, GitHub, Glassdoor 및 Medium 등이 있어요.\n- 자신의 명함을 과시하세요.\n- 과정을 설명하세요.\n- 귀하의 작업에 관심 있는 사람들과 연락을 취하세요 - 아마도 인재영입자/매니저들일 거에요.\n\n## 가장 이상적인 상황\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nML 모델이 마음에 들지 않지만 대시보드 디자인에 큰 만족을 느끼는군요. 그러나 모든 사람들이 대시보드를 만들고 싶어하며 또 다른 Titanic 생존자의 막대 플롯을 보고 싶어하지 않는다고요.\n\n우연히도, 데이터 과학 숙제를 하면서 MLB를 많이 보고 있었습니다. 조금씩 통계 애호가가 되었습니다. 심지어 근처의 MLB 팀에서 데이터 분석가로 지원하는 것도 고려해봤습니다 (아마 뉴욕에 여러 팀이 있을 것으로 생각됩니다).\n\n동시에, Michael Lewis의 Moneyball을 읽고 있었고 Billy Beane가 섭외한 선수들에 대한 통계를 파헤치고 있습니다.\n\n수업에 지루해지자, 그 시대의 오클랜드 에스를 위한 스카우팅 대시보드를 만들어 사이드 프로젝트를 시작하기로 결심했습니다. 몇 주 동안 노력하여 대시보드를 만들어 자랑스러워하며 LinkedIn에 공유하기로 결정했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReddit의 r/dataisbeautiful(2000만 명 이상의 데이터 시각화 커뮤니티) 커뮤니티와 공유하도록 권장하는 연결 메시지가 도착했어요. 초기 대시보드에 대해 게시하는 것 외에도 Medium에서 접근 방법과 얻은 교훈에 대해 설명한 두 부분으로 된 시리즈를 작성했어요. 이 모든 것을 r/dataisbeautiful 게시물에 링크해놓았어요.\n\n잠복 중인 채용 매니저가 연락을 해와서 면접에 초대해 주었어요.\n\n비록 이 극적인 시나리오가 그렇게 매끄럽게 일어나는 경우는 드물겠지만, 표면상으로는 우연한 일들처럼 보이는 것에 드는 수많은 시간과 노력을 강조하고 싶어요.\n\n먼저, 우리 가정의 후보는 MLB 게임을 100시간 이상 지켜가며 데이터를 세심하게 기록하고 분석했어요. 그들은 인상적인 도메인 지식을 발전시키는데 그치지 않고 동시에 주도적으로 자신만의 데이터를 확보했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그들은 수업 외에도 관련성 있는 (하지만 재미있는) 데이터 과학 독해 자료를 읽으며 '머니볼'을 읽었습니다.\n\nLooker와 같은 기본 도구 대신 프로그래밍 방식으로 대시보드를 구축함으로써, 그들은 효과적인 데이터 분석가가 되기 위해 필요한 기술과 디자인 능력을 보여 주었습니다.\n\n그들이 자신의 작업을 공유하는 용기를 가지면, 그것은 주기적이고 쓰고 다듬어진 결과물이기 때문에 숙제 과제보다는 캡스톤 프로젝트나 학위 논문과 유사합니다.\n\n그리고 Medium에 '비하인드 더 신스'를 게시함으로써, 후보자는 채용 공고에서 자주 볼 수 있는 기술을 갖추고 있다는 것을 보여줍니다: \"비기술 관객을 위해 복잡한 기술 개념을 단순화할 수 있는 능력이 필요합니다.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이건 누군가가 \"나를 봐\"라고 하는 경우가 아니라, 누군가가 자신의 기술을 개발하는 이야기입니다.\n\n왜냐하면 짐작했을 것처럼, 이 이야기에는 행복한 결말이 없는 많은 방법들이 있다.\n\n제이크 이야기에서 가장 놀라운 측면 중 하나는 그의 고용에 대해 알게 된 것이 아닌, 그의 예가 무엇이 아닌지를 보는 사람들을 위해 느낀 간접적인 창피 기분이었습니다. 단축키가 아닌 것에 대해 그가 보여준 그 예에서 느낀 놀라움이었습니다.\n\n제이크가 비디오를 게시한 직후, NBCU의 엄격한 고용 절차 우회를 위한 빠른 길을 드러냈습니다. (디즈니 용어에 대해 죄송합니다)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"투나잇 쇼 랩\"을 검색하면 이제 제이크가 출었던 영상 뿐만 아니라 똑같은 것을 하는 다른 수백 개의 영상도 나옵니다. 하지만 그들은 제작 품질이 낮은 나쁜 작품들이었습니다.\n\n요약하자면 이들은 독특한 아이디어의 모방이 아니라 대중들 사이에서 돋보이려는 진정성과 신중한 노력이 반영되지 않았기 때문에 나쁘다고 할 수 있습니다.\n\n부가 프로젝트를 만들 때 가능한 한 자신이 진정으로 알고 관심을 가지고 있는 것을 선택하세요. 제이크와 달리, 첫 번째 시도에서 당신의 후보 자격을 알릴 수 있는 확률은 매우 낮습니다.\n\n그래서 프로필을 끌어올리는 마지막 구성 요소는 일관성입니다.\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n고등학교 선생님 중 한 분이 계속 반복하던 주제를 가져왔어요. \"일관성이 최고야.\"\n\n당신의 지원을 시각적으로 부각시킬 수 있는 방법이 무엇이든 선택하셨다면, 그것이 반복 가능한 것임을 확인하세요. 첫 대시보드로 두 번째 눈길을 끄는 데 필요한 것은 아니기 때문에 몇 번 반복하는 것이 좋습니다.\n\n당신의 가시성과 신뢰성을 높이기 위해 전문가들이 깜짝 놀랐던 Medium에 처음 글을 쓸 때처럼, 큰 팔로워나 인기 있는 글이 없더라도 훌륭한 인터뷰를 기대할 수 있습니다.\n\n다시 말해, 그들이 감동받은 것은 결과물이 아니라 작품을 홍보하기 위한 용기와 노력(제품을 만드는 기술에 더해)이었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제이크의 원본 비디오는 30만 회 조회되었고, 그가 고용된 세그먼트는 수백만 회 조회를 기록했습니다. 때때로 좋은 어플리케이션은 그 자체로 이력서에 올라갈 만한 가치가 있는 것을 증명했죠.\n\n도와주실 수 있을까요? 이 블로그 이외에 어떻게 도와드릴 수 있는지 알려주시기 위해 3가지 질문으로 된 설문 조사에 한 분만 투자해 주세요. 모든 응답자께는 무료 선물이 제공됩니다.","ogImage":{"url":"/assets/img/2024-06-19-NotGettingDataScienceJobInterviewsYouHaveAVisibilityProblem_0.png"},"coverImage":"/assets/img/2024-06-19-NotGettingDataScienceJobInterviewsYouHaveAVisibilityProblem_0.png","tag":["Tech"],"readingTime":6},{"title":"데이터 엔지니어가 직면하는 다섯 가지 무자비한 진실","description":"","date":"2024-06-19 16:18","slug":"2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer","content":"\n\n\n![Five Brutal Truths About Being a Data Engineer](/assets/img/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer_0.png)\n\nI like my job! 🙂\n\nI really do!\n\nBut sometimes I have that feeling...\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 그냥 노트북을 창문 밖으로 버리고 농부가 되고 싶어요. 😡\n\n모든 직업에는 면접 과정 중에 거의 다루지 않는 혹독한 진실이 있어요.\n\n당신이 데이터 엔지니어로 일할 때 알아야 할 5가지 혹독한 진실을 배울 거에요.\n\n나는 이것들을 제 경험을 바탕으로 만들었어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터는 종종 지저분하고 불완전해요\n\n![image](/assets/img/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer_1.png)\n\n프로젝트를 들어가서 기대하는 것은 깔끔하고 완전한 데이터셋(튜토리얼이나 수업 자료처럼)을 다루는 것이라면...\n\n그냥 잊으세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n진짜 데이터셋들은 깨끗하지 않고, 완전하지 않고, 그저... \"아름답지\" 않아요! 😒\n\n데이터 엔지니어들은 분석, 시각화 또는 모델에 사용하기 전에 데이터를 정리하고 처리하는 데 상당한 시간을 투자합니다.\n\n# 요구 사항은 자주 변경될 수 있습니다\n\n![이미지](/assets/img/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 소프트웨어 엔지니어링 개발의 전형적인 사례이며, 따라서 데이터 엔지니어링에서도 매우 \"고전\"적이다.\n\n비즈니스 요구사항이 신속하게 변화할 수 있으며, 데이터 엔지니어들은 적응력을 갖추고 따라가야 합니다.\n\n이는 프로젝트 중간에 방향을 바꾸거나 새로운 기술을 신속하게 배워야 할 수도 있음을 의미할 수 있습니다.\n\n따라서 예산 압력으로 비즈니스가 오늘 변경해야 할 필요가 있다면...\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네가 할 일이니까, 오늘은 바뀔거야.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 나쁜 코드에 많은 시간을 낭비할 것입니다\n\n어디서나 나쁜 전문가가 존재합니다!\n\n모든 직책과 모든 회사에서, 적어도 한 명의 나쁜 전문가를 찾을 수 있습니다.\n\n그래서 이해관계자가 파이프라인이나 API에서 작은 변경을 요청하면... 나쁜 코드를 찾을 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n바로 숨 한 번 깊이 들이마시고 일에 전념하세요. 🤐\n\n# 때로는 데이터를 활용하지 못할 수도 있어요\n\n![Image](/assets/img/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer_3.png)\n\n상상해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 프로젝트에 두 주 동안 집중해서 일했어요;\n- 세 번째 주에 제공한 데이터가 이후 스테이크홀더들에게 제공됐어요;\n- 스테이크홀더들은 제공한 데이터에 매우 만족했고 \"다음 학기에 매우 중요하다\"고 말했어요;\n- 다음 학기에는 프로젝트 파이프라인이 3일 동안 고장나도 한 사람도 불평하지 않았어요!! 이상하네요...\n- 그런데 결국 데이터를 사용하지 않는다는 걸 알게 되었어요... 😣\n\n이러한 상황은 불행히도 흔한 일입니다.\n이런 일이 발생할 수 있다는 점을 인식하고 그냥... 그렇게 내버려두어야 합니다.\n\n# 분야는 끊임없이 진화하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에 있는 두 이미지는 2023년과 2021년의 데이터 엔지니어링 생태계를 보여줍니다.\n\n두 해 동안 생태계가 많이 성장했다는 것을 알 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 기술과 도구들이 언제나 계속해서 등장하고 있어요.\n\n정말 빠르죠!!\n\n만약 오늘은 A 도구로 데이터 조정을 하고 있다면, 아마 내년에는 B 도구로 작업할지도 몰라요.\n\n가능한 해결책은 항상 최신 트렌드와 최신 기술에 대해 숙지하고 있어야 한다는 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 당신도 빠르게 움직이지 않는다면 뒤처질 것입니다.\n\n이 기사를 확인해보세요:\n\n## 결론\n\n데이터 엔지니어가 되는 것은 결코 간단하고 쉬운 여정이 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n혼잡하고 불완전한 데이터로 작업하고, 자주 바뀌는 요구 사항에 적응하고, 나쁜 코드와 씨름하며, 사용되지 않는 데이터의 좌절을 겪으며, 끊임없이 발전하는 분야를 따라잡는 것은 받아들이기 어려울 수 있어요.\n\n이 기사를 마음에 드셨나요? 더 많은 기사를 위해 저를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer_0.png"},"coverImage":"/assets/img/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer_0.png","tag":["Tech"],"readingTime":3},{"title":"클래스워드 - 데이터베이스 열 이름 짓는데 내가 가장 좋아하는 컨벤션","description":"","date":"2024-06-19 16:16","slug":"2024-06-19-ClasswordsMyFavoriteConventionforNamingDatabaseColumns","content":"\n\n![이미지](/assets/img/2024-06-19-ClasswordsMyFavoriteConventionforNamingDatabaseColumns_0.png)\n\n클래스워드는 그냥 네이밍 프로토콜이 아니에요; 각 컬럼의 목적과 내용을 즉시 이해할 수 있도록 하는 명확한 커뮤니케이션 도구로서 작용해요. 핵심 아이디어는 간단해요: 각 데이터베이스 컬럼의 이름이 그 안에 포함된 데이터를 어떻게 나타내는지 전달되도록 해요. 날짜, 텍스트 설명, 숫자 값과 같이 특정 유형의 정보를 식별하거나, 클래스워드는 각 데이터 조각 뒤에 숨은 의도를 명확하게 합니다.\n\n이 규칙은 원하는 어떤 네이밍 스타일과도 잘 어울려요 — 카멜케이스, 패스칼케이스, 또는 스네이크케이스. 이 글에서는 가독성과 인기 때문에 스네이크케이스를 선호하지만, 클래스워드 사용의 본질은 이 문법적 선택을 초월합니다.\n\n좀 더 깊게 파고들어서, 클래스워드 적용 과정에 대해 공유하고 싶은 개인적인 감상이 있어요. 컬럼 이름에 클래스워드를 할당해야 할 때마다, 그 컬럼이 어떤 데이터를 보유하게 될지 심도 있게 생각하도록 강요받아요. 이 데이터가 정말로 무엇을 의미하는 걸까요? 데이터의 세부 사항을 충분히 이해했을까요? 이 내성적인 순간은 귀중해요. 네이밍만 하는 게 아니라, 이 데이터베이스를 사용하는 나와 다른 누군가가 해당 내용을 포괄적으로 이해할 수 있도록 하는 거예요. 클래스워드로 신중하게 네이밍하는 이 실천은, 내 경험 상으로 더 직관적이고 효율적인 데이터 관리 환경을 육성하는 데 중요한 역할을 해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 클래스워드란 무엇인가요?\n\n클래스워드는 본질적으로 데이터베이스 열의 이름 뒤에 추가하는 키워드, 즉 데이터 유형을 나타내는 접미사입니다. 이 관례는 데이터의 형태와 기능 사이에 다리 역할을 하며, 데이터베이스와 상호작용하는 사람들이 해당 열이 어떤 종류의 정보를 포함하는지 즉각 파악할 수 있도록 돕습니다. 클래스워드 사용은 본질적으로 데이터베이스 구조에 의미론적 명확성의 한 층을 포함시키는 데 관한 것입니다.\n\n클래스워드의 아름다움은 그들의 간단함과 의미 전달 능력에 있습니다. 예를 들어, 열 이름 뒤에 _id를 추가하는 것은 이 열이 엔티티의 고유 식별자로 기능함을 나타냅니다. 비슷하게, _size_kb와 같은 접미사는 데이터의 크기를 킬로바이트 단위로 표현한 정보를 저장하는 열임을 알려줍니다. 이 의미론적 풍부함은 단순히 명명 규칙을 준수하는 데 그치는 것이 아니라, 데이터베이스에 명확성을 주입함으로써 일당팀을 초월하여 미래의 데이터 엔지니어나 데이터 분석가에게 다가갑니다.\n\n예를 들어, 상태라는 이름으로만 된 열을 고려해 봅시다. 추가적인 맥락이나 데이터 탐색 없이는 해당 열이 어떤 상태를 나타내는지 알기 어려울 것입니다. 이 상태는 상태 코드인가요, 상태에 대한 텍스트 설명인가요, 아니면 활성/비활성 상태를 나타내는 불리언 플래그인가요? 이 모호함은 일상적인 작업뿐만 아니라 데이터 분석과 보고서 작성에서도 혼란을 야기할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n클래스와드를 적용하면 가독성을 크게 향상시킬 수 있습니다. 예를 들어:\n\n- status_code — 숫자 또는 상징적 코드를 포함하는 열로, 아마도 문서 내 열거체나 룩업 테이블을 참조하는 다양한 상태를 나타내는 것으로 보입니다.\n- status_name — 상태의 설명적인 이름을 저장하는 열을 나타내며 열 내에서 직접 가독성 있는 맥락을 제공합니다.\n\n# 기본 Classwords\n\n카테고리 별로 기본 클래스와드를 더 자세히 살펴봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 텍스트 클래스워드\n\n텍스트 클래스워드는 데이터베이스 내 텍스트 데이터의 성격과 기능을 정의하는 데 중요한 역할을 합니다.\n\n- 식별자 (또는 id) — 이 클래스워드는 고유성을 위해 중요합니다. 이는 엔티티의 인스턴스를 식별하는 숫자나 문자열입니다 (보통 시스템이 생성하는 것으로, 시퀀스에서 나온 숫자 값과 같은); 예: request_id.\n- 코드[_`표준`] — 코드는 보통 분류를 위해 사용되는 간략한 표현입니다. 예를 들어, status_code는 전체 이름을 저장하지 않고도 빠르게 상태를 식별하는 데 도움이 됩니다. 이 클래스워드를 사용할 때 해당하는 코딩 표준을 나타내는 것이 좋습니다 (해당하는 경우). 예: airport_code_iata는 IATA 공항 코드를 저장한다는 것을 명확히 나타냅니다 (ICAO나 다른 것이 아닌).\n- 이름 — 이름은 직관적이지만 인간이 읽기 쉽게 식별하기 위해 중요합니다. 예를 들어, product_name을 다룰 때, 이 컬럼이 제품 이름을 저장한다는 것이 즉시 명확합니다.\n- 설명 (또는 desc) — 설명은 더 자세한 통찰력을 제공합니다. 이를 간결하고 유익하게 유지하는 것이 좋은 실천법입니다. 예를 들어, service_description은 제공된 서비스에 대한 간략한 개요를 제공할 수 있습니다.\n- 지표 (또는 ind) — 지표는 \"예\" 또는 \"아니오\" 또는 \"참\" 또는 \"거짓\"을 나타내는 플래그입니다. 예를 들어, is_active_indicator, has_dependencies_indicator와 같이 Boolean 값으로 종종 사용되며 빠른 확인에 이상적입니다.\n- 숫자 — 이름과 달리, 여기서의 숫자는 종종 수학적인 의미에서의 숫자가 아닙니다. phone_number 및 serial_number가 그러한 예시로, 이 값이 식별에 사용되지만 계산을 위해 사용되지 않는 것입니다.\n- 텍스트 — 한 두 개의 단어로 충분하지 않을 때, comment_text 또는 feedback_text가 등장하여 확장된 문자열을 허용합니다.\n\n## 캘린더 클래스워드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n달력 클래스워드는 시간 데이터를 관리하고 해석하는 데 필수적이며, 다양한 차원에서 시간을 추적하는 데 프레임워크를 제공합니다.\n\n- date — 달력 날짜만 필요할 때, event_date는 어떤 일이 언제 일어나는지를 알려주며 정확한 시간에 대해 걱정할 필요가 없습니다.\n- datetime[_`timezone`] (또는 dt[_`timezone`])**— 보다 정확한 타이밍을 위해, meeting_start_datetime은 시간까지 포함한 날짜를 보여주어 초까지 표시할 수 있습니다. 시간대 정보가 전달되지 않는 데이터 유형을 사용하는 경우, column 이름에 적절한 접미사를 추가하여 명확하게 만들어 주세요. 예를 들어, scheduled_start_dt_utc.\n- timestamp[_`timezone`] (또는 ts[_`timezone`])**— 시스템에서 생성되며 종종 초 단위까지 포함하는 시간대 정보가 있는 경우, record_created_timestamp는 행동이나 이벤트의 정확한 순간을 제공합니다. 마찬가지로, 시간대 정보가 포함되지 않는 데이터 유형의 경우, 적절한 접미사를 추가하여 해당 시간대를 나타내세요. 예를 들어, actual_start_ts_utc.\n\n## 숫자형 클래스워드\n\n숫자형 클래스워드는 양적 데이터에 순서와 명확성을 제공하여, 다양한 유형의 숫자 정보를 구별합니다. 아이템을 계산하거나 값, 비율을 측정하든, 이러한 클래스워드는 정확한 데이터 표현과 분석에 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- count — 방문자 수 등을 합산하는 데 사용하며, 참여도나 트래픽을 측정하는 데 유용합니다.\n- amount[_`화폐단위`] — 이 클래스워드는 재무 데이터에 필수적입니다. sale_amount_usd는 미국 달러로 거래 가치를 명확히 나타냅니다(화폐 표기는 조건적*).\n- `quantity_property`[_`측정단위`] — 측정 가능한 속성에 대해 사용되며, cable_length_meters는 단순히 길이뿐 아니라 단위까지 명시합니다(측정단위 표기는 조건적*). 길이, 무게, 부피, 크기, 거리, 지속 시간 등 측정 가능한 모든 속성에 사용할 수 있습니다. 다른 예시로는: file_size_kb, job_duration_seconds, package_weight_kg, avg_speed_mph\n- ratio — aspect_ratio와 같은 비율은 연결된 단위 없이 비교하는 데 필수적입니다.\n- factor — tax_rate_factor와 같은 요소는 계산에 유용한 곱셈 효과를 제공합니다.\n- percent (또는 pct) — 이익률을 나타내는 profit_margin_percent와 같은 백분율은 상대적인 측정을 제공하며 보통 이해하기 쉬운 형식으로 표시됩니다. 그러나 이 값이 1에 기반한 1%를 나타내는지 100에 기반한 1%를 나타내는지 명확히하면 좋습니다.\n\n* 화폐나 측정단위를 표기하는 접미사의 조건부 포함은 관련 열이 해당 통화나 단위를 나타내는 열을 포함하는지 여부에 따라 결정됩니다. 그러한 열이 있는 경우 접두사가 필요하지 않습니다. 그러므로 tax_amount_usd를 사용하거나 tax_amount와 tax_amount_currency_code(기록이 다양한 통화로 세금액을 저장하는 경우) 쌍을 사용할 수 있습니다.\n\n# 도메인별 클래스워드\n\n도메인별 클래스워드를 네이밍 규칙에 통합하는 것은 유익할 뿐만 아니라 특정 분야의 세세한 점을 포착하는 데 필수적입니다. 이러한 전문화된 클래스워드는 이전에 논의한 더 일반적인 클래스워드에서 파생되며, 데이터 스키마에 추가적인 정확성, 네이밍 간소화 및 맥락을 추가합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시:\n\n- uri (identifier 클래스워드의 전문화) — profile_picture_uri와 같은 URI 열은 인터넷 또는 현실 세계의 리소스에 대한 고유 식별자(또는 주소)를 저장합니다.\n- address (text 클래스워드의 전문화) — 주소와 유사한 열을 자주 사용한다면 postal_address_text와 같이 부르는 대신, 전문화된 address 키워드를 소개하고 postal_address와 같이 약칭 사용을 고려해보세요.\n- email (address 클래스워드의 전문화) — 이는 이메일 주소를 포함하는 열을 명명하는 유용한 단축키입니다. email 클래스워드는 uri를 특수화한 클래스워드도 될 수 있습니다. 이러한 출처를 확인하면 URI에 특화된 이메일 구문(예: \"mailto:someone.special@example.com\") 대신 간단한 \"someone.special@example.com\"이 아니라는 것을 나타낼 수 있습니다.\n- sku (code 클래스워드의 전문화) — 상업 분야에서 각 제품에 대한 고유 식별자인 Stock Keeping Unit에 유용한 전문화된 클래스워드를 사용할 수 있습니다. 예시: product_sku, 재고 관리 시스템에서 제품을 식별하기 위한 편리한 약어입니다.\n- json(text 클래스워드의 전문화) — config_settings_json과 같은 JSON 열은 구조화된 데이터를 압축된 형식으로 저장하며, 설정이나 데이터 교환에 적합합니다.\n- geojson (json 클래스워드의 전문화) — GIS 분야에서 GeoJSON 형식으로 지리 데이터를 저장하는 데 사용될 수 있습니다. 예시: parcel_border_geojson은 토지 경계를 나타내기 위한 지리 공간 데이터를 포함합니다.\n\n# Context에 유의하세요\n\n테이블 스키마를 설계할 때 항상 해당 테이블이 제공하는 문맥을 고려해보세요. 예를 들어, product라는 이름의 테이블에서는 모든 열 이름에 product_를 접두어로 붙이는 것은 중복되고 불필요하게 장황합니다. product_name, product_description 또는 product_launch_date와 같은 이름 대신 테이블 내에서 name, description 및 launch_date와 같은 간결한 이름을 사용하는 것이 반복적인 꼬리표 없이 필요한 모든 문맥을 제공합니다. 아래 쿼리가 충분히 읽기 쉽지 않나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nSELECT name, description, launch_date\nFROM product\n```\n\n이 규칙은 나에게 Smurf 네이밍 컨벤션을 떠올리게 합니다. 이는 클래스를 네임스페이스에 맥락을 고려해 네이밍하는 프로그래밍 안티 패턴입니다. 하지만, 테이블 내의 열을 네이밍하는 것을 생각할 때, 좋은 비유가 될 수 있습니다.\n\n# 클래스워드 사용의 주요 이점\n\n데이터베이스 열 네이밍 규칙으로 클래스워드를 포함하는 것은 데이터 관리 프로세스를 스트림라인하게 하고 데이터베이스 스키마의 명확성을 높일 수 있는 다양한 이점을 제공합니다. 이것은 왜 나는 클래스워드를 내 데이터베이스 디자인 도구에서 없어서는 안 되는 부분으로 여기게 되었는지에 대한 이유입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 향상된 가독성과 명확성 — Classwords는 데이터베이스 열 이름의 가독성과 이해도를 크게 향상시켜줍니다. 이는 팀 구성원들의 학습 곡선을 최소화하고 상세 문서에 대한 의존을 줄여줍니다. 이로써 각 열의 목적과 데이터 유형을 한눈에 파악하기가 더욱 쉬워집니다.\n- AI 기반 SQL 쿼리 생성의 향상 — Classwords는 자연어 프롬프트로부터 SQL 쿼리를 생성하는 GenAI 모델의 정확성을 향상시킵니다. 이들은 AI 시스템이 데이터베이스 구조를 더 잘 이해하도록 돕고, 대화 인터페이스를 통해 더 쉽게 데이터 추출을 용이하게 합니다. 이를 통해 데이터베이스가 AI 친화적으로 변화합니다.\n- 모든 구문 기반 명명 스타일과의 호환성 — Classwords는 다재다능하며 문법적 명명 패턴인 camelCase, PascalCase 또는 snake_case와 쉽게 통합될 수 있습니다. 이 유연성은 classwords를 채택함에 있어 기존의 명명 규칙을 완전히 변경할 필요가 없게 만들어줍니다. 대신 의미론적 의미를 추가하여 기존 규칙을 향상시킵니다.\n\n이 클래스워드에 대한 탐구가 데이터베이스를 보다 관리 가능하고 이해하기 쉽도록 만드는 가치를 잘 보여줬으면 좋겠습니다. 제 경험은 이들이 데이터 무결성과 팀 협업에 미치는 중요한 영향을 입증합니다. 데이터베이스 관행에 classwords를 도입하여 더 명확하고 일관된 명명 규칙을 추구하는 것을 장려합니다.\n\n본문이 마음에 드셨다면, Database Naming Convention Checklist도 관심 있게 보실 수 있습니다.\n\n# 🖐🤓👉 재미있는 사실\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n헝가리안 표기법의 원래 의도가 종종 오해를 받았다는 사실을 알고 계셨나요? 대중적인 믿음과는 달리, 헝가리안 표기법은 데이터 유형과 관련된 것이 아닌 의미론적 유형 접두사를 사용하도록 설계되었습니다. 변수의 유형이 아닌 목적에 대한 통찰력을 제공하기 위한 것이었습니다. 오늘날 일부에서는 안티 패턴으로 간주되지만, 헝가리안 표기법의 본질은 의미 있는 명명의 중요성을 강조하며, 이는 데이터베이스 관리에서의 클래스워드의 가치와 resonates 한 원칙입니다.\n\n더 자세한 이해를 위해, 마이크로소프트의 문서에서 헝가리안 표기법을 설명한 원래 논문을 살펴보세요.\n\n혹시 이제 안티 패턴으로 간주해야 할지 다시 생각할 때가 온 것일지도 모릅니다! 🤔","ogImage":{"url":"/assets/img/2024-06-19-ClasswordsMyFavoriteConventionforNamingDatabaseColumns_0.png"},"coverImage":"/assets/img/2024-06-19-ClasswordsMyFavoriteConventionforNamingDatabaseColumns_0.png","tag":["Tech"],"readingTime":8}],"page":"74","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"74"},"buildId":"8coAiP0lmiEK5aH6nkQkj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>