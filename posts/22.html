<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/22" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/22" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="DevOps 엔지니어를 위한 기본적인 리눅스 쉘 스크립팅 Day 4" href="/post/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="DevOps 엔지니어를 위한 기본적인 리눅스 쉘 스크립팅 Day 4" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="DevOps 엔지니어를 위한 기본적인 리눅스 쉘 스크립팅 Day 4" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">DevOps 엔지니어를 위한 기본적인 리눅스 쉘 스크립팅 Day 4</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Hack The Box - Responder 초반 해결 방법" href="/post/2024-06-23-HackTheBoxStartingPointResponderSolution"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Hack The Box - Responder 초반 해결 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Hack The Box - Responder 초반 해결 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Hack The Box - Responder 초반 해결 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리눅스 커널 리눅스 시스템의 심장과 두뇌" href="/post/2024-06-23-TheLinuxKernelTheHeartandBrainofLinuxSystems"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리눅스 커널 리눅스 시스템의 심장과 두뇌" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheLinuxKernelTheHeartandBrainofLinuxSystems_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리눅스 커널 리눅스 시스템의 심장과 두뇌" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">리눅스 커널 리눅스 시스템의 심장과 두뇌</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">8<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Ubuntu에서 기본 커널 변경 및 설정하는 방법" href="/post/2024-06-23-HowdoyouchangeandsetthedefaultKernelinUbuntuMachine"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Ubuntu에서 기본 커널 변경 및 설정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowdoyouchangeandsetthedefaultKernelinUbuntuMachine_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Ubuntu에서 기본 커널 변경 및 설정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Ubuntu에서 기본 커널 변경 및 설정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="EC2 마스터 리눅스 인스턴스에 다른 EBS 볼륨 추가하는 방법 - 완벽 가이드" href="/post/2024-06-23-HowtoaddanotherEBSVolumetoaLinuxinstance-EC2Mastery"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="EC2 마스터 리눅스 인스턴스에 다른 EBS 볼륨 추가하는 방법 - 완벽 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtoaddanotherEBSVolumetoaLinuxinstance-EC2Mastery_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="EC2 마스터 리눅스 인스턴스에 다른 EBS 볼륨 추가하는 방법 - 완벽 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">EC2 마스터 리눅스 인스턴스에 다른 EBS 볼륨 추가하는 방법 - 완벽 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리눅스에서 CPU, 메모리, 스토리지 정보를 얻기 위한 기본 시스템 명령어들" href="/post/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리눅스에서 CPU, 메모리, 스토리지 정보를 얻기 위한 기본 시스템 명령어들" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리눅스에서 CPU, 메모리, 스토리지 정보를 얻기 위한 기본 시스템 명령어들" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">리눅스에서 CPU, 메모리, 스토리지 정보를 얻기 위한 기본 시스템 명령어들</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="면접 질문, 답변  Linux-1" href="/post/2024-06-23-InterviewQuestionAnswerLinux-1"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="면접 질문, 답변  Linux-1" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-InterviewQuestionAnswerLinux-1_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="면접 질문, 답변  Linux-1" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">면접 질문, 답변  Linux-1</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="1년 전 VS Code를 삭제하고 Neovim으로 전환한 이유" href="/post/2024-06-23-OneYearAgoIUninstalledVSCodeandSwitchedtoNeovim"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="1년 전 VS Code를 삭제하고 Neovim으로 전환한 이유" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-OneYearAgoIUninstalledVSCodeandSwitchedtoNeovim_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="1년 전 VS Code를 삭제하고 Neovim으로 전환한 이유" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">1년 전 VS Code를 삭제하고 Neovim으로 전환한 이유</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="리눅스 보안 여정  SGID 저장된 그룹 ID 이해하기" href="/post/2024-06-23-TheLinuxSecurityJourneySGIDSavedGroupID"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="리눅스 보안 여정  SGID 저장된 그룹 ID 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-TheLinuxSecurityJourneySGIDSavedGroupID_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="리눅스 보안 여정  SGID 저장된 그룹 ID 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">리눅스 보안 여정  SGID 저장된 그룹 ID 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">1<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="AWS EC2 Linux 인스턴스의 디스크 크기 늘리는 방법" href="/post/2024-06-23-HowtoIncreaseDiskSizeonYourAWSEC2LinuxInstance"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="AWS EC2 Linux 인스턴스의 디스크 크기 늘리는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowtoIncreaseDiskSizeonYourAWSEC2LinuxInstance_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="AWS EC2 Linux 인스턴스의 디스크 크기 늘리는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">AWS EC2 Linux 인스턴스의 디스크 크기 늘리는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link posts_-active__YVJEi" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"DevOps 엔지니어를 위한 기본적인 리눅스 쉘 스크립팅 Day 4","description":"","date":"2024-06-23 15:28","slug":"2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4","content":"\n\n안녕하세요 여러분!\n이전 토론에서는 AWS에서 데브옵스 엔지니어를 위한 Linux를 다루었습니다. 아직 확인하지 않으셨다면 [여기]에서 확인해보세요.\n\n오늘은 Linux 셸 스크립팅에 대해 알아볼 것입니다. 지금은 SSH를 사용하여 내 로컬 머신에서 원격으로 AWS의 Ubuntu Linux 서버(프리티어)에 접속하고 있습니다. Secure Shell Protocol (SSH)을 통해 원격 Linux 서버에 안전하게 접속하고 관리할 수 있습니다.\n\n## 데브옵스를 위한 셸 스크립팅이란?\n\n데브옵스를 위한 셸 스크립팅은 Bash (Bourne Again Shell) 또는 다른 호환되는 셸과 같은 셸 언어를 사용하여 개발 및 운영과 관련된 작업을 자동화하는 스크립트를 작성하는 것을 말합니다. 이러한 작업은 시스템 구성 및 관리부터 배포 및 모니터링 프로세스까지 데브옵스 환경에서 가능합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## #!/bin/bash은 무엇인가요?\n\n#!/bin/bash은 셰뱅 또는 해시뱅 라인이라고 불립니다. 이는 스크립트의 시작 부분에 사용되며 스크립트를 실행하기 위해 사용되어야 하는 해석기를 지정하는 데 사용됩니다. 이 경우, #!/bin/bash은 스크립트가 Bash 쉘에 의해 해석되어야 함을 나타냅니다. 네, #!/bin/sh를 작성하여 시스템의 기본 쉘에 의해 (Bash 또는 Bourne 쉘과 호환되는 다른 쉘일 수도 있음) 스크립트가 해석되도록 할 수도 있습니다.\n\n# Day 4-Task: Linux Shell Scripting:-\n\n오늘은 AWS Ubuntu Linux 서버에서 실행된 명령어 몇 가지를 살펴보겠습니다. 여기에 몇 가지 예시가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메시지 출력:\n\n간단한 셸 스크립트입니다. \"내가 #90DaysOfDevOps 챌린지를 완료할 것이다\"를 출력합니다.\n\n```js\n#!/bin/bash\necho \"I will complete #90DaysOfDevOps challenge\"\n```\n\n예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지1](/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_0.png)\n\n![이미지2](/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_1.png)\n\n## 사용자 입력 및 인수\n\n사용자 입력과 인수를 활용하여 Shell Script를 작성하고 변수를 출력합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n#!/bin/bash\n# 이것은 셰뱅 라인입니다. 시스템에 이 스크립트를 해석할 때 Bash 쉘을 사용하라는 것을 나타냅니다.\n\necho \"나는 #90DaysOfDevOps 챌린지를 완료할 것입니다.\"\n\n# 변수:\nname=\"Araiz\"\necho \"안녕하세요 ${name}, 나이를 입력해 주세요.\"\n\n# 사용자 입력 받기:\nread age\necho \"나의 나이는 ${age}세 입니다.\"\n\n# 첫 번째 인자 전달($1):\necho \"안녕하세요, 저는 $1입니다.\"\n```\n\n예시\n\n![image1](/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_2.png)\n\n![image2](/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_3.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## If-Else Example\n\n두 숫자를 비교하여 쉘 스크립팅에서 If else 예제를 작성해보세요.\n\n```js\n#!/bin/bash\n\nnum1=5\nnum2=10\n\nif [ $num1 -gt $num2 ]; then\n    echo \"$num1가 $num2보다 큽니다\"\nelif [ $num1 -lt $num2 ]; then\n    echo \"$num1가 $num2보다 작습니다\"\nelse\n    echo \"$num1와 $num2는 같습니다\"\nfi\n```\n\n예제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 1](/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_4.png)\n\n![Image 2](/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_5.png)\n","ogImage":{"url":"/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_0.png"},"coverImage":"/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_0.png","tag":["Tech"],"readingTime":3},{"title":"Hack The Box - Responder 초반 해결 방법","description":"","date":"2024-06-23 15:27","slug":"2024-06-23-HackTheBoxStartingPointResponderSolution","content":"\n\n\n![image](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_0.png)\n\nResponder는 Hack The Box 플랫폼의 Starting Point 시리즈에서 Tier 1 중 4번째 머신입니다. 랩 중에는 Penetration Testing 능력을 향상시키기 위해 일부 중요하고 최신 도구들을 활용했습니다. 이 중에는 Responder, John the Ripper 및 evil-winrm이 있습니다.\n\n하나의 머신을 더 pwed해 봅시다!\n\nTASK 1 — IP 주소를 사용하여 웹 서비스를 방문할 때, 우리가 리디렉트되는 도메인은 무엇입니까?\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n웹 브라우저를 통해 IP 주소에 액세스하려고 하면 unika.htb로 리디렉션되지만 연결이 성공하지 않을 것입니다.\n\n\n![image1](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_1.png)\n\n\n웹 페이지를 보려면 대상 IP를 /etc/hosts 파일에 추가해야 합니다. 그런 다음 터미널에서 텍스트 파일 편집기를 열고 페이지의 호스트 이름과 IP 주소를 입력하십시오.\n\n\n![image2](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식의 텍스트입니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_3.png)\n\n웹 브라우저에서 페이지가 불러와집니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_4.png)\n\nTASK 2 — 서버에서 웹페이지를 생성하는데 사용된 스크립팅 언어는 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNmap 스캔을 실행하여 사용 가능한 포트 목록을 생성 중입니다. 결과에 따르면, 웹 서비스용 포트 80이 활성화되어 있으며 서비스에 대한 세부 정보가 제공되었습니다. 또한, 아파치가 PHP를 사용하여 웹 페이지를 생성하고 있다고 언급했습니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_5.png)\n\n작업 3 - 웹페이지의 다른 언어 버전을로드하는 데 사용되는 URL 매개 변수 이름은 무엇입니까?\n\n다른 언어로 전환하려면 페이지 매개 변수를 사용합니다. 언어가 변경되면 주소 표시줄의 URL이 변경되는 것을 확인할 수 있습니다. 아래 예시를 참고하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![2024-06-23-HackTheBoxStartingPointResponderSolution_6.png](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_6.png)\n\n### TASK 4 — 다음 `page` 매개변수 값 중 로컬 파일 포함(LFI) 취약점을 악용할 수 있는 예시는 무엇인가요?: “french.html,” “//10.10.14.6/somefile”, “../../../../../../../../windows/system32/drivers/etc/hosts”, “minikatz.exe”\n\n로컬 파일 포함 취약점을 악용하려면 ../../../../../../../../windows/system32/drivers/etc/hosts와 같은 매개변수를 사용해야 합니다. \" ../ /\"을 이용하면 \"etc/hosts\"에 액세스할 수 있습니다.\n\n![2024-06-23-HackTheBoxStartingPointResponderSolution_7.png](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**TASK 5** — `page` 매개변수에 다음 중 어떤 값이 원격 파일 포함(Remote File Include, RFI) 취약점을 악용한 예시인가요: “french.html,” “//10.10.14.6/somefile”, “../../../../../../../../windows/system32/drivers/etc/hosts”, “minikatz.exe”?\n\n원격 파일 포함을 악용하기 위해서는 대상 기계의 IP 주소를 가져야 하며, 이 경우에는 //10.10.14.6/somefile이 있어야 합니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_8.png)\n\n**TASK 6** — NTLM은 무엇의 약자인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNTLM은 Microsoft Windows를 위해 설계된 보안 프로토콜 그룹인 New Technology LAN Manager의 약자입니다. NTLM은 클라이언트 및 서버를 인증하기 위해 도전-응답 메커니즘을 사용합니다. 그러나 현재의 응용 프로그램에서는 암호화 부족 때문에 NTLM 사용을 권장하지 않습니다.\n\nTASK 7 — Responder 유틸리티에서 네트워크 인터페이스를 지정하는 데 사용하는 플래그는 무엇인가요?\n\nResponder는 네트워킹 인터페이스를 지정하기 위해 -I로 표시된 플래그를 사용하며 인터페이스 이름이 이어집니다.\n\n![Resonder Flag](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, \"ip a |grep + 네트워크 인터페이스\" 명령어를 사용하여 IP를 확인하세요.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_10.png)\n\nResponder가 제대로 작동하는지 확인하기 위해 Responder가 이벤트를 잡았는지 확인할 수 있습니다. 이를 위해 IP와 공유 폴더 이름을 사용하여 웹 브라우저에서 공유 파일을 열어보세요. 그러나 이 작업은 폴더가 사용 가능하고 권한이 필요하기 때문에 거부될 가능성이 높습니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nResponder가 작동 중인 터미널에서 NTLM 정보에는 클라이언트의 IP, 사용자 이름 및 암호 해시가 포함되어 있습니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_12.png)\n\n태스크 8 - NetNTLMv2 챌린지/응답을 이용하여 수백만 개의 암호를 시도하여 같은 응답을 생성하는지 확인하는 여러 도구들이 있습니다. 이러한 도구 중 하나는 종종 `john`이라고 불리지만, 전체 이름은 무엇인가요?\n\n암호 해독 도구 John의 전체 이름은 John the Ripper입니다. 이 랩에서 사용자 암호를 찾는 데 곧 사용될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해시를 복사한 후 \"echo\" 명령어를 사용하여 파일로 전송하세요. 그런 다음 \"ls\" 명령어를 사용하여 디렉터리를 확인하여 파일이 저장되었는지 확인하세요.\n\n![image](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_13.png)\n\n다음으로 \"RockYou\" 워드리스트 파일을 압축 해제하는 단계를 따르세요.\n\n![image](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_14.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"john\" 명령을 사용하여 워드리스트를 실행하고 해당 패스워드 해시 파일과 일치시켰어요.\n\n\n![image](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_15.png)\n\n\n할일 9 — 관리자 사용자의 비밀번호는 뭔가요?\n\n1단계에서 착안한 단계별 지시 사항을 통해 관리자 사용자의 비밀번호는 \"badminton\"이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**TASK 10** — 윈도우 서비스(즉, 상자에서 실행 중인)를 사용하여 복구한 비밀번호를 사용하여 Responder 머신에 원격으로 액세스할 것입니다. 이 서비스가 청취하는 TCP 포트는 무엇인가요?\n\n이 TCP 포트는 5985이며, Nmap으로 스캔하면 쉽게 정보를 얻을 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_16.png)\n\n**플래그 제출**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n악성-winrm을 활용하여 플래그 사냥을 진행해봅시다. 해당 패키지에는 대상 컴퓨터에 액세스하기 위한 Windows 원격 관리가 포함되어 있습니다. 마침내 IP 주소, 사용자 이름 및 비밀번호를 포함한 모든 필요한 정보를 모았습니다.\n\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_17.png)\n\n\n디렉터리 및 폴더 간 이동에는 \"cd\" 명령을 사용할 수 있으며, 폴더 내용은 \"dir\"을 사용하여 나열할 수 있습니다. 사용자 Mike에게 숨겨진 플래그가 있습니다.\n\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_18.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n깃발을 확인하려면 \"type\" 명령어를 사용하세요.\n\n![flag1](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_19.png)\n\n![flag2](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_20.png)\n\n제공된 이미지의 모든 작업에 대한 답안을 가지고 있어요. Pweding Responder 머신은 정말 재미있는 경험이었습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![HackTheBoxStartingPointResponderSolution_21.png](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_21.png)\n\n![HackTheBoxStartingPointResponderSolution_22.png](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_22.png)\n","ogImage":{"url":"/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_0.png"},"coverImage":"/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_0.png","tag":["Tech"],"readingTime":6},{"title":"리눅스 커널 리눅스 시스템의 심장과 두뇌","description":"","date":"2024-06-23 15:24","slug":"2024-06-23-TheLinuxKernelTheHeartandBrainofLinuxSystems","content":"\n\n\n![Linux Kernel](/assets/img/2024-06-23-TheLinuxKernelTheHeartandBrainofLinuxSystems_0.png)\n\n만약 리눅스를 사용해 본 적이 있다면, 리눅스 커널을 만난 적이 있을 것입니다. 물론 이를 인식하지 못했을지도 모릅니다. 커널은 컴퓨터의 심장이자 두뇌라고 생각해 보세요. 컴퓨터 안에서 일어나는 모든 일, 애플리케이션 시작부터 인터넷 연결까지 모두 커널이 책임지고 있습니다. 그렇다면 리눅스 커널은 정확히 무엇이고, 어째서 중요한 것일까요? 함께 알아봅시다!\n\n# 리눅스 커널이란?\n\n리눅스 커널은 리눅스 운영 체제의 핵심 부분입니다. 커널은 컴퓨터의 하드웨어(예: CPU, 메모리, 디바이스)와 사용하는 소프트웨어 애플리케이션 사이의 다리 역할을 합니다. 커널이 없다면 소프트웨어가 하드웨어와 통신할 수 없어 아무 것도 작동하지 않을 것입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 역사 소개\n\n## 기원과 창조\n\n리눅스 커널의 이야기는 1991년 핀란드 출신 컴퓨터과학 학생인 Linus Torvalds와 함께 시작되었습니다. 그때 Torvalds는 교육 목적으로 사용되는 작은 Unix와 유사한 시스템인 MINIX의 한계에 좌절했습니다. 개인 컴퓨터에서 운영될 수 있는 무료 오픈 소스 운영 체제를 만들고 싶어한 Torvalds는 리눅스 커널을 개발하기 시작했습니다.\n\n1991년 8월 26일, Torvalds는 comp.os.minix 뉴스 그룹에서 자신의 프로젝트를 발표했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 겸손한 발표는 컴퓨팅 역사상 가장 중요한 프로젝트 중 하나로 자리매김하게 될 시작을 알렸습니다.\n\n## 초기 개발과 성장\n\n토르발즈는 1991년 9월 17일에 리눅스 커널의 첫 번째 버전인 0.01 버전을 공개했습니다. 이 초기 버전은 완전하지 않았지만, 향후 개발을 위한 기반을 마련했습니다. 그 이후 토르발즈는 커널 개발을 계속하고, 1991년 말까지 0.12 버전을 공개했습니다. 이 버전은 GNU 일반 공중 사용 허가서(GPL) 하에 라이선스를 받은 첫 번째 버전이었습니다. 이 결정으로 리눅스 커널은 계속해서 무료 및 오픈 소스로 유지되어 누구나 사용, 수정, 배포할 수 있게 되었습니다.\n\nGPL의 채택으로 프로젝트에 기여하는 개발자 커뮤니티가 점점 더 커졌고, 새로운 기능을 추가하고 버그를 수정하며 성능을 개선했습니다. 1990년대 중반이 되자, 리눅스 커널은 상당히 성숙해지며 전 세계의 취미로, 연구자, 기업들에 의해 사용되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 주요 이정표\n\n- 1994 — 버전 1.0: 리눅스 커널의 첫 번째 공식 안정 버전인 버전 1.0이 1994년 3월 14일에 출시되었습니다. 이 버전은 다양한 하드웨어 및 네트워크 프로토콜을 지원하여 더 심층적인 사용에 적합했습니다.\n- 1996 — 버전 2.0: 1996년 6월 9일에 출시된 리눅스 커널 2.0 버전은 대칭 다중 처리(SMP)를 지원하여 다중 프로세서 시스템에서 실행할 수 있게되었습니다. 이것은 성능과 확장성 면에서 중요한 발전을 이룬 것입니다.\n- 2003 — 버전 2.6: 2003년 12월 17일에 출시된 2.6 시리즈는 확장성, 성능 및 하드웨어 지원에서 많은 개선을 가져왔습니다. 이 버전은 데스크톱 및 서버 환경에서 널리 채택되었습니다.\n- 2011 — 버전 3.0: 리눅스 커널 3.0이 2011년 7월 21일에 처음으로 버전 번호가 변경되었습니다. 새 번호에도 불구하고 이 릴리스는 주요 변경이 아닌 점진적인 업데이트였습니다.\n- 2015 — 버전 4.0: 2015년 4월 12일에 출시된 4.0 버전은 라이브 패칭을 도입하여 관리자가 시스템을 다시 부팅하지 않고 커널 패치를 적용할 수 있는 기능을 제공했습니다. 기업 환경에서 가동 시간을 유지하는 데 중요한 기능입니다.\n\n## 현대 시대\n\n리눅스 커널은 지속적으로 발전하고 있으며 새로운 버전이 정기적으로 출시됩니다. 각 릴리스에는 성능, 보안 및 하드웨어 지원이 개선됩니다. 리눅스 커널은 이제 전 세계의 수천 명의 기여자들, 자원봉사자, 학술 연구원 및 주요 기술 기업 엔지니어들에 의해 개발되고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리눅스는 많은 현대 기술의 기반이 되었습니다. 웹 서버, 초고속 컴퓨터, 그리고 클라우드 인프라 대부분을 구동합니다. 또한, 세계에서 가장 인기 있는 모바일 운영 체제 안드로이드의 기초이기도 합니다.\n\n# 리눅스 커널의 기본 구성 요소\n\n- 프로세스 관리: 이는 마치 커널의 트래픽 컨트롤러와 같습니다. 컴퓨터에서 프로세스(프로그램)가 어떻게, 그리고 언제 실행되는지를 관리합니다. 각 프로세스가 CPU의 시간을 공평하게 할당받을 수 있도록 합니다.\n- 메모리 관리: 이는 커널의 사서와 같습니다. 컴퓨터 메모리에 모든 것이 어디에 저장되어 있는지 추적하고, 각 프로그램이 필요한 메모리를 확보합니다.\n- 파일 시스템: 커널의 파일 정리자는 데이터가 디스크에 어떻게 저장되며, 어떻게 검색할 수 있는지를 관리합니다.\n- 장치 드라이버: 이것들은 키보드, 마우스, 프린터, 그래픽 카드와 같은 하드웨어 장치들과 커널이 통신할 수 있도록 해주는 특별한 프로그램입니다.\n- 네트워킹: 커널의 이 부분은 네트워크 연결과 관련된 모든 것을 처리하여 데이터가 컴퓨터 간에 이동할 수 있도록 합니다.\n- 보안: 커널의 보안 가드는 누가 컴퓨터에서 무엇에 접근할 수 있는지를 제어하여 권한 없는 접근으로부터 데이터를 보호합니다.\n\n# 리눅스 커널의 핵심 개념\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 커널 공간 대 커널 영역: 커널은 사용자 응용 프로그램이 실행되는 영역(user space)과 별도의 커널 공간(kernel space)이라는 특수한 메모리 영역에서 작동합니다. 이 분리로 시스템을 안정하고 안전하게 유지합니다.\n- 시스템 호출: 응용 프로그램이 커널에 파일 읽기 또는 새 프로세스 시작과 같은 작업을 수행하도록 요청하는 것입니다.\n- 컨텍스트 전환: 커널이 CPU를 한 작업에서 다른 작업으로 전환하는 과정으로, 여러 작업이 효율적으로 CPU를 공유할 수 있습니다.\n- 프로세스간 통신 (IPC): 프로세스가 서로 통신하고 조정할 수 있도록 하는 방법입니다.\n- 인터럽트 처리: 커널은 하드웨어에서의 신호(인터럽트)를 처리하여 I/O 작업을 효율적으로 관리합니다.\n- 가상 파일 시스템 (VFS): 다양한 파일 시스템에 대해 공통 인터페이스를 제공하는 추상화 계층으로, 다양한 종류의 저장 장치를 지원하기 쉽습니다.\n\n# 커널 작동 방식\n\n컴퓨터를 켜면 부트로더(작은 프로그램)가 커널을 메모리에 로드합니다. 그런 다음 커널은 시스템을 초기화하고 필요한 프로세스를 시작하며 CPU 시간, 메모리 및 장치와 같은 자원을 관리합니다. 모든 것이 원활하고 효율적으로 함께 작동하도록 보장합니다.\n\n## 모든 것이 원활하게 작동함을 보장\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n커널은 CPU 시간을 효율적으로 스케줄링하여 프로세스 간의 메모리 할당을 관리하고 시스템 리소스를 무단 접근으로부터 보호하며 기기 간 통신을 원활하게 하는 등 컴퓨터가 원할하게 작동하도록합니다.\n\n# 왜 다양한 버전이 존재할까요?\n\nLinux 커널은 새로운 기술을 통합하고 성능을 향상시키며 보안 취약점을 수정하기 위해 신속하게 발전합니다. 자주 업데이트되고 다양한 버전이 존재하는 주요 이유는 다음과 같습니다:\n\n- 신속한 개발: 새로운 기능과 개선 사항의 지속적인 추가.\n- 보안 업데이트: 보안 취약점을 신속하게 수정하기 위한 정기적인 업데이트.\n- 하드웨어 지원: 최신 하드웨어 장치 지원을 포함.\n- 버그 수정: 버그를 빈번히 수정하고 안정성을 향상시키기 위한 업데이트.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 커널 대 운영 체제 대 하드웨어\n\n- **하드웨어**: CPU, 메모리 및 하드 드라이브와 같이 컴퓨터의 물리적 부분입니다.\n- **커널**: 하드웨어와 직접 상호 작용하는 소프트웨어 계층으로, 응용 프로그램과 하드웨어 간의 다리 역할을 제공합니다.\n- **운영 체제**: 사용자 인터페이스 및 핵심 기능을 제공하고 응용 프로그램을 실행하며 하드웨어를 관리하는 커널을 포함한 소프트웨어 집합입니다.\n\n# 리눅스 커널 업데이트\n\n커널을 업데이트하는 것은 시스템을 안전하고 안정적으로 유지하며 새 하드웨어와 소프트웨어와 호환되도록 하는 데 중요합니다. 아래는 그 방법입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 개발 및 유지 관리: 리눅스 커널은 리눅스 재단이 조정하는 글로벌 개발자 커뮤니티에 의해 개발됩니다. 리누스 토르발스(Linus Torvalds)는 리눅스를 만든 개발자로 프로젝트를 감독하지만, 수천 명의 기여자들이 이를 개선하는 데 도움을 줍니다.\n\n- 릴리스 주기: 커널의 새로운 주요 버전은 몇 달마다 릴리스됩니다. 각 버전은 번호(예: 5.10.1)로 식별됩니다. 주요 버전은 새로운 기능을 도입하며, 마이너 버전은 버그를 수정하고 성능을 개선합니다.\n\n- 장기 지원 (LTS): 일부 커널 버전은 LTS로 지정되며, 이는 여러 년 동안 유지 및 지원되어 중요한 애플리케이션을 위한 안정적인 플랫폼을 제공합니다.\n\n- 업데이트 프로세스: 대부분의 사용자는 리눅스 배포본의 패키지 매니저를 통해 커널을 업데이트합니다. 이는 프로세스를 간소화합니다. 수동으로 업데이트하고 싶은 사람들을 위해서는 새로운 커널을 다운로드하고 컴파일한 후 설치하는 과정이 필요합니다.\n\n# 커널 이야기: 컴퓨토폴리스의 슈퍼히어로\n\n데이터가 강 같이 흐르고 코드의 고층 빌딩이 하늘을 대적하는 활기찬 디지털 도시 컴퓨토폴리스를 상상해보세요. 이 도시에서는 혼돈이 일상이었지만, 커널이라는 슈퍼히어로가 나타나 순서와 조화를 가져다주었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## CPU 구역: 커널의 지시 센터\n\n컴퓨토폴리스의 중심에 위치한 CPU 구역은 도시의 주요 활동 허브입니다. 이곳에서 끊임없이 일을 해야 하는 무수히 많은 시민들(작업 및 프로세스)이 주목을 끌기 위해 노력하고 있습니다. 프로세스 관리의 힘을 가진 커널은 궁극적인 지휘자 역할을 합니다. 초인적인 정확성으로 커널은 각 시민의 활동을 일정에 맞추어 시간을 할당하며 모든 사람이 도시의 중심인 CPU에서 공평한 시간을 얻도록 합니다. 어떤 작업도 방치되지 않고 모든 것이 시계처럼 원활하게 운영됩니다.\n\n![이미지](/assets/img/2024-06-23-TheLinuxKernelTheHeartandBrainofLinuxSystems_1.png)\n\n## 메모리 공원: 커널의 질서 영역\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCPU 지구에서 멀지 않은 곳에는 메모리 공원이 있습니다. 시민들이 앉아서 작업할 수 있는 공간(메모리)이 필요한 넓은 지역입니다. 커널의 메모리 관리 능력이 여기서 빛을 발합니다. 각 벤치(메모리 공간)는 커널에 의해 꼼꼼하게 할당됩니다. 시민이 떠나면 커널은 신속하게 벤치를 필요로 하는 다른 사람에게 재할당합니다. 이 원활한 관리는 메모리 공원이 언제나 완벽한 순서로 유지되도록 하며 공간의 낭비가 없도록 합니다.\n\n![이미지](/assets/img/2024-06-23-TheLinuxKernelTheHeartandBrainofLinuxSystems_2.png)\n\n### 장치 마을: 커널의 통신 네트워크\n\n컴퓨토폴리스의 교외에는 프린터, 키보드, 모니터 등 다양한 장치가 있는 장치 마을이 있습니다. 커널의 장치 통신 능력은 모든 시민이 이러한 장치와 손쉽게 상호 작용할 수 있도록 보장합니다. 누군가 문서를 인쇄하려고 하면 커널은 프린터와 통신하기 위한 적합한 드라이버가 있는지 확인합니다. 이 슈퍼파워는 장치 마을이 원활하게 연결되고 문제없이 작동하도록 유지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 1](/assets/img/2024-06-23-TheLinuxKernelTheHeartandBrainofLinuxSystems_3.png)\n\n## 보안 요새: 커널의 안전한 요새\n\n보안은 컴퓨토폴리스에서 가장 중요합니다. 커널은 그것의 경비원입니다. 보안 관리의 힘으로 커널은 불법 접근과 잠재적 위협으로부터 도시를 보호합니다. 승인된 시민만 안전 지역에 접근할 수 있고, 커널은 언제나 문제의 징후를 주시하며, 혼돈의 시도에 대비할 준비가 되어 있습니다.\n\n![Image 2](/assets/img/2024-06-23-TheLinuxKernelTheHeartandBrainofLinuxSystems_4.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 시스템 호출: 커널의 도움데스크\n\n컴퓨토폴리스 전역에는 시스템 호출이라고 불리는 다양한 도움데스크가 있습니다. 시민이 도움이 필요할 때마다 데스크에 다가가면 그곳이 커널과 통신합니다. 파일에 접근하거나 새로운 프로세스를 시작하는 등의 요청에 대해 커널은 빠르게 응답하여 필요한 모든 것이 효율적으로 충족되도록 합니다.\n\n![이미지](/assets/img/2024-06-23-TheLinuxKernelTheHeartandBrainofLinuxSystems_5.png)\n\n## 컴퓨토폴리스의 조화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKernel의 슈퍼파워 덕분에 Computopolis는 조화롭고 생산적인 도시로 번영하고 있어요. 자원을 효율적으로 관리하고 안전을 보장하며 원활한 통신 채널을 유지하는 Kernel의 능력 덕분에 도시가 원활히 운영됩니다. Kernel에게는 너무 작은 일도, 너무 큰 위협도 없죠. Kernel은 Computopolis의 슈퍼히어로랍니다!\n\n이 디지털 유토피아 속에서 Kernel은 보이지 않는 영웅으로 서있어요. 모든 것이 완벽하게 함께 작동하도록 보장하며, Computopolis를 효율적이고 질서 정연한 모범 도시로 만들어주고 있어요. Kernel은 끊임없는 경계심과 무한한 능력을 통해 디지털 세계를 모든 시민들을 위해 안전하고 번영하게 유지하고 있어요.\n\n![이미지](/assets/img/2024-06-23-TheLinuxKernelTheHeartandBrainofLinuxSystems_6.png)\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLinux 커널은 컴퓨터를 작동시키는 중요한 구성 요소입니다. 하드웨어, 자원 및 보안을 관리하여 모든 것이 원활하게 작동하도록 합니다. 커널의 역할과 작동 방식을 이해하면 현대 컴퓨팅의 복잡성에 대해 더 심층적으로 이해할 수 있습니다. 업데이트하거나 기능을 탐색하거나 컴퓨터를 사용하더라도 커널은 항상 작동하여 디지털 세계를 유지합니다.\n\n# 여러분의 지원은 매우 중요합니다! 🙌\n\n이 글을 즐겁게 읽으시고 가치 있게 여기셨다면 지원을 보이기 위해 박수를 보내주세요. 다른 주제인 파이썬 프로그래밍 및 기타 주제에 관련된 다른 글도 살펴보세요. 저를 따라오면 제 최신 콘텐츠와 통찰력을 업데이트하게 됩니다. 미래 글을 통해 더 많은 지식을 공유하고 여러분과 연결하기를 기대합니다. 그동안 계속 코딩하고 계속 배우며, 무엇보다 중요한 것은 여정을 즐기십시오!\n\n즐거운 학습 되세요!","ogImage":{"url":"/assets/img/2024-06-23-TheLinuxKernelTheHeartandBrainofLinuxSystems_0.png"},"coverImage":"/assets/img/2024-06-23-TheLinuxKernelTheHeartandBrainofLinuxSystems_0.png","tag":["Tech"],"readingTime":8},{"title":"Ubuntu에서 기본 커널 변경 및 설정하는 방법","description":"","date":"2024-06-23 15:23","slug":"2024-06-23-HowdoyouchangeandsetthedefaultKernelinUbuntuMachine","content":"\n\n우분투 머신의 기본 커널을 변경하고 다른 커널로 전환해야하는 상황에 처해본 적이 있나요?\n\n![이미지](/assets/img/2024-06-23-HowdoyouchangeandsetthedefaultKernelinUbuntuMachine_0.png)\n\n저 또한 이 상황을 마주했는데, 시간을 보내며 원하는 우분투 커널로 변경하는 간단한 방법을 찾게 되었습니다.\n\n본 글에서는 AWS에서 운영 중인 우분투 18.04 머신을 사용하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-23-HowdoyouchangeandsetthedefaultKernelinUbuntuMachine_1.png\" /\u003e\n\n우분투 머신의 커널을 확인하려면 터미널을 사용하여 머신에 SSH로 연결하세요. 현재 커널 버전을 확인하려면 다음 명령을 사용하세요.\n\n```js\nubuntu@ip-172–32–11–86:~$ uname -r\n5.4.0-1103-aws\n```\n\n이 우분투 머신에 설치된 커널 목록을 보려면 터미널에서 다음 명령을 사용하세요\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n위 명령을 사용하면 Ubuntu 머신에 설치된 커널 목록을 얻을 수 있어요. 원하는 커널을 선택하고 아래 명령을 사용하여 설치하세요.\n\n```js\nubuntu@ip-172–32–11–86:~$ sudo apt install linux-image-unsigned-4.15.0-136-lowlatency\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-HowdoyouchangeandsetthedefaultKernelinUbuntuMachine_2.png\" /\u003e \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 단계는 Grub 기본 커널을 설정하는 것입니다. 두 부분으로 나뉩니다. 먼저 다음 명령어를 사용하여 $menuentry_id_option을 가져와야 합니다.\n\n```js\nubuntu@ip-172-31-11-86:~$ grep submenu /boot/grub/grub.cfg\nsubmenu 'Advanced options for Ubuntu' $menuentry_id_option 'gnulinux-advanced-9cf7073a-6786-43dc-895e-8bbebe712a1e' {\n```\n\n`gnulinux-advanced-9cf7073a-6786–43dc-895e-8bbebe712a1e`을 복사해 주세요.\n\n둘째로, 지정된 커널 버전을 얻어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```plaintext\nubuntu@ip-172-31-11-86:~$ grep 4.15.0-136 /boot/grub/grub.cfg\n```\n\n여기서 제가 설치된 커널 목록에서 커널 버전만 복사했습니다.\n\n아래 이미지를 참고해주세요:\n\n![그림](/assets/img/2024-06-23-HowdoyouchangeandsetthedefaultKernelinUbuntuMachine_3.png)\n\n녹색으로 강조된 gnulinux-4.15.0–136-lowlatency-advanced-9cf7073a-6786–43dc-895e-8bbebe712a1e를 복사해주세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본 GRUB을 설정하려면 선택한 편집기(vim, nano 등)를 사용하여 grub 파일인 /etc/default/grub을 엽니다. 두 개의 복사된 문자열을 역따옴표(`)로 연결하고 grub 파일의 GRUB_DEFAULT로 설정합니다.\n\ngnulinux-advanced-9cf7073a-6786-43dc-895e-8bbebe712a1e`gnulinux-4.15.0-136-lowlatency-advanced-9cf7073a-6786-43dc-895e-8bbebe712a1e\n\n![이미지](/assets/img/2024-06-23-HowdoyouchangeandsetthedefaultKernelinUbuntuMachine_4.png)\n\n파일을 저장하고 grub을 업데이트하는 다음 명령을 사용하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\nubuntu@ip-172-31-11-86:~$ sudo update-grub\nubuntu@ip-172-31-11-86:~$ sudo reboot\n```\n\n머신이 다시 부팅되면, 기본 커널로 설정된 커널을 선택할 수 있게 됩니다 ✅\n\n==============================================================\n\n이 이야기가 도움이 되었다면 비슷한 이야기를 보고 싶다면, 가상 커피로 저를 지원해주시면 감사하겠습니다 😉👇🏻\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n☕ https://ko-fi.com/mnzel1 ☕","ogImage":{"url":"/assets/img/2024-06-23-HowdoyouchangeandsetthedefaultKernelinUbuntuMachine_0.png"},"coverImage":"/assets/img/2024-06-23-HowdoyouchangeandsetthedefaultKernelinUbuntuMachine_0.png","tag":["Tech"],"readingTime":3},{"title":"EC2 마스터 리눅스 인스턴스에 다른 EBS 볼륨 추가하는 방법 - 완벽 가이드","description":"","date":"2024-06-23 15:22","slug":"2024-06-23-HowtoaddanotherEBSVolumetoaLinuxinstance-EC2Mastery","content":"\n\nAWS의 핵심은 EC2에 있습니다. 클라우드 서비스 제공업체를 사용하기 시작할 때 대부분 처음 배우는 서비스 중 하나입니다. 이를 염두에 둔다면, 배울 것이 많고 현재 사용 중인 use case에 다른 서비스를 통합하는 다양한 방법이 있습니다.\n\n이 새로운 시리즈인 'EC2 마스터리'에서는 EC2의 여러 실제 사용 예제를 배울 것입니다.\n\n![이미지](/assets/img/2024-06-23-HowtoaddanotherEBSVolumetoaLinuxinstance-EC2Mastery_0.png)\n\n'EC2 마스터리'의 이번 에피소드에서는 EC2 Linux 인스턴스에 추가 EBS 볼륨을 추가하는 방법을 살펴볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. 명령 줄 및 fstab 파일(Linux)을 통해 추가적인 EBS 볼륨 추가하기\n\n## 단계 1: EBS 볼륨 연결하기\n\nCloudShell 탭을 열거나 AWS 계정에 명령 줄을 통해 상호 작용합니다. 아래는 제가 입력한 명령어의 스크린샷입니다.\n\nEBS 볼륨 생성:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n aws ec2 create-volume --availability-zone \u003cyour-az\u003e --size \u003csize-in-gb\u003e\n```\n\n다음은 사용할 수 있는 다른 옵션들입니다:\n\n--volume-type: EBS 볼륨의 유형을 지정합니다 (예: gp3, io2).\n--iops: io1 또는 io2 볼륨의 IOPS 수를 설정합니다.\n--encrypted: 볼륨을 위해 암호화를 활성화합니다.\n--kms-key-id: 암호화를 위한 KMS 키를 지정합니다.\n--snapshot-id: 기존 스냅샷에서 볼륨을 생성합니다.\n--tag-specifications: 볼륨에 태그를 추가합니다.\n--multi-attach-enabled: 볼륨을 여러 인스턴스에 동시에 연결할 수 있도록 허용합니다 (io1 또는 io2용).\n\nEC2 인스턴스에 EBS 볼륨을 연결하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\naws ec2 attach-volume --volume-id \u003c볼륨-id\u003e --instance-id \u003c인스턴스-id\u003e --device /dev/xvdf\n```\n\n`볼륨-id`에 방금 생성한 볼륨의 ID를, `인스턴스-id`에는 EC2 인스턴스 ID를 입력해주세요.\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoaddanotherEBSVolumetoaLinuxinstance-EC2Mastery_1.png\" /\u003e\n\n이제 AWS 측에서의 작업이 완료되었으니, 우리의 인스턴스 내부에서 작업을 완료해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 2: EBS 볼륨을 마운트합니다\n\n인스턴스에 SSH로 로그인하거나 콘솔을 사용하세요.\n\n볼륨 포맷:\n\n```js\nsudo mkfs -t ext4 /dev/xvdf\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마운트 지점 생성하기:\n\n```js\nsudo mkdir /mnt/data\n```\n\n볼륨 마운트하기:\n\n```js\nsudo mount /dev/xvdf /mnt/data\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에서 우리는 인스턴스에 10gb EBS 볼륨을 성공적으로 추가했음을 확인할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoaddanotherEBSVolumetoaLinuxinstance-EC2Mastery_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. fstab 파일에 추가하여 마운트 영구화하기:\n\n어떤 시점에서든 인스턴스를 끄거나 다시 부팅하게 되면 최근에 생성하고 추가한 EBS 볼륨이 유지되지 않습니다. 그러므로 /etc/fstab 파일에 추가해주어야 합니다.\n\n```bash\nsudo bash -c 'echo \"/dev/xvdf /mnt/data ext4 defaults,nofail 0 2\" \u003e\u003e /etc/fstab'\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이것은 Linux EC2 인스턴스에 다른 EBS 볼륨을 추가하는 과정입니다.\n\n박수를 치고 팔로우해 주세요. EC2 마스터리 시리즈의 시작에 불과해요!","ogImage":{"url":"/assets/img/2024-06-23-HowtoaddanotherEBSVolumetoaLinuxinstance-EC2Mastery_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoaddanotherEBSVolumetoaLinuxinstance-EC2Mastery_0.png","tag":["Tech"],"readingTime":3},{"title":"리눅스에서 CPU, 메모리, 스토리지 정보를 얻기 위한 기본 시스템 명령어들","description":"","date":"2024-06-23 15:21","slug":"2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux","content":"\n\n![이미지](/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_0.png)\n\n이 문서는 리눅스 쉘 명령어를 사용하여 CPU, 메모리, 저장소 세부 정보를 얻는 방법을 가르쳐 드립니다.\n\n👨🏽‍💻🧑🏻‍💻더 많은 기사를 보려면, 클라우드상의 DevOps 엔지니어링을 팔로우해주세요.\n\n시작해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 컴퓨터의 핵심 구성 요소 개요\n\n컴퓨터는 일련의 알고리즘과 산술 명령을 실행할 수 있도록 프로그래밍할 수 있는 모든 기계를 말합니다.\n\n게임 시스템이든 가정용 PC이든, 현재 대부분의 컴퓨터를 구성하는 다섯 가지 주요 구성 요소는 다음과 같습니다:\n\n![이미지](/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Linux에서 lscpu 명령어를 사용하여 CPU 세부 정보 가져오기\n\nlscpu는 Linux에서 CPU 구성에 대해 알아보는 데 필수적인 명령어입니다. lscpu에 대한 자세한 정보는 lscpu --help를 실행하여 얻을 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_2.png)\n\nLinux의 명령줄 유틸리티 \"lscpu\"는 시스템의 CPU 정보를 가져오는 데 사용됩니다. \"lscpu\" 명령어는 CPU 아키텍처 정보를 \"sysfs\" 및 /proc/cpuinfo 파일에서 가져와 터미널에 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_3.png\" /\u003e\n\n# Linux에서 free를 사용하여 메모리 세부 정보 가져오기\n\nLinux의 free 명령은 컴퓨터의 RAM 사용량을 전체적으로 확인하는 데 사용됩니다. free 명령의 전체 세부 정보를 확인하려면 free --help 명령을 실행할 수 있습니다.\n\n아래 그림에서 제어 인수를 사용하여 free 명령을 사용할 수 있습니다.👇🏻\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Free Command Output 1](/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_4.png)\n\nThis is what the output to the free command looks like in the Linux terminal.\n\n![Free Command Output 2](/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_5.png)\n\nIf you want the human-readable output of the free command you can use the `-h` argument along with the `free` command.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfree -h\n```\n\n![Storage Details](/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_6.png)\n\n# Linux에서 df를 사용하여 저장소 세부 정보 가져오기\n\nLinux의 df 명령어는 각 파일이 존재하는 파일 시스템에 대한 정보나 기본적으로 모든 파일 시스템에 대한 정보를 표시하는 데 사용됩니다. 일반적인 용어로 표현하면, df 프로그램은 하드 디스크나 CD, DVD 및 플래시 드라이브를 포함한 모든 하드디스크 또는 마운트된 장치에서 데이터를 검색하는 데 도움이 됩니다.  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리눅스 터미널에서 다음 명령을 실행하여 df 명령의 전체 사용법을 확인할 수 있어요.\n\n```js\ndf --help\n```\n\n![image](/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_7.png)\n\n만약 인간이 읽기 쉬운 형식으로 출력을 원하면 Linux에서 `df -h` 명령을 사용할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_8.png)\n\n현재 작업 디렉토리의 저장소 세부정보를 사람이 읽을 수 있는 형식으로 확인하려면 Linux에서 다음 명령을 실행할 수 있습니다. 여기서 '.'은(는) 현재 작업 디렉토리를 나타냅니다.\n\n```js\ndf -h .\n```\n\n![image](/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_9.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Linux에서 du를 사용하여 디스크 사용량 세부 정보 가져오기\n\nLinux에서 du 명령어는 디스크 사용량을 가져오는 데 사용됩니다. 이 du 명령어는 각 폴더를 재귀적으로 통과하면서 각 파일의 저장소 세부 정보를 가져옵니다.\n\n간단히 말해, du 명령어는 파일 집합의 디스크 사용량을 요약하여 디렉토리에 대해 재귀적으로 작동합니다. du 명령어의 전체 세부 정보를 얻으려면 du --help을 실행하면 됩니다.\n\n![이미지](/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_10.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ndu 명령어의 출력 결과는 아래 이미지와 같을 것입니다.\n\n![이미지](/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_11.png)\n\n만약 파일의 세부 정보를 찾는 대신 폴더 수준에서 저장소의 세부 정보만을 원한다면 모든 폴더를 재귀적으로 검색하지 않고 다음과 같은 Linux 명령어를 사용할 수 있습니다.\n\n```bash\ndu -sh *\n-s, --summarize        각 인수에 대한 총합만 출력\n-h, --human-readable   사람이 읽을 수 있는 형식으로 크기 출력 (예: 1K 234M 2G)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같은 결과가 출력됩니다👇🏻\n\n![이미지](/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_12.png)\n\n# du 및 sort 명령어를 사용하여 Linux에서 가장 큰 폴더 및 파일 가져오기\n\ndu 명령어와 sort 명령어를 사용하여 Linux 파일 시스템에서 저장 용량을 가장 많이 사용하는 파일을 해결할 수 있습니다. du 명령어의 출력을 sort 명령어로 연결하는 방식으로 이 작업을 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndu -s * | sort -n\n```\n\n위의 명령어를 실행하면 결과는 아래와 같이 나타날 것입니다👇🏻\n\n\u003cimg src=\"/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_13.png\" /\u003e\n\n# Windows에서 du를 사용하여 디렉터리의 저장 세부 정보 이해하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 비디오 타임 스탬프에서 윈도우의 디렉토리 저장소 세부 정보에 대한 설명을 확인하실 수 있어요.\n\n# 폴더 및 파일의 저장소 사용량 얻기\n\n다음 명령어를 실행하여 리눅스 터미널에서 파일 및 폴더의 저장소 사용량을 얻을 수 있어요\n\n```js\ndu -sh .\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리눅스 터미널에서 위 명령을 실행할 때 권한 관련 문제가 발생하면 다음 명령을 사용하여 'Operation not permitted' 메시지를 무시할 수 있습니다.\n\n```js\ndu -sm * 2\u003e/dev/null\n```\n\n출력은 권한 관련 오류 없이 표시됩니다.\n\n위 출력을 sort 명령에 파이핑하여 결과를 오름차순으로 정렬할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sh\ndu -sm * 2\u003e/dev/null | sort -n\n```\n\n# find와 du를 사용하여 더 큰 파일의 저장소 세부 정보 가져 오기\n\n더 큰 파일 세부 정보를 얻으려면 find 명령어와 du 명령어를 함께 사용할 수 있습니다.\n\n```sh\nfind [STRING] -type f -exec du -m {} +;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 명령어에 | sort -n을 추가하여 출력을 정렬할 수도 있습니다.\n\n```js\nfind [STRING] -type f -exec du -m {} + | sort -n\n```\n\n이렇게 하면 Linux 시스템에서 저장 공간을 많이 차지하는 파일 및 폴더를 해결할 수 있습니다.\n\n🙏🏼글을 읽어주셔서 감사합니다. 유용하다고 느껴지면 DevOps Engineering on Cloud 게시물을 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_0.png"},"coverImage":"/assets/img/2024-06-23-BasicSystemCommandstogetCPUMemoryandStoragedetailsinLinux_0.png","tag":["Tech"],"readingTime":5},{"title":"면접 질문, 답변  Linux-1","description":"","date":"2024-06-23 15:19","slug":"2024-06-23-InterviewQuestionAnswerLinux-1","content":"\n\n❓리눅스 부팅 프로세스는 무엇인가요?\n\n리눅스 부팅 프로세스는 여섯 가지의 고수준 단계로 나뉩니다:\n\n- BIOS — Basic Input/Output System이 MBR을 실행합니다.\n- MBR — Master Boot Record가 GRUB를 실행합니다.\n- GRUB — Grand Unified Bootloader가 커널을 실행합니다.\n- Kernel — 커널이 /sbin/init을 실행합니다.\n- Init — Init이 런레벨 프로그램을 실행합니다.\n- Runlevel — 런레벨 프로그램은 /etc/rc.d/rc*.d/에서 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nbuymeacoffee ☕ 👈 클릭해보세요\n\n❓리눅스에서 어떻게 제로 사이즈 파일을 만들 수 있을까요?\n\n쉘 명령어 $ touch 파일이름 을 입력하면 파일 이름의 사이즈가 0바이트인 파일이 생성됩니다.\n\n❓리눅스에서 소프트 링크와 하드 링크는 무엇이며, 이들을 어떻게 생성할 수 있을까요? 이 두 링크 유형의 차이는 무엇일까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Link](/assets/img/2024-06-23-InterviewQuestionAnswerLinux-1_1.png)\n\nA “soft link” takes more, as it has an inode, and file contents (the path to the target file) it also has the name in the directory.\n\nSoftlink 👈\n\nA “hardlink” only exists in the name in a directory- and specifies the inode number of the file.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하드 링크 👈\n\n```js\nln [원본 파일명] [링크 이름] --\u003e 하드 링크 생성\nln -s [원본 파일명] [링크 이름] --\u003e 심볼릭 링크 생성\n```\n\n하드 링크: 파일 이름 = `Inode` = 내 하드 링크\n\n심볼릭 링크: inode `=== 파일 이름 `== 소프트 링크\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n❓ 쉘 스크립트에서 일반적으로 첫 줄은 무엇인가요? 그 의미는 무엇인가요? 만약 이 줄이 생략된다면 어떤 일이 발생하고, 이 경우 스크립트를 어떻게 실행하나요?\n\n스크립트의 첫 줄은 어떤 프로그램을 사용할지를 지시합니다. 첫 줄은 #! 두 문자의 시퀀스로 시작하는데, 이를 \"shebang\"이라고 합니다. 그 다음에는 운영 체제에게 파일의 나머지 부분을 파싱하는 데 사용할 해석기를 알려주는 프로그램이 옵니다.\n\n#!는 사람이 읽기 편하지만, 반드시 그렇게 되어야 하는 것은 아닙니다.\n\n❓ 리눅스에서 쉘 스크립트를 백그라운드에서 실행하는 방법은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n\u0026 Symbol\n```\n\n프로세스를 백그라운드에서 실행하는 또 다른 방법은 실행하는 명령어 뒤에 앰퍼샌드(\u0026) 기호를 추가하는 것입니다.\n\n```js\nscript.sh \u0026\ncommand \u0026\n```\n\n❓리눅스에서 크론탭(crontab)은 무엇인가요? 크론탭을 이용하여 작업을 설정하고 예약하는 방법에 대해 설명해주세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCrontab은 cron 테이블의 약어로, 특정 시간에 실행되어야 하는 다양한 cron 항목의 일정을 포함하는 파일입니다.\n\nCrontab은 백그라운드에서 cron 데몬에 의해 정기적으로 자동으로 실행되도록 하는 유틸리티로 설명할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-23-InterviewQuestionAnswerLinux-1_2.png)\n\nCrontab → 미래의 어느 시점에 실행되어야 할 작업을 예약하는 것.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n크론탭 링크를 참조하세요\n\n- 스크립트 작성 (옵션): 이 섹션에서는 예제 스크립트를 만드는 방법을 설명합니다.\n- 크론텝 파일 생성 또는 편집: 다음 명령을 입력하여 현재 사용자의 크론텝 구성 파일을 엽니다: crontab -e.\n- 크론 작업 생성\n- 출력 (옵션)\n- 저장\n- 활성 크론 작업 확인\n\n❓리눅스에서 포트를 허용하려면 어떻게 해야 하나요?\n\n```js\nsudo ufw allow 53/tcp\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n❓원격 서버에서 문제가 발생하는 경우 어떻게 문제를 해결할 수 있을까요?\n\n- 서버에서 원격 데스크톱 서비스가 실행 중인지 확인합니다.\n- 서버 방화벽이 원격 데스크톱 연결을 차단하고 있는지 확인합니다.\n- 서버가 원격 데스크톱 연결을 허용하도록 구성되어 있는지 확인합니다.\n- 서버의 네트워크 설정이 올바른지 확인합니다.","ogImage":{"url":"/assets/img/2024-06-23-InterviewQuestionAnswerLinux-1_0.png"},"coverImage":"/assets/img/2024-06-23-InterviewQuestionAnswerLinux-1_0.png","tag":["Tech"],"readingTime":3},{"title":"1년 전 VS Code를 삭제하고 Neovim으로 전환한 이유","description":"","date":"2024-06-23 15:18","slug":"2024-06-23-OneYearAgoIUninstalledVSCodeandSwitchedtoNeovim","content":"\n\n\n![image](/assets/img/2024-06-23-OneYearAgoIUninstalledVSCodeandSwitchedtoNeovim_0.png)\n\n## 왜 바꾸고 싶은지 알아보세요\n\n내가 기억할 수 있는 한 오랜 시간 동안 VS Code를 사용해왔습니다. 초보자들이 시작하기에 아주 좋은 편집기입니다. 그러나 다른 일렉트론 기반 앱들처럼, VS Code는 느리고 컴퓨터 배터리를 많이 소모합니다. 제 노트북에서 긴 시간 동안 작업하려고 할 때마다 콘센트를 찾아야하는 번거로움에 지쳐갔습니다.\n\n거기에다가, 동시에 내 Logitech M510 시리즈 마우스가 작동하지 않는 문제가 발생했습니다 — 화면에서 지연되고 깜박이는 현상이 나타났습니다. 이 문제는 때때로 발생하지만 빈번하여 짜증이 났습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 이전에 ThePrimeagen의 YouTube 채널을 구독하고 있었습니다. 그의 독특한 성격과 컴퓨터를 빠른 속도로 조작하는 능력이 저를 매료시켜, 깊이 있는 도구 사용을 배우게 되었습니다. 그래서 나는 내 자신을 설득하여 마우스를 움직이지 않고 vim 명령어를 배워야겠다고 결심했습니다.\n\n## 적절한 도구 선택하기\n\n몇 년 전 vim 명령어를 배우기 전에 Neovim으로 전환을 시도했지만 분명히 실패했습니다. 그래서 이번에는 명령어를 먼저 마스터해야 한다는 것을 알고 있었습니다.\n\nvim 명령어의 숙달을 약속하는 여러 온라인 게임 및 터미널 기반 도구를 시도해 봤지만, 모두 잘 맞지 않았습니다. VS Code용 Vim 확장 프로그램을 사용해 보기도 했지만, 실망스러웠습니다. 확장 프로그램은 느린 에디터를 더 느리게 만들었고, 여러 문제가 있었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내 저는 Zed 텍스트 편집기로 전환했습니다, 비록 여러 가지 단점이 있지만 vim-motion 지원이 훨씬 더 원활했기 때문입니다. 저는 지속적으로 연습하여 모든 앱에서 vim 지원을 찾기 시작했습니다. 정확히 이 이유로 Obsidian을 제 메모 앱으로 선택했습니다. 결과적으로, 그렇게 어렵지 않았습니다. 필요한 대부분을 몇 주 만에 배웠죠.\n\n## Neovim 설정하기\n\nNeovim의 전체 의도는 사용자의 취향에 맞게 설정하는 것입니다. 그렇기 때문에 다른 사람의 환경을 사용하는 것은 의미가 없죠. 그래도, 전체 편집기를 직접 설정하는 것은 압도적으로 어려울 수 있습니다. 그래서 여기에 저가 제 환경을 구성하는 데 사용한 유용한 자료 몇 가지를 제공하겠습니다. 기억하세요, 핵심은 해야 할 작업을 이해하고 스스로 처리하는 것입니다.\n\nGithub 저장소:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Kickstart.nvim. 모든 것이 한 파일에 있어 시작하기에 최적인 곳입니다.\n- ThePrimeagen. 전설 그 자체.\n- 내 Nvim 설정: 내 환경을 어떻게 설정했는지 확인하고 싶다면.\n\n배포:\n\n- LazyVim\n- NvChad.\n- AstroVim\n- LunarVim\n\nYouTube\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Chris@machine의 Neovim 시리즈.\n- TypeCraft.\n- Vhyrro에 의한 Neovim 이해\n\n## 멋진 경험\n\nNeovim이 노트북 배터리를 태우지 않는다는 것을 좋아합니다. 일본으로 향하는 길에 비행기에서 Go 프로젝트의 유닛 테스트를 쓰는 데 5시간 이상을 보냈는데, 배터리 소모가 약 15% 정도 밖에 되지 않았습니다. 요즘에는 노트북이 시원하게 유지되면서 그것을 정말 좋아합니다. 이것만으로도 Neovim으로 변경하는 것이 정당화되었습니다.\n\n게다가, VS Code에서는 너무 많은 확장 기능이 필요하지 않았습니다. 그래서 제가 떠나고 나서 그리워하는 확장 기능이 있지는 않습니다. Quokkajs를 제외하고요, 그것은 자바스크립트와 타입스크립트 스크래치패드입니다. 일단 quokka 대안으로, 제가 어떤 자바스크립트 코드를 시험해보고 싶을 때 빠르게 노드 프로젝트로 전환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n터미널 기반 앱의 사용 경험은 키보드 조작 능력에 달려 있어요. 그래서 만약 키를 누르기 전에 각 키를 살펴봐야 하는 타자 타입이라면 Neovim은 당신을 위한 것이 아닙니다. 스위치하기 전에 키보드를 튼튼하게 다루는 능력이 필요해요. 제가 분당 80자 정도의 타자 능력을 갖고 있었기 때문에 이 문제는 전혀 발생하지 않았어요.\n\n마침내, 다른 사람들이 제가 VS Code를 사용하지 않는 것을 깨달을 때의 반응을 보는 것이 정말 기쁘죠.\n\nNeovim으로 바꾼 것이 내가 한 가장 좋은 결정 중 하나가 되었습니다. 이 스위치로 인해 터미널에 대해 편안해지고 이제 다양한 CLI 응용 프로그램을 사용하고 있어요. 이에 대해 전체 기사를 썼답니다. 모두가 각자의 독특한 학습 경로를 갖고 있어요. 그래서 여러 도구와 기술을 시도하고, 가장 잘 맞는 것을 받아들이는 것이 중요해요. Zed, Obsidian 또는 고장 났거나 망가진 마우스가 당신에게 적합하지 않을지도 몰라요.\n\n아래는 제가 이전 게시물에서 언급한 기사들이에요.","ogImage":{"url":"/assets/img/2024-06-23-OneYearAgoIUninstalledVSCodeandSwitchedtoNeovim_0.png"},"coverImage":"/assets/img/2024-06-23-OneYearAgoIUninstalledVSCodeandSwitchedtoNeovim_0.png","tag":["Tech"],"readingTime":3},{"title":"리눅스 보안 여정  SGID 저장된 그룹 ID 이해하기","description":"","date":"2024-06-23 15:17","slug":"2024-06-23-TheLinuxSecurityJourneySGIDSavedGroupID","content":"\n\n이 문맥에서 SGID는 \"Saved Group ID\"의 약자이며 SGID 비트와는 다릅니다. 이는 루트와 같은 고권한(하지만 그에 국한되지는 않는) 상태에서 일을 하다가 무권한으로 무언가를 수행해야 하는 경우 사용됩니다. 우리는 \"최소한의 권한\" 원칙을 따르고자 하기 때문에 높은 권한은 반드시 필요한 경우에만 사용해야 합니다.\n\n따라서, 우리는 SGID를 사용하여 EGID를 저장한 후 변경을 수행하여 작업이 무권한 사용자로 실행되도록 합니다. 작업이 완료되면 SGID에서 EGID를 다시 가져옵니다.\n\n마지막으로, EGID와 SGID 간에 다른 값을 설정하기 위해 \"setresgid\" 시스템 호출을 사용할 수 있습니다. 우리는 sgid=0이면 egid=0을 사용할 수 있지만 sgid!=0이면 그렇게 할 수 없습니다. 따라서 SGID는 SGID와 같은 개념을 사용합니다. SGID는 \"struct cred\"의 일부로 저장되는 속성이기도 합니다.\n\n다음 글에서 다시 만나요 ;-) 트위터(@boutnaru)를 통해 제 소식을 확인할 수 있습니다. 또한 매체(medium)에서 다른 글도 읽을 수 있습니다. 무료 eBook은 https://TheLearningJourneyEbooks.com에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![2024-06-23-TheLinuxSecurityJourneySGIDSavedGroupID_0.png](/assets/img/2024-06-23-TheLinuxSecurityJourneySGIDSavedGroupID_0.png)\n","ogImage":{"url":"/assets/img/2024-06-23-TheLinuxSecurityJourneySGIDSavedGroupID_0.png"},"coverImage":"/assets/img/2024-06-23-TheLinuxSecurityJourneySGIDSavedGroupID_0.png","tag":["Tech"],"readingTime":1},{"title":"AWS EC2 Linux 인스턴스의 디스크 크기 늘리는 방법","description":"","date":"2024-06-23 15:16","slug":"2024-06-23-HowtoIncreaseDiskSizeonYourAWSEC2LinuxInstance","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoIncreaseDiskSizeonYourAWSEC2LinuxInstance_0.png\" /\u003e\n\n클라우드 컴퓨팅 세계에서는 유연성이 모든 것입니다. 프로젝트가 성장함에 따라 저장 공간 요구도 증가합니다. AWS EC2에서 Linux 인스턴스를 실행 중이고 디스크 공간이 더 필요하다면 걱정하지 마십시오! AWS는 저장 용량을 확장하는 과정을 간단하게 만들어 두었습니다. 이 안내서에서는 XFS 파일 시스템에 대해 xfs_growfs 명령을 사용하는 방법에 중점을 두고 디스크 크기를 증가시키는 단계별 작업을 안내해 드리겠습니다.\n\n# 시작하기 전에\n\n시작하기 전에 다음을 확인하십시오:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- AWS 콘솔 접속: AWS 콘솔에 로그인해야 합니다.\n- EC2 인스턴스: 우분투 또는 아마존 리눅스와 같은 Linux 기반 EC2 인스턴스가 실행 중인지 확인하세요.\n\n# 단계 1: 현재 설정 확인하기\n\n- 인스턴스 연결: 즐겨 사용하는 SSH 클라이언트를 사용하여 인스턴스에 연결합니다. 연결하는 방법을 모르는 경우, AWS 문서를 참조하실 수 있습니다.\n- 디스크 사용량 확인: 연결된 후, 현재 디스크 공간 사용량을 확인하려면 다음 명령을 실행하세요:\n\n```bash\ndf -h\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-23-HowtoIncreaseDiskSizeonYourAWSEC2LinuxInstance_1.png)\n\n모든 마운트된 파일 시스템의 현재 디스크 사용량을 보여줍니다.\n\n# 단계 2: AWS 콘솔에서 볼륨 수정하기\n\n- AWS 콘솔로 이동: AWS 관리 콘솔로 이동하여 EC2 대시보드로 이동합니다.\n- 인스턴스 찾기: \"인스턴스\" 아래에서 인스턴스를 찾아 루트 EBS 볼륨의 볼륨 ID를 메모합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n볼륨 크기를 조정하세요:\n\n- 볼륨을 선택한 후 \"작업\"을 클릭한 다음 \"볼륨 수정\"을 클릭합니다.\n\n![image](/assets/img/2024-06-23-HowtoIncreaseDiskSizeonYourAWSEC2LinuxInstance_2.png)\n\n- 원하는 새 크기를 입력하십시오 (크기를 늘릴 수는 있지만 줄일 수는 없습니다).\n- 변경 사항을 적용하려면 \"수정\"을 클릭하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 3: Linux에서 파일 시스템 확장하기\n\n- 볼륨 크기 변경 확인: SSH 세션으로 돌아가서 새로운 크기를 인스턴스가 인식하는지 확인하세요.\n\n```js\n# lsblk\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoIncreaseDiskSizeonYourAWSEC2LinuxInstance_3.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 명령어를 사용하면 업데이트된 디스크 크기가 표시됩니다.\n\n2. 파티션 크기 조정: 디스크가 파티션을 사용하는 경우 (/dev/xvda4와 같이), growpart를 사용하여 파티션 크기를 조정해야 합니다:\n\n```js\n# growpart /dev/xvda 4\n```\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoIncreaseDiskSizeonYourAWSEC2LinuxInstance_4.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n디스크 식별자와 필요에 따라 파티션 번호를 조정해 /dev/xvda를 변경하세요.\n\n3. 파일 시스템 크기 조정: XFS 파일 시스템의 경우 xfs_growfs를 사용하여 파일 시스템을 새 파티션 크기로 확장할 수 있습니다. 또한 ext 기반 파일 시스템을 resize2fs 명령을 사용하여 크기를 조정할 수도 있습니다.\n\n```js\n# xfs_growfs -d /dev/xvda1\n```\n\n![이미지](/assets/img/2024-06-23-HowtoIncreaseDiskSizeonYourAWSEC2LinuxInstance_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 파티션 (/dev/xvda4)으로 테이블 태그를 변경하십시오.\n\n# 단계 4: 확인 및 정리\n\n- 디스크 공간 확인: 파일 시스템이 성공적으로 확장되었고 추가된 공간을 사용 중인지 확인하기 위해 df -h를 한 번 더 실행해주세요.\n\n![이미지](/assets/img/2024-06-23-HowtoIncreaseDiskSizeonYourAWSEC2LinuxInstance_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 정리하기: 모든 것이 올바르게 작동하는 것에 만족하셨다면, 볼륨을 조정할 때 AWS가 자동으로 생성한 스냅샷을 삭제할 수 있습니다.\n\n# 결론\n\n여기까지 왔습니다! xfs_growfs 명령어를 사용하여 AWS EC2 Linux 인스턴스에서 XFS 파일 시스템의 디스크 크기를 성공적으로 증가시켰습니다. AWS는 이 과정을 꽤 간편하게 만들었지만, 중요한 데이터를 백업하는 것은 인프라를 변경하기 전 좋은 아이디어입니다.\n\n클라우드 리소스를 효과적으로 관리하는 능력은 가치 있는 기술입니다. 이제 프로젝트가 성장함에 따라 EC2 인스턴스의 스토리지를 확장할 수 있는 노하우를 갖추고 있습니다. 질문이 있거나 어려움을 겪는 경우, AWS 문서 및 커뮤니티 포럼은 더 많은 지침을 얻을 수 있는 훌륭한 자료입니다.","ogImage":{"url":"/assets/img/2024-06-23-HowtoIncreaseDiskSizeonYourAWSEC2LinuxInstance_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoIncreaseDiskSizeonYourAWSEC2LinuxInstance_0.png","tag":["Tech"],"readingTime":3}],"page":"22","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"22"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>