<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/28" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/28" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_buildManifest.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="ChatGPT로 완성된 최고의 Midjourney 프롬프트 만들기  이렇게 해봤어요" href="/post/2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ChatGPT로 완성된 최고의 Midjourney 프롬프트 만들기  이렇게 해봤어요" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ChatGPT로 완성된 최고의 Midjourney 프롬프트 만들기  이렇게 해봤어요" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">ChatGPT로 완성된 최고의 Midjourney 프롬프트 만들기  이렇게 해봤어요</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="예측 AI의 도래, 당신과 세계는 준비되었는가" href="/post/2024-06-22-PredictionAIIsComingAreYouandtheWorldReady"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="예측 AI의 도래, 당신과 세계는 준비되었는가" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-PredictionAIIsComingAreYouandtheWorldReady_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="예측 AI의 도래, 당신과 세계는 준비되었는가" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">예측 AI의 도래, 당신과 세계는 준비되었는가</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ChatGPT에게 도널드 트럼프에 대한 45개의 키워드를 부탁한 결과" href="/post/2024-06-22-IAskedChatGPTfor45KeywordsforDonaldTrump"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ChatGPT에게 도널드 트럼프에 대한 45개의 키워드를 부탁한 결과" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-IAskedChatGPTfor45KeywordsforDonaldTrump_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ChatGPT에게 도널드 트럼프에 대한 45개의 키워드를 부탁한 결과" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">ChatGPT에게 도널드 트럼프에 대한 45개의 키워드를 부탁한 결과</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="GPT-4o로 데이터 분석 무기한 변경 2024년 최신 동향 분석" href="/post/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="GPT-4o로 데이터 분석 무기한 변경 2024년 최신 동향 분석" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="GPT-4o로 데이터 분석 무기한 변경 2024년 최신 동향 분석" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">GPT-4o로 데이터 분석 무기한 변경 2024년 최신 동향 분석</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시리와 OpenAI 통합 실험적 첫걸음" href="/post/2024-06-22-SiriandOpenAIIntegrationAnExperimentalFirstStep"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시리와 OpenAI 통합 실험적 첫걸음" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-SiriandOpenAIIntegrationAnExperimentalFirstStep_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시리와 OpenAI 통합 실험적 첫걸음" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">시리와 OpenAI 통합 실험적 첫걸음</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">22<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="OpenAI의 Rockset 인수, AI 기업들에게 어떤 의미가 있을까" href="/post/2024-06-22-WhatDoesOpenAIsAcquisitionofRocksetMeanforAICompanies"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="OpenAI의 Rockset 인수, AI 기업들에게 어떤 의미가 있을까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-WhatDoesOpenAIsAcquisitionofRocksetMeanforAICompanies_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="OpenAI의 Rockset 인수, AI 기업들에게 어떤 의미가 있을까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">OpenAI의 Rockset 인수, AI 기업들에게 어떤 의미가 있을까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="혼돈 시스템을 모델링하는 동적 시스템 딥러닝 활용 방법" href="/post/2024-06-22-Howtousedynamicalsystemdeeplearningtomodelchaoticsystems"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="혼돈 시스템을 모델링하는 동적 시스템 딥러닝 활용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Howtousedynamicalsystemdeeplearningtomodelchaoticsystems_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="혼돈 시스템을 모델링하는 동적 시스템 딥러닝 활용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">혼돈 시스템을 모델링하는 동적 시스템 딥러닝 활용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="시계열 예측에 딥러닝이 필요 없는 이유 현재 기준" href="/post/2024-06-22-WhyYouCurrentlyDoNotNeedDeepLearningforTimeSeriesForecasting"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="시계열 예측에 딥러닝이 필요 없는 이유 현재 기준" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-WhyYouCurrentlyDoNotNeedDeepLearningforTimeSeriesForecasting_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="시계열 예측에 딥러닝이 필요 없는 이유 현재 기준" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">시계열 예측에 딥러닝이 필요 없는 이유 현재 기준</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="신경망 출력에 제약 조건을 적용하는 방법" href="/post/2024-06-22-HowtoEncodeConstraintstotheOutputofNeuralNetworks"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="신경망 출력에 제약 조건을 적용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-HowtoEncodeConstraintstotheOutputofNeuralNetworks_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="신경망 출력에 제약 조건을 적용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">신경망 출력에 제약 조건을 적용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="트랜스포머의 위치 인코딩 시각적이고 직관적인 가이드" href="/post/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="트랜스포머의 위치 인코딩 시각적이고 직관적인 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="트랜스포머의 위치 인코딩 시각적이고 직관적인 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">트랜스포머의 위치 인코딩 시각적이고 직관적인 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">10<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link posts_-active__YVJEi" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"ChatGPT로 완성된 최고의 Midjourney 프롬프트 만들기  이렇게 해봤어요","description":"","date":"2024-06-22 20:31","slug":"2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut","content":"\n\n## 완벽한 프롬프트 만들기\n\n최근 업데이트: 15/06/24.\n\n안녕하세요! Midjourney 크루 여러분, 어떻게 지내시나요?\n\n만약 멋진 Midjourney 프롬프트를 만드는 데 어려움을 겪고 계시고 이미지에 세부 정보를 추가하기 위해 수많은 시간을 쓰고 싶지 않다면, ChatGPT를 사용해 완벽한 프롬프트를 만들어보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 마디도 쓰기 싫다면 이미지를 만들 수도 있어요. 조금 이상하지만 말이죠. 이에 대해 더 많이 쓴 글이 있어요:\n\n그럼 당신에게 무엇이 좋을까요?\n\n- Midjourney에 대한 좋은 프롬프트 구조를 배우세요 (물론 구조가 단 하나뿐은 아니에요)\n- ChatGPT를 사용하여 Midjourney 프롬프트를 만드세요\n- 몇 가지 정말 멋진 예시에서 영감을 얻으세요\n\n이제 ChatGPT를 사용하여 프롬프트를 만드는 방법을 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 기본 프롬프트 구조\n\n먼저 미드저니 프롬프트의 기본 구조를 살펴보겠습니다.\n\n여기서 보시는 것처럼, 주제로 시작하고 속성과 세부 정보를 추가하고, 스타일을 설명하고, 색상 팔레트를 추가한 다음 마지막으로 선택적 요소를 추가해주시면 됩니다.\n\n간혹 요소를 제외해 보는 것도 도전해 볼 수 있지만, 때로는 실패할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당연히 간단한 템플릿을 사용하여 고유한 프롬프트를 만들 수 있어요. 하지만 ChatGPT를 대신 사용해볼 수도 있어요.\n\n## ChatGPT\n\nChatGPT를 사용하는 것은 정말 쉽고 직관적이에요. 이건 Midjourney를 사용하기 전에 한 단계 더 밟는 과정이죠. 초심자들에게는 프롬프트 구조를 이해하고 효과적인 프롬프트를 만드는 방법을 배우는데 좋을 수도 있어요.\n\n익숙해지면 이 단계를 건너뛸 수 있을 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우주 비행사가 외계 행성에 있는 영화 장면을 만들고 싶다고 해보죠.\n\n\u003cimg src=\"/assets/img/2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut_0.png\" /\u003e\n\n우리가 해야 할 일은 원하는 대로 설명하고 ChatGPT가 거의 완벽에 가까운 프롬프트를 만들어주기를 기다리는 것뿐이에요. 적어도 초고, 일부 기초는 제공해줍니다. 그냥 Midjourney에 복사하여 그 마법을 발휘하게 하면 됩니다(결과는 아래에서 확인).\n\n지금 알아차린 것처럼 ChatGPT에 대한 프롬프트로 개인 패턴을 사용했어요. 명시적으로 지시해서 프롬프트 천재로 만드는 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 한 단계 더 나아가서 ChatGPT에게 항상 기본 프롬프트 구조를 따르도록 미리 말할 수도 있어요. 아래 예시에 나와 있는 대로 하면 됩니다:\n\n![2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut_1.png](/assets/img/2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut_1.png)\n\n여기서 볼 수 있듯이, ChatGPT에게 기본 프롬프트 구조를 따르도록 명확히 지시했어요. 이 대화 도중에는 이 규칙을 따르지만, 물론 새 채팅을 열 경우 ChatGPT는 초기화될 거예요(그러니 새 채팅을 시작할 때마다 ChatGPT에게 무엇을 원하는지 말하는 걸 잊지 마세요).\n\n## 중간 단계\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n엔터를 누르기 전에 사용할 모델(예: v6 또는 Niji)과 종횡비에 대해 고민해 보세요. 위 예제를 살펴보겠습니다. 이는 영화 스틸 사진이므로 적어도 16:9 종횡비를 사용하고자 합니다.\n\n이것이 결과입니다:\n\n지금 이 이미지는 훌륭하며, ChatGPT 덕분에 프롬프트를 만드는 데 몇 초만 걸렸어요.\n\n## 프롬프트 예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nChatGPT가 생성한 몇 가지 추가 프롬프트 예제를 살펴보겠습니다. Midjourney v6을 사용하고 있으며 아무것도 포함하지 않기로 결정했습니다.\n\nv6를 사용하고 있고 개인화를 포함하지 않았습니다.\n\n![이미지](/assets/img/2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut_2.png)\n\n![이미지](/assets/img/2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut_4.png)\n\n![이미지](/assets/img/2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut_5.png)\n\n아래는 ChatGPT에 입력한 내용의 예시입니다:\n\n![이미지](/assets/img/2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut_6.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 최소한의 내용만 언급하여 초등부터 화려한 꽃들이 있는 하이테크 생태계에서 슈퍼모델이 나온 잡지 사진에 관심이 있다고 말하기로 결정했어요.\n\nChatGPT는 우리의 대화 초반에 요청 사항과 따라야 할 구조를 명시했음을 기억할 거예요. 그러니 다시 모든 것을 반복할 필요는 없답니다.\n\n또한 제 개인용 궁극의 미드젠 가이드를 만들었어요. 읽는 데 시간이 오래 걸리지만, 50장이 넘는 이미지와 다양한 프롬프트 예시를 포함하고 있으며 정기적으로 업데이트 되고 있어요.\n\n지금은 여기까지입니다 친구들.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nChatGPT를 사용하면 초보자들이 멋진 프롬프트를 만들 수 있어요. Midjourney 프롬프트에 ChatGPT를 사용해 보신 적이 있나요? 💬\n\n저는 개인적으로 ChatGPT를 Midjourney 프롬프트에 사용할까요? 아마도 독립적인 해결책으로서는 사용하지 않을 거예요. 기본 프롬프트를 얻은 후 조명, 카메라, 스타일과 같은 내용을 추가하겠죠. 마지막으로 genAI와 개인화를 조합하면 훌륭한 결과물을 만들 수 있을 거예요.\n\n![이야기 이미지](/assets/img/2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut_7.png)\n\n이 이야기는 Generative AI에서 발표되었어요. 최신 AI 이야기를 만나고 싶다면 LinkedIn에서 만나세요. Zeniteq를 팔로우하여 최신 소식을 받아보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리의 뉴스레터 구독하면 창조적 AI의 최신 뉴스와 업데이트를 받아보실 수 있어요. 함께 AI의 미래를 만들어가요!\n\n![이미지](/assets/img/2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut_8.png)","ogImage":{"url":"/assets/img/2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut_0.png"},"coverImage":"/assets/img/2024-06-22-IHaveUsedChatGPTToCraftThePerfectMidjourneyPromptHeresHowThisTurnedOut_0.png","tag":["Tech"],"readingTime":4},{"title":"예측 AI의 도래, 당신과 세계는 준비되었는가","description":"","date":"2024-06-22 20:29","slug":"2024-06-22-PredictionAIIsComingAreYouandtheWorldReady","content":"\n\n\n![2024-06-22-PredictionAIIsComingAreYouandtheWorldReady](/assets/img/2024-06-22-PredictionAIIsComingAreYouandtheWorldReady_0.png)\n\n참고: 중간 회원이 아닌 경우 이 링크를 통해 무료로 이야기를 읽으실 수 있습니다. 우리 커뮤니티에 참여하도록 권장합니다!\n\n우리 중 누구나 미래를 곰곰이 생각해보지 않나요? 짧고 긴 시간에 걸쳐 펼쳐지는 삶에 대해 얼마나 자주 생각하나요? 미래의 건강과 수명, 자녀의 성공, 직장에서 열심히 일하는 결과를 궁금해하나요? 이런 깊은 개인적 질문들은 앞으로 무엇이 기다리고 있는지에 대한 우리의 타고난 호기심을 반영합니다.\n\n예측은 인간 존재의 기본이자 중추입니다. 일관된 삶이란 다가오는 것을 예상하는 것을 의미합니다. 삶의 사건들이 펼쳐지는 일련의 단계에서 다음 단계를 어림잡을 수 없다면 미래를 위한 계획을 세울 수 없습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예측은 당신의 순간적인 존재에 중요한 역할을 하기 때문에 미래를 알고 싶어하는 갈증이 있다는 것을 모르실지도 모릅니다. 어떤 사람들은 미래에 대해 다른 사람보다 더 걱정을 하는데, 그 이유는 타당하거나 단지 강박적일 수 있습니다. 그러나 미래에 대한 궁금증은 적어도 우리 모두가 가지고 있는데, 이 안에는 새로운 AI 제품에 대한 거대한 마케팅 기회가 숨어 있습니다.\n\n롤아웃 시기가 불확실하지만 AI 산업은 불가피한 미래로 점점 빠르게 나아가고 있습니다. 만약 오픈소스의 ChatGPT나 구글의 Gemini과 같은 생성적 AI가 인상적으로 느껴진다면, 미래에 대해 정보를 잘 알려주는 봇에 대비하는 것이 좋을 수도 있습니다.\n\n## 생성적 AI vs. 예측 AI\n\n생성적 AI (GenAI)와 예측 AI (PredAI)는 서로 다른 목적을 가지고 다양한 응용 분야에서 사용되는 두 가지 구별되는 인공지능 유형입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생성적 AI: 깊은 학습에 뿌리를 둔 GenAI는 자연어 처리(NLP)에서 뛰어난 변형 모델을 활용합니다. 이를 통해 GenAI 모델은 모든 입력 세그먼트(인터넷에서 스크래핑된 데이터 등)을 동시에 검토할 수 있습니다. 이러한 대규모 언어 모델은 출력 생성 중 관련 세그먼트를 우선적으로 분석하여 빠른 텍스트 분석을 가능케 합니다.\n\n미리 정의된 규칙이나 패턴에 의존하는 일반적인 AI 시스템과는 달리, GenAI는 \"상상\"하고 명시적으로 프로그래밍되지 않은 텍스트, 이미지, 음악 또는 코드와 같은 창조적이고 매력적인 콘텐츠를 생성합니다.\n\n예측 AI: PredAI는 과거 데이터, 패턴 및 트렌드를 기반으로 미래 결과를 예측하는 데 중점을 둡니다. 이 접근 방식은 머신러닝 알고리즘, 통계 모델 및 데이터 분석을 활용하여 예측과 추천을 수행합니다.\n\nPredAI는 예측 분석을 사용하여 특정 도메인(헬스케어, 시장, 스포츠 등)에서 현재 사건과 과거 데이터를 평가하여 미래 결과에 대한 교육된 추측을 제공합니다. 머신러닝은 방대한 데이터 집합에서 패턴을 구별하여 예측 분석을 보완합니다. 데이터의 관련성과 풍부성이 관심 영역 및 패턴 이력에 더할수록 그들의 예측이 더 정확해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 예측 인공지능이 미래를 위해 개인화될 수 있을까요?\n\n![image](/assets/img/2024-06-22-PredictionAIIsComingAreYouandtheWorldReady_1.png)\n\n당신은 PredAI의 설명에서 볼 수 있듯, 이 모델은 예측 도메인에 대한 수많은 역사적 정보를 필요로 합니다. 만약 당신만의 개인화된 PredAI 버전을 원한다면, 미래에 대해 알려줄 PredAI 모델이 당신에 대한 풍부한 정보를 필요로 할 것입니다.\n\nPredAI는 왜 예측을 위해 이렇게 많은 역사적 정보가 필요할까요? 통계적 확률론의 관점에서 볼 때, 당신은 습관의 피조물이며, 당신의 습관이 미래를 결정할 것입니다. Pred AI는 당신의 일상에 대해 알고 싶어합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n10년 전, 기술 기자이자 미래학자인 패트릭 터커가 \"The Naked Future\" (2014)를 썼어요. 책의 부제가 제 관심을 끌었어요: 미래를 예상하는 세계에서 어떤 일이 일어날까?\n\n터커는 그의 책에서 많은 인지과학자들에게 잘 알려진 아이디어를 상세히 설명해요: 인간 마음은 예측 기계예요. 우리의 본성으로 인해, 우리는 항상 다음 일이 무엇일지 예측하고 있어요.\n\n터커는 우리가 현재를 기반으로 미래를 관리하기 위해 정신적 모델들을 만들어간다고 언급했어요. 우리의 다양한 경험을 고려할 때, 우리 뇌에는 일이 어떻게 작동하는지에 대한 수많은 모델이 저장되어 있어요.\n\n간단한 예를 들어볼게요. 어릴 때, 포크와 숟가락의 다른 용도에 대해 배워요. 그 결과, 당신의 뇌는 각각에 대한 모델을 개발해요. 어른이 되어서는, 생각하지 않고도 손님에게 수프를 서빙할 때 포크 대신 숟가락을 가져가는 모델을 그 모델에 올려놓을 때에 사용하게 될 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n인간 관계나 정부와 같은 비물리적 측면에 대한 모델도 작성합니다. 수 년간의 우정을 기반으로, 다음 만남에서 당신의 친구에 대한 예상을 나타내는 인식 규칙 집합이 되는 친구 모델을 만듭니다. 우리가 만들어낸 모델은 미래를 예측하는 데 도움이 됩니다. 포크로 수프를 호봉하는 것은 불가능하다고 예측합니다. 당신의 친구가 다음 주에 당신을 만나서 기뻐할 것이라고 예측합니다.\n\n## 당신과 당신의 삶에 맞춤형 예측 AI\n\n두뇌에 저장된 인지 모델은 일상적인 사건에 대한 예측을 돕습니다. 당신은 전문 면허 시험을 위해 열심히 공부하고 있습니다. 모의고사를 보면서 면허 시험에서 무엇을 기대해야 하는지에 대한 인지 모델을 만들었습니다. 당신의 공부 습관을 모의 모델과 일치시켜, 면허 시험에서 잘 볼 것이라고 예측합니다.\n\n그렇다면 선택한 직업에서 어떻게 성과를 내게 될까요? 시간과 에너지적 요구가 많을 것입니다. 상사에게 24시간 7일간의 가용성을 제공할 수 있는 체질적으로 가능할까요? 이 힘든 역할에서 행복을 느낄 수 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n귀하는 일상 속에서 벗어난 분야에서 미래를 예측하기 위해 뇌에 자신의 삶에 대한 더 많은 정보를 저장해야 합니다. 인간 뇌는 모든 살아있는 생물 중에서 가장 뛰어난 기능을 갖고 있지만, 까먹는 등의 한계가 있습니다. 과거에서 고등학교 육상팀에서 탈락한 이유를 너무 바빠서 개인 시간이 부족했다고 잊어버리는 등, 귀하는 개인 시간을 경쟁보다 더 중요시하는 것을 보여주는 사실이 있습니다.\n\n개인 시간이 없는 직장에서 잘 할 수 있을까요?\n\n과거 경험이 미래 경험과 밀접하게 관련이 있습니다. 하지만 만약 지난 경험에 대한 모든 정보를 포착하는 마법같은 존재가 있다면 어떨까요? \"역사적인 나\"에 대한 데이터가 \"미래의 나\"를 예측하는 데 이용된다면 어떨까요?\n\n당신에 대해 모든 정보를 알고 미래를 예측하는 누군가의 생각은 흥미롭거나 두려울 수 있지만, 걱정하지 마십시오. 이미 그런 일이 벌어지고 있습니다. 미래에 대한 귀하의 관심은 산업 리더들이 Prediction AI의 개인화된 모델을 가능한 빨리 제공할 수 있도록 동기를 부여합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 코펜하겐 인구 기반 예측 AI 모델\n\n![이미지](/assets/img/2024-06-22-PredictionAIIsComingAreYouandtheWorldReady_2.png)\n\n덴마크 코펜하겐의 한 연구팀은 방대한 개인 정보 데이터베이스를 기반으로 한 흥미로운 실험적 예측 모델을 개발했습니다.\n\n코펜하겐 팀은 새로운 논리(\"당신의 삶은 문장과 같다\")를 사용하여 상세한 사건 시퀀스를 기반으로 인간의 삶의 진화와 예측 가능성을 조사했습니다. 이 논리는 삶을 비유적인 문장으로 사용합니다. 예를 들어, 문장에 포함된 단어가 많을수록 어떻게 끝나는지 알 수 있을 가능성이 높습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, \"나는...\"라고 시작하면 문장의 끝이 다양할 수 있다는 것을 시사합니다. 반면에 \"나는 ... 할 것이다\"라고 시작하면 가능한 후보가 좀 더 좁아집니다. 만약 어떤 엔티티가 당신의 일상을 알고 있다면(금요일이며 주말에 특정 장소를 자주 방문하는 경우), 그 엔티티는 당신의 미래를 \"나는 ... Jake's Bar에 친구들을 만나러 퇴근 후에 갈 것이다\"로 예측할 수 있습니다. 이런 식으로 당신의 삶은 더 많은 정보를 통해 더 예측 가능하게 됩니다.\n\n분명히, PredAI가 당신에 대해 알면 알수록 더 나은 예측을 할 수 있습니다. 이 전제가 코펜하겐 팀이 덴마크 국립 레지스트리로부터 독특하고 포괄적인 데이터셋에 액세스하는 계기가 되었습니다. 이 데이터셋은 약 10년 동안 약 600만 명의 덴마크 시민들에 대한 상세한 일일 생활 기록을 포함하고 있었습니다.\n\n이 국립 레지스트리에서 연구자들은 덴마크 시민들의 건강, 교육, 직업, 소득, 주소, 근무 시간과 관련된 정보를 수집했는데, 이 정보들은 일일 해상도로 기록되었습니다. 이 데이터셋을 사용하여 교대어 모델에서 인간의 삶을 언어로 표현된 문장과 유사한 사건의 연속으로 표현할 수 있다는 것을 연구자들은 입증했습니다. 이러한 연속은 일찍 사망부터 성격의 미묘함까지 다양한 결과를 예측하는 데 사용될 수 있습니다.\n\n이 연구가 당신에게 오싹한 느낌을 준다면? Patrick Tucker의 책 제목 \"당신의 모든 움직임을 예견하는 세상에서 무슨 일이 벌어질까\"를 고려해보세요. 덴마크에 거주하고 계시다면, 국립 레지스트리가 당신의 모든 움직임을 기록했을 것입니다. 윤리적 및 개인정보 보호 제약 내에서, 그 데이터셋은 코펜하겐 팀이 개인화된 인구 기반 예측 AI 모델을 생성하는 데 활용되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 이 모델의 장단점을 평가하기 전에, 우리는 먼저 그 핵심 작동 원리를 살펴보겠습니다.\n\n## 코펜하겐 모델의 기능\n\n연구자들은 그들의 인공지능 모델이 수행하는 세 가지 \"예측 작업\"을 강조했는데, 이를 'life2vec'이란 색다른 이름으로 부여했습니다. (제 생각에 이것은 '인생에서 벡터로'의 약칭인데, 이는 또한 '인생에서 스냅샷으로'를 의미합니다.)\n\n1. 사망 예측: 생애 사건의 연속을 분석함으로써, 이 모델은 특정 시간대 내 조기 사망 가능성을 예측할 수 있습니다. 이것은 특정 사건 순서가 조기 사망 위험과 연관된 패턴을 학습함으로써 수행됩니다. 예를 들어, 여러 가지 부정적인 건강 관련 사건을 포함한 일련의 사건은 더 높은 위험을 나타낼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 성격 뉘앙스 예측: 이 모델은 인간의 삶에 대한 더 세밀한 측면, 예를 들어 성격 특성까지 예측합니다. 이는 삶의 사건 순서와 자가 보고된 성격 설문 조사 응답 사이의 연관성을 학습하여 가능해집니다. 예를 들어, 빈번한 사회적 상호작용이 외향적인 성격 특성과 연관될 수 있습니다.\n\n3. 개인 요약: 건강 기록, 교육적 이정표, 직업 진로 등을 포함한 사람의 삶의 다양한 사건을 파헤쳐 Life2Vec는 이 정보를 \"개인 요약\"으로 추려내어 특정 인물의 삶의 여정의 본질을 잡아낸 콤팩트하고 포괄적인 스냅샷(벡터)으로 변환합니다.\n\n이 개인 요약 기능을 더 자세히 살펴보겠습니다.\n\n당신이 삶에 대한 세부적인 일지를 기록하여 건강 점검이나 직장 변경부터 중요한 이정표와 금전적 결정까지 모든 중요한 사건을 기록했다고 상상해보세요. 이제 Life2Vec 앱에 가입하여 당신의 일기를 읽고 알고 있는 모든 것을 한눈에 이해하기 쉬운 스냅샷으로 요약하는 기능이 있는 상황을 상상해봅니다. 이 스냅샷은 당신 이야기의 본질을 잡아내는 특별한 코드와 같습니다. 해당 앱은 개인 요약 공간에서 당신을 위한 \"벡터\"를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생활 벡이 미래에 대해 추측할 때, 예를 들어 건강이나 가질 수 있는 직업과 같은 것에 대해 본인에 대한 데이터가 이 특징 벡터(스냅샷)를 통해 분석됩니다. 당신의 나이, 자신을 얼마나 잘 돌보고 있는지, 수입 등과 같은 명백한 사항뿐만 아니라, 현재 수행하고 있는 직업의 종류와 이로 인한 미래 영향과 같은 미묘한 세부 사항들에도 주목합니다.\n\n미래에 대해 알고 싶은 것에 따라, 개인적인 세부 사항(스냅샷)이 조정되어 어느 특정 분야의 앞으로 벌어질 일에 대한 다양한 질문에 대한 가장 정확한 예측을 제공하게 됩니다.\n\n예를 들어, life2vec은 직업 선택이 미래의 건강에 어떤 영향을 미칠 수 있는지를 도와줄 수 있습니다. 이러한 통찰력은 새로운 질문을 불러일으키며, 이전에 생각하지 못했던 영역을 탐구하도록 이끌어주어, 당신이 미래에 대한 이 AI 예측에 대한 '왜'를 이해하도록 돕습니다.\n\n개인적인 예측뿐만 아니라, life2vec의 세 가지 예측 작업(사망률, 성격 세부 사항, 개요)은 어디에 사시는지, 교육 수준, 연령대, 정치적 소속 등과 같은 것을 기반으로 당신을 위한 미래 시나리오를 제시할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 예측 AI의 위험성\n\n![예측 AI 이미지](/assets/img/2024-06-22-PredictionAIIsComingAreYouandtheWorldReady_3.png)\n\n개인 AI 어시스턴트가 미래 행동의 예상 결과에 대한 결정을 돕는 한, 이 혜택의 대가는 당신에 대해 알아야 할 모든 것을 아는 AI 엔티티입니다. 자신에 대해 말하는 것이 많을수록 그 혜택은 커집니다.\n\n예측 AI의 힘에 대해 읽으면서, 당신은 아마도 여러분의 디지턜 히스토리와 관련된 위험 목록을 직접 작성할 수 있을 것입니다. 여기에 제가 작성한 목록이 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예측 모델 소유권: 북유럽 지역 국가들과 일부 국가들만이 포괄적이고 규제된 시민 등록 시스템을 갖추고 있지만, 다른 국가들은 그렇지 않습니다. 만약 인구 기반 예측 AI가 확대된다면, 당신의 인생 사건에 대한 정보를 보관할 주체가 누가 될지에 대한 의문이 제기됩니다. 억만장자가 소유한 사립 기업이 이 정보를 신뢰할만 할까요? 당신은 정부에게 이 정보를 신뢰할 수 있을까요?\n\n개인정보 보호 및 윤리적 우려: 개인이나 인구 예측을 위해 상세한 개인 데이터를 사용하는 것은 동의, 데이터 보호 및 민감한 정보 남용 가능성 등에 대한 중요한 개인정보 보호 및 윤리적 문제를 도출합니다.\n\n편향성과 공정성: 생성 모델 AI는 \"환각\"을 일으키며 가짜 정보를 만들어내는 것으로 알려져 있습니다. 예측 AI 예측은 역사 데이터셋에 내재된 편향으로 영향을 받을 수 있으며, 부정확하거나 잘못된 미래 시나리오로 이어질 수 있습니다. 이는 분명히 나쁜 계획을 유도하거나 잘못된 조언에 기반한 잠재적으로 재앙을 초래할 수 있습니다.\n\n예측 모델에 대한 과대 의존: 미래에 대한 다른 사람보다 많은 확신이 필요한 사람들이 있습니다. 불확실성으로 치닫는 사람의 욕구는 PredAI의 복잡성과 인간 건강의 다층적 한계를 고려하지 않고 결정적인 건강 결정을 위해 이러한 모델에 지나치게 의존하는 위험을 초래할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 한 번 도착하면, 예측 AI는 사라지지 않을 것입니다\n\n예측 AI는 현재 많은 산업에서 활발히 사용되고 있으며 더욱 보급화될 것입니다. 의료 분야에서는 예측 AI와 생성 AI가 질병의 초기 검출 및 진단의 핵심 구성 요소로 자리잡을 것으로 예상되며, 개인 맞춤형 치료 계획의 작성 및 질병 진행의 예측 분석을 통해 환자 안전성, 효율성 및 비용 절감을 향상시킬 수 있습니다.\n\n## 이제 내가 미래를 예측할 차례입니다\n\n![이미지](/assets/img/2024-06-22-PredictionAIIsComingAreYouandtheWorldReady_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n생성적 AI는 사람이나 기계가 예측하기 힘든 속도로 확산되었습니다. GenAI는 이제 거의 모든 개인의 삶과 대부분의 산업에 보급되어 있습니다. 18개월 전에 나는 유럽 휴가를 계획하기 위해 AI 봇을 사용할 줄이야!\n\n예측 AI도 동일한 미래를 예측할까요? GenAI와 마찬가지로, PredAI는 큰 데이터를 필요로 합니다. 그러나 PredAI는 예측을 위한 패턴을 수립하기 위해 역사적이고 추세 데이터가 필요합니다. 개인 역사에 대해서는 코펜하겐 모델을 만드는 데 사용된 국가 기록이 마련되어 있는 몇몇 국가밖에 없습니다.\n\n이전의 일상적인 생활에 대한 모든 세부 정보를 수집하도록 이익 중심의 대형 기술 기업에 허용하지 않는다면, PredAI 산업은 필요한 깊이와 폭의 개인 중심 데이터에 대한 접근 권한이 부족할 수 있습니다.\n\nPredAI가 우리의 삶에 점차적으로 침투할 가능성이 더 높습니다. 예를 들어, 의료 계획은 의료 기록을 추적하며 필요에 따라 시스템 내 전문가들과 공유됩니다. PredAI 모델은 최근 진단의 변화 추이를 예측하는 데 도움이 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n정확도 AI의 성장은 결국 우리가 얼마나 많은 정보를 제공하는지에 달려 있을 수 있어요. 천사인지 악마인지, 맞춤형 PredAI는 필요한 영양소를 제공받으면 성장할 거예요 - 당신의 삶의 역사.\n\nPredAI의 미래를 준비하기 위한 최상의 조언은 무엇일까요? 경험 많은 카우보이들이 첫 번째 힘든 라이딩을 할 준비를 하는 로데오 초보자들에게 하는 말처럼 \"그 불을 알고 발길 준비를 하세요!\"","ogImage":{"url":"/assets/img/2024-06-22-PredictionAIIsComingAreYouandtheWorldReady_0.png"},"coverImage":"/assets/img/2024-06-22-PredictionAIIsComingAreYouandtheWorldReady_0.png","tag":["Tech"],"readingTime":9},{"title":"ChatGPT에게 도널드 트럼프에 대한 45개의 키워드를 부탁한 결과","description":"","date":"2024-06-22 20:27","slug":"2024-06-22-IAskedChatGPTfor45KeywordsforDonaldTrump","content":"\n\n## 정치, 챗지피티 트럼프\n\n\u003cimg src=\"/assets/img/2024-06-22-IAskedChatGPTfor45KeywordsforDonaldTrump_0.png\" /\u003e\n\n친구가 AI(인공 지능)가 160-IQ를 가지고 있다고 하자, 나는 도널드 트럼프에 대해 어떻게 생각하는지 궁금했습니다. ChatGPT에 질의를 제출했지만 트럼프가 매우 논란적인 인물이기 때문에 답변을 받지 못했습니다. 그래서 키워드를 요청했습니다. 예상하기로는, 나의 IQ가 160 아래인 작가에게는 이용할 수 없는 통찰을 제공할 것 같았습니다.\n\nChatGPT가 제공한 키워드와 각 키워드에 대한 내 코멘트는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 대통령 (네, 대통령이었습니다. 아직 여기에 남아있어서 운이 좋습니다.)\r\n- 사업가 (의견이 분분할 만한데, 뉴욕 및 다른 곳에서의 사기 역사를 보면 사업가로 설명하기 어려울 수 있습니다. 트럼프는 사업을 하기 원하지 않는 사업가입니다.)\r\n- 기업가 (의견이 분분합니다. 기업가는 사기꾼, 사기꾼, 기회 및 범죄자에게 일반적으로 사용되지 않습니다.)\r\n- 공화당 (사실이 아닙니다. 트럼프는 공화당이 되기 전에 민주당원이었습니다. 공화당을 MAGA 당이나 Trump 당으로 재편한 점을 고려하면, 나는 그를 명목상의 공화당이라고 설명하겠습니다.)\r\n- 정치인 (부정적인 의미에서 네. 그는 내가 아는 민주당원들보다 더 늪스러워 보입니다. 그는 2018년과 2020년 하원 및 상원 선거를 조작하여 공화당을 피해 선발할 기회가 필요하다고 생각합니다.)\r\n- 논란 (매우 정확합니다.)\r\n- 대중주의자 (네, 대중주의자가라고 하면 \"일반 대중의 편견, 두려움 및 도덕적 결함에 호소하는\" 것을 의미하는 경우 맞습니다.)\r\n- 형평성 (네. 트럼프 씨는 사실에 대해 잘 알려져 있지 않습니다.)\r\n- 트위터 (ChatGPT 씨, 당신이 \"X\"를 의미하는 거 맞나요?)\r\n- 이민 (네, 그러나 트럼프는 동유럽 슈퍼모델을 제외하고는 이민에 반대하는 입장을 취합니다.)\r\n- 무역 (네, 그러나 트럼프는 관세를 인상하여 무역을 소멸시키려는 계획을 강행하고 있습니다. 소득세를 없애고 관세로 대체하기로 계획을 실행할 경우, 무역이 거의 남지 않을지도 모릅니다.)\r\n- 경제 (네, 그러나 트럼프에게 주어진 것보다 더 많은 영광을 받았습니다. 트럼프가 좋은 경제를 만드는 데 기여한 것으로 인정된다면, 바이든도 동일한 대우를 받아야 합니다. 고용 숫자를 확인해 보세요.\r\n- 미국 우선주의 (네. 트럼프 씨는 고립주의자입니다. 미국 연합군을 상어에게 던질 준비가 되어 있습니다.)\r\n- 성벽 (네, 그러나 트럼프가 미국에서 갈색 인종을 배제하기 위해 만들 것이라고 약속한 성벽은 실제로 만들어지지 않았습니다.)\r\n- MAGA (네)\r\n- 백악관 (2024년 미국 유권자들이 선거일에 약간의 상식을 갖춘다면 트럼프가 다시 가지 못하는 곳을 설명하는 용어입니다.)\r\n- 대통령직 (네. 트럼프는 첫 대임 기간에 대통령직을 광대한 오락쇼로 만들었습니다. 두 번째 임기는 더 나빠질 것입니다.)\r\n- 정책 (트럼프가 이 용어를 정의하도록 요청받으면, 이해하기 어려워하고 주제를 바꿀 것입니다.)\r\n- 행정명령 (이것들은 트럼프의 \"하룻밤 독재자\"로 나아가는 계획에 필수적이며, 독재적 권한을 경험한 후에는 그가 물러나기를 원치 않을 것입니다.)\r\n- 캠페인 (트럼프의 캠페인의 핵심은 그의 집회입니다. 배부른 상태로 그것을 보지 마세요.)\r\n- 선거 (트럼프는 선거를 위해 달려가고 있지만, 여기에서 키워드는 \"선거 부정\"이어야 합니다. 그것이 트럼프가 2024년 백악관에서 승리하는 유일한 방법입니다. 또한, 트럼프 팀은 이미 11월에 패배한다면 어떻게 선거 부정을 주장할지 기획 중입니다.)\r\n- 미디어 (이 키워드는 \"가짜 미디어\"여야 했으며, \"진실\" 소셜 이외에도 트럼프는 어느 미디어도 완전히 합법적으로 인정하지 않습니다.)\r\n- 셀러브리티 (트럼프가 자기 홍보와 \"더 앱렌티스\"를 통해 유명인으로 된 것이 아니었다면 지금 여기에 대해 작성 중이진 않았을 것입니다.)\r\n- 억만장자 (의문이 드는 부분입니다. 트럼프 씨, 소득세 신고서를 보여 주실 수 있나요?)\r\n- 부동산 (네, 그러나 트럼프는 뉴욕의 부동산 비즈니스가 얼마나 추잡할 수 있는지를 우리에게 가르쳐 주었습니다.)\r\n- 뉴욕 (트럼프의 과거 고향. 오늘, 뉴욕은 트럼프와 전혀 상관이 없는 것을 원합니다.)\r\n- 수습생 (네, 이것은 당연합니다. 트럼프의 TV 프로그램의 이름이기도 한 수습생입니다. 2017년 대통령으로 백악관에 입성할 때 트럼프는 수습생이라고 불리워야 했지만, 트럼프는 독해, 청취 또는 학습자가 아니기 때문에 대통령으로 있다가는 교만한 아마추어에 불과했습니다.)\r\n- 탄핵 (이 키워드가 두 번 포함되어야 합니다.)\r\n- 뮬러 보고서 (누군가 나에게 말해 줄 수 있나요? 뮬러가 체감 적발전은 사실로 보고 않았는지요.)\r\n- 코로나19 대응 ( Ivermectin (말 약), 클로록스 마시기, 대규모 창관 이벤트, 월터 리드 의료센터 주변을 리무진으로 운전하여 팬들이 그를 부를 수 있게 하는 등의 대응 사례들)\r\n","ogImage":{"url":"/assets/img/2024-06-22-IAskedChatGPTfor45KeywordsforDonaldTrump_0.png"},"coverImage":"/assets/img/2024-06-22-IAskedChatGPTfor45KeywordsforDonaldTrump_0.png","tag":["Tech"],"readingTime":3},{"title":"GPT-4o로 데이터 분석 무기한 변경 2024년 최신 동향 분석","description":"","date":"2024-06-22 20:26","slug":"2024-06-22-GPT-4oChangedDataAnalysisIndefinitely","content":"\n\n예, 이 요소는 데이터 과학입니다. 이 기사에서는 데이터 분석이 어떻게 완전히 변화되었는지 살펴보겠습니다.\n\nChatGPT는 다양한 영역에 영향을 미치지만, 가장 많은 영향을 미치는 영역이 무엇인지 궁금해하시나요? ChatGPT의 최신 및 가장 발전된 모델인 GPT-4를 사용하여 데이터 분석 방법을 자동화할 수 있는 방법을 볼 수 있습니다. 시작해 봅시다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# NVIDIA 주식 가격\n\n![이미지](/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_1.png)\n\nNVIDIA는 현재 매우 인기가 있습니다. 여기서 NVIDIA 주식가격 데이터셋을 사용해보죠. 이 데이터셋을 다운로드한 후 Google 드라이브에 업로드하고 거기서 ChatGPT에서 불러올 수 있지만, 드래그 앤 드롭으로 업로드하는 것이 더 쉽습니다.\n\n![이미지](/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터 탐색\n\n지금은 이 데이터셋을 탐색해보겠습니다. 아래 프롬프트를 사용할 수 있어요.\n\n- 이 데이터셋의 처음과 끝을 보여줘.\n- 이 데이터의 샘플을 임의로(10개) 보여줘.\n- 이 데이터의 형태(shape)는 무엇인가?\n- 이 열의 데이터 유형은 무엇인가?\n- 열에 대한 통계 정보를 알려줘.(describe)\n\n이제 이를 적용해 봅시다. 첫 번째 프롬프트가 여기 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n이 데이터 세트의 첫 부분과 끝 부분을 보여주세요.\n```\n\n![이미지](/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_3.png)\n\n또한, 오른쪽 상단의 확장 버튼을 클릭하면 이 테이블들을 확장할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 클릭하면 테이블이 이렇게 확장되고, 여전히 아래의 대화 전체를 볼 수 있어요.\n\n![이미지](/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_5.png)\n\n두 번째 프롬프트를 사용해 보겠습니다.\n\n```js\n이 데이터의 샘플을 무작위로 보여줘(10).\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![불러오기 실패](/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_6.png)\n\n다른 프롬프트를 사용해보세요.\n\n```js\n각 열의 통계 정보를 제공해주세요.(describe)\n```\n\n![불러오기 실패](/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_7.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n뭔가 알아차렸어요? 네, GPT-4o가 이미 이 데이터셋을 시각화하는 옵션을 제안했어요. 그러니 기다릴 필요가 없겠죠? 데이터 시각화로 계속 진행합시다. 놀라움이 더 있을 거예요.\n\n# 데이터 시각화\n\n우리가 데이터 시각화를 어떻게 자동화할 수 있는지 살펴봐요.\n\n## 월간 수익률 막대 그래프\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 당신이 달의 시작에 주식을 사고, 달의 끝에 판매한다면 얼마를 벌 수 있을까요?\n\n자, 문제를 봐봅시다;\n\n```js\n다음을 제공하세요: Bar Plot of Monthly Returns in percentage Daily over time, \ndate column should include this Month- Year instead of dates day by day.\n```\n\n여기가 결과물입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Change the table tag to Markdown format](/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_8.png)  \n\nYou can change the column by clicking on the second button on the top right, and here, you can easily adjust the plot.\n\n![Change the table tag to Markdown format](/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_9.png)  \n\nAlso, when you click on the first button on the top right-switch to static chart, you can not change the plot now.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003ctd\u003e\u003cimg src=\"/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_10.png\" /\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\n\"차트를 다운로드하시려면 오른쪽 상단의 3번 버튼을 클릭하시면 됩니다.\"\n\n## 트렌드 이벤트와 함께 라인 플롯\n\n주식 가격을 분석하는 것은 멋진 일이죠. 모두들 어떻게 시간이 지남에 따라 가격이 어떻게 변화되었는지 궁금해합니다. 하지만 저희에게 멋진 도구(GPT 4-o)가 있으니까요, 주요 이벤트가 가격에 어떤 영향을 미치는지 확인해봅시다. 여기에 프롬프트가 있습니다;\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n중요 이벤트에 대한 주석이 있는 조정 종가 시간대별 그래프입니다.\n데이터셋에는 '날짜' 및 '조정 종가' 열이 포함되어 있습니다.\n주식 가격의 주요 변동에 기반하여 중요 이벤트를 식별하고 그래프에 주석을 추가하세요.\n```\n\n이 그래프를 확인해주세요.\n\n\u003cimg src=\"/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_11.png\" /\u003e\n\n하지만 중요한 이벤트가 상당한 가격 변동과 연관이 있는지 궁금해서 이를 사용합니다;\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n네, 이러한(상승 및 하강)을 세계의 중요한 사건들과 연관시킬 수 있을까요?\n\n\n여기에 결과입니다.\n\n멋지네요, 계속 진행되지만 이해하셨죠. 이제 이 프롬프트로 그래프에 이러한 이벤트를 쓰세요.\n\n\n각 이벤트에 대해 2단어씩 그래프에 작성해주세요.\n단어가 겹치지 않도록 유의하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기에 결과가 있습니다.\n\n![이미지](/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_12.png)\n\n## 한 번에 여러 그래프\n\n이제 빠른 결과를 원하신다면, 이건 정말 좋아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n다양하고 많은 정보를 제공하는 그래프 3개를 제공해주세요.\n```\n\n다음은 출력입니다.\n\n또한 이 그래프들에 대한 정보도 여기 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_13.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마무리\n\n이 글을 읽어주셔서 감사합니다. ChatGPT가 처음 출시되었을 때, 아무것도 변하지 않았다고 설명하려는 많은 기사를 읽었지만, 그때부터 데이터 과학이 영원히 변화했다고 믿어요.\n\n이러한 변화를 따라가고 싶다면, 제 substack의 유료 구독자가 되는 것을 고려해보세요.\n\n여기에서는 팔로워들에게 특별한 GPT를 제공하며, ChatGPT와 같은 LLM을 사용한 데이터 프로젝트, 주간 인공지능 뉴스레터 등을 제공합니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미지 태그를 마크다운 형식으로 변경하였습니다.\n\n이곳에 무료 자료들이 있습니다.\n\nChatGPT 치트 시트가 이곳에 있습니다.\n\nNumPy 치트 시트가 이곳에 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기가 \"How to be a Billionaire\" 데이터 프로젝트의 소스 코드입니다.\n\n여기가 \"Classification Task with 6 Different Algorithms using Python\" 데이터 프로젝트의 소스 코드입니다.\n\n여기가 \"Decision Tree in Energy Efficiency Analysis\" 데이터 프로젝트의 소스 코드입니다.\n\n여기가 \"DataDrivenInvestor 2022 Articles Analysis\" 데이터 프로젝트의 소스 코드입니다.","ogImage":{"url":"/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_0.png"},"coverImage":"/assets/img/2024-06-22-GPT-4oChangedDataAnalysisIndefinitely_0.png","tag":["Tech"],"readingTime":5},{"title":"시리와 OpenAI 통합 실험적 첫걸음","description":"","date":"2024-06-22 20:23","slug":"2024-06-22-SiriandOpenAIIntegrationAnExperimentalFirstStep","content":"\n\n내 맥북의 Siri와 OpenAI API를 통합하려고 생각 중이에요. 그 과정에서 API와 대화하는 방법을 상세히 설명한 옵션을 찾았는데, 대부분이 Mac에서 작업을 수행하는 것을 활용하지 않고 Siri를 통해 API와 대화에 대해만 논의했어요. 저는 Siri를 사용하여 컴퓨터를 제어하기 위해 한 발짝 더 나아가고 싶었어요. 이 블로그에서는 Siri와 OpenAI API를 결합한 도구를 만든 방법을 공유할 거예요. 이 도구를 사용하면 PyCharm 프로젝트를 열거나 음성 명령으로 브라우저를 열거나 코드를 생성하거나 생성된 코드를 직접 클립보드에 복사하거나 심지어 Siri로 Spotify에서 검색할 수 있어요. 이것은 첫 번째 버전이라 강력하고 최종적인 도구는 아니에요. 그러나 저는 저의 실수, 사용한 전략, 만난 발견, 그리고 이의 장단점에 대해 이야기할 거예요.\n\n# 목차\n\n∘ 실행하는 방법\n∘ 바로 가기 다운로드:\n∘ 기능\n∘ Siri 바로 가기\n∘ OpenAI API\n∘ 서비스\n∘ 큰 문제\n∘ 비용\n∘ 개선 사항 및 결론\n\n## 실행하는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저장소에는 서비스 실행 방법에 대한 지침이 있습니다.\n\nShortcuts 다운로드:\n\n- Hey Jarvis\n- 클립보드 확인\n- Jarvis Call\n\nOpenAI 대시보드에서 어시스턴트를 생성하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOpenAI 대시보드에서 도우미를 만들 수 있어요. 이 블로그에 보여진 프롬프트와 함수 정의를 복사할 수 있어요.\n\n## 기능\n\n![이미지](/assets/img/2024-06-22-SiriandOpenAIIntegrationAnExperimentalFirstStep_0.png)\n\n## Siri 바로가기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요즘 채팅 흐름을 만드는 도중, Siri가 질문에 응답하고 요청을 처리하는 뿐만 아니라 사용자와 자연스러운 대화를 나눌 수 있는 것이 중요하다는 것을 알게 되었어요. 그래서 Siri 바로가기(Siri Shortcuts)를 발견하게 되었죠. Siri 바로가기는 사용자 지정 바로가기를 설정할 수 있는 멋진 도구에요. 맞아, 이걸로 Siri를 사용할 수도 있어요. 솔직히 말해서, 이 프로젝트를 시작하기 전에 Siri 바로가기를 사용해 본 적이 없었어요.\n\n도전해 보기로 결정했죠. 제 주요 목표는 Siri에게 대화 끝에 질문을 하도록 유도하여 사용자와 상호작용할 수 있게 하는 것이었어요. ChatGPT가 하는 것처럼 대화를 나눌 수 있도록 하고 싶었어요. 즉, \"안녕, 어떻게 지내?\"라고 ChatGPT에게 말하면 \"안녕하세요! 궁금한 점이나 할 일이 있으면 도와드리겠어요. 무슨 일이신가요?\"라고 돌아온다는 거죠.\n\n한 번에 대화를 진행하고 사용자 요청에 따라 응답하는 바로가기를 만드는 것뿐만 아니라, 사용자와 연속적인 대화를 나누는 것(다수 요청)이 가능한 바로가기를 만들고 싶었어요. Siri가 사용자와 계속해서 상호작용하며 문맥과 관련된 후속 질문을 하여 사용자가 도움이 더이상 필요하지 않다고 느낄 때까지 지원할 수 있도록 하는 것이 제 목표였어요. 이 아이디어를 구현하기 위해 플로 차트를 그렸어요:\n\n![플로 차트](/assets/img/2024-06-22-SiriandOpenAIIntegrationAnExperimentalFirstStep_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알고리즘은 'N' 번 반복하는 루프로 시작합니다. 이때 'N'은 질문 세션의 사전 정의된 반복 횟수입니다. 그러나, 'finish_loop' 변수를 평가함으로써 특정 조건이 충족되면 'N'에 도달하기 전에 사이클을 종료할 수 있는 전역 변수를 통해 흐름 제어 메커니즘을 구현했습니다.\n\n- 서비스 응답이 사용자가 \"안녕\" 또는 \"도움이 필요하지 않아\"와 같은 키워드를 사용하여 더 이상 도움이 필요하지 않다고 나타내면 'finish_loop' 변수가 True로 설정되어 사이클이 종료됩니다.\n- 각 반복에서 변수는 기본 값('' - 빈 필드)으로 초기화되고 사용자의 입력이 요청되며 항상 같은 초기 질문과 함께 전달됩니다.\n- 사용자가 음성을 사용하여 입력을 제공하면 시스템은 서비스를 요청하고 결과를 기다립니다. 사용자가 현재 클립보드에 있는 텍스트를 사용하려면 'clipboard'이라고 명시적으로 말해야 합니다. 이 명령을 통해 클립보드에서 값을 가져와 서비스로 전달할 수 있습니다.\n- 결과가 있으면 응답에서 필요한 값이 추출되고 변수 질문은 다음에 물어볼 질문으로 업데이트됩니다. 또한, 얻은 응답의 로직을 기반으로 대화가 계속될 수 있습니다.\n- API 오류가 발생하거나 결과가 없는 경우 'finish_loop'가 True로 설정되어 대화가 다음 사이클에서 종료됩니다.\n- 결과가 만족스러운 경우 시스템은 Siri를 통해 사용자에게 결과 메시지를 전달합니다. 결과에 클립보드가 관련된 경우 새 결과로 업데이트되어 클립보드로 반환됩니다.\n- 각 상호 작용 사이에는 자연스러운 대화를 시뮬레이션하기 위해 1초의 일시 중지가 있습니다.\n\n![이미지](/assets/img/2024-06-22-SiriandOpenAIIntegrationAnExperimentalFirstStep_2.png)\n\n안녕 Jarvis:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주요 단축키가 보조 단축키를 관리합니다. Siri를 통해 'Hey Jarvis'라고 말하여 활성화할 수 있습니다. 추가로, 원한다면 이 단축키를 좀 덜 혹한 이름으로 바꿀 수도 있어요 😅.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*lmuTcUmBR89MTml-Dg2qvQ.gif)\n\n클립보드 확인:\n\n시스템은 사용자 메시지에 'clipboard'라는 단어가 있는지 확인하기 위해 정규식을 사용합니다. 해당 단어가 있다면, 시스템은 클립보드의 값을 검색하여 해당 값을 서비스에 전달합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Siri and OpenAI Integration - An Experimental First Step](/assets/img/2024-06-22-SiriandOpenAIIntegrationAnExperimentalFirstStep_3.png)\n\nJarvis Call:\n\n![Siri and OpenAI Integration - An Experimental First Step](/assets/img/2024-06-22-SiriandOpenAIIntegrationAnExperimentalFirstStep_4.png)\n\n## OpenAI API\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 바로 개발자에요. 위의 텍스트를 친근하게 번역해 드릴게요.\n\n\"저는 바로 단축키를 사용하여 만든 시스템을 활용하여 이 어시스턴트를 개발하는 방법을 탐색 중이었어요. 처음에는 대화 응답을 생성하기 위해 OpenAI API를 통합했지만, 최근에 다중 도구를 동시에 지원하는 Assistants API (실제로는 베타)를 발견했어요. 이 API에는 코드 해석기, 검색 및 함수 호출이 포함돼 있는데, 이는 나에게 맥에서 특정 작업을 실행하는 함수를 정의하고, 모두 어시스턴트에 의해 트리거되는 기능을 아우르기 때문에 중요합니다. 또한 지속적인 쓰레드 기능이라는 중요한 기능이 있는데, 메시지 기록을 간단히 메시지를 추가하여 유지할 수 있어요. 이 능력은 Siri가 대화 종료 시 사용자에게 질문하도록 유도하여 ChatGPT와 비슷한 메모리 시스템을 제공함으로써 중요한 목표를 달성하는 데 필수적입니다. 그래서 gpt-4-turbo-preview로 테스트하려고 해요.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:920/0*jdSBXKqVP7lJoNgp.gif\" /\u003e\n\n음… 사용 중에 발견한 몇 가지 문제점이 있어요:\n\n- 스트리밍 출력을 지원하지 않아요.\n- 랜덤성을 제어하는 온도 매개변수가 없어요.\n- response_format 매개변수가 없어요. JSON 출력 형식이 필요했는데 어시스턴트가 그를 지원하지 않아요.\n- 출력이 자동으로 추가되기 때문에 출력이 잘못되거나 잘못된 정보가 포함되었다면 제어할 방법이 없어요. 해당 정보는 쓰레드 기록에 저장돼요.\n- 때때로 통신 쓰레드가 손상될 수 있어요. 유효한 JSON이 아닌 응답 형식을 받거나 지시에 따르지 않는 메시지를 받으면 해당 쓰레드는 사용할 수 없는 것으로 판단되어서 그 다음 메시지는 잘못된 답변을 받게 될 거에요. 유일한 해결책은 새 쓰레드를 만드는 것이에요.\n- 함수가 API 오류를 발생시키고 출력 함수가 run 객체에 전송되지 않았을 경우, 기능에서 응답을 기다리는 동안 새로운 메시지를 추가할 수 없으므로 다음 메시지는 추가되지 않을 거에요. 따라서 실행 프로세스를 취소하고 메시지를 다시 추가해야 할 수도 있어요.\n- 쓰레드는 모델이 지원할 수 있는 콘텍스트 길이만큼 크기가 됩니다. 메시지 수나 쓰레드가 활성화된 시간을 제어할 수 있는 시스템이 없다면 긴 쓰레드에 많은 비용을 지출할 수밖에 없을 거에요 (비용 부분에서 제 전략과 결과를 설명할게요).\"\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시스템에 대해 설명해 드릴게요. 매우 간단해요: 주요 보조 기능을 사용하여 제 맥에서 동작을 실행합니다.\n\n![image](/assets/img/2024-06-22-SiriandOpenAIIntegrationAnExperimentalFirstStep_5.png)\n\n주요 기능이 세 가지 있어요. 첫 번째 함수인 open_pycharm_projects는 매우 구체적인 이름을 가지고 있어요: 이 함수는 간단히 PyCharm 프로젝트를 엽니다. 프로젝트 이름이 정확히 일치하지 않는 경우 시스템은 상위 세 가지 가장 근접한 일치 사항을 반환하며, 보조기는 어떤 PyCharm 프로젝트를 열지 물어볼 거에요. 두 번째 함수인 search_web은 Google, YouTube 및 YouTube Music에서 검색할 수 있으며, 검색 결과가 포함된 새 창을 브라우저에서 엽니다. 게다가 여러 창을 열고 여러 개의 검색을 할 수도 있어요. 세 번째 함수는 Spotify 음악과 관련이 있어요; 특정 노래를 검색하거나 원하신다면 아티스트의 랜덤한 노래를 재생해 줘요. 그리고 사용된 다른 기능은 클립보드 출력인데요. 이를 통해 클립보드에 저장된 텍스트를 수정하여 번역하거나 향상시키거나 맞춤법을 교정하거나 코드를 생성할 수 있어요. 어떻게 작동하는지 보기 위해 프롬프트를 확인해 보세요.\n\n```js\n당신의 주요 업무: 다양한 경험을 가진 비즈니스 어시스턴트로서, 사용자와 가장 자연스럽고 인간적으로 대화를 나누어 신뢰를 유지하며 효과적으로 목표를 달성하고자 합니다. 대화를 계속 이끌기 위해 사용자에게 질문을 제시하고 아직 마무리되지 않은 경우 대화를 이어나가세요. 항상 JSON 형식으로 출력하여야 합니다.\n\n규칙:\n- 클립보드를 사용할 때는 \"search_web\"과 같은 함수를 사용하지 말고 본인의 지식으로 직접 응답하세요.\n- 필요할 때 함수를 사용하세요. 그러나 출력은 항상 JSON 형식이어야 합니다.\n- 각 사용자 메시지에 대해 한 번만 응답하세요.\n\nJSON 출력:\n출력은 다음과 같은 키를 포함해야 합니다:\n{\n\"tool\": \"대화형_어시스턴트\",\n\"message\": \"대화형 응답 메시지만 포함해 주세요. 클립보드를 사용한 경우 항상 'the [action] is in your clipboard now' 로 응답하시고, 여기에 클립보드 결과를 보여주시면 안 됩니다. 클립보드 내용이 코드거나 상세한 응답인 경우에도 여기엔 사용자에게 표시할 대화 메시지만 포함해 주세요.\",\n\"clipboard_result\": 클립보드를 사용한 경우, 결과가 여기에 나타나야 합니다. 클립보드 내용인 \"클립보드 텍스트\"를 가져와 번역하거나 수정하거나 변형하거나, 클립보드 내용을 기반으로 코드를 생성할 수 있습니다. 사용자가 코드 생성을 요청하거나 클립보드 내용을 다른 언어로 번역하길 원할 때, 해당 결과는 항상 여기에 표시됩니다.\n\"conversation_closed\": \"True\" 또는 \"False\" (문자열)입니다. 대화가 종료되는 시점을 인식하는 것이 매우 중요합니다. 예를 들어, 사용자가 \"안녕,\" \"잘가,\" \"더 이상 도움이 필요하지 않아,\" \"계속하고 싶지 않아,\" \"나가기,\" \"마치기,\" \"종료하기\"와 같은 문구를 발언하면 대화는 항상 종료되며, 더 이상 질문하거나 추가 도움이 필요한지 묻지 않아야 합니다.\n}\n\nJSON으로만 올바른 응답이 됩니다.\n\n기억하세요: 사용자가 더 이상 도움이 필요하지 않을 때까지 대화를 종료하지 마세요. 이것이 비즈니스 어시스턴트로서 올바르게 업무를 수행하는 데 매우 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 볼 수 있듯이, 'clipboard_result'는 어시스턴트가 생성한 JSON에서의 출력 매개변수입니다. 사용자가 클립보드를 사용하려 한다는 것을 어시스턴트가 감지하면 이 매개변수는 생성된 텍스트를 식별하고 클립보드로 반환하는 데 사용됩니다. 그런 다음 사용자는 단순히 결과물을 붙여넣을 수 있습니다. 여기 함수 정의가 있습니다:\n\nopen_pycharm_projects\n\n{\n  \"name\": \"open_pycharm_projects\",\n  \"description\": \"이 도구는 PyCharm 프로젝트를 열 때 유용합니다. 프로젝트를 열고자 하는 사용자는 반드시 이 함수를 사용해야 합니다.\",\n  \"parameters\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"pycharm_project\": {\n        \"type\": \"string\",\n        \"description\": \"열고자 하는 PyCharm 프로젝트의 이름.\"\n      }\n    },\n    \"required\": [\n      \"pycharm_project\"\n    ]\n  }\n}\n\nsearch_web\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n{\n  \"name\": \"search_web\",\n  \"description\": \"사용자가 필요한 내용에 따라 웹을 검색하는 기능입니다. Google, YouTube 또는 YouTube Music으로 검색할 수 있습니다.\",\n  \"parameters\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"url\": {\n        \"type\": \"string\",\n        \"enum\": [\n          \"https://www.google.com/search?q={query}\",\n          \"https://www.youtube.com/results?search_query={query}\",\n          \"https://music.youtube.com/search?q={query}\"\n        ],\n        \"description\": \"사용자가 검색하려는 URL을 올바른 순서대로 지정해야 합니다. 각 검색에 대해 어떤 URL을 사용할지 식별해야 하며 검색할 쿼리를 사용합니다.\"\n      }\n    },\n    \"required\": [\n      \"url\"\n    ]\n  }\n}\r\n\nplay_spotify_music\n\n{\n  \"name\": \"play_spotify_music\",\n  \"description\": \"이 함수는 Spotify에서 일반적으로 음악을 검색하는 데 유용합니다.\",\n  \"parameters\": {\n    \"type\": \"object\",\n    \"properties\": {\n      \"spotify_search\": {\n        \"type\": \"string\",\n        \"description\": \"다음 형식의 검색을 사용하십시오. 사용자가 노래를 검색하려면 'track: [노래 제목]'을 사용하고, 아티스트를 검색하려면 'artist: [아티스트 이름]'을 사용하며, 특정 아티스트 및 노래를 검색하려면 'artist: [아티스트 이름] track: [노래 제목]'을 사용하십시오. 항상 이 형식을 사용하고, 사용자가 원하는 내용에 가장 가까운 검색을 판단하기 위해 음악 지식을 활용하여 요구 형식을 사용합니다.\"\n      },\n      \"artist_search\": {\n        \"type\": \"string\",\n        \"description\": \"항상 아티스트나 밴드 이름 쿼리를 입력하십시오. 사용자가 아티스트나 밴드 이름을 지정하지 않으면 시스템은 검색의 기본값으로 빈 문자열('')을 사용해야 합니다.\"\n      },\n      \"song_search\": {\n        \"type\": \"string\",\n        \"description\": \"항상 노래 제목 쿼리를 입력하십시오. 사용자가 아티스트나 밴드 이름을 지정하지 않으면 시스템은 검색의 기본값으로 빈 문자열('')을 사용해야 합니다.\"\n      },\n      \"search_specific\": {\n        \"type\": \"boolean\",\n        \"description\": \"true/false (부울) 음악 지식을 사용하여 사용자가 특정 노래를 검색하려는지 판단하십시오. 예를 들어 사용자가 'Spotify에서 flashing lights 플레이'라고 요청하면 특정 노래를 원하는 것이며, 사용자가 'Spotify에서 Metallica의 무언가를 플레이해줘'라고 하면 일반적인 검색이므로 매개 변수는 False입니다.\"\n      }\n    },\n    \"required\": [\n      \"spotify_search\",\n      \"artist_search\",\n      \"song_search\",\n      \"search_specific\"\n    ]\n  }\n}\r\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 서비스\n\n이 서비스는 FastAPI를 사용하여 생성되었습니다. 스레드 ID와 Spotify 토큰을 저장하기 위해 데이터베이스를 사용합니다. 이 접근 방식은 Spotify 토큰이 일정 기간 후에 만료되기 때문에 사용자 승인 요구사항을 우회하는 데 도움이 됩니다.\n\n구현된 기능은 직관적입니다. 제가 만든 첫 번째 기능은 PyCharm 프로젝트를 열 수 있게 해줍니다. 지정된 경로 내 파일을 검색하여 가장 유사한 파일을 찾습니다. 정확한 일치 항목을 찾지 못하면 시스템이 가장 가까운 상위 3개 항목을 표시하고 사용자에게 어떤 프로젝트를 열고 싶은지 물어봅니다.\n\nasync def open_pycharm_projects(func_params: FunctionPayload, **kwargs: dict) -\u003e FunctionResult:\n    try:\n        project_paths = secrets['pycharm_directories']\n        pycharm_project = func_params.function_params.get('pycharm_project', None)\n\n        if pycharm_project is None:\n            raise Exception('프로젝트 이름을 입력해주세요')\n\n        all_folders = {}\n        for project in project_paths:\n            for name in os.listdir(project):\n                if os.path.isdir(os.path.join(project, name)) and not re.match(r'^\\..+', name):\n                    if name in all_folders:\n                        all_folders[name].append(os.path.join(project, name))\n                    else:\n                        all_folders[name] = [os.path.join(project, name)]\n\n        matches = find_top_project_matches(pycharm_project, all_folders)\n\n        if len(list(matches.keys())) == 1:\n            message = f'{list(matches.keys())[0]} 프로젝트를 성공적으로 엽니다.'\n\n            os.system(f'pycharm {list(matches.values())[0][0]}')\n\n        elif len(list(matches.keys())) \u003e 1:\n            message = f'{pycharm_project}에 대해 여러 프로젝트를 발견했습니다. 더 구체적으로 말해주세요. 아래는 가장 가까운 프로젝트 목록입니다: {list(matches.keys())}'\n        else:\n            message = f'{pycharm_project}에 대한 프로젝트를 찾을 수 없습니다.'\n\n        return FunctionResult(\n            function_id=func_params.function_id,\n            output={'message': message},\n            metadata={},\n            traceback=None\n        )\n    except Exception as e:\n        logging.error(f\"open_pycharm_projects에서 오류 발생: {e}, 함수 실행을 종료합니다\")\n        return FunctionResult(\n            function_id=func_params.function_id,\n            output={'message': 'open_pycharm_projects에서 오류 발생'},\n            metadata={},\n            traceback=str(e)\n        )\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 검색 시스템\n\ndef find_top_project_matches(input_str: str, folders_info: dict, top=3) -\u003e dict:\n    if input_str in folders_info:\n        return {input_str: folders_info[input_str]}\n\n    close_names = difflib.get_close_matches(input_str.lower(), folders_info.keys(), n=top, cutoff=0.5)\n\n    closest_matches = {}\n    for name in close_names:\n        closest_matches[name] = folders_info[name]\n\n    return closest_matches\n\n에러 발생 시 시스템에서는 예외를 트리거하지 않고, 대신 오류가 발생했음을 나타내는 알림을 GPT-4에 보냅니다. 결과적으로 사용자에게 '죄송합니다, 프로젝트를 열 수 없어요. 다른 도움이 필요하신가요?'라는 메시지를 통해 알려줍니다. 이 접근 방식은 대화가 원활하게 진행되도록합니다. 또한 언급한대로, Run Object는 어떤 이유로든 함수로부터 응답이 없는 경우 새 메시지의 추가를 방지합니다. 이 제한 사항은 Run Object가 기능 응답 객체를 필요로 하기 때문에 발생하며, 그렇지 않으면 API 요청이 실패할 것입니다. 따라서 시스템의 신뢰성을 향상하고 잠재적인 오류를 방지하려면 코드 주석 처리를 해제할 수 있습니다.\n\n'검색 웹' 기능은 간단히 GPT로부터 전달된 URL을 엽니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"https://www.google.com/search?q={query}\",\n\"https://www.youtube.com/results?search_query={query}\",\n\"https://music.youtube.com/search?q={query}\"\n\nGPT가 자동으로 귀하의 검색 요청으로 대체하는 쿼리 매개변수가 있습니다. 여러 개의 검색이 포함된 시나리오에서는 예를 들어 Google에서 한 번, YouTube에서 다른 한 번 검색하는 경우, '실행 개체'는 '웹 검색' 함수에 대해 여러 요청을 시작합니다.\n\nasync def search_web(func_params: FunctionPayload, **kwargs: dict) -\u003e FunctionResult:\n    try:\n        url = func_params.function_params.get('url', None)\n\n        webbrowser.open(url, new=1, autoraise=True)\n\n        return FunctionResult(\n            function_id=func_params.function_id,\n            output={'message': '브라우저를 성공적으로 열었습니다'},\n            metadata={},\n            traceback=None\n        )\n    except Exception as e:\n        # client.beta.threads.runs.cancel(\n        #     thread_id=func_params.thread_id,\n        #     run_id=func_params.run_id\n        # )\n        logging.error(f\"search_web에서 오류 발생: {e}, 실행 함수가 종료되었음\")\n        return FunctionResult(\n            function_id=func_params.function_id,\n            output={'message': '브라우저에서 열지 못했습니다'},\n            metadata={},\n            traceback=str(e)\n        )\n\n마지막으로, 'Spotify' 함수는 Spotify에서만 트랙을 검색합니다. 시스템은 트랙을 인기순으로 반환합니다. 'artist_search' 매개변수가 GPT에서 전달되면 'specific_search'가 활성화될 때 가장 가까운 매칭 곡을 찾는 데에도 사용됩니다. 예를 들어 \"Spotify에서 'Uprising' by Muse 열어\"라고 말하면 특정 검색이 활성화됩니다. 그러나 \"Muse의 노래 하나 틀어줘\"라고 말하면 특정 검색 시스템이 활성화되지 않으며 해당 아티스트의 무작위 노래가 재생됩니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndef spotify_search(client: spotipy.Spotify, query: str, limit: int = 10):\n    search_result = client.search(query, limit=limit, type='track')\n    return search_result\n\n\ndef search_specific_song(\n        search_result: dict,\n        song_search: str,\n        func_params: FunctionPayload,\n        artist_search: str\n) -\u003e FunctionResult | dict:\n    searched_list = []\n\n    for type in search_result.keys():\n        info_type = search_result[type]['items']\n\n        if artist_search != '':\n            filter_info = list(\n                filter(lambda x:\n                       SequenceMatcher(None, artist_search, x['album']['artists'][0]['name']).ratio() \u003e= 0.6\n                       and SequenceMatcher(None, song_search, x['name']).ratio() \u003e= 0.6,\n                       info_type\n                       )\n            )\n        else:\n            filter_info = list(\n                filter(lambda x:\n                       SequenceMatcher(None, song_search, x['name']).ratio() \u003e= 0.6,\n                       info_type\n                       )\n            )\n\n        searched_list.extend(filter_info)\n\n    if len(searched_list) == 0:\n        return FunctionResult(\n            function_id=func_params.function_id,\n            output={'message': '해당 쿼리에 대한 검색 결과가 없습니다.'},\n            metadata={},\n            traceback=None\n        )\n\n    ordered_list = sorted(searched_list, key=lambda x: x.get('popularity', 0), reverse=True)[0]\n\n    return ordered_list\n\n\nasync def play_spotify_music(func_params: FunctionPayload, **kwargs: dict) -\u003e FunctionResult:\n    try:\n        sp_client = await get_spotify_client()\n        if sp_client is None:\n            return FunctionResult(\n                function_id=func_params.function_id,\n                output={'message': '스포티파이 클라이언트를 사용할 수 없습니다. 먼저 로그인하거나 개발.yaml 파일에서 자격 증명을 구성해야 합니다.'},\n                metadata={},\n                traceback=None\n            )\n\n        sp_search = func_params.function_params.get('spotify_search', '')\n        artist_search = func_params.function_params.get('artist_search', '')\n        song_search = func_params.function_params.get('song_search', '')\n\n        search_result = spotify_search(sp_client, sp_search)\n\n        if func_params.function_params.get('search_specific') is False:\n            # could filter the search result to get the best match (?)\n            random_number = random.randint(0, len(search_result[\"tracks\"][\"items\"]) - 1)\n            web.open(search_result[\"tracks\"][\"items\"][random_number][\"uri\"])\n\n            if sp_client.current_playback() is not None:\n                if sp_client.current_playback()['is_playing']:\n                    # if you have the spotify premium you can use this\n                    # sp_client.start_playback(search_result[\"tracks\"][\"items\"][random_number][\"uri\"])\n                    sleep(1)\n                    keyboard.press_and_release(\"enter\")\n\n        else:\n\n            ordered_list = search_specific_song(\n                search_result=search_result,\n                song_search=song_search,\n                artist_search=artist_search,\n                func_params=func_params\n            )\n\n            if isinstance(ordered_list, FunctionResult):\n                return ordered_list\n\n            web.open(ordered_list[\"uri\"])\n\n            if sp_client.current_playback() is not None:\n                if sp_client.current_playback()['is_playing']:\n                    # if you have the spotify premium you can use this\n                    # sp_client.start_playback(search_result[\"tracks\"][\"items\"][random_number][\"uri\"])\n                    sleep(1)\n                    keyboard.press_and_release(\"enter\")\n\n        return FunctionResult(\n            function_id=func_params.function_id,\n            output={'message': '스포티파이가 성공적으로 열렸습니다.'},\n            metadata={},\n            traceback=None\n        )\n    except Exception as e:\n        # client.beta.threads.runs.cancel(\n        #     thread_id=func_params.thread_id,\n        #     run_id=func_params.run_id\n        # )\n        logging.error(f\"플레이음악에서 오류 발생: {e}, 실행 함수가 종료되었습니다.\")\n        return FunctionResult(\n            function_id=func_params.function_id,\n            output={'message': '스포티파이에서 열지 못했습니다.'},\n            metadata={},\n            traceback=str(e)\n        )\r\n```\r\n\r\n서비스의 예시 로그:\r\n\r\n```js\r\n{\r\n  \"name\": \"root\",\r\n  \"message\": \"\",\r\n  \"role\": \"assistant\",\r\n  \"content\": {\r\n    \"tool\": \"conversational_agent\",\r\n    \"message\": \"'저는 디지털 어시스턴트이므로 감정이 없어요, 하지만 물어봐주셔서 감사합니다!'\",\r\n    \"clipboard_result\": \"\",\r\n    \"conversation_closed\": \"False\",\r\n    \"question\": \"'오늘은 어떻게 도와드릴까요?'\"\r\n  },\r\n  \"created_at\": \"2024-03-30 19:22:07\",\r\n  \"run_id\": \"gg\",\r\n  \"thread_id\": \"gg\",\r\n  \"timestamp\": \"2024-03-30T19:22:09.450830+00:00\",\r\n  \"status\": \"INFO\"\r\n}\r\n```\r\n\r\n보시다시피 처음 응답은 '저는 디지털 어시스턴트이므로 감정이 없어요, 하지만 물어봐주셔서 감사합니다!'라는 메시지입니다. 그 후에 '오늘은 어떻게 도와드릴까요?'라는 질문이 사용자에게 계속 대화를 이어나가기 위해 제시됩니다. 또한 'clipboard_result' 매개변수를 볼 수 있는데, 이 경우에는 사용하지 않으므로 매개변수는 비어져 있는 상태입니다.\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 큰 문제\n\n서비스에서 코드를 시스템에 직접 실행하는 것을 알아채셨다면, 아마도 스스로에게 묻게 될 것입니다: 그렇다면 컨테이너에 배포하는 것은 어떻게 가능할까요? 이 설계에서 큰 문제가 발생하는데, 시스템은 시스템 작업의 실행을 외부화하지 않고 내부적으로 관리합니다. 결과적으로 직접적으로 컨테이너에 포장할 수 없습니다. 그러나 대화 및 클립보드 텍스트 변환과 관련된 기본 기능을 컨테이너화하는 것은 가능합니다. 왜냐하면 이러한 기능은 시스템 수준의 실행을 필요로하지 않기 때문입니다.\n\nDocker를 사용하여 서비스를 사용하려면 Docker 구성 파일에서 애플리케이션 설명을 주석 처리해야 합니다. 더욱 중요한 것은 구성에서 호스트 값을 'siri_assistant_database'와 같은 서비스의 구체적인 이름으로 변경해야 합니다. 이 변경은 중요한데, Docker는 docker-compose.yml 파일에서 정의된 서비스 이름을 사용하여 컨테이너 간 통신을 용이하게 합니다. 호스트로 `siri_assistant_database`를 지정함으로써, 우리의 애플리케이션이 Docker의 내부 네트워크를 사용하여 데이터베이스 컨테이너와 통신하도록 지시합니다.\n\n```js\n  database:\n    driver:\n    host: siri_assistant_database\n    port: 5432\n    database: siri_assistant\n    user: gg\n    password: 1234\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nversion: '3'\n\nservices:\n#  app:\n#    container_name: siri_assistant_app\n#    build:\n#      context: .\n#      dockerfile: Dockerfile\n#    volumes:\n#      - .:/app\n#    ports:\n#      - '8080:8080'\n#    depends_on:\n#      - siri_assistant_database\n  siri_assistant_database:\n    container_name: siri_assistant_db\n    mem_limit: 100m\n    cpuset: \"0\"\n    image: arm64v8/postgres:15\n    environment:\n      - POSTGRES_DB=siri_assistant\n      - POSTGRES_PASSWORD=1234\n      - POSTGRES_USER=gg\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - siri_assistant:/var/lib/postgresql/data\n      - ./db_init:/docker-entrypoint-initdb.d\n    restart: no\nvolumes:\n  siri_assistant:\r\n```\n\n## 비용\n\n지금까지 알아본 대로, Assistant API를 사용하여 gpt-4-turbo-preview 모델을 활용했습니다. 이 글 작성 시점에서 OpenAI는 어시스턴트, 스레드 또는 실행을 생성, 업데이트 또는 삭제할 때 요금을 부과하지 않습니다. 따라서 발생하는 요금은 모델 사용에 대한 비용뿐입니다. 긴 스레드의 경우 비용이 상당히 높아집니다. 이 비용을 줄이기 위해 10분 동안 스레드를 유지하는 시간 만료 전략을 사용했습니다. 이 기간 이후에 사용자가 서비스에 새 요청을 보내면 새 스레드가 생성됩니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-SiriandOpenAIIntegrationAnExperimentalFirstStep_6.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이번 달에는 시간 만료 시스템 없이 Assistant API를 사용하여 몇 가지 테스트를 진행하여 프로젝트를 시작했습니다. 2월 14일에 비용이 매우 빨리 증가한 것을 보면, 이는 단지 테스트였습니다. 그래서 2월 15일 이후 시간 만료 시스템을 도입하여 만료 시간을 60분으로 설정했습니다. 이로써 비용이 크게 감소되었습니다. 그러나 이번 달 마지막 날에 Siri로 많은 테스트를 실시하여 가격이 다시 새로운 최고점을 기록했습니다.\n\n이러한 패턴은 시간 만료 시스템을 통한 비용 관리가 효과적임을 시사합니다. 이 시스템을 도입한 후 비용이 일반적으로 감소하는 경향이 있습니다. 그러나 월 말에 진행된 많은 테스트 단계와 같은 집중적인 테스트는 지출의 상당한 증가로 이어질 수 있습니다.\n\n이번 달에는 시스템에 광범위하게 작업을 하지 않고 간헐적으로 개발만을 수행했습니다. 그러나 3월 14일에 시스템을 완료한 후 몇 가지 테스트를 수행했습니다. 60분의 만료 시간 설정이 너무 길다는 것을 깨달았기 때문에 이를 10분으로 줄였습니다. 다음 날 동일한 수의 테스트를 수행한 결과, 비용이 크게 감소했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 데이터는 60분에서 10분으로 시간 만료 설정을 조정한 결과가 비용 효율성에 긍정적인 영향을 미쳤음을 나타냅니다.\n전략의 일환으로 메시지 수를 제한하는 것이 추가 개선을 이끌어낼 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-SiriandOpenAIIntegrationAnExperimentalFirstStep_8.png)\n\n## 개선 및 결론\n\n- 대화 당 메시지 수 한도와 시간 초과 전략을 결합하여 비용 제어 시스템을 구현하는 것이 효과적일 수 있으며, gpt-3.5-turbo와 같은 경제적인 OpenAI 모델을 탐색함으로써 효율성이 더 증가될 수 있다는 가능성을 제시합니다.\n- 어시스턴트와 Siri 간 지연 시간을 줄이는 것은 사용자 경험을 향상시키기 위한 중요한 과제로 남아 있습니다. 빠른 OpenAI 모델을 실험하거나 심지어 LLM-Studio를 통해 로컬에서 모델을 구현하는 것은 이 문제를 해결하기 위한 유망한 방향입니다. 그러나 Siri에서 바로 시간 초과를 조정할 수 없어 더 복잡한 상호작용을 만드는 능력에 제약이 있습니다.\n- 시스템을 도커화하는 가능성은 아키텍처와 워크플로우를 최적화하는 새로운 기회를 제공합니다. 하나의 타당한 전략은 OpenAI에 응답을 동일한 요청에 반환할 필요 없이 사용자에게 어떤 도구를 사용해야 하는지 알려줌으로써 함수의 사용을 최소화하고, Siri Shortcuts가 해당 흐름을 인식하고 실행할 수 있도록 하는 것입니다. 이는 응답 시간을 줄일뿐만 아니라 Shortcuts와의 더 큰 유연성을 제공할 수 있습니다. 커뮤니티에서 개발된 Shortcuts를 사용할 수도 있습니다. 이 모듈식이자 분산된 접근법은 현재 버전 대비 상당한 개선을 이끌어낼 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-22-SiriandOpenAIIntegrationAnExperimentalFirstStep_0.png"},"coverImage":"/assets/img/2024-06-22-SiriandOpenAIIntegrationAnExperimentalFirstStep_0.png","tag":["Tech"],"readingTime":22},{"title":"OpenAI의 Rockset 인수, AI 기업들에게 어떤 의미가 있을까","description":"","date":"2024-06-22 20:21","slug":"2024-06-22-WhatDoesOpenAIsAcquisitionofRocksetMeanforAICompanies","content":"\n\n![image source](/assets/img/2024-06-22-WhatDoesOpenAIsAcquisitionofRocksetMeanforAICompanies_0.png)\n\n2020년 3월, 세상이 문을 닫고 빛나는 디바이스 화면을 바라보며 모여있을 때, 궁금한 작은 기술 기업이 나타났습니다. 그 이름은 Clubhouse였습니다. 가상의 방에서 모여 실시간으로 스피커를 듣고 세션이 끝나면 콘텐츠가 디지털 공간으로 사라지는 라이브 오디오 플랫폼을 상상해보세요. 이는 그 전에 있었던 덜 알려진 혁신적인 기술인 라디오와 놀랍게도 매우 유사하죠!\n\n단 몇 달 만에 Clubhouse는 매주 약 1000만 명의 활발한 사용자를 자랑하는 누구나가 놀고 싶어하는 새로운 장난감이 되었습니다.\n\n그런 다음 1년 뒤, 방송 후 사라진 콘텐츠와 비슷하게, Clubhouse 자체가 사라져 버렸습니다. 사람들의 지나치게 과부하된 영구적이고 항상 소멸성 있는 관심에서 영원히 사라지다니요.\n\n이것은 우리가 이런 영화를 본 것이 처음은 아니었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n“에버노트”의 경우, 여러 년 전에도 비슷한 일화가 벌어졌는데, 현재도 지속되고 있거나 당시 제 개인적인 즐겨찾기 서비스인 \"델.이슈스(del.icio.us)\"와 함께했습니다. 이 창의적으로 제작된 도구와 더불어 창의적인 도메인 URL(https://del.icio.us)을 가진 이 서비스는 2000년대 초기 인터넷 애호가들 사이에서 특별한 자리를 차지했었죠. 저도 포함하여 말이죠.\n\n그렇다면, 이 회사들과 한때 소중했던 반짝거리는 테크 제품들은 어떤 일로 사라졌을까요? 왜 그렇게 높은 인기를 얻은 뒤 사라져 버렸을까요?\n\n저는 이를 회사들의 '마이크로소프트화'라 칭합니다.\n\n본질적으로, 이들은 진정한 제품이 아니었고, 제품으로 위장한 기능들이었습니다. 이 기능들이 독립적으로 존재하려 하자, 산업의 지배군인 거대한 거인 기업들이 들이닥치며 이들 기능들을 이미 방대한 청중들과 더욱 방대한 유통 채널을 보유하고 있는 자신들의 거대한 생태계로 흡수했습니다. Pinterest는 델.이슈스의 본질을 흡수했고, 트위터와 디스코드는 음성 전용 채널을 추가했으며, 구글, 마이크로소프트, 애플은 모두 자사의 에코 시스템에서 노트 테이킹에 대한 고유한 방법을 가지고 있습니다.\n\n그렇다면, 지금 이야기를 꺼내는 이유는 무엇일까요?\n\n그 이유는, 최근 OpenAI가 비교적 잘 알려지지 않은 \"록셋(Rockset)\"을 인수한다고 발표했기 때문입니다.\n\n저에게 이것은 두 가지를 외치는 것 같아요:\n- AI는 이제 제품이 아니라 기능이 되었다는 점입니다.\n- 이에 상응하여 벡터 전용 데이터베이스도 제품이 아니라 기능입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함께 이를 풀어보면 좋겠어요.\n\n하지만, 특히 현재 Rockset을 사용하는 기업에게 이것이 무엇을 의미하는지 알아보기 전에 이것에 대해 생각해봅시다: Pinecone, Milvus, Weaviate와 같은 벡터 전용 데이터베이스가 최근에 핫한 트렌드였죠 (Pinecone이 1억 달러를 모금했을 때 7억 5천만 달러로 평가되었던 걸 아시나요?)\n\n그렇다면, 왜 OpenAI가 Rockset을 인수하기로 선택했는데, 이 트렌디한 벡터 전용 빛나는 옵션 중 하나를 선택하지 않았을까요?\n\n이 질문에 대한 답변을 하기 전에, 데이터베이스 관점에서 Rockset이 정확히 무엇이며 어떤 점에서 알려져 있는지 살펴봐야 합니다.\n\n옛날로 돌아가서 한 번 생각해봅시다. 몇 년 전에 Google이 LevelDB라는 키-값 인메모리 저장 라이브러리를 출시했습니다. 실시간 분석을 수행하려면 훌륭했지만, 기계의 메모리보다 데이터셋이 더 클 경우 성능이 저하되는 문제가 발생했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 라이브러리와 함께 작업하던 일부 페이스북 엔지니어들이 이를 기반으로 내장형 데이터베이스를 개발하고 오픈 소스로 공개했고 RocksDB라고 이름 붙였습니다. 이 오픈 소스 DB는 이제 메모리에 추가로 플래시 기반 스토리지에서 매우 빠른 인메모리 처리를 실행할 수 있는 기능이 추가되었습니다.\n\n몇 년 뒤에 같은 일부 페이스북 엔지니어들이 RocksDB를 기반으로 한 데이터베이스 회사를 시작했고 그 회사의 이름은 바로 Rockset입니다.\n\nRockset은 LevelDB와 RocksDB를 보다 나은 커넥터와 실시간 분석 지원으로 진화시켰으며 인메모리부터 로컬 디스크, 객체 스토리지까지 세 가지 스토리지 계층을 추가했습니다. 놀랍게도, 이 세 가지 스토리지 아키텍처는 SingleStore와 동일합니다.\n\n전체적으로 말씀드리면, 저는 SingleStore에서 일하고 있는데, 이 블로그는 SingleStore가 무엇을 하는지에 관한 것은 아닙니다. 하지만 제안으로는 꼭 자세한 설명서를 확인해 보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 Rockset와 SingleStore 사이의 유사성은 여기서 끝나는데, Rockset은 반구조화된 데이터(기본 데이터 유형은 문서(Document)입니다)에서 작동하며 실시간 분석을 수행합니다. 다시 말해, JSON 문서를 가져와서 테이블로 평탄화한 뒤 데이터에 대해 SQL 쿼리, 특히 분석 기반 쿼리를 실행할 수 있습니다. 그에 비해 SingleStore는 RDF(그래프)를 제외한 모든 데이터 유형을 지원하며 수조 행의 데이터에 대해 서브초 시간 지연 내에 지원하는데, 그렇게 깊이 들어가지는 않겠습니다.\n\n그래서 OpenAI가 Rockset을 인수한 이유는 무엇일까요.\n\n그것은 바로 구조화된 및 반구조화된 데이터 때문이죠. OpenAI는 AI 기업인만큼 벡터 전용 데이터베이스가 아닌 Rockset을 인수한 이유입니다.\n\n두 단어 — 구조화된 및 반구조화된 데이터입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알겠어요, 좀 더 말수는 많지만, 요점은 이해했죠.\n\n작년 OpenAI가 Assistants라는 기능(우리는 모두 Agents라 부릅니다!)을 출시했을 때, 이를 위한 'Retrieval tool'이라는 기능이 추가되었습니다. 이에 대해 깊게 다뤄본 내용은 여기에 있어요. 궁금하시다면 더 자세히 읽어보세요.\n\n![이미지](/assets/img/2024-06-22-WhatDoesOpenAIsAcquisitionofRocksetMeanforAICompanies_1.png)\n\n'Retrieval tool'은 노코드 및 API 버전으로 사용할 수 있었고, 사용자들이 문서를 업로드하여 ChatGPT의 문맥으로 사용할 수 있었습니다. 즉, 이는 벡터 검색 또는 의미론적 특징을 사용하여 보이지 않게 'Retrieval Augmented Generation (RAG)'을 수행했던 것이죠! 이제 제가 이 제품 대 기능에 관한 얘기를 하고 있다는 맥락을 이해하시겠죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n몇 주 전에 오픈AI가 새로운 기능 몇 가지를 추가했어요 — ChatGPT를 통해 Google 시트를 읽고 데이터 분석 및 차트 작성을 위한 네이티브 테이블을 생성할 수 있는 기능입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*LuTKTHUEixnuGyclfYrkvA.gif)\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*EcgEBtqEFLEt2eYgA80eBg.gif)\n\n그럼, 모든 이것에서 빠진 것은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**실시간 분석**.\n\n그리고, 우리가 다 아는 대로, 실시간 분석은 일반적으로 PDF 문서가 아니라 구조화된 및 반구조화된 데이터로 수행됩니다.\n\n내 예상은 OpenAI가 이제 검색 도구를 보다 구조화된 데이터 소스 — MySQL, SingleStore (MySQL 와이어 프로토콜 호환), Postgres, Kafka 및 기타와 연결할 수 있는 기능으로 확장할 것이라고 합니다. 이는 사용자들이 이제 OpenAI 생태계로 구조화 및 반구조화된 데이터를 모두 가져올 수 있음을 의미합니다.\n\n그런데, 제품 대 기능에 대한 모든 이야기는 무엇일까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 가지 중요한 사항이 있습니다:\n\n- AI는 LLM으로 구동되는 기능입니다.\n- 벡터는 기능 중 하나입니다. (Rockset 및 다른 모든 데이터베이스가 벡터를 이미 기능으로 사용하고 있습니다).\n- 데이터가 진짜 제품입니다.\n\n아마도 최초의 LLM을 개발한 회사는 이제 LLM뿐만 아니라 데이터를 진정한 차별화 요소로 만들고 있습니다.\n\nRockset 고객이시라면 안타깝지만 쿼리 언어가 SQL이므로 앱 코드 전체를 다시 작성해야 하는 것만큼 나쁘지 않은 전망이라고 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n데이터 자체에 대해서는 제어권을 즉시 가져가는 것을 고려해보세요 (안타깝게도 Rockset의 스냅샷 및 복원 프로세스는 아직 프라이빗 미리보기 중 🫣). 저는 당신을 위해 단계별 안내서를 제공할 수도 있지만, 그것들이 제가 사랑하고 일하는 제품을 향하여 편향될 것입니다.\n\n그러나, AI 차별화된 기업으로 자신을 생각한다면, 특히 AI 기능을 위해 여러분의 데이터를 실시간으로 정리하는 것에 대해 깊이 고민해보시기를 권해드립니다.\n\n✌️","ogImage":{"url":"/assets/img/2024-06-22-WhatDoesOpenAIsAcquisitionofRocksetMeanforAICompanies_0.png"},"coverImage":"/assets/img/2024-06-22-WhatDoesOpenAIsAcquisitionofRocksetMeanforAICompanies_0.png","tag":["Tech"],"readingTime":5},{"title":"혼돈 시스템을 모델링하는 동적 시스템 딥러닝 활용 방법","description":"","date":"2024-06-22 20:20","slug":"2024-06-22-Howtousedynamicalsystemdeeplearningtomodelchaoticsystems","content":"\n\n## 매우 중요한 기법 요약\n\n혼돈 시스템은 모델링하기 매우 어렵습니다. 최상의 결과를 얻기 위해서는 딥 러닝과 강력한 규칙 기반 분석을 결합하는 것이 좋습니다.\n\n잘 수행된 예시로는 타임 시리즈 데이터를 사용하여 시스템의 attractor 즉, 시스템이 추구하는 상태의 집합을 재구성하는 Dynamical System Deep Learning (DSDL)가 있습니다. DSDL은 시스템의 동역학을 포착하기 위해 단변량(시간) 및 다변량(공간) 재구성을 결합합니다.\n\n여기 해당 기법의 스파크노트 요약입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDSDL는 시계열 데이터를 활용하여 얼마든지 다양한 초기 조건 하에서 시스템이 수렴할 상태의 집합인 끌근을 재구성합니다.\n\nDSDL는 원래 끌근(A)을 재구성하기 위해 두 가지 기둥을 결합합니다: 단변량과 다변량 재구성. 각 재구성 방법에는 고유한 이점이 있습니다. 단변량 방법은 대상 변수의 시간 정보를 캡처합니다. 한편 다변량 방법은 시스템 변수 간의 공간 정보를 캡처합니다. 함께 알아보겠습니다.\n\n단변량 재구성(D)은 단일 변수의 시간 지연 샘플을 사용하여 과거의 행동을 캡처하고 미래 트렌드를 예측합니다. 이는 미래의 변동을 예측하기 위해 과거 온도 데이터를 활용하는 것과 유사하며, 혼돈된 시스템 내에서의 단일 변수의 기본 동역학에 대한 통찰력을 제공합니다.\n\n다변량 재구성(N)은 보다 종합적인 방식으로 다루며, 온도, 압력, 습도와 같은 다양한 변수를 포함하여 복잡한 관계를 캡처하고 시스템의 전체적인 동역학을 이해합니다. 이 방법은 이러한 변수들이 서로 연결되어 있고 서로 영향을 주며 혼돈된 시스템 내에서 서로 영향을 미친다는 것을 인식합니다. DSDL은 이러한 복잡하고 종종 예측할 수 없는 상호작용을 모델링하기 위해 비선형 신경망을 사용하여 정확한 예측과 시스템의 동작에 대한 심층적인 이해를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 접근 방식은 데이터 내의 숨겨진 패턴과 관계를 식별하여 혼돈된 시스템에 대한 더 효과적인 제어 전략과 더 많은 정보 기반의 의사 결정을 이끌어냅니다.\n\n\n![image](/assets/img/2024-06-22-Howtousedynamicalsystemdeeplearningtomodelchaoticsystems_0.png)\n\n\n마지막으로, diffeomorphism 맵을 사용하여 재구성된 어트랙터를 원래 어트랙터와 관련시킵니다. 내가 이해한 바에 따르면, diffeomorphism은 매니폴드 간의 함수입니다(매니폴드는 곡선과 표면을 고차원으로 일반화한 것입니다) 그리고 양쪽 방향 모두에서 연속적으로 미분 가능합니다. 간단히 말해, 두 공간 간의 매끈하고 역함수 가능한 맵입니다. 이렇게 함으로써 우리는 공간의 위상을 보존할 수 있습니다. N과 D가 모두 동등하므로 ('논문에서 위상 동형'임), 그들을 연결할 수 있는 맵이 있다는 것을 알 수 있습니다.\n\n이를 통해 DSDL은 시스템의 미래 상태에 대한 예측을 수행할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 간단한 시각화입니다. 구성 요소들이 어떻게 연결되는지 확인해보세요.\n\n![Visualization](/assets/img/2024-06-22-Howtousedynamicalsystemdeeplearningtomodelchaoticsystems_1.png)\n\n혼돈 시스템을 모델링하는 데 사용된 더 많은 기술을 확인하려면 저희 논의 \"AI가 혼돈 시스템을 예측하는 데 사용될 수 있을까요?\"를 참조해보세요.\n\n이 기사가 마음에 들었다면 공유하고 싶다면 아래 가이드라인을 참조해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그게 이번 내용이에요. 시간 내어 주셔서 감사해요. 언제나 제 작업에 관심이 있거나 다른 작품을 확인하고 싶다면, 제 링크가 메일/게시물 끝에 나올 거예요. 이 글에서 가치를 찾았다면, 더 많은 사람들과 공유해 주시면 감사하겠어요. 여러분과 같은 입소문 추천이 저를 성장시키죠.\n\n![이미지](/assets/img/2024-06-22-Howtousedynamicalsystemdeeplearningtomodelchaoticsystems_2.png)\n\n정보가 풍부하고 유용하며 영향을 받지 않는 작업을 만들기 위해 많은 노력을 기울였어요. 제 글을 지원하고 싶다면, 인기있는 이 뉴스레터의 유료 구독자가 되어주시기를 고려해 주세요. 그렇게 하면 글쓰기/연구에 더 많은 노력을 기울일 뿐 아니라 더 많은 사람들에게 도달하고, 제 초콜릿 우유 중독을 지원해 주는 데 도움이 돼요. 매주 10만 명 이상의 독자에게 인공지능(AI) 연구 및 엔지니어링의 중요한 아이디어를 민주화하도록 도와주세요.\n\n제게 초콜릿 우유를 사줘요~\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPS- 저희는 \"원하는 대로 지불\" 모델을 따르고 있어요. 이는 여러분의 가능한 한 방법으로 지원할 수 있게 해줍니다. 자세한 내용을 확인하고 여러분에게 적합한 요금제를 찾아보세요.\n\n저는 X(https://twitter.com/Machine01776819), Threads(https://www.threads.net/@iseethings404), TikTok(https://www.tiktok.com/@devansh_ai_made_simple)에서 읽은 내용에 대한 미니 업데이트를 정기적으로 공유하고 있습니다. 제 학습 내용을 계속 따라가고 싶다면 거기서 저를 팔로우해주세요.\n\n# 저에게 연락해주세요\n\n아래의 링크를 사용하여 제 다른 콘텐츠를 확인하거나 과외에 대해 자세히 알아보거나 프로젝트에 대해 저에게 연락하거나 그냥 인사를 전해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서는 기술, AI 및 기계 학습에 관한 작은 단편들이 있어요\n\nAI 뉴스레터- https://artificialintelligencemadesimple.substack.com/\n\n내 할머니가 좋아하는 기술 뉴스레터- https://codinginterviewsmadesimple.substack.com/\n\n다른 기사들은 저의 Medium에서 확인하세요. : https://rb.gy/zn1aiu\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 YouTube: https://rb.gy/88iwdd\n\nLinkedIn에서 나에게 연락하세요. 함께 연결합시다: https://rb.gy/m5ok2y\n\n내 Instagram: https://rb.gy/gmvuy9\n\n내 Twitter: https://twitter.com/Machine01776819","ogImage":{"url":"/assets/img/2024-06-22-Howtousedynamicalsystemdeeplearningtomodelchaoticsystems_0.png"},"coverImage":"/assets/img/2024-06-22-Howtousedynamicalsystemdeeplearningtomodelchaoticsystems_0.png","tag":["Tech"],"readingTime":4},{"title":"시계열 예측에 딥러닝이 필요 없는 이유 현재 기준","description":"","date":"2024-06-22 20:17","slug":"2024-06-22-WhyYouCurrentlyDoNotNeedDeepLearningforTimeSeriesForecasting","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-WhyYouCurrentlyDoNotNeedDeepLearningforTimeSeriesForecasting_0.png\" /\u003e\n\n시계열 예측을 위한 딥러닝이 많은 관심을 받고 있습니다. 많은 문서와 과학 논문들이 최신 딥러닝 모델에 대해 언급하며 이 모델이 모든 기계 학습 또는 통계 모델보다 훨씬 우수하다고 언급합니다. 이는 딥러닝이 시계열 예측을 위한 모든 문제를 해결해 줄 것이라는 인상을 줍니다. 특히 이 분야의 새로운 사람들에게 말이죠.\n\n그러나 제 경험상 딥러닝은 필수적인 것이 아닙니다. 다른 것들이 더 중요하며 시계열 예측에 더 잘 작동합니다.\n\n그래서 이 기사에서는 여러분에게 어떤 것이 작동하는지 보여드리고 싶습니다. 여러 가지 방법을 소개해 드릴 것이며 이들은 다양한 방법으로 검증되었습니다. Makridakis M5 대회 및 Kaggle AI 보고서 2023의 연구 결과를 활용해 제 경험과 비교해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마크리다키스 대회는 실제 데이터 세트에서 예측 방법을 비교합니다. 실제로 어떤 것이 효과적인지를 보여줍니다. 거의 40년 전에 시작된 이 대회의 연구 결과는 변화했습니다. 처음 세 개의 대회(M1 ~ M3)에서는 통계 모델이 우세했습니다. M4 대회에서는 기계 학습 모델이 혼합 접근법의 형태로 잠재력을 드러냈는데, 해당 방법은 기계 학습 모델과 통계적 방법을 결합한 것입니다.\n\nM5 대회에서는 참가자들이 월마트의 계층적 판매량을 예측해야 했습니다. 대회는 정확도 대회와 불확실성 대회로 분할되었습니다. 정확도 대회의 목표는 각 시계열에 대한 최상의 점 예측을 찾는 것이었습니다. 불확실성 대회는 확률적 예측에 초점을 맞췄습니다. 이를 위해 참가자들은 미래 판매의 전체 분포를 설명하는 아홉 가지 다른 분위수를 예측해야 했습니다.\n\n한편, 캐글 AI 보고서는 캐글 대회의 일환으로 캐글 커뮤니티가 작성한 에세이 모음입니다. 일반적으로 최근 고성능 솔루션에서 주요 배움과 추세를 정리합니다.\n\n추신으로, 캐글이 M5 대회를 주최했습니다. 따라서 이 대회는 다른 캐글 대회에 참가한 많은 사람들의 관심을 끌었습니다. 결과적으로 캐글 AI 보고서와 M5 대회의 결과가 매우 유사한 이유가 될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 결과를 한 번 살펴볼까요?\n\n# 머신 러닝 모델이 우수한 성능을 보여줍니다\n\n지난 몇 년 동안 머신 러닝 접근 방식은 시계열 예측 분야를 선점해 왔습니다. 2020년 M4 대회에서는 하이브리드 방식의 일부로 중요해지기 시작했고, 그러나 2년 후인 M5 대회에서는 머신 러닝이 대회를 지배했습니다. 모든 성능이 좋은 솔루션은 순수한 머신 러닝 방식으로, 모든 통계 기준을 능가했습니다.\n\n특히 Gradient Boosting Machines (GBMs)는 M5와 캐글 대회에서 모두 우세합니다. 가장 성공적인 것들은 LightGBM, XGBoost 및 CatBoost입니다. 많은 피쳐의 효과적인 처리, 거의 또는 전혀 데이터 전처리와 변환이 필요하지 않은 점, 빠른 학습 속도 및 피쳐 중요성을 정량화하는 능력 등은 최근 몇 년간 최고의 공급 모델 중 하나로 만들어줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실험하기에 매우 편리하며 빠른 반복이 가능하여 최적의 특징을 식별하는 데 중요합니다. 또한 몇 가지 하이퍼파라미터만 최적화하면 됩니다. 종종 기본 설정만으로도 좋은 성능을 얻을 수 있습니다. 따라서 많은 시계열 문제에서 주로 사용되는 알고리즘이 되어갔습니다.\n\n또한 이러한 방식은 성능과 학습 시간에서 딥러닝 모델을 이긴다. 그래서 딥러닝 모델은 인기가 떨어졌습니다.\n\n나의 첫 번째 선택 역시 위에서 언급한 장점들 때문에 GBM입니다. 시간이 흐름에 따라 XGBoost에서 CatBoost로, 그리고 또 LightGBM로 옮겼습니다. 많은 문제에서 LightGBM이 더 나은 성능과 짧은 학습 시간을 보였습니다. 또 LightGBM은 작은 데이터 세트에 더 능숙했습니다. 예를 들어 한 문제에서 동일한 특징과 손실 함수를 사용하여 CatBoost 모델과 LightGBM 모델을 학습했습니다. CatBoost는 학습하는 데 대략 50% 더 많은 시간이 소요되었으며 LightGBM에서 얻은 MAE보다 2% 더 많았습니다.\n\n# 통계적 방법은 여전히 가치가 있습니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nML 방법은 종종 통계 모델보다 우수한 성능을 보이지만, 우리는 통계 모델을 잊어서는 안 됩니다. M5 정확도 대회에서 팀 중 92.5%가 기존의 예측 방법인 간단한 기준선 방법을 이기지 못했습니다. ML 모델을 사용한다고 해서 최상의 성능이 보장되는 것은 아닙니다. 더구나, 이러한 모델을 개발하는 데 더 많은 시간이 걸립니다.\n\n그러므로, 어떤 ML 모델을 시작하기 전에 항상 간단한 모델부터 시작해야 합니다. 이러한 모델을 기준선 모델로 활용해 의사 결정을 지원할 수 있습니다. 예를 들어, ML 모델이 복잡성을 상쇄할만큼 충분한 가치를 추가하는지 확인할 수 있습니다.\n\n기준선 모델에 대해 자세히 알아보고, 왜 그것으로 시작해야 하는지 궁금하시다면 제 논문을 확인해보세요.\n\n저는 보통 기준선으로 가장 간단한 모델부터 시작합니다. 제 경험 상, 간단한 통계 기준선 모델은 종종 이길 수 없는 경우가 많습니다. 게다가, ML 모델을 개발하는 데 필요한 시간 대비 매우 짧은 시간이 걸립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 앙상블은 성능을 향상시킵니다\n\nM5와 카글 대회에서 다양한 모델을 결합하면 종종 더 나은 예측 정확도를 얻을 수 있음을 보여줍니다. 앙상블은 개별 모델이 상관 관계가 없는 오류를 만들 때 특히 성공적입니다. 예를 들어, M5 대회의 일부 팀들은 훈련 데이터의 하위 집합 및 다른 손실 함수로 훈련된 모델을 결합했습니다.\n\n우리는 간단한 평균화(블렌딩), 복잡한 블렌딩 또는 스택 방식을 통해 앙상블을 구축할 수 있습니다. 그러나 종종 동일한 가중치를 부여하는 것이 충분합니다.\n\n앙상블은 모델 성능을 향상시키지만 실제 응용 프로그램에서는 단점이 있습니다. 복잡성이 늘어나면 설명 가능성이 감소하고 프로덕션 환경에서 유지하기가 더 어려워집니다. 그러므로 매우 복잡한 앙상블은 종종 사용되지 않습니다. 일반적으로 더 간단한 대안은 충분히 좋은 결과를 제공하면서 유지보수하기가 더 쉽습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제 응용 프로그램에서 앙상블 사용의 이점을 보았어요. 저에게는 보통 두 가지 접근 방식이 가장 잘 작동했어요. 하나는 LightGBM과 같은 동일 유형의 모델을 결합하는 접근 방식이에요. 이 모델들은 서로 다른 손실 함수로 훈련되죠. 다른 하나는 서로 다른 특성으로 훈련된 모델을 사용하는 접근 방식이에요. 이 두 가지 접근 방식을 선호하는데, 구현하기 쉽고 빠르게 테스트할 수 있기 때문이죠. 손실 함수를 바꾸거나 모델 입력을 변경할 뿐 나머지 파이프라인은 동일한 채로 유지할 수 있어요.\n\n또한, 복잡성을 최소화하기 위해 보통 간단한 앙상블에 집중해요. 보통 간단한 평균화를 사용해요. 그러나 앙상블의 이점은 충분히 커야만 실제 제품으로 이어갈 수 있어야 해요. 보통 앙상블이 성능을 충분히 향상시키지 못해요.\n\n# 과학 문헌이 적용된 시계열 예측에 미치는 영향은 작았어요\n\n과학 문헌과 적용된 기계 학습 시계열 예측 간에 간극이 보여요. 과학 문헌은 주로 딥러닝 모델에 초점을 맞추지만, 실무에서는 잘 사용되지 않아요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 왜 그런 큰 격차가 있는 걸까요? 논문들은 그들의 모델이 기계 학습 및 통계 모델들을 이기는 것을 보여줍니다. 그럼에도 불구하고 왜 아무도 그것들을 사용하지 않을까요? 왜냐하면 딥 러닝 접근법은 종종 현실 세계 응용에서 성공적이지 않을 수도 있기 때문입니다. 게다가, 그들을 훈련하는 데 매우 비용이 많이 들 수도 있습니다.\n\n그러나 왜 과학 문헌이 딥 러닝에 그토록 집중되어 있는 걸까요, 실용적이지 않다면?\n\n음, 제 추측만 할 수 있지만, 딥 러닝은 다른 기계 학습 모델들보다 더 많은 관심을 끕니다. N-BEATS 및 N-HiTS에 대한 두 기사에서 이를 본 적이 있습니다. 모두가 NLP를 위한 LLM의 큰 성공 이후에 딥 러닝에 일하고 싶어합니다.\n\nTransformer와 같은 딥 러닝 접근법은 NLP에 대해 잘 작동하지만 시계열에 대해서는 그렇지 않습니다. 두 작업 모두 값들의 순서로 보이기는 하지만, 실제로는 그렇지 않습니다. NLP에서는 맥락이 중요하지만, 시계열에서는 순서가 중요합니다. 이것은 잘 작동하는 접근법에 큰 영향을 미치는 작은 차이입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러므로 깊은 학습 모델을 훈련시키는 것이 가치가 있는지, 아마도 기계 학습 모델보다 더 낮은 성능을 낼 것이라는 생각을 할 수 있습니다. N-BEATS 및 N-HiTS와 같은 접근 방식을 시도해 보았지만, 이러한 모델들은 항상 성능이 떨어지고 ML 모델보다 훈련하는 데 훨씬 더 오랜 시간이 걸렸습니다. 그래서, 저는 이러한 모델들을 실제 예측 작업에 성공적으로 적용해 본 적이 없습니다.\n\n이제 어떤 모델이 작동하고 어느 것이 그렇지 않은지에 대해 많이 얘기했습니다. 하지만 모델에만 집중하는 것으로는 충분하지 않습니다. 올바른 모델을 선택하는 것보다 더 중요한 것들이 있습니다. Kaggle AI 보고서 및 M5 대회는 좋은 피처 엔지니어링이 모델보다 더 중요하다고 결론 내렸습니다. 새로운 모델을 개발할 때 아마도 가장 중요한 측면일 것입니다.\n\n# 피처 엔지니어링이 모델보다 더 중요합니다.\n\n실제 세계 데이터는 지저분하고 유용하게 사용하려면 많은 정리가 필요합니다. 그러므로, 좋은 피처를 찾기 위해 데이터를 정리하고 이해하는 데 많은 시간이 필요합니다. 이것이 저가 모델을 개발할 때 대부분의 시간을 보내는 곳입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKaggle 대회에서는 특성 공학이 중요하다는 것이 반복적으로 증명되었습니다. 종종 특성의 품질이 해결 방법을 결정하는 중요한 요소가 됩니다. 데이터에서 가장 많은 정보를 추출하고 특성 간에 더 큰 차이를 만들어내는 팀들이 더 좋은 성능의 모델을 갖게 됩니다. 그러므로 특성을 만들고 선택하며 변형하는 데 시간을 소비하는 것은 중요합니다.\n\n하지만 특성 공학에 좋은 접근법은 무엇일까요?\n\n제 경험 상, 단일 최상의 접근법은 없습니다. 오히려 다양한 특성과 특성 조합을 시도하는 시행착오 접근법입니다. 좋은 특징을 찾는 데 도움이 된 것은 창의적이고 융통성 있게 고려하며 데이터 기반의 교차 검증 전략을 사용하는 것입니다.\n\n때로는 다양한 특성을 생성하는 넓은 접근법이 도움이 될 수 있습니다. 예를 들어, 많은 외생 변수와 외부 데이터 소스가 제공되는 경우, 보통 변환 없이 그대로 사용하여 시작합니다. 여기서 변수 선택은 설명적 데이터 분석 결과와 그 안에서 찾은 내용에 따라 결정됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가끔 하나의 기능에 집중하고 여러 방법으로 확장하는 것이 더 나을 수 있어요. 예를 들어, 한정된 양의 데이터를 가지고 있다면요. 어떻게 하나의 기능을 확장할지는 해결하고자 하는 문제에 따라 다를 거에요. 평균, 표준편차, 최소값 및 최대값과 같은 창 기능을 사용하면 성능이 향상될 수 있어요. 때로는 다른 시차 기능만을 사용하는 것도 충분할 수 있어요.\n\nM5 및 Kaggle 대회를 통해 도메인 지식이 좋은 기능을 찾는 데 필요하지 않다는 것을 알 수 있어요. 그러나 도메인 지식은 종종 데이터를 더 빨리 이해하고 더 나은 기능을 도출하는 데 도움이 되었어요.\n\n# 외생/설명 변수로 성능 향상\n\n외부 데이터 사용은 예측 성능을 향상시키는 데 중요해요. 이들은 모델의 성능을 크게 향상시킬 수 있어요. M5 대회에서 외부 데이터를 사용한 모델이 오직 과거 데이터에만 의존한 모델보다 더 나은 성과를 거뒀어요. 이에 따라 이러한 설명 변수를 찾는 것이 현실 세계 응용 프로그램에서 중요해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가능한 한 많은 외부 요인을 식별하려고 노력합니다. 그런 다음 이러한 요인을 특성 엔지니어링 과정 중에 테스트합니다. 이는 공휴일과 같은 간단한 날짜 및 시간 관련 특성이나 다른 소스에서 가져온 데이터와 같이 될 수 있습니다. 제 선택은 추론 중에 데이터의 이용 가능성과 접근성에 따라 다릅니다.\n\n실제로, 성능이 크게 향상된 것을 확인했을 때는 외부 변수를 추가했을 때였습니다. 대부분의 실제 응용 프로그램에서 예측하려는 시계열의 행동은 외부 요소에 따라 달라집니다. 예를 들어 전력 가격을 예측하려면 전력 소비 및 생산을 특성으로 사용하면 성능이 크게 향상됩니다. 왜냐하면 전력 소비가 증가하거나 전력 생산이 감소할 때 전력 가격이 보통 상승하기 때문입니다.\n\n# 가능한 빨리 반복하기\n\n일반적으로 우리는 모델 개발 과정에서 많은 특성을 시도하므로 가능한 빨리 진행해야 합니다. 새로운 특성을 추가하는 것이 도움이 되는지 확인하기 위해 오래 기다리고 싶지 않습니다. 예를 들어, M5 정확도 대회에서 우승한 솔루션은 220개의 모델을 테스트했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n따라서, Kagglers는 모델 학습이 매우 빠르기 때문에 LightGBM을 주로 사용합니다. 따라서, 그들은 짧은 기간에 많은 실험을 실행할 수 있습니다.\n\n다시 한번, 저도 이 연구 결과에 동의합니다. 테스트할 수 있는 것이 많을수록 더 나은 결과를 얻는 경향이 있습니다. 더 많은 기능, 다른 기능 조합 및 다른 손실 함수. 빠르게 진행되는 것이 나에게 많은 가설을 짧은 시간 내에 테스트할 수 있도록 도와줍니다.\n\n그러나 성능을 향상시키는 기능을 결정하기 위해서는 모델의 우수성을 반복적으로 평가해야 합니다. 우리가 신뢰할 수 있고 최적의 기능과 모델을 식별하는 데 도움이 되는 접근 방식이 필요합니다.\n\n# 효과적인 교차 검증 전략이 중요합니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n효과적인 교차 검증 전략은 최상의 모델을 객관적으로 선택하는 데 중요합니다. 교차 검증을 활용한 로컬 검증 프로세스를 구축하여\n\n- 모델 성능이 신뢰할 만큼 향상되었는지 이해할 수 있습니다\n- 모델이 오류를 만들거나 신뢰할 수 없는 예측을 하는 영역을 발견할 수 있습니다\n- 피쳐 엔지니어링에 유용한 정보를 얻을 수 있습니다\n- 사후 표본 정확도를 시뮬레이션할 수 있습니다\n- 테스트 데이터에서 오버피팅을 피할 수 있습니다\n- 불확실성을 완화할 수 있습니다\n- 모델의 하이퍼파라미터를 튜닝할 수 있습니다\n\nM5와 캐글 경쟁은 이 중요성을 보여줍니다. M5 대회에서 많은 팀이 최종 제출을 위한 최상의 모델을 선택하는 데 실패했습니다. 캐글 대회에서는 공개 리더보드에서 최상의 모델이 항상 우승자가 되지 않는 경우가 많습니다.\n\n하지만 좋은 교차 검증 전략을 선택하는 것은 어려울 수 있습니다. 다양한 옵션이 있기 때문이죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 어떤 기간을 선택해야 하는가요?\n- 검증 창의 크기는 얼마인가요?\n- 창을 어떻게 업데이트해야 하나요?\n- 예측 성능을 요약하는 데 사용하는 기준/지표는 무엇인가요?\n\n그러므로 전략은 항상 문제에 따라 달라져야 합니다.\n\n# 각 문제마다 독특한 접근 방식이 필요합니다\n\nKaggle 및 M5 대회의 결과는 모든 데이터 세트와 문제에 대해 독특한 접근 방식이 필요하다는 것을 보여줍니다. 일반적인 해결책은 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 접근 방식이 동작하는지 결정하려면 우리의 지식과 경험이 필요합니다.\n\n예측 작업의 복잡성을 기반으로 모델을 조정해야 합니다. 이에는 위에서 논의한 모든 요소가 포함됩니다. 특성 공학부터 교차 검증, 그리고 모델 선택까지 모두요.\n\n예를 들어 M5 정확도 대회에서 각 시계열의 최상의 모델을 결합하면 우승 솔루션을 대략 2% 정도 이기는 결과를 얻을 수 있습니다.\n\n이로 인해 딥러닝 모델이 현재 실제 응용 프로그램에서 작동하지 않습니다. 그들은 상세한 특성 공학이 필요한 문제에 대해 일반적인 해결책을 제시하려고 시도합니다. 딥러닝 모델은 상세한 특성 공학이 필요한 필요성을 없애주어 우리 삶을 더 쉽게 만들어 줄 것을 약속합니다. 예를 들어, N-BEATS와 N-HiTS는 시계열에서 계절성 및 추세 구성 요소를 자동으로 찾는 것을 약속하지만, 시계열의 독특한 복잡성을 찾아내지는 못합니다. 반면, 우리의 지식으로는 이러한 복잡성을 찾아내어 ML 모델이 사용할 수 있는 특성으로 인코딩할 수 있으며, 이를 통해 딥러닝 모델을 이길 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\nM5 대회와 2023 Kaggle AI 보고서는 시계열 예측에 중요한 것과 잘 작동하는 요소에 동의합니다. 저는 실제 시계열 예측 작업에서 경험하며 그 결론을 지지할 뿐입니다.\n\n가장 중요한 요소는 다음과 같습니다:\n\n- 머신러닝 모델이 우수한 성능을 보임\n- 통계적 방법은 여전히 가치가 있음\n- 앙상블이 성능을 향상시킴\n- 학술 문헌은 시계열 예측에 미치는 영향이 작음\n- 모델보다 특성 엔지니어링이 더 중요함\n- 외생적/설명 변수는 성능을 높일 수 있음\n- 가능한 한 빨리 반복\n- 효과적인 교차 검증 전략이 중요함\n- 각 문제마다 고유한 접근이 필요함\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n딥 러닝이 목록에 포함되어 있지 않다는 것을 확인할 수 있어요.\n\n현재 딥 러닝은 아직 충분히 성숙하지 않습니다. 이러한 모델들이 문학적인 영역에서 현실 세계의 문제로 성공적으로 전이되지 못했습니다. 그러나 미래에는 변할 수도 있습니다. 오랫동안 시계열 예측을 지배해 온 통계 모델로부터 ML 모델로의 전환을 보았습니다. 앞으로 딥 러닝 모델로의 전환이 일어날 수도 있습니다. 그러므로 딥 러닝의 발전에 대해 계속해서 주목하는 것이 좋습니다. 하지만 현재는 현실 세계의 응용에 유용하지 않다고 할 수 있습니다.\n\n따라서, 딥 러닝 영역 뿐만 아니라 ML 영역에서도 추가 연구와 개선 가능성이 여전히 많이 남아 있습니다.\n\n이 글에서 유익한 정보를 많이 찾으셨으면 좋겠어요. 다음 시계열 예측 모델의 성능 향상에 도움이 되길 바랍니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 글에서 뵙겠습니다. 댓글도 남겨주세요!","ogImage":{"url":"/assets/img/2024-06-22-WhyYouCurrentlyDoNotNeedDeepLearningforTimeSeriesForecasting_0.png"},"coverImage":"/assets/img/2024-06-22-WhyYouCurrentlyDoNotNeedDeepLearningforTimeSeriesForecasting_0.png","tag":["Tech"],"readingTime":10},{"title":"신경망 출력에 제약 조건을 적용하는 방법","description":"","date":"2024-06-22 20:15","slug":"2024-06-22-HowtoEncodeConstraintstotheOutputofNeuralNetworks","content":"\n\n## 사용 가능한 접근 방식 요약\n\n![이미지](/assets/img/2024-06-22-HowtoEncodeConstraintstotheOutputofNeuralNetworks_0.png)\n\n신경망은 정말로 강력합니다. 그러나 신경망의 응용 범위가 \"표준\" 분류 및 회귀 작업에서 더 복잡한 의사 결정 및 과학용 AI로 이동함에 따라 한 가지 단점이 점점 더 두드러지고 있습니다. 신경망의 출력은 일반적으로 제한이 없거나 보다 정확히는 간단한 0-1 한계 (시그모이드 활성화 함수), 비음수 제약 (ReLU 활성화 함수) 또는 합이 일 (소프트맥스 활성화 함수)인 제약으로만 제한됩니다. 이러한 \"표준\" 활성화 계층은 분류 및 회귀 문제를 처리하고 심층 학습의 활발한 발전을 목격했습니다. 그러나 신경망이 의사 결정, 최적화 해결 및 기타 복잡한 과학 문제에 널리 사용되기 시작함에 따라, 이러한 \"표준\" 활성화 계층이 명백히 더 이상 충분하지 않습니다. 본 문서에서는 신경망의 출력에 제약 조건을 추가할 수 있는 현재 사용 가능한 방법론을 간단히 논의하고 일부 개인적인 통찰을 포함시키겠습니다. 관련 주제에 대해 비평하고 토론하는 것을 망설이지 마세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 한 번에 성공하지 않을 때는 여러 번 시도해보세요\n\n강화 학습에 익숙하시다면 이미 얘기하는 내용을 아실지도 모릅니다. n차원 벡터에 제약 조건을 적용하는 것은 어렵게 느껴질 수 있지만, n차원 벡터를 n개의 출력으로 나눌 수 있습니다. 각 출력이 생성될 때마다 다음 변수의 작업 공간을 제한하는 코드를 직접 작성하여 그 값이 적절한 범위 내에 유지되도록 할 수 있습니다. 이러한 \"자기 회귀\" 방법은 명백한 장점이 있습니다. 간단하며 다양한 제약 조건 (코드를 작성할 수 있다면)을 처리할 수 있습니다. 그러나 이 방법의 단점도 분명히 있습니다. n차원 벡터에 대해 순전파 연산을 호출해야 하기 때문에 비효율적이며, 또한 이 방법은 대개 Markov 의사 결정 과정 (MDP)으로 모델링되어야 하고 강화 학습을 통해 교육되어야 하므로 강화 학습에서 발생하는 일반적인 어려움인 큰 작업 공간, 희소 보상 함수, 오랜 교육 시간 또한 피할 수 없습니다.\n\n신경망을 사용하여 조합 최적화 문제를 해결하는 영역에서 과거에는 강화 학습과 결합된 자기 회귀 방법이 일반적이었지만, 현재는 더 효율적인 방법으로 대체되고 있습니다.\n\n# 어쩌면… 제약 조건을 학습해보는 것은 어떨까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n훈련 중에는 현재 신경망 출력이 제약 조건을 어기는 정도를 나타내는 페널티 항을 목적 함수에 추가할 수 있습니다. 전통적인 최적화 분야에서는 Lagrangian 이중 메서드도 비슷한 속임수를 제공합니다. 유감스럽게도, 이러한 방법들은 현재까지 일부 간단한 제약 조건에서만 신경망에 적용되었으며, 더 복잡한 제약 조건에도 적용 가능한지 여전히 불분명합니다. 단점 중 하나는 모델의 일부 용량이 해당 제약 조건을 충족하는 법을 배우는 데 사용되어, 모델의 다른 측면(예: 최적화 문제 해결)에서의 능력이 제한된다는 것입니다.\n\n예를 들어, Karalias와 Loukas가 2021 NeurIPS에서 발표한 “Erdo˝s Goes Neural: an Unsupervised Learning Framework for Combinatorial Optimization on Graphs”에서는 변수 값이 [a, b] 사이에 있는 \"상자 제약 조건\"이란, 상자 제약 조건을 페널티 항을 통해 배울 수 있고, 네트워크는 일부 비교적 간단한 조합 최적화 문제를 해결할 수 있다는 것을 보여주었습니다. 그러나 우리의 추가 연구 결과, 이 방법론은 일반화 능력이 부족하다는 것을 발견했습니다. 훈련 세트에서는 신경망이 제약 조건을 잘 유지할 수 있지만, 테스트 세트에서는 제약 조건이 거의 완전히 상실됩니다. 또한, 원칙적으로 페널티 항을 추가하는 것은 어떤 제약 조건에도 적용할 수 있지만, 더 어려운 제약 조건을 처리할 수 없습니다. 저희 논문 Wang et al, 2023 ICLR에서는 “Towards One-Shot Neural Combinatorial Optimization Solvers: Theoretical and Empirical Notes on the Cardinality-Constrained Case”에서 이러한 현상에 대해 논의하고 이론적 분석을 제시합니다.\n\n한편, 출력이 특정 분포를 준수해야 하는 생성 모델의 설계 철학은 \"제약 조건 학습\" 접근 방식과 더 잘 어울리는 것으로 보입니다. Sun과 Yang가 2023 NeurIPS에서 발표한 “DIFUSCO: Graph-based Diffusion Solvers for Combinatorial Optimization”에서는 확산 모델이 외판원 문제의 제약 조건(즉, 완전한 경로를 출력할 수 있는)을 충족하는 솔루션을 출력할 수 있다는 것을 보여주었습니다. 저희는 이어서 Li et al이 2023 NeurIPS에서 발표한 “T2T: From Distribution Learning in Training to Gradient Search in Testing for Combinatorial Optimization\"에서 생성 모델(Diffusion)이 제약 조건을 충족하고, 다른 옵티마이저가 확산의 점진적 소음 제거 과정 중에 최적화 지침을 제공하는 방법을 제시했습니다. 이 전략은 실험에서 상당히 성능이 우수하게 나와서 이전의 모든 신경망 솔버를 능가했습니다.\n\n# 또 다른 흥미로운 시각: 볼록 최적화 문제 해결\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아마도 자기회귀가 너무 비효율적이라고 생각하거나 생성 모델이 당신의 문제를 해결하지 못할 것 같다는 걱정이 있을 것 같아요. 단 한 번의 전방향 패스만 수행하는 신경망이 있고 출력이 주어진 제약 조건을 충족해야 한다면 가능할까요? \n\n그 대답은 예요. 우리는 신경망의 출력을 볼록 제약 조건에 의해 경계가 지정된 허용 가능한 영역으로 프로젝션하는 볼록 최적화 문제를 해결할 수 있어요. 이 방법론은 볼록 최적화 문제가 KKT 조건에서 미분 가능하다는 성질을 활용하여 이 프로젝션 단계를 활성화 레이어로 간주할 수 있어서 엔드 투 엔드 신경망에 삽입할 수 있어요. 이 방법론은 Zico Kolter의 CMU 그룹에서 제안 및 홍보되었으며 현재 cvxpylayers 패키지를 제공하여 구현 단계를 용이하게 할 수 있어요. 해당하는 볼록 최적화 문제는 다음과 같아요\n\n여기서 y는 제약이 없는 신경망 출력이고, x는 제약이 있는 신경망 출력입니다. 이 단계의 목적이 프로젝션일 뿐이므로 선형 목적 함수로 이를 달성할 수 있어요 (엔트로피 정규화 항을 추가하는 것도 합리적입니다). Ax ≤ b는 적용해야 하는 선형 제약 조건이며, 제곱 혹은 다른 볼록 제약 조건일 수도 있어요.\n\n개인 메모: 알려진 문제가 있는 것 같아서 이 저장소가 오랫동안 업데이트/유지되지 않은 것으로 보입니다 (2024년 04월). 무슨 일이 일어나고 있는지 조사해 주시는 분이 있다면 진심으로 감사하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 비 볼록 문제에 대해: 어떤 기울기 근사를 선호하시나요?\n\nKKT 조건을 사용해 기울기를 유도하는 것은 이론적으로 타당하지만, 비 볼록 또는 비 연속 문제를 해결할 수 없습니다. 사실, 비 연속 문제의 경우, 문제 매개변수의 변화로 인해 해가 점프하면, 실제 기울기는 델타 함수(즉, 점프에서 무한대)가 됩니다. 이는 당연히 신경망 학습에 사용할 수 없습니다. 다행히도, 이 문제를 해결할 수 있는 몇 가지 기울기 근사 방법이 있습니다.\n\nMax Planck 연구소 내 Georg Martius 그룹은 검은 상자 근사법 Vlastelica 등 (\"Differentiation of Blackbox Combinatorial Solvers\", ICLR'2020)를 소개했습니다. 이 방법은 문제 해결자를 검은 상자로 보는데, 먼저 한 번 호출한 후에 문제 매개변수를 특정 방향으로 변형하고 다시 호출합니다. 두 번의 해결자 호출의 출력 간 잔차가 근사 기울기로 작용합니다. 이러한 방법을 신경망 출력에 적용하여 제약 조건을 부여하는 경우, 선형 목적 함수가 있는 최적화 문제를 정의할 수 있습니다.\n\n여기에서 y는 제약이 없는 신경망 출력이며, x는 제한된 신경망 출력입니다. 여러분의 다음 단계는 위 문제를 해결할 알고리즘을 구현하는 것(반드시 최적이 아니어도 됨)이며, 그런 다음 그것을 검은 상자 근사 프레임워크에 통합하는 것입니다. 검은 상자 근사법의 단점은 선형 목적 함수만 처리할 수 있다는 것이지만, 제약 조건을 부여하는 방법을 찾고 있다면 선형 목적 함수가 작동하는 것이 바로 맞게 됩니다. 게다가, 하이퍼파라미터가 잘 조정되지 않은 경우에는 희소한 기울기와 수렴 문제가 발생할 수 있기 때문에 주의가 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기울기를 근사하는 또 다른 방법은 Berthet 등에 의해 논의된 것처럼 많은 양의 무작위 잡음 변형을 사용하여 반복적으로 솔버를 호출하여 기울기를 추정하는 것입니다. NeurIPS’2020 “Learning with Differentiable Perturbed Optimizers”에서 충분히 알려져 있습니다. 이론적으로 이 방법으로 얻은 기울기는 LinSAT 방법을 통해 얻은 기울기와 유사해야 합니다 (다음 섹션에서 설명될 것입니다). 즉, 엔트로피 정규화된 선형 목적 함수의 기울기입니다. 그러나 실제로는 이 방법이 많은 무작위 샘플을 필요로 하므로, 실제로는 조금 비실용적인 면이 있습니다 (적어도 내 사용 사례에서는 그렇습니다).\n\n# 자기 홍보할 시간: 최적화 문제를 풀지 않고 투영하기\n\n볼록 문제의 KKT 조건으로부터 기울기를 유도하거나 비볼록 방법에 대해 기울기를 근사하기 위해 솔버를 호출하거나 작성해야 하는 경우, CPU-GPU 통신이 병목 현상이 될 수 있습니다. 왜냐하면 대부분의 솔버는 보통 CPU용으로 설계 및 구현되기 때문입니다. 최적화 문제를 명시적으로 풀지 않고 GPU에 특정 제약 조건을 직접 투영하는 방법이 있을까요? \n\n그 대답은 예, 있습니다. 그리고 저희 Wang 등인 ICML’2023 “LinSATNet: The Positive Linear Satisfiability Neural Networks”는 실행 가능한 경로를 제시하며 알고리즘의 수렴 특성을 유도합니다. LinSAT은 선형 충족 네트워크를 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLinSAT은 신경망의 출력에 일반적인 양의 선형 제약 조건을 적용할 수 있도록 하는 활성화 계층으로 볼 수 있습니다.\n\n![image](/assets/img/2024-06-22-HowtoEncodeConstraintstotheOutputofNeuralNetworks_1.png)\n\nLinSAT 계층은 완전히 미분 가능하며, 실제 그래디언트는 다른 활성화 계층처럼 autograd에 의해 계산됩니다. 현재 우리의 구현은 PyTorch를 지원합니다.\n\n설치 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```shell\npip install linsatnet\n```\n\n그리고 다음과 같이 시작해보세요:\n\n```python\nfrom LinSATNet import linsat_layer\n```\n\n# 간단한 예제\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 소스 코드를 다운로드해서 실행하면 간단한 예제를 찾을 수 있어요. 이 예제에서는 3×3 행렬에 이중 확률 제약 조건을 적용해요.\n\n예제를 실행하려면 먼저 repo를 복제하세요:\n\n```js\ngit clone https://github.com/Thinklab-SJTU/LinSATNet.git\n```\n\n그리고 repo로 이동해서 예제 코드를 실행하면 돼요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ncd LinSATNet\npython LinSATNet/linsat.py\n```\n\n이 예에서는 3x3 행렬에 이중 확률 제약 조건을 적용하려고 합니다. 이중 확률 제약 조건은 행렬의 모든 행과 열의 합이 1이어야 한다는 것을 의미합니다.\n\n3x3 행렬은 벡터로 변환되며 다음과 같은 양의 선형 제약 조건이 고려됩니다 (Ex=f):\n\n```js\nE = torch.tensor(\n    [[1, 1, 1, 0, 0, 0, 0, 0, 0],\n     [0, 0, 0, 1, 1, 1, 0, 0, 0],\n     [0, 0, 0, 0, 0, 0, 1, 1, 1],\n     [1, 0, 0, 1, 0, 0, 1, 0, 0],\n     [0, 1, 0, 0, 1, 0, 0, 1, 0],\n     [0, 0, 1, 0, 0, 1, 0, 0, 1]], dtype=torch.float32\n)\nf = torch.tensor([1, 1, 1, 1, 1, 1], dtype=torch.float32)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 w를 무작위로 초기화하고, 이를 일부 신경망의 출력으로 간주합니다:\n\n```js\nw = torch.rand(9) # w는 신경망의 출력일 수 있음\nw = w.requires_grad_(True)\n```\n\n또한, linsat_layer의 출력에 대한 \"ground-truth target\"도 있습니다. 이 예제에서는 대각 행렬입니다:\n\n```js\nx_gt = torch.tensor(\n    [1, 0, 0,\n     0, 1, 0,\n     0, 0, 1], dtype=torch.float32\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nYou are a developer. Please translate the above text into Korean in a friendly tone.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nloss = ((linsat_outp — x_gt) ** 2).sum()\nloss.backward()\n```\n\n대량의 입력에 대해 시간 및 메모리 효율성을 높이려면 E를 희소 행렬로 설정할 수도 있어요. 다음은 덤한 예시에요 (효율성을 높이기 위해 E를 희소 행렬로 구성하는 것을 고려해보세요):\n\n```js\nlinsat_outp = linsat_layer(w, E=E.to_sparse(), f=f, tau=0.1, max_iter=10, dummy_val=0)\n```\n\n우리는 linsat_layer의 출력을 x_gt에 가깝게 만들기 위해 w에 대한 경사 기반 최적화도 할 수 있어요. 이것은 신경망을 훈련시킬 때 발생하는 일이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nniters = 10\nopt = torch.optim.SGD([w], lr=0.1, momentum=0.9)\nfor i in range(niters):\n x = linsat_layer(w, E=E, f=f, tau=0.1, max_iter=10, dummy_val=0)\n cv = torch.matmul(E, x.t()).t() - f.unsqueeze(0)\n loss = ((x - x_gt) ** 2).sum()\n loss.backward()\n opt.step()\n opt.zero_grad()\n print(f'{i}/{niters}\\n'\n f' underlying obj={torch.sum(w * x)},\\n'\n f' loss={loss},\\n'\n f' sum(constraint violation)={torch.sum(cv[cv \u003e 0])},\\n'\n f' x={x},\\n'\n f' constraint violation={cv}')\n```\n\nAnd you are likely to see the loss decreasing during the training steps.\n\nFor full API references, please check out the GitHub repository.\n\n# How does LinSAT work?\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주의하세요! 수학 내용이 많습니다! LinSAT을 사용 중이라면 이 부분을 건너뛰셔도 됩니다.\n\nLinSAT 내부의 메커니즘을 소개합니다. 우리는 Sinkhorn 알고리즘을 여러 세트의 마진에 확장함으로써 작동합니다 (우리의 최선 지식으로, 우리는 마진의 다중 세트에 대해 Sinkhorn을 연구한 첫 번째 연구자입니다). 그런 다음 양적 선형 제약 사항은 제약 사항을 마진으로 변환함으로써 강제됩니다.\n\n## 단일 세트 마진을 사용하는 클래식한 Sinkhorn\n\n클래식한 Sinkhorn 알고리즘부터 시작해봅시다. 크기가 m×n인 비음수 점수 행렬 S가 주어지고, 행에 대한 마진 분포 세트(크기가 m인 비음수 벡터 v)와 열에 대한 마진 분포 세트(크기가 n인 비음수 벡터 u)가 주어지면\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSinkhorn 알고리즘은 m×n 크기의 정규화된 행렬 Γ를 출력하며, 값은 [0,1] 범위에 있습니다.\n\n개념적으로, Γᵢ ⱼ는 uⱼ에서 vᵢ로 이동된 비율을 의미합니다.\n\n알고리즘 단계는 다음과 같습니다:\n\n## 다중 집합 마진을 가진 확장된 Sinkhorn\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSinkhorn 알고리즘이 여러 세트의 마진에 대해 일반화될 수 있다는 것을 발견했습니다. Γᵢ ⱼ ∈ [0,1]는 uⱼ가 vᵢ로 이동한 비율을 의미합니다. 흥미로운 점은 u, v를 다른 세트의 마진 분포로 간단히 교체하면 동일한 공식이 생성된다는 것입니다. 이는 Sinkhorn 알고리즘을 여러 세트의 마진 분포로 확장할 수 있는 잠재력을 시사합니다. 현실세계 시나리오를 더 잘 반영하기 위해 강제되는 k개의 세트의 마진 분포를 나타냅니다. 마진 분포 세트는 다음과 같습니다.\n그리고 우리는 다음과 같습니다:\n\nm×n 크기의 정규화된 Z ∈ [0,1]가 존재한다고 가정합니다.\n즉, 여러 세트의 마진 분포가 비어 있지 않은 실행 가능 영역을 갖습니다 (다음 섹션에서 어떻게 양의 선형 제약 조건을 처리하는지 읽은 후 \"비어 있지 않은 실행 가능 영역\"의 의미를 이해할 수 있습니다). 여러 세트의 마진 분포는 Sinkhorn 반복을 거치면서 강제할 수 있습니다. 알고리즘 단계는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 논문에서는 다중 집합 주변 분포를 위한 Sinkhorn 알고리즘이 클래식한 Sinkhorn과 동일한 수렴 패턴을 공유하며, 기본적인 공식 또한 클래식한 Sinkhorn과 유사하다는 것을 증명합니다.\n\n## 긍정적 선형 제약 조건을 주변 분포로 변환\n\n그런 다음, 우리는 긍정적 선형 제약 조건을 주변 분포로 변환하는 방법을 보여주고, 이는 우리가 제안하는 다중 세트 Sinkhorn에 의해 처리됩니다.\n\n신경망의 출력 인코딩\n신경망의 출력으로 표시되는 길이 l의 벡터 y에 대해 (이는 신경망의 출력이 될 수 있으며, linsat_layer의 입력일 수도 있습니다), 다음 행렬이 구성됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nW는 크기가 2 × (l + 1)인 표입니다. β는 더미 변수이며 기본값은 β = 0입니다. y는 W의 왼쪽 위 영역에 위치합니다. 그런 다음 엔트로피 정규화자가 강제로 적용되어 이산성을 제어하고 잠재적으로 음의 입력값을 처리합니다:\n\n점수 행렬 S는 다중 집합 marginal의 입력으로 사용됩니다.\n\n선형 제약 조건부터 마진까지\n\n1) 포장 제약 Ax ≤ b. 단 하나의 제약 조건만 있는 경우, 제약 조건을 다음과 같이 다시 쓸 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시콘의 \"운송\" 관점을 따르면 출력 x는 a₁, a₂, ..., aₗ에서 최대 b 단위의 질량을 이동하고 더미 차원은 가짜 차원으로부터 질량을 이동하여 부등식을 허용합니다. 또한 uₚ의 합이 vₚ의 합과 동일하다는 것이 보장됩니다. 주변 분포는 다음과 같이 정의됩니다.\n\n2) 커버링 제약 Cx ≥ d. 하나의 제약만 있는 경우, 제약을 다음과 같이 다시 쓸 수 있습니다.\n\n우리는 항상 가지고 있기 때문에 이러한 승수를 도입합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n(그렇지 않으면 제약 조건이 실행할 수 없는 것이며, 이 배율 없이 x 내의 모든 요소가 1이 되는 실행 가능한 솔루션에 도달할 수 없습니다. 우리의 공식은 x에 의해 c₁, c₂, ..., cₗ 에서 적어도 d 단위의 질량이 이동되는 것을 보장하므로 \"이상\"의 커버링 제약 조건을 나타냅니다. 또한 u_c의 합이 v_c의 합과 동일함을 보장합니다. 마진 분포는 다음과 같이 정의됩니다\n\n3) 등식 제약 조건 Ex = f. 등식 제약 조건을 나타내는 것은 더 직관적입니다. 하나의 제약 조건만 있는 경우를 가정하면, 제약 조건을 다음과 같이 다시 작성할 수 있습니다\n\n결과 x는 e₁, e₂, ..., eₗ를 f로 이동시키며, uₑ에 더미 요소가 필요하지 않음을 알아야합니다. 또한 uₑ의 합이 vₑ의 합과 동일함을 보장합니다. 마진 분포는 다음과 같이 정의됩니다\n\n모든 제약 조건을 인코딩하고 이를 여러 세트의 마진으로 쌓은 후, Sinkhorn 알고리즘을 호출하여 다중 세트 마진에 대한 제약 조건을 인코딩할 수 있습니다.)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## LinSAT의 실험적 유효성 검증\n\n저희의 ICML 논문에서는 LinSATNet 방법을 일반적인 경우를 넘어 라우팅 제약 조건에 대해 검증했습니다 (여행하는 외판원 문제의 변형 해결에 사용), 부분 그래프 매칭 제약 조건 (그래프 매칭에서 그래프의 부분 집합만 서로 일치하는 경우 사용), 그리고 일반적인 선형 제약 조건 (포트폴리오 최적화와 관련된 특정 선호도에서 사용). 이러한 문제들은 모두 양수 선형 제약 조건으로 표현할 수 있으며 LinSATNet 방법을 사용하여 처리할 수 있습니다. 실험에서 신경망은 이 세 가지 문제를 해결하는 방법을 배울 수 있었습니다.\n\nLinSATNet 방법은 음수 용어가 포함된 x₁ — x₂ ≤ 0과 같은 제약 조건을 처리할 수 없다는 사실을 강조해야 합니다. 그러나 양수 선형 제약 조건은 이미 다양한 시나리오를 포괄하고 있습니다. 각각의 특정 문제에 대해 수학적 모델링은 종종 유일하지 않으며, 많은 경우 합리적인 양수 선형 정식을 찾을 수 있습니다. 위에 언급된 예시들 외에도, 유기 분자를 출력하는 네트워크가 있을 수 있습니다 (그래프로 표현되며 수소 원자를 무시하고 골격만 고려). 이 경우에는 C 원자가 4개의 결합을 초과하지 않도록, O 원자는 2개의 결합을 초과하지 않도록 하는 제약 조건이 고려될 수 있습니다.\n\n# 결말\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n신경망에 제약 조건을 추가하는 것은 다양한 응용 시나리오를 가지고 있으며, 현재까지 여러 방법이 있습니다. 각 방법의 우월성을 판단하는 황금 기준이 없다는 것을 알아두는 것이 중요합니다. 일반적으로 최적의 방법은 특정 시나리오에 관련이 있습니다.\n\n물론 LinSATNet을 사용해보는 것을 추천합니다! 아무튼, 이는 당신의 네트워크에 활성화 계층만큼 간단합니다.\n\n만약 이 기사가 도움이 되었다면 아래를 인용해주시기 바랍니다:\n\n```js\n@inproceedings{WangICML23,\n  title={LinSATNet: The Positive Linear Satisfiability Neural Networks},\n  author={Wang, Runzhong and Zhang, Yunhao and Guo, Ziao and Chen, Tianyi and Yang, Xiaokang and Yan, Junchi},\n  booktitle={International Conference on Machine Learning (ICML)},\n  year={2023}\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 언급된 내용은 이 논문에서 논의되었습니다.","ogImage":{"url":"/assets/img/2024-06-22-HowtoEncodeConstraintstotheOutputofNeuralNetworks_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoEncodeConstraintstotheOutputofNeuralNetworks_0.png","tag":["Tech"],"readingTime":12},{"title":"트랜스포머의 위치 인코딩 시각적이고 직관적인 가이드","description":"","date":"2024-06-22 20:12","slug":"2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide","content":"\n\n이 글에서는 Transformer 모델의 변형적인 힘을 탐구할 것이며, 특히 위치 인코딩을 통해 그 힘을 조명할 것입니다. GPT, DALL-E, SORA와 같은 혁신적인 AI 모델의 기술인 트랜스포머는 기계가 인간과 유사한 텍스트와 이미지를 이해하고 생성하는 방법을 혁신적으로 바꾸었습니다. 이러한 모델의 핵심에는 \"Attention is All You Need\"라는 선행 논문에서 소개된 위치 인코딩 개념이 있습니다. 이 방법은 순환 구조 없이 데이터의 순서를 유지하는 데 중요한 역할을 합니다. 우리는 왜 저자들이 사인 함수 위치 인코딩을 선택했는지 그리고 이 선택 뒤에 있는 수학적 프레임워크와 직관적 이유를 자세히 알아볼 것입니다.\n\n저는 복잡한 개념을 명확하고 시각적으로 설명하는 데 초점을 맞추었으며, 3D 공간이나 복소수를 사용하지 않았습니다. Jonathan Kernes의 글과 같은 작품에서 상세히 다루어진 주제이지만, Vaswani 등의 최종 수식과 개념 뒤에 숨은 직관을 가능한 가장 간단한 용어로 설명하려고 노력했습니다.\n\n# 소개: 위치 인코딩의 필요성\n\nRNN이나 LSTM과 같은 다른 순차 처리 모델과는 달리 트랜스포머는 데이터를 순서대로 처리하지 않습니다. 따라서 입력 데이터의 순서 또는 '위치 정보'를 통합해야 합니다. 이것이 위치 인코딩이 필요한 이유입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n트랜스포머가 작동하는 기본 아이디어에 대해 간단히 알고 있으면 좋겠네요. 알지 못한다면, 3Blue1Brown의 어텐션에 대한 비디오를 추천드립니다. 이 비디오에서 이해해야 할 점은 각 \"토큰\"이 해당되는 벡터를 가지고 있다는 것이며, 이 벡터는 주변 토큰이나 단어를 주의 깊게 살피면 변경되거나 변형된다는 것입니다. 이를 알고 있다면, 이 비디오 뒤로 바로 넘어갈 수 있습니다.\n\n이 벡터 임베딩 외에도 각 토큰에 대한 \"위치 임베딩\" 또는 인코딩이 필요합니다. 위치 인코딩이 없으면 트랜스포머는 동일한 단어 세트의 서로 다른 순서로 이루어진 두 개의 시퀀스 사이의 차이를 알 수 없습니다. 위치 인코딩은 모델이 시퀀스에서 각 단어가 어디에 있는지를 이해하는 데 도움이 됩니다. 이 게시물 전체에서 개념을 더 잘 이해하기 위해 \"나는 오늘 저녁에 축구를 하러 가고 싶다\"는 문장을 사용하겠습니다. 이 개념을 더 잘 이해하기 위해 토큰화하는 대신 각 단어를 토큰으로 가정하겠습니다. \"I\", \"am\", \"going\"은 모두 토큰입니다.\n\n![이미지](/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_0.png)\n\n위치 인코딩에 대한 순진한 접근 방식을 살펴보겠습니다. 각 단어의 위치에 따라 고유한 식별자를 할당한다고 가정해봅시다. 예를 들어, 0부터 7까지의 순서 위치에 대해 0, 1, 2, 3, 4, 5, 6, 7의 숫자를 사용할 수 있고, 이를 [P_i]로 표현할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 숫자 0부터 7을 위치 인코딩으로 사용하는 것은 직접적으로 보이지만, 이 방법은 모델에게 혼란을 줄 수 있습니다. 이 방식은 이러한 위치를 숫자 값으로 취급하여 의도하지 않은 중요도나 크기 순서를 나타낼 수 있습니다. 이로 인해 모델이 순서를 해석하는 방법에 편향이 발생할 수 있습니다. 다음 해야 할 단계는 명백합니다. 정규화하자!\n\n# 정규화 시도 중\n\n더 큰 위치 숫자를 사용해 발생하는 폭주 그래디언트와 같은 문제를 완화하기 위해, 이러한 값들을 정규화하는 것을 고려해볼 수 있습니다. 예를 들어, 시퀀스 길이를 기준으로 이러한 위치를 0부터 1 사이로 스케일링하는 방법 등이 있습니다.\n\n![이미지](/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 정규화는 시퀀스 길이를 기준으로 모든 위치 부호화를 조정합니다. 예를 들어, 8단어 문장에서 7번째 위치는 7/7 또는 1로 부호화되고 0번째 위치는 0/7 또는 0으로 부호화됩니다.\n\n그러나 이 방법은 새로운 문제를 도입합니다. 50개 토큰을 가진 시퀀스와 100개 토큰을 가진 다른 시퀀스를 고려해보세요. 위치 부호화 값이 0.3이라면 첫 번째 시퀀스의 15번째 토큰을 나타내지만 두 번째 시퀀스에서는 30번째 토큰을 나타냅니다.\n\n이러한 가변성은 문제가 될 수 있습니다. 0.3과 같은 위치 값의 의미는 시퀀스 길이에 따라 달라집니다. 이상적으로는 시퀀스 길이에 관계없이 일관된 위치 관계를 유지하는 방법이 필요합니다.\n\n이것은 어떤 길이의 시퀀스라도 균일하게 처리하고 일관된 관계를 유지할 수 있는 더 견고한 위치 부호화 방법이 필요함을 강조합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 단계는 무엇일까요? 이번에는 숫자를 이진수로 표현해 보는 것을 시도해 봅시다.\n\n## 이진 위치 부호화\n\n정규화를 탐색한 후, 고려할 수 있는 다른 방법은 이진 위치 부호화를 사용하는 것입니다. 이 방법에서는 각 위치 번호가 해당하는 이진수로 표현됩니다. 예를 들어, 0부터 3까지의 위치는 각각 [0,0], [0,1], [1,0], [1,1]과 같이 인코딩될 것입니다.”\n\n![](/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법은 순진한 숫자 접근법과 비교하여 위치를 인코딩하는 데 더 적은 차원을 사용하기 때문에 영리해 보입니다. 그러나 다른 문제가 생깁니다 — 불연속성. 첫 4단어를 살펴보겠습니다 —\n\n![image](/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_3.png)\n\n![image](/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_4.png)\n\n그럼 이들을 그래프로 표현해 보겠습니다 —\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Positional encoding in transformers: a Visual and Intuitive guide](/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_5.png)\n\n그래프를 보면 한 위치에서 다음 위치로의 전환이 부드럽지 않음을 볼 수 있습니다. 예를 들어, [0,1]에서 [1,0]으로 이동하는 경우 두 비트를 모두 뒤집어야 하며, 이는 인코딩된 공간에서 상당한 점프를 나타냅니다.\n\n이 연속성은 여러 이유로 문제가 될 수 있습니다-\n\n- 먼저 학습 모델에서는 위치의 작은 변화가 표현의 작은 변화에 대응되기를 원합니다. 그러나 이진 방법은 인접한 위치에 대한 인코딩의 큰 점프로 이어져 모델이 이를 의미 있는 패턴으로 해석하려고 하면 혼란스러울 수 있습니다.\n- 위치 인코딩의 연속성은 모델이 본 적이 없는 위치에 더 잘 일반화하도록 돕습니다. 연속적인 인코딩 체계는 수치적으로 가까운 위치가 비슷한 표현을 받도록 보장하여 모델이 여러 위치에 걸쳐 된 패턴을 이해하는 데 도움이 됩니다.\n- 이진 방법에서 각 위치는 고유한 표현을 갖지만 부드러운 전환의 부재는 모델이 내삽하고 유용한 위치 정보를 추출하는 능력을 방해할 수 있습니다. 이는 부드럽고 연속적인 인코딩의 혜택이 중요해지는 긴 시퀀스를 다룰 때 특히 두드러집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n따라서, 이진 인코딩은 흥미로운 방법이지만 불연속적인 성격 때문에 중요한 어려움이 있습니다. 각 위치가 고유하게 표현되도록 하는 인코딩 방법이 필요한데, 동시에 유사한 위치가 유사한 인코딩을 가지도록 연속성이 유지되어야 합니다. 이는 모델의 학습과 일반화 능력을 향상시킵니다.\n\n다음 단계는 마음에 떠오르는 가장 쉬운 연속곡선은 무엇이며, 각 위치에 대해 고유한 값이 있는지 고려하는 것입니다.\n\n# 사인 곡선\n\n이진 위치 인코딩의 한계를 검토한 후에는 사인파를 사용하는 더 자연스러운 방법을 고려해 봅시다. 각 위치를 사인 곡선으로 표현한다고 상상해보세요. 이를 통해 위치가 증가함에 따라 부드럽고 연속적인 인코딩 변화를 제공할 수 있으며, 이는 모델 학습에 유익합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_6.png)\n\n만약 우리의 훈련 세트가 50개의 토큰으로 구성되어 있다고 가정해보면, 51번째 위치의 값은 사인파의 주기적인 특성으로 인해 1번째와 동일한 값을 반복하게 될 것입니다. 이는 각 위치에 대해 고유한 값이 없어지면서 모델이 시퀀스의 길이와 위치를 제대로 이해하는 데 제약을 가할 수 있음을 의미합니다.\n\n이를 해결하기 위해 우리는 추가적인 차원을 도입합니다 — 다른 주파수를 갖는 또 다른 사인파입니다. 이 두 번째 차원은 단순히 또 다른 파형이 아닙니다; 위치 인코딩이 시퀀스 내의 각 위치를 구별할 수 있도록 하는 중요한 요소입니다. 위치의 수가 증가해도 다른 위치들과 구분될 수 있도록 하는 역할을 수행합니다.\n\n![image](/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_7.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n직관적으로 첫 번째 사인파는 기본 위치 신호를 제공하며, 다른 주파수의 두 번째 사인파를 추가함으로써 우리는 인코딩이 다르게 진동하도록 허용함으로써 시퀀스를 따라 이동할 때 다르게 진폭된다. 주파수의 변화는 하나의 사인파가 값 반복을 시작해도 두 주파수의 조합이 여전히 고유할 가능성이 높다는 것을 의미합니다.\n\n이 추가적인 차원은 효과적으로 더 복잡한 위치 풍경을 만들어냅니다. 각 위치는 이제 두 차원 공간에서 한 점으로 표현되며, 각 차원은 다른 주파수의 사인파에 해당합니다. 결과적으로 각기 다른 두 파도 혼자서 달성할 수 없었던 매우 긴 시퀀스에 대한 고유하고 연속적인 위치 인코딩이 생성됩니다.\n\n다른 주파수를 가진 두 사인파를 사용함으로써, 우리는 인코딩 겹침 가능성을 크게 줄여 모델이 시퀀스 길이에 상관없이 위치 정보를 정확하게 해석하고 활용할 수 있는 능력을 향상시킵니다.\n\nVaswani 등이 사용한 위치 인코딩의 \"cos\" 측면에 대해 들어가기 전에, 직관적인 비유를 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 직관적인 비유들\n\n두 가지 직관적인 비유를 활용하여 다중 사인파 주파수를 이용한 위치 부호화에 대한 이해를 더 깊게 해보겠습니다.\n\n![이미지](/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_8.png)\n\n- 세 개의 볼륨 조절 다이얼이 있다고 상상해보세요. 각 다이얼은 각각 1, 2, 4 데시벨씩 볼륨을 늘립니다. 이 세 다이얼만 가지고 다양한 설정을 조합하여 0부터 7 데시벨까지의 볼륨 레벨을 만들 수 있습니다. 이는 여러 주파수를 사용하는 것이 우리에게 다양한 위치를 부호화할 수 있는 기회를 준다는 점과 유사합니다. 각 주파수 조절은 다이얼을 돌리는 것처럼, 다차원 공간에서 위치를 부호화할 수 있게 해줍니다. 이를 통해 우리는 만들 수 있는 고유한 위치 특성의 범위를 확장할 수 있습니다.\n- 이 개념을 시각화하는 또 다른 방법은 두 사람이 동일한 말을 하되 서로 다른 주파수로 말하는 상황을 상상해 보는 것입니다. 말의 내용은 같지만 말하는 높이가 다르기 때문에 각각의 목소리에는 독특한 특징이 있습니다. 위치 부호화에서도 동일한 사인파의 주기적 성격으로 인해 '내용' 또는 기본 위치가 반복될 수 있지만, 다른 주파수로부터 나온 다른 사인파를 추가하면 부호화의 '톤'이 달라지게 됩니다. 이로 인해 각 위치는 구별되는 '목소리' 또는 부호화를 가지도록 되어, 일부 기본 위치 값이 반복되어도 모델에서 인식할 수 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 계층 구조 방식은 다양한 위치를 인코딩하는 견고한 프레임워크를 제공하는 것처럼 여러 볼륨 조절기를 사용하거나 서로 다른 음높이의 겹치는 음성을 듣는 것과 유사합니다. 시퀀스 내의 다양한 지점을 보다 정밀하게 구분하여 모델이 각 토큰의 위치적 맥락에 기반하여 일관된 응답을 이해하고 생성할 수 있는 능력을 향상시킵니다.\n\n# 위치 인코딩에서 선형 변환의 중요성\n\n이제 우리는 위치 인코딩의 또 다른 중요한 측면인 위치 약간 다른 위치에 대한 인코딩을 예측하는 능력을 탐색해보겠습니다. 이것은 이상적으로 직관적인 작업이어야 하며 구체적으로 선형 변환이어야 합니다. 왜 선형일까요? 이에 대해 자세히 살펴보겠습니다.\n\n우리의 위치 인코딩 행렬은 지금까지 논의한 내용에 기반하여 다음과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마크다운 포맷으로 테이블 태그를 변경하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 문장 '나는 오늘 저녁에 축구를 할 예정이에요'로 돌아가 봅시다.\n\n이 모델이 이 문장을 이해하기 위해 ‘나에 대한 동사가 어디 있지’라는 질문을 생성합니다. 이상적으로 모델의 키와 질문은 '나'에 대한 동사와 관련된 질문과 정확하게 일치해야 합니다. 이러한 정렬은 모델이 문장 구조를 올바르게 해석하는 데 매우 중요합니다.\n\n특히 입력 시퀀스의 위치가 약간 변경될 때 이러한 정렬이 효과적으로 작동하려면 위치 인코딩은 매끈하게 조정될 수 있어야 합니다. 여기에서 선형 변환을 사용합니다. 위치의 변경으로 인한 위치 인코딩의 변환이 선형적이라면 모델은 단어와 위치적 맥락 간의 관계를 유지하면서 키와 질문을 쉽게 조정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수학적으로, 작은 위치 이동 δx에 대해 위치 인코딩 P의 변화는 선형 함수여아 합니다. 이러한 변환은 입력이 약간 다르더라도 문장의 서로 다른 부분 간의 관계가 일관되게 유지되도록 보장합니다. 이 일관성은 트랜스포머가 다른 위치에서 문장 내에서 문법적인 관계를 유지하는 데 중요합니다.\n\n따라서 위치 인코딩에서의 선형 변환은 편의를 위한 것뿐만 아니라, 모델의 자기 주의 메커니즘의 무결성과 효과적인 기능을 다양한 문장 길이와 구조에 걸쳐 유지하는 데 필수적입니다.\n\n# 방정식에 \"cos\"를 추가\n\n위치 인코딩에서의 선형 변환의 중요성을 이해했으니, 이제 회전 행렬을 사용하여 세 차원에서 이 개념이 어떻게 적용되는지 시각화하고, 이 아이디어를 다시 트랜스포머의 사인 함수 위치 인코딩과 연결해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_12.png)\n\n3D 공간에서의 회전 행렬은 우리에게 어떠한 축 주변으로 벡터를 회전시킬 수 있는 기능을 제공합니다. 예를 들어, 우리가 z-축 주변으로 벡터를 회전시킬 때, 벡터의 x 및 y 성분이 변하지만, z 성분은 그대로 유지됩니다. 이 회전에 사용되는 행렬은 사인과 코사인 함수를 포함하며, 회전 중 벡터의 길이가 유지되도록 도와줍니다.\n\n이 개념은 사인 함수 위치 인코딩과 유사합니다. 우리는 단순히 하나의 사인 함수를 사용하는 대신, 각 사인 함수를 코사인 함수와 짝지어 사용합니다. 이러한 짝지어짐은 행렬의 회전적인 측면을 모방하여, 각 위치를 고유하고 일관되게 인코딩할 수 있도록 공간을 통과하는 다차원 파동을 제공합니다.\n\n이제 이 이해를 우리의 위치 인코딩 행렬에 적용해봅시다. 각 사인 함수를 사인-코사인 쌍으로 대체합니다. 사인과 코사인 함수는 삼각법의 특성을 통해 본질적으로 관련되어 있으며, 마치 회전 행렬의 요소들이 관련되어 있는 것처럼요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 모두 변경되었습니다 - \n\n![그림](/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_14.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 위치에 대한 독특한 인코딩을 유지하는데 그치지 않고 인코딩이 다차원 공간에 매끄럽게 분산되도록합니다. 이 다차원 분포는 공간에서 회전하는 벡터와 유사하며, 각도(또는 여기서는 위치)의 작은 변화가 벡터(또는 인코딩)의 방향에 예측 가능하고 일관된 변화를 일으킵니다.\n\n삼각함수의 노련한 활용은 우리 모델이 위치 정보를 효과적으로 식별하고 활용할 수 있는 능력을 보장하여 순차 데이터의 전반적인 이해와 처리를 향상시킵니다.\n\n# 결론\n\n여기까지입니다! 우리는 위치 인코딩의 수학적 풍경을 통해 단순한 숫자에서 이진까지의 여정을 함께해왔고, 다중 주파수의 사인파와 코사인파의 파동을 타고 날아다니며 이것들로 단어 시퀀스를 조화롭게 만드는 트랜스포머가 어떻게 작동하는지 확인했습니다. 마치 숙련된 지휘자가 오케스트라를 음악의 심포니를 통해 안내하는 것처럼, 우리는 트랜스포머가 사인파와 코사인파의 우아한 수학을 활용해 단어 시퀀스를 조화롭게 만드는 것을 보았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위치 인코딩의 목표는 모델이 처리하는 데이터에서 방향감을 제공하는 것입니다. 마치 지도가 여행자를 안내하는 것처럼 말이죠. 사인 함수 위치 인코딩을 사용하여, 데이터 주도형 네비게이터가 자신이 어디에 있는지뿐만 아니라 정보 바다 속으로 향하는 방향까지 파악합니다.\n\n# 참고 자료\n\n- Jonathan Kernes- https://towardsdatascience.com/master-positional-encoding-part-i-63c05d90a0c3\n\n2. Herman Kamper- https://www.kamperh.com/nlp817/notes/11_transformers_notes.pdf\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. Vaswani, Ashish, et al. \"Attention is all you need.\" arXiv preprint arXiv:1706.03762 (2017).","ogImage":{"url":"/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_0.png"},"coverImage":"/assets/img/2024-06-22-PositionalencodingintransformersaVisualandIntuitiveguide_0.png","tag":["Tech"],"readingTime":10}],"page":"28","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"28"},"buildId":"8coAiP0lmiEK5aH6nkQkj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>