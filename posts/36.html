<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/36" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/36" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="데이터 분석 효율성을 높이는 방법 esProc SPL 종합 가이드" href="/post/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 분석 효율성을 높이는 방법 esProc SPL 종합 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 분석 효율성을 높이는 방법 esProc SPL 종합 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">데이터 분석 효율성을 높이는 방법 esProc SPL 종합 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">43<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SQL 윈도우 함수 탐구 ROW_NUMBER, RANK, DENSE_RANK 사용 방법" href="/post/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SQL 윈도우 함수 탐구 ROW_NUMBER, RANK, DENSE_RANK 사용 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SQL 윈도우 함수 탐구 ROW_NUMBER, RANK, DENSE_RANK 사용 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">SQL 윈도우 함수 탐구 ROW_NUMBER, RANK, DENSE_RANK 사용 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="DuckDB 빅데이터 업계의 떠오르는 스타" href="/post/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="DuckDB 빅데이터 업계의 떠오르는 스타" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="DuckDB 빅데이터 업계의 떠오르는 스타" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">DuckDB 빅데이터 업계의 떠오르는 스타</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">6<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="데이터 마법사를 위한 CASE WHEN 완벽 마스터 가이드 SQL 최종 안내서" href="/post/2024-06-22-TheUltimateGuidetoMasteringCASEWHENinSQLforDataWizards"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="데이터 마법사를 위한 CASE WHEN 완벽 마스터 가이드 SQL 최종 안내서" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-TheUltimateGuidetoMasteringCASEWHENinSQLforDataWizards_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="데이터 마법사를 위한 CASE WHEN 완벽 마스터 가이드 SQL 최종 안내서" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">데이터 마법사를 위한 CASE WHEN 완벽 마스터 가이드 SQL 최종 안내서</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">9<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SQL에서 임시 테이블의 강력한 기능 탐구하기" href="/post/2024-06-22-ExploringthePowerofTemporaryTablesinSQL"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SQL에서 임시 테이블의 강력한 기능 탐구하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ExploringthePowerofTemporaryTablesinSQL_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SQL에서 임시 테이블의 강력한 기능 탐구하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">SQL에서 임시 테이블의 강력한 기능 탐구하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="스트림 프로세싱 엔진과 스트리밍 데이터베이스의 차이점" href="/post/2024-06-22-DifferencesBetweenStreamProcessingEnginesandStreamingDatabases"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="스트림 프로세싱 엔진과 스트리밍 데이터베이스의 차이점" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-DifferencesBetweenStreamProcessingEnginesandStreamingDatabases_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="스트림 프로세싱 엔진과 스트리밍 데이터베이스의 차이점" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">스트림 프로세싱 엔진과 스트리밍 데이터베이스의 차이점</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">12<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="SQL에서는 쉽지만 NoSQL에서는 어려운 다대일 관계 설정 방법" href="/post/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="SQL에서는 쉽지만 NoSQL에서는 어려운 다대일 관계 설정 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="SQL에서는 쉽지만 NoSQL에서는 어려운 다대일 관계 설정 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">SQL에서는 쉽지만 NoSQL에서는 어려운 다대일 관계 설정 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">7<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="GA4 BigQuery Export 스키마와 구조 이해하기" href="/post/2024-06-22-UnderstandingtheGA4BigQueryExportSchemaandStructure"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="GA4 BigQuery Export 스키마와 구조 이해하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-UnderstandingtheGA4BigQueryExportSchemaandStructure_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="GA4 BigQuery Export 스키마와 구조 이해하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">GA4 BigQuery Export 스키마와 구조 이해하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="파이썬 Enum 모듈 완벽 가이드 마스터하기 위한 모든 것" href="/post/2024-06-22-MasterPythonEnumModuleAComprehensiveGuide"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="파이썬 Enum 모듈 완벽 가이드 마스터하기 위한 모든 것" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-MasterPythonEnumModuleAComprehensiveGuide_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="파이썬 Enum 모듈 완벽 가이드 마스터하기 위한 모든 것" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">파이썬 Enum 모듈 완벽 가이드 마스터하기 위한 모든 것</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Airflow, DuckDB, Streamlit으로 StarCraft 2 데이터 탐험하기" href="/post/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Airflow, DuckDB, Streamlit으로 StarCraft 2 데이터 탐험하기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Airflow, DuckDB, Streamlit으로 StarCraft 2 데이터 탐험하기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Airflow, DuckDB, Streamlit으로 StarCraft 2 데이터 탐험하기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 22, 2024</span><span class="PostList_reading_time__6CBMQ">27<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><button type="button" class="page_button -prev">&lt;</button><a class="link" href="/posts/21">21</a><a class="link" href="/posts/22">22</a><a class="link" href="/posts/23">23</a><a class="link" href="/posts/24">24</a><a class="link" href="/posts/25">25</a><a class="link" href="/posts/26">26</a><a class="link" href="/posts/27">27</a><a class="link" href="/posts/28">28</a><a class="link" href="/posts/29">29</a><a class="link" href="/posts/30">30</a><a class="link" href="/posts/31">31</a><a class="link" href="/posts/32">32</a><a class="link" href="/posts/33">33</a><a class="link" href="/posts/34">34</a><a class="link" href="/posts/35">35</a><a class="link posts_-active__YVJEi" href="/posts/36">36</a><a class="link" href="/posts/37">37</a><a class="link" href="/posts/38">38</a><a class="link" href="/posts/39">39</a><a class="link" href="/posts/40">40</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"데이터 분석 효율성을 높이는 방법 esProc SPL 종합 가이드","description":"","date":"2024-06-22 17:41","slug":"2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL","content":"\n\n## esProc SPL(Structured Process Language)을 통해 애플리케이션 비용을 줄이고 일반적인 데이터 분석 도전 과제를 해결하는 방법을 발견하세요\n\n![이미지](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_0.png)\n\n현재의 디지털 시대에서 데이터의 만능성은 부인될 수 없습니다. 데이터 관리의 선두주자인 SQL(Structured Query Language)이 많은 사람들에게 신뢰받는 동반자로 자리 잡고 있습니다. 그러나 효율적인 데이터 관리 영역에서 유일한 경쟁자인가요?\n\nesProc SPL(Structured Process Language)이라는 챌린저가 나타나 데이터와 상호 작용하는 방식을 혁신하겠다고 약속합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함께 참여하여 SPL의 세계를 해독하고 그 잠재적 이점을 탐험해 보세요.👇🏻\n\n# esProc SPL이란 무엇인가요?\n\n먼저, esProc SPL이 무엇인지 설명하겠습니다.\n\n구조화된 및 반구조화된 데이터의 계산 및 처리 엔진으로, esProc SPL은 분석 데이터베이스나 데이터 컴퓨팅 미들웨어로 사용될 수 있으며, 주로 오프라인 일괄 작업 및 온라인 쿼리와 같은 두 가지 데이터 분석 시나리오에 적용됩니다. 시장에서 흔히 볼 수 있는 일반적인 분석 데이터베이스와는 달리, esProc SPL은 SQL 시스템이나 NoSQL 기술(MongoDB, HBase와 같은)이 아니며, 대신 자체 생성한 SPL (Structured Process Language) 구문을 채택합니다. 이는 기존의 데이터 처리 기술과 비교하여 코딩이 간단하고 실행 효율이 높습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nesProc SPL이 해결하는 고통점은 무엇인가요?\n\nSPL은 주로 어렵게 작성하고 실행이 느리며 운영 및 유지 관리가 어려운 데이터 문제를 해결합니다. 아래에 몇 가지 예시가 있습니다.\n\n현재 많은 산업 분야에서는 배치 작업을 수행해야 하는데, 이 작업은 일반적으로 평소 업무 시간이 끝난 밤에 이루어집니다. 따라서 고정된 시간 창이 있고, 이 작업은 반드시 해당 창 안에서 완료되어야 하는데, 그렇지 않으면 정상적인 업무에 영향을 미칩니다. 그러나 업무가 축적됨에 따라 배치 작업의 압력이 커지게 됩니다. 고정된 시간 창 때문에 때로는 비즈니스와 데이터 양이 증가함에 따라 배치 작업이 해당 시간 창 내에서 완료되지 못할 수도 있습니다, 특히 월/년 말과 같은 중요한 날짜에는 더 그렇습니다.\n\n보고서를 조회할 때 항상 몇 가지 중요한 보고서가 쿼리하기 어렵고, 세 분 또는 두 분 또는 심지어 그 이상 걸리는 경우가 있습니다. 최적화를 여러 차례 시도해도 쿼리 효과가 크게 향상되지 않으면 사용자들은 화를 내게 됩니다. 가끔은 보고서를 쿼리하는 사용자 수가 증가하고, 선택한 시간 범위가 길어지면 결과를 찾기가 더욱 어려워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n업무에서는 매우 긴, 극도로 복잡한 SQL 코드를 종종 볼 수 있습니다. 이러한 코드는 N개의 계층으로 중첩되어 있을 뿐만 아니라, 문을 작성하는 데 수백 줄이 필요합니다. 이러한 코드는 작성하기 힘들 뿐만 아니라 수정하기도 불가능하며, 몇 일 후에는 프로그래머조차 헷갈릴 수 있습니다. 저장 프로시저에 대해서는 상황이 더 나빠며, 때로는 저장 프로시저의 크기가 수십 또는 수백 KB에 달하는 경우도 있어 작성하고 유지하기가 매우 어렵습니다.\n\n일부 복잡한 계산은 저장 프로시저로 작성할 수 있지만 JAVA보다 간단하지만, 저장 프로시저는 애플리케이션을 이관할 수 없으며, 이에 지나치게 의존하면 애플리케이션 프레임워크에 문제가 발생할 수 있습니다. 애플리케이션의 확장이 불가능해지거나 결합도가 높아진다는 등의 문제가 발생할 수 있습니다.\n\n현재는 다양한 종류의 데이터 소스가 있으며, 데이터베이스만해도 많은 종류가 존재합니다. 게다가 NoSQL, 텍스트, 엑셀, JSON과 같은 다른 데이터 소스도 많이 있습니다. 이러한 다양한 데이터 소스를 혼합하여 사용하려면 더 어려워집니다. 특히, 모든 데이터를 데이터베이스로 가져와야 한다면, 실시간 데이터 처리가 떨어지며 데이터베이스 공간을 차지하여 데이터베이스에 더 많은 압력을 가하게 됩니다. 반대로 데이터베이스로 가져오지 않으면, 하드 코딩을 해야 하므로 매우 어려울 수 있습니다. 결과적으로 궁지에 몰릴 수 있습니다.\n\n일반적으로 esProc SPL은 느린 일괄 작업, 느린 쿼리, 데이터베이스 압력이 높은 경우, SQL 코드 작성과 유지 보수가 어려운 경우, 다양한 데이터 소스의 혼합 계산, 불합리한 응용 프레임워크 등의 문제를 해결할 수 있는 능력을 갖추고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래에 더 많은 문제들을 나열해보겠습니다:\n\n- 시간 창 안에 맞지 않는 느린 일괄 작업은 특히 중요한 요약 날짜에 부담감을 주고 있습니다.\n- 쿼리/보고서를 위해 몇 분을 기다려야 하는 경우, 업무 인원들은 화를 내게 됩니다.\n- 더 많은 동시성, 쿼리 시간 간격이 길어질수록 데이터베이스가 크래시됩니다.\n- 수십 KB의 N-레벨 중첩 SQL 또는 저장 프로시저들은 몇 일 지나면 프로그래머 자신도 헷갈립니다.\n- RDB/NoSQL/파일/JSON/웹 등과 같은 수십 개의 데이터 원천, 원천간 혼합 계산이 매우 필요합니다.\n- 핫 데이터와 콜드 데이터를 별도의 데이터베이스로 분리하면 전체 데이터에 대한 실시간 쿼리가 어렵습니다.\n- 저장 프로시저에 너무 의존하면 응용 프로그램을 이전할 수 없으며, 프레임워크를 조정하기 어렵습니다.\n- 데이터베이스에 너무 많은 중간 테이블이 존재하여 저장소 및 자원을 고갈시키지만 그것들을 삭제하기는 무서워합니다.\n- 기업에서 끊임없는 보고서 수요가 있어, 인력 비용을 어떻게 경감할 수 있을까요?\n- …\n\n물론 esProc SPL 대상 시나리오에 대한 대응 기술들도 언제든 사용 가능합니다. 그러니, esProc SPL의 대응 기술은 무엇인가요?\n\n가장 중요한 것은 OLAP 시나리오에 적용되는 SQL 구문을 사용하는 데이터베이스와 데이터 웨어하우스입니다. 예를 들어, MySQL, PostgreSQL, Oracle, DB2 등과 같은 일반 관계형 데이터베이스; 하둡 위의 데이터 웨어하우스인 Hive, Spark SQL; Snowflake와 같은 새로운 MPP 및 클라우드 데이터 웨어하우스; Oracle의 ExaData와 같은 상용 올인원 데이터베이스 머신 등이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n개발 언어 관점에서 SPL은 Python, Scala, Java 및 Kotlin과 같은 일부 데이터 분석 및 통계 기술을 대체할 수 있습니다.\n\n상기 기술들과 비교했을 때, esProc SPL은 저 코드, 고 성능, 가벼움, 다양성의 장점을 가지고 있습니다. 특히 복잡한 계산을 구현하는 데 있어 Python 및 SQL보다 SPL이 더 간결하고 간단하며, 즉 SPL 코드가 더 짧습니다. esProc SPL은 높은 성능 알고리즘과 고성능 스토리지를 제공하여 빠르게 실행하는 것이 가능하며, 독립적으로 사용하거나 응용 프로그램에 통합하여 여러 데이터 소스에서 직접 계산할 수 있어 더 가볍고 개방적입니다. SPL은 전통적인 계산 능력뿐만 아니라 행렬, 적합 및 심지어 AI 모델링과 같은 다양한 기능을 제공하여 대부분의 데이터 작업을 쉽게 처리할 수 있어 더 다재다능합니다.\n\nSPL의 주요 대응 기술은 여전히 SQL입니다. 결국 데이터 분석 분야에서 가장 널리 사용되는 기술 중 하나입니다. 그래서 esProc SPL은 SQL 이상의 무엇을 제공할까요?\n\n현대 복잡한 비즈니스 및 빅데이터 관점에서 SQL을 살펴보면 SQL의 계산 및 설명 능력이 부족하다는 것을 알게 될 것입니다. 필요한 데이터 유형 및 계산 기능(예: 순서화 된 계산)이 부족한 SQL은 종종 복잡한 계산을 다층 중첩 및 우회적 방법으로 구현해야만 하고, 이런 방식은 두 가지 문제를 발생시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째로 개발 비용에 대해 이야기해 보겠습니다. 실무에서는 종종 천 줄이 넘는 SQL 코드를 볼 수 있습니다. 한 번 계산 로직이 약간 복잡해지면 긴 코드와 다층 중첩 코드를 작성해야 하며, 이는 쓰기와 디버깅이 어렵다는 것뿐만 아니라, 프로그래머 자신도 시간이 지난 후에 작성한 코드가 무슨 뜻인지 이해하지 못할 수 있습니다. 이는 개발 비용 증가로 이어질 수밖에 없습니다. 반면 SPL은 풍부한 데이터 유형과 계산 기능을 제공하여 계산 및 설명 능력을 크게 향상시킵니다. 더불어 좀 더 유연한 구문 시스템을 제공하는 SPL은 단계적 코딩을 지지하며, \"다단계\"의 자연스러운 사고에 따라 복잡한 계산 로직을 구현할 수 있어 쉽게 코딩하고 디버그할 수 있으며 개발 비용을 크게 줄일 수 있습니다.\n\n두 번째로 복잡한 SQL 코딩으로 인한 성능 문제에 대해 이야기해 보겠습니다. SQL로는 구현할 수 없는 효율적인 방법이 있더라도 느린 알고리즘을 사용해야 할 수 있습니다. 원하는 성능 지수를 달성하려면 추가 하드웨어를 더해야 하므로 하드웨어 비용이 증가합니다. SPL은 높은 성능 알고리즘(및 저장소)을 캡슐화하고 동일한 성능을 달성하는 데 더 적은 하드웨어가 필요하므로 하드웨어 비용이 효과적으로 감소합니다. SPL은 덜 많은 하드웨어로 SQL 성능을 달성하거나 능가하는 많은 사례를 찾을 수 있습니다.\n\nSQL(데이터베이스)의 컴퓨팅 시스템은 닫혀 있고 데이터는 데이터베이스로 로드된 후에만 계산될 수 있으며, 보통 데이터베이스를 독립적으로 배포할 수 있기 때문에 부풀어 오른 무겁고 무겁은 프레임워크로 이어질 수 있습니다. 더욱이 SQL의 컴퓨팅 능력은 실제로 불완전하며, SQL은 일부 복잡한 시나리오를 독립적으로 처리하는 데 적합하지 않기 때문에 Python, Java와 같은 다른 기술을 채용해야 합니다. 그러나 이러한 완전히 다른 기술은 기술 스택의 복잡성을 증가시킬 수 있습니다. 무겁고 부풀어 오른 프레임워크와 복잡한 기술 스택은 O\u0026M 비용을 크게 증가시킵니다. 반면 SPL은 컴퓨팅 능력에서 더 개방적이며 다양한 데이터 원본에서 직접 계산하고 독립적 또는 통합적으로 사용할 수 있습니다. 그리고 그 프레임워크가 가벼워집니다. 또한 SPL은 복잡한 계산을 쉽게 구현할 수 있도록 포괄적인 기능을 제공하며, 다른 기술 없이 대부분의 작업을 수행할 수 있습니다. 그 기술 스택은 간단하게 됩니다. 가벼운 프레임워크와 간단한 기술 스택은 O\u0026M 비용을 낮춥니다.\n\n![image](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSPL은 Java보다도 상당한 장점을 지니고 있어요. Java는 기능이 많은 프로그래밍 언어로, 이론상으로는 어떤 데이터 계산 작업도 처리할 수 있어요. 그러나 너무 네이티브한 특성과 필요한 계산 라이브러리 부족으로 모든 계산 작업을 처음부터 개발해야 하여 구현이 어렵다는 제약이 있어요.\n\n특히 고성능 알고리즘의 경우 Java에서 구현하기가 더 어려워요. 프로그래머들이 최선을 다해 문제를 해결하려고 하더라도 성능이 매우 취약해요. 그 결과 개발 비용은 높아지고 성능은 낮아지는데요. 따라서 하드웨어 비용도 증가하게 되요.\n\n또한 Java는 실제 사용에서 몇 가지 단점을 가지고 있어요. 예를 들어, 컴파일된 언어로써 핫 스왑을 달성하는 것이 어렵고, 다른 애플리케이션/모듈이 함께 주 애플리케이션과 함께 배포되어야 하는 경우 서로 강하게 결합되는 문제가 발생해요. 이러한 단점들은 자주 변경되는 데이터 분석 시나리오에 상당한 부정적 영향을 미치게 돼요. 이러한 단점을 피하기 위해 프로그래머들은 SQL과 Java를 함께 사용하곤 해요. SQL이 많은 계산에 더 간단하고 편리하기 때문이죠. 그러나 이렇게 함으로써 SQL 문제만 해결되지 않을 뿐더러 새로운 Java 문제가 발생해서 복잡한 기술 스택, 사용하기 어려움, 그리고 높은 유지보수 비용을 초래하게 되요.\n\n한편 SPL은 이러한 문제들이 없어요. SPL은 풍부한 계산 라이브러리를 제공하여 계산 작업을 쉽게 구현할 수 있으며, 성능을 보장하기 위해 많은 저복잡도 알고리즘을 제공해요. 또한 해석형 언어로, SPL은 자연스럽게 핫 스왑을 지원하고 결합 문제는 결코 발생하지 않아요. SQL과 비교하면 SPL은 Java에 비해 상당한 장점을 지니고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Table](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_2.png)\n\n파이썬에서는 구조화된 데이터 처리에 문제가 있습니다. 파이썬(Pandas)은 풍부한 연산 라이브러리를 제공하고 많은 간단한 계산에 대해 파이썬으로 쉽게 코딩할 수 있어 Python이 기본적으로 SQL과 동등하다고 할 수 있습니다. 그러나 약간 복잡한 계산에 대해 Python으로 코딩하는 것은 어렵고 개발 비용이 여전히 높습니다.\n\n또한, 파이썬은 대규모 데이터 처리에 취약합니다. 외부 저장소에 대해 커서 타입을 제공하지 않기 때문에 메모리 용량을 초과하는 데이터를 처리하는 것은 번거롭고 비효율적이며 하드웨어 비용이 증가할 수 있습니다.\n\n뿐만 아니라, 파이썬은 버전 문제를 내포하고 있습니다. 다른 버전 간의 호환성 문제로 사용 및 운영 비용이 높아지게 되며 파이썬은 통합력이 매우 떨어져 응용 프로그램에서 결합하기 어려워 별도의 서비스를 배포해야 하는 경우가 많습니다. 이로 인해 운영 및 유지보수 비용이 증가하게 됩니다. 자바와 마찬가지로 파이썬은 실무에서 종종 SQL과 함께 사용되며, 기존의 SQL 문제는 여전히 존재하면서 새로운 문제가 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 개발 및 성능 측면에서 SPL의 장점에 대해 많이 설명했습니다. 더불어 SPL은 많은 다른 이점을 갖고 있습니다: 버전 문제 없음; 우수한 통합으로 애플리케이션에 매끄럽게 통합이 가능함; 완전한 기능 제공; 간단한 기술 스택; 다른 기술에 의존할 필요 없음; 운영 및 유지보수 비용 절감.\n\n![이미지](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_3.png)\n\n전반적으로 SPL은 SQL, Java 및 Python과 비교하여 개발, 하드웨어 및 운영 및 유지보수 비용 모두에서 수십 배의 비용 절감을 이룰 수 있습니다.\n\n# 사례 소개\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 esProc SPL의 실제 응용효과입니다.\n\n먼저 두 가지 일괄 작업 사례를 살펴보겠습니다.\n\n## 보험 회사의 자동차 보험 일괄 작업\n\n이것은 보험 회사의 자동차 보험에 대한 일괄 작업 시나리오로, 사용자에게 보험 갱신을 상기시키기 위해 과거 보험을 새 보험과 관련시켜야 합니다. 데이터 양이 많아서 정책 테이블에는 3500만 개의 데이터 행, 세부 사항 테이블에는 1억 2300만 개의 데이터 행이 포함되어 있습니다. 여러 가지 연관 방법이 있기 때문에 따로 처리해야 하며, 계산이 매우 복잡합니다. 보험 회사는 원래 informix의 저장 프로시저를 사용하여 계산했으며, 30일간의 새 보험을 연관시키는 데 112분이 걸렸습니다. 시간이 더 길면 계산이 어려울 것입니다. 이로 인해 성능 문제가 발생합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nesProc SPL을 사용하면 동일한 작업을 수행하는 데 17분 만에 끝낼 수 있어요. 이는 6.5배의 증가이며 코드 양도 1800줄에서 500줄로 줄어드는 걸 확인할 수 있어요. 이전에 말했듯이, SPL을 사용하면 쉽게 코드를 작성할 수 있고 실행 속도도 더 빨라져요.\n\n사례 상세정보: 오픈소스 SPL은 보험 회사의 일괄 처리 작업 시간을 2시간에서 17분으로 최적화했어요\n\n# 은행의 대출 계약 일괄 작업\n\n이 또한 일괄 작업 시나리오에 해당돼요. 은행은 AIX 및 DB2(은행의 표준 설정)이 장착된 작은 기계에서 이 작업을 수행하며 \"기업 대출 계약 세부 정보\" 저장 프로시저를 실행하는 데 1.5시간이 걸렸어요. 이 계산에는 48개의 SQL 단계, 매우 복잡한 다중 테이블 관련 및 3300줄의 코드가 포함돼 있어요. 이 일괄 작업은 전체 은행의 일괄 작업의 일부이기 때문에 이 일괄 작업이 느리다면 전반적인 일괄 작업 프로세스를 늦추기 때문에 긴급히 최적화해야 할 필요가 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nesProc SPL을 사용하여 동일한 작업을 수행할 때는 10분만에 처리할 수 있으며, 속도를 8.5배 빠르게 하며 코드 양을 3300줄에서 500줄로 줄입니다. 속도 향상의 주된 이유는 SPL의 순서 처리와 다목적 순회와 같은 기능을 활용한 것입니다.\n\n사례 세부 정보: 오픈 소스 SPL은 은행 대출 동의의 일괄 처리 속도를 10배 이상 높입니다.\n\n이제 두 가지 온라인 쿼리 사례를 살펴보겠습니다.\n\n# 모바일 뱅킹: 다중 동시 계좌 조회\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n은행에서는 고객들에게 현재 계좌 정보를 조회할 수 있는 모바일 뱅킹을 통해 서비스를 제공하고 있습니다. 이 서비스는 대규모 동시 접속이 필요하며 실시간 처리가 요구됩니다. Hadoop은 동시 접근 요구를 충족할 수 없기 때문에, 은행은 6개 노드로 구성된 ES 클러스터를 쿼리 백엔드로 구축했습니다. 백엔드는 요구 사항을 충족하지만 실시간으로 연관을 짓지는 못하며, 지점 코드가 변경되면 데이터를 업데이트하는 데 몇 시간이 소요됩니다. 업데이트 기간 동안 서비스를 중단해야 하므로 사용자의 정상적인 조회에 영향을 줍니다.\n\nesProc SPL을 도입한 후, 상세 데이터는 계좌 번호별로 순서대로 저장됩니다. SPL의 외부 저장소 인덱스 및 정렬 기술을 이용하여 계좌 번호별 정보를 빠르게 액세스하고, 메모리에서 지점 코드와 연관시킬 수 있습니다. 이렇게 하면 실시간 조회와 실시간 연관을 구현할 뿐만 아니라 고 동시성을 처리할 수 있습니다. 마지막으로, esProc SPL은 1개 노드에 6개 ES 노드의 효과를 실현하며, 지점 정보 업데이트에 대기 시간이 없는 실시간 연관을 구현합니다.\n\n케이스 세부 정보 : 오픈 소스 SPL은 은행 모바일 계정에 대한 사전 연관 쿼리를 실시간 연관으로 변경하는 계산\n\n\n은행의 고객 중 고유 대출 클라이언트 수 계산\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n은행의 대출 업무에는 대출 잔액, 담보 유형, 고객 유형, 대출 방식 등 여러 지표가 관련되어 있습니다. 수백 가지 지표가 임의로 조합되어 쿼리되며, 따라서 계산 규모가 방대하며, 동시 쿼리 수가 증가함에 따라 계산 난이도도 증가합니다. 이 계산 시나리오에서는 2000만 행의 대형 테이블과 더 큰 상세 테이블에 대한 연관, 필터링 및 집계 계산이 필요하며, 각 페이지는 거의 200개의 지표를 계산해야 하며, 10개의 동시성은 2000개 이상의 지표를 동시 계산할 수 있습니다. 이러한 대규모 계산 규모에 대해 Oracle을 사용하여 하루 전에 계산해야 하지만, 사전 계산은 사용자의 실시간 쿼리 요구를 충족시키지 못합니다.\n\n은행이 SPL을 채용한 후에는 정렬 병합, 부울 차원 순서, 멀티 스레드 병렬 컴퓨팅 등을 통해 지표의 계산이 실시간으로 구현되어 성능 요구 사항이 충족되며, 총 2000개 지표와 10개의 동시성에 대한 계산 시간이 3초 미만이 됩니다. 데이터를 미리 준비할 필요가 없으며 어떤 레이블 조합도 즉시 선택할 수 있고 실시간으로 쿼리 결과를 얻을 수 있습니다.\n\n사례 세부 정보: 오픈 소스 SPL은 은행 사전 계산 고정 쿼리를 실시간 유연한 쿼리로 최적화합니다.\n\n오프라인 배치 작업과 온라인 쿼리 사이에는 큰 차이가 있습니다. 전자는 종종 많은 양의 데이터와 매우 복잡한 계산 로직이 포함되지만 동시성 쿼리가 관련되지 않으며 실시간 계산이 필요하지 않습니다. 지정된 시간 내에 계산을 완료하면 됩니다. 후자는 그 반대로, 대량의 동시성 숫자가 관련되며 높은 실시간성이 필요하며 처리하기가 어려울 수 있습니다. esProc SPL은 두 시나리오에 모두 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사실, 개발 효율성과 성능 외에도 esProc SPL은 응용 프레임워크 측면에서도 효과적으로 작동합니다. 아래에 두 가지 관련 사례가 있습니다.\n\n# 은행의 BI 시스템에서의 프런트 엔드 데이터베이스\n\n이 은행은 중앙 데이터 웨어하우스를 보유하고 있습니다. 이 웨어하우스는 전체 은행의 모든 데이터 작업을 담당하며, 오버로드되었기 때문에 BI 시스템에 5개의 동시성을 할당하지만 여전히 요구 사항을 충족시키지 못합니다.\n\n이 문제를 해결하기 위해 BI 시스템을 위한 전용 프런트 엔드 데이터베이스(은행에서는 프런트 엔드 머신이라고 부릅니다)를 구축해야 합니다. 그러나 데이터베이스를 구축할 때 문제가 발생합니다. 즉, 데이터 웨어하우스에서 고빈도 데이터만 데이터베이스로 가져오면 다른 데이터를 조회할 수 없어 비즈니스 요구 사항에 대응할 수 없습니다. 데이터를 모두 데이터베이스로 가져오면 비현실적(너무 비용이 많이든다)이며 이는 사실상 데이터 웨어하우스를 재구축하는 것과 같습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nesProc SPL을 사용하여 프런트엔드 머신을 구축할 때는 고빈도 데이터만 프런트엔드 머신으로 가져오면 되므로 반복적인 구성을 피할 수 있습니다. esProc은 가장 높은 빈도로 발생하는 데이터 계산 작업을 처리하며, 몇 가지 낮은 빈도의 데이터 계산 작업은 자동으로 중앙 데이터 웨어하우스로 라우팅되어 앞서 언급한 두 가지 문제가 해결됩니다. 이러한 자동 라우팅 기능은 여기서 핵심 역할을 합니다.\n\n# 보험 회사 - 외부 데이터베이스 저장 프로시저\n\n이 경우는 esProc SPL을 Vertica 저장 프로시저로 사용하는 것입니다. 캐나다 보험 회사인 고객이 Vertica, MySQL, Access와 같은 데이터베이스에서 겪는 주요 문제는 두 가지입니다. 하나는 Vertica가 저장 프로시저를 지원하지 않기 때문에 복잡한 계산을 실행해야 하는 경우 Java 하드코딩을 통해 구현해야 하며, 이는 매우 어렵습니다. 또 다른 하나는 여러 데이터 소스의 혼합 계산에 관련된 경우 MySQL과 같은 데이터를 먼저 Vertica로 로드해야 하는데, 이는 장황하고 실시간이 아니며, 로딩 후 데이터베이스가 부풀어 오르며, 결국 일부 데이터는 영구 저장할 필요가 없습니다.\n\nesProc SPL로 이러한 두 가지 문제를 해결할 수 있습니다. 먼저 Vertica 외부 저장 프로시저로 작용하면서 esProc은 원래 하드 코딩이 필요한 모든 계산을 맡아 처리하므로 구현이 단순해지며 더 효율적입니다. 둘째, esProc SPL의 다중 소스 계산 능력을 통해 다양한 데이터 소스에서 직접 혼합 계산을 수행하여 모든 데이터를 하나의 데이터베이스로 로드할 필요가 없게 되어 데이터가 실시간이 되고 효율이 높아지며, Vertica를 가볍게 유지할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예시들을 통해 esProc SPL의 적용 가능한 시나리오와 효과에 대해 기본적으로 이해했습니다. 물론 여기서는 주어지지 않은 더 많은 케이스들이 있습니다.\n\n# 왜 esProc SPL이 더 잘 작동하는가\n\n위의 예시들에서 우리는 코드 효율성과 컴퓨팅 성능 측면에서 SPL이 SQL보다 명확한 장점을 가지고 있다는 것을 확인할 수 있습니다. 왜 그럴까요? SPL에는 특별한 점이 있나요?\n\n하지만, 질문은 오히려 다른 방향에서 물어봐야 합니다. 즉, SQL이 잘 작동하지 않는 이유는 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQL로 작성하는 것이 어려운 이유를 설명하는 예제부터 시작해 보겠습니다: 주식이 최대 연속 상승을 유지하는 일 수를 계산해 보겠습니다.\n\n```js\nSELECT MAX(ContinuousDays)\nFROM (SELECT COUNT(*) ContinuousDays\n    FROM (SELECT SUM(UpDownTag) OVER ( ORDER BY TradeDate) NoRisingDays\n            FROM (SELECT TradeDate,\n                    CASE WHEN Price\u003eLAG(price) OVER ( ORDER BY TradeDate)\n                        THEN 0 ELSE 1 END UpDownTag\n                FROM Stock ) )\n        GROUP BY NoRisingDays )\n```\n\nSQL은 네 단계로 중첩된 코드를 채택하고 있어서 전반적으로 더 복잡합니다. 이 문제는 저희 회사의 채용 시험 문제로 사용되었었는데, 합격률은 20% 미만이었습니다. 이 문제가 너무 어려웠기 때문에 우리는 수정했습니다: 명령문을 제공하고 목적을 찾도록 요청했지만, 아쉽게도 합격률은 여전히 높지 않았습니다. 이것이 우리에게 말해주는 것은 무엇일까요? 복잡한 계산 로직이 조금이라도 어려워지면, SQL을 이해하고 작성하기 어려워진다는 것을 말해줍니다!\n\n사실, 이 문제는 자연스러운 사고를 따라 간단한 단계로 쉽게 해결할 수 있습니다: i) 거래일별로 레코드를 정렬하기; ii) 연속 상승과 하락의 간격을 얻기; iii) 최대 연속 상승 간격의 일 수를 세기. 그러나 SQL은 순서화된 작업을 충분히 지원하지 않으며 순서화된 그룹핑을 직접 제공하지 않기 때문에 다중 중첩 및 우회적인 방식을 사용해야 하며, 결과적으로 SQL 코드를 이해하고 작성하는 데 어려움을 겪게 됩니다. 이 계산 문제는 드문 문제가 아니며, 현실에서 더 복잡한 계산이 많이 있으며, 수천 줄이 넘는 SQL 코드들이 정확히 이러한 문제를 해결하기 위해 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 빠른 실행이 어려운 이유를 설명하는 또 다른 예제를 살펴보겠습니다: 1억 개의 데이터 행 중 상위 10개 가져오기.\n\n```js\nSELECT TOP 10 * FROM Orders ORDER BY Amount DESC\n```\n\n이 코드가 복잡하지 않지만 ORDER BY 키워드가 포함되어 있어 모든 데이터에 대한 대규모 정렬을 먼저 수행하고 TOP 10을 가져오게 됩니다. 대규모 정렬은 메모리와 외부 저장소 간의 여러 번의 교환을 수반하기 때문에 매우 느립니다. 이 문은 얕은 의미에 따라 실행된다면 효율성이 매우 낮을 것입니다. 사실 완전한 정렬 없이 훨씬 빠른 방법이 있습니다. 단지 10개의 가장 큰 수를 포함하는 집합을 유지하면 되며 데이터를 한 번만 통과하여 결과를 얻을 수 있습니다. 그러나 SQL은 이러한 알고리즘을 설명할 수 없습니다. 이 경우 데이터베이스의 옵티마이저만 의존할 수 있습니다. 간단한 계산의 경우 대부분의 데이터베이스가 실제로 최적화할 수 있으며 완전한 정렬을 수행하지 않아 빠르게 계산할 수 있습니다. 그러나 계산이 복잡해지면 최적화 엔진은 혼란스러워지고 느린 알고리즘을 실행해야 합니다. 예를 들어 다음 코드는 그룹 내 상위 10개를 가져오기 위한 것입니다:\n\n```js\nSELECT * FROM (\n      SELECT *, ROW_NUMBER() OVER (PARTITION BY Area ORDER BY Amount DESC) rn \n      FROM Orders ) \nWHERE rn\u003c=10\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 SQL 코드와 이전 것 사이에는 큰 차이가 있어요. 이 코드는 서브쿼리와 윈도우 함수를 사용하여 간접적인 방법으로 계산을 구현해야 합니다. 이러한 복잡한 계산을 위해 데이터베이스의 최적화 엔진이 최적화할 수 없어 정렬을 수행해야 하므로 매우 느립니다. 실제 테스트에서 Oracle에서 그룹화된 하위 집합의 TopN을 계산하는 것이 전체 집합의 TopN을 계산하는 것보다 21배 느리다는 것을 발견했습니다. 우리는 그룹 내 TopN을 계산할 때 성능이 약간만 떨어져야 하는 것으로 생각했지만, 실제 결과는 우리가 기대한 것과는 거리가 멀었습니다. 따라서 Oracle은 아마도 그룹 내 TopN을 계산할 때 정렬을 수행하여 성능이 급격히 저하되었을 것으로 생각되며, 이로 인해 옵티마이저가 실패한 것입니다.\n\n그렇다면 SPL은 이를 어떻게 해결할까요?\n\n첫 번째 예제에 대한 해결책은 다음과 같습니다:\n\n```js\nStock.sort(TradeDate).group@i(Price\u003cPrice[-1]).max(~.len())\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSPL은 순서대로 그룹화를 제공합니다. 구현 아이디어는 이전 SQL 코드와 같지만 매우 간결하게 표현됩니다.\n\n두 번째 예제의 경우:\n\n![이미지](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_4.png)\n\nSPL은 TopN을 세트를 반환하는 집계 연산으로 간주하여 전체 정렬을 피합니다. 전체 집합 또는 그룹화된 하위 집합의 경우 구문이 유사하며 우회적인 접근이 필요하지 않습니다. 대부분의 경우, 간단하게 작성하면 빠르게 실행됩니다. 코드를 간단하게 작성하면 빠르게 실행되고, 반대로 코드를 지나치게 복잡하게 작성하면 빠르게 실행되지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 유사성을 찾아서 1+2+3+...+100을 계산해보자. 일반 사람들은 가장 흔한 방법을 선택할 것이다. 즉, 1+2=3, 3+3=6, 6+4=10...; 반면에 가우스는 1+100=101, 2+99=101..., 50+51=101로 발견하고 총 50개의 같은 합(101)이 있음을 발견했고 이를 통해 50에 101을 곱해서 결과를 빠르게 구할 수 있었다. 우리가 초등학교에서 이를 읽은 적이 있기 때문에 이 이야기가 누구에게나 새로운 것은 아닐 것이다. 우리는 가우스가 이처럼 뛰어난 해결책을 떠올렸다고 생각하지만, 우리는 하나의 사실을 넘어가는 것이 쉽다는 것을 잊기 쉽다: 가우스 시대에는 이미 곱셈이 존재했다. 우리는 곱셈이 덧셈보다 나중에 만들어진 것을 알고 있으며 곱셈이 그 시대에 발명되지 않았다면 가우스가 얼마나 똑똑하더라도 이 문제를 해결할 방법을 이렇게 빨리 찾을 수 없었을 것이다. 이제 우리 주제로 돌아와 SQL은 덧셈만 있는 산술체계와 같다. 연속적인 덧셈 문제를 해결하고 싶다면 하나씩 더해야 하므로 코드가 길어지고 효율적인 계산이 이루어지지 않는다. 반면에 SPL은 곱셈의 발명과 같이, 코드를 단순화하고 성능을 향상시키는 기술로 볼 수 있다.\n\nSQL의 어려움은 관계 대수에서 비롯된다. 이러한 이론적 결함은 공학적인 방법으로 해결할 수 없다. SPL은 \"이산 데이터셋 모델\"에 기초하고 있으며 더 풍부한 데이터 유형 및 기본 연산을 제공하므로 보다 강력한 표현 능력이 있다.\n\n이 말은 가우스만큼 똑똑한 프로그래머만이 SPL을 사용할 수 있는 것을 의미합니까?\n\n사실은 그렇지 않습니다. SPL은 일반 프로그래머들을 위해 만들어진 것이며 대부분의 경우, 자연스러운 사고를 따르기만 하면 올바른 코드를 작성할 수 있습니다. 반면에 SQL을 사용하면 계산이 다소 복잡해지면 우회적인 방법으로 구현해야 할 때가 많아서 숙련된 프로그래머가 아니라면 해결하기 어려울 수 있습니다. 이 의미에서 SPL은 SQL보다 간단합니다. 그러나 SPL을 마스터하고 싶다면 더 배워야 합니다. 걱정 마세요, SPL 관련 지식에 대해 이미 어느 정도 배운 것이 있습니다. 나머지를 모르는 것은 똑똑한 프로그래머가 이미 지식 포인트(많지 않음)를 요약했기 때문에 그것들을 배우기만 하면 됩니다. 이러한 지식을 마스터하면 복잡한 문제를 손쉽게 해결할 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제로 SQL로 처리할 수 없는 많은 시나리오가 있습니다. 몇 가지 예제를 살펴보겠습니다:\n\n전자 상거래 분야의 사용자 행동 변환을 위한 퍈널 분석에서는 각 이벤트(페이지 브라우징, 검색, 장바구니에 담기, 주문하기 및 결제) 후의 사용자 이탈률을 계산해야 합니다. 이 분석은 이러한 이벤트가 특정 시간 창 안에서 완료되고 특정 순서로 발생할 때에만 효과적입니다. SQL에서 이러한 복잡한 순서 관련 계산을 설명하는 것은 번거롭습니다. 코드를 작성해도 효율적이지 않을 뿐더러 최적화하는 일은 훨씬 어렵습니다.\n\n상기 언급한 복잡한 다단계 배치 잡 케이스에서는 대용량 데이터에서 일부 복잡한 절차를 커서(커서)의 도움으로 수행해야 합니다. 그러나 커서를 읽는 것은 느리며 병렬로 계산할 수 없어 컴퓨팅 자원이 낭비됩니다. 다단계 절차적 계산 중에는 중간 결과를 반복해서 버퍼링해야 하며 지정된 시간 창 내에 배치 잡을 완료하지 못하는 매우 낮은 효율성과 실패를 초래합니다.\n\n대용량 데이터에서 다중 인덱스 계산을 수행할 때 한 번에 수백 개의 인덱스를 계산하고 상세 데이터를 여러 차례 사용해야하며 연관이 또한 관련될 때, SQL에서는 데이터를 반복적으로 탐색해야 합니다. 큰 테이블 연관, 조건 필터링, 그룹화 및 집계, 중복 제거 등의 혼합 계산이 포함되며 높은 동시성으로 실시간 계산도 필요합니다. 이러한 계산을 SQL에서 구현하는 것은 어려운 일입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n…\n\n여유 공간의 제한 때문에 전자 상거래 퍈널 계산을 위한 SQL 코드만 아래에 제시되었습니다. 코드를 보시면 복잡성을 느끼실 수 있을 겁니다.\n\n```js\nwith e1 as (\n select uid,1 as step1,min(etime) as t1\n from event\n where etime\u003e= to_date('2021-01-10') and etime\u003cto_date('2021-01-25')\n and eventtype='eventtype1' and …\n group by 1),\ne2 as (\n select uid,1 as step2,min(e1.t1) as t1,min(e2.etime) as t2\n from event as e2\n inner join e1 on e2.uid = e1.uid\n where e2.etime\u003e= to_date('2021-01-10') and e2.etime\u003cto_date('2021-01-25')\n and e2.etime \u003e t1 and e2.etime \u003c t1 + 7\n and eventtype='eventtype2' and …\n group by 1),\ne3 as (\n select uid,1 as step3,min(e2.t1) as t1,min(e3.etime) as t3\n from event as e3\n inner join e2 on e3.uid = e2.uid\n where e3.etime\u003e= to_date('2021-01-10') and e3.etime\u003cto_date('2021-01-25')\n and e3.etime \u003e t2 and e3.etime \u003c t1 + 7\n and eventtype='eventtype3' and …\n group by 1)\nselect\n sum(step1) as step1,\n sum(step2) as step2,\n sum(step3) as step3\nfrom\n e1\n left join e2 on e1.uid = e2.uid\n left join e3 on e2.uid = e3.uid\n```\n\n이것은 세 단계의 퍼널 계산입니다. SQL은 순서와 관련된 계산을 부족하게 가지고 있으며 완전히 집합 지향적이지 않습니다. 여러 하위 쿼리로 우회하고 반복적으로 JOIN해야하는 등 쓰기와 이해하기 어렵고, 성능이 낮으며 최적화하기 어렵습니다. 여기에는 세 단계 퍼널만 제시되었지만 더 많은 단계가 필요한 경우 더 많은 서브쿼리를 추가해야 하므로 난이도가 높아집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대조적으로, SPL 코드는 훨씬 간단합니다:\n\n![이미지](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_5.png)\n\nSPL은 주문 관련 계산을 제공하며 보다 체계적인 집합 중심적입니다. 코드는 자연스러운 생각에 따라 직접 작성되어 간단하고 효율적입니다. 또한, 이 코드는 단계 수에 상관없이 퍼널을 처리할 수 있으며 수정해야 하는 것은 매개변수 뿐입니다.\n\n이것은 단순화된 실제 사례입니다 (원래 SQL 코드는 거의 200줄이 있었습니다). 사용자는 Snowflake의 중간 서버(4*8=32코어와 동등)에서 3분 후에 결과를 얻지 못했지만, 12코어, 1.7G 저사양 서버에서 SPL 코드를 실행하여 20초 미만에 결과를 얻었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 언급했듯이, SPL은 덧셈을 기반으로 한 곱셈의 발명과 동등하며 사실, SPL은 여러 \"곱셈\"을 만들어 냅니다. 아래에는 SPL의 고성능 알고리즘 중 일부가 나와 있으며, 그 중 많은 알고리즘은 SPL의 독자적인 발명품입니다.\n\n![이미지](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_6.png)\n\n예를 들어, 다목적 순회 알고리즘은 한 번의 순회로 여러 작업의 효과를 달성할 수 있으며, 포인터로 사용되는 외래 키는 외래 키 필드를 외래 키가 가리키는 레코드의 주소로 매핑하여 이 레코드를 다시 사용할 때 더 효율적으로 만들어 줍니다. 더블 증분 분할은 급격히 확장되는 데이터 규모에 적응하여 데이터를 저장하고 액세스하는 데 매우 효율적으로 만들어 줍니다.\n\n더 많은 정보: [성능 최적화 — 서문](링크)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면, Java도 잘 작동하지 않는 이유는 무엇인가요?\n\n이전에 언급했듯이, Java는 너무 원시적이며 필요한 데이터 유형과 계산 라이브러리가 부족하기 때문에 모든 계산 작업을 처음부터 해야 하며 이는 매우 번거롭습니다. 예를 들어, Java에서 그룹화 및 집계 작업을 구현하려면 10줄 이상의 코드가 필요합니다. Java 8의 Stream이 이러한 유형의 작업을 어느 정도 단순화하지만 약간 복잡한 계산에 대해 여전히 구현하기가 매우 어렵습니다(SQL과 비교하면 큰 차이가 있음).\n\nJava에서는 성능 요구 사항이 높은 계산을 위해 코드를 작성하는 것이 더 어렵습니다. 예를 들어, 큰 정렬 알고리즘을 사용하지 않는 TopN 작업, 더 효율적인 HASH 조인 알고리즘, 정렬 병합 알고리즘 등이 있습니다. 이러한 알고리즘 자체를 구현하는 것이 어렵고 Java는 계산 라이브러리가 부족하기 때문에 많은 응용 프로그래머들이 이를 어떻게 해결해야 하는지 알지 못하고 상대적으로 간단하지만 느린 알고리즘을 사용해야 합니다. 결과적으로, 계산 속도는 SQL보다 느리고 이러한 문제를 해결하는 것조차 어렵습니다.\n\n큰 데이터를 처리하는 성능은 대부분 데이터 IO와 관련이 있습니다. IO 비용이 너무 높으면 연산 속도가 빨라도 작동하지 않습니다. 효율적인 IO는 주로 특별히 최적화된 저장 체계에 의존합니다. 그러나 안타깝게도 Java는 널리 사용되는 효율적인 저장 체계가 없으며 일반적으로 텍스트 파일이나 데이터베이스를 사용하여 데이터를 저장합니다. 데이터베이스 인터페이스의 성능은 매우 나쁩니다. 텍스트 파일은 약간 나아지지만 데이터 유형을 구문 분석하는 데 너무 많은 시간이 소요되어 성능이 낮아집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 실제로 Java의 단점이 고려된다면, 핫 스왑이 어렵고 강한 결합력 등 Java는 이전 문제를 해결하기 위해 SQL을 넘어설 수도 없는 상태에 미치지 못할 것입니다.\n\n그렇다면 왜 Python은 여전히 잘 작동하지 못하나요?\n\nJava를 분석하면 Python의 많은 단점이 유사하다는 것을 기본적으로 알 수 있습니다. 예를 들어, 인접 참조, 정렬된 그룹화, 위치 계산, 비등치 그룹화와 같이 비교적 복잡한 계산을 구현하기 어렵다는 것입니다.\n\n외부 저장 처리 메커니즘 없이 대용량 데이터 처리를 위해 Python에서 구현하는 것은 매우 어려울 것입니다. 게다가 Python은 진정한 병렬 처리를 지원하지 않습니다. Python 자체의 병렬 처리는 사실상 가짜로, 실제로는 CPU에 대한 직렬 처리이거나 직렬 처리보다 더 느리기 때문에 현대 멀티 코어 CPU의 장점을 활용하기 어려울 수 있습니다. Python의 주요 인터프리터인 CPython 인터프리터에는 Global Interpreter Lock이 있습니다. 이 잠금은 Python 코드를 실행하기 전에 얻어야 하며, 즉 여러 CPU 스레드가 동시에 작업하는 경우에도 하나의 스레드만 코드를 실행하고 여러 스레드는 번갈아가며 코드를 실행할 수밖에 없습니다. 그러나 여러 스레드 실행은 문맥 전환 및 잠금 메커니즘 처리와 같은 복잡한 트랜잭션을 포함하므로 성능은 향상되지 않고 오히려 감소됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬은 한 프로세스에서 간단한 멀티스레드 병렬 처리 메커니즘을 활용할 수 없어, 많은 프로그래머들이 복잡한 멀티프로세스 병렬 처리 방법을 채택해야 합니다. 프로세스 자체의 비용과 관리가 훨씬 더 복잡하며, 병렬 처리의 효과는 여러 스레드보다 비교할 수 없이 낮습니다. 게다가 프로세스 간 통신 또한 매우 복잡합니다. 때로는 직접 통신을 포기하고 집계 결과를 전달하기 위해 파일 시스템을 사용해야 하며, 이는 상당한 성능 저하로 이어집니다.\n\n자바와 같이, 파이썬은 고성능 컴퓨팅을 위한 효율적인 저장 체계를 제공하지 않아, 오픈 포맷 파일이나 데이터베이스를 사용해야 하므로 성능이 낮아집니다. 많은 경우 파이썬은 SQL과 함께 사용되지만, SQL의 문제를 해결하지 못합니다. 파이썬의 버전 및 통합 등의 문제를 고려한다면, 파이썬이 실제로 작동하지 않는다는 결론에 도달할 수 있습니다.\n\n# 기술적 특성\n\n위에서 언급한대로, esProc SPL에서 코딩이 간단하고 실행이 빠른 이유를 설명했습니다. 즉, SPL의 저 코드 및 고 성능입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금 esProc SPL의 기술적 특성을 좀 더 자세히 살펴보겠습니다.\n\n![이미지](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_7.png)\n\n현재 esProc는 순수한 Java로 개발된 소프트웨어이며 JDK1.8 이상 버전의 JVM 환경에서 모든 운영 체제에서 실행할 수 있습니다. 일반적인 VM 및 컨테이너를 포함합니다.\n\n일반적인 설치 후 esProc는 1G 미만의 공간을 차지하며, 대부분은 참조된 타사 외부 데이터 소스 드라이버 패키지가 차지합니다. esProc의 핵심 패키지는 15M 미만으로 Android에서도 실행할 수 있게 만들어 줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nJVM을 제외하고 esProc은 운영 환경에 대한 다른 엄격한 요구 사항이 없습니다. 하드 디스크 및 메모리 용량 요구 사항은 컴퓨팅 작업과 관련되어 있으며 다양한 작업에 따라 크게 달라질 수 있습니다. 동일한 컴퓨팅 작업을 수행할 때, esProc은 일반 데이터베이스보다 적은 하드웨어 자원을 요구하는 경우가 많습니다 (특히 분산 데이터베이스의 경우). 메모리 용량을 늘리고, 더 높은 주파수와 코어 수를 가진 CPU를 선택하며, SSD를 활용하면 컴퓨팅 성능 향상에 긍정적인 영향을 미칠 수 있습니다.\n\n![Image](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_8.png)\n\n프레임워크 가장 왼쪽에는 업무 데이터베이스와 전통적인 데이터 웨어하우스(있는 경우)가 있습니다. 실제로 다양한 유형의 데이터 소스가 있을 수 있으며, 이러한 데이터를 \"데이터 응고\"를 통해 esProc의 고성능 파일 저장소로 변환하여 더 높은 성능을 달성할 수 있습니다.\n\n물론, 데이터 변환은 필수적이지 않습니다. 더 높은 데이터 실시간성이 필요한 시나리오의 경우, esProc은 데이터 소스가 제공하는 인터페이스(예: JDBC)를 통해 데이터를 실시간으로 읽고 계산할 수 있습니다. 그러나 esProc이 데이터 인터페이스의 성능에 개입할 수 없기 때문에, 서로 다른 데이터 소스에 대해 다른 컴퓨팅 성능이 발생할 수 있으며 성능 저하도 발생할 수 있습니다. 사용자가 실시간성과 컴퓨팅 성능 모두에 요구 사항이 있는 경우, 데이터 소스의 핫 데이터를 읽어 고정되지 않은 과거의 콜드 데이터를 esProc의 고성능 저장소로 변환하여 모든 데이터를 esProc의 혼합 컴퓨팅 능력을 활용하여 동시에 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nesProc의 고성능 파일 저장소에 대해 아래에서 자세히 소개하겠습니다.\n\n프레임워크 중간 부분에는 실제 데이터 처리를 담당하는 esProc Server가 있습니다. esProc Server를 사용하면 분산 방식으로 여러 노드를 배치하여 클러스터 컴퓨팅을 지원하며, 부하 분산 및 오류 허용 메커니즘을 지원합니다. esProc의 클러스터 크기는 비교적 작으며(32개 노드 이하), 리소스가 계산용(관리 및 스케줄링이 아님)으로 사용됩니다. 많은 경우에 구현된 것처럼 esProc는 기존 기술(MPP/HADOOP)의 클러스터 컴퓨팅 시나리오를 단일 노드를 통해 처리하며 성능이 더 우수하여 계산 능력이 부족할 걱정이 없습니다.\n\nesProc의 SPL 스크립트는 각 클러스터 노드에 배포되며, 스크립트는 esProc의 IDE에서 원격으로 개발 및 디버깅할 수 있으며 디버깅 중에 데이터는 로컬 노드로 저장되거나 다운로드되지 않으므로 보안상 더 안전합니다.\n\nesProc은 JDBC/RESTful와 같은 표준 인터페이스를 캡슐화하여 애플리케이션에서 호출할 수 있습니다. Java 애플리케이션의 경우 esProc는 직접 통합되어 애플리케이션 내부에서 계산 엔진으로 사용될 수 있습니다. Java가 아닌 애플리케이션의 경우 다른 인터페이스를 통해 esProc를 호출할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전체 프레임워크 관점에서 보면, esProc은 간단하고 효율적인 데이터 처리 능력을 제공하는 것에 더해, 독립적으로 또는 통합하여 사용할 수 있는 유연성이 뛰어납니다. 더불어 비교적 가벼운 연산 방식으로 esProc은 가벼운 사용감을 제공하며, 전통적인 분산 기술처럼 무겁지 않습니다.\n\n개발 및 디버깅 측면에서 esProc SPL은 간단하고 쉽게 사용할 수 있는 개발 환경을 제공합니다.\n\n![image](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_9.png)\n\nIDE에서는 단계별로 코드를 작성하고, 오른쪽에 있는 결과 패널에서 각 단계의 실행 결과를 실시간으로 확인할 수 있습니다. 또한 디버그, 스텝인, 중단점 설정 등 다양한 편집 및 디버깅 기능이 있습니다. 사용하기 쉬운 편집 및 디버깅 기능은 저코딩을 위해 꼭 필요하며, SQL (및 저장 프로시저)과는 매우 다르며 개발 비용을 크게 절감할 수 있습니다. 이러한 기능들로 esProc SPL은 데스크탑 분석에 자주 사용되며 매우 편리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSPL은 특별히 설계된 구문 시스템으로, 점진적 계산을 자연스럽게 지원하며 복잡한 프로세스 작업에 특히 적합합니다. 또한 SPL은 SQL보다 루프, 분기, 프로시저, 서브프로그램과 같은 보다 완전한 프로그래밍 능력을 자랑합니다. 각 작업 단계에서 SPL은 변수를 정의하지 않고 이전 단계의 결과를 셀 이름으로 참조할 수 있습니다 (물론 변수도 지원됩니다).\n\n![Image](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_10.png)\n\n게다가, SPL은 매우 다양한 구조화된 데이터 계산 라이브러리를 제공하여 문자열, 날짜 및 시간 처리, 수학적 계산, 파일 및 데이터베이스 읽기/쓰기, JSON/XML 다층 데이터 지원, 그룹화/루프/정렬/필터링/연관/집합/순서 있는 계산을 수행할 수 있습니다. 특히 시퀀스(테이블 시퀀스)를 위해 제공된 루프 함수는 집합 연산을 크게 단순화할 수 있습니다. SPL은 또한 대량 데이터 계산을 위한 커서, 하드 디스크 반복 탐색을 줄이는 채널, 병렬 및 분산 컴퓨팅 메커니즘을 제공합니다. 뿐만 아니라, SPL은 AI를 위한 모델링 및 예측 함수와 MongoDB, Elasticsearch, HBase, HDFS, Influxdb 등 수십 가지 데이터 소스를 위한 외부 라이브러리 함수를 제공합니다.\n\n현재 SPL은 400개 이상의 함수를 제공하며 각 함수에는 여러 옵션이 포함되어 있습니다. 이는 수천 개의 라이브러리 함수에 해당합니다. 이러한 함수들은 프로시저, 루프, 분기와 같은 완벽한 프로그래밍 언어 함수와 함께, SPL이 다양한 데이터 처리 작업을 수행할 수 있도록 합니다. 이는 SPL의 다재다능성 특징의 전형적인 표현입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nesProc SPL은 매우 높은 통합성을 자랑합니다. Java로 개발된 SPL은 독립적으로 실행되거나 응용 프로그램에 심층적으로 통합되어 인애플리케이션 컴퓨팅 엔진으로 작동할 수 있으며, 마이크로 서비스, 엣지 컴퓨팅, 보고서 데이터 준비와 같은 시나리오에서 중요한 역할을 수행할 수 있습니다.\n\n[이미지](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_11.png)\n\n뛰어난 통합성은 가벼운 특징을 반영합니다. esProc SPL은 항상 독립된 서버가 필요하지 않습니다(데이터베이스와는 매우 다름), 대신 JAR 파일을 임베딩하는 것만으로 응용 프로그램에 강력한 컴퓨팅 성능을 제공할 수 있습니다. 게다가 JAR 파일은 수십 메가바이트 크기만으로 매우 작고 가벼우며, 언제 어디서든 사용할 수 있습니다. 심지어 Android 폰에서도 실행할 수 있습니다.\n\nesProc SPL은 수십 가지 데이터 소스를 지원하며 혼합 컴퓨팅 능력을 자랑합니다. 다수의 데이터 소스를 데이터베이스에 데이터를로드하지 않고 직접 계산할 수 있습니다. 실시간 데이터 처리 뿐만 아니라 다양한 데이터 소스의 장점을 완전히 유지할 수 있습니다. 예를 들어, RDB는 계산 능력이 뛰어나지만 IO 효율이 낮습니다. RDB에 일부 계산을 수행한 후 SPL이 나머지 계산을 수행하게 할 수 있습니다. MongoDB는 동적 다층 데이터를 저장하기에 적합하며, SPL을 사용하여 다층 데이터를 직접 처리할 수 있습니다. 파일 시스템은 읽기 및 쓰기 효율이 더 높을 뿐만 아니라 사용이 더 유연합니다. SPL은 파일을 기반으로 직접 계산할 수 있고, 병렬 컴퓨팅의 효과를 최대로 발휘할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_12.png)\n\nesProc SPL은 여러 데이터 소스를 지원하여 그 유연성을 한 번 더 보여줍니다. 또한, esProc SPL에 메타데이터가 없기 때문에 여러 데이터 소스에 직접 액세스할 수 있고 혼합 계산도 수행할 수 있으며, 따라서 esProc SPL은 가벼워졌습니다. 이는 한 번 더 그 가벼운 특성을 보여주는 것입니다.\n\n현재, esProc SPL은 다음과 같은 데이터 유형을 처리할 수 있습니다:\n\n- 구조화된 텍스트: txt/csv\n- 일반 텍스트, 문자열 분석\n- 엑셀 파일의 데이터\n- 다층 구조의 텍스트: json, xml\n- 구조화된 데이터: 관계형 데이터베이스\n- 다층 구조 데이터: bson\n- KV 유형 데이터: NoSQL\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특히 esProc은 json 및 xml과 같은 다층 구조 데이터를 강력하게 지원하여 전통적인 데이터베이스를 크게 능가합니다. 따라서 esProc은 mongodb와 kafka와 같은 json과 유사한 데이터 소스와 잘 작동하며, HTTP/Restful 및 마이크로서비스와 데이터를 쉽게 교환하고 계산 서비스를 제공할 수 있습니다.\n\n또한, esProc은 Excel 파일에서 데이터를 쉽게 계산할 수 있습니다. 그러나 esProc은 Excel의 형식 처리에 능숙하지 않으며, 이미지, 오디오 및 비디오와 같은 데이터 처리도 잘하지 못합니다.\n\n뿐만 아니라, esProc SPL은 자체 효율적인 데이터 파일 저장을 제공합니다. 개인 데이터 형식은 높은 성능뿐만 아니라 비즈니스 범주별로 데이터를 파일 시스템 트리 디렉토리에 저장할 수 있도록 합니다.\n\n현재 SPL은 bin 파일 및 복합 테이블 두 가지 파일 저장 형식을 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBin 파일은 기본적인 이진 데이터 형식으로, 압축 기술을 채택하여 공간 점유도가 낮고 빠른 읽기를 제공합니다. 데이터 타입을 저장하여 데이터 형식을 구문 분석할 필요가 없어 더 빠른 읽기가 가능하며, 증가형 분할 메커니즘을 지원하여 데이터를 추가할 수 있어 병렬 컴퓨팅을 통한 구분 전략을 구현하기 매우 쉽습니다. 이를 통해 컴퓨팅 성능을 향상시킬 수 있습니다.\n\n복합 테이블은 더 복잡한 저장 구조를 제공합니다. 특히 혼합 행 방식 및 열 방식 저장을 지원하며, 정렬된 저장이 압축률과 위치 지정 성능을 향상시킵니다. 더 효율적인 지능형 인덱스를 지원하며, 기본 테이블 및 하위 테이블의 통합을 지원하여 저장 공간과 연관을 효과적으로 줄입니다. 또한 증가형 분할 메커니즘을 지원하여 병렬 컴퓨팅을 구현하기 쉬워지며 컴퓨팅 성능을 향상시킬 수 있습니다.\n\n파일 기반 저장은 데이터베이스를 필요로하지 않고 메타데이터가 없기 때문에 SPL의 사용이 더 유연하고 더 효율적이며 가벼우며 저렴하여 빅데이터 시대의 요구에 보다 적합합니다.\n\n![이미지](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_13.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nesProc는 전통적인 데이터 웨어하우스의 \"데이터 저장소(warehouse)\" 개념이 없으며, 메타데이터 개념도 없습니다. 또한, 일정한 주제의 데이터를 통합 관리하는 개념이 존재하지 않습니다. esProc에서 \"데이터베이스 내부\"나 \"데이터베이스 외부\"라는 개념도 없고, \"데이터를 데이터베이스로 가져오기(import)\"하거나 \"데이터베이스에서 가져오기(export)\"하는 동작도 없습니다.\n\nesProc는 접근 가능한 모든 데이터 원본을 esProc의 데이터로 취급하고 직접 계산할 수 있습니다. 데이터를 계산하기 전에 데이터베이스에 가져오는 작업은 필요하지 않으며, 계산 후 의도적으로 데이터베이스로 내보내는 작업도 필요하지 않습니다. 결과는 해당 인터페이스를 통해 대상 데이터 원본에 기록할 수 있습니다.\n\nesProc는 일반 데이터 원본에 대한 접근 인터페이스를 캡슐화하며, 다양한 데이터 원본은 기본적으로 동일한 논리적 상태를 갖습니다. 유일한 차이점은 서로 다른 데이터 원본이 다른 접근 인터페이스를 가지며, 서로 다른 인터페이스에는 서로 다른 성능이 있습니다. 이러한 인터페이스들은 데이터 원본 공급 업체에 의해 제공되므로, esProc는 이러한 기능과 성능에 개입할 수 없습니다.\n\nesProc는 데이터를 저장하기 위해 특수 형식 파일 (바이너리 파일 및 복합 테이블)을 설계하고 더 많은 기능과 성능을 달성하기 위해 이 파일들을 파일 시스템에 저장합니다. 이러한 파일들은 기술적으로 esProc가 소유하지 않으며, 파일 포맷은 공개되어 있으며(접근 코드가 오픈 소스로 공개됨), 이러한 데이터 파일에 액세스할 수 있는 모든 응용 프로그램은 공개된 사양 또는 오픈 소스 코드를 통해 이를 읽고 쓸 수 있습니다. 물론 SPL에서 직접 읽고 쓰는 것이 더 편리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 의미에서 esProc와 외부 데이터 원본 간의 데이터 교환 시 \"데이터베이스로 가져오기\" 또는 \"데이터베이스에서 내보내기\"와 같은 작업이 없습니다. 그러나 외부 데이터를 esProc 형식 파일로 변환하여 더 많은 기능과 더 나은 성능을 얻거나 esProc 형식 파일을 외부 데이터로 변환하여 다른 응용 프로그램에서 사용하는 것과 같이 데이터 변환 작업이 발생할 수 있습니다. 이러한 모든 변환 작업은 SPL을 사용하여 수행할 수 있습니다.\n\n![image](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_14.png)\n\n원칙적으로 esProc는 데이터를 관리하지 않으며 데이터 보안에 대한 책임이 없습니다. 어느 정도로는 esProc에 보안 메커니즘이 없고 필요하지 않다고 말할 수 있습니다.\n\n지속적인 데이터의 보안은 원칙적으로 데이터 원본의 책임입니다. esProc 형식 파일의 경우, 많은 파일 시스템이나 VM이 완전한 보안 메커니즘(액세스 제어, 암호화 등)을 제공하며 이를 직접 활용할 수 있습니다. esProc의 클라우드 버전은 또한 계산하기 전에 S3와 같은 객체 저장 서비스에서 데이터를 검색하고 이들의 보안 메커니즘을 활용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내장된 esProc은 주 Java 애플리케이션과 동일한 프로세스에서 실행되며 주 애플리케이션에 대한 컴퓨팅 서비스만 제공합니다. esProc은 외부 서비스 인터페이스를 제공하지 않으므로 보안 및 권한 문제가 없습니다. 독립적인 서비스 프로세스의 esProc은 표준 TCP/IP 및 HTTP를 사용하여 통신하며 전문적인 네트워크 보안 제품을 통해 모니터링 및 관리할 수 있으며 구체적인 보안 조치는 이러한 제품의 책임입니다.\nesProc은 계산에 특화되어 있으며 영속적 저장의 신뢰성에 대한 책임이 없습니다. 이에 관련된 전문 기술 및 제품도 있습니다. esProc은 이러한 기술 및 제품과 함께 작동할 수 있도록 표준 규격을 준수하려고 노력합니다. 예를 들어, 데이터는 매우 신뢰할 수 있는 객체 저장소에 영속화될 수 있고, 이를 위해 esProc은 해당 인터페이스를 제공하여 이러한 데이터 원본에 액세스하여 계산을 수행할 수 있도록 합니다.\n\nesProc은 전문적인 컴퓨팅 기술이지만 전문적인 보안 기능을 제공하지는 않습니다. esProc의 철학은 다른 전문 보안 기술과 함께 작동하는 것입니다.\n\n위에서 esProc SPL의 몇 가지 기술적 특성을 소개했습니다. 이제 더 많은 시나리오에서 적용된 esProc SPL 솔루션을 살펴봅시다.\n\n# 더 많은 솔루션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터 주도형 마이크로서비스 구현\n\n마이크로서비스는 응용 프로그램 단에서 데이터 처리가 필요하며, 관련 처리 기술이 필요합니다. 데이터베이스가 강력한 컴퓨팅 능력을 가지고 있지만, 응용 프로그램 단에 포함되기 어려워 하드 코딩이 종종 필요합니다. Java/ORM은 충분히 구조화된 컴퓨팅 라이브러리가 부족하여 데이터 처리 개발이 어려워지고, 핫 스왑을 달성하지 못하기 때문에 마이크로서비스의 요구 사항을 충족하기 어렵습니다.\n\n마이크로서비스에서 데이터 계산을 구현하기 위해 Java/ORM을 SPL로 교체하면 이러한 문제를 효율적으로 해결할 수 있습니다. SPL은 풍부한 컴퓨팅 라이브러리와 민첩한 구문을 갖추어 개발을 크게 단순화할 수 있습니다. SPL은 오픈 시스템이며, 실시간으로 어떤 소스의 데이터도 처리할 수 있습니다. SPL은 해석 실행되어 핫 스왑을 자연스럽게 지원합니다. 뛰어난 알고리즘과 병렬 메커니즘을 갖춘 SPL은 컴퓨팅 성능을 보장합니다. 따라서 SPL은 마이크로서비스에서 이상적인 컴퓨팅 엔진입니다.\n\n더 많은 정보를 원하신다면: Open-source SPL Rings down the Curtain on ORM를 방문해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 저장 프로시저 교체\n\n저장 프로시저의 단점들은 오랜 역사를 갖고 있습니다. 특히, 저장 프로시저는 수정과 디버그가 어려우며 이동성이 없습니다; 저장 프로시저를 컴파일하는 데는 높은 권한이 필요하여 보안 문제를 일으킵니다; 여러 애플리케이션이 공유된 저장 프로시저를 사용하면 애플리케이션 간의 강력한 결합을 야기할 수 있습니다. 안타깝게도, 우리는 더 나은 해결책이 없어서(하드 코딩 비용이 너무 높기 때문에) 이러한 단점들을 감내해야 합니다.\n\nSPL은 복잡한 구조화된 데이터 연산을 위해 특별히 설계되었으며, 저장 프로시저의 우수한 대체품이 될 수 있으며 외부 데이터베이스 저장 프로시저의 효과를 달성할 수 있습니다. SPL은 다단계 계산을 지원하며, 저장 프로시저와 같은 복잡한 계산에 자연스럽게 적합합니다. SPL 스크립트는 자연적으로 이동할 수 있으며, 스크립트는 데이터베이스의 읽기 권한만을 요구하며 데이터베이스 보안 문제를 일으키지 않습니다; 다른 애플리케이션의 스크립트는 서로 다른 디렉토리에 저장되어 애플리케이션 간의 결합을 일으키지 않습니다.\n\n더 많은 정보는 다음을 참조하십시오:  [안녕, 저장 프로시저 - 사랑과 미움의 대상](Goodbye, Stored Procedures — the Love/Hate Thing)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터베이스에서 중간 테이블을 제거하세요\n\n데이터베이스를 사용할 때는, 쿼리 성능을 향상시키거나 개발을 간소화하기 위해 많은 중간 테이블이 생성되며, 이 중간 테이블의 수는 시간이 지남에 따라 계속 증가합니다. 이러한 테이블은 많은 공간을 차지하여 데이터베이스가 지나치게 중복되고 부풀어 있게 만들며, 각 어플리케이션에서 동일한 중간 테이블에 대한 액세스는 강한 결합을 유발시키며 중간 테이블을 관리하기가 어렵습니다.\n\n데이터베이스에 중간 테이블을 저장하는 목적은 후속 계산에 데이터베이스의 계산 능력을 활용하는 것입니다. 위에서 언급한 문제를 해결하기 위해 중간 테이블을 데이터베이스 외부에 배치하고 파일로 저장하며, 후속 계산은 SPL에서 구현할 수 있습니다. 외부 중간 테이블(파일)은 관리가 더 쉽고, 다른 디렉토리에 저장하면 어플리케이션 간 결합 문제가 발생하지 않습니다. 이 방법을 통해 데이터베이스의 부하를 완전히 줄일 수 있으며, 데이터베이스를 배포할 필요 없이도 수행할 수 있습니다.\n\n자세한 정보는 아래 링크를 방문해 주세요: [오픈 소스 SPL: 데이터베이스로부터 수만 개의 중간 테이블을 제거합니다](https://www.example.com)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 계속되는 보고서 개발 요구 사항을 처리하세요\n\n보고서/BI 개발은 데이터 준비와 데이터 표현 두 단계로 진행됩니다. 그러나 보고서 도구/BI 도구는 표현 단계의 문제만 해결할 뿐 데이터 준비에 대해서는 아무것도 할 수 없습니다. 복잡한 데이터 준비를 위해서는 SQL/저장 프로시저/자바 하드코딩이 유일한 선택이며, 이는 개발과 유지보수가 어려우며 비용이 높습니다. 우리는 종종 계속되는 보고서 개발 요구 사항에 직면하며, 저비용으로 빠르게 대응하기가 어려운 경우가 많습니다. 개발 비용을 높이는 주된 요인은 데이터 준비입니다.\n\nSPL의 도움을 받아 보고서 표현과 데이터 소스 사이에 컴퓨팅 레이어를 추가함으로써 데이터 준비 문제를 해결할 수 있습니다. SPL은 보고서의 데이터 준비를 간단하게 만들어주며, 보고서 도구의 계산 기능 부족을 보완하여 보고서 개발 효율을 포괄적으로 향상시킵니다. 보고서의 데이터 준비가 도구로 구현되면, 보고서 표현과 데이터 준비 양쪽 모두가 저비용으로 계속되는 보고서 개발 요구 사항을 신속하게 처리할 수 있습니다.\n\n자세한 내용은 방문해주십시오: 오픈 소스 SPL이 보고서 응용 프로그램을 최적화하고 계속되는 보고서 개발 요구를 처리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프론트엔드 계산을 구현하기 위한 프로그래밍 가능한 데이터 라우팅\n\n너무 많은 비즈니스를 맡으면 데이터 웨어하우스가 심한 작업 부담을 겪을 수 있습니다. 따라서, 고주파 계산 작업의 일부를 프론트엜드 애플리케이션으로 옮겨 부담을 분산해야 합니다. 그러나, 프론트엔드 계산에 사용할 수 있는 기술이 거의 없습니다. 데이터베이스를 사용해 프론트엔드 계산을 구현하면 데이터 동기화 문제가 발생할 수 있습니다. 즉, 고주파 데이터만 프론트엔드 데이터베이스로 가져오면 모든 쿼리 요청을 처리할 수 없지만, 전체 데이터를 프론트엔드 데이터베이스에 복사하면 반복된 구축과 막대한 작업을 해결해야 합니다.\n\nSPL은 고주파 데이터를 SPL 파일로 변환하여 저장함으로써 이 문제를 해결할 수 있으며, SPL의 고성능 계산 능력으로 응용 프로그램에 효율적인 컴퓨팅 서비스를 제공할 수 있습니다. 또한, SPL은 지능형 데이터 라우팅 기능을 제공합니다. 응용 프로그램이 저주파 데이터를 쿼리하면 SPL이 자동으로 쿼리 요청을 데이터 웨어하우스로 라우팅하여 반복된 구축의 높은 비용을 피하고 유연하고 효율적인 컴퓨팅 능력을 낮은 구현 비용으로 최대한 발휘할 수 있습니다.\n\n더 많은 정보를 원하시면 아래 링크를 방문해주세요: Routable computing engine implements front-end database\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 혼합 계산을 통한 실시간 HTAP 구현\n\nHTAP 요구 사항은 다양한 데이터베이스에 대량의 데이터가 저장된 후에 실시간 쿼리를 수행할 수 없는 문제의 결과입니다. 실시간 쿼리를 구현할 때, HTAP 데이터베이스는 현재 다음과 같은 문제에 직면하게 됩니다: i) 기존의 프로덕션 데이터베이스가 HTAP 데이터베이스가 아니기 때문에 프로덕션 데이터베이스를 대체해야 하는데, 이는 높은 위험을 유발할 것입니다; ii) SQL의 계산 능력이 충분하지 않고, 과거 데이터가 잘 구성되지 않아 성능이 낮아지는 문제가 발생합니다; iii) 데이터베이스의 계산 능력이 다양한 데이터 소스의 장점을 활용하기에 너무 제한적이며, 모든 데이터를 하나의 데이터베이스로로 로드하는 복잡한 ETL 프로세스는 실시간 성능이 나빠진다.\n\nSPL은 다양한 데이터 소스에 대한 혼합 계산을 지원하고 실시간 분석을 달성할 자연스러운 능력을 갖고 있습니다. 계산 특성에 따라 잘 구성된 과거 추월 데이터를 파일로 저장함으로써 계산 성능을 향상시키고, 트랜잭션 핫 데이터는 여전히 프로덕션 데이터베이스에 저장되어 실시간으로 읽을 수 있습니다. 이러한 능력을 통해 SPL은 프로덕션 시스템을 변경하지 않고 효율적인 HTAP 효과를 달성할 수 있으며, 위험과 비용을 최소화할 수 있습니다. SPL은 오픈, 다중 소스 혼합 계산 능력을 통해 저위험, 고성능 및 강력한 실시간 HTAP를 지원합니다.\n\n더 많은 정보를 원하시면, 다음을 방문해 주세요: HTAP 데이터베이스는 HTAP 요구 사항을 처리할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 파일 계산을 통한 레이크하우스 구현\n\n레이크하우스를 구현하기 위해서는 저장 및 계산 능력이 모두 필요합니다. 다시 말해, 노출 데이터를 완전히 보존할 수 있는 능력과 강력한 계산 능력이 필요합니다. 디비로 레이크하우스를 구현하는 것은 계산만 할 수 있고 저장은 할 수 없는 난처한 상황에 직면하게 됩니다. 디비는 강력한 제약 조건을 가지고 있어서, 비준수 데이터를 저장할 수 없어 데이터의 모든 기능을 보존할 수 없습니다. 게다가 복잡한 ETL 프로세스는 매우 비효율적입니다. 디비는 매우 강하게 닫혀있는 성격을 가지고 있어서, 디비 데이터에서만 계산을 할 수 있어 다양한 원시 데이터 원본을 직접 계산하거나 실시간 혼합 계산을 수행할 수 없습니다.\n\nSPL은 진정한 레이크하우스를 구현할 수 있습니다. 원시 데이터는 파일 시스템에 직접 저장될 수 있어 데이터의 무결성을 보존할 수 있습니다.\n\nSPL은 더욱 개방적이며, 어떤 유형의 데이터든지 직접 계산할 수 있습니다. txt, csv, json과 같은 개방형 형식 파일 데이터에 대해서 SPL은 직접 계산하고, 다른 유형의 데이터에 대해서도 실시간 혼합 계산을 수행할 수 있습니다. 데이터의 계산과 구성은 동기적으로 이루어질 수 있어 데이터를 더욱 효율적으로 활용하며 재계산 시에도 높은 성능을 유지할 수 있습니다. 단계적 접근법은 레이크하우스를 구현하는 올바른 방법입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 정보를 원하시면 다음을 방문해주세요: 현재 Lakehouse는 거짓 제안과 같습니다.\n\n# FAQ\n\n# esProc은 오픈 소스 또는 데이터베이스 기술을 기반으로 하나요?\n\n위에서 주로 SQL과 같은 기존 기술의 단점을 자세히 분석했는데, 이러한 단점은 주로 그 뒤에 있는 이론 체계로 인한 것입니다. 만약 이러한 이론을 그대로 따른다면, 이러한 결점을 근본적으로 해결하는 것은 불가능합니다. 그래서 우리는 새로운 컴퓨팅 모델인 이산 데이터 집합을 발명하고, 이 모델을 기반으로 한 esProc SPL을 개발했습니다. 모든 것이 새로워서 산업에 참고할 수 있는 관련 이론과 엔지니어링 제품이 없으므로, 우리는 처음부터 개발해야 했고, 모델에서 코드까지의 모든 부분은 처음부터 만들어졌습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 에스프록은 어디에 배포할 수 있나요?\n\n에스프록은 완전히 Java로 개발되어 있기 때문에 JVM이 장착된 모든 환경에 배포할 수 있습니다. VM, 클라우드 서버, 컨테이너를 비롯한 환경에 배포할 수 있습니다. 실제로 에스프록은 독립적으로 사용하거나 응용 프로그램에 통합할 수 있습니다. 독립적으로 사용할 때는 별도의 에스프록 서버를 실행해야 하며 분산 클러스터를 구축할 수 있습니다. 응용 프로그램에 통합될 때는 jar 형식으로 삽입되어 응용 프로그램의 일부(계산 엔진)로 간주됩니다.\n\n# 어떻게 응용 프로그램이 에스프록을 호출할까요?\n\n에스프록은 표준 JDBC 드라이버를 제공하므로 Java 응용 프로그램에 직접적으로 신속하게 통합할 수 있습니다. .net/Python과 같은 Java가 아닌 응용 프로그램의 경우 ODBC/HTTP/RESTful 인터페이스를 통해 호출할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 다른 프레임워크와 esProc를 통합할 수 있을까요?\n\nesProc는 전통적인 데이터베이스처럼 독립적인 서비스 프로세스로 실행될 수 있습니다. 또한 esProc는 표준 JDBC 드라이버와 HTTP 서비스를 제공하여 애플리케이션이 호출할 수 있습니다. 따라서 JDBC를 통해 SPL 문을 보내야 하는 Java 애플리케이션에서 SPL 스크립트를 실행할 수 있습니다. esProc의 스크립트 코드를 호출하는 것은 관계형 데이터베이스의 저장 프로시저를 호출하는 것과 동등합니다. Java 애플리케이션이 아닌 경우에는 HTTP/Restful 메커니즘을 통해 esProc에서 제공하는 컴퓨팅 서비스에 액세스할 수 있습니다.\n\nJava에서 개발된 애플리케이션에서 esProc는 완전히 포함될 수 있습니다. 즉, 모든 컴퓨팅 기능이 JDBC 드라이버에 캡슐화되어 주 응용 프로그램과 동일한 프로세스에서 외부 독립적인 서비스 프로세스에 의존하지 않고 실행될 수 있습니다.\n\nesProc는 순수한 Java로 개발된 소프트웨어이기 때문에 다양한 Java 프레임워크 및 애플리케이션 서버에 완전하고 원활하게 통합될 수 있습니다. Spring, Tomcat과 같은 프레임워크에서 esProc는 사용자가 작성한 Java 애플리케이션과 동일한 논리적 상태를 갖습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n계산 유형의 프레임워크인 Spark과 같은 곳에 esProc를 완벽하게 통합할 수 있지만 실용적으로는 그다지 의미가 없습니다. esProc는 계산하기 전에 데이터를 SPL 특정 데이터 객체로 변환해야 하는데, 이는 시간이 많이 소요되며 처음부터 있던 계산 프레임워크의 데이터 객체를 무의미하게 만들어 두 유형의 데이터 객체의 장점을 결합할 수 없게 만들어 실패로 이어집니다. 이러한 계산 프레임워크의 핵심은 데이터 객체(예: Spark의 RDD)입니다. 만약 그러한 데이터 객체를 더 이상 사용할 수 없다면, 해당 계산 프레임워크 자체가 의미가 없어집니다. esProc의 계산 능력은 보통의 계산 프레임워크보다 훨씬 뛰어나기 때문에 더 이상 이러한 프레임워크를 사용할 필요가 없습니다.\n\n특히 스트림 계산 프레임워크(예: Flink)의 경우, esProc가 통합될 수 있더라도 역할을 할 수 없습니다. esProc는 독립적으로 여러 차례 스트림 계산 시나리오에 활용되어 왔고, 전혀 스트림 계산 프레임워크의 지원이 필요하지 않습니다. 동일한 계산 양에 대해 esProc는 일반적인 스트림 계산 프레임워크보다 크게 낮은 리소스를 소비하며 더 많은 기능을 제공합니다.\n\n# 기존 데이터베이스를 기반으로 esProc를 실행할 수 있나요?\n\n네, 물론 가능합니다! esProc는 데이터베이스, 텍스트, 엑셀, JSON/XML, 웹 서비스 등 수십 가지 데이터 원본을 지원합니다. 게다가, esProc는 데이터베이스와 텍스트와 같은 다른 데이터 원본 간의 연관 및 혼합 작업을 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 데이터 집중적 작업(대부분의 대용량 데이터 작업이 해당됨)의 경우, 데이터베이스로부터 데이터를 읽는 것은 데이터베이스의 느린 I/O 성능 때문에 많은 시간이 소요됩니다. esProc의 계산 시간이 매우 짧더라도, 전체 시간이 여전히 매우 길어져 성능 요구 사항을 충족시키지 못할 수 있습니다. 따라서 고성능을 요구하는 시나리오에서는 데이터베이스로부터 대량의 콜드 데이터를 esProc의 고성능 파일로 이동해야만 최적의 성능을 얻을 수 있습니다. 남은 작은 양의 핫 데이터는 여전히 데이터베이스에 저장되어 있을 수 있으며, esProc의 다중 소스 혼합 컴퓨팅 능력을 통해 실시간 전체 데이터 조회를 쉽게 구현할 수 있습니다.\n\n# esProc는 데이터를 어디에 저장합니까?\n\nesProc는 데이터를 파일로 저장하며, 오픈 텍스트 형식을 지원하며 고성능의 개인 파일 형식을 제공합니다. 파일은 더욱 개방적이고 유연하기 때문에 파일을 기반으로 한 고성능 저장 스키마를 설계하고 병렬 컴퓨팅을 통해 계산 성능을 향상시키기가 더 쉽습니다. esProc는 로컬 파일 시스템 및 NFS를 포함한 모든 OS의 파일 시스템을 지원합니다. 따라서 esProc는 저장 및 계산을 분리하는 능력을 자연히 갖추고 있으며, 하드 디스크를 직접 운영해야 하는 데이터베이스와 달리 저장 및 계산을 분리하는 것이 어려운 데이터베이스와는 달리 파일 시스템을 우회하여 운영할 필요가 없습니다.\n\n# esProc의 고가용성을 어떻게 보장할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nesProc는 여러 노드가 협력하여 작동할 수 있는 분산 컴퓨팅을 지원합니다. 그러나 실제로는 대부분의 작업을 처리하고 높은 동시성 시나리오를 제외한 대부분의 작업 요청 속도를 단일 노드를 통해 충분히 처리 할 수 있기 때문에 분산 컴퓨팅이 드물게 사용됩니다.\n\nesProc의 다가오는 클라우드 에디션(사설 배포 지원)은 자동 탄력적 컴퓨팅을 지원할 것입니다. 데이터 요청량이 증가하면 새 VM이 자동으로 활성화되어 계산에 참여하고, 데이터 요청량이 감소하면 유휴 상태의 VM이 자동으로 종료됩니다.\n\n내장된 esProc는 주 애플리케이션에 대한 컴퓨팅 서비스만 제공하며 외부 서비스를 제공하지 않거나 외부 서비스의 신뢰성에 대한 책임을 지지 않습니다. 외부 서비스의 신뢰성은 주 애플리케이션과 프레임워크가 책임집니다.\n\n독립 프로세스의 esProc은 핫 스탠바이 메커니즘을 지원하며, JDBC는 현재 작동 중인 서비스 프로세스 중 부하가 적은 프로세스를 선택하여 계산을 수행합니다. esProc의 분산 컴퓨팅도 내결함성을 제공합니다. 그러나 esProc의 설계 목표가 대규모 클러스터가 아니기 때문에 계산 중 노드 오류가 발견되면 작업이 실패로 처리됩니다. esProc의 내결함성은 노드 오류가 감지되면 클러스터가 새 작업을 수용할 수 있도록 하는 것으로 제한되어, 소규모 클러스터에 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nesProc의 서비스 프로세스는 현재 실패 후 자동 복구 기능을 제공하지 않으며, 실패는 관리자가 처리해야 합니다. 그러나 감시 프로세스를 설계하여 자동 기능을 구현하는 것은 어렵지 않습니다.\n\nesProc의 탄력 있는 컴퓨팅 메커니즘(클라우드 버전)은 VM을 할당할 때 현재 실패한 노드를 피함으로써 일정한 수준의 고가용성을 실현할 수 있습니다.\n\n# esProc 기능 확장 방법\n\nesProc는 Java로 작성된 소프트웨어이며, Java로 작성된 정적 함수를 호출하기 위한 인터페이스를 제공하여 esProc의 기능을 확장할 수 있습니다. 또한 esProc는 사용자 정의 함수 인터페이스를 공개하여 응용 프로그래머가 Java로 새로운 함수를 작성하고 이를 esProc로 이동하여 SPL에서 사용할 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# esProc의 약점은 무엇인가요?\n\nRDB와 비교했을 때:\n\nesProc의 메타데이터 기능은 비교적 미숙합니다.\n\nesProc는 DBMS가 아니며 전통적인 의미에서 메타데이터 개념이 없으며 데이터는 대부분 파일 형태로 저장, 관리 및 사용됩니다. 대부분의 작업은 데이터 원본(파일)에 접근하여 시작되므로 데이터베이스에 비해 간단한 계산에는 약간 더 귀찮을 수 있지만 복잡한 계산에는 더 유리합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHadoop/MPP과 비교할 때:\n\nHadoop/MPP 데이터베이스 클러스터의 규모는 비교적 큽니다 (MPP 클러스터의 노드 수에는 제약이 있을 수 있지만), 그리고 해당 클러스터의 활용, 운영 및 관리에 대한 성숙한 경험이 이미 존재합니다. 반면에, esProc 클러스터는 주로 소규모에서 중규모를 타겟팅하며, 일반적으로 몇 개에서 몇십 개의 노드를 가리킵니다. 그럼에도 불구하고, Hadoop/MPP에 비해 실용적인 경험이 부족합니다. 실제로, esProc 클러스터는 거의 사용되지 않는데, 그 이유는 고객이 종종 원래 클러스터의 효과를 달성하거나 심지어 뛰어넘을 수 있는 경우가 많아서, 이는 esProc 클러스터 활용에 대한 상대적인 경험 부족으로 이어집니다.\n\nPython과 비교할 때:\n\n우리는 현재 esProc SPL의 AI 기능을 개발하고 있으며, AI 모델링 및 예측 기능을 점차 향상시키고 있지만, 이러한 기능은 아직 Python의 다양한 AI 알고리즘 라이브러리만큼 풍부하지는 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# SPL과 SQL 간의 호환성은 어때요?\n\nesProc는 SQL 시스템의 연산 엔진이 아니며, 현재는 대량의 데이터를 포함하지 않는 간단한 SQL만 지원하며 성능을 보장할 수 없습니다. 대규모 데이터 처리 시나리오에서는 esProc가 SQL을 지원하지 않는 것으로 간주할 수 있으며 물론 어떤 SQL 저장 프로시저와도 호환되지 않을 것입니다.\n\nesProc는 앞으로 SQL을 지원하는 이중 엔진을 개발할 예정이지만, 여전히 높은 성능과 대규모 데이터 처리 요구를 충족시키기 어렵습니다. esProc로 기존 SQL 코드를 쉽게 이관하도록만 하기 때문입니다.\n\n# SQL을 SPL로 자동 변환해 주는 도구가 있을까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQL의 널리 사용으로, 특히 기존 시스템을 최적화할 때, SQL을 SPL로 자동 변환하여 마이그레이션 비용을 줄일 수 있는지 궁금해질 수밖에 없습니다.\n\n안타깝게도, 그럴 수 없습니다.\n\n데이터베이스는 SPL의 데이터 원본으로 사용될 수 있지만, 데이터베이스에 기반을 둔 고성능 구현은 어렵기 때문에(SQL의 저장 방식 때문에), 데이터베이스에 기반한 SQL을 SPL로 자동 변환하는 것은 불가능합니다. 더 중요한 것은, 충분한 설명 능력의 부족으로 인해, SQL은 많은 고성능 알고리즘을 구현할 수 없습니다. 이 경우 SQL을 강제로 SPL로 변환하면 기능은 보장되지만, 성능은 보통 훨씬 나쁠 수 있습니다.\n\n또한, SPL은 SQL만큼 강력한 자동 최적화 메커니즘을 제공하지 않습니다. 수십 년에 걸쳐 발전한 뒤, 많은 데이터베이스가 강력한 최적화 엔진을 갖추고 있습니다. 상대적으로 간단한 느린 SQL 문을 직면했을 때 엔진은 그들의 진정한 의도를 \"추측\"하고, 이를 자동으로 최적화하여 고성능 방식으로 실행할 수 있습니다(위에서 언급한 TopN과 같은); 반면, SPL의 자동 최적화 기능은 부족하며, 우리는 데이터베이스 공급 업체만큼 최적화 경험이 풍부하지 않기 때문에, 진술의 의도를 \"추측\"할 능력이 없으며, 코드를 직접 실행해야 합니다. 이 경우 우리는 고성능을 달성하기 위해 저복잡도 코드를 작성하는 우리 프로그래머들에게만 의존할 수밖에 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# SPL 배우기는 얼마나 어려운가요?\n\nSPL은 로우 코드와 고성능을 목표로 합니다. SPL 구문은 Java보다 쉽고 훨씬 간단하며, 몇 시간 안에 마스터할 수 있고 몇 주 안에 능숙해질 수 있습니다. 어려운 것은 최적화 알고리즘을 설계하는 것입니다. 다행히도 배우기 어렵지 않고, 우리는 그 지식 포인트들을 요약하여 고정된 루틴으로 정리했습니다. 이 루틴을 따르기만 하면, 마스터할 수 있고 숙달된 전문가가 될 수 있습니다.\n\n- SPL 프로그래밍 — 서문\n- 성능 최적화 — 서문\n- SQL과 비교했을 때 SPL이 더 어려운가요?\n\n# 성능 최적화 프로젝트를 어떻게 시작할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 프로그래머들은 SQL로 생각하는 방법에 익숙하지만 고성능 알고리즘에 대해 친숙하지 않습니다. 그들은 한두 가지 시나리오를 통해 이해할 수 있도록 훈련받아야 합니다. 성능 최적화 루틴은 많지 않으며 (수십 개), 흔히 사용되는 루틴은 10개 미만입니다. 이러한 루틴을 경험하면 알고리즘 설계와 구현이 그리 어렵지 않다는 것을 깨닫게 될 것입니다. 처음 2-3가지 시나리오는 사용자가 우리 엔지니어의 도움을 받아 구현할 것입니다. 이 과정에서 우리는 사용자들에게 문제 해결 방법을 직접 제시하는 대신에 어떻게 문제를 해결할 수 있는지 가르쳐줄 것입니다.\n\n![이미지](/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_15.png)\n\n자세한 정보를 보려면 다음을 방문하세요: SQL (그리고 저장 프로시저) 실행 속도가 너무 느릴 때 어떻게 해야 합니까?\n\n# 요약\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, esProc SPL의 데이터 분석 엔진으로의 장점을 요약해 보겠습니다.\n\n높은 성능\n\n실제로 esProc SPL은 대용량 데이터를 처리하는 성능이 평균적으로 기존 솔루션보다 1~2개 수준 높기 때문에 성능 우위가 매우 명백합니다.\n\n효율적인 개발\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSPL의 유연한 구문과 풍부한 컴퓨팅 라이브러리, 그리고 절차적 특성을 통해 복잡한 알고리즘을 자연스러운 사고에 따라 구현할 수 있어 개발 효율이 향상됩니다.\n\n유연하고 개방적인\n\nesProc SPL은 여러 데이터 소스의 혼합 계산을 지원하며, 다중 데이터 소스의 장점을 효과적으로 활용하면서 최소 비용으로 HTAP를 구현할 수 있습니다. 게다가, esProc SPL은 응용 프로그램에 통합되어 진정으로 개방적이고 유연합니다.\n\n리소스 절약\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n높은 컴퓨팅 능력을 지원하는 esProc SPL은 비즈니스 목표를 달성하는 데 더 적은 하드웨어로 가능합니다 (단일 기계가 클러스터와 견줄 수 있습니다), 그래서 더 환경 친화적인 기술입니다.\n\n날카로운 비용 절감\n\n이러한 장점이 비용에 반영되면 개발, 하드웨어, 운영 및 유지보수 비용을 X 배 절감할 수 있습니다.\n\n추가 질문이 있거나 다른 확장 기능을 알고 계신다면 언제든지 댓글을 남겨주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 Medium 뉴스레터를 구독하시면 최신 소식을 받으실 수 있습니다. 저의 콘텐츠를 받아보실 걸 약속드립니다! \n\nTwitter와 LinkedIn에서도 만나보실 수 있어요!\n\n원본 논문 보기:\n\nesProcess SPL 더 많은 내용은:","ogImage":{"url":"/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_0.png"},"coverImage":"/assets/img/2024-06-22-UnlockingDataAnalysisEfficiencyAComprehensiveGuidetoesProcSPL_0.png","tag":["Tech"],"readingTime":43},{"title":"SQL 윈도우 함수 탐구 ROW_NUMBER, RANK, DENSE_RANK 사용 방법","description":"","date":"2024-06-22 17:39","slug":"2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK","content":"\n\nSQL 세계에서 윈도우 함수는 현재 행과 관련된 테이블 행 집합을 대상으로 계산을 수행할 수 있는 강력한 도구입니다. 이 글에서는 세 가지 필수 SQL 윈도우 함수인 ROW_NUMBER, RANK 및 DENSE_RANK에 대해 알아볼 것입니다. 이러한 함수를 사용하면 결과 세트 내에서 행에 고유한 번호나 순위를 할당하여 데이터에서 가치 있는 통찰을 추출하기가 쉬워집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반 구문:\nROW_NUMBER() OVER (ORDER BY column)\n\n- ORDER BY는 결과 집합을 정렬하는 데 사용되는 열 또는 표현식을 지정합니다.\n\nROW_NUMBER() OVER (PARTITION BY column ORDER BY column)\n\n- PARTITION BY는 지정된 열을 기준으로 결과 집합을 분할하는 선택적 절입니다. 순위가 각 파티션 내에서 별도로 적용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n회사 직원들에게 급여 순으로 내림차순으로 새 직원 ID를 할당해 봅시다:\n\n```js\nSELECT * , ROW_NUMBER() OVER(ORDER BY salary DESC) AS new_employee_id\nFROM employees;\n```\n\n![이미지](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_1.png)\n\n직원들을 급여에 따라 내림차순으로 순위를 매기고, 'position' 열을 기준으로 결과 집합을 파티션으로 나눠 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nSELECT * , ROW_NUMBER() OVER(PARTITION BY position ORDER BY salary DESC) AS employee_rank\nFROM employees;\n```\n\n![Exploring SQL Window Functions](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_2.png)\n\n## 2. RANK Function\n\nThe RANK() function assigns a unique rank to each row based on the values in one or more columns. Rows with the same values receive the same rank, and the next rank is skipped. It’s useful when you want to create a ranking with gaps.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적인 구문:\n\nRANK() OVER (ORDER BY column)\n\nRANK() OVER (PARTITION BY column ORDER BY column)\n\n우리는 직원들을 급여에 따라 내림차순으로 순위 매겨볼게요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sql\nSELECT * , RANK() OVER(ORDER BY salary DESC) AS salary_rank\nFROM employees;\n```\n\n![Exploring SQL Window Functions](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_3.png)\n\n## 3. DENSE_RANK Function: 동일한 순위를 가진 항목 그룹화하기\n\nDENSE_RANK() 함수는 동일한 순위를 가진 항목을 함께 그룹화하고 싶을 때 유용합니다. 동일한 값들을 갖는 행들은 동일한 순위를 부여받으며, 다음 순위가 건너뛰어지지 않습니다. 이 함수는 순위에 빈칸이 없는 순위를 만들고 싶을 때 유용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적인 구문:\n\n\nDENSE_RANK() OVER (ORDER BY column)\n\nDENSE_RANK() OVER (PARTITION BY column ORDER BY column)\n\n\n만약 \"titles\"라는 테이블이 있고 \"title\"과 \"price\"라는 열이 있다고 가정해보겠습니다.\n책 제목을 가격순으로 순위를 매기고 동일한 가격을 가진 제목들을 그룹화하려면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nSELECT title, price, DENSE_RANK() OVER(ORDER BY price DESC) as 'rank'\nFROM titles;\n```\n\n![Exploring SQL Window Functions](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_4.png)\n\n‘type’ 열을 기반으로 결과 집합을 파티션으로 나눠 봅시다.\n\n```js\nSELECT title, price, type, DENSE_RANK() OVER(PARTITION BY type ORDER BY price DESC) as 'rank'\nFROM titles;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_5.png)\n\n가정하고 있는 것은 \"titles\"라는 테이블이 \"title\"과 \"ytd_sales\"라는 열을 가지고 있다는 것입니다. 성과가 좋은 책을 식별하기 위해 다음 쿼리를 사용할 수 있습니다:\n\n```js\nSELECT title, ytd_sales, DENSE_RANK() OVER(ORDER BY ytd_sales DESC) as 'rank'\nFROM titles;\n```\n\n![image](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_6.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n‘type’ 열을 기반으로 결과 집합을 파티션으로 나눠 봅시다.\n\n```js\nSELECT title, ytd_sales, type, DENSE_RANK() OVER(PARTITION BY type ORDER BY ytd_sales DESC) as 'rank'\nFROM titles;\n```\n\n![참고 이미지](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_7.png)\n\n# 세 가지 함수를 모두 결합하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n직원의 급여와 함께 직원 목록이 있는 시나리오를 고려해보세요. 각 직원에 고유한 직원 ID를 할당하고, 급여순으로 순위를 매기고, 촘촘한 순위를 부여하려고 합니다.\n\n```js\nSELECT \n    first_name, last_name, position, salary,\n    ROW_NUMBER() OVER (ORDER BY salary) AS employee_id,\n    RANK() OVER (ORDER BY salary) AS salary_rank,\n    DENSE_RANK() OVER (ORDER BY salary) AS dense_salary_rank\nFROM employees;\n```\n\n이 예제에서는 세 윈도우 함수를 한 쿼리에서 모두 사용합니다:\n\n- ROW_NUMBER()는 각 직원에게 고유한 employee_id를 할당합니다.\n- RANK()는 직원들을 급여에 따라 순위를 매기되, 동일한 급여의 경우 갭을 둡니다.\n- DENSE_RANK()는 직원들을 급여에 따라 순위를 매기되, 동일한 급여의 경우 갭을 두지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 쿼리는 직원 데이터의 종합적인 정보를 제공합니다. 고유 식별자와 두 가지 유형의 급여 순위가 포함되어 있습니다.\n\n## 결론\n\nROW_NUMBER, RANK, DENSE_RANK와 같은 SQL 윈도우 함수는 데이터 분석 및 보고에 불가결한 도구입니다. 이들은 결과 집합 내에서 행에 고유한 번호나 순위를 할당하여 데이터에서 통찰을 도출하는 작업을 더 쉽게 만들어 줍니다.\n\n# SQL 기초 개념\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n감사합니다! 더 많은 콘텐츠는 SQL Fundamentals에서도 찾아볼 수 있어요! 🚀💫","ogImage":{"url":"/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_0.png"},"coverImage":"/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_0.png","tag":["Tech"],"readingTime":5},{"title":"DuckDB 빅데이터 업계의 떠오르는 스타","description":"","date":"2024-06-22 17:38","slug":"2024-06-22-DuckDBTheRisingStarintheBigDataLandscape","content":"\n\n# 빅 데이터의 현재 상태\n\n지난 십 년 동안 빅 데이터 환경은 놀라운 변화를 겪었습니다. 이 빠르게 발전하는 분야에서 오늘날 사용 가능한 도구의 숫자는 엄청납니다 — 십 년 전과 비교하면 약 9배나 다양합니다.\n\n이 다양성은 데이터 웨어하우스, 데이터 레이크, 레이크하우스로만 한정되지 않고, ETL (추출, 변환, 적재)에서 ELT (추출, 적재, 변환), EL (추출, 적재) 등의 처리 방법론까지 확대되었습니다. 선택의 폭증은 하나의 기술에 대한 전문가가 되는 일이 어렵다는 점을 복합화시키는 것으로, 결국 시간은 우리 모두에게 동등합니다!\n\nSQL이 다양하고 다양한 이 생태계에서 데이터 변환의 선택 도구로 자리 잡았으며, 많은 데이터 처리 플랫폼에서 선택 언어로 자리잡았음을 입증하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다양한 도구 중 하나인 DuckDB가 큰 인기를 끌고 있어요! 알아맞히셨죠... DuckDB!\n\n# DuckDB가 뭔지, 그리고 왜 신경 써야 할까요!?\n\nDuckDB는 빠르게 인기를 얻고 있는 인프로세스 SQL 분석 엔진입니다. 그 인기를 증명하는 인상적인 통계들이 있어요:\n\n- PyPI에서 매달 170만 다운로드\n- GitHub에서 13,800개의 스타를 기록하며 Postgres와 같은 관심을 절반의 시간에 도달합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_0.png\" /\u003e\n\n- DuckDB는 DB-Engines의 트렌드 보고서에 의하면 Snowflake와 유사한 두 년간의 기간 동안 인기가 급증했습니다. 다음 몇 년 동안 주류가 될 것으로 전망되며, 현재 전통적인 데이터 웨어하우스에서 처리되는 일부 페이로드를 대체하는 것으로 잘 준비되어 있는 것으로 보입니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_1.png\" /\u003e\n\nDuckDB의 오픈 소스 성격은 영구적인 MIT 라이선스로 보장되어 있어 매력을 더합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# DuckDB의 주요 이점\n\n- 설치의 용이성: DuckDB를 실행하는 것은 brew install duckdb(이것은 DuckDB CLI를 설치합니다)처럼 매우 간단합니다.\n- 낮은 복잡성: 서버가 없다는 점 (DuckDB는 바이너리일 뿐입니다)로, 자격 증명, 액세스 제어 목록, 방화벽 구성 등과 같은 복잡한 작업이 필요하지 않습니다.\n- 보편적 호환성: 매우 적은 종속성을 가지고 DuckDB는 이식성을 대표합니다. 심지어 브라우저에서도 실행할 수 있습니다!\n- DataFrame 통합: DuckDB의 Python 라이브러리는 Pandas DataFrames를 쿼리할 수 있는 능력을 갖고 있어 게임 체인저입니다! 직접 쿼리할 수 없는 어떤 시스템과도 통합 계층 또는 '접착제' 역할을 하여 데이터 처리의 변환 단계를 용이하게 합니다.\n- 확장 기능: DuckDB는 유연한 확장 메커니즘을 가지고 있어 JSON 및 Parquet에서 데이터를 직접 읽거나 S3에서 데이터를 직접 읽는 경우와 같은 유연성을 제공합니다. 이 능력은 개발자들의 경험을 크게 향상시킵니다.\n- 안정성과 효율성: DuckDB는 메모리 제한을 초과하는 작업 부담을 처리하도록 설계되었습니다 (일부 제한 사항이 있음). 이것은 분석 데이터셋이 사용 가능한 RAM보다 훨씬 크지만 디스크에 맞는 작은 경우에 특히 관련이 있으며, 이는 '싼' 및 쉽게 이용 가능한 하드웨어(예: 랩톱)를 사용하여 분석을 완료할 수 있도록 해줍니다.\n\n# 실제 데이터 파이프라인에서의 DuckDB\n\n클라우드 기반 시스템과 비교할 때 DuckDB는 최소한의 요구 사항과 비용 효율성으로 두드러지게 나타납니다. DuckDB는 클라우드 계정, 할당량 또는 추가 비용이 필요하지 않습니다. 개발자의 랩톱에서 제품 설정까지 DuckDB의 일관성은 데이터가 스테일하거나 잘못될 경우 시간이 지남에 따라 발생하는 클라우드 기반 솔루션과는 대조적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDuckDB의 간편한 실행은 데이터를 계산 노드로 이동하거나 VM/작업 오케스트레이션, 장애 처리와 같은 분산 시스템에서 볼 수 있는 일반적인 도전 과제를 우회합니다. Apple의 M1 SoC로 구동되는 클라우드 기반 또는 유사한 현대 기계의 성능은 DuckDB의 유용성을 더욱 향상시킵니다. 이는 대규모 데이터셋을 처리하는 단일 기계 처리 시나리오를 가능케 하죠. 실제로 매일 TB 단위의 데이터를 처리해야 하는 고객은 매우 적고, 이들은 모든 공개 클라우드에서 사용 가능한 CPU 성능보다 더 많은 CPU 성능이 필요하게 될 것입니다.\n\n# SQL 구문 설탕\n\nDuckDB의 상대적인 신선함은 GROUP BY ALL, SELECT * EXCLUDE, ASOF JOINS 등과 같은 새로운 SQL 구문 개선을 도입할 수 있는 유연성을 제공합니다. 이러한 추가 기능은 SQL 쿼리를 더 직관적이고 가독성 있게 만들어줍니다. 아래 코드 스니펫을 살펴보세요:\n\n```js\n-- ANSI SQL에서 여러 필드로 그룹화\nSELECT country, city, region, postal_code, AVG(price) AS avg_price\nFROM customers\n-- 집계되지 않는 필드는 여기서 반복되어야 함\nGROUP BY country, city, region, postal_code;\n\n-- DuckDB에서 모두를 기준으로 그룹화\nSELECT country, city, region, postal_code, AVG(price) AS avg_price\n-- 필드는 한 번만 나열됨. 코드 유지 관리가 더 쉬워집니다\nGROUP BY ALL;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n-- 'email' 필드를 제외한 모든 데이터를 ANSI SQL에서 쿼리합니다.\nSELECT country, city, region, postal_code, address, phone_number\n  /*, email*/\nFROM customers;\n\n-- 'email' 필드를 제외한 모든 데이터를 DuckDB에서 쿼리합니다.\nSELECT * EXCLUDE (email) FROM customers;\n```\n\n```js\n-- '대략적으로' 동일한 타임스탬프를 조인하는 것을 고려합니다.\n-- ANSI SQL에서는 보통 이를 버킷화해야 합니다.\n-- DuckDB에서는 ASOF JOIN을 사용하여 동일한 결과를 더 간편하고 효율적으로 얻을 수 있습니다.\nSELECT events.id, events.ts, events.val, metadata.details\nFROM events\nASOF JOIN metadata USING(id, ts);\n```\n\n# Pandas 데이터프레임 통합\n\n특히 Python 생태계에서 DuckDB의 중요한 장점은 Pandas 데이터프레임과의 원활한 통합 기능입니다. 이 기능은 다양한 소스에서 다양한 데이터셋을 병합하는 프로세스를 간소화하여 데이터 분석 및 변환 작업을 용이하게 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, Jupyter Notebook에서 다음을 수행할 수 있습니다 (영화 추천 시스템 데이터셋을 기반으로):\n\n```js\n# 의존성 설치\n%pip install --quiet duckdb\n%pip install --quiet jupysql\n%pip install --quiet duckdb-engine\n%pip install --quiet pandas\n%pip install --quiet matplotlib\n%pip install --quiet psycopg2-binary\n%pip install --quiet dash\n%pip install --quiet plotly\n\nimport duckdb\nimport pandas as pd\n\n# jupysql 로드 및 구성\n%load_ext sql\n%config SqlMagic.autopandas = True\n%config SqlMagic.feedback = False\n%config SqlMagic.displaycon = False\n%config SqlMagic.named_parameters=True\n\n# 로컬 DuckDB 인스턴스에 연결\n%sql duckdb:///\n\n# DuckDB를 사용하여 원격 파일 조회 활성화 (예: S3)\n%%sql\nINSTALL httpfs;\nLOAD httpfs;\n\n# S3 액세스 키 구성\nSET s3_region = '...';\nSET s3_access_key_id = '...';\nSET s3_secret_access_key = '...';\n\n# 원격 Postgres 데이터베이스에 연결\nATTACH 'dbname=DATABASE user=USER host=HOST password=PASSWORD connect_timeout=10' AS postgres (TYPE postgres, READ_ONLY);\n\n# 쿼리를 실행하고 데이터프레임에 저장\n%%sql\ndf \u003c\u003c SELECT \n    t1.movieId,\n    t1.title,\n    t1.genres,\n    t2.userId,\n    t2.rating,\n    t3.tag\n  # Postgres의 테이블 쿼리\n  FROM postgres.public.movies AS t1\n  # DuckDB의 테이블과 조인\n  INNER JOIN ratings AS t2 USING (movieId)\n  # S3의 JSON 데이터셋과 조인\n  INNER JOIN 's3://S3-BUCKET/tags.json' AS t3 USING (userId, movieId)\n\n# 마지막으로 다른 쿼리에서 데이터프레임을 참조\n%%sql\nby_genres \u003c\u003c SELECT genres, COUNT(*) AS cnt \n             FROM df\n             GROUP BY ALL\n             ORDER BY 2 DESC\n             LIMIT 5;\n\n# 또는 변형된 데이터셋 플롯\nimport plotly.express as px\nfig = px.pie(by_genres,\n             values='cnt',\n             names='genres',\n             title='Top 5 movie genres')\nfig.show()\n```\n\n# 결론\n\nDuckDB의 개요를 통해 이 도구가 대용량 데이터 영역에서 다재다능하고 효율적이며 사용자 친화적인 잠재력을 갖고 있음을 강조했습니다. 상대적으로 새로운 참가자로서, 데이터 엔지니어와 소프트웨어 개발자들의 변화하는 요구에 부합하는 솔루션을 가능하게 하고 간극을 좁히는 독특한 위치에 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 일반적인 데이터 처리 사용 사례를 다루는 데 그 유틸리티와 다양성에 대해 자신이 있습니다. DuckDB와 관련한 여러분의 경험과 통찰력에 대해 듣고 싶습니다!\n\n다음에 또 만나요 - 계속해서 쿼리해 보세요! 🦆","ogImage":{"url":"/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_0.png"},"coverImage":"/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_0.png","tag":["Tech"],"readingTime":6},{"title":"데이터 마법사를 위한 CASE WHEN 완벽 마스터 가이드 SQL 최종 안내서","description":"","date":"2024-06-22 17:36","slug":"2024-06-22-TheUltimateGuidetoMasteringCASEWHENinSQLforDataWizards","content":"\n\n## CASE WHEN 매직: SQL 기술을 즉시 변화시키세요!\n\n![이미지](/assets/img/2024-06-22-TheUltimateGuidetoMasteringCASEWHENinSQLforDataWizards_0.png)\n\nSQL의 세계에서 조건부 논리를 마스터하는 것은 체스 선수가 전략적 움직임을 배우는 것과 조금 비슷합니다.\n\n이 핵심에는 CASE WHEN 문이 있습니다. SQL Server, Oracle 및 Snowflake와 같은 환경에서 데이터와 의사 결정을 형성할 수 있는 다재다능한 도구입니다. 이 문서는 다양한 시나리오에서 CASE WHEN을 활용하는 데 필수적인 가이드입니다. 여러분이 데이터 과학자를 희망하는 초보자이든 경험이 풍부한 전문가이든 데이터 조작 기술을 향상시키는 데 도움이 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. CASE WHEN 이해하기\n\nSQL의 CASE WHEN 문은 프로그래밍 언어의 if-else 논리와 유사한 조건식입니다.\n\n이는 SQL 쿼리 내에서 조건부 체크를 가능케 하며, 특정 기준에 따라 데이터를 동적으로 조작하는 방법을 제공합니다.\n\n구문 개요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nCASE\n    WHEN condition1 THEN result1\n    WHEN condition2 THEN result2\n    ...\n    ELSE resultN\nEND\n```\n\n# 2. SQL Server에서의 기본 사용 사례\n\nSQL Server에서 시작해봅시다.\n\nSQL Server에서는 CASE WHEN이 쿼리에서 조건부 로직에 대한 기본 도구로 작용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 조건에 따라 데이터를 분류하거나 변환할 수 있습니다. 이 기능은 데이터를 특정 기준에 따라 세분화하거나 레이블을 지정해야 하는 상황에 특히 유용합니다. 예를 들어, 판매 금액을 높음, 중간, 낮음과 같이 다른 수준으로 분류할 때 활용할 수 있습니다.\n\n판매 데이터베이스가 있다고 가정하고 판매를 다양한 수준으로 분류하고 싶다면 다음과 같이 CASE WHEN을 사용할 수 있습니다:\n\n```js\nSELECT \n    SaleAmount,\n    CASE \n        WHEN SaleAmount \u003e 1000 THEN '높음'\n        WHEN SaleAmount BETWEEN 500 AND 1000 THEN '중간'\n        ELSE '낮음'\n    END AS SaleLevel\nFROM Sales;\n```\n\n이 쿼리는 판매 금액을 기준으로 높음, 중간, 낮음 수준으로 판매를 분류합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. Oracle의 고급 사용\n\nOracle SQL은 CASE WHEN의 기능을 확장합니다.\n\nOracle의 CASE WHEN 구현은 다양성을 더욱 확대합니다.\n\n여러 조건에 따라 다른 계산 또는 변환을 적용하는 등 더 복잡한 결정 프로세스에 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 능력은 고객 상태나 구매 금액과 같은 다른 열 값에 따라 데이터 필드에 할인이나 사용자 정의 계산을 적용하는 것과 같은 시나리오에서 특히 유용합니다.\n\n고객 데이터베이스를 다루고 있고 고객 상태와 구매 금액에 따라 할인을 적용하려는 경우를 상상해보세요. 다음은 이를 수행하는 방법입니다:\n\n```js\nSELECT \n    CustomerID,\n    PurchaseAmount,\n    CASE \n        WHEN CustomerStatus = 'VIP' AND PurchaseAmount \u003e 1000 THEN PurchaseAmount * 0.8\n        WHEN CustomerStatus = 'Regular' AND PurchaseAmount \u003e 1000 THEN PurchaseAmount * 0.9\n        ELSE PurchaseAmount\n    END AS FinalAmount\nFROM Customers;\n```\n\n이 쿼리는 VIP 고객에게는 20% 할인을 적용하고, 1000달러 이상 구매시 일반 고객에게는 10% 할인을 적용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. Snowflake에서 CASE WHEN을 사용하여 값 합산하기\n\nSnowflake는 클라우드 데이터 플랫폼 기능으로 유명한데, CASE WHEN도 지원합니다.\n\nSnowflake는 조건부 집계를 위해 CASE WHEN을 지원합니다. 이 기능은 하나의 쿼리 내에서 서로 다른 범주나 기준에 따라 값들을 조건적으로 합산해야 하는 상황에 유용합니다.\n\n특히 이 기능은 데이터를 세심하게 요약하는 데 유용한데, 예를 들어 동일한 데이터 세트 내에서 서로 다른 비용 유형별 총 비용을 계산하는 경우 등에 활용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTravel 및 Supplies와 같은 다른 유형의 비용을 카테고리별로 합산하려는 시나리오를 생각해보세요. 쿼리는 다음과 같을 수 있습니다:\n\n```js\nSELECT \n    SUM(CASE WHEN ExpenseType = 'Travel' THEN Amount ELSE 0 END) AS TotalTravelExpense,\n    SUM(CASE WHEN ExpenseType = 'Supplies' THEN Amount ELSE 0 END) AS TotalSuppliesExpense\nFROM Expenses;\n```\n\n이 쿼리는 여행 및 용품에 대한 총 비용을 별도로 계산합니다.\n\n# 5. PostgreSQL 및 다중 조건 처리\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPostgreSQL는 인기있는 오픈 소스 데이터베이스로, CASE WHEN에 강력한 지원을 제공합니다.\n\nPostgreSQL에서 CASE WHEN은 쿼리 내에서 여러 조건을 처리하는 데 능숙합니다. 이 기능은 다양한 기준을 충족해야 하는 경우에 결과가 달라지는 상세한 데이터 분석과 조작에 중요합니다.\n\n여러 조건에 따라 데이터를 자세히 분해하거나 분류해야 하는 시나리오에서 가치 있는데, 즉 여러 입력 데이터 범위에 따라 다른 값이나 조치를 할당해야 하는 경우입니다.\n\n예를 들어, 학생 성적 데이터 세트를 분석하고 성적 점수를 할당하려고 한다고 가정해 봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nSELECT \n    StudentID,\n    Grade,\n    CASE \n        WHEN Grade = 'A' THEN 4\n        WHEN Grade = 'B' THEN 3\n        WHEN Grade = 'C' THEN 2\n        WHEN Grade = 'D' THEN 1\n        ELSE 0\n    END AS GradePoints\nFROM StudentGrades;\n```\n\n이 쿼리는 문자 학점에 따라 학점을 할당합니다.\n\n# 6. CASE WHEN으로 동적 열 이름 생성\n\nCASE WHEN의 독특한 응용은 열 이름을 동적으로 지정하는 데 있습니다. 이는 보고서 작성이나 다양한 스키마 요구 사항을 처리할 때 특히 유용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n판매 데이터를 분석하고 연도에 따라 동적 열 이름을 갖는 보고서를 생성하려고 한다고 가정해봅시다. SQL Server에서 다음 예시를 참고하세요:\n\n```js\nSELECT \n    CustomerID,\n    SUM(CASE WHEN Year = 2021 THEN Amount ELSE 0 END) AS [Sales_2021],\n    SUM(CASE WHEN Year = 2022 THEN Amount ELSE 0 END) AS [Sales_2022]\nFROM Sales\nGROUP BY CustomerID;\n```\n\n위 쿼리에서는 각 연도별로 고객당 총 판매 금액을 보여주기 위해 'Sales_2021', 'Sales_2022'라는 동적 열을 생성합니다.\n\n# 7. 성능 고려사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCASE WHEN은 강력하지만 대규모 데이터셋에서 쿼리 성능에 미치는 영향을 고려하는 것이 중요합니다.\n\n효율적인 인덱싱 및 쿼리 최적화로 잠재적인 지연을 완화할 수 있습니다.\n\n고객 구매 행동을 분석하는 대규모 전자 상거래 데이터베이스를 고려해보세요. 수백만 개의 행이 포함된 쿼리에 CASE WHEN을 사용하면 성능에 영향을 줄 수 있습니다. 다음은 샘플 쿼리입니다:\n\n```js\nSELECT \n    CustomerID,\n    TotalPurchases,\n    CASE \n        WHEN TotalPurchases \u003e 1000 THEN 'High Value'\n        ELSE 'Regular'\n    END AS CustomerType\nFROM Purchases\nWHERE TotalPurchases \u003e 1000;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 상황에서 'Purchases' 테이블이 수백만 개의 행을 포함하는 경우, CASE WHEN 문은 쿼리의 속도를 늦출 수 있습니다. 특히 `TotalPurchases`가 인덱싱되지 않은 경우에는 더 그렇습니다.\n\n성능을 개선하기 위해 중요한 열에 인덱스를 설정하거나 쿼리를 더 작고 관리하기 쉬운 부분으로 분할하는 것이 좋습니다.\n\n# 제한 사항과 대안\n\nCASE WHEN은 중첩된 쿼리나 저장 프로시저가 더 효율적일 수 있는 복잡한 논리 구조에서 제한 사항이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## i. 복잡한 논리 처리:\n\nCASE WHEN은 복잡한 논리나 여러 조건으로 인해 읽기 어렵고 다루기 어려워질 수 있습니다.\n\n복잡한 결정 트리나 다수의 중첩 조건이 필요한 시나리오에는 적합하지 않습니다.\n\n## ii. 성능 문제:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대규모 데이터 세트에서는 CASE WHEN을 사용하면 특히 수백만 개의 행을 대상으로 한 계산에서 쿼리 성능이 느려질 수 있습니다.\n\n특정 사용 사례에 최적화된 다른 SQL 구조물이나 함수보다 효율성이 떨어질 수 있습니다.\n\n## iii. 집계 제어가 제한됨:\n\nCASE WHEN은 여러 열 또는 테이블을 포함하는 복잡한 집계에 이상적이지 않을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음과 같은 추가 서브쿼리나 조인이 필요할 수 있습니다. 그러나 이러한 경우 쿼리를 복잡하게 만들 수 있고 실행 속도를 늦출 수 있습니다.\n\n## iv. 대안적 SQL 구조:\n\nIF/ELSE 문: 일부 SQL 환경에서는 저장 프로시저 내에서 IF/ELSE 문을 사용하여 더 복잡한 로직을 처리할 수 있습니다.\n\n저장 프로시저 및 함수: 복잡한 로직에 대해서는 해당 로직을 저장 프로시저나 함수로 캡슐화하는 것이 더 효율적이고 유지보수하기 쉬울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n창 함수: 고급 데이터 분석을 위해 창 함수는 행 집합에 대한 작업에 특히 더 강력하고 효율적인 접근 방식을 제공할 수 있습니다.\n\n## v. SQL 이외의 대안:\n\n데이터 처리 파이프라인에서 스크립팅: 때로는 데이터 처리 스크립트(예: Python, R)에서 복잡한 조건 로직을 처리하는 것이 SQL 외부에서 처리하는 것보다 더 효율적일 수 있습니다.\n\n데이터 변환 도구 활용: 데이터 변환 도구(예: ETL 도구)는 복잡한 데이터 조작을 처리하는 더 직관적이고 효율적인 방법을 제공하는 경우도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## vi. Best Practices Consideration:\n\nCASE WHEN이 주어진 작업에 가장 적합한 도구인지를 평가하는 것이 매우 중요합니다. 이때 양식의 복잡성과 데이터 집합의 크기를 함께 고려해야 합니다.\n\n정기적으로 SQL 쿼리를 검토하고 리팩토링하여 데이터와 요구 사항이 발전함에 따라 효율적이고 유지 관리가 용이한 쿼리일 수 있도록 합니다.\n\n이러한 한계와 대안을 이해함으로써 다양한 데이터 조작 및 분석 시나리오에서 SQL을 더 효과적이고 효율적으로 사용할 수 있습니다. 이는 데이터 전문가들이 특정 요구 사항에 맞는 올바른 도구를 선택하도록 도와주며, 단숨함, 성능, 유지 관리성을 균형 있게 고려하게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 9. 실제 응용 분야\n\n데이터 과학에서, CASE WHEN은 데이터 클리닝, 분류 및 피쳐 엔지니어링에 응용됩니다. 예를 들어 고객 행동을 분류하거나 일관성 없는 데이터 항목을 정리하는 데 사용됩니다.\n\na. 데이터 클리닝: 예를 들어, 성별의 불일치하는 표현이 포함된 데이터셋이 있다고 가정해 봅시다 (예: 'M', 'Male', 'F', 'Female'). 이러한 값을 표준화하기 위해 CASE WHEN을 사용할 수 있습니다:\n\n```js\nSELECT \n    CASE \n        WHEN Gender IN ('M', 'Male') THEN '남성'\n        WHEN Gender IN ('F', 'Female') THEN '여성'\n        ELSE '기타'\n    END AS 표준화된성별\nFROM Users;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nb. 고객 행동 분류: 소매 데이터셋에서 구매 빈도에 따라 고객을 분류합니다:\n\n```sql\nSELECT \n    CustomerID,\n    CASE \n        WHEN PurchaseCount \u003e 50 THEN '자주 구매하는 고객'\n        WHEN PurchaseCount BETWEEN 10 AND 50 THEN '가끔 구매하는 고객'\n        ELSE '거의 구매하지 않는 고객'\n    END AS BuyerType\nFROM CustomerPurchases;\n```\n\nc. 기계 학습 모델을 위한 피처 엔지니어링: 연령과 소득에 기반하여 신용 위험을 예측하는 머신 러닝 모델을 위한 새로운 피처를 생성합니다:\n\n```sql\nSELECT \n    Age,\n    Income,\n    CASE \n        WHEN Age \u003c 30 AND Income \u003c 50000 THEN '낮은 위험'\n        WHEN Age \u003e= 30 AND Income \u003e= 50000 THEN '높은 위험'\n        ELSE '보통 위험'\n    END AS RiskCategory\nFROM CustomerData;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 예시들은 CASE WHEN의 실용성과 다양성을 보여줍니다. 특히 데이터 클리닝, 고객 행동 분석, 예측 모델링을 위한 피처 엔지니어링과 같은 데이터 과학 응용 프로그램에서 이러한 기능을 활용하기에 유용합니다.\n\n## 10. 모범 사례\n\n- 조건을 간단하고 가독성 있도록 유지합니다.\n- 지나치게 복잡한 중첩 CASE WHEN 문을 피합니다.\n- 대규모 데이터셋에서 성능을 테스트합니다.\n\n## 11. 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCASE WHEN은 SQL에서 조건부 데이터 조작을 위한 강력한 도구입니다. 다양한 SQL 환경에서의 유연성은 데이터 과학 전문가들에게 귀중한 도구로 만들어 줍니다.\n\n여기서 소개된 개념과 예제를 이해하고 적용함으로써 데이터 조작 능력을 향상시킬 수 있습니다. 데이터 과학 여정을 생산적이고 매혹적으로 만드는 데 도움이 될 것입니다.\n\nCASE WHEN에 대한 이 탐구는 SQL 기능을 배우는 것 이상의 의미가 있습니다. 데이터 처리 능력에 유연성과 효율성을 더해주는 도구로 데이터 과학 여정을 강화시키는 것입니다.\n\n이러한 개념을 계속해서 탐구하고 적용할수록 각 쿼리는 단순히 한 가지 명령이 아니라 데이터 과학의 기술을 습득하는 한 걸음이라는 것을 기억해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n계속 실험하고, 학습하고, 무엇보다 중요한 것은 여정을 즐기는 것이에요!\n\n⭐️ 내 Gumroad 샵: [codewarepam의 Gumroad](https://codewarepam.gumroad.com/)\n\n무료 eBook, AI 트렌드, 그리고 데이터 과학 사례 연구를 꾸준히 받고 싶다면, 지금 구독하세요!\n\n# 베스트셀러 eBook:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTop 50+ ChatGPT Personas for Custom Instructions\n\n# 무료 eBook:\n\n- Prompt Engineering 예술 습득하기\n- 데이터 과학자를 위한 Top 50+ 효과적인 ChatGPT 프롬프트\n- 완벽한 AI 예술 프롬프트 습득하기: Top 50+ 프롬프트\n- Top 200+ 정교하게 만들어진 프롬프트\n- 데이터 지망생을 위한 도메인 마스터리","ogImage":{"url":"/assets/img/2024-06-22-TheUltimateGuidetoMasteringCASEWHENinSQLforDataWizards_0.png"},"coverImage":"/assets/img/2024-06-22-TheUltimateGuidetoMasteringCASEWHENinSQLforDataWizards_0.png","tag":["Tech"],"readingTime":9},{"title":"SQL에서 임시 테이블의 강력한 기능 탐구하기","description":"","date":"2024-06-22 17:35","slug":"2024-06-22-ExploringthePowerofTemporaryTablesinSQL","content":"\n\nSQL은 가장 인기 있는 관계형 데이터베이스 관리 시스템 중 하나로, 데이터 조작 및 분석을 향상시키는 다양한 기능을 제공합니다. 임시 테이블 사용이 그 중 하나입니다.\n\n![image](/assets/img/2024-06-22-ExploringthePowerofTemporaryTablesinSQL_0.png)\n\n임시 테이블은 세션 내에서 중간 결과 집합을 저장하고 조작할 수 있는 방법을 제공하여 유연성과 성능 향상을 제공합니다. 이 기사에서는 임시 테이블의 세계로 뛰어들어 SQL에서의 이점과 실제 사용 사례를 탐색해 보겠습니다.\n\n# 1. 임시 테이블 이해하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n임시 테이블은 그 이름 그대로 임시로 존재하며 특정 세션에 바인딩된 테이블입니다. 중간 결과를 저장하거나 복잡한 데이터 조작을 수행하는 데 유용합니다. 임시 테이블은 MySQL 임시 디렉토리에 저장되며 시스템에 의해 자동으로 생성된 고유한 이름을 갖습니다. 생성 세션 내에서만 표시되고 액세스할 수 있으며 세션이 종료될 때 자동으로 삭제됩니다.\n\n# 2. 임시 테이블 생성\n\nMySQL에서 임시 테이블을 만드는 것은 간단합니다. 아래 데이터를 임시 테이블에 저장하려는 예제를 살펴봅시다:\n\n```js\n-- 이 쿼리 결과를 임시 테이블로 표시하고 싶어요.\n-- (책 제목과 출판사 국가를 보여줍니다.)\n\nSELECT title, country\nFROM titles\nLEFT JOIN publishers\nUSING (pub_id)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-ExploringthePowerofTemporaryTablesinSQL_1.png\" /\u003e\n\n```js\n-- 임시 테이블 'titles_publishers'을 생성합니다.\n\nCREATE TEMPORARY TABLE titles_publishers\nSELECT title, country\nFROM titles\nLEFT JOIN publishers\nUSING (pub_id)\n\n-- 임시 테이블 'titles_publishers'에서 모든 데이터를 검색합니다.\n\nSELECT *\nFROM titles_publishers;\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-ExploringthePowerofTemporaryTablesinSQL_2.png\" /\u003e\n\n# 3. 임시 테이블 사용하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n-- 'The' 으로 시작하는 책 제목과 출판사 국가를 표시합니다.\n\nSELECT *\nFROM titles_publishers\nWHERE title LIKE 'The%';\n```\n\n\u003cimg src=\"/assets/img/2024-06-22-ExploringthePowerofTemporaryTablesinSQL_3.png\" /\u003e\n\n# 4. 임시 테이블과 일반 테이블 결합하기\n\n임시 테이블을 일반 테이블과 결합할 수 있는 기능은 여러 가지 강력한 측면 중 하나입니다. 이를 통해 임시 데이터를 기존 데이터와 결합하여 복잡한 쿼리를 작성할 수 있습니다. 다음 예제를 살펴보세요:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n-- 'The'으로 시작하는 책 제목과 출판 국가를 표시해주세요.\n\nSELECT titles_publishers.title, publishers.country\nFROM titles_publishers\nLEFT JOIN publishers\nON titles_publishers.publisher_id = publishers.publisher_id\nWHERE titles_publishers.title LIKE 'The%';\n```\n\n![Exploring the Power of Temporary Tables in SQL](/assets/img/2024-06-22-ExploringthePowerofTemporaryTablesinSQL_4.png)\n\n## 5. 임시 테이블 삭제하기\n\n임시 테이블은 세션이 끝나면 자동으로 삭제되지만, 필요한 경우에는 세션이 끝나기 전에 명시적으로 삭제할 수도 있습니다. 임시 테이블을 삭제하려면 DROP TABLE 문을 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n테이블 titles_publishers 삭제;\n```\n\n# 결론\n\nMySQL의 임시 테이블은 중간 결과 세트를 저장하고 조작하는 강력하고 다재다능한 솔루션을 제공합니다. 데이터 조작 작업에서 성능과 유연성을 향상시킵니다.\n\n임시 테이블을 사용하면 MySQL에서 데이터 조작 기능을 향상시키고 더 효율적이고 효과적인 데이터 분석을 수행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# SQL 기초\n\n시간을 내주셔서 감사합니다! 🚀\nSQL 기초에서 더 많은 콘텐츠를 찾아보실 수 있어요 💫","ogImage":{"url":"/assets/img/2024-06-22-ExploringthePowerofTemporaryTablesinSQL_0.png"},"coverImage":"/assets/img/2024-06-22-ExploringthePowerofTemporaryTablesinSQL_0.png","tag":["Tech"],"readingTime":3},{"title":"스트림 프로세싱 엔진과 스트리밍 데이터베이스의 차이점","description":"","date":"2024-06-22 17:32","slug":"2024-06-22-DifferencesBetweenStreamProcessingEnginesandStreamingDatabases","content":"\n\n\u003cimg src=\"/assets/img/2024-06-22-DifferencesBetweenStreamProcessingEnginesandStreamingDatabases_0.png\" /\u003e\n\n리얼타임 분석 분야에서 빠르게 발전하는 가운데, 지난 10년간 다양한 스트림 처리 엔진이 등장했습니다. 주목할 만한 예시로는 Apache Storm, Apache Flink, Apache Samza 등이 있습니다. 이러한 엔진들은 다양한 기업에서 널리 받아들여져 실시간 처리 및 분석 애플리케이션에 상당한 지원을 제공하고 있습니다.\n\n지난 몇 년 동안 새롭고 흥미로운 혁신이 등장했습니다: 스트리밍 데이터베이스. PostgreSQL 플러그인으로 개발된 초기 솔루션이었던 PipelineDB를 시작으로, 카프카를 위해 디자인된 Confluent의 KsqlDB, 그리고 최근에 등장한 오픈 소스인 RisingWave - 분산 SQL 스트리밍 데이터베이스입니다. 이러한 시스템들은 꾸준히 수용과 인기를 얻어왔습니다.\n\n그럼 스트림 처리 엔진과 스트리밍 데이터베이스를 서로 교환해서 사용할 수 있을까요? 이 기사는 각각의 설계 원칙에 대해 알아보며, 이러한 흥미로운 기술들의 차이점, 유사성, 사용 사례, 그리고 잠재적인 미래 전망을 탐구합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 디자인 원칙\n\n스트림 처리 엔진과 데이터베이스는 데이터 스트림 처리에 중요한 기능을 제공합니다. 그러나 사용자 상호 작용 인터페이스 및 데이터 저장 옵션 측면에서 디자인 원칙에서 뚜렷한 차이가 있습니다. 이러한 기술이 등장한 역사적 배경을 명확히 이해하기 위해 각각의 독특한 특성에 대해 자세히 알아보기 전에 관심을 기울여야 합니다.\n\n# 스트림 처리 엔진의 진화\n\n데이터베이스 시스템은 60년 이상의 시간 동안 연구되어 왔지만, 배치 처리 및 스트림 처리를 포괄하는 컴퓨팅 엔진은 비교적 최근의 혁신입니다. 현대 스트림 처리로의 여정은 2004년 구글의 MapReduce 논문 발표로 시작되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMapReduce는 최고의 성능을 위해 상품용 기계 네트워크를 효율적으로 최적화하는 것을 목표로 했습니다. 이 높은 목표는 MapReduce에서 두 가지 주요 기능, Map과 Reduce,을 갖춘 세련된 저수준 프로그래밍 인터페이스의 도입으로 이어졌습니다. 이러한 설계는 유경험 프로그래머에게 핵심 기능에 직접 액세스할 수 있게 해주어 특정 비즈니스 논리를 구현하고 프로그램 병렬 처리를 제어하며 다른 복잡한 세부사항을 자체적으로 관리할 수 있도록 했습니다.\n\nMapReduce를 독특하게 만든 점은 데이터 저장을 원격 분산 파일 시스템과 같은 외부 시스템에 위임하여 처리에만 초점을 맞춘 것입니다. 이 분할은 오늘날의 스트림 처리 엔진에 영향을 주고 스트리밍 데이터베이스와의 중요한 차이점 및 시너지 파악을 위한 무대를 설정했습니다.\n\n회사 내에서 MapReduce를 성공적으로 활용하기 위해 다음 세 가지 중요 사전 조건이 필요했습니다:\n\n- 회사는 상당량의 데이터와 관련 비즈니스 시나리오를 내부에 보유해야 합니다.\n- 회사는 상품용 기계에 충분히 액세스할 수 있어야 합니다.\n- 회사는 숙련된 소프트웨어 엔지니어 집단을 고용해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 세 가지 조건은 맵리듀스가 2004년에 소개될 때 대부분의 기업들이 달성하기 어려웠던 벽이었습니다. 소셜 네트워크와 모바일 인터넷의 폭발적인 성장으로 2010년 이후에야 첫 번째 조건이 충족되기 시작했습니다. 이러한 변화로 주요 기업들은 스트림 처리 기술에 관심을 기울이고, 두 번째와 세 번째 전제 조건을 충족하기 위해 크게 투자했습니다. 이 투자는 2010년쯤부터 시작된 스트림 처리 엔진의 발전 시대를 의미했습니다. 이 기간 동안 Apache Storm, Apache Samza, Apache Flink 등 다수의 탁월한 스트림 처리 엔진이 등장했습니다.\n\n이 신생 스트림 처리 엔진들은 맵리듀스 디자인 패턴의 핵심 원칙을 완전히 수용했습니다. 구체적으로 다음과 같습니다:\n\n- 사용자에게 저수준 프로그래밍 인터페이스 노출;\n- 데이터 스토리지 제어 양보.\n\n이 디자인은 빅데이터 시대에 적합하게 개조되었습니다. 일반적으로 대량 데이터 처리를 필요로 하는 기술 기업들은 자체 데이터 센터와 전문 엔지니어링 팀을 보유했습니다. 이 기업들이 필요로 한 것은 성능 향상과 더 다채로운 프로그래밍 패러다임이었습니다. 전문 엔지니어링 팀과 함께하면 보통 분산 파일 시스템을 배포하여 방대한 데이터 스토리지를 처리할 수 있었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 2015년 이후 클라우드 컴퓨팅 기술의 혁신적인 발전으로 풍경이 변화하기 시작했습니다. 기술적 배경이 부족한 기업들조차도 스트림 처리 기술에 접근하고자 했습니다. 이 수요에 대응하여 스트림 처리 엔진은 SQL을 채택해 간결하고 폭넓게 인정받는 프로그래밍 언어가 되었습니다. 이 적응으로 인해 더 많은 사용자들이 스트림 처리 기술의 혜택을 누릴 수 있게 되었습니다. 그 결과, 오늘날 주요한 스트림 처리 엔진은 사용자 상호작용에 계층적 접근 방식을 제공하며 Java와 Scala와 같은 낮은 수준의 프로그래밍 인터페이스와 더 접근성 있는 고수준의 SQL 프로그래밍 인터페이스를 제공합니다.\n\n# 사용자 상호작용 인터페이스\n\n현대의 스트림 처리 엔진은 Java와 Scala와 같은 낮은 수준의 프로그래밍 인터페이스뿐만 아니라 SQL 및 Python과 같은 고수준 인터페이스도 제공합니다. 이러한 인터페이스는 병렬성과 같은 다양한 시스템 런타임 세부 정보를 노출하여 사용자가 응용프로그램의 설령 미묘한 측면들을 제어할 수 있게 합니다. 다른 한편으로, 스트리밍 데이터베이스는 주로 SQL 인터페이스를 특징으로 하며 런타임 복잡성을 단순화합니다. 일부는 파이썬 및 자바와 같은 언어로 사용자 정의 함수(UDF)를 제공하여 표현 능력을 향상시킵니다. 이러한 사용자 상호작용 인터페이스의 다양성은 두 가지 주요 균형을 유발합니다.\n\n1. 유연성과 사용 편의성 사이의 균형 유지\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n능숙한 프로그래머들은 Java와 Scala와 같은 저수준 인터페이스가 제공하는 풍부한 표현 능력을 누릴 수 있습니다. Turing-complete 언어인 Java, Scala 및 유사한 언어는 이론적으로 사용자가 어떤 로직이든 표현할 수 있도록 합니다. 기존 Java 및 Scala 라이브러리를 보유한 기업에게는 특히 유리합니다.\n\n그러나 이러한 접근법은 Java나 Scala에 익숙하지 않은 사람들을 막을 수 있으며 복잡함 때문에 시간이 많이 소요될 수 있습니다. 시스템의 사용자 정의 API를 마스터하는 것은 기술적인 사용자에게도 어려울 수 있습니다.\n\n스트리밍 데이터베이스에서 더 높은 수준의 SQL 인터페이스를 통해 사용 편의성을 강조하면 몇 가지 사용 가능한 도전 과제가 있습니다. 첫 번째는 SQL 지원의 완성도로, 단순한 DML (데이터 조작 언어) 문이 아닌 복잡한 DDL (데이터 정의 언어) 작업이 필요할 수 있습니다. 사용자들은 종종 롤, 사용자, 인덱스 생성 또는 삭제와 같은 복잡한 작업이 필요합니다. 두 번째는 SQL 생태계의 지원으로, DBeaver나 pgAdmin과 같은 관리 도구와의 호환성을 포함하여 추가 노력이 필요할 수 있습니다.\n\n저수준 인터페이스는 기술 중심 사용자에게 더 많은 유연성을 제공하며, 스트리밍 데이터베이스의 SQL 인터페이스는 비즈니스 중심 사용자를 위해 특별히 설계되어 사용 편의성을 강조합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n2. 유연성과 성능의 균형\n\n낮은 수준의 프로그래밍 인터페이스의 가용성은 사용자가 이전 지식을 활용하여 시스템 성능을 최적화할 수 있게 합니다. 심층적인 프로그래밍 전문 지식과 비즈니스 논리 이해력을 갖춘 사람들은 종종 낮은 수준의 인터페이스를 통해 탁월한 성능을 얻을 수 있습니다. 그러나 이에는 회사가 엔지니어링 팀을 구축하기 위해 더 많은 투자를 해야 할 수도 있습니다.\n\n대조적으로, 고수준 프로그래밍 인터페이스를 사용할 때 계층적 스트림 처리 엔진은 성능 단점을 겪을 수 있습니다. 캡슐화는 성능 오버헤드를 야기하며 캡슐화 계층이 더 많을수록 성능이 더 나빠집니다. 스트림 처리 엔진의 중간 계층은 하위 디자인이 고수준 논리에 어둡게 되어 성능 손실을 야기할 수 있습니다. 비교적으로, SQL 인터페이스와 최적화 기능만을 제공하는 스트리밍 데이터베이스는 더 높은 성능 수준에 도달할 수 있습니다.\n\n요약하면, 낮은 수준의 인터페이스를 갖춘 스트림 처리 엔진은 기술 중심 사용자가 성능 이점을 얻을 수 있도록 해줍니다. 반면 SQL 인터페이스를 제공하는 스트리밍 데이터베이스는 비즈니스 중심 사용자를 위해 맞춤화되어 있으며 복잡한 기술 전문 지식이 필요 없이도 더 높은 성능 경계를 달성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터 저장\n\n사용자 상호 작용 인터페이스 외에도 스트림 처리 엔진과 스트리밍 데이터베이스 사이의 가장 중요한 차이점은 시스템이 데이터를 저장하는지 여부입니다. 스트림 처리에서 데이터 저장의 유무는 성능, 오류 복구, 확장성 및 사용 사례와 같은 시스템의 여러 측면에 직접적으로 영향을 미칩니다.\n\n스트림 처리 엔진에서 데이터 입력 및 출력은 일반적으로 HDFS와 같은 원격 분산 파일 시스템과 같은 외부 시스템에서 발생합니다. 반면, 스트리밍 데이터베이스는 계산 능력 뿐만 아니라 데이터 저장 기능도 포함하고 있습니다. 이는 적어도 두 가지 작업을 수행할 수 있다는 것을 의미합니다: 1) 입력을 저장하고, 2) 출력을 저장합니다.\n\n데이터 입력 측면에서 데이터 저장은 중요한 성능 이점을 제공합니다. 예를 들어, 데이터 입력을 저장하는 경우 성능상의 이점이 있습니다. 메시지 큐(예: Kafka)에서의 데이터 스트림과 원격 데이터베이스(예: MySQL)에 저장된 테이블을 결합하는 단순한 스트림 처리 엔진의 시나리오를 고려해 보겠습니다. 스트림 처리 엔진이 데이터 저장 기능이 없는 경우, 새로운 데이터 항목이 스트림에 들어올 때마다 연산을 수행하기 전에 원격 데이터베이스에서 데이터를 가져와야 합니다. 이 접근 방식은 초기 분산 스트림 처리 엔진에서 채택되었습니다. 시스템 아키텍처를 간단화하는 장점이 있지만, 성능이 급격히 저하된다는 단점이 있습니다. 서로 다른 시스템 간의 데이터 접근은 명백히 높은 지연 시간을 유발하며, 지연 시간에 민감한 스트림 처리 엔진에 높은 지연 작업을 도입하면 성능이 떨어지게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스트림 처리 시스템 내부에 데이터를 저장(또는 캐싱)하면 시스템 간 데이터 접근을 피할 수 있어 성능을 향상시킬 수 있습니다. 내장 저장 기능을 갖춘 스트림 처리 시스템인 스트리밍 데이터베이스에서는 사용자가 필요에 따라 메시지 대기열에서 데이터 스트림을 가져와 원격 데이터베이스의 테이블과 결합해야 할 때 해당 테이블을 직접 스트리밍 데이터베이스로 복제할 수 있습니다. 이렇게 하면 모든 접근이 내부 작업으로 처리되어 효율적인 처리가 가능해집니다. 물론 이것은 단순화된 예시일 뿐입니다. 실제 시나리오에서는 원격 데이터베이스의 대규모 또는 동적으로 변화하는 테이블과 같은 문제가 발생할 수 있으나 이에 대해 자세히 다루지는 않겠습니다.\n\n출력 측면에서 출력 결과를 저장하는 것은 상당한 이점을 제공할 수 있습니다. 간단히 말해 네 가지 주요 장점은 다음과 같습니다:\n\n- 데이터 스택 아키텍처를 단순화: 계산을 위해 별도의 스트림 처리 엔진과 데이터 저장 및 쿼리 응답을 위한 별도의 저장 시스템을 사용하는 대신 스트리밍 데이터베이스와 같이 단일 시스템이 계산, 저장 및 쿼리 응답을 처리할 수 있습니다. 이 방식은 데이터 스택을 크게 단순화하고 종종 비용 절감을 이루어냅니다.\n- 계산 리소스 공유 용이: 스트림 처리 엔진에서는 계산 결과가 입력 데이터를 사용하고 계산을 수행한 후 외부 시스템으로 내보내기 때문에 그 결과를 시스템 내에서 직접 재사용하기가 어렵습니다. 내장 저장 기능을 갖춘 스트리밍 데이터베이스는 계산 결과를 내부적으로 머티얼라이징된 뷰로 저장해 다른 계산이 이 리소스에 직접 액세스하고 재사용할 수 있게 해줍니다.\n- 데이터 일관성 보장: 스트림 처리 엔진은 처리에 대한 정확히 한 번 문맥을 보장할 수 있지만 결과 액세스 일관성을 보장할 수는 없습니다. 스트림 처리 엔진은 저장소가 없기 때문에 계산 결과를 하류 저장 시스템으로 가져와야 합니다. 상류 엔진은 결과의 버전 정보를 하류 시스템으로 출력하여 하류 시스템의 사용자에게 보여지는 일관된 결과를 얻도록 해야 합니다. 이는 일관성 보장 부담을 사용자에게 지우게 됩니다. 반면, 저장 기능을 갖춘 스트리밍 데이터베이스는 시스템 내에 계산 진행 상태와 결과 버전 정보를 관리하여 사용자가 다중 버전 컨트롤을 통해 항상 일관된 결과를 보게끔 해줍니다.\n- 프로그램 해석 용이성 향상: 프로그램 개발 중에는 반복적인 수정과 정확성 검증이 흔합니다. 정확성을 검증하는 공통 접근 방법은 입력 및 출력을 얻어와 계산 논리가 기대에 부응하는지 수동으로 검증하는 것입니다. 이 작업은 배치 처리 엔진에서는 비교적 간단하지만 스트림 처리 엔진에서는 더 복잡합니다. 스트림 처리 엔진에서는 입력 및 출력이 동적으로 변하기 때문에 엔진이 저장소가 없고 정확성을 검증하기 위해 상류 메시지 소스, 하류 결과 저장 시스템 및 스트림 처리 엔진을 횡단해야 합니다. 게다가 사용자는 계산 진행 정보를 인식해야 해 복잡한 작업이 됩니다. 이에 비해 스트리밍 데이터베이스에서는 계산 결과가 데이터베이스 내에 저장되므로 상류 시스템에서 입력을 얻은 후(일반적으로 Kafka와 같은 메시지 대기열로 직접 오프셋을 가져오는 방식) 단일 시스템 내에서 결과를 검증하기만 하면 됩니다. 이는 개발 효율을 크게 향상시킵니다.\n\n물론 공짜 점심은 없으며 소프트웨어 개발은 단순해 보이는 해결책을 제공하지 않습니다. 스트림 처리 엔진과 비교했을 때 저장 기능을 갖춘 스트리밍 데이터베이스는 아키텍처, 리소스 활용, 일관성 및 사용자 경험에서 많은 장점을 제공합니다. 하지만 그에 따라 어떤 것을 희생해야 할까요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 가지 중요한 희생은 소프트웨어 설계의 복잡성입니다. MapReduce의 설계를 기억해보세요. MapReduce의 개념은 오라클과 IBM과 같은 거대 기업이 전체 데이터베이스 시장을 지배하던 시절에 뛰어났습니다. 왜냐하면 이들은 많은 보통 컴퓨터를 사용하는 기술 기업을 위해 대규모 병렬 컴퓨팅을 가능케 하는 간단한 모델을 효과적으로 활용했기 때문입니다.\n\nMapReduce는 데이터베이스의 저장 및 연산 통합 개념을 직접 역전시켰으며, 연산을 독립적인 제품으로 분리했습니다. 이를 통해 사용자는 프로그래밍을 통해 연산을 확장할 수 있게 되었습니다. 다시 말해, MapReduce는 간소화된 아키텍처를 통해 대규모 수평 스케일링을 실현했으며, 높은 수준의 전문 기술 사용자의 유능성에 의존했습니다.\n\n그러나 시스템이 데이터 저장을 필요로 하는 경우, 모든 것이 더욱 복잡해집니다. 그러한 시스템을 사용 가능하게 만들기 위해 개발자는 고가용성, 장애 복구, 동적 스케일링, 데이터 일치성 및 기타 다양한 도전에 대한 섬세한 설계와 구현을 고려해야 합니다. 다행히도 지난 10년 동안 대규모 데이터베이스와 스트림 처리의 이론과 실무가 크게 발전해왔습니다. 따라서 지금은 스트리밍 데이터베이스의 등장에 이상적인 시기라고 할 수 있습니다.\n\n# 활용 사례\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n계산 모델에서 유사성을 공유하고 있지만, 스트리밍 처리 엔진과 스트리밍 데이터베이스는 여전히 고유한 응용 및 기능으로 이어지는 세세한 점들이 있습니다. 이러한 기술들은 응용 분야에서 중첩되어 있지만, 최종 사용자의 초점에서 차이가 나타납니다.\n\n스트림 처리 엔진은 일반적으로 기계 중심의 작업과 더 일치하며 데이터 저장 기능이 부족하며 종종 계산 결과 소비를 위해 하류 시스템과 통합이 필요합니다. 반면에, 스트리밍 데이터베이스는 더 많은 인간 상호 작용을 고려하여 저장 및 임의 쿼리 지원을 제공함으로써 직접적인 인간 참여를 가능하게 합니다.\n\n기계와 인간 사이의 이분법은 기계가 하드코딩된 프로그램의 고성능 처리를 요구하면서, 인간은 더 인터랙티브하고 사용자 친화적인 경험을 선호한다는 것을 보여줍니다. 이 본질적인 이견으로 인해 스트림 처리 엔진과 스트리밍 데이터베이스 간의 기능, 사용자 경험 및 기타 측면에서 차이가 생깁니다.\n\n요약하면, 이러한 기술들 간의 응용 시나리오에서의 공통점은 최종 사용자와 상호 작용 모드에 특정 초점이 있어 각 시스템 내에서 독특한 기능을 결과로 낳습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 역사적 차원으로 나아가는 거담아, 아니면 현재 시대의 트렌드일까요?\n\n데이터베이스와 컴퓨팅 엔진은 종종 서로 다른 두 가지 설계 철학을 반영합니다. 그것들은 독특한 학계 기여와 산업 발전을 통해 명백히 입증됩니다.\n\n학계에서는 컴퓨팅 엔진 논문들이 주로 OSDI, SOSP, EuroSys와 같은 시스템 회의에서 발표되는 반면, 데이터베이스 중심 작업들은 주로 SIGMOD 및 VLDB 회의에서 자주 볼 수 있습니다. 이 분할은 2008년 David DeWitt와 Michael Stonebraker에 의한 \"MapReduce: 역사적인 큰 걸음\" 비평에 의해 유명하게 강조되었습니다. 그들은 MapReduce가 역사적으로 후퇴적이고 데이터베이스에 비해 더 많은 혁신이 필요하다고 주장했습니다.\n\n스트림 처리의 영역에서, 다음 질문이 등장합니다: 어떤 철학이 역사적으로 후퇴를 대표하고, 어떤 것이 현재 시대의 트렌드를 대변할까요? 저는 스트림 처리 엔진과 스트리밍 데이터베이스가 앞으로 최소 3~5년 동안 공존하고 계속 발전할 것으로 판단합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스트림 처리 엔진은 극한의 성능과 유연성에 중점을 둬 기술적으로 뛰어난 사용자들을 대상으로 합니다. 한편, 스트리밍 데이터베이스는 사용자 경험의 우아함과 높은 성능 그리고 섬세한 내부 구현을 균형있게 갖추고 있습니다. 이러한 철학 간 상호 통합 트렌드는 SQL 인터페이스를 도입해 사용자 경험을 향상시키는 컴퓨팅 엔진과 UDF 기능을 활용해 프로그래밍 적응성을 높이는 데이터베이스 등 양쪽을 모두 강화시킵니다.\n\n# 스트림 처리의 미래 예측\n\n역사를 살펴보면, 스트리밍 데이터베이스 개념은 20년 전에 이미 제안되고 구현되었습니다. 예를 들어, 앞서 언급된 Aurora 시스템은 이미 스트리밍 데이터베이스입니다. 그러나 스트리밍 데이터베이스는 스트림 처리 시스템만큼 인기가 없습니다. 역사는 나선형 패턴으로 진행됩니다.\n\n빅 데이터 시대는 스트림 처리와 데이터베이스를 분리하고 오라클, IBM, Microsoft와 같은 세 거인의 독점을 무너뜨리는 트렌드를 경험했습니다. 최근 클라우드 시대에서는 2012년 전후부터 배치 처리 시스템 분야에서 Redshift, Snowflake, Clickhouse와 같은 시스템이 \"컴퓨팅 엔진\"을 \"데이터베이스\"로 돌아오게 하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 스트림 처리를 데이터베이스로 돌려보는 시기입니다. 이것이 현대 스트리밍 데이터베이스인 RisingWave와 Materialize의 주요 아이디어입니다. 그런데 왜 이 시점인 걸까요? 이 부분에서 자세히 분석해보겠습니다.\n\n20년 이상의 개발 노력을 거친 끝에, 스트림 처리는 상용적 채용이라는 측면에서 아직 초기 단계에 머물러 있습니다, 특히 배치 처리와 비교했을 때 말이죠. 그러나 산업계는 스트림 처리 방향에 대해 합의에 이르렀습니다. 스트림 처리 엔진과 스트리밍 데이터베이스 모두 스트림과 배치 처리를 지원해야 한다는 필요성에 동의합니다. 주요 차이점은 이 두 가지 다른 컴퓨팅 모델을 조화롭게 통합하는 데 있습니다. 본질적으로 “통합된 스트림과 배치 처리” 개념은 이 분야에서 공유되는 이해 관계가 되었습니다.\n\n이 통합을 달성하는 일반적인 세 가지 방법이 있습니다:\n\n- 단일 엔진 접근\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 전략은 스트림 처리 및 일괄 처리 기능을 관리하기 위해 동일한 컴퓨팅 엔진을 사용하는 것을 포함합니다. 이의 장점은 비교적 간단한 실행 계획과 더 통합된 사용자 경험을 제공한다는 것입니다. 그러나 스트림 처리 및 일괄 처리는 최적화 및 계산 방법과 같은 실행 측면에서 상당한 차이가 있기 때문에 각각을 구분하여 최고의 성능을 달성하기 위한 처리가 종종 필요합니다.\n\n2. 이중 엔진 접근\n\n이 접근 방식에서는 스트림 처리와 일괄 처리가 두 개의 고유한 시스템 엔진으로 별도로 구성됩니다. 각각을 특정 최적화할 수 있는 장점이 있지만, 공학 리소스의 상당한 투입, 공학 팀 내의 높은 협력 수준 및 엄격한 우선 순위 관리가 필요합니다. 양쪽을 조율하고 둘 다 원활하게 작동시키는 것이 상당한 도전이 될 수 있습니다.\n\n3. 섞여서 시스템 접근 방식\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 세 번째 접근 방식은 새로운 이상적인 시스템을 만드는 대신 기존 시스템을 재활용하여 통합된 사용자 경험을 제공하는 것을 포함합니다. 엔지니어링에 가장 부담이 적을 수 있는 방법으로 보이지만, 매끄러운 사용자 경험을 제공하는 것은 매우 어려울 수 있습니다. 기존 시장 시스템은 인터페이스 지원에서 다양하며 SQL을 사용하더라도 다른 방언을 사용할 수 있습니다. 이러한 불일치로부터 사용자를 보호하는 것이 핵심적인 문제가 됩니다. 게다가, 여러 시스템을 조율하여 상호 작용하고, 서로 인식하도록 유지하는 것은 복잡한 엔지니어링 과제를 도입합니다.\n\n비록 스트림 처리 엔진과 스트리밍 데이터베이스는 일부 중복과 디자인 및 실제적인 적용에서 차이가 있을 수 있지만, 둘 다 해당 배치 처리 시스템과 조화를 이루려고 노력합니다. 채택할 접근 방식을 선택하는 것은 궁극적으로 사용자의 평가에 달려 있으며, 그들의 특정 시나리오와 필요에 대한 고려를 고려합니다. 이 의사 결정 프로세스는 각 시스템의 고유한 특성과 요구 사항을 이해하고, 넓은 컴퓨팅 환경 내에 어떻게 맞는지 강조합니다.","ogImage":{"url":"/assets/img/2024-06-22-DifferencesBetweenStreamProcessingEnginesandStreamingDatabases_0.png"},"coverImage":"/assets/img/2024-06-22-DifferencesBetweenStreamProcessingEnginesandStreamingDatabases_0.png","tag":["Tech"],"readingTime":12},{"title":"SQL에서는 쉽지만 NoSQL에서는 어려운 다대일 관계 설정 방법","description":"","date":"2024-06-22 17:31","slug":"2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL","content":"\n\n![img](/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_0.png)\n\n- 소개\n- 일대다 관계\n  - 참조 패턴\n  - 내장 패턴\n  - 부분 내장 패턴\n- 다대다 관계\n  - 중간 컬렉션\n  - 양방향 및 단방향 다대다 관계\n- 결론\n\n# 소개\n\n본 글에서는 SQL 및 NoSQL에서 일대다 및 다대다 관계를 모델링하는 방법의 차이점을 살펴볼 것입니다. 또한 NoSQL (문서 지향 데이터베이스)에서 사용되는 다양한 패턴을 탐구하고, 언제 어떤 것을 적용해야 하는지 이해해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 일대다 관계\n\n우리가 Article과 Comment 엔티티를 가진 애플리케이션을 개발하고 있다고 상상해 봅시다. 또한 요구사항은 다음과 같습니다:\n\n- 하나의 글에는 하나 이상의 댓글이 포함될 수 있습니다.\n- 하나의 댓글은 하나의 글에만 속할 수 있습니다.\n\n위 요구사항은 두 엔티티 간에 일대다 관계를 사용해야 함을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQL 데이터베이스에서는 보통 Articles 및 Comments 두 테이블을 생성하고 외래 키(Comments 테이블에)를 생성하여 일대다 관계를 설정합니다. 클라이언트 코드는 이후 이 두 테이블을 조인하여 댓글이 달린 기사를 가져와야 합니다.\n\n![이미지](/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_1.png)\n\nNoSQL 데이터베이스에서는 일대다 관계를 정의하는 데 더 많은 옵션이 있습니다. 참조, 삽입 또는 혼합 방식 중 하나를 선택할 수 있습니다.\n\n참조 및 삽입 사이에서 선택하는 것은 NoSQL 문서 데이터베이스와 작업할 때 개발자들이 하는 주요 선택사항 중 하나입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 참조 패턴\n\nNoSQL에서 참조 패턴을 사용하는 것은 SQL에서 일대다 관계를 정의하는 것과 비슷합니다. 우리는 기사와 댓글의 두 개의 별도의 JSON 컬렉션을 정의하고, 그들 사이의 관계를 ID를 사용하여 수립할 수 있습니다:\n\n```js\n//기사 컬렉션 (부모)\n[\n  {\n    \"id\": 4,\n    \"title\": \"SQL에서는 다대다/일대다 관계가 간단합니다...\",\n    \"content\": \"...\",\n    \"author\": \"...\",\n    \"postedAt\": \"...\"\n  }\n]\n\n//댓글 컬렉션 (자식)\n[\n  {\n    \"id\": \"...\",\n    \"articleID\": 41,\n    \"content\": \"...\",\n    \"author\": \"...\",\n    \"rating\": \"...\"\n  }\n]\n```\n\n이러한 방식으로 문서를 참조할 때, 기사에 댓글 ID의 배열을 포함하는 것도 고려할 수 있습니다. 그러나 이것은 최적의 해결책이 아닐 수 있습니다. 왜냐하면 기사에는 많은 수의 댓글이 포함될 수 있어서, 문서에는 많은 댓글 ID 배열이 포함될 수 있기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참조 패턴을 사용할 때, 보통 앱은 기사와 관련 댓글을 검색하기 위해 두 번의 쿼리를 수행해야 합니다. 그러나 MongoDB와 같은 문서 지향 데이터베이스는 컬렉션을 단일 읽기 쿼리에서 조인할 수 있는 기능을 제공합니다.\n\n참조 패턴을 사용해야 하는 경우에 대한 일반적인 고려 사항:\n\n✅ 자식 문서가 크거나 많은 경우. 또한 문서 데이터베이스의 문서 당 크기 제한을 고려해야 합니다. 참조 패턴은 이러한 제한을 피하는 데 도움이 됩니다.\n\n✅ 부모 문서와 그 자식 문서가 거의 동시에 읽히거나 쓰이지 않는 경우. 자식 문서가 앱에서 부모 문서와 별도로 사용되는 경우, 이를 서로 다른 컬렉션에 저장함으로써 읽기 및 쓰기 작업이 간편해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✅ 문서 데이터베이스에서 쿼리 기능이 제한적이기 때문에 복잡한 중첩 계층 컬렉션을 만드는 것을 피하는 것이 좋습니다.\n\n✅ 자식 문서는 다른 컬렉션의 다른 유형의 상위 문서에 의해 참조되어야 하며, 데이터 일관성 관리를 간소화하기 위해 참조가 사용될 수 있습니다.\n\n## 임베디드 패턴\n\n반면에, 코멘트 배열은 아티클 문서에 완전히 임베드될 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 글 모음\n[\n  {\n    \"id\": 41,\n    \"title\": \"매니-투-매니/원 관계는 SQL에서 간단합니다...\",\n    \"content\": \"...\",\n    \"author\": \"...\",\n    \"postedAt\": \"...\",\n    \"comments\": [ \n      {\n        \"id\": \"...\",\n        \"content\": \"...\",\n        \"author\": \"...\",\n        \"rating\": \"...\"\n      }\n    ]\n  }\n]\n```\n\n먼저, 포함은 연관된 댓글이 있는 글을 하나의 간단한 조회 작업으로 검색할 수 있도록 해줍니다.\n\n포함 패턴을 사용해야 하는 경우에 대한 일반적인 고려 사항:\n\n✅ 응용 프로그램이 부모 문서와 별도로 자식 문서를 검색(또는 업데이트)할 필요가 없는 경우(도메인 주도 설계의 집합 및 집합 루트 개념을 상기하세요).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✅ 부모와 자식 문서를 한 번의 원자적 쓰기 작업으로 업데이트해야 하는 능력이 필요합니다 (대부분의 문서 지향형 데이터베이스에서 쓰기 작업은 보통 단일 문서 수준에서만 원자적입니다).\n\n✅ 내장 문서는 작고, 그 수도 많지 않습니다 (\"하나 대 소수\" 관계).\n\n✅ 자식 문서의 업데이트는 자식 문서가 생성된 후에 드물게 발생하거나 전혀 발생하지 않습니다.\n\n## Partial Embedded Pattern\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 번째 방법은 참조 및 포함 패턴의 조합입니다. 부모 문서를 검색할 때 자식 문서의 하위 집합만 정기적으로 읽어야 할 경우 사용할 수 있습니다.\n\n예를 들어, 글을 검색할 때 사용자에게 표시할 수 있는 최상위 댓글만 검색해야 할 수 있습니다. 다른 댓글은 나중에 필요할 때 검색하거나 전혀 필요하지 않을 수 있습니다.\n\n```js\n//Article collection (Parent)\n[\n  {\n    \"id\": 41,\n    \"title\": \"Many-to-Many/One Relationships are Simple in SQL...\",\n    \"content\": \"...\",\n    \"author\": \"...\",\n    \"postedAt\": \"...\",\n    \"comments\": [ //Only 1 of 2 comments included\n      {\n        \"id\": 1,\n        \"content\": \"...\",\n        \"author\": \"...\",\n        \"rating\": 10\n       }\n    ]\n  }\n]\n\n//Comment collection (Child)\n[\n  {\n    \"id\": 1,\n    \"articleID\": 41,\n    \"content\": \"...\",\n    \"author\": \"...\",\n    \"rating\": \"...\"\n  },\n  {\n    \"id\": 2,\n    \"articleID\": 41,\n    \"content\": \"...\",\n    \"author\": \"...\",\n    \"raing\": 3\n  }\n]\n```\n\n부분 포함된 패턴은 성능을 향상시키기 위해 단일 읽기 작업에서 글과 최상위 댓글을 검색하는 애플리케이션에 사용될 수 있으며 모든 댓글을 별도의 컬렉션에 저장하는 이점 중 일부를 유지할 수 있습니다. 그러나 일부 자식 문서가 두 군데에 나타나기 때문에 응용 프로그램은 일관성을 보장하기 위해 추가 작업을 수행해야 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 다대다 관계\n\n우리가 프로젝트와 직원 엔티티를 가지고 있다고 상상해봅시다. 아래는 그들에 대한 요구 사항입니다:\n\n- 여러 직원이 하나의 프로젝트에서 일할 수 있습니다.\n- 동일한 직원이 동시에 여러 다른 프로젝트에 할당될 수 있습니다.\n\n여기서 우리는 다대다 관계가 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은-대-많은 관계란 한 테이블의 여러 레코드가 다른 테이블의 여러 레코드와 관련이 있다는 것을 의미합니다.\n\nSQL에서는 추가 테이블을 사용하여 많은-대-많은을 정의합니다:\n\n![Many-to-Many Relationship](/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_2.png)\n\nEmployeeToProjectAssignment 중간 테이블에는 외래 키뿐만 아니라 할당 이벤트에 대한 자세한 정보(이유, 날짜 등)를 제공하는 추가 속성도 포함될 수 있다는 점에 유의하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNoSQL에서는 두 개의 컬렉션 간의 다대다 관계를 정의하는 여러 가지 방법이 있습니다:\n\n## 중간 컬렉션\n\n첫 번째 옵션은 SQL과 유사한 중간 컬렉션을 생성하는 것입니다:\n\n```js\n//프로젝트 컬렉션\n[\n  {\n    \"id\": 41,\n    \"title\": \"전자 상거래\",\n    \"priority\": \"...\",\n    \"dueDate\": \"...\"\n  }\n]\n\n//직원 컬렉션\n[\n  {\n    \"id\": 82,\n    \"name\": \"존 도우\",\n    \"email\": \"...\",\n    \"role\": \"...\"\n  }\n]\n\n//EmployeeToProjectAssignment (중간) 컬렉션\n[\n  {\n    \"id\": 1,\n    \"projectID\": 41,\n    \"employeeID\": 82,\n    \"reason\": \"...\",\n    \"date\": \"...\"\n  }\n]\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중간 컬렉션을 사용할 수 있는 경우:\n\n✅ 다른 속성 (예: 이유, 날짜 등)을 외래 키 외에도 관계에 특정한 많은 속성을 저장해야 할 때\n\n✅ 많은 문서가 관련된 다대다 관계인 경우 중간 컬렉션을 사용하면 문서 크기 제한을 피할 수 있음\n\n✅ SQL에서 NoSQL로 테이블을 빠르게 마이그레이션해야 하는 경우? 중간 SQL 테이블에서 중간 NoSQL 컬렉션으로 데이터를 마이그레이션하는 것이 구현하기 가장 쉬운 방법일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 양방향 및 단방향 다대다 관계\n\n다대다 관계를 정의하는 다음 옵션은 각 직원 문서에 프로젝트 ID 목록을 삽입하고 각 프로젝트 문서에 직원 ID 목록을 삽입하는 것입니다:\n\n```js\n//프로젝트 컬렉션\n[\n  {\n    \"id\": 41,\n    \"title\": \"전자 상거래\",\n    \"priority\": \"...\",\n    \"dueDate\": \"...\",\n    \"employees\": [ 1, 2 ]\n  }\n]\n\n//직원 컬렉션\n[\n  {\n    \"id\": 1,\n    \"name\": \"존 도\",\n    \"email\": \"...\",\n    \"role\": \"...\",\n    \"projects\": [ 41 ]\n  },\n  {\n    \"id\": 2,\n    \"name\": \"제인 도\",\n    \"email\": \"...\",\n    \"role\": \"...\",\n    \"projects\": [ 41 ]\n  }\n]\r\n```\n\n식별자를 포함하는 대신 문서 전체를 포함하는 것도 고려할 수 있습니다. 포함할 내용의 선택은 일대다 관계에 대해 설명된 것과 유사하며, 따라서 반복하지 않겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 참조 또는 포함을 사용하여 다대다 관계를 정의할 때 더 고려해야 할 흥미로운 점이 또 있습니다:\n\n이전의 JSON 예시로 돌아갑시다. 프로젝트 컬렉션에서 employees 배열을 완전히 제거해도 두 컬렉션 간의 다대다 관계가 유지될 수 있습니다. 프로젝트 문서가 검색되면 응용 프로그램에서 관련 직원을 찾기 위해 추가 작업을 수행해야 합니다(직원 컬렉션을 스캔하고 프로젝트 배열을 확인함).\n\n이 방법으로 다대다 관계를 모델링하는 것은 한쪽의 문서 수가 많고 다른 쪽은 매우 적은 경우 선택할 수 있습니다. 예를 들어, 단일 프로젝트에 많은 직원이 참여할 수 있지만, 직원은 한 번에 1~2개의 프로젝트만 작업할 수 있습니다. \n\n그러나 이 경우 문서 크기뿐만 아니라 고려해야 할 사항은 두 컬렉션/엔티티가 응용 프로그램에서 어떻게 사용될지도 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 예시를 상상해봅시다. 국가와 공식 언어 엔티티 간의 다대다 관계입니다. 이 응용 프로그램의 사용 사례가 특정 국가에서 어떤 언어가 사용되는지에만 관심이 있다면 그 반대는 아니라면, 공식 언어 문서에 국가 배열을 저장하는 것은 단순히 중복일 뿐입니다. 국가 문서에 언어 배열을 저장하는 것이 충분합니다.\n\n# 결론\n\nSQL 및 NoSQL 데이터베이스에서 엔티티간 관계를 정의하기 위해 가장 일반적으로 사용되는 두 가지 방법을 비교해보았습니다. 유연한 문서 데이터베이스의 성격으로 인해, NoSQL은 SQL에 비해 일대다 및 다대다 관계를 정의하는 데 더 많은 옵션을 제공합니다.\n\n특정 사례에 가장 적합한 옵션을 선택하려면 응용 프로그램 사용 사례, 데이터 액세스 패턴, 필요한 일관성 수준, 문서 크기 제한 및 기타 요소를 고려해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n읽어 주셔서 감사합니다. 내용이 마음에 드셨다면 아래 이야기도 확인해보세요:\n\n🔔 그리고 Buy Me a Coffee에서 제를 지원해 주시는 걸 고려해 주세요.","ogImage":{"url":"/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_0.png"},"coverImage":"/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_0.png","tag":["Tech"],"readingTime":7},{"title":"GA4 BigQuery Export 스키마와 구조 이해하기","description":"","date":"2024-06-22 17:28","slug":"2024-06-22-UnderstandingtheGA4BigQueryExportSchemaandStructure","content":"\n\n![GA4 BigQuery Export Schema](/assets/img/2024-06-22-UnderstandingtheGA4BigQueryExportSchemaandStructure_0.png)\n\n# 소개\n\n현재 전 세계적으로 15.6 백만 개의 웹 사이트에서 사용 중인 Google Analytics 4는 글로벌 데이터 스키마 중 가장 널리 내보내어진 것 중 하나일 수 있습니다. Google Analytics 4 데이터는 웹 사용자 인터페이스를 통해 액세스하거나 Looker Studio로 API를 통해 직접 접근할 수 있지만, 데이터 소유권을 유지하고자 한다면:\n   \n- 구글의 데이터 보유 정책을 넘어서 데이터 소유권을 보유하려면\n- 데이터 손실 가능성을 방지하기 위해 데이터를 보관하려면\n- 다른 내부 데이터 소스와 데이터를 결합하려면\n- 외부 소스, API 또는 LLM에서 데이터를 확장하려면\n- 사용자 정의 자동화 워크플로우를 구축하려면\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러면 GA4 내보내기를 빅쿼리로 활성화하는 것이 권장되는 접근 방식입니다. 설정 및 구성하기 매우 간단합니다.\n\n좋아요! 작업 완료!\n\n하지만 아직 끝난 게 아닙니다. 매일 빅쿼리 내보내기에 데이터가 나타나기 시작하면 구조가 다소 불규칙하다는 것을 알 수 있을 것입니다. 이는 직접 작업하기 매우 어려워지므로 데이터를 더 쉽게 활용할 수 있는 형식으로 정확하게 변환하는 방법에 대해 설명하는 이 문서를 통해 '하이브리드' 데이터 구조에 대해 설명하고 데이터에 접근하는 방법을 설명합니다. 이는 사용 사례에 적합한 형식으로 변환합니다.\n\n# 조사\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 스키마 요약과 쿼리에서 events_YYYYMMDD는 BigQuery의 Date-Sharded GA4 Export Table을 나타냅니다. 아래와 같은 구문 변형을 사용하여 쿼리할 수 있습니다.\n\n모든 데이터 선택\n\n```js\nSELECT *\nFROM [project_id].[ga4_dataset_name].events_*\n```\n\n날짜 범위 선택\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 예: 지난 7일간의 데이터 선택\n\nSELECT *\nFROM [project_id].[ga4_dataset_name].events_*\nWHERE _TABLE_SUFFIX\nBETWEEN FORMAT_DATE(\"%Y%m%d\", CURRENT_DATE - 7)\nAND FORMAT_DATE(\"%Y%m%d\", CURRENT_DATE))\n```\n\n## GA4 내보내기 스키마\n\nGA4 내보내기의 구조는 표준화되어 있으며 다음 상위 수준 스키마로 나타낼 수 있습니다:\n\n```js\nevents_YYYYMMDD\n    ├── event_date STRING   \n    ├── event_timestamp INTEGER \n    ├── event_name STRING   \n    ├── event_params ARRAY\u003cSTRUCT\u003e  \n    ├── event_previous_timestamp INTEGER    \n    ├── event_value_in_usd FLOAT    \n    ├── event_bundle_sequence_id INTEGER    \n    ├── event_server_timestamp_offset INTEGER   \n    ├── user_id STRING  \n    ├── user_pseudo_id STRING   \n    ├── privacy_info STRUCT \n    ├── user_properties ARRAY\u003cSTRUCT\u003e   \n    ├── user_first_touch_timestamp INTEGER  \n    ├── user_ltv STRUCT \n    ├── device STRUCT   \n    ├── geo STRUCT  \n    ├── app_info STRUCT \n    ├── traffic_source STRUCT   \n    ├── stream_id STRING    \n    ├── platform STRING \n    ├── event_dimensions STRUCT \n    ├── ecommerce STRUCT    \n    ├── items ARRAY\u003cSTRUCT\u003e \n    ├── collected_traffic_source STRUCT \n    └── is_active_user BOOLEAN\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 다른 열 데이터 유형이 있으므로 데이터 원본을 쿼리, 분석 및 후속 데이터 워크플로에 대비하도록 준비하는데 다른 처리가 필요합니다.\n\n## 간단한 데이터 유형\n\n이 하위 집합의 열은 각 행마다 열 당 하나의 연결된 값이 있어 각 열에 대해 특정 데이터 유형이 강제로 적용되는 의미에서 '간단한'으로 간주할 수 있습니다.\n\n```js\nevents_YYYYMMDD\n    ├── event_date STRING   \n    ├── event_timestamp INTEGER \n    ├── event_name STRING   \n    ├── event_previous_timestamp INTEGER    \n    ├── event_value_in_usd FLOAT    \n    ├── event_bundle_sequence_id INTEGER    \n    ├── event_server_timestamp_offset INTEGER   \n    ├── user_id STRING  \n    ├── user_pseudo_id STRING   \n    ├── user_first_touch_timestamp INTEGER  \n    ├── stream_id STRING    \n    ├── platform STRING \n    └── is_active_user BOOLEAN\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDATE 및 TIMESTAMP 필드 중 일부는 일부 유형 변환을 필요로 합니다. 이에 필요한 함수는 다음 기사에 포함되어 있습니다. 그러나 이러한 열은 SQL에서 쉽게 작업할 수 있습니다.\n\n간단한 STRUCT 데이터 유형\n\n다음 하위 집합 열은 모두 STRUCT 데이터 유형입니다. 이는 JSON 또는 JavaScript의 개체에 대응하는 구조, Python의 사전 또는 연관 배열로 일반화할 수 있는 구조입니다:\n\n```js\nevents_YYYYMMDD\n    ├── privacy_info STRUCT \n    ├── user_ltv STRUCT \n    ├── device STRUCT   \n    ├── geo STRUCT  \n    ├── app_info STRUCT \n    ├── traffic_source STRUCT   \n    ├── event_dimensions STRUCT \n    ├── ecommerce STRUCT   \n    └── collected_traffic_source STRUCT\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빅쿼리에서 STRUCT 열은 하위 열의 컨테이너로 간주될 수 있으며, 쿼리 간결성 측면에서 일부 이점을 가지지만 몇 가지 추가적인 도전 과제를 도입하기도 합니다. 위에 나열된 STRUCT 열은 '간단한' 것으로 간주됩니다. 왜냐하면 '간단한' 데이터 유형(즉, ARRAY, STRUCT 또는 JSON 하위 열이 없는)만 포함하고 있기 때문입니다.\n\n예를 들어, geo STRUCT 열에는 이벤트 원점의 감지된 위치를 나타내는 다음과 같은 간단한 STRING 하위 열이 포함되어 있습니다:\n\n```js\nevents_YYYYMMDD\n└── geo STRUCT \n    ├── city STRING \n    ├── country STRING \n    ├── continent STRING \n    ├── region STRING \n    ├── sub_continent STRING \n    └── metro STRING \n```\n\n간단한 STRUCT 하위 열 값은 점 표기법을 사용하여 깔끔하게 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n-- events_YYYYMMDD 테이블에서 geo.city를 선택합니다.\n\nSELECT geo.city\nFROM events_YYYYMMDD\n```\n\n예시에서 도시 이름을 수정된 컬럼 이름으로 불러올 것이며, 이는 STRUCT 접두어 없이 불러온 것입니다 (예시에서는 city). 구조체 데이터 구조를 유지하기 위해, 다음 구문을 사용하여 명시적으로 포함할 하위 컬럼을 설정할 수 있습니다:\n\n```js\n-- events_YYYYMMDD 테이블에서 geo.country, geo.region, geo.city를 선택하며, geo라는 이름으로 결과를 반환합니다.\n\nSELECT \nSTRUCT (\ngeo.country,\ngeo.region,\ngeo.city) AS geo\nFROM events_YYYYMMDD\n```\n\n전체 STRUCT를 포함하거나 제외하는 것도 간단합니다. 전체 STRUCT를 포함하려면, 간단히 해당 STRUCT 열을 SQL 쿼리에서 다른 열처럼 선택하면 됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nSELECT geo\nFROM events_YYYYMMDD\n```\n\n특정 STRUCT 열 (및 모든 하위 열)을 제외하고 다른 모든 열을 포함하려면 EXCEPT 구문을 사용합니다:\n\n```js\nSELECT *\nEXCEPT (geo)\nFROM events_YYYYMMDD\n```\n\nSTRUCT에서 특정 하위 열을 제외하는 구문은 조금 더 길고 직관적이지 않습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sql\nSELECT \n(SELECT AS STRUCT geo.* EXCEPT(continent, sub_continent, metro)) AS geo\nFROM events_YYYYMMDD\n```\n\nLooker Studio에서 STRUCT 데이터 유형을 지원하지만 다른 비즈니스 인텔리전스 도구에서 문제를 일으킬 수 있으므로 데이터 통합을 지원하기 위해 열 이름 변경이 필요할 수 있습니다.\n\n복잡한 ARRAY`STRUCT` 데이터 유형\n\n이 데이터 구조는 각 배열의 STRUCT 데이터 유형을 저장하기 위해 사용되며, 배열에 포함된 각 STRUCT가 동일한 구조를 갖습니다. 데이터를 모델링하는 방법은 특정 컨텍스트에 따라 달라집니다. GA4 BigQuery 내보내기에서 다음 ARRAY`STRUCT` 열이 발견됩니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nevents_YYYYMMDD\n    ├── event_params ARRAY\u003cSTRUCT\u003e  \n    ├── user_properties ARRAY\u003cSTRUCT\u003e     \n    └── items ARRAY\u003cSTRUCT\u003e\n\n\nevent_params ARRAY`STRUCT`에는 GA4에서 설정한 표준 및 사용자 지정 이벤트 매개변수 배열이 포함되어 있습니다. user_properties ARRAY`STRUCT`에는 사용자 지정 사용자 속성 배열이 들어 있으며, items ARRAY`STRUCT`에는 사용자 정의 항목 및 메타데이터의 배열과 연결된 항목 매개변수의 다른 중첩 배열이 포함되어 있습니다.\n\n이전 예제보다 더 복잡하며, STRUCT 스키마를 살펴보면 현실이 더 복잡하다는 것이 빠르게 명확해집니다. 예를 들어, event_params ARRAY`STRUCT` 스키마는 다음과 같습니다:\n\n\nevents_YYYYMMDD\n└── event_params STRUCT\n    ├── key STRING \n    └── value STRUCT\n        ├── string_value STRING \n        ├── int_value INTEGER \n        ├── float_value FLOAT \n        └── double_value FLOAT\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구글 애널리틱스 4 속성에 이벤트 매개변수가 추가되면 이들은 BigQuery로 간단한 STRUCT 형식으로 들어오지 않습니다. 따라서 이들은 BigQuery Studio의 스키마 탭에서 보이지 않고 점 표기법을 통해서도 접근할 수 없습니다.\n\n예를 들어 session_engaged 매개변수는 사용자 배포가 필요 없이 구글에서 생성한 표준 이벤트 매개변수로, 각 특정 이벤트가 참여 세션의 일부인지 여부를 결정할 수 있게 합니다.\n\n만약 event_params STRUCT가 다음과 같은 스키마를 가지고 있다면, session_engaged의 값은 점 표기법을 통해 접근할 수 있을 것입니다 (예: SELECT event_params.session_engaged FROM events_YYYYMMDD):\n\n```js\nevents_YYYYMMDD\n└── event_params STRUCT\n    ├── ga_session_id INTEGER \n    └── ...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 실제 스키마를 고려할 때, session_engaged 값은 다음 SQL 구문을 사용하여 액세스됩니다:\n\n```js\nSELECT \n(SELECT value.int_value FROM UNNEST(event_params) WHERE key='session_engaged') AS `session_engaged`\nFROM events_YYYYMMDD\n```\n\n구문적으로 더 복잡하지만, 이 구문을 사용해야 하는 요구 사항은 추가적인 문제를 야기합니다: 찾고 있는 키의 정확한 이름을 알아야 하고, 예상 데이터 유형도 알아야 합니다. 이는 값 STRUCT가 네 가지 서로 다른 하위 열을 포함하고 있으며, 이 중 하나는 NULL 값이 아니어야 하며 나머지 세 개는 NULL 값이어야 합니다. 이 경우 INT64로 값이 예상되므로 해당 값을 추출합니다.\n\n이 복잡성을 이해하는 것은 이 데이터를 재구성하기 위한 전략을 개발할 때 중요합니다: 데이터의 특정 예상 특성을 알아야만 재구성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 지식을 얻기 위한 계획이 서로 다른 변형 및 자동화 전략으로 향하는 근본적인 동력입니다.\n\n## 가정\n\n또한 원본 데이터에 대한 우리의 가정과 해당 가정 중 하나라도 잘못된 것으로 판명되었을 경우의 결과를 이해해야 합니다.\n\n데이터 형식 일관성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 예에서는 session_engaged가 정수 값일 것이라고 가정하고, 해당 값을 추출하는 쿼리는 정수 값을 추출합니다. 그러나 이전에 역사적 불일치가 있었고 관측된 값이 STRING에서 INTEGER로 변경되었을 경우, 위의 쿼리는 일부 데이터를 소실하지만 조용히 처리될 것입니다. 데이터를 기반으로 한 보고서는 부정확해질 것이지만 하류 사용자는 이를 알 수 없을 것입니다.\n\nBigQuery의 GA4 데이터는 Google에서 설명한 이유로 GA4 사용자 인터페이스나 GA4 API에서 관측된 데이터와 일치하지 않을 것으로 예상됩니다. 비교할 기준이 없는 상황에서 보니 작아 보이는 테스트되지 않은 가정이 검출되지 않은 잘못된 결과로 쉽게 이어질 수 있음을 의미합니다.\n\nsession_engaged 이벤트 매개 변수는 때때로 STRING 값으로 관측되기도 하고, 때로는 INTEGER 값으로 관측되기도 합니다. 따라서 소스 데이터에서 신뢰할 수 있게 이를 추출하려면 아래 쿼리와 같이 보다 고급 전략이 필요합니다:\n\n```js\nSELECT \n(SELECT COALESCE(value.int_value, SAFE_CAST(value.int_value AS INT64) FROM UNNEST(event_params) WHERE key='session_engaged') AS `session_engaged`\nFROM events_YYYYMMDD\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주의하세요! COALESCE는 비용이 많이 소요되는 작업이기 때문에 이 방법을 많은 이벤트 매개변수에 적용하면 쿼리가 리소스 부족으로 실패할 수 있습니다.\n\n고유키\n\n또한 위의 예시들은 각 키가 배열 `STRUCT` 내에서 고유하다고 가정하므로 SELECT… FROM UNNEST… 쿼리는 정확히 한 행을 반환할 것으로 예상됩니다. 이는 상위 시스템에서 강제되는 올바른 가정인 것으로 보입니다. 그러나 BigQuery에서 강제되는 제약 조건은 아닙니다.\n\n이는 미래에 한 행 내에서 이벤트 매개변수 키가 고유하지 않다는 것이 밝혀지면, 해당 값을 추출하는 데 사용된 서브쿼리는 단일 행 대신 여러 행을 반환하고 쿼리는 다음 오류와 함께 실패합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n쿼리 오류: Scalar subquery는 하나 이상의 요소를 생성함\n\nsingle row event_param 내에서 중복 키의 존재가 관찰되지 않았지만, 미래에 이러한 사례가 발생할 가능성이 있는 BigQuery의 기술적 제약은 없습니다. 즉, 앞으로 아무것도 변하지 않을 것을 가정할 수도 있고, 코드에서 잠재적인 변화에 대비할 수도 있습니다.\n\n# 결론\n\n문제는 당신이 아닌 데이터 구조입니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 데이터 구조\n\n본질적으로 BigQuery는 행, 열 및 데이터 조작을 위해 사용되는 SQL 기반 작업을 가진 관계형 데이터베이스로 구성됩니다. BigQuery는 INFORMATION_SCHEMA.COLUMNS를 통해 열 수준의 메타데이터를 사용할 수 있으며 BigQuery Studio 사용자 인터페이스에도 사용할 수 있습니다. 일반적으로 이러한 정보 중 하나를 검사함으로써 데이터 구조를 이해할 수 있습니다.\n\n복잡한 데이터 유형(배열, 구조)의 포함은 약간의 복잡성을 추가하지만 사용자 인터페이스와 INFORMATION_SCHEMA(둘 다 COLUMNS 및 COLUMN_FIELD_PATHS)에도 열 및 하위 열 메타데이터가 사용 가능하기 때문에 검사 및 자동화 사용 사례를 충족시킬 수 있습니다.\n\n그러나 배열`구조`열 내 여러 중첩 키-값 구조의 복잡한 구현으로 인해 데이터의 의미 구조를 메타데이터를 통해 이해하는 능력을 상실하므로 전형적인 관계 구조가 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기본적으로 event_params, user_properties 및 item_params 데이터 구조는 이 데이터 원본이 전형적인 관계형 구조가 아니라 관계형, 반정형 및 키-값 저장소 특성이 혼합된 구조임을 의미합니다. 이것은 복잡하며, 데이터의 내용이 변경될 때 (시간이 지남에 따라 예상대로), 아래쪽 모델에서 이 데이터를 포착하기 위해 출력 데이터의 스키마를 변경해야 합니다.\n\n즉, 하류 모델에서 데이터를 사용할 수 있도록 데이터를 준비하는 데 사용된 접근 방식은 이 예상된 스키마 진화를 고려해야 합니다.\n\n## 접근 방식\n\n이 복잡한 소스 데이터를 후속 사용을 위해 다시 구조화하는 몇 가지 접근 방식이 있습니다. 이 단계에서는 데이터 변환 로직을 고려하고 있으며, 데이터 변환을 트리거하거나 실행하는 데 사용된 접근 방식이 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n변환 코드는 다음과 같이 가능합니다:\n\n- 수동으로 제작되어서는 수동 검사와 시행착오가 필요합니다;\n- 다양한 GA4-BigQuery 인터넷 자료에서 수동으로 조정되었습니다;\n- AI로 생성되었지만 (일반적으로 좋은 아이디어는 아닙니다... 정확한지 어떻게 알 수 있을까요? SQL을 배우세요!);\n- Dataform이나 DBT와 같은 변환 도구에 내장된 모델을 사용하여 생성된 구성 요소;\n- 관측 데이터를 기반으로 변환 논리를 구축하는 자동화 방법.\n\n다음 기사에서는 위에 설명된 접근 방식을 사용하여 GA4 BigQuery 모델링 과제를 해결하는 다양한 옵션을 탐색할 것입니다.\n\n## 다음 단계\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제를 식별하고 상세히 탐색하는 것은 문제를 해결하는 것과 같지 않다는 것을 기억해주세요!\n\n그러나 이 기사의 목적은 당신이 이 데이터셋을 다뤄야 했을 때 느낄 수 있는 'why?!' (또는 더 정확히는 'wtf?!')를 개략적으로 설명하고, 수많은 도전에 대처할 때 고려해야 하는 다양한 고려 사항을 논의하는 것입니다.\n\n이 시리즈의 다음 기사는 현재 존재하는 다양한 실용적 옵션을 탐험하며, 그 비용, 노력, 기술/기술 요구 사항 및 제한 사항에 대해 다룰 것입니다.\n\n다음 내용을 받아보려면 저를 팔로우해주세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 스키마 참조\n\n참고를 위해 전체 소스 데이터 스키마를 아래에 재현하고 있습니다. 편집 가능한 형식은 다음과 같습니다.\n\n```js\nevents_YYYYMMDD\n├── event_date STRING\n├── event_timestamp INTEGER\n├── event_name STRING\n├── event_params ARRAY\u003cSTRUCT\u003e\n│   ├── key STRING\n│   └── value STRUCT\n│       ├── string_value STRING\n│       ├── int_value INTEGER\n│       ├── float_value FLOAT\n│       └── double_value FLOAT\n├── event_previous_timestamp INTEGER\n├── event_value_in_usd FLOAT\n├── event_bundle_sequence_id INTEGER\n├── event_server_timestamp_offset INTEGER\n├── user_id STRING\n├── user_pseudo_id STRING\n├── privacy_info STRUCT\n│   ├── analytics_storage STRING\n│   ├── ads_storage STRING\n│   └── uses_transient_token STRING\n├── user_properties ARRAY\u003cSTRUCT\u003e\n│   ├── key STRING\n│   └── value STRUCT\n│       ├── string_value STRING\n│       ├── int_value INTEGER\n│       ├── float_value FLOAT\n│       ├── double_value FLOAT\n│       └── set_timestamp_micros INTEGER\n├── user_first_touch_timestamp INTEGER\n├── user_ltv STRUCT\n│   ├── revenue FLOAT\n│   └── currency STRING\n├── device STRUCT\n│   ├── category STRING\n│   ├── mobile_brand_name STRING\n│   ├── mobile_model_name STRING\n│   ├── mobile_marketing_name STRING\n│   ├── mobile_os_hardware_model STRING\n│   ├── operating_system STRING\n│   ├── operating_system_version STRING\n│   ├── vendor_id STRING\n│   ├── advertising_id STRING\n│   ├── language STRING\n│   ├── is_limited_ad_tracking STRING\n│   ├── time_zone_offset_seconds INTEGER\n│   ├── browser STRING\n│   ├── browser_version STRING\n│   └── web_info STRUCT\n│       ├── browser STRING\n│       ├── browser_version STRING\n│       └── hostname STRING\n├── geo STRUCT\n│   ├── city STRING\n│   ├── country STRING\n│   ├── continent STRING\n│   ├── region STRING\n│   ├── sub_continent STRING\n│   └── metro STRING\n├── app_info STRUCT\n│   ├── id STRING\n│   ├── version STRING\n│   ├── install_store STRING\n│   ├── firebase_app_id STRING\n│   └── install_source STRING\n├── traffic_source STRUCT\n│   ├── name STRING\n│   ├── medium STRING\n│   └── source STRING\n├── stream_id STRING\n├── platform STRING\n├── event_dimensions STRUCT\n│   └── hostname STRING\n├── ecommerce STRUCT\n│   ├── total_item_quantity INTEGER\n│   ├── purchase_revenue_in_usd FLOAT\n│   ├── purchase_revenue FLOAT\n│   ├── refund_value_in_usd FLOAT\n│   ├── refund_value FLOAT\n│   ├── shipping_value_in_usd FLOAT\n│   ├── shipping_value FLOAT\n│   ├── tax_value_in_usd FLOAT\n│   ├── tax_value FLOAT\n│   ├── unique_items INTEGER\n│   └── transaction_id STRING\n├── items ARRAY\u003cSTRUCT\u003e\n│   ├── item_id STRING\n│   ├── item_name STRING\n│   ├── item_brand STRING\n│   ├── item_variant STRING\n│   ├── item_category STRING\n│   ├── item_category2 STRING\n│   ├── item_category3 STRING\n│   ├── item_category4 STRING\n│   ├── item_category5 STRING\n│   ├── price_in_usd FLOAT\n│   ├── price FLOAT\n│   ├── quantity INTEGER\n│   ├── item_revenue_in_usd FLOAT\n│   ├── item_revenue FLOAT\n│   ├── item_refund_in_usd FLOAT\n│   ├── item_refund FLOAT\n│   ├── coupon STRING\n│   ├── affiliation STRING\n│   ├── location_id STRING\n│   ├── item_list_id STRING\n│   ├── item_list_name STRING\n│   ├── item_list_index STRING\n│   ├── promotion_id STRING\n│   ├── promotion_name STRING\n│   ├── creative_name STRING\n│   ├── creative_slot STRING\n│   └── item_params ARRAY\u003cSTRUCT\u003e\n│       ├── key STRING\n│       └── value STRUCT\n│           ├── string_value STRING\n│           ├── int_value INTEGER\n│           ├── float_value FLOAT\n│           └── double_value FLOAT\n├── collected_traffic_source STRUCT\n│   ├── manual_campaign_id STRING\n│   ├── manual_campaign_name STRING\n│   ├── manual_source STRING\n│   ├── manual_medium STRING\n│   ├── manual_term STRING\n│   ├── manual_content STRING\n│   ├── gclid STRING\n│   ├── dclid STRING\n│   └── srsltid STRING\n└── is_active_user BOOLEAN \n```","ogImage":{"url":"/assets/img/2024-06-22-UnderstandingtheGA4BigQueryExportSchemaandStructure_0.png"},"coverImage":"/assets/img/2024-06-22-UnderstandingtheGA4BigQueryExportSchemaandStructure_0.png","tag":["Tech"],"readingTime":14},{"title":"파이썬 Enum 모듈 완벽 가이드 마스터하기 위한 모든 것","description":"","date":"2024-06-22 17:26","slug":"2024-06-22-MasterPythonEnumModuleAComprehensiveGuide","content":"\n\n## 파이썬의 Enum 모듈로 코드를 향상시키세요\n\n![이미지](/assets/img/2024-06-22-MasterPythonEnumModuleAComprehensiveGuide_0.png)\n\n프로그래밍 세계에서 관련된 상수 집합을 관리하는 것은 종종 번거롭고 오류가 발생하기 쉽습니다. Enumerations 또는 Enums로 일반적으로 알려진 것은 값 집합에 대한 상징적인 이름을 정의함으로써 강력한 솔루션을 제공하여 코드의 가독성을 향상시키고 오류 가능성을 줄이는데 도움이 됩니다.\n\n다재다능하면서 널리 사용되는 프로그래밍 언어인 Python은 Enumerations의 생성과 관리를 간단하게 해주는 강력한 enum 모듈을 포함하고 있습니다. 상태 관리, 데이터 유효성 검사 또는 pandas Series 내에서 데이터를 분류하는 경우에도 Python의 enum 모듈이 중요한 역할을 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글에서는 Python의 enum 모듈에 대해 자세히 살펴보고 그 기능, 실제 적용 및 모범 사례를 탐구할 것입니다. 이 글을 마치면 Python 프로젝트에서 Enum을 활용하여 더 깨끗하고 유지보수가 쉬운 코드를 작성하는 방법에 대해 철저히 이해하게 될 것입니다.\n\n## 나에 대해\n\n나는 상당히 오랫동안 Python을 사용해왔고 개발자로서의 여정에서 코드의 기능성과 효율성을 향상시키는 다양한 모듈과 라이브러리를 탐험해왔습니다. 그 중에서도 enum 모듈은 관련 상수를 효과적으로 관리하는 데 있어 단숨함과 효과성으로 빛을 발합니다. 당신이 경험 많은 개발자이든 시작하는 프로그래밍 여정이든 상관없이 Enum을 이해하고 활용함으로써 코딩 실천을 크게 개선할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-MasterPythonEnumModuleAComprehensiveGuide_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Enumeration (Enum)이란 무엇인가요?\n\nEnumeration 또는 Enum으로 줄여 부르는 것은 요소 또는 멤버라고 불리는 일련의 명명된 값을 포함하는 구분된 데이터 유형입니다. 이러한 멤버들은 특정 값을 나타내는 상수이며, 변수가 미리 정의된 일련의 값 중 하나만 보유해야 하는 경우에 이상적인 Enum입니다.\n\n# Enums 사용 사례\n\nEnums는 다음과 같은 시나리오에서 특히 유용합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 상태 관리: 객체의 상태를 추적할 때, 프로세스의 단계(예: 보류 중, 처리 중, 완료)를 말합니다.\n- 구성 옵션: 특정 옵션 집합에 제한된 구성 값을 설정할 때 사용됩니다(예: 낮음, 중간, 높음).\n- 분류: 데이터를 분류할 때, 사용자 유형(예: 관리자, 사용자, 손님)와 같은 것을 나타낼 수 있습니다.\n\n# 다른 데이터 유형과의 비교\n\n리스트와 사전은 관련 값들을 저장하는 데 사용될 수 있지만, Enum은 여러 장점을 제공합니다:\n\n- 가독성: Enum을 이용하면 명확하고 읽기 쉬운 방식으로 관련된 상수를 정의할 수 있습니다.\n- 안전성: Enum은 잘못된 값을 할당하는 것을 방지하여 오류 발생 가능성을 줄입니다.\n- 유지 관리: 특히 관련된 상수 집합을 다룰 때, Enum은 유지보수와 업데이트가 더 쉽습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 예시 코드\n\nEnum의 사용을 설명하기 위해 Python에서 Enum을 정의하고 사용하는 간단한 예제를 시작해보겠습니다.\n\n```js\nfrom enum import Enum\n\n# 요일에 대한 Enum 정의\nclass Day(Enum):\n    SUNDAY = 1\n    MONDAY = 2\n    TUESDAY = 3\n    WEDNESDAY = 4\n    THURSDAY = 5\n    FRIDAY = 6\n    SATURDAY = 7\n\n# Enum 멤버에 접근\nprint(Day.MONDAY)           # 출력: Day.MONDAY\nprint(Day.MONDAY.name)      # 출력: MONDAY\nprint(Day.MONDAY.value)     # 출력: 2\n\n# 조건문에서 Enum 사용\n# 특정 요일이 토요일 또는 일요일인지 확인하는 함수\ndef is_weekend(day):\n    return day in (Day.SATURDAY, Day.SUNDAY)\n\nprint(is_weekend(Day.SATURDAY))  # 출력: True\nprint(is_weekend(Day.WEDNESDAY)) # 출력: False\n```\n\n코드 설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Enum 정의하기: 우리는 enum 모듈에서 Enum 클래스를 사용하여 Day라는 새로운 Enum을 정의합니다. 각 Enum 멤버는 연결된 정수 값과 함께 주의 하루를 나타냅니다.\n- 멤버에 접근하기: 우리는 Enum의 멤버에 이름(Day.MONDAY)을 사용하여 접근할 수 있습니다. 각 멤버는 이름과 값 속성을 가지고 있습니다.\n- 조건문에서 Enum 사용하기: Day.SATURDAY와 Day.SUNDAY와 비교하여 특정 날짜가 주말인지 확인하는 is_weekend 함수를 정의합니다.\n\n# Python의 enum 모듈 개요\n\nPython의 enum 모듈은 Python 3.4에서 도입되어 열거형을 만드는 표준화된 방법을 제공합니다. 이 모듈을 사용하면 개발자는 값들의 집합에 대한 상징적인 이름을 정의할 수 있어 고정된, 상수 값들을 더 읽기 쉽고 유지보수하기 좋은 방식으로 표현할 수 있습니다.\n\n# enum 모듈의 주요 기능\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 클래스 기반 Enum: Enum은 클래스로 정의되어 있어 객체지향 코드에 통합하고 이해하기 쉽습니다.\n- 형 안전성: Enum은 변수가 미리 정의된 값만 가질 수 있도록 보장하여 오류 발생 위험을 줄입니다.\n- 반복 및 비교: Enum은 반복 및 비교를 지원하여 다양한 애플리케이션에 유연하게 사용할 수 있습니다.\n\n## 설치\n\nPython 3.4 이상을 사용하는 경우 enum 모듈이 표준 라이브러리에 포함되어 있어 설치가 필요하지 않습니다. Python의 이전 버전을 사용하는 경우 pip를 사용하여 enum34 패키지를 설치할 수 있습니다:\n\n```js\npip install enum\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기본 Enum 생성\n\nPython에서 Enum을 만드는 것은 간단합니다. Enum 클래스를 상속하는 클래스를 정의하고 Enum의 멤버를 클래스 속성으로 정의하면 됩니다.\n\n# 예제 코드\n\nEnum 모듈의 또 다른 예제를 살펴봅시다. 이 예제에서는 로그와 함께 enum 모듈을 사용하여 Enum을 정의하고 사용하는 방법을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom enum import Enum\n\n# 다른 로깅 레벨을 위한 Enum 정의하기\nclass LogLevel(Enum):\n    DEBUG = 10\n    INFO = 20\n    WARNING = 30\n    ERROR = 40\n    CRITICAL = 50\n\n# Enum 멤버에 접근하기\nprint(LogLevel.DEBUG)         # 결과: LogLevel.DEBUG\nprint(LogLevel.DEBUG.name)    # 결과: DEBUG\nprint(LogLevel.DEBUG.value)   # 결과: 10\n\n# 함수에서 Enum 사용하기\ndef log_message(level, message):\n    if level == LogLevel.DEBUG:\n        print(f\"DEBUG: {message}\")\n    elif level == LogLevel.INFO:\n        print(f\"INFO: {message}\")\n    elif level == LogLevel.WARNING:\n        print(f\"WARNING: {message}\")\n    elif level == LogLevel.ERROR:\n        print(f\"ERROR: {message}\")\n    elif level == LogLevel.CRITICAL:\n        print(f\"CRITICAL: {message}\")\n\n# 로깅 메시지\nlog_message(LogLevel.INFO, \"이것은 정보 메시지입니다.\")\nlog_message(LogLevel.ERROR, \"이것은 오류 메시지입니다.\")\n```\n\n코드 설명\n\n- Enum 정의: LogLevel이라는 Enum을 정의하여 다른 로깅 레벨을 표현합니다. 각 멤버는 로깅 심각성에 해당하는 정수 값을 가지고 있습니다.\n- 멤버 접근: LogLevel Enum의 멤버에 접근하여 이름과 값 가져오기\n- 함수에서 Enum 사용: LogLevel Enum을 사용하여 로깅 레벨을 결정하고 적절한 메시지 출력하기.\n\n# Enum 멤버 및 속성\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEnum의 각 구성원은 두 가지 키 속성을 가지고 있어요:\n\n- name: 구성원의 이름.\n- value: 구성원과 연결된 값.\n\n여기 과일 종류를 위한 Enum을 만드는 간단한 예제가 있어요:\n\n```js\nfrom enum import Enum\n\n# 다양한 종류의 과일을 위한 Enum 정의\nclass Fruit(Enum):\n    APPLE = 1\n    BANANA = 2\n    CHERRY = 3\n\n# Enum 구성원에 접근\nprint(Fruit.APPLE)           # 출력: Fruit.APPLE\nprint(Fruit.APPLE.name)      # 출력: APPLE\nprint(Fruit.APPLE.value)     # 출력: 1\n\n# 조건문에서 Enum 사용\ndef is_favorite_fruit(fruit):\n    return fruit == Fruit.CHERRY\n\nprint(is_favorite_fruit(Fruit.CHERRY))  # 출력: True\nprint(is_favorite_fruit(Fruit.BANANA))  # 출력: False\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 속성에는 각각 .name 및 .value 속성을 사용하여 액세스할 수 있습니다.\n\n다음은 이러한 속성을 사용하는 방법을 보여주는 예제입니다:\n\n```js\nfrom enum import Enum\n\n# 상태 코드를 위한 Enum 정의\nclass StatusCode(Enum):\n    SUCCESS = 200\n    NOT_FOUND = 404\n    SERVER_ERROR = 500\n\n# 멤버 이름 및 값에 액세스\nfor status in StatusCode:\n    print(f\"{status.name} = {status.value}\")\n\n# 출력:\n# SUCCESS = 200\n# NOT_FOUND = 404\n# SERVER_ERROR = 500\n```\n\n코드 설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Enum 정의: HTTP 상태 코드를 나타내기 위해 StatusCode라는 Enum을 정의합니다. 각 멤버는 연관된 정수 값이 있습니다.\n- 멤버 순회: for 루프를 사용하여 StatusCode Enum의 멤버를 순회하고 이름과 값들을 출력합니다.\n\n# 함수에서 Enum 사용하기\n\nEnum은 함수의 인수로 전달될 수 있어서 코드를 더 가독성 있고 명확하게 만들어줍니다.\n\n함수에서 Enum 사용을 보여주기 위해 StatusCode Enum 예제를 확장해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom enum import Enum\n\n# 상태 코드를 위한 Enum 정의\nclass StatusCode(Enum):\n    SUCCESS = 200\n    NOT_FOUND = 404\n    SERVER_ERROR = 500\n\n# 상태 메시지를 가져오는 함수\ndef get_status_message(status):\n    if status == StatusCode.SUCCESS:\n        return \"요청이 성공했습니다.\"\n    elif status == StatusCode.NOT_FOUND:\n        return \"자원을 찾을 수 없습니다.\"\n    elif status == StatusCode.SERVER_ERROR:\n        return \"내부 서버 오류가 발생했습니다.\"\n\n# Enum 멤버를 사용하는 함수 호출\nprint(get_status_message(StatusCode.SUCCESS))      # 결과: 요청이 성공했습니다.\nprint(get_status_message(StatusCode.NOT_FOUND))    # 결과: 자원을 찾을 수 없습니다.\nprint(get_status_message(StatusCode.SERVER_ERROR)) # 결과: 내부 서버 오류가 발생했습니다.\n```\n\n코드 해석\n\n- Enum 정의: StatusCode라는 Enum을 정의하고 다른 HTTP 상태 코드를 나타내는 멤버를 가집니다.\n- Enum 인자를 받는 함수: StatusCode Enum 멤버를 인자로 받아 해당하는 메시지를 반환하는 get_status_message 함수를 정의합니다.\n- 함수 사용: get_status_message 함수를 다른 StatusCode 멤버와 함께 호출하여 사용법을 보여줍니다.\n\n# 조건문과 함께 Enum 사용하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEnum을 사용하면 코드의 가독성과 유지 보수성을 높일 수 있어요. Enum 멤버를 비교하여 Enum 값에 따라 특정 코드를 실행할 수 있어요.\n\n## 코드 예시\n\n아래는 조건문에서 Enum을 사용하는 예시에요:\n\n```js\nfrom enum import Enum\n\n# 다양한 종류의 차량을 위한 Enum 정의\nclass VehicleType(Enum):\n    CAR = 1\n    TRUCK = 2\n    MOTORCYCLE = 3\n    BICYCLE = 4\n\n# 운전 면허가 필요한 차량인지 확인하는 함수\ndef requires_license(vehicle):\n    if vehicle in (VehicleType.CAR, VehicleType.TRUCK, VehicleType.MOTORCYCLE):\n        return True\n    elif vehicle == VehicleType.BICYCLE:\n        return False\n\n# 다양한 VehicleType 멤버를 이용한 함수 호출\nprint(requires_license(VehicleType.CAR))        # 출력: True\nprint(requires_license(VehicleType.BICYCLE))    # 출력: False\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 설명\n\n- Enum 정의: VehicleType이라는 Enum을 정의합니다. 이 Enum은 다양한 유형의 차량을 나타내는 멤버를 포함합니다.\n- 조건부 함수: VehicleType Enum 멤버를 인수로 받아 해당 차량이 운전면허가 필요한지 여부를 반환하는 requires_license 함수를 정의합니다.\n- 함수 사용: 다른 VehicleType 멤버를 사용하여 requires_license 함수를 호출하여 사용법을 보여줍니다.\n\n# 반복과 비교\n\nEnum은 반복과 비교를 지원하여 다양한 응용 프로그램에 유용합니다. Enum의 멤버를 반복하고 표준 비교 연산자를 사용하여 비교할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEnum 멤버를 반복하고 비교하는 예제를 살펴보겠습니다:\n\n```js\nfrom enum import Enum\n\n# 심각도 레벨을 위한 Enum 정의\nclass Severity(Enum):\n    LOW = 1\n    MEDIUM = 2\n    HIGH = 3\n    CRITICAL = 4\n\n# Enum 멤버 반복\nfor level in Severity:\n    print(level.name, level.value)\n\n# 출력:\n# LOW 1\n# MEDIUM 2\n# HIGH 3\n# CRITICAL 4\n\n# Enum 멤버 비교\ndef compare_severity(level1, level2):\n    if level1 \u003e level2:\n        return f\"{level1.name}이(가) {level2.name}보다 심각합니다.\"\n    elif level1 \u003c level2:\n        return f\"{level1.name}이(가) {level2.name}보다 덜 심각합니다.\"\n    else:\n        return f\"{level1.name}과 {level2.name}은(는) 동등한 심각도입니다.\"\n\n# 비교 함수 사용\nprint(compare_severity(Severity.HIGH, Severity.MEDIUM))     # 출력: HIGH이(가) MEDIUM보다 더 심각합니다.\nprint(compare_severity(Severity.LOW, Severity.LOW))         # 출력: LOW와 LOW는 동등한 심각도입니다.\n```\n\n코드 설명\n\n- Enum 정의: Severity라는 Enum을 정의하고 다른 심각도 레벨을 나타내는 멤버를 정의합니다.\n- 멤버 반복: for 루프를 사용하여 Severity Enum의 멤버를 반복하고 이름과 값을 출력합니다.\n- 멤버 비교: 두 개의 Severity Enum 멤버를 인자로 받아서 두 심각도 레벨을 비교하는 compare_severity 함수를 정의합니다.\n- 비교 함수 사용: compare_severity 함수를 다른 Severity 멤버와 함께 호출하여 사용법을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\u003cimg src=\"/assets/img/2024-06-22-MasterPythonEnumModuleAComprehensiveGuide_2.png\" /\u003e\n\n# Enum의 실제 적용\n\n## 데이터 유효성 검증에서의 Enum\n\nEnum을 사용하여 데이터를 유효성 검사할 수 있습니다. 이는 특정 값을 허용하는 미리 정의된 집합에 속하는지 확인하여 데이터를 인증하는 데 특히 유용합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 데이터 유효성을 위해 Enum을 사용하는 예제입니다:\n\n```js\nfrom enum import Enum\n\n# 사용자 역할을 나타내는 Enum 정의\nclass UserRole(Enum):\n    ADMIN = 'admin'\n    USER = 'user'\n    GUEST = 'guest'\n\n# 사용자 역할을 유효성 검사하는 함수\ndef validate_user_role(role):\n    if role in UserRole.__members__.values():\n        return True\n    else:\n        raise ValueError(f\"잘못된 사용자 역할: {role}\")\n\n# 유효성 검사 함수 사용 예시\ntry:\n    print(validate_user_role(UserRole.ADMIN))  # 결과: True\n    print(validate_user_role('superuser'))     # ValueError 발생\nexcept ValueError as e:\n    print(e)\n```\n\n코드 설명\n\n- Enum 정의: UserRole이라는 Enum을 정의하고 다른 사용자 역할을 나타내는 멤버를 포함시킵니다.\n- 유효성 확인 함수: role을 인수로 받아서 유효한 UserRole 멤버인지 확인하는 validate_user_role 함수를 정의합니다. 유효하지 않을 경우 ValueError를 발생시킵니다.\n- 유효성 확인 함수 사용: 다른 역할로 validate_user_role 함수를 호출하여 사용법을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 상태 관리에서의 Enums\n\nEnums은 응용 프로그램 또는 객체의 상태를 관리하는 데에도 유용합니다. Enums를 사용하여 상태를 나타내면 유효한 상태만 할당되고 상태간 전환도 명확히 정의할 수 있습니다.\n\nEnums를 사용하여 상태 관리를 보여주는 예제를 살펴봅시다:\n\n```js\nfrom enum import Enum\n\n# 주문 상태에 대한 Enum 정의\nclass OrderStatus(Enum):\n    PENDING = 'pending'\n    PROCESSING = 'processing'\n    SHIPPED = 'shipped'\n    DELIVERED = 'delivered'\n    CANCELLED = 'cancelled'\n\n# 주문 상태를 관리하는 클래스\nclass Order:\n    def __init__(self, order_id):\n        self.order_id = order_id\n        self.status = OrderStatus.PENDING\n\n    def update_status(self, new_status):\n        if isinstance(new_status, OrderStatus):\n            self.status = new_status\n        else:\n            raise ValueError(f\"잘못된 상태: {new_status}\")\n\n# 주문 생성 및 상태 업데이트\norder = Order(order_id=123)\nprint(order.status)  # 출력: OrderStatus.PENDING\n\norder.update_status(OrderStatus.PROCESSING)\nprint(order.status)  # 출력: OrderStatus.PROCESSING\n\n# 유효하지 않은 상태로 업데이트 시도\ntry:\n    order.update_status('completed')  # ValueError 발생\nexcept ValueError as e:\n    print(e)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 설명\n\n- Enum 정의: OrderStatus라는 Enum을 정의하며, 각 멤버는 주문의 다양한 단계를 나타냅니다.\n- 주문 클래스: OrderStatus Enum을 사용하여 주문의 상태를 관리하는 Order 클래스를 만듭니다.\n- 상태 업데이트: update_status 메서드는 새로운 상태가 유효한 OrderStatus 멤버인 경우 주문의 상태를 업데이트하고, 그렇지 않으면 ValueError를 발생시킵니다.\n- 클래스 사용법: Order 클래스의 인스턴스를 만들어 상태를 업데이트하고, 유효하지 않은 상태 업데이트에 대한 에러 처리를 보여줍니다.\n\n![MasterPythonEnumModuleAComprehensiveGuide_3.png](/assets/img/2024-06-22-MasterPythonEnumModuleAComprehensiveGuide_3.png)\n\n# 판다스 시리즈에서의 Enum들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 아마 기다리고 계셨던 순간입니다. 여기서는 Enum이 pandas Series와 함께 데이터 범주화에 어떻게 활용될 수 있는지 살펴보겠습니다. Enum을 사용하면 DataFrame 전체에서 일관된 범주를 유지할 수 있어 데이터 조작과 분석을 더 구조화되고 오류가 없게 만들 수 있습니다.\n\n## 데이터 범주화를 위한 Enum 사용\n\nEnum은 pandas에서 범주형 데이터를 다룰 때 특히 유용할 수 있습니다. Enum을 사용하여 범주를 정의하면 DataFrame 전체에서만 유효한 범주가 사용되도록 보장할 수 있습니다.\n\n다음은 pandas Series와 Enum을 사용하는 방법을 보여주는 예제입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport pandas as pd\nfrom enum import Enum\n\n# 제품 카테고리를 위한 Enum 정의\nclass ProductCategory(Enum):\n    ELECTRONICS = '전자제품'\n    CLOTHING = '의류'\n    FOOD = '식품'\n    TOYS = '장난감'\n\n# 샘플 DataFrame 생성\ndata = {\n    'Product': ['노트북', '티셔츠', '사과', '곰인형'],\n    'Category': [ProductCategory.ELECTRONICS.value, ProductCategory.CLOTHING.value, ProductCategory.FOOD.value, ProductCategory.TOYS.value]\n}\n\ndf = pd.DataFrame(data)\n\n# DataFrame 출력\nprint(df)\n\n# 출력:\n#       Product    Category\n# 0       노트북      전자제품\n# 1      티셔츠         의류\n# 2        사과          식품\n# 3      곰인형        장난감\n```\n\n코드 설명\n\n- Enum 정의: ProductCategory Enum을 정의하여 각각의 제품 카테고리를 나타냅니다.\n- DataFrame 생성: ProductCategory Enum의 멤버 값들을 사용하여 제품명과 해당 카테고리를 포함한 샘플 DataFrame을 생성합니다.\n- DataFrame 출력: Enum 값을 Category 열에 어떻게 사용하는지를 보여주기 위해 DataFrame을 출력합니다.\n\n## Pandas에서 Enum 사용의 장점\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 일관성: Enum을 사용하면 미리 정의된 카테고리만 사용하므로 오타와 불일치의 위험을 줄입니다.\r\n- 가독성: Enum을 사용하면 카테고리에 대한 명확하고 설명적인 이름을 제공하여 코드를 더 읽기 쉽게 만듭니다.\r\n- 유효성 검사: Enum을 사용하여 데이터가 DataFrame에 추가되기 전에 데이터를 유효성 검사할 수 있어 데이터 무결성을 보장합니다.\n\n## Enum을 사용한 데이터 유효성 검사 예제 코드\n\n다음은 pandas Series에 데이터를 추가하기 전에 Enum을 사용하여 데이터 유효성을 확인하는 예제입니다:\n\n```python\nimport pandas as pd\nfrom enum import Enum\n\n# 제품 카테고리를 위한 Enum 정의\nclass ProductCategory(Enum):\n    ELECTRONICS = '전자제품'\n    CLOTHING = '의류'\n    FOOD = '식품'\n    TOYS = '장난감'\n\n# 제품 카테고리를 검증하는 함수\ndef validate_category(category):\n    if category in ProductCategory._value2member_map_:\n        return True\n    else:\n        raise ValueError(f\"유효하지 않은 카테고리: {category}\")\n\n# 샘플 데이터\nproducts = ['노트북', '티셔츠', '사과', '곰 인형']\ncategories = ['전자제품', '의류', '식품', '가구']  # 참고: '가구'는 올바른 카테고리가 아닙니다.\n\n# 유효성을 검사하고 DataFrame 생성\nvalidated_data = {\n    '제품': [],\n    '카테고리': []\n}\n\nfor product, category in zip(products, categories):\n    try:\n        if validate_category(category):\n            validated_data['제품'].append(product)\n            validated_data['카테고리'].append(category)\n    except ValueError as e:\n        print(e)\n\ndf = pd.DataFrame(validated_data)\n\n# 유효성 검사된 DataFrame 출력\nprint(df)\n\n# 결과:\n# 유효하지 않은 카테고리: 가구\n#     제품      카테고리\n# 0  노트북     전자제품\n# 1  티셔츠       의류\n# 2  사과         식품\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 설명\n\n- Enum 정의: ProductCategory라는 Enum을 정의합니다. 각 멤버는 다른 제품 카테고리를 표현합니다.\n- 유효성 검사 함수: validate_category라는 함수를 만들어 카테고리가 ProductCategory의 유효한 멤버인지 확인합니다.\n- 데이터 유효성 검사: DataFrame에 추가하기 전에 샘플 데이터를 유효성 검사합니다. 유효하지 않은 카테고리가 있으면 해당 항목을 잡아내고 오류 메시지를 출력합니다.\n- DataFrame 생성 및 표시: 유효한 데이터로 DataFrame을 생성하고 표시하며, 유효하지 않은 항목은 제외됩니다.\n\n## Enum 사용 시기\n\nEnum은 변수가 미리 정의된 값 집합으로 제한되어야 하는 경우에 이상적입니다. Enum이 특히 유용한 몇 가지 상황을 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 고정 상수 집합: 주간, 월, 또는 사용자 역할과 같이 변경될 가능성이 거의 없는 관련 상수 집합이 있는 경우에 사용합니다.\n- 상태 관리: 주문 상태, 프로세스 단계 또는 UI 상태와 같은 응용 프로그램이나 시스템에서 상태를 관리해야 할 때 사용합니다.\n- 구성 옵션: 로깅 수준 또는 환경 유형과 같이 특정 값으로 제한해야 하는 구성 옵션을 정의할 때 사용합니다.\n\n## 피해야 할 일반적인 함정\n\nEnum은 강력하고 유용하지만, 피해야 할 몇 가지 일반적인 함정이 있습니다:\n\n- Enum 과용: 모든 상수 집합이 Enum이 될 필요는 없습니다. Enum은 가독성, 안정성 및 유지 관리 측면에서 명확한 이점을 제공할 때에만 사용하세요.\n- 변경 가능한 Enum: Enum은 고정된 변경할 수 없는 값의 집합을 나타내어야 합니다. 런타임에서 Enum을 수정하는 것은 예상치 못한 동작 및 오류를 유발할 수 있으므로 피하세요.\n- 형식 혼합: Enum 내 모든 값이 동일한 형식이어야 합니다. 형식을 혼합하면 (예: 문자열 및 정수) 혼란과 오류가 발생할 수 있으니 주의하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 팁 및 권장 사항\n\n여기 Python 프로젝트에서 Enum을 효과적으로 사용하는 데 도움이 되는 몇 가지 팁과 권장 사항이 있습니다:\n\n- 설명적인 이름 사용: Enum 멤버에 명확하고 설명적인 이름을 선택하세요. 이렇게 하면 코드의 가독성이 향상되고 각 멤버의 목적을 이해하기 쉬워집니다.\n- 관련된 상수를 그룹화: Enum을 사용하여 관련된 상수를 함께 그룹화하세요. 이렇게 하면 코드가 더 정리되고 오류 발생 가능성이 줄어듭니다.\n- Enum 기능 활용: enum 모듈에서 제공하는 기능을 활용하세요. 예를 들어 반복, 비교, 멤버 속성 등의 기능을 사용하면 코드가 간소화되고 더 견고해질 수 있습니다.\n- Enum에 설명 추가: Enum에 설명을 제공하세요. 특히 복잡한 값이나 상태 집합을 나타내는 경우 다른 개발자가 올바르게 사용하는 방법을 이해하는 데 도움이 됩니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n열거형(Enum)은 파이썬에서 가독성, 안전성 및 유지보수성을 향상시키는 강력한 기능입니다. 이름이 지정된 상수 집합을 정의함으로써, 열거형은 유효한 값들을 강제하고 오류를 줄이며 코드를 이해하기 쉽게 만듭니다.\n\n## 다루는 내용:\n\n- 열거형(Enum)의 기본: Enum이 무엇이고 왜 유용한지.\n- Python의 enum 모듈: Python에서 열거형을 생성하고 사용하는 방법.\n- 고급 열거형 사용법: 조건, 반복 및 열거형과의 비교.\n- 실용적인 응용: 데이터 유효성 검사, 상태 관리 및 pandas Series.\n- 최적의 사례: 효과적인 열거형 사용을 위한 팁.\n\n파이썬 코드에 열거형을 도입하면 더 명확하고 신뢰할 수 있는 결과를 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마지막으로:\n\n제 글을 읽어 주셔서 감사합니다!\n\n안녕하세요! 저는 데이터 엔지니어 Charilaos Alkiviades Savoullis입니다. 엔드 투 엔드 솔루션을 만드는 것을 좋아하는 엔지니어입니다. Python, SQL, AI, 데이터 엔지니어링, 라이프스타일 등에 관한 글을 씁니다!\n\n함께 테크놀로지, 데이터 및 더 나아가는 세계를 탐험해 봅시다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비슷한 글이나 업데이트를 보려면 내 Medium 프로필을 방문해보세요. https://medium.com/@casavoullis\n\n만약 이 글을 즐겼다면, 앞으로의 업데이트를 받기 위해 좋아요와 팔로우를 고려해보세요.\n\n이 글은 Charilaos Savoullis가 처음으로 Medium에 게시했습니다.\n\n# 내 소셜 미디어에서 나와 연락하기를 주저하지 마세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLinkedIn: [Casavoullis](https://www.linkedin.com/in/casavoullis/)  \nGitHub: [GitHub Profile](https://bit.ly/3WrMzgm)\n\n파이썬 콘텐츠 및 팁에 관심이 있으신가요? 저의 Medium 목록을 확인하려면 여기를 클릭해 보세요.\n\nSQL, 데이터베이스 및 데이터 엔지니어링 콘텐츠에 더 관심이 있으신가요? 더 알아보려면 여기를 클릭해 주세요!\n\n아래 댓글란에 의견을 남겨주세요... 또는 아래가 아니라 위에 남기셔도 됩니다. 🙃\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 친절한 한국어로 번역해 드립니다 🚀\n\nIn Plain English 커뮤니티에 참여해 주셔서 감사합니다! 마지막으로 가시기 전에:\n\n- 작가를 갈채하고 팔로우해 주세요 ️👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | 뉴스레터\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-22-MasterPythonEnumModuleAComprehensiveGuide_0.png"},"coverImage":"/assets/img/2024-06-22-MasterPythonEnumModuleAComprehensiveGuide_0.png","tag":["Tech"],"readingTime":17},{"title":"Airflow, DuckDB, Streamlit으로 StarCraft 2 데이터 탐험하기","description":"","date":"2024-06-22 17:22","slug":"2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit","content":"\n\n- 📝 소개 및 개요\n- ⏱️ Airflow\n- 🦆 DuckDB\n· DuckDB: 여러분의 휴대용 분석 데이터베이스\n· DuckDB: 여러분의 다재다능한 데이터 조작 도구\n- 🚀 Streamlit\n- 🎮 Airflow, DuckDB 및 Streamlit을 활용한 StarCraft II 데이터 파이프라인\n· 프로젝트 설정\n· Airflow 준비\n· StarCraft II API 액세스 가져오기\n· DAG 구현\n· 데이터 가져오기\n· 데이터 저장\n· Streamlit을 사용하여 데이터 시각화\n- 💡 결론\n\n# 소개 및 개요\n\n이 프로젝트와 기사는 지식 공유의 원천일 뿐만 아니라 게임을 사랑하고 데이터가 보유한 끝없는 가능성을 축하하는 것이기도 합니다. 이것은 두 가지 큰 열정, 즉 게임과 데이터 엔지니어링의 융합입니다. 저는 '스타크래프트: 브루드 워'뿐만 아니라 '스타크래프트 II'도 많이 플레이해오면서, 이 게임은 플레이어가 은하 간 전쟁에서 세 개의 독특한 진영 중 하나를 조종하는 실시간 전략 비디오 게임으로, 자원 관리, 건물 건설 및 전술 전투가 특징입니다. 저는 최고 순위 선수들이 서로 경쟁하는 그랜드마스터 래더에 도달하지는 못했지만, 전장에서 군대를 지휘하는 아드레날린 붐을 경험하고 상대를 앞지르며 승리를 차지하는 것을 즐겼습니다 (적어도 때때로).\n\n마치 스타크래프트에서 빌드 오더를 세밀하게 조정하고 적의 전술에 적응했던 것처럼, 지금은 데이터 엔지니어로서 데이터 파이프라인을 최적화하고 트렌드를 분석하며 통찰을 시각화하고 있습니다. 오늘의 현대 데이터 스택에서 강력한 세 가지 기술에 대해 지식을 공유하고 싶습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- ⏱️ Apache Airflow: 복잡한 작업 흐름을 조정하고 예약하는 플랫폼입니다.\n- 🦆 DuckDB: 가벼우면서 다재다능한 분석용 데이터베이스입니다.\n- 🚀 Streamlit: 상호작용 웹 애플리케이션을 구축하기 위한 사용자 친화적인 프레임워크입니다.\n\n본 글에서는 이 세 가지 기술에 대한 기본을 설명하고, 일상 업무에서 어떻게 활용할 수 있는지 예시를 드리겠습니다.\n\n마지막으로, StarCraft II 데이터 파이프라인 예제 프로젝트를 생성할 때 모든 것이 결합됩니다. 본 프로젝트에서는 StarCraft II API에서 데이터를 가져와 DuckDB에 결과를 저장하고, Airflow를 통해 조정합니다. 또한 데이터를 시각화하기 위해 Streamlit 앱을 만들어 볼 것입니다. StarCraft II의 현재 그랜드마스터 래더가 어떻게 보이는지 살펴봅니다 (스포일러: 저는 찾아보기 힘들 것입니다). 이것이 최종 결과물입니다:\n\n\u003cimg src=\"/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_0.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGithub에서 완성된 프로젝트를 찾을 수 있어요 🪄: https://github.com/vojay-dev/sc2-data-pipeline\n\n자, 마우스와 키보드를 쥐고, 내부 프로토스, 저그 또는 테란 지휘관을 소환하고 데이터와 게임 세계를 함께 탐험할 준비를 하세요.\n\n![Airflow](/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_1.png)\n\n# Airflow\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아파치 에어플로우는 파이썬을 사용하여 프로그램 방식으로 작성하고 예약하며 워크플로를 모니터링할 수 있는 오픈 소스 플랫폼입니다. 워크플로는 방향성 비순환 그래프(Directed Acyclic Graphs, DAGs)로 표현되며 그래프의 각 정점은 작업의 단위입니다.\n\n일반적으로, 워크플로는 데이터 추출, 변환, 로드(Extract, Transform, Load, ETL) 프로세스로 알려져 있지만, 사실 에어플로우는 매우 유연하여 어떠한 종류의 워크플로도 구현할 수 있습니다.\n\n![Airflow Image](/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_2.png)\n\n에어플로우는 웹 인터페이스를 제공하여 DAGs를 관리하고 모니터링할 수 있습니다. 에어플로우에는 네 가지 주요 구성 요소가 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 🌎 웹서버: Airflow 웹 인터페이스를 제공합니다.\n- ⏱️ 스케줄러: 구성된 시간에 DAG를 실행할 수 있도록 일정을 관리합니다.\n- 🗄️ 데이터베이스: 모든 DAG 및 작업 메타데이터를 저장합니다.\n- 🚀 실행자: 개별 작업을 실행합니다.\n\n데이터베이스와 실행자에 관해서 Airflow는 매우 유연합니다. 예를 들어 SequentialExecutor는 로컬 개발에 사용될 수 있으며 한 번에 하나의 작업을 실행합니다. 한편, CeleryExecutor 또는 KubernetesExecutor는 작업자 노드 클러스터에서 병렬 실행을 가능하게 합니다.\n\n이 프로젝트에서는 Airflow를 사용하여 StarCraft II API에서 데이터를 가져와 DuckDB에 유지하도록 작업 흐름을 조정할 것입니다.\n\n# DuckDB\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_3.png\" /\u003e\n\n덕디비 세계에 오신 것을 환영합니다! 덕디비를 데이터 분석 영역에서의 신뢰할 수 있는 동반자로 상상해보세요. 가벼우면서도 강력한 도구로, 강력한 효과를 발휘합니다. 덕디비를 스타크래프트 군에서의 민첩한 정찰병으로 상상해보세요. 적의 선을 민첩하게 헤쳐가며 정보를 수집합니다.\n\n본 예제 프로젝트에서는 덕디비를 사용하여 스타크래프트 API의 데이터, 특히 그랜드마스터 랭킹 데이터를 임베디드 방식으로 영구 저장하는 방법을 살펴보겠습니다. 이를 위해 파이썬을 통해 덕디비를 사용하여 데이터를 한 파일에 저장합니다.\n\n하지만 프로젝트에 바로 뛰어들기 전에, 아래 장들에서 덕디비에 대해 더 자세히 소개하고 일상적인 데이터 엔지니어링/분석 비즈니스에서 덕디비를 활용하는 데 어떻게 도움을 받을 수 있는지 설명하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# DuckDB: 휴대용 분석용 데이터베이스\n\nDuckDB를 데이터베이스의 스위스 아미 나이프로 생각해보세요. 이것은 빠르고 효율적이며 다재다능합니다. 마치 전투터스 제알럿처럼 어떤 상황에도 쉽게 적응할 수 있습니다.\n\nDuckDB는 쉽게 설치할 수 있으며 휴대용이며 오픈소스입니다. SQL 언어에서 기능이 풍부하며 CSV, Parquest, JSON과 같은 다양한 형식의 데이터를 가져오고 내보낼 수 있습니다. 또한 Pandas 데이터프레임과 원활하게 통합되어 있어 데이터 테이블 작업에 강력한 도구로 사용할 수 있습니다. 다음 장에서 자세히 살펴보겠습니다.\n\nPython 프로젝트에 간단히 설치할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\npip install duckdb\n```\n\n그 후에는 DuckDB를 인메모리 데이터베이스로 즉석에서 사용할 수 있습니다:\n\n```js\nimport duckdb\n\nduckdb.execute(\"CREATE TABLE tbl AS SELECT 42 a\")\ndf = duckdb.execute(\"SELECT * FROM tbl\").df()\nprint(df)\n```\n\n```js\n    a\n0  42\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또는 간단한 파일에 데이터를 유지하는 내장 데이터베이스로 DuckDB를 사용할 수도 있어요:\n\n```js\nimport duckdb\n\n# 영구 데이터베이스를 생성하고 데이터를 씁니다\nwith duckdb.connect(database=\"my_duckdb.db\") as write_conn:\n    write_conn.execute(\"CREATE TABLE tbl AS SELECT 42 a\")\n\n# 다른 곳에서: 데이터를 읽고 처리합니다\nwith duckdb.connect(database=\"my_duckdb.db\", read_only=True) as read_conn:\n    df = read_conn.execute(\"SELECT * FROM tbl\").df()\n    print(df)\n```\n\n이렇게 하면 모든 데이터가 my_duckdb.db라는 파일에 저장됩니다. 여기서는 DuckDB와 Pandas 데이터프레임 간에 데이터를 교환하는 것 뿐만 아니라 CSV, JSON 등을 읽고 쓸 수도 있어요.\n\n만약 SQLite에 익숙하다면 DuckDB를 그보다 더 성능 중심적이고 더 세련된 씨봉인 것으로 생각해보세요. SQLite가 소규모 프로젝트에 적합하다면 DuckDB는 한 단계 발전된 것입니다. 작은 Terran Hellion에서 강력한 Thor 유닛으로 업그레이드하는 것 같아요. 더 큰 데이터셋과 복잡한 쿼리도 무리 없이 처리할 준비가 되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDuckDB는 Command Line Interface (CLI)도 제공합니다. DuckDB CLI는 Windows, Mac 및 Linux용으로 미리 컴파일된 간단한 실행 파일입니다. 내 Mac 환경에서는 간단히 Homebrew를 통해 설치할 수 있어요:\n\n```js\nbrew install duckdb\n```\n\n이를 사용하여 DuckDB 소스에 연결하거나 인메모리 작업을 수행할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 능력을 보여주기 위해 DuckDB 데이터베이스 파일에 연결하여 프로젝트의 일부로 나준비 한 일부를 실행하기 위해 사용했습니다:\n\n```js\nSELECT favorite_race, SUM(wins) AS total_wins, MAX(mmr) AS max_mmr, AVG(mmr) AS avg_mmr\nFROM ladder\nWHERE favorite_race IN ('protoss', 'terran', 'zerg')\nGROUP BY favorite_race\nORDER BY total_wins DESC;\n```\n\n```js\n| favorite_race | total_wins | max_mmr |      avg_mmr      |\n|    varchar    |   int128   | double  |      double       |\n|---------------|------------|---------|-------------------|\n| protoss       |      11816 |  6840.0 |            5541.3 |\n| terran        |       7207 |  7140.0 | 5501.839285714285 |\n| zerg          |       5380 |  7080.0 | 5591.622222222222 |\n```\n\n- 🥇 Protoss가 그랜드마스터 래더에서 가장 높은 총 승리 수를 가졌지만 최대 MMR는 가장 낮습니다.\n- 🥈 Terran은 그랜드마스터 래더에서 최고의 최대 MMR을 가지고 있습니다.\n- 🥉 Zerg는 그랜드마스터 래더에서 가장 적은 승리를 가지고 있지만 평균 MMR이 가장 높습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# DuckDB: 다목적 데이터 조작 도구\n\n덕DB에 대해 처음 프로젝트를 진행하면서, 휴대용 가벼운 분석 데이터베이스 이상의 기능을 발견할 수 있었어요. 실제로 덕DB를 데이터 처리 작업에 사용하면 매우 강력해질 수 있답니다. \n\n덕DB의 핵심은 SQL 기반 작업과 Pandas와 같은 다른 데이터 처리 도구 사이에 원활한 통합 기능을 제공하는 것입니다. 이 독특한 기능 덕분에 데이터 처리 스크립트 내에서 다른 기술들 간에 쉽게 전환할 수 있어요.\n\nPandas나 NumPy와 같은 전형적인 라이브러리를 사용하여 Python 스크립트 내에서 데이터 처리를 완전히 구현하는 대신, 복잡한 데이터베이스 통합 설정 없이 이러한 환경들 간에 전환할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAPI로부터 데이터를 가져와 Pandas 데이터프레임에 로드하고 메모리 내 DuckDB에 삽입하여 SQL을 사용하여 집계를 수행한 다음 결과를 또 다른 데이터프레임에 다시 작성하여 계속 진행할 수 있습니다. 특히 SQL과 함께 많이 작업하는 데이터 엔지니어로서 이는 더 직관적인 데이터 흐름을 만들기 위한 제 도구 상자에 강력한 도구를 제공했습니다.\n\n스타크래프트와 마찬가지로, 상황에 맞는 올바른 유닛을 선택해야 합니다.  Zealots의 군대를 만들 수 있지만 상대가 많은 Roaches로 공격할 때에는 군대 구성을 조정하고 Immortals와 Void Rays를 추가해야 합니다. 데이터 처리 스크립트도 마찬가지입니다: DuckDB와 같은 도구를 전체 구성에 추가함으로써 데이터 처리 시 더 많은 도전에 대처할 수 있는 가능성을 가질 수 있습니다.\n\n다음 예시는 Airflow DAG로 채울 StarCraft II 래더 데이터를 읽어와 SQL을 사용하여 집계하고 결과를 Pandas 데이터프레임으로 작성한 다음 Pandas를 사용하여 일부 열을 추가하고 결과를 다시 메모리 내 DuckDB 테이블로 이동하여 최종적으로 Pandas 데이터프레임으로 돌아가게 됩니다.\n\n```js\nimport duckdb\n\nif __name__ == '__main__':\n    # 영구 DuckDB 사용\n    with duckdb.connect(database=\"sc2data.db\") as conn:\n        df = conn.sql(f\"\"\"\n            SELECT\n                favorite_race,\n                SUM(wins) AS total_wins,\n                SUM(losses) AS total_losses,\n                MAX(mmr) AS max_mmr,\n                AVG(mmr) AS avg_mmr\n            FROM ladder\n            WHERE favorite_race IN ('protoss', 'terran', 'zerg')\n            GROUP BY favorite_race\n            ORDER BY total_wins DESC;\n        \"\"\").df()\n        print(df)\n\n    # 팬더스에서 데이터 처리\n    df[\"win_pct\"] = (df[\"total_wins\"] / (df[\"total_wins\"] + df[\"total_losses\"]) * 100)\n\n    # 추가 처리를 위해 메모리 내 DuckDB 사용\n    duckdb.sql(\"\"\"\n        CREATE TABLE aggregation AS\n        SELECT CASE\n            WHEN favorite_race = 'protoss' THEN 'p'\n            WHEN favorite_race = 'terran' THEN 't'\n            WHEN favorite_race = 'zerg' THEN 'z'\n        END AS fav_rc,\n        total_wins + total_losses AS total_games,\n        win_pct\n        FROM df;\n    \"\"\")\n\n    # 팬더스로 변경\n    df_agg = duckdb.sql(\"SELECT * FROM aggregation;\").df()\n    print(df_agg)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 코드와 StarCraft II API 그랜드마스터 래더 데이터를 사용하여 위와 같은 결과가 생성됩니다:\n\n```js\n  favorite_race  total_wins  total_losses  max_mmr      avg_mmr\n0       protoss     11816.0        8927.0   6840.0  5541.300000\n1        terran      7207.0        5655.0   7140.0  5501.839286\n2          zerg      5380.0        3985.0   7080.0  5591.622222\n  fav_rc  total_games    win_pct\n0      p      20743.0  56.963795\n1      t      12862.0  56.033276\n2      z       9365.0  57.447944\n```\n\n우리는 그랜드마스터 래더에서 프로토스가 가장 인기 있는 선택이라는 것을 배울 수 있을 뿐만 아니라, DuckDB가 Pandas와의 호환성으로 데이터 과학자와 분석가들에게 새로운 가능성을 열어 줍니다. DuckDB의 SQL 능력과 Pandas의 데이터 조작 기능을 원활하게 전환하여 사용자들은 두 플랫폼의 강점을 활용하여 업무 효율성과 유연성을 극대화할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_5.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n숫자를 다루거나 데이터 집합을 변환하거나 복잡한 분석을 수행하더라도, DuckDB는 신뢰할 수 있는 동반자로 빛을 발합니다. SQL의 편리함과 Pandas 및 기타 라이브러리의 다양성을 통해 데이터 조작을 효율적으로 진행할 수 있습니다.\n\n# Streamlit\n\nStreamlit의 오픈 소스 앱 프레임워크를 통해 데이터 시각화 및 상호 작용 가능한 웹 앱을 만들 수 있습니다. 이러한 앱을 로컬에서 실행하거나 무료로 Streamlit Community Cloud에 배포할 수도 있습니다. Streamlit 자체에는 모든 종류의 데이터를 렌더링할 요소가 이미 포함되어 있지만, Streamlit의 가능성을 확장하는 서드파티 모듈(구성 요소)도 많이 있습니다.\n\n간단히 Python 프로젝트에 설치할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nstreamlit 설치하기\n```\n\n그런 다음, 전용 스크립트 파일에서 앱을 만들고 streamlit run 명령어를 통해 실행합니다:\n\n```js\nstreamlit run your_script.py [-- 스크립트 인수]\n```\n\n파이썬 스크립트를 코드로 상상해 보세요. 위에서부터 아래로 앱을 나타내죠. 함께 하면:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nimport streamlit as st\n\nst.title(\"내 Streamlit 앱\")\n```\n\n간단한 헤더가 있는 웹 앱이 생성됩니다.\n\n![img](/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_6.png)\n\n다음 코드를 사용하면:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nimport streamlit as st\n\nst.dataframe(df)\n```\n\n대화형 테이블로 데이터프레임을 표시할 수 있어요. 데이터를 시각화하는 많은 가능성이 있습니다. StarCraft II 데이터를 렌더링하는 앱을 구현할 때 구체적인 사용 사례를 보게 될 거에요. 기대하시고 즐겁게 읽어 주세요.\n\n# Airflow, DuckDB 및 Streamlit을 사용한 StarCraft II 데이터 파이프라인\n\n프로젝트의 기본 아이디어는 StarCraft II API에서 데이터를 가져오는 것이에요. 보다 정확하게 말하자면 현재 게임에서 가장 우수한 사람을 알아보기위해 그랜드마스터 래더에 대한 정보를 가져올 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 그 데이터를 DuckDB 파일에 저장한 다음 Airflow DAG와 TaskFlow API를 사용하여 이 프로세스를 조정할 것입니다. 마지막으로, Streamlit을 사용하여 간단한 앱을 만들 것입니다.\n\n최종 프로젝트는 Github에서도 확인하실 수 있어요 🪄: https://github.com/vojay-dev/sc2-data-pipeline 하지만 이어지는 챕터에서는 이 스타크래프트 II 데이터 파이프라인을 어떻게 단계별로 구현하는지 설명할 거예요.\n\n제가 사용하고 있는 환경은 다음과 같아요:\n\n- OS: macOS Sonoma\n- Python: 3.11.8\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 프로젝트 설정\n\n새로운 파이썬 프로젝트를 만들기 위해 시작합니다. 먼저 새로운 폴더를 만듭니다. 이 폴더 안에서 빌트인 venv 모듈을 사용하여 가상 환경을 만듭니다:\n\n```bash\nmkdir sc2-data-pipeline\ncd sc2-data-pipeline\npython -m venv .venv\nsource .venv/bin/activate\n```\n\n![이미지](/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막 명령어로 가상 환경도 활성화되었습니다. 이는 말하자면: 해당 터미널 세션에서 실행하는 모든 것이 시스템 전역 Python이 아닌 가상 Python을 사용하게 됩니다. 이는 우리가 다음에 설치할 종속성을 프로젝트 내에서 격리시키고 싶어하는 중요한 부분입니다.\n\n이 프로젝트는 Airflow, DuckDB, Streamlit, Pandas 및 PyArrow을 사용하므로, 다음 단계는 모든 요구 사항을 설치하는 것입니다:\n\n```javascript\n# Airflow 설치\nAIRFLOW_VERSION=2.8.2\nPYTHON_VERSION=\"$(python --version | cut -d \" \" -f 2 | cut -d \".\" -f 1-2)\"\nCONSTRAINT_URL=\"https://raw.githubusercontent.com/apache/airflow/constraints-${AIRFLOW_VERSION}/constraints-${PYTHON_VERSION}.txt\"\npip install \"apache-airflow==${AIRFLOW_VERSION}\" --constraint \"${CONSTRAINT_URL}\"\n\n# DuckDB 설치\npip install duckdb\n\n# Pandas 및 PyArrow 설치\npip install pandas\npip install pyarrow\n\n# Streamlit 설치\npip install streamlit\n```\n\n이 과정은 조금 시간이 걸릴 수 있으니, 이는 커피를 마실 좋은 순간입니다. ☕️\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_8.png\" /\u003e\n\n위에서 보듯이 Airflow 2.8.2를 사용하고 있습니다. 또한, 왜 Poetry나 최소한 requirements.txt를 사용하는 대신 이러한 종속성을 수동으로 설치하는지 궁금해할 수도 있습니다. Airflow를 로컬에 설치할 때는 이 접근 방식이 가장 안정적으로 작동하며, 공식적인 Poetry 지원이 아직 없습니다. 이러한 이유로 그리고 간단하게 유지하기 위해 수동 방식을 선택했습니다.\n\n# Airflow 준비하기\n\nAirflow는 구성 파일과 같은 데이터를 관리하기 위해 로컬 디스크에 airflow라는 폴더를 사용합니다. 보통 이 폴더는 현재 사용자의 홈 디렉터리에 배치됩니다. 그러나 다른 프로젝트와 충돌을 피하기 위해 AIRFLOW_HOME 환경 변수를 해당하는 프로젝트 폴더로 설정하여 airflow 폴더의 기준으로 사용할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAirflow를 독립 실행 모드로 처음 시작하면, 지정된 위치에 폴더를 생성하고 기본 구성을 사용합니다. SequentialExecutor와 SQLite를 데이터베이스로 사용하며, 데이터베이스 파일은 AIRFLOW_HOME 위치에 저장됩니다.\n\n다음 명령어는 AIRFLOW_HOME 환경 변수를 현재 디렉토리(프로젝트 디렉토리)에 airflow라는 폴더로 설정하고 Airflow를 독립 실행 모드로 시작합니다. 또한 명령에 NO_PROXY라는 다른 환경 변수를 추가합니다. 이는 macOS에서 DAG를 Airflow 웹 인터페이스를 통해 실행할 때 발생하는 SIGSEGV 문제로 인한 것입니다.\n\n```sh\nNO_PROXY=\"*\" AIRFLOW_HOME=\"$(pwd)/airflow\" airflow standalone\n```\n\n이로써 Airflow를 시작할 뿐만 아니라 프로젝트 디렉토리에 airflow 폴더를 자동으로 생성할 것입니다. 또한 웹 인터페이스를 위해 관리자 사용자를 자동으로 생성합니다. 로그 출력에 사용자 이름과 비밀번호를 확인할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_9.png\" /\u003e\n\n```js\nstandalone | Airflow is ready\nstandalone | Login with username: admin password: FZCvvSd8WVYDb2Vm\nstandalone | Airflow Standalone is for development purposes only. Do not use this in production!\n```\n\n브라우저에서 http://localhost:8080/을 열어서 로그 출력에서 제공된 자격 증명을 사용하여 로그인할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_10.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n축하해요 🎉, 실용적이고 로컬 Airflow 환경을 갖추셨군요. 웹 인터페이스의 경고 메시지가 표시되는 이유는 자동으로 SequentialExecutor와 스탠드얼론 모드의 SQLite 데이터베이스를 사용하고 있기 때문입니다. 당연히 이는 본격적인 운영용이 아닌 것이죠.\n\n스탠드얼론 프로세스를 종료하려면 컨트롤+c를 누르세요.\n\nDAG 작업에 앞서 환경을 좀 더 준비해보겠습니다.\n\n한 가지 주목할 점이 있을 겁니다: 예제 DAG들이 많이 있습니다. 저는 개인적으로 깔끔한 환경으로 시작하는 것을 좋아해요. 이 예제들은 특정 구성 변수가 설정되었을 때 시작됩니다. 그러니 먼저 이 부분을 구성 수정해 볼게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n프로젝트 폴더 내의 airflow 폴더에 AIRFLOW_HOME 변수를 설정했기 때문에 구성 파일의 위치는 airflow/airflow.cfg입니다.\n\n![이미지](/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_11.png)\n\n즐겨 사용하는 편집기에서 구성을 열어 다음 구성을 변경하세요:\n\n```js\nload_examples = False\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n혼자서 실행되는 프로세스를 다시 시작하더라도 예시 DAG들은 데이터베이스에 남아있기 때문에 계속 나타날 수 있습니다. 따라서 다음 명령어로 데이터베이스를 재설정해야 합니다. (가상 환경을 활성화하고 프로젝트 폴더 내에 있어야 함을 확인하세요).\n\n```bash\nNO_PROXY=\"*\" AIRFLOW_HOME=\"$(pwd)/airflow\" airflow db reset\n```\n\n정상적으로 재설정했다면, 환경을 다시 시작하고 이제는 깨끗한 상태입니다. 이제 새로운 관리자 사용자를 생성하지만 이번에는 예시 DAG는 생성되지 않습니다.\n\n```bash\nNO_PROXY=\"*\" AIRFLOW_HOME=\"$(pwd)/airflow\" airflow standalone\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_12.png)\n\nDAG를 생성하기 전에 조정해야 할 사항이 하나 더 있습니다. 일반적으로 프로젝트를 Git 저장소에 커밋할 때 airflow 폴더를 추가하고 싶지 않습니다. 그 이유는 프로덕션 환경에서 프로젝트 폴더에 위치하지 않고 로컬 환경이기 때문에 다른 개발자들이 각자의 환경을 설정할 수 있도록 하기 위함입니다.\n\n그래서 .gitignore 파일에 airflow/를 추가할 것입니다. 그러나 이 접근 방식에 문제가 있습니다. 기본적으로 Airflow는 airflow 폴더 내의 dags라는 폴더에서 DAG를 찾기 때문에 airflow/dags로 지정합니다. 이 폴더에 DAG 구현을 추가하고 .gitignore 파일에서 airflow/ 폴더를 무시한다면, 우회 방식 없이 코드를 저장소에 커밋할 수 없게 됩니다.\n\n다행히도, 해결책은 Airflow 구성에서 DAGs 폴더를 변경하는 것뿐입니다. 이를 해결하기 위해 이 변수를 프로젝트 폴더 내에 있는 dags라는 폴더로 설정하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 목적을 달성하려면 Airflow/airflow.cfg 파일을 다시 열어서 dags_folder 변수를 찾으세요. 이 변수를 프로젝트 폴더 내의 dags라는 폴더를 가리키도록 설정하십시오. 예를 들어:\n\n```js\ndags_folder = /tmp/sc2-data-pipeline/dags\n```\n\n마지막으로, 프로젝트 내에 빈 dags 폴더를 생성하고 준비 완료입니다.\n\n```js\nmkdir dags\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_13.png)\n\n# 스타크래프트 II API 액세스 받기\n\n우리가 사용하고 있는 API는 스타크래프트 II 커뮤니티 API의 일부입니다.\n\n![image](/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_14.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제한은 매우 관대합니다: 1시간당 36000개의 요청 및 1초당 100개의 요청이 가능하므로 이 시나리오에서 DAG를 자유롭게 실행할 수 있습니다.\n\n액세스를 받으려면 무료로 battle.net 계정을 사용하여 OAuth 클라이언트를 생성해야 합니다. 단순히 https://develop.battle.net/access/clients 로 이동하여 battle.net 계정으로 로그인하고 클라이언트를 생성하면 됩니다.\n\n![이미지](/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_15.png)\n\n이렇게 하면 다음을 얻을 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 클라이언트 ID 및\n- 클라이언트 비밀번호\n\n둘 다 API에 액세스하기 위해 필요하니 안전하게 보관하세요.\n\n기본 흐름은 먼저 클라이언트 ID와 비밀번호를 사용하여 액세스 토큰을 가져온 후 이 토큰을 사용하여 커뮤니티 API에서 데이터를 가져오는 것입니다. 다음 예시는 터미널에서 curl 및 jq를 사용하여 이 작업을 수행하는 방법을 보여줍니다. jq는 brew install jq를 사용하여 설치할 수 있습니다.\n\n액세스 토큰 가져오기 예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\ncurl -s -u your_client_id:your_client_secret -d grant_type=client_credentials https://oauth.battle.net/token | jq .\n```\n\n```js\n{\n  \"access_token\": \"super_secret_token\",\n  \"token_type\": \"bearer\",\n  \"expires_in\": 86399,\n  \"sub\": \"xxx\"\n}\n```\n\n데이터 가져오는 예시\n\n```js\ncurl -s --header \"Authorization: Bearer super_secret_token\" \"https://eu.api.blizzard.com/sc2/ladder/season/2\" | jq .\n```\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```json\n{\n  \"seasonId\": 58,\n  \"number\": 1,\n  \"year\": 2024,\n  \"startDate\": \"1704412800\",\n  \"endDate\": \"1711929600\"\n}\n```\n\n클라이언트 ID 및 시크릿이 준비되었으니 이제 DAG를 구현하여 그랜드마스터 래더 데이터를 가져와 유지할 수 있습니다.\n\n# DAG 구현\n\ndags 폴더에 Python 파일 sc2.py를 만들어 DAG의 구현을 실행할 것입니다. 아래 코드를 추가하십시오. 이 코드는 TaskFlow API를 사용한 DAG 구현입니다. 이후에 일부 세부 정보를 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nimport logging\n\nimport pendulum\nimport requests\nfrom airflow.decorators import dag, task, task_group\nfrom airflow.models import Variable\nfrom requests.adapters import HTTPAdapter\nfrom urllib3 import Retry\nimport duckdb\nimport pandas as pd\n\nlogger = logging.getLogger(__name__)\n\nDUCK_DB = \"sc2data.db\"\n\nCLIENT_ID = \"your_client_id\"\nCLIENT_SECRET = \"your_client_secret\"\n\nBASE_URI = \"https://eu.api.blizzard.com\"\nREGION_ID = 2  # Europe\n\n# retry strategy for contacting the StarCraft 2 API\nMAX_RETRIES = 4\nBACKOFF_FACTOR = 2\n\n\n@dag(start_date=pendulum.now())\ndef sc2():\n    retry_strategy = Retry(total=MAX_RETRIES, backoff_factor=BACKOFF_FACTOR)\n    adapter = HTTPAdapter(max_retries=retry_strategy)\n    session = requests.Session()\n    session.mount('https://', adapter)\n\n    @task\n    def get_access_token() -\u003e str:\n        data = {\"grant_type\": \"client_credentials\"}\n        response = session.post(\"https://oauth.battle.net/token\", data=data, auth=(CLIENT_ID, CLIENT_SECRET))\n        return response.json()[\"access_token\"]\n\n    @task\n    def get_grandmaster_ladder_data(token: str):\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        response = session.get(f\"{BASE_URI}/sc2/ladder/grandmaster/{REGION_ID}\", headers=headers)\n        ladder_teams = response.json().get(\"ladderTeams\", [])\n        return [{\n            \"id\": lt[\"teamMembers\"][0][\"id\"],\n            \"realm\": lt[\"teamMembers\"][0][\"realm\"],\n            \"region\": lt[\"teamMembers\"][0][\"region\"],\n            \"display_name\": lt[\"teamMembers\"][0][\"displayName\"],\n            \"clan_tag\": lt[\"teamMembers\"][0][\"clanTag\"] if \"clanTag\" in lt[\"teamMembers\"][0] else None,\n            \"favorite_race\": lt[\"teamMembers\"][0][\"favoriteRace\"] if \"favoriteRace\" in lt[\"teamMembers\"][0] else None,\n            \"previous_rank\": lt[\"previousRank\"],\n            \"points\": lt[\"points\"],\n            \"wins\": lt[\"wins\"],\n            \"losses\": lt[\"losses\"],\n            \"mmr\": lt[\"mmr\"] if \"mmr\" in lt else None,\n            \"join_timestamp\": lt[\"joinTimestamp\"]\n        } for lt in ladder_teams if lt[\"teamMembers\"] and len(lt[\"teamMembers\"]) == 1]\n\n    def get_profile_metadata(token: str, region: str, realm: int, player_id: int) -\u003e dict:\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        response = session.get(f\"{BASE_URI}/sc2/metadata/profile/{region}/{realm}/{player_id}\", headers=headers)\n        return response.json() if response.status_code == 200 else None\n\n    @task\n    def enrich_data(token: str, data: list) -\u003e list:\n        logger.info(\"Fetching metadata for %d players\", len(data))\n\n        for i, player in enumerate(data, start=1):\n            logger.info(\"Fetching metadata for player %d/%d\", i, len(data))\n            metadata = get_profile_metadata(token, player[\"region\"], player[\"realm\"], player[\"id\"])\n\n            player[\"profile_url\"] = metadata.get(\"profileUrl\") if metadata else None\n            player[\"avatar_url\"] = metadata.get(\"avatarUrl\") if metadata else None\n            player[\"name\"] = metadata.get(\"name\") if metadata else None\n\n        return data\n\n    @task\n    def create_pandas_df(data: list) -\u003e pd.DataFrame:\n        return pd.DataFrame(data)\n\n    @task\n    def store_data_in_duckdb(ladder_df: pd.DataFrame) -\u003e None:\n        with duckdb.connect(DUCK_DB) as conn:\n            conn.sql(f\"\"\"\n                DROP TABLE IF EXISTS ladder;\n                CREATE TABLE ladder AS\n                SELECT * FROM ladder_df;\n            \"\"\")\n\n    @task_group\n    def get_data() -\u003e list:\n        access_token = get_access_token()\n        ladder_data = get_grandmaster_ladder_data(access_token)\n        return enrich_data(access_token, ladder_data)\n\n    @task_group\n    def store_data(enriched_data: list) -\u003e None:\n        df = create_pandas_df(enriched_data)\n        store_data_in_duckdb(df)\n\n    store_data(get_data())\n\n\nsc2()\n```\n\nDAG의 기본 흐름은 꽤 간단합니다. 앞서 설명한 두 주요 태스크 그룹인 get_data와 store_data가 연결됩니다.\n\n![image](/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_16.png)\n\n이제 이러한 태스크 그룹의 주요 요소들을 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터 가져오기\n\n데이터 가져오기는 Airflow에서 각각의 태스크로 실행되는 다음 3단계로 이루어집니다:\n\n- 🔐 get_access_token: 클라이언트 ID와 비밀번호를 사용하여 최신 엑세스 토큰을 가져옵니다.\n- 📝 get_grandmaster_ladder_data: 토큰을 사용하여 모든 플레이어의 최신 그랜드마스터 래더 데이터를 가져옵니다.\n- 👥 enrich_data: 다른 API 엔드포인트를 사용하여 래더의 각 항목을 플레이어 프로필 URL, 아바타 및 이름과 함께 풍부하게 만듭니다.\n\nrequest.get 또는 request.post 함수를 직접 사용하는 대신, 모든 요청에 사용하는 세션을 생성합니다. 이를 통해 재시도 및 백오프 전략을 정의할 수도 있습니다. 외부 API 소스에서 데이터를 가져오는 경우 DAG가 일시적으로 사용할 수 없는 API 때문에 실패하지 않도록 하려면 이 방법이 권장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nMAX_RETRIES = 4\nBACKOFF_FACTOR = 2\n\nretry_strategy = Retry(total=MAX_RETRIES, backoff_factor=BACKOFF_FACTOR)\nadapter = HTTPAdapter(max_retries=retry_strategy)\nsession = requests.Session()\nsession.mount('https://', adapter) \n```\n\n여기에, 우리는 세션을 사용하여 작업에서 요청을 보낼 수 있습니다. 예를 들어, 액세스 토큰을 얻기 위해:\n\n```js\n    @task\n    def get_access_token() -\u003e str:\n        data = {\"grant_type\": \"client_credentials\"}\n        response = session.post(\"https://oauth.battle.net/token\", data=data, auth=(CLIENT_ID, CLIENT_SECRET))\n        return response.json()[\"access_token\"]\n```\n\nget_grandmaster_ladder_data에서는 https://eu.api.blizzard.com/sc2/ladder/grandmaster/'REGION_ID' 엔드포인트에서 최신 그랜드마스터 래더를 가져옵니다. 여기서 REGION_ID는 유럽 데이터를 얻기 위해 우리의 경우에 2로 설정됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, enrich_data 작업에서는 래더의 각 플레이어에 대해 https://eu.api.blizzard.com/sc2/metadata/profile/'region'/'realm'/'player_id' 엔드포인트를 호출하여 기존 플레이어 항목을 보강합니다. 엔드포인트 호출 자체는 get_profile_metadata 도우미 함수에 캡슐화되어 있습니다.\n\n# 데이터 저장\n\n데이터 저장은 다음 2 단계에서 발생하며 각각 Airflow에서 작업으로 실행됩니다:\n\n- 🐼 create_pandas_df: 플레이어 목록을 기반으로 판다스 데이터프레임 생성.\n- 🦆 store_data_in_duckdb: 데이터프레임을 파일에 저장된 DuckDB에 저장합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전에도 언급했듯이, DuckDB는 Pandas 데이터프레임을 포함한 다양한 형식을 읽고 쓸 수 있습니다. 따라서 첫 번째 단계는 사다리의 각 플레이어가 되는 딕셔너리 목록에서 데이터프레임을 생성하는 것입니다.\n\n```js\n    @task\n    def create_pandas_df(data: list) -\u003e pd.DataFrame:\n        return pd.DataFrame(data)\n```\n\nDuckDB에 이 데이터프레임을 저장하는 것은 놀랍도록 쉽습니다. 처음 보는 코드를 읽을 때 놀라실 수도 있지만, 네: SQL에서 데이터프레임 변수를 참조할 수 있습니다.\n\n```js\n    @task\n    def store_data_in_duckdb(ladder_df: pd.DataFrame) -\u003e None:\n        with duckdb.connect(DUCK_DB) as conn:\n            conn.sql(f\"\"\"\n                DROP TABLE IF EXISTS ladder;\n                CREATE TABLE ladder AS\n                SELECT * FROM ladder_df;\n            \"\"\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파일에 데이터를 유지하는데, 각 실행에서 기존 데이터를 삭제하여 가장 최신 정보만 저장합니다. 우리는 INSERT OR REPLACE를 사용할 수 있지만, 그런 경우에는 기본 키 제약 조건을 정의해야 합니다. 이는 데이터프레임을 기반으로 직접 테이블을 생성할 때 불가능합니다. 하지만 우리의 사용 사례에는 이 방법이 충분합니다. 이런 경우에 저는 사람들에게 KISS 원칙을 상기시키는 것을 좋아합니다:\n\n데이터를 저장한 후에는 DAG가 완료되어 시각화할 수 있습니다.\n\n# Streamlit을 사용한 데이터 시각화\n\nStreamlit 앱을 위해 프로젝트의 루트 디렉토리에 새 파일을 만듭니다: app.py. 다음 내용을 간단히 추가할 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nimport streamlit as st\n\nst.title(\"StarCraft 2 Grandmaster Ladder\")\n\n\n앱을 실행하려면 다음을 사용하세요:\n\n\nstreamlit run app.py\n\n\n헤더가 있는 간단한 웹 페이지가 표시됩니다. 앱을 확장할 때마다 자동으로 새로 고침됩니다. 이제 DuckDB에서 데이터를 읽고 렌더링하는 실제 앱으로 내용을 바꿔봅시다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nimport streamlit as st\nimport duckdb\n\ncon = duckdb.connect(database=\"sc2data.db\", read_only=True)\n\nst.title(\"StarCraft 2 Grandmaster Ladder\")\n\n@st.cache_data\ndef load_ladder_data():\n    df = con.execute(\"SELECT * FROM LADDER\").df()\n\n    # mmr로 정렬하고 아바타를 첫 번째 열로 이동\n    df.sort_values(\"mmr\")\n    avatar_url = df.pop(\"avatar_url\")\n    df.insert(0, \"avatar\", avatar_url)\n\n    return df\n\n@st.cache_data\ndef load_favorite_race_distribution_data():\n    df = con.execute(\"\"\"\n        SELECT favorite_race, COUNT(*) AS count\n        FROM LADDER\n        WHERE favorite_race IS NOT NULL\n        GROUP BY 1\n        ORDER BY 2 DESC\n    \"\"\").df()\n    return df\n\nladder = load_ladder_data()\n\nst.dataframe(ladder, column_config={\n    \"avatar\": st.column_config.ImageColumn(\"avatar\")\n})\n\ndistribution_data = load_favorite_race_distribution_data()\nst.bar_chart(distribution_data, x=\"favorite_race\", y=\"count\")\n\n\n마지막으로, MMR순으로 정렬된 StarCraft II 그랜드마스터 래더 데이터를 시각화하고, 플레이어들의 아바타도 보여줍니다:\n\n\u003cimg src=\"/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_17.png\" /\u003e\n\nPandas 데이터프레임과 DuckDB를 강력한 데이터 가공 툴킷으로 결합하는 좋은 예시를 보여주는 앱 구현입니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndf = con.execute(\"SELECT * FROM LADDER\").df()\n\n# mmr을 기준으로 정렬하고 아바타를 첫 번째 열로 옮깁니다\ndf.sort_values(\"mmr\")\navatar_url = df.pop(\"avatar_url\")\ndf.insert(0, \"avatar\", avatar_url)\n\nreturn df\n```\n\nStreamlit을 사용하면 데이터프레임을 쉽게 렌더링할 수 있을 뿐만 아니라 특정 열을 교체하여 앱에서 렌더링하는 방식을 수정할 수도 있습니다. 이 예시에서는 아바타 열에서 URL을 가져와 이미지로 렌더링합니다:\n\n```js\nst.dataframe(ladder, column_config={\n    \"avatar\": st.column_config.ImageColumn(\"avatar\")\n})\n```\n\n마지막으로, 그랜드마스터 래더에서 프로토스가 가장 주요한 진영으로 보이는 것을 확인할 수 있습니다. 제가 전 프로토스 플레이어였기 때문에 이 소식을 듣는 것은 좋습니다 😉. \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n마지막으로, Apache Airflow, Streamlit, 그리고 DuckDB를 활용하여 데이터 파이프라인을 구축하는 여정은 데이터 파이프라인을 조율하고 대화형 데이터 애플리케이션을 개발하는 데 소중한 기술적 통찰력을 제공했습니다.\n\nDuckDB는 데이터 wrangling 도전에 강력한 동반자로 나타났으며, Pandas 데이터프레임과 고급 분석 SQL 기능과의 원활한 통합을 제공했습니다. 가벼운 성격과 효율적인 성능을 통해 리소스 제한적 환경에서 분석 워크로드에 적합함을 입증했습니다.\n\n직관적인 인터페이스와 강력한 시각화 기능을 갖춘 Streamlit은 대화형 데이터 애플리케이션의 신속한 개발 잠재력을 보여주었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 기술을 탐색한 것을 되돌아보면, 현대 데이터 엔지니어링 및 분석 워크플로우에서 그 역할의 중요성을 인지합니다. 별Craft II 그랜드마스터 플레이어처럼, 당신의 유닛 구성을 신중하게 계획하고, 항상 데이터 엔지니어링 도구 상자를 확장하고 최적화하세요. 데이터 영역에서의 다음 임무까지, 여러분의 파이프라인이 원활히 흐르고 승리가 시간이 잘 맞은 레베이저 사격만큼 달콤하길 바랍니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_18.png\" /\u003e","ogImage":{"url":"/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_0.png"},"coverImage":"/assets/img/2024-06-22-ExploringStarCraft2datawithAirflowDuckDBandStreamlit_0.png","tag":["Tech"],"readingTime":27}],"page":"36","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"36"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>