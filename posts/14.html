<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>itposting</title><meta name="description" content="I develop websites, games and apps with HTML, CSS and JS."/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///posts/14" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="itposting" data-gatsby-head="true"/><meta property="og:title" content="itposting" data-gatsby-head="true"/><meta property="og:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta property="og:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///posts/14" data-gatsby-head="true"/><meta name="twitter:title" content="itposting" data-gatsby-head="true"/><meta name="twitter:description" content="I develop websites, games and apps with HTML, CSS and JS." data-gatsby-head="true"/><meta name="twitter:image" content="/favicons/ms-icon-310x310.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="next-head-count" content="18"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/a22d13b8e6bc8203.css" as="style"/><link rel="stylesheet" href="/_next/static/css/a22d13b8e6bc8203.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/873-1532cbf2955c0c6a.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bpage%5D-cd321dee6458c228.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="posts_container__s9Z_H posts_-list__bsl0U"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><div class="posts_inner__HIBjT"><article><h2 class="SectionTitle_section_title__HS_xr">Posts</h2><div class="posts_project_list__oDV_y"><div class="PostList_post_list__or0rl"><a class="PostList_post_item__gAdVi" aria-label="해상 통신을 위한 LoRa 기술 활용법 범선에서의 새로운 가능성" href="/post/2024-06-23-BeyondtheGridLoRaforSailboatCommunication"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="해상 통신을 위한 LoRa 기술 활용법 범선에서의 새로운 가능성" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="해상 통신을 위한 LoRa 기술 활용법 범선에서의 새로운 가능성" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">해상 통신을 위한 LoRa 기술 활용법 범선에서의 새로운 가능성</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="CH340 칩이 탑재된 비공식 Arduino 클론에서 Arduino IDE 사용하는 방법" href="/post/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="CH340 칩이 탑재된 비공식 Arduino 클론에서 Arduino IDE 사용하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="CH340 칩이 탑재된 비공식 Arduino 클론에서 Arduino IDE 사용하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">CH340 칩이 탑재된 비공식 Arduino 클론에서 Arduino IDE 사용하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Proteus와 Arduino IDE를 사용하여 벽돌깨기 게임 만드는 방법" href="/post/2024-06-23-CreatingaBrick-BreakingGameUsingProteusandArduinoIDE"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Proteus와 Arduino IDE를 사용하여 벽돌깨기 게임 만드는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-CreatingaBrick-BreakingGameUsingProteusandArduinoIDE_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Proteus와 Arduino IDE를 사용하여 벽돌깨기 게임 만드는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Proteus와 Arduino IDE를 사용하여 벽돌깨기 게임 만드는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">17<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="저항 밴드 색상 읽는 방법 쉽게 배우기" href="/post/2024-06-23-HowToReadResistorBandColors"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="저항 밴드 색상 읽는 방법 쉽게 배우기" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-HowToReadResistorBandColors_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="저항 밴드 색상 읽는 방법 쉽게 배우기" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">저항 밴드 색상 읽는 방법 쉽게 배우기</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">3<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법" href="/post/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">5<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="필라멘트 압출기 제작 파트 2 단계별 가이드" href="/post/2024-06-23-Part2BuildingFilamentExtruder"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="필라멘트 압출기 제작 파트 2 단계별 가이드" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-Part2BuildingFilamentExtruder_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="필라멘트 압출기 제작 파트 2 단계별 가이드" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">필라멘트 압출기 제작 파트 2 단계별 가이드</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="ESA, 세계 최초의 금속 3D 프린팅 성공 우주정거장에서의 혁신적인 순간" href="/post/2024-06-23-ESAAchievesHistoricWorlds1stMetal3DPrintingonSpaceStation"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="ESA, 세계 최초의 금속 3D 프린팅 성공 우주정거장에서의 혁신적인 순간" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-ESAAchievesHistoricWorlds1stMetal3DPrintingonSpaceStation_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="ESA, 세계 최초의 금속 3D 프린팅 성공 우주정거장에서의 혁신적인 순간" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">ESA, 세계 최초의 금속 3D 프린팅 성공 우주정거장에서의 혁신적인 순간</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">4<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Original Prusa MK4 3D 프린터 리뷰 조용한 일꾼의 성능 평가" href="/post/2024-06-23-OriginalPrusaMK43DPrinterReviewTheQuietWorkhorse"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Original Prusa MK4 3D 프린터 리뷰 조용한 일꾼의 성능 평가" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-OriginalPrusaMK43DPrinterReviewTheQuietWorkhorse_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Original Prusa MK4 3D 프린터 리뷰 조용한 일꾼의 성능 평가" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Original Prusa MK4 3D 프린터 리뷰 조용한 일꾼의 성능 평가</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">14<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="Creality Ender-3 V2의 전력 소비 얼마나 전력을 사용할까" href="/post/2024-06-23-PowerConsumptionoftheCrealityEnder-3V2"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="Creality Ender-3 V2의 전력 소비 얼마나 전력을 사용할까" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-PowerConsumptionoftheCrealityEnder-3V2_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="Creality Ender-3 V2의 전력 소비 얼마나 전력을 사용할까" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">Creality Ender-3 V2의 전력 소비 얼마나 전력을 사용할까</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a><a class="PostList_post_item__gAdVi" aria-label="OctoPrint로 Z 오프셋 조정하는 방법" href="/post/2024-06-23-26HowtocalibrateZoffsetusingOctoPrint"><div class="PostList_thumbnail_wrap__YuxdB"><img alt="OctoPrint로 Z 오프셋 조정하는 방법" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="PostList_thumbnail__6_oQk" style="color:transparent" src="/assets/img/2024-06-23-26HowtocalibrateZoffsetusingOctoPrint_0.png"/></div><div class="PostList_text_area__Hzd11"><div class="PostList_profile_area___aTjn"><div class="PostList_profile_image_wrap__tCTuE"><img alt="OctoPrint로 Z 오프셋 조정하는 방법" loading="lazy" width="20" height="20" decoding="async" data-nimg="1" class="PostList_profile__VGF_a" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><span class="writer">IT Posting</span></div><strong class="PostList_title__loLkl">OctoPrint로 Z 오프셋 조정하는 방법</strong><div class="PostList_meta__VCFLX"><span class="date">Jun 23, 2024</span><span class="PostList_reading_time__6CBMQ">2<!-- --> min read</span><span class="PostList_bookmark__PCpOK"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" aria-hidden="true"><path d="M6.75 4.5h10.5a.75.75 0 01.75.75v14.357a.375.375 0 01-.575.318L12 16.523l-5.426 3.401A.375.375 0 016 19.607V5.25a.75.75 0 01.75-.75zM16.5 6h-9v11.574l4.5-2.82 4.5 2.82V6z"></path></svg></span></div></div></a></div></div></article><div class="posts_pagination__R_03T"><a class="link" href="/posts/1">1</a><a class="link" href="/posts/2">2</a><a class="link" href="/posts/3">3</a><a class="link" href="/posts/4">4</a><a class="link" href="/posts/5">5</a><a class="link" href="/posts/6">6</a><a class="link" href="/posts/7">7</a><a class="link" href="/posts/8">8</a><a class="link" href="/posts/9">9</a><a class="link" href="/posts/10">10</a><a class="link" href="/posts/11">11</a><a class="link" href="/posts/12">12</a><a class="link" href="/posts/13">13</a><a class="link posts_-active__YVJEi" href="/posts/14">14</a><a class="link" href="/posts/15">15</a><a class="link" href="/posts/16">16</a><a class="link" href="/posts/17">17</a><a class="link" href="/posts/18">18</a><a class="link" href="/posts/19">19</a><a class="link" href="/posts/20">20</a><button type="button" class="page_button -prev">&gt;</button></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"title":"해상 통신을 위한 LoRa 기술 활용법 범선에서의 새로운 가능성","description":"","date":"2024-06-23 17:37","slug":"2024-06-23-BeyondtheGridLoRaforSailboatCommunication","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_0.png\" /\u003e\n\n# 배경\n\n내 아내와 나는 40피트 카타마란에 살고 있으며 자주 휴대용 VHF 해양 무선기로 통하지 않는 지역에 있습니다. 휴대용 VHF 해양 무선기는 좋지만 범위가 제한되고 배터리 수명은 사용에 따라 일수보다는 시간으로 더 정확히 측정됩니다. 게다가, 해양 VHF 주파수는 156-174 MHz 사이이기 때문에 시야 통제 밖이면 신호가 빠르게 약해집니다. 일반적으로 주파수가 높을수록 건물, 언덕 또는 산과 같은 물체를 통과하거나 주위를 휘젓는 데 있어 침투하는 능력이 떨어집니다.\n\n그래서 나는 이에 대한 대안적인 통신 수단을 찾고 있었습니다. 그래서 나왔다고 하는 것이 LoRa와 Meshtastic입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 가능한 해결책\n\nLoRa (Long Range)은 미국에서 915MHz 주파수에서 작동하는 라디오 유형입니다. 해양용 VHF보다 훨씬 높은 주파수에서 작동하지만, CSS (chirp spread spectrum) 기술을 사용하여 신호 무결성을 유지하는 데 훨씬 효율적입니다. CSS는 915MHz 주변을 중심으로 한 주파수 범위에 퍼져있는 신호를 방송합니다.\n이로써 전파가 소음과 간섭, 도플러 이동 (신호가 이동할 때, 예를 들어 보트 딩기에서)에 민감하지 않고 수신기 성능도 더 우수합니다. 이 문장을 읽고 계시다면 트랜시버가 어떻게 작동하는지에 대한 기본적인 지식이 있거나 몇 가지 사항을 찾아보는 것이 상관 없다고 가정하겠습니다.\n\n# 우리에게 어떤 점이 도움이 될까요?\n\n첫째, 이것이 우리의 요구 사항을 충족시킬 것이라는 보장은 없지만, 시도할 가치가 있는 실험이라고 생각됩니다. 또한, 어릴 때 해머디오 라이선스를 취득했기 때문에 라디오 하드웨어와 노는 것을 즐겼던 시절로 돌아가는 향수 여행이기도 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 시나리오를 고려해 봅시다; 우리는 휴대폰 수신이 가능한 지역 가장자리에 정박해 있고, 우리 중 한 명이 보트를 타고 마을로 가서 장보러 가야 합니다. 마을은 가깝지만 몇 건물만 떨어져 있어도 휴대용 VHF 라디오를 사용할 수 없을 수 있습니다. \n우리가 리스트에 팝콘을 잊어먹었다는 걸 어떻게 알려줄까요? 이럴 때 LoRa가 필요합니다.\n\n# 장비\n\n![image](/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_1.png)\n\n저는 LoRa 보드를 아마존에서 주문했는데, 편리하게도 2개 팩키지로 판매하고 있습니다. 저는 WiFi와 블루투스가 장착된 제품을 선택했으나 GPS는 없는 제품입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUSB-C 커넥터로 전원을 공급할 수 있는데, 동시에 내장형 LiPo 배터리 관리자가 있어서 이에 맞는 배터리를 구입했습니다. 보드의 전체 사양을 원하신다면 여기서 찾아볼 수 있어요.\n\n사알과 함께 사용할 배터리가 감쪽같이 들어가지 않아서 사례에는 맞지 않는다는 사실을 깨달았습니다. 하지만 사례가 그리 단단하지 않다고 생각해서 크게 상관하지 않았어요. muziWORKSlab에서 이 사례를 몇 개 주문했으니 곧 도착할 거예요. 거기서 일이 잘 풀리지 않는다고 느꼈기 때문에 이 같은 상황이 발생했어요. 그리고 동일한 상점에서 와이파이 안테나도 주문했어요. 사실상, 같은 상품으로 부터 공급을 받은 안테나는 최적의 성능을 내기에는 크기가 적절하지 않은 듯하더라고요. 주문한 애는 길이 등을 고려하여 계산해 보았을 때 훨씬 나아보여서, 915MHz 대역에서 전송할 때 측정된 SWR이 좋아졌어요. 이 대역은 미국의 주파수대 조건이죠.\n\n선택한 배터리는 이미 SH1.25×2 배터리 커넥터가 부착되어 있어 배터리 포트에 직접 연결할 수 있습니다. 라디오와 함께 제공된 헤더 핀들은 좋은 것 같지만, 나는 아직 신기한 하드웨어 실험을 하고 싶진 않아요. 적어도 아직은요.\n\n\u003cimg src=\"/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_2.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 조각들을 모두 맞추기\n\n조그만하지만 정말 라디오인데, 모든 라디오들처럼 안테나를 사용하지 않고 방송하면 라디오 전송 회로에 손상을 입힐 수 있습니다. 그래서 장치에 전원을 공급하기 전에 안테나를 설치해야 했습니다. 이것은 실제로 시도해보기 전에는 간단한 과정처럼 보였습니다. 커넥터를 딱 맞추고 눌러야 하는데, 제 뚱뚱한 소세지 손가락은 작은 OLED 디스플레이의 정확한 가장자리와 싸우고 있었습니다. 이미지에서 얼마나 간격이 좁은지 볼 수 있습니다.\n수정하는 데 몇 분이 걸렸지만, 마침내 제대로 끼울 수 있었습니다. 진짜 안테나가 이번 주에 도착할 때 신경 쓰이지 않기를 바랍니다.\n\n![이미지](/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_3.png)\n\n# 라디오 설정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안테나가 설치되어 있어 라디오를 설정해야 했습니다. USB-C 커넥터를 사용하는 라디오와 노트북 및 USB 케이블이 있어 전원을 공급하는 것은 쉬웠어요. 부팅 시퀀스가 완료되면 위의 화면이 표시됩니다. 이제 메스타스틱 플랫폼을 장치에 플래시해야 했어요. 메스타스틱은 장치를 메쉬 네트워크의 노드로 변환하는 소프트웨어 및 하드웨어 통신 프로토콜을 제공합니다.\n\n복잡성 수준이 다른 몇 가지 방법으로 이 작업을 수행할 수 있지만, 현재는 어떤 실험도 하지 않고(적어도 현재는) 게으르기 때문에 브라우저 기반의 USB 플래셔를 사용하기로 선택했습니다.\n\n다행히도 이 프로세스는 원하던 대로 매우 간단했습니다. 단순히 설치하고 싶은 메스타스틱 버전을 선택하고 플래싱하는 것으로 요약됩니다. 그것뿐이에요. 장치에 대한 많은 구성이 있지만, 플래시된 후에는 라디오가 작동하도록 장치가 작동하는 지역을 구성해야 합니다.\n\n구성은 웹 클라이언트, iOS 또는 Android 클라이언트 또는 CLI를 사용하여 설정할 수 있습니다. 블루투스, 무선 또는 시리얼 연결을 받아들입니다. 저는 간단한 텍스트 메시지를 보내기 위해 사용할 것이므로 안드로이드 클라이언트를 설치하고 블루투스로 연결했어요. 이제 첫 번째 작동하는 라디오가 준비되었습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 배터리와 두 번째 라디오\n\n구성 옵션을 몇 분 동안 살펴본 후, 배터리 중 하나를 꽂아 충전할 시간이라고 결정했습니다. 배터리 소켓 앞에 골치 아픈 칩이 위치해 있어서 손가락이 뚱뚱해서 귀찮은 문제를 마주했죠. 소켓 정렬하는 데 고통스러움을 겪었지만 결국 해내서 배터리를 꽂을 수 있었습니다. USB 케이블을 다시 연결하고 완전히 충전될 때까지 약 2시간 동안 충전한 후 검을 뽑고 전원을 끄었습니다.\n\n![이미지](/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_6.png)\n\n이제 두 번째 라디오에 대한 라디오 설정을 반복해야 했습니다. 두 번째 시도 때는 확실히 빨랐어요. 금방 충전했습니다. 두 장치 간에 작은 텍스트 메시지를 주고받도록 실험한 뒤 결국 핸드폰의 GPS 위치를 라디오와 공유하는 방법을 찾았습니다. 그래서 통신하는 노드와의 거리를 나타내는 작은 화살표가 보이게 했습니다. 정확하지는 않지만 귀엽고, 내가 배에서 얼마나 떨어져 있는지 알고 싶을 때 유용할 것 같았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_7.png\" /\u003e\n\n# 실험 시간입니다\n\n집 안에서 간단히 살펴 보았지만, 실제 실험이 시작되는 것은 케이스가 도착하고 범위 테스트를 시작할 수 있는 때입니다. 희망적으로 케이스가 도착하면 다음 주에 그에 대한 보고를 할 수 있을 것입니다.\n데이터가 있으면 설정과 설명에 대해 자세히 이야기할 예정입니다.","ogImage":{"url":"/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_0.png"},"coverImage":"/assets/img/2024-06-23-BeyondtheGridLoRaforSailboatCommunication_0.png","tag":["Tech"],"readingTime":5},{"title":"CH340 칩이 탑재된 비공식 Arduino 클론에서 Arduino IDE 사용하는 방법","description":"","date":"2024-06-23 17:35","slug":"2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip","content":"\n\n사용되지 않는 Arduino 복제품의 예측할 수 없는 세계로 한 발 들어보세요\n\n![image](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_0.png)\n\n아두이노는 많은 DIY 프로젝트에 매우 인기가 높은 플랫폼이며 오픈 디자인 덕분에 많은 비공식 복제품이 있습니다. 그중 일부는 원래 아두이노 디자인을 완전히 복제하고 있지만, 일부는 더 저렴하게 만들려고 노력하고 있습니다.\n\n![image](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 비공식 아두이노 Uno R3 클론을 구매하고 Windows 기기에 연결했을 때 \"USB 장치를 인식하지 못했습니다\" 오류가 발생했다면, 이 기사가 도움이 될 것입니다. 아래에서는 공식 및 일부 비공식 아두이노 보드 간의 차이와 일부 비공식 보드가 Windows에서 인식되기 위해 설치해야 하는 것에 대해 살펴보겠습니다.\n\n## USB 어댑터\n\n우선, 아래에서 공식 아두이노 UNO R3를 살펴보겠습니다:\n\n![아두이노 UNO R3 이미지](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 사진의 칩 넘버 1은 아두이노의 두뇌입니다: 이것은 ATmega328P로, 아두이노 IDE를 통해 프로그래밍합니다. 이것이 보드의 핵심이며, 이 칩은 모든 스케치를 실행시킵니다 — CPU, 메모리를 포함하고 아두이노 핀들을 모두 제어합니다.\n\n하지만 더 자세히 살펴보면, 이 보드에 실제로 다른 칩이 하나 더 있음을 알 수 있습니다. 번호가 매겨진 칩은 2입니다. 이것은 ATmega16U2이며 이 보드에서 유일한 역할은 USB to 시리얼 변환기로서 일합니다. 다시 말해 — 이것은 이 보드에 USB 연결성을 제공하고 컴퓨터 USB 포트와 아두이노 시리얼 포트 사이의 다리 역할을 합니다.\n\n그러니까, 본질적으로 원래 아두이노 보드에 USB를 꼽으면 실제로 ATmega16U2로 꽂히게 되고, 이것이 컴퓨터에 통신하여 운영 체제가 인식하고 설치된 드라이버 목록에서 해당 드라이버를 로드합니다. 그런 다음 드라이버가 시스템에 새로운 COM 포트를 등록하고, 아두이노를 프로그래밍할 때 아두이노 IDE에서 선택할 수 있습니다. 아래 스크린샷을 보면 올바른 포트가 해당되는 이름으로 표시될 것임을 주의하세요 — 목적에 따라 드라이버가 수행하는지 아니면 ATmega16U2 칩의 펌웨어가 수행하는지는 확실하지 않습니다. 알고 계신다면 코멘트로 알려주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 위에서 설명한 모든 것은 공식 아두이노 Uno R3 보드에 대해서만 해당되며, 비공식 보드에는 항상 그렇지 않을 수 있습니다. 그러나 일부 비공식 보드는 아두이노의 완벽한 복제품이며, 보드 색상과 로고만 다를 뿐입니다.\n\n![이미지](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_4.png)\n\n이 Elegoo UNO R3 보드를 살펴보세요: 원본 아두이노 보드와 동일한 칩을 쉽게 찾을 수 있습니다. 보드 상에서 가장 큰 칩은 ATmega328P이며, TX 및 RX LED 옆 왼쪽에 있는 작은 칩은 ATmega16U2입니다. 따라서 Windows 드라이버에서 이 보드는 원본과 정확히 동일하게 보입니다. 드라이버는 동일한 ATmega16U2 칩과 통신하기 때문에 Arduino IDE에서 인식되어 정상적으로 작동할 것입니다.\n\n## CH340G 칩이 장착된 비공식 보드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 Windows에서 인식하지 않는 일부 비공식 보드도 있습니다. 따라서 장치가 종료됩니다. COM 포트가 표시되지 않으며 결과적으로 Arduino IDE에서 이러한 보드를 사용할 수 없습니다. COM 포트가 없으면 통신 방법이 없으므로 스케치를 업로드할 수 없습니다.\n\n![이미지](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_5.png)\n\n이 보드를 살펴보겠습니다. 첫눈에 차이점을 볼 수 있습니다. ATmega328P가 어디로 사라졌나요?! 걱정하지 마세요. 여기 있습니다. 이 그림에서 번호로 표시된 것입니다. 네, 훨씬 작아졌습니다. 하지만 동일한 칩이며, 다른 케이스로 포장되었습니다. 시각적으로 큰 차이가 있더라도 내부에는 여전히 동일한 ATmega328P가 있으므로 모든 스케치가 정확히 동일한 방식으로 작동할 것입니다.\n\n진짜 차이점은 번호로 표시된 칩에 있습니다. 공식 아두이노에서 ATmega16U2가 있었던 위치에, 이 보드에는 CH340G가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**CH340**은 USB-시리얼 변환기로 기능하는 전용 칩 시리즈입니다. 이 고도로 전문화된 특성으로 인해 공식 보드에 사용된 강력하고 다용도인 ATmega16U2보다 간단하고 더 저렴합니다. 그러나 이 ATmega16U2의 모든 잠재적인 성능과 가능성이 공식 보드에서는 소홀히 다뤄지므로 이 칩이 장착되어 있더라도 그 잠재력은 활용되지 않습니다. 따라서 전반적인 성능과 아두이노 보드의 기능 면에서는 USB-시리얼 어댑터로 어떤 칩이 사용되든 차이를 거의 느끼지 못할 것입니다.\n\n## CH340 드라이버\n\n하지만 CH340에는 한 가지 문제가 있습니다: Windows에는 이를 위한 내장 드라이버가 없습니다. 엄밀히 말하면 이는 CH340의 문제가 아니라 Windows의 문제이지만, 우리 사용자들에게는 모두 같은 문제입니다. 이 보드를 USB에 연결하면 Windows가 \"USB 장치 인식 안됨\"이라는 내용으로 오류를 표시하고 해당 보드에 대한 COM 포트가 생성되지 않을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제 해결은 매우 간단해요 — 그냥 올바른 드라이버를 설치하세요!\n\n- 단계 1: 드라이버를 찾아보세요. “Arduino CH340 driver”를 구글에 검색하면 많은 링크가 나올 거예요. 저에게는 구글에서 첫 번째로 나온 것이 있는데, 이 링크 외에도 다른 링크를 사용해도 됩니다. 이 드라이버는 여러 곳에서 사용 가능해요.\n- 단계 2: 파일을 임시 위치에 압축을 푼 다음 설치 프로그램을 실행하세요.\n- 단계 3: Arduino 보드를 연결하고 장치 관리자에서 새 COM 포트를 확인하세요. 아래 그림에서는 COM3인데, 여러분의 컴퓨터에선 다른 포트 번호를 사용할 수 있어요.\n\n![이미지](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_7.png)\n\n- 단계 4: Arduino IDE에서 올바른 포트를 선택하세요. 이번에는 “Arduino Uno”와 같이 레이블이 아니라 포트 번호로 표시될 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![Image](/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_8.png)\n\n## 끝\n\nCH340는 Arduino 클론뿐만 아니라 많은 다른 보드에서도 사용됩니다. 따라서 이 드라이버는 언젠가는 어쩌면 바로 필요할 지도 모릅니다.\n\n호기심을 갖고 다른 Arduino 클론을 시도해보세요 (가격이 싸요!) 그리고 즐겁게 즐기세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 자료\n\n- CH340 드라이버는 [여기](https://sparks.gogo.co.nz/ch340.html)에서 다운로드할 수 있어요. 하지만 다양한 다른 위치에서도 이용 가능하니, 구글에서 검색해보세요!","ogImage":{"url":"/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_0.png"},"coverImage":"/assets/img/2024-06-23-UsingArduinoIDEwithunofficialArduinoclonesbearingCH340chip_0.png","tag":["Tech"],"readingTime":5},{"title":"Proteus와 Arduino IDE를 사용하여 벽돌깨기 게임 만드는 방법","description":"","date":"2024-06-23 17:33","slug":"2024-06-23-CreatingaBrick-BreakingGameUsingProteusandArduinoIDE","content":"\n\n본문에서 프로테우스와 아두이노 IDE를 사용하여 벽돌 깨기 게임을 만들어 보겠습니다. 필요한 절차를 단계별로 공유할 예정이에요. 시뮬레이션에서의 게임 모습은 다음과 같을 거에요.\n\n![게임 이미지](/assets/img/2024-06-23-CreatingaBrick-BreakingGameUsingProteusandArduinoIDE_0.png)\n\n우선 내용을 간단히 설명해보려고 해요.\n\n## 시작 화면 및 메뉴 옵션:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n먼저, 사용자에게 시작 화면이 표시됩니다. 이 화면에는 \"시작\" 및 \"종료\" 옵션이 포함되어 있습니다. 사용자는 버튼을 사용하여 이 옵션들 사이를 이동하고, \"선택\" 버튼으로 선택을 집니다.\n\n## 게임 시작 및 종료 절차:\n\n사용자가 \"시작\" 옵션을 선택하면 게임 화면이 열리고 게임이 시작됩니다. \"종료\" 옵션이 선택된 경우 \"저희 게임에 관심 가져 주셔서 감사합니다\"와 같은 메시지가 화면에 표시됩니다.\n\n## 패들 조절:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n게임이 시작되면 사용자가 제어하는 패들이 포텐티오미터로 좌우로 움직입니다.\n\n**공의 움직임과 벽돌 파괴:**\n\n위에 위치한 패들에 의해 이뤄지는 공이 벽돌에 부딪혀 파괴됩니다. 동시에 공은 오른쪽, 왼쪽, 그리고 위쪽 벽에 부딪힐 때 방향을 바꿉니다.\n\n**점수 계산 절차:**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매 벽돌이 깨질 때마다 플레이어의 점수가 1점씩 올라갑니다. 이 점수는 플레이어의 성과를 추적하는 데 사용됩니다.\n\n## 체력 게이지:\n\n게임이 시작될 때 각 플레이어는 3개의 목숨을 가지고 있습니다. 공이 팔레트에서 빠져 떨어질 때마다 플레이어의 체력이 감소합니다. 목숨은 LED로 사용자에게 표시됩니다.\n\n## 특별 아이템 및 체력 증가:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매번 벽돌이 깨질 때마다 특별한 물건이 10%의 확률로 떨어집니다. 이 물건을 받은 플레이어는 체력이 1 증가합니다. 이 상태는 LED 표시기로 동시에 표시됩니다.\n\n## 배경색 변경:\n\n게임의 배경과 벽돌의 색상은 빛 센서가 감지한 빛의 양에 따라 변합니다. 빛이 켜지면 배경은 흰색이 되고 벽돌은 검은색이 됩니다.\n\n## 레벨 변화와 속도 증가:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n매 레벨을 클리어할 때마다 벽돌 배치가 변경되고, 공의 속도도 이전 라운드 대비 20% 증가합니다.\n\n## 게임 종료:\n\n모든 목숨을 소진하면, 플레이어의 점수가 화면에 출력되고 그 후에 메뉴로 이동됩니다.\n\n## 시뮬레이션에 필요한 도구들:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 아두이노 Uno\n- Oled 스크린\n- 버튼\n- LED\n- 가변 저항\n- 7 세그먼트 디스플레이\n- 광 센서\n\n프로테우스에 위의 부품들을 추가하고 필요한 곳에 사용해야 합니다.\n\n이제 프로젝트를 자세히 설명하겠습니다.\n\n## 라이브러리 및 정의:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 섹션에서는 사용할 라이브러리와 상수들이 정의되어 있습니다.\n\n화면에 사용할 벽돌, 패들, 공, 및 객체들의 크기와 값을 여기에서 지정합니다.\n\n```js\n#include \u003cWire.h\u003e\n#include \u003cAdafruit_GFX.h\u003e\n#include \u003cAdafruit_SSD1306.h\u003e     \n#include \u003cSPI.h\u003e\n\n#define SCREEN_WIDTH 128\n#define SCREEN_HEIGHT 64\n#define SCREEN_ADDRESS 0x3D\n#define OLED_RESET 1 \n\n#define BRICK_WIDTH 31\n#define BRICK_HEIGHT 10\n#define BRICK_GAP_X 1\n#define BRICK_GAP_Y 1\n#define NUM_BRICKS_X 4\n#define NUM_BRICKS_Y 2\n\n#define PADDLE_WIDTH 40 \n#define PADDLE_HEIGHT 3\n#define PADDLE_SPEED 5 \n\n#define BALL_SIZE 2\n#define BALL_SPEED_X 3 \n#define BALL_SPEED_Y 3 \n\n#define OBJECT_SIZE 7\n#define OBJECT_SPEED 2\n\nAdafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, \u0026Wire, OLED_RESET);\n\nint paddlePosition = 50;\nint paddleDirection = 0; // 패들 이동 방향을 유지합니다: -1 왼쪽, 1 오른쪽, 0 가만히\nint ballPositionX ;\nint ballPositionY;\nint ballDirectionX;\nint ballDirectionY;\n\n// 7 세그먼트 디스플레이 핀 연결\nconst int segmentPins[] = {2,3,4,5,6,7,8,9};\n\n// 버튼 핀 연결\nconst int upButton = 10;\nconst int downButton = 11;\nconst int selectButton = 12;\n\nint counter = 0;\nint score = 0;\nint menu = 1;\nint currentLevel = 1;\n\nint ballSpeedX = BALL_SPEED_X;\nint ballSpeedY = BALL_SPEED_Y;\n\n// 각 벽돌의 상태를 추적하는 2D 배열 정의\nbool bricks[NUM_BRICKS_Y][NUM_BRICKS_X];\n\n// 각 레벨별 벽돌 레이아웃 정의\nconst int levelBricksLayouts[][NUM_BRICKS_Y][NUM_BRICKS_X] = {\n  // 레벨 1\n  {\n    {1,1,1,1},\n    {1,1,1,1}\n  },\n  // 레벨 2\n  {\n    {1,0,1,0},\n    {0,1,0,1}\n  },\n  // 레벨 3\n  {\n    {1,1,0,1},\n    {0,1,1,0}\n  },\n  // 레벨 4\n  {\n    {1,0,0,1},\n    {0,1,1,0}\n  },\n  // 레벨 5\n  {\n    {1,0,1,0},\n    {0,1,0,1}\n  }\n};\n\nint lives = 3; \nconst int lifeLEDs[] = {13,A2,A3}; \n\nbool objectActive = false;\nint objectX, objectY;\n\nuint16_t backgroundColor, brickColor, paddleColor, ballColor, objectColor;\r\n```\n\n## 설정 함수:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n설정 함수는 초기 설정을 수행합니다. 화면 초기화, 입력/출력 핀 설정, 메뉴 표시 등의 작업이 여기서 수행됩니다.\n\n```js\nvoid setup() {\n  display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS);\n  \n  display.clearDisplay();\n  display.display();\n  display.setTextColor(SSD1306_WHITE, SSD1306_BLACK);\n\n  // 포텐셔미터 핀을 입력으로 설정\n  pinMode(A0, INPUT);\n\n  for(int i = 0; i\u003c8; i++) {\n    pinMode(segmentPins[i], OUTPUT);\n  }\n\n  // 버튼 핀을 입력으로 설정\n  pinMode(upButton, INPUT);\n  pinMode(downButton, INPUT);\n  pinMode(selectButton, INPUT);\n\n  digitalWrite(upButton, HIGH);\n  digitalWrite(downButton, HIGH);\n  digitalWrite(selectButton, HIGH);\n  delay(1000);\n  updateMenu();\n\n  // 초기에 모든 벽을 솔리드로 설정\n  for (int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n    for (int j = 0; j \u003c NUM_BRICKS_X; j++) {\n      bricks[i][j] = true;\n    }\n  }\n\n  for(int i = 0; i\u003c3; i++) {\n    pinMode(lifeLEDs[i], OUTPUT);\n  }\n\n  // 광센서의 핀을 입력으로 설정\n  pinMode(A1, INPUT);\n}\n```\n\n## 루프 함수:\n\n이 함수는 버튼 상태를 확인하고 필요한 기능을 제공합니다. 각 사이클마다 7세그먼트 디스플레이에 카운터의 값을 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n## 숫자 표시 함수:\n\n이 함수는 7세그먼트 디스플레이에 특정 숫자를 표시하는 데 사용됩니다. 이 숫자는 0에서 9 사이여야 합니다.\n\n```js\nvoid displayNumber(int num) {\n  const int numbers[][8] = {\n    {1,1,1,1,1,1,0,0}, //0\n    {0,1,1,0,0,0,0,0}, //1\n    {1,1,0,1,1,0,1,0}, //2\n    {1,1,1,1,0,0,1,0}, //3\n    {0,1,1,0,0,1,1,0}, //4\n    {1,0,1,1,0,1,1,0}, //5\n    {1,0,1,1,1,1,1,0}, //6\n    {1,1,1,0,0,0,0,0}, //7\n    {1,1,1,1,1,1,1,0}, //8\n    {1,1,1,1,0,1,1,0}  //9\n  };\n\n  for(int i = 0; i\u003c8; i++) {\n    digitalWrite(segmentPins[i], numbers[num][i]);\n  } \n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 메뉴 업데이트 기능:\n\n이 함수는 메뉴를 업데이트하는 데 사용됩니다. 사용자가 선택한 메뉴를 강조합니다.\n\n```js\nvoid updateMenu() {\n  switch(menu) {\n    case 0:\n      menu = 1;\n      break;\n    case 1:\n      display.clearDisplay();\n      display.setCursor(0,0);\n      display.println(\"\u003e 시작\");\n      display.setCursor(0,10);\n      display.println(\"  종료\");\n      display.display();\n      break;\n    case 2:\n      display.clearDisplay();\n      display.setCursor(0,0);\n      display.println(\"  시작\");\n      display.setCursor(0,10);\n      display.println(\"\u003e 종료\");\n      display.display();\n      break;\n    case 3:\n      menu = 2;\n      break;\n  }\n}\n```\n\n## 동작 실행 함수:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사용자가 선택한 작업을 수행하는 함수입니다. 시작 및 종료 옵션에 따라 서로 다른 작업을 수행합니다.\n\n```js\nvoid executeAction() {\n  switch(menu) {\n    case 1:\n      action1();\n      break;\n    case 2:\n      action2();\n      break;\n    default:\n      break;\n  }\n}\n\n// 시작 작업\nvoid action1() {\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  playGame();\n  display.display();\n  delay(1500);\n}\n\n// 종료 작업\nvoid action2() {\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.print(\"Thank you for your interest in our game....\");\n  display.display();\n  delay(1500);\n}\n```\n\n## 벽돌 그리기 함수:\n\n게임 화면에 벽돌을 그리는 함수입니다. 특정 색상의 벽돌을 그립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvoid drawBricks(uint16_t color) {\n  for(int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n    for(int j = 0; j \u003c NUM_BRICKS_X; j++) {\n      int brickX = j * (BRICK_WIDTH + BRICK_GAP_X);\n      int brickY = i * (BRICK_HEIGHT + BRICK_GAP_Y);\n      if (bricks[i][j]) { // Only draw solid bricks\n        display.fillRect(brickX + 1, brickY + 1, BRICK_WIDTH - 1, BRICK_HEIGHT - 1, color);\n      }\n    }\n  }\n}\n```\n\n## 패들 그리기, 삭제 및 업데이트 기능:\n\n```js\n// 화면에 패들을 그리는 함수\nvoid drawPaddle(uint16_t color) {\n  display.fillRect(paddlePosition, display.height() - PADDLE_HEIGHT - 2, PADDLE_WIDTH, PADDLE_HEIGHT, color);\n}\n\n// 이전 패들 위치를 지우는 함수\nvoid clearPaddle() {\n  display.fillRect(paddlePosition, display.height() - PADDLE_HEIGHT - 2, PADDLE_WIDTH, PADDLE_HEIGHT, SSD1306_BLACK);\n}\n\n// 패들의 위치를 포텐셔미터에서 받은 데이터에 따라 업데이트하는 함수\nvoid updatePaddle() {\n  int potValue = analogRead(A0);\n\n  paddlePosition = map(potValue, 0, 1023, 0, display.width() - PADDLE_WIDTH);\n}\n```\n\n## 공 그리기, 삭제 및 업데이트 기능:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 화면에 공을 그리는 함수\nvoid drawBall(uint16_t color) {\n  display.fillCircle(ballPositionX, ballPositionY, BALL_SIZE, color);\n}\n\n// 이전 공 위치를 지우는 함수\nvoid clearBall() {\n  display.fillCircle(ballPositionX - ballDirectionX * BALL_SPEED_X, ballPositionY - ballDirectionY * BALL_SPEED_Y, BALL_SIZE, SSD1306_BLACK);\n}\n\n// 공의 위치와 움직임을 업데이트하는 함수\nvoid updateBall() {\n  ballPositionX += ballDirectionX * ballSpeedX;\n  ballPositionY += ballDirectionY * ballSpeedY;\n\n  // 왼쪽 가장자리 충돌 확인 및 방향 전환\n  if(ballPositionX \u003c= 0) {\n    ballDirectionX *= -1;\n  } \n  // 오른쪽 가장자리 충돌 확인 및 방향 전환\n  else if(ballPositionX \u003e= display.width() - BALL_SIZE) {\n    ballDirectionX *= -1;\n  }\n\n  // 위쪽 가장자리 충돌 확인\n  if(ballPositionY \u003c= 0) {\n    ballDirectionY *= -1;\n  } \n\n  checkPaddleCollision();\n\n  // 아래쪽 가장자리 충돌 확인\n  if(ballPositionY \u003e= display.height()) {\n    loseLife();\n  }\n}\r\n```\n\n## 생명과 생명을 잃은 상태를 보여주는 함수:\n\n```js\r\n// 사용자의 생명을 표시하는 함수\nvoid displayLives() {\n  for (int i = 0; i \u003c 3; i++) {\n    digitalWrite(lifeLEDs[i], i \u003c lives ? HIGH : LOW); // 건강 상태에 따라 LED 켜기/끄기\n  }\n}\n\n// 사용자의 생명을 잃는 상황을 처리하는 함수\nvoid loseLife() {\n  lives--;\n  for (int i = 0; i \u003c 3; i++) {\n    digitalWrite(lifeLEDs[i], i \u003c lives ? HIGH : LOW); // 건강 상태에 따라 LED 켜기/끄기\n  }\n\n  // 사용자가 건강 상태가 낮을 때 공을 트랙 위에 시작하도록 함\n  delay(100);\n  ballPositionX = paddlePosition + PADDLE_WIDTH / 2;\n  ballPositionY = display.height() - PADDLE_HEIGHT - BALL_SIZE - 3;\n  ballDirectionX = 0;\n  ballDirectionY = 0;\n  displayLives();\n  objectActive = false;\n  display.fillRect(objectX, objectY, OBJECT_SIZE, OBJECT_SIZE, SSD1306_BLACK);\n  delay(100); \n}\r\n```\n\n## 패들과 공의 충돌 함수: \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n볼이 패들에 닿았는지 확인하는 함수입니다.\n\n```js\nvoid checkPaddleCollision() {\n    // 패들과 볼의 충돌 확인\n    if (ballPositionY + BALL_SIZE \u003e= display.height() - PADDLE_HEIGHT - BALL_SPEED_Y \u0026\u0026 ballPositionX + BALL_SIZE \u003e= paddlePosition \u0026\u0026 ballPositionX \u003c= paddlePosition + PADDLE_WIDTH) {\n        // 패들의 왼쪽 부분\n        if (ballPositionX \u003c= paddlePosition + PADDLE_WIDTH / 3) {\n            ballDirectionX = -1; // 왼쪽으로 볼 진행\n            ballDirectionY = -1; // 볼의 방향을 위쪽으로 전환\n        }\n        // 패들의 중간 부분\n        else if (ballPositionX \u003c= paddlePosition + 2 * PADDLE_WIDTH / 3) {\n            ballDirectionX = 0; // 볼의 방향을 바꾸지 않음\n            ballDirectionY = 0;\n        }\n        // 패들의 오른쪽 부분\n        else {\n            ballDirectionX = 1; // 오른쪽으로 볼 진행\n            ballDirectionY = -1; // 볼의 방향을 위쪽으로 전환\n        }  \n    }\n}\n```\n\n## 볼이 패들과 충돌하는지 확인하는 함수:\n\n볼이 패들과 충돌하는지 확인하고 true 또는 false를 반환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbool ballHitsPaddle() {\n  // 패들과 공의 충돌 제어\n  if (ballPositionY + BALL_SIZE \u003e= display.height() - PADDLE_HEIGHT - BALL_SPEED_Y \u0026\u0026 ballPositionX + BALL_SIZE \u003e= paddlePosition \u0026\u0026 ballPositionX \u003c= paddlePosition + PADDLE_WIDTH) {\n    return true;\n  } else {\n    return false;\n  }\n}\n```\n\n## 객체 그리기, 업데이트 함수:\n\n```js\n// 화면에 특별한 객체를 그리는 함수\nvoid drawObject(uint16_t color) {\n  display.fillRect(objectX, objectY, OBJECT_SIZE, OBJECT_SIZE, color);\n}\n\n// 특별한 객체의 위치를 업데이트하는 함수\nvoid updateObject() {\n  // 객체가 활성화되어 있고 화면 아래로 떨어지는 방향으로 이동하지 않으면 이동\n  if (objectActive \u0026\u0026 objectY \u003c display.height() - OBJECT_SIZE) {\n    // 객체 지우기\n    display.fillRect(objectX, objectY, OBJECT_SIZE, OBJECT_SIZE, SSD1306_BLACK);\n    // 새로운 위치 업데이트\n    objectY += OBJECT_SPEED;\n\n    // 플레이어가 객체를 잡았을 경우\n    if (objectY \u003e= display.height() - PADDLE_HEIGHT - OBJECT_SIZE \u0026\u0026 objectX \u003e= paddlePosition \u0026\u0026 objectX \u003c= paddlePosition + PADDLE_WIDTH) {\n      objectActive = false;\n      lives++; // 생명 카운트 증가\n\n      // LED로 생명 수 표시\n      for (int i = 0; i \u003c 3; i++) {\n        digitalWrite(lifeLEDs[i], i \u003c lives ? HIGH : LOW);\n      }\n      display.fillRect(objectX, objectY, OBJECT_SIZE, OBJECT_SIZE, SSD1306_BLACK);\n    }\n\n    // 객체가 화면 하단 가장자리에 도착했을 경우\n    if (objectY \u003e= display.height() - OBJECT_SIZE) {\n      display.fillRect(objectX, objectY, OBJECT_SIZE, OBJECT_SIZE, SSD1306_BLACK);\n    }\n    drawObject(objectColor);\n  }\n}\n```\n\n## 벽돌 충돌 확인:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n볼이 벽돌에 충돌하는지 확인합니다.\n\n```js\nvoid checkBrickCollision() {\n  for(int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n    for(int j = 0; j \u003c NUM_BRICKS_X; j++) {\n      if (bricks[i][j]) { // Check to only crash into solid bricks\n        int brickX = j * (BRICK_WIDTH + BRICK_GAP_X);\n        int brickY = i * (BRICK_HEIGHT + BRICK_GAP_Y);\n\n        if (ballPositionX + BALL_SIZE \u003e= brickX \u0026\u0026 ballPositionX \u003c= brickX + BRICK_WIDTH \u0026\u0026 ballPositionY + BALL_SIZE \u003e= brickY \u0026\u0026 ballPositionY \u003c= brickY + BRICK_HEIGHT) {\n          ballDirectionY *= -1; \n          bricks[i][j] = false; // Mark the brick as broken\n          incrementCounter(); // Increase score\n          display.fillRect(brickX + 1, brickY + 1, BRICK_WIDTH - 1, BRICK_HEIGHT - 1, SSD1306_BLACK);\n        \n          // Creating an object every time a brick is broken\n          if(random(100) \u003c 10) { // 10 percent probability of creating an object\n            objectActive = true;\n            objectX = brickX + (BRICK_WIDTH - OBJECT_SIZE) / 2;\n            objectY = brickY + (BRICK_HEIGHT - OBJECT_SIZE) / 2;;\n            drawObject(objectColor);\n          }\n        \n        }\n      }\n    }\n  }\n}\n```\n\n## 다음 레벨 전환 함수:\n\n레벨의 모든 벽돌이 깨졌을 때 다음 레벨로 이동을 허용하는 함수입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvoid nextLevel() {\n  if(currentLevel \u003c 5) {\n    currentLevel++;  \n    // Increase your ball speed by 20% for the next level\n    ballSpeedX += ballSpeedX * 0.2;\n    ballSpeedY += ballSpeedY * 0.2;\n\n    // Reset ball position and direction\n    ballPositionX = paddlePosition + PADDLE_WIDTH / 2;\n    ballPositionY = display.height() - PADDLE_HEIGHT - BALL_SIZE - 3;\n    ballDirectionX = 0;\n    ballDirectionY = 0;\n\n    // Reset bricks\n    for(int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n      for(int j = 0; j \u003c NUM_BRICKS_X; j++) {\n        bricks[i][j] = true;\n      }\n    }\n\n    // Clear screen and reset lives\n    display.clearDisplay();\n    display.setCursor(0, 0);\n    display.print(\"Level \");\n    display.print(currentLevel);\n    display.display();\n    delay(20);\n    playGame();\n  }\n}\n```\n\n## 게임 시작 기능:\n\n게임이 시작될 때와 진행 중인 게임에서 필요한 작업을 제공하는 함수입니다.\n\n```js\nvoid playGame() {\n  // Adjust brick layout depending on level\n  int currentLevelLayout[NUM_BRICKS_Y][NUM_BRICKS_X];\n  for (int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n    for (int j = 0; j \u003c NUM_BRICKS_X; j++) {\n      currentLevelLayout[i][j] = levelBricksLayouts[currentLevel - 1][i][j];\n    }\n  }\n\n  // Reset brick array\n  for (int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n    for (int j = 0; j \u003c NUM_BRICKS_X; j++) {\n      bricks[i][j] = currentLevelLayout[i][j];\n    }\n  }\n\n  ballPositionX = paddlePosition + PADDLE_WIDTH / 2 - 6; \n  ballPositionY = display.height() - PADDLE_HEIGHT - BALL_SIZE - 3;\n  ballDirectionX = 0;\n  ballDirectionY = 0;\n\n  while (lives \u003e 0) {\n    int lightSensorValue = analogRead(A1);\n    if (lightSensorValue \u003c 15) {\n      backgroundColor = SSD1306_BLACK;\n      brickColor = SSD1306_WHITE;\n      paddleColor = SSD1306_WHITE;\n      ballColor = SSD1306_WHITE;\n      objectColor = SSD1306_WHITE;\n    } else { \n      backgroundColor = SSD1306_WHITE;\n      brickColor = SSD1306_BLACK;\n      paddleColor = SSD1306_BLACK;\n      ballColor = SSD1306_BLACK;\n      objectColor = SSD1306_BLACK;\n    }\n  \n    display.fillScreen(backgroundColor);\n\n    clearPaddle();\n    updatePaddle();\n    updateBall();\n    clearBall();\n    drawBricks(brickColor);\n    drawPaddle(paddleColor);\n    drawBall(ballColor);\n    checkBrickCollision();\n    updateObject(); \n    displayNumber(counter);\n    displayLives();\n    display.display();\n    \n    // Reads the potentiometer value and controls the movement of the paddle\n    int potValue = analogRead(A0);\n    int newPaddlePosition = map(potValue, 0, 1023, 0, display.width() - PADDLE_WIDTH);\n    \n    // If you move the paddle the ball starts to move\n    if (newPaddlePosition != paddlePosition \u0026\u0026 ballHitsPaddle()) {\n      // Determine the direction of movement of the paddle\n      if (paddlePosition \u003e 50) {\n        ballDirectionX = -1; // Move right\n      } else if (paddlePosition \u003c 50) {\n        ballDirectionX = 1; // Move left\n      } else {\n        ballDirectionX = 1; // Move left\n      }\n      ballDirectionY = -1; // Make the ball go up\n    }\n    clearPaddle();\n    // Update the position of the palette\n    paddlePosition = newPaddlePosition;\n\n    // Check if all bricks are broken\n    bool allBricksDestroyed = true;\n      for (int i = 0; i \u003c NUM_BRICKS_Y; i++) {\n        for (int j = 0; j \u003c NUM_BRICKS_X; j++) {\n          if (bricks[i][j]) {\n            allBricksDestroyed = false;\n            break;\n          }\n        }\n        if (!allBricksDestroyed) {\n          break;\n        }\n      }\n\n      // If all the bricks are broken go to the next level\n      if (allBricksDestroyed) {\n        display.clearDisplay();\n        display.display();\n        delay(5000);\n        nextLevel();\n        break;\n      }\n  }\n\n  if(lives == 0) {\n    // End game\n    gameOver();\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 게임 종료 함수:\n\n게임이 종료될 때 호출되는 함수입니다.\n\n```js\nvoid gameOver() {\n  display.clearDisplay();\n  display.setCursor(0, 0);\n  display.println(\"Game Over!\");\n  display.print(\"Score: \");\n  display.print(score);\n  display.display();\n  delay(3000); // 3초 대기\n  // 메인 메뉴로 돌아가기\n  menu = 1;\n  updateMenu();\n  lives = 3;\n}\n```\n\n프로젝트의 모든 코드를 포함한 소스 코드:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n절차 상 표를 마크다운 형식으로 변경하였습니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에 아래 사항을 고려해 주세요:\n\n- 저자를 박수로 응원하고 팔로우하기를 고려해 주세요! 👏\n- 저희를 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- Stackademic.com에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-23-CreatingaBrick-BreakingGameUsingProteusandArduinoIDE_0.png"},"coverImage":"/assets/img/2024-06-23-CreatingaBrick-BreakingGameUsingProteusandArduinoIDE_0.png","tag":["Tech"],"readingTime":17},{"title":"저항 밴드 색상 읽는 방법 쉽게 배우기","description":"","date":"2024-06-23 17:32","slug":"2024-06-23-HowToReadResistorBandColors","content":"\n\n\n![Resistor](/assets/img/2024-06-23-HowToReadResistorBandColors_0.png)\n\n저항은 회로 내의 전기 흐름을 제어하는 데 사용되는 필수 전자 부품입니다. 저항은 옴(Ω)으로 측정되는 저항으로 특징 지어집니다.\n\n![Resistor Color Bands](/assets/img/2024-06-23-HowToReadResistorBandColors_1.png)\n\n저항기의 저항은 저항기 본체의 색 조각을 읽어서 식별할 수 있습니다. 이 기사에서는 4, 5, 6 밴드 저항에 대한 저항기 밴드 색상 읽는 방법에 대해 설명하겠습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1096/0*He1_5wkKjnFY2Qm5.gif)\n\n비록 이것은 유용한 기술이지만, 매번 이러한 차트를 참조하는 것이 귀찮았습니다. 그래서 나는 무료 iOS 앱을 만들어 이러한 계산을 관리하기로 했어요:\n\n# 4 밴드 저항기 색상 코드\n\n4밴드 저항기에서 첫 두 밴드는 저항 값의 첫 번째와 두 번째 숫자를 나타냅니다. 세 번째 밴드는 배율을 나타내고, 네 번째 밴드는 허용 편차를 나타냅니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4밴드 저항기 색 코드를 읽을 때 따라야 할 단계를 알려드리겠어요:\n\n- 첫 번째 두 밴드의 색과 해당 값을 확인하세요. 저항기 색 코드 차트를 사용해주세요 (위를 참조하세요).\n- 세 번째 밴드의 색을 사용하여 곱수를 결정하세요. 이는 첫 두 자리 수 뒤에 따라오는 0의 개수를 나타냅니다.\n- 다음 공식을 사용하여 저항 값을 계산하세요:\n\n## 저항 (Ω) = (1번째 숫자 값 x 10 + 2번째 숫자 값) x 곱수\n\n그다음으로, 네 번째 밴드의 색을 식별하여 허용 편차를 결정하세요. 허용 편차는 지정된 저항 값에서 허용되는 저항기의 편차를 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5-Band 저항기 색상 코드\n\n5-Band 저항기의 처음 세 개의 밴드는 저항값의 첫 번째, 두 번째 및 세 번째 자리수를 나타냅니다. 네 번째 밴드는 배수기를 나타내며, 다섯 번째 밴드는 허용 편차를 나타냅니다.\n\n다음은 5-Band 저항기 색상 코드를 읽을 때 따라야 할 단계입니다:\n\n- 저항기 색상 코드 차트를 사용하여 처음 세 개의 밴드의 색상과 해당 값을 식별합니다.\n- 네 번째 밴드의 색상을 사용하여 배수기를 결정하십시오. 이는 첫 세 자리 숫자 뒤에 따라오는 0의 개수를 나타냅니다.\n- 다음 공식을 사용하여 저항값을 계산합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 저항 (Ω) = (첫 번째 숫자 값 x 100 + 두 번째 숫자 값 x 10 + 세 번째 숫자 값) x 배율\n\n마지막으로 다섯 번째 밴드의 색으로 공차를 결정합니다.\n\n# 6 밴드 저항기 색코드\n\n6 밴드 저항기의 첫 세 밴드는 저항값의 첫 번째, 두 번째, 세 번째 숫자를 나타냅니다. 네 번째 밴드는 배율을, 다섯 번째 밴드는 공차를, 여섯 번째 밴드는 온도 계수를 나타냅니다. 6밴드 저항기 색코드를 읽을 때 따라야 할 단계는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 저항기 밴드 색상 차트를 사용하여 첫 번째 세 밴드의 색상과 해당 값 식별\n- 네 번째 밴드 색상을 사용하여 0을 뒤따르는 숫자를 나타내는 곱산자 결정\n- 다음 공식을 사용하여 저항값 계산:\n\n## 저항 (Ω) = (1번째 숫자 값 x 100 + 2번째 숫자 값 x 10 + 3번째 숫자 값) x 곱산자\n\n이후, 5번째 밴드의 색상을 식별하여 허용 편차를 결정합니다. 마지막으로, 6번째 밴드의 색상을 식별하여 온도 계수를 결정합니다. 온도 계수는 온도가 변할 때 저항기의 저항 변화를 나타냅니다.\n\n저항기 밴드 색상을 읽는 것은 혼란스러울 수 있지만, 올바른 도구와 지식이 있다면 간단한 작업이 됩니다. 4, 5 또는 6 밴드 저항기를 사용하든, 저항값, 곱산자, 허용 편차 및 온도 계수를 정확히 결정하기 위해 저항기 색상코드 차트를 사용하는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에 제시된 단계를 따라가면 저합리로 저항을 다루고 회로가 의도대로 작동하는지 확인할 수 있어요. 귀찮다면, 저처럼 온라인/모바일 계산기 중 하나를 자유롭게 사용하세요.\n\n일반적으로 iOS 개발에 대해 쓰지만, 최근에 부수적으로 전기 공학 프로젝트를 탐색하고 있어요.\n\n전통적인 프로그래밍보다 더 즐겁다고 느끼고 있어요.\n\n소프트웨어가 작동하는 만족감을 경험할 뿐만 아니라, 하드웨어가 올바르게 작동하는 것을 볼 수 있는 추가적인 혜택도 얻을 수 있어요. 두 가지가 매끄럽게 동작할 때, 이 느낌은 전혀 다른 만족감을 줘요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n누가 알겠어요, 아마 나의 미래에는 직업 전환이 있을지도 몰라요...\n\n저항체 밴드 색상을 읽는 것은 전자제품을 다루는 사람에게 필수적인 기술이에요. 이 글에서는 저항체 색상 밴드를 사용하는 방법에 대해 간단히 소개할 거예요. 초보자이든 경험 많은 엔지니어이든, 저항체 밴드 코드를 이해하는 것은 정확하고 효율적인 회로를 구축하는 데 중요해요.","ogImage":{"url":"/assets/img/2024-06-23-HowToReadResistorBandColors_0.png"},"coverImage":"/assets/img/2024-06-23-HowToReadResistorBandColors_0.png","tag":["Tech"],"readingTime":3},{"title":"FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법","description":"","date":"2024-06-23 17:31","slug":"2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup","content":"\n\n\n![Image](/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png)\n\n웹 소프트웨어 엔지니어인 저와 같은 경우에는 실시간 프로그래밍 개념을 이해하기 어려울 수 있습니다. \n이 짧은 기사에서는 여러 멀티스레딩 작업의 완료를 기다리기 위한 세마포어 패턴을 구현하는 쉬운 기술을 소개하겠습니다.\n\n# 정의\n\n- FreeRTOS 작업\nFreeRTOS 작업은 FreeRTOS 실시간 운영 체제 내에서 실행되는 작고 독립적인 프로그램 세그먼트입니다. 각 작업은 특정 작업을 수행하도록 설계되었으며 FreeRTOS 스케줄러에 의해 관리되는 다른 작업과 준동시에 작동합니다. FreeRTOS의 작업은 우선 순위를 부여할 수 있어, 스케줄러가 작업 우선 순위에 따라 실행 흐름을 관리하고 시간에 민감한 작업을 효과적으로 처리할 수 있게 합니다. 이를 통해 응용 프로그램은 여러 작업 간에 작업을 나누어 다루므로 다양한 응용 프로그램 요구 사항을 처리할 수 있습니다.\n\n- 카운팅 세마포어\nFreeRTOS의 카운팅 세마포어는 공유 리소스에 대한 액세스를 관리하거나 가용성에 따라 작업을 동기화하는 동기화 메커니즘입니다. 두 가지 상태만을 갖는 이진 세마포어와 달리 카운팅 세마포어는 가용 리소스의 개수나 이벤트가 발생하기 전에 실행 흐름을 차단/해제하는 횟수를 나타내는 값을 유지합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# TL;DR — The code\n\n데모 코드는 \"xTaskCreate\"를 사용하여 세 가지 작업을 실행하며 \"xEventGroupCreate\"로 생성된 이벤트 그룹을 사용하여 카운팅 세마포어를 구현합니다. 메인 작업은 생성된 모든 작업이 실행된 후에만 종료되도록 기다립니다.\n\n```js\n#include \u003cArduino.h\u003e\n\n// 카운팅 세마포어를 구현하는 그룹 핸들\nstatic EventGroupHandle_t eventGroup;\n\n// 각 작업에 대한 비트 마스크 정의\nconst EventBits_t TASK_1_BIT = (1 \u003c\u003c 0); // 00000001\nconst EventBits_t TASK_2_BIT = (1 \u003c\u003c 1); // 00000010\nconst EventBits_t TASK_3_BIT = (1 \u003c\u003c 2); // 00000100\n\nvoid taskFunction(void *pvParameters) {\n    int taskNumber = ((int)pvParameters);\n    // 작업 번호를 기반으로 설정할 비트 계산\n    EventBits_t taskBit = (1 \u003c\u003c (taskNumber - 1));\n\n    for(int i = 0; i \u003c 5; i++) {\n        Serial.printf(\"Task %d is executing...\\n\", taskNumber);\n        vTaskDelay(pdMS_TO_TICKS(1000)); // 작업 활동 시뮬레이션\n    }\n\n    // 이 작업을 위해 이벤트 그룹에 적합한 비트 설정\n    Serial.printf(\"Task %d completed and bit set.\\n\", taskNumber);\n    xEventGroupSetBits(eventGroup, taskBit);\n    // 완료되면 이 작업 삭제\n    vTaskDelete(NULL);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    while (!Serial);\n\n     // 이벤트 그룹 생성\n    eventGroup = xEventGroupCreate();\n    if (eventGroup == NULL) {\n        Serial.println(\"이벤트 그룹 생성 실패. 힙 부족일 수 있습니다.\");\n        return;\n    }\n\n    // 작업에 전달할 매개변수, 작업 번호를 나타냄\n    static int taskParams[3] = {1, 2, 3};\n    for (int i = 0; i \u003c 3; i++) {\n        xTaskCreate(\n            taskFunction,            // 작업 함수\n            \"Task\",                  // 작업 이름\n            2048,                    // 스택 크기\n            \u0026taskParams[i],          // 매개변수 (작업 번호)\n            1,                       // 우선순위\n            NULL                     // 사용하지 않는 작업 핸들\n        );\n    }\n\n    // 모든 작업이 비트를 설정할 때까지 기다림\n    Serial.println(\"작업 완료 대기 중...\");\n    xEventGroupWaitBits(\n        eventGroup,                          // 테스트할 이벤트 그룹.\n        TASK_1_BIT | TASK_2_BIT | TASK_3_BIT, // 기다릴 이벤트 그룹 내 비트.\n        pdTRUE,                              // 종료 시 비트 지우기.\n        pdTRUE,                              // 모든 비트를 기다림.\n        portMAX_DELAY                        // 무기한 대기.\n    );\n\n    Serial.println(\"모든 작업 완료됨.\");\n    // 이벤트 그룹 정리\n    vEventGroupDelete(eventGroup);\n}\n\nvoid loop() {}\n```\n\n# 자세한 설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이벤트 그룹 핸들이 선언되었습니다.\n\n```js\n// 카운팅 세마포어를 구현하는 그룹 핸들\nstatic EventGroupHandle_t eventGroup;\n```\n\n- 각 작업은 숫자 ID에 연결되며, 이는 비트 시퀀스의 인덱스를 나타냅니다. 작업이 완료되었는지 확인하는 데 세 개의 비트 마스크가 사용됩니다.\n\n```js\n// 각 작업을 위한 비트 마스크 정의\nconst EventBits_t TASK_1_BIT = (1 \u003c\u003c 0); // 00000001\nconst EventBits_t TASK_2_BIT = (1 \u003c\u003c 1); // 00000010\nconst EventBits_t TASK_3_BIT = (1 \u003c\u003c 2); // 00000100\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 주요 작업은 작업 번호를 매개변수로 전달하여 세 가지 작업을 생성합니다.\n\n```js\n// 작업에 전달할 매개변수, 작업 번호를 나타냄\nstatic int taskParams[3] = {1, 2, 3};\nfor (int i = 0; i \u003c 3; i++) {\n    xTaskCreate(\n        taskFunction,            // 작업 함수\n        \"Task\",                  // 작업 이름\n        2048,                    // 스택 크기\n        \u0026taskParams[i],          // 매개변수 (작업 번호)\n        1,                       // 우선 순위\n        NULL                     // 작업 핸들은 사용하지 않음\n    );\n}\n```\n\n- 작업 번호는 \"EventBits_t\" 변수를 생성하는 데 사용되며 해당하는 양 만큼 비트를 왼쪽으로 이동시킵니다.\n\n```js\nint taskNumber = ((int)pvParameters);\n// 작업 번호를 기반으로 설정할 비트를 계산\nEventBits_t taskBit = (1 \u003c\u003c (taskNumber - 1));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작업이 완료되면 그룹에 신호를 보내고 자체를 삭제합니다.\n\n```js\n// 이벤트 그룹에서이 작업에 대한 적절한 비트 설정\nSerial.printf(\"작업 %d가 완료되었고 비트가 설정되었습니다.\\n\", taskNumber);\nxEventGroupSetBits(eventGroup, taskBit);\n// 완료되면이 작업 삭제\nvTaskDelete(NULL);\n```\n\n- 주 작업은 비트 마스크를 사용하여 그룹 내 세 개의 비트가 1로 설정될 때까지 기다리고 즉시 실행을 다시 시작합니다.\n\n```js\n// 모든 작업이 비트를 설정 할 때까지 대기\nSerial.println(\"작업이 완료 될 때까지 대기 중 ...\");\nxEventGroupWaitBits(\n    eventGroup,                          // 테스트되는 이벤트 그룹.\n    TASK_1_BIT | TASK_2_BIT | TASK_3_BIT, // 대기해야 하는 이벤트 그룹 내의 비트.\n    pdTRUE,                              // 종료시 비트 지우기.\n    pdTRUE,                              // 모든 비트를 대기합니다.\n    portMAX_DELAY                        // 무기한 대기.\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 마침내 이벤트 그룹이 삭제되었습니다.\n\n```js\nSerial.println(\"모든 작업이 완료되었습니다.\");\n// 이벤트 그룹 정리\nvEventGroupDelete(eventGroup);\n```\n\n# 결론\n\n이 유용한 기술은 FreeRTOS 기능만을 사용하여 동기화를 강제하는 간단한 방법입니다. 따라서 무분별한 코드 부하를 피할 수 있습니다. 여러분의 프로젝트에 유용하게 활용하시기를 바랍니다. 읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png"},"coverImage":"/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png","tag":["Tech"],"readingTime":5},{"title":"필라멘트 압출기 제작 파트 2 단계별 가이드","description":"","date":"2024-06-23 17:30","slug":"2024-06-23-Part2BuildingFilamentExtruder","content":"\n\n첫 번째 게시물에서는 집에서 필라멘트를 만드는 것의 타당성에 대해 논의했어요. 필라멘트를 만들어 돈을 절약하는 것도 중요하지만, 지역 플라스틱 재활용 업체들이 플라스틱 잔재를 분쇄, 세척하여 펠릿으로 변환하는 데 도움을 줄 수 있으면 좋겠죠. 주로 기능적인 부품과 신속한 프로토타입을 출력하는데, 우리가 출력하는 물건 중 80%는 쓰레기통으로 이어지죠. 이를 지역적으로 다시 필라멘트로 재활용하여 30-40%의 순수 펠릿과 혼합한다면 환경에 도움이 될 수 있을 거에요.\n\n필라멘트 압출 선에는 4부분이 있어요:\n\n- 압출기\n- 수조\n- 폴러\n- 꼬임기\n\n그래서, 앞으로의 게시물에서 한 번에 하나씩 만들어 보겠습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 외출더\n\n외출더를 만들기 위해 필요한 주요 구성품은 다음과 같습니다:\n\n- 스크류, 배럴, 그리고 노즐\n- 모터, 기어박스 그리고 AC 드라이브\n- 밴드 히터, 열전대, 온도 조절기\n\n# 스크류, 배럴, 그리고 노즐\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-Part2BuildingFilamentExtruder_0.png\" /\u003e\n\n저는 기계공이 아니어서 이걸 공급업체에서 사야 했어요. 현지 공급업체들이 나에게 스크류/배럴 세트에 $1000-$1500과 같이 엄청난 가격을 제시하더라구요.\n\n25mm 스크류 직경과 400-500 길이, 그리고 배럴이 필요합니다. 이 부분이 이 기계에서 가장 비싼 부품이에요.\n\n이 웹사이트에서 구매할 수 있어요. 저는 여기서 좋은 품질의 스크류/배럴을 구입했어요. 노즐도 같은 웹사이트에서 샀어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n배럴에 홀이 있는 것에 유의해주세요. 거기에 PETG로 만든 3D 프린팅 허퍼를 설치할 예정입니다.\n\n비용: $350–$400 (새 제품)\n\n## 모터 사이징\n\n![이미지](/assets/img/2024-06-23-Part2BuildingFilamentExtruder_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nABS 5kg 당 1HP 모터입니다. 5kg/시간의 라인부터 시작하는 것을 제안합니다.\n\n3상 4극 교류 인덕션 모터입니다.\n\n이 모터를 어떻게 구할 수 있을까요? 60Hz에서 4극 모터는 1800rpm이 평가됩니다. 따라서, 폐창고에서 찾았다면 모터에 붙은 라벨을 읽을 수 있습니다. 아니면 eBay에서 찾거나 중고 모터용 광고를 올리는 등의 방법도 있습니다. 이런 모터는 물 펌프, 분쇄기 등에 사용되기 때문에 어디에서든 찾을 수 있습니다.\n\n가격: 100달러 (새 제품)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 기어박스\n\n15:1 또는 14:1, 웜 기어박스를 사용할 수 있습니다. 다만 웜 기어박스는 더 저렴하지만 헬리컬 인라인 기어박스는 더 효율적이지만 비용이 더 많이 듭니다.\n\n기어박스를 구매할 때는 모터가 제공할 수 있는 전력에 맞게 등급이 매겨졌는지 확인하고, 모터의 축에 적합한 보어 또는 축이 있는지 확인하세요.\n\n가격: $125 (새 제품)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# AC 드라이브\n\n![AC 드라이브](/assets/img/2024-06-23-Part2BuildingFilamentExtruder_2.png)\n\n이것은 모터 속도 제어에 사용됩니다. 모터를 기어 다운했을 때 0 rpm부터 100 rpm까지의 속도 범위를 사용할 수 있습니다. 만약 30rpm을 선택하고 싶다면 AC 드라이브를 사용하면 가능합니다. 모터 출력의 2배 정도 용량을 갖춘 3상 AC 드라이브를 구입하면 됩니다. 이에 대해 제 경험이 많지 않지만, 친구가 그렇게 제안했습니다.\n\n가격: $150 (새 제품)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 밴드 히터, 열전 대, 온도 조절기\n\n![Band Heater Image](/assets/img/2024-06-23-Part2BuildingFilamentExtruder_3.png)\n\n마이카 밴드 히터를 구매했어요. 시간당 5kg에 필요한 100-150W 밴드 히터가 3개 필요할 거에요.\n\n![Band Heater Image 2](/assets/img/2024-06-23-Part2BuildingFilamentExtruder_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n필요한 열전대는 표준 K 타입 열전대입니다.\n\n![image](/assets/img/2024-06-23-Part2BuildingFilamentExtruder_5.png)\n\n온도 컨트롤러는 REX-C100 온도 컨트롤러입니다.\n\n찾은 각 컨트롤러/열전대 세트는 $20에 판매 중입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 DIY ekstruders는 3개의 히팅 존을 사용하기 때문에 3개의 컨트롤러, 열전대, 히터가 필요합니다.\n\n3개의 컨트롤러/열전대/SSR에 $20 * 3 = $60, 그리고 3개의 히터에 $15를 사용합니다.\n\n비용: $75\n\n# 모두 함께 조립하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 장치는 보통 3개의 가열 존이 있지만, 이 장치는 4개의 가열 존을 가지고 있습니다. 또한, 3개의 디스플레이 유닛이 있습니다. 이 유닛들은 PID 컨트롤러 REX C100입니다. 여기에서 ABS를 녹이기 위한 온도를 설정할 수 있습니다. 이후 게시물에서 온도 설정에 대해 이야기할 예정이에요. 컨트롤러 아래에 있는 조절 다이얼은 온도를 설정하는 데 사용됩니다. 그리고 마지막에 있는 표시가 있는 다이얼은 모터/스크류 속도를 제어하는 데 사용되며, AC 드라이브에 연결되어 있습니다.\n\n![이미지](/assets/img/2024-06-23-Part2BuildingFilamentExtruder_6.png)\n\n# 배럴 단열\n\n히터가 배럴 벽을 가열하고, 배럴 벽은 나사에 의해 호퍼로부터 운반된 플라스틱에 열을 전달합니다. 단열된 배럴은 열의 빠른 손실로 인한 온도 변동을 줄이고 전력 소비를 줄일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n배럴 주변에 유리섬유 밴드 롤을 사서 몇 번 감아주세요. 긴 알루미늄 호일 조각을 여러 번 접어 다층 밴드를 만들어주세요. 이제 유리섬유 단열 배럴 주변에 감아주세요. 마지막으로 모든 것을 Kapton 테이프 한 층으로 고정시켜주세요.\n\n세라믹 섬유, 슈퍼 울, 또는 cms 울을 사용할 수 있어요 — 원하시는 곳에 사용 가능하다면 좋겠지만, 저는 사용 가능한 곳을 찾지 못해 자동차 부품 공급업체에서 찾은 배기 파이프 단열재로 대체했어요.\n\n# 비용 절감\n\n기어박스와 모터와 같은 무거운 물품은 현지에서 구매하세요. 중고로 구매하면 20% 더 싸게 구입할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 이 기계의 가장 비싼 부분입니다. 풀러/위더라도 $100 이하로 구입할 수 있어요. 이에 대해 우리는 향후 게시물에서 다룰 거예요.\n\n# 그렇지만 더 저렴하게 만들 수 있을까요?\n\n# 필라멘트를 압출하고 0.03mm 내에 제작하는 방법은 무엇인가요?","ogImage":{"url":"/assets/img/2024-06-23-Part2BuildingFilamentExtruder_0.png"},"coverImage":"/assets/img/2024-06-23-Part2BuildingFilamentExtruder_0.png","tag":["Tech"],"readingTime":4},{"title":"ESA, 세계 최초의 금속 3D 프린팅 성공 우주정거장에서의 혁신적인 순간","description":"","date":"2024-06-23 17:28","slug":"2024-06-23-ESAAchievesHistoricWorlds1stMetal3DPrintingonSpaceStation","content":"\n\n![ESA](/assets/img/2024-06-23-ESAAchievesHistoricWorlds1stMetal3DPrintingonSpaceStation_0.png)\n\n유럽 우주국(ESA)가 국제 우주 정거장(ISS)에서 최초의 금속 3D 프린팅을 성공적으로 실시함으로써 획기적인 성과를 이루었습니다. 에어버스를 중심으로 한 연합체가 주도한 이 역사적 사건은 우주 기술과 지속 가능성 노력에서 중대한 발전을 의미합니다.\n\n# 새로운 우주 제조 시대\n\n3D 금속 프린팅은 2024년 5월 30일에 이루어졌으며, 액체 스테인레스 스틸로 작은 S자 형태를 만들었습니다. 이 성취는 ESA가 우주에서 폐기된 위성 부품과 다른 우주 폐기물을 3D 프린팅 기술을 통해 새로운 유용한 재료로 재활용하는 것을 목표로 하는 대담한 계획의 중요한 한걸음입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 우주에서 금속 3D 프린팅의 중요성\n\nISS에서는 장시간 동안 플라스틱 기반 3D 프린터가 사용되어 왔지만, 금속 3D 프린팅은 훨씬 더 중요한 도전을 제시합니다. 플라스틱과 달리 금속은 용융되어 원하는 모양으로 형성되기 위해 극히 높은 온도가 필요합니다. ISS에 탑재된 금속 3D 프린터는 이러한 도전을 처리할 수 있도록 설계되었으며, 레이저를 사용하여 금속을 액체 상태로 가열합니다. 안전과 정밀성을 보장하기 위해 프린터는 공간 정거장 환경으로의 과도한 열 및 연기 유출을 방지하는 완전히 밀폐된 상자에 위치해 있습니다.\n\n# ISS로의 여정\n\n금속 3D 프린터는 2024년 1월 30일에 SpaceX 파이콘 9 로켓에 의해 발사된 Cygnus NG-20 미션을 통해 ISS로 여정을 떴습니다. 약 180kg(396파운드)의 무게를 갖는 이 프린터는 ESA 우주비행사 안드레아스 모겐센에 의해 ISS의 콜럼버스 모듈에 신중히 설치되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또 읽기: 일본, 우주로 사람을 태우는 96,000km의 우주 엘리베이터 건설 중\n\n# 금속 3D 프린터 작동 방식\n\n프린터는 스테인리스 스틸 와이어를 챔버로 공급하여, 고출력 레이저가 강철을 녹입니다. 녹은 강철은 프린터에 의해 원하는 형태로 가공됩니다. 이 과정은 지구에서 원격으로 제어되며, ISS 선원들은 인쇄 프로세스를 용이하게하기 위해 질소 및 배출 밸브의 개방만 관리해야 합니다.\n\n# 첫 번째 성공적인 인쇄\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nS 모양 곡선의 성공적인 출력은 프린터가 기능적인 부품을 생산할 수 있는 능력을 입증합니다. ESA의 기술 책임자인 Rob Postema에 따르면, 이 초기 성공은 프린터가 곧 미래에 더 복잡하고 유용한 구성품을 제조하기 시작할 수 있도록 준비된 상태임을 보여줍니다. 인쇄된 S자 모양과 다른 기준 선들은 기술이 실용적인 응용에 준비되었음을 의미합니다.\n\n# 미래 응용 및 혜택\n\n다음 단계는 프린터를 사용하여 네 가지의 특정 모양을 만들고, 그 모양들을 지구로 송부하여 상세 분석을 수행하는 것을 포함합니다. 이 부품 중 두 개는 네덜란드 ESTEC의 재료 및 전기 부품 실험실에서 연구되어 연장된 미세 중력이 금속 인쇄에 미치는 영향을 평가합니다. 나머지 두 부품은 유럽 우주 비행사 센터 및 덴마크 공과대학 (DTU)에서 분석될 것입니다.\n\n또한, 일본이 상용 우주 임무를 위한 소화물 시축 연료를 성공적으로 생산했다고 보도됐습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 지속 가능한 우주 경제 구축하기\n\nESA는 미래에 3D 프린팅 기술이 지구에서 대체 부품을 발사하는 필요성을 크게 줄일 수 있는 시대를 상상하고 있습니다. 우주에서 기존 재료를 재활용함으로써, 기관은 비용을 낮추고 우주 임무의 효율성을 증대시키려고 합니다. 이 접근 방식은 우주 탐사의 지속 가능성을 지원하는 데 뿐만 아니라, 지구 기반 자원에 대한 의존을 줄이는 방식으로 보다 포괄적인 환경 목표와도 부합합니다.\n\n# 협력 노력\n\n이 구상의 성공은 다양한 기관들의 협력 노력에 기인합니다. Airbus Defence and Space SAS가 주도하는 산업 팀은 중요한 역할을 하였으며, 프랑스의 CADMOS 사용자 지원 센터는 지상에서 프린팅 작업을 감독했습니다. 또한 ESA의 헌신적인 팀 또한 이 역사적인 성취에 상당한 기여를 했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 연구 및 개발의 역할\n\n실용적인 응용뿐만 아니라 ESA는 기술 향상을 위해 연구 프로젝트에 크게 투자하고 있습니다. 뮌헨 응용 과학 대학과 독일 연방 경제 및 에너지부와의 협력은 우주 3D 프린팅 기술의 능력과 효율성을 높이는 데 중요한 역할을 합니다. 이러한 파트너십은 수소 저장 기술을 개선하고, 수소 연료 전지 자동차의 실용성과 비용 효율성을 높이기 위해 집중 노력하고 있습니다.\n\n# 우주 탐사에 미치는 넓은 영향\n\n우주에서 금속 부품을 제조할 수 있는 능력은 미래 미션에 대한 다양한 가능성을 열어줍니다. 위성 부품, 거주 모듈, 심지어 우주선 부품 등과 같이 더 복잡한 구조물 개발에 이를 수 있습니다. 이 능력은 특히 지구로부터의 보급이 불가능한 확장된 기간 미션, 예를 들어 화성 이상의 계획된 미션에서 매우 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한 읽기: 중국 과학자들이 초음속 우주 비행기 발사를 위한 거대 전자기 실내포 사격 관 개발 중\n\n# 결론\n\n국제우주정거장(ISS)에서의 성공적인 금속 3D 프린팅은 우주 기술과 지속가능성에 대한 거대한 발전이다. 유럽 우주국(ESA)의 이번 성과는 우주에서 원형 경제를 구축하는 잠재력뿐만 아니라 우주 제조업에서의 미래 혁신을 위한 전례를 제시한다. 기술이 발전함에 따라 우주에서 필수 부품을 생산하는 능력은 점점 더 중요해지며, 더욱 야심찬 지속가능한 우주 탐사 노력을 위한 길을 열어줄 것이다.\n\n지속적인 연구, 개발 및 국제 협력을 통해, 완전히 운영 가능한 우주기반 제조 시스템의 꿈이 현실이 되고 있으며, 지구 이외의 지각적인 신시대의 탐사와 지속가능성을 약속하고 있다.","ogImage":{"url":"/assets/img/2024-06-23-ESAAchievesHistoricWorlds1stMetal3DPrintingonSpaceStation_0.png"},"coverImage":"/assets/img/2024-06-23-ESAAchievesHistoricWorlds1stMetal3DPrintingonSpaceStation_0.png","tag":["Tech"],"readingTime":4},{"title":"Original Prusa MK4 3D 프린터 리뷰 조용한 일꾼의 성능 평가","description":"","date":"2024-06-23 17:25","slug":"2024-06-23-OriginalPrusaMK43DPrinterReviewTheQuietWorkhorse","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-OriginalPrusaMK43DPrinterReviewTheQuietWorkhorse_0.png\" /\u003e\n\n2023년 3월 29일에 Original Prusa™ MK4 출시 발표가 공개 소비자 3D 프린팅 산업에 경고를 줬어요: Prusa가 돌아왔다! 성능이 향상된 압출기, 인풋 형상화, 셀 센서 및 기타 많은 기능을 갖춘 이 제품은 \"매번 완벽한 첫 번째 층\"을 약속하며, 그 당시 미발매 소프트웨어로 \"벤치\" 벤치마크를 20분미만으로 인쇄하며 일상 대화의 소리 수준 이하로 유지할 것이라고 말했어요. 5년 전 MK3 디자인과 비교했을 때 이 제품은 훌륭한 업그레이드예요.\n\n내가 알기로 Prusa는 중국에서 제조하지 않는 세계에서 유일한 소비자 가격의 3D 프린터 제조업체에요. 그들의 프린터는 유럽에서 만들어지며 서구를 약화시키는 국가 혜택(세제 혜택) 없이 공정한 노동 법 등으로 만들어져요. 그래서 당연히 Prusa 프린터는 더 비싸요. 또한 Prusa 회사는 3D 프린팅에서 주요 혁신원 중 한 곳(유일한 것은 아니에요)이며, 요제프 프루사는 오픈 소스를 강력히 신봉하는데, 그들의 대부분의 혁신은 모방자들에 의해 복제돼요. 사실, \"Original Prusa\"라는 용어는 평판의 명확성을 제공하기 위한 상표예요. 많은 기능을 추가한 원래 \"Slic3r\"의 분파인 PrusaSlicer는 오픈 소스로 유지되고 MK4를 완전히 지원하며, 대부분의 다른 제조업체의 프린터와 Prusa의 필라멘트 및 대부분의 다른 제조업체의 필라멘트를 사용할 수 있어요. PrusaSlicer는 다른 프린터 제조업체에 의해 채택되어 Bambu Studio, SuperSlicer, AnycubicSlicer, OrcaSlicer 등의 분파로 이어졌어요. 그 반대 방향으로는 프린터에서 실행되는 \"Marlin\" 펌웨어의 원래 버전이 오픈 소스로 Prusa가 사용하지만 크게 수정돼요. Prusa는 자유롭게 다운로드할 수 있는 모델의 널리 사용되는 저장소인 https://printables.com도 후원해요. (이전 모델 저장소인 Thingiverse는 프린터 벤더 Ultimaker도 후원해요).\n\n이 프린터가 출시된 후에 실제로 얼마 동안 망설이며 다음을 고려했어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 여기에는 오리지널 프루사 MK4가 있어요.\n- 저렴한 소볼 SV06 Plus도 있구요.\n- 밤부 랩스 P1P도 있죠.\n- 저의 고려 마지막에 출시된 크리얼리티 K1도 있어요.\n\n위의 네 대의 프린터들은 경쟁 중이며 아마도 새로운 \"무기 경주\" (로봇 경주?)의 시작일 것입니다. 네 회사 모두 충분히 성장하고 자금 조달이 되어 있어서 장기간 유지될 가능성이 높습니다.\n\n첫 두 대의 프린터는 전통적인 \"베드 슬링거\" 디자인입니다. 여기서는 베드가 동일한 높이로 고정되며 Y 평면(앞 뒤)으로 움직이고 프린트 헤드가 X(좌우) 및 Z(상하) 평면으로 움직입니다. 나머지 두 대는 \"CoreXY\" 프린터로, 여기서는 베드가 상하로 움직이고 프린트 헤드가 x 및 y 평면으로 움직입니다. 프루사는 또한 CoreXY 디자인인 오리지널 프루사 XL도 있지만 MK4보다 가격이 상당히 비싸요.\n\n대부분의 다른 제조업체들처럼 프루사도 수지 기반 프린터를 만들지만, 여기서는 FDM 또는 필라멘트 기반 인쇄만 살펴봅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n왜 Prusa일까요? MK4에 저를 끌어들인 몇 가지 요소가 있습니다:\n\n- 항상 Prusa를 갖고 싶었어요;\n- MK4의 기능 세트;\n- 공정하고 안전한 작업에 대한 공정한 보수가 요구되는 유럽에서 생산된 제품이라는 사실;\n- 이전 유사 모델의 대규모 고객 기반은 온라인 포럼에서 도와줄 수 있습니다;\n- 고객 서비스에 대한 평판;\n- 그리고 오렌지색 :-).\n\n사실, MK4가 발표되었을 때 Sovol SV06+를 방금 구매했었는데, 마침내 Sovol을 다른 구매자에게 미개봉으로 넘겼습니다. 박스를 열고 사용해보지 않는 것이 고통스럽긴 했지만, 결과적으로 주문한 Prusa가 승리했어요.\n\nMK4(공식적으로 \"Mark Four\"로 발음하며 \"em kay four\"가 아닙니다)는 모든 Prusa 프린터와 마찬가지로 조립식 키트 혹은 조립 및 테스트된 형태로 구입할 수 있습니다. 키트를 조립하면 프린터가 실제로 어떻게 작동하는지에 대해 많은 것을 배울 수 있습니다. 그러나 거의 하루가 걸릴 것입니다. 더 비쌈에도 불구하고, 저는 이미 3D 프린터를 두 대 조립했고(둘 다 작동했지만 둘 다 100% 만족스럽지는 않았습니다), 상자에서 꺼내자마자 “바로 작동”할 가능성이 더 높은 무언가를 원했기 때문에 조립된 버전을 선택했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n공지의 시작에서 웹 사이트가 잘못된 6-7주의 백로그가 있다고 주장했습니다. Prusa Live #51에서 MK4 공지 이후에, Josef는 이것이 완전히 틀렸다고 말하고 그것을 그들의 CRM 소프트웨어 탓으로 돌렸습니다. 그러나 2023년 4월 18일에 주문한 시점에는 주문이 많아서 실제로 맞는 것으로 확인되었습니다. 주문하면 배송 백로그 예상 일정이 제공되지 않았다는 점이 약간 실망스러웠고, \"당신의 돈을 받았다\"라는 말 이외에 아무 정보도 듣지 못한 채 몇 일이 지났습니다. 돈 이야기를 하자면, 그들의 유럽 신용 카드 청구 공급업체가 어떤 이유로 나의 캐나다 신용 카드를 처리할 수 없었습니다. 몇 번 시도해 보았지만 결국 PayPal로 변경했습니다.\n\n사실, 가장 큰 고통점 중 하나는 주문 대기열에 대한 정보 부족이었습니다. Prusament 필라멘트 롤이나 예비 인쇄 시트를 주문하면 예상 출고 일정이 표시됩니다. 그러나 US$1100 프린터를 주문하면... 주문했을 때 당시에는 주문이 언제 출고될지에 대한 피드백이 없었습니다. \"5-7주\" 백로그가 여름까지 늘어나고 있었는데, 사람들이 휴가 중이어서 주문을 받지 못할 수도 있기 때문에 문제가 됩니다 (현관 약탈범 누군가?). 제가 가만히 해볼 친구를 준비해 놓았던 참이도 있습니다. 하지만 결국 휴가를 떠나기 전날 도착해서, 휴가에서 돌아온 후에 개봉했습니다. 이 대기열은 해소되었지만, MK5가 발표될 때 모든 것이 다시 일어나지 않도록 그들의 IT를 재편해야 할 필요가 있습니다.\n\n# 기능 세트\n\n아무 것도 놓치지 않기 위해, 여기에 prusa3d.com에서 직접 인용한 기능 목록을 제시해 드립니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 수상 경력에 빛나던 3D 프린팅 전문가 오리지널 프루사 MK3의 후속 모델\n- MK4에서의 즉각적이고 조용한 3D 프린팅. MK4에서 20분 미만의 벤치 비디오를 확인하세요!\n- 로드셀 센서 덕분에 완전히 자동화된 첫 번째 층 교정\n- 상자에서 꺼내서 즉시 프린트하기 - 프린트 시트 프로필이나 조정 필요 없음\n- 넥스트루더 - 맞춤형 브레이크아웃 보드와 스마트 기능을 갖춘 새로운 엑스트루더\n- 필라멘트 센서와 전원 패닉과 같은 안전 기능\n- 쉬운 유지 보수, 빠른 노즐 교체, 탈착 가능한 프린트 시트\n- PLA, PETG, 플렉스, 나일론, ASA, PVA, PC, PP, 복합 등 다양한 재료 지원\n- 사용하기 간편한 컬러 LCD 화면 및 모든 중요 기능에 빠르게 액세스 가능\n- 이더넷 및 Wi-fi 연결\n- 유럽 제조, 편안한 보증, 24/7 라이브 채팅 지원\n- 오픈 소스\n\n인터넷 상에서 MK4의 출시가 최근 발표된 경쟁사의 압박으로 인해 \"서둘러 출시되었다\"고 말하는 소문이 있습니다. 그러나 작년 한 해 동안 프루사는 내부 MK4를 백만 시간 이상 가동해왔다는 사실로 이를 부정합니다. 계산을 해보면, 그것은 아마도 한 해 동안 매일 백 개의 MK4 장치가 24/7 가동되었을 것이라는 것을 의미합니다, 혹은 반년 동안 200대, 등의 가정을 할 수 있습니다. 이 기간 동안 테스트 프린트 및 프린터 부품을 무더기로 생산하며 공개 전 발표까지 유출이 전혀 없었던 점이 인상적입니다!\n\n그 말인즉, \"20분 미만의 벤치\"는 초기 주문이 출하된 후에 릴리스된 소프트웨어를 기반으로 합니다. 그리고 \"드래프트\" (최저 해상도) 모드에서 작동합니다.\n\nLCD 화면은 MK3보다 큰 개선점입니다. 컬러이며 고해상도입니다. 주요 에러가 발생할 때 (이미지 확인, 초기 셰이크다운 중 단 한번 발생한 일시적 에러), 그것을 이용할 때 이점을 얻을 수 있습니다. 화면 하드웨어는 터치 지원이 있지만 소프트웨어가 아직 그것을 활용하지 않습니다 (싱글 컨트롤 노브로 충분히 간단한 UI이므로 아마도 필요하지 않을 것입니다) [편집: 2024년 4월 이후 릴리스 된 6.0부터 터치 UI 작동함]. 전면 패널은 리셋 버튼과 장치의 유일한 사용자 접근 가능 디스크 저장 공간을 위한 USB-A 소켓으로 완성돼 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![2024-06-23-OriginalPrusaMK43DPrinterReviewTheQuietWorkhorse_1](/assets/img/2024-06-23-OriginalPrusaMK43DPrinterReviewTheQuietWorkhorse_1.png)\n\n![2024-06-23-OriginalPrusaMK43DPrinterReviewTheQuietWorkhorse_2](/assets/img/2024-06-23-OriginalPrusaMK43DPrinterReviewTheQuietWorkhorse_2.png)\n\n# 첫 번째 인쇄\n\n프린터의 비키트 버전은 완전히 조립된 채 도착하기 때문에 초기화는 상자를 열고 프린터를 안정한 테이블로 이동시키고 일부 폼 패키지를 제거하고 프린터를 연결하고 켜고 간단한 자체 테스트를 실행하고 인쇄할 때까지로 이루어집니다. 이론상으로는... 음, 아니요. 실제로도 그렇습니다. 필라멘트와 모델을 넣고 인쇄 버튼을 누르세요. 그냥 작동합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 몇 모델 출력은 잘됐어요. 완벽한 첫 번째 층이 나왔죠. 그런 다음에 좀 어려운 것을 해보고 싶어졌는데, 곧 이야기하겠습니다. 먼저, 프린터에 출력 파일을 가져다 놓고 노즐을 살펴봅시다.\n\n# 소프트웨어: 슬라이싱, 다이싱...\n\n아마도 3D 모델이 낮은 수준의 기계어(“g-코드”)를 생성하기 위해 “슬라이싱”되어야 한다는 것을 알고 계실 것입니다. 이는 프린터에게 어디로 이동해야 하는지, 언제 필라멘트를 공급해야 하는지, 헤드와 베드에 어떤 온도를 사용해야 하는지 등을 각 층 또는 “스라이스”마다 알려주는 것입니다. PrusaSlicer는 프루사의 자체 슬라이서 소프트웨어입니다. 이는 알렉산드로 라넬루치(Alessandro Ranellucci)에 의해 이전 도구인 “Slic3r”에서 크게 재작성되었습니다. PrusaSlicer™는 Linux, Windows 및 Mac에서 해당 웹 사이트에서 다운로드할 수 있습니다. 소프트웨어 반대론자로 알려진 저는 노트북에 OpenBSD Unix를 실행하고 있습니다. 따라서 OpenBSD로 PrusaSlicer를 “포팅”하게 되었고, 이 작업은 2023년 10월/11월에 완료되었습니다(레나토 아귀아르(Renato Aguiar)와 요하네스 티스만 티쉬만(Johannes Thyssen Tishman)이 주요 작업을 수행했습니다). 가끔 필요한 이상한 작업을 위해 맥북도 있답니다.\n\nPrusaSlicer는 다음과 같은 기능을 갖춘 완전한 슬라이서입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다양한 파일 유형 (STL, OBJ, 3MF 및 STEP 포함)을 가져올 수 있습니다.\n- Prusa 프린터뿐만 아니라 다양한 프린터를 위한 g-code 파일을 생성할 수 있습니다.\n- Prusament뿐만 아니라 다양한 필라멘트에 대한 최적의 매개변수를 제공할 수 있습니다.\n\nPrusaSlicer는 정기적으로 업데이트됩니다. 프린터 자체의 소프트웨어 인 \"펌웨어\"도 자주 업데이트됩니다. 내 프린터는 4.9 버전 중 하나로 도착했으며, 도착 직후에 4.9 업데이트를 받았습니다. 5 버전은 초기 제공 당시 \"나중에\" 약속된 기능 중 일부를 제공했습니다. 내가 이 글을 쓰는 시점의 최신 버전은 5.1이며, 이 버전은 느린 링크로 적재하는 사람들을 위해 gcode를 압축하는 방법을 포함하고 있습니다. 좋든 싫든, 이는 프린터에서 출력 중인 항목을 보여주는 데 사용되는 섬네일 이미지도 압축합니다 (무엇을 출력하는지 확실하게 하기 위해 도움이 됩니다!). 이전 펌웨어는 이 압축된 형식을 이해하지 못했으므로, 이 업그레이드는 미리보기를 보기 위해 펌웨어와 PrusaSlicer 버전을 동시에 변경해야 합니다. PrusaSlicer 2.6로 슬라이싱된 파일을 5.1 펌웨어에서 인쇄할 수 있었지만, 섬네일은 암호와 같은 것으로 화면에 나타납니다.\n\n# 연결성\n\n프린터는 유선 이더넷, 무선 (WiFi) 및 USB 드라이브 삽입을 지원합니다. 저는 유선 연결을 선호하므로 이더넷과 \"스니커넷\"(USB 드라이브를 컴퓨터에서 프린터로 이동)만 사용했습니다. 결과적으로 다른 사람들이 보고한 \"느린 WiFi\" 문제로 고생하지 않았습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPrusaLink은 하나의 프린터를 로컬로 관리하는 웹 기반 프로그램이에요. 모든 현대 브라우저와 호환되며, 프린터에 파일을 업로드하고 인쇄를 시작하며 인쇄 작업을 모니터링하고 프린터의 USB 저장 공간에서 파일을 다운로드하거나 제거할 수 있어요. 제 경험 상 훌륭하게 작동해요.\n\nPrusaLink의 한 가지 성가신 점은 웹 기반 로그인이에요. 사용자 이름이 \"maker\"이어야 하고, 암호는 프린터에 의해 생성된 일부 무작위 말쑥이어야 해요. 프린터의 LCD 화면에 표시될 수 있어요. 자체 암호를 설정할 수 있는 옵션이 없으므로 일반적인 \"abc.123\"은 사용할 수 없어요. 한 번 PrusaLink가 혼란스러워져서 프린터와 통신을 할 수 없었던 적이 있었는데(아마 DHCP 문제, 즉, 내 문제), 그냥 USB로 돌아갔어요.\n\nPrusaConnect는 그들의 클라우드 기반 연결 서비스에요. 제겐 소수의 견해지만, 나는 내 모델을 위한 클라우드 기반 스토리지를 선호하지 않아서 테스트해보지 않았어요. 최신 소프트웨어로, 스트리밍 다운로드와 OTA(Over The Air) 펌웨어 업데이트 두 가지 이점을 제공해요. 스트리밍 다운로드 기능은 느린 네트워크 처리량에 대응하는 것이죠. 이전에는 파일이 프린터로 다운로드될 때까지 기다려야 했는데, 바쁜 프린트 팜에서 큰 파일들의 경우 이 지연은 돈을 낭비하게 만들었어요. 이제 첫 몇 개의 g-code 명령어를 수신하자마자 프린터가 작업을 시작할 수 있어요. OTA(Over The Air) 펌웨어 업데이트는 스마트폰과 테슬라 자동차에서 10년 동안 사용되어온 기술이기 때문에 여기에 도착하는 것은 자연스러운 일이에요. PrusaConnect를 사용하지 않으므로 PrusaLink도 펌웨어 파일을 보내주지 않아서 컴퓨터에서 프린터로 펌웨어를 USB 메모리 장치를 이용해 전달해야 해요. 몇 달에 한 번씩, 그건 나에겐 괜찮아요.\n\n클라우드에 대한 두려움을 설명하기 위해, 예를 들어, Bambu Labs가 중국 정부에 나의 최신 디자인을 공유하도록 허용하는 가능성 외에도, Bambu Labs는 완전히 자유롭게 인쇄 작업을 시작할 수 있는 클라우드 방식을 활용할 수 있도록 더 나아갔어요. 불행히도 그들(그리고 그들의 고객)을 위해, 그들의 클라우드 소프트웨어에서 버그로 인해 전 세계의 많은 고객 프린터가 뜻하지 않게 인쇄를 시작했는데, 이전 모델이 있는 경우에도 프린터가 고장이 나고 수리를 위해 DIY하거나 공장에서 수리를 받아야 했어요. 젊은 기업에게 빛나는 시작은 아니었죠!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n옥토프린트는 2012년부터 Gina Häußge가 개발한 프린터용 제3자 오픈소스 프로그램으로, 커뮤니티의 지원으로 이뤄졌어요. 라즈베리 파이에서 미리 구성되어 있어 옥토파이라고도 불리며, PrusaLink와 같은 기능을 갖추고 있지만 훨씬 더 많은 기능을 제공해요. 다양한 플러그인을 지원하며 라즈베리 파이 카메라 사용을 지원합니다. 이전 프린터에서 사용해봤어요. 엠케이4와는 아직 설정하지 않았지만 다른 사용자들은 설정을 해두었어요.\n\n# 넥스트루더\n\n\"로드 셀 베드 레벨링\"은 모두가 모방하는 멋진 기능이에요. Bambu의 고급 유닛을 제외하고 라이다를 사용하죠. 빌드 플레이트에 매우 가볍게 노즐을 닿게 해서 다양한 지점마다 베드 높이를 정확히 파악하죠. 실제로 사용되는 프린트 베드 부분에서만 수행되어 대부분의 프린트에 시간을 절약해줘요. 많은 저렴한 프린터들에서 노즐이나 빌드 시트를 교체할 때 전체 베드의 Z 높이를 재조정해야 하는데, MK4는 이 작업을 자동으로 처리해줘요. 이것은 큰 장점이에요! 유튜브에서는 중공 골판지 상자 조각이나 얇은 나무 조각을 잘라 빌드 플레이트에 붙이고, 프루사 MK4가 어떠한 조정도 필요하지 않고 거기에 바로 인쇄되는 모습을 보실 수 있어요.\n\n적절한 부품을 갖고 있다면 몇 초 안에 노즐을 교체할 수 있어요. 프린트 헤드 박스의 한 쪽에는 열리는 선풍기가 있어 내부에 접근할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 더 어려운 프린팅\n\n물론 3D 프린터의 진짜 시험은 첫 주에 얼마나 잘 인쇄하는지만이 아니라, 수년 동안 계속해서 얼마나 잘 인쇄하는지입니다. 각종 MK3 패밀리는 \"일말의 말\"로 묘사되었으며, 그것은 분명히 그것을 충족합니다. 사람들은 수년 동안 성공적으로 운영되는 것을 보았습니다. MK4는 1년 동안 완전히 가동 중인 일부 내장 장치와 함께 잘 시험된 후속 디자인입니다.\n\n나는 친구들과 친척들을 위해 \"고양이 열쇠 걸이\"의 여러 복제본을 인쇄했습니다. 캐나다에서 만든 EconoFil PLA로 인쇄된 것들은 성공적이었습니다. 프루사 자체의 Prusament PLA로 인쇄된 몇 가지 작품은 오류를 만났습니다. 상자를 여는 레버 하단의 \"갈고리\"를 인쇄하지 못한 작품이 몇 개가 있었고, 하나는 상단이 여전히 열려 있는 원인이 되는 거친 부분이 있었습니다. 경험이 풍부한 3D 프린트 제작자들은 서로 다른 필라멘트 사이에 큰 차이가 있다는 것을 알고 있기 때문에 이것은 큰 놀라움이 아니었습니다. 또한, 이것은 \"자리에서 인쇄\" 디자인입니다. 이는 움직이는 부품들을 조립할 필요가 없다는 것을 의미합니다; 레버는 축에 사전 장착된 상태로 인쇄되기 때문에 조립이 적게 필요하지만 \"막혀 있는\" 상태여야 합니다. 실패할 가능성이 다소 높으며, 특정 인쇄 문제를 수정할 수 없으며 전체 상자를 다시 인쇄하지 않고는 해결할 수 없습니다. 그럼에도 불구하고, 나는 작동하는 고양이 열쇠 걸이 시리즈를 만들었고, 이를 주변에 나눠주었습니다.\n\n![이미지](/assets/img/2024-06-23-OriginalPrusaMK43DPrinterReviewTheQuietWorkhorse_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nThingiverse.com에서 가져온 이 주사위 타워는 제가 다음으로 진행한 프로젝트였는데요, 게이머 친구들에게 선물로 주려고 준비했어요. 주사위 타워는 약 400년 경부터 주사위를 공정하게 굴릴 수 있도록 보장하기 위해 사용되었습니다. PrusaSlicer 프로그램에 따르면 해당 프로젝트는 올바르게 출력하려면 \"서포트\"가 필요하다고 했어요. FDM 인쇄는 연속적인 층을 놓는 방식으로 작동합니다. 이전 층을 45도 이상 오버행하는 경우나 출력물의 일부가 공기 위에 돌출되는 경우에 서포트가 필요합니다. 그러나 타워의 디자이너인 Shin da Silva aka FresnelTHz는 \"서포트가 필요 없다\"고 합니다. 저는 디자이너의 말을 믿고 타워를 PLA로 완벽하게 출력했어요.\n\n다음으로 테스트/데모로 그랜드 캐슬을 출력하기로 결정했어요. 잘 알려진 3D 프린트인 이 캐슬은 클라우드 기반의 \"Thingiverse Customizer\"로서 중세 성을 얼마나 크게 만들 것인지, 몇 개의 타워를 추가할 것인지, 디자인에 얼마나 많은 무작위성을 부여할 것인지 등을 선택할 수 있습니다. 또한 이 모델 파일을 로컬에서 실행하기 위해 OpenSCAD에서 다운로드할 수도 있는데요, 이는 여러 무료 오픈 소스 모델링 디자인 도구 중 하나입니다. 저는 그랜드 캐슬을 3D 프린터의 좋은 테스트로 간주하는데, 이는 가능한 많은 타워 간의 이동을 수반하며, 프린터가 빠르고 정확하게 위치를 잡을 수 있는 능력과 필라멘트가 \"스트링잉(피달림)\"에 대한 저항력을 강조합니다. 저는 일부 무작위 타워를 추가한 작은 크기를 선택했어요. \"0.30mm Draft\" 모드에서 약 2.5시간 안에 출력되었는데, 약간의 스트링잉이 있었는데, 이는 아마도 필라멘트를 건조시키지 않고 상대적으로 습기가 많은 지하 사무실에서 출력했기 때문일 것입니다. 스트링잉은 후처리 단계에서 열풍건 또는 헤어 드라이어를 사용하여 쉽게 제거할 수 있어요.\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n몇 번의 인쇄 실패를 경험했지만 대부분은 작업자 실수 때문인 것 같아요 — 필라멘트를 건조하지 않는 것, 빌드 플레이트를 충분히 자주 청소하지 않는 것과 같은 이유로 실패한 것 같아요.\n\n# 강력한 전원 이상 복구\n\nMK4는 상태를 지속적으로 저장하여 전원이 꺼지면 이전 상태에서 계속할 수 있어요. 대부분의 검토어들은 이 기능을 테스트하기 위해 벽에서 플러그를 뽑아내야 하지만, 전력 이상이 좀 더 흔한 지방에 사는 저는 프린터의 DeLack Enclosure 부품을 프린팅하는 중에 등전이 꺼졌을 때 이 기능을 무료로 테스트할 수 있었어요. 전력이 복구되자 기계가 정확히 이전 작업 부분에서 다시 시작했어요. 이 이벤트의 \"기념품\"으로 약간의 선이 보이고, 조금의 추가 필라멘트가 출력되었지만, 쉽게 벗길 수 있었어요. 중요한 점은 레이어 이동이나 기타 중요한 손상이 없었다는 점이에요.\n\n# 추가 옵션\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"Nextruder\" 엑스트루더는 프루사 자체 노즐을 사용하며, 몇 가지 지름의 노즐을 그들로부터 구입할 수 있습니다. 사람들은 한 공급 업체에 묶이고 싶지 않기 때문에, 프루사는 \"E6 노즐 어댑터\"를 발표하여 더 널리 사용되는(더 싼) \"E6\" 스타일의 노즐을 사용할 수 있게 했습니다. 또한, E6 스타일의 단단한 강철 노즐을 얻을 수 있지만, 아직 Nextruder 형식으로는 제공되지 않았습니다. 어댑터는 첫날에는 제공되지 않았지만, 지금은 수 개월간 제공되고 있습니다.\n\nMK4의 가장 오랫동안 지연된 약속은 MMU3였으며, 이는 \"멀티 머티리얼 업그레이드\"의 세 번째 버전입니다. 이를 통해 최대 5가지 다른 필라멘트를 사용할 수 있으며, 일반적으로 다른 색상을 위해 사용되지만, 녹는 지지물 등 다양한 종류의 필라멘트에도 사용됩니다. MK4를 위해 MMU는 완전히 다시 디자인되었습니다. 이 버전은 업그레이드된 MK3S+ 프린터에서 큰 성공을 거두고 있지만, 개발자들은 MK4에서 이를 사용할 때 신뢰성 문제를 겪어 심각한 지연이 발생했습니다. 이 지연으로 인해, 오랜 기간 주문을 한 모든 사람들에게 프루사가 이 업그레이드에 대한 US$50 바우처를 보냈습니다. 저는 바우처를 사용하여 그들의 필라멘트를 구입했고, MMU3는 결국 출하되었습니다. 최첨단 기술을 이용한다는 대가가 있죠.\n\n일부 3D 프린터는 \"폐쇄형\"이며, 채비 메커니즘이 있는 방에서 벽으로 둘러싸여 있습니다. 많은 다른 기종은 Original Prusa MK3/MK4 라인을 포함하여, 폐쇄물은 추가비용으로 제공됩니다. 3D 프린터를 폐쇄하는 것은 다음과 같은 혜택을 제공합니다:\n\n-보다 신뢰할 수 있는 출력을 위해 일정한 온도를 유지하는 데 도움이 됩니다;\n-일정한 온도는 전기 소비를 줄일 수 있습니다;\n-소음을 차단합니다;\n-먼지를 방지하여 프린터 작동 또는 냉각 중일 때 손목을 넣지 않아도 됩니다;\n-일부 필라멘트가 방출하는 먼지나 유해 가스를 필터링하거나 외부로 배출하는 것을 허용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMK3/MK4 가족이 오랫동안 사용되어 왔기 때문에 이를 위한 다양한 케이스가 있습니다:\n\n- Ikea Lack 테이블을 사용한 몇 가지 DIY 케이스;\n- JK Tech의 판매용 팬시 케이스 구입 안내;\n- Kickstarter에서 구입할 수 있는 다른 팬시한 케이스 구입 안내;\n- Prusa의 고유한 MK3/MK4 케이스;\n- FYSETC Metal Printer Box 소음 차단 케이스;\n- MK4용 Atmos3d 케이스;\n- PrinterBox의 PrusaBox;\n- 3D Sourcerer의 Delack.\n\n나는 Delack 케이스를 선택하고 설치했는데, 실제로 내 프린팅을 믿을 수 있게 만들어줬어. 나는 이에 대한 자세한 리뷰를 작성해 I Tried That에 게재했어. Delack의 부품을 모두 인쇄하는 데 시간이 걸렸지만, 다른 옵션과 비교해 돈을 절약할 수 있을 뿐만 아니라 다양한 케이스 옵션이 있고, 어떤 방향에서든 프린트물을 확인할 수 있으며, 멋지게 보여! 나는 MK3/MK4 사용자, 오리지널 프루사 미니 사용자, 그리고 이와 유사한 크기의 프린터를 가진 사람들에게 이 케이스를 추천해.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n오리지널 프루사 MK4는 멋진 프린터에요! 이 프린터는 제가 시도해 본 다른 프린터들보다 훨씬 사용하기 쉽고 예측 가능하며 일관성이 있어요. 유럽에서 만들어졌고 중국이 아니기 때문에 가격이 더 비싸지만, 제 의견으로는 그 가치가 충분히 있다고 생각해요. 중국 제조업체들로부터의 경쟁이 앞으로 어떻게 전개될지 시간이 알려줄 거에요.\n\n#조그만 요청, 그리고 전체 공개\n\n만약 여기까지 읽었다면, 이 글에 박수를 부탁드립니다 (좋아하는만큼 여러 번), 그리고 제 프로필 또는 I Tried That e-지인을 팔로우해주세요 — 감사합니다!\n\n이 프린터를 Prusa에서 직접 소매 가격으로 구매했고, 처음에는 리뷰를 할 것임을 알리지 않았어요. 전체적이고 상세한 글을 작성할 예정이라고 말씀드렸는데, 신속하게 처리해 주실 수 있느냐고 요청했지만 거절당했어요. 따라서 특별한 대우를 받지 않았고, 그 결과 이 리뷰가 지연되었어요. 하지만 광고를 리뷰로 위장한 \"유료 영향력 있는 사람\"은 아니기 때문에, 이 리뷰는 기대되는 대로 진행됐어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제품 사용 후에 공장에서 이 프린터를 직접 구매하려면 제 리뷰를 읽고 이 제휴 링크를 사용해주세요. 그러면 무료 Prusa 필라멘트 롤 또는 다른 잠재적인 Prusa 구매를 위한 Prusa 크레딧('prusameters')을 받을 수 있어요. 이는 'I Tried That'에서의 글쓰기를 지원하게 도와줍니다. 감사합니다!","ogImage":{"url":"/assets/img/2024-06-23-OriginalPrusaMK43DPrinterReviewTheQuietWorkhorse_0.png"},"coverImage":"/assets/img/2024-06-23-OriginalPrusaMK43DPrinterReviewTheQuietWorkhorse_0.png","tag":["Tech"],"readingTime":14},{"title":"Creality Ender-3 V2의 전력 소비 얼마나 전력을 사용할까","description":"","date":"2024-06-23 17:25","slug":"2024-06-23-PowerConsumptionoftheCrealityEnder-3V2","content":"\n\n3D 프린팅 사업에 뛰어들기 전에, 특히 3D 프린팅 서비스 제공을 시작하기 전에, 나는 내 3D 프린터의 운영 비용에 대해 궁금해 했습니다. 그리고 알리익스프레스에서 약 8달러에 기본 스마트 소켓을 구매한 후, 이러한 측정을 준비했습니다. 그럼 시작해볼까요,\n\n# TLDR — 전력 소비 표\n\n인쇄 프로세스 중 — 110 와트 (평균)\n모델의 총 인쇄 시간에 직접 곱하기만 하면 됩니다.\n\n간단히(평균적으로):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 표에서 각 작업의 전력 소비량을 개별적으로 확인할 수 있습니다. 모든 값은 평균값이며 독립적인 소비량을 보여줍니다.\n\n또한 아래 초기 가열 값을 총 전력 소비량에 추가할 수도 있지만, 그들이 큰 차이를 만들지는 않습니다.\n` 히팅 베드 60°C로 가열 - 1Wh\n` 히팅 노즐 210°C로 가열 - 8Wh\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 보정 큐브의 예시 계산\n\n보정 큐브의 총 비용을 계산하는 예시를 살펴봅시다.\n\n![image](/assets/img/2024-06-23-PowerConsumptionoftheCrealityEnder-3V2_2.png)\n\n레이어 높이: 0.2 mm\n베드 온도: 60°C\n노즐 온도: 210°C\n필라멘트: PLA — 4 그램\n인쇄 시간: 30 분\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPLA 1kg - ₺400 | 4g - ₺1.6\n전기 요금: 1kWh당 ₺1.5 (터키)\n전기 소비량: 55Wh (0.5시간) + 9Wh (초기 가열) = 64Wh\n\n필라멘트 비용: 0.004 x 400 = ₺1.6\n전기 요금: 1.5 x 0.064 = 약 ₺0.1\n총 비용 = ₺1.7\n\n필라멘트 비용과 비교했을 때 거의 없지만 알아두는 것도 좋아요 :).\n\n# 테스트 조건\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n환경\n- 실내 온도: 25°C\n- 습도: 50%\n\n가열 온도\n- 노즐: 200°C\n- 베드: 60°C\n\n마더보드: Creality V4.2.2\n\n**크레딧**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n내 친구 멜리 나피 에킴에게 스마트 소켓의 측정을 확인해 주어서 감사합니다.","ogImage":{"url":"/assets/img/2024-06-23-PowerConsumptionoftheCrealityEnder-3V2_0.png"},"coverImage":"/assets/img/2024-06-23-PowerConsumptionoftheCrealityEnder-3V2_0.png","tag":["Tech"],"readingTime":2},{"title":"OctoPrint로 Z 오프셋 조정하는 방법","description":"","date":"2024-06-23 17:24","slug":"2024-06-23-26HowtocalibrateZoffsetusingOctoPrint","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-26HowtocalibrateZoffsetusingOctoPrint_0.png\" /\u003e\n\n가끔씩 Z 오프셋을 보정하는 데 어려움을 겪곤 합니다. 며칠 전에 Ender3 엑스트루더와 노즐을 모두 금속으로 교체했는데 Z 오프셋을 다시 보정해야 한다는 것을 깨달았죠.\n\nOctoPrint를 사용하여 Z 오프셋을 보정하는 단계를 아래에 소개해 드릴게요. OctoPrint에서 터미널 탭을 열고 다음 명령을 입력하세요.\n\n```js\n// Z 오프셋 재설정\nM851 Z0\n// 설정을 eeprom에 저장\nM500\n// 활성 매개변수 설정\nM501\n활성 매개변수 표시\nM503\n// Z 축 원점 복귀\nG28 Z\n// 노즐을 실제 0 오프셋으로 이동\nG1 F60 Z0\n// 소프트 엔드스톱 끄기\nM211 S0\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n용접기 갈고리를 침대 쪽으로 천천히 이동시켜서 종이가 거의 움직이지 않을 때까지 맞춰주세요. Octoprint의 제어 탭을 사용하여 Z 축을 조정해보세요. 프린터 디스플레이에 표시된 Z 값을 확인하세요. 그 숫자에 균질 측정지나 장치의 측정 값을 더해보세요. A4용지 한 장은 대략 0.05mm 두꺼워요.\n\n```js\n// 여기서 X.XX는 당신이 얻은 z 옵셋을 의미합니다\nM851 Z X.XX\n// 예시: M851 Z -2.44 (- 부호는 항상 음수여야 해요. 명령어에서 음수 부호를 주목하세요)\n// Soft Endstops 활성화\nM211 S1\n// 설정을 EEPROM에 저장\nM500\n// 활성 매개변수 설정\nM501\n// 현재 설정 표시\nM503\n```\n\nOctoprint의 터미널 탭:\n\n![Octoprint Terminal Tab](/assets/img/2024-06-23-26HowtocalibrateZoffsetusingOctoPrint_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n10월 3일 Octoprint의 Control 탭에서 Z축 이동에 대한 미세 조정을 할 수 있어요:\n\n![이미지](/assets/img/2024-06-23-26HowtocalibrateZoffsetusingOctoPrint_2.png)\n\n참고 자료:\n\nBLTouch 침대 레벨링 프로브로 Z 오프셋 보정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가이드: 오토 베드 레벨링 (ABL) 센서를 교정하는 방법\n\n3D 프린터를 위한 쉬운 Z-오프셋 조정\n\n\"기울어지는\" 베드 레벨링 결과를 고치는 방법\n\n이전 | 색인 | 다음","ogImage":{"url":"/assets/img/2024-06-23-26HowtocalibrateZoffsetusingOctoPrint_0.png"},"coverImage":"/assets/img/2024-06-23-26HowtocalibrateZoffsetusingOctoPrint_0.png","tag":["Tech"],"readingTime":2}],"page":"14","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true},"page":"/posts/[page]","query":{"page":"14"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>