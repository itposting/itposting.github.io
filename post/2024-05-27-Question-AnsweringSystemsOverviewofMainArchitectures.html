<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>질문-응답 시스템 주요 아키텍처 개요 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="질문-응답 시스템 주요 아키텍처 개요 | itposting" data-gatsby-head="true"/><meta property="og:title" content="질문-응답 시스템 주요 아키텍처 개요 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures" data-gatsby-head="true"/><meta name="twitter:title" content="질문-응답 시스템 주요 아키텍처 개요 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 15:08" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-0fd008072af5a644.js" defer=""></script><script src="/_next/static/kNTo-t2jvQG5kfHDWIcB-/_buildManifest.js" defer=""></script><script src="/_next/static/kNTo-t2jvQG5kfHDWIcB-/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">질문-응답 시스템 주요 아키텍처 개요</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="질문-응답 시스템 주요 아키텍처 개요" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>확장 가능한 정보 검색 시스템을 구축하는 디자인 방식 탐색</h2>
<p><img src="/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_0.png" alt="Question-AnsweringSystemsOverviewofMainArchitectures"></p>
<h1>소개</h1>
<p>최근 몇 년 동안 질문-응답 애플리케이션이 강력하게 등장했습니다. 현대적인 검색 엔진, 챗봇 또는 단순히 대량의 테마 데이터에서 관련 정보를 검색하는 애플리케이션 등 어디에서나 찾을 수 있습니다.</p>
<p>이름에서 알 수 있듯이 QA 응용 프로그램의 목적은 텍스트 단락에서 주어진 질문에 대한 가장 적합한 답변을 검색하는 것입니다. 처음 몇 가지 방법은 키워드 또는 정규 표현식을 사용한 단순한 검색으로 이뤄졌습니다. 당연히 이러한 접근 방식은 최적이 아닙니다: 질문이나 텍스트에 오타가 있을 수 있습니다. 게다가, 정규 표현식은 쿼리에서 주어진 단어와 관련이 높은 유의어를 감지할 수 없습니다. 이러한 접근 방식은 결과적으로, 트랜스포머와 벡터 데이터베이스 시대에 특히 강력한 새로운 방법론으로 대체되었습니다.</p>
<p>이 기사에서는 현대적이고 확장 가능한 QA 응용 프로그램을 구축하기 위한 세 가지 주요 설계 접근 방식을 다룹니다.</p>
<p><img src="/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_1.png" alt="이미지"></p>
<h1>추출형 QA</h1>
<p>추출형 QA 시스템은 세 가지 구성 요소로 구성되어 있습니다:</p>
<ul>
<li>검색기 (Retriever)</li>
<li>데이터베이스 (Database)</li>
<li>리더 (Reader)</li>
</ul>
<p><img src="/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_2.png" alt="이미지"></p>
<p>먼저, 질문이 검색기에 입력됩니다. 검색기의 목표는 질문에 해당하는 임베딩을 반환하는 것입니다. 간단한 벡터화 방법인 TF-IDF, BM-25부터 더 복잡한 모델까지 다양한 구현이 있을 수 있습니다. 대부분의 경우 트랜스포머와 같은 모델 (BERT)이 검색기에 통합됩니다. 단순한 단어 빈도수만을 의존하는 날것한 접근 방식과는 달리, 언어 모델은 텍스트의 의미를 캡처할 수 있는 밀집된 임베딩을 구축할 수 있습니다.</p>
<p>질문에서 쿼리 벡터를 얻은 후, 외부 문서 모음에서 가장 유사한 벡터를 찾는 데 사용됩니다. 각 문서에는 질문에 대한 답변이 포함될 확률이 있습니다. 보통 문서 모음은 학습 단계에서 처리되어 리트리버에 전달되어 해당 문서에 대한 임베딩을 출력합니다. 이러한 임베딩은 일반적으로 효과적인 검색을 제공할 수 있는 데이터베이스에 저장됩니다.</p>
<p>쿼리 벡터와 가장 유사한 상위 k개의 데이터베이스 벡터를 검색함으로써, 원래 텍스트 표현을 사용하여 다른 구성 요소인 리더가 답변을 찾습니다. 리더는 초기 질문을 취하고 k개의 검색된 문서 각각에서 텍스트 단락에서 답변을 추출하고 이 답변이 올바른 확률을 반환합니다. 가장 높은 확률을 갖는 답변이 마지막으로 독점 QA 시스템에서 반환됩니다.</p>
<h1>오픈 생성형 QA</h1>
<p>오픈 생성형 QA는 추출형 QA와 정확히 동일한 프레임워크를 따릅니다. 단, 리더 대신 제너레이터를 사용한다는 점에서 차이가 있습니다. 리더와 달리 제너레이터는 텍스트 단락에서 답변을 추출하지 않습니다. 대신, 질문과 텍스트 단락에서 제공된 정보를 사용하여 답변이 생성됩니다. 추출형 QA의 경우와 마찬가지로 가장 높은 확률을 갖는 답변이 최종 답변으로 선택됩니다.</p>
<p><img src="/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_3.png" alt="Question-Answering Systems Overview of Main Architectures"></p>
<p>비슷한 구조를 가지고 있기 때문에, 추출형 또는 개방적 생성 구조를 사용하는 것이 더 나은 시점에 대한 질문이 생길 수 있습니다. 독자 모델이 상대적 정보를 포함한 텍스트 단락에 직접 액세스할 수 있는 경우, 일반적으로 정확하고 간결한 답변을 검색하는 데 충분히 똑똑합니다. 반면에, 대부분의 경우 생생 생성 모델은 주어진 맥락에 대해 더 긴 범용 정보를 생성하는 경향이 있습니다. 이는 질문이 개방형 형태로 제시될 때 유익할 수 있지만, 짧거나 정확한 답변이 예상되는 상황에는 해당되지 않을 수 있습니다.</p>
<h2>검색 보조 생성</h2>
<p>최근 기계 학습에서 "검색 보조 생성" 또는 "RAG"라는 용어의 인기가 급증했습니다. 간단히 말하면, 이는 개방형 생성 QA 시스템에 기반을 둔 LLM 응용 프로그램을 생성하는 프레임워크입니다.</p>
<p>경우에 따라서, LLM 응용 프로그램이 여러 지식 도메인과 작동하는 경우, RAG 검색기는 주어진 쿼리에 가장 관련있는 지식 도메인을 식별하려는 보조 단계를 추가할 수 있습니다. 식별된 도메인에 따라 검색기는 다양한 작업을 수행할 수 있습니다. 예를 들어, 특정 도메인에 속하는 쿼리의 경우 해당 도메인의 벡터 데이터베이스를 사용하여 쿼리에 가장 관련있는 정보를 검색할 수 있습니다.</p>
<p>이 기술은 모든 문서가 아닌 특정 문서 하위 집합을 통해 검색하기 때문에 검색 프로세스를 더 빠르게 만듭니다. 게다가, 검색을 더 신뢰할 수 있게 만들 수 있습니다. 왜냐하면 최종 검색된 컨텍스트가 더 많은 관련 문서에서 구성되기 때문입니다.</p>
<p><img src="/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_4.png" alt="이미지"></p>
<h2>닫힌 생성 QA</h2>
<p>닫힌 생성형 QA 시스템은 외부 정보에 액세스할 수 없으며 질문에서 제공된 정보만 사용하여 답변을 생성합니다.</p>
<p><img src="/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_5.png" alt="이미지"></p>
<p>닫힌 QA 시스템의 명백한 이점은 대규모 외부 문서 집합을 검색할 필요가 없어지므로 파이프라인 시간을 줄일 수 있다는 점입니다. 그러나 교육 및 정확도 측면에서는 비용이 발생합니다: 생성기는 충분히 강력하고 적절한 답변을 생성할 수 있도록 충분한 학습 지식을 갖추어야 합니다.</p>
<p>닫힌 생성형 QA 파이프라인은 다른 단점도 있습니다. 생성기는 교육을 받은 데이터에 후에 나타난 정보를 알지 못합니다. 이 문제를 해결하기 위해 생성기는 최신 데이터셋에 다시 교육을 받을 수 있습니다. 그러나 생성기는 일반적으로 수백만 또는 수십억 개의 매개변수를 가지고 있기 때문에 이러한 교육은 매우 많은 자원을 필요로 합니다. 이와 비교하여 추출형 QA 및 개방형 생성형 QA 시스템으로 동일한 문제를 다루는 것은 훨씬 간단합니다. 벡터 데이터베이스에 새로운 콘텍스트 데이터를 추가하는 것만으로 충분합니다.</p>
<p>대부분의 경우 일반적인 질문이 있는 애플리케이션에서는 폐쇄형 생성 접근 방식이 사용됩니다. 매우 구체적인 도메인의 경우, 폐쇄형 생성 모델의 성능이 저하되는 경향이 있습니다.</p>
<h1>결론</h1>
<p>본 문서에서 QA 시스템 구축을 위한 세 가지 주요 접근 방법을 발견했습니다. 이들 중에서 절대적인 승자는 없습니다. 각각이 각자의 장단점을 갖고 있습니다. 그러므로 먼저 입력 문제를 분석하고 올바른 QA 아키텍처 유형을 선택하여 더 나은 성능을 내도록 하는 것이 선행되어야 합니다.</p>
<p>머신 러닝 분야에서 Open Generative QA 아키텍처가 현재 트렌드로 떠오르고 있으며, 특히 최근에 등장한 혁신적인 RAG 기술들과 함께 그 인기가 높아지고 있습니다. NLP 엔지니어라면 지금 당장 RAG 시스템에 주목하는 것이 좋습니다. 이 시스템들은 최근에 엄청난 속도로 발전하고 있습니다.</p>
<h1>자료</h1>
<ul>
<li>질의 응답 | Hugging Face</li>
</ul>
<p>모든 이미지는 특별히 언급되지 않는 한 저자에 의해 제공됩니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"질문-응답 시스템 주요 아키텍처 개요","description":"","date":"2024-05-27 15:08","slug":"2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures","content":"\n## 확장 가능한 정보 검색 시스템을 구축하는 디자인 방식 탐색\n\n![Question-AnsweringSystemsOverviewofMainArchitectures](/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_0.png)\n\n# 소개\n\n최근 몇 년 동안 질문-응답 애플리케이션이 강력하게 등장했습니다. 현대적인 검색 엔진, 챗봇 또는 단순히 대량의 테마 데이터에서 관련 정보를 검색하는 애플리케이션 등 어디에서나 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이름에서 알 수 있듯이 QA 응용 프로그램의 목적은 텍스트 단락에서 주어진 질문에 대한 가장 적합한 답변을 검색하는 것입니다. 처음 몇 가지 방법은 키워드 또는 정규 표현식을 사용한 단순한 검색으로 이뤄졌습니다. 당연히 이러한 접근 방식은 최적이 아닙니다: 질문이나 텍스트에 오타가 있을 수 있습니다. 게다가, 정규 표현식은 쿼리에서 주어진 단어와 관련이 높은 유의어를 감지할 수 없습니다. 이러한 접근 방식은 결과적으로, 트랜스포머와 벡터 데이터베이스 시대에 특히 강력한 새로운 방법론으로 대체되었습니다.\n\n이 기사에서는 현대적이고 확장 가능한 QA 응용 프로그램을 구축하기 위한 세 가지 주요 설계 접근 방식을 다룹니다.\n\n![이미지](/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_1.png)\n\n# 추출형 QA\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n추출형 QA 시스템은 세 가지 구성 요소로 구성되어 있습니다:\n\n- 검색기 (Retriever)\n- 데이터베이스 (Database)\n- 리더 (Reader)\n\n![이미지](/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_2.png)\n\n먼저, 질문이 검색기에 입력됩니다. 검색기의 목표는 질문에 해당하는 임베딩을 반환하는 것입니다. 간단한 벡터화 방법인 TF-IDF, BM-25부터 더 복잡한 모델까지 다양한 구현이 있을 수 있습니다. 대부분의 경우 트랜스포머와 같은 모델 (BERT)이 검색기에 통합됩니다. 단순한 단어 빈도수만을 의존하는 날것한 접근 방식과는 달리, 언어 모델은 텍스트의 의미를 캡처할 수 있는 밀집된 임베딩을 구축할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n질문에서 쿼리 벡터를 얻은 후, 외부 문서 모음에서 가장 유사한 벡터를 찾는 데 사용됩니다. 각 문서에는 질문에 대한 답변이 포함될 확률이 있습니다. 보통 문서 모음은 학습 단계에서 처리되어 리트리버에 전달되어 해당 문서에 대한 임베딩을 출력합니다. 이러한 임베딩은 일반적으로 효과적인 검색을 제공할 수 있는 데이터베이스에 저장됩니다.\n\n쿼리 벡터와 가장 유사한 상위 k개의 데이터베이스 벡터를 검색함으로써, 원래 텍스트 표현을 사용하여 다른 구성 요소인 리더가 답변을 찾습니다. 리더는 초기 질문을 취하고 k개의 검색된 문서 각각에서 텍스트 단락에서 답변을 추출하고 이 답변이 올바른 확률을 반환합니다. 가장 높은 확률을 갖는 답변이 마지막으로 독점 QA 시스템에서 반환됩니다.\n\n# 오픈 생성형 QA\n\n오픈 생성형 QA는 추출형 QA와 정확히 동일한 프레임워크를 따릅니다. 단, 리더 대신 제너레이터를 사용한다는 점에서 차이가 있습니다. 리더와 달리 제너레이터는 텍스트 단락에서 답변을 추출하지 않습니다. 대신, 질문과 텍스트 단락에서 제공된 정보를 사용하여 답변이 생성됩니다. 추출형 QA의 경우와 마찬가지로 가장 높은 확률을 갖는 답변이 최종 답변으로 선택됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Question-Answering Systems Overview of Main Architectures](/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_3.png)\n\n비슷한 구조를 가지고 있기 때문에, 추출형 또는 개방적 생성 구조를 사용하는 것이 더 나은 시점에 대한 질문이 생길 수 있습니다. 독자 모델이 상대적 정보를 포함한 텍스트 단락에 직접 액세스할 수 있는 경우, 일반적으로 정확하고 간결한 답변을 검색하는 데 충분히 똑똑합니다. 반면에, 대부분의 경우 생생 생성 모델은 주어진 맥락에 대해 더 긴 범용 정보를 생성하는 경향이 있습니다. 이는 질문이 개방형 형태로 제시될 때 유익할 수 있지만, 짧거나 정확한 답변이 예상되는 상황에는 해당되지 않을 수 있습니다.\n\n## 검색 보조 생성\n\n최근 기계 학습에서 \"검색 보조 생성\" 또는 \"RAG\"라는 용어의 인기가 급증했습니다. 간단히 말하면, 이는 개방형 생성 QA 시스템에 기반을 둔 LLM 응용 프로그램을 생성하는 프레임워크입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n경우에 따라서, LLM 응용 프로그램이 여러 지식 도메인과 작동하는 경우, RAG 검색기는 주어진 쿼리에 가장 관련있는 지식 도메인을 식별하려는 보조 단계를 추가할 수 있습니다. 식별된 도메인에 따라 검색기는 다양한 작업을 수행할 수 있습니다. 예를 들어, 특정 도메인에 속하는 쿼리의 경우 해당 도메인의 벡터 데이터베이스를 사용하여 쿼리에 가장 관련있는 정보를 검색할 수 있습니다.\n\n이 기술은 모든 문서가 아닌 특정 문서 하위 집합을 통해 검색하기 때문에 검색 프로세스를 더 빠르게 만듭니다. 게다가, 검색을 더 신뢰할 수 있게 만들 수 있습니다. 왜냐하면 최종 검색된 컨텍스트가 더 많은 관련 문서에서 구성되기 때문입니다.\n\n![이미지](/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_4.png)\n\n## 닫힌 생성 QA\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n닫힌 생성형 QA 시스템은 외부 정보에 액세스할 수 없으며 질문에서 제공된 정보만 사용하여 답변을 생성합니다.\n\n![이미지](/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_5.png)\n\n닫힌 QA 시스템의 명백한 이점은 대규모 외부 문서 집합을 검색할 필요가 없어지므로 파이프라인 시간을 줄일 수 있다는 점입니다. 그러나 교육 및 정확도 측면에서는 비용이 발생합니다: 생성기는 충분히 강력하고 적절한 답변을 생성할 수 있도록 충분한 학습 지식을 갖추어야 합니다.\n\n닫힌 생성형 QA 파이프라인은 다른 단점도 있습니다. 생성기는 교육을 받은 데이터에 후에 나타난 정보를 알지 못합니다. 이 문제를 해결하기 위해 생성기는 최신 데이터셋에 다시 교육을 받을 수 있습니다. 그러나 생성기는 일반적으로 수백만 또는 수십억 개의 매개변수를 가지고 있기 때문에 이러한 교육은 매우 많은 자원을 필요로 합니다. 이와 비교하여 추출형 QA 및 개방형 생성형 QA 시스템으로 동일한 문제를 다루는 것은 훨씬 간단합니다. 벡터 데이터베이스에 새로운 콘텍스트 데이터를 추가하는 것만으로 충분합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 경우 일반적인 질문이 있는 애플리케이션에서는 폐쇄형 생성 접근 방식이 사용됩니다. 매우 구체적인 도메인의 경우, 폐쇄형 생성 모델의 성능이 저하되는 경향이 있습니다.\n\n# 결론\n\n본 문서에서 QA 시스템 구축을 위한 세 가지 주요 접근 방법을 발견했습니다. 이들 중에서 절대적인 승자는 없습니다. 각각이 각자의 장단점을 갖고 있습니다. 그러므로 먼저 입력 문제를 분석하고 올바른 QA 아키텍처 유형을 선택하여 더 나은 성능을 내도록 하는 것이 선행되어야 합니다.\n\n머신 러닝 분야에서 Open Generative QA 아키텍처가 현재 트렌드로 떠오르고 있으며, 특히 최근에 등장한 혁신적인 RAG 기술들과 함께 그 인기가 높아지고 있습니다. NLP 엔지니어라면 지금 당장 RAG 시스템에 주목하는 것이 좋습니다. 이 시스템들은 최근에 엄청난 속도로 발전하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 자료\n\n- 질의 응답 | Hugging Face\n\n모든 이미지는 특별히 언급되지 않는 한 저자에 의해 제공됩니다.\n","ogImage":{"url":"/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_0.png"},"coverImage":"/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e확장 가능한 정보 검색 시스템을 구축하는 디자인 방식 탐색\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_0.png\" alt=\"Question-AnsweringSystemsOverviewofMainArchitectures\"\u003e\u003c/p\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e최근 몇 년 동안 질문-응답 애플리케이션이 강력하게 등장했습니다. 현대적인 검색 엔진, 챗봇 또는 단순히 대량의 테마 데이터에서 관련 정보를 검색하는 애플리케이션 등 어디에서나 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이름에서 알 수 있듯이 QA 응용 프로그램의 목적은 텍스트 단락에서 주어진 질문에 대한 가장 적합한 답변을 검색하는 것입니다. 처음 몇 가지 방법은 키워드 또는 정규 표현식을 사용한 단순한 검색으로 이뤄졌습니다. 당연히 이러한 접근 방식은 최적이 아닙니다: 질문이나 텍스트에 오타가 있을 수 있습니다. 게다가, 정규 표현식은 쿼리에서 주어진 단어와 관련이 높은 유의어를 감지할 수 없습니다. 이러한 접근 방식은 결과적으로, 트랜스포머와 벡터 데이터베이스 시대에 특히 강력한 새로운 방법론으로 대체되었습니다.\u003c/p\u003e\n\u003cp\u003e이 기사에서는 현대적이고 확장 가능한 QA 응용 프로그램을 구축하기 위한 세 가지 주요 설계 접근 방식을 다룹니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e추출형 QA\u003c/h1\u003e\n\u003cp\u003e추출형 QA 시스템은 세 가지 구성 요소로 구성되어 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e검색기 (Retriever)\u003c/li\u003e\n\u003cli\u003e데이터베이스 (Database)\u003c/li\u003e\n\u003cli\u003e리더 (Reader)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e먼저, 질문이 검색기에 입력됩니다. 검색기의 목표는 질문에 해당하는 임베딩을 반환하는 것입니다. 간단한 벡터화 방법인 TF-IDF, BM-25부터 더 복잡한 모델까지 다양한 구현이 있을 수 있습니다. 대부분의 경우 트랜스포머와 같은 모델 (BERT)이 검색기에 통합됩니다. 단순한 단어 빈도수만을 의존하는 날것한 접근 방식과는 달리, 언어 모델은 텍스트의 의미를 캡처할 수 있는 밀집된 임베딩을 구축할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e질문에서 쿼리 벡터를 얻은 후, 외부 문서 모음에서 가장 유사한 벡터를 찾는 데 사용됩니다. 각 문서에는 질문에 대한 답변이 포함될 확률이 있습니다. 보통 문서 모음은 학습 단계에서 처리되어 리트리버에 전달되어 해당 문서에 대한 임베딩을 출력합니다. 이러한 임베딩은 일반적으로 효과적인 검색을 제공할 수 있는 데이터베이스에 저장됩니다.\u003c/p\u003e\n\u003cp\u003e쿼리 벡터와 가장 유사한 상위 k개의 데이터베이스 벡터를 검색함으로써, 원래 텍스트 표현을 사용하여 다른 구성 요소인 리더가 답변을 찾습니다. 리더는 초기 질문을 취하고 k개의 검색된 문서 각각에서 텍스트 단락에서 답변을 추출하고 이 답변이 올바른 확률을 반환합니다. 가장 높은 확률을 갖는 답변이 마지막으로 독점 QA 시스템에서 반환됩니다.\u003c/p\u003e\n\u003ch1\u003e오픈 생성형 QA\u003c/h1\u003e\n\u003cp\u003e오픈 생성형 QA는 추출형 QA와 정확히 동일한 프레임워크를 따릅니다. 단, 리더 대신 제너레이터를 사용한다는 점에서 차이가 있습니다. 리더와 달리 제너레이터는 텍스트 단락에서 답변을 추출하지 않습니다. 대신, 질문과 텍스트 단락에서 제공된 정보를 사용하여 답변이 생성됩니다. 추출형 QA의 경우와 마찬가지로 가장 높은 확률을 갖는 답변이 최종 답변으로 선택됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_3.png\" alt=\"Question-Answering Systems Overview of Main Architectures\"\u003e\u003c/p\u003e\n\u003cp\u003e비슷한 구조를 가지고 있기 때문에, 추출형 또는 개방적 생성 구조를 사용하는 것이 더 나은 시점에 대한 질문이 생길 수 있습니다. 독자 모델이 상대적 정보를 포함한 텍스트 단락에 직접 액세스할 수 있는 경우, 일반적으로 정확하고 간결한 답변을 검색하는 데 충분히 똑똑합니다. 반면에, 대부분의 경우 생생 생성 모델은 주어진 맥락에 대해 더 긴 범용 정보를 생성하는 경향이 있습니다. 이는 질문이 개방형 형태로 제시될 때 유익할 수 있지만, 짧거나 정확한 답변이 예상되는 상황에는 해당되지 않을 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e검색 보조 생성\u003c/h2\u003e\n\u003cp\u003e최근 기계 학습에서 \"검색 보조 생성\" 또는 \"RAG\"라는 용어의 인기가 급증했습니다. 간단히 말하면, 이는 개방형 생성 QA 시스템에 기반을 둔 LLM 응용 프로그램을 생성하는 프레임워크입니다.\u003c/p\u003e\n\u003cp\u003e경우에 따라서, LLM 응용 프로그램이 여러 지식 도메인과 작동하는 경우, RAG 검색기는 주어진 쿼리에 가장 관련있는 지식 도메인을 식별하려는 보조 단계를 추가할 수 있습니다. 식별된 도메인에 따라 검색기는 다양한 작업을 수행할 수 있습니다. 예를 들어, 특정 도메인에 속하는 쿼리의 경우 해당 도메인의 벡터 데이터베이스를 사용하여 쿼리에 가장 관련있는 정보를 검색할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 기술은 모든 문서가 아닌 특정 문서 하위 집합을 통해 검색하기 때문에 검색 프로세스를 더 빠르게 만듭니다. 게다가, 검색을 더 신뢰할 수 있게 만들 수 있습니다. 왜냐하면 최종 검색된 컨텍스트가 더 많은 관련 문서에서 구성되기 때문입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e닫힌 생성 QA\u003c/h2\u003e\n\u003cp\u003e닫힌 생성형 QA 시스템은 외부 정보에 액세스할 수 없으며 질문에서 제공된 정보만 사용하여 답변을 생성합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e닫힌 QA 시스템의 명백한 이점은 대규모 외부 문서 집합을 검색할 필요가 없어지므로 파이프라인 시간을 줄일 수 있다는 점입니다. 그러나 교육 및 정확도 측면에서는 비용이 발생합니다: 생성기는 충분히 강력하고 적절한 답변을 생성할 수 있도록 충분한 학습 지식을 갖추어야 합니다.\u003c/p\u003e\n\u003cp\u003e닫힌 생성형 QA 파이프라인은 다른 단점도 있습니다. 생성기는 교육을 받은 데이터에 후에 나타난 정보를 알지 못합니다. 이 문제를 해결하기 위해 생성기는 최신 데이터셋에 다시 교육을 받을 수 있습니다. 그러나 생성기는 일반적으로 수백만 또는 수십억 개의 매개변수를 가지고 있기 때문에 이러한 교육은 매우 많은 자원을 필요로 합니다. 이와 비교하여 추출형 QA 및 개방형 생성형 QA 시스템으로 동일한 문제를 다루는 것은 훨씬 간단합니다. 벡터 데이터베이스에 새로운 콘텍스트 데이터를 추가하는 것만으로 충분합니다.\u003c/p\u003e\n\u003cp\u003e대부분의 경우 일반적인 질문이 있는 애플리케이션에서는 폐쇄형 생성 접근 방식이 사용됩니다. 매우 구체적인 도메인의 경우, 폐쇄형 생성 모델의 성능이 저하되는 경향이 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e본 문서에서 QA 시스템 구축을 위한 세 가지 주요 접근 방법을 발견했습니다. 이들 중에서 절대적인 승자는 없습니다. 각각이 각자의 장단점을 갖고 있습니다. 그러므로 먼저 입력 문제를 분석하고 올바른 QA 아키텍처 유형을 선택하여 더 나은 성능을 내도록 하는 것이 선행되어야 합니다.\u003c/p\u003e\n\u003cp\u003e머신 러닝 분야에서 Open Generative QA 아키텍처가 현재 트렌드로 떠오르고 있으며, 특히 최근에 등장한 혁신적인 RAG 기술들과 함께 그 인기가 높아지고 있습니다. NLP 엔지니어라면 지금 당장 RAG 시스템에 주목하는 것이 좋습니다. 이 시스템들은 최근에 엄청난 속도로 발전하고 있습니다.\u003c/p\u003e\n\u003ch1\u003e자료\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e질의 응답 | Hugging Face\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e모든 이미지는 특별히 언급되지 않는 한 저자에 의해 제공됩니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-Question-AnsweringSystemsOverviewofMainArchitectures"},"buildId":"kNTo-t2jvQG5kfHDWIcB-","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>