<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>아두이노에서 머신 러닝 시작하기  아두이노 나노 33 BLE 센스 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="아두이노에서 머신 러닝 시작하기  아두이노 나노 33 BLE 센스 | itposting" data-gatsby-head="true"/><meta property="og:title" content="아두이노에서 머신 러닝 시작하기  아두이노 나노 33 BLE 센스 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense" data-gatsby-head="true"/><meta name="twitter:title" content="아두이노에서 머신 러닝 시작하기  아두이노 나노 33 BLE 센스 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 05:54" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-0fd008072af5a644.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_buildManifest.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">아두이노에서 머신 러닝 시작하기  아두이노 나노 33 BLE 센스</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="아두이노에서 머신 러닝 시작하기  아두이노 나노 33 BLE 센스" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_0.png" alt="image"></p>
<p>이 포괄적인 자습서에서는 Arduino Nano 33 BLE Sense를 중점으로 한 Arduino 장치에 머신러닝 모델을 배치하는 흥미로운 세계에 대해 살펴볼 것입니다.</p>
<p>다음은 Arduino Nano 33 BLE Sense에 머신러닝 모델을 배포하는 단계 목록입니다:</p>
<ul>
<li>Arduino IDE 설치</li>
<li>Mbed OS Core for Nano Boards 설치</li>
<li>Harvard_TinyMLx 라이브러리 설치</li>
<li>Google Colab에서 TensorFlow를 사용하여 머신러닝 모델 생성</li>
<li>훈련된 모델을 TensorFlow Lite로 변환</li>
<li>Arduino 헤더 파일에 모델 인코딩</li>
<li>Arduino에 ML 모델 배포</li>
</ul>
<p><img src="/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_1.png" alt="이미지"></p>
<ol>
<li>아두이노 IDE 설치</li>
</ol>
<p>다음 가이드를 따라 주세요: <a href="https://support.arduino.cc/hc/en-us/articles/360019833020-Download-and-install-Arduino-IDE" rel="nofollow" target="_blank">아두이노 IDE 다운로드 및 설치</a>.</p>
<ol start="2">
<li>나노 보드용 Mbed OS 코어 설치</li>
</ol>
<p>아두이노로 이동해서 Tools → Board → Board Manager로 이동해 주세요.</p>
<p>"Arduino Mbed OS Nano Boards"를 설치해 주세요.</p>
<p><img src="/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_2.png" alt="이미지"></p>
<ol start="3">
<li>Harvard_TinyMLx 라이브러리 설치</li>
</ol>
<p>Tools -> Manage Libraries 로 이동해주세요.</p>
<p>"Harvard_TinyMLx" 라이브러리를 설치하세요.</p>
<p><img src="/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_3.png" alt="이미지"></p>
<ol start="4">
<li>Google Colab에서 TensorFlow를 사용하여 머신러닝 모델을 생성하세요.</li>
</ol>
<p>여기서는 TensorFlow에서 선형 회귀를 사용하여 간단한 날씨 예측 기계 학습 모델을 만들고 있어요. 입력 특성은 온도와 습도이며, 날씨 요약은 예상 출력입니다. 이 모델은 IoT에서 기계 학습 통합을 보여주기 위한 것이며, 정확한 날씨 예측을 최적화한 것이 아니라는 점을 유의해 주세요.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">model_selection</span> <span class="hljs-keyword">import</span> train_test_split
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">from</span> tensorflow <span class="hljs-keyword">import</span> keras

# 데이터셋 불러오기
weather_df = pd.<span class="hljs-title function_">read_csv</span>(<span class="hljs-string">'weatherHistory.csv'</span>)

weather_df.<span class="hljs-title function_">head</span>()

weather_df.<span class="hljs-title function_">info</span>()

weather_df.<span class="hljs-title function_">keys</span>()

weather_df[<span class="hljs-string">'Summary'</span>].<span class="hljs-title function_">unique</span>()

#weather_df[<span class="hljs-string">'Summary'</span>].<span class="hljs-title function_">unique</span>()
factorized_mapping = <span class="hljs-title function_">dict</span>(<span class="hljs-title function_">enumerate</span>(weather_df[<span class="hljs-string">'Summary'</span>].<span class="hljs-title function_">unique</span>()))
weather_df[<span class="hljs-string">'Summary'</span>] = pd.<span class="hljs-title function_">factorize</span>(weather_df[<span class="hljs-string">'Summary'</span>])[<span class="hljs-number">0</span>]
<span class="hljs-title function_">print</span>(factorized_mapping)

# 특성과 레이블 정의
features = weather_df[[<span class="hljs-string">'Temperature (C)'</span>,<span class="hljs-string">'Humidity'</span>]]
labels = weather_df[[<span class="hljs-string">'Summary'</span>]]

# 훈련 및 테스트 데이터 분할
features_train, features_test, labels_train, labels_test = <span class="hljs-title function_">train_test_split</span>(features, labels, test_size=<span class="hljs-number">0.3</span>, random_state=<span class="hljs-number">0</span>)

# <span class="hljs-title class_">Keras</span>를 사용하여 선형 회귀 모델 만들기
model = keras.<span class="hljs-title class_">Sequential</span>([
    keras.<span class="hljs-property">layers</span>.<span class="hljs-title class_">Dense</span>(units=<span class="hljs-number">1</span>, input_shape=(<span class="hljs-number">2</span>,))  # 두 개의 입력 특성, 하나의 출력 유닛
])

# 모델 컴파일
model.<span class="hljs-title function_">compile</span>(optimizer=<span class="hljs-string">'Adam'</span>, loss=<span class="hljs-string">'mean_squared_error'</span>)  # 확률적 경사 하강법 (<span class="hljs-variable constant_">SGD</span>) 옵티마이저 사용

# 모델 훈련
model.<span class="hljs-title function_">fit</span>(
    features_train,labels_train,
    epochs=<span class="hljs-number">6</span>,
    validation_data=(features_test, labels_test)
    )

predictions = model.<span class="hljs-title function_">predict</span>(features_test)
<span class="hljs-title function_">print</span>(predictions)

rounded_predictions = [<span class="hljs-title function_">round</span>(prediction[<span class="hljs-number">0</span>]) <span class="hljs-keyword">for</span> prediction <span class="hljs-keyword">in</span> predictions]
original_predictions = [factorized_mapping[prediction] <span class="hljs-keyword">for</span> prediction <span class="hljs-keyword">in</span> rounded_predictions]
original_predictions

rmse = np.<span class="hljs-title function_">sqrt</span>(((labels_test - predictions) ** <span class="hljs-number">2</span>).<span class="hljs-title function_">mean</span>())
<span class="hljs-title function_">print</span>(<span class="hljs-string">"Root Mean Squared Error (RMSE):"</span>, rmse)
</code></pre>
<ol start="5">
<li>훈련된 모델을 TensorFlow Lite로 변환하기</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-string">""</span><span class="hljs-string">"# 훈련된 모델을 텐서 플로 Lite로 변환하기"</span><span class="hljs-string">""</span>

<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

# 양자화 없이 모델을 <span class="hljs-title class_">TensorFlow</span> <span class="hljs-title class_">Lite</span> 형식으로 변환
converter = tf.<span class="hljs-property">lite</span>.<span class="hljs-property">TFLiteConverter</span>.<span class="hljs-title function_">from_keras_model</span>(model)
tflite_model = converter.<span class="hljs-title function_">convert</span>()

# 모델을 디스크에 저장
<span class="hljs-title function_">open</span>(<span class="hljs-string">"weather_model.tflite"</span>, <span class="hljs-string">"wb"</span>).<span class="hljs-title function_">write</span>(tflite_model)

<span class="hljs-keyword">import</span> os
basic_model_size = os.<span class="hljs-property">path</span>.<span class="hljs-title function_">getsize</span>(<span class="hljs-string">"weather_model.tflite"</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">"모델 크기는 %d바이트입니다"</span> % basic_model_size)
</code></pre>
<ol start="6">
<li>아두이노 헤더 파일에 모델 인코딩</li>
</ol>
<p>"아두이노 헤더 파일에 모델 인코딩"은 일반적으로 TensorFlow Lite와 같은 형식의 머신 러닝 모델을 아두이노 스케치 내에 포함할 수 있는 특정 형식으로 변환하는 과정을 의미합니다. 이 과정은 모델의 수치적 가중치와 아키텍처를 아두이노 코드의 헤더 파일(.h)로 쉽게 포함할 수 있도록 변환하는 것을 포함합니다.</p>
<p>이 헤더 파일은 아두이노 스케치가 외부 종속성이나 별도의 모델 파일 없이 추론에 사용할 수 있도록 모델 데이터를 포함하도록 되어 있습니다. 이 형식으로 모델을 인코딩함으로써 자원 제한적인 기기인 아두이노 같은 장치에 머신 러닝 모델을 배포할 때 아두이노 프로젝트가 외부 자원에 의존하지 않고 아두이노 보드에서 머신 러닝 모델을 직접 사용하여 예측하거나 작업을 수행할 수 있도록 할 수 있습니다. 아두이노와 같은 자원에 제한된 기기에 머신 러닝 모델을 배포할 때 중요한 단계입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-string">""</span><span class="hljs-string">"# 아두이노 헤더 파일에 모델 인코딩하기"</span><span class="hljs-string">""</span>

!echo <span class="hljs-string">"const unsigned char model[] = {"</span> > <span class="hljs-regexp">/content/m</span>odel.<span class="hljs-property">h</span>
!cat weather_model.<span class="hljs-property">tflite</span> | xxd -i      >> <span class="hljs-regexp">/content/m</span>odel.<span class="hljs-property">h</span>
!echo <span class="hljs-string">"};"</span>                              >> <span class="hljs-regexp">/content/m</span>odel.<span class="hljs-property">h</span>

<span class="hljs-keyword">import</span> os
model_h_size = os.<span class="hljs-property">path</span>.<span class="hljs-title function_">getsize</span>(<span class="hljs-string">"model.h"</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"헤더 파일인 model.h의 크기는 {model_h_size:,} 바이트입니다."</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">"\n사이드 패널을 열어보세요 (필요시 새로고침). 모델 파일인 model.h를 더블 클릭하여 다운로드하세요."</span>)
</code></pre>
<ol start="7">
<li>아두이노에 ML 모델 배포하기</li>
</ol>
<p>‘model.h’ 파일을 다운로드하고 또한 아두이노 스케치와 동일한 디렉토리에 저장하세요. 이 코드에서는 예측을 위해 샘플 온도 및 습도 값을 제공했습니다. 또한 센서에서 이러한 값을 읽어 실시간 예측을 할 수도 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">/*
  날씨 예측
  회로:
  - 아두이노 나노 33 BLE 또는 아두이노 나노 33 BLE Sense 보드.
  작성자: Jobin J
*/</span>


#include &#x3C;<span class="hljs-title class_">TensorFlowLite</span>.<span class="hljs-property">h</span>>
#include &#x3C;tensorflow/lite/micro/all_ops_resolver.<span class="hljs-property">h</span>>
#include &#x3C;tensorflow/lite/micro/micro_error_reporter.<span class="hljs-property">h</span>>
#include &#x3C;tensorflow/lite/micro/micro_interpreter.<span class="hljs-property">h</span>>
#include &#x3C;tensorflow/lite/schema/schema_generated.<span class="hljs-property">h</span>>
#include &#x3C;tensorflow/lite/version.<span class="hljs-property">h</span>>

#include <span class="hljs-string">"model.h"</span>


<span class="hljs-comment">// TensorFlow Lite (Micro)에 사용되는 전역 변수</span>
<span class="hljs-attr">tflite</span>::<span class="hljs-title class_">MicroErrorReporter</span> tflErrorReporter;

<span class="hljs-comment">// 모든 TFLM 오퍼레이션을 가져옵니다. 필요한 오퍼레이션만 가져와</span>
<span class="hljs-comment">// 스케치의 컴파일 크기를 줄이고자 한다면 이 줄을 제거하고</span>
<span class="hljs-comment">// 필요한 TFLM 오퍼레이션만 가져오실 수 있습니다.</span>
<span class="hljs-attr">tflite</span>::<span class="hljs-title class_">AllOpsResolver</span> tflOpsResolver;

<span class="hljs-keyword">const</span> <span class="hljs-attr">tflite</span>::<span class="hljs-title class_">Model</span>* tflModel = nullptr;
<span class="hljs-attr">tflite</span>::<span class="hljs-title class_">MicroInterpreter</span>* tflInterpreter = nullptr;
<span class="hljs-title class_">TfLiteTensor</span>* tflInputTensor = nullptr;
<span class="hljs-title class_">TfLiteTensor</span>* tflOutputTensor = nullptr;

<span class="hljs-comment">// TFLM을 위한 정적 메모리 버퍼를 생성합니다. 모델의 크기에 따라</span>
<span class="hljs-comment">// 조정이 필요할 수 있습니다.</span>
constexpr int tensorArenaSize = <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>;
byte tensorArena[tensorArenaSize] <span class="hljs-title function_">__attribute__</span>((<span class="hljs-title function_">aligned</span>(<span class="hljs-number">16</span>)));

<span class="hljs-comment">// 제스처 인덱스를 이름에 매핑하는 배열</span>
<span class="hljs-keyword">const</span> char* <span class="hljs-variable constant_">LABELS</span>[] = {
  <span class="hljs-string">"부분적으로 흐림"</span>, <span class="hljs-string">"대체로 흐림"</span>, <span class="hljs-string">"흐리고 흐림"</span>, <span class="hljs-string">"안개"</span>,
  <span class="hljs-string">"바람 부는 대체로 흐림"</span>, <span class="hljs-string">"맑음"</span>, <span class="hljs-string">"바람 부는 부분적으로 흐림"</span>,
  <span class="hljs-string">"바람 부는 흐리고 흐림"</span>, <span class="hljs-string">"습하고 대체로 흐림"</span>,
  <span class="hljs-string">"습하고 부분적으로 흐림"</span>, <span class="hljs-string">"바람 부는 안개 낀날"</span>, <span class="hljs-string">"바람 부는 흐리고 흐림"</span>,
  <span class="hljs-string">"바람 부는 안개"</span>, <span class="hljs-string">"바람 부는 부분적으로 흐림"</span>, <span class="hljs-string">"바람"</span>,
  <span class="hljs-string">"건조하고 부분적으로 흐림"</span>, <span class="hljs-string">"바람 부는 대체로 흐림"</span>,
  <span class="hljs-string">"위험한 바람 부는 부분적으로 흐림"</span>, <span class="hljs-string">"건조함"</span>, <span class="hljs-string">"바람"</span>,
  <span class="hljs-string">"습하고 흐리고 흐림"</span>, <span class="hljs-string">"가벼운 비"</span>, <span class="hljs-string">"이슬비"</span>, <span class="hljs-string">"바람 부는 건조한"</span>,
  <span class="hljs-string">"건조하고 대체로 흐림"</span>, <span class="hljs-string">"바람 부는 건조한"</span>, <span class="hljs-string">"비"</span>
};

#define <span class="hljs-variable constant_">NUM_LABELS</span> (<span class="hljs-title function_">sizeof</span>(<span class="hljs-variable constant_">LABELS</span>) / <span class="hljs-title function_">sizeof</span>(<span class="hljs-variable constant_">LABELS</span>[<span class="hljs-number">0</span>]))

<span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">begin</span>(<span class="hljs-number">9600</span>);
  <span class="hljs-keyword">while</span> (!<span class="hljs-title class_">Serial</span>);


  <span class="hljs-comment">// 모델 바이트 배열의 TFL 표현을 가져옵니다.</span>
  tflModel = <span class="hljs-attr">tflite</span>::<span class="hljs-title class_">GetModel</span>(model);
  <span class="hljs-keyword">if</span> (tflModel-><span class="hljs-title function_">version</span>() != <span class="hljs-variable constant_">TFLITE_SCHEMA_VERSION</span>) {
    <span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"모델 스키마 불일치!"</span>);
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);
  }

  <span class="hljs-comment">// 모델 실행을 위한 인터프리터 생성</span>
  tflInterpreter = <span class="hljs-keyword">new</span> <span class="hljs-attr">tflite</span>::<span class="hljs-title class_">MicroInterpreter</span>(tflModel, tflOpsResolver, tensorArena, tensorArenaSize, &#x26;tflErrorReporter);

  <span class="hljs-comment">// 모델의 입력 및 출력 텐서를 위한 메모리 할당</span>
  tflInterpreter-><span class="hljs-title class_">AllocateTensors</span>();

  <span class="hljs-comment">// 모델의 입력 및 출력 텐서를 위한 포인터 가져오기</span>
  tflInputTensor = tflInterpreter-><span class="hljs-title function_">input</span>(<span class="hljs-number">0</span>);
  tflOutputTensor = tflInterpreter-><span class="hljs-title function_">output</span>(<span class="hljs-number">0</span>);
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>) {
  float temperature = <span class="hljs-number">28.0</span>, humidity = <span class="hljs-number">50.0</span>;

  <span class="hljs-comment">// 입력 텐서</span>
  tflInputTensor->data.<span class="hljs-property">f</span>[<span class="hljs-number">0</span>] = temperature;
  tflInputTensor->data.<span class="hljs-property">f</span>[<span class="hljs-number">1</span>] = humidity;


  <span class="hljs-title class_">TfLiteStatus</span> invokeStatus = tflInterpreter-><span class="hljs-title class_">Invoke</span>();
  <span class="hljs-keyword">if</span> (invokeStatus != kTfLiteOk) {
    <span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"실행 실패!"</span>);
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-comment">// 모델의 출력 텐서 값 순회</span>
  <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-variable constant_">NUM_LABELS</span>; i++) {
    <span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">print</span>(<span class="hljs-variable constant_">LABELS</span>[i]);
    <span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">": "</span>);
    <span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">println</span>(tflOutputTensor->data.<span class="hljs-property">f</span>[i], <span class="hljs-number">6</span>);
  }

  <span class="hljs-title function_">delay</span>(<span class="hljs-number">5000</span>);
}
</code></pre>
<p>GitHub - Machine_Learning_Weather_Prediction</p>
<p>이제 시리얼 모니터에서 이렇게 출력을 볼 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_4.png" alt="이미지"></p>
<p>아두이노 나노 33 BLE Sense에서 기계 학습의 세계를 탐험하고 오늘부터 자신만의 흥미로운 프로젝트를 시작해보세요. 즐거운 코딩되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"아두이노에서 머신 러닝 시작하기  아두이노 나노 33 BLE 센스","description":"","date":"2024-06-19 05:54","slug":"2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense","content":"\n\n![image](/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_0.png)\n\n이 포괄적인 자습서에서는 Arduino Nano 33 BLE Sense를 중점으로 한 Arduino 장치에 머신러닝 모델을 배치하는 흥미로운 세계에 대해 살펴볼 것입니다.\n\n다음은 Arduino Nano 33 BLE Sense에 머신러닝 모델을 배포하는 단계 목록입니다:\n\n- Arduino IDE 설치\n- Mbed OS Core for Nano Boards 설치\n- Harvard_TinyMLx 라이브러리 설치\n- Google Colab에서 TensorFlow를 사용하여 머신러닝 모델 생성\n- 훈련된 모델을 TensorFlow Lite로 변환\n- Arduino 헤더 파일에 모델 인코딩\n- Arduino에 ML 모델 배포\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_1.png)\n\n1. 아두이노 IDE 설치\n\n다음 가이드를 따라 주세요: [아두이노 IDE 다운로드 및 설치](https://support.arduino.cc/hc/en-us/articles/360019833020-Download-and-install-Arduino-IDE).\n\n2. 나노 보드용 Mbed OS 코어 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아두이노로 이동해서 Tools → Board → Board Manager로 이동해 주세요.\n\n\"Arduino Mbed OS Nano Boards\"를 설치해 주세요.\n\n![이미지](/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_2.png)\n\n3. Harvard_TinyMLx 라이브러리 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nTools -\u003e Manage Libraries 로 이동해주세요.\n\n\"Harvard_TinyMLx\" 라이브러리를 설치하세요.\n\n![이미지](/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_3.png)\n\n4. Google Colab에서 TensorFlow를 사용하여 머신러닝 모델을 생성하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서는 TensorFlow에서 선형 회귀를 사용하여 간단한 날씨 예측 기계 학습 모델을 만들고 있어요. 입력 특성은 온도와 습도이며, 날씨 요약은 예상 출력입니다. 이 모델은 IoT에서 기계 학습 통합을 보여주기 위한 것이며, 정확한 날씨 예측을 최적화한 것이 아니라는 점을 유의해 주세요.\n\n```js\nfrom sklearn.model_selection import train_test_split\nimport pandas as pd\nimport numpy as np\nimport tensorflow as tf\nfrom tensorflow import keras\n\n# 데이터셋 불러오기\nweather_df = pd.read_csv('weatherHistory.csv')\n\nweather_df.head()\n\nweather_df.info()\n\nweather_df.keys()\n\nweather_df['Summary'].unique()\n\n#weather_df['Summary'].unique()\nfactorized_mapping = dict(enumerate(weather_df['Summary'].unique()))\nweather_df['Summary'] = pd.factorize(weather_df['Summary'])[0]\nprint(factorized_mapping)\n\n# 특성과 레이블 정의\nfeatures = weather_df[['Temperature (C)','Humidity']]\nlabels = weather_df[['Summary']]\n\n# 훈련 및 테스트 데이터 분할\nfeatures_train, features_test, labels_train, labels_test = train_test_split(features, labels, test_size=0.3, random_state=0)\n\n# Keras를 사용하여 선형 회귀 모델 만들기\nmodel = keras.Sequential([\n    keras.layers.Dense(units=1, input_shape=(2,))  # 두 개의 입력 특성, 하나의 출력 유닛\n])\n\n# 모델 컴파일\nmodel.compile(optimizer='Adam', loss='mean_squared_error')  # 확률적 경사 하강법 (SGD) 옵티마이저 사용\n\n# 모델 훈련\nmodel.fit(\n    features_train,labels_train,\n    epochs=6,\n    validation_data=(features_test, labels_test)\n    )\n\npredictions = model.predict(features_test)\nprint(predictions)\n\nrounded_predictions = [round(prediction[0]) for prediction in predictions]\noriginal_predictions = [factorized_mapping[prediction] for prediction in rounded_predictions]\noriginal_predictions\n\nrmse = np.sqrt(((labels_test - predictions) ** 2).mean())\nprint(\"Root Mean Squared Error (RMSE):\", rmse)\r\n```\n\n5. 훈련된 모델을 TensorFlow Lite로 변환하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\"\"\"# 훈련된 모델을 텐서 플로 Lite로 변환하기\"\"\"\n\nimport tensorflow as tf\n\n# 양자화 없이 모델을 TensorFlow Lite 형식으로 변환\nconverter = tf.lite.TFLiteConverter.from_keras_model(model)\ntflite_model = converter.convert()\n\n# 모델을 디스크에 저장\nopen(\"weather_model.tflite\", \"wb\").write(tflite_model)\n\nimport os\nbasic_model_size = os.path.getsize(\"weather_model.tflite\")\nprint(\"모델 크기는 %d바이트입니다\" % basic_model_size)\n```\n\n6. 아두이노 헤더 파일에 모델 인코딩\n\n\"아두이노 헤더 파일에 모델 인코딩\"은 일반적으로 TensorFlow Lite와 같은 형식의 머신 러닝 모델을 아두이노 스케치 내에 포함할 수 있는 특정 형식으로 변환하는 과정을 의미합니다. 이 과정은 모델의 수치적 가중치와 아키텍처를 아두이노 코드의 헤더 파일(.h)로 쉽게 포함할 수 있도록 변환하는 것을 포함합니다.\n\n이 헤더 파일은 아두이노 스케치가 외부 종속성이나 별도의 모델 파일 없이 추론에 사용할 수 있도록 모델 데이터를 포함하도록 되어 있습니다. 이 형식으로 모델을 인코딩함으로써 자원 제한적인 기기인 아두이노 같은 장치에 머신 러닝 모델을 배포할 때 아두이노 프로젝트가 외부 자원에 의존하지 않고 아두이노 보드에서 머신 러닝 모델을 직접 사용하여 예측하거나 작업을 수행할 수 있도록 할 수 있습니다. 아두이노와 같은 자원에 제한된 기기에 머신 러닝 모델을 배포할 때 중요한 단계입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n\"\"\"# 아두이노 헤더 파일에 모델 인코딩하기\"\"\"\n\n!echo \"const unsigned char model[] = {\" \u003e /content/model.h\n!cat weather_model.tflite | xxd -i      \u003e\u003e /content/model.h\n!echo \"};\"                              \u003e\u003e /content/model.h\n\nimport os\nmodel_h_size = os.path.getsize(\"model.h\")\nprint(f\"헤더 파일인 model.h의 크기는 {model_h_size:,} 바이트입니다.\")\nprint(\"\\n사이드 패널을 열어보세요 (필요시 새로고침). 모델 파일인 model.h를 더블 클릭하여 다운로드하세요.\")\r\n```\n\n7. 아두이노에 ML 모델 배포하기\n\n‘model.h’ 파일을 다운로드하고 또한 아두이노 스케치와 동일한 디렉토리에 저장하세요. 이 코드에서는 예측을 위해 샘플 온도 및 습도 값을 제공했습니다. 또한 센서에서 이러한 값을 읽어 실시간 예측을 할 수도 있습니다.\n\n```js\n/*\n  날씨 예측\n  회로:\n  - 아두이노 나노 33 BLE 또는 아두이노 나노 33 BLE Sense 보드.\n  작성자: Jobin J\n*/\n\n\n#include \u003cTensorFlowLite.h\u003e\n#include \u003ctensorflow/lite/micro/all_ops_resolver.h\u003e\n#include \u003ctensorflow/lite/micro/micro_error_reporter.h\u003e\n#include \u003ctensorflow/lite/micro/micro_interpreter.h\u003e\n#include \u003ctensorflow/lite/schema/schema_generated.h\u003e\n#include \u003ctensorflow/lite/version.h\u003e\n\n#include \"model.h\"\n\n\n// TensorFlow Lite (Micro)에 사용되는 전역 변수\ntflite::MicroErrorReporter tflErrorReporter;\n\n// 모든 TFLM 오퍼레이션을 가져옵니다. 필요한 오퍼레이션만 가져와\n// 스케치의 컴파일 크기를 줄이고자 한다면 이 줄을 제거하고\n// 필요한 TFLM 오퍼레이션만 가져오실 수 있습니다.\ntflite::AllOpsResolver tflOpsResolver;\n\nconst tflite::Model* tflModel = nullptr;\ntflite::MicroInterpreter* tflInterpreter = nullptr;\nTfLiteTensor* tflInputTensor = nullptr;\nTfLiteTensor* tflOutputTensor = nullptr;\n\n// TFLM을 위한 정적 메모리 버퍼를 생성합니다. 모델의 크기에 따라\n// 조정이 필요할 수 있습니다.\nconstexpr int tensorArenaSize = 8 * 1024;\nbyte tensorArena[tensorArenaSize] __attribute__((aligned(16)));\n\n// 제스처 인덱스를 이름에 매핑하는 배열\nconst char* LABELS[] = {\n  \"부분적으로 흐림\", \"대체로 흐림\", \"흐리고 흐림\", \"안개\",\n  \"바람 부는 대체로 흐림\", \"맑음\", \"바람 부는 부분적으로 흐림\",\n  \"바람 부는 흐리고 흐림\", \"습하고 대체로 흐림\",\n  \"습하고 부분적으로 흐림\", \"바람 부는 안개 낀날\", \"바람 부는 흐리고 흐림\",\n  \"바람 부는 안개\", \"바람 부는 부분적으로 흐림\", \"바람\",\n  \"건조하고 부분적으로 흐림\", \"바람 부는 대체로 흐림\",\n  \"위험한 바람 부는 부분적으로 흐림\", \"건조함\", \"바람\",\n  \"습하고 흐리고 흐림\", \"가벼운 비\", \"이슬비\", \"바람 부는 건조한\",\n  \"건조하고 대체로 흐림\", \"바람 부는 건조한\", \"비\"\n};\n\n#define NUM_LABELS (sizeof(LABELS) / sizeof(LABELS[0]))\n\nvoid setup() {\n  Serial.begin(9600);\n  while (!Serial);\n\n\n  // 모델 바이트 배열의 TFL 표현을 가져옵니다.\n  tflModel = tflite::GetModel(model);\n  if (tflModel-\u003eversion() != TFLITE_SCHEMA_VERSION) {\n    Serial.println(\"모델 스키마 불일치!\");\n    while (1);\n  }\n\n  // 모델 실행을 위한 인터프리터 생성\n  tflInterpreter = new tflite::MicroInterpreter(tflModel, tflOpsResolver, tensorArena, tensorArenaSize, \u0026tflErrorReporter);\n\n  // 모델의 입력 및 출력 텐서를 위한 메모리 할당\n  tflInterpreter-\u003eAllocateTensors();\n\n  // 모델의 입력 및 출력 텐서를 위한 포인터 가져오기\n  tflInputTensor = tflInterpreter-\u003einput(0);\n  tflOutputTensor = tflInterpreter-\u003eoutput(0);\n}\n\nvoid loop() {\n  float temperature = 28.0, humidity = 50.0;\n\n  // 입력 텐서\n  tflInputTensor-\u003edata.f[0] = temperature;\n  tflInputTensor-\u003edata.f[1] = humidity;\n\n\n  TfLiteStatus invokeStatus = tflInterpreter-\u003eInvoke();\n  if (invokeStatus != kTfLiteOk) {\n    Serial.println(\"실행 실패!\");\n    while (1);\n    return;\n  }\n\n  // 모델의 출력 텐서 값 순회\n  for (int i = 0; i \u003c NUM_LABELS; i++) {\n    Serial.print(LABELS[i]);\n    Serial.print(\": \");\n    Serial.println(tflOutputTensor-\u003edata.f[i], 6);\n  }\n\n  delay(5000);\n}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nGitHub - Machine_Learning_Weather_Prediction\n\n이제 시리얼 모니터에서 이렇게 출력을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_4.png)\n\n아두이노 나노 33 BLE Sense에서 기계 학습의 세계를 탐험하고 오늘부터 자신만의 흥미로운 프로젝트를 시작해보세요. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_0.png"},"coverImage":"/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이 포괄적인 자습서에서는 Arduino Nano 33 BLE Sense를 중점으로 한 Arduino 장치에 머신러닝 모델을 배치하는 흥미로운 세계에 대해 살펴볼 것입니다.\u003c/p\u003e\n\u003cp\u003e다음은 Arduino Nano 33 BLE Sense에 머신러닝 모델을 배포하는 단계 목록입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eArduino IDE 설치\u003c/li\u003e\n\u003cli\u003eMbed OS Core for Nano Boards 설치\u003c/li\u003e\n\u003cli\u003eHarvard_TinyMLx 라이브러리 설치\u003c/li\u003e\n\u003cli\u003eGoogle Colab에서 TensorFlow를 사용하여 머신러닝 모델 생성\u003c/li\u003e\n\u003cli\u003e훈련된 모델을 TensorFlow Lite로 변환\u003c/li\u003e\n\u003cli\u003eArduino 헤더 파일에 모델 인코딩\u003c/li\u003e\n\u003cli\u003eArduino에 ML 모델 배포\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e아두이노 IDE 설치\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e다음 가이드를 따라 주세요: \u003ca href=\"https://support.arduino.cc/hc/en-us/articles/360019833020-Download-and-install-Arduino-IDE\" rel=\"nofollow\" target=\"_blank\"\u003e아두이노 IDE 다운로드 및 설치\u003c/a\u003e.\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e나노 보드용 Mbed OS 코어 설치\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e아두이노로 이동해서 Tools → Board → Board Manager로 이동해 주세요.\u003c/p\u003e\n\u003cp\u003e\"Arduino Mbed OS Nano Boards\"를 설치해 주세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003eHarvard_TinyMLx 라이브러리 설치\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eTools -\u003e Manage Libraries 로 이동해주세요.\u003c/p\u003e\n\u003cp\u003e\"Harvard_TinyMLx\" 라이브러리를 설치하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003eGoogle Colab에서 TensorFlow를 사용하여 머신러닝 모델을 생성하세요.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e여기서는 TensorFlow에서 선형 회귀를 사용하여 간단한 날씨 예측 기계 학습 모델을 만들고 있어요. 입력 특성은 온도와 습도이며, 날씨 요약은 예상 출력입니다. 이 모델은 IoT에서 기계 학습 통합을 보여주기 위한 것이며, 정확한 날씨 예측을 최적화한 것이 아니라는 점을 유의해 주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.\u003cspan class=\"hljs-property\"\u003emodel_selection\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e train_test_split\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e tensorflow \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e tf\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e tensorflow \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e keras\n\n# 데이터셋 불러오기\nweather_df = pd.\u003cspan class=\"hljs-title function_\"\u003eread_csv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'weatherHistory.csv'\u003c/span\u003e)\n\nweather_df.\u003cspan class=\"hljs-title function_\"\u003ehead\u003c/span\u003e()\n\nweather_df.\u003cspan class=\"hljs-title function_\"\u003einfo\u003c/span\u003e()\n\nweather_df.\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e()\n\nweather_df[\u003cspan class=\"hljs-string\"\u003e'Summary'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eunique\u003c/span\u003e()\n\n#weather_df[\u003cspan class=\"hljs-string\"\u003e'Summary'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eunique\u003c/span\u003e()\nfactorized_mapping = \u003cspan class=\"hljs-title function_\"\u003edict\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eenumerate\u003c/span\u003e(weather_df[\u003cspan class=\"hljs-string\"\u003e'Summary'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eunique\u003c/span\u003e()))\nweather_df[\u003cspan class=\"hljs-string\"\u003e'Summary'\u003c/span\u003e] = pd.\u003cspan class=\"hljs-title function_\"\u003efactorize\u003c/span\u003e(weather_df[\u003cspan class=\"hljs-string\"\u003e'Summary'\u003c/span\u003e])[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(factorized_mapping)\n\n# 특성과 레이블 정의\nfeatures = weather_df[[\u003cspan class=\"hljs-string\"\u003e'Temperature (C)'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'Humidity'\u003c/span\u003e]]\nlabels = weather_df[[\u003cspan class=\"hljs-string\"\u003e'Summary'\u003c/span\u003e]]\n\n# 훈련 및 테스트 데이터 분할\nfeatures_train, features_test, labels_train, labels_test = \u003cspan class=\"hljs-title function_\"\u003etrain_test_split\u003c/span\u003e(features, labels, test_size=\u003cspan class=\"hljs-number\"\u003e0.3\u003c/span\u003e, random_state=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-title class_\"\u003eKeras\u003c/span\u003e를 사용하여 선형 회귀 모델 만들기\nmodel = keras.\u003cspan class=\"hljs-title class_\"\u003eSequential\u003c/span\u003e([\n    keras.\u003cspan class=\"hljs-property\"\u003elayers\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eDense\u003c/span\u003e(units=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, input_shape=(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,))  # 두 개의 입력 특성, 하나의 출력 유닛\n])\n\n# 모델 컴파일\nmodel.\u003cspan class=\"hljs-title function_\"\u003ecompile\u003c/span\u003e(optimizer=\u003cspan class=\"hljs-string\"\u003e'Adam'\u003c/span\u003e, loss=\u003cspan class=\"hljs-string\"\u003e'mean_squared_error'\u003c/span\u003e)  # 확률적 경사 하강법 (\u003cspan class=\"hljs-variable constant_\"\u003eSGD\u003c/span\u003e) 옵티마이저 사용\n\n# 모델 훈련\nmodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(\n    features_train,labels_train,\n    epochs=\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\n    validation_data=(features_test, labels_test)\n    )\n\npredictions = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(features_test)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(predictions)\n\nrounded_predictions = [\u003cspan class=\"hljs-title function_\"\u003eround\u003c/span\u003e(prediction[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e prediction \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e predictions]\noriginal_predictions = [factorized_mapping[prediction] \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e prediction \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e rounded_predictions]\noriginal_predictions\n\nrmse = np.\u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(((labels_test - predictions) ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003emean\u003c/span\u003e())\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Root Mean Squared Error (RMSE):\"\u003c/span\u003e, rmse)\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"5\"\u003e\n\u003cli\u003e훈련된 모델을 TensorFlow Lite로 변환하기\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"# 훈련된 모델을 텐서 플로 Lite로 변환하기\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e tensorflow \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e tf\n\n# 양자화 없이 모델을 \u003cspan class=\"hljs-title class_\"\u003eTensorFlow\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLite\u003c/span\u003e 형식으로 변환\nconverter = tf.\u003cspan class=\"hljs-property\"\u003elite\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eTFLiteConverter\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_keras_model\u003c/span\u003e(model)\ntflite_model = converter.\u003cspan class=\"hljs-title function_\"\u003econvert\u003c/span\u003e()\n\n# 모델을 디스크에 저장\n\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"weather_model.tflite\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"wb\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(tflite_model)\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\nbasic_model_size = os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetsize\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"weather_model.tflite\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"모델 크기는 %d바이트입니다\"\u003c/span\u003e % basic_model_size)\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"6\"\u003e\n\u003cli\u003e아두이노 헤더 파일에 모델 인코딩\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\"아두이노 헤더 파일에 모델 인코딩\"은 일반적으로 TensorFlow Lite와 같은 형식의 머신 러닝 모델을 아두이노 스케치 내에 포함할 수 있는 특정 형식으로 변환하는 과정을 의미합니다. 이 과정은 모델의 수치적 가중치와 아키텍처를 아두이노 코드의 헤더 파일(.h)로 쉽게 포함할 수 있도록 변환하는 것을 포함합니다.\u003c/p\u003e\n\u003cp\u003e이 헤더 파일은 아두이노 스케치가 외부 종속성이나 별도의 모델 파일 없이 추론에 사용할 수 있도록 모델 데이터를 포함하도록 되어 있습니다. 이 형식으로 모델을 인코딩함으로써 자원 제한적인 기기인 아두이노 같은 장치에 머신 러닝 모델을 배포할 때 아두이노 프로젝트가 외부 자원에 의존하지 않고 아두이노 보드에서 머신 러닝 모델을 직접 사용하여 예측하거나 작업을 수행할 수 있도록 할 수 있습니다. 아두이노와 같은 자원에 제한된 기기에 머신 러닝 모델을 배포할 때 중요한 단계입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"# 아두이노 헤더 파일에 모델 인코딩하기\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n!echo \u003cspan class=\"hljs-string\"\u003e\"const unsigned char model[] = {\"\u003c/span\u003e \u003e \u003cspan class=\"hljs-regexp\"\u003e/content/m\u003c/span\u003eodel.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\n!cat weather_model.\u003cspan class=\"hljs-property\"\u003etflite\u003c/span\u003e | xxd -i      \u003e\u003e \u003cspan class=\"hljs-regexp\"\u003e/content/m\u003c/span\u003eodel.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\n!echo \u003cspan class=\"hljs-string\"\u003e\"};\"\u003c/span\u003e                              \u003e\u003e \u003cspan class=\"hljs-regexp\"\u003e/content/m\u003c/span\u003eodel.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\nmodel_h_size = os.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetsize\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"model.h\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"헤더 파일인 model.h의 크기는 {model_h_size:,} 바이트입니다.\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n사이드 패널을 열어보세요 (필요시 새로고침). 모델 파일인 model.h를 더블 클릭하여 다운로드하세요.\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"7\"\u003e\n\u003cli\u003e아두이노에 ML 모델 배포하기\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e‘model.h’ 파일을 다운로드하고 또한 아두이노 스케치와 동일한 디렉토리에 저장하세요. 이 코드에서는 예측을 위해 샘플 온도 및 습도 값을 제공했습니다. 또한 센서에서 이러한 값을 읽어 실시간 예측을 할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/*\n  날씨 예측\n  회로:\n  - 아두이노 나노 33 BLE 또는 아두이노 나노 33 BLE Sense 보드.\n  작성자: Jobin J\n*/\u003c/span\u003e\n\n\n#include \u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eTensorFlowLite\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n#include \u0026#x3C;tensorflow/lite/micro/all_ops_resolver.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n#include \u0026#x3C;tensorflow/lite/micro/micro_error_reporter.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n#include \u0026#x3C;tensorflow/lite/micro/micro_interpreter.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n#include \u0026#x3C;tensorflow/lite/schema/schema_generated.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n#include \u0026#x3C;tensorflow/lite/version.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n\n#include \u003cspan class=\"hljs-string\"\u003e\"model.h\"\u003c/span\u003e\n\n\n\u003cspan class=\"hljs-comment\"\u003e// TensorFlow Lite (Micro)에 사용되는 전역 변수\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003etflite\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eMicroErrorReporter\u003c/span\u003e tflErrorReporter;\n\n\u003cspan class=\"hljs-comment\"\u003e// 모든 TFLM 오퍼레이션을 가져옵니다. 필요한 오퍼레이션만 가져와\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 스케치의 컴파일 크기를 줄이고자 한다면 이 줄을 제거하고\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 필요한 TFLM 오퍼레이션만 가져오실 수 있습니다.\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003etflite\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eAllOpsResolver\u003c/span\u003e tflOpsResolver;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etflite\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eModel\u003c/span\u003e* tflModel = nullptr;\n\u003cspan class=\"hljs-attr\"\u003etflite\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eMicroInterpreter\u003c/span\u003e* tflInterpreter = nullptr;\n\u003cspan class=\"hljs-title class_\"\u003eTfLiteTensor\u003c/span\u003e* tflInputTensor = nullptr;\n\u003cspan class=\"hljs-title class_\"\u003eTfLiteTensor\u003c/span\u003e* tflOutputTensor = nullptr;\n\n\u003cspan class=\"hljs-comment\"\u003e// TFLM을 위한 정적 메모리 버퍼를 생성합니다. 모델의 크기에 따라\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 조정이 필요할 수 있습니다.\u003c/span\u003e\nconstexpr int tensorArenaSize = \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e;\nbyte tensorArena[tensorArenaSize] \u003cspan class=\"hljs-title function_\"\u003e__attribute__\u003c/span\u003e((\u003cspan class=\"hljs-title function_\"\u003ealigned\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e)));\n\n\u003cspan class=\"hljs-comment\"\u003e// 제스처 인덱스를 이름에 매핑하는 배열\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e char* \u003cspan class=\"hljs-variable constant_\"\u003eLABELS\u003c/span\u003e[] = {\n  \u003cspan class=\"hljs-string\"\u003e\"부분적으로 흐림\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"대체로 흐림\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"흐리고 흐림\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"안개\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"바람 부는 대체로 흐림\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"맑음\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"바람 부는 부분적으로 흐림\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"바람 부는 흐리고 흐림\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"습하고 대체로 흐림\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"습하고 부분적으로 흐림\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"바람 부는 안개 낀날\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"바람 부는 흐리고 흐림\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"바람 부는 안개\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"바람 부는 부분적으로 흐림\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"바람\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"건조하고 부분적으로 흐림\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"바람 부는 대체로 흐림\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"위험한 바람 부는 부분적으로 흐림\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"건조함\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"바람\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"습하고 흐리고 흐림\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"가벼운 비\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"이슬비\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"바람 부는 건조한\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"건조하고 대체로 흐림\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"바람 부는 건조한\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"비\"\u003c/span\u003e\n};\n\n#define \u003cspan class=\"hljs-variable constant_\"\u003eNUM_LABELS\u003c/span\u003e (\u003cspan class=\"hljs-title function_\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eLABELS\u003c/span\u003e) / \u003cspan class=\"hljs-title function_\"\u003esizeof\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eLABELS\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]))\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetup\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebegin\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e9600\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (!\u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e);\n\n\n  \u003cspan class=\"hljs-comment\"\u003e// 모델 바이트 배열의 TFL 표현을 가져옵니다.\u003c/span\u003e\n  tflModel = \u003cspan class=\"hljs-attr\"\u003etflite\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eGetModel\u003c/span\u003e(model);\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (tflModel-\u003e\u003cspan class=\"hljs-title function_\"\u003eversion\u003c/span\u003e() != \u003cspan class=\"hljs-variable constant_\"\u003eTFLITE_SCHEMA_VERSION\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"모델 스키마 불일치!\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 모델 실행을 위한 인터프리터 생성\u003c/span\u003e\n  tflInterpreter = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etflite\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eMicroInterpreter\u003c/span\u003e(tflModel, tflOpsResolver, tensorArena, tensorArenaSize, \u0026#x26;tflErrorReporter);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 모델의 입력 및 출력 텐서를 위한 메모리 할당\u003c/span\u003e\n  tflInterpreter-\u003e\u003cspan class=\"hljs-title class_\"\u003eAllocateTensors\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 모델의 입력 및 출력 텐서를 위한 포인터 가져오기\u003c/span\u003e\n  tflInputTensor = tflInterpreter-\u003e\u003cspan class=\"hljs-title function_\"\u003einput\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n  tflOutputTensor = tflInterpreter-\u003e\u003cspan class=\"hljs-title function_\"\u003eoutput\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloop\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  float temperature = \u003cspan class=\"hljs-number\"\u003e28.0\u003c/span\u003e, humidity = \u003cspan class=\"hljs-number\"\u003e50.0\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// 입력 텐서\u003c/span\u003e\n  tflInputTensor-\u003edata.\u003cspan class=\"hljs-property\"\u003ef\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = temperature;\n  tflInputTensor-\u003edata.\u003cspan class=\"hljs-property\"\u003ef\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] = humidity;\n\n\n  \u003cspan class=\"hljs-title class_\"\u003eTfLiteStatus\u003c/span\u003e invokeStatus = tflInterpreter-\u003e\u003cspan class=\"hljs-title class_\"\u003eInvoke\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (invokeStatus != kTfLiteOk) {\n    \u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"실행 실패!\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 모델의 출력 텐서 값 순회\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (int i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; \u003cspan class=\"hljs-variable constant_\"\u003eNUM_LABELS\u003c/span\u003e; i++) {\n    \u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eLABELS\u003c/span\u003e[i]);\n    \u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e);\n    \u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(tflOutputTensor-\u003edata.\u003cspan class=\"hljs-property\"\u003ef\u003c/span\u003e[i], \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGitHub - Machine_Learning_Weather_Prediction\u003c/p\u003e\n\u003cp\u003e이제 시리얼 모니터에서 이렇게 출력을 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e아두이노 나노 33 BLE Sense에서 기계 학습의 세계를 탐험하고 오늘부터 자신만의 흥미로운 프로젝트를 시작해보세요. 즐거운 코딩되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-GetStartedwithMachineLearningonArduinoArduinoNano33BLESense"},"buildId":"FH3Qr-mLAesqA0X5IFRQr","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>