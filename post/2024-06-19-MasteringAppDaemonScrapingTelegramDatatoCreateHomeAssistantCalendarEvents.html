<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>앱데몬 마스터하기 홈 어시스턴트 캘린더 이벤트 생성을 위해 텔레그램 데이터 수집하기 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="앱데몬 마스터하기 홈 어시스턴트 캘린더 이벤트 생성을 위해 텔레그램 데이터 수집하기 | itposting" data-gatsby-head="true"/><meta property="og:title" content="앱데몬 마스터하기 홈 어시스턴트 캘린더 이벤트 생성을 위해 텔레그램 데이터 수집하기 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents" data-gatsby-head="true"/><meta name="twitter:title" content="앱데몬 마스터하기 홈 어시스턴트 캘린더 이벤트 생성을 위해 텔레그램 데이터 수집하기 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 05:39" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-0fd008072af5a644.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_buildManifest.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">앱데몬 마스터하기 홈 어시스턴트 캘린더 이벤트 생성을 위해 텔레그램 데이터 수집하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="앱데몬 마스터하기 홈 어시스턴트 캘린더 이벤트 생성을 위해 텔레그램 데이터 수집하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">15<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>요크라이나에서 살면서, 저희 가족은 계속되는 전력 공급 차단 문제를 해결하는 데 익숙해져 왔습니다. 계속되는 갈등과 러시아의 에너지 인프라를 향한 공격 속에서 혹독한 현실이 가정됩니다. 2022년 겨울은 특히 전기 공급이 빈번하고 긴급했던 어려운 시기였습니다. 얼마 동안은 상황이 나아졌지만, 최근 새로운 공격이 시작되면서 전기 공급 차단이 다시 복귀되었습니다.</p>
<p>특히 피크 시간에 전기 부하를 관리하고, 이용 가능한 전력을 가정과 기업 간에 공정하게 나눠주기 위해 당국은 일정을 마련했습니다. 소비자들은 각 그룹으로 나누어져 고정 시간대에 전력 차단을 받게 됩니다. 이러한 일정은 일반적으로 운영자들의 웹사이트나 공개 텔레그램 채널을 통해 하루 전에 발표됩니다.</p>
<p>스마트 홈 애호가로서 당연히 이 정전 정보를 내 Home Assistant 시스템에 통합하고 싶었어요. 가능성을 상상해보세요: 수전중이던 전기 온수기 같은 전력 소모 가전제품을 자동으로 끄어 백업 배터리 전력을 절약하거나, 가족에게 "주의! 30분 후 정전 예정입니다! 핸드폰을 충전하는 시간이에요!" 라고 음성으로 미리 알려주기도 해봤어요.</p>
<p>하지만 가장 중요한 점은 이 시간표가 매일 동적으로 바뀌며 고정된 발행 시간이 없다는 것이에요. 즉, Home Assistant를 최신 상태로 유지하려면 웹사이트나 텔레그램 채널을 지속적으로 모니터링해야 한다는 것이죠.</p>
<h1>해결책</h1>
<p>제가 선택한 해결책은 Home Assistant의 로컬 캘린더를 사용하여 이 정전 시간표를 처리하는 것이었어요. 저는 이 정전 데이터를 텔레그램 채널에서 스크래핑하기로 결정했는데, 그 이유는 메시지 구조가 제 요구 사항에 딱 맞았기 때문이에요.</p>
<p>홈 어시스턴트에는 내장된 스크래이프 통합 및 더 고급 HACS 구성 요소인 Multiscrape(여기서 확인하세요)가 있습니다. 하지만 이러한 도구들을 사용하여 내 문제를 해결하는 방법을 찾지 못했습니다. 아마 가능할지도 모르지만, 제가 Jinja 템플릿과 복잡한 구성에 대한 기술이 부족해서 그렇습니다. 그래서 홈 어시스턴트의 AppDaemon 통합으로 돌아가기로 결정했습니다.</p>
<p>공식 문서에 따르면, "AppDaemon은 홈 어시스턴트의 자동화 및 스크립팅 구성 요소를 보완하는 하위 시스템입니다." 더 간단히 말하면, 이를 통해 Python 코드(앱)를 작성하여 홈 어시스턴트를 제어하고 자동화할 수 있습니다.</p>
<p>다른 프로그래밍 언어에 대한 경험이 있지만, Python은 제게는 새로운 영역이었습니다. 그래서 최신 기술 센세이션이라고 불리는 ChatGPT에 의지했습니다. "이 인공지능이 분명히 도와줄 것이다!"라고 생각했지만, 솔직히 말하면 결과는 성공과 실패가 섞였습니다. 옳은 방향으로 나아갈 수 있게 도와줬지만 항상 순조롭지는 않았습니다. 가끔씩 존재하지 않는 함수와 서비스를 제안하기도 했거든요. 올바른 서비스 호출 방법, 변수 전달 방법 및 변수 형식화 방법을 이해하는 데 많은 시간을 소요했습니다.</p>
<p>가장 큰 골칫거리 중 하나는 AppDaemon으로부터 홈 어시스턴트 캘린더에 이미 전원 차단 일정이 있는지 확인하는 방법을 찾는 것이었습니다. 중복된 이벤트를 방지하기 위해서였죠. ChatGPT는 "calendar.get_events" 서비스를 사용하여 시간을 지정하여 이미 있는 이벤트를 확인하라고 제안했습니다. 안타깝게도, 이 방법은 AppDaemon 내에서의 제약 사항으로 작동하지 않았습니다. 여러 차례 검색하고 몇 번의 좌절한 한숨 뒤에, Markus Ressel의 매우 유익한 기사(<a href="https://markusressel.de/blog/post/calendar-integration-between-home-assistant-and-appdaemon)%EB%A5%BC" rel="nofollow" target="_blank">https://markusressel.de/blog/post/calendar-integration-between-home-assistant-and-appdaemon)를</a> 우연히 발견했습니다. 이 기사는 문제의 근본 원인을 이해하게 해주었고, 결국 캘린더 중복 없는 해결책을 찾는 데 도움이 되었습니다.</p>
<p>홈 어시스턴트에 AppDaemon을 사용하여 전원 차단 스케줄을 통합하는 방법을 단계별로 안내해 드릴게요.</p>
<h1>단계 1: 로컬 캘린더 설정</h1>
<p>가장 먼저, "powercuts"라는 이름의 로컬 캘린더를 홈 어시스턴트에 생성하여 스케줄을 가져올 수 있어요. 다음 방법으로 진행할 수 있어요:</p>
<ul>
<li>"장치 및 서비스" 페이지로 이동합니다.</li>
<li>"통합 추가"를 클릭하세요.</li>
<li>"로컬 캘린더"를 검색하고 선택하세요.</li>
<li>새 캘린더를 설정하고 이름을 "powercuts"로 지정하는 안내에 따라 진행하세요.</li>
</ul>
<h1>단계 2: AppDaemon 설치</h1>
<p>홈 어시스턴트 애드온 스토어로 이동하여 AppDaemon 통합을 설치하세요.</p>
<h1>단계 3: AppDaemon 구성</h1>
<p>통합을 시작하기 전에, 앱에서 필요한 Python 패키지를 포함하도록 구성해야 합니다. 제 프로젝트에서는 datetime, requests 및 beautifulsoup4를 추가했습니다. 이러한 패키지를 AppDaemon의 구성 섹션에 추가한 후, 통합을 시작하세요.</p>
<p><img src="/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_2.png" alt="이미지"></p>
<h1>단계 4: 올바른 폴더 찾기</h1>
<p>홈 어시스턴트의 상위 디렉터리로 이동합니다. 그 안에는 addon_configs라는 폴더가 있습니다. addon_configs 안에는 일반적으로 글자와 숫자의 조합 뒤에 _Appdaemon이 붙은 abcd123_Appdaemon과 같은 이름의 폴더를 찾습니다. 이 폴더 안에 apps라는 다른 폴더가 있습니다.</p>
<h1>단계 5: Python 앱 만들기</h1>
<p>apps 폴더에 새 Python 파일(.py)을 만드세요. 여기에 코드를 작성할 거에요. 이 파일의 이름과 내부에 사용하는 클래스 이름은 중요합니다. 나중에 apps.yaml 파일에서 이들을 참조할 거니까요.</p>
<p>예를 들어, powercut_scraper.py라는 파일을 만들고 PowercutScraper 클래스를 사용하면, AppDaemon을 구성할 때 코드를 찾을 위치를 알려줄 때 이 이름들을 사용해야 합니다.</p>
<pre><code class="hljs language-js"># apps/powercut_scraper_web.<span class="hljs-property">py</span>

<span class="hljs-keyword">import</span> appdaemon.<span class="hljs-property">plugins</span>.<span class="hljs-property">hass</span>.<span class="hljs-property">hassapi</span> <span class="hljs-keyword">as</span> hass
<span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> <span class="hljs-title class_">BeautifulSoup</span>
<span class="hljs-keyword">import</span> re
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PowercutScraperWeb</span>(hass.<span class="hljs-property">Hass</span>):

    def <span class="hljs-title function_">initialize</span>(self):
        # <span class="hljs-title class_">Configuration</span>
        self.<span class="hljs-property">url</span> = <span class="hljs-string">"https://t.me/s/pat_cherkasyoblenergo"</span>
        self.<span class="hljs-property">queue_number</span> = <span class="hljs-number">3</span>  # 확인해야 할 대기 번호
        self.<span class="hljs-property">calendar_entity</span> = <span class="hljs-string">"calendar.powercuts"</span>
        self.<span class="hljs-property">months_uk</span> = {
            <span class="hljs-string">"січня"</span>: <span class="hljs-string">"01"</span>, <span class="hljs-string">"лютого"</span>: <span class="hljs-string">"02"</span>, <span class="hljs-string">"березня"</span>: <span class="hljs-string">"03"</span>, <span class="hljs-string">"квітня"</span>: <span class="hljs-string">"04"</span>, 
            <span class="hljs-string">"травня"</span>: <span class="hljs-string">"05"</span>, <span class="hljs-string">"червня"</span>: <span class="hljs-string">"06"</span>, <span class="hljs-string">"липня"</span>: <span class="hljs-string">"07"</span>, <span class="hljs-string">"серпня"</span>: <span class="hljs-string">"08"</span>, 
            <span class="hljs-string">"вересня"</span>: <span class="hljs-string">"09"</span>, <span class="hljs-string">"жовтня"</span>: <span class="hljs-string">"10"</span>, <span class="hljs-string">"листопада"</span>: <span class="hljs-string">"11"</span>, <span class="hljs-string">"грудня"</span>: <span class="hljs-string">"12"</span>
        }
        self.<span class="hljs-property">current_year</span> = datetime.<span class="hljs-title function_">now</span>().<span class="hljs-property">year</span>

        # homeassistant 이벤트 청취
        self.<span class="hljs-title function_">listen_event</span>(self.<span class="hljs-property">scrape_messages</span>, <span class="hljs-string">"tele_powercut_scraper_event"</span>)
        # self.<span class="hljs-title function_">run_every</span>(self.<span class="hljs-property">scrape_messages</span>, <span class="hljs-string">"now"</span>, <span class="hljs-number">3600</span>)
        
    def <span class="hljs-title function_">scrape_messages</span>(self, event_name, data, kwargs):
        # 웹페이지 가져오기
        response = requests.<span class="hljs-title function_">get</span>(self.<span class="hljs-property">url</span>)
        <span class="hljs-keyword">if</span> response.<span class="hljs-property">status_code</span> != <span class="hljs-number">200</span>:
            self.<span class="hljs-title function_">error</span>(f<span class="hljs-string">"웹페이지 가져오기 실패: {response.status_code}"</span>)
            <span class="hljs-keyword">return</span>

        # 웹페이지 내용 파싱
        soup = <span class="hljs-title class_">BeautifulSoup</span>(response.<span class="hljs-property">content</span>, <span class="hljs-string">'html.parser'</span>)
        messages = soup.<span class="hljs-title function_">find_all</span>(<span class="hljs-string">'div'</span>, class_=<span class="hljs-string">'tgme_widget_message_text'</span>)

        <span class="hljs-keyword">for</span> message <span class="hljs-keyword">in</span> <span class="hljs-attr">messages</span>:
            date = self.<span class="hljs-title function_">extract_date</span>(message.<span class="hljs-title function_">get_text</span>())
            schedules = self.<span class="hljs-title function_">extract_schedules</span>(message.<span class="hljs-title function_">get_text</span>())
            <span class="hljs-keyword">if</span> date and <span class="hljs-attr">schedules</span>:
                self.<span class="hljs-title function_">update_calendar</span>(date, schedules)

    
    def <span class="hljs-title function_">extract_schedules</span>(self, message):
        pattern = re.<span class="hljs-title function_">compile</span>(r<span class="hljs-string">'(\d{2}:\d{2}-\d{2}:\d{2})\s*([0-9\sта,.;:!?]*черг[а|и])'</span>)
        matches = pattern.<span class="hljs-title function_">findall</span>(message)
        relevant_schedules = []

        <span class="hljs-keyword">for</span> match <span class="hljs-keyword">in</span> <span class="hljs-attr">matches</span>:
            time_range = match[<span class="hljs-number">0</span>]
            queue_info = match[<span class="hljs-number">1</span>]

            # queue_info에서 모든 숫자 추출
            queue_numbers = re.<span class="hljs-title function_">findall</span>(r<span class="hljs-string">'\d+'</span>, queue_info)

            # 대기 번호 중 하나라도 self.<span class="hljs-property">queue_number</span>와 일치하는지 확인
            <span class="hljs-keyword">if</span> <span class="hljs-title function_">any</span>(<span class="hljs-title function_">int</span>(queue_number) == self.<span class="hljs-property">queue_number</span> <span class="hljs-keyword">for</span> queue_number <span class="hljs-keyword">in</span> queue_numbers):
                relevant_schedules.<span class="hljs-title function_">append</span>(time_range)
        self.<span class="hljs-title function_">log</span>(relevant_schedules)
        <span class="hljs-keyword">return</span> relevant_schedules
    
    def <span class="hljs-title function_">extract_date</span>(self, message):
        date_pattern = re.<span class="hljs-title function_">compile</span>(r<span class="hljs-string">'(\d{2})\s([а-я]+)'</span>)
        match = date_pattern.<span class="hljs-title function_">search</span>(message)
        <span class="hljs-keyword">if</span> <span class="hljs-attr">match</span>:
            day = match.<span class="hljs-title function_">group</span>(<span class="hljs-number">1</span>)    
            month_uk = match.<span class="hljs-title function_">group</span>(<span class="hljs-number">2</span>)
            <span class="hljs-keyword">if</span> month_uk <span class="hljs-keyword">in</span> self.<span class="hljs-property">months_uk</span>:
                month = self.<span class="hljs-property">months_uk</span>[month_uk]
                <span class="hljs-keyword">return</span> f<span class="hljs-string">"{day}.{month}.{self.current_year}"</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">None</span>

    def <span class="hljs-title function_">update_calendar</span>(self, date, time_slots):
        # 오늘 이후인지 확인하는 날짜 비교
        date_obj = datetime.<span class="hljs-title function_">strptime</span>(date, <span class="hljs-string">"%d.%m.%Y"</span>)
        today = datetime.<span class="hljs-title function_">today</span>().<span class="hljs-title function_">replace</span>(hour=<span class="hljs-number">0</span>, minute=<span class="hljs-number">0</span>, second=<span class="hljs-number">0</span>, microsecond=<span class="hljs-number">0</span>)
        <span class="hljs-keyword">if</span> date_obj >= <span class="hljs-attr">today</span>:
            # 시간 슬롯 결합
            combined_slots = self.<span class="hljs-title function_">combine_time_slots</span>(date, time_slots)
            <span class="hljs-keyword">for</span> slot <span class="hljs-keyword">in</span> <span class="hljs-attr">combined_slots</span>:
                start_time, end_time = slot.<span class="hljs-title function_">split</span>(<span class="hljs-string">'-'</span>)
                event_start = datetime.<span class="hljs-title function_">strptime</span>(f<span class="hljs-string">"{date} {start_time}"</span>, <span class="hljs-string">"%d.%m.%Y %H:%M"</span>).<span class="hljs-title function_">strftime</span>(<span class="hljs-string">"%Y-%m-%dT%H:%M:%S"</span>)
                event_end = datetime.<span class="hljs-title function_">strptime</span>(f<span class="hljs-string">"{date} {end_time}"</span>, <span class="hljs-string">"%d.%m.%Y %H:%M"</span>).<span class="hljs-title function_">strftime</span>(<span class="hljs-string">"%Y-%m-%dT%H:%M:%S"</span>)

                self.<span class="hljs-title function_">call_service</span>(
                    <span class="hljs-string">"script/create_powercut_calendar_events"</span>, 
                    start_date_time=event_start, 
                    end_date_time=event_end
                    
                )
        <span class="hljs-attr">else</span>:
            self.<span class="hljs-title function_">log</span>(f<span class="hljs-string">"과거 날짜에 대한 캘린더 업데이트 건너뛰기: {date}"</span>)

    def <span class="hljs-title function_">combine_time_slots</span>(self, date, time_slots):
            <span class="hljs-keyword">if</span> not <span class="hljs-attr">time_slots</span>:
                self.<span class="hljs-title function_">log</span>(f<span class="hljs-string">"{date}에 결합할 시간 슬롯이 없어요."</span>)
                <span class="hljs-keyword">return</span> []

            # 시간 슬롯 구문 분석 및 정렬
            slots = []
            <span class="hljs-keyword">for</span> slot <span class="hljs-keyword">in</span> <span class="hljs-attr">time_slots</span>:
                start_time, end_time = slot.<span class="hljs-title function_">split</span>(<span class="hljs-string">'-'</span>)
                <span class="hljs-keyword">if</span> end_time == <span class="hljs-string">"24:00"</span>:
                    end_time = <span class="hljs-string">"23:59"</span>
                start = datetime.<span class="hljs-title function_">strptime</span>(f<span class="hljs-string">"{date} {start_time}"</span>, <span class="hljs-string">"%d.%m.%Y %H:%M"</span>)
                end = datetime.<span class="hljs-title function_">strptime</span>(f<span class="hljs-string">"{date} {end_time}"</span>, <span class="hljs-string">"%d.%m.%Y %H:%M"</span>)
                slots.<span class="hljs-title function_">append</span>((start, end))

            slots.<span class="hljs-title function_">sort</span>()

            # 겹치거나 연속된 시간 슬롯 병합
            merged_slots = []
            current_start, current_end = slots[<span class="hljs-number">0</span>]

            <span class="hljs-keyword">for</span> start, end <span class="hljs-keyword">in</span> slots[<span class="hljs-number">1</span>:]:
                <span class="hljs-keyword">if</span> start &#x3C;= <span class="hljs-attr">current_end</span>:
                    # 현재 시간 슬롯 확장
                    current_end = <span class="hljs-title function_">max</span>(current_end, end)
                <span class="hljs-attr">else</span>:
                    # 겹침 없음, 현재 시간 슬롯 추가 및 새로 시작
                    merged_slots.<span class="hljs-title function_">append</span>((current_start, current_end))
                    current_start, current_end = start, end

            # 마지막 시간 슬롯 추가
            merged_slots.<span class="hljs-title function_">append</span>((current_start, current_end))

            # 병합된 시간 슬롯을 다시 문자열로 변환
            combined_slots = [f<span class="hljs-string">"{start.strftime('%H:%M')}-{end.strftime('%H:%M')}"</span> <span class="hljs-keyword">for</span> start, end <span class="hljs-keyword">in</span> merged_slots]
            <span class="hljs-keyword">return</span> combined_slots
</code></pre>
<h1>단계 6: apps.yaml에서 앱 구성하기</h1>
<p>apps 폴더 안에 apps.yaml 파일이 있을 것입니다. 이 파일은 AppDaemon에게 사용자 정의 앱에 대해 알려줍니다. 다음과 같이 항목을 추가해보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">powercut_scraper_web</span>:
  <span class="hljs-attr">module</span>: powercut_scraper_web  # .<span class="hljs-property">py</span> 확장자를 제외한 파일명입니다
  <span class="hljs-attr">class</span>: <span class="hljs-title class_">PowercutScraperWeb</span> # 파일 내부의 클래스 이름입니다
</code></pre>
<p>이 구성은 AppDaemon에 앱을 연결하여 코드를 찾고 실행할 위치를 알려줍니다.</p>
<h1>단계 7: 코드 흐름 이해하기</h1>
<ul>
<li>코드 트리거: 코드는 "tele_powercut_scraper_event"라는 이벤트에 의해 트리거되며, 이 이벤트는 Multiscrape 구성 요소를 사용하여 생성된 이진 센서가 켜졌을 때 발생합니다. 제가 이 센서를 이전에 설정했으므로 트리거로 사용했습니다. 원하는 경우 앱을 몇 분마다 실행하도록 예약할 수도 있습니다.</li>
<li>텔레그램 채널 스크랩: 코드는 텔레그램 채널의 메시지를 통해 날짜와 일정을 찾습니다. 둘 다 발견되면 캘린더를 업데이트하는 함수를 호출합니다.</li>
<li>캘린더 업데이트: 이 함수는 먼저 오늘보다 이전인 전력 공급 차단 날짜를 무시합니다 (과거 이벤트에 대해 걱정할 필요가 없습니다). 관련 메시지의 경우 연속된 시간 단위 슬롯을 더 큰 블록으로 결합합니다 (일정은 1시간 간격으로 제공됨).</li>
</ul>
<p><img src="/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_3.png" alt="이미지"></p>
<ul>
<li>중복 확인: 이 단계에서 이상적으로는 calendar.get_events 서비스를 호출하여 캘린더에 이미 이벤트가 있는지 확인해야 합니다. 그러나 이전에 언급했듯이 AppDaemon은이 서비스를 지원하지 않습니다. 따라서 필요한 경우 기존 항목을 확인하고 필요한 경우 새 항목을 만드는 Home Assistant 스크립트를 호출함으로써 이 문제를 해결했습니다.</li>
</ul>
<p>요약하면, AppDaemon 앱은 텔레그램 채널에서 데이터를 스크랩하고 정리한 후 HA에 관련 시간 슬롯을 전송하여 캘린더에 새 이벤트를 생성합니다. 아래는 이진 센서와 스크립트 코드입니다:</p>
<pre><code class="hljs language-js">  <span class="hljs-attr">multiscrape</span>:
    - <span class="hljs-attr">name</span>: <span class="hljs-title class_">Cherkasy</span> powercut alert
      <span class="hljs-attr">resource</span>: <span class="hljs-attr">https</span>:<span class="hljs-comment">//t.me/s/pat_cherkasyoblenergo</span>
      <span class="hljs-attr">scan_interval</span>: <span class="hljs-number">30</span>
      <span class="hljs-attr">list_separator</span>: <span class="hljs-string">"|||"</span>
      <span class="hljs-attr">binary_sensor</span>:
        - <span class="hljs-attr">unique_id</span>: energy_sensor_powercut_alert_oblenergo
          <span class="hljs-attr">name</span>: <span class="hljs-title class_">Cherkasy</span> powercut alert
          <span class="hljs-attr">icon</span>: <span class="hljs-attr">mdi</span>:transmission-tower-<span class="hljs-keyword">export</span>
          <span class="hljs-attr">device_class</span>: power
          <span class="hljs-attr">select_list</span>: <span class="hljs-string">".js-message_text"</span>
          <span class="hljs-attr">value_template</span>: >-
            { set message = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">"|||"</span>) | last | lower }
            { <span class="hljs-string">"годин"</span> <span class="hljs-keyword">in</span> message and <span class="hljs-string">"відсутност"</span> <span class="hljs-keyword">in</span> message and <span class="hljs-string">"електропостача"</span> <span class="hljs-keyword">in</span> message}
          <span class="hljs-attr">attributes</span>:         
            - <span class="hljs-attr">name</span>: latest_message_date
              <span class="hljs-attr">select_list</span>: <span class="hljs-string">".js-message_text"</span>
              <span class="hljs-attr">value_template</span>: >-
                { set message = value.<span class="hljs-title function_">split</span>(<span class="hljs-string">'|||'</span>) | last }
                { set date_match = message | <span class="hljs-title function_">regex_findall_index</span>(<span class="hljs-string">"(\d{1,2}\s(?:січня|лютого|березня|квітня|травня|червня|липня|серпня|вересня|жовтня|листопада|грудня))"</span>, <span class="hljs-number">0</span>) }
                { set months_uk = {
                            <span class="hljs-string">'січня'</span>: <span class="hljs-string">'01'</span>, <span class="hljs-string">'лютого'</span>: <span class="hljs-string">'02'</span>, <span class="hljs-string">'березня'</span>: <span class="hljs-string">'03'</span>, <span class="hljs-string">'квітня'</span>: <span class="hljs-string">'04'</span>, 
                            <span class="hljs-string">'травня'</span>: <span class="hljs-string">'05'</span>, <span class="hljs-string">'червня'</span>: <span class="hljs-string">'06'</span>, <span class="hljs-string">'липня'</span>: <span class="hljs-string">'07'</span>, <span class="hljs-string">'серпня'</span>: <span class="hljs-string">'08'</span>, 
                            <span class="hljs-string">'вересня'</span>: <span class="hljs-string">'09'</span>, <span class="hljs-string">'жовтня'</span>: <span class="hljs-string">'10'</span>, <span class="hljs-string">'листопада'</span>: <span class="hljs-string">'11'</span>, <span class="hljs-string">'грудня'</span>: <span class="hljs-string">'12'</span>
                          } }
                { <span class="hljs-keyword">if</span> date_match }
                  { set day = date_match.<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>)[<span class="hljs-number">0</span>] }
                  { set month_uk = date_match.<span class="hljs-title function_">split</span>(<span class="hljs-string">' '</span>)[<span class="hljs-number">1</span>] }
                  { set month = months_uk[month_uk] }
                  { set year = <span class="hljs-title function_">now</span>().<span class="hljs-property">year</span> }
                  {  <span class="hljs-title function_">as_datetime</span>(<span class="hljs-title function_">strptime</span>(<span class="hljs-string">'{}-{}-{} 00:00:00'</span>.<span class="hljs-title function_">format</span>(year, month, day),<span class="hljs-string">'%Y-%m-%d %H:%M:%S'</span>)) } 
                { <span class="hljs-keyword">else</span> }
                  { <span class="hljs-string">'Date not found'</span> }
                { endif }  
            - <span class="hljs-attr">name</span>: latest_message
              <span class="hljs-attr">select_list</span>: <span class="hljs-string">".js-message_text"</span>
              <span class="hljs-attr">value_template</span>: >
                { value.<span class="hljs-title function_">split</span>(<span class="hljs-string">'|||'</span>) | last | <span class="hljs-title function_">regex_findall</span>(<span class="hljs-string">'\d{2}:\d{2}-\d{2}:\d{2}\s*[0-9\sта,.;:!?]*черг[а|и]'</span>)| <span class="hljs-title function_">join</span>(<span class="hljs-string">'\n'</span>) }
</code></pre>
<pre><code class="hljs language-js">  <span class="hljs-attr">script</span>:
    <span class="hljs-attr">create_powercut_calendar_events</span>:
      <span class="hljs-attr">mode</span>: parallel
      <span class="hljs-attr">sequence</span>:
        - <span class="hljs-attr">service</span>: calendar.<span class="hljs-property">get_events</span>
          <span class="hljs-attr">target</span>:
            <span class="hljs-attr">entity_id</span>: calendar.<span class="hljs-property">powercuts</span>
          <span class="hljs-attr">data</span>:
            <span class="hljs-attr">start_date_time</span>: <span class="hljs-string">"{ start_date_time }"</span>
            <span class="hljs-attr">end_date_time</span>: <span class="hljs-string">"{ end_date_time }"</span> 
          <span class="hljs-attr">response_variable</span>: agenda
        - <span class="hljs-attr">if</span>: <span class="hljs-string">"{ not agenda['calendar.powercuts'].events| map(attribute='summary')| list| count > 0 }"</span> 
          <span class="hljs-attr">then</span>:
            - <span class="hljs-attr">service</span>: calendar.<span class="hljs-property">create_event</span>
              <span class="hljs-attr">target</span>:
                <span class="hljs-attr">entity_id</span>: calendar.<span class="hljs-property">powercuts</span>
              <span class="hljs-attr">data</span>:
                <span class="hljs-attr">summary</span>: <span class="hljs-title class_">Power</span> cut
                <span class="hljs-attr">description</span>: >-
                  <span class="hljs-title class_">Scheduled</span> <span class="hljs-title class_">Powercut</span> data <span class="hljs-keyword">from</span> <span class="hljs-title class_">Oblenergo</span> telegram channel, auto created <span class="hljs-keyword">from</span> appdaemon script
                <span class="hljs-attr">start_date_time</span>: <span class="hljs-string">"{ start_date_time }"</span>
                <span class="hljs-attr">end_date_time</span>: <span class="hljs-string">"{ end_date_time }"</span>      
</code></pre>
<h1>단계 8: 자동화</h1>
<p>Appdaemon 스크립트를 트리거하는 자동화:</p>
<pre><code class="hljs language-yaml">    <span class="hljs-bullet">-</span> <span class="hljs-attr">alias:</span> <span class="hljs-string">새로운</span> <span class="hljs-string">전원</span> <span class="hljs-string">공급</span> <span class="hljs-string">일정</span> <span class="hljs-bullet">-</span> <span class="hljs-string">캘린더에</span> <span class="hljs-string">추가</span>
      <span class="hljs-attr">id:</span> <span class="hljs-string">"vdgadsfwerwfsdgasdsdxxkOOcKAo"</span>
      <span class="hljs-attr">initial_state:</span> <span class="hljs-string">"on"</span>
      <span class="hljs-attr">trigger:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">state</span>
          <span class="hljs-attr">entity_id:</span> <span class="hljs-string">binary_sensor.energy_sensor_powercut_alert_oblenergo</span>
          <span class="hljs-attr">attribute:</span> <span class="hljs-string">latest_message</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">time</span>
          <span class="hljs-attr">at:</span> <span class="hljs-string">'23:45:00'</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">homeassistant</span>
          <span class="hljs-attr">event:</span> <span class="hljs-string">start</span>
      <span class="hljs-attr">mode:</span> <span class="hljs-string">single</span>
      <span class="hljs-attr">max_exceeded:</span> <span class="hljs-string">silent</span>
      <span class="hljs-attr">action:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">event:</span> <span class="hljs-string">tele_powercut_scraper_event</span>
          <span class="hljs-attr">event_data:</span>
            <span class="hljs-attr">date:</span> <span class="hljs-string">"{ now().strftime('%Y-%m-%d') }"</span>
</code></pre>
<p>이 정보를 자동화하는 방법의 예시입니다:</p>
<pre><code class="hljs language-yaml">    <span class="hljs-bullet">-</span> <span class="hljs-attr">alias:</span> <span class="hljs-string">"전원 정전 알림"</span>
      <span class="hljs-attr">id:</span> <span class="hljs-string">"automation_notification_home_powercut_notification"</span>
      <span class="hljs-attr">trigger:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">calendar</span>
          <span class="hljs-attr">id:</span> <span class="hljs-string">"5_minute"</span>
          <span class="hljs-attr">event:</span> <span class="hljs-string">start</span>
          <span class="hljs-attr">entity_id:</span> <span class="hljs-string">calendar.powercuts</span>
          <span class="hljs-attr">offset:</span> <span class="hljs-number">-00</span><span class="hljs-string">:05:00</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">calendar</span>
          <span class="hljs-attr">id:</span> <span class="hljs-string">"15_minute"</span>
          <span class="hljs-attr">event:</span> <span class="hljs-string">start</span>
          <span class="hljs-attr">entity_id:</span> <span class="hljs-string">calendar.powercuts</span>
          <span class="hljs-attr">offset:</span> <span class="hljs-number">-00</span><span class="hljs-string">:15:00</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">calendar</span>
          <span class="hljs-attr">id:</span> <span class="hljs-string">"30_minute"</span>
          <span class="hljs-attr">event:</span> <span class="hljs-string">start</span>
          <span class="hljs-attr">entity_id:</span> <span class="hljs-string">calendar.powercuts</span>
          <span class="hljs-attr">offset:</span> <span class="hljs-number">-00</span><span class="hljs-string">:30:00</span>
      <span class="hljs-attr">condition:</span>
        <span class="hljs-attr">condition:</span> <span class="hljs-string">and</span>
        <span class="hljs-attr">conditions:</span>
          <span class="hljs-bullet">-</span> <span class="hljs-attr">condition:</span> <span class="hljs-string">state</span>
            <span class="hljs-attr">entity_id:</span> <span class="hljs-string">input_boolean.powercuts</span>
            <span class="hljs-attr">state:</span> <span class="hljs-string">"on"</span>
      <span class="hljs-attr">mode:</span> <span class="hljs-string">single</span>
      <span class="hljs-attr">max_exceeded:</span> <span class="hljs-string">silent</span>
      <span class="hljs-attr">action:</span>
        <span class="hljs-bullet">-</span> <span class="hljs-attr">service:</span> <span class="hljs-string">notify.telegram_home</span>
          <span class="hljs-attr">data:</span>
            <span class="hljs-attr">title:</span> <span class="hljs-string">"⚡*전력 공급 중단*"</span>
            <span class="hljs-attr">message:</span> <span class="hljs-string">"{ trigger.id.split('_')[0] } 분 내에 전력 공급이 중단됩니다."</span>
</code></pre>
<h1>결론</h1>
<p>여러분 중 많은 분들이 국가에서 정전이나 미사일 경보로 걱정할 필요가 없을 수도 있습니다. 하지만 저는 이 기사를 공유하고 싶었습니다. 왜냐하면 제가 소개한 방법과 코드는 여러분의 스마트 홈에서 더 복잡한 자동화를 만드는데 영감을 줄 수 있기 때문입니다. 에너지 사용을 피크 시간에 관리하거나 정교한 아침 루틴을 조정하는 등, AppDaemon은 여러분의 스마트 홈을 더 똑똑하게 만드는 강력한 도구를 제공합니다.</p>
<p>그러니 이러한 도전 없이 사는 행운한 분들이라도, 여기서 유용한 아이디어를 찾아서 여러분의 홈 자동화 프로젝트를 향상시키는 데 도움이 되기를 바랍니다. 결국, 스마트 홈은 우리가 창의적으로 해결책을 찾는 한에만 똑똑할 뿐입니다.</p>
<p>즐거운 자동화!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"앱데몬 마스터하기 홈 어시스턴트 캘린더 이벤트 생성을 위해 텔레그램 데이터 수집하기","description":"","date":"2024-06-19 05:39","slug":"2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_0.png\" /\u003e\n\n요크라이나에서 살면서, 저희 가족은 계속되는 전력 공급 차단 문제를 해결하는 데 익숙해져 왔습니다. 계속되는 갈등과 러시아의 에너지 인프라를 향한 공격 속에서 혹독한 현실이 가정됩니다. 2022년 겨울은 특히 전기 공급이 빈번하고 긴급했던 어려운 시기였습니다. 얼마 동안은 상황이 나아졌지만, 최근 새로운 공격이 시작되면서 전기 공급 차단이 다시 복귀되었습니다.\n\n특히 피크 시간에 전기 부하를 관리하고, 이용 가능한 전력을 가정과 기업 간에 공정하게 나눠주기 위해 당국은 일정을 마련했습니다. 소비자들은 각 그룹으로 나누어져 고정 시간대에 전력 차단을 받게 됩니다. 이러한 일정은 일반적으로 운영자들의 웹사이트나 공개 텔레그램 채널을 통해 하루 전에 발표됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스마트 홈 애호가로서 당연히 이 정전 정보를 내 Home Assistant 시스템에 통합하고 싶었어요. 가능성을 상상해보세요: 수전중이던 전기 온수기 같은 전력 소모 가전제품을 자동으로 끄어 백업 배터리 전력을 절약하거나, 가족에게 \"주의! 30분 후 정전 예정입니다! 핸드폰을 충전하는 시간이에요!\" 라고 음성으로 미리 알려주기도 해봤어요.\n\n하지만 가장 중요한 점은 이 시간표가 매일 동적으로 바뀌며 고정된 발행 시간이 없다는 것이에요. 즉, Home Assistant를 최신 상태로 유지하려면 웹사이트나 텔레그램 채널을 지속적으로 모니터링해야 한다는 것이죠.\n\n# 해결책\n\n제가 선택한 해결책은 Home Assistant의 로컬 캘린더를 사용하여 이 정전 시간표를 처리하는 것이었어요. 저는 이 정전 데이터를 텔레그램 채널에서 스크래핑하기로 결정했는데, 그 이유는 메시지 구조가 제 요구 사항에 딱 맞았기 때문이에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n홈 어시스턴트에는 내장된 스크래이프 통합 및 더 고급 HACS 구성 요소인 Multiscrape(여기서 확인하세요)가 있습니다. 하지만 이러한 도구들을 사용하여 내 문제를 해결하는 방법을 찾지 못했습니다. 아마 가능할지도 모르지만, 제가 Jinja 템플릿과 복잡한 구성에 대한 기술이 부족해서 그렇습니다. 그래서 홈 어시스턴트의 AppDaemon 통합으로 돌아가기로 결정했습니다.\n\n공식 문서에 따르면, \"AppDaemon은 홈 어시스턴트의 자동화 및 스크립팅 구성 요소를 보완하는 하위 시스템입니다.\" 더 간단히 말하면, 이를 통해 Python 코드(앱)를 작성하여 홈 어시스턴트를 제어하고 자동화할 수 있습니다.\n\n다른 프로그래밍 언어에 대한 경험이 있지만, Python은 제게는 새로운 영역이었습니다. 그래서 최신 기술 센세이션이라고 불리는 ChatGPT에 의지했습니다. \"이 인공지능이 분명히 도와줄 것이다!\"라고 생각했지만, 솔직히 말하면 결과는 성공과 실패가 섞였습니다. 옳은 방향으로 나아갈 수 있게 도와줬지만 항상 순조롭지는 않았습니다. 가끔씩 존재하지 않는 함수와 서비스를 제안하기도 했거든요. 올바른 서비스 호출 방법, 변수 전달 방법 및 변수 형식화 방법을 이해하는 데 많은 시간을 소요했습니다.\n\n가장 큰 골칫거리 중 하나는 AppDaemon으로부터 홈 어시스턴트 캘린더에 이미 전원 차단 일정이 있는지 확인하는 방법을 찾는 것이었습니다. 중복된 이벤트를 방지하기 위해서였죠. ChatGPT는 \"calendar.get_events\" 서비스를 사용하여 시간을 지정하여 이미 있는 이벤트를 확인하라고 제안했습니다. 안타깝게도, 이 방법은 AppDaemon 내에서의 제약 사항으로 작동하지 않았습니다. 여러 차례 검색하고 몇 번의 좌절한 한숨 뒤에, Markus Ressel의 매우 유익한 기사(https://markusressel.de/blog/post/calendar-integration-between-home-assistant-and-appdaemon)를 우연히 발견했습니다. 이 기사는 문제의 근본 원인을 이해하게 해주었고, 결국 캘린더 중복 없는 해결책을 찾는 데 도움이 되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n홈 어시스턴트에 AppDaemon을 사용하여 전원 차단 스케줄을 통합하는 방법을 단계별로 안내해 드릴게요.\n\n# 단계 1: 로컬 캘린더 설정\n\n가장 먼저, \"powercuts\"라는 이름의 로컬 캘린더를 홈 어시스턴트에 생성하여 스케줄을 가져올 수 있어요. 다음 방법으로 진행할 수 있어요:\n\n- \"장치 및 서비스\" 페이지로 이동합니다.\n- \"통합 추가\"를 클릭하세요.\n- \"로컬 캘린더\"를 검색하고 선택하세요.\n- 새 캘린더를 설정하고 이름을 \"powercuts\"로 지정하는 안내에 따라 진행하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_1.png\" /\u003e\n\n# 단계 2: AppDaemon 설치\n\n홈 어시스턴트 애드온 스토어로 이동하여 AppDaemon 통합을 설치하세요.\n\n# 단계 3: AppDaemon 구성\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n통합을 시작하기 전에, 앱에서 필요한 Python 패키지를 포함하도록 구성해야 합니다. 제 프로젝트에서는 datetime, requests 및 beautifulsoup4를 추가했습니다. 이러한 패키지를 AppDaemon의 구성 섹션에 추가한 후, 통합을 시작하세요.\n\n![이미지](/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_2.png)\n\n# 단계 4: 올바른 폴더 찾기\n\n홈 어시스턴트의 상위 디렉터리로 이동합니다. 그 안에는 addon_configs라는 폴더가 있습니다. addon_configs 안에는 일반적으로 글자와 숫자의 조합 뒤에 _Appdaemon이 붙은 abcd123_Appdaemon과 같은 이름의 폴더를 찾습니다. 이 폴더 안에 apps라는 다른 폴더가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 5: Python 앱 만들기\n\napps 폴더에 새 Python 파일(.py)을 만드세요. 여기에 코드를 작성할 거에요. 이 파일의 이름과 내부에 사용하는 클래스 이름은 중요합니다. 나중에 apps.yaml 파일에서 이들을 참조할 거니까요.\n\n예를 들어, powercut_scraper.py라는 파일을 만들고 PowercutScraper 클래스를 사용하면, AppDaemon을 구성할 때 코드를 찾을 위치를 알려줄 때 이 이름들을 사용해야 합니다.\n\n```js\n# apps/powercut_scraper_web.py\n\nimport appdaemon.plugins.hass.hassapi as hass\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\nfrom datetime import datetime, timedelta\n\nclass PowercutScraperWeb(hass.Hass):\n\n    def initialize(self):\n        # Configuration\n        self.url = \"https://t.me/s/pat_cherkasyoblenergo\"\n        self.queue_number = 3  # 확인해야 할 대기 번호\n        self.calendar_entity = \"calendar.powercuts\"\n        self.months_uk = {\n            \"січня\": \"01\", \"лютого\": \"02\", \"березня\": \"03\", \"квітня\": \"04\", \n            \"травня\": \"05\", \"червня\": \"06\", \"липня\": \"07\", \"серпня\": \"08\", \n            \"вересня\": \"09\", \"жовтня\": \"10\", \"листопада\": \"11\", \"грудня\": \"12\"\n        }\n        self.current_year = datetime.now().year\n\n        # homeassistant 이벤트 청취\n        self.listen_event(self.scrape_messages, \"tele_powercut_scraper_event\")\n        # self.run_every(self.scrape_messages, \"now\", 3600)\n        \n    def scrape_messages(self, event_name, data, kwargs):\n        # 웹페이지 가져오기\n        response = requests.get(self.url)\n        if response.status_code != 200:\n            self.error(f\"웹페이지 가져오기 실패: {response.status_code}\")\n            return\n\n        # 웹페이지 내용 파싱\n        soup = BeautifulSoup(response.content, 'html.parser')\n        messages = soup.find_all('div', class_='tgme_widget_message_text')\n\n        for message in messages:\n            date = self.extract_date(message.get_text())\n            schedules = self.extract_schedules(message.get_text())\n            if date and schedules:\n                self.update_calendar(date, schedules)\n\n    \n    def extract_schedules(self, message):\n        pattern = re.compile(r'(\\d{2}:\\d{2}-\\d{2}:\\d{2})\\s*([0-9\\sта,.;:!?]*черг[а|и])')\n        matches = pattern.findall(message)\n        relevant_schedules = []\n\n        for match in matches:\n            time_range = match[0]\n            queue_info = match[1]\n\n            # queue_info에서 모든 숫자 추출\n            queue_numbers = re.findall(r'\\d+', queue_info)\n\n            # 대기 번호 중 하나라도 self.queue_number와 일치하는지 확인\n            if any(int(queue_number) == self.queue_number for queue_number in queue_numbers):\n                relevant_schedules.append(time_range)\n        self.log(relevant_schedules)\n        return relevant_schedules\n    \n    def extract_date(self, message):\n        date_pattern = re.compile(r'(\\d{2})\\s([а-я]+)')\n        match = date_pattern.search(message)\n        if match:\n            day = match.group(1)    \n            month_uk = match.group(2)\n            if month_uk in self.months_uk:\n                month = self.months_uk[month_uk]\n                return f\"{day}.{month}.{self.current_year}\"\n        return None\n\n    def update_calendar(self, date, time_slots):\n        # 오늘 이후인지 확인하는 날짜 비교\n        date_obj = datetime.strptime(date, \"%d.%m.%Y\")\n        today = datetime.today().replace(hour=0, minute=0, second=0, microsecond=0)\n        if date_obj \u003e= today:\n            # 시간 슬롯 결합\n            combined_slots = self.combine_time_slots(date, time_slots)\n            for slot in combined_slots:\n                start_time, end_time = slot.split('-')\n                event_start = datetime.strptime(f\"{date} {start_time}\", \"%d.%m.%Y %H:%M\").strftime(\"%Y-%m-%dT%H:%M:%S\")\n                event_end = datetime.strptime(f\"{date} {end_time}\", \"%d.%m.%Y %H:%M\").strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n                self.call_service(\n                    \"script/create_powercut_calendar_events\", \n                    start_date_time=event_start, \n                    end_date_time=event_end\n                    \n                )\n        else:\n            self.log(f\"과거 날짜에 대한 캘린더 업데이트 건너뛰기: {date}\")\n\n    def combine_time_slots(self, date, time_slots):\n            if not time_slots:\n                self.log(f\"{date}에 결합할 시간 슬롯이 없어요.\")\n                return []\n\n            # 시간 슬롯 구문 분석 및 정렬\n            slots = []\n            for slot in time_slots:\n                start_time, end_time = slot.split('-')\n                if end_time == \"24:00\":\n                    end_time = \"23:59\"\n                start = datetime.strptime(f\"{date} {start_time}\", \"%d.%m.%Y %H:%M\")\n                end = datetime.strptime(f\"{date} {end_time}\", \"%d.%m.%Y %H:%M\")\n                slots.append((start, end))\n\n            slots.sort()\n\n            # 겹치거나 연속된 시간 슬롯 병합\n            merged_slots = []\n            current_start, current_end = slots[0]\n\n            for start, end in slots[1:]:\n                if start \u003c= current_end:\n                    # 현재 시간 슬롯 확장\n                    current_end = max(current_end, end)\n                else:\n                    # 겹침 없음, 현재 시간 슬롯 추가 및 새로 시작\n                    merged_slots.append((current_start, current_end))\n                    current_start, current_end = start, end\n\n            # 마지막 시간 슬롯 추가\n            merged_slots.append((current_start, current_end))\n\n            # 병합된 시간 슬롯을 다시 문자열로 변환\n            combined_slots = [f\"{start.strftime('%H:%M')}-{end.strftime('%H:%M')}\" for start, end in merged_slots]\n            return combined_slots\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 6: apps.yaml에서 앱 구성하기\n\napps 폴더 안에 apps.yaml 파일이 있을 것입니다. 이 파일은 AppDaemon에게 사용자 정의 앱에 대해 알려줍니다. 다음과 같이 항목을 추가해보세요:\n\n```js\npowercut_scraper_web:\n  module: powercut_scraper_web  # .py 확장자를 제외한 파일명입니다\n  class: PowercutScraperWeb # 파일 내부의 클래스 이름입니다\n```\n\n이 구성은 AppDaemon에 앱을 연결하여 코드를 찾고 실행할 위치를 알려줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 단계 7: 코드 흐름 이해하기\n\n- 코드 트리거: 코드는 \"tele_powercut_scraper_event\"라는 이벤트에 의해 트리거되며, 이 이벤트는 Multiscrape 구성 요소를 사용하여 생성된 이진 센서가 켜졌을 때 발생합니다. 제가 이 센서를 이전에 설정했으므로 트리거로 사용했습니다. 원하는 경우 앱을 몇 분마다 실행하도록 예약할 수도 있습니다.\n- 텔레그램 채널 스크랩: 코드는 텔레그램 채널의 메시지를 통해 날짜와 일정을 찾습니다. 둘 다 발견되면 캘린더를 업데이트하는 함수를 호출합니다.\n- 캘린더 업데이트: 이 함수는 먼저 오늘보다 이전인 전력 공급 차단 날짜를 무시합니다 (과거 이벤트에 대해 걱정할 필요가 없습니다). 관련 메시지의 경우 연속된 시간 단위 슬롯을 더 큰 블록으로 결합합니다 (일정은 1시간 간격으로 제공됨).\n\n![이미지](/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_3.png)\n\n- 중복 확인: 이 단계에서 이상적으로는 calendar.get_events 서비스를 호출하여 캘린더에 이미 이벤트가 있는지 확인해야 합니다. 그러나 이전에 언급했듯이 AppDaemon은이 서비스를 지원하지 않습니다. 따라서 필요한 경우 기존 항목을 확인하고 필요한 경우 새 항목을 만드는 Home Assistant 스크립트를 호출함으로써 이 문제를 해결했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요약하면, AppDaemon 앱은 텔레그램 채널에서 데이터를 스크랩하고 정리한 후 HA에 관련 시간 슬롯을 전송하여 캘린더에 새 이벤트를 생성합니다. 아래는 이진 센서와 스크립트 코드입니다:\n\n```js\n  multiscrape:\n    - name: Cherkasy powercut alert\n      resource: https://t.me/s/pat_cherkasyoblenergo\n      scan_interval: 30\n      list_separator: \"|||\"\n      binary_sensor:\n        - unique_id: energy_sensor_powercut_alert_oblenergo\n          name: Cherkasy powercut alert\n          icon: mdi:transmission-tower-export\n          device_class: power\n          select_list: \".js-message_text\"\n          value_template: \u003e-\n            { set message = value.split(\"|||\") | last | lower }\n            { \"годин\" in message and \"відсутност\" in message and \"електропостача\" in message}\n          attributes:         \n            - name: latest_message_date\n              select_list: \".js-message_text\"\n              value_template: \u003e-\n                { set message = value.split('|||') | last }\n                { set date_match = message | regex_findall_index(\"(\\d{1,2}\\s(?:січня|лютого|березня|квітня|травня|червня|липня|серпня|вересня|жовтня|листопада|грудня))\", 0) }\n                { set months_uk = {\n                            'січня': '01', 'лютого': '02', 'березня': '03', 'квітня': '04', \n                            'травня': '05', 'червня': '06', 'липня': '07', 'серпня': '08', \n                            'вересня': '09', 'жовтня': '10', 'листопада': '11', 'грудня': '12'\n                          } }\n                { if date_match }\n                  { set day = date_match.split(' ')[0] }\n                  { set month_uk = date_match.split(' ')[1] }\n                  { set month = months_uk[month_uk] }\n                  { set year = now().year }\n                  {  as_datetime(strptime('{}-{}-{} 00:00:00'.format(year, month, day),'%Y-%m-%d %H:%M:%S')) } \n                { else }\n                  { 'Date not found' }\n                { endif }  \n            - name: latest_message\n              select_list: \".js-message_text\"\n              value_template: \u003e\n                { value.split('|||') | last | regex_findall('\\d{2}:\\d{2}-\\d{2}:\\d{2}\\s*[0-9\\sта,.;:!?]*черг[а|и]')| join('\\n') }\r\n```\n\n```js\r\n  script:\n    create_powercut_calendar_events:\n      mode: parallel\n      sequence:\n        - service: calendar.get_events\n          target:\n            entity_id: calendar.powercuts\n          data:\n            start_date_time: \"{ start_date_time }\"\n            end_date_time: \"{ end_date_time }\" \n          response_variable: agenda\n        - if: \"{ not agenda['calendar.powercuts'].events| map(attribute='summary')| list| count \u003e 0 }\" \n          then:\n            - service: calendar.create_event\n              target:\n                entity_id: calendar.powercuts\n              data:\n                summary: Power cut\n                description: \u003e-\n                  Scheduled Powercut data from Oblenergo telegram channel, auto created from appdaemon script\n                start_date_time: \"{ start_date_time }\"\n                end_date_time: \"{ end_date_time }\"      \r\n```\n\n# 단계 8: 자동화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAppdaemon 스크립트를 트리거하는 자동화:\n\n```yaml\n    - alias: 새로운 전원 공급 일정 - 캘린더에 추가\n      id: \"vdgadsfwerwfsdgasdsdxxkOOcKAo\"\n      initial_state: \"on\"\n      trigger:\n        - platform: state\n          entity_id: binary_sensor.energy_sensor_powercut_alert_oblenergo\n          attribute: latest_message\n        - platform: time\n          at: '23:45:00'\n        - platform: homeassistant\n          event: start\n      mode: single\n      max_exceeded: silent\n      action:\n        - event: tele_powercut_scraper_event\n          event_data:\n            date: \"{ now().strftime('%Y-%m-%d') }\"\n```\n\n이 정보를 자동화하는 방법의 예시입니다:\n\n```yaml\n    - alias: \"전원 정전 알림\"\n      id: \"automation_notification_home_powercut_notification\"\n      trigger:\n        - platform: calendar\n          id: \"5_minute\"\n          event: start\n          entity_id: calendar.powercuts\n          offset: -00:05:00\n        - platform: calendar\n          id: \"15_minute\"\n          event: start\n          entity_id: calendar.powercuts\n          offset: -00:15:00\n        - platform: calendar\n          id: \"30_minute\"\n          event: start\n          entity_id: calendar.powercuts\n          offset: -00:30:00\n      condition:\n        condition: and\n        conditions:\n          - condition: state\n            entity_id: input_boolean.powercuts\n            state: \"on\"\n      mode: single\n      max_exceeded: silent\n      action:\n        - service: notify.telegram_home\n          data:\n            title: \"⚡*전력 공급 중단*\"\n            message: \"{ trigger.id.split('_')[0] } 분 내에 전력 공급이 중단됩니다.\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n여러분 중 많은 분들이 국가에서 정전이나 미사일 경보로 걱정할 필요가 없을 수도 있습니다. 하지만 저는 이 기사를 공유하고 싶었습니다. 왜냐하면 제가 소개한 방법과 코드는 여러분의 스마트 홈에서 더 복잡한 자동화를 만드는데 영감을 줄 수 있기 때문입니다. 에너지 사용을 피크 시간에 관리하거나 정교한 아침 루틴을 조정하는 등, AppDaemon은 여러분의 스마트 홈을 더 똑똑하게 만드는 강력한 도구를 제공합니다.\n\n그러니 이러한 도전 없이 사는 행운한 분들이라도, 여기서 유용한 아이디어를 찾아서 여러분의 홈 자동화 프로젝트를 향상시키는 데 도움이 되기를 바랍니다. 결국, 스마트 홈은 우리가 창의적으로 해결책을 찾는 한에만 똑똑할 뿐입니다.\n\n즐거운 자동화!","ogImage":{"url":"/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_0.png"},"coverImage":"/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_0.png","tag":["Tech"],"readingTime":15},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e요크라이나에서 살면서, 저희 가족은 계속되는 전력 공급 차단 문제를 해결하는 데 익숙해져 왔습니다. 계속되는 갈등과 러시아의 에너지 인프라를 향한 공격 속에서 혹독한 현실이 가정됩니다. 2022년 겨울은 특히 전기 공급이 빈번하고 긴급했던 어려운 시기였습니다. 얼마 동안은 상황이 나아졌지만, 최근 새로운 공격이 시작되면서 전기 공급 차단이 다시 복귀되었습니다.\u003c/p\u003e\n\u003cp\u003e특히 피크 시간에 전기 부하를 관리하고, 이용 가능한 전력을 가정과 기업 간에 공정하게 나눠주기 위해 당국은 일정을 마련했습니다. 소비자들은 각 그룹으로 나누어져 고정 시간대에 전력 차단을 받게 됩니다. 이러한 일정은 일반적으로 운영자들의 웹사이트나 공개 텔레그램 채널을 통해 하루 전에 발표됩니다.\u003c/p\u003e\n\u003cp\u003e스마트 홈 애호가로서 당연히 이 정전 정보를 내 Home Assistant 시스템에 통합하고 싶었어요. 가능성을 상상해보세요: 수전중이던 전기 온수기 같은 전력 소모 가전제품을 자동으로 끄어 백업 배터리 전력을 절약하거나, 가족에게 \"주의! 30분 후 정전 예정입니다! 핸드폰을 충전하는 시간이에요!\" 라고 음성으로 미리 알려주기도 해봤어요.\u003c/p\u003e\n\u003cp\u003e하지만 가장 중요한 점은 이 시간표가 매일 동적으로 바뀌며 고정된 발행 시간이 없다는 것이에요. 즉, Home Assistant를 최신 상태로 유지하려면 웹사이트나 텔레그램 채널을 지속적으로 모니터링해야 한다는 것이죠.\u003c/p\u003e\n\u003ch1\u003e해결책\u003c/h1\u003e\n\u003cp\u003e제가 선택한 해결책은 Home Assistant의 로컬 캘린더를 사용하여 이 정전 시간표를 처리하는 것이었어요. 저는 이 정전 데이터를 텔레그램 채널에서 스크래핑하기로 결정했는데, 그 이유는 메시지 구조가 제 요구 사항에 딱 맞았기 때문이에요.\u003c/p\u003e\n\u003cp\u003e홈 어시스턴트에는 내장된 스크래이프 통합 및 더 고급 HACS 구성 요소인 Multiscrape(여기서 확인하세요)가 있습니다. 하지만 이러한 도구들을 사용하여 내 문제를 해결하는 방법을 찾지 못했습니다. 아마 가능할지도 모르지만, 제가 Jinja 템플릿과 복잡한 구성에 대한 기술이 부족해서 그렇습니다. 그래서 홈 어시스턴트의 AppDaemon 통합으로 돌아가기로 결정했습니다.\u003c/p\u003e\n\u003cp\u003e공식 문서에 따르면, \"AppDaemon은 홈 어시스턴트의 자동화 및 스크립팅 구성 요소를 보완하는 하위 시스템입니다.\" 더 간단히 말하면, 이를 통해 Python 코드(앱)를 작성하여 홈 어시스턴트를 제어하고 자동화할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다른 프로그래밍 언어에 대한 경험이 있지만, Python은 제게는 새로운 영역이었습니다. 그래서 최신 기술 센세이션이라고 불리는 ChatGPT에 의지했습니다. \"이 인공지능이 분명히 도와줄 것이다!\"라고 생각했지만, 솔직히 말하면 결과는 성공과 실패가 섞였습니다. 옳은 방향으로 나아갈 수 있게 도와줬지만 항상 순조롭지는 않았습니다. 가끔씩 존재하지 않는 함수와 서비스를 제안하기도 했거든요. 올바른 서비스 호출 방법, 변수 전달 방법 및 변수 형식화 방법을 이해하는 데 많은 시간을 소요했습니다.\u003c/p\u003e\n\u003cp\u003e가장 큰 골칫거리 중 하나는 AppDaemon으로부터 홈 어시스턴트 캘린더에 이미 전원 차단 일정이 있는지 확인하는 방법을 찾는 것이었습니다. 중복된 이벤트를 방지하기 위해서였죠. ChatGPT는 \"calendar.get_events\" 서비스를 사용하여 시간을 지정하여 이미 있는 이벤트를 확인하라고 제안했습니다. 안타깝게도, 이 방법은 AppDaemon 내에서의 제약 사항으로 작동하지 않았습니다. 여러 차례 검색하고 몇 번의 좌절한 한숨 뒤에, Markus Ressel의 매우 유익한 기사(\u003ca href=\"https://markusressel.de/blog/post/calendar-integration-between-home-assistant-and-appdaemon)%EB%A5%BC\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://markusressel.de/blog/post/calendar-integration-between-home-assistant-and-appdaemon)를\u003c/a\u003e 우연히 발견했습니다. 이 기사는 문제의 근본 원인을 이해하게 해주었고, 결국 캘린더 중복 없는 해결책을 찾는 데 도움이 되었습니다.\u003c/p\u003e\n\u003cp\u003e홈 어시스턴트에 AppDaemon을 사용하여 전원 차단 스케줄을 통합하는 방법을 단계별로 안내해 드릴게요.\u003c/p\u003e\n\u003ch1\u003e단계 1: 로컬 캘린더 설정\u003c/h1\u003e\n\u003cp\u003e가장 먼저, \"powercuts\"라는 이름의 로컬 캘린더를 홈 어시스턴트에 생성하여 스케줄을 가져올 수 있어요. 다음 방법으로 진행할 수 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\"장치 및 서비스\" 페이지로 이동합니다.\u003c/li\u003e\n\u003cli\u003e\"통합 추가\"를 클릭하세요.\u003c/li\u003e\n\u003cli\u003e\"로컬 캘린더\"를 검색하고 선택하세요.\u003c/li\u003e\n\u003cli\u003e새 캘린더를 설정하고 이름을 \"powercuts\"로 지정하는 안내에 따라 진행하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e단계 2: AppDaemon 설치\u003c/h1\u003e\n\u003cp\u003e홈 어시스턴트 애드온 스토어로 이동하여 AppDaemon 통합을 설치하세요.\u003c/p\u003e\n\u003ch1\u003e단계 3: AppDaemon 구성\u003c/h1\u003e\n\u003cp\u003e통합을 시작하기 전에, 앱에서 필요한 Python 패키지를 포함하도록 구성해야 합니다. 제 프로젝트에서는 datetime, requests 및 beautifulsoup4를 추가했습니다. 이러한 패키지를 AppDaemon의 구성 섹션에 추가한 후, 통합을 시작하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e단계 4: 올바른 폴더 찾기\u003c/h1\u003e\n\u003cp\u003e홈 어시스턴트의 상위 디렉터리로 이동합니다. 그 안에는 addon_configs라는 폴더가 있습니다. addon_configs 안에는 일반적으로 글자와 숫자의 조합 뒤에 _Appdaemon이 붙은 abcd123_Appdaemon과 같은 이름의 폴더를 찾습니다. 이 폴더 안에 apps라는 다른 폴더가 있습니다.\u003c/p\u003e\n\u003ch1\u003e단계 5: Python 앱 만들기\u003c/h1\u003e\n\u003cp\u003eapps 폴더에 새 Python 파일(.py)을 만드세요. 여기에 코드를 작성할 거에요. 이 파일의 이름과 내부에 사용하는 클래스 이름은 중요합니다. 나중에 apps.yaml 파일에서 이들을 참조할 거니까요.\u003c/p\u003e\n\u003cp\u003e예를 들어, powercut_scraper.py라는 파일을 만들고 PowercutScraper 클래스를 사용하면, AppDaemon을 구성할 때 코드를 찾을 위치를 알려줄 때 이 이름들을 사용해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# apps/powercut_scraper_web.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e appdaemon.\u003cspan class=\"hljs-property\"\u003eplugins\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ehass\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ehassapi\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e hass\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e requests\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e bs4 \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBeautifulSoup\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e re\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e datetime \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e datetime, timedelta\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePowercutScraperWeb\u003c/span\u003e(hass.\u003cspan class=\"hljs-property\"\u003eHass\u003c/span\u003e):\n\n    def \u003cspan class=\"hljs-title function_\"\u003einitialize\u003c/span\u003e(self):\n        # \u003cspan class=\"hljs-title class_\"\u003eConfiguration\u003c/span\u003e\n        self.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"https://t.me/s/pat_cherkasyoblenergo\"\u003c/span\u003e\n        self.\u003cspan class=\"hljs-property\"\u003equeue_number\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e  # 확인해야 할 대기 번호\n        self.\u003cspan class=\"hljs-property\"\u003ecalendar_entity\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"calendar.powercuts\"\u003c/span\u003e\n        self.\u003cspan class=\"hljs-property\"\u003emonths_uk\u003c/span\u003e = {\n            \u003cspan class=\"hljs-string\"\u003e\"січня\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"01\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"лютого\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"02\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"березня\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"03\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"квітня\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"04\"\u003c/span\u003e, \n            \u003cspan class=\"hljs-string\"\u003e\"травня\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"05\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"червня\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"06\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"липня\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"07\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"серпня\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"08\"\u003c/span\u003e, \n            \u003cspan class=\"hljs-string\"\u003e\"вересня\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"09\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"жовтня\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"10\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"листопада\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"11\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"грудня\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"12\"\u003c/span\u003e\n        }\n        self.\u003cspan class=\"hljs-property\"\u003ecurrent_year\u003c/span\u003e = datetime.\u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eyear\u003c/span\u003e\n\n        # homeassistant 이벤트 청취\n        self.\u003cspan class=\"hljs-title function_\"\u003elisten_event\u003c/span\u003e(self.\u003cspan class=\"hljs-property\"\u003escrape_messages\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"tele_powercut_scraper_event\"\u003c/span\u003e)\n        # self.\u003cspan class=\"hljs-title function_\"\u003erun_every\u003c/span\u003e(self.\u003cspan class=\"hljs-property\"\u003escrape_messages\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"now\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3600\u003c/span\u003e)\n        \n    def \u003cspan class=\"hljs-title function_\"\u003escrape_messages\u003c/span\u003e(self, event_name, data, kwargs):\n        # 웹페이지 가져오기\n        response = requests.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(self.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e response.\u003cspan class=\"hljs-property\"\u003estatus_code\u003c/span\u003e != \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e:\n            self.\u003cspan class=\"hljs-title function_\"\u003eerror\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"웹페이지 가져오기 실패: {response.status_code}\"\u003c/span\u003e)\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n\n        # 웹페이지 내용 파싱\n        soup = \u003cspan class=\"hljs-title class_\"\u003eBeautifulSoup\u003c/span\u003e(response.\u003cspan class=\"hljs-property\"\u003econtent\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'html.parser'\u003c/span\u003e)\n        messages = soup.\u003cspan class=\"hljs-title function_\"\u003efind_all\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'div'\u003c/span\u003e, class_=\u003cspan class=\"hljs-string\"\u003e'tgme_widget_message_text'\u003c/span\u003e)\n\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e message \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003emessages\u003c/span\u003e:\n            date = self.\u003cspan class=\"hljs-title function_\"\u003eextract_date\u003c/span\u003e(message.\u003cspan class=\"hljs-title function_\"\u003eget_text\u003c/span\u003e())\n            schedules = self.\u003cspan class=\"hljs-title function_\"\u003eextract_schedules\u003c/span\u003e(message.\u003cspan class=\"hljs-title function_\"\u003eget_text\u003c/span\u003e())\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e date and \u003cspan class=\"hljs-attr\"\u003eschedules\u003c/span\u003e:\n                self.\u003cspan class=\"hljs-title function_\"\u003eupdate_calendar\u003c/span\u003e(date, schedules)\n\n    \n    def \u003cspan class=\"hljs-title function_\"\u003eextract_schedules\u003c/span\u003e(self, message):\n        pattern = re.\u003cspan class=\"hljs-title function_\"\u003ecompile\u003c/span\u003e(r\u003cspan class=\"hljs-string\"\u003e'(\\d{2}:\\d{2}-\\d{2}:\\d{2})\\s*([0-9\\sта,.;:!?]*черг[а|и])'\u003c/span\u003e)\n        matches = pattern.\u003cspan class=\"hljs-title function_\"\u003efindall\u003c/span\u003e(message)\n        relevant_schedules = []\n\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e match \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ematches\u003c/span\u003e:\n            time_range = match[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n            queue_info = match[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n\n            # queue_info에서 모든 숫자 추출\n            queue_numbers = re.\u003cspan class=\"hljs-title function_\"\u003efindall\u003c/span\u003e(r\u003cspan class=\"hljs-string\"\u003e'\\d+'\u003c/span\u003e, queue_info)\n\n            # 대기 번호 중 하나라도 self.\u003cspan class=\"hljs-property\"\u003equeue_number\u003c/span\u003e와 일치하는지 확인\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eany\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eint\u003c/span\u003e(queue_number) == self.\u003cspan class=\"hljs-property\"\u003equeue_number\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e queue_number \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e queue_numbers):\n                relevant_schedules.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(time_range)\n        self.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(relevant_schedules)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e relevant_schedules\n    \n    def \u003cspan class=\"hljs-title function_\"\u003eextract_date\u003c/span\u003e(self, message):\n        date_pattern = re.\u003cspan class=\"hljs-title function_\"\u003ecompile\u003c/span\u003e(r\u003cspan class=\"hljs-string\"\u003e'(\\d{2})\\s([а-я]+)'\u003c/span\u003e)\n        match = date_pattern.\u003cspan class=\"hljs-title function_\"\u003esearch\u003c/span\u003e(message)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ematch\u003c/span\u003e:\n            day = match.\u003cspan class=\"hljs-title function_\"\u003egroup\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)    \n            month_uk = match.\u003cspan class=\"hljs-title function_\"\u003egroup\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e month_uk \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003emonths_uk\u003c/span\u003e:\n                month = self.\u003cspan class=\"hljs-property\"\u003emonths_uk\u003c/span\u003e[month_uk]\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e f\u003cspan class=\"hljs-string\"\u003e\"{day}.{month}.{self.current_year}\"\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n\n    def \u003cspan class=\"hljs-title function_\"\u003eupdate_calendar\u003c/span\u003e(self, date, time_slots):\n        # 오늘 이후인지 확인하는 날짜 비교\n        date_obj = datetime.\u003cspan class=\"hljs-title function_\"\u003estrptime\u003c/span\u003e(date, \u003cspan class=\"hljs-string\"\u003e\"%d.%m.%Y\"\u003c/span\u003e)\n        today = datetime.\u003cspan class=\"hljs-title function_\"\u003etoday\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(hour=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, minute=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, second=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, microsecond=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e date_obj \u003e= \u003cspan class=\"hljs-attr\"\u003etoday\u003c/span\u003e:\n            # 시간 슬롯 결합\n            combined_slots = self.\u003cspan class=\"hljs-title function_\"\u003ecombine_time_slots\u003c/span\u003e(date, time_slots)\n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e slot \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecombined_slots\u003c/span\u003e:\n                start_time, end_time = slot.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'-'\u003c/span\u003e)\n                event_start = datetime.\u003cspan class=\"hljs-title function_\"\u003estrptime\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{date} {start_time}\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"%d.%m.%Y %H:%M\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003estrftime\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%Y-%m-%dT%H:%M:%S\"\u003c/span\u003e)\n                event_end = datetime.\u003cspan class=\"hljs-title function_\"\u003estrptime\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{date} {end_time}\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"%d.%m.%Y %H:%M\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003estrftime\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"%Y-%m-%dT%H:%M:%S\"\u003c/span\u003e)\n\n                self.\u003cspan class=\"hljs-title function_\"\u003ecall_service\u003c/span\u003e(\n                    \u003cspan class=\"hljs-string\"\u003e\"script/create_powercut_calendar_events\"\u003c/span\u003e, \n                    start_date_time=event_start, \n                    end_date_time=event_end\n                    \n                )\n        \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n            self.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"과거 날짜에 대한 캘린더 업데이트 건너뛰기: {date}\"\u003c/span\u003e)\n\n    def \u003cspan class=\"hljs-title function_\"\u003ecombine_time_slots\u003c/span\u003e(self, date, time_slots):\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not \u003cspan class=\"hljs-attr\"\u003etime_slots\u003c/span\u003e:\n                self.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{date}에 결합할 시간 슬롯이 없어요.\"\u003c/span\u003e)\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e []\n\n            # 시간 슬롯 구문 분석 및 정렬\n            slots = []\n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e slot \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etime_slots\u003c/span\u003e:\n                start_time, end_time = slot.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'-'\u003c/span\u003e)\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e end_time == \u003cspan class=\"hljs-string\"\u003e\"24:00\"\u003c/span\u003e:\n                    end_time = \u003cspan class=\"hljs-string\"\u003e\"23:59\"\u003c/span\u003e\n                start = datetime.\u003cspan class=\"hljs-title function_\"\u003estrptime\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{date} {start_time}\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"%d.%m.%Y %H:%M\"\u003c/span\u003e)\n                end = datetime.\u003cspan class=\"hljs-title function_\"\u003estrptime\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{date} {end_time}\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"%d.%m.%Y %H:%M\"\u003c/span\u003e)\n                slots.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e((start, end))\n\n            slots.\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e()\n\n            # 겹치거나 연속된 시간 슬롯 병합\n            merged_slots = []\n            current_start, current_end = slots[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n\n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e start, end \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e slots[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:]:\n                \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e start \u0026#x3C;= \u003cspan class=\"hljs-attr\"\u003ecurrent_end\u003c/span\u003e:\n                    # 현재 시간 슬롯 확장\n                    current_end = \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(current_end, end)\n                \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n                    # 겹침 없음, 현재 시간 슬롯 추가 및 새로 시작\n                    merged_slots.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e((current_start, current_end))\n                    current_start, current_end = start, end\n\n            # 마지막 시간 슬롯 추가\n            merged_slots.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e((current_start, current_end))\n\n            # 병합된 시간 슬롯을 다시 문자열로 변환\n            combined_slots = [f\u003cspan class=\"hljs-string\"\u003e\"{start.strftime('%H:%M')}-{end.strftime('%H:%M')}\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e start, end \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e merged_slots]\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e combined_slots\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 6: apps.yaml에서 앱 구성하기\u003c/h1\u003e\n\u003cp\u003eapps 폴더 안에 apps.yaml 파일이 있을 것입니다. 이 파일은 AppDaemon에게 사용자 정의 앱에 대해 알려줍니다. 다음과 같이 항목을 추가해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003epowercut_scraper_web\u003c/span\u003e:\n  \u003cspan class=\"hljs-attr\"\u003emodule\u003c/span\u003e: powercut_scraper_web  # .\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e 확장자를 제외한 파일명입니다\n  \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePowercutScraperWeb\u003c/span\u003e # 파일 내부의 클래스 이름입니다\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 구성은 AppDaemon에 앱을 연결하여 코드를 찾고 실행할 위치를 알려줍니다.\u003c/p\u003e\n\u003ch1\u003e단계 7: 코드 흐름 이해하기\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e코드 트리거: 코드는 \"tele_powercut_scraper_event\"라는 이벤트에 의해 트리거되며, 이 이벤트는 Multiscrape 구성 요소를 사용하여 생성된 이진 센서가 켜졌을 때 발생합니다. 제가 이 센서를 이전에 설정했으므로 트리거로 사용했습니다. 원하는 경우 앱을 몇 분마다 실행하도록 예약할 수도 있습니다.\u003c/li\u003e\n\u003cli\u003e텔레그램 채널 스크랩: 코드는 텔레그램 채널의 메시지를 통해 날짜와 일정을 찾습니다. 둘 다 발견되면 캘린더를 업데이트하는 함수를 호출합니다.\u003c/li\u003e\n\u003cli\u003e캘린더 업데이트: 이 함수는 먼저 오늘보다 이전인 전력 공급 차단 날짜를 무시합니다 (과거 이벤트에 대해 걱정할 필요가 없습니다). 관련 메시지의 경우 연속된 시간 단위 슬롯을 더 큰 블록으로 결합합니다 (일정은 1시간 간격으로 제공됨).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e중복 확인: 이 단계에서 이상적으로는 calendar.get_events 서비스를 호출하여 캘린더에 이미 이벤트가 있는지 확인해야 합니다. 그러나 이전에 언급했듯이 AppDaemon은이 서비스를 지원하지 않습니다. 따라서 필요한 경우 기존 항목을 확인하고 필요한 경우 새 항목을 만드는 Home Assistant 스크립트를 호출함으로써 이 문제를 해결했습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e요약하면, AppDaemon 앱은 텔레그램 채널에서 데이터를 스크랩하고 정리한 후 HA에 관련 시간 슬롯을 전송하여 캘린더에 새 이벤트를 생성합니다. 아래는 이진 센서와 스크립트 코드입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  \u003cspan class=\"hljs-attr\"\u003emultiscrape\u003c/span\u003e:\n    - \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCherkasy\u003c/span\u003e powercut alert\n      \u003cspan class=\"hljs-attr\"\u003eresource\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//t.me/s/pat_cherkasyoblenergo\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003escan_interval\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003elist_separator\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"|||\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ebinary_sensor\u003c/span\u003e:\n        - \u003cspan class=\"hljs-attr\"\u003eunique_id\u003c/span\u003e: energy_sensor_powercut_alert_oblenergo\n          \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCherkasy\u003c/span\u003e powercut alert\n          \u003cspan class=\"hljs-attr\"\u003eicon\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003emdi\u003c/span\u003e:transmission-tower-\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003edevice_class\u003c/span\u003e: power\n          \u003cspan class=\"hljs-attr\"\u003eselect_list\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\".js-message_text\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003evalue_template\u003c/span\u003e: \u003e-\n            { set message = value.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"|||\"\u003c/span\u003e) | last | lower }\n            { \u003cspan class=\"hljs-string\"\u003e\"годин\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e message and \u003cspan class=\"hljs-string\"\u003e\"відсутност\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e message and \u003cspan class=\"hljs-string\"\u003e\"електропостача\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e message}\n          \u003cspan class=\"hljs-attr\"\u003eattributes\u003c/span\u003e:         \n            - \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: latest_message_date\n              \u003cspan class=\"hljs-attr\"\u003eselect_list\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\".js-message_text\"\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003evalue_template\u003c/span\u003e: \u003e-\n                { set message = value.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'|||'\u003c/span\u003e) | last }\n                { set date_match = message | \u003cspan class=\"hljs-title function_\"\u003eregex_findall_index\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"(\\d{1,2}\\s(?:січня|лютого|березня|квітня|травня|червня|липня|серпня|вересня|жовтня|листопада|грудня))\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) }\n                { set months_uk = {\n                            \u003cspan class=\"hljs-string\"\u003e'січня'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'01'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'лютого'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'02'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'березня'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'03'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'квітня'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'04'\u003c/span\u003e, \n                            \u003cspan class=\"hljs-string\"\u003e'травня'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'05'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'червня'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'06'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'липня'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'07'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'серпня'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'08'\u003c/span\u003e, \n                            \u003cspan class=\"hljs-string\"\u003e'вересня'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'09'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'жовтня'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'10'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'листопада'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'11'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'грудня'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'12'\u003c/span\u003e\n                          } }\n                { \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e date_match }\n                  { set day = date_match.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e' '\u003c/span\u003e)[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] }\n                  { set month_uk = date_match.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e' '\u003c/span\u003e)[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] }\n                  { set month = months_uk[month_uk] }\n                  { set year = \u003cspan class=\"hljs-title function_\"\u003enow\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003eyear\u003c/span\u003e }\n                  {  \u003cspan class=\"hljs-title function_\"\u003eas_datetime\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003estrptime\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'{}-{}-{} 00:00:00'\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eformat\u003c/span\u003e(year, month, day),\u003cspan class=\"hljs-string\"\u003e'%Y-%m-%d %H:%M:%S'\u003c/span\u003e)) } \n                { \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e }\n                  { \u003cspan class=\"hljs-string\"\u003e'Date not found'\u003c/span\u003e }\n                { endif }  \n            - \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: latest_message\n              \u003cspan class=\"hljs-attr\"\u003eselect_list\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\".js-message_text\"\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003evalue_template\u003c/span\u003e: \u003e\n                { value.\u003cspan class=\"hljs-title function_\"\u003esplit\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'|||'\u003c/span\u003e) | last | \u003cspan class=\"hljs-title function_\"\u003eregex_findall\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'\\d{2}:\\d{2}-\\d{2}:\\d{2}\\s*[0-9\\sта,.;:!?]*черг[а|и]'\u003c/span\u003e)| \u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'\\n'\u003c/span\u003e) }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  \u003cspan class=\"hljs-attr\"\u003escript\u003c/span\u003e:\n    \u003cspan class=\"hljs-attr\"\u003ecreate_powercut_calendar_events\u003c/span\u003e:\n      \u003cspan class=\"hljs-attr\"\u003emode\u003c/span\u003e: parallel\n      \u003cspan class=\"hljs-attr\"\u003esequence\u003c/span\u003e:\n        - \u003cspan class=\"hljs-attr\"\u003eservice\u003c/span\u003e: calendar.\u003cspan class=\"hljs-property\"\u003eget_events\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003etarget\u003c/span\u003e:\n            \u003cspan class=\"hljs-attr\"\u003eentity_id\u003c/span\u003e: calendar.\u003cspan class=\"hljs-property\"\u003epowercuts\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e:\n            \u003cspan class=\"hljs-attr\"\u003estart_date_time\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"{ start_date_time }\"\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003eend_date_time\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"{ end_date_time }\"\u003c/span\u003e \n          \u003cspan class=\"hljs-attr\"\u003eresponse_variable\u003c/span\u003e: agenda\n        - \u003cspan class=\"hljs-attr\"\u003eif\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"{ not agenda['calendar.powercuts'].events| map(attribute='summary')| list| count \u003e 0 }\"\u003c/span\u003e \n          \u003cspan class=\"hljs-attr\"\u003ethen\u003c/span\u003e:\n            - \u003cspan class=\"hljs-attr\"\u003eservice\u003c/span\u003e: calendar.\u003cspan class=\"hljs-property\"\u003ecreate_event\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003etarget\u003c/span\u003e:\n                \u003cspan class=\"hljs-attr\"\u003eentity_id\u003c/span\u003e: calendar.\u003cspan class=\"hljs-property\"\u003epowercuts\u003c/span\u003e\n              \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e:\n                \u003cspan class=\"hljs-attr\"\u003esummary\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003ePower\u003c/span\u003e cut\n                \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003e-\n                  \u003cspan class=\"hljs-title class_\"\u003eScheduled\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePowercut\u003c/span\u003e data \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOblenergo\u003c/span\u003e telegram channel, auto created \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e appdaemon script\n                \u003cspan class=\"hljs-attr\"\u003estart_date_time\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"{ start_date_time }\"\u003c/span\u003e\n                \u003cspan class=\"hljs-attr\"\u003eend_date_time\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"{ end_date_time }\"\u003c/span\u003e      \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e단계 8: 자동화\u003c/h1\u003e\n\u003cp\u003eAppdaemon 스크립트를 트리거하는 자동화:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealias:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e새로운\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e전원\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e공급\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e일정\u003c/span\u003e \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e캘린더에\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e추가\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eid:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"vdgadsfwerwfsdgasdsdxxkOOcKAo\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003einitial_state:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"on\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003etrigger:\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eplatform:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003estate\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eentity_id:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ebinary_sensor.energy_sensor_powercut_alert_oblenergo\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eattribute:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003elatest_message\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eplatform:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etime\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eat:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'23:45:00'\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eplatform:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ehomeassistant\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eevent:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003estart\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003emode:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003esingle\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003emax_exceeded:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003esilent\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eaction:\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eevent:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etele_powercut_scraper_event\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eevent_data:\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003edate:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"{ now().strftime('%Y-%m-%d') }\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 정보를 자동화하는 방법의 예시입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e    \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealias:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"전원 정전 알림\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eid:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"automation_notification_home_powercut_notification\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003etrigger:\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eplatform:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecalendar\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eid:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"5_minute\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eevent:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003estart\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eentity_id:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecalendar.powercuts\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eoffset:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e-00\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e:05:00\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eplatform:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecalendar\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eid:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"15_minute\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eevent:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003estart\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eentity_id:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecalendar.powercuts\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eoffset:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e-00\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e:15:00\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eplatform:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecalendar\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eid:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"30_minute\"\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eevent:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003estart\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eentity_id:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecalendar.powercuts\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003eoffset:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e-00\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e:30:00\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003econdition:\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003econdition:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eand\u003c/span\u003e\n        \u003cspan class=\"hljs-attr\"\u003econditions:\u003c/span\u003e\n          \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econdition:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003estate\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003eentity_id:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003einput_boolean.powercuts\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003estate:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"on\"\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003emode:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003esingle\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003emax_exceeded:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003esilent\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eaction:\u003c/span\u003e\n        \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eservice:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003enotify.telegram_home\u003c/span\u003e\n          \u003cspan class=\"hljs-attr\"\u003edata:\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003etitle:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"⚡*전력 공급 중단*\"\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003emessage:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"{ trigger.id.split('_')[0] } 분 내에 전력 공급이 중단됩니다.\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e여러분 중 많은 분들이 국가에서 정전이나 미사일 경보로 걱정할 필요가 없을 수도 있습니다. 하지만 저는 이 기사를 공유하고 싶었습니다. 왜냐하면 제가 소개한 방법과 코드는 여러분의 스마트 홈에서 더 복잡한 자동화를 만드는데 영감을 줄 수 있기 때문입니다. 에너지 사용을 피크 시간에 관리하거나 정교한 아침 루틴을 조정하는 등, AppDaemon은 여러분의 스마트 홈을 더 똑똑하게 만드는 강력한 도구를 제공합니다.\u003c/p\u003e\n\u003cp\u003e그러니 이러한 도전 없이 사는 행운한 분들이라도, 여기서 유용한 아이디어를 찾아서 여러분의 홈 자동화 프로젝트를 향상시키는 데 도움이 되기를 바랍니다. 결국, 스마트 홈은 우리가 창의적으로 해결책을 찾는 한에만 똑똑할 뿐입니다.\u003c/p\u003e\n\u003cp\u003e즐거운 자동화!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents"},"buildId":"FH3Qr-mLAesqA0X5IFRQr","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>