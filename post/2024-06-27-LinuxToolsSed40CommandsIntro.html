<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리눅스 도구 Sed 40 기본 명령어 입문 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-27-LinuxToolsSed40CommandsIntro" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리눅스 도구 Sed 40 기본 명령어 입문 | itposting" data-gatsby-head="true"/><meta property="og:title" content="리눅스 도구 Sed 40 기본 명령어 입문 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-27-LinuxToolsSed40CommandsIntro_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-27-LinuxToolsSed40CommandsIntro" data-gatsby-head="true"/><meta name="twitter:title" content="리눅스 도구 Sed 40 기본 명령어 입문 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-27-LinuxToolsSed40CommandsIntro_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-27 18:59" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리눅스 도구 Sed 40 기본 명령어 입문</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리눅스 도구 Sed 40 기본 명령어 입문" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 27, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-27-LinuxToolsSed40CommandsIntro&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이 노트 세트에서는 다양한 Sed 명령에 대해 논의를 시작하겠습니다. 그 명령들이 많기 때문에 명령에 대한 논의를 몇 개의 다른 게시물로 나눌 것입니다. 이 게시물에는 다음 내용이 포함됩니다:</p>
<ul>
<li>Sed 명령 구문</li>
<li>Sed 스크립트 및 실행 방법</li>
<li>명령 대상 지정, 구분자 및 그룹화</li>
</ul>
<p>명령 구문</p>
<p>모든 다른 프로그래밍 언어와 마찬가지로 Sed에는 구문이 있습니다.</p>
<div class="content-ad"></div>
<p>설명서에 따르면 Sed 명령의 구문은 다음과 같습니다:</p>
<p>[주소]X[명령 옵션]</p>
<p>X는 한 글자 명령입니다. 모든 Sed 명령은 한 글자로만 구성됩니다.</p>
<p>[주소]는 명령 또는 명령 그룹 앞에 나오는 선택적 조건입니다. [주소]는 숫자, 정규 표현식 또는 이전에 설명한 둘 중 하나의 범위일 수 있습니다.</p>
<div class="content-ad"></div>
<p>[command options]은 명령어 X를 제어하는 옵션입니다.</p>
<p>Sed 스크립트</p>
<p>저에게 Sed 스크립트는 단순히 프로그래머가 설정한 순서대로 실행되는 하나 이상의 Sed 명령어 목록입니다. Sed는 호출될 때 하나 이상의 스크립트를 실행할 수 있습니다.</p>
<p>Sed 스크립트는 명령줄에 직접 제공하거나 하나 이상의 파일에 포함하여 Sed에 제공할 수 있습니다. 명령줄에서는 여러 스크립트를 -e 스크립트 또는 --expression=스크립트 명령줄 옵션으로 구분합니다. Sed는 -f 스크립트 | --file=스크립트 명령줄 옵션을 사용하여 파일에서 스크립트를 읽을 수도 있습니다.</p>
<div class="content-ad"></div>
<p>한 행에 여러 명령을 사용하려면 스크립트 내에서 ; 문자를 사용하여 구분합니다. 스크립트가 파일에 저장된 경우 \n도 명령 구분자로 작동합니다.</p>
<p>간단한 예제 몇 가지를 보여드리겠습니다:</p>
<pre><code class="hljs language-js">$ ## A string
$ declare s=<span class="hljs-string">"L1\nL2\nL3\n"</span>
$ ## <span class="hljs-title class_">Here</span> <span class="hljs-title class_">Sed</span> executes multiple <span class="hljs-title class_">Sed</span> commands.  A
$ ## single script is entered on the command line.
$ ## <span class="hljs-title class_">Since</span> only <span class="hljs-number">1</span> script is present, there isn<span class="hljs-string">'t
$ ## a need for the -e option.
$ ## The script prints each line of the string
$ ## 2 times.  The commands are separated
$ ## with a '</span>;<span class="hljs-string">' character.
$ printf "${s}" | sed -n "/L1/p; /L2/p; /L3/p"
L1
L2
L3
$ ## You can also enter 1 or more commands 
$ ## as separate scripts using the -e option
$ printf "${s}" | sed -n -e "/L1/p" -e "/L2/p; /L3/p"
L1
L2
L3 
</span></code></pre>
<p>Sed 스크립트가 들어 있는 파일도 만들 수 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 이것은 demo.<span class="hljs-property">sed</span>라는 파일에 저장된 <span class="hljs-title class_">Sed</span> 스크립트입니다.
# # 부호는 주석의 시작을 나타냅니다.
# 여기에 명령어가 있습니다.
/<span class="hljs-variable constant_">L1</span>/p
/<span class="hljs-variable constant_">L2</span>/p
/<span class="hljs-variable constant_">L3</span>/p
# demo.<span class="hljs-property">sed</span>의 끝
</code></pre>
<p>다음과 같이 명령 줄에서 호출할 수 있습니다.</p>
<pre><code class="hljs language-js">$ printf <span class="hljs-string">"${s}"</span> | sed -nEf demo.<span class="hljs-property">sed</span>
<span class="hljs-variable constant_">L1</span>
<span class="hljs-variable constant_">L2</span>
<span class="hljs-variable constant_">L3</span>
</code></pre>
<p>실행 가능한 Sed 스크립트 실행하기</p>
<div class="content-ad"></div>
<p>표 태그를 Markdown 형식으로 변경할 수 있어요.</p>
<pre><code class="hljs language-js">#!<span class="hljs-regexp">/bin/</span>sed -nEf
##################
# <span class="hljs-title class_">Sed</span> 스크립트 파일: demo.<span class="hljs-property">sed</span>
# -n - 자동 출력 비활성화
# -E - 확장 정규 표현식 사용 가능
# -f - 
<span class="hljs-regexp">/L1/</span>p
/<span class="hljs-variable constant_">L2</span>/p; <span class="hljs-regexp">/L3/</span>p
/<span class="hljs-variable constant_">L3</span>/ { s/(.*)/\<span class="hljs-number">1</span>\nThat<span class="hljs-string">'s All Folks!!!/; p}
### demo.sed 끝
</span></code></pre>
<p>아래와 같이 파일 내에 저장된 Sed 스크립트를 작성하고 실행할 수 있어요:</p>
<pre><code class="hljs language-js">$ ## 실행 가능하도록 변경
$ chmod <span class="hljs-number">755</span> ./demo.<span class="hljs-property">sed</span>
$ ## 문자열 선언
$ declare s=<span class="hljs-string">"L1\nL2\nL3\n"</span>
$ ## 실행
$ printf <span class="hljs-string">"${s}"</span> | ./demo.<span class="hljs-property">sed</span>
<span class="hljs-variable constant_">L1</span>
<span class="hljs-variable constant_">L2</span>
<span class="hljs-variable constant_">L3</span>
<span class="hljs-title class_">That</span><span class="hljs-string">'s All Folks!!!!
$ ## 파일에 텍스트 저장
$ printf "${s}" > ./f1.txt
$ ## 이후 처리 가능
$ cat ./f1.txt | ./demo.sed
L1
L2
L3
That'</span>s <span class="hljs-title class_">All</span> <span class="hljs-title class_">Folks</span>!!!!
$ ## 또는
$ ./demo.<span class="hljs-property">sed</span> ./f1.<span class="hljs-property">txt</span>
<span class="hljs-variable constant_">L1</span>
<span class="hljs-variable constant_">L2</span>
<span class="hljs-variable constant_">L3</span>
<span class="hljs-title class_">That</span><span class="hljs-string">'s All Folks!!!!
$ ## 정말 그게 다에요
</span></code></pre>
<div class="content-ad"></div>
<p>조건문과 주소 지정</p>
<p>만약 [주소]가 없다면, 명령 또는 명령 그룹이 무조건 실행됩니다. 만약 [주소]가 존재한다면, 해당 조건이 명령을 실행하기 위해 충족되어야 합니다. 조건은 숫자 주소나 정규 표현식으로 구성됩니다. 범위 및 기타 표현식도 포함될 수 있으며, 다른 곳에서 논의된 내용일 수 있습니다. 가끔 여기저기 "not"을 사용하기도 합니다.</p>
<p>명령 그룹화</p>
<p>다음 명명 방식을 사용하여 명령을 그룹화할 수 있습니다:</p>
<div class="content-ad"></div>
<p><strong>address</strong> ' <strong>address1</strong> X1; <strong>address2</strong> X2; ... <strong>addressn</strong> Xn '</p>
<p>들어 가 있는 ''문자는 그룹을 구분하고, [address]는 전체 그룹을 선택합니다. 그룹은 다음과 같이 중첩될 수도 있습니다:</p>
<p><strong>address_outer</strong>' <strong>address_inner</strong>' <strong>addr1</strong>X1; <strong>addr2</strong>X2 '; <strong>addr3</strong>X3 '</p>
<p>이렇게 함으로써 if-elseif-else 유형의 구조가 포함된 Sed 스크립트를 작성할 수 있습니다.</p>
<div class="content-ad"></div>
<p>유용한 명령줄 옵션과 별명</p>
<pre><code class="hljs language-js">$ ## -n|--silent|--quite - 자동 인쇄 비활성화
$ ## -E|-r|--regexp-extended - 확장 정규 표현식 활성화
$ ## 일반적으로 다음과 같은 별명을 사용합니다
$ alias sed=<span class="hljs-string">'sed -E'</span>
$ alias sedn=<span class="hljs-string">'sed -E -n'</span>
</code></pre>
<p>다음 자료의 예제를 이해하는 데 충분한 정보입니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리눅스 도구 Sed 40 기본 명령어 입문","description":"","date":"2024-06-27 18:59","slug":"2024-06-27-LinuxToolsSed40CommandsIntro","content":"\n\n이 노트 세트에서는 다양한 Sed 명령에 대해 논의를 시작하겠습니다. 그 명령들이 많기 때문에 명령에 대한 논의를 몇 개의 다른 게시물로 나눌 것입니다. 이 게시물에는 다음 내용이 포함됩니다:\n\n- Sed 명령 구문\n- Sed 스크립트 및 실행 방법\n- 명령 대상 지정, 구분자 및 그룹화\n\n명령 구문\n\n모든 다른 프로그래밍 언어와 마찬가지로 Sed에는 구문이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n설명서에 따르면 Sed 명령의 구문은 다음과 같습니다:\n\n[주소]X[명령 옵션]\n\nX는 한 글자 명령입니다. 모든 Sed 명령은 한 글자로만 구성됩니다.\n\n[주소]는 명령 또는 명령 그룹 앞에 나오는 선택적 조건입니다. [주소]는 숫자, 정규 표현식 또는 이전에 설명한 둘 중 하나의 범위일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[command options]은 명령어 X를 제어하는 옵션입니다.\n\nSed 스크립트\n\n저에게 Sed 스크립트는 단순히 프로그래머가 설정한 순서대로 실행되는 하나 이상의 Sed 명령어 목록입니다. Sed는 호출될 때 하나 이상의 스크립트를 실행할 수 있습니다.\n\nSed 스크립트는 명령줄에 직접 제공하거나 하나 이상의 파일에 포함하여 Sed에 제공할 수 있습니다. 명령줄에서는 여러 스크립트를 -e 스크립트 또는 --expression=스크립트 명령줄 옵션으로 구분합니다. Sed는 -f 스크립트 | --file=스크립트 명령줄 옵션을 사용하여 파일에서 스크립트를 읽을 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 행에 여러 명령을 사용하려면 스크립트 내에서 ; 문자를 사용하여 구분합니다. 스크립트가 파일에 저장된 경우 \\n도 명령 구분자로 작동합니다.\n\n간단한 예제 몇 가지를 보여드리겠습니다:\n\n```js\n$ ## A string\n$ declare s=\"L1\\nL2\\nL3\\n\"\n$ ## Here Sed executes multiple Sed commands.  A\n$ ## single script is entered on the command line.\n$ ## Since only 1 script is present, there isn't\n$ ## a need for the -e option.\n$ ## The script prints each line of the string\n$ ## 2 times.  The commands are separated\n$ ## with a ';' character.\n$ printf \"${s}\" | sed -n \"/L1/p; /L2/p; /L3/p\"\nL1\nL2\nL3\n$ ## You can also enter 1 or more commands \n$ ## as separate scripts using the -e option\n$ printf \"${s}\" | sed -n -e \"/L1/p\" -e \"/L2/p; /L3/p\"\nL1\nL2\nL3 \n```\n\nSed 스크립트가 들어 있는 파일도 만들 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 이것은 demo.sed라는 파일에 저장된 Sed 스크립트입니다.\n# # 부호는 주석의 시작을 나타냅니다.\n# 여기에 명령어가 있습니다.\n/L1/p\n/L2/p\n/L3/p\n# demo.sed의 끝\n```\n\n다음과 같이 명령 줄에서 호출할 수 있습니다.\n\n```js\n$ printf \"${s}\" | sed -nEf demo.sed\nL1\nL2\nL3\n```\n\n실행 가능한 Sed 스크립트 실행하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표 태그를 Markdown 형식으로 변경할 수 있어요.\n\n```js\n#!/bin/sed -nEf\n##################\n# Sed 스크립트 파일: demo.sed\n# -n - 자동 출력 비활성화\n# -E - 확장 정규 표현식 사용 가능\n# -f - \n/L1/p\n/L2/p; /L3/p\n/L3/ { s/(.*)/\\1\\nThat's All Folks!!!/; p}\n### demo.sed 끝\n```\n\n아래와 같이 파일 내에 저장된 Sed 스크립트를 작성하고 실행할 수 있어요:\n\n```js\n$ ## 실행 가능하도록 변경\n$ chmod 755 ./demo.sed\n$ ## 문자열 선언\n$ declare s=\"L1\\nL2\\nL3\\n\"\n$ ## 실행\n$ printf \"${s}\" | ./demo.sed\nL1\nL2\nL3\nThat's All Folks!!!!\n$ ## 파일에 텍스트 저장\n$ printf \"${s}\" \u003e ./f1.txt\n$ ## 이후 처리 가능\n$ cat ./f1.txt | ./demo.sed\nL1\nL2\nL3\nThat's All Folks!!!!\n$ ## 또는\n$ ./demo.sed ./f1.txt\nL1\nL2\nL3\nThat's All Folks!!!!\n$ ## 정말 그게 다에요\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n조건문과 주소 지정\n\n만약 [주소]가 없다면, 명령 또는 명령 그룹이 무조건 실행됩니다. 만약 [주소]가 존재한다면, 해당 조건이 명령을 실행하기 위해 충족되어야 합니다. 조건은 숫자 주소나 정규 표현식으로 구성됩니다. 범위 및 기타 표현식도 포함될 수 있으며, 다른 곳에서 논의된 내용일 수 있습니다. 가끔 여기저기 \"not\"을 사용하기도 합니다.\n\n명령 그룹화\n\n다음 명명 방식을 사용하여 명령을 그룹화할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**address** ' **address1** X1; **address2** X2; ... **addressn** Xn '\n\n들어 가 있는 ''문자는 그룹을 구분하고, [address]는 전체 그룹을 선택합니다. 그룹은 다음과 같이 중첩될 수도 있습니다:\n\n**address_outer**' **address_inner**' **addr1**X1; **addr2**X2 '; **addr3**X3 '\n\n이렇게 함으로써 if-elseif-else 유형의 구조가 포함된 Sed 스크립트를 작성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n유용한 명령줄 옵션과 별명\n\n```js\n$ ## -n|--silent|--quite - 자동 인쇄 비활성화\n$ ## -E|-r|--regexp-extended - 확장 정규 표현식 활성화\n$ ## 일반적으로 다음과 같은 별명을 사용합니다\n$ alias sed='sed -E'\n$ alias sedn='sed -E -n'\n```\n\n다음 자료의 예제를 이해하는 데 충분한 정보입니다.","ogImage":{"url":"/assets/img/2024-06-27-LinuxToolsSed40CommandsIntro_0.png"},"coverImage":"/assets/img/2024-06-27-LinuxToolsSed40CommandsIntro_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이 노트 세트에서는 다양한 Sed 명령에 대해 논의를 시작하겠습니다. 그 명령들이 많기 때문에 명령에 대한 논의를 몇 개의 다른 게시물로 나눌 것입니다. 이 게시물에는 다음 내용이 포함됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSed 명령 구문\u003c/li\u003e\n\u003cli\u003eSed 스크립트 및 실행 방법\u003c/li\u003e\n\u003cli\u003e명령 대상 지정, 구분자 및 그룹화\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e명령 구문\u003c/p\u003e\n\u003cp\u003e모든 다른 프로그래밍 언어와 마찬가지로 Sed에는 구문이 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e설명서에 따르면 Sed 명령의 구문은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e[주소]X[명령 옵션]\u003c/p\u003e\n\u003cp\u003eX는 한 글자 명령입니다. 모든 Sed 명령은 한 글자로만 구성됩니다.\u003c/p\u003e\n\u003cp\u003e[주소]는 명령 또는 명령 그룹 앞에 나오는 선택적 조건입니다. [주소]는 숫자, 정규 표현식 또는 이전에 설명한 둘 중 하나의 범위일 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e[command options]은 명령어 X를 제어하는 옵션입니다.\u003c/p\u003e\n\u003cp\u003eSed 스크립트\u003c/p\u003e\n\u003cp\u003e저에게 Sed 스크립트는 단순히 프로그래머가 설정한 순서대로 실행되는 하나 이상의 Sed 명령어 목록입니다. Sed는 호출될 때 하나 이상의 스크립트를 실행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eSed 스크립트는 명령줄에 직접 제공하거나 하나 이상의 파일에 포함하여 Sed에 제공할 수 있습니다. 명령줄에서는 여러 스크립트를 -e 스크립트 또는 --expression=스크립트 명령줄 옵션으로 구분합니다. Sed는 -f 스크립트 | --file=스크립트 명령줄 옵션을 사용하여 파일에서 스크립트를 읽을 수도 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e한 행에 여러 명령을 사용하려면 스크립트 내에서 ; 문자를 사용하여 구분합니다. 스크립트가 파일에 저장된 경우 \\n도 명령 구분자로 작동합니다.\u003c/p\u003e\n\u003cp\u003e간단한 예제 몇 가지를 보여드리겠습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ ## A string\n$ declare s=\u003cspan class=\"hljs-string\"\u003e\"L1\\nL2\\nL3\\n\"\u003c/span\u003e\n$ ## \u003cspan class=\"hljs-title class_\"\u003eHere\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSed\u003c/span\u003e executes multiple \u003cspan class=\"hljs-title class_\"\u003eSed\u003c/span\u003e commands.  A\n$ ## single script is entered on the command line.\n$ ## \u003cspan class=\"hljs-title class_\"\u003eSince\u003c/span\u003e only \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e script is present, there isn\u003cspan class=\"hljs-string\"\u003e't\n$ ## a need for the -e option.\n$ ## The script prints each line of the string\n$ ## 2 times.  The commands are separated\n$ ## with a '\u003c/span\u003e;\u003cspan class=\"hljs-string\"\u003e' character.\n$ printf \"${s}\" | sed -n \"/L1/p; /L2/p; /L3/p\"\nL1\nL2\nL3\n$ ## You can also enter 1 or more commands \n$ ## as separate scripts using the -e option\n$ printf \"${s}\" | sed -n -e \"/L1/p\" -e \"/L2/p; /L3/p\"\nL1\nL2\nL3 \n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSed 스크립트가 들어 있는 파일도 만들 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 이것은 demo.\u003cspan class=\"hljs-property\"\u003esed\u003c/span\u003e라는 파일에 저장된 \u003cspan class=\"hljs-title class_\"\u003eSed\u003c/span\u003e 스크립트입니다.\n# # 부호는 주석의 시작을 나타냅니다.\n# 여기에 명령어가 있습니다.\n/\u003cspan class=\"hljs-variable constant_\"\u003eL1\u003c/span\u003e/p\n/\u003cspan class=\"hljs-variable constant_\"\u003eL2\u003c/span\u003e/p\n/\u003cspan class=\"hljs-variable constant_\"\u003eL3\u003c/span\u003e/p\n# demo.\u003cspan class=\"hljs-property\"\u003esed\u003c/span\u003e의 끝\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음과 같이 명령 줄에서 호출할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ printf \u003cspan class=\"hljs-string\"\u003e\"${s}\"\u003c/span\u003e | sed -nEf demo.\u003cspan class=\"hljs-property\"\u003esed\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eL1\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eL2\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eL3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e실행 가능한 Sed 스크립트 실행하기\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e표 태그를 Markdown 형식으로 변경할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#!\u003cspan class=\"hljs-regexp\"\u003e/bin/\u003c/span\u003esed -nEf\n##################\n# \u003cspan class=\"hljs-title class_\"\u003eSed\u003c/span\u003e 스크립트 파일: demo.\u003cspan class=\"hljs-property\"\u003esed\u003c/span\u003e\n# -n - 자동 출력 비활성화\n# -E - 확장 정규 표현식 사용 가능\n# -f - \n\u003cspan class=\"hljs-regexp\"\u003e/L1/\u003c/span\u003ep\n/\u003cspan class=\"hljs-variable constant_\"\u003eL2\u003c/span\u003e/p; \u003cspan class=\"hljs-regexp\"\u003e/L3/\u003c/span\u003ep\n/\u003cspan class=\"hljs-variable constant_\"\u003eL3\u003c/span\u003e/ { s/(.*)/\\\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\\nThat\u003cspan class=\"hljs-string\"\u003e's All Folks!!!/; p}\n### demo.sed 끝\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래와 같이 파일 내에 저장된 Sed 스크립트를 작성하고 실행할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ ## 실행 가능하도록 변경\n$ chmod \u003cspan class=\"hljs-number\"\u003e755\u003c/span\u003e ./demo.\u003cspan class=\"hljs-property\"\u003esed\u003c/span\u003e\n$ ## 문자열 선언\n$ declare s=\u003cspan class=\"hljs-string\"\u003e\"L1\\nL2\\nL3\\n\"\u003c/span\u003e\n$ ## 실행\n$ printf \u003cspan class=\"hljs-string\"\u003e\"${s}\"\u003c/span\u003e | ./demo.\u003cspan class=\"hljs-property\"\u003esed\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eL1\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eL2\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eL3\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eThat\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e's All Folks!!!!\n$ ## 파일에 텍스트 저장\n$ printf \"${s}\" \u003e ./f1.txt\n$ ## 이후 처리 가능\n$ cat ./f1.txt | ./demo.sed\nL1\nL2\nL3\nThat'\u003c/span\u003es \u003cspan class=\"hljs-title class_\"\u003eAll\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFolks\u003c/span\u003e!!!!\n$ ## 또는\n$ ./demo.\u003cspan class=\"hljs-property\"\u003esed\u003c/span\u003e ./f1.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eL1\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eL2\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eL3\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eThat\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e's All Folks!!!!\n$ ## 정말 그게 다에요\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e조건문과 주소 지정\u003c/p\u003e\n\u003cp\u003e만약 [주소]가 없다면, 명령 또는 명령 그룹이 무조건 실행됩니다. 만약 [주소]가 존재한다면, 해당 조건이 명령을 실행하기 위해 충족되어야 합니다. 조건은 숫자 주소나 정규 표현식으로 구성됩니다. 범위 및 기타 표현식도 포함될 수 있으며, 다른 곳에서 논의된 내용일 수 있습니다. 가끔 여기저기 \"not\"을 사용하기도 합니다.\u003c/p\u003e\n\u003cp\u003e명령 그룹화\u003c/p\u003e\n\u003cp\u003e다음 명명 방식을 사용하여 명령을 그룹화할 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cstrong\u003eaddress\u003c/strong\u003e ' \u003cstrong\u003eaddress1\u003c/strong\u003e X1; \u003cstrong\u003eaddress2\u003c/strong\u003e X2; ... \u003cstrong\u003eaddressn\u003c/strong\u003e Xn '\u003c/p\u003e\n\u003cp\u003e들어 가 있는 ''문자는 그룹을 구분하고, [address]는 전체 그룹을 선택합니다. 그룹은 다음과 같이 중첩될 수도 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eaddress_outer\u003c/strong\u003e' \u003cstrong\u003eaddress_inner\u003c/strong\u003e' \u003cstrong\u003eaddr1\u003c/strong\u003eX1; \u003cstrong\u003eaddr2\u003c/strong\u003eX2 '; \u003cstrong\u003eaddr3\u003c/strong\u003eX3 '\u003c/p\u003e\n\u003cp\u003e이렇게 함으로써 if-elseif-else 유형의 구조가 포함된 Sed 스크립트를 작성할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e유용한 명령줄 옵션과 별명\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ ## -n|--silent|--quite - 자동 인쇄 비활성화\n$ ## -E|-r|--regexp-extended - 확장 정규 표현식 활성화\n$ ## 일반적으로 다음과 같은 별명을 사용합니다\n$ alias sed=\u003cspan class=\"hljs-string\"\u003e'sed -E'\u003c/span\u003e\n$ alias sedn=\u003cspan class=\"hljs-string\"\u003e'sed -E -n'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 자료의 예제를 이해하는 데 충분한 정보입니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-27-LinuxToolsSed40CommandsIntro"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>