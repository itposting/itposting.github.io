<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>유닉스 리눅스 wc 도구 만들기 최종 파트 표준 입력 지원 추가하기 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="유닉스 리눅스 wc 도구 만들기 최종 파트 표준 입력 지원 추가하기 | itposting" data-gatsby-head="true"/><meta property="og:title" content="유닉스 리눅스 wc 도구 만들기 최종 파트 표준 입력 지원 추가하기 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput" data-gatsby-head="true"/><meta name="twitter:title" content="유닉스 리눅스 wc 도구 만들기 최종 파트 표준 입력 지원 추가하기 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 14:20" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_buildManifest.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">유닉스 리눅스 wc 도구 만들기 최종 파트 표준 입력 지원 추가하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="유닉스 리눅스 wc 도구 만들기 최종 파트 표준 입력 지원 추가하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput_0.png">
<p>지금까지 시리즈의 이전 부분을 읽지 않으셨다면, 먼저 읽어보시는 것을 권장합니다 :)</p>
<ol>
<li>
<p>Part I: 이 부분에서는 wccommand의 기본 구성, 파일 크기 계산만을 지원하는 데 중점을 뒀습니다.</p>
</li>
<li>
<p>Part II: Part II에서는 라인 카운터 플래그를 지원하도록 추가하는 데 중점을 뒀습니다.</p>
</li>
</ol>
<div class="content-ad"></div>
<ol start="3">
<li>Part III: 이번 글은 최신 글로, 단어 카운터 플래그를 지원하는 데 초점을 맞추었습니다.</li>
</ol>
<p>이제 현재 목표로 돌아가 봅시다. 이 목표에는 두 단계가 있습니다:</p>
<ul>
<li>기본 옵션을 지원하는 것, 즉 어떤 옵션이 제공되지 않았을 때입니다. 이는 -c, -l 및 -w 옵션과 동등합니다.</li>
</ul>
<pre><code class="hljs language-js">go run main test.<span class="hljs-property">txt</span>
<span class="hljs-comment">// 결과: 7145   58164  342190 test.txt</span>
</code></pre>
<div class="content-ad"></div>
<ul>
<li>입력 파일 이름이 지정되지 않은 경우 표준 입력에서 읽어 들일 수 있는 지원 추가</li>
</ul>
<pre><code class="hljs language-js">cat test.<span class="hljs-property">txt</span> | go run main.<span class="hljs-property">go</span> -l
<span class="hljs-comment">// 결과: 7145</span>
</code></pre>
<h2>1. 기본 옵션 지원</h2>
<p>파일 내 라인 수, 단어 수 등을 얻는 서로 다른 로직을 처리하는 함수가 이미 있었습니다. 이 목표를 달성하기 위한 접근 방법은 ProcessFile 함수에 콜백 함수를 전달하여 파일의 바이트 수, 파일 내 라인 수 및 파일 내 단어 수를 얻는 데 책임이 있는 세 가지 함수를 호출하고 그 결과를 출력하는 것이었습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-title class_">ProcessFile</span>(args[<span class="hljs-number">0</span>], <span class="hljs-title function_">func</span>(<span class="hljs-params">s string</span>) {
    byteNumber := <span class="hljs-title function_">getByteNumber</span>(&#x26;s, nil)
    lineNumber := <span class="hljs-title function_">getNumberOfLines</span>(&#x26;s, nil)
    wordNumber := <span class="hljs-title function_">countWords</span>(s)

    fmt.<span class="hljs-title class_">Println</span>(byteNumber, lineNumber, wordNumber, s)
})
</code></pre>
<h2>2. 표준 입력 지원</h2>
<p>이 목표를 달성하는 것은 조금 복잡했습니다. 이전 구현에서 빈 플래그를 가져올 수 없는 이유를 알아내려고 몇 시간을 보냈습니다.</p>
<p>다음 코드를 고려해보겠습니다. 이 코드는 파일의 바이트 수를 얻는 데 사용되는 c 플래그를 생성합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">byteNumber := flag.<span class="hljs-title class_">String</span>(byteNumberFlag, <span class="hljs-string">""</span>, <span class="hljs-string">"파일 바이트 수를 얻는 플래그"</span>)
</code></pre>
<p>만약 플래그에 어떤 인자도 전달하지 않는다면, 해당 플래그의 기본값을 빈 문자열로 설정했기 때문에 빈 문자열이 반환될 것으로 생각했습니다. 그러나 실제 상황은 다릅니다. 파싱 로직에서, 플래그에 인자가 없는 경우 flag.Parse는 자동으로 도움말 플래그가 있는 경우 해당 플래그를 반환하거나, 2의 종료 상태를 갖는 패닉을 발생시키도록 구현되어 있습니다.</p>
<p>이 문제에 직면하여, 파싱하기 전에 인수에 액세스할 다른 방법을 찾았습니다. 표준 라이브러리인 os의 도움을 통해 예상보다 쉽게 해결했습니다. 접근 방식은 다음과 같습니다:</p>
<ul>
<li>입력 파일을 스캔하고 해당 내용을 반환합니다.</li>
<li>전달된 인수를 가져옵니다.</li>
<li>전달된 인수의 길이를 확인합니다.</li>
<li>길이가 하나인 경우, 다른 플래그와 비교합니다.</li>
<li>각 플래그에 대해 해당 함수를 실행합니다.</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-go"><span class="hljs-comment">// 명령줄 인수 가져오기</span>
args := os.Args[<span class="hljs-number">1</span>:]

<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) == <span class="hljs-number">1</span> { <span class="hljs-comment">// 정확히 하나의 인수가 제공되었는지 확인</span>
    <span class="hljs-comment">// 플래그의 "-" 문자를 피하기 위해 단일 인수의 마지막 문자를 가져와서 플래그를 결정</span>
    flag_ := args[<span class="hljs-number">0</span>][<span class="hljs-built_in">len</span>(args[<span class="hljs-number">0</span>])<span class="hljs-number">-1</span>:]

    <span class="hljs-comment">// 플래그 값에 따라 다른 경우 처리</span>
    <span class="hljs-keyword">switch</span> flag_ {
    <span class="hljs-keyword">case</span> byteNumberFlag: <span class="hljs-comment">// 바이트 수 세는 경우</span>
        <span class="hljs-comment">// 표준 입력에서 읽기</span>
        stdin := handleStandardInput()
        fmt.Println(getByteNumber(<span class="hljs-literal">nil</span>, &#x26;stdin))
    <span class="hljs-keyword">case</span> linesCounterFlag: <span class="hljs-comment">// 줄 수 세는 경우</span>
        stdin := handleStandardInput()
        fmt.Println(getNumberOfLines(<span class="hljs-literal">nil</span>, &#x26;stdin))
    <span class="hljs-keyword">case</span> wordsCounterFlag: <span class="hljs-comment">// 단어 수 세는 경우</span>
        stdin := handleStandardInput()
        wordsSlice := strings.Fields(stdin)
        fmt.Println(<span class="hljs-built_in">len</span>(wordsSlice))
    <span class="hljs-keyword">case</span> characterCounterFlag: <span class="hljs-comment">// 문자 수 세는 경우</span>
        stdin := handleStandardInput()
        <span class="hljs-comment">// 입력의 UTF-8 룬 수 세기</span>
        runes := utf8.RuneCountInString(stdin)
        fmt.Println(runes)
    <span class="hljs-keyword">default</span>: <span class="hljs-comment">// 파일 처리의 기본 경우</span>
        ProcessFile(args[<span class="hljs-number">0</span>], <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> {
            byteNumber := getByteNumber(&#x26;s, <span class="hljs-literal">nil</span>)
            lineNumber := getNumberOfLines(&#x26;s, <span class="hljs-literal">nil</span>)
            wordNumber := countWords(s)

            <span class="hljs-comment">// 바이트, 줄, 단어 수를 문자열과 함께 출력</span>
            fmt.Println(byteNumber, lineNumber, wordNumber, s)
        })
    }
    <span class="hljs-keyword">return</span> <span class="hljs-comment">// 인수 처리 후 종료</span>
}
</code></pre>
<p>참고: 이 마지막 단계를 작동하도록 도우미 함수에 일부 변경을 가했습니다.</p>
<p>읽어주셔서 감사합니다! 다음 도전에 주목해주세요. 이 도전의 전체 소스 코드는 여기에서, 도전 설명은 여기에서 찾을 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"유닉스 리눅스 wc 도구 만들기 최종 파트 표준 입력 지원 추가하기","description":"","date":"2024-06-20 14:20","slug":"2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput","content":"\n\n\u003cimg src=\"/assets/img/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput_0.png\" /\u003e\n\n지금까지 시리즈의 이전 부분을 읽지 않으셨다면, 먼저 읽어보시는 것을 권장합니다 :)\n\n1. Part I: 이 부분에서는 wccommand의 기본 구성, 파일 크기 계산만을 지원하는 데 중점을 뒀습니다.\n   \n2. Part II: Part II에서는 라인 카운터 플래그를 지원하도록 추가하는 데 중점을 뒀습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. Part III: 이번 글은 최신 글로, 단어 카운터 플래그를 지원하는 데 초점을 맞추었습니다.\n\n이제 현재 목표로 돌아가 봅시다. 이 목표에는 두 단계가 있습니다:\n\n- 기본 옵션을 지원하는 것, 즉 어떤 옵션이 제공되지 않았을 때입니다. 이는 -c, -l 및 -w 옵션과 동등합니다.\n\n```js\ngo run main test.txt\n// 결과: 7145   58164  342190 test.txt\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 입력 파일 이름이 지정되지 않은 경우 표준 입력에서 읽어 들일 수 있는 지원 추가\n\n```js\ncat test.txt | go run main.go -l\n// 결과: 7145\n```\n\n## 1. 기본 옵션 지원\n\n파일 내 라인 수, 단어 수 등을 얻는 서로 다른 로직을 처리하는 함수가 이미 있었습니다. 이 목표를 달성하기 위한 접근 방법은 ProcessFile 함수에 콜백 함수를 전달하여 파일의 바이트 수, 파일 내 라인 수 및 파일 내 단어 수를 얻는 데 책임이 있는 세 가지 함수를 호출하고 그 결과를 출력하는 것이었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nProcessFile(args[0], func(s string) {\n    byteNumber := getByteNumber(\u0026s, nil)\n    lineNumber := getNumberOfLines(\u0026s, nil)\n    wordNumber := countWords(s)\n\n    fmt.Println(byteNumber, lineNumber, wordNumber, s)\n})\n```\n\n## 2. 표준 입력 지원\n\n이 목표를 달성하는 것은 조금 복잡했습니다. 이전 구현에서 빈 플래그를 가져올 수 없는 이유를 알아내려고 몇 시간을 보냈습니다.\n\n다음 코드를 고려해보겠습니다. 이 코드는 파일의 바이트 수를 얻는 데 사용되는 c 플래그를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nbyteNumber := flag.String(byteNumberFlag, \"\", \"파일 바이트 수를 얻는 플래그\")\n```\n\n만약 플래그에 어떤 인자도 전달하지 않는다면, 해당 플래그의 기본값을 빈 문자열로 설정했기 때문에 빈 문자열이 반환될 것으로 생각했습니다. 그러나 실제 상황은 다릅니다. 파싱 로직에서, 플래그에 인자가 없는 경우 flag.Parse는 자동으로 도움말 플래그가 있는 경우 해당 플래그를 반환하거나, 2의 종료 상태를 갖는 패닉을 발생시키도록 구현되어 있습니다.\n\n이 문제에 직면하여, 파싱하기 전에 인수에 액세스할 다른 방법을 찾았습니다. 표준 라이브러리인 os의 도움을 통해 예상보다 쉽게 해결했습니다. 접근 방식은 다음과 같습니다:\n\n- 입력 파일을 스캔하고 해당 내용을 반환합니다.\n- 전달된 인수를 가져옵니다.\n- 전달된 인수의 길이를 확인합니다.\n- 길이가 하나인 경우, 다른 플래그와 비교합니다.\n- 각 플래그에 대해 해당 함수를 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```go\n// 명령줄 인수 가져오기\nargs := os.Args[1:]\n\nif len(args) == 1 { // 정확히 하나의 인수가 제공되었는지 확인\n    // 플래그의 \"-\" 문자를 피하기 위해 단일 인수의 마지막 문자를 가져와서 플래그를 결정\n    flag_ := args[0][len(args[0])-1:]\n\n    // 플래그 값에 따라 다른 경우 처리\n    switch flag_ {\n    case byteNumberFlag: // 바이트 수 세는 경우\n        // 표준 입력에서 읽기\n        stdin := handleStandardInput()\n        fmt.Println(getByteNumber(nil, \u0026stdin))\n    case linesCounterFlag: // 줄 수 세는 경우\n        stdin := handleStandardInput()\n        fmt.Println(getNumberOfLines(nil, \u0026stdin))\n    case wordsCounterFlag: // 단어 수 세는 경우\n        stdin := handleStandardInput()\n        wordsSlice := strings.Fields(stdin)\n        fmt.Println(len(wordsSlice))\n    case characterCounterFlag: // 문자 수 세는 경우\n        stdin := handleStandardInput()\n        // 입력의 UTF-8 룬 수 세기\n        runes := utf8.RuneCountInString(stdin)\n        fmt.Println(runes)\n    default: // 파일 처리의 기본 경우\n        ProcessFile(args[0], func(s string) {\n            byteNumber := getByteNumber(\u0026s, nil)\n            lineNumber := getNumberOfLines(\u0026s, nil)\n            wordNumber := countWords(s)\n\n            // 바이트, 줄, 단어 수를 문자열과 함께 출력\n            fmt.Println(byteNumber, lineNumber, wordNumber, s)\n        })\n    }\n    return // 인수 처리 후 종료\n}\n```\n\n참고: 이 마지막 단계를 작동하도록 도우미 함수에 일부 변경을 가했습니다.\n\n읽어주셔서 감사합니다! 다음 도전에 주목해주세요. 이 도전의 전체 소스 코드는 여기에서, 도전 설명은 여기에서 찾을 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput_0.png"},"coverImage":"/assets/img/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput_0.png\"\u003e\n\u003cp\u003e지금까지 시리즈의 이전 부분을 읽지 않으셨다면, 먼저 읽어보시는 것을 권장합니다 :)\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003ePart I: 이 부분에서는 wccommand의 기본 구성, 파일 크기 계산만을 지원하는 데 중점을 뒀습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePart II: Part II에서는 라인 카운터 플래그를 지원하도록 추가하는 데 중점을 뒀습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003ePart III: 이번 글은 최신 글로, 단어 카운터 플래그를 지원하는 데 초점을 맞추었습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e이제 현재 목표로 돌아가 봅시다. 이 목표에는 두 단계가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기본 옵션을 지원하는 것, 즉 어떤 옵션이 제공되지 않았을 때입니다. 이는 -c, -l 및 -w 옵션과 동등합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ego run main test.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 결과: 7145   58164  342190 test.txt\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e입력 파일 이름이 지정되지 않은 경우 표준 입력에서 읽어 들일 수 있는 지원 추가\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecat test.\u003cspan class=\"hljs-property\"\u003etxt\u003c/span\u003e | go run main.\u003cspan class=\"hljs-property\"\u003ego\u003c/span\u003e -l\n\u003cspan class=\"hljs-comment\"\u003e// 결과: 7145\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e1. 기본 옵션 지원\u003c/h2\u003e\n\u003cp\u003e파일 내 라인 수, 단어 수 등을 얻는 서로 다른 로직을 처리하는 함수가 이미 있었습니다. 이 목표를 달성하기 위한 접근 방법은 ProcessFile 함수에 콜백 함수를 전달하여 파일의 바이트 수, 파일 내 라인 수 및 파일 내 단어 수를 얻는 데 책임이 있는 세 가지 함수를 호출하고 그 결과를 출력하는 것이었습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eProcessFile\u003c/span\u003e(args[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], \u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003es string\u003c/span\u003e) {\n    byteNumber := \u003cspan class=\"hljs-title function_\"\u003egetByteNumber\u003c/span\u003e(\u0026#x26;s, nil)\n    lineNumber := \u003cspan class=\"hljs-title function_\"\u003egetNumberOfLines\u003c/span\u003e(\u0026#x26;s, nil)\n    wordNumber := \u003cspan class=\"hljs-title function_\"\u003ecountWords\u003c/span\u003e(s)\n\n    fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintln\u003c/span\u003e(byteNumber, lineNumber, wordNumber, s)\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e2. 표준 입력 지원\u003c/h2\u003e\n\u003cp\u003e이 목표를 달성하는 것은 조금 복잡했습니다. 이전 구현에서 빈 플래그를 가져올 수 없는 이유를 알아내려고 몇 시간을 보냈습니다.\u003c/p\u003e\n\u003cp\u003e다음 코드를 고려해보겠습니다. 이 코드는 파일의 바이트 수를 얻는 데 사용되는 c 플래그를 생성합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ebyteNumber := flag.\u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e(byteNumberFlag, \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"파일 바이트 수를 얻는 플래그\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 플래그에 어떤 인자도 전달하지 않는다면, 해당 플래그의 기본값을 빈 문자열로 설정했기 때문에 빈 문자열이 반환될 것으로 생각했습니다. 그러나 실제 상황은 다릅니다. 파싱 로직에서, 플래그에 인자가 없는 경우 flag.Parse는 자동으로 도움말 플래그가 있는 경우 해당 플래그를 반환하거나, 2의 종료 상태를 갖는 패닉을 발생시키도록 구현되어 있습니다.\u003c/p\u003e\n\u003cp\u003e이 문제에 직면하여, 파싱하기 전에 인수에 액세스할 다른 방법을 찾았습니다. 표준 라이브러리인 os의 도움을 통해 예상보다 쉽게 해결했습니다. 접근 방식은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e입력 파일을 스캔하고 해당 내용을 반환합니다.\u003c/li\u003e\n\u003cli\u003e전달된 인수를 가져옵니다.\u003c/li\u003e\n\u003cli\u003e전달된 인수의 길이를 확인합니다.\u003c/li\u003e\n\u003cli\u003e길이가 하나인 경우, 다른 플래그와 비교합니다.\u003c/li\u003e\n\u003cli\u003e각 플래그에 대해 해당 함수를 실행합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 명령줄 인수 가져오기\u003c/span\u003e\nargs := os.Args[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:]\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(args) == \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e { \u003cspan class=\"hljs-comment\"\u003e// 정확히 하나의 인수가 제공되었는지 확인\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 플래그의 \"-\" 문자를 피하기 위해 단일 인수의 마지막 문자를 가져와서 플래그를 결정\u003c/span\u003e\n    flag_ := args[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(args[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e])\u003cspan class=\"hljs-number\"\u003e-1\u003c/span\u003e:]\n\n    \u003cspan class=\"hljs-comment\"\u003e// 플래그 값에 따라 다른 경우 처리\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e flag_ {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e byteNumberFlag: \u003cspan class=\"hljs-comment\"\u003e// 바이트 수 세는 경우\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// 표준 입력에서 읽기\u003c/span\u003e\n        stdin := handleStandardInput()\n        fmt.Println(getByteNumber(\u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e, \u0026#x26;stdin))\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e linesCounterFlag: \u003cspan class=\"hljs-comment\"\u003e// 줄 수 세는 경우\u003c/span\u003e\n        stdin := handleStandardInput()\n        fmt.Println(getNumberOfLines(\u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e, \u0026#x26;stdin))\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e wordsCounterFlag: \u003cspan class=\"hljs-comment\"\u003e// 단어 수 세는 경우\u003c/span\u003e\n        stdin := handleStandardInput()\n        wordsSlice := strings.Fields(stdin)\n        fmt.Println(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(wordsSlice))\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e characterCounterFlag: \u003cspan class=\"hljs-comment\"\u003e// 문자 수 세는 경우\u003c/span\u003e\n        stdin := handleStandardInput()\n        \u003cspan class=\"hljs-comment\"\u003e// 입력의 UTF-8 룬 수 세기\u003c/span\u003e\n        runes := utf8.RuneCountInString(stdin)\n        fmt.Println(runes)\n    \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e: \u003cspan class=\"hljs-comment\"\u003e// 파일 처리의 기본 경우\u003c/span\u003e\n        ProcessFile(args[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(s \u003cspan class=\"hljs-type\"\u003estring\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e {\n            byteNumber := getByteNumber(\u0026#x26;s, \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e)\n            lineNumber := getNumberOfLines(\u0026#x26;s, \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e)\n            wordNumber := countWords(s)\n\n            \u003cspan class=\"hljs-comment\"\u003e// 바이트, 줄, 단어 수를 문자열과 함께 출력\u003c/span\u003e\n            fmt.Println(byteNumber, lineNumber, wordNumber, s)\n        })\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 인수 처리 후 종료\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e참고: 이 마지막 단계를 작동하도록 도우미 함수에 일부 변경을 가했습니다.\u003c/p\u003e\n\u003cp\u003e읽어주셔서 감사합니다! 다음 도전에 주목해주세요. 이 도전의 전체 소스 코드는 여기에서, 도전 설명은 여기에서 찾을 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-BuildingUnixLinuxwcToolFinalPartAddingSupportforStandardInput"},"buildId":"8coAiP0lmiEK5aH6nkQkj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>