<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>선형 회귀를 사용한 비농업 부문 고용 예측 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="선형 회귀를 사용한 비농업 부문 고용 예측 | itposting" data-gatsby-head="true"/><meta property="og:title" content="선형 회귀를 사용한 비농업 부문 고용 예측 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression" data-gatsby-head="true"/><meta name="twitter:title" content="선형 회귀를 사용한 비농업 부문 고용 예측 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 06:38" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">선형 회귀를 사용한 비농업 부문 고용 예측</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="선형 회귀를 사용한 비농업 부문 고용 예측" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression_0.png" alt="image"></p>
<p>선형 회귀는 가끔 단숨함과 선형 종속적 결과 때문에 무시당하기도 합니다. 그러나 많은 복잡한 예측 작업을 선형 회귀를 사용하여 해결할 수 있습니다. 한 번 매우 성공한 헤지 펀드 관리자로부터 들은 적이 있는데, 그들의 정교한 거래 모델 중 하나는 간단한 선형 회귀 모델에 의존했다고 말씀하셨습니다.</p>
<p>이 기사에서는 파이썬을 사용하여 간단한 선형 회귀를 통해 미국의 고용 데이터를 예측하는 방법을 보여줍니다.</p>
<h1>비농업 실업자수란 무엇인가요?</h1>
<div class="content-ad"></div>
<p>비농업 실업률(NFP)은 미국에서 중요하게 살펴보고 있는 경제 지표로, 미국 노동 시장의 건강 상태를 판단하는 중요한 기준 역할을 합니다. 매달 발표되는 이 취업 보고서는 미국의 고용 상황을 종합적으로 보여줍니다. 이 보고서에서는 농업 부문, 가정부 및 비영리 기관의 일자리를 제외한 미국 내 유료 종업원 수의 순 증가량이 공개됩니다.</p>
<p>이 NFP 보고서는 지난 달 동안 특정 부문을 제외한 미국 내 유료 종업원 수의 순 증감을 보여줍니다. 이는 미국 경제의 전반적인 강도와 방향에 대한 통찰력을 제공하기 때문에 특히 중요합니다. 데이터를 분석함으로써 경제학자, 정책 결정자, 투자자 및 기업은 노동 시장의 건강 상황을 평가하고 취업 트렌드를 추적하며 경제 정책, 투자, 채용 관행에 관한 판단을 내릴 수 있습니다.</p>
<p>또한, NFP 보고서는 금융 시장을 넘어서 통화 환율, 이자율 결정 및 기타 금융 상품 등에도 영향을 미칩니다. 매달 예측을 시도하며 우리만의 모델을 적용해 보고 나온 결과를 살펴봅시다.</p>
<p>우리는 방향성 정확도 및 RMSE를 이용하여 예측을 평가할 것입니다. 이들이 의미하는 것은 다음과 같습니다:</p>
<div class="content-ad"></div>
<ul>
<li>방향성 정확도는 NFP가 상승인 경우와 NFP가 하락인 경우를 비교하여 올바른 예측 수와 예측 수를 비교하는 단순한 이진 측정입니다.</li>
<li>RMSE는 평균 제곱근 오차를 의미합니다. 데이터 세트에서 예측 값과 실제 값 사이의 오차의 평균 크기를 측정하는 지표입니다.</li>
</ul>
<p>더 많은 작업을 보고 싶으시면, 제 웹사이트에서 PDF 도서 카탈로그를 확인하실 수 있습니다. 아래 그림에 첨부된 링크를 따라가시면 됩니다:</p>
<p><img src="/assets/img/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression_1.png" alt="PDF books catalogue"></p>
<h1>알고리즘 만들기</h1>
<div class="content-ad"></div>
<p>알고리즘을 생성하기 전에 선형 회귀 알고리즘이 어떻게 작동하는지 알아보겠습니다.</p>
<p>선형 회귀는 데이터 점들의 산점도를 통해 직선을 그리는 것과 같습니다. 집의 크기와 가격에 관한 데이터가 있다고 상상해보세요. 이 정보를 수집하여 대부분의 점을 지나가는 최적의 선을 찾는 데 사용합니다. 이 선은 일반적인 추세를 나타냅니다: 집이 커질수록 가격도 올라가는 경향이 있습니다.</p>
<p>이 과정에는 수학적 계산이 필요하여 선이 가능한 모든 데이터 점에 가장 가깝게 위치하도록 합니다. 이 선을 갖고 나면 집의 크기를 알고 있다면 집의 가격을 예측할 수 있습니다. 이 선은 기울기(크기에 따라 가격이 얼마나 변하는지)와 y절편(크기가 0일 때의 가격, 집에 대해서는 의미가 없음)을 갖고 있습니다. 따라서 이는 두 가지 사이의 관계를 이해하고 예측하는 방법입니다.</p>
<p>작업 계획은 다음과 같습니다:</p>
<div class="content-ad"></div>
<ul>
<li>해당 GitHub 저장소에서 NFP 데이터를 다운로드하고 Python에 업로드하세요.</li>
<li>NFP 데이터의 차이를 취하세요. 이미 stationary 상태이지만 방향성 정확성을 측정하기 위해 이를 수행합니다.</li>
<li>데이터를 학습 세트와 테스트 세트로 분할하세요.</li>
<li>모델을 학습시키는 데에는 마지막 다섯 개의 NFP 변경 사항을 특성으로 사용하세요. 그런 다음 테스트 세트의 이전에 본 적이 없는 데이터에 대해 예측하세요.</li>
<li>예측된 데이터와 실제 데이터를 평가하고 비교하세요.</li>
</ul>
<p>아래 코드를 사용하여 프로세스를 구현하세요 (저장소에서 NFP 데이터를 다운로드해야 함):</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">linear_model</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">LinearRegression</span>
<span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

def <span class="hljs-title function_">data_preprocessing</span>(data, num_lags, train_test_split):
    # 데이터 처리를 위해 준비
    x = []
    y = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(data) - num_lags):
        x.<span class="hljs-title function_">append</span>(data[<span class="hljs-attr">i</span>:i + num_lags])
        y.<span class="hljs-title function_">append</span>(data[i+ num_lags])
    # 데이터를 넘파이 배열로 변환
    x = np.<span class="hljs-title function_">array</span>(x)
    y = np.<span class="hljs-title function_">array</span>(y)
    # 데이터를 학습 및 테스트 세트로 분할
    split_index = <span class="hljs-title function_">int</span>(train_test_split * <span class="hljs-title function_">len</span>(x))
    x_train = x[:split_index]
    y_train = y[:split_index]
    x_test = x[<span class="hljs-attr">split_index</span>:]
    y_test = y[<span class="hljs-attr">split_index</span>:]
    
    <span class="hljs-keyword">return</span> x_train, y_train, x_test, y_test 
# 시간 인덱스가 설정되지 않았다면 설정하세요
data = pd.<span class="hljs-title function_">read_excel</span>(<span class="hljs-string">'NFP.xlsx'</span>).<span class="hljs-property">values</span>
data = np.<span class="hljs-title function_">reshape</span>(data, (-<span class="hljs-number">1</span>))
data = np.<span class="hljs-title function_">diff</span>(data)
x_train, y_train, x_test, y_test = <span class="hljs-title function_">data_preprocessing</span>(data, <span class="hljs-number">5</span>, <span class="hljs-number">0.80</span>)
# <span class="hljs-title class_">CatBoostRegressor</span> 모델 생성
model = <span class="hljs-title class_">LinearRegression</span>()
# 데이터에 모델 학습
model.<span class="hljs-title function_">fit</span>(x_train, y_train)
# 학습에 사용된 데이터에 대해 예측
y_pred = model.<span class="hljs-title function_">predict</span>(x_test)  # 예측을 위해 X 대신 X_new 사용
# 오리지널 사인파와 예측값 플롯
plt.<span class="hljs-title function_">plot</span>(y_pred[-<span class="hljs-number">50</span>:], label=<span class="hljs-string">'예측 데이터'</span>, linestyle=<span class="hljs-string">'--'</span>, marker=<span class="hljs-string">'o'</span>)
plt.<span class="hljs-title function_">plot</span>(y_test[-<span class="hljs-number">50</span>:], label=<span class="hljs-string">'실제 데이터'</span>, marker=<span class="hljs-string">'o'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">grid</span>()
plt.<span class="hljs-title function_">axhline</span>(y=<span class="hljs-number">0</span>, color=<span class="hljs-string">'black'</span>, linestyle=<span class="hljs-string">'--'</span>)
<span class="hljs-keyword">import</span> math
<span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">metrics</span> <span class="hljs-keyword">import</span> mean_squared_error
rmse_test = math.<span class="hljs-title function_">sqrt</span>(<span class="hljs-title function_">mean_squared_error</span>(y_pred, y_test))
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"테스트의 RMSE: {rmse_test}"</span>)
same_sign_count = np.<span class="hljs-title function_">sum</span>(np.<span class="hljs-title function_">sign</span>(y_pred) == np.<span class="hljs-title function_">sign</span>(y_test)) / <span class="hljs-title function_">len</span>(y_test) * <span class="hljs-number">100</span>
<span class="hljs-title function_">print</span>(<span class="hljs-string">'방향성 정확도 = '</span>, same_sign_count, <span class="hljs-string">'%'</span>)
</code></pre>
<p>다음 그림은 실제 데이터와 예측 데이터를 비교합니다.</p>
<div class="content-ad"></div>
<p>위 코드의 출력은 다음과 같습니다:</p>
<pre><code class="hljs language-js">테스트의 <span class="hljs-attr">RMSE</span>: <span class="hljs-number">188.81</span>
방향 정확도 = <span class="hljs-number">69.65</span>%
</code></pre>
<p>69.65%의 방향 정확도로 보아, 모델은 마지막 변화에서 긍정적 또는 부정적 변화가 발생할지를 예측할 수 있는 것으로 보입니다. RMSE는 예측이 약 188의 오류 항을 가지고 있음을 보여줍니다. 이는 개선할 여지가 많이 남아 있다는 것을 의미합니다.</p>
<p>개선은 특성을 더 추가하거나 래깅된 입력의 수를 변경하고 다른 조건을 추가하는 방식으로 이루어질 수 있습니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression_2.png" alt="Graph"></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"선형 회귀를 사용한 비농업 부문 고용 예측","description":"","date":"2024-06-19 06:38","slug":"2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression","content":"\n\n\n![image](/assets/img/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression_0.png)\n\n선형 회귀는 가끔 단숨함과 선형 종속적 결과 때문에 무시당하기도 합니다. 그러나 많은 복잡한 예측 작업을 선형 회귀를 사용하여 해결할 수 있습니다. 한 번 매우 성공한 헤지 펀드 관리자로부터 들은 적이 있는데, 그들의 정교한 거래 모델 중 하나는 간단한 선형 회귀 모델에 의존했다고 말씀하셨습니다.\n\n이 기사에서는 파이썬을 사용하여 간단한 선형 회귀를 통해 미국의 고용 데이터를 예측하는 방법을 보여줍니다.\n\n# 비농업 실업자수란 무엇인가요?\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비농업 실업률(NFP)은 미국에서 중요하게 살펴보고 있는 경제 지표로, 미국 노동 시장의 건강 상태를 판단하는 중요한 기준 역할을 합니다. 매달 발표되는 이 취업 보고서는 미국의 고용 상황을 종합적으로 보여줍니다. 이 보고서에서는 농업 부문, 가정부 및 비영리 기관의 일자리를 제외한 미국 내 유료 종업원 수의 순 증가량이 공개됩니다.\n\n이 NFP 보고서는 지난 달 동안 특정 부문을 제외한 미국 내 유료 종업원 수의 순 증감을 보여줍니다. 이는 미국 경제의 전반적인 강도와 방향에 대한 통찰력을 제공하기 때문에 특히 중요합니다. 데이터를 분석함으로써 경제학자, 정책 결정자, 투자자 및 기업은 노동 시장의 건강 상황을 평가하고 취업 트렌드를 추적하며 경제 정책, 투자, 채용 관행에 관한 판단을 내릴 수 있습니다.\n\n또한, NFP 보고서는 금융 시장을 넘어서 통화 환율, 이자율 결정 및 기타 금융 상품 등에도 영향을 미칩니다. 매달 예측을 시도하며 우리만의 모델을 적용해 보고 나온 결과를 살펴봅시다.\n\n우리는 방향성 정확도 및 RMSE를 이용하여 예측을 평가할 것입니다. 이들이 의미하는 것은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 방향성 정확도는 NFP가 상승인 경우와 NFP가 하락인 경우를 비교하여 올바른 예측 수와 예측 수를 비교하는 단순한 이진 측정입니다.\n- RMSE는 평균 제곱근 오차를 의미합니다. 데이터 세트에서 예측 값과 실제 값 사이의 오차의 평균 크기를 측정하는 지표입니다.\n\n더 많은 작업을 보고 싶으시면, 제 웹사이트에서 PDF 도서 카탈로그를 확인하실 수 있습니다. 아래 그림에 첨부된 링크를 따라가시면 됩니다:\n\n![PDF books catalogue](/assets/img/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression_1.png)\n\n# 알고리즘 만들기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알고리즘을 생성하기 전에 선형 회귀 알고리즘이 어떻게 작동하는지 알아보겠습니다.\n\n선형 회귀는 데이터 점들의 산점도를 통해 직선을 그리는 것과 같습니다. 집의 크기와 가격에 관한 데이터가 있다고 상상해보세요. 이 정보를 수집하여 대부분의 점을 지나가는 최적의 선을 찾는 데 사용합니다. 이 선은 일반적인 추세를 나타냅니다: 집이 커질수록 가격도 올라가는 경향이 있습니다.\n\n이 과정에는 수학적 계산이 필요하여 선이 가능한 모든 데이터 점에 가장 가깝게 위치하도록 합니다. 이 선을 갖고 나면 집의 크기를 알고 있다면 집의 가격을 예측할 수 있습니다. 이 선은 기울기(크기에 따라 가격이 얼마나 변하는지)와 y절편(크기가 0일 때의 가격, 집에 대해서는 의미가 없음)을 갖고 있습니다. 따라서 이는 두 가지 사이의 관계를 이해하고 예측하는 방법입니다.\n\n작업 계획은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 해당 GitHub 저장소에서 NFP 데이터를 다운로드하고 Python에 업로드하세요.\n- NFP 데이터의 차이를 취하세요. 이미 stationary 상태이지만 방향성 정확성을 측정하기 위해 이를 수행합니다.\n- 데이터를 학습 세트와 테스트 세트로 분할하세요.\n- 모델을 학습시키는 데에는 마지막 다섯 개의 NFP 변경 사항을 특성으로 사용하세요. 그런 다음 테스트 세트의 이전에 본 적이 없는 데이터에 대해 예측하세요.\n- 예측된 데이터와 실제 데이터를 평가하고 비교하세요.\n\n아래 코드를 사용하여 프로세스를 구현하세요 (저장소에서 NFP 데이터를 다운로드해야 함):\n\n```js\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndef data_preprocessing(data, num_lags, train_test_split):\n    # 데이터 처리를 위해 준비\n    x = []\n    y = []\n    for i in range(len(data) - num_lags):\n        x.append(data[i:i + num_lags])\n        y.append(data[i+ num_lags])\n    # 데이터를 넘파이 배열로 변환\n    x = np.array(x)\n    y = np.array(y)\n    # 데이터를 학습 및 테스트 세트로 분할\n    split_index = int(train_test_split * len(x))\n    x_train = x[:split_index]\n    y_train = y[:split_index]\n    x_test = x[split_index:]\n    y_test = y[split_index:]\n    \n    return x_train, y_train, x_test, y_test \n# 시간 인덱스가 설정되지 않았다면 설정하세요\ndata = pd.read_excel('NFP.xlsx').values\ndata = np.reshape(data, (-1))\ndata = np.diff(data)\nx_train, y_train, x_test, y_test = data_preprocessing(data, 5, 0.80)\n# CatBoostRegressor 모델 생성\nmodel = LinearRegression()\n# 데이터에 모델 학습\nmodel.fit(x_train, y_train)\n# 학습에 사용된 데이터에 대해 예측\ny_pred = model.predict(x_test)  # 예측을 위해 X 대신 X_new 사용\n# 오리지널 사인파와 예측값 플롯\nplt.plot(y_pred[-50:], label='예측 데이터', linestyle='--', marker='o')\nplt.plot(y_test[-50:], label='실제 데이터', marker='o')\nplt.legend()\nplt.grid()\nplt.axhline(y=0, color='black', linestyle='--')\nimport math\nfrom sklearn.metrics import mean_squared_error\nrmse_test = math.sqrt(mean_squared_error(y_pred, y_test))\nprint(f\"테스트의 RMSE: {rmse_test}\")\nsame_sign_count = np.sum(np.sign(y_pred) == np.sign(y_test)) / len(y_test) * 100\nprint('방향성 정확도 = ', same_sign_count, '%')\n```\n\n다음 그림은 실제 데이터와 예측 데이터를 비교합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 코드의 출력은 다음과 같습니다:\n\n```js\n테스트의 RMSE: 188.81\n방향 정확도 = 69.65%\n```\n\n69.65%의 방향 정확도로 보아, 모델은 마지막 변화에서 긍정적 또는 부정적 변화가 발생할지를 예측할 수 있는 것으로 보입니다. RMSE는 예측이 약 188의 오류 항을 가지고 있음을 보여줍니다. 이는 개선할 여지가 많이 남아 있다는 것을 의미합니다.\n\n개선은 특성을 더 추가하거나 래깅된 입력의 수를 변경하고 다른 조건을 추가하는 방식으로 이루어질 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Graph](/assets/img/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression_2.png)\n","ogImage":{"url":"/assets/img/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression_0.png"},"coverImage":"/assets/img/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e선형 회귀는 가끔 단숨함과 선형 종속적 결과 때문에 무시당하기도 합니다. 그러나 많은 복잡한 예측 작업을 선형 회귀를 사용하여 해결할 수 있습니다. 한 번 매우 성공한 헤지 펀드 관리자로부터 들은 적이 있는데, 그들의 정교한 거래 모델 중 하나는 간단한 선형 회귀 모델에 의존했다고 말씀하셨습니다.\u003c/p\u003e\n\u003cp\u003e이 기사에서는 파이썬을 사용하여 간단한 선형 회귀를 통해 미국의 고용 데이터를 예측하는 방법을 보여줍니다.\u003c/p\u003e\n\u003ch1\u003e비농업 실업자수란 무엇인가요?\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e비농업 실업률(NFP)은 미국에서 중요하게 살펴보고 있는 경제 지표로, 미국 노동 시장의 건강 상태를 판단하는 중요한 기준 역할을 합니다. 매달 발표되는 이 취업 보고서는 미국의 고용 상황을 종합적으로 보여줍니다. 이 보고서에서는 농업 부문, 가정부 및 비영리 기관의 일자리를 제외한 미국 내 유료 종업원 수의 순 증가량이 공개됩니다.\u003c/p\u003e\n\u003cp\u003e이 NFP 보고서는 지난 달 동안 특정 부문을 제외한 미국 내 유료 종업원 수의 순 증감을 보여줍니다. 이는 미국 경제의 전반적인 강도와 방향에 대한 통찰력을 제공하기 때문에 특히 중요합니다. 데이터를 분석함으로써 경제학자, 정책 결정자, 투자자 및 기업은 노동 시장의 건강 상황을 평가하고 취업 트렌드를 추적하며 경제 정책, 투자, 채용 관행에 관한 판단을 내릴 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또한, NFP 보고서는 금융 시장을 넘어서 통화 환율, 이자율 결정 및 기타 금융 상품 등에도 영향을 미칩니다. 매달 예측을 시도하며 우리만의 모델을 적용해 보고 나온 결과를 살펴봅시다.\u003c/p\u003e\n\u003cp\u003e우리는 방향성 정확도 및 RMSE를 이용하여 예측을 평가할 것입니다. 이들이 의미하는 것은 다음과 같습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e방향성 정확도는 NFP가 상승인 경우와 NFP가 하락인 경우를 비교하여 올바른 예측 수와 예측 수를 비교하는 단순한 이진 측정입니다.\u003c/li\u003e\n\u003cli\u003eRMSE는 평균 제곱근 오차를 의미합니다. 데이터 세트에서 예측 값과 실제 값 사이의 오차의 평균 크기를 측정하는 지표입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e더 많은 작업을 보고 싶으시면, 제 웹사이트에서 PDF 도서 카탈로그를 확인하실 수 있습니다. 아래 그림에 첨부된 링크를 따라가시면 됩니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression_1.png\" alt=\"PDF books catalogue\"\u003e\u003c/p\u003e\n\u003ch1\u003e알고리즘 만들기\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e알고리즘을 생성하기 전에 선형 회귀 알고리즘이 어떻게 작동하는지 알아보겠습니다.\u003c/p\u003e\n\u003cp\u003e선형 회귀는 데이터 점들의 산점도를 통해 직선을 그리는 것과 같습니다. 집의 크기와 가격에 관한 데이터가 있다고 상상해보세요. 이 정보를 수집하여 대부분의 점을 지나가는 최적의 선을 찾는 데 사용합니다. 이 선은 일반적인 추세를 나타냅니다: 집이 커질수록 가격도 올라가는 경향이 있습니다.\u003c/p\u003e\n\u003cp\u003e이 과정에는 수학적 계산이 필요하여 선이 가능한 모든 데이터 점에 가장 가깝게 위치하도록 합니다. 이 선을 갖고 나면 집의 크기를 알고 있다면 집의 가격을 예측할 수 있습니다. 이 선은 기울기(크기에 따라 가격이 얼마나 변하는지)와 y절편(크기가 0일 때의 가격, 집에 대해서는 의미가 없음)을 갖고 있습니다. 따라서 이는 두 가지 사이의 관계를 이해하고 예측하는 방법입니다.\u003c/p\u003e\n\u003cp\u003e작업 계획은 다음과 같습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e해당 GitHub 저장소에서 NFP 데이터를 다운로드하고 Python에 업로드하세요.\u003c/li\u003e\n\u003cli\u003eNFP 데이터의 차이를 취하세요. 이미 stationary 상태이지만 방향성 정확성을 측정하기 위해 이를 수행합니다.\u003c/li\u003e\n\u003cli\u003e데이터를 학습 세트와 테스트 세트로 분할하세요.\u003c/li\u003e\n\u003cli\u003e모델을 학습시키는 데에는 마지막 다섯 개의 NFP 변경 사항을 특성으로 사용하세요. 그런 다음 테스트 세트의 이전에 본 적이 없는 데이터에 대해 예측하세요.\u003c/li\u003e\n\u003cli\u003e예측된 데이터와 실제 데이터를 평가하고 비교하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래 코드를 사용하여 프로세스를 구현하세요 (저장소에서 NFP 데이터를 다운로드해야 함):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.\u003cspan class=\"hljs-property\"\u003elinear_model\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLinearRegression\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\ndef \u003cspan class=\"hljs-title function_\"\u003edata_preprocessing\u003c/span\u003e(data, num_lags, train_test_split):\n    # 데이터 처리를 위해 준비\n    x = []\n    y = []\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(data) - num_lags):\n        x.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(data[\u003cspan class=\"hljs-attr\"\u003ei\u003c/span\u003e:i + num_lags])\n        y.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(data[i+ num_lags])\n    # 데이터를 넘파이 배열로 변환\n    x = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(x)\n    y = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(y)\n    # 데이터를 학습 및 테스트 세트로 분할\n    split_index = \u003cspan class=\"hljs-title function_\"\u003eint\u003c/span\u003e(train_test_split * \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(x))\n    x_train = x[:split_index]\n    y_train = y[:split_index]\n    x_test = x[\u003cspan class=\"hljs-attr\"\u003esplit_index\u003c/span\u003e:]\n    y_test = y[\u003cspan class=\"hljs-attr\"\u003esplit_index\u003c/span\u003e:]\n    \n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e x_train, y_train, x_test, y_test \n# 시간 인덱스가 설정되지 않았다면 설정하세요\ndata = pd.\u003cspan class=\"hljs-title function_\"\u003eread_excel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'NFP.xlsx'\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003evalues\u003c/span\u003e\ndata = np.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(data, (-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e))\ndata = np.\u003cspan class=\"hljs-title function_\"\u003ediff\u003c/span\u003e(data)\nx_train, y_train, x_test, y_test = \u003cspan class=\"hljs-title function_\"\u003edata_preprocessing\u003c/span\u003e(data, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.80\u003c/span\u003e)\n# \u003cspan class=\"hljs-title class_\"\u003eCatBoostRegressor\u003c/span\u003e 모델 생성\nmodel = \u003cspan class=\"hljs-title class_\"\u003eLinearRegression\u003c/span\u003e()\n# 데이터에 모델 학습\nmodel.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(x_train, y_train)\n# 학습에 사용된 데이터에 대해 예측\ny_pred = model.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(x_test)  # 예측을 위해 X 대신 X_new 사용\n# 오리지널 사인파와 예측값 플롯\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(y_pred[-\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e:], label=\u003cspan class=\"hljs-string\"\u003e'예측 데이터'\u003c/span\u003e, linestyle=\u003cspan class=\"hljs-string\"\u003e'--'\u003c/span\u003e, marker=\u003cspan class=\"hljs-string\"\u003e'o'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(y_test[-\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e:], label=\u003cspan class=\"hljs-string\"\u003e'실제 데이터'\u003c/span\u003e, marker=\u003cspan class=\"hljs-string\"\u003e'o'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\nplt.\u003cspan class=\"hljs-title function_\"\u003egrid\u003c/span\u003e()\nplt.\u003cspan class=\"hljs-title function_\"\u003eaxhline\u003c/span\u003e(y=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e, linestyle=\u003cspan class=\"hljs-string\"\u003e'--'\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e math\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.\u003cspan class=\"hljs-property\"\u003emetrics\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e mean_squared_error\nrmse_test = math.\u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003emean_squared_error\u003c/span\u003e(y_pred, y_test))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"테스트의 RMSE: {rmse_test}\"\u003c/span\u003e)\nsame_sign_count = np.\u003cspan class=\"hljs-title function_\"\u003esum\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esign\u003c/span\u003e(y_pred) == np.\u003cspan class=\"hljs-title function_\"\u003esign\u003c/span\u003e(y_test)) / \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(y_test) * \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'방향성 정확도 = '\u003c/span\u003e, same_sign_count, \u003cspan class=\"hljs-string\"\u003e'%'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 그림은 실제 데이터와 예측 데이터를 비교합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위 코드의 출력은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e테스트의 \u003cspan class=\"hljs-attr\"\u003eRMSE\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e188.81\u003c/span\u003e\n방향 정확도 = \u003cspan class=\"hljs-number\"\u003e69.65\u003c/span\u003e%\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e69.65%의 방향 정확도로 보아, 모델은 마지막 변화에서 긍정적 또는 부정적 변화가 발생할지를 예측할 수 있는 것으로 보입니다. RMSE는 예측이 약 188의 오류 항을 가지고 있음을 보여줍니다. 이는 개선할 여지가 많이 남아 있다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e개선은 특성을 더 추가하거나 래깅된 입력의 수를 변경하고 다른 조건을 추가하는 방식으로 이루어질 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression_2.png\" alt=\"Graph\"\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-ForecastingNon-FarmPayrollsWithLinearRegression"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>