<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>트라이햅미 케노비 라이트업 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-TryHackMeKenobiWriteup" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="트라이햅미 케노비 라이트업 | itposting" data-gatsby-head="true"/><meta property="og:title" content="트라이햅미 케노비 라이트업 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-TryHackMeKenobiWriteup_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-TryHackMeKenobiWriteup" data-gatsby-head="true"/><meta name="twitter:title" content="트라이햅미 케노비 라이트업 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-TryHackMeKenobiWriteup_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 15:01" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-0fd008072af5a644.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_buildManifest.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">트라이햅미 케노비 라이트업</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="트라이햅미 케노비 라이트업" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-TryHackMeKenobiWriteup&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>리눅스 머신을 해킹해 봅시다.</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_0.png" alt="TryHackMeKenobiWriteup_0"></p>
<p><strong>Task 1</strong> 취약한 머신 배포하기</p>
<p>열려 있는 포트: 7 (nmap <code>머신의 IP 주소</code>-vvv)</p>
<p>과제 2 Samba 공유 목록 열거</p>
<p>Samba는 Linux 및 Unix 용 표준 Windows 상호 운용성 프로그램 스위트입니다. 회사의 내부망 또는 인터넷에서 파일, 프린터 및 기타 공유 리소스에 대한 액세스 및 사용을 끝 사용자에게 허용합니다. 이는 종종 네트워크 파일 시스템으로 불립니다.</p>
<p>Samba는 Server Message Block (SMB)의 공통 클라이언트/서버 프로토콜에 기반을 두고 있습니다. SMB는 Windows 전용으로 개발되었으며, Samba가 없으면 같은 네트워크에 속해 있더라도 다른 컴퓨터 플랫폼이 Windows 기계로부터 격리될 수 있습니다.</p>
<p>nmap을 사용하여 기계를 SMB 공유에 대해 열거할 수 있습니다.</p>
<p>Nmap은 다양한 네트워킹 작업을 자동화하여 실행할 수 있는 능력을 가지고 있어요. 공유를 열거하는 스크립트가 있어요!</p>
<p>nmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse 10.10.3.132</p>
<p>SMB에는 445번과 139번이라는 두 개의 포트가 있어요.</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_1.png" alt="이미지"></p>
<p>위의 nmap 명령어를 사용하여 찾은 공유는 몇 개인가요?</p>
<p>발견된 공유: 3</p>
<p>대부분의 Linux 배포판에는 이미 smbclient가 설치되어 있습니다. 공유 중 하나를 검사해 봅시다.</p>
<p>smbclient //<code>machine’s ip</code>/anonymous</p>
<p>당신의 컴퓨터를 사용하여, 해당 컴퓨터의 네트워크 공유에 연결하세요.</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_3.png" alt="이미지"></p>
<p>연결되었으면 공유된 파일 목록을 나열하세요. 어떤 파일을 볼 수 있나요?</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_4.png" alt="이미지"></p>
<p>파일: log.txt</p>
<p>SMB 공유를 재귀적으로 다운로드할 수도 있습니다. 아이디와 비밀번호를 'nothing'으로 제출하실 수 있습니다.</p>
<p>smbget -R smb://<code>머신의 아이피</code>/anonymous</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_5.png" alt="이미지"></p>
<p>공유된 파일을 열어보세요. 발견된 몇 가지 흥미로운 정보들이 있습니다.</p>
<p>유저를 위해 SSH 키를 생성할 때 Kenobi에 대한 생성된 정보</p>
<p>ProFTPD 서버에 관한 정보.</p>
<p>FTP는 어떤 포트에서 실행되나요?</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_6.png" alt="이미지"></p>
<p>포트: 21</p>
<p>이전에 실행한 nmap 포트 스캔에서 포트 111에서 rpcbind 서비스가 실행 중인 것을 확인했을 것입니다. 이 서비스는 원격 프로시저 호출(RPC) 프로그램 번호를 유니버설 주소로 변환하는 서버에 불과합니다. RPC 서비스가 시작되면 rpcbind에게 해당 서비스가 수신 대기하고 있는 주소 및 제공할 RPC 프로그램 번호를 알려줍니다.</p>
<p>우리 경우에는 포트 111은 네트워크 파일 시스템에 액세스하는 것입니다. 이를 열어보기 위해 nmap을 사용합시다.</p>
<p>nmap -p 111 — script=nfs-ls,nfs-statfs,nfs-showmount 10.10.3.132</p>
<p>어떤 mount를 볼 수 있나요?</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_7.png" alt="네트워크 파일 시스템"></p>
<p><code>Mount: /var</code></p>
<p><strong>Task 3: ProFtpd를 사용하여 초기 액세스 얻기</strong></p>
<p>ProFtpd는 Unix 및 Windows 시스템과 호환되는 무료 오픈 소스 FTP 서버입니다. 과거 소프트웨어 버전에서 취약점이 발견되기도 했습니다.</p>
<p>아래의 질문에 답해주세요.</p>
<p>ProFtpd의 버전을 확인해 봅시다. FTP 포트에 머신에 netcat을 사용하여 연결하세요.</p>
<pre><code class="hljs language-bash">nc `머신의 IP` 21
</code></pre>
<p>버전은 무엇인가요?</p>
<p>버전: 1.3.5</p>
<p>searchsploit을 사용하여 특정 소프트웨어 버전에 대한 취약점을 찾을 수 있어요.</p>
<p>Searchsploit은 기본적으로 exploit-db.com의 명령 줄 검색 도구에요.</p>
<p>ProFTPd를 실행 중인 시스템에 대한 exploit이 얼마나 있죠?</p>
<p>searchsploit ProFTPD <code>버전 번호</code></p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_8.png" alt="이미지"></p>
<p>Exploits running: 4</p>
<p>ProFtpd의 mod_copy 모듈(<a href="http://www.proftpd.org/docs/contrib/mod_copy.html)%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">http://www.proftpd.org/docs/contrib/mod_copy.html)에서</a> exploit을 발견했어요.</p>
<p>mod_copy 모듈은 SITE CPFR 및 SITE CPTO 명령을 구현하며, 이를 사용하여 서버의 한 곳에서 다른 곳으로 파일/디렉터리를 복사할 수 있습니다. 인증되지 않은 클라이언트는 이러한 명령을 이용하여 파일을 파일 시스템의 어디서든 원하는 대상으로 복사할 수 있습니다.</p>
<p>FTP 서비스가 Kenobi 사용자로 실행되고 (공유 파일에서) 그 사용자를 위해 SSH 키가 생성되었다는 것을 알고 있습니다.</p>
<p>이제 SITE CPFR 및 SITE CPTO 명령을 사용하여 Kenobi의 개인 키를 복사할 것입니다.</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_9.png" alt="image"></p>
<p>우리는 /var 디렉토리가 우리가 볼 수 있는 마운트임을 알고 있었습니다(task 2, question 4). 이제 Kenobi의 개인 키를 /var/tmp 디렉토리로 이동했어요.</p>
<p>'/var/tmp' 디렉토리를 우리의 머신에 연결해 봅시다.</p>
<p>sudo mkdir /mnt/kenobiNFS
sudo mount machine_ip:/var /mnt/kenobiNFS
ls -la /mnt/kenobiNFS</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_10.png" alt="Screenshot 10"></p>
<p>We now have a network mount on our deployed machine! We can go to <code>/var/tmp</code> and get the private key then login to Kenobi’s account.</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_11.png" alt="Screenshot 11"></p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_12.png" alt="Screenshot 12"></p>
<p>케노비의 사용자 플래그(/home/kenobi/user.txt)는 무엇인가요?</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_13.png" alt="이미지"></p>
<p>사용자 플래그: d0b0f3f53b6caa532a83915e19224899</p>
<p>작업 4 경로 변수 조작을 통한 권한 상승</p>
<p>우선 SUID, SGID 및 Sticky Bits가 무엇인지 이해해 봅시다.</p>
<p>파일 권한</p>
<p>디렉토리에 대해서</p>
<p>SUID 비트</p>
<p>사용자가 파일 소유자의 권한으로 파일을 실행합니다.</p>
<ul>
<li></li>
</ul>
<p>SGID 비트</p>
<p>사용자가 그룹 소유자의 권한으로 파일을 실행합니다.</p>
<p>디렉토리에 만들어진 파일은 동일한 그룹 소유자를 가집니다.</p>
<p>Sticky Bit</p>
<p>아래 명령어를 사용하여 시스템에서 이 유형의 파일을 검색할 수 있습니다:</p>
<p>다음 명령어를 사용하여 특이한 파일을 찾을 수 있습니다:</p>
<pre><code class="hljs language-bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2>/dev/null
</code></pre>
<p>찾은 파일 중에서 특이한 것은 다음과 같습니다:</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_15.png" alt="특이한 파일"></p>
<p>파일: /usr/bin/menu</p>
<p>바이너리를 실행하면 몇 개의 옵션이 나타납니까?</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_16.png" alt="이미지"></p>
<p>옵션: 3</p>
<p><code>strings</code>는 리눅스에서 바이너리 파일에서 사람이 읽을 수 있는 문자열을 찾는 명령어입니다.</p>
<p>여기에서 볼 수 있듯이, 해당 이진 파일은 전체 경로를 사용하지 않고 (예: /usr/bin/curl 또는 /usr/bin/uname를 사용하지 않음) 실행 중입니다.</p>
<p>이 파일은 루트 사용자 권한으로 실행되므로, 경로를 조작하여 루트 셸을 얻을 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_19.png" alt="이미지1"></p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_20.png" alt="이미지2"></p>
<p>우리는 /bin/sh 쉘을 복사하여 curl이라고 이름 지었으며 올바른 권한을 부여한 다음 그 위치를 경로에 넣었습니다. 이는 /usr/bin/menu 이진 파일이 실행될 때 경로 변수를 사용하여 "curl" 이진 파일을 찾게 한다는 것을 의미합니다. 실제로 이는 /usr/sh의 버전이며 이 파일이 root로 실행되는 동안 우리의 쉘도 root로 실행됩니다!</p>
<p>루트 플래그(/root/root.txt)는 무엇인가요?</p>
<p><img src="/assets/img/2024-06-19-TryHackMeKenobiWriteup_21.png" alt="이미지"></p>
<p>Root Flag: 177b3cd8562289f37382721c28381f02</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"트라이햅미 케노비 라이트업","description":"","date":"2024-06-19 15:01","slug":"2024-06-19-TryHackMeKenobiWriteup","content":"\n\n리눅스 머신을 해킹해 봅시다.\n\n![TryHackMeKenobiWriteup_0](/assets/img/2024-06-19-TryHackMeKenobiWriteup_0.png)\n\n**Task 1** 취약한 머신 배포하기\n\n열려 있는 포트: 7 (nmap `머신의 IP 주소`-vvv)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n과제 2 Samba 공유 목록 열거\n\nSamba는 Linux 및 Unix 용 표준 Windows 상호 운용성 프로그램 스위트입니다. 회사의 내부망 또는 인터넷에서 파일, 프린터 및 기타 공유 리소스에 대한 액세스 및 사용을 끝 사용자에게 허용합니다. 이는 종종 네트워크 파일 시스템으로 불립니다.\n\nSamba는 Server Message Block (SMB)의 공통 클라이언트/서버 프로토콜에 기반을 두고 있습니다. SMB는 Windows 전용으로 개발되었으며, Samba가 없으면 같은 네트워크에 속해 있더라도 다른 컴퓨터 플랫폼이 Windows 기계로부터 격리될 수 있습니다.\n\nnmap을 사용하여 기계를 SMB 공유에 대해 열거할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNmap은 다양한 네트워킹 작업을 자동화하여 실행할 수 있는 능력을 가지고 있어요. 공유를 열거하는 스크립트가 있어요!\n\n\nnmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse 10.10.3.132\n\n\nSMB에는 445번과 139번이라는 두 개의 포트가 있어요.\n\n![이미지](/assets/img/2024-06-19-TryHackMeKenobiWriteup_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_2.png\" /\u003e\n\n위의 nmap 명령어를 사용하여 찾은 공유는 몇 개인가요?\n\n발견된 공유: 3\n\n대부분의 Linux 배포판에는 이미 smbclient가 설치되어 있습니다. 공유 중 하나를 검사해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nsmbclient //`machine’s ip`/anonymous\n\n당신의 컴퓨터를 사용하여, 해당 컴퓨터의 네트워크 공유에 연결하세요.\n\n![이미지](/assets/img/2024-06-19-TryHackMeKenobiWriteup_3.png)\n\n연결되었으면 공유된 파일 목록을 나열하세요. 어떤 파일을 볼 수 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-TryHackMeKenobiWriteup_4.png)\n\n파일: log.txt\n\nSMB 공유를 재귀적으로 다운로드할 수도 있습니다. 아이디와 비밀번호를 'nothing'으로 제출하실 수 있습니다.\n\nsmbget -R smb://`머신의 아이피`/anonymous\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-TryHackMeKenobiWriteup_5.png)\n\n공유된 파일을 열어보세요. 발견된 몇 가지 흥미로운 정보들이 있습니다.\n\n유저를 위해 SSH 키를 생성할 때 Kenobi에 대한 생성된 정보\n\nProFTPD 서버에 관한 정보.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFTP는 어떤 포트에서 실행되나요?\n\n![이미지](/assets/img/2024-06-19-TryHackMeKenobiWriteup_6.png)\n\n포트: 21\n\n이전에 실행한 nmap 포트 스캔에서 포트 111에서 rpcbind 서비스가 실행 중인 것을 확인했을 것입니다. 이 서비스는 원격 프로시저 호출(RPC) 프로그램 번호를 유니버설 주소로 변환하는 서버에 불과합니다. RPC 서비스가 시작되면 rpcbind에게 해당 서비스가 수신 대기하고 있는 주소 및 제공할 RPC 프로그램 번호를 알려줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리 경우에는 포트 111은 네트워크 파일 시스템에 액세스하는 것입니다. 이를 열어보기 위해 nmap을 사용합시다.\n\nnmap -p 111 — script=nfs-ls,nfs-statfs,nfs-showmount 10.10.3.132\n\n어떤 mount를 볼 수 있나요?\n\n![네트워크 파일 시스템](/assets/img/2024-06-19-TryHackMeKenobiWriteup_7.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`Mount: /var`\n\n**Task 3: ProFtpd를 사용하여 초기 액세스 얻기**\n\nProFtpd는 Unix 및 Windows 시스템과 호환되는 무료 오픈 소스 FTP 서버입니다. 과거 소프트웨어 버전에서 취약점이 발견되기도 했습니다.\n\n아래의 질문에 답해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nProFtpd의 버전을 확인해 봅시다. FTP 포트에 머신에 netcat을 사용하여 연결하세요.\n\n```bash\nnc `머신의 IP` 21\n```\n\n버전은 무엇인가요?\n\n버전: 1.3.5\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nsearchsploit을 사용하여 특정 소프트웨어 버전에 대한 취약점을 찾을 수 있어요.\n\nSearchsploit은 기본적으로 exploit-db.com의 명령 줄 검색 도구에요.\n\nProFTPd를 실행 중인 시스템에 대한 exploit이 얼마나 있죠?\n\nsearchsploit ProFTPD `버전 번호`\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-TryHackMeKenobiWriteup_8.png)\n\nExploits running: 4\n\nProFtpd의 mod_copy 모듈(http://www.proftpd.org/docs/contrib/mod_copy.html)에서 exploit을 발견했어요.\n\nmod_copy 모듈은 SITE CPFR 및 SITE CPTO 명령을 구현하며, 이를 사용하여 서버의 한 곳에서 다른 곳으로 파일/디렉터리를 복사할 수 있습니다. 인증되지 않은 클라이언트는 이러한 명령을 이용하여 파일을 파일 시스템의 어디서든 원하는 대상으로 복사할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFTP 서비스가 Kenobi 사용자로 실행되고 (공유 파일에서) 그 사용자를 위해 SSH 키가 생성되었다는 것을 알고 있습니다.\n\n이제 SITE CPFR 및 SITE CPTO 명령을 사용하여 Kenobi의 개인 키를 복사할 것입니다.\n\n![image](/assets/img/2024-06-19-TryHackMeKenobiWriteup_9.png)\n\n우리는 /var 디렉토리가 우리가 볼 수 있는 마운트임을 알고 있었습니다(task 2, question 4). 이제 Kenobi의 개인 키를 /var/tmp 디렉토리로 이동했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n'/var/tmp' 디렉토리를 우리의 머신에 연결해 봅시다.\n\n\nsudo mkdir /mnt/kenobiNFS\nsudo mount machine_ip:/var /mnt/kenobiNFS\nls -la /mnt/kenobiNFS\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Screenshot 10](/assets/img/2024-06-19-TryHackMeKenobiWriteup_10.png)\n\nWe now have a network mount on our deployed machine! We can go to `/var/tmp` and get the private key then login to Kenobi’s account.\n\n![Screenshot 11](/assets/img/2024-06-19-TryHackMeKenobiWriteup_11.png)\n\n![Screenshot 12](/assets/img/2024-06-19-TryHackMeKenobiWriteup_12.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n케노비의 사용자 플래그(/home/kenobi/user.txt)는 무엇인가요?\n\n![이미지](/assets/img/2024-06-19-TryHackMeKenobiWriteup_13.png)\n\n사용자 플래그: d0b0f3f53b6caa532a83915e19224899\n\n작업 4 경로 변수 조작을 통한 권한 상승\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_14.png\" /\u003e\n\n우선 SUID, SGID 및 Sticky Bits가 무엇인지 이해해 봅시다.\n\n파일 권한\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n디렉토리에 대해서\n\nSUID 비트\n\n사용자가 파일 소유자의 권한으로 파일을 실행합니다.\n\n-\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSGID 비트\n\n사용자가 그룹 소유자의 권한으로 파일을 실행합니다.\n\n디렉토리에 만들어진 파일은 동일한 그룹 소유자를 가집니다.\n\nSticky Bit\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 명령어를 사용하여 시스템에서 이 유형의 파일을 검색할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 명령어를 사용하여 특이한 파일을 찾을 수 있습니다: \n```bash\nfind / -perm -u=s -type f 2\u003e/dev/null\n```\n\n찾은 파일 중에서 특이한 것은 다음과 같습니다:\n\n![특이한 파일](/assets/img/2024-06-19-TryHackMeKenobiWriteup_15.png)\n\n파일: /usr/bin/menu\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n바이너리를 실행하면 몇 개의 옵션이 나타납니까?\n\n![이미지](/assets/img/2024-06-19-TryHackMeKenobiWriteup_16.png)\n\n옵션: 3\n\n`strings`는 리눅스에서 바이너리 파일에서 사람이 읽을 수 있는 문자열을 찾는 명령어입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_17.png\" /\u003e\n\n여기에서 볼 수 있듯이, 해당 이진 파일은 전체 경로를 사용하지 않고 (예: /usr/bin/curl 또는 /usr/bin/uname를 사용하지 않음) 실행 중입니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_18.png\" /\u003e\n\n이 파일은 루트 사용자 권한으로 실행되므로, 경로를 조작하여 루트 셸을 얻을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지1](/assets/img/2024-06-19-TryHackMeKenobiWriteup_19.png)\n\n![이미지2](/assets/img/2024-06-19-TryHackMeKenobiWriteup_20.png)\n\n우리는 /bin/sh 쉘을 복사하여 curl이라고 이름 지었으며 올바른 권한을 부여한 다음 그 위치를 경로에 넣었습니다. 이는 /usr/bin/menu 이진 파일이 실행될 때 경로 변수를 사용하여 \"curl\" 이진 파일을 찾게 한다는 것을 의미합니다. 실제로 이는 /usr/sh의 버전이며 이 파일이 root로 실행되는 동안 우리의 쉘도 root로 실행됩니다!\n\n루트 플래그(/root/root.txt)는 무엇인가요?\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-TryHackMeKenobiWriteup_21.png)\n\nRoot Flag: 177b3cd8562289f37382721c28381f02\n","ogImage":{"url":"/assets/img/2024-06-19-TryHackMeKenobiWriteup_0.png"},"coverImage":"/assets/img/2024-06-19-TryHackMeKenobiWriteup_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e리눅스 머신을 해킹해 봅시다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_0.png\" alt=\"TryHackMeKenobiWriteup_0\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTask 1\u003c/strong\u003e 취약한 머신 배포하기\u003c/p\u003e\n\u003cp\u003e열려 있는 포트: 7 (nmap \u003ccode\u003e머신의 IP 주소\u003c/code\u003e-vvv)\u003c/p\u003e\n\u003cp\u003e과제 2 Samba 공유 목록 열거\u003c/p\u003e\n\u003cp\u003eSamba는 Linux 및 Unix 용 표준 Windows 상호 운용성 프로그램 스위트입니다. 회사의 내부망 또는 인터넷에서 파일, 프린터 및 기타 공유 리소스에 대한 액세스 및 사용을 끝 사용자에게 허용합니다. 이는 종종 네트워크 파일 시스템으로 불립니다.\u003c/p\u003e\n\u003cp\u003eSamba는 Server Message Block (SMB)의 공통 클라이언트/서버 프로토콜에 기반을 두고 있습니다. SMB는 Windows 전용으로 개발되었으며, Samba가 없으면 같은 네트워크에 속해 있더라도 다른 컴퓨터 플랫폼이 Windows 기계로부터 격리될 수 있습니다.\u003c/p\u003e\n\u003cp\u003enmap을 사용하여 기계를 SMB 공유에 대해 열거할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eNmap은 다양한 네트워킹 작업을 자동화하여 실행할 수 있는 능력을 가지고 있어요. 공유를 열거하는 스크립트가 있어요!\u003c/p\u003e\n\u003cp\u003enmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse 10.10.3.132\u003c/p\u003e\n\u003cp\u003eSMB에는 445번과 139번이라는 두 개의 포트가 있어요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e위의 nmap 명령어를 사용하여 찾은 공유는 몇 개인가요?\u003c/p\u003e\n\u003cp\u003e발견된 공유: 3\u003c/p\u003e\n\u003cp\u003e대부분의 Linux 배포판에는 이미 smbclient가 설치되어 있습니다. 공유 중 하나를 검사해 봅시다.\u003c/p\u003e\n\u003cp\u003esmbclient //\u003ccode\u003emachine’s ip\u003c/code\u003e/anonymous\u003c/p\u003e\n\u003cp\u003e당신의 컴퓨터를 사용하여, 해당 컴퓨터의 네트워크 공유에 연결하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e연결되었으면 공유된 파일 목록을 나열하세요. 어떤 파일을 볼 수 있나요?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e파일: log.txt\u003c/p\u003e\n\u003cp\u003eSMB 공유를 재귀적으로 다운로드할 수도 있습니다. 아이디와 비밀번호를 'nothing'으로 제출하실 수 있습니다.\u003c/p\u003e\n\u003cp\u003esmbget -R smb://\u003ccode\u003e머신의 아이피\u003c/code\u003e/anonymous\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e공유된 파일을 열어보세요. 발견된 몇 가지 흥미로운 정보들이 있습니다.\u003c/p\u003e\n\u003cp\u003e유저를 위해 SSH 키를 생성할 때 Kenobi에 대한 생성된 정보\u003c/p\u003e\n\u003cp\u003eProFTPD 서버에 관한 정보.\u003c/p\u003e\n\u003cp\u003eFTP는 어떤 포트에서 실행되나요?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e포트: 21\u003c/p\u003e\n\u003cp\u003e이전에 실행한 nmap 포트 스캔에서 포트 111에서 rpcbind 서비스가 실행 중인 것을 확인했을 것입니다. 이 서비스는 원격 프로시저 호출(RPC) 프로그램 번호를 유니버설 주소로 변환하는 서버에 불과합니다. RPC 서비스가 시작되면 rpcbind에게 해당 서비스가 수신 대기하고 있는 주소 및 제공할 RPC 프로그램 번호를 알려줍니다.\u003c/p\u003e\n\u003cp\u003e우리 경우에는 포트 111은 네트워크 파일 시스템에 액세스하는 것입니다. 이를 열어보기 위해 nmap을 사용합시다.\u003c/p\u003e\n\u003cp\u003enmap -p 111 — script=nfs-ls,nfs-statfs,nfs-showmount 10.10.3.132\u003c/p\u003e\n\u003cp\u003e어떤 mount를 볼 수 있나요?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_7.png\" alt=\"네트워크 파일 시스템\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eMount: /var\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTask 3: ProFtpd를 사용하여 초기 액세스 얻기\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eProFtpd는 Unix 및 Windows 시스템과 호환되는 무료 오픈 소스 FTP 서버입니다. 과거 소프트웨어 버전에서 취약점이 발견되기도 했습니다.\u003c/p\u003e\n\u003cp\u003e아래의 질문에 답해주세요.\u003c/p\u003e\n\u003cp\u003eProFtpd의 버전을 확인해 봅시다. FTP 포트에 머신에 netcat을 사용하여 연결하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003enc `머신의 IP` 21\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e버전은 무엇인가요?\u003c/p\u003e\n\u003cp\u003e버전: 1.3.5\u003c/p\u003e\n\u003cp\u003esearchsploit을 사용하여 특정 소프트웨어 버전에 대한 취약점을 찾을 수 있어요.\u003c/p\u003e\n\u003cp\u003eSearchsploit은 기본적으로 exploit-db.com의 명령 줄 검색 도구에요.\u003c/p\u003e\n\u003cp\u003eProFTPd를 실행 중인 시스템에 대한 exploit이 얼마나 있죠?\u003c/p\u003e\n\u003cp\u003esearchsploit ProFTPD \u003ccode\u003e버전 번호\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eExploits running: 4\u003c/p\u003e\n\u003cp\u003eProFtpd의 mod_copy 모듈(\u003ca href=\"http://www.proftpd.org/docs/contrib/mod_copy.html)%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://www.proftpd.org/docs/contrib/mod_copy.html)에서\u003c/a\u003e exploit을 발견했어요.\u003c/p\u003e\n\u003cp\u003emod_copy 모듈은 SITE CPFR 및 SITE CPTO 명령을 구현하며, 이를 사용하여 서버의 한 곳에서 다른 곳으로 파일/디렉터리를 복사할 수 있습니다. 인증되지 않은 클라이언트는 이러한 명령을 이용하여 파일을 파일 시스템의 어디서든 원하는 대상으로 복사할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eFTP 서비스가 Kenobi 사용자로 실행되고 (공유 파일에서) 그 사용자를 위해 SSH 키가 생성되었다는 것을 알고 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 SITE CPFR 및 SITE CPTO 명령을 사용하여 Kenobi의 개인 키를 복사할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_9.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e우리는 /var 디렉토리가 우리가 볼 수 있는 마운트임을 알고 있었습니다(task 2, question 4). 이제 Kenobi의 개인 키를 /var/tmp 디렉토리로 이동했어요.\u003c/p\u003e\n\u003cp\u003e'/var/tmp' 디렉토리를 우리의 머신에 연결해 봅시다.\u003c/p\u003e\n\u003cp\u003esudo mkdir /mnt/kenobiNFS\nsudo mount machine_ip:/var /mnt/kenobiNFS\nls -la /mnt/kenobiNFS\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_10.png\" alt=\"Screenshot 10\"\u003e\u003c/p\u003e\n\u003cp\u003eWe now have a network mount on our deployed machine! We can go to \u003ccode\u003e/var/tmp\u003c/code\u003e and get the private key then login to Kenobi’s account.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_11.png\" alt=\"Screenshot 11\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_12.png\" alt=\"Screenshot 12\"\u003e\u003c/p\u003e\n\u003cp\u003e케노비의 사용자 플래그(/home/kenobi/user.txt)는 무엇인가요?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_13.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e사용자 플래그: d0b0f3f53b6caa532a83915e19224899\u003c/p\u003e\n\u003cp\u003e작업 4 경로 변수 조작을 통한 권한 상승\u003c/p\u003e\n\u003cp\u003e우선 SUID, SGID 및 Sticky Bits가 무엇인지 이해해 봅시다.\u003c/p\u003e\n\u003cp\u003e파일 권한\u003c/p\u003e\n\u003cp\u003e디렉토리에 대해서\u003c/p\u003e\n\u003cp\u003eSUID 비트\u003c/p\u003e\n\u003cp\u003e사용자가 파일 소유자의 권한으로 파일을 실행합니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSGID 비트\u003c/p\u003e\n\u003cp\u003e사용자가 그룹 소유자의 권한으로 파일을 실행합니다.\u003c/p\u003e\n\u003cp\u003e디렉토리에 만들어진 파일은 동일한 그룹 소유자를 가집니다.\u003c/p\u003e\n\u003cp\u003eSticky Bit\u003c/p\u003e\n\u003cp\u003e아래 명령어를 사용하여 시스템에서 이 유형의 파일을 검색할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e다음 명령어를 사용하여 특이한 파일을 찾을 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003efind / -perm -u=s -\u003cspan class=\"hljs-built_in\"\u003etype\u003c/span\u003e f 2\u003e/dev/null\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e찾은 파일 중에서 특이한 것은 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_15.png\" alt=\"특이한 파일\"\u003e\u003c/p\u003e\n\u003cp\u003e파일: /usr/bin/menu\u003c/p\u003e\n\u003cp\u003e바이너리를 실행하면 몇 개의 옵션이 나타납니까?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_16.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e옵션: 3\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003estrings\u003c/code\u003e는 리눅스에서 바이너리 파일에서 사람이 읽을 수 있는 문자열을 찾는 명령어입니다.\u003c/p\u003e\n\u003cp\u003e여기에서 볼 수 있듯이, 해당 이진 파일은 전체 경로를 사용하지 않고 (예: /usr/bin/curl 또는 /usr/bin/uname를 사용하지 않음) 실행 중입니다.\u003c/p\u003e\n\u003cp\u003e이 파일은 루트 사용자 권한으로 실행되므로, 경로를 조작하여 루트 셸을 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_19.png\" alt=\"이미지1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_20.png\" alt=\"이미지2\"\u003e\u003c/p\u003e\n\u003cp\u003e우리는 /bin/sh 쉘을 복사하여 curl이라고 이름 지었으며 올바른 권한을 부여한 다음 그 위치를 경로에 넣었습니다. 이는 /usr/bin/menu 이진 파일이 실행될 때 경로 변수를 사용하여 \"curl\" 이진 파일을 찾게 한다는 것을 의미합니다. 실제로 이는 /usr/sh의 버전이며 이 파일이 root로 실행되는 동안 우리의 쉘도 root로 실행됩니다!\u003c/p\u003e\n\u003cp\u003e루트 플래그(/root/root.txt)는 무엇인가요?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TryHackMeKenobiWriteup_21.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eRoot Flag: 177b3cd8562289f37382721c28381f02\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-TryHackMeKenobiWriteup"},"buildId":"FH3Qr-mLAesqA0X5IFRQr","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>