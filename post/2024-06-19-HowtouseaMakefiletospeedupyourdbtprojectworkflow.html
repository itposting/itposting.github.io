<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>dbt 프로젝트 작업 흐름을 빠르게하는 방법 Makefile 사용하기 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="dbt 프로젝트 작업 흐름을 빠르게하는 방법 Makefile 사용하기 | itposting" data-gatsby-head="true"/><meta property="og:title" content="dbt 프로젝트 작업 흐름을 빠르게하는 방법 Makefile 사용하기 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow" data-gatsby-head="true"/><meta name="twitter:title" content="dbt 프로젝트 작업 흐름을 빠르게하는 방법 Makefile 사용하기 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 16:02" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_buildManifest.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">dbt 프로젝트 작업 흐름을 빠르게하는 방법 Makefile 사용하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="dbt 프로젝트 작업 흐름을 빠르게하는 방법 Makefile 사용하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>명령 체계를 간소화하고 관련 명령을 그룹화하여 재사용성을 높이세요</h2>
<p>빌드, 실행, 테스트, 문서, 스냅샷, 복제 등 dbt 명령이 많이 있습니다. 저와 같은 경우면 필요한 명령어를 다시 입력하기 싫어서 명령어 히스토리를 계속 찾아다니고 있을 것입니다. 특히 여러 명령을 자주 함께 사용할 때는 더 그렇습니다. 더 나은 해결책이 있을 것입니다.</p>
<p><img src="/assets/img/2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow_0.png" alt="Makefile"></p>
<h1>Makefile이 구원해줄 것입니다</h1>
<div class="content-ad"></div>
<p>소프트웨어를 컴파일한 적이 없다면 메이크파일을 본 적이 없을 수도 있어요. 메이크파일은 코드를 컴파일하는 데 필요한 모든 종속성과 명령을 관리하는 데 사용되지만, 리눅스나 맥 OS에서 어떤 작업을 자동화하는 데도 사용할 수 있어요.</p>
<p>메이크파일을 사용하면 기본적으로 자신만의 추상화된 명령을 만들 수 있어요. 이를 필요로 하는 경우가 있습니다:</p>
<ul>
<li>같은 명령을 자주 실행하는 경우</li>
<li>명령이 길고 매번 입력하기 귀찮거나 명령 기록을 찾기 싫은 경우</li>
<li>명령을 논리적으로 &#x26;&#x26; 그룹으로 묶고 싶은 경우</li>
<li>명령을 공유하거나 일반적인 명령 패턴을 프로젝트에 포함하고 싶은 경우</li>
</ul>
<p>메이크파일의 미세한 세부 사항에 너무 심술을 파는 것은 필요하지 않아요. 알아야 할 주요한 점은 우리가 타겟과 명령으로 구성된 규칙을 만들 수 있다는 것이에요. 'Phony'라는 특별한 타겟을 사용할 것인데요, 아래에서 좀 더 자세히 알아볼게요.</p>
<div class="content-ad"></div>
<h1>간단한 예제</h1>
<p>다음은 dbt 문서를 생성하고 제공하는 간단한 makefile입니다:</p>
<pre><code class="hljs language-js"># 기본 대상에 대한 문서 생성 및 제공
.<span class="hljs-property">PHONY</span>: docs
<span class="hljs-attr">docs</span>:
 dbt docs generate &#x26;&#x26; dbt docs serve
</code></pre>
<ul>
<li>프로젝트의 루트 디렉토리에 위 줄을 포함한 Makefile(확장자 없음)이라는 파일을 만듭니다.</li>
<li>프로젝트의 루트에서 make docs를 실행하면 dbt docs generate &#x26;&#x26; dbt docs serve 명령이 실행됩니다.</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-js">$ make docs
dbt docs generate &#x26;&#x26; dbt docs serve
<span class="hljs-number">04</span>:<span class="hljs-number">35</span>:<span class="hljs-number">12</span>  dbt 실행 중=<span class="hljs-number">1.7</span><span class="hljs-number">.9</span>
<span class="hljs-number">04</span>:<span class="hljs-number">35</span>:<span class="hljs-number">12</span>  등록된 어댑터: duckdb=<span class="hljs-number">1.7</span><span class="hljs-number">.2</span>
<span class="hljs-number">04</span>:<span class="hljs-number">35</span>:<span class="hljs-number">12</span>  모델 <span class="hljs-number">7</span>개, 테스트 <span class="hljs-number">25</span>개, 소스 <span class="hljs-number">3</span>개, 노출 <span class="hljs-number">0</span>개, 메트릭 <span class="hljs-number">0</span>개, 매크로 <span class="hljs-number">582</span>개, 그룹 <span class="hljs-number">0</span>개, 의미 모델 <span class="hljs-number">0</span>개 발견됨
...
...
</code></pre>
<h1>.PHONY</h1>
<p>.PHONY로 시작하는 줄을 본 적이 있을지도 모르겠죠. 이것은 홀덴 코필드와는 아무 상관이 없습니다. 이것은 'Phony targets'라고 불리는 사용자 정의 대상을 정의하는 방법입니다. 이는 파일이 아닌 명령을 참조하는 makefile 규칙입니다.</p>
<p>기억해야 할 것은 대상을 올바르게 작동하도록 'Phony'로 식별하는 것입니다. 이를 간단한 예제처럼 각 대상 위에 할 수도 있고, 대신에 다음과 같이 한 곳에 모두 선언할 수도 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">.<span class="hljs-property">PHONY</span>: build test docs help
</code></pre>
<p>이렇게 하면 build, test, docs, help 네 개의 가짜 대상이 정의되며, 여러분의 makefile 상단에 위치합니다.</p>
<h1>이것으로 빌드합니다</h1>
<p>추가하는 명령어는 실제로 여러분의 개인적인 워크플로우에 따라 다양합니다. 그것이 바로 이에 대한 아름다움입니다 — 그것들은 여러분의 프로젝트에 유용한 명령어로 이루어진 여러분만의 특정 명령어 세트입니다.</p>
<div class="content-ad"></div>
<p>다음은 추가적인 기본 예시 몇 가지가 있어요:</p>
<pre><code class="hljs language-js">.<span class="hljs-property">PHONY</span> run seed docs kitchen-sink clean 

<span class="hljs-attr">run</span>:
 dbt run &#x26;&#x26; dbt test
 
<span class="hljs-attr">seed</span>:
 dbt seed &#x26;&#x26; dbt run
 
<span class="hljs-attr">docs</span>:
 dbt docs generate &#x26;&#x26; dbt docs serve

kitchen-<span class="hljs-attr">sink</span>:
 dbt clean &#x26;&#x26; dbt deps &#x26;&#x26; dbt seed &#x26;&#x26; dbt run &#x26;&#x26; dbt test

<span class="hljs-attr">clean</span>:
 dbt clean &#x26;&#x26; dbt deps
</code></pre>
<h1>고급 예시</h1>
<p>명령줄에서 변수를 makefile로 전달하거나 환경 변수를 로드하여 더 심화된 수준으로 이어갈 수 있어요.</p>
<div class="content-ad"></div>
<h2>CLI에서 변수 전달하기</h2>
<p>가정해보자. dbt 빌드 명령을 실행하고 dbt 환경 대상을 지정하고 싶다면 다음과 같이 코드를 작성할 수 있습니다:</p>
<pre><code class="hljs language-js">.<span class="hljs-property">PHONY</span>: build

<span class="hljs-attr">build</span>:
 @echo <span class="hljs-string">"Building project with environment: $(TARGET)"</span>
 dbt build --tar<span class="hljs-keyword">get</span> <span class="hljs-title function_">$</span>(<span class="hljs-params">TARGET</span>)
</code></pre>
<p>그런 다음 make 명령을 실행할 때 사용할 dbt 대상을 지정할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">$ make build <span class="hljs-variable constant_">TARGET</span>=dev
환경: dev으로 프로젝트 빌드 중
dbt 빌드 --target dev
<span class="hljs-number">04</span>:<span class="hljs-number">11</span>:<span class="hljs-number">42</span>  dbt=<span class="hljs-number">1.7</span><span class="hljs-number">.9</span> 버전으로 실행 중
...
</code></pre>
<p>환경 변수와 함께 사용하면 makefile이 프로젝트를 조작하는 데 매우 강력한 도구가 될 수 있음을 알 수 있습니다.</p>
<h2>환경 변수 로드</h2>
<p>.env 파일을 로드하려면 makefile 맨 위에 다음을 추가하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">include .<span class="hljs-property">env</span>
<span class="hljs-keyword">export</span>
</code></pre>
<p>이제 당신의 makefile은 모든 .env 변수를 불러올 것입니다. 예를 들어 기본 dbt 타겟을 지정할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">TARGET</span>=dev
</code></pre>
<p>그런 다음, makefile을 업데이트하여 .env 변수가 설정되었는지 확인해주세요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">include .<span class="hljs-property">env</span>
<span class="hljs-keyword">export</span>

# <span class="hljs-title class_">Default</span> value <span class="hljs-keyword">for</span> <span class="hljs-variable constant_">TARGET</span> <span class="hljs-keyword">if</span> not set
<span class="hljs-variable constant_">TARGET</span> ?= $(<span class="hljs-variable constant_">TARGET</span>)

.<span class="hljs-property">PHONY</span>: build

<span class="hljs-attr">build</span>:
 @echo <span class="hljs-string">"프로젝트를 환경과 함께 빌드 중: $(TARGET)"</span>
 dbt build --tar<span class="hljs-keyword">get</span> <span class="hljs-title function_">$</span>(<span class="hljs-params">TARGET</span>)
</code></pre>
<p>이제 make build를 실행할 때, .env 파일에 정의된 대상인 dev가 사용됩니다. 그러나 make 명령을 실행할 때 TARGET를 지정하여 재정의할 수도 있습니다:</p>
<pre><code class="hljs language-js"># 기본 .<span class="hljs-property">env</span> 대상 재정의
make build <span class="hljs-variable constant_">TARGET</span>=prod
</code></pre>
<p>이로써 makefile이 일종의 bash 스크립트로 변환되었습니다 (이것을 말할 때 리눅스 전문가들이 나를 죽일지도 모릅니다). 특히 환경 변수를 로드할 수 있다는 점을 고려할 때입니다.</p>
<div class="content-ad"></div>
<h1>도움말 섹션</h1>
<p>명령을 완료하면 만든 모든 사용 가능한 명령에 대해 설명하는 도움말 섹션을 추가하십시오. 이렇게 하면 거의 자체 CLI 도구처럼 만들어집니다!</p>
<pre><code class="hljs language-js"># 사용 가능한 명령 표시
.<span class="hljs-property">PHONY</span>: help
<span class="hljs-attr">help</span>:
 @echo <span class="hljs-string">"사용 가능한 명령:"</span>
 @echo <span class="hljs-string">"  docs - 기본 대상의 문서 생성 및 서비스"</span>
</code></pre>
<h1>일반 dbt 작업을 위한 보일러플레이트 makefile</h1>
<div class="content-ad"></div>
<p>여기 시작할 수 있는 보일러플레이트가 있어요. 별로 복잡하지 않지만 시작할 때 도움이 될 거에요:</p>
<p>프로젝트를 위한 기본 TARGET 및 PROFILE을 가진 .env 파일을 만들어놓지 않았다면 기억하세요.</p>
<h2>Makefile 활용</h2>
<p>구체적인 요구 사항과 의존성을 갖는 실제 프로젝트에서 makefile이 어떻게 보일 수 있는지 알고 싶다면, Alex가 Zero to dbt 프로젝트의 makefile에서 어떤 작업을 했는지 확인해보세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">.<span class="hljs-property">include</span> .<span class="hljs-property">env</span>
.<span class="hljs-property">export</span>

.<span class="hljs-property">PHONY</span>: run clean clean_log duck_dev duck_prod

<span class="hljs-variable constant_">DBT_TARGET</span> = dev

<span class="hljs-attr">run</span>:
 @echo <span class="hljs-string">"SPODBTIFY_SOURCE_PARQUET = $$SPODBTIFY_SOURCE_PARQUET"</span>
 dbt run --tar<span class="hljs-keyword">get</span> <span class="hljs-title function_">$</span>(<span class="hljs-params">DBT_TARGET</span>)

<span class="hljs-attr">doc</span>: 
 dbt docs generate &#x26;&#x26; dbt docs serve 

<span class="hljs-attr">duck_dev</span>:
 duckdb spodbtify.<span class="hljs-property">duckdb</span> -cmd <span class="hljs-string">"USE spodbtify.dev; show all tables"</span>

<span class="hljs-attr">duck_prod</span>:
 duckdb spodbtify.<span class="hljs-property">duckdb</span> -cmd <span class="hljs-string">"USE spodbtify.prod; show all tables"</span>

<span class="hljs-attr">clean</span>: 
 unset <span class="hljs-variable constant_">SPODBTIFY_SOURCE_PARQUET</span> &#x26;&#x26; dbt clean &#x26;&#x26; rm -rf *.<span class="hljs-property">duckdb</span>

<span class="hljs-attr">clean_log</span>:
 rm -rf logs<span class="hljs-comment">/*.log
</span></code></pre>
<p>이 프로젝트는 duckdb를 사용하므로 Alex가 duckdb를 실행하고 prod 및 dev의 테이블을 표시하는 몇 가지 타겟을 만들었습니다. 따라서 프로젝트에서 makefile을 사용하는 방식은 구성에 매우 의존함을 알 수 있습니다.</p>
<h1>결론</h1>
<p>Makefiles는 사용하는 명령어를 소유하는 강력한 방법이 될 수 있습니다. 여러 명령어를 자주 실행하거나 프로젝트별 공통 작업이 있는 경우 생명 구원자가 될 수 있습니다.</p>
<div class="content-ad"></div>
<p>한 가지 단점은 원래 명령어를 추상화함으로써 해당 명령어로부터 동떨어져 있게 될 수 있다는 점입니다. 원래 명령어를 잊어버릴 수도 있고, 새로운 기능이나 사용 패턴을 놓칠 수도 있습니다. 따라서 자주 자신의 makefile을 다시 살펴보는 것이 좋습니다.</p>
<p>프로젝트에서 makefile을 사용하고 계신가요? 팁이나 멋진 사용 예시가 있다면 댓글로 공유해주세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"dbt 프로젝트 작업 흐름을 빠르게하는 방법 Makefile 사용하기","description":"","date":"2024-06-19 16:02","slug":"2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow","content":"\n\n## 명령 체계를 간소화하고 관련 명령을 그룹화하여 재사용성을 높이세요\n\n빌드, 실행, 테스트, 문서, 스냅샷, 복제 등 dbt 명령이 많이 있습니다. 저와 같은 경우면 필요한 명령어를 다시 입력하기 싫어서 명령어 히스토리를 계속 찾아다니고 있을 것입니다. 특히 여러 명령을 자주 함께 사용할 때는 더 그렇습니다. 더 나은 해결책이 있을 것입니다.\n\n![Makefile](/assets/img/2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow_0.png)\n\n# Makefile이 구원해줄 것입니다\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n소프트웨어를 컴파일한 적이 없다면 메이크파일을 본 적이 없을 수도 있어요. 메이크파일은 코드를 컴파일하는 데 필요한 모든 종속성과 명령을 관리하는 데 사용되지만, 리눅스나 맥 OS에서 어떤 작업을 자동화하는 데도 사용할 수 있어요.\n\n메이크파일을 사용하면 기본적으로 자신만의 추상화된 명령을 만들 수 있어요. 이를 필요로 하는 경우가 있습니다:\n\n- 같은 명령을 자주 실행하는 경우\n- 명령이 길고 매번 입력하기 귀찮거나 명령 기록을 찾기 싫은 경우\n- 명령을 논리적으로 \u0026\u0026 그룹으로 묶고 싶은 경우\n- 명령을 공유하거나 일반적인 명령 패턴을 프로젝트에 포함하고 싶은 경우\n\n메이크파일의 미세한 세부 사항에 너무 심술을 파는 것은 필요하지 않아요. 알아야 할 주요한 점은 우리가 타겟과 명령으로 구성된 규칙을 만들 수 있다는 것이에요. 'Phony'라는 특별한 타겟을 사용할 것인데요, 아래에서 좀 더 자세히 알아볼게요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 간단한 예제\n\n다음은 dbt 문서를 생성하고 제공하는 간단한 makefile입니다:\n\n```js\n# 기본 대상에 대한 문서 생성 및 제공\n.PHONY: docs\ndocs:\n dbt docs generate \u0026\u0026 dbt docs serve\n```\n\n- 프로젝트의 루트 디렉토리에 위 줄을 포함한 Makefile(확장자 없음)이라는 파일을 만듭니다.\n- 프로젝트의 루트에서 make docs를 실행하면 dbt docs generate \u0026\u0026 dbt docs serve 명령이 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ make docs\ndbt docs generate \u0026\u0026 dbt docs serve\n04:35:12  dbt 실행 중=1.7.9\n04:35:12  등록된 어댑터: duckdb=1.7.2\n04:35:12  모델 7개, 테스트 25개, 소스 3개, 노출 0개, 메트릭 0개, 매크로 582개, 그룹 0개, 의미 모델 0개 발견됨\n...\n...\n```\n\n# .PHONY\n\n.PHONY로 시작하는 줄을 본 적이 있을지도 모르겠죠. 이것은 홀덴 코필드와는 아무 상관이 없습니다. 이것은 'Phony targets'라고 불리는 사용자 정의 대상을 정의하는 방법입니다. 이는 파일이 아닌 명령을 참조하는 makefile 규칙입니다.\n\n기억해야 할 것은 대상을 올바르게 작동하도록 'Phony'로 식별하는 것입니다. 이를 간단한 예제처럼 각 대상 위에 할 수도 있고, 대신에 다음과 같이 한 곳에 모두 선언할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n.PHONY: build test docs help\n```\n\n이렇게 하면 build, test, docs, help 네 개의 가짜 대상이 정의되며, 여러분의 makefile 상단에 위치합니다.\n\n# 이것으로 빌드합니다\n\n추가하는 명령어는 실제로 여러분의 개인적인 워크플로우에 따라 다양합니다. 그것이 바로 이에 대한 아름다움입니다 — 그것들은 여러분의 프로젝트에 유용한 명령어로 이루어진 여러분만의 특정 명령어 세트입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 추가적인 기본 예시 몇 가지가 있어요:\n\n```js\n.PHONY run seed docs kitchen-sink clean \n\nrun:\n dbt run \u0026\u0026 dbt test\n \nseed:\n dbt seed \u0026\u0026 dbt run\n \ndocs:\n dbt docs generate \u0026\u0026 dbt docs serve\n\nkitchen-sink:\n dbt clean \u0026\u0026 dbt deps \u0026\u0026 dbt seed \u0026\u0026 dbt run \u0026\u0026 dbt test\n\nclean:\n dbt clean \u0026\u0026 dbt deps\n```\n\n# 고급 예시\n\n명령줄에서 변수를 makefile로 전달하거나 환경 변수를 로드하여 더 심화된 수준으로 이어갈 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## CLI에서 변수 전달하기\n\n가정해보자. dbt 빌드 명령을 실행하고 dbt 환경 대상을 지정하고 싶다면 다음과 같이 코드를 작성할 수 있습니다:\n\n```js\n.PHONY: build\n\nbuild:\n @echo \"Building project with environment: $(TARGET)\"\n dbt build --target $(TARGET)\n```\n\n그런 다음 make 명령을 실행할 때 사용할 dbt 대상을 지정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n$ make build TARGET=dev\n환경: dev으로 프로젝트 빌드 중\ndbt 빌드 --target dev\n04:11:42  dbt=1.7.9 버전으로 실행 중\n...\n```\n\n환경 변수와 함께 사용하면 makefile이 프로젝트를 조작하는 데 매우 강력한 도구가 될 수 있음을 알 수 있습니다.\n\n## 환경 변수 로드\n\n.env 파일을 로드하려면 makefile 맨 위에 다음을 추가하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ninclude .env\nexport\n```\n\n이제 당신의 makefile은 모든 .env 변수를 불러올 것입니다. 예를 들어 기본 dbt 타겟을 지정할 수 있습니다:\n\n```js\nTARGET=dev\n```\n\n그런 다음, makefile을 업데이트하여 .env 변수가 설정되었는지 확인해주세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ninclude .env\nexport\n\n# Default value for TARGET if not set\nTARGET ?= $(TARGET)\n\n.PHONY: build\n\nbuild:\n @echo \"프로젝트를 환경과 함께 빌드 중: $(TARGET)\"\n dbt build --target $(TARGET)\n```\n\n이제 make build를 실행할 때, .env 파일에 정의된 대상인 dev가 사용됩니다. 그러나 make 명령을 실행할 때 TARGET를 지정하여 재정의할 수도 있습니다:\n\n```js\n# 기본 .env 대상 재정의\nmake build TARGET=prod\n```\n\n이로써 makefile이 일종의 bash 스크립트로 변환되었습니다 (이것을 말할 때 리눅스 전문가들이 나를 죽일지도 모릅니다). 특히 환경 변수를 로드할 수 있다는 점을 고려할 때입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 도움말 섹션\n\n명령을 완료하면 만든 모든 사용 가능한 명령에 대해 설명하는 도움말 섹션을 추가하십시오. 이렇게 하면 거의 자체 CLI 도구처럼 만들어집니다!\n\n```js\n# 사용 가능한 명령 표시\n.PHONY: help\nhelp:\n @echo \"사용 가능한 명령:\"\n @echo \"  docs - 기본 대상의 문서 생성 및 서비스\"\n``` \n\n# 일반 dbt 작업을 위한 보일러플레이트 makefile\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기 시작할 수 있는 보일러플레이트가 있어요. 별로 복잡하지 않지만 시작할 때 도움이 될 거에요:\n\n프로젝트를 위한 기본 TARGET 및 PROFILE을 가진 .env 파일을 만들어놓지 않았다면 기억하세요.\n\n## Makefile 활용\n\n구체적인 요구 사항과 의존성을 갖는 실제 프로젝트에서 makefile이 어떻게 보일 수 있는지 알고 싶다면, Alex가 Zero to dbt 프로젝트의 makefile에서 어떤 작업을 했는지 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\n.include .env\n.export\n\n.PHONY: run clean clean_log duck_dev duck_prod\n\nDBT_TARGET = dev\n\nrun:\n @echo \"SPODBTIFY_SOURCE_PARQUET = $$SPODBTIFY_SOURCE_PARQUET\"\n dbt run --target $(DBT_TARGET)\n\ndoc: \n dbt docs generate \u0026\u0026 dbt docs serve \n\nduck_dev:\n duckdb spodbtify.duckdb -cmd \"USE spodbtify.dev; show all tables\"\n\nduck_prod:\n duckdb spodbtify.duckdb -cmd \"USE spodbtify.prod; show all tables\"\n\nclean: \n unset SPODBTIFY_SOURCE_PARQUET \u0026\u0026 dbt clean \u0026\u0026 rm -rf *.duckdb\n\nclean_log:\n rm -rf logs/*.log\n```\n\n이 프로젝트는 duckdb를 사용하므로 Alex가 duckdb를 실행하고 prod 및 dev의 테이블을 표시하는 몇 가지 타겟을 만들었습니다. 따라서 프로젝트에서 makefile을 사용하는 방식은 구성에 매우 의존함을 알 수 있습니다.\n\n# 결론\n\nMakefiles는 사용하는 명령어를 소유하는 강력한 방법이 될 수 있습니다. 여러 명령어를 자주 실행하거나 프로젝트별 공통 작업이 있는 경우 생명 구원자가 될 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 가지 단점은 원래 명령어를 추상화함으로써 해당 명령어로부터 동떨어져 있게 될 수 있다는 점입니다. 원래 명령어를 잊어버릴 수도 있고, 새로운 기능이나 사용 패턴을 놓칠 수도 있습니다. 따라서 자주 자신의 makefile을 다시 살펴보는 것이 좋습니다.\n\n프로젝트에서 makefile을 사용하고 계신가요? 팁이나 멋진 사용 예시가 있다면 댓글로 공유해주세요!","ogImage":{"url":"/assets/img/2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow_0.png"},"coverImage":"/assets/img/2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e명령 체계를 간소화하고 관련 명령을 그룹화하여 재사용성을 높이세요\u003c/h2\u003e\n\u003cp\u003e빌드, 실행, 테스트, 문서, 스냅샷, 복제 등 dbt 명령이 많이 있습니다. 저와 같은 경우면 필요한 명령어를 다시 입력하기 싫어서 명령어 히스토리를 계속 찾아다니고 있을 것입니다. 특히 여러 명령을 자주 함께 사용할 때는 더 그렇습니다. 더 나은 해결책이 있을 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow_0.png\" alt=\"Makefile\"\u003e\u003c/p\u003e\n\u003ch1\u003eMakefile이 구원해줄 것입니다\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e소프트웨어를 컴파일한 적이 없다면 메이크파일을 본 적이 없을 수도 있어요. 메이크파일은 코드를 컴파일하는 데 필요한 모든 종속성과 명령을 관리하는 데 사용되지만, 리눅스나 맥 OS에서 어떤 작업을 자동화하는 데도 사용할 수 있어요.\u003c/p\u003e\n\u003cp\u003e메이크파일을 사용하면 기본적으로 자신만의 추상화된 명령을 만들 수 있어요. 이를 필요로 하는 경우가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e같은 명령을 자주 실행하는 경우\u003c/li\u003e\n\u003cli\u003e명령이 길고 매번 입력하기 귀찮거나 명령 기록을 찾기 싫은 경우\u003c/li\u003e\n\u003cli\u003e명령을 논리적으로 \u0026#x26;\u0026#x26; 그룹으로 묶고 싶은 경우\u003c/li\u003e\n\u003cli\u003e명령을 공유하거나 일반적인 명령 패턴을 프로젝트에 포함하고 싶은 경우\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e메이크파일의 미세한 세부 사항에 너무 심술을 파는 것은 필요하지 않아요. 알아야 할 주요한 점은 우리가 타겟과 명령으로 구성된 규칙을 만들 수 있다는 것이에요. 'Phony'라는 특별한 타겟을 사용할 것인데요, 아래에서 좀 더 자세히 알아볼게요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e간단한 예제\u003c/h1\u003e\n\u003cp\u003e다음은 dbt 문서를 생성하고 제공하는 간단한 makefile입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 기본 대상에 대한 문서 생성 및 제공\n.\u003cspan class=\"hljs-property\"\u003ePHONY\u003c/span\u003e: docs\n\u003cspan class=\"hljs-attr\"\u003edocs\u003c/span\u003e:\n dbt docs generate \u0026#x26;\u0026#x26; dbt docs serve\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e프로젝트의 루트 디렉토리에 위 줄을 포함한 Makefile(확장자 없음)이라는 파일을 만듭니다.\u003c/li\u003e\n\u003cli\u003e프로젝트의 루트에서 make docs를 실행하면 dbt docs generate \u0026#x26;\u0026#x26; dbt docs serve 명령이 실행됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ make docs\ndbt docs generate \u0026#x26;\u0026#x26; dbt docs serve\n\u003cspan class=\"hljs-number\"\u003e04\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e35\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e  dbt 실행 중=\u003cspan class=\"hljs-number\"\u003e1.7\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.9\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e04\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e35\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e  등록된 어댑터: duckdb=\u003cspan class=\"hljs-number\"\u003e1.7\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.2\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e04\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e35\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e  모델 \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e개, 테스트 \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e개, 소스 \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e개, 노출 \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e개, 메트릭 \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e개, 매크로 \u003cspan class=\"hljs-number\"\u003e582\u003c/span\u003e개, 그룹 \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e개, 의미 모델 \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e개 발견됨\n...\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e.PHONY\u003c/h1\u003e\n\u003cp\u003e.PHONY로 시작하는 줄을 본 적이 있을지도 모르겠죠. 이것은 홀덴 코필드와는 아무 상관이 없습니다. 이것은 'Phony targets'라고 불리는 사용자 정의 대상을 정의하는 방법입니다. 이는 파일이 아닌 명령을 참조하는 makefile 규칙입니다.\u003c/p\u003e\n\u003cp\u003e기억해야 할 것은 대상을 올바르게 작동하도록 'Phony'로 식별하는 것입니다. 이를 간단한 예제처럼 각 대상 위에 할 수도 있고, 대신에 다음과 같이 한 곳에 모두 선언할 수도 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e.\u003cspan class=\"hljs-property\"\u003ePHONY\u003c/span\u003e: build test docs help\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 build, test, docs, help 네 개의 가짜 대상이 정의되며, 여러분의 makefile 상단에 위치합니다.\u003c/p\u003e\n\u003ch1\u003e이것으로 빌드합니다\u003c/h1\u003e\n\u003cp\u003e추가하는 명령어는 실제로 여러분의 개인적인 워크플로우에 따라 다양합니다. 그것이 바로 이에 대한 아름다움입니다 — 그것들은 여러분의 프로젝트에 유용한 명령어로 이루어진 여러분만의 특정 명령어 세트입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음은 추가적인 기본 예시 몇 가지가 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e.\u003cspan class=\"hljs-property\"\u003ePHONY\u003c/span\u003e run seed docs kitchen-sink clean \n\n\u003cspan class=\"hljs-attr\"\u003erun\u003c/span\u003e:\n dbt run \u0026#x26;\u0026#x26; dbt test\n \n\u003cspan class=\"hljs-attr\"\u003eseed\u003c/span\u003e:\n dbt seed \u0026#x26;\u0026#x26; dbt run\n \n\u003cspan class=\"hljs-attr\"\u003edocs\u003c/span\u003e:\n dbt docs generate \u0026#x26;\u0026#x26; dbt docs serve\n\nkitchen-\u003cspan class=\"hljs-attr\"\u003esink\u003c/span\u003e:\n dbt clean \u0026#x26;\u0026#x26; dbt deps \u0026#x26;\u0026#x26; dbt seed \u0026#x26;\u0026#x26; dbt run \u0026#x26;\u0026#x26; dbt test\n\n\u003cspan class=\"hljs-attr\"\u003eclean\u003c/span\u003e:\n dbt clean \u0026#x26;\u0026#x26; dbt deps\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e고급 예시\u003c/h1\u003e\n\u003cp\u003e명령줄에서 변수를 makefile로 전달하거나 환경 변수를 로드하여 더 심화된 수준으로 이어갈 수 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003eCLI에서 변수 전달하기\u003c/h2\u003e\n\u003cp\u003e가정해보자. dbt 빌드 명령을 실행하고 dbt 환경 대상을 지정하고 싶다면 다음과 같이 코드를 작성할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e.\u003cspan class=\"hljs-property\"\u003ePHONY\u003c/span\u003e: build\n\n\u003cspan class=\"hljs-attr\"\u003ebuild\u003c/span\u003e:\n @echo \u003cspan class=\"hljs-string\"\u003e\"Building project with environment: $(TARGET)\"\u003c/span\u003e\n dbt build --tar\u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e$\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eTARGET\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 make 명령을 실행할 때 사용할 dbt 대상을 지정할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ make build \u003cspan class=\"hljs-variable constant_\"\u003eTARGET\u003c/span\u003e=dev\n환경: dev으로 프로젝트 빌드 중\ndbt 빌드 --target dev\n\u003cspan class=\"hljs-number\"\u003e04\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e11\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e  dbt=\u003cspan class=\"hljs-number\"\u003e1.7\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.9\u003c/span\u003e 버전으로 실행 중\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e환경 변수와 함께 사용하면 makefile이 프로젝트를 조작하는 데 매우 강력한 도구가 될 수 있음을 알 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e환경 변수 로드\u003c/h2\u003e\n\u003cp\u003e.env 파일을 로드하려면 makefile 맨 위에 다음을 추가하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einclude .\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 당신의 makefile은 모든 .env 변수를 불러올 것입니다. 예를 들어 기본 dbt 타겟을 지정할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eTARGET\u003c/span\u003e=dev\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음, makefile을 업데이트하여 .env 변수가 설정되었는지 확인해주세요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einclude .\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e\n\n# \u003cspan class=\"hljs-title class_\"\u003eDefault\u003c/span\u003e value \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTARGET\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not set\n\u003cspan class=\"hljs-variable constant_\"\u003eTARGET\u003c/span\u003e ?= $(\u003cspan class=\"hljs-variable constant_\"\u003eTARGET\u003c/span\u003e)\n\n.\u003cspan class=\"hljs-property\"\u003ePHONY\u003c/span\u003e: build\n\n\u003cspan class=\"hljs-attr\"\u003ebuild\u003c/span\u003e:\n @echo \u003cspan class=\"hljs-string\"\u003e\"프로젝트를 환경과 함께 빌드 중: $(TARGET)\"\u003c/span\u003e\n dbt build --tar\u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e$\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eTARGET\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 make build를 실행할 때, .env 파일에 정의된 대상인 dev가 사용됩니다. 그러나 make 명령을 실행할 때 TARGET를 지정하여 재정의할 수도 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 기본 .\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e 대상 재정의\nmake build \u003cspan class=\"hljs-variable constant_\"\u003eTARGET\u003c/span\u003e=prod\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이로써 makefile이 일종의 bash 스크립트로 변환되었습니다 (이것을 말할 때 리눅스 전문가들이 나를 죽일지도 모릅니다). 특히 환경 변수를 로드할 수 있다는 점을 고려할 때입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e도움말 섹션\u003c/h1\u003e\n\u003cp\u003e명령을 완료하면 만든 모든 사용 가능한 명령에 대해 설명하는 도움말 섹션을 추가하십시오. 이렇게 하면 거의 자체 CLI 도구처럼 만들어집니다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 사용 가능한 명령 표시\n.\u003cspan class=\"hljs-property\"\u003ePHONY\u003c/span\u003e: help\n\u003cspan class=\"hljs-attr\"\u003ehelp\u003c/span\u003e:\n @echo \u003cspan class=\"hljs-string\"\u003e\"사용 가능한 명령:\"\u003c/span\u003e\n @echo \u003cspan class=\"hljs-string\"\u003e\"  docs - 기본 대상의 문서 생성 및 서비스\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e일반 dbt 작업을 위한 보일러플레이트 makefile\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기 시작할 수 있는 보일러플레이트가 있어요. 별로 복잡하지 않지만 시작할 때 도움이 될 거에요:\u003c/p\u003e\n\u003cp\u003e프로젝트를 위한 기본 TARGET 및 PROFILE을 가진 .env 파일을 만들어놓지 않았다면 기억하세요.\u003c/p\u003e\n\u003ch2\u003eMakefile 활용\u003c/h2\u003e\n\u003cp\u003e구체적인 요구 사항과 의존성을 갖는 실제 프로젝트에서 makefile이 어떻게 보일 수 있는지 알고 싶다면, Alex가 Zero to dbt 프로젝트의 makefile에서 어떤 작업을 했는지 확인해보세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e.\u003cspan class=\"hljs-property\"\u003einclude\u003c/span\u003e .\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e\n.\u003cspan class=\"hljs-property\"\u003eexport\u003c/span\u003e\n\n.\u003cspan class=\"hljs-property\"\u003ePHONY\u003c/span\u003e: run clean clean_log duck_dev duck_prod\n\n\u003cspan class=\"hljs-variable constant_\"\u003eDBT_TARGET\u003c/span\u003e = dev\n\n\u003cspan class=\"hljs-attr\"\u003erun\u003c/span\u003e:\n @echo \u003cspan class=\"hljs-string\"\u003e\"SPODBTIFY_SOURCE_PARQUET = $$SPODBTIFY_SOURCE_PARQUET\"\u003c/span\u003e\n dbt run --tar\u003cspan class=\"hljs-keyword\"\u003eget\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e$\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eDBT_TARGET\u003c/span\u003e)\n\n\u003cspan class=\"hljs-attr\"\u003edoc\u003c/span\u003e: \n dbt docs generate \u0026#x26;\u0026#x26; dbt docs serve \n\n\u003cspan class=\"hljs-attr\"\u003educk_dev\u003c/span\u003e:\n duckdb spodbtify.\u003cspan class=\"hljs-property\"\u003educkdb\u003c/span\u003e -cmd \u003cspan class=\"hljs-string\"\u003e\"USE spodbtify.dev; show all tables\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003educk_prod\u003c/span\u003e:\n duckdb spodbtify.\u003cspan class=\"hljs-property\"\u003educkdb\u003c/span\u003e -cmd \u003cspan class=\"hljs-string\"\u003e\"USE spodbtify.prod; show all tables\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003eclean\u003c/span\u003e: \n unset \u003cspan class=\"hljs-variable constant_\"\u003eSPODBTIFY_SOURCE_PARQUET\u003c/span\u003e \u0026#x26;\u0026#x26; dbt clean \u0026#x26;\u0026#x26; rm -rf *.\u003cspan class=\"hljs-property\"\u003educkdb\u003c/span\u003e\n\n\u003cspan class=\"hljs-attr\"\u003eclean_log\u003c/span\u003e:\n rm -rf logs\u003cspan class=\"hljs-comment\"\u003e/*.log\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 프로젝트는 duckdb를 사용하므로 Alex가 duckdb를 실행하고 prod 및 dev의 테이블을 표시하는 몇 가지 타겟을 만들었습니다. 따라서 프로젝트에서 makefile을 사용하는 방식은 구성에 매우 의존함을 알 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eMakefiles는 사용하는 명령어를 소유하는 강력한 방법이 될 수 있습니다. 여러 명령어를 자주 실행하거나 프로젝트별 공통 작업이 있는 경우 생명 구원자가 될 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e한 가지 단점은 원래 명령어를 추상화함으로써 해당 명령어로부터 동떨어져 있게 될 수 있다는 점입니다. 원래 명령어를 잊어버릴 수도 있고, 새로운 기능이나 사용 패턴을 놓칠 수도 있습니다. 따라서 자주 자신의 makefile을 다시 살펴보는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003e프로젝트에서 makefile을 사용하고 계신가요? 팁이나 멋진 사용 예시가 있다면 댓글로 공유해주세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow"},"buildId":"8coAiP0lmiEK5aH6nkQkj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>