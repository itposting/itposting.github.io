<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Docker와 QEMU 엣지 컴퓨팅 개발 가속화 및 코드 컴파일 최적화를 위한 강력한 조합 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Docker와 QEMU 엣지 컴퓨팅 개발 가속화 및 코드 컴파일 최적화를 위한 강력한 조합 | itposting" data-gatsby-head="true"/><meta property="og:title" content="Docker와 QEMU 엣지 컴퓨팅 개발 가속화 및 코드 컴파일 최적화를 위한 강력한 조합 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation" data-gatsby-head="true"/><meta name="twitter:title" content="Docker와 QEMU 엣지 컴퓨팅 개발 가속화 및 코드 컴파일 최적화를 위한 강력한 조합 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 18:22" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Docker와 QEMU 엣지 컴퓨팅 개발 가속화 및 코드 컴파일 최적화를 위한 강력한 조합</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Docker와 QEMU 엣지 컴퓨팅 개발 가속화 및 코드 컴파일 최적화를 위한 강력한 조합" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png" alt="Docker &#x26; QEMU: 강력한 조합"></p>
<p>QEMU는 호스트 시스템에서 가상 머신을 실행할 수 있는 타입-2 하이퍼바이저입니다. x86 및 ARM을 포함한 다양한 아키텍처를 에뮬레이트할 수 있습니다. qemu-system-aarch64 패키지는 AArch64 (ARM64) 시스템 에뮬레이터를 제공하며 CPU 및 다양한 주변장치를 에뮬레이트할 수 있습니다.</p>
<p>Raspberry Pi용 코드를 컴파일하거나 테스트할 때, QEMU를 사용하여 x86 머신에서 AArch64 시스템을 모의 실행할 수 있습니다. 이는 개발자가 실제 Raspberry Pi를 가지고 있지 않아도 해당 코드를 컴파일하고 테스트할 수 있다는 것을 의미합니다. 이는 Jetson, Beaglebone 등 다른 엣지 디바이스에도 적용됩니다.</p>
<p>Raspberry Pi용 코드를 컴파일하기 위해 QEMU를 사용하는 프로세스에는 qemu-system-aarch64 패키지를 사용하여 가상 머신을 설정한 다음 가상 머신에 필요한 도구 및 종속성을 설치하는 과정이 포함됩니다. ARM 아키텍처용 코드를 컴파일하는 데 필요한 GCC 컴파일러 및 기타 도구가 포함됩니다.</p>
<div class="content-ad"></div>
<p>라즈베리 파이용 코드를 컴파일하기 위해 QEMU를 사용하는 장점 중 하나는 일반적으로 라즈베리 파이보다 강력한 x86 머신에서 코드를 테스트하고 디버깅할 수 있다는 것입니다.</p>
<p><img src="/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_1.png" alt="이미지"></p>
<p>도커 이미지 내에서 QEMU를 사용하면 라즈베리 파이용 코드를 컴파일하고 테스트하는 방법이 더욱 효율적이고 효율적해질 수 있습니다.</p>
<p>도커 이미지는 가벼우며 휴대 가능하며 독립적인 컨테이너로, 어떤 머신에서도 쉽게 배포하고 실행할 수 있습니다. 라즈베리 파이용 코드를 컴파일하기 위한 필수 도구 및 종속성을 포함한 QEMU와 함께 도커 이미지를 생성하면 Docker가 설치된 모든 머신에서 이미지를 쉽게 실행할 수 있습니다.</p>
<div class="content-ad"></div>
<p>예를 들어, PyTorch의 C++ 인터페이스 인 libtorch와 같은 대규모 라이브러리를 컴파일하는 것은 Raspberry Pi나 다른 엣지 장치에서 자원이 제한되기 때문에 상당한 시간이 소요될 수 있습니다. QEMU를 사용하여 Docker 이미지 내에서 AArch64 시스템을 x86 머신에서 에뮬레이션함으로써, 개발자는 x86 머신에서 사용 가능한 빠른 처리 속도와 코어 수를 활용하여 컴파일 시간을 크게 줄일 수 있습니다.</p>
<p>예를 들어, 고속 CPU를 탑재한 10코어 x86 머신에서 Raspberry Pi에서 보통 4~5시간 소요되는 libtorch의 컴파일 시간이 30분으로 단축될 수 있습니다. 이는 개발자들에게 상당한 시간을 절약해줄 수 있습니다.</p>
<p>이제 Raspberry Pi 4를 위한 libtorch 라이브러리 빌드 프로세스 예제를 살펴보겠습니다.</p>
<p>호스트 머신 설정:
Docker 설치</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">QEMU</span> 및 크로스 플랫폼 패키지 설치
sudo apt-get install -y gcc-arm-linux-gnueabihf libc6-dev-armhf-cross qemu-user-<span class="hljs-keyword">static</span> qemu-system-i386
</code></pre>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">FROM</span> arm64v8/<span class="hljs-attr">ubuntu</span>:focal
# 참고:
# /usr/bin/qemu-system-aarch64를 로컬 bin 폴더로 복사
<span class="hljs-variable constant_">COPY</span> ./bin/qemu-system-aarch64 /usr/bin/qemu-system-aarch64

<span class="hljs-variable constant_">ARG</span> <span class="hljs-variable constant_">DEBIAN_FRONTEND</span>=noninteractive

# 기본적인 apt 업데이트
<span class="hljs-variable constant_">RUN</span> apt-get update &#x26;&#x26; <span class="hljs-variable constant_">DEBIAN_FRONTEND</span>=noninteractive apt-get install -y --no-install-recommends locales ca-certificates 
 
# 로캘을 en_US.<span class="hljs-property">UTF</span>-<span class="hljs-number">8</span>로 설정(로캘이 없으면 <span class="hljs-title class_">Yocto</span> 빌드 실패함)
<span class="hljs-variable constant_">RUN</span> locale-gen en_US.<span class="hljs-property">UTF</span>-<span class="hljs-number">8</span> &#x26;&#x26; update-locale <span class="hljs-variable constant_">LC_ALL</span>=en_US.<span class="hljs-property">UTF</span>-<span class="hljs-number">8</span> <span class="hljs-variable constant_">LANG</span>=en_US.<span class="hljs-property">UTF</span>-<span class="hljs-number">8</span>
<span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">LANG</span> en_US.<span class="hljs-property">UTF</span>-<span class="hljs-number">8</span>
<span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">LC_ALL</span> en_US.<span class="hljs-property">UTF</span>-<span class="hljs-number">8</span>

# 기본 패키지 설치
<span class="hljs-variable constant_">RUN</span> apt-get update &#x26;&#x26; apt-get install -y \
    apparmor \
    aufs-tools \
    automake \
    bash-completion \
    build-essential \
    cmake \
    curl \
    dpkg-sig \
    g++ \
    gcc \
    git \
    iptables \
    jq \
    libapparmor-dev \
    libc6-dev \
    libcap-dev \
    libsystemd-dev \
    libyaml-dev \
    mercurial \
    net-tools \
    parallel \
    pkg-config \
    golang-go \
    iproute2 \
    iputils-ping \
    vim-common \
    vim \
    --no-install-recommends \
    &#x26;&#x26; apt-get clean \
    &#x26;&#x26; rm -rf /<span class="hljs-keyword">var</span>/lib/apt/lists<span class="hljs-comment">/*

RUN apt-get update &#x26;&#x26; apt install -y software-properties-common &#x26;&#x26; add-apt-repository main &#x26;&#x26; add-apt-repository universe &#x26;&#x26; add-apt-repository restricted &#x26;&#x26; add-apt-repository multiverse

# libtorch 의존성 설치
RUN apt-get install -y clang ninja-build git cmake libjpeg-dev libopenmpi-dev libomp-dev ccache \
    libopenblas-dev libblas-dev libeigen3-dev 
RUN apt-get install -y python3-pip
RUN pip3 install -U --user wheel mock pillow
RUN pip3 install setuptools==58.3.0

# 소스 코드 다운로드
RUN mkdir ~/torch/ &#x26;&#x26; cd ~/torch/ &#x26;&#x26; \
    git clone -b v1.13.0 --depth=1 --recursive https://github.com/pytorch/pytorch.git &#x26;&#x26; \
    cd pytorch &#x26;&#x26; pip3 install -r requirements.txt

# 컴파일 환경 변수 설정
ENV BUILD_CAFFE2_OPS=OFF
ENV USE_FBGEMM=OFF
ENV USE_FAKELOWP=OFF
ENV BUILD_TEST=OFF
ENV USE_MKLDNN=OFF
ENV USE_NNPACK=ON
ENV USE_XNNPACK=ON
ENV USE_QNNPACK=ON
ENV MAX_JOBS=12
ENV USE_NUMPY=ON
ENV USE_OPENCV=OFF
ENV USE_NCCL=OFF
ENV BUILD_SHARED_LIBS=ON
ENV PATH=/usr/lib/ccache:$PATH
ENV CC=clang

# C++ torch 인터페이스 라이브러리(.so) 파일 빌드
RUN cd ~/torch/pytorch/ &#x26;&#x26; python3 tools/build_libtorch.py
</span></code></pre>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Docker</span> 이미지 빌드
sudo docker build --rm --tag arm64v8_libtorch -f arm64v8.<span class="hljs-property">Dockerfile</span> .

# 터미널 <span class="hljs-number">1</span>
# 컴파일된 패키지 실행 및 복사
mkdir libtorch
sudo docker run -v /etc/<span class="hljs-attr">localtime</span>:<span class="hljs-regexp">/etc/</span><span class="hljs-attr">localtime</span>:ro --rm -it -e http_proxy -e https_proxy -e ftp_proxy -v <span class="hljs-string">`pwd`</span>:/work arm64v8_libtorch

# 터미널 <span class="hljs-number">2</span>
# 실행 중인 컨테이너 <span class="hljs-variable constant_">ID</span> 가져오기
sudo docker ps

# 터미널 <span class="hljs-number">3</span>
# 컨테이너에서 호스트 머신으로 파일 복사
sudo docker cp 389143<span class="hljs-attr">f92f85</span>:~<span class="hljs-regexp">/torch/</span>pytorch/torch/bin/ libtorch/
sudo docker cp 389143<span class="hljs-attr">f92f85</span>:~<span class="hljs-regexp">/torch/</span>pytorch/torch/lib/ libtorch/
sudo docker cp 389143<span class="hljs-attr">f92f85</span>:~<span class="hljs-regexp">/torch/</span>pytorch/torch/include/ libtorch/
sudo docker cp 389143<span class="hljs-attr">f92f85</span>:~<span class="hljs-regexp">/torch/</span>pytorch/torch/share/ libtorch/

# 권한 설정
sudo chmod -R <span class="hljs-number">755</span> libtorch<span class="hljs-comment">/* 

# 소유자 변경(scp용)
sudo chown -R username:username libtorch

# 이제 libtorch 폴더를 RPI로 복사할 수 있습니다
scp -r libtorch/ ubuntu@static_ip_address:/home/ubuntu/
</span></code></pre>
<p>Docker 이미지인 "arm64v8_libtorch"를 "arm64v8.Dockerfile" 파일을 사용하여 빌드합니다. "--rm" 플래그는 컨테이너가 종료될 때 자동으로 제거되도록 사용됩니다.</p>
<p>터미널 1:
"arm64v8_libtorch"이라는 빌드된 Docker 이미지를 실행하고 현재 디렉토리를 컨테이너 내의 볼륨으로 마운트합니다.</p>
<p>터미널 2:
실행 중인 컨테이너의 ID를 가져옵니다.</p>
<p>터미널 3:</p>
<ol>
<li>컨테이너에서 호스트 머신으로 파일을 복사합니다.</li>
<li>"libtorch" 폴더 내의 모든 파일의 권한을 755로 변경합니다.</li>
<li>"libtorch" 폴더 내의 모든 파일의 소유권을 현재 사용자 이름으로 변경합니다.</li>
</ol>
<p>터미널 4:
"libtorch" 폴더를 scp를 통해 원격 머신[RPI4]으로 복사합니다.</p>
<div class="content-ad"></div>
<p>ROS2를 X86 호스트 시스템에서 RPI용으로 빌드하는 또 다른 예제를 확인해보세요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">FROM</span> arm64v8/<span class="hljs-attr">ubuntu</span>:focal
<span class="hljs-variable constant_">COPY</span> ./bin/qemu-system-aarch64 /usr/bin/qemu-system-aarch64

<span class="hljs-variable constant_">ARG</span> <span class="hljs-variable constant_">DEBIAN_FRONTEND</span>=noninteractive

# 기본적인 apt 업데이트
<span class="hljs-variable constant_">RUN</span> apt-get update &#x26;&#x26; <span class="hljs-variable constant_">DEBIAN_FRONTEND</span>=noninteractive apt-get install -y --no-install-recommends locales ca-certificates 
 
# <span class="hljs-title class_">Yocto</span> 빌드에 로캘이 설정되어 있지 않으면 빌드에 실패할 수 있으므로 로캘이 en_US.<span class="hljs-property">UTF</span>-<span class="hljs-number">8</span>로 설정됩니다.
<span class="hljs-variable constant_">RUN</span> locale-gen en_US.<span class="hljs-property">UTF</span>-<span class="hljs-number">8</span> &#x26;&#x26; update-locale <span class="hljs-variable constant_">LC_ALL</span>=en_US.<span class="hljs-property">UTF</span>-<span class="hljs-number">8</span> <span class="hljs-variable constant_">LANG</span>=en_US.<span class="hljs-property">UTF</span>-<span class="hljs-number">8</span>
<span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">LANG</span> en_US.<span class="hljs-property">UTF</span>-<span class="hljs-number">8</span>
<span class="hljs-variable constant_">ENV</span> <span class="hljs-variable constant_">LC_ALL</span> en_US.<span class="hljs-property">UTF</span>-<span class="hljs-number">8</span>

# 기본 패키지 가져오기
<span class="hljs-variable constant_">RUN</span> apt-get update &#x26;&#x26; apt-get install -y \
    apparmor \
    aufs-tools \
    automake \
    bash-completion \
    build-essential \
    cmake \
    curl \
    dpkg-sig \
    g++ \
    gcc \
    git \
    iptables \
    jq \
    libapparmor-dev \
    libc6-dev \
    libcap-dev \
    libsystemd-dev \
    libyaml-dev \
    mercurial \
    net-tools \
    parallel \
    pkg-config \
    golang-go \
    iproute2 \
    iputils-ping \
    vim-common \
    vim \
    --no-install-recommends \
    &#x26;&#x26; apt-get clean \
    &#x26;&#x26; rm -rf /<span class="hljs-keyword">var</span>/lib/apt/lists<span class="hljs-comment">/*

...

# 전체 흐름을 간략하게 말하자면, Docker와 QEMU는 엣지 컴퓨팅 개발을 가속화하고 코드 컴파일을 최적화하는 강력한 조합입니다. 이 설정을 통해 개발자들은 x86 기계의 빠른 처리 능력과 리소스를 활용하면서도 라즈베리파이나 젯슨과 같은 ARM 기반 에뮬레이터에서 코드를 테스트하고 디버깅할 수 있습니다. 이 접근 방식은 컴파일 시간을 크게 단축하고 개발 주기를 가속화할 수 있습니다.
</span></code></pre>
<div class="content-ad"></div>
<p>제가 몇 가지 도커 예제를 여기에 만들어 놨어요. 참고용으로 활용하시면 좋을 것 같아요! 설정 프로세스에 대해 궁금한 점이 있거나 추가 도움이 필요하면 언제든지 알려주세요.</p>
<p>흥미로운 기사나 업데이트는 항상 LinkedIn에 공유하고 있어요. 최신 소식을 받아보고 싶으시면 편하게 저를 팔로우해주세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Docker와 QEMU 엣지 컴퓨팅 개발 가속화 및 코드 컴파일 최적화를 위한 강력한 조합","description":"","date":"2024-06-23 18:22","slug":"2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation","content":"\n\n![Docker \u0026 QEMU: 강력한 조합](/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png)\n\nQEMU는 호스트 시스템에서 가상 머신을 실행할 수 있는 타입-2 하이퍼바이저입니다. x86 및 ARM을 포함한 다양한 아키텍처를 에뮬레이트할 수 있습니다. qemu-system-aarch64 패키지는 AArch64 (ARM64) 시스템 에뮬레이터를 제공하며 CPU 및 다양한 주변장치를 에뮬레이트할 수 있습니다.\n\nRaspberry Pi용 코드를 컴파일하거나 테스트할 때, QEMU를 사용하여 x86 머신에서 AArch64 시스템을 모의 실행할 수 있습니다. 이는 개발자가 실제 Raspberry Pi를 가지고 있지 않아도 해당 코드를 컴파일하고 테스트할 수 있다는 것을 의미합니다. 이는 Jetson, Beaglebone 등 다른 엣지 디바이스에도 적용됩니다.\n\nRaspberry Pi용 코드를 컴파일하기 위해 QEMU를 사용하는 프로세스에는 qemu-system-aarch64 패키지를 사용하여 가상 머신을 설정한 다음 가상 머신에 필요한 도구 및 종속성을 설치하는 과정이 포함됩니다. ARM 아키텍처용 코드를 컴파일하는 데 필요한 GCC 컴파일러 및 기타 도구가 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n라즈베리 파이용 코드를 컴파일하기 위해 QEMU를 사용하는 장점 중 하나는 일반적으로 라즈베리 파이보다 강력한 x86 머신에서 코드를 테스트하고 디버깅할 수 있다는 것입니다.\n\n![이미지](/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_1.png)\n\n도커 이미지 내에서 QEMU를 사용하면 라즈베리 파이용 코드를 컴파일하고 테스트하는 방법이 더욱 효율적이고 효율적해질 수 있습니다.\n\n도커 이미지는 가벼우며 휴대 가능하며 독립적인 컨테이너로, 어떤 머신에서도 쉽게 배포하고 실행할 수 있습니다. 라즈베리 파이용 코드를 컴파일하기 위한 필수 도구 및 종속성을 포함한 QEMU와 함께 도커 이미지를 생성하면 Docker가 설치된 모든 머신에서 이미지를 쉽게 실행할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, PyTorch의 C++ 인터페이스 인 libtorch와 같은 대규모 라이브러리를 컴파일하는 것은 Raspberry Pi나 다른 엣지 장치에서 자원이 제한되기 때문에 상당한 시간이 소요될 수 있습니다. QEMU를 사용하여 Docker 이미지 내에서 AArch64 시스템을 x86 머신에서 에뮬레이션함으로써, 개발자는 x86 머신에서 사용 가능한 빠른 처리 속도와 코어 수를 활용하여 컴파일 시간을 크게 줄일 수 있습니다.\n\n예를 들어, 고속 CPU를 탑재한 10코어 x86 머신에서 Raspberry Pi에서 보통 4~5시간 소요되는 libtorch의 컴파일 시간이 30분으로 단축될 수 있습니다. 이는 개발자들에게 상당한 시간을 절약해줄 수 있습니다.\n\n이제 Raspberry Pi 4를 위한 libtorch 라이브러리 빌드 프로세스 예제를 살펴보겠습니다.\n\n호스트 머신 설정:\nDocker 설치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# QEMU 및 크로스 플랫폼 패키지 설치\nsudo apt-get install -y gcc-arm-linux-gnueabihf libc6-dev-armhf-cross qemu-user-static qemu-system-i386\n```\n\n```js\nFROM arm64v8/ubuntu:focal\n# 참고:\n# /usr/bin/qemu-system-aarch64를 로컬 bin 폴더로 복사\nCOPY ./bin/qemu-system-aarch64 /usr/bin/qemu-system-aarch64\n\nARG DEBIAN_FRONTEND=noninteractive\n\n# 기본적인 apt 업데이트\nRUN apt-get update \u0026\u0026 DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends locales ca-certificates \n \n# 로캘을 en_US.UTF-8로 설정(로캘이 없으면 Yocto 빌드 실패함)\nRUN locale-gen en_US.UTF-8 \u0026\u0026 update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nENV LANG en_US.UTF-8\nENV LC_ALL en_US.UTF-8\n\n# 기본 패키지 설치\nRUN apt-get update \u0026\u0026 apt-get install -y \\\n    apparmor \\\n    aufs-tools \\\n    automake \\\n    bash-completion \\\n    build-essential \\\n    cmake \\\n    curl \\\n    dpkg-sig \\\n    g++ \\\n    gcc \\\n    git \\\n    iptables \\\n    jq \\\n    libapparmor-dev \\\n    libc6-dev \\\n    libcap-dev \\\n    libsystemd-dev \\\n    libyaml-dev \\\n    mercurial \\\n    net-tools \\\n    parallel \\\n    pkg-config \\\n    golang-go \\\n    iproute2 \\\n    iputils-ping \\\n    vim-common \\\n    vim \\\n    --no-install-recommends \\\n    \u0026\u0026 apt-get clean \\\n    \u0026\u0026 rm -rf /var/lib/apt/lists/*\n\nRUN apt-get update \u0026\u0026 apt install -y software-properties-common \u0026\u0026 add-apt-repository main \u0026\u0026 add-apt-repository universe \u0026\u0026 add-apt-repository restricted \u0026\u0026 add-apt-repository multiverse\n\n# libtorch 의존성 설치\nRUN apt-get install -y clang ninja-build git cmake libjpeg-dev libopenmpi-dev libomp-dev ccache \\\n    libopenblas-dev libblas-dev libeigen3-dev \nRUN apt-get install -y python3-pip\nRUN pip3 install -U --user wheel mock pillow\nRUN pip3 install setuptools==58.3.0\n\n# 소스 코드 다운로드\nRUN mkdir ~/torch/ \u0026\u0026 cd ~/torch/ \u0026\u0026 \\\n    git clone -b v1.13.0 --depth=1 --recursive https://github.com/pytorch/pytorch.git \u0026\u0026 \\\n    cd pytorch \u0026\u0026 pip3 install -r requirements.txt\n\n# 컴파일 환경 변수 설정\nENV BUILD_CAFFE2_OPS=OFF\nENV USE_FBGEMM=OFF\nENV USE_FAKELOWP=OFF\nENV BUILD_TEST=OFF\nENV USE_MKLDNN=OFF\nENV USE_NNPACK=ON\nENV USE_XNNPACK=ON\nENV USE_QNNPACK=ON\nENV MAX_JOBS=12\nENV USE_NUMPY=ON\nENV USE_OPENCV=OFF\nENV USE_NCCL=OFF\nENV BUILD_SHARED_LIBS=ON\nENV PATH=/usr/lib/ccache:$PATH\nENV CC=clang\n\n# C++ torch 인터페이스 라이브러리(.so) 파일 빌드\nRUN cd ~/torch/pytorch/ \u0026\u0026 python3 tools/build_libtorch.py\n```\n\n```js\n# Docker 이미지 빌드\nsudo docker build --rm --tag arm64v8_libtorch -f arm64v8.Dockerfile .\n\n# 터미널 1\n# 컴파일된 패키지 실행 및 복사\nmkdir libtorch\nsudo docker run -v /etc/localtime:/etc/localtime:ro --rm -it -e http_proxy -e https_proxy -e ftp_proxy -v `pwd`:/work arm64v8_libtorch\n\n# 터미널 2\n# 실행 중인 컨테이너 ID 가져오기\nsudo docker ps\n\n# 터미널 3\n# 컨테이너에서 호스트 머신으로 파일 복사\nsudo docker cp 389143f92f85:~/torch/pytorch/torch/bin/ libtorch/\nsudo docker cp 389143f92f85:~/torch/pytorch/torch/lib/ libtorch/\nsudo docker cp 389143f92f85:~/torch/pytorch/torch/include/ libtorch/\nsudo docker cp 389143f92f85:~/torch/pytorch/torch/share/ libtorch/\n\n# 권한 설정\nsudo chmod -R 755 libtorch/* \n\n# 소유자 변경(scp용)\nsudo chown -R username:username libtorch\n\n# 이제 libtorch 폴더를 RPI로 복사할 수 있습니다\nscp -r libtorch/ ubuntu@static_ip_address:/home/ubuntu/\n``` \n\nDocker 이미지인 \"arm64v8_libtorch\"를 \"arm64v8.Dockerfile\" 파일을 사용하여 빌드합니다. \"--rm\" 플래그는 컨테이너가 종료될 때 자동으로 제거되도록 사용됩니다.\n\n터미널 1:\n\"arm64v8_libtorch\"이라는 빌드된 Docker 이미지를 실행하고 현재 디렉토리를 컨테이너 내의 볼륨으로 마운트합니다.\n\n터미널 2:\n실행 중인 컨테이너의 ID를 가져옵니다.\n\n터미널 3:\n1. 컨테이너에서 호스트 머신으로 파일을 복사합니다.\n2. \"libtorch\" 폴더 내의 모든 파일의 권한을 755로 변경합니다.\n3. \"libtorch\" 폴더 내의 모든 파일의 소유권을 현재 사용자 이름으로 변경합니다.\n\n터미널 4:\n\"libtorch\" 폴더를 scp를 통해 원격 머신[RPI4]으로 복사합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nROS2를 X86 호스트 시스템에서 RPI용으로 빌드하는 또 다른 예제를 확인해보세요.\n\n```js\nFROM arm64v8/ubuntu:focal\nCOPY ./bin/qemu-system-aarch64 /usr/bin/qemu-system-aarch64\n\nARG DEBIAN_FRONTEND=noninteractive\n\n# 기본적인 apt 업데이트\nRUN apt-get update \u0026\u0026 DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends locales ca-certificates \n \n# Yocto 빌드에 로캘이 설정되어 있지 않으면 빌드에 실패할 수 있으므로 로캘이 en_US.UTF-8로 설정됩니다.\nRUN locale-gen en_US.UTF-8 \u0026\u0026 update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nENV LANG en_US.UTF-8\nENV LC_ALL en_US.UTF-8\n\n# 기본 패키지 가져오기\nRUN apt-get update \u0026\u0026 apt-get install -y \\\n    apparmor \\\n    aufs-tools \\\n    automake \\\n    bash-completion \\\n    build-essential \\\n    cmake \\\n    curl \\\n    dpkg-sig \\\n    g++ \\\n    gcc \\\n    git \\\n    iptables \\\n    jq \\\n    libapparmor-dev \\\n    libc6-dev \\\n    libcap-dev \\\n    libsystemd-dev \\\n    libyaml-dev \\\n    mercurial \\\n    net-tools \\\n    parallel \\\n    pkg-config \\\n    golang-go \\\n    iproute2 \\\n    iputils-ping \\\n    vim-common \\\n    vim \\\n    --no-install-recommends \\\n    \u0026\u0026 apt-get clean \\\n    \u0026\u0026 rm -rf /var/lib/apt/lists/*\n\n...\n\n# 전체 흐름을 간략하게 말하자면, Docker와 QEMU는 엣지 컴퓨팅 개발을 가속화하고 코드 컴파일을 최적화하는 강력한 조합입니다. 이 설정을 통해 개발자들은 x86 기계의 빠른 처리 능력과 리소스를 활용하면서도 라즈베리파이나 젯슨과 같은 ARM 기반 에뮬레이터에서 코드를 테스트하고 디버깅할 수 있습니다. 이 접근 방식은 컴파일 시간을 크게 단축하고 개발 주기를 가속화할 수 있습니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 몇 가지 도커 예제를 여기에 만들어 놨어요. 참고용으로 활용하시면 좋을 것 같아요! 설정 프로세스에 대해 궁금한 점이 있거나 추가 도움이 필요하면 언제든지 알려주세요.\n\n흥미로운 기사나 업데이트는 항상 LinkedIn에 공유하고 있어요. 최신 소식을 받아보고 싶으시면 편하게 저를 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png"},"coverImage":"/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png\" alt=\"Docker \u0026#x26; QEMU: 강력한 조합\"\u003e\u003c/p\u003e\n\u003cp\u003eQEMU는 호스트 시스템에서 가상 머신을 실행할 수 있는 타입-2 하이퍼바이저입니다. x86 및 ARM을 포함한 다양한 아키텍처를 에뮬레이트할 수 있습니다. qemu-system-aarch64 패키지는 AArch64 (ARM64) 시스템 에뮬레이터를 제공하며 CPU 및 다양한 주변장치를 에뮬레이트할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eRaspberry Pi용 코드를 컴파일하거나 테스트할 때, QEMU를 사용하여 x86 머신에서 AArch64 시스템을 모의 실행할 수 있습니다. 이는 개발자가 실제 Raspberry Pi를 가지고 있지 않아도 해당 코드를 컴파일하고 테스트할 수 있다는 것을 의미합니다. 이는 Jetson, Beaglebone 등 다른 엣지 디바이스에도 적용됩니다.\u003c/p\u003e\n\u003cp\u003eRaspberry Pi용 코드를 컴파일하기 위해 QEMU를 사용하는 프로세스에는 qemu-system-aarch64 패키지를 사용하여 가상 머신을 설정한 다음 가상 머신에 필요한 도구 및 종속성을 설치하는 과정이 포함됩니다. ARM 아키텍처용 코드를 컴파일하는 데 필요한 GCC 컴파일러 및 기타 도구가 포함됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e라즈베리 파이용 코드를 컴파일하기 위해 QEMU를 사용하는 장점 중 하나는 일반적으로 라즈베리 파이보다 강력한 x86 머신에서 코드를 테스트하고 디버깅할 수 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e도커 이미지 내에서 QEMU를 사용하면 라즈베리 파이용 코드를 컴파일하고 테스트하는 방법이 더욱 효율적이고 효율적해질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e도커 이미지는 가벼우며 휴대 가능하며 독립적인 컨테이너로, 어떤 머신에서도 쉽게 배포하고 실행할 수 있습니다. 라즈베리 파이용 코드를 컴파일하기 위한 필수 도구 및 종속성을 포함한 QEMU와 함께 도커 이미지를 생성하면 Docker가 설치된 모든 머신에서 이미지를 쉽게 실행할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예를 들어, PyTorch의 C++ 인터페이스 인 libtorch와 같은 대규모 라이브러리를 컴파일하는 것은 Raspberry Pi나 다른 엣지 장치에서 자원이 제한되기 때문에 상당한 시간이 소요될 수 있습니다. QEMU를 사용하여 Docker 이미지 내에서 AArch64 시스템을 x86 머신에서 에뮬레이션함으로써, 개발자는 x86 머신에서 사용 가능한 빠른 처리 속도와 코어 수를 활용하여 컴파일 시간을 크게 줄일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 고속 CPU를 탑재한 10코어 x86 머신에서 Raspberry Pi에서 보통 4~5시간 소요되는 libtorch의 컴파일 시간이 30분으로 단축될 수 있습니다. 이는 개발자들에게 상당한 시간을 절약해줄 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 Raspberry Pi 4를 위한 libtorch 라이브러리 빌드 프로세스 예제를 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003e호스트 머신 설정:\nDocker 설치\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-variable constant_\"\u003eQEMU\u003c/span\u003e 및 크로스 플랫폼 패키지 설치\nsudo apt-get install -y gcc-arm-linux-gnueabihf libc6-dev-armhf-cross qemu-user-\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e qemu-system-i386\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e arm64v8/\u003cspan class=\"hljs-attr\"\u003eubuntu\u003c/span\u003e:focal\n# 참고:\n# /usr/bin/qemu-system-aarch64를 로컬 bin 폴더로 복사\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e ./bin/qemu-system-aarch64 /usr/bin/qemu-system-aarch64\n\n\u003cspan class=\"hljs-variable constant_\"\u003eARG\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDEBIAN_FRONTEND\u003c/span\u003e=noninteractive\n\n# 기본적인 apt 업데이트\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e apt-get update \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-variable constant_\"\u003eDEBIAN_FRONTEND\u003c/span\u003e=noninteractive apt-get install -y --no-install-recommends locales ca-certificates \n \n# 로캘을 en_US.\u003cspan class=\"hljs-property\"\u003eUTF\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e로 설정(로캘이 없으면 \u003cspan class=\"hljs-title class_\"\u003eYocto\u003c/span\u003e 빌드 실패함)\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e locale-gen en_US.\u003cspan class=\"hljs-property\"\u003eUTF\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e \u0026#x26;\u0026#x26; update-locale \u003cspan class=\"hljs-variable constant_\"\u003eLC_ALL\u003c/span\u003e=en_US.\u003cspan class=\"hljs-property\"\u003eUTF\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLANG\u003c/span\u003e=en_US.\u003cspan class=\"hljs-property\"\u003eUTF\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLANG\u003c/span\u003e en_US.\u003cspan class=\"hljs-property\"\u003eUTF\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLC_ALL\u003c/span\u003e en_US.\u003cspan class=\"hljs-property\"\u003eUTF\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e\n\n# 기본 패키지 설치\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e apt-get update \u0026#x26;\u0026#x26; apt-get install -y \\\n    apparmor \\\n    aufs-tools \\\n    automake \\\n    bash-completion \\\n    build-essential \\\n    cmake \\\n    curl \\\n    dpkg-sig \\\n    g++ \\\n    gcc \\\n    git \\\n    iptables \\\n    jq \\\n    libapparmor-dev \\\n    libc6-dev \\\n    libcap-dev \\\n    libsystemd-dev \\\n    libyaml-dev \\\n    mercurial \\\n    net-tools \\\n    parallel \\\n    pkg-config \\\n    golang-go \\\n    iproute2 \\\n    iputils-ping \\\n    vim-common \\\n    vim \\\n    --no-install-recommends \\\n    \u0026#x26;\u0026#x26; apt-get clean \\\n    \u0026#x26;\u0026#x26; rm -rf /\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e/lib/apt/lists\u003cspan class=\"hljs-comment\"\u003e/*\n\nRUN apt-get update \u0026#x26;\u0026#x26; apt install -y software-properties-common \u0026#x26;\u0026#x26; add-apt-repository main \u0026#x26;\u0026#x26; add-apt-repository universe \u0026#x26;\u0026#x26; add-apt-repository restricted \u0026#x26;\u0026#x26; add-apt-repository multiverse\n\n# libtorch 의존성 설치\nRUN apt-get install -y clang ninja-build git cmake libjpeg-dev libopenmpi-dev libomp-dev ccache \\\n    libopenblas-dev libblas-dev libeigen3-dev \nRUN apt-get install -y python3-pip\nRUN pip3 install -U --user wheel mock pillow\nRUN pip3 install setuptools==58.3.0\n\n# 소스 코드 다운로드\nRUN mkdir ~/torch/ \u0026#x26;\u0026#x26; cd ~/torch/ \u0026#x26;\u0026#x26; \\\n    git clone -b v1.13.0 --depth=1 --recursive https://github.com/pytorch/pytorch.git \u0026#x26;\u0026#x26; \\\n    cd pytorch \u0026#x26;\u0026#x26; pip3 install -r requirements.txt\n\n# 컴파일 환경 변수 설정\nENV BUILD_CAFFE2_OPS=OFF\nENV USE_FBGEMM=OFF\nENV USE_FAKELOWP=OFF\nENV BUILD_TEST=OFF\nENV USE_MKLDNN=OFF\nENV USE_NNPACK=ON\nENV USE_XNNPACK=ON\nENV USE_QNNPACK=ON\nENV MAX_JOBS=12\nENV USE_NUMPY=ON\nENV USE_OPENCV=OFF\nENV USE_NCCL=OFF\nENV BUILD_SHARED_LIBS=ON\nENV PATH=/usr/lib/ccache:$PATH\nENV CC=clang\n\n# C++ torch 인터페이스 라이브러리(.so) 파일 빌드\nRUN cd ~/torch/pytorch/ \u0026#x26;\u0026#x26; python3 tools/build_libtorch.py\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eDocker\u003c/span\u003e 이미지 빌드\nsudo docker build --rm --tag arm64v8_libtorch -f arm64v8.\u003cspan class=\"hljs-property\"\u003eDockerfile\u003c/span\u003e .\n\n# 터미널 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n# 컴파일된 패키지 실행 및 복사\nmkdir libtorch\nsudo docker run -v /etc/\u003cspan class=\"hljs-attr\"\u003elocaltime\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/etc/\u003c/span\u003e\u003cspan class=\"hljs-attr\"\u003elocaltime\u003c/span\u003e:ro --rm -it -e http_proxy -e https_proxy -e ftp_proxy -v \u003cspan class=\"hljs-string\"\u003e`pwd`\u003c/span\u003e:/work arm64v8_libtorch\n\n# 터미널 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n# 실행 중인 컨테이너 \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e 가져오기\nsudo docker ps\n\n# 터미널 \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n# 컨테이너에서 호스트 머신으로 파일 복사\nsudo docker cp 389143\u003cspan class=\"hljs-attr\"\u003ef92f85\u003c/span\u003e:~\u003cspan class=\"hljs-regexp\"\u003e/torch/\u003c/span\u003epytorch/torch/bin/ libtorch/\nsudo docker cp 389143\u003cspan class=\"hljs-attr\"\u003ef92f85\u003c/span\u003e:~\u003cspan class=\"hljs-regexp\"\u003e/torch/\u003c/span\u003epytorch/torch/lib/ libtorch/\nsudo docker cp 389143\u003cspan class=\"hljs-attr\"\u003ef92f85\u003c/span\u003e:~\u003cspan class=\"hljs-regexp\"\u003e/torch/\u003c/span\u003epytorch/torch/include/ libtorch/\nsudo docker cp 389143\u003cspan class=\"hljs-attr\"\u003ef92f85\u003c/span\u003e:~\u003cspan class=\"hljs-regexp\"\u003e/torch/\u003c/span\u003epytorch/torch/share/ libtorch/\n\n# 권한 설정\nsudo chmod -R \u003cspan class=\"hljs-number\"\u003e755\u003c/span\u003e libtorch\u003cspan class=\"hljs-comment\"\u003e/* \n\n# 소유자 변경(scp용)\nsudo chown -R username:username libtorch\n\n# 이제 libtorch 폴더를 RPI로 복사할 수 있습니다\nscp -r libtorch/ ubuntu@static_ip_address:/home/ubuntu/\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDocker 이미지인 \"arm64v8_libtorch\"를 \"arm64v8.Dockerfile\" 파일을 사용하여 빌드합니다. \"--rm\" 플래그는 컨테이너가 종료될 때 자동으로 제거되도록 사용됩니다.\u003c/p\u003e\n\u003cp\u003e터미널 1:\n\"arm64v8_libtorch\"이라는 빌드된 Docker 이미지를 실행하고 현재 디렉토리를 컨테이너 내의 볼륨으로 마운트합니다.\u003c/p\u003e\n\u003cp\u003e터미널 2:\n실행 중인 컨테이너의 ID를 가져옵니다.\u003c/p\u003e\n\u003cp\u003e터미널 3:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e컨테이너에서 호스트 머신으로 파일을 복사합니다.\u003c/li\u003e\n\u003cli\u003e\"libtorch\" 폴더 내의 모든 파일의 권한을 755로 변경합니다.\u003c/li\u003e\n\u003cli\u003e\"libtorch\" 폴더 내의 모든 파일의 소유권을 현재 사용자 이름으로 변경합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e터미널 4:\n\"libtorch\" 폴더를 scp를 통해 원격 머신[RPI4]으로 복사합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eROS2를 X86 호스트 시스템에서 RPI용으로 빌드하는 또 다른 예제를 확인해보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e arm64v8/\u003cspan class=\"hljs-attr\"\u003eubuntu\u003c/span\u003e:focal\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e ./bin/qemu-system-aarch64 /usr/bin/qemu-system-aarch64\n\n\u003cspan class=\"hljs-variable constant_\"\u003eARG\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDEBIAN_FRONTEND\u003c/span\u003e=noninteractive\n\n# 기본적인 apt 업데이트\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e apt-get update \u0026#x26;\u0026#x26; \u003cspan class=\"hljs-variable constant_\"\u003eDEBIAN_FRONTEND\u003c/span\u003e=noninteractive apt-get install -y --no-install-recommends locales ca-certificates \n \n# \u003cspan class=\"hljs-title class_\"\u003eYocto\u003c/span\u003e 빌드에 로캘이 설정되어 있지 않으면 빌드에 실패할 수 있으므로 로캘이 en_US.\u003cspan class=\"hljs-property\"\u003eUTF\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e로 설정됩니다.\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e locale-gen en_US.\u003cspan class=\"hljs-property\"\u003eUTF\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e \u0026#x26;\u0026#x26; update-locale \u003cspan class=\"hljs-variable constant_\"\u003eLC_ALL\u003c/span\u003e=en_US.\u003cspan class=\"hljs-property\"\u003eUTF\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLANG\u003c/span\u003e=en_US.\u003cspan class=\"hljs-property\"\u003eUTF\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLANG\u003c/span\u003e en_US.\u003cspan class=\"hljs-property\"\u003eUTF\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eENV\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eLC_ALL\u003c/span\u003e en_US.\u003cspan class=\"hljs-property\"\u003eUTF\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e\n\n# 기본 패키지 가져오기\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e apt-get update \u0026#x26;\u0026#x26; apt-get install -y \\\n    apparmor \\\n    aufs-tools \\\n    automake \\\n    bash-completion \\\n    build-essential \\\n    cmake \\\n    curl \\\n    dpkg-sig \\\n    g++ \\\n    gcc \\\n    git \\\n    iptables \\\n    jq \\\n    libapparmor-dev \\\n    libc6-dev \\\n    libcap-dev \\\n    libsystemd-dev \\\n    libyaml-dev \\\n    mercurial \\\n    net-tools \\\n    parallel \\\n    pkg-config \\\n    golang-go \\\n    iproute2 \\\n    iputils-ping \\\n    vim-common \\\n    vim \\\n    --no-install-recommends \\\n    \u0026#x26;\u0026#x26; apt-get clean \\\n    \u0026#x26;\u0026#x26; rm -rf /\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e/lib/apt/lists\u003cspan class=\"hljs-comment\"\u003e/*\n\n...\n\n# 전체 흐름을 간략하게 말하자면, Docker와 QEMU는 엣지 컴퓨팅 개발을 가속화하고 코드 컴파일을 최적화하는 강력한 조합입니다. 이 설정을 통해 개발자들은 x86 기계의 빠른 처리 능력과 리소스를 활용하면서도 라즈베리파이나 젯슨과 같은 ARM 기반 에뮬레이터에서 코드를 테스트하고 디버깅할 수 있습니다. 이 접근 방식은 컴파일 시간을 크게 단축하고 개발 주기를 가속화할 수 있습니다.\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e제가 몇 가지 도커 예제를 여기에 만들어 놨어요. 참고용으로 활용하시면 좋을 것 같아요! 설정 프로세스에 대해 궁금한 점이 있거나 추가 도움이 필요하면 언제든지 알려주세요.\u003c/p\u003e\n\u003cp\u003e흥미로운 기사나 업데이트는 항상 LinkedIn에 공유하고 있어요. 최신 소식을 받아보고 싶으시면 편하게 저를 팔로우해주세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>