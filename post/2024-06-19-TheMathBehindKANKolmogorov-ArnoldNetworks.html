<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>KAN  콜모고로프-아놀드 네트워크 뒤에 숨은 수학 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="KAN  콜모고로프-아놀드 네트워크 뒤에 숨은 수학 | itposting" data-gatsby-head="true"/><meta property="og:title" content="KAN  콜모고로프-아놀드 네트워크 뒤에 숨은 수학 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks" data-gatsby-head="true"/><meta name="twitter:title" content="KAN  콜모고로프-아놀드 네트워크 뒤에 숨은 수학 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 03:45" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_buildManifest.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">KAN  콜모고로프-아놀드 네트워크 뒤에 숨은 수학</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="KAN  콜모고로프-아놀드 네트워크 뒤에 숨은 수학" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">14<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>클래식 다층 퍼셉트론 대안이 나왔어요. 왜 더 정확하고 해석 가능한 건가요? 수학과 코드 심층 탐구.</h2>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_0.png" alt="다음 이미지 참고"></p>
<p>AI 세계에서 신경망은 끊임없는 혁신과 발전을 이끌어옵니다. 많은 획기적인 발전의 핵심에는 복잡한 함수를 근사하는 능력으로 유명한 다층 퍼셉트론(MLP)이 있습니다. 그러나 AI가 얼마나 많이 이루어 낼 수 있는지 경계를 늘릴 때, 우리는 클래식 MLP보다 더 나은 것을 할 수 있을까요?</p>
<p>여기 Kolmogorov-Arnold Networks(KANs)가 나왔습니다. Kolmogorov-Arnold 표현 정리에서 영감을 받은 신경망에 대한 새로운 접근법입니다. 기존 MLP가 각 뉴런에서 고정 활성화 함수를 사용하는 반면, KANs는 네트워크의 가중치(엣지)에 학습 가능한 활성화 함수를 사용합니다. 이 간단한 변경은 정확성, 해석 가능성, 효율성에서 새로운 가능성을 열어줍니다.</p>
<div class="content-ad"></div>
<p>이 기사는 KAN이 신경망 설계에서 혁명적인 발전을 이루는 이유를 탐구합니다. 우리는 그들의 수학적 기초에 대해 자세히 살펴보고, MLP(Multi-Layer Perceptrons)와의 주요 차이점을 강조하며, KAN이 전통적인 방법을 능가할 수 있는 방법을 보여줄 것입니다.</p>
<h1>1: MLP의 한계</h1>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_1.png" alt="이미지"></p>
<p>다층 퍼셉트론(MLP)은 현대 신경망의 핵심 구성 요소입니다. 각각의 뉴런은 데이터로부터 학습하여 복잡한 비선형 함수를 근사하는 것을 목표로 설계된 상호 연결된 노드 레이어로 구성되어 있습니다. 각 뉴런은 입력의 가중 합에 고정된 활성화 함수를 사용하여 입력 데이터를 원하는 출력으로 변환함으로써 여러 계층의 추상화를 통해 동작합니다. MLP는 컴퓨터 비전에서부터 음성 인식까지 다양한 분야에서 앞도적인 성과를 이루어 왔습니다.</p>
<div class="content-ad"></div>
<p>그러나 MLP에는 몇 가지 중요한 제한 사항이 있습니다:</p>
<ul>
<li>노드에 고정된 활성화 함수: MLP의 각 노드에는 ReLU나 Sigmoid와 같은 미리 정의된 활성화 함수가 있습니다. 이러한 고정 함수는 많은 경우에 효과적이지만 네트워크의 유연성과 적응성을 제한합니다. 이는 MLP가 특정 유형의 함수를 최적화하거나 특정 데이터 특성에 적응하는 데 어려움을 겪을 수 있게 만들 수 있습니다.</li>
<li>해석 가능성 문제: MLP는 종종 "블랙 박스"로 비판받습니다. 복잡해지면서, 그들의 의사 결정 과정을 이해하기가 더 어려워집니다. 고정된 활성화 함수와 복잡한 가중치 행렬은 네트워크의 내부 작업을 가리고, 깊이 분석 없이 모델의 예측을 해석하고 신뢰하기 어렵게 만듭니다.</li>
</ul>
<p>이러한 단점은 더 큰 유연성과 해석 가능성을 제공하는 대안이 필요함을 강조하며, Kolmogorov-Arnold Networks (KANs)와 같은 혁신을 위한 길을 열어줍니다.</p>
<h1>2: Kolmogorov-Arnold Networks (KANs)</h1>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_2.png" alt="이미지"></p>
<p>콜모고로프-아놀드 표현 이론은 수학자 안드레이 콜모고로프와 블라디미르 아놀드가 정립한 이론으로, 이론은 다변수 연속 함수를 단일 변수의 연속 함수와 덧셈 작업의 유한 구성으로 표현할 수 있다고 주장합니다. 이 이론은 복잡한 레시피를 각각의 간단한 단계로 분해하는 것으로 생각할 수 있습니다. 전체 레시피 전체적으로 다루는 대신에 각 단계를 개별적으로 처리하여 전반적인 프로세스를 더 효율적으로 만듭니다. 이 이론은 복잡한 고차원 함수를 간단한 단일 변수 함수로 분해할 수 있다는 것을 시사합니다.</p>
<p>KAN(Kolmogorov-Arnold Networks)은 콜모고로프-아놀드 이론의 힘을 활용하여 신경망의 구조를 근본적으로 변경합니다. 전통적인 MLP에서는 각 노드에 고정된 활성화 함수가 적용되지만, KAN은 네트워크의 가중치에 학습 가능한 활성화 함수를 배치합니다. 이러한 주요 차이점은 고정된 활성화 함수 세트가 아닌, KAN이 학습 중에 적용할 최상의 함수를 적응적으로 학습한다는 것을 의미합니다. KAN의 각 가중치는 데이터를 기반으로 한 다이내믹하고 세밀한 조정이 가능한 스플라인으로 매개변수화된 단일 변수 함수를 나타냅니다.</p>
<p>이 변화는 네트워크의 유연성을 향상시키고 데이터의 복잡한 패턴을 포착할 수 있는 능력을 강화하여 전통적인 MLP에 대한 해석 가능하고 강력한 대안을 제공합니다. KAN은 가장 최적의 성능을 위해 엣지에 있는 학습 가능한 활성화 함수에 초점을 맞춘 결과, 다양한 AI 작업에서 성능이 향상됩니다.</p>
<div class="content-ad"></div>
<h1>3: 수학적 기초</h1>
<p>콜모고로프-아놀드 네트워크(KANs)의 핵심은 이러한 네트워크가 입력 데이터를 처리하고 변환하는 방식을 정의하는 일련의 방정식입니다. KANs의 기초는 콜모고로프-아놀드 표현 정리에 있으며, 이는 네트워크의 구조와 학습 과정에 영감을 주는 개념입니다.</p>
<p>입력 벡터 x=[x1,x2,…,xn]가 있다고 상상해보세요. 이 벡터는 처리하려는 데이터 포인트를 나타냅니다. 이 입력 벡터를 레시피의 재료 목록으로 생각해보세요.</p>
<p>이 정리는 어떤 복잡한 레시피(고차원 함수)라도 보다 간단한 단계(일변량 함수)로 분해할 수 있다는 것을 명시합니다. KANs에서는 각 재료(입력 값)가 네트워크의 가장자리에 배치된 일련의 간단한 단계(일변량 함수)를 통해 변환됩니다. 이를 수학적으로 표현하면:</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_3.png" alt="image"></p>
<p>여기서 ϕ_q,p는 학습 중에 학습되는 단변량 함수입니다. ϕ_q,p를 각 재료에 대한 개별 조리 기술로 생각하고, Φ_q를 이러한 준비된 재료를 결합하는 최종 조립 단계로 생각해보세요.</p>
<p>KAN의 각 층은 이러한 요리 기술을 사용하여 재료를 더 변형합니다. 층 l에 대해, 변형은 다음과 같이 주어집니다:</p>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_4.png" alt="image"></p>
<div class="content-ad"></div>
<p>여기서 x(l)은 l번째 레이어에서 변환된 재료를 나타내고, ϕ_l,i,j는 l레이어와 l+1 레이어 사이의 학습 가능한 일변량 함수입니다. 이를 각 단계마다 재료에 다양한 조리 기술을 적용하여 중간 요리를 얻는 것으로 생각해보세요.</p>
<p>KAN의 출력은 이러한 레이어 변환의 합성입니다. 중간 요리를 결합하여 최종 식사를 만드는 것처럼, KAN은 변환을 결합하여 최종 출력물을 생성합니다:</p>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_5.png" alt="image"></p>
<p>여기서 Φl은 l번째 레이어의 일변량 함수 행렬을 나타냅니다. KAN의 전체 함수는 이러한 레이어의 합성으로, 각각이 변환을 더욱 세밀하게 다듬습니다.</p>
<div class="content-ad"></div>
<p>MLP 구조
전통적인 MLP에서 각 노드는 입력에 고정된 활성화 함수 (예: ReLU 또는 sigmoid)를 적용합니다. 이를 생각해보면 각각의 성질에 관계없이 모든 재료에 동일한 조리 기술을 적용하는 것과 같습니다.</p>
<p>MLPs는 이러한 고정 비선형 활성화 함수에 이어서 선형 변환을 사용합니다:</p>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_6.png" alt="MLP Structure"></p>
<p>여기서 W는 가중치 행렬을 나타내고, σ는 고정된 활성화 함수를 나타냅니다.</p>
<div class="content-ad"></div>
<h2>그리드 확장 기술</h2>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_7.png" alt="이미지"></p>
<p>그리드 확장은 Kolmogorov-Arnold Networks (KANs)의 정확도를 향상시키기 위해 사용되는 강력한 기술로, 단변량 함수가 정의된 스플라인 그리드를 세밀하게 다듬는 데 사용됩니다. 이 과정을 통해 네트워크는 완전 재교육이 필요하지 않고도 데이터의 점점 더 세부적인 패턴을 학습할 수 있습니다.</p>
<p>이 B-스플라인은 부드러운 곡선을 형성하기 위해 결합된 일련의 다항 함수입니다. KANs에서는 가장자리의 단변량 함수를 나타내는 데 사용됩니다. 스플라인은 그리드 포인트라고 불리는 일련의 간격을 통해 정의됩니다. 그리드 포인트가 많을수록 스플라인이 캡처할 수 있는 세부 정보가 더욱 섬세해집니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_8.png" alt="KANKolmogorov-ArnoldNetworks_8"></p>
<p>먼저, 네트워크는 거친 격자로 시작되어 그리드 포인트 사이의 간격이 적습니다. 이는 네트워크가 세부 사항에 깊이 빠지지 않고 데이터의 기본 구조를 학습할 수 있도록 합니다. 이는 세부 사항을 채우기 전에 대략적인 윤곽을 그리는 것과 유사합니다.</p>
<p>학습이 진행됨에 따라 그리드 포인트의 수가 점진적으로 증가합니다. 이 과정을 그리드 세분화라고 합니다. 더 많은 그리드 포인트를 추가함으로써 스플라인이 더 자세해지고 데이터 내의 미세한 패턴을 잡을 수 있습니다. 이는 처음에 대략적인 스케치에 점차적으로 더 많은 세부 사항을 추가하여 자세한 그림으로 완성하는 것과 유사합니다.</p>
<p>매 증가할 때마다 새로운 B-spline 기저 함수 B′_m(x)가 도입됩니다. 이러한 새로운 기저 함수에 대한 계수 c'_m은 새로운, 더 자세한 스플라인이 초기, 더 거친 스플라인과 밀접하게 일치하도록 조절됩니다.</p>
<div class="content-ad"></div>
<p>이 작업을 수행하기 위해서는 최소 제곱 최적화가 사용됩니다. 이 방법은 계수 c'_m을 조정하여 원본 스플라인과 개선된 스플라인 간의 차이를 최소화합니다.</p>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_9.png" alt="image"></p>
<p>본질적으로, 이 과정은 개선된 스플라인이 원시 스플라인에 의해 학습된 데이터 패턴을 정확하게 나타내도록 보장합니다.</p>
<h2>간소화 기법</h2>
<div class="content-ad"></div>
<p>KANs의 해석 가능성을 향상시키기 위해, 네트워크를 이해하고 시각화하기 쉽게 만들기 위해 여러 간소화 기술이 사용될 수 있습니다.</p>
<p>희박화 및 가지치기
이 기술은 활성화 함수의 L1 노름에 기반한 손실 함수에 패널티를 추가하는 것을 포함합니다. 함수 ϕ에 대한 L1 노름은 모든 입력 샘플을 대상으로 함수의 평균 크기로 정의됩니다:</p>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_10.png" alt="수학 공식"></p>
<p>여기서 N_p는 입력 샘플 수이며, ϕ(x_s)는 입력 샘플 x_s에 대한 함수 ϕ의 값입니다.</p>
<div class="content-ad"></div>
<p>스파스파이케이션은 방을 정리하는 것과 같습니다. 불필요한 항목을 제거하거나 중요하지 않은 기능을 줄임으로써 공간(또는 네트워크)을 더 정리하고 쉽게 이동할 수 있게 만듭니다.</p>
<p>L1 규제를 적용한 후 활성화 함수의 L1 노름이 평가됩니다. 특정 임계값 이하의 노름을 가진 뉴런과 엣지는 중요하지 않다고 간주되어 제거됩니다. 가지치기를 위한 임계값은 가지치기를 얼마나 적극적으로 진행할지를 결정하는 하이퍼파라미터입니다.</p>
<p>가지치기는 나무를 가지치는 것과 같습니다. 약한 또는 불필요한 가지를 제거함으로써, 나무가 더 강하고 중요한 부분에 리소스를 집중할 수 있게 되어 더 건강하고 관리하기 쉬운 구조를 만들어냅니다.</p>
<p>상징화
다른 방법은 배운 단변량 함수를 알려진 기호 형태로 대체하여 네트워크를 보다 해석하기 쉽게 만드는 것입니다.</p>
<div class="content-ad"></div>
<p>잠재적인 상징적 형식 (예: sin⁡, exp)을 식별하는 작업입니다. 이 단계는 학습된 함수를 분석하고 모양과 행동에 기초하여 상징적 후보를 제안하는 것을 포함합니다.</p>
<p>상징적 후보가 식별되면 상징적 함수가 학습된 함수를 근사화하도록 매개변수를 적합시키기 위해 그리드 서치 및 선형 회귀를 사용하십시오.</p>
<h1>4: KAN vs MLP in Python</h1>
<p>Kolmogorov-Arnold Networks (KANs)와 전통적인 Multi-Layer Perceptrons (MLPs)의 능력을 시범하기 위해, PyTorch를 활용하여 함수를 생성한 데이터세트에 KAN 모델과 MLP 모델을 모두 적합시켜보겠습니다. 이들의 성능이 어떻게 보이는지 확인해봅니다.</p>
<div class="content-ad"></div>
<p>우리가 사용할 함수는 KAN의 능력을 MLP(원본 논문 예제)과 비교하기 위해 논문 저자들이 사용한 것과 동일합니다. 그러나 코드는 다를 것입니다. 오늘 다룰 모든 코드는 이 노트북에서 찾을 수 있습니다:</p>
<p>필요한 라이브러리를 가져와 데이터셋을 생성해 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">import</span> torch.<span class="hljs-property">nn</span> <span class="hljs-keyword">as</span> nn
<span class="hljs-keyword">from</span> torchsummary <span class="hljs-keyword">import</span> summary
<span class="hljs-keyword">from</span> kan <span class="hljs-keyword">import</span> <span class="hljs-variable constant_">KAN</span>, create_dataset
<span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt
</code></pre>
<p>여기서 우리가 사용하는 것입니다:</p>
<div class="content-ad"></div>
<ul>
<li>numpy: 숫자 연산에 사용됩니다.</li>
<li>torch: PyTorch 용으로, 신경망 구축 및 훈련에 사용됩니다.</li>
<li>torch.nn: PyTorch 내에서의 신경망 모듈에 사용됩니다.</li>
<li>torchsummary: 모델 구조를 요약하는 데 사용됩니다.</li>
<li>kan: KAN 모델 및 데이터셋 생성 함수를 포함하는 사용자 지정 라이브러리입니다.</li>
<li>matplotlib.pyplot: 그래프 그리기와 시각화에 사용됩니다.</li>
</ul>
<pre><code class="hljs language-js"># 데이터셋 생성 함수 정의
f = lambda <span class="hljs-attr">x</span>: torch.<span class="hljs-title function_">exp</span>(torch.<span class="hljs-title function_">sin</span>(torch.<span class="hljs-property">pi</span> * x[:, [<span class="hljs-number">0</span>]]) + x[:, [<span class="hljs-number">1</span>]] ** <span class="hljs-number">2</span>)
</code></pre>
<p>이 함수에는 삼각함수(sin)와 지수함수(exp) 요소가 모두 포함되어 있습니다. 이 함수는 2차원 입력 x를 취하고 다음 공식을 사용하여 출력을 계산합니다:</p>
<img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_11.png">
<div class="content-ad"></div>
<p>이제 [-2, 2] 사이에서 균일하게 분포된 100개의 점의 텐서를 이 함수에 맞춰 보겠습니다.</p>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_12.png" alt="function"></p>
<pre><code class="hljs language-js"># 데이터셋 생성
dataset = <span class="hljs-title function_">create_dataset</span>(f, n_var=<span class="hljs-number">2</span>)
</code></pre>
<p>create_dataset은 함수 f를 기반으로 데이터셋을 생성합니다. 이 데이터셋에는 신경망의 훈련 및 테스트에 사용될 입력-출력 쌍이 포함됩니다.</p>
<div class="content-ad"></div>
<p>자, 이제 데이터셋을 사용하여 KAN 모델을 구축하고 훈련시킬 차례입니다.
우리는 먼저 더 넓은 격자 (5 포인트)로 시작하여 점진적으로 더 섬세한 세부 사항을 캡처하기 위해 그것을 미세 조정할 것입니다(최대 100 포인트까지).
이것은 데이터의 세부 사항을 잡아내어 모델의 정확도를 향상시킵니다.</p>
<pre><code class="hljs language-js">grids = np.<span class="hljs-title function_">array</span>([<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>])
train_losses_kan = []
test_losses_kan = []
steps = <span class="hljs-number">50</span>
k = <span class="hljs-number">3</span>

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(grids.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>]):
    <span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:
        model = <span class="hljs-title function_">KAN</span>(width=[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], grid=grids[i], k=k)
    <span class="hljs-attr">else</span>:
        model = <span class="hljs-title function_">KAN</span>(width=[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], grid=grids[i], k=k).<span class="hljs-title function_">initialize_from_another_model</span>(model, dataset[<span class="hljs-string">'train_input'</span>])
    results = model.<span class="hljs-title function_">train</span>(dataset, opt=<span class="hljs-string">"LBFGS"</span>, steps=steps, stop_grid_update_step=<span class="hljs-number">30</span>)
    train_losses_kan += results[<span class="hljs-string">'train_loss'</span>]
    test_losses_kan += results[<span class="hljs-string">'test_loss'</span>]

    <span class="hljs-title function_">print</span>(f<span class="hljs-string">"Train RMSE: {results['train_loss'][-1]:.8f} | Test RMSE: {results['test_loss'][-1]:.8f}"</span>)
</code></pre>
<p>이 예시에서 우리는 [5, 10, 20, 50, 100]의 값으로 grids라는 배열을 정의했습니다. 이러한 격자들을 순차적으로 모델 적합에 사용하며, 새 모델을 이전 모델을 사용하여 초기화합니다.</p>
<p>각 반복마다, k=3인 모델을 정의합니다. 여기서 k는 B-스플라인의 순서를 나타냅니다. 훈련 단계(또는 에포크) 수를 50으로 설정합니다. 모델의 아키텍처는 2개의 노드를 가진 입력 레이어, 1개의 노드를 가진 은닉 레이어 및 1개의 노드를 가진 출력 레이어로 구성됩니다. LFGBS 옵티마이저를 사용하여 훈련합니다.</p>
<div class="content-ad"></div>
<p>아래는 훈련 과정 중의 훈련 및 테스트 손실입니다:</p>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_13.png" alt="loss graph"></p>
<p>이제 전통적인 MLP를 정의하고 훈련하여 비교해 보겠습니다.</p>
<pre><code class="hljs language-python"><span class="hljs-comment"># MLP 정의</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MLP</span>(nn.Module):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>(MLP, self).__init__()
        self.layers = nn.Sequential(
            nn.Linear(dataset[<span class="hljs-string">'train_input'</span>].shape[<span class="hljs-number">1</span>], <span class="hljs-number">64</span>),
            nn.ReLU(),
            nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>),
            nn.ReLU(),
            nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">1</span>)
        )
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):
        <span class="hljs-keyword">return</span> self.layers(x)

<span class="hljs-comment"># 모델 인스턴스화</span>
model = MLP()
summary(model, input_size=(dataset[<span class="hljs-string">'train_input'</span>].shape[<span class="hljs-number">1</span>],))
</code></pre>
<div class="content-ad"></div>
<p>MLP는 입력 레이어, 64개의 뉴런을 가진 두 개의 히든 레이어 및 출력 레이어를 가지고 있습니다. 레이어 간에는 ReLU 활성화 함수가 사용됩니다.</p>
<pre><code class="hljs language-js">criterion = nn.<span class="hljs-title class_">MSELoss</span>()
optimizer = torch.<span class="hljs-property">optim</span>.<span class="hljs-title class_">Adam</span>(model.<span class="hljs-title function_">parameters</span>(), lr=<span class="hljs-number">1e-2</span>)
train_loss_mlp = []
test_loss_mlp = []

epochs = <span class="hljs-number">250</span>
<span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(epochs):
    optimizer.<span class="hljs-title function_">zero_grad</span>()
    output = <span class="hljs-title function_">model</span>(dataset[<span class="hljs-string">'train_input'</span>]).<span class="hljs-title function_">squeeze</span>()
    loss = <span class="hljs-title function_">criterion</span>(output, dataset[<span class="hljs-string">'train_label'</span>])
    loss.<span class="hljs-title function_">backward</span>()
    optimizer.<span class="hljs-title function_">step</span>()
    train_loss_mlp.<span class="hljs-title function_">append</span>(loss.<span class="hljs-title function_">item</span>()**<span class="hljs-number">0.5</span>)

    # 모델 테스트
    model.<span class="hljs-built_in">eval</span>()
    <span class="hljs-keyword">with</span> torch.<span class="hljs-title function_">no_grad</span>():
        output = <span class="hljs-title function_">model</span>(dataset[<span class="hljs-string">'test_input'</span>]).<span class="hljs-title function_">squeeze</span>()
        loss = <span class="hljs-title function_">criterion</span>(output, dataset[<span class="hljs-string">'test_label'</span>])
        test_loss_mlp.<span class="hljs-title function_">append</span>(loss.<span class="hljs-title function_">item</span>()**<span class="hljs-number">0.5</span>)

    <span class="hljs-title function_">print</span>(f<span class="hljs-string">'에폭 {epoch+1}/{epochs}, 훈련 손실: {train_loss_mlp[-1]:.2f}, 테스트 손실: {test_loss_mlp[-1]:.2f}'</span>, end=<span class="hljs-string">'\r'</span>)
</code></pre>
<p>평균 제곱 오차 (MSE) 손실과 Adam 옵티마이저를 사용하고 모델을 250 에폭 동안 훈련하여 훈련 및 테스트 손실을 기록합니다.</p>
<p>MLP에서 훈련 및 테스트 RMSE가 어떻게 나타나는지 보여드리겠습니다:</p>
<div class="content-ad"></div>
<p>아래는 비교를 위해 손실 그래프를 나란히 두어 보겠습니다:</p>
<p><img src="/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_15.png" alt=""></p>
<p>이 그래프는 KAN 모델이 MLP 모델보다 더 낮은 훈련 RMSE를 달성하여 더 나은 함수 맞추기 능력을 나타낸다는 것을 보여줍니다. 마찬가지로, KAN 모델은 시험 세트에서 MLP를 능가하여 뛰어난 일반화 능력을 보여줍니다.</p>
<div class="content-ad"></div>
<p>이 예시는 KAN이 유연하고 적응적인 구조 덕분에 복잡한 함수들을 전통적인 MLP보다 더 정확하게 맞출 수 있다는 것을 보여줍니다. 격자를 세밀하게 조정하고 가장자리에 학습 가능한 일변량 함수를 사용함으로써, KAN은 MLP가 놓치는 데이터의 복잡한 패턴을 포착하여 함수 맞추기 작업에서 성능을 향상시킵니다.</p>
<p>그렇다면 우리는 영구적으로 KAN 모델로 전환해야 한다는 것을 의미합니까? 꼭 그렇지는 않습니다.</p>
<p>이 예시에서 KAN은 훌륭한 결과를 보여주었지만, 다른 실제 데이터 시나리오에서 KAN을 시험한 결과, MLP가 더 좋은 성능을 내는 경우가 많았습니다. KAN 모델을 사용할 때 주목해야 할 점은 하이퍼파라미터 최적화에 대한 민감성입니다. 또한, KAN은 주로 스플라인 함수를 사용하여 테스트되었는데, 이는 저희 예시와 같이 부드럽게 변하는 데이터에는 잘 맞지만 다른 상황에서는 그렇지 않을 수 있습니다.</p>
<p>요약하자면, KAN은 분명히 매력적이고 많은 잠재력을 가지고 있지만, 실제로 효과적으로 작동하기 위해서는 다른 데이터셋 및 알고리즘 내부 동작에 대해 더 많은 연구가 필요합니다.</p>
<div class="content-ad"></div>
<h1>5: KAN의 장점</h1>
<h2>정확성</h2>
<p>Kolmogorov-Arnold Networks (KANs)의 두드러진 장점 중 하나는 전통적인 Multi-Layer Perceptrons (MLPs)에 비해 적은 매개변수로 더 높은 정확도를 달성할 수 있는 능력입니다. 이는 주로 에지에 있는 학습 가능한 활성화 함수 때문에 가능한데, 이는 KAN이 데이터 내의 복잡한 패턴과 관계를 더 잘 포착할 수 있게 합니다.</p>
<p>각 노드에 고정된 활성화 함수를 사용하는 MLP와 달리, KAN은 에지에서 단변량 함수를 사용하여 네트워크를 더 융통성 있게 만들고 학습 프로세스를 데이터에 더 잘 맞출 수 있도록 합니다.</p>
<div class="content-ad"></div>
<p>KANs은 층간 기능을 동적으로 조절할 수 있기 때문에 더 적은 매개변수로 비교적 높은 정확도를 얻을 수 있습니다. 이 효율성은 데이터나 계산 리소스가 제한된 작업에 특히 유용합니다.</p>
<h2>해석가능성</h2>
<p>KANs은 전통적인 MLPs에 비해 해석력을 크게 향상시킵니다. 이 향상된 해석력은 의사 결정 과정을 이해하는 것이 결과만큼 중요한 응용 프로그램에 중요합니다.</p>
<p>KANs은 희소화(sparsification) 및 가지치기(pruning)와 같은 기술을 통해 단순화될 수 있습니다. 이러한 기술은 해석력을 향상시키는 뿐만 아니라 가장 관련성이 높은 구성 요소에 집중함으로써 네트워크의 성능을 향상시킵니다.</p>
<div class="content-ad"></div>
<p>일부 함수의 경우 활성화 함수의 기호적 형태를 식별할 수 있으며, 이를 통해 네트워크 내에서 발생하는 수학적 변환을 이해하기 쉬워집니다.</p>
<h2>확장성</h2>
<p>KAN은 MLP와 비교했을 때 더 빠른 신경 확장 법칙을 나타내며, 매개변수의 수가 증가함에 따라 더 신속하게 개선됩니다.</p>
<p>KAN은 복잡한 함수를 더 단순한 단변량 함수로 분해할 수 있는 능력으로 인해 보다 유리한 확장 법칙을 갖게 되어, MLP보다 모델 복잡도가 증가함에 따라 더 효율적으로 낮은 오류율을 달성할 수 있습니다.</p>
<div class="content-ad"></div>
<p>KANs는 훈련 중에 더 미세한 그리드까지 더욱 세분화된 그리드로 시작하여 계산 효율성과 정확도를 균형있게 유지하도록 합니다. 이 접근 방식은 MLPs보다 KANs가 보다 우아하게 확장될 수 있게 하며, 모델 크기를 증가시킬 때 완전히 재훈련이 필요한 MLPs보다 우수한 성능을 제공합니다.</p>
<h1>결론</h1>
<p>Kolmogorov-Arnold Networks (KANs)는 전통적인 Multi-Layer Perceptrons (MLPs)에 비해 혁신적인 대안을 제시하여 이전 모델의 한계를 해소하는 핵심 혁신을 제공합니다. KANs는 노드에서 고정된 함수 대신 가장자리에 가중치가 있는 활성화 함수를 활용함으로써 새로운 수준의 유연성과 적응성을 도입합니다. 이 구조적인 변화로 인해 다음과 같은 장점을 제공합니다:</p>
<ul>
<li>향상된 정확도: 더 적은 매개변수로 더 높은 정확도를 달성하는 KANs는 다양한 작업에 더 효율적이고 효과적입니다.</li>
<li>향상된 해석력: KANs를 시각화하고 단순화할 수 있는 능력은 건강 관리, 금융 및 자율 시스템과 같은 중요한 응용 분야에서 의사 결정 과정을 이해하는 데 도움이 됩니다.</li>
<li>더 나은 확장성: KANs는 더 빠른 신경 확장 법칙을 나타내며 MLPs보다 증가하는 복잡성을 우아하게 처리할 수 있습니다.</li>
</ul>
<div class="content-ad"></div>
<p>콜모고로프-아놀드 네트워크 소개는 신경망 분야에서 흥미로운 발전을 의미합니다. 이는 AI 및 머신 러닝에 대한 새로운 가능성을 열어줍니다.</p>
<h1>참고 자료</h1>
<ul>
<li>Ziming Liu, 등. “KAN: 콜모고로프-아놀드 네트워크”. <a href="https://arxiv.org/abs/2404.19756" rel="nofollow" target="_blank">https://arxiv.org/abs/2404.19756</a></li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"KAN  콜모고로프-아놀드 네트워크 뒤에 숨은 수학","description":"","date":"2024-06-19 03:45","slug":"2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks","content":"\n\n## 클래식 다층 퍼셉트론 대안이 나왔어요. 왜 더 정확하고 해석 가능한 건가요? 수학과 코드 심층 탐구.\n\n![다음 이미지 참고](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_0.png)\n\nAI 세계에서 신경망은 끊임없는 혁신과 발전을 이끌어옵니다. 많은 획기적인 발전의 핵심에는 복잡한 함수를 근사하는 능력으로 유명한 다층 퍼셉트론(MLP)이 있습니다. 그러나 AI가 얼마나 많이 이루어 낼 수 있는지 경계를 늘릴 때, 우리는 클래식 MLP보다 더 나은 것을 할 수 있을까요?\n\n여기 Kolmogorov-Arnold Networks(KANs)가 나왔습니다. Kolmogorov-Arnold 표현 정리에서 영감을 받은 신경망에 대한 새로운 접근법입니다. 기존 MLP가 각 뉴런에서 고정 활성화 함수를 사용하는 반면, KANs는 네트워크의 가중치(엣지)에 학습 가능한 활성화 함수를 사용합니다. 이 간단한 변경은 정확성, 해석 가능성, 효율성에서 새로운 가능성을 열어줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사는 KAN이 신경망 설계에서 혁명적인 발전을 이루는 이유를 탐구합니다. 우리는 그들의 수학적 기초에 대해 자세히 살펴보고, MLP(Multi-Layer Perceptrons)와의 주요 차이점을 강조하며, KAN이 전통적인 방법을 능가할 수 있는 방법을 보여줄 것입니다.\n\n# 1: MLP의 한계\n\n![이미지](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_1.png)\n\n다층 퍼셉트론(MLP)은 현대 신경망의 핵심 구성 요소입니다. 각각의 뉴런은 데이터로부터 학습하여 복잡한 비선형 함수를 근사하는 것을 목표로 설계된 상호 연결된 노드 레이어로 구성되어 있습니다. 각 뉴런은 입력의 가중 합에 고정된 활성화 함수를 사용하여 입력 데이터를 원하는 출력으로 변환함으로써 여러 계층의 추상화를 통해 동작합니다. MLP는 컴퓨터 비전에서부터 음성 인식까지 다양한 분야에서 앞도적인 성과를 이루어 왔습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나 MLP에는 몇 가지 중요한 제한 사항이 있습니다:\n\n- 노드에 고정된 활성화 함수: MLP의 각 노드에는 ReLU나 Sigmoid와 같은 미리 정의된 활성화 함수가 있습니다. 이러한 고정 함수는 많은 경우에 효과적이지만 네트워크의 유연성과 적응성을 제한합니다. 이는 MLP가 특정 유형의 함수를 최적화하거나 특정 데이터 특성에 적응하는 데 어려움을 겪을 수 있게 만들 수 있습니다.\n- 해석 가능성 문제: MLP는 종종 \"블랙 박스\"로 비판받습니다. 복잡해지면서, 그들의 의사 결정 과정을 이해하기가 더 어려워집니다. 고정된 활성화 함수와 복잡한 가중치 행렬은 네트워크의 내부 작업을 가리고, 깊이 분석 없이 모델의 예측을 해석하고 신뢰하기 어렵게 만듭니다.\n\n이러한 단점은 더 큰 유연성과 해석 가능성을 제공하는 대안이 필요함을 강조하며, Kolmogorov-Arnold Networks (KANs)와 같은 혁신을 위한 길을 열어줍니다.\n\n# 2: Kolmogorov-Arnold Networks (KANs)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_2.png)\n\n콜모고로프-아놀드 표현 이론은 수학자 안드레이 콜모고로프와 블라디미르 아놀드가 정립한 이론으로, 이론은 다변수 연속 함수를 단일 변수의 연속 함수와 덧셈 작업의 유한 구성으로 표현할 수 있다고 주장합니다. 이 이론은 복잡한 레시피를 각각의 간단한 단계로 분해하는 것으로 생각할 수 있습니다. 전체 레시피 전체적으로 다루는 대신에 각 단계를 개별적으로 처리하여 전반적인 프로세스를 더 효율적으로 만듭니다. 이 이론은 복잡한 고차원 함수를 간단한 단일 변수 함수로 분해할 수 있다는 것을 시사합니다.\n\nKAN(Kolmogorov-Arnold Networks)은 콜모고로프-아놀드 이론의 힘을 활용하여 신경망의 구조를 근본적으로 변경합니다. 전통적인 MLP에서는 각 노드에 고정된 활성화 함수가 적용되지만, KAN은 네트워크의 가중치에 학습 가능한 활성화 함수를 배치합니다. 이러한 주요 차이점은 고정된 활성화 함수 세트가 아닌, KAN이 학습 중에 적용할 최상의 함수를 적응적으로 학습한다는 것을 의미합니다. KAN의 각 가중치는 데이터를 기반으로 한 다이내믹하고 세밀한 조정이 가능한 스플라인으로 매개변수화된 단일 변수 함수를 나타냅니다.\n\n이 변화는 네트워크의 유연성을 향상시키고 데이터의 복잡한 패턴을 포착할 수 있는 능력을 강화하여 전통적인 MLP에 대한 해석 가능하고 강력한 대안을 제공합니다. KAN은 가장 최적의 성능을 위해 엣지에 있는 학습 가능한 활성화 함수에 초점을 맞춘 결과, 다양한 AI 작업에서 성능이 향상됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3: 수학적 기초\n\n콜모고로프-아놀드 네트워크(KANs)의 핵심은 이러한 네트워크가 입력 데이터를 처리하고 변환하는 방식을 정의하는 일련의 방정식입니다. KANs의 기초는 콜모고로프-아놀드 표현 정리에 있으며, 이는 네트워크의 구조와 학습 과정에 영감을 주는 개념입니다.\n\n입력 벡터 x=[x1,x2,…,xn]가 있다고 상상해보세요. 이 벡터는 처리하려는 데이터 포인트를 나타냅니다. 이 입력 벡터를 레시피의 재료 목록으로 생각해보세요.\n\n이 정리는 어떤 복잡한 레시피(고차원 함수)라도 보다 간단한 단계(일변량 함수)로 분해할 수 있다는 것을 명시합니다. KANs에서는 각 재료(입력 값)가 네트워크의 가장자리에 배치된 일련의 간단한 단계(일변량 함수)를 통해 변환됩니다. 이를 수학적으로 표현하면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![image](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_3.png)\n\n여기서 ϕ_q,p는 학습 중에 학습되는 단변량 함수입니다. ϕ_q,p를 각 재료에 대한 개별 조리 기술로 생각하고, Φ_q를 이러한 준비된 재료를 결합하는 최종 조립 단계로 생각해보세요.\n\nKAN의 각 층은 이러한 요리 기술을 사용하여 재료를 더 변형합니다. 층 l에 대해, 변형은 다음과 같이 주어집니다:\n\n![image](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 x(l)은 l번째 레이어에서 변환된 재료를 나타내고, ϕ_l,i,j는 l레이어와 l+1 레이어 사이의 학습 가능한 일변량 함수입니다. 이를 각 단계마다 재료에 다양한 조리 기술을 적용하여 중간 요리를 얻는 것으로 생각해보세요.\n\nKAN의 출력은 이러한 레이어 변환의 합성입니다. 중간 요리를 결합하여 최종 식사를 만드는 것처럼, KAN은 변환을 결합하여 최종 출력물을 생성합니다:\n\n![image](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_5.png)\n\n여기서 Φl은 l번째 레이어의 일변량 함수 행렬을 나타냅니다. KAN의 전체 함수는 이러한 레이어의 합성으로, 각각이 변환을 더욱 세밀하게 다듬습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMLP 구조\n전통적인 MLP에서 각 노드는 입력에 고정된 활성화 함수 (예: ReLU 또는 sigmoid)를 적용합니다. 이를 생각해보면 각각의 성질에 관계없이 모든 재료에 동일한 조리 기술을 적용하는 것과 같습니다.\n\nMLPs는 이러한 고정 비선형 활성화 함수에 이어서 선형 변환을 사용합니다:\n\n![MLP Structure](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_6.png)\n\n여기서 W는 가중치 행렬을 나타내고, σ는 고정된 활성화 함수를 나타냅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 그리드 확장 기술\n\n![이미지](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_7.png)\n\n그리드 확장은 Kolmogorov-Arnold Networks (KANs)의 정확도를 향상시키기 위해 사용되는 강력한 기술로, 단변량 함수가 정의된 스플라인 그리드를 세밀하게 다듬는 데 사용됩니다. 이 과정을 통해 네트워크는 완전 재교육이 필요하지 않고도 데이터의 점점 더 세부적인 패턴을 학습할 수 있습니다.\n\n이 B-스플라인은 부드러운 곡선을 형성하기 위해 결합된 일련의 다항 함수입니다. KANs에서는 가장자리의 단변량 함수를 나타내는 데 사용됩니다. 스플라인은 그리드 포인트라고 불리는 일련의 간격을 통해 정의됩니다. 그리드 포인트가 많을수록 스플라인이 캡처할 수 있는 세부 정보가 더욱 섬세해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![KANKolmogorov-ArnoldNetworks_8](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_8.png)\n\n먼저, 네트워크는 거친 격자로 시작되어 그리드 포인트 사이의 간격이 적습니다. 이는 네트워크가 세부 사항에 깊이 빠지지 않고 데이터의 기본 구조를 학습할 수 있도록 합니다. 이는 세부 사항을 채우기 전에 대략적인 윤곽을 그리는 것과 유사합니다.\n\n학습이 진행됨에 따라 그리드 포인트의 수가 점진적으로 증가합니다. 이 과정을 그리드 세분화라고 합니다. 더 많은 그리드 포인트를 추가함으로써 스플라인이 더 자세해지고 데이터 내의 미세한 패턴을 잡을 수 있습니다. 이는 처음에 대략적인 스케치에 점차적으로 더 많은 세부 사항을 추가하여 자세한 그림으로 완성하는 것과 유사합니다.\n\n매 증가할 때마다 새로운 B-spline 기저 함수 B′_m(x)가 도입됩니다. 이러한 새로운 기저 함수에 대한 계수 c'_m은 새로운, 더 자세한 스플라인이 초기, 더 거친 스플라인과 밀접하게 일치하도록 조절됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 작업을 수행하기 위해서는 최소 제곱 최적화가 사용됩니다. 이 방법은 계수 c'_m을 조정하여 원본 스플라인과 개선된 스플라인 간의 차이를 최소화합니다.\n\n![image](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_9.png)\n\n본질적으로, 이 과정은 개선된 스플라인이 원시 스플라인에 의해 학습된 데이터 패턴을 정확하게 나타내도록 보장합니다.\n\n## 간소화 기법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKANs의 해석 가능성을 향상시키기 위해, 네트워크를 이해하고 시각화하기 쉽게 만들기 위해 여러 간소화 기술이 사용될 수 있습니다.\n\n희박화 및 가지치기\n이 기술은 활성화 함수의 L1 노름에 기반한 손실 함수에 패널티를 추가하는 것을 포함합니다. 함수 ϕ에 대한 L1 노름은 모든 입력 샘플을 대상으로 함수의 평균 크기로 정의됩니다:\n\n![수학 공식](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_10.png)\n\n여기서 N_p는 입력 샘플 수이며, ϕ(x_s)는 입력 샘플 x_s에 대한 함수 ϕ의 값입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스파스파이케이션은 방을 정리하는 것과 같습니다. 불필요한 항목을 제거하거나 중요하지 않은 기능을 줄임으로써 공간(또는 네트워크)을 더 정리하고 쉽게 이동할 수 있게 만듭니다.\n\nL1 규제를 적용한 후 활성화 함수의 L1 노름이 평가됩니다. 특정 임계값 이하의 노름을 가진 뉴런과 엣지는 중요하지 않다고 간주되어 제거됩니다. 가지치기를 위한 임계값은 가지치기를 얼마나 적극적으로 진행할지를 결정하는 하이퍼파라미터입니다.\n\n가지치기는 나무를 가지치는 것과 같습니다. 약한 또는 불필요한 가지를 제거함으로써, 나무가 더 강하고 중요한 부분에 리소스를 집중할 수 있게 되어 더 건강하고 관리하기 쉬운 구조를 만들어냅니다.\n\n상징화\n다른 방법은 배운 단변량 함수를 알려진 기호 형태로 대체하여 네트워크를 보다 해석하기 쉽게 만드는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n잠재적인 상징적 형식 (예: sin⁡, exp)을 식별하는 작업입니다. 이 단계는 학습된 함수를 분석하고 모양과 행동에 기초하여 상징적 후보를 제안하는 것을 포함합니다.\n\n상징적 후보가 식별되면 상징적 함수가 학습된 함수를 근사화하도록 매개변수를 적합시키기 위해 그리드 서치 및 선형 회귀를 사용하십시오.\n\n# 4: KAN vs MLP in Python\n\nKolmogorov-Arnold Networks (KANs)와 전통적인 Multi-Layer Perceptrons (MLPs)의 능력을 시범하기 위해, PyTorch를 활용하여 함수를 생성한 데이터세트에 KAN 모델과 MLP 모델을 모두 적합시켜보겠습니다. 이들의 성능이 어떻게 보이는지 확인해봅니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리가 사용할 함수는 KAN의 능력을 MLP(원본 논문 예제)과 비교하기 위해 논문 저자들이 사용한 것과 동일합니다. 그러나 코드는 다를 것입니다. 오늘 다룰 모든 코드는 이 노트북에서 찾을 수 있습니다:\n\n필요한 라이브러리를 가져와 데이터셋을 생성해 봅시다.\n\n```js\nimport numpy as np\nimport torch\nimport torch.nn as nn\nfrom torchsummary import summary\nfrom kan import KAN, create_dataset\nimport matplotlib.pyplot as plt\n```\n\n여기서 우리가 사용하는 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- numpy: 숫자 연산에 사용됩니다.\n- torch: PyTorch 용으로, 신경망 구축 및 훈련에 사용됩니다.\n- torch.nn: PyTorch 내에서의 신경망 모듈에 사용됩니다.\n- torchsummary: 모델 구조를 요약하는 데 사용됩니다.\n- kan: KAN 모델 및 데이터셋 생성 함수를 포함하는 사용자 지정 라이브러리입니다.\n- matplotlib.pyplot: 그래프 그리기와 시각화에 사용됩니다.\n\n```js\n# 데이터셋 생성 함수 정의\nf = lambda x: torch.exp(torch.sin(torch.pi * x[:, [0]]) + x[:, [1]] ** 2)\n```\n\n이 함수에는 삼각함수(sin)와 지수함수(exp) 요소가 모두 포함되어 있습니다. 이 함수는 2차원 입력 x를 취하고 다음 공식을 사용하여 출력을 계산합니다:\n\n\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_11.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 [-2, 2] 사이에서 균일하게 분포된 100개의 점의 텐서를 이 함수에 맞춰 보겠습니다.\n\n![function](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_12.png)\n\n```js\n# 데이터셋 생성\ndataset = create_dataset(f, n_var=2)\n```\n\ncreate_dataset은 함수 f를 기반으로 데이터셋을 생성합니다. 이 데이터셋에는 신경망의 훈련 및 테스트에 사용될 입력-출력 쌍이 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자, 이제 데이터셋을 사용하여 KAN 모델을 구축하고 훈련시킬 차례입니다. \n우리는 먼저 더 넓은 격자 (5 포인트)로 시작하여 점진적으로 더 섬세한 세부 사항을 캡처하기 위해 그것을 미세 조정할 것입니다(최대 100 포인트까지).\n이것은 데이터의 세부 사항을 잡아내어 모델의 정확도를 향상시킵니다.\n\n```js\ngrids = np.array([5, 10, 20, 50, 100])\ntrain_losses_kan = []\ntest_losses_kan = []\nsteps = 50\nk = 3\n\nfor i in range(grids.shape[0]):\n    if i == 0:\n        model = KAN(width=[2, 1, 1], grid=grids[i], k=k)\n    else:\n        model = KAN(width=[2, 1, 1], grid=grids[i], k=k).initialize_from_another_model(model, dataset['train_input'])\n    results = model.train(dataset, opt=\"LBFGS\", steps=steps, stop_grid_update_step=30)\n    train_losses_kan += results['train_loss']\n    test_losses_kan += results['test_loss']\n\n    print(f\"Train RMSE: {results['train_loss'][-1]:.8f} | Test RMSE: {results['test_loss'][-1]:.8f}\")\n```\n\n이 예시에서 우리는 [5, 10, 20, 50, 100]의 값으로 grids라는 배열을 정의했습니다. 이러한 격자들을 순차적으로 모델 적합에 사용하며, 새 모델을 이전 모델을 사용하여 초기화합니다.\n\n각 반복마다, k=3인 모델을 정의합니다. 여기서 k는 B-스플라인의 순서를 나타냅니다. 훈련 단계(또는 에포크) 수를 50으로 설정합니다. 모델의 아키텍처는 2개의 노드를 가진 입력 레이어, 1개의 노드를 가진 은닉 레이어 및 1개의 노드를 가진 출력 레이어로 구성됩니다. LFGBS 옵티마이저를 사용하여 훈련합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 훈련 과정 중의 훈련 및 테스트 손실입니다:\n\n![loss graph](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_13.png)\n\n이제 전통적인 MLP를 정의하고 훈련하여 비교해 보겠습니다.\n\n```python\n# MLP 정의\nclass MLP(nn.Module):\n    def __init__(self):\n        super(MLP, self).__init__()\n        self.layers = nn.Sequential(\n            nn.Linear(dataset['train_input'].shape[1], 64),\n            nn.ReLU(),\n            nn.Linear(64, 64),\n            nn.ReLU(),\n            nn.Linear(64, 1)\n        )\n    def forward(self, x):\n        return self.layers(x)\n\n# 모델 인스턴스화\nmodel = MLP()\nsummary(model, input_size=(dataset['train_input'].shape[1],))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMLP는 입력 레이어, 64개의 뉴런을 가진 두 개의 히든 레이어 및 출력 레이어를 가지고 있습니다. 레이어 간에는 ReLU 활성화 함수가 사용됩니다.\n\n```js\ncriterion = nn.MSELoss()\noptimizer = torch.optim.Adam(model.parameters(), lr=1e-2)\ntrain_loss_mlp = []\ntest_loss_mlp = []\n\nepochs = 250\nfor epoch in range(epochs):\n    optimizer.zero_grad()\n    output = model(dataset['train_input']).squeeze()\n    loss = criterion(output, dataset['train_label'])\n    loss.backward()\n    optimizer.step()\n    train_loss_mlp.append(loss.item()**0.5)\n\n    # 모델 테스트\n    model.eval()\n    with torch.no_grad():\n        output = model(dataset['test_input']).squeeze()\n        loss = criterion(output, dataset['test_label'])\n        test_loss_mlp.append(loss.item()**0.5)\n\n    print(f'에폭 {epoch+1}/{epochs}, 훈련 손실: {train_loss_mlp[-1]:.2f}, 테스트 손실: {test_loss_mlp[-1]:.2f}', end='\\r')\r\n```\n\n평균 제곱 오차 (MSE) 손실과 Adam 옵티마이저를 사용하고 모델을 250 에폭 동안 훈련하여 훈련 및 테스트 손실을 기록합니다.\n\nMLP에서 훈련 및 테스트 RMSE가 어떻게 나타나는지 보여드리겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 비교를 위해 손실 그래프를 나란히 두어 보겠습니다:\n\n![](/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_15.png)\n\n이 그래프는 KAN 모델이 MLP 모델보다 더 낮은 훈련 RMSE를 달성하여 더 나은 함수 맞추기 능력을 나타낸다는 것을 보여줍니다. 마찬가지로, KAN 모델은 시험 세트에서 MLP를 능가하여 뛰어난 일반화 능력을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 예시는 KAN이 유연하고 적응적인 구조 덕분에 복잡한 함수들을 전통적인 MLP보다 더 정확하게 맞출 수 있다는 것을 보여줍니다. 격자를 세밀하게 조정하고 가장자리에 학습 가능한 일변량 함수를 사용함으로써, KAN은 MLP가 놓치는 데이터의 복잡한 패턴을 포착하여 함수 맞추기 작업에서 성능을 향상시킵니다.\n\n그렇다면 우리는 영구적으로 KAN 모델로 전환해야 한다는 것을 의미합니까? 꼭 그렇지는 않습니다.\n\n이 예시에서 KAN은 훌륭한 결과를 보여주었지만, 다른 실제 데이터 시나리오에서 KAN을 시험한 결과, MLP가 더 좋은 성능을 내는 경우가 많았습니다. KAN 모델을 사용할 때 주목해야 할 점은 하이퍼파라미터 최적화에 대한 민감성입니다. 또한, KAN은 주로 스플라인 함수를 사용하여 테스트되었는데, 이는 저희 예시와 같이 부드럽게 변하는 데이터에는 잘 맞지만 다른 상황에서는 그렇지 않을 수 있습니다.\n\n요약하자면, KAN은 분명히 매력적이고 많은 잠재력을 가지고 있지만, 실제로 효과적으로 작동하기 위해서는 다른 데이터셋 및 알고리즘 내부 동작에 대해 더 많은 연구가 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 5: KAN의 장점\n\n## 정확성\n\nKolmogorov-Arnold Networks (KANs)의 두드러진 장점 중 하나는 전통적인 Multi-Layer Perceptrons (MLPs)에 비해 적은 매개변수로 더 높은 정확도를 달성할 수 있는 능력입니다. 이는 주로 에지에 있는 학습 가능한 활성화 함수 때문에 가능한데, 이는 KAN이 데이터 내의 복잡한 패턴과 관계를 더 잘 포착할 수 있게 합니다.\n\n각 노드에 고정된 활성화 함수를 사용하는 MLP와 달리, KAN은 에지에서 단변량 함수를 사용하여 네트워크를 더 융통성 있게 만들고 학습 프로세스를 데이터에 더 잘 맞출 수 있도록 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKANs은 층간 기능을 동적으로 조절할 수 있기 때문에 더 적은 매개변수로 비교적 높은 정확도를 얻을 수 있습니다. 이 효율성은 데이터나 계산 리소스가 제한된 작업에 특히 유용합니다.\n\n## 해석가능성\n\nKANs은 전통적인 MLPs에 비해 해석력을 크게 향상시킵니다. 이 향상된 해석력은 의사 결정 과정을 이해하는 것이 결과만큼 중요한 응용 프로그램에 중요합니다.\n\nKANs은 희소화(sparsification) 및 가지치기(pruning)와 같은 기술을 통해 단순화될 수 있습니다. 이러한 기술은 해석력을 향상시키는 뿐만 아니라 가장 관련성이 높은 구성 요소에 집중함으로써 네트워크의 성능을 향상시킵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 함수의 경우 활성화 함수의 기호적 형태를 식별할 수 있으며, 이를 통해 네트워크 내에서 발생하는 수학적 변환을 이해하기 쉬워집니다.\n\n## 확장성\n\nKAN은 MLP와 비교했을 때 더 빠른 신경 확장 법칙을 나타내며, 매개변수의 수가 증가함에 따라 더 신속하게 개선됩니다.\n\nKAN은 복잡한 함수를 더 단순한 단변량 함수로 분해할 수 있는 능력으로 인해 보다 유리한 확장 법칙을 갖게 되어, MLP보다 모델 복잡도가 증가함에 따라 더 효율적으로 낮은 오류율을 달성할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nKANs는 훈련 중에 더 미세한 그리드까지 더욱 세분화된 그리드로 시작하여 계산 효율성과 정확도를 균형있게 유지하도록 합니다. 이 접근 방식은 MLPs보다 KANs가 보다 우아하게 확장될 수 있게 하며, 모델 크기를 증가시킬 때 완전히 재훈련이 필요한 MLPs보다 우수한 성능을 제공합니다.\n\n# 결론\n\nKolmogorov-Arnold Networks (KANs)는 전통적인 Multi-Layer Perceptrons (MLPs)에 비해 혁신적인 대안을 제시하여 이전 모델의 한계를 해소하는 핵심 혁신을 제공합니다. KANs는 노드에서 고정된 함수 대신 가장자리에 가중치가 있는 활성화 함수를 활용함으로써 새로운 수준의 유연성과 적응성을 도입합니다. 이 구조적인 변화로 인해 다음과 같은 장점을 제공합니다:\n\n- 향상된 정확도: 더 적은 매개변수로 더 높은 정확도를 달성하는 KANs는 다양한 작업에 더 효율적이고 효과적입니다.\n- 향상된 해석력: KANs를 시각화하고 단순화할 수 있는 능력은 건강 관리, 금융 및 자율 시스템과 같은 중요한 응용 분야에서 의사 결정 과정을 이해하는 데 도움이 됩니다.\n- 더 나은 확장성: KANs는 더 빠른 신경 확장 법칙을 나타내며 MLPs보다 증가하는 복잡성을 우아하게 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n콜모고로프-아놀드 네트워크 소개는 신경망 분야에서 흥미로운 발전을 의미합니다. 이는 AI 및 머신 러닝에 대한 새로운 가능성을 열어줍니다.\n\n# 참고 자료\n\n- Ziming Liu, 등. “KAN: 콜모고로프-아놀드 네트워크”. https://arxiv.org/abs/2404.19756","ogImage":{"url":"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_0.png"},"coverImage":"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_0.png","tag":["Tech"],"readingTime":14},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e클래식 다층 퍼셉트론 대안이 나왔어요. 왜 더 정확하고 해석 가능한 건가요? 수학과 코드 심층 탐구.\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_0.png\" alt=\"다음 이미지 참고\"\u003e\u003c/p\u003e\n\u003cp\u003eAI 세계에서 신경망은 끊임없는 혁신과 발전을 이끌어옵니다. 많은 획기적인 발전의 핵심에는 복잡한 함수를 근사하는 능력으로 유명한 다층 퍼셉트론(MLP)이 있습니다. 그러나 AI가 얼마나 많이 이루어 낼 수 있는지 경계를 늘릴 때, 우리는 클래식 MLP보다 더 나은 것을 할 수 있을까요?\u003c/p\u003e\n\u003cp\u003e여기 Kolmogorov-Arnold Networks(KANs)가 나왔습니다. Kolmogorov-Arnold 표현 정리에서 영감을 받은 신경망에 대한 새로운 접근법입니다. 기존 MLP가 각 뉴런에서 고정 활성화 함수를 사용하는 반면, KANs는 네트워크의 가중치(엣지)에 학습 가능한 활성화 함수를 사용합니다. 이 간단한 변경은 정확성, 해석 가능성, 효율성에서 새로운 가능성을 열어줍니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 기사는 KAN이 신경망 설계에서 혁명적인 발전을 이루는 이유를 탐구합니다. 우리는 그들의 수학적 기초에 대해 자세히 살펴보고, MLP(Multi-Layer Perceptrons)와의 주요 차이점을 강조하며, KAN이 전통적인 방법을 능가할 수 있는 방법을 보여줄 것입니다.\u003c/p\u003e\n\u003ch1\u003e1: MLP의 한계\u003c/h1\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e다층 퍼셉트론(MLP)은 현대 신경망의 핵심 구성 요소입니다. 각각의 뉴런은 데이터로부터 학습하여 복잡한 비선형 함수를 근사하는 것을 목표로 설계된 상호 연결된 노드 레이어로 구성되어 있습니다. 각 뉴런은 입력의 가중 합에 고정된 활성화 함수를 사용하여 입력 데이터를 원하는 출력으로 변환함으로써 여러 계층의 추상화를 통해 동작합니다. MLP는 컴퓨터 비전에서부터 음성 인식까지 다양한 분야에서 앞도적인 성과를 이루어 왔습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그러나 MLP에는 몇 가지 중요한 제한 사항이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e노드에 고정된 활성화 함수: MLP의 각 노드에는 ReLU나 Sigmoid와 같은 미리 정의된 활성화 함수가 있습니다. 이러한 고정 함수는 많은 경우에 효과적이지만 네트워크의 유연성과 적응성을 제한합니다. 이는 MLP가 특정 유형의 함수를 최적화하거나 특정 데이터 특성에 적응하는 데 어려움을 겪을 수 있게 만들 수 있습니다.\u003c/li\u003e\n\u003cli\u003e해석 가능성 문제: MLP는 종종 \"블랙 박스\"로 비판받습니다. 복잡해지면서, 그들의 의사 결정 과정을 이해하기가 더 어려워집니다. 고정된 활성화 함수와 복잡한 가중치 행렬은 네트워크의 내부 작업을 가리고, 깊이 분석 없이 모델의 예측을 해석하고 신뢰하기 어렵게 만듭니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 단점은 더 큰 유연성과 해석 가능성을 제공하는 대안이 필요함을 강조하며, Kolmogorov-Arnold Networks (KANs)와 같은 혁신을 위한 길을 열어줍니다.\u003c/p\u003e\n\u003ch1\u003e2: Kolmogorov-Arnold Networks (KANs)\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e콜모고로프-아놀드 표현 이론은 수학자 안드레이 콜모고로프와 블라디미르 아놀드가 정립한 이론으로, 이론은 다변수 연속 함수를 단일 변수의 연속 함수와 덧셈 작업의 유한 구성으로 표현할 수 있다고 주장합니다. 이 이론은 복잡한 레시피를 각각의 간단한 단계로 분해하는 것으로 생각할 수 있습니다. 전체 레시피 전체적으로 다루는 대신에 각 단계를 개별적으로 처리하여 전반적인 프로세스를 더 효율적으로 만듭니다. 이 이론은 복잡한 고차원 함수를 간단한 단일 변수 함수로 분해할 수 있다는 것을 시사합니다.\u003c/p\u003e\n\u003cp\u003eKAN(Kolmogorov-Arnold Networks)은 콜모고로프-아놀드 이론의 힘을 활용하여 신경망의 구조를 근본적으로 변경합니다. 전통적인 MLP에서는 각 노드에 고정된 활성화 함수가 적용되지만, KAN은 네트워크의 가중치에 학습 가능한 활성화 함수를 배치합니다. 이러한 주요 차이점은 고정된 활성화 함수 세트가 아닌, KAN이 학습 중에 적용할 최상의 함수를 적응적으로 학습한다는 것을 의미합니다. KAN의 각 가중치는 데이터를 기반으로 한 다이내믹하고 세밀한 조정이 가능한 스플라인으로 매개변수화된 단일 변수 함수를 나타냅니다.\u003c/p\u003e\n\u003cp\u003e이 변화는 네트워크의 유연성을 향상시키고 데이터의 복잡한 패턴을 포착할 수 있는 능력을 강화하여 전통적인 MLP에 대한 해석 가능하고 강력한 대안을 제공합니다. KAN은 가장 최적의 성능을 위해 엣지에 있는 학습 가능한 활성화 함수에 초점을 맞춘 결과, 다양한 AI 작업에서 성능이 향상됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e3: 수학적 기초\u003c/h1\u003e\n\u003cp\u003e콜모고로프-아놀드 네트워크(KANs)의 핵심은 이러한 네트워크가 입력 데이터를 처리하고 변환하는 방식을 정의하는 일련의 방정식입니다. KANs의 기초는 콜모고로프-아놀드 표현 정리에 있으며, 이는 네트워크의 구조와 학습 과정에 영감을 주는 개념입니다.\u003c/p\u003e\n\u003cp\u003e입력 벡터 x=[x1,x2,…,xn]가 있다고 상상해보세요. 이 벡터는 처리하려는 데이터 포인트를 나타냅니다. 이 입력 벡터를 레시피의 재료 목록으로 생각해보세요.\u003c/p\u003e\n\u003cp\u003e이 정리는 어떤 복잡한 레시피(고차원 함수)라도 보다 간단한 단계(일변량 함수)로 분해할 수 있다는 것을 명시합니다. KANs에서는 각 재료(입력 값)가 네트워크의 가장자리에 배치된 일련의 간단한 단계(일변량 함수)를 통해 변환됩니다. 이를 수학적으로 표현하면:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_3.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e여기서 ϕ_q,p는 학습 중에 학습되는 단변량 함수입니다. ϕ_q,p를 각 재료에 대한 개별 조리 기술로 생각하고, Φ_q를 이러한 준비된 재료를 결합하는 최종 조립 단계로 생각해보세요.\u003c/p\u003e\n\u003cp\u003eKAN의 각 층은 이러한 요리 기술을 사용하여 재료를 더 변형합니다. 층 l에 대해, 변형은 다음과 같이 주어집니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_4.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기서 x(l)은 l번째 레이어에서 변환된 재료를 나타내고, ϕ_l,i,j는 l레이어와 l+1 레이어 사이의 학습 가능한 일변량 함수입니다. 이를 각 단계마다 재료에 다양한 조리 기술을 적용하여 중간 요리를 얻는 것으로 생각해보세요.\u003c/p\u003e\n\u003cp\u003eKAN의 출력은 이러한 레이어 변환의 합성입니다. 중간 요리를 결합하여 최종 식사를 만드는 것처럼, KAN은 변환을 결합하여 최종 출력물을 생성합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_5.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e여기서 Φl은 l번째 레이어의 일변량 함수 행렬을 나타냅니다. KAN의 전체 함수는 이러한 레이어의 합성으로, 각각이 변환을 더욱 세밀하게 다듬습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eMLP 구조\n전통적인 MLP에서 각 노드는 입력에 고정된 활성화 함수 (예: ReLU 또는 sigmoid)를 적용합니다. 이를 생각해보면 각각의 성질에 관계없이 모든 재료에 동일한 조리 기술을 적용하는 것과 같습니다.\u003c/p\u003e\n\u003cp\u003eMLPs는 이러한 고정 비선형 활성화 함수에 이어서 선형 변환을 사용합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_6.png\" alt=\"MLP Structure\"\u003e\u003c/p\u003e\n\u003cp\u003e여기서 W는 가중치 행렬을 나타내고, σ는 고정된 활성화 함수를 나타냅니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e그리드 확장 기술\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e그리드 확장은 Kolmogorov-Arnold Networks (KANs)의 정확도를 향상시키기 위해 사용되는 강력한 기술로, 단변량 함수가 정의된 스플라인 그리드를 세밀하게 다듬는 데 사용됩니다. 이 과정을 통해 네트워크는 완전 재교육이 필요하지 않고도 데이터의 점점 더 세부적인 패턴을 학습할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 B-스플라인은 부드러운 곡선을 형성하기 위해 결합된 일련의 다항 함수입니다. KANs에서는 가장자리의 단변량 함수를 나타내는 데 사용됩니다. 스플라인은 그리드 포인트라고 불리는 일련의 간격을 통해 정의됩니다. 그리드 포인트가 많을수록 스플라인이 캡처할 수 있는 세부 정보가 더욱 섬세해집니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_8.png\" alt=\"KANKolmogorov-ArnoldNetworks_8\"\u003e\u003c/p\u003e\n\u003cp\u003e먼저, 네트워크는 거친 격자로 시작되어 그리드 포인트 사이의 간격이 적습니다. 이는 네트워크가 세부 사항에 깊이 빠지지 않고 데이터의 기본 구조를 학습할 수 있도록 합니다. 이는 세부 사항을 채우기 전에 대략적인 윤곽을 그리는 것과 유사합니다.\u003c/p\u003e\n\u003cp\u003e학습이 진행됨에 따라 그리드 포인트의 수가 점진적으로 증가합니다. 이 과정을 그리드 세분화라고 합니다. 더 많은 그리드 포인트를 추가함으로써 스플라인이 더 자세해지고 데이터 내의 미세한 패턴을 잡을 수 있습니다. 이는 처음에 대략적인 스케치에 점차적으로 더 많은 세부 사항을 추가하여 자세한 그림으로 완성하는 것과 유사합니다.\u003c/p\u003e\n\u003cp\u003e매 증가할 때마다 새로운 B-spline 기저 함수 B′_m(x)가 도입됩니다. 이러한 새로운 기저 함수에 대한 계수 c'_m은 새로운, 더 자세한 스플라인이 초기, 더 거친 스플라인과 밀접하게 일치하도록 조절됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 작업을 수행하기 위해서는 최소 제곱 최적화가 사용됩니다. 이 방법은 계수 c'_m을 조정하여 원본 스플라인과 개선된 스플라인 간의 차이를 최소화합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_9.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e본질적으로, 이 과정은 개선된 스플라인이 원시 스플라인에 의해 학습된 데이터 패턴을 정확하게 나타내도록 보장합니다.\u003c/p\u003e\n\u003ch2\u003e간소화 기법\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eKANs의 해석 가능성을 향상시키기 위해, 네트워크를 이해하고 시각화하기 쉽게 만들기 위해 여러 간소화 기술이 사용될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e희박화 및 가지치기\n이 기술은 활성화 함수의 L1 노름에 기반한 손실 함수에 패널티를 추가하는 것을 포함합니다. 함수 ϕ에 대한 L1 노름은 모든 입력 샘플을 대상으로 함수의 평균 크기로 정의됩니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_10.png\" alt=\"수학 공식\"\u003e\u003c/p\u003e\n\u003cp\u003e여기서 N_p는 입력 샘플 수이며, ϕ(x_s)는 입력 샘플 x_s에 대한 함수 ϕ의 값입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e스파스파이케이션은 방을 정리하는 것과 같습니다. 불필요한 항목을 제거하거나 중요하지 않은 기능을 줄임으로써 공간(또는 네트워크)을 더 정리하고 쉽게 이동할 수 있게 만듭니다.\u003c/p\u003e\n\u003cp\u003eL1 규제를 적용한 후 활성화 함수의 L1 노름이 평가됩니다. 특정 임계값 이하의 노름을 가진 뉴런과 엣지는 중요하지 않다고 간주되어 제거됩니다. 가지치기를 위한 임계값은 가지치기를 얼마나 적극적으로 진행할지를 결정하는 하이퍼파라미터입니다.\u003c/p\u003e\n\u003cp\u003e가지치기는 나무를 가지치는 것과 같습니다. 약한 또는 불필요한 가지를 제거함으로써, 나무가 더 강하고 중요한 부분에 리소스를 집중할 수 있게 되어 더 건강하고 관리하기 쉬운 구조를 만들어냅니다.\u003c/p\u003e\n\u003cp\u003e상징화\n다른 방법은 배운 단변량 함수를 알려진 기호 형태로 대체하여 네트워크를 보다 해석하기 쉽게 만드는 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e잠재적인 상징적 형식 (예: sin⁡, exp)을 식별하는 작업입니다. 이 단계는 학습된 함수를 분석하고 모양과 행동에 기초하여 상징적 후보를 제안하는 것을 포함합니다.\u003c/p\u003e\n\u003cp\u003e상징적 후보가 식별되면 상징적 함수가 학습된 함수를 근사화하도록 매개변수를 적합시키기 위해 그리드 서치 및 선형 회귀를 사용하십시오.\u003c/p\u003e\n\u003ch1\u003e4: KAN vs MLP in Python\u003c/h1\u003e\n\u003cp\u003eKolmogorov-Arnold Networks (KANs)와 전통적인 Multi-Layer Perceptrons (MLPs)의 능력을 시범하기 위해, PyTorch를 활용하여 함수를 생성한 데이터세트에 KAN 모델과 MLP 모델을 모두 적합시켜보겠습니다. 이들의 성능이 어떻게 보이는지 확인해봅니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리가 사용할 함수는 KAN의 능력을 MLP(원본 논문 예제)과 비교하기 위해 논문 저자들이 사용한 것과 동일합니다. 그러나 코드는 다를 것입니다. 오늘 다룰 모든 코드는 이 노트북에서 찾을 수 있습니다:\u003c/p\u003e\n\u003cp\u003e필요한 라이브러리를 가져와 데이터셋을 생성해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e torch\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e torch.\u003cspan class=\"hljs-property\"\u003enn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e nn\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e torchsummary \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e summary\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e kan \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eKAN\u003c/span\u003e, create_dataset\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 우리가 사용하는 것입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003enumpy: 숫자 연산에 사용됩니다.\u003c/li\u003e\n\u003cli\u003etorch: PyTorch 용으로, 신경망 구축 및 훈련에 사용됩니다.\u003c/li\u003e\n\u003cli\u003etorch.nn: PyTorch 내에서의 신경망 모듈에 사용됩니다.\u003c/li\u003e\n\u003cli\u003etorchsummary: 모델 구조를 요약하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003ekan: KAN 모델 및 데이터셋 생성 함수를 포함하는 사용자 지정 라이브러리입니다.\u003c/li\u003e\n\u003cli\u003ematplotlib.pyplot: 그래프 그리기와 시각화에 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 데이터셋 생성 함수 정의\nf = lambda \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: torch.\u003cspan class=\"hljs-title function_\"\u003eexp\u003c/span\u003e(torch.\u003cspan class=\"hljs-title function_\"\u003esin\u003c/span\u003e(torch.\u003cspan class=\"hljs-property\"\u003epi\u003c/span\u003e * x[:, [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]]) + x[:, [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]] ** \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수에는 삼각함수(sin)와 지수함수(exp) 요소가 모두 포함되어 있습니다. 이 함수는 2차원 입력 x를 취하고 다음 공식을 사용하여 출력을 계산합니다:\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_11.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 [-2, 2] 사이에서 균일하게 분포된 100개의 점의 텐서를 이 함수에 맞춰 보겠습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_12.png\" alt=\"function\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 데이터셋 생성\ndataset = \u003cspan class=\"hljs-title function_\"\u003ecreate_dataset\u003c/span\u003e(f, n_var=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecreate_dataset은 함수 f를 기반으로 데이터셋을 생성합니다. 이 데이터셋에는 신경망의 훈련 및 테스트에 사용될 입력-출력 쌍이 포함됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e자, 이제 데이터셋을 사용하여 KAN 모델을 구축하고 훈련시킬 차례입니다.\n우리는 먼저 더 넓은 격자 (5 포인트)로 시작하여 점진적으로 더 섬세한 세부 사항을 캡처하기 위해 그것을 미세 조정할 것입니다(최대 100 포인트까지).\n이것은 데이터의 세부 사항을 잡아내어 모델의 정확도를 향상시킵니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003egrids = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e])\ntrain_losses_kan = []\ntest_losses_kan = []\nsteps = \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e\nk = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(grids.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]):\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e i == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n        model = \u003cspan class=\"hljs-title function_\"\u003eKAN\u003c/span\u003e(width=[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], grid=grids[i], k=k)\n    \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n        model = \u003cspan class=\"hljs-title function_\"\u003eKAN\u003c/span\u003e(width=[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], grid=grids[i], k=k).\u003cspan class=\"hljs-title function_\"\u003einitialize_from_another_model\u003c/span\u003e(model, dataset[\u003cspan class=\"hljs-string\"\u003e'train_input'\u003c/span\u003e])\n    results = model.\u003cspan class=\"hljs-title function_\"\u003etrain\u003c/span\u003e(dataset, opt=\u003cspan class=\"hljs-string\"\u003e\"LBFGS\"\u003c/span\u003e, steps=steps, stop_grid_update_step=\u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e)\n    train_losses_kan += results[\u003cspan class=\"hljs-string\"\u003e'train_loss'\u003c/span\u003e]\n    test_losses_kan += results[\u003cspan class=\"hljs-string\"\u003e'test_loss'\u003c/span\u003e]\n\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"Train RMSE: {results['train_loss'][-1]:.8f} | Test RMSE: {results['test_loss'][-1]:.8f}\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예시에서 우리는 [5, 10, 20, 50, 100]의 값으로 grids라는 배열을 정의했습니다. 이러한 격자들을 순차적으로 모델 적합에 사용하며, 새 모델을 이전 모델을 사용하여 초기화합니다.\u003c/p\u003e\n\u003cp\u003e각 반복마다, k=3인 모델을 정의합니다. 여기서 k는 B-스플라인의 순서를 나타냅니다. 훈련 단계(또는 에포크) 수를 50으로 설정합니다. 모델의 아키텍처는 2개의 노드를 가진 입력 레이어, 1개의 노드를 가진 은닉 레이어 및 1개의 노드를 가진 출력 레이어로 구성됩니다. LFGBS 옵티마이저를 사용하여 훈련합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 훈련 과정 중의 훈련 및 테스트 손실입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_13.png\" alt=\"loss graph\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 전통적인 MLP를 정의하고 훈련하여 비교해 보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# MLP 정의\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMLP\u003c/span\u003e(nn.Module):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-built_in\"\u003esuper\u003c/span\u003e(MLP, self).__init__()\n        self.layers = nn.Sequential(\n            nn.Linear(dataset[\u003cspan class=\"hljs-string\"\u003e'train_input'\u003c/span\u003e].shape[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e64\u003c/span\u003e),\n            nn.ReLU(),\n            nn.Linear(\u003cspan class=\"hljs-number\"\u003e64\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e64\u003c/span\u003e),\n            nn.ReLU(),\n            nn.Linear(\u003cspan class=\"hljs-number\"\u003e64\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n        )\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eforward\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, x\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e self.layers(x)\n\n\u003cspan class=\"hljs-comment\"\u003e# 모델 인스턴스화\u003c/span\u003e\nmodel = MLP()\nsummary(model, input_size=(dataset[\u003cspan class=\"hljs-string\"\u003e'train_input'\u003c/span\u003e].shape[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e],))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eMLP는 입력 레이어, 64개의 뉴런을 가진 두 개의 히든 레이어 및 출력 레이어를 가지고 있습니다. 레이어 간에는 ReLU 활성화 함수가 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecriterion = nn.\u003cspan class=\"hljs-title class_\"\u003eMSELoss\u003c/span\u003e()\noptimizer = torch.\u003cspan class=\"hljs-property\"\u003eoptim\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eAdam\u003c/span\u003e(model.\u003cspan class=\"hljs-title function_\"\u003eparameters\u003c/span\u003e(), lr=\u003cspan class=\"hljs-number\"\u003e1e-2\u003c/span\u003e)\ntrain_loss_mlp = []\ntest_loss_mlp = []\n\nepochs = \u003cspan class=\"hljs-number\"\u003e250\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e epoch \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(epochs):\n    optimizer.\u003cspan class=\"hljs-title function_\"\u003ezero_grad\u003c/span\u003e()\n    output = \u003cspan class=\"hljs-title function_\"\u003emodel\u003c/span\u003e(dataset[\u003cspan class=\"hljs-string\"\u003e'train_input'\u003c/span\u003e]).\u003cspan class=\"hljs-title function_\"\u003esqueeze\u003c/span\u003e()\n    loss = \u003cspan class=\"hljs-title function_\"\u003ecriterion\u003c/span\u003e(output, dataset[\u003cspan class=\"hljs-string\"\u003e'train_label'\u003c/span\u003e])\n    loss.\u003cspan class=\"hljs-title function_\"\u003ebackward\u003c/span\u003e()\n    optimizer.\u003cspan class=\"hljs-title function_\"\u003estep\u003c/span\u003e()\n    train_loss_mlp.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(loss.\u003cspan class=\"hljs-title function_\"\u003eitem\u003c/span\u003e()**\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e)\n\n    # 모델 테스트\n    model.\u003cspan class=\"hljs-built_in\"\u003eeval\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e torch.\u003cspan class=\"hljs-title function_\"\u003eno_grad\u003c/span\u003e():\n        output = \u003cspan class=\"hljs-title function_\"\u003emodel\u003c/span\u003e(dataset[\u003cspan class=\"hljs-string\"\u003e'test_input'\u003c/span\u003e]).\u003cspan class=\"hljs-title function_\"\u003esqueeze\u003c/span\u003e()\n        loss = \u003cspan class=\"hljs-title function_\"\u003ecriterion\u003c/span\u003e(output, dataset[\u003cspan class=\"hljs-string\"\u003e'test_label'\u003c/span\u003e])\n        test_loss_mlp.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(loss.\u003cspan class=\"hljs-title function_\"\u003eitem\u003c/span\u003e()**\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'에폭 {epoch+1}/{epochs}, 훈련 손실: {train_loss_mlp[-1]:.2f}, 테스트 손실: {test_loss_mlp[-1]:.2f}'\u003c/span\u003e, end=\u003cspan class=\"hljs-string\"\u003e'\\r'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e평균 제곱 오차 (MSE) 손실과 Adam 옵티마이저를 사용하고 모델을 250 에폭 동안 훈련하여 훈련 및 테스트 손실을 기록합니다.\u003c/p\u003e\n\u003cp\u003eMLP에서 훈련 및 테스트 RMSE가 어떻게 나타나는지 보여드리겠습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 비교를 위해 손실 그래프를 나란히 두어 보겠습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks_15.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e이 그래프는 KAN 모델이 MLP 모델보다 더 낮은 훈련 RMSE를 달성하여 더 나은 함수 맞추기 능력을 나타낸다는 것을 보여줍니다. 마찬가지로, KAN 모델은 시험 세트에서 MLP를 능가하여 뛰어난 일반화 능력을 보여줍니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 예시는 KAN이 유연하고 적응적인 구조 덕분에 복잡한 함수들을 전통적인 MLP보다 더 정확하게 맞출 수 있다는 것을 보여줍니다. 격자를 세밀하게 조정하고 가장자리에 학습 가능한 일변량 함수를 사용함으로써, KAN은 MLP가 놓치는 데이터의 복잡한 패턴을 포착하여 함수 맞추기 작업에서 성능을 향상시킵니다.\u003c/p\u003e\n\u003cp\u003e그렇다면 우리는 영구적으로 KAN 모델로 전환해야 한다는 것을 의미합니까? 꼭 그렇지는 않습니다.\u003c/p\u003e\n\u003cp\u003e이 예시에서 KAN은 훌륭한 결과를 보여주었지만, 다른 실제 데이터 시나리오에서 KAN을 시험한 결과, MLP가 더 좋은 성능을 내는 경우가 많았습니다. KAN 모델을 사용할 때 주목해야 할 점은 하이퍼파라미터 최적화에 대한 민감성입니다. 또한, KAN은 주로 스플라인 함수를 사용하여 테스트되었는데, 이는 저희 예시와 같이 부드럽게 변하는 데이터에는 잘 맞지만 다른 상황에서는 그렇지 않을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e요약하자면, KAN은 분명히 매력적이고 많은 잠재력을 가지고 있지만, 실제로 효과적으로 작동하기 위해서는 다른 데이터셋 및 알고리즘 내부 동작에 대해 더 많은 연구가 필요합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e5: KAN의 장점\u003c/h1\u003e\n\u003ch2\u003e정확성\u003c/h2\u003e\n\u003cp\u003eKolmogorov-Arnold Networks (KANs)의 두드러진 장점 중 하나는 전통적인 Multi-Layer Perceptrons (MLPs)에 비해 적은 매개변수로 더 높은 정확도를 달성할 수 있는 능력입니다. 이는 주로 에지에 있는 학습 가능한 활성화 함수 때문에 가능한데, 이는 KAN이 데이터 내의 복잡한 패턴과 관계를 더 잘 포착할 수 있게 합니다.\u003c/p\u003e\n\u003cp\u003e각 노드에 고정된 활성화 함수를 사용하는 MLP와 달리, KAN은 에지에서 단변량 함수를 사용하여 네트워크를 더 융통성 있게 만들고 학습 프로세스를 데이터에 더 잘 맞출 수 있도록 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eKANs은 층간 기능을 동적으로 조절할 수 있기 때문에 더 적은 매개변수로 비교적 높은 정확도를 얻을 수 있습니다. 이 효율성은 데이터나 계산 리소스가 제한된 작업에 특히 유용합니다.\u003c/p\u003e\n\u003ch2\u003e해석가능성\u003c/h2\u003e\n\u003cp\u003eKANs은 전통적인 MLPs에 비해 해석력을 크게 향상시킵니다. 이 향상된 해석력은 의사 결정 과정을 이해하는 것이 결과만큼 중요한 응용 프로그램에 중요합니다.\u003c/p\u003e\n\u003cp\u003eKANs은 희소화(sparsification) 및 가지치기(pruning)와 같은 기술을 통해 단순화될 수 있습니다. 이러한 기술은 해석력을 향상시키는 뿐만 아니라 가장 관련성이 높은 구성 요소에 집중함으로써 네트워크의 성능을 향상시킵니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e일부 함수의 경우 활성화 함수의 기호적 형태를 식별할 수 있으며, 이를 통해 네트워크 내에서 발생하는 수학적 변환을 이해하기 쉬워집니다.\u003c/p\u003e\n\u003ch2\u003e확장성\u003c/h2\u003e\n\u003cp\u003eKAN은 MLP와 비교했을 때 더 빠른 신경 확장 법칙을 나타내며, 매개변수의 수가 증가함에 따라 더 신속하게 개선됩니다.\u003c/p\u003e\n\u003cp\u003eKAN은 복잡한 함수를 더 단순한 단변량 함수로 분해할 수 있는 능력으로 인해 보다 유리한 확장 법칙을 갖게 되어, MLP보다 모델 복잡도가 증가함에 따라 더 효율적으로 낮은 오류율을 달성할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eKANs는 훈련 중에 더 미세한 그리드까지 더욱 세분화된 그리드로 시작하여 계산 효율성과 정확도를 균형있게 유지하도록 합니다. 이 접근 방식은 MLPs보다 KANs가 보다 우아하게 확장될 수 있게 하며, 모델 크기를 증가시킬 때 완전히 재훈련이 필요한 MLPs보다 우수한 성능을 제공합니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eKolmogorov-Arnold Networks (KANs)는 전통적인 Multi-Layer Perceptrons (MLPs)에 비해 혁신적인 대안을 제시하여 이전 모델의 한계를 해소하는 핵심 혁신을 제공합니다. KANs는 노드에서 고정된 함수 대신 가장자리에 가중치가 있는 활성화 함수를 활용함으로써 새로운 수준의 유연성과 적응성을 도입합니다. 이 구조적인 변화로 인해 다음과 같은 장점을 제공합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e향상된 정확도: 더 적은 매개변수로 더 높은 정확도를 달성하는 KANs는 다양한 작업에 더 효율적이고 효과적입니다.\u003c/li\u003e\n\u003cli\u003e향상된 해석력: KANs를 시각화하고 단순화할 수 있는 능력은 건강 관리, 금융 및 자율 시스템과 같은 중요한 응용 분야에서 의사 결정 과정을 이해하는 데 도움이 됩니다.\u003c/li\u003e\n\u003cli\u003e더 나은 확장성: KANs는 더 빠른 신경 확장 법칙을 나타내며 MLPs보다 증가하는 복잡성을 우아하게 처리할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e콜모고로프-아놀드 네트워크 소개는 신경망 분야에서 흥미로운 발전을 의미합니다. 이는 AI 및 머신 러닝에 대한 새로운 가능성을 열어줍니다.\u003c/p\u003e\n\u003ch1\u003e참고 자료\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eZiming Liu, 등. “KAN: 콜모고로프-아놀드 네트워크”. \u003ca href=\"https://arxiv.org/abs/2404.19756\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://arxiv.org/abs/2404.19756\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-TheMathBehindKANKolmogorov-ArnoldNetworks"},"buildId":"kkckKPyxcjJp_o8wb2unW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>