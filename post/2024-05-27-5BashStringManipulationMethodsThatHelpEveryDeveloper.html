<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>모든 개발자를 위해 도움이 되는 5가지 Bash 문자열 조작 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="모든 개발자를 위해 도움이 되는 5가지 Bash 문자열 조작 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="모든 개발자를 위해 도움이 되는 5가지 Bash 문자열 조작 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper" data-gatsby-head="true"/><meta name="twitter:title" content="모든 개발자를 위해 도움이 되는 5가지 Bash 문자열 조작 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 12:16" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">모든 개발자를 위해 도움이 되는 5가지 Bash 문자열 조작 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="모든 개발자를 위해 도움이 되는 5가지 Bash 문자열 조작 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png" alt="Bash String Manipulation Methods"></p>
<p>배시는 모든 유닉스류 또는 유닉스 기반 운영 체제의 기본 자동화 언어가 되었습니다. 시스템 관리자, 데브옵스 엔지니어 및 프로그래머는 일반적으로 반복적인 명령 시퀀스를 사용하여 셸 스크립트를 작성하는 데 Bash를 사용합니다. Bash 스크립트에는 일반적으로 다른 프로그램 이진 파일을 실행하는 명령이 포함되어 있습니다. 대부분의 시나리오에서 데이터를 처리하고 셸 스크립트 내에서 논리적 흐름을 생성해야 할 수 있습니다. 따라서 우리는 종종 셸 스크립트에 조건문과 텍스트 조작 문을 추가해야 합니다.</p>
<p>전통적인 Bash 스크립트와 이전 버전의 Bash 해석기를 사용한 이전 프로그래머들은 텍스트 조작을 위해 awk, sed, tr 및 cut 명령을 일반적으로 사용했습니다. 이들은 별개의 프로그램입니다. 이 텍스트 처리 프로그램들은 좋은 기능을 제공하지만 각 명령마다 상당한 프로세스 생성 시간이 소요되기 때문에 Bash 스크립트를 느리게 만듭니다. 현대의 Bash 버전은 잘 알려진 매개변수 확장 기능을 통해 내장된 텍스트 처리 기능을 제공합니다.</p>
<p>본 기사에서는 Bash 스크립트에서 효율적으로 텍스트를 처리하는 데 사용할 수 있는 내장 문자열 조작 구문 몇 가지에 대해 설명하겠습니다.</p>
<div class="content-ad"></div>
<h1>부분 문자열 추출 및 대체</h1>
<p>부분 문자열은 특정 문자열의 연속된 세그먼트 또는 일부를 가리킵니다. 다양한 스크립팅 시나리오에서 문자열 세그먼트에서 부분 문자열을 추출해야 하는 경우가 있습니다. 예를 들어, 파일 확장자가 포함된 완전한 파일 이름에서 파일 이름 세그먼트만 얻어야 하는 경우가 있습니다. 또한 부분 문자열을 특정 문자열 세그먼트로 대체해야 할 수도 있습니다 (즉, 파일 이름의 확장자를 변경하는 경우).</p>
<p>문자의 위치와 길이를 제공함으로써 부분 문자열을 추출하는 것은 매우 쉽습니다:</p>
<pre><code class="hljs language-js">#!<span class="hljs-regexp">/bin/</span>bash

str=<span class="hljs-string">"2023-10-12"</span>

echo <span class="hljs-string">"${str:5:2}"</span> # <span class="hljs-number">10</span>
echo <span class="hljs-string">"${str::4}"</span> # <span class="hljs-number">2023</span>
echo <span class="hljs-string">"2022-${str:5}"</span> # <span class="hljs-number">2022</span>-<span class="hljs-number">10</span>-<span class="hljs-number">12</span>
</code></pre>
<div class="content-ad"></div>
<p>다음과 같이 오른쪽 기준으로 부분 문자열 계산도 할 수 있습니다.</p>
<pre><code class="hljs language-js">#!<span class="hljs-regexp">/bin/</span>bash

str=<span class="hljs-string">"backup.sql"</span>

echo <span class="hljs-string">"original${str:(-4)}"</span> # original.<span class="hljs-property">sql</span>
</code></pre>
<p>Bash는 부분 문자열을 대체하는 데 유용한 내장 구문도 제공합니다.</p>
<pre><code class="hljs language-js">#!<span class="hljs-regexp">/bin/</span>bash

str=<span class="hljs-string">"obin-linux_x64_bin"</span>

echo <span class="hljs-string">"${str/x64/armhf}"</span> # obin-linux_armhf_bin
echo <span class="hljs-string">"${str/bin/dist}"</span> # odist-linux_x64_bin
echo <span class="hljs-string">"${str//bin/dist}"</span> # odist-linux_x64_dist
</code></pre>
<div class="content-ad"></div>
<p>일부 문자열(예: 파일 이름, 경로 등)을 작업할 때는 문자열의 접두사와 접미사를 대체해야 할 수도 있습니다. 파일 확장자를 다른 확장자로 바꾸는 것이 좋은 예시입니다. 다음 예시를 살펴보세요:</p>
<pre><code class="hljs language-bash"><span class="hljs-meta">#!/bin/bash</span>

str=<span class="hljs-string">"db_config_backup.zip"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${str/%.zip/.conf}</span>"</span> <span class="hljs-comment"># db_config_backup.conf</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${str/#db/settings}</span>"</span> <span class="hljs-comment"># settings_config_backup.zip</span>
</code></pre>
<p>위의 부분 문자열 대체 예시에서 일치시키기 위해 정확한 부분 문자열 세그먼트를 사용했지만, 다음과 같이 '*' 와일드카드 문자를 사용하여 부분 문자열을 사용할 수도 있습니다:</p>
<pre><code class="hljs language-bash"><span class="hljs-meta">#!/bin/bash</span>

str=<span class="hljs-string">"db_config_backup.zip"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${str/%.*/.bak}</span>"</span> <span class="hljs-comment"># db_config_backup.bak</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${str/#*_/new}</span>"</span> <span class="hljs-comment"># newbackup.zip</span>
</code></pre>
<div class="content-ad"></div>
<p>위의 방법은 정확한 부분 문자열을 모를 때 도움이 됩니다.</p>
<h1>정규 표현식 일치, 추출 및 치환</h1>
<p>이미 많은 유닉스 또는 GNU/Linux 사용자들이 알고 있는 대로, grep과 sed를 사용하여 정규 표현식 기반 텍스트 검색이 가능합니다. sed는 우리에게 정규 표현식 치환을 도와줍니다. 당신은 내장된 Bash 정규 표현식 기능을 사용하여 이러한 외부 이진 파일보다 빠르게 텍스트 처리를 처리할 수 있습니다.</p>
<p>다음의 코드 스니펫에서 보여지는 것처럼, if 조건문과 =~ 연산자를 사용하여 정규 표현식 일치를 수행할 수 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">#!<span class="hljs-regexp">/bin/</span>bash

str=<span class="hljs-string">"db_backup_2003.zip"</span>

<span class="hljs-keyword">if</span> [[ $str =~ <span class="hljs-number">200</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>]+ ]]; then
    echo <span class="hljs-string">"regex_matched"</span>
fi
</code></pre>
<p>만약 원하시면 if 문을 인라인 조건문으로 바꿀 수도 있어요:</p>
<pre><code class="hljs language-js">[[ $str =~ <span class="hljs-number">200</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>]+ ]] &#x26;&#x26; echo <span class="hljs-string">"regex_matched"</span>
</code></pre>
<p>Bash 해석기가 정규 표현식을 찾은 후에는 일반적으로 모든 일치 항목을 BASH_REMATCH 쉘 변수에 저장합니다. 이 변수는 읽기 전용 배열이며, 전체 일치 데이터를 첫 번째 인덱스에 저장합니다. 서브 패턴을 사용하는 경우, Bash는 그에 해당하는 일치 항목을 다른 인덱스에 차례대로 보관합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">#!<span class="hljs-regexp">/bin/</span>bash

str=<span class="hljs-string">"db_backup_2003.zip"</span>

<span class="hljs-keyword">if</span> [[ $str =~ (<span class="hljs-number">200</span>[<span class="hljs-number">0</span>-<span class="hljs-number">5</span>])(.*)$ ]]; then
    echo <span class="hljs-string">"${BASH_REMATCH[0]}"</span> # <span class="hljs-number">2003.</span>zip
    echo <span class="hljs-string">"${BASH_REMATCH[1]}"</span> # <span class="hljs-number">2003</span>
    echo <span class="hljs-string">"${BASH_REMATCH[2]}"</span> # .<span class="hljs-property">zip</span>
fi
</code></pre>
<p>이전에 substring matching을 wildcard와 함께 사용했던 것을 기억하시나요? 비슷하게, 다음 예시에서 보여지는 것처럼 파라미터 확장 내에서 regex 정의를 사용할 수 있습니다.:</p>
<pre><code class="hljs language-js">#!<span class="hljs-regexp">/bin/</span>bash

str=<span class="hljs-string">"db_backup_2003.zip"</span>
re=<span class="hljs-string">"200[0-3].zip"</span>

echo <span class="hljs-string">"${str/$re/new}.bak"</span> # db_backup_new.<span class="hljs-property">bak</span>
</code></pre>
<h1>Substring Removal Techniques</h1>
<div class="content-ad"></div>
<p>자주 텍스트 처리 요구 사항에서는 원하는 부분 문자열을 제거하여 텍스트 세그먼트를 사전 처리해야 할 때가 있습니다. 예를 들어, v 접두사와 일부 빌드 번호를 포함한 버전 번호를 추출하고 주 버전 번호를 찾으려면 일부 부분 문자열을 제거해야 합니다. 똑같은 부분 문자열 교체 구문을 사용할 수 있지만, 문자열 제거를 위해 교체 문자열 매개변수를 생략할 수도 있습니다.</p>
<pre><code class="hljs language-js">#!<span class="hljs-regexp">/bin/</span>bash

str=<span class="hljs-string">"ver5.02-2224.e2"</span>

ver=<span class="hljs-string">"${str#ver}"</span>
echo $ver # <span class="hljs-number">5.02</span>-<span class="hljs-number">2224.e2</span>

maj=<span class="hljs-string">"${ver/.*}"</span>
echo $maj # <span class="hljs-number">5</span>
</code></pre>
<p>위 예제에서는 정확한 부분 문자열과 와일드카드를 사용하여 부분 문자열을 제거했지만, 정규 표현식을 사용할 수도 있습니다. 과도한 문자 없이 깔끔한 버전 번호를 추출하는 방법을 확인해보세요.</p>
<pre><code class="hljs language-js">#!<span class="hljs-regexp">/bin/</span>bash

str=<span class="hljs-string">"ver5.02-2224_release"</span>

ver=<span class="hljs-string">"${str//[a-z_]}"</span>
echo $ver # <span class="hljs-number">5.02</span>-<span class="hljs-number">2224</span>
</code></pre>
<div class="content-ad"></div>
<h1>대 소문자 변환 및 대 소문자 기반 변수</h1>
<p>심지어 표준 C 언어에는 문자의 대 소문자를 변환하는 함수가 있습니다. 대부분의 현대적인 프로그래밍 언어들은 대소문자 변환을 위한 내장 함수를 제공합니다. 셸 스크립트 언어인 Bash는 대소문자 변환을 위한 함수를 제공하지는 않지만, 매개변수 확장과 변수 선언을 통해 대소문자 변환 기능을 제공합니다.</p>
<p>다음 예제를 살펴보세요. 이 예제는 글자의 대소문자를 변환합니다:</p>
<pre><code class="hljs language-bash"><span class="hljs-meta">#!/bin/bash</span>

str=<span class="hljs-string">"안녕 Bash!"</span>

lower=<span class="hljs-string">"<span class="hljs-variable">${str,,}</span>"</span>
upper=<span class="hljs-string">"<span class="hljs-variable">${str^^}</span>"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-variable">$lower</span> <span class="hljs-comment"># 안녕 bash!</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$upper</span> <span class="hljs-comment"># 안녕 BASH!</span>
</code></pre>
<div class="content-ad"></div>
<p>다음처럼 특정 문자열의 첫 글자만 대문자 또는 소문자로 변경할 수도 있습니다:</p>
<pre><code class="hljs language-js">#!<span class="hljs-regexp">/bin/</span>bash

ver1=<span class="hljs-string">"V2.0-release"</span>
ver2=<span class="hljs-string">"v4.0-release"</span>

echo <span class="hljs-string">"${ver1,}"</span> # v2<span class="hljs-number">.0</span>-release
echo <span class="hljs-string">"${ver2^}"</span> # <span class="hljs-variable constant_">V4</span><span class="hljs-number">.0</span>-release
</code></pre>
<p>만약 특정 변수를 엄격하게 대문자 또는 소문자로 만들어야 할 경우에는 매번 케이스 변환 함수를 실행할 필요가 없습니다. 대신, 다음 예시와 같이 내장된 declare 명령을 사용하여 특정 변수에 케이스 속성을 추가할 수 있습니다:</p>
<pre><code class="hljs language-js">#!<span class="hljs-regexp">/bin/</span>bash

declare -l ver1
declare -u ver2

ver1=<span class="hljs-string">"V4.02.2"</span>
ver2=<span class="hljs-string">"v2.22.1"</span>

echo $ver1 # v4<span class="hljs-number">.02</span><span class="hljs-number">.2</span>
echo $ver2 # <span class="hljs-variable constant_">V2</span><span class="hljs-number">.22</span><span class="hljs-number">.1</span>
</code></pre>
<div class="content-ad"></div>
<p>위의 ver1 및 ver2 변수는 선언 시 case 속성을 받기 때문에 특정 변수에 값을 할당할 때마다 Bash는 변수 속성을 기반으로 텍스트 case를 변환합니다.</p>
<h1>문자열 분할 (문자열을 배열로 변환하기)</h1>
<p>Bash는 declare 내장을 사용하여 색인 배열과 연관 배열을 정의할 수 있습니다. 대부분의 범용 프로그래밍 언어는 문자열 객체의 분할 메서드나 표준 라이브러리 함수를 통해 분할 기능을 제공합니다 (예: Go의 strings.Split 함수). Bash에서는 다양한 방법으로 문자열을 분할하고 배열을 생성할 수 있습니다. 예를 들어 필요한 구분 기호를 IFS로 변경하고 read 내장을 사용할 수 있습니다. 또는 tr 명령어를 루프와 함께 사용하여 배열을 구성할 수도 있습니다. 내장 매개변수 확장을 사용하는 방법도 있습니다. Bash에서는 문자열을 분할하는 다양한 방법이 있습니다.</p>
<p>IFS와 read를 사용하는 것은 문자열을 분할하는 가장 간단하고 오류가 적은 방법 중 하나입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-bash"><span class="hljs-meta">#!/bin/bash</span>

str=<span class="hljs-string">"C,C++,JavaScript,Python,Bash"</span>

IFS=<span class="hljs-string">','</span> <span class="hljs-built_in">read</span> -ra arr &#x3C;&#x3C;&#x3C; <span class="hljs-string">"<span class="hljs-variable">$str</span>"</span>

<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${#arr[@]}</span>"</span> <span class="hljs-comment"># 5</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${arr[0]}</span>"</span> <span class="hljs-comment"># C</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${arr[4]}</span>"</span> <span class="hljs-comment"># Bash</span>
</code></pre>
<p>위의 코드 스니펫은 쉼표를 구분자로 사용하며 read 내장 명령어를 사용하여 IFS를 기반으로 배열을 생성합니다.</p>
<p>read를 사용하지 않고 쉽게 분할할 수 있는 방법이 있더라도, 숨겨진 문제가 없는지 확인해야 합니다. 예를 들어, 다음 분할 구현은 매우 간단하지만 * (현재 디렉토리의 내용으로 확장)을 요소로 포함하고 구분 기호로 공백을 사용하는 경우에 작동하지 않습니다:</p>
<pre><code class="hljs language-bash"><span class="hljs-meta">#!/bin/bash</span>

<span class="hljs-comment"># 경고: 이 코드에는 여러 숨겨진 문제가 있습니다.</span>

str=<span class="hljs-string">"C,Bash,*"</span>

arr=(<span class="hljs-variable">${str//,/ }</span>)

<span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">${#arr[@]}</span>"</span> <span class="hljs-comment"># 현재 디렉토리의 내용이 포함되어 있음</span>
</code></pre>
<div class="content-ad"></div>
<p>지금까지 읽어 주셔서 감사합니다.</p>
<h1>레벨 업 코딩</h1>
<p>우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 마지막으로 하고 가기 전에:</p>
<div class="content-ad"></div>
<ul>
<li>👏 이야기에 박수를 보내고 저자를 팔로우하세요 👉</li>
<li>📰 Level Up Coding 게시물에서 더 많은 콘텐츠 확인하기</li>
<li>💰 무료 코딩 면접 코스 ⇒ 코스 보기</li>
<li>🔔 팔로우하기: Twitter | LinkedIn | 뉴스레터</li>
</ul>
<p>🚀👉 Level Up 팀의 멤버가 되어 멋진 직업을 찾아보세요</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"모든 개발자를 위해 도움이 되는 5가지 Bash 문자열 조작 방법","description":"","date":"2024-05-27 12:16","slug":"2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper","content":"\n![Bash String Manipulation Methods](/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png)\n\n배시는 모든 유닉스류 또는 유닉스 기반 운영 체제의 기본 자동화 언어가 되었습니다. 시스템 관리자, 데브옵스 엔지니어 및 프로그래머는 일반적으로 반복적인 명령 시퀀스를 사용하여 셸 스크립트를 작성하는 데 Bash를 사용합니다. Bash 스크립트에는 일반적으로 다른 프로그램 이진 파일을 실행하는 명령이 포함되어 있습니다. 대부분의 시나리오에서 데이터를 처리하고 셸 스크립트 내에서 논리적 흐름을 생성해야 할 수 있습니다. 따라서 우리는 종종 셸 스크립트에 조건문과 텍스트 조작 문을 추가해야 합니다.\n\n전통적인 Bash 스크립트와 이전 버전의 Bash 해석기를 사용한 이전 프로그래머들은 텍스트 조작을 위해 awk, sed, tr 및 cut 명령을 일반적으로 사용했습니다. 이들은 별개의 프로그램입니다. 이 텍스트 처리 프로그램들은 좋은 기능을 제공하지만 각 명령마다 상당한 프로세스 생성 시간이 소요되기 때문에 Bash 스크립트를 느리게 만듭니다. 현대의 Bash 버전은 잘 알려진 매개변수 확장 기능을 통해 내장된 텍스트 처리 기능을 제공합니다.\n\n본 기사에서는 Bash 스크립트에서 효율적으로 텍스트를 처리하는 데 사용할 수 있는 내장 문자열 조작 구문 몇 가지에 대해 설명하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 부분 문자열 추출 및 대체\n\n부분 문자열은 특정 문자열의 연속된 세그먼트 또는 일부를 가리킵니다. 다양한 스크립팅 시나리오에서 문자열 세그먼트에서 부분 문자열을 추출해야 하는 경우가 있습니다. 예를 들어, 파일 확장자가 포함된 완전한 파일 이름에서 파일 이름 세그먼트만 얻어야 하는 경우가 있습니다. 또한 부분 문자열을 특정 문자열 세그먼트로 대체해야 할 수도 있습니다 (즉, 파일 이름의 확장자를 변경하는 경우).\n\n문자의 위치와 길이를 제공함으로써 부분 문자열을 추출하는 것은 매우 쉽습니다:\n\n```js\n#!/bin/bash\n\nstr=\"2023-10-12\"\n\necho \"${str:5:2}\" # 10\necho \"${str::4}\" # 2023\necho \"2022-${str:5}\" # 2022-10-12\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음과 같이 오른쪽 기준으로 부분 문자열 계산도 할 수 있습니다.\n\n```js\n#!/bin/bash\n\nstr=\"backup.sql\"\n\necho \"original${str:(-4)}\" # original.sql\n```\n\nBash는 부분 문자열을 대체하는 데 유용한 내장 구문도 제공합니다.\n\n```js\n#!/bin/bash\n\nstr=\"obin-linux_x64_bin\"\n\necho \"${str/x64/armhf}\" # obin-linux_armhf_bin\necho \"${str/bin/dist}\" # odist-linux_x64_bin\necho \"${str//bin/dist}\" # odist-linux_x64_dist\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 문자열(예: 파일 이름, 경로 등)을 작업할 때는 문자열의 접두사와 접미사를 대체해야 할 수도 있습니다. 파일 확장자를 다른 확장자로 바꾸는 것이 좋은 예시입니다. 다음 예시를 살펴보세요:\n\n```bash\n#!/bin/bash\n\nstr=\"db_config_backup.zip\"\n\necho \"${str/%.zip/.conf}\" # db_config_backup.conf\necho \"${str/#db/settings}\" # settings_config_backup.zip\n```\n\n위의 부분 문자열 대체 예시에서 일치시키기 위해 정확한 부분 문자열 세그먼트를 사용했지만, 다음과 같이 '\\*' 와일드카드 문자를 사용하여 부분 문자열을 사용할 수도 있습니다:\n\n```bash\n#!/bin/bash\n\nstr=\"db_config_backup.zip\"\n\necho \"${str/%.*/.bak}\" # db_config_backup.bak\necho \"${str/#*_/new}\" # newbackup.zip\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 방법은 정확한 부분 문자열을 모를 때 도움이 됩니다.\n\n# 정규 표현식 일치, 추출 및 치환\n\n이미 많은 유닉스 또는 GNU/Linux 사용자들이 알고 있는 대로, grep과 sed를 사용하여 정규 표현식 기반 텍스트 검색이 가능합니다. sed는 우리에게 정규 표현식 치환을 도와줍니다. 당신은 내장된 Bash 정규 표현식 기능을 사용하여 이러한 외부 이진 파일보다 빠르게 텍스트 처리를 처리할 수 있습니다.\n\n다음의 코드 스니펫에서 보여지는 것처럼, if 조건문과 =~ 연산자를 사용하여 정규 표현식 일치를 수행할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n#!/bin/bash\n\nstr=\"db_backup_2003.zip\"\n\nif [[ $str =~ 200[0-5]+ ]]; then\n    echo \"regex_matched\"\nfi\n```\n\n만약 원하시면 if 문을 인라인 조건문으로 바꿀 수도 있어요:\n\n```js\n[[ $str =~ 200[0-5]+ ]] \u0026\u0026 echo \"regex_matched\"\n```\n\nBash 해석기가 정규 표현식을 찾은 후에는 일반적으로 모든 일치 항목을 BASH_REMATCH 쉘 변수에 저장합니다. 이 변수는 읽기 전용 배열이며, 전체 일치 데이터를 첫 번째 인덱스에 저장합니다. 서브 패턴을 사용하는 경우, Bash는 그에 해당하는 일치 항목을 다른 인덱스에 차례대로 보관합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n#!/bin/bash\n\nstr=\"db_backup_2003.zip\"\n\nif [[ $str =~ (200[0-5])(.*)$ ]]; then\n    echo \"${BASH_REMATCH[0]}\" # 2003.zip\n    echo \"${BASH_REMATCH[1]}\" # 2003\n    echo \"${BASH_REMATCH[2]}\" # .zip\nfi\n```\n\n이전에 substring matching을 wildcard와 함께 사용했던 것을 기억하시나요? 비슷하게, 다음 예시에서 보여지는 것처럼 파라미터 확장 내에서 regex 정의를 사용할 수 있습니다.:\n\n```js\n#!/bin/bash\n\nstr=\"db_backup_2003.zip\"\nre=\"200[0-3].zip\"\n\necho \"${str/$re/new}.bak\" # db_backup_new.bak\n```\n\n# Substring Removal Techniques\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자주 텍스트 처리 요구 사항에서는 원하는 부분 문자열을 제거하여 텍스트 세그먼트를 사전 처리해야 할 때가 있습니다. 예를 들어, v 접두사와 일부 빌드 번호를 포함한 버전 번호를 추출하고 주 버전 번호를 찾으려면 일부 부분 문자열을 제거해야 합니다. 똑같은 부분 문자열 교체 구문을 사용할 수 있지만, 문자열 제거를 위해 교체 문자열 매개변수를 생략할 수도 있습니다.\n\n```js\n#!/bin/bash\n\nstr=\"ver5.02-2224.e2\"\n\nver=\"${str#ver}\"\necho $ver # 5.02-2224.e2\n\nmaj=\"${ver/.*}\"\necho $maj # 5\n```\n\n위 예제에서는 정확한 부분 문자열과 와일드카드를 사용하여 부분 문자열을 제거했지만, 정규 표현식을 사용할 수도 있습니다. 과도한 문자 없이 깔끔한 버전 번호를 추출하는 방법을 확인해보세요.\n\n```js\n#!/bin/bash\n\nstr=\"ver5.02-2224_release\"\n\nver=\"${str//[a-z_]}\"\necho $ver # 5.02-2224\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 대 소문자 변환 및 대 소문자 기반 변수\n\n심지어 표준 C 언어에는 문자의 대 소문자를 변환하는 함수가 있습니다. 대부분의 현대적인 프로그래밍 언어들은 대소문자 변환을 위한 내장 함수를 제공합니다. 셸 스크립트 언어인 Bash는 대소문자 변환을 위한 함수를 제공하지는 않지만, 매개변수 확장과 변수 선언을 통해 대소문자 변환 기능을 제공합니다.\n\n다음 예제를 살펴보세요. 이 예제는 글자의 대소문자를 변환합니다:\n\n```bash\n#!/bin/bash\n\nstr=\"안녕 Bash!\"\n\nlower=\"${str,,}\"\nupper=\"${str^^}\"\n\necho $lower # 안녕 bash!\necho $upper # 안녕 BASH!\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음처럼 특정 문자열의 첫 글자만 대문자 또는 소문자로 변경할 수도 있습니다:\n\n```js\n#!/bin/bash\n\nver1=\"V2.0-release\"\nver2=\"v4.0-release\"\n\necho \"${ver1,}\" # v2.0-release\necho \"${ver2^}\" # V4.0-release\n```\n\n만약 특정 변수를 엄격하게 대문자 또는 소문자로 만들어야 할 경우에는 매번 케이스 변환 함수를 실행할 필요가 없습니다. 대신, 다음 예시와 같이 내장된 declare 명령을 사용하여 특정 변수에 케이스 속성을 추가할 수 있습니다:\n\n```js\n#!/bin/bash\n\ndeclare -l ver1\ndeclare -u ver2\n\nver1=\"V4.02.2\"\nver2=\"v2.22.1\"\n\necho $ver1 # v4.02.2\necho $ver2 # V2.22.1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 ver1 및 ver2 변수는 선언 시 case 속성을 받기 때문에 특정 변수에 값을 할당할 때마다 Bash는 변수 속성을 기반으로 텍스트 case를 변환합니다.\n\n# 문자열 분할 (문자열을 배열로 변환하기)\n\nBash는 declare 내장을 사용하여 색인 배열과 연관 배열을 정의할 수 있습니다. 대부분의 범용 프로그래밍 언어는 문자열 객체의 분할 메서드나 표준 라이브러리 함수를 통해 분할 기능을 제공합니다 (예: Go의 strings.Split 함수). Bash에서는 다양한 방법으로 문자열을 분할하고 배열을 생성할 수 있습니다. 예를 들어 필요한 구분 기호를 IFS로 변경하고 read 내장을 사용할 수 있습니다. 또는 tr 명령어를 루프와 함께 사용하여 배열을 구성할 수도 있습니다. 내장 매개변수 확장을 사용하는 방법도 있습니다. Bash에서는 문자열을 분할하는 다양한 방법이 있습니다.\n\nIFS와 read를 사용하는 것은 문자열을 분할하는 가장 간단하고 오류가 적은 방법 중 하나입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n#!/bin/bash\n\nstr=\"C,C++,JavaScript,Python,Bash\"\n\nIFS=',' read -ra arr \u003c\u003c\u003c \"$str\"\n\necho \"${#arr[@]}\" # 5\necho \"${arr[0]}\" # C\necho \"${arr[4]}\" # Bash\n```\n\n위의 코드 스니펫은 쉼표를 구분자로 사용하며 read 내장 명령어를 사용하여 IFS를 기반으로 배열을 생성합니다.\n\nread를 사용하지 않고 쉽게 분할할 수 있는 방법이 있더라도, 숨겨진 문제가 없는지 확인해야 합니다. 예를 들어, 다음 분할 구현은 매우 간단하지만 \\* (현재 디렉토리의 내용으로 확장)을 요소로 포함하고 구분 기호로 공백을 사용하는 경우에 작동하지 않습니다:\n\n```bash\n#!/bin/bash\n\n# 경고: 이 코드에는 여러 숨겨진 문제가 있습니다.\n\nstr=\"C,Bash,*\"\n\narr=(${str//,/ })\n\necho \"${#arr[@]}\" # 현재 디렉토리의 내용이 포함되어 있음\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n지금까지 읽어 주셔서 감사합니다.\n\n# 레벨 업 코딩\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 마지막으로 하고 가기 전에:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 👏 이야기에 박수를 보내고 저자를 팔로우하세요 👉\n- 📰 Level Up Coding 게시물에서 더 많은 콘텐츠 확인하기\n- 💰 무료 코딩 면접 코스 ⇒ 코스 보기\n- 🔔 팔로우하기: Twitter | LinkedIn | 뉴스레터\n\n🚀👉 Level Up 팀의 멤버가 되어 멋진 직업을 찾아보세요\n","ogImage":{"url":"/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png"},"coverImage":"/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png\" alt=\"Bash String Manipulation Methods\"\u003e\u003c/p\u003e\n\u003cp\u003e배시는 모든 유닉스류 또는 유닉스 기반 운영 체제의 기본 자동화 언어가 되었습니다. 시스템 관리자, 데브옵스 엔지니어 및 프로그래머는 일반적으로 반복적인 명령 시퀀스를 사용하여 셸 스크립트를 작성하는 데 Bash를 사용합니다. Bash 스크립트에는 일반적으로 다른 프로그램 이진 파일을 실행하는 명령이 포함되어 있습니다. 대부분의 시나리오에서 데이터를 처리하고 셸 스크립트 내에서 논리적 흐름을 생성해야 할 수 있습니다. 따라서 우리는 종종 셸 스크립트에 조건문과 텍스트 조작 문을 추가해야 합니다.\u003c/p\u003e\n\u003cp\u003e전통적인 Bash 스크립트와 이전 버전의 Bash 해석기를 사용한 이전 프로그래머들은 텍스트 조작을 위해 awk, sed, tr 및 cut 명령을 일반적으로 사용했습니다. 이들은 별개의 프로그램입니다. 이 텍스트 처리 프로그램들은 좋은 기능을 제공하지만 각 명령마다 상당한 프로세스 생성 시간이 소요되기 때문에 Bash 스크립트를 느리게 만듭니다. 현대의 Bash 버전은 잘 알려진 매개변수 확장 기능을 통해 내장된 텍스트 처리 기능을 제공합니다.\u003c/p\u003e\n\u003cp\u003e본 기사에서는 Bash 스크립트에서 효율적으로 텍스트를 처리하는 데 사용할 수 있는 내장 문자열 조작 구문 몇 가지에 대해 설명하겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e부분 문자열 추출 및 대체\u003c/h1\u003e\n\u003cp\u003e부분 문자열은 특정 문자열의 연속된 세그먼트 또는 일부를 가리킵니다. 다양한 스크립팅 시나리오에서 문자열 세그먼트에서 부분 문자열을 추출해야 하는 경우가 있습니다. 예를 들어, 파일 확장자가 포함된 완전한 파일 이름에서 파일 이름 세그먼트만 얻어야 하는 경우가 있습니다. 또한 부분 문자열을 특정 문자열 세그먼트로 대체해야 할 수도 있습니다 (즉, 파일 이름의 확장자를 변경하는 경우).\u003c/p\u003e\n\u003cp\u003e문자의 위치와 길이를 제공함으로써 부분 문자열을 추출하는 것은 매우 쉽습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#!\u003cspan class=\"hljs-regexp\"\u003e/bin/\u003c/span\u003ebash\n\nstr=\u003cspan class=\"hljs-string\"\u003e\"2023-10-12\"\u003c/span\u003e\n\necho \u003cspan class=\"hljs-string\"\u003e\"${str:5:2}\"\u003c/span\u003e # \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\necho \u003cspan class=\"hljs-string\"\u003e\"${str::4}\"\u003c/span\u003e # \u003cspan class=\"hljs-number\"\u003e2023\u003c/span\u003e\necho \u003cspan class=\"hljs-string\"\u003e\"2022-${str:5}\"\u003c/span\u003e # \u003cspan class=\"hljs-number\"\u003e2022\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음과 같이 오른쪽 기준으로 부분 문자열 계산도 할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#!\u003cspan class=\"hljs-regexp\"\u003e/bin/\u003c/span\u003ebash\n\nstr=\u003cspan class=\"hljs-string\"\u003e\"backup.sql\"\u003c/span\u003e\n\necho \u003cspan class=\"hljs-string\"\u003e\"original${str:(-4)}\"\u003c/span\u003e # original.\u003cspan class=\"hljs-property\"\u003esql\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBash는 부분 문자열을 대체하는 데 유용한 내장 구문도 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#!\u003cspan class=\"hljs-regexp\"\u003e/bin/\u003c/span\u003ebash\n\nstr=\u003cspan class=\"hljs-string\"\u003e\"obin-linux_x64_bin\"\u003c/span\u003e\n\necho \u003cspan class=\"hljs-string\"\u003e\"${str/x64/armhf}\"\u003c/span\u003e # obin-linux_armhf_bin\necho \u003cspan class=\"hljs-string\"\u003e\"${str/bin/dist}\"\u003c/span\u003e # odist-linux_x64_bin\necho \u003cspan class=\"hljs-string\"\u003e\"${str//bin/dist}\"\u003c/span\u003e # odist-linux_x64_dist\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e일부 문자열(예: 파일 이름, 경로 등)을 작업할 때는 문자열의 접두사와 접미사를 대체해야 할 수도 있습니다. 파일 확장자를 다른 확장자로 바꾸는 것이 좋은 예시입니다. 다음 예시를 살펴보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-meta\"\u003e#!/bin/bash\u003c/span\u003e\n\nstr=\u003cspan class=\"hljs-string\"\u003e\"db_config_backup.zip\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e${str/%.zip/.conf}\u003c/span\u003e\"\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e# db_config_backup.conf\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e${str/#db/settings}\u003c/span\u003e\"\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e# settings_config_backup.zip\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 부분 문자열 대체 예시에서 일치시키기 위해 정확한 부분 문자열 세그먼트를 사용했지만, 다음과 같이 '*' 와일드카드 문자를 사용하여 부분 문자열을 사용할 수도 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-meta\"\u003e#!/bin/bash\u003c/span\u003e\n\nstr=\u003cspan class=\"hljs-string\"\u003e\"db_config_backup.zip\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e${str/%.*/.bak}\u003c/span\u003e\"\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e# db_config_backup.bak\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e${str/#*_/new}\u003c/span\u003e\"\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e# newbackup.zip\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 방법은 정확한 부분 문자열을 모를 때 도움이 됩니다.\u003c/p\u003e\n\u003ch1\u003e정규 표현식 일치, 추출 및 치환\u003c/h1\u003e\n\u003cp\u003e이미 많은 유닉스 또는 GNU/Linux 사용자들이 알고 있는 대로, grep과 sed를 사용하여 정규 표현식 기반 텍스트 검색이 가능합니다. sed는 우리에게 정규 표현식 치환을 도와줍니다. 당신은 내장된 Bash 정규 표현식 기능을 사용하여 이러한 외부 이진 파일보다 빠르게 텍스트 처리를 처리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음의 코드 스니펫에서 보여지는 것처럼, if 조건문과 =~ 연산자를 사용하여 정규 표현식 일치를 수행할 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#!\u003cspan class=\"hljs-regexp\"\u003e/bin/\u003c/span\u003ebash\n\nstr=\u003cspan class=\"hljs-string\"\u003e\"db_backup_2003.zip\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e [[ $str =~ \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]+ ]]; then\n    echo \u003cspan class=\"hljs-string\"\u003e\"regex_matched\"\u003c/span\u003e\nfi\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 원하시면 if 문을 인라인 조건문으로 바꿀 수도 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[[ $str =~ \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]+ ]] \u0026#x26;\u0026#x26; echo \u003cspan class=\"hljs-string\"\u003e\"regex_matched\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBash 해석기가 정규 표현식을 찾은 후에는 일반적으로 모든 일치 항목을 BASH_REMATCH 쉘 변수에 저장합니다. 이 변수는 읽기 전용 배열이며, 전체 일치 데이터를 첫 번째 인덱스에 저장합니다. 서브 패턴을 사용하는 경우, Bash는 그에 해당하는 일치 항목을 다른 인덱스에 차례대로 보관합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#!\u003cspan class=\"hljs-regexp\"\u003e/bin/\u003c/span\u003ebash\n\nstr=\u003cspan class=\"hljs-string\"\u003e\"db_backup_2003.zip\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e [[ $str =~ (\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e])(.*)$ ]]; then\n    echo \u003cspan class=\"hljs-string\"\u003e\"${BASH_REMATCH[0]}\"\u003c/span\u003e # \u003cspan class=\"hljs-number\"\u003e2003.\u003c/span\u003ezip\n    echo \u003cspan class=\"hljs-string\"\u003e\"${BASH_REMATCH[1]}\"\u003c/span\u003e # \u003cspan class=\"hljs-number\"\u003e2003\u003c/span\u003e\n    echo \u003cspan class=\"hljs-string\"\u003e\"${BASH_REMATCH[2]}\"\u003c/span\u003e # .\u003cspan class=\"hljs-property\"\u003ezip\u003c/span\u003e\nfi\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이전에 substring matching을 wildcard와 함께 사용했던 것을 기억하시나요? 비슷하게, 다음 예시에서 보여지는 것처럼 파라미터 확장 내에서 regex 정의를 사용할 수 있습니다.:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#!\u003cspan class=\"hljs-regexp\"\u003e/bin/\u003c/span\u003ebash\n\nstr=\u003cspan class=\"hljs-string\"\u003e\"db_backup_2003.zip\"\u003c/span\u003e\nre=\u003cspan class=\"hljs-string\"\u003e\"200[0-3].zip\"\u003c/span\u003e\n\necho \u003cspan class=\"hljs-string\"\u003e\"${str/$re/new}.bak\"\u003c/span\u003e # db_backup_new.\u003cspan class=\"hljs-property\"\u003ebak\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eSubstring Removal Techniques\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e자주 텍스트 처리 요구 사항에서는 원하는 부분 문자열을 제거하여 텍스트 세그먼트를 사전 처리해야 할 때가 있습니다. 예를 들어, v 접두사와 일부 빌드 번호를 포함한 버전 번호를 추출하고 주 버전 번호를 찾으려면 일부 부분 문자열을 제거해야 합니다. 똑같은 부분 문자열 교체 구문을 사용할 수 있지만, 문자열 제거를 위해 교체 문자열 매개변수를 생략할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#!\u003cspan class=\"hljs-regexp\"\u003e/bin/\u003c/span\u003ebash\n\nstr=\u003cspan class=\"hljs-string\"\u003e\"ver5.02-2224.e2\"\u003c/span\u003e\n\nver=\u003cspan class=\"hljs-string\"\u003e\"${str#ver}\"\u003c/span\u003e\necho $ver # \u003cspan class=\"hljs-number\"\u003e5.02\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e2224.e2\u003c/span\u003e\n\nmaj=\u003cspan class=\"hljs-string\"\u003e\"${ver/.*}\"\u003c/span\u003e\necho $maj # \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 예제에서는 정확한 부분 문자열과 와일드카드를 사용하여 부분 문자열을 제거했지만, 정규 표현식을 사용할 수도 있습니다. 과도한 문자 없이 깔끔한 버전 번호를 추출하는 방법을 확인해보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#!\u003cspan class=\"hljs-regexp\"\u003e/bin/\u003c/span\u003ebash\n\nstr=\u003cspan class=\"hljs-string\"\u003e\"ver5.02-2224_release\"\u003c/span\u003e\n\nver=\u003cspan class=\"hljs-string\"\u003e\"${str//[a-z_]}\"\u003c/span\u003e\necho $ver # \u003cspan class=\"hljs-number\"\u003e5.02\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e2224\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e대 소문자 변환 및 대 소문자 기반 변수\u003c/h1\u003e\n\u003cp\u003e심지어 표준 C 언어에는 문자의 대 소문자를 변환하는 함수가 있습니다. 대부분의 현대적인 프로그래밍 언어들은 대소문자 변환을 위한 내장 함수를 제공합니다. 셸 스크립트 언어인 Bash는 대소문자 변환을 위한 함수를 제공하지는 않지만, 매개변수 확장과 변수 선언을 통해 대소문자 변환 기능을 제공합니다.\u003c/p\u003e\n\u003cp\u003e다음 예제를 살펴보세요. 이 예제는 글자의 대소문자를 변환합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-meta\"\u003e#!/bin/bash\u003c/span\u003e\n\nstr=\u003cspan class=\"hljs-string\"\u003e\"안녕 Bash!\"\u003c/span\u003e\n\nlower=\u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e${str,,}\u003c/span\u003e\"\u003c/span\u003e\nupper=\u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e${str^^}\u003c/span\u003e\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003e$lower\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e# 안녕 bash!\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003e$upper\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e# 안녕 BASH!\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음처럼 특정 문자열의 첫 글자만 대문자 또는 소문자로 변경할 수도 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#!\u003cspan class=\"hljs-regexp\"\u003e/bin/\u003c/span\u003ebash\n\nver1=\u003cspan class=\"hljs-string\"\u003e\"V2.0-release\"\u003c/span\u003e\nver2=\u003cspan class=\"hljs-string\"\u003e\"v4.0-release\"\u003c/span\u003e\n\necho \u003cspan class=\"hljs-string\"\u003e\"${ver1,}\"\u003c/span\u003e # v2\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e-release\necho \u003cspan class=\"hljs-string\"\u003e\"${ver2^}\"\u003c/span\u003e # \u003cspan class=\"hljs-variable constant_\"\u003eV4\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e-release\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e만약 특정 변수를 엄격하게 대문자 또는 소문자로 만들어야 할 경우에는 매번 케이스 변환 함수를 실행할 필요가 없습니다. 대신, 다음 예시와 같이 내장된 declare 명령을 사용하여 특정 변수에 케이스 속성을 추가할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#!\u003cspan class=\"hljs-regexp\"\u003e/bin/\u003c/span\u003ebash\n\ndeclare -l ver1\ndeclare -u ver2\n\nver1=\u003cspan class=\"hljs-string\"\u003e\"V4.02.2\"\u003c/span\u003e\nver2=\u003cspan class=\"hljs-string\"\u003e\"v2.22.1\"\u003c/span\u003e\n\necho $ver1 # v4\u003cspan class=\"hljs-number\"\u003e.02\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.2\u003c/span\u003e\necho $ver2 # \u003cspan class=\"hljs-variable constant_\"\u003eV2\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.22\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 ver1 및 ver2 변수는 선언 시 case 속성을 받기 때문에 특정 변수에 값을 할당할 때마다 Bash는 변수 속성을 기반으로 텍스트 case를 변환합니다.\u003c/p\u003e\n\u003ch1\u003e문자열 분할 (문자열을 배열로 변환하기)\u003c/h1\u003e\n\u003cp\u003eBash는 declare 내장을 사용하여 색인 배열과 연관 배열을 정의할 수 있습니다. 대부분의 범용 프로그래밍 언어는 문자열 객체의 분할 메서드나 표준 라이브러리 함수를 통해 분할 기능을 제공합니다 (예: Go의 strings.Split 함수). Bash에서는 다양한 방법으로 문자열을 분할하고 배열을 생성할 수 있습니다. 예를 들어 필요한 구분 기호를 IFS로 변경하고 read 내장을 사용할 수 있습니다. 또는 tr 명령어를 루프와 함께 사용하여 배열을 구성할 수도 있습니다. 내장 매개변수 확장을 사용하는 방법도 있습니다. Bash에서는 문자열을 분할하는 다양한 방법이 있습니다.\u003c/p\u003e\n\u003cp\u003eIFS와 read를 사용하는 것은 문자열을 분할하는 가장 간단하고 오류가 적은 방법 중 하나입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-meta\"\u003e#!/bin/bash\u003c/span\u003e\n\nstr=\u003cspan class=\"hljs-string\"\u003e\"C,C++,JavaScript,Python,Bash\"\u003c/span\u003e\n\nIFS=\u003cspan class=\"hljs-string\"\u003e','\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eread\u003c/span\u003e -ra arr \u0026#x3C;\u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e$str\u003c/span\u003e\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e${#arr[@]}\u003c/span\u003e\"\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e# 5\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e${arr[0]}\u003c/span\u003e\"\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e# C\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e${arr[4]}\u003c/span\u003e\"\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e# Bash\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 코드 스니펫은 쉼표를 구분자로 사용하며 read 내장 명령어를 사용하여 IFS를 기반으로 배열을 생성합니다.\u003c/p\u003e\n\u003cp\u003eread를 사용하지 않고 쉽게 분할할 수 있는 방법이 있더라도, 숨겨진 문제가 없는지 확인해야 합니다. 예를 들어, 다음 분할 구현은 매우 간단하지만 * (현재 디렉토리의 내용으로 확장)을 요소로 포함하고 구분 기호로 공백을 사용하는 경우에 작동하지 않습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e\u003cspan class=\"hljs-meta\"\u003e#!/bin/bash\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 경고: 이 코드에는 여러 숨겨진 문제가 있습니다.\u003c/span\u003e\n\nstr=\u003cspan class=\"hljs-string\"\u003e\"C,Bash,*\"\u003c/span\u003e\n\narr=(\u003cspan class=\"hljs-variable\"\u003e${str//,/ }\u003c/span\u003e)\n\n\u003cspan class=\"hljs-built_in\"\u003eecho\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-variable\"\u003e${#arr[@]}\u003c/span\u003e\"\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e# 현재 디렉토리의 내용이 포함되어 있음\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e지금까지 읽어 주셔서 감사합니다.\u003c/p\u003e\n\u003ch1\u003e레벨 업 코딩\u003c/h1\u003e\n\u003cp\u003e우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 마지막으로 하고 가기 전에:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e👏 이야기에 박수를 보내고 저자를 팔로우하세요 👉\u003c/li\u003e\n\u003cli\u003e📰 Level Up Coding 게시물에서 더 많은 콘텐츠 확인하기\u003c/li\u003e\n\u003cli\u003e💰 무료 코딩 면접 코스 ⇒ 코스 보기\u003c/li\u003e\n\u003cli\u003e🔔 팔로우하기: Twitter | LinkedIn | 뉴스레터\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e🚀👉 Level Up 팀의 멤버가 되어 멋진 직업을 찾아보세요\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>