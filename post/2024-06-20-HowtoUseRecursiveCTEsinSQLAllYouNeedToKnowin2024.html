<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>2024년을 위한 SQL에서 재귀 CTE 사용 방법 알아야 할 모든 것 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="2024년을 위한 SQL에서 재귀 CTE 사용 방법 알아야 할 모든 것 | itposting" data-gatsby-head="true"/><meta property="og:title" content="2024년을 위한 SQL에서 재귀 CTE 사용 방법 알아야 할 모든 것 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024" data-gatsby-head="true"/><meta name="twitter:title" content="2024년을 위한 SQL에서 재귀 CTE 사용 방법 알아야 할 모든 것 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 15:40" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-0fd008072af5a644.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_buildManifest.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">2024년을 위한 SQL에서 재귀 CTE 사용 방법 알아야 할 모든 것</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="2024년을 위한 SQL에서 재귀 CTE 사용 방법 알아야 할 모든 것" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>데이터 과학</h2>
<p><img src="/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_0.png" alt="이미지"></p>
<p><img src="/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_1.png" alt="이미지"></p>
<p>공통 테이블 표현식인 CTE는 SQL에서 가장 강력하고 널리 사용되는 도구 중 하나입니다!</p>
<p>CTE(공통 테이블 식)를 사용하면 복잡한 쿼리를 간소화하고 가독성이 좋고 유지보수가 쉬운 SQL 쿼리를 작성할 수 있습니다.</p>
<p>CTE를 사용하면 쿼리 결과에서 임시 테이블을 생성할 수 있습니다. 사실, 복잡한 서브쿼리를 간단한 CTE로 분해할 수도 있어요.</p>
<p>CTE에 대해 더 알아보려면 제 이전 이야기 중 하나를 읽어보세요.</p>
<p>그러나 CTE를 더 강력하게 만드는 것은 계층 데이터를 분석하는 능력입니다. CTE는 재귀를 지원하여 서로 다른 엔티티 간의 관계를 분석하기 위해 자신을 참조할 수 있어요.</p>
<p>간단한 시나리오로 중첩된 인형 예시를 들어보겠습니다 —</p>
<p><img src="/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_2.png" alt="인형 사진"></p>
<p>세트 안에 몇 개의 인형이 있는지 정확히 알고 싶을 때, 동일한 세트를 계속해서 살펴봐야 하며 가장 작은 인형을 찾아야 합니다. 가장 작은 인형은 내부에 더 작은 인형이 없는 인형으로, 이것이 세트 내 인형 수를 세는 중단 조건이 됩니다.</p>
<p>재귀 공통 테이블 표현식(CTE)은 정확히 동일한 논리를 따르며 여러 레이어가 서로 아래에 존재하는 데이터 집합을 탐색하는 데 도움을 줍니다. 재귀 CTE의 각 반복에서는 특정 중단 조건을 만날 때까지 데이터 구조의 한 수준을 탐색합니다.</p>
<p>현실에서는 소셜 미디어 네트워크(예: 페이스북의 친구 목록), 슬랙의 채팅 스레드, 회사의 직원 구조(고위 경영진부터 개별 직원까지)와 같은 계층적 데이터 유형을 볼 수 있습니다. 재귀 CTE는 이러한 데이터를 다룰 때 매우 유용할 수 있습니다.</p>
<h1>재귀 CTE의 기본 사항</h1>
<p>모든 재귀 CTE에는 두 가지 주요 부분이 포함됩니다 —</p>
<ul>
<li>앵커 부분 — 주 쿼리 또는 초기 쿼리라고 할 수 있습니다. 따라서 재귀 부분에서 참조할 수 있는 시작점입니다.</li>
<li>재귀 부분 — 재귀 CTE의 두 번째 부분으로, 앵커 부분을 참조하고 일정 조건을 충족하는 한 반복적으로 실행됩니다. 따라서 한 번 반복의 결과가 다음 반복의 입력으로 사용됩니다.</li>
</ul>
<p>위의 두 가지 기본 내용을 처음에 이해하지 못해도 전혀 괜찮아요!</p>
<p>다음 두 사용 사례를 탐험하면서 예제로 설명해드릴 거예요. 이 두 가지 사용 사례에서 재귀 CTE를 사용할 수 있어요.</p>
<h1>계층적 데이터 다루기</h1>
<p>계층 데이터는 이름에서 알 수 있듯이 트리 형식이거나 부모-자식 관계로 구성된 데이터를 포함하고 있어요.</p>
<p>기관에서는 관리자 - 직원 또는 폴더 - 하위 폴더 구조와 같은 데이터 유형을 일반적으로 관찰할 수 있습니다.</p>
<p>따라서 계층 구조에서 항목은 그 아래에 있는 모든 다른 항목의 '상위 항목'입니다.</p>
<p>재귀 공통 테이블 식(CTE)은 이러한 종류의 데이터에서 통찰력을 얻는 데 매우 유용할 수 있습니다. 자기 자신을 참조하는 CTE를 활용하여 전체 계층 구조를 검색할 수 있습니다.</p>
<p>이 개념을 이해하는 데 가장 좋은 예시를 살펴보겠습니다. 조직적인 계층 구조의 매우 흔한 예시를 살펴보죠.</p>
<p>아래 표에 표시된 대로 직원 테이블을 가지고 있고 각 목록이 관리자부터 직원까지의 경로를 나타내는 쉼표로 구분된 목록을 얻고 싶다고 가정해보세요.</p>
<p><img src="/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_3.png" alt="Employee Table"></p>
<p>다음 쿼리를 사용하여 이 입력 데이터를 다시 생성할 수 있습니다.</p>
<p>MySQL Workbench에 있는 analyticswithsuraj는 스키마 이름입니다. 여러분의 스키마로 대체할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">DROP</span> <span class="hljs-variable constant_">TABLE</span> <span class="hljs-variable constant_">IF</span> <span class="hljs-variable constant_">EXISTS</span> analyticswithsuraj.<span class="hljs-property">employee</span>;
<span class="hljs-variable constant_">CREATE</span> <span class="hljs-variable constant_">TABLE</span> analyticswithsuraj.<span class="hljs-property">employee</span> (
    <span class="hljs-title class_">EmployeeID</span> <span class="hljs-title function_">VARCHAR</span>(<span class="hljs-number">10</span>),
    <span class="hljs-title class_">EmployeeName</span> <span class="hljs-title function_">VARCHAR</span>(<span class="hljs-number">50</span>),
    <span class="hljs-title class_">ManagerID</span> <span class="hljs-title function_">VARCHAR</span>(<span class="hljs-number">10</span>)
);

-- <span class="hljs-title class_">Insert</span> sample data
<span class="hljs-variable constant_">INSERT</span> <span class="hljs-variable constant_">INTO</span> analyticswithsuraj.<span class="hljs-property">employee</span> <span class="hljs-variable constant_">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">'John'</span>, <span class="hljs-variable constant_">NULL</span>);
<span class="hljs-variable constant_">INSERT</span> <span class="hljs-variable constant_">INTO</span> analyticswithsuraj.<span class="hljs-property">employee</span> <span class="hljs-variable constant_">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">'Jane'</span>, <span class="hljs-number">1</span>);
<span class="hljs-variable constant_">INSERT</span> <span class="hljs-variable constant_">INTO</span> analyticswithsuraj.<span class="hljs-property">employee</span> <span class="hljs-variable constant_">VALUES</span> (<span class="hljs-number">3</span>, <span class="hljs-string">'Bob'</span>, <span class="hljs-number">1</span>);
<span class="hljs-variable constant_">INSERT</span> <span class="hljs-variable constant_">INTO</span> analyticswithsuraj.<span class="hljs-property">employee</span> <span class="hljs-variable constant_">VALUES</span> (<span class="hljs-number">4</span>, <span class="hljs-string">'Alice'</span>, <span class="hljs-number">2</span>);
<span class="hljs-variable constant_">INSERT</span> <span class="hljs-variable constant_">INTO</span> analyticswithsuraj.<span class="hljs-property">employee</span> <span class="hljs-variable constant_">VALUES</span> (<span class="hljs-number">5</span>, <span class="hljs-string">'Charlie'</span>, <span class="hljs-number">2</span>);
<span class="hljs-variable constant_">INSERT</span> <span class="hljs-variable constant_">INTO</span> analyticswithsuraj.<span class="hljs-property">employee</span> <span class="hljs-variable constant_">VALUES</span> (<span class="hljs-number">6</span>, <span class="hljs-string">'David'</span>, <span class="hljs-number">3</span>);
<span class="hljs-variable constant_">INSERT</span> <span class="hljs-variable constant_">INTO</span> analyticswithsuraj.<span class="hljs-property">employee</span> <span class="hljs-variable constant_">VALUES</span> (<span class="hljs-number">7</span>, <span class="hljs-string">'Eva'</span>, <span class="hljs-number">3</span>);
</code></pre>
<p>문제에 돌아가서... 완전한 해결책을 보여드릴게요. 그리고 그 후에 설명을 따라 읽어볼게요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">WITH</span> <span class="hljs-variable constant_">RECURSIVE</span> <span class="hljs-title class_">RecursiveCTE</span> <span class="hljs-variable constant_">AS</span> (
    <span class="hljs-variable constant_">SELECT</span>
        <span class="hljs-title class_">EmployeeID</span>,
        <span class="hljs-title class_">EmployeeName</span>,
        <span class="hljs-title class_">ManagerID</span>,
        <span class="hljs-title class_">EmployeeName</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-title class_">Path</span> -- 초기 경로는 직원의 <span class="hljs-variable constant_">ID</span>입니다
    <span class="hljs-variable constant_">FROM</span>
        analyticswithsuraj.<span class="hljs-property">employee</span>
    <span class="hljs-variable constant_">WHERE</span>
        <span class="hljs-title class_">ManagerID</span> <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NULL</span> -- 앵커 부분

    <span class="hljs-variable constant_">UNION</span> <span class="hljs-variable constant_">ALL</span>

    <span class="hljs-variable constant_">SELECT</span>
        e.<span class="hljs-property">EmployeeID</span>,
        e.<span class="hljs-property">EmployeeName</span>,
        e.<span class="hljs-property">ManagerID</span>,
        <span class="hljs-title function_">concat_ws</span>(<span class="hljs-string">','</span>, rc.<span class="hljs-property">Path</span>, e.<span class="hljs-property">EmployeeName</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-title class_">Path</span>
    <span class="hljs-variable constant_">FROM</span>
        analyticswithsuraj.<span class="hljs-property">employee</span> e
    <span class="hljs-variable constant_">JOIN</span>
        <span class="hljs-title class_">RecursiveCTE</span> rc <span class="hljs-variable constant_">ON</span> e.<span class="hljs-property">ManagerID</span> = rc.<span class="hljs-property">EmployeeID</span> -- 재귀 부분
)
</code></pre>
<p>MySQL Workbench에서 재귀 CTE를 작성하려면 CTE 이름 앞에 RECURSIVE 키워드를 입력해야 합니다.</p>
<p>Caveat: 재귀 CTE의 기본 개념을 읽으신다면, 솔루션은 두 부분으로 이뤄져야 합니다.</p>
<p>첫 번째는 시작점인 앵커 부분입니다. 재귀 쿼리에서 참조할 수 있는 시작점으로, 아래와 같이 간단한 SELECT 문으로 표현됩니다.</p>
<pre><code class="hljs language-js">    <span class="hljs-variable constant_">SELECT</span>
        <span class="hljs-title class_">EmployeeID</span>,
        <span class="hljs-title class_">EmployeeName</span>,
        <span class="hljs-title class_">ManagerID</span>,
        <span class="hljs-title class_">EmployeeName</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-title class_">Path</span> -- 초기 경로는 직원의 <span class="hljs-variable constant_">ID</span>만 포함합니다
    <span class="hljs-variable constant_">FROM</span>
        analyticswithsuraj.<span class="hljs-property">employee</span>
    <span class="hljs-variable constant_">WHERE</span>
        <span class="hljs-title class_">ManagerID</span> <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NULL</span> -- 앵커 부분
</code></pre>
<p>여기서는 직원의 전체 계층 구조를 저장할 추가적인 Path 열을 생성합니다.</p>
<p>이 앵커 쿼리는 항상 ManagerID가 NULL 인 직원만 포함합니다. 즉, 그들 위에 매니저가 없는 직원만을 선택합니다.</p>
<p>재귀 CTE의 두 번째 부분은 재귀 부분으로, 직원 이름을 선택하고 Path 열의 값을 업데이트하여 아래와 같이 쉼표로 구분된 경로를 만듭니다.</p>
<pre><code class="hljs language-js">    <span class="hljs-variable constant_">UNION</span> <span class="hljs-variable constant_">ALL</span>

    <span class="hljs-variable constant_">SELECT</span>
        e.<span class="hljs-property">EmployeeID</span>,
        e.<span class="hljs-property">EmployeeName</span>,
        e.<span class="hljs-property">ManagerID</span>,
        <span class="hljs-title function_">concat_ws</span>(<span class="hljs-string">', '</span>, rc.<span class="hljs-property">Path</span>, e.<span class="hljs-property">EmployeeName</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-title class_">Path</span>
    <span class="hljs-variable constant_">FROM</span>
        analyticswithsuraj.<span class="hljs-property">employee</span> e
    <span class="hljs-variable constant_">JOIN</span>
        <span class="hljs-title class_">RecursiveCTE</span> rc <span class="hljs-variable constant_">ON</span> e.<span class="hljs-property">ManagerID</span> = rc.<span class="hljs-property">EmployeeID</span> -- <span class="hljs-title class_">Recursive</span> part
</code></pre>
<p>보시다시피 이 재귀 부분은 원래의 직원 테이블에서 데이터를 조회하고 안에 쓰여진 CTE와 조인합니다.</p>
<p>UNION ALL은 앵커 쿼리와 순환 쿼리의 결과를 결합하는 데 사용됩니다.</p>
<p>최종적으로는 이 순환 CTE를 간단한 SELECT 문으로 쿼리할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span>
    <span class="hljs-title class_">EmployeeID</span>,
    <span class="hljs-title class_">EmployeeName</span>,
    <span class="hljs-title class_">ManagerID</span>,
    <span class="hljs-title class_">Path</span>
<span class="hljs-variable constant_">FROM</span>
    <span class="hljs-title class_">RecursiveCTE</span>;
</code></pre>
<p><img src="/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_4.png" alt="이미지"></p>
<p>결과적으로 각 레코드마다 직원의 완전한 계층 구조를 볼 수 있습니다. 여기에는 John이 최종 관리자로 나타나며 그의 상사가 없는 것을 나타내고, Jane과 Bob이 그의 직속 보고자들이라는 것을 보여줍니다.</p>
<p>입력 테이블에서 4번째 레코드에서 Jane이 Alice의 관리자이고 John이 Jane의 관리자인 것을 볼 수 있으므로 Alice의 전체 계층은 'John, Jane, Alice'입니다.</p>
<p>그러나 데이터는 단순한 계층보다 복잡할 수 있습니다. Facebook 친구 목록이나 다른 소셜 네트워킹 데이터와 같이 요롯한 경우도 있습니다. 재귀 CTE가 어떻게 활용될 수 있는지 살펴보겠습니다.</p>
<h1>네트워크 데이터 처리하기</h1>
<p>네트워크 데이터는 이름에서 알 수 있듯이 사물, 엔티티 및 사람들의 네트워크에 대한 것입니다. 아래 그림에서 보이는 것처럼 네트워크 데이터를 노드(블록)와 노드를 연결하는 엣지(선)로 시각화할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_5.png" alt="그림"></p>
<p>노드는 사용자 또는 엔티티를 나타내며, 엣지는 그들 사이의 관계를 나타냅니다.</p>
<p>간단히 말해서, 두 노드 사이에 엣지(선)가 있다면, 두 노드는 직접적으로 서로 연결되어있다는 것을 의미합니다.</p>
<p>아래는 테이블 <code>network_connections</code>에 표시된 11명의 친구들 중 파올로와 연결된 사람들을 분석하고 있습니다. 파올로의 친구와 친구의 친구들을 파악하고 싶습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">DROP</span> <span class="hljs-variable constant_">TABLE</span> <span class="hljs-variable constant_">IF</span> <span class="hljs-variable constant_">EXISTS</span> alldata.<span class="hljs-property">network_connections</span>;
<span class="hljs-variable constant_">CREATE</span> <span class="hljs-variable constant_">TABLE</span> alldata.<span class="hljs-property">network_connections</span> (
    source_node <span class="hljs-title function_">VARCHAR</span>(<span class="hljs-number">50</span>),
    target_node <span class="hljs-title function_">VARCHAR</span>(<span class="hljs-number">50</span>)
);

<span class="hljs-variable constant_">INSERT</span> <span class="hljs-variable constant_">INTO</span> alldata.<span class="hljs-property">network_connections</span> (source_node, target_node) <span class="hljs-variable constant_">VALUES</span>
(<span class="hljs-string">'Paolo'</span>, <span class="hljs-string">'David'</span>),
(<span class="hljs-string">'Paolo'</span>, <span class="hljs-string">'Anna'</span>),
(<span class="hljs-string">'David'</span>, <span class="hljs-string">'Mark'</span>),
(<span class="hljs-string">'Anna'</span>, <span class="hljs-string">'Peter'</span>),
(<span class="hljs-string">'Samar'</span>, <span class="hljs-string">'Patrik'</span>),
(<span class="hljs-string">'Mark'</span>, <span class="hljs-string">'Vivan'</span>),
(<span class="hljs-string">'Patrik'</span>, <span class="hljs-string">'Maya'</span>),
(<span class="hljs-string">'Julia'</span>, <span class="hljs-string">'Robert'</span>);
</code></pre>
<p>알다타는 MySQL Workbench에서의 스키마 이름입니다. 이를 여러분의 스키마 이름으로 바꿔 사용하실 수 있습니다.</p>
<p>이전 계층 데이터의 예제에서 이미 앵커 부분과 재귀 부분을 설명했으니, 여기서 바로 솔루션으로 넘어가겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">WITH</span> <span class="hljs-variable constant_">RECURSIVE</span> <span class="hljs-title class_">NetworkCTE</span> <span class="hljs-variable constant_">AS</span> (
    -- 시작 노드를 선택하는 앵커 부분
    <span class="hljs-variable constant_">SELECT</span> source_node,
            target_node
    <span class="hljs-variable constant_">FROM</span> network_connections
    <span class="hljs-variable constant_">WHERE</span> source_node = <span class="hljs-string">'Paolo'</span> -- 다른 사람의 네트워크를 보려면 여기를 변경하세요
    
    <span class="hljs-variable constant_">UNION</span> <span class="hljs-variable constant_">ALL</span>
    
    -- 연결된 노드를 선택하는 재귀 부분
    <span class="hljs-variable constant_">SELECT</span> nc.<span class="hljs-property">source_node</span>,
            nc.<span class="hljs-property">target_node</span>
    <span class="hljs-variable constant_">FROM</span> network_connections nc
    <span class="hljs-variable constant_">JOIN</span> <span class="hljs-title class_">NetworkCTE</span> n <span class="hljs-variable constant_">ON</span> nc.<span class="hljs-property">source_node</span> = n.<span class="hljs-property">target_node</span>
)

<span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> <span class="hljs-title class_">NetworkCTE</span>;
</code></pre>
<p>코드에서 설명한 대로, 앵커 부분은 먼저 모든 레코드를 가져와 Paolo를 소스 노드로 하는 것 즉, Paolo의 직접적인 친구들을 모두 가져옵니다. 반면 재귀 부분은 Paolo의 친구의 친구를 모두 가져옵니다.</p>
<p>그래서 Paolo의 네트워크를 최종적으로 다음과 같이 볼 수 있습니다.</p>
<p><img src="/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_7.png" alt="image"></p>
<p>네트워크 데이터 분석의 다른 사용 사례들은 공급망 산업에서 서로 다른 개체간의 의존 관계를 분석하거나 재무 거래 분석에 계정을 통해 자금 이동을 추적하는 데 사용될 수 있습니다.</p>
<p>더 많은 재귀 CTE를 효과적으로 사용할 수 있는 예시가 있다면 댓글에 언급하지 않을래요?</p>
<p>이 글이 유용하고 정보가 풍부하게 느껴졌으면 좋겠어요!</p>
<p>공통 테이블 표현식(CTE)은 SQL에서 널리 사용되며 재귀 CTE는 특수한 경우입니다. 이 간편한 글에서 재귀 CTE를 사용하여 계층적 및 네트워크 데이터를 다루는 방법을 알아보았어요.</p>
<p>여기서 실제 예시를 통해 배운 것처럼, 특정 시나리오에서 SQL에서 재귀 CTE가 게임 체인저가 될 수 있다는 점을 알게 되었어요. 동일한 내용에 대한 다른 통찰이 있으면 댓글로 자유롭게 공유해주시기 바랍니다!</p>
<p>💡 저를 팔로우하고 제 이메일 목록에 가입하여 데이터 과학, SQL, Python 및 취업 검색 팁에 관한 다른 글을 더 이상 놓치지 않도록 해보세요!</p>
<p>읽어 주셔서 감사합니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"2024년을 위한 SQL에서 재귀 CTE 사용 방법 알아야 할 모든 것","description":"","date":"2024-06-20 15:40","slug":"2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024","content":"\n\n## 데이터 과학\n\n![이미지](/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_0.png)\n\n![이미지](/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_1.png)\n\n공통 테이블 표현식인 CTE는 SQL에서 가장 강력하고 널리 사용되는 도구 중 하나입니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCTE(공통 테이블 식)를 사용하면 복잡한 쿼리를 간소화하고 가독성이 좋고 유지보수가 쉬운 SQL 쿼리를 작성할 수 있습니다.\n\nCTE를 사용하면 쿼리 결과에서 임시 테이블을 생성할 수 있습니다. 사실, 복잡한 서브쿼리를 간단한 CTE로 분해할 수도 있어요.\n\nCTE에 대해 더 알아보려면 제 이전 이야기 중 하나를 읽어보세요.\n\n그러나 CTE를 더 강력하게 만드는 것은 계층 데이터를 분석하는 능력입니다. CTE는 재귀를 지원하여 서로 다른 엔티티 간의 관계를 분석하기 위해 자신을 참조할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 시나리오로 중첩된 인형 예시를 들어보겠습니다 —\n\n![인형 사진](/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_2.png)\n\n세트 안에 몇 개의 인형이 있는지 정확히 알고 싶을 때, 동일한 세트를 계속해서 살펴봐야 하며 가장 작은 인형을 찾아야 합니다. 가장 작은 인형은 내부에 더 작은 인형이 없는 인형으로, 이것이 세트 내 인형 수를 세는 중단 조건이 됩니다.\n\n재귀 공통 테이블 표현식(CTE)은 정확히 동일한 논리를 따르며 여러 레이어가 서로 아래에 존재하는 데이터 집합을 탐색하는 데 도움을 줍니다. 재귀 CTE의 각 반복에서는 특정 중단 조건을 만날 때까지 데이터 구조의 한 수준을 탐색합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현실에서는 소셜 미디어 네트워크(예: 페이스북의 친구 목록), 슬랙의 채팅 스레드, 회사의 직원 구조(고위 경영진부터 개별 직원까지)와 같은 계층적 데이터 유형을 볼 수 있습니다. 재귀 CTE는 이러한 데이터를 다룰 때 매우 유용할 수 있습니다.\n\n# 재귀 CTE의 기본 사항\n\n모든 재귀 CTE에는 두 가지 주요 부분이 포함됩니다 —\n\n- 앵커 부분 — 주 쿼리 또는 초기 쿼리라고 할 수 있습니다. 따라서 재귀 부분에서 참조할 수 있는 시작점입니다.\n- 재귀 부분 — 재귀 CTE의 두 번째 부분으로, 앵커 부분을 참조하고 일정 조건을 충족하는 한 반복적으로 실행됩니다. 따라서 한 번 반복의 결과가 다음 반복의 입력으로 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 두 가지 기본 내용을 처음에 이해하지 못해도 전혀 괜찮아요!\n\n다음 두 사용 사례를 탐험하면서 예제로 설명해드릴 거예요. 이 두 가지 사용 사례에서 재귀 CTE를 사용할 수 있어요.\n\n# 계층적 데이터 다루기\n\n계층 데이터는 이름에서 알 수 있듯이 트리 형식이거나 부모-자식 관계로 구성된 데이터를 포함하고 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n기관에서는 관리자 - 직원 또는 폴더 - 하위 폴더 구조와 같은 데이터 유형을 일반적으로 관찰할 수 있습니다.\n\n따라서 계층 구조에서 항목은 그 아래에 있는 모든 다른 항목의 '상위 항목'입니다.\n\n재귀 공통 테이블 식(CTE)은 이러한 종류의 데이터에서 통찰력을 얻는 데 매우 유용할 수 있습니다. 자기 자신을 참조하는 CTE를 활용하여 전체 계층 구조를 검색할 수 있습니다.\n\n이 개념을 이해하는 데 가장 좋은 예시를 살펴보겠습니다. 조직적인 계층 구조의 매우 흔한 예시를 살펴보죠.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 표에 표시된 대로 직원 테이블을 가지고 있고 각 목록이 관리자부터 직원까지의 경로를 나타내는 쉼표로 구분된 목록을 얻고 싶다고 가정해보세요.\n\n![Employee Table](/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_3.png)\n\n다음 쿼리를 사용하여 이 입력 데이터를 다시 생성할 수 있습니다.\n\nMySQL Workbench에 있는 analyticswithsuraj는 스키마 이름입니다. 여러분의 스키마로 대체할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nDROP TABLE IF EXISTS analyticswithsuraj.employee;\nCREATE TABLE analyticswithsuraj.employee (\n    EmployeeID VARCHAR(10),\n    EmployeeName VARCHAR(50),\n    ManagerID VARCHAR(10)\n);\n\n-- Insert sample data\nINSERT INTO analyticswithsuraj.employee VALUES (1, 'John', NULL);\nINSERT INTO analyticswithsuraj.employee VALUES (2, 'Jane', 1);\nINSERT INTO analyticswithsuraj.employee VALUES (3, 'Bob', 1);\nINSERT INTO analyticswithsuraj.employee VALUES (4, 'Alice', 2);\nINSERT INTO analyticswithsuraj.employee VALUES (5, 'Charlie', 2);\nINSERT INTO analyticswithsuraj.employee VALUES (6, 'David', 3);\nINSERT INTO analyticswithsuraj.employee VALUES (7, 'Eva', 3);\n```\n\n문제에 돌아가서... 완전한 해결책을 보여드릴게요. 그리고 그 후에 설명을 따라 읽어볼게요.\n\n```js\nWITH RECURSIVE RecursiveCTE AS (\n    SELECT\n        EmployeeID,\n        EmployeeName,\n        ManagerID,\n        EmployeeName AS Path -- 초기 경로는 직원의 ID입니다\n    FROM\n        analyticswithsuraj.employee\n    WHERE\n        ManagerID IS NULL -- 앵커 부분\n\n    UNION ALL\n\n    SELECT\n        e.EmployeeID,\n        e.EmployeeName,\n        e.ManagerID,\n        concat_ws(',', rc.Path, e.EmployeeName) AS Path\n    FROM\n        analyticswithsuraj.employee e\n    JOIN\n        RecursiveCTE rc ON e.ManagerID = rc.EmployeeID -- 재귀 부분\n)\n```\n\nMySQL Workbench에서 재귀 CTE를 작성하려면 CTE 이름 앞에 RECURSIVE 키워드를 입력해야 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCaveat: 재귀 CTE의 기본 개념을 읽으신다면, 솔루션은 두 부분으로 이뤄져야 합니다.\n\n첫 번째는 시작점인 앵커 부분입니다. 재귀 쿼리에서 참조할 수 있는 시작점으로, 아래와 같이 간단한 SELECT 문으로 표현됩니다.\n\n```js\n    SELECT\n        EmployeeID,\n        EmployeeName,\n        ManagerID,\n        EmployeeName AS Path -- 초기 경로는 직원의 ID만 포함합니다\n    FROM\n        analyticswithsuraj.employee\n    WHERE\n        ManagerID IS NULL -- 앵커 부분\n```\n\n여기서는 직원의 전체 계층 구조를 저장할 추가적인 Path 열을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 앵커 쿼리는 항상 ManagerID가 NULL 인 직원만 포함합니다. 즉, 그들 위에 매니저가 없는 직원만을 선택합니다.\n\n재귀 CTE의 두 번째 부분은 재귀 부분으로, 직원 이름을 선택하고 Path 열의 값을 업데이트하여 아래와 같이 쉼표로 구분된 경로를 만듭니다.\n\n```js\n    UNION ALL\n\n    SELECT\n        e.EmployeeID,\n        e.EmployeeName,\n        e.ManagerID,\n        concat_ws(', ', rc.Path, e.EmployeeName) AS Path\n    FROM\n        analyticswithsuraj.employee e\n    JOIN\n        RecursiveCTE rc ON e.ManagerID = rc.EmployeeID -- Recursive part\n```\n\n보시다시피 이 재귀 부분은 원래의 직원 테이블에서 데이터를 조회하고 안에 쓰여진 CTE와 조인합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUNION ALL은 앵커 쿼리와 순환 쿼리의 결과를 결합하는 데 사용됩니다.\n\n최종적으로는 이 순환 CTE를 간단한 SELECT 문으로 쿼리할 수 있습니다.\n\n```js\nSELECT\n    EmployeeID,\n    EmployeeName,\n    ManagerID,\n    Path\nFROM\n    RecursiveCTE;\n```\n\n![이미지](/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과적으로 각 레코드마다 직원의 완전한 계층 구조를 볼 수 있습니다. 여기에는 John이 최종 관리자로 나타나며 그의 상사가 없는 것을 나타내고, Jane과 Bob이 그의 직속 보고자들이라는 것을 보여줍니다.\n\n입력 테이블에서 4번째 레코드에서 Jane이 Alice의 관리자이고 John이 Jane의 관리자인 것을 볼 수 있으므로 Alice의 전체 계층은 'John, Jane, Alice'입니다.\n\n그러나 데이터는 단순한 계층보다 복잡할 수 있습니다. Facebook 친구 목록이나 다른 소셜 네트워킹 데이터와 같이 요롯한 경우도 있습니다. 재귀 CTE가 어떻게 활용될 수 있는지 살펴보겠습니다.\n\n# 네트워크 데이터 처리하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네트워크 데이터는 이름에서 알 수 있듯이 사물, 엔티티 및 사람들의 네트워크에 대한 것입니다. 아래 그림에서 보이는 것처럼 네트워크 데이터를 노드(블록)와 노드를 연결하는 엣지(선)로 시각화할 수 있습니다.\n\n![그림](/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_5.png)\n\n노드는 사용자 또는 엔티티를 나타내며, 엣지는 그들 사이의 관계를 나타냅니다.\n\n간단히 말해서, 두 노드 사이에 엣지(선)가 있다면, 두 노드는 직접적으로 서로 연결되어있다는 것을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 테이블 `network_connections`에 표시된 11명의 친구들 중 파올로와 연결된 사람들을 분석하고 있습니다. 파올로의 친구와 친구의 친구들을 파악하고 싶습니다.\n\n```js\nDROP TABLE IF EXISTS alldata.network_connections;\nCREATE TABLE alldata.network_connections (\n    source_node VARCHAR(50),\n    target_node VARCHAR(50)\n);\n\nINSERT INTO alldata.network_connections (source_node, target_node) VALUES\n('Paolo', 'David'),\n('Paolo', 'Anna'),\n('David', 'Mark'),\n('Anna', 'Peter'),\n('Samar', 'Patrik'),\n('Mark', 'Vivan'),\n('Patrik', 'Maya'),\n('Julia', 'Robert');\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알다타는 MySQL Workbench에서의 스키마 이름입니다. 이를 여러분의 스키마 이름으로 바꿔 사용하실 수 있습니다.\n\n이전 계층 데이터의 예제에서 이미 앵커 부분과 재귀 부분을 설명했으니, 여기서 바로 솔루션으로 넘어가겠습니다.\n\n```js\nWITH RECURSIVE NetworkCTE AS (\n    -- 시작 노드를 선택하는 앵커 부분\n    SELECT source_node,\n            target_node\n    FROM network_connections\n    WHERE source_node = 'Paolo' -- 다른 사람의 네트워크를 보려면 여기를 변경하세요\n    \n    UNION ALL\n    \n    -- 연결된 노드를 선택하는 재귀 부분\n    SELECT nc.source_node,\n            nc.target_node\n    FROM network_connections nc\n    JOIN NetworkCTE n ON nc.source_node = n.target_node\n)\n\nSELECT * FROM NetworkCTE;\n```\n\n코드에서 설명한 대로, 앵커 부분은 먼저 모든 레코드를 가져와 Paolo를 소스 노드로 하는 것 즉, Paolo의 직접적인 친구들을 모두 가져옵니다. 반면 재귀 부분은 Paolo의 친구의 친구를 모두 가져옵니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 Paolo의 네트워크를 최종적으로 다음과 같이 볼 수 있습니다.\n\n![image](/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_7.png)\n\n네트워크 데이터 분석의 다른 사용 사례들은 공급망 산업에서 서로 다른 개체간의 의존 관계를 분석하거나 재무 거래 분석에 계정을 통해 자금 이동을 추적하는 데 사용될 수 있습니다.\n\n더 많은 재귀 CTE를 효과적으로 사용할 수 있는 예시가 있다면 댓글에 언급하지 않을래요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글이 유용하고 정보가 풍부하게 느껴졌으면 좋겠어요!\n\n공통 테이블 표현식(CTE)은 SQL에서 널리 사용되며 재귀 CTE는 특수한 경우입니다. 이 간편한 글에서 재귀 CTE를 사용하여 계층적 및 네트워크 데이터를 다루는 방법을 알아보았어요.\n\n여기서 실제 예시를 통해 배운 것처럼, 특정 시나리오에서 SQL에서 재귀 CTE가 게임 체인저가 될 수 있다는 점을 알게 되었어요. 동일한 내용에 대한 다른 통찰이 있으면 댓글로 자유롭게 공유해주시기 바랍니다!\n\n💡 저를 팔로우하고 제 이메일 목록에 가입하여 데이터 과학, SQL, Python 및 취업 검색 팁에 관한 다른 글을 더 이상 놓치지 않도록 해보세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e데이터 과학\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e공통 테이블 표현식인 CTE는 SQL에서 가장 강력하고 널리 사용되는 도구 중 하나입니다!\u003c/p\u003e\n\u003cp\u003eCTE(공통 테이블 식)를 사용하면 복잡한 쿼리를 간소화하고 가독성이 좋고 유지보수가 쉬운 SQL 쿼리를 작성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eCTE를 사용하면 쿼리 결과에서 임시 테이블을 생성할 수 있습니다. 사실, 복잡한 서브쿼리를 간단한 CTE로 분해할 수도 있어요.\u003c/p\u003e\n\u003cp\u003eCTE에 대해 더 알아보려면 제 이전 이야기 중 하나를 읽어보세요.\u003c/p\u003e\n\u003cp\u003e그러나 CTE를 더 강력하게 만드는 것은 계층 데이터를 분석하는 능력입니다. CTE는 재귀를 지원하여 서로 다른 엔티티 간의 관계를 분석하기 위해 자신을 참조할 수 있어요.\u003c/p\u003e\n\u003cp\u003e간단한 시나리오로 중첩된 인형 예시를 들어보겠습니다 —\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_2.png\" alt=\"인형 사진\"\u003e\u003c/p\u003e\n\u003cp\u003e세트 안에 몇 개의 인형이 있는지 정확히 알고 싶을 때, 동일한 세트를 계속해서 살펴봐야 하며 가장 작은 인형을 찾아야 합니다. 가장 작은 인형은 내부에 더 작은 인형이 없는 인형으로, 이것이 세트 내 인형 수를 세는 중단 조건이 됩니다.\u003c/p\u003e\n\u003cp\u003e재귀 공통 테이블 표현식(CTE)은 정확히 동일한 논리를 따르며 여러 레이어가 서로 아래에 존재하는 데이터 집합을 탐색하는 데 도움을 줍니다. 재귀 CTE의 각 반복에서는 특정 중단 조건을 만날 때까지 데이터 구조의 한 수준을 탐색합니다.\u003c/p\u003e\n\u003cp\u003e현실에서는 소셜 미디어 네트워크(예: 페이스북의 친구 목록), 슬랙의 채팅 스레드, 회사의 직원 구조(고위 경영진부터 개별 직원까지)와 같은 계층적 데이터 유형을 볼 수 있습니다. 재귀 CTE는 이러한 데이터를 다룰 때 매우 유용할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e재귀 CTE의 기본 사항\u003c/h1\u003e\n\u003cp\u003e모든 재귀 CTE에는 두 가지 주요 부분이 포함됩니다 —\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e앵커 부분 — 주 쿼리 또는 초기 쿼리라고 할 수 있습니다. 따라서 재귀 부분에서 참조할 수 있는 시작점입니다.\u003c/li\u003e\n\u003cli\u003e재귀 부분 — 재귀 CTE의 두 번째 부분으로, 앵커 부분을 참조하고 일정 조건을 충족하는 한 반복적으로 실행됩니다. 따라서 한 번 반복의 결과가 다음 반복의 입력으로 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위의 두 가지 기본 내용을 처음에 이해하지 못해도 전혀 괜찮아요!\u003c/p\u003e\n\u003cp\u003e다음 두 사용 사례를 탐험하면서 예제로 설명해드릴 거예요. 이 두 가지 사용 사례에서 재귀 CTE를 사용할 수 있어요.\u003c/p\u003e\n\u003ch1\u003e계층적 데이터 다루기\u003c/h1\u003e\n\u003cp\u003e계층 데이터는 이름에서 알 수 있듯이 트리 형식이거나 부모-자식 관계로 구성된 데이터를 포함하고 있어요.\u003c/p\u003e\n\u003cp\u003e기관에서는 관리자 - 직원 또는 폴더 - 하위 폴더 구조와 같은 데이터 유형을 일반적으로 관찰할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e따라서 계층 구조에서 항목은 그 아래에 있는 모든 다른 항목의 '상위 항목'입니다.\u003c/p\u003e\n\u003cp\u003e재귀 공통 테이블 식(CTE)은 이러한 종류의 데이터에서 통찰력을 얻는 데 매우 유용할 수 있습니다. 자기 자신을 참조하는 CTE를 활용하여 전체 계층 구조를 검색할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 개념을 이해하는 데 가장 좋은 예시를 살펴보겠습니다. 조직적인 계층 구조의 매우 흔한 예시를 살펴보죠.\u003c/p\u003e\n\u003cp\u003e아래 표에 표시된 대로 직원 테이블을 가지고 있고 각 목록이 관리자부터 직원까지의 경로를 나타내는 쉼표로 구분된 목록을 얻고 싶다고 가정해보세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_3.png\" alt=\"Employee Table\"\u003e\u003c/p\u003e\n\u003cp\u003e다음 쿼리를 사용하여 이 입력 데이터를 다시 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eMySQL Workbench에 있는 analyticswithsuraj는 스키마 이름입니다. 여러분의 스키마로 대체할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eDROP\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTABLE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eIF\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eEXISTS\u003c/span\u003e analyticswithsuraj.\u003cspan class=\"hljs-property\"\u003eemployee\u003c/span\u003e;\n\u003cspan class=\"hljs-variable constant_\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTABLE\u003c/span\u003e analyticswithsuraj.\u003cspan class=\"hljs-property\"\u003eemployee\u003c/span\u003e (\n    \u003cspan class=\"hljs-title class_\"\u003eEmployeeID\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eVARCHAR\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e),\n    \u003cspan class=\"hljs-title class_\"\u003eEmployeeName\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eVARCHAR\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e),\n    \u003cspan class=\"hljs-title class_\"\u003eManagerID\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eVARCHAR\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n);\n\n-- \u003cspan class=\"hljs-title class_\"\u003eInsert\u003c/span\u003e sample data\n\u003cspan class=\"hljs-variable constant_\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINTO\u003c/span\u003e analyticswithsuraj.\u003cspan class=\"hljs-property\"\u003eemployee\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'John'\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eNULL\u003c/span\u003e);\n\u003cspan class=\"hljs-variable constant_\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINTO\u003c/span\u003e analyticswithsuraj.\u003cspan class=\"hljs-property\"\u003eemployee\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Jane'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003cspan class=\"hljs-variable constant_\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINTO\u003c/span\u003e analyticswithsuraj.\u003cspan class=\"hljs-property\"\u003eemployee\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Bob'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003cspan class=\"hljs-variable constant_\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINTO\u003c/span\u003e analyticswithsuraj.\u003cspan class=\"hljs-property\"\u003eemployee\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Alice'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"hljs-variable constant_\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINTO\u003c/span\u003e analyticswithsuraj.\u003cspan class=\"hljs-property\"\u003eemployee\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Charlie'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"hljs-variable constant_\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINTO\u003c/span\u003e analyticswithsuraj.\u003cspan class=\"hljs-property\"\u003eemployee\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'David'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-variable constant_\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINTO\u003c/span\u003e analyticswithsuraj.\u003cspan class=\"hljs-property\"\u003eemployee\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Eva'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e문제에 돌아가서... 완전한 해결책을 보여드릴게요. 그리고 그 후에 설명을 따라 읽어볼게요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eWITH\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eRECURSIVE\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRecursiveCTE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n    \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eEmployeeID\u003c/span\u003e,\n        \u003cspan class=\"hljs-title class_\"\u003eEmployeeName\u003c/span\u003e,\n        \u003cspan class=\"hljs-title class_\"\u003eManagerID\u003c/span\u003e,\n        \u003cspan class=\"hljs-title class_\"\u003eEmployeeName\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e -- 초기 경로는 직원의 \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e입니다\n    \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e\n        analyticswithsuraj.\u003cspan class=\"hljs-property\"\u003eemployee\u003c/span\u003e\n    \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eManagerID\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eIS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eNULL\u003c/span\u003e -- 앵커 부분\n\n    \u003cspan class=\"hljs-variable constant_\"\u003eUNION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eALL\u003c/span\u003e\n\n    \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n        e.\u003cspan class=\"hljs-property\"\u003eEmployeeID\u003c/span\u003e,\n        e.\u003cspan class=\"hljs-property\"\u003eEmployeeName\u003c/span\u003e,\n        e.\u003cspan class=\"hljs-property\"\u003eManagerID\u003c/span\u003e,\n        \u003cspan class=\"hljs-title function_\"\u003econcat_ws\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e','\u003c/span\u003e, rc.\u003cspan class=\"hljs-property\"\u003ePath\u003c/span\u003e, e.\u003cspan class=\"hljs-property\"\u003eEmployeeName\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e\n    \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e\n        analyticswithsuraj.\u003cspan class=\"hljs-property\"\u003eemployee\u003c/span\u003e e\n    \u003cspan class=\"hljs-variable constant_\"\u003eJOIN\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eRecursiveCTE\u003c/span\u003e rc \u003cspan class=\"hljs-variable constant_\"\u003eON\u003c/span\u003e e.\u003cspan class=\"hljs-property\"\u003eManagerID\u003c/span\u003e = rc.\u003cspan class=\"hljs-property\"\u003eEmployeeID\u003c/span\u003e -- 재귀 부분\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMySQL Workbench에서 재귀 CTE를 작성하려면 CTE 이름 앞에 RECURSIVE 키워드를 입력해야 합니다.\u003c/p\u003e\n\u003cp\u003eCaveat: 재귀 CTE의 기본 개념을 읽으신다면, 솔루션은 두 부분으로 이뤄져야 합니다.\u003c/p\u003e\n\u003cp\u003e첫 번째는 시작점인 앵커 부분입니다. 재귀 쿼리에서 참조할 수 있는 시작점으로, 아래와 같이 간단한 SELECT 문으로 표현됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eEmployeeID\u003c/span\u003e,\n        \u003cspan class=\"hljs-title class_\"\u003eEmployeeName\u003c/span\u003e,\n        \u003cspan class=\"hljs-title class_\"\u003eManagerID\u003c/span\u003e,\n        \u003cspan class=\"hljs-title class_\"\u003eEmployeeName\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e -- 초기 경로는 직원의 \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e만 포함합니다\n    \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e\n        analyticswithsuraj.\u003cspan class=\"hljs-property\"\u003eemployee\u003c/span\u003e\n    \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eManagerID\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eIS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eNULL\u003c/span\u003e -- 앵커 부분\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서는 직원의 전체 계층 구조를 저장할 추가적인 Path 열을 생성합니다.\u003c/p\u003e\n\u003cp\u003e이 앵커 쿼리는 항상 ManagerID가 NULL 인 직원만 포함합니다. 즉, 그들 위에 매니저가 없는 직원만을 선택합니다.\u003c/p\u003e\n\u003cp\u003e재귀 CTE의 두 번째 부분은 재귀 부분으로, 직원 이름을 선택하고 Path 열의 값을 업데이트하여 아래와 같이 쉼표로 구분된 경로를 만듭니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    \u003cspan class=\"hljs-variable constant_\"\u003eUNION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eALL\u003c/span\u003e\n\n    \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n        e.\u003cspan class=\"hljs-property\"\u003eEmployeeID\u003c/span\u003e,\n        e.\u003cspan class=\"hljs-property\"\u003eEmployeeName\u003c/span\u003e,\n        e.\u003cspan class=\"hljs-property\"\u003eManagerID\u003c/span\u003e,\n        \u003cspan class=\"hljs-title function_\"\u003econcat_ws\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e', '\u003c/span\u003e, rc.\u003cspan class=\"hljs-property\"\u003ePath\u003c/span\u003e, e.\u003cspan class=\"hljs-property\"\u003eEmployeeName\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e\n    \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e\n        analyticswithsuraj.\u003cspan class=\"hljs-property\"\u003eemployee\u003c/span\u003e e\n    \u003cspan class=\"hljs-variable constant_\"\u003eJOIN\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eRecursiveCTE\u003c/span\u003e rc \u003cspan class=\"hljs-variable constant_\"\u003eON\u003c/span\u003e e.\u003cspan class=\"hljs-property\"\u003eManagerID\u003c/span\u003e = rc.\u003cspan class=\"hljs-property\"\u003eEmployeeID\u003c/span\u003e -- \u003cspan class=\"hljs-title class_\"\u003eRecursive\u003c/span\u003e part\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e보시다시피 이 재귀 부분은 원래의 직원 테이블에서 데이터를 조회하고 안에 쓰여진 CTE와 조인합니다.\u003c/p\u003e\n\u003cp\u003eUNION ALL은 앵커 쿼리와 순환 쿼리의 결과를 결합하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e최종적으로는 이 순환 CTE를 간단한 SELECT 문으로 쿼리할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eEmployeeID\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eEmployeeName\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eManagerID\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eRecursiveCTE\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e결과적으로 각 레코드마다 직원의 완전한 계층 구조를 볼 수 있습니다. 여기에는 John이 최종 관리자로 나타나며 그의 상사가 없는 것을 나타내고, Jane과 Bob이 그의 직속 보고자들이라는 것을 보여줍니다.\u003c/p\u003e\n\u003cp\u003e입력 테이블에서 4번째 레코드에서 Jane이 Alice의 관리자이고 John이 Jane의 관리자인 것을 볼 수 있으므로 Alice의 전체 계층은 'John, Jane, Alice'입니다.\u003c/p\u003e\n\u003cp\u003e그러나 데이터는 단순한 계층보다 복잡할 수 있습니다. Facebook 친구 목록이나 다른 소셜 네트워킹 데이터와 같이 요롯한 경우도 있습니다. 재귀 CTE가 어떻게 활용될 수 있는지 살펴보겠습니다.\u003c/p\u003e\n\u003ch1\u003e네트워크 데이터 처리하기\u003c/h1\u003e\n\u003cp\u003e네트워크 데이터는 이름에서 알 수 있듯이 사물, 엔티티 및 사람들의 네트워크에 대한 것입니다. 아래 그림에서 보이는 것처럼 네트워크 데이터를 노드(블록)와 노드를 연결하는 엣지(선)로 시각화할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_5.png\" alt=\"그림\"\u003e\u003c/p\u003e\n\u003cp\u003e노드는 사용자 또는 엔티티를 나타내며, 엣지는 그들 사이의 관계를 나타냅니다.\u003c/p\u003e\n\u003cp\u003e간단히 말해서, 두 노드 사이에 엣지(선)가 있다면, 두 노드는 직접적으로 서로 연결되어있다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e아래는 테이블 \u003ccode\u003enetwork_connections\u003c/code\u003e에 표시된 11명의 친구들 중 파올로와 연결된 사람들을 분석하고 있습니다. 파올로의 친구와 친구의 친구들을 파악하고 싶습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eDROP\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTABLE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eIF\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eEXISTS\u003c/span\u003e alldata.\u003cspan class=\"hljs-property\"\u003enetwork_connections\u003c/span\u003e;\n\u003cspan class=\"hljs-variable constant_\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTABLE\u003c/span\u003e alldata.\u003cspan class=\"hljs-property\"\u003enetwork_connections\u003c/span\u003e (\n    source_node \u003cspan class=\"hljs-title function_\"\u003eVARCHAR\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e),\n    target_node \u003cspan class=\"hljs-title function_\"\u003eVARCHAR\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e)\n);\n\n\u003cspan class=\"hljs-variable constant_\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINTO\u003c/span\u003e alldata.\u003cspan class=\"hljs-property\"\u003enetwork_connections\u003c/span\u003e (source_node, target_node) \u003cspan class=\"hljs-variable constant_\"\u003eVALUES\u003c/span\u003e\n(\u003cspan class=\"hljs-string\"\u003e'Paolo'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'David'\u003c/span\u003e),\n(\u003cspan class=\"hljs-string\"\u003e'Paolo'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Anna'\u003c/span\u003e),\n(\u003cspan class=\"hljs-string\"\u003e'David'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Mark'\u003c/span\u003e),\n(\u003cspan class=\"hljs-string\"\u003e'Anna'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Peter'\u003c/span\u003e),\n(\u003cspan class=\"hljs-string\"\u003e'Samar'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Patrik'\u003c/span\u003e),\n(\u003cspan class=\"hljs-string\"\u003e'Mark'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Vivan'\u003c/span\u003e),\n(\u003cspan class=\"hljs-string\"\u003e'Patrik'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Maya'\u003c/span\u003e),\n(\u003cspan class=\"hljs-string\"\u003e'Julia'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'Robert'\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e알다타는 MySQL Workbench에서의 스키마 이름입니다. 이를 여러분의 스키마 이름으로 바꿔 사용하실 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이전 계층 데이터의 예제에서 이미 앵커 부분과 재귀 부분을 설명했으니, 여기서 바로 솔루션으로 넘어가겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eWITH\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eRECURSIVE\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNetworkCTE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n    -- 시작 노드를 선택하는 앵커 부분\n    \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e source_node,\n            target_node\n    \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e network_connections\n    \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e source_node = \u003cspan class=\"hljs-string\"\u003e'Paolo'\u003c/span\u003e -- 다른 사람의 네트워크를 보려면 여기를 변경하세요\n    \n    \u003cspan class=\"hljs-variable constant_\"\u003eUNION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eALL\u003c/span\u003e\n    \n    -- 연결된 노드를 선택하는 재귀 부분\n    \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e nc.\u003cspan class=\"hljs-property\"\u003esource_node\u003c/span\u003e,\n            nc.\u003cspan class=\"hljs-property\"\u003etarget_node\u003c/span\u003e\n    \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e network_connections nc\n    \u003cspan class=\"hljs-variable constant_\"\u003eJOIN\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNetworkCTE\u003c/span\u003e n \u003cspan class=\"hljs-variable constant_\"\u003eON\u003c/span\u003e nc.\u003cspan class=\"hljs-property\"\u003esource_node\u003c/span\u003e = n.\u003cspan class=\"hljs-property\"\u003etarget_node\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e * \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNetworkCTE\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e코드에서 설명한 대로, 앵커 부분은 먼저 모든 레코드를 가져와 Paolo를 소스 노드로 하는 것 즉, Paolo의 직접적인 친구들을 모두 가져옵니다. 반면 재귀 부분은 Paolo의 친구의 친구를 모두 가져옵니다.\u003c/p\u003e\n\u003cp\u003e그래서 Paolo의 네트워크를 최종적으로 다음과 같이 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024_7.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e네트워크 데이터 분석의 다른 사용 사례들은 공급망 산업에서 서로 다른 개체간의 의존 관계를 분석하거나 재무 거래 분석에 계정을 통해 자금 이동을 추적하는 데 사용될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e더 많은 재귀 CTE를 효과적으로 사용할 수 있는 예시가 있다면 댓글에 언급하지 않을래요?\u003c/p\u003e\n\u003cp\u003e이 글이 유용하고 정보가 풍부하게 느껴졌으면 좋겠어요!\u003c/p\u003e\n\u003cp\u003e공통 테이블 표현식(CTE)은 SQL에서 널리 사용되며 재귀 CTE는 특수한 경우입니다. 이 간편한 글에서 재귀 CTE를 사용하여 계층적 및 네트워크 데이터를 다루는 방법을 알아보았어요.\u003c/p\u003e\n\u003cp\u003e여기서 실제 예시를 통해 배운 것처럼, 특정 시나리오에서 SQL에서 재귀 CTE가 게임 체인저가 될 수 있다는 점을 알게 되었어요. 동일한 내용에 대한 다른 통찰이 있으면 댓글로 자유롭게 공유해주시기 바랍니다!\u003c/p\u003e\n\u003cp\u003e💡 저를 팔로우하고 제 이메일 목록에 가입하여 데이터 과학, SQL, Python 및 취업 검색 팁에 관한 다른 글을 더 이상 놓치지 않도록 해보세요!\u003c/p\u003e\n\u003cp\u003e읽어 주셔서 감사합니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-HowtoUseRecursiveCTEsinSQLAllYouNeedToKnowin2024"},"buildId":"FH3Qr-mLAesqA0X5IFRQr","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>