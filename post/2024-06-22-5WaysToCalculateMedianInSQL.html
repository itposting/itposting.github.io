<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SQL에서 중앙값 계산하는 5가지 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-22-5WaysToCalculateMedianInSQL" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SQL에서 중앙값 계산하는 5가지 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="SQL에서 중앙값 계산하는 5가지 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-22-5WaysToCalculateMedianInSQL" data-gatsby-head="true"/><meta name="twitter:title" content="SQL에서 중앙값 계산하는 5가지 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 17:50" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_buildManifest.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SQL에서 중앙값 계산하는 5가지 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SQL에서 중앙값 계산하는 5가지 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-5WaysToCalculateMedianInSQL&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_0.png" alt="이미지"></p>
<p>3년 전, 데이터 과학의 세계에 들어갈 것 같았을 때, 여러 가지가 너무 압도적으로 보였어요. 딱 한 번의 인생 안에 배워야 할 것들이 너무 많았죠! 데이터 과학자가 되기 위해 필요한 기술을 탐험하면서 저를 안심시켜준 것 중 하나는 통계학이었어요. 저는 고등학교 때부터 대학 시절까지 통계학을 좋아했거든요. 통계학을 배울 때 우리가 초기에 배운 것 중 하나는 데이터의 평균, 중앙값 그리고 최빈값을 계산하는 것이었어요. 전문 용어로는 중심 경향성 측정값이라고 부르기도 해요.</p>
<h1>빠른 복습</h1>
<p>평균: "평균치"라고도 불리며, 모든 데이터 점수를 더하고 데이터 점수의 수로 나누어 찾을 수 있어요.</p>
<div class="content-ad"></div>
<p>중앙값: 중간 숫자; 모든 데이터 포인트를 정렬하고 중간에 있는 숫자를 선택하여 찾음 (또는 두 개의 중간 숫자가 있는 경우, 그 두 숫자의 평균을 취함).</p>
<p>최빈값: 가장 빈도가 높은 숫자 - 즉, 가장 자주 발생하는 숫자.</p>
<p><img src="/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_1.png" alt="이미지"></p>
<p>Measure of Central Tendency에 대한 마이크로블로그를 보유하고 있습니다. 여기에서 그들의 필요성과 사용 사례가 더 자세히 설명되어 있습니다.</p>
<div class="content-ad"></div>
<p><a href="https://www.linkedin.com/posts/subhralina-nayak_data-statistics-datascience-activity-6977655040274522112-bvR6?utm_source=share&#x26;utm_medium=member_desktop" rel="nofollow" target="_blank">https://www.linkedin.com/posts/subhralina-nayak_data-statistics-datascience-activity-6977655040274522112-bvR6?utm_source=share&#x26;utm_medium=member_desktop</a></p>
<h1>SQL: 나의 진정한 사랑</h1>
<p>말할 것도 없이, 나는 "SQL이 모든 것보다 중요" 운동의 기수입니다!</p>
<p>데이터 분석에 필수인 최고의 도구가 SQL이죠. SQL을 사용하면 가능한 모든 분석을 수행할 수 있습니다. 하지만 중심 경향성 측정은 할 수 있나요?</p>
<div class="content-ad"></div>
<p>네, 당연히 가능해요!</p>
<p>평균을 계산하는 것은 매우 간단해요. AVG() 집계 함수를 사용할 수 있어요.</p>
<p>최빈값을 계산하는 것은 각 카테고리의 레코드 수를 세고, MAX() 함수를 사용하여 가장 많은 수의 그룹을 구할 수 있어요.</p>
<p>하지만, 중앙값을 계산하는 것은 약간 까다로울 수 있어요. 그렇지만 중앙값을 SQL에서 계산하는 것은 여전히 가능해요. 한 가지 방법이 아니라, 5가지 방법으로 가능해요.</p>
<div class="content-ad"></div>
<h1>SQL을 사용하여 중앙값 계산해보기</h1>
<p>먼저, 중앙값을 계산하는 데 사용되는 수학 공식을 이해해야 합니다.</p>
<p>N개의 요소를 가진 데이터셋이 있을 때, 작은 순서대로 정렬된 경우,</p>
<p>중앙값 = (N+1)/2번째 요소, 만약 N이 홀수인 경우</p>
<div class="content-ad"></div>
<p>중앙값 = (N/2번째 요소 + (N/2 + 1)번째 요소)/2, 단, N이 짝수인 경우</p>
<p>위의 공식에 따르면 데이터셋은 정렬되어 있어야 하며 홀수와 짝수 개수의 데이터포인트를 고려해야 합니다.</p>
<h2>변수와 OFFSET — FETCH를 사용하여</h2>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">DECLARE</span> @c <span class="hljs-variable constant_">BIGINT</span> = (<span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">COUNT</span>(*) <span class="hljs-variable constant_">FROM</span> sales.<span class="hljs-property">order_items</span>)

<span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">AVG</span>(list_price) <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"Median"</span>
<span class="hljs-variable constant_">FROM</span> (
 <span class="hljs-variable constant_">SELECT</span> list_price
 <span class="hljs-variable constant_">FROM</span> sales.<span class="hljs-property">order_items</span>
 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> list_price
 <span class="hljs-variable constant_">OFFSET</span> (@c - <span class="hljs-number">1</span>)/<span class="hljs-number">2</span> <span class="hljs-variable constant_">ROWS</span>
 <span class="hljs-variable constant_">FETCH</span> <span class="hljs-variable constant_">NEXT</span> <span class="hljs-number">1</span> + (<span class="hljs-number">1</span> - @c%<span class="hljs-number">2</span>) <span class="hljs-variable constant_">ROWS</span> <span class="hljs-variable constant_">ONLY</span>
) data
</code></pre>
<div class="content-ad"></div>
<p>변수 @c는 sales.order_items 테이블의 전체 행 수로 할당됩니다. 내부 서브쿼리는 목록 가격을 오름차순으로 정렬합니다. OFFSET (@c - 1)/2 ROWS 절은 첫 번째 절반의 행 (단 @c가 홀수인 경우) 또는 정확히 중간 행 (단 @c가 짝수인 경우)을 건너뜁니다. FETCH NEXT 1 + (1 - @c%2) ROWS ONLY 절은 @c가 홀수인 경우 다음 행을 가져오거나 @c가 짝수인 경우 추가 행을 가져오지 않습니다. 마지막으로 외부 쿼리는 검색된 행의 평균을 계산하여 중앙값을 구합니다.</p>
<h2>ROW_NUMBER() 윈도우 함수 사용하기</h2>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">AVG</span>(list_price) <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"Median"</span>
<span class="hljs-variable constant_">FROM</span>
(
   <span class="hljs-variable constant_">SELECT</span> list_price,
      <span class="hljs-title function_">ROW_NUMBER</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> list_price <span class="hljs-variable constant_">ASC</span>, order_id <span class="hljs-variable constant_">ASC</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-title class_">RowAsc</span>,
      <span class="hljs-title function_">ROW_NUMBER</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> list_price <span class="hljs-variable constant_">DESC</span>, order_id <span class="hljs-variable constant_">DESC</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-title class_">RowDesc</span>
   <span class="hljs-variable constant_">FROM</span> sales.<span class="hljs-property">order_items</span>
) data
<span class="hljs-variable constant_">WHERE</span>
   <span class="hljs-title class_">RowAsc</span> <span class="hljs-variable constant_">IN</span> (<span class="hljs-title class_">RowDesc</span>, <span class="hljs-title class_">RowDesc</span> - <span class="hljs-number">1</span>, <span class="hljs-title class_">RowDesc</span> + <span class="hljs-number">1</span>)
</code></pre>
<p>위 쿼리는 먼저 각 행에 대해 목록 가격과 주문 ID에 따라 오름차순 및 내림차순으로 순서를 지정합니다. 서브쿼리는 목록 가격 및 해당하는 오름차순 및 내림차순 순서의 행 번호를 검색합니다. 외부 쿼리는 오름차순 순서의 행 번호가 내림차순 순서의 행 번호와 동일하거나 하나 차이 나는 경우의 목록 가격의 평균을 계산합니다.</p>
<div class="content-ad"></div>
<h2>ORDER BY, MIN() 및 MAX() 함수 사용</h2>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> (
(<span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">MAX</span>(list_price)
<span class="hljs-variable constant_">FROM</span> (
 <span class="hljs-variable constant_">SELECT</span> list_price
 <span class="hljs-variable constant_">FROM</span> sales.<span class="hljs-property">order_items</span>
 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> list_price
 <span class="hljs-variable constant_">OFFSET</span> (<span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">COUNT</span>(*)
 <span class="hljs-variable constant_">FROM</span> sales.<span class="hljs-property">order_items</span>) / <span class="hljs-number">2</span> <span class="hljs-variable constant_">ROWS</span>
 <span class="hljs-variable constant_">FETCH</span> <span class="hljs-variable constant_">NEXT</span> <span class="hljs-number">1</span> <span class="hljs-variable constant_">ROW</span> <span class="hljs-variable constant_">ONLY</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-title class_">BottomHalf</span>) +
(<span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">MIN</span>(list_price)
<span class="hljs-variable constant_">FROM</span> (
 <span class="hljs-variable constant_">SELECT</span> list_price
 <span class="hljs-variable constant_">FROM</span> sales.<span class="hljs-property">order_items</span>
 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> list_price <span class="hljs-variable constant_">DESC</span>
 <span class="hljs-variable constant_">OFFSET</span> (<span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">COUNT</span>(*)
 <span class="hljs-variable constant_">FROM</span> sales.<span class="hljs-property">order_items</span>) / <span class="hljs-number">2</span> <span class="hljs-variable constant_">ROWS</span>
 <span class="hljs-variable constant_">FETCH</span> <span class="hljs-variable constant_">NEXT</span> <span class="hljs-number">1</span> <span class="hljs-variable constant_">ROW</span> <span class="hljs-variable constant_">ONLY</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-title class_">TopHalf</span>)
) / <span class="hljs-number">2</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-title class_">Median</span>
</code></pre>
<p>데이터셋을 list_price를 기준으로 두 부분 (상위 및 하위)으로 분할합니다. 내부 서브쿼리는 각각 list 가격의 상위 50%와 하위 50%를 찾습니다. MAX(list_price) 및 MIN(list_price) 함수는 각각 각 반의 최대값과 최소값을 검색합니다. 최종 결과는 하위 반의 최댓값과 상위 반의 최솟값을 더한 다음 그 합을 2로 나누어 중앙값을 얻습니다.</p>
<h2>NTILE() 윈도우 함수 사용</h2>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">MAX</span>(list_price) <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"중앙값"</span>
<span class="hljs-variable constant_">FROM</span> (
 <span class="hljs-variable constant_">SELECT</span> list_price,
 <span class="hljs-title function_">NTILE</span>(<span class="hljs-number">4</span>) <span class="hljs-title function_">OVER</span>(<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> list_price) <span class="hljs-variable constant_">AS</span> <span class="hljs-title class_">Quartile</span> 
 <span class="hljs-variable constant_">FROM</span> sales.<span class="hljs-property">order_items</span>
) X
<span class="hljs-variable constant_">WHERE</span> <span class="hljs-title class_">Quartile</span> = <span class="hljs-number">2</span>
</code></pre>
<p>NTILE 함수는 결과 집합을 4개의 동일한 부분(사분위수)으로 나눕니다. ORDER BY list_price는 목록 가격을 오름차순으로 정렬합니다. 외부 쿼리는 Quartile이 2인 서브쿼리에서 최대 목록 가격을 선택하는데, 이는 중간값인 두 번째 사분위수를 나타냅니다.</p>
<h2>PERCENTILE_CONT() 윈도우 함수 사용하기</h2>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> <span class="hljs-variable constant_">DISTINCT</span> <span class="hljs-title function_">PERCENTILE_CONT</span>(<span class="hljs-number">0.5</span>) 
  <span class="hljs-variable constant_">WITHIN</span> <span class="hljs-variable constant_">GROUP</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> list_price) <span class="hljs-title function_">OVER</span>() <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"중앙값"</span>
<span class="hljs-variable constant_">FROM</span> sales.<span class="hljs-property">order_items</span>
</code></pre>
<div class="content-ad"></div>
<p>PERCENTILE_CONT 함수는 그룹 내에서 주어진 열의 특정 백분위수를 계산합니다. 0.5 인수는 우리가 50번째 백분위수인 중앙값을 찾고 싶다는 것을 나타냅니다. ORDER BY list_price 절은 중앙값을 계산하기 전에 목록 가격이 오름차순으로 정렬되도록 합니다. DISTINCT 키워드는 중앙값이 동일한 값이 여러 개 있는 경우에도 전체 중앙값에 대해 한 결과만 얻도록 합니다. OVER() 함수는 어떤 분할도 없이 사용되므로 PERCENTILE_CONT가 전체 결과 집합에 적용됩니다.</p>
<p>참고: 모든 쿼리는 MS SQL Server에서 작성되었습니다.</p>
<p>이 쿼리들은 SQL에서 중앙값을 계산하는 다양한 방법을 제공하며, 그 효과는 데이터셋 크기와 사용 중인 데이터베이스 시스템에 따라 달라질 수 있습니다. 데이터셋에서 가장 효율적이고 정확한 중앙값 계산 방법을 찾기 위해 이 쿼리들을 특정 데이터셋에서 테스트하는 것이 좋은 실천법입니다.</p>
<p>SQL에서 중앙값을 계산하는 다른 방법이 있을 것으로 확신합니다. 발견하면 코멘트로 남겨주시기 바랍니다. 위에서 소개한 방법 중에서 여러분의 즐겨찾는 또는 선호하는 방법을 알려주세요. 이 블로그가 여러분의 SQL 역량을 향상시키는 데 도움이 되기를 바랍니다. 네, "모든 것은 SQL로 시작한다"고 말씀합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SQL에서 중앙값 계산하는 5가지 방법","description":"","date":"2024-06-22 17:50","slug":"2024-06-22-5WaysToCalculateMedianInSQL","content":"\n\n![이미지](/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_0.png)\n\n3년 전, 데이터 과학의 세계에 들어갈 것 같았을 때, 여러 가지가 너무 압도적으로 보였어요. 딱 한 번의 인생 안에 배워야 할 것들이 너무 많았죠! 데이터 과학자가 되기 위해 필요한 기술을 탐험하면서 저를 안심시켜준 것 중 하나는 통계학이었어요. 저는 고등학교 때부터 대학 시절까지 통계학을 좋아했거든요. 통계학을 배울 때 우리가 초기에 배운 것 중 하나는 데이터의 평균, 중앙값 그리고 최빈값을 계산하는 것이었어요. 전문 용어로는 중심 경향성 측정값이라고 부르기도 해요.\n\n# 빠른 복습\n\n평균: \"평균치\"라고도 불리며, 모든 데이터 점수를 더하고 데이터 점수의 수로 나누어 찾을 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중앙값: 중간 숫자; 모든 데이터 포인트를 정렬하고 중간에 있는 숫자를 선택하여 찾음 (또는 두 개의 중간 숫자가 있는 경우, 그 두 숫자의 평균을 취함).\n\n최빈값: 가장 빈도가 높은 숫자 - 즉, 가장 자주 발생하는 숫자.\n\n![이미지](/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_1.png)\n\nMeasure of Central Tendency에 대한 마이크로블로그를 보유하고 있습니다. 여기에서 그들의 필요성과 사용 사례가 더 자세히 설명되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://www.linkedin.com/posts/subhralina-nayak_data-statistics-datascience-activity-6977655040274522112-bvR6?utm_source=share\u0026utm_medium=member_desktop\n\n# SQL: 나의 진정한 사랑\n\n말할 것도 없이, 나는 \"SQL이 모든 것보다 중요\" 운동의 기수입니다!\n\n데이터 분석에 필수인 최고의 도구가 SQL이죠. SQL을 사용하면 가능한 모든 분석을 수행할 수 있습니다. 하지만 중심 경향성 측정은 할 수 있나요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네, 당연히 가능해요!\n\n평균을 계산하는 것은 매우 간단해요. AVG() 집계 함수를 사용할 수 있어요.\n\n최빈값을 계산하는 것은 각 카테고리의 레코드 수를 세고, MAX() 함수를 사용하여 가장 많은 수의 그룹을 구할 수 있어요.\n\n하지만, 중앙값을 계산하는 것은 약간 까다로울 수 있어요. 그렇지만 중앙값을 SQL에서 계산하는 것은 여전히 가능해요. 한 가지 방법이 아니라, 5가지 방법으로 가능해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# SQL을 사용하여 중앙값 계산해보기\n\n먼저, 중앙값을 계산하는 데 사용되는 수학 공식을 이해해야 합니다.\n\nN개의 요소를 가진 데이터셋이 있을 때, 작은 순서대로 정렬된 경우,\n\n중앙값 = (N+1)/2번째 요소, 만약 N이 홀수인 경우\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중앙값 = (N/2번째 요소 + (N/2 + 1)번째 요소)/2, 단, N이 짝수인 경우\n\n위의 공식에 따르면 데이터셋은 정렬되어 있어야 하며 홀수와 짝수 개수의 데이터포인트를 고려해야 합니다.\n\n## 변수와 OFFSET — FETCH를 사용하여\n\n```js\nDECLARE @c BIGINT = (SELECT COUNT(*) FROM sales.order_items)\n\nSELECT AVG(list_price) AS \"Median\"\nFROM (\n SELECT list_price\n FROM sales.order_items\n ORDER BY list_price\n OFFSET (@c - 1)/2 ROWS\n FETCH NEXT 1 + (1 - @c%2) ROWS ONLY\n) data\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n변수 @c는 sales.order_items 테이블의 전체 행 수로 할당됩니다. 내부 서브쿼리는 목록 가격을 오름차순으로 정렬합니다. OFFSET (@c - 1)/2 ROWS 절은 첫 번째 절반의 행 (단 @c가 홀수인 경우) 또는 정확히 중간 행 (단 @c가 짝수인 경우)을 건너뜁니다. FETCH NEXT 1 + (1 - @c%2) ROWS ONLY 절은 @c가 홀수인 경우 다음 행을 가져오거나 @c가 짝수인 경우 추가 행을 가져오지 않습니다. 마지막으로 외부 쿼리는 검색된 행의 평균을 계산하여 중앙값을 구합니다.\n\n## ROW_NUMBER() 윈도우 함수 사용하기\n\n```js\nSELECT AVG(list_price) AS \"Median\"\nFROM\n(\n   SELECT list_price,\n      ROW_NUMBER() OVER (ORDER BY list_price ASC, order_id ASC) AS RowAsc,\n      ROW_NUMBER() OVER (ORDER BY list_price DESC, order_id DESC) AS RowDesc\n   FROM sales.order_items\n) data\nWHERE\n   RowAsc IN (RowDesc, RowDesc - 1, RowDesc + 1)\n```\n\n위 쿼리는 먼저 각 행에 대해 목록 가격과 주문 ID에 따라 오름차순 및 내림차순으로 순서를 지정합니다. 서브쿼리는 목록 가격 및 해당하는 오름차순 및 내림차순 순서의 행 번호를 검색합니다. 외부 쿼리는 오름차순 순서의 행 번호가 내림차순 순서의 행 번호와 동일하거나 하나 차이 나는 경우의 목록 가격의 평균을 계산합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## ORDER BY, MIN() 및 MAX() 함수 사용\n\n```js\nSELECT (\n(SELECT MAX(list_price)\nFROM (\n SELECT list_price\n FROM sales.order_items\n ORDER BY list_price\n OFFSET (SELECT COUNT(*)\n FROM sales.order_items) / 2 ROWS\n FETCH NEXT 1 ROW ONLY) AS BottomHalf) +\n(SELECT MIN(list_price)\nFROM (\n SELECT list_price\n FROM sales.order_items\n ORDER BY list_price DESC\n OFFSET (SELECT COUNT(*)\n FROM sales.order_items) / 2 ROWS\n FETCH NEXT 1 ROW ONLY) AS TopHalf)\n) / 2 AS Median\n```\n\n데이터셋을 list_price를 기준으로 두 부분 (상위 및 하위)으로 분할합니다. 내부 서브쿼리는 각각 list 가격의 상위 50%와 하위 50%를 찾습니다. MAX(list_price) 및 MIN(list_price) 함수는 각각 각 반의 최대값과 최소값을 검색합니다. 최종 결과는 하위 반의 최댓값과 상위 반의 최솟값을 더한 다음 그 합을 2로 나누어 중앙값을 얻습니다.\n\n## NTILE() 윈도우 함수 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nSELECT MAX(list_price) AS \"중앙값\"\nFROM (\n SELECT list_price,\n NTILE(4) OVER(ORDER BY list_price) AS Quartile \n FROM sales.order_items\n) X\nWHERE Quartile = 2\n```\n\nNTILE 함수는 결과 집합을 4개의 동일한 부분(사분위수)으로 나눕니다. ORDER BY list_price는 목록 가격을 오름차순으로 정렬합니다. 외부 쿼리는 Quartile이 2인 서브쿼리에서 최대 목록 가격을 선택하는데, 이는 중간값인 두 번째 사분위수를 나타냅니다.\n\n## PERCENTILE_CONT() 윈도우 함수 사용하기\n\n```js\nSELECT DISTINCT PERCENTILE_CONT(0.5) \n  WITHIN GROUP (ORDER BY list_price) OVER() AS \"중앙값\"\nFROM sales.order_items\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPERCENTILE_CONT 함수는 그룹 내에서 주어진 열의 특정 백분위수를 계산합니다. 0.5 인수는 우리가 50번째 백분위수인 중앙값을 찾고 싶다는 것을 나타냅니다. ORDER BY list_price 절은 중앙값을 계산하기 전에 목록 가격이 오름차순으로 정렬되도록 합니다. DISTINCT 키워드는 중앙값이 동일한 값이 여러 개 있는 경우에도 전체 중앙값에 대해 한 결과만 얻도록 합니다. OVER() 함수는 어떤 분할도 없이 사용되므로 PERCENTILE_CONT가 전체 결과 집합에 적용됩니다.\n\n참고: 모든 쿼리는 MS SQL Server에서 작성되었습니다.\n\n이 쿼리들은 SQL에서 중앙값을 계산하는 다양한 방법을 제공하며, 그 효과는 데이터셋 크기와 사용 중인 데이터베이스 시스템에 따라 달라질 수 있습니다. 데이터셋에서 가장 효율적이고 정확한 중앙값 계산 방법을 찾기 위해 이 쿼리들을 특정 데이터셋에서 테스트하는 것이 좋은 실천법입니다.\n\nSQL에서 중앙값을 계산하는 다른 방법이 있을 것으로 확신합니다. 발견하면 코멘트로 남겨주시기 바랍니다. 위에서 소개한 방법 중에서 여러분의 즐겨찾는 또는 선호하는 방법을 알려주세요. 이 블로그가 여러분의 SQL 역량을 향상시키는 데 도움이 되기를 바랍니다. 네, \"모든 것은 SQL로 시작한다\"고 말씀합니다.","ogImage":{"url":"/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_0.png"},"coverImage":"/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e3년 전, 데이터 과학의 세계에 들어갈 것 같았을 때, 여러 가지가 너무 압도적으로 보였어요. 딱 한 번의 인생 안에 배워야 할 것들이 너무 많았죠! 데이터 과학자가 되기 위해 필요한 기술을 탐험하면서 저를 안심시켜준 것 중 하나는 통계학이었어요. 저는 고등학교 때부터 대학 시절까지 통계학을 좋아했거든요. 통계학을 배울 때 우리가 초기에 배운 것 중 하나는 데이터의 평균, 중앙값 그리고 최빈값을 계산하는 것이었어요. 전문 용어로는 중심 경향성 측정값이라고 부르기도 해요.\u003c/p\u003e\n\u003ch1\u003e빠른 복습\u003c/h1\u003e\n\u003cp\u003e평균: \"평균치\"라고도 불리며, 모든 데이터 점수를 더하고 데이터 점수의 수로 나누어 찾을 수 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e중앙값: 중간 숫자; 모든 데이터 포인트를 정렬하고 중간에 있는 숫자를 선택하여 찾음 (또는 두 개의 중간 숫자가 있는 경우, 그 두 숫자의 평균을 취함).\u003c/p\u003e\n\u003cp\u003e최빈값: 가장 빈도가 높은 숫자 - 즉, 가장 자주 발생하는 숫자.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-5WaysToCalculateMedianInSQL_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eMeasure of Central Tendency에 대한 마이크로블로그를 보유하고 있습니다. 여기에서 그들의 필요성과 사용 사례가 더 자세히 설명되어 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003ca href=\"https://www.linkedin.com/posts/subhralina-nayak_data-statistics-datascience-activity-6977655040274522112-bvR6?utm_source=share\u0026#x26;utm_medium=member_desktop\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.linkedin.com/posts/subhralina-nayak_data-statistics-datascience-activity-6977655040274522112-bvR6?utm_source=share\u0026#x26;utm_medium=member_desktop\u003c/a\u003e\u003c/p\u003e\n\u003ch1\u003eSQL: 나의 진정한 사랑\u003c/h1\u003e\n\u003cp\u003e말할 것도 없이, 나는 \"SQL이 모든 것보다 중요\" 운동의 기수입니다!\u003c/p\u003e\n\u003cp\u003e데이터 분석에 필수인 최고의 도구가 SQL이죠. SQL을 사용하면 가능한 모든 분석을 수행할 수 있습니다. 하지만 중심 경향성 측정은 할 수 있나요?\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e네, 당연히 가능해요!\u003c/p\u003e\n\u003cp\u003e평균을 계산하는 것은 매우 간단해요. AVG() 집계 함수를 사용할 수 있어요.\u003c/p\u003e\n\u003cp\u003e최빈값을 계산하는 것은 각 카테고리의 레코드 수를 세고, MAX() 함수를 사용하여 가장 많은 수의 그룹을 구할 수 있어요.\u003c/p\u003e\n\u003cp\u003e하지만, 중앙값을 계산하는 것은 약간 까다로울 수 있어요. 그렇지만 중앙값을 SQL에서 계산하는 것은 여전히 가능해요. 한 가지 방법이 아니라, 5가지 방법으로 가능해요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eSQL을 사용하여 중앙값 계산해보기\u003c/h1\u003e\n\u003cp\u003e먼저, 중앙값을 계산하는 데 사용되는 수학 공식을 이해해야 합니다.\u003c/p\u003e\n\u003cp\u003eN개의 요소를 가진 데이터셋이 있을 때, 작은 순서대로 정렬된 경우,\u003c/p\u003e\n\u003cp\u003e중앙값 = (N+1)/2번째 요소, 만약 N이 홀수인 경우\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e중앙값 = (N/2번째 요소 + (N/2 + 1)번째 요소)/2, 단, N이 짝수인 경우\u003c/p\u003e\n\u003cp\u003e위의 공식에 따르면 데이터셋은 정렬되어 있어야 하며 홀수와 짝수 개수의 데이터포인트를 고려해야 합니다.\u003c/p\u003e\n\u003ch2\u003e변수와 OFFSET — FETCH를 사용하여\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eDECLARE\u003c/span\u003e @c \u003cspan class=\"hljs-variable constant_\"\u003eBIGINT\u003c/span\u003e = (\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eCOUNT\u003c/span\u003e(*) \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e sales.\u003cspan class=\"hljs-property\"\u003eorder_items\u003c/span\u003e)\n\n\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eAVG\u003c/span\u003e(list_price) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Median\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e (\n \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e list_price\n \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e sales.\u003cspan class=\"hljs-property\"\u003eorder_items\u003c/span\u003e\n \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e list_price\n \u003cspan class=\"hljs-variable constant_\"\u003eOFFSET\u003c/span\u003e (@c - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROWS\u003c/span\u003e\n \u003cspan class=\"hljs-variable constant_\"\u003eFETCH\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eNEXT\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e + (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e - @c%\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eROWS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eONLY\u003c/span\u003e\n) data\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e변수 @c는 sales.order_items 테이블의 전체 행 수로 할당됩니다. 내부 서브쿼리는 목록 가격을 오름차순으로 정렬합니다. OFFSET (@c - 1)/2 ROWS 절은 첫 번째 절반의 행 (단 @c가 홀수인 경우) 또는 정확히 중간 행 (단 @c가 짝수인 경우)을 건너뜁니다. FETCH NEXT 1 + (1 - @c%2) ROWS ONLY 절은 @c가 홀수인 경우 다음 행을 가져오거나 @c가 짝수인 경우 추가 행을 가져오지 않습니다. 마지막으로 외부 쿼리는 검색된 행의 평균을 계산하여 중앙값을 구합니다.\u003c/p\u003e\n\u003ch2\u003eROW_NUMBER() 윈도우 함수 사용하기\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eAVG\u003c/span\u003e(list_price) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Median\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e\n(\n   \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e list_price,\n      \u003cspan class=\"hljs-title function_\"\u003eROW_NUMBER\u003c/span\u003e() \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e list_price \u003cspan class=\"hljs-variable constant_\"\u003eASC\u003c/span\u003e, order_id \u003cspan class=\"hljs-variable constant_\"\u003eASC\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRowAsc\u003c/span\u003e,\n      \u003cspan class=\"hljs-title function_\"\u003eROW_NUMBER\u003c/span\u003e() \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e list_price \u003cspan class=\"hljs-variable constant_\"\u003eDESC\u003c/span\u003e, order_id \u003cspan class=\"hljs-variable constant_\"\u003eDESC\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRowDesc\u003c/span\u003e\n   \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e sales.\u003cspan class=\"hljs-property\"\u003eorder_items\u003c/span\u003e\n) data\n\u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e\n   \u003cspan class=\"hljs-title class_\"\u003eRowAsc\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eIN\u003c/span\u003e (\u003cspan class=\"hljs-title class_\"\u003eRowDesc\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eRowDesc\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eRowDesc\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 쿼리는 먼저 각 행에 대해 목록 가격과 주문 ID에 따라 오름차순 및 내림차순으로 순서를 지정합니다. 서브쿼리는 목록 가격 및 해당하는 오름차순 및 내림차순 순서의 행 번호를 검색합니다. 외부 쿼리는 오름차순 순서의 행 번호가 내림차순 순서의 행 번호와 동일하거나 하나 차이 나는 경우의 목록 가격의 평균을 계산합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003eORDER BY, MIN() 및 MAX() 함수 사용\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e (\n(\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMAX\u003c/span\u003e(list_price)\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e (\n \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e list_price\n \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e sales.\u003cspan class=\"hljs-property\"\u003eorder_items\u003c/span\u003e\n \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e list_price\n \u003cspan class=\"hljs-variable constant_\"\u003eOFFSET\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eCOUNT\u003c/span\u003e(*)\n \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e sales.\u003cspan class=\"hljs-property\"\u003eorder_items\u003c/span\u003e) / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROWS\u003c/span\u003e\n \u003cspan class=\"hljs-variable constant_\"\u003eFETCH\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eNEXT\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROW\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eONLY\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBottomHalf\u003c/span\u003e) +\n(\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMIN\u003c/span\u003e(list_price)\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e (\n \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e list_price\n \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e sales.\u003cspan class=\"hljs-property\"\u003eorder_items\u003c/span\u003e\n \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e list_price \u003cspan class=\"hljs-variable constant_\"\u003eDESC\u003c/span\u003e\n \u003cspan class=\"hljs-variable constant_\"\u003eOFFSET\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eCOUNT\u003c/span\u003e(*)\n \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e sales.\u003cspan class=\"hljs-property\"\u003eorder_items\u003c/span\u003e) / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROWS\u003c/span\u003e\n \u003cspan class=\"hljs-variable constant_\"\u003eFETCH\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eNEXT\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROW\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eONLY\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTopHalf\u003c/span\u003e)\n) / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMedian\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e데이터셋을 list_price를 기준으로 두 부분 (상위 및 하위)으로 분할합니다. 내부 서브쿼리는 각각 list 가격의 상위 50%와 하위 50%를 찾습니다. MAX(list_price) 및 MIN(list_price) 함수는 각각 각 반의 최대값과 최소값을 검색합니다. 최종 결과는 하위 반의 최댓값과 상위 반의 최솟값을 더한 다음 그 합을 2로 나누어 중앙값을 얻습니다.\u003c/p\u003e\n\u003ch2\u003eNTILE() 윈도우 함수 사용\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eMAX\u003c/span\u003e(list_price) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"중앙값\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e (\n \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e list_price,\n \u003cspan class=\"hljs-title function_\"\u003eNTILE\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e) \u003cspan class=\"hljs-title function_\"\u003eOVER\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e list_price) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eQuartile\u003c/span\u003e \n \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e sales.\u003cspan class=\"hljs-property\"\u003eorder_items\u003c/span\u003e\n) X\n\u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eQuartile\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNTILE 함수는 결과 집합을 4개의 동일한 부분(사분위수)으로 나눕니다. ORDER BY list_price는 목록 가격을 오름차순으로 정렬합니다. 외부 쿼리는 Quartile이 2인 서브쿼리에서 최대 목록 가격을 선택하는데, 이는 중간값인 두 번째 사분위수를 나타냅니다.\u003c/p\u003e\n\u003ch2\u003ePERCENTILE_CONT() 윈도우 함수 사용하기\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDISTINCT\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePERCENTILE_CONT\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e) \n  \u003cspan class=\"hljs-variable constant_\"\u003eWITHIN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGROUP\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e list_price) \u003cspan class=\"hljs-title function_\"\u003eOVER\u003c/span\u003e() \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"중앙값\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e sales.\u003cspan class=\"hljs-property\"\u003eorder_items\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003ePERCENTILE_CONT 함수는 그룹 내에서 주어진 열의 특정 백분위수를 계산합니다. 0.5 인수는 우리가 50번째 백분위수인 중앙값을 찾고 싶다는 것을 나타냅니다. ORDER BY list_price 절은 중앙값을 계산하기 전에 목록 가격이 오름차순으로 정렬되도록 합니다. DISTINCT 키워드는 중앙값이 동일한 값이 여러 개 있는 경우에도 전체 중앙값에 대해 한 결과만 얻도록 합니다. OVER() 함수는 어떤 분할도 없이 사용되므로 PERCENTILE_CONT가 전체 결과 집합에 적용됩니다.\u003c/p\u003e\n\u003cp\u003e참고: 모든 쿼리는 MS SQL Server에서 작성되었습니다.\u003c/p\u003e\n\u003cp\u003e이 쿼리들은 SQL에서 중앙값을 계산하는 다양한 방법을 제공하며, 그 효과는 데이터셋 크기와 사용 중인 데이터베이스 시스템에 따라 달라질 수 있습니다. 데이터셋에서 가장 효율적이고 정확한 중앙값 계산 방법을 찾기 위해 이 쿼리들을 특정 데이터셋에서 테스트하는 것이 좋은 실천법입니다.\u003c/p\u003e\n\u003cp\u003eSQL에서 중앙값을 계산하는 다른 방법이 있을 것으로 확신합니다. 발견하면 코멘트로 남겨주시기 바랍니다. 위에서 소개한 방법 중에서 여러분의 즐겨찾는 또는 선호하는 방법을 알려주세요. 이 블로그가 여러분의 SQL 역량을 향상시키는 데 도움이 되기를 바랍니다. 네, \"모든 것은 SQL로 시작한다\"고 말씀합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-5WaysToCalculateMedianInSQL"},"buildId":"8coAiP0lmiEK5aH6nkQkj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>