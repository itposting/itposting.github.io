<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>라즈베리파이와 Flutter 사이에서 Bluetooth Low Energy 사용 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-22-UsingBluetoothLowEnergybetweenRaspberryPiandFlutter" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="라즈베리파이와 Flutter 사이에서 Bluetooth Low Energy 사용 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="라즈베리파이와 Flutter 사이에서 Bluetooth Low Energy 사용 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-UsingBluetoothLowEnergybetweenRaspberryPiandFlutter_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-22-UsingBluetoothLowEnergybetweenRaspberryPiandFlutter" data-gatsby-head="true"/><meta name="twitter:title" content="라즈베리파이와 Flutter 사이에서 Bluetooth Low Energy 사용 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-UsingBluetoothLowEnergybetweenRaspberryPiandFlutter_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 18:11" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_buildManifest.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">라즈베리파이와 Flutter 사이에서 Bluetooth Low Energy 사용 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="라즈베리파이와 Flutter 사이에서 Bluetooth Low Energy 사용 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-UsingBluetoothLowEnergybetweenRaspberryPiandFlutter&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>플러터의 멋진 점은 안드로이드, iOS 및 웹과 같은 다양한 플랫폼용 앱을 만들 수 있다는 것입니다. 그러나 iOS에서는 BLE(Bluetooth Low Energy) 프로토콜을 사용해야 합니다.</p>
<p>이전에 플러터 응용 프로그램과 라즈베리 파이를 사용한 나의 프로젝트는 서로 통신하기 위해 클래식 블루투스를 사용했습니다. 정말 잘 작동했죠... 그러나 아버지께 선물로 줬었는데 — 아이폰을 사용하시는 분이라 — 제대로 사용할 수 없었답니다. 조금 답답했죠.</p>
<p>그래서 이제 Python과 Flutter에서 BLE로 마이그레이션하기로 결정했습니다.</p>
<h1>1. Bluetooth Low Energy</h1>
<div class="content-ad"></div>
<p>제 첫 번째 이주 단계는 BLE를 이해하고 요구 사항을 준비하는 것입니다.</p>
<p>Adafruit에서 이에 대해 잘 문서화된 주제를 다루었습니다: Bluetooth Low Energy 소개. BLE가 어떻게 작동하는지 모른다면, 이 기사는 꽤 좋은 시작점입니다.</p>
<p>BLE 통신은 장치의 역할을 정의하기 위해 GAP (일반 접속 프로필)를 사용합니다. 이 프로젝트에서 RPi 스테이션은 페리페럴 장치로, 와이파이에 연결하고, 휴대폰과 연결하며, 원격 API를 통해 기상 데이터를 가져오고 반환합니다. 모바일 폰은 중앙 장치로, 받은 데이터를 표시하고 명령을 보냅니다.</p>
<p>BLE를 통해 통신하기 위해 GATT (일반 속성 프로필)을 사용합니다. 이는 두 장치가 Profile, Service 및 Characteristic를 사용하여 서로 통신하는 방법을 정의합니다. 이 주제에서 모든 프로토콜을 설명하지는 않겠지만, 간단히 설명하면, 프로필은 서비스 모음이며, 서비스는 장치의 기능입니다 (예: "날씨 서비스", "색상 서비스"). 그리고 Characteristic는 서비스의 작업입니다 (예: "날씨 서비스"에는 "날씨 데이터 가져오기", "날씨 데이터 가져오기 일시 중지/재개", "도시 변경"과 같은 여러 작업이 있습니다).</p>
<div class="content-ad"></div>
<p>서비스와 특성은 고유한 UUID가 필요합니다(일부는 이미 할당되어 있음). 나는 웹사이트에서 그들을 생성했어. 그들을 쉽게 식별하기 위해, 서비스의 UUID들의 동일한 생성된 시퀀스를 정의했지만 관련 작업마다 첫 부분을 간단한 증가로 변경했어:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">WEATHER</span> <span class="hljs-variable constant_">SERVICE</span>  - <span class="hljs-number">00000000</span>-8cb1-44ce-9a66-001dca0941a6
<span class="hljs-variable constant_">RETRIEVE</span> <span class="hljs-variable constant_">WEATHER</span> - <span class="hljs-number">00000001</span>-8cb1-44ce-9a66-001dca0941a6
<span class="hljs-variable constant_">RESUME</span> <span class="hljs-variable constant_">WEATHER</span>   - <span class="hljs-number">00000002</span>-8cb1-44ce-9a66-001dca0941a6
<span class="hljs-variable constant_">CHANGE</span> <span class="hljs-variable constant_">CITY</span> <span class="hljs-variable constant_">ID</span>   - <span class="hljs-number">00000003</span>-8cb1-44ce-9a66-001dca0941a6
<span class="hljs-variable constant_">COLOR</span> <span class="hljs-variable constant_">SERVICE</span>    - <span class="hljs-number">00000000</span>-<span class="hljs-number">8194</span>-<span class="hljs-number">4451</span>-aaf5-7874c7c16a27
<span class="hljs-variable constant_">CHANGE</span> <span class="hljs-variable constant_">COLOR</span>     - <span class="hljs-number">00000001</span>-<span class="hljs-number">8194</span>-<span class="hljs-number">4451</span>-aaf5-7874c7c16a27
</code></pre>
<p>마지막으로, 읽기, 쓰기 및 알림을 할 수 있는 특성들을 명시해야 했어:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">WEATHER</span> <span class="hljs-variable constant_">SERVICE</span>
<span class="hljs-variable constant_">RETRIEVE</span> <span class="hljs-variable constant_">WEATHER</span> - 읽기/알림
<span class="hljs-variable constant_">RESUME</span> <span class="hljs-variable constant_">WEATHER</span>   - 쓰기
<span class="hljs-variable constant_">CHANGE</span> <span class="hljs-variable constant_">CITY</span> <span class="hljs-variable constant_">ID</span>   - 읽기/쓰기
<span class="hljs-variable constant_">COLOR</span> <span class="hljs-variable constant_">SERVICE</span>
<span class="hljs-variable constant_">CHANGE</span> <span class="hljs-variable constant_">COLOR</span>     - 쓰기
</code></pre>
<div class="content-ad"></div>
<p>읽기 권한을 활성화하면 클라이언트가 캐릭터리스틱 값들을 읽을 수 있습니다. 쓰기 권한을 부여하면 클라이언트가 캐릭터리스틱에 값을 쓸 수 있습니다. 그리고 알림 권한은 서버가 클라이언트에게 캐릭터리스틱 값이 변경되었음을 알려주는 것입니다.</p>
<h1>2. Raspberry Pi</h1>
<p>Raspberry Pi를 이전하면 Bluetooth 소켓에서 RFCOMM을 통한 Python 스크립트를 BLE로 변경하는 것을 의미합니다.</p>
<p>나는 Douglas Otwell의 Python을 통해 RPi 센서에서 현재 온도를 가져오는 간단한 프로젝트를 찾았습니다. 그는 BlueZ 실험 버전을 기반으로 하고 BLE를 다루는 모듈을 만들었습니다. 나는 그것을 나만의 서비스와 캐릭터리스틱과 함께 사용했습니다.</p>
<div class="content-ad"></div>
<p>그가 만든 GATT 서버가 훌륭하고 명확했기 때문에, 나는 그의 애플리케이션 설정, 광고 및 도구 클래스를 복사했습니다. 이것들을 ble_gatt_server라는 특정 패키지로 옮겼어요:</p>
<pre><code class="hljs language-js">gatt_server.<span class="hljs-property">py</span>
main.<span class="hljs-property">py</span>
ble_gatt_server
    advertisement.<span class="hljs-property">py</span>
    bletools.<span class="hljs-property">py</span>
    service.<span class="hljs-property">py</span>
</code></pre>
<p>gatt_server.py는 내 애플리케이션의 선언입니다. Advertisement를 페리페럴 장치로서 인스턴스화합니다:</p>
<p>아래와 같이 서비스를 생성하고 특성을 연결합니다:</p>
<div class="content-ad"></div>
<p>Characteristics의 생성자에 이어서:</p>
<p>그리고 Service에서 데이터(온도, 날씨 ID, 도시 ID)를 가져오는 특정 함수들:</p>
<p>또는 클라이언트에게 새로운 값들을 알리는 방법:</p>
<p>마지막으로 main.py에서, BLE 애플리케이션을 선언하고 나의 서비스들을 추가하며, 클라이언트에게 변화한 값(예: 온도)을 알립니다:</p>
<div class="content-ad"></div>
<h1>3. 플러터 애플리케이션</h1>
<p>저는 flutter_bluetooth_serial 패키지를 사용하여 모바일 애플리케이션을 만들었습니다. 통신 프로세스를 다른 라이브러리인 flutter_blue로 변경해야 했습니다.</p>
<p>제 플러터 애플리케이션은 BLoC 패턴으로 설계되었습니다. 이 아키텍처는 변경하지 않고 모든 화면을 그대로 유지했습니다. 새 라이브러리와 작업하기 위해 BLoC 클래스만 업데이트했습니다.</p>
<p>BLE를 사용할 때, 모바일 앱은 연결되었을 때 서비스를 발견하고 BleBloc 클래스의 bleServices 목록에 저장해야 합니다.</p>
<div class="content-ad"></div>
<p>각 BLoC 생성자에 각각의 UUID와 함께 해당 서비스를 전달해요:</p>
<p>리스트 내에서 첫 번째 발생을 찾는 이 함수로 검색해요:</p>
<p>그들의 특성에 대해서도 동일한 방법이에요:</p>
<p>마지막으로, 모바일 앱은 업데이트를 청취하고 데이터를 디코딩해요. RPi가 속성이 변경되었다고 알릴 때 이미 그랬던 것처럼요:</p>
<div class="content-ad"></div>
<h1>4. 최종 결과</h1>
<p>BLE로의 이주가 완료되었습니다. RPi에서 main.py를 시작하면 다음 출력을 볼 수 있습니다:</p>
<pre><code class="hljs language-js">$ sudo python3 main.<span class="hljs-property">py</span>
<span class="hljs-variable constant_">GATT</span> 어플리케이션이 실행 중입니다
<span class="hljs-variable constant_">GATT</span> 어플리케이션이 등록되었습니다
<span class="hljs-variable constant_">GATT</span> 광고가 등록되었습니다
---
날씨 업데이트
요청 응답: <span class="hljs-number">18</span>°C (날씨: <span class="hljs-number">803</span>)
선택된 색: (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>)
---
날씨 업데이트
요청 응답: <span class="hljs-number">18</span>°C (날씨: <span class="hljs-number">803</span>)
선택된 색: (<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>)
</code></pre>
<p>이전과 같이, 스크립트는 5초마다 날씨 데이터를 가져와 "날씨 업데이트" 정보를 표시하고 데이터가 변경되었다고 알립니다. 기기가 연결되었을 때는 출력이 다음과 같습니다:</p>
<div class="content-ad"></div>
<hr>
<h2>날씨 업데이트
요청 응답: 18°C (날씨: 803)
선택된 색상: (255, 255, 0)
전송 중:  D=19,W=803,C=6454880</h2>
<p>날씨 업데이트
요청 응답: 18°C (날씨: 803)
선택된 색상: (255, 255, 0)
전송 중:  D=19,W=803,C=6454880</p>
<p>BLE의 주요 장점은 낮은 전력 소비를 사용한다는 것 이외에도 Classical Bluetooth보다 더 나은 방식으로 기능을 분할할 수 있다는 것입니다. 각 기능은 특정 서비스입니다. 이는 더 읽기 쉽고 깔끔합니다.</p>
<p>마지막으로, 업데이트하는 것은 예상보다 덜 고통스러웠습니다. Classical Bluetooth에서 BLE로 넘어가려면 양쪽에서 라이브러리를 변경하는 것뿐입니다. 음, 거의 그렇습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"라즈베리파이와 Flutter 사이에서 Bluetooth Low Energy 사용 방법","description":"","date":"2024-06-22 18:11","slug":"2024-06-22-UsingBluetoothLowEnergybetweenRaspberryPiandFlutter","content":"\n\n플러터의 멋진 점은 안드로이드, iOS 및 웹과 같은 다양한 플랫폼용 앱을 만들 수 있다는 것입니다. 그러나 iOS에서는 BLE(Bluetooth Low Energy) 프로토콜을 사용해야 합니다.\n\n이전에 플러터 응용 프로그램과 라즈베리 파이를 사용한 나의 프로젝트는 서로 통신하기 위해 클래식 블루투스를 사용했습니다. 정말 잘 작동했죠... 그러나 아버지께 선물로 줬었는데 — 아이폰을 사용하시는 분이라 — 제대로 사용할 수 없었답니다. 조금 답답했죠.\n\n그래서 이제 Python과 Flutter에서 BLE로 마이그레이션하기로 결정했습니다.\n\n# 1. Bluetooth Low Energy\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 첫 번째 이주 단계는 BLE를 이해하고 요구 사항을 준비하는 것입니다.\n\nAdafruit에서 이에 대해 잘 문서화된 주제를 다루었습니다: Bluetooth Low Energy 소개. BLE가 어떻게 작동하는지 모른다면, 이 기사는 꽤 좋은 시작점입니다.\n\nBLE 통신은 장치의 역할을 정의하기 위해 GAP (일반 접속 프로필)를 사용합니다. 이 프로젝트에서 RPi 스테이션은 페리페럴 장치로, 와이파이에 연결하고, 휴대폰과 연결하며, 원격 API를 통해 기상 데이터를 가져오고 반환합니다. 모바일 폰은 중앙 장치로, 받은 데이터를 표시하고 명령을 보냅니다.\n\nBLE를 통해 통신하기 위해 GATT (일반 속성 프로필)을 사용합니다. 이는 두 장치가 Profile, Service 및 Characteristic를 사용하여 서로 통신하는 방법을 정의합니다. 이 주제에서 모든 프로토콜을 설명하지는 않겠지만, 간단히 설명하면, 프로필은 서비스 모음이며, 서비스는 장치의 기능입니다 (예: \"날씨 서비스\", \"색상 서비스\"). 그리고 Characteristic는 서비스의 작업입니다 (예: \"날씨 서비스\"에는 \"날씨 데이터 가져오기\", \"날씨 데이터 가져오기 일시 중지/재개\", \"도시 변경\"과 같은 여러 작업이 있습니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n서비스와 특성은 고유한 UUID가 필요합니다(일부는 이미 할당되어 있음). 나는 웹사이트에서 그들을 생성했어. 그들을 쉽게 식별하기 위해, 서비스의 UUID들의 동일한 생성된 시퀀스를 정의했지만 관련 작업마다 첫 부분을 간단한 증가로 변경했어:\n\n```js\nWEATHER SERVICE  - 00000000-8cb1-44ce-9a66-001dca0941a6\nRETRIEVE WEATHER - 00000001-8cb1-44ce-9a66-001dca0941a6\nRESUME WEATHER   - 00000002-8cb1-44ce-9a66-001dca0941a6\nCHANGE CITY ID   - 00000003-8cb1-44ce-9a66-001dca0941a6\nCOLOR SERVICE    - 00000000-8194-4451-aaf5-7874c7c16a27\nCHANGE COLOR     - 00000001-8194-4451-aaf5-7874c7c16a27\n```\n\n마지막으로, 읽기, 쓰기 및 알림을 할 수 있는 특성들을 명시해야 했어:\n\n```js\nWEATHER SERVICE\nRETRIEVE WEATHER - 읽기/알림\nRESUME WEATHER   - 쓰기\nCHANGE CITY ID   - 읽기/쓰기\nCOLOR SERVICE\nCHANGE COLOR     - 쓰기\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n읽기 권한을 활성화하면 클라이언트가 캐릭터리스틱 값들을 읽을 수 있습니다. 쓰기 권한을 부여하면 클라이언트가 캐릭터리스틱에 값을 쓸 수 있습니다. 그리고 알림 권한은 서버가 클라이언트에게 캐릭터리스틱 값이 변경되었음을 알려주는 것입니다.\n\n# 2. Raspberry Pi\n\nRaspberry Pi를 이전하면 Bluetooth 소켓에서 RFCOMM을 통한 Python 스크립트를 BLE로 변경하는 것을 의미합니다.\n\n나는 Douglas Otwell의 Python을 통해 RPi 센서에서 현재 온도를 가져오는 간단한 프로젝트를 찾았습니다. 그는 BlueZ 실험 버전을 기반으로 하고 BLE를 다루는 모듈을 만들었습니다. 나는 그것을 나만의 서비스와 캐릭터리스틱과 함께 사용했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그가 만든 GATT 서버가 훌륭하고 명확했기 때문에, 나는 그의 애플리케이션 설정, 광고 및 도구 클래스를 복사했습니다. 이것들을 ble_gatt_server라는 특정 패키지로 옮겼어요:\n\n```js\ngatt_server.py\nmain.py\nble_gatt_server\n    advertisement.py\n    bletools.py\n    service.py\n```\n\ngatt_server.py는 내 애플리케이션의 선언입니다. Advertisement를 페리페럴 장치로서 인스턴스화합니다:\n\n아래와 같이 서비스를 생성하고 특성을 연결합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCharacteristics의 생성자에 이어서:\n\n그리고 Service에서 데이터(온도, 날씨 ID, 도시 ID)를 가져오는 특정 함수들:\n\n또는 클라이언트에게 새로운 값들을 알리는 방법:\n\n마지막으로 main.py에서, BLE 애플리케이션을 선언하고 나의 서비스들을 추가하며, 클라이언트에게 변화한 값(예: 온도)을 알립니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 플러터 애플리케이션\n\n저는 flutter_bluetooth_serial 패키지를 사용하여 모바일 애플리케이션을 만들었습니다. 통신 프로세스를 다른 라이브러리인 flutter_blue로 변경해야 했습니다.\n\n제 플러터 애플리케이션은 BLoC 패턴으로 설계되었습니다. 이 아키텍처는 변경하지 않고 모든 화면을 그대로 유지했습니다. 새 라이브러리와 작업하기 위해 BLoC 클래스만 업데이트했습니다.\n\nBLE를 사용할 때, 모바일 앱은 연결되었을 때 서비스를 발견하고 BleBloc 클래스의 bleServices 목록에 저장해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 BLoC 생성자에 각각의 UUID와 함께 해당 서비스를 전달해요:\n\n리스트 내에서 첫 번째 발생을 찾는 이 함수로 검색해요:\n\n그들의 특성에 대해서도 동일한 방법이에요:\n\n마지막으로, 모바일 앱은 업데이트를 청취하고 데이터를 디코딩해요. RPi가 속성이 변경되었다고 알릴 때 이미 그랬던 것처럼요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 4. 최종 결과\n\nBLE로의 이주가 완료되었습니다. RPi에서 main.py를 시작하면 다음 출력을 볼 수 있습니다:\n\n```js\n$ sudo python3 main.py\nGATT 어플리케이션이 실행 중입니다\nGATT 어플리케이션이 등록되었습니다\nGATT 광고가 등록되었습니다\n---\n날씨 업데이트\n요청 응답: 18°C (날씨: 803)\n선택된 색: (255, 255, 0)\n---\n날씨 업데이트\n요청 응답: 18°C (날씨: 803)\n선택된 색: (255, 255, 0)\n```\n\n이전과 같이, 스크립트는 5초마다 날씨 데이터를 가져와 \"날씨 업데이트\" 정보를 표시하고 데이터가 변경되었다고 알립니다. 기기가 연결되었을 때는 출력이 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n---\n날씨 업데이트\n요청 응답: 18°C (날씨: 803)\n선택된 색상: (255, 255, 0)\n전송 중:  D=19,W=803,C=6454880\n---\n날씨 업데이트\n요청 응답: 18°C (날씨: 803)\n선택된 색상: (255, 255, 0)\n전송 중:  D=19,W=803,C=6454880\n\n\nBLE의 주요 장점은 낮은 전력 소비를 사용한다는 것 이외에도 Classical Bluetooth보다 더 나은 방식으로 기능을 분할할 수 있다는 것입니다. 각 기능은 특정 서비스입니다. 이는 더 읽기 쉽고 깔끔합니다.\n\n마지막으로, 업데이트하는 것은 예상보다 덜 고통스러웠습니다. Classical Bluetooth에서 BLE로 넘어가려면 양쪽에서 라이브러리를 변경하는 것뿐입니다. 음, 거의 그렇습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-UsingBluetoothLowEnergybetweenRaspberryPiandFlutter_0.png"},"coverImage":"/assets/img/2024-06-22-UsingBluetoothLowEnergybetweenRaspberryPiandFlutter_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e플러터의 멋진 점은 안드로이드, iOS 및 웹과 같은 다양한 플랫폼용 앱을 만들 수 있다는 것입니다. 그러나 iOS에서는 BLE(Bluetooth Low Energy) 프로토콜을 사용해야 합니다.\u003c/p\u003e\n\u003cp\u003e이전에 플러터 응용 프로그램과 라즈베리 파이를 사용한 나의 프로젝트는 서로 통신하기 위해 클래식 블루투스를 사용했습니다. 정말 잘 작동했죠... 그러나 아버지께 선물로 줬었는데 — 아이폰을 사용하시는 분이라 — 제대로 사용할 수 없었답니다. 조금 답답했죠.\u003c/p\u003e\n\u003cp\u003e그래서 이제 Python과 Flutter에서 BLE로 마이그레이션하기로 결정했습니다.\u003c/p\u003e\n\u003ch1\u003e1. Bluetooth Low Energy\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e제 첫 번째 이주 단계는 BLE를 이해하고 요구 사항을 준비하는 것입니다.\u003c/p\u003e\n\u003cp\u003eAdafruit에서 이에 대해 잘 문서화된 주제를 다루었습니다: Bluetooth Low Energy 소개. BLE가 어떻게 작동하는지 모른다면, 이 기사는 꽤 좋은 시작점입니다.\u003c/p\u003e\n\u003cp\u003eBLE 통신은 장치의 역할을 정의하기 위해 GAP (일반 접속 프로필)를 사용합니다. 이 프로젝트에서 RPi 스테이션은 페리페럴 장치로, 와이파이에 연결하고, 휴대폰과 연결하며, 원격 API를 통해 기상 데이터를 가져오고 반환합니다. 모바일 폰은 중앙 장치로, 받은 데이터를 표시하고 명령을 보냅니다.\u003c/p\u003e\n\u003cp\u003eBLE를 통해 통신하기 위해 GATT (일반 속성 프로필)을 사용합니다. 이는 두 장치가 Profile, Service 및 Characteristic를 사용하여 서로 통신하는 방법을 정의합니다. 이 주제에서 모든 프로토콜을 설명하지는 않겠지만, 간단히 설명하면, 프로필은 서비스 모음이며, 서비스는 장치의 기능입니다 (예: \"날씨 서비스\", \"색상 서비스\"). 그리고 Characteristic는 서비스의 작업입니다 (예: \"날씨 서비스\"에는 \"날씨 데이터 가져오기\", \"날씨 데이터 가져오기 일시 중지/재개\", \"도시 변경\"과 같은 여러 작업이 있습니다).\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e서비스와 특성은 고유한 UUID가 필요합니다(일부는 이미 할당되어 있음). 나는 웹사이트에서 그들을 생성했어. 그들을 쉽게 식별하기 위해, 서비스의 UUID들의 동일한 생성된 시퀀스를 정의했지만 관련 작업마다 첫 부분을 간단한 증가로 변경했어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eWEATHER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSERVICE\u003c/span\u003e  - \u003cspan class=\"hljs-number\"\u003e00000000\u003c/span\u003e-8cb1-44ce-9a66-001dca0941a6\n\u003cspan class=\"hljs-variable constant_\"\u003eRETRIEVE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eWEATHER\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e00000001\u003c/span\u003e-8cb1-44ce-9a66-001dca0941a6\n\u003cspan class=\"hljs-variable constant_\"\u003eRESUME\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eWEATHER\u003c/span\u003e   - \u003cspan class=\"hljs-number\"\u003e00000002\u003c/span\u003e-8cb1-44ce-9a66-001dca0941a6\n\u003cspan class=\"hljs-variable constant_\"\u003eCHANGE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCITY\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e   - \u003cspan class=\"hljs-number\"\u003e00000003\u003c/span\u003e-8cb1-44ce-9a66-001dca0941a6\n\u003cspan class=\"hljs-variable constant_\"\u003eCOLOR\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSERVICE\u003c/span\u003e    - \u003cspan class=\"hljs-number\"\u003e00000000\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8194\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e4451\u003c/span\u003e-aaf5-7874c7c16a27\n\u003cspan class=\"hljs-variable constant_\"\u003eCHANGE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCOLOR\u003c/span\u003e     - \u003cspan class=\"hljs-number\"\u003e00000001\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e8194\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e4451\u003c/span\u003e-aaf5-7874c7c16a27\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, 읽기, 쓰기 및 알림을 할 수 있는 특성들을 명시해야 했어:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eWEATHER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSERVICE\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eRETRIEVE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eWEATHER\u003c/span\u003e - 읽기/알림\n\u003cspan class=\"hljs-variable constant_\"\u003eRESUME\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eWEATHER\u003c/span\u003e   - 쓰기\n\u003cspan class=\"hljs-variable constant_\"\u003eCHANGE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCITY\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e   - 읽기/쓰기\n\u003cspan class=\"hljs-variable constant_\"\u003eCOLOR\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSERVICE\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eCHANGE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCOLOR\u003c/span\u003e     - 쓰기\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e읽기 권한을 활성화하면 클라이언트가 캐릭터리스틱 값들을 읽을 수 있습니다. 쓰기 권한을 부여하면 클라이언트가 캐릭터리스틱에 값을 쓸 수 있습니다. 그리고 알림 권한은 서버가 클라이언트에게 캐릭터리스틱 값이 변경되었음을 알려주는 것입니다.\u003c/p\u003e\n\u003ch1\u003e2. Raspberry Pi\u003c/h1\u003e\n\u003cp\u003eRaspberry Pi를 이전하면 Bluetooth 소켓에서 RFCOMM을 통한 Python 스크립트를 BLE로 변경하는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e나는 Douglas Otwell의 Python을 통해 RPi 센서에서 현재 온도를 가져오는 간단한 프로젝트를 찾았습니다. 그는 BlueZ 실험 버전을 기반으로 하고 BLE를 다루는 모듈을 만들었습니다. 나는 그것을 나만의 서비스와 캐릭터리스틱과 함께 사용했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그가 만든 GATT 서버가 훌륭하고 명확했기 때문에, 나는 그의 애플리케이션 설정, 광고 및 도구 클래스를 복사했습니다. 이것들을 ble_gatt_server라는 특정 패키지로 옮겼어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003egatt_server.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\nmain.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\nble_gatt_server\n    advertisement.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n    bletools.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n    service.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003egatt_server.py는 내 애플리케이션의 선언입니다. Advertisement를 페리페럴 장치로서 인스턴스화합니다:\u003c/p\u003e\n\u003cp\u003e아래와 같이 서비스를 생성하고 특성을 연결합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eCharacteristics의 생성자에 이어서:\u003c/p\u003e\n\u003cp\u003e그리고 Service에서 데이터(온도, 날씨 ID, 도시 ID)를 가져오는 특정 함수들:\u003c/p\u003e\n\u003cp\u003e또는 클라이언트에게 새로운 값들을 알리는 방법:\u003c/p\u003e\n\u003cp\u003e마지막으로 main.py에서, BLE 애플리케이션을 선언하고 나의 서비스들을 추가하며, 클라이언트에게 변화한 값(예: 온도)을 알립니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e3. 플러터 애플리케이션\u003c/h1\u003e\n\u003cp\u003e저는 flutter_bluetooth_serial 패키지를 사용하여 모바일 애플리케이션을 만들었습니다. 통신 프로세스를 다른 라이브러리인 flutter_blue로 변경해야 했습니다.\u003c/p\u003e\n\u003cp\u003e제 플러터 애플리케이션은 BLoC 패턴으로 설계되었습니다. 이 아키텍처는 변경하지 않고 모든 화면을 그대로 유지했습니다. 새 라이브러리와 작업하기 위해 BLoC 클래스만 업데이트했습니다.\u003c/p\u003e\n\u003cp\u003eBLE를 사용할 때, 모바일 앱은 연결되었을 때 서비스를 발견하고 BleBloc 클래스의 bleServices 목록에 저장해야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e각 BLoC 생성자에 각각의 UUID와 함께 해당 서비스를 전달해요:\u003c/p\u003e\n\u003cp\u003e리스트 내에서 첫 번째 발생을 찾는 이 함수로 검색해요:\u003c/p\u003e\n\u003cp\u003e그들의 특성에 대해서도 동일한 방법이에요:\u003c/p\u003e\n\u003cp\u003e마지막으로, 모바일 앱은 업데이트를 청취하고 데이터를 디코딩해요. RPi가 속성이 변경되었다고 알릴 때 이미 그랬던 것처럼요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e4. 최종 결과\u003c/h1\u003e\n\u003cp\u003eBLE로의 이주가 완료되었습니다. RPi에서 main.py를 시작하면 다음 출력을 볼 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ sudo python3 main.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eGATT\u003c/span\u003e 어플리케이션이 실행 중입니다\n\u003cspan class=\"hljs-variable constant_\"\u003eGATT\u003c/span\u003e 어플리케이션이 등록되었습니다\n\u003cspan class=\"hljs-variable constant_\"\u003eGATT\u003c/span\u003e 광고가 등록되었습니다\n---\n날씨 업데이트\n요청 응답: \u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e°C (날씨: \u003cspan class=\"hljs-number\"\u003e803\u003c/span\u003e)\n선택된 색: (\u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n---\n날씨 업데이트\n요청 응답: \u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e°C (날씨: \u003cspan class=\"hljs-number\"\u003e803\u003c/span\u003e)\n선택된 색: (\u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이전과 같이, 스크립트는 5초마다 날씨 데이터를 가져와 \"날씨 업데이트\" 정보를 표시하고 데이터가 변경되었다고 알립니다. 기기가 연결되었을 때는 출력이 다음과 같습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003chr\u003e\n\u003ch2\u003e날씨 업데이트\n요청 응답: 18°C (날씨: 803)\n선택된 색상: (255, 255, 0)\n전송 중:  D=19,W=803,C=6454880\u003c/h2\u003e\n\u003cp\u003e날씨 업데이트\n요청 응답: 18°C (날씨: 803)\n선택된 색상: (255, 255, 0)\n전송 중:  D=19,W=803,C=6454880\u003c/p\u003e\n\u003cp\u003eBLE의 주요 장점은 낮은 전력 소비를 사용한다는 것 이외에도 Classical Bluetooth보다 더 나은 방식으로 기능을 분할할 수 있다는 것입니다. 각 기능은 특정 서비스입니다. 이는 더 읽기 쉽고 깔끔합니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, 업데이트하는 것은 예상보다 덜 고통스러웠습니다. Classical Bluetooth에서 BLE로 넘어가려면 양쪽에서 라이브러리를 변경하는 것뿐입니다. 음, 거의 그렇습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-UsingBluetoothLowEnergybetweenRaspberryPiandFlutter"},"buildId":"8coAiP0lmiEK5aH6nkQkj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>