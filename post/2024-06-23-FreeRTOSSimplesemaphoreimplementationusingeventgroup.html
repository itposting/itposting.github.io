<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup" data-gatsby-head="true"/><meta name="twitter:title" content="FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 17:31" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png" alt="Image"></p>
<p>웹 소프트웨어 엔지니어인 저와 같은 경우에는 실시간 프로그래밍 개념을 이해하기 어려울 수 있습니다.
이 짧은 기사에서는 여러 멀티스레딩 작업의 완료를 기다리기 위한 세마포어 패턴을 구현하는 쉬운 기술을 소개하겠습니다.</p>
<h1>정의</h1>
<ul>
<li>
<p>FreeRTOS 작업
FreeRTOS 작업은 FreeRTOS 실시간 운영 체제 내에서 실행되는 작고 독립적인 프로그램 세그먼트입니다. 각 작업은 특정 작업을 수행하도록 설계되었으며 FreeRTOS 스케줄러에 의해 관리되는 다른 작업과 준동시에 작동합니다. FreeRTOS의 작업은 우선 순위를 부여할 수 있어, 스케줄러가 작업 우선 순위에 따라 실행 흐름을 관리하고 시간에 민감한 작업을 효과적으로 처리할 수 있게 합니다. 이를 통해 응용 프로그램은 여러 작업 간에 작업을 나누어 다루므로 다양한 응용 프로그램 요구 사항을 처리할 수 있습니다.</p>
</li>
<li>
<p>카운팅 세마포어
FreeRTOS의 카운팅 세마포어는 공유 리소스에 대한 액세스를 관리하거나 가용성에 따라 작업을 동기화하는 동기화 메커니즘입니다. 두 가지 상태만을 갖는 이진 세마포어와 달리 카운팅 세마포어는 가용 리소스의 개수나 이벤트가 발생하기 전에 실행 흐름을 차단/해제하는 횟수를 나타내는 값을 유지합니다.</p>
</li>
</ul>
<div class="content-ad"></div>
<h1>TL;DR — The code</h1>
<p>데모 코드는 "xTaskCreate"를 사용하여 세 가지 작업을 실행하며 "xEventGroupCreate"로 생성된 이벤트 그룹을 사용하여 카운팅 세마포어를 구현합니다. 메인 작업은 생성된 모든 작업이 실행된 후에만 종료되도록 기다립니다.</p>
<pre><code class="hljs language-js">#include &#x3C;<span class="hljs-title class_">Arduino</span>.<span class="hljs-property">h</span>>

<span class="hljs-comment">// 카운팅 세마포어를 구현하는 그룹 핸들</span>
<span class="hljs-keyword">static</span> <span class="hljs-title class_">EventGroupHandle</span>_t eventGroup;

<span class="hljs-comment">// 각 작업에 대한 비트 마스크 정의</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBits</span>_t <span class="hljs-variable constant_">TASK_1_BIT</span> = (<span class="hljs-number">1</span> &#x3C;&#x3C; <span class="hljs-number">0</span>); <span class="hljs-comment">// 00000001</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBits</span>_t <span class="hljs-variable constant_">TASK_2_BIT</span> = (<span class="hljs-number">1</span> &#x3C;&#x3C; <span class="hljs-number">1</span>); <span class="hljs-comment">// 00000010</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBits</span>_t <span class="hljs-variable constant_">TASK_3_BIT</span> = (<span class="hljs-number">1</span> &#x3C;&#x3C; <span class="hljs-number">2</span>); <span class="hljs-comment">// 00000100</span>

<span class="hljs-keyword">void</span> <span class="hljs-title function_">taskFunction</span>(<span class="hljs-params"><span class="hljs-keyword">void</span> *pvParameters</span>) {
    int taskNumber = ((int)pvParameters);
    <span class="hljs-comment">// 작업 번호를 기반으로 설정할 비트 계산</span>
    <span class="hljs-title class_">EventBits</span>_t taskBit = (<span class="hljs-number">1</span> &#x3C;&#x3C; (taskNumber - <span class="hljs-number">1</span>));

    <span class="hljs-keyword">for</span>(int i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">5</span>; i++) {
        <span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">printf</span>(<span class="hljs-string">"Task %d is executing...\n"</span>, taskNumber);
        <span class="hljs-title function_">vTaskDelay</span>(<span class="hljs-title function_">pdMS_TO_TICKS</span>(<span class="hljs-number">1000</span>)); <span class="hljs-comment">// 작업 활동 시뮬레이션</span>
    }

    <span class="hljs-comment">// 이 작업을 위해 이벤트 그룹에 적합한 비트 설정</span>
    <span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">printf</span>(<span class="hljs-string">"Task %d completed and bit set.\n"</span>, taskNumber);
    <span class="hljs-title function_">xEventGroupSetBits</span>(eventGroup, taskBit);
    <span class="hljs-comment">// 완료되면 이 작업 삭제</span>
    <span class="hljs-title function_">vTaskDelete</span>(<span class="hljs-variable constant_">NULL</span>);
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">begin</span>(<span class="hljs-number">115200</span>);
    <span class="hljs-keyword">while</span> (!<span class="hljs-title class_">Serial</span>);

     <span class="hljs-comment">// 이벤트 그룹 생성</span>
    eventGroup = <span class="hljs-title function_">xEventGroupCreate</span>();
    <span class="hljs-keyword">if</span> (eventGroup == <span class="hljs-variable constant_">NULL</span>) {
        <span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"이벤트 그룹 생성 실패. 힙 부족일 수 있습니다."</span>);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// 작업에 전달할 매개변수, 작업 번호를 나타냄</span>
    <span class="hljs-keyword">static</span> int taskParams[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
    <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">3</span>; i++) {
        <span class="hljs-title function_">xTaskCreate</span>(
            taskFunction,            <span class="hljs-comment">// 작업 함수</span>
            <span class="hljs-string">"Task"</span>,                  <span class="hljs-comment">// 작업 이름</span>
            <span class="hljs-number">2048</span>,                    <span class="hljs-comment">// 스택 크기</span>
            &#x26;taskParams[i],          <span class="hljs-comment">// 매개변수 (작업 번호)</span>
            <span class="hljs-number">1</span>,                       <span class="hljs-comment">// 우선순위</span>
            <span class="hljs-variable constant_">NULL</span>                     <span class="hljs-comment">// 사용하지 않는 작업 핸들</span>
        );
    }

    <span class="hljs-comment">// 모든 작업이 비트를 설정할 때까지 기다림</span>
    <span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"작업 완료 대기 중..."</span>);
    <span class="hljs-title function_">xEventGroupWaitBits</span>(
        eventGroup,                          <span class="hljs-comment">// 테스트할 이벤트 그룹.</span>
        <span class="hljs-variable constant_">TASK_1_BIT</span> | <span class="hljs-variable constant_">TASK_2_BIT</span> | <span class="hljs-variable constant_">TASK_3_BIT</span>, <span class="hljs-comment">// 기다릴 이벤트 그룹 내 비트.</span>
        pdTRUE,                              <span class="hljs-comment">// 종료 시 비트 지우기.</span>
        pdTRUE,                              <span class="hljs-comment">// 모든 비트를 기다림.</span>
        portMAX_DELAY                        <span class="hljs-comment">// 무기한 대기.</span>
    );

    <span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"모든 작업 완료됨."</span>);
    <span class="hljs-comment">// 이벤트 그룹 정리</span>
    <span class="hljs-title function_">vEventGroupDelete</span>(eventGroup);
}

<span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>) {}
</code></pre>
<h1>자세한 설명</h1>
<div class="content-ad"></div>
<ul>
<li>이벤트 그룹 핸들이 선언되었습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 카운팅 세마포어를 구현하는 그룹 핸들</span>
<span class="hljs-keyword">static</span> <span class="hljs-title class_">EventGroupHandle</span>_t eventGroup;
</code></pre>
<ul>
<li>각 작업은 숫자 ID에 연결되며, 이는 비트 시퀀스의 인덱스를 나타냅니다. 작업이 완료되었는지 확인하는 데 세 개의 비트 마스크가 사용됩니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 각 작업을 위한 비트 마스크 정의</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBits</span>_t <span class="hljs-variable constant_">TASK_1_BIT</span> = (<span class="hljs-number">1</span> &#x3C;&#x3C; <span class="hljs-number">0</span>); <span class="hljs-comment">// 00000001</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBits</span>_t <span class="hljs-variable constant_">TASK_2_BIT</span> = (<span class="hljs-number">1</span> &#x3C;&#x3C; <span class="hljs-number">1</span>); <span class="hljs-comment">// 00000010</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBits</span>_t <span class="hljs-variable constant_">TASK_3_BIT</span> = (<span class="hljs-number">1</span> &#x3C;&#x3C; <span class="hljs-number">2</span>); <span class="hljs-comment">// 00000100</span>
</code></pre>
<div class="content-ad"></div>
<ul>
<li>주요 작업은 작업 번호를 매개변수로 전달하여 세 가지 작업을 생성합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 작업에 전달할 매개변수, 작업 번호를 나타냄</span>
<span class="hljs-keyword">static</span> int taskParams[<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
<span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">3</span>; i++) {
    <span class="hljs-title function_">xTaskCreate</span>(
        taskFunction,            <span class="hljs-comment">// 작업 함수</span>
        <span class="hljs-string">"Task"</span>,                  <span class="hljs-comment">// 작업 이름</span>
        <span class="hljs-number">2048</span>,                    <span class="hljs-comment">// 스택 크기</span>
        &#x26;taskParams[i],          <span class="hljs-comment">// 매개변수 (작업 번호)</span>
        <span class="hljs-number">1</span>,                       <span class="hljs-comment">// 우선 순위</span>
        <span class="hljs-variable constant_">NULL</span>                     <span class="hljs-comment">// 작업 핸들은 사용하지 않음</span>
    );
}
</code></pre>
<ul>
<li>작업 번호는 "EventBits_t" 변수를 생성하는 데 사용되며 해당하는 양 만큼 비트를 왼쪽으로 이동시킵니다.</li>
</ul>
<pre><code class="hljs language-js">int taskNumber = ((int)pvParameters);
<span class="hljs-comment">// 작업 번호를 기반으로 설정할 비트를 계산</span>
<span class="hljs-title class_">EventBits</span>_t taskBit = (<span class="hljs-number">1</span> &#x3C;&#x3C; (taskNumber - <span class="hljs-number">1</span>));
</code></pre>
<div class="content-ad"></div>
<ul>
<li>작업이 완료되면 그룹에 신호를 보내고 자체를 삭제합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 이벤트 그룹에서이 작업에 대한 적절한 비트 설정</span>
<span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">printf</span>(<span class="hljs-string">"작업 %d가 완료되었고 비트가 설정되었습니다.\n"</span>, taskNumber);
<span class="hljs-title function_">xEventGroupSetBits</span>(eventGroup, taskBit);
<span class="hljs-comment">// 완료되면이 작업 삭제</span>
<span class="hljs-title function_">vTaskDelete</span>(<span class="hljs-variable constant_">NULL</span>);
</code></pre>
<ul>
<li>주 작업은 비트 마스크를 사용하여 그룹 내 세 개의 비트가 1로 설정될 때까지 기다리고 즉시 실행을 다시 시작합니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-comment">// 모든 작업이 비트를 설정 할 때까지 대기</span>
<span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"작업이 완료 될 때까지 대기 중 ..."</span>);
<span class="hljs-title function_">xEventGroupWaitBits</span>(
    eventGroup,                          <span class="hljs-comment">// 테스트되는 이벤트 그룹.</span>
    <span class="hljs-variable constant_">TASK_1_BIT</span> | <span class="hljs-variable constant_">TASK_2_BIT</span> | <span class="hljs-variable constant_">TASK_3_BIT</span>, <span class="hljs-comment">// 대기해야 하는 이벤트 그룹 내의 비트.</span>
    pdTRUE,                              <span class="hljs-comment">// 종료시 비트 지우기.</span>
    pdTRUE,                              <span class="hljs-comment">// 모든 비트를 대기합니다.</span>
    portMAX_DELAY                        <span class="hljs-comment">// 무기한 대기.</span>
);
</code></pre>
<div class="content-ad"></div>
<ul>
<li>마침내 이벤트 그룹이 삭제되었습니다.</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-title class_">Serial</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">"모든 작업이 완료되었습니다."</span>);
<span class="hljs-comment">// 이벤트 그룹 정리</span>
<span class="hljs-title function_">vEventGroupDelete</span>(eventGroup);
</code></pre>
<h1>결론</h1>
<p>이 유용한 기술은 FreeRTOS 기능만을 사용하여 동기화를 강제하는 간단한 방법입니다. 따라서 무분별한 코드 부하를 피할 수 있습니다. 여러분의 프로젝트에 유용하게 활용하시기를 바랍니다. 읽어주셔서 감사합니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"FreeRTOS  이벤트 그룹을 사용하여 간단한 세마포어 구현 방법","description":"","date":"2024-06-23 17:31","slug":"2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup","content":"\n\n\n![Image](/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png)\n\n웹 소프트웨어 엔지니어인 저와 같은 경우에는 실시간 프로그래밍 개념을 이해하기 어려울 수 있습니다. \n이 짧은 기사에서는 여러 멀티스레딩 작업의 완료를 기다리기 위한 세마포어 패턴을 구현하는 쉬운 기술을 소개하겠습니다.\n\n# 정의\n\n- FreeRTOS 작업\nFreeRTOS 작업은 FreeRTOS 실시간 운영 체제 내에서 실행되는 작고 독립적인 프로그램 세그먼트입니다. 각 작업은 특정 작업을 수행하도록 설계되었으며 FreeRTOS 스케줄러에 의해 관리되는 다른 작업과 준동시에 작동합니다. FreeRTOS의 작업은 우선 순위를 부여할 수 있어, 스케줄러가 작업 우선 순위에 따라 실행 흐름을 관리하고 시간에 민감한 작업을 효과적으로 처리할 수 있게 합니다. 이를 통해 응용 프로그램은 여러 작업 간에 작업을 나누어 다루므로 다양한 응용 프로그램 요구 사항을 처리할 수 있습니다.\n\n- 카운팅 세마포어\nFreeRTOS의 카운팅 세마포어는 공유 리소스에 대한 액세스를 관리하거나 가용성에 따라 작업을 동기화하는 동기화 메커니즘입니다. 두 가지 상태만을 갖는 이진 세마포어와 달리 카운팅 세마포어는 가용 리소스의 개수나 이벤트가 발생하기 전에 실행 흐름을 차단/해제하는 횟수를 나타내는 값을 유지합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# TL;DR — The code\n\n데모 코드는 \"xTaskCreate\"를 사용하여 세 가지 작업을 실행하며 \"xEventGroupCreate\"로 생성된 이벤트 그룹을 사용하여 카운팅 세마포어를 구현합니다. 메인 작업은 생성된 모든 작업이 실행된 후에만 종료되도록 기다립니다.\n\n```js\n#include \u003cArduino.h\u003e\n\n// 카운팅 세마포어를 구현하는 그룹 핸들\nstatic EventGroupHandle_t eventGroup;\n\n// 각 작업에 대한 비트 마스크 정의\nconst EventBits_t TASK_1_BIT = (1 \u003c\u003c 0); // 00000001\nconst EventBits_t TASK_2_BIT = (1 \u003c\u003c 1); // 00000010\nconst EventBits_t TASK_3_BIT = (1 \u003c\u003c 2); // 00000100\n\nvoid taskFunction(void *pvParameters) {\n    int taskNumber = ((int)pvParameters);\n    // 작업 번호를 기반으로 설정할 비트 계산\n    EventBits_t taskBit = (1 \u003c\u003c (taskNumber - 1));\n\n    for(int i = 0; i \u003c 5; i++) {\n        Serial.printf(\"Task %d is executing...\\n\", taskNumber);\n        vTaskDelay(pdMS_TO_TICKS(1000)); // 작업 활동 시뮬레이션\n    }\n\n    // 이 작업을 위해 이벤트 그룹에 적합한 비트 설정\n    Serial.printf(\"Task %d completed and bit set.\\n\", taskNumber);\n    xEventGroupSetBits(eventGroup, taskBit);\n    // 완료되면 이 작업 삭제\n    vTaskDelete(NULL);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    while (!Serial);\n\n     // 이벤트 그룹 생성\n    eventGroup = xEventGroupCreate();\n    if (eventGroup == NULL) {\n        Serial.println(\"이벤트 그룹 생성 실패. 힙 부족일 수 있습니다.\");\n        return;\n    }\n\n    // 작업에 전달할 매개변수, 작업 번호를 나타냄\n    static int taskParams[3] = {1, 2, 3};\n    for (int i = 0; i \u003c 3; i++) {\n        xTaskCreate(\n            taskFunction,            // 작업 함수\n            \"Task\",                  // 작업 이름\n            2048,                    // 스택 크기\n            \u0026taskParams[i],          // 매개변수 (작업 번호)\n            1,                       // 우선순위\n            NULL                     // 사용하지 않는 작업 핸들\n        );\n    }\n\n    // 모든 작업이 비트를 설정할 때까지 기다림\n    Serial.println(\"작업 완료 대기 중...\");\n    xEventGroupWaitBits(\n        eventGroup,                          // 테스트할 이벤트 그룹.\n        TASK_1_BIT | TASK_2_BIT | TASK_3_BIT, // 기다릴 이벤트 그룹 내 비트.\n        pdTRUE,                              // 종료 시 비트 지우기.\n        pdTRUE,                              // 모든 비트를 기다림.\n        portMAX_DELAY                        // 무기한 대기.\n    );\n\n    Serial.println(\"모든 작업 완료됨.\");\n    // 이벤트 그룹 정리\n    vEventGroupDelete(eventGroup);\n}\n\nvoid loop() {}\n```\n\n# 자세한 설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이벤트 그룹 핸들이 선언되었습니다.\n\n```js\n// 카운팅 세마포어를 구현하는 그룹 핸들\nstatic EventGroupHandle_t eventGroup;\n```\n\n- 각 작업은 숫자 ID에 연결되며, 이는 비트 시퀀스의 인덱스를 나타냅니다. 작업이 완료되었는지 확인하는 데 세 개의 비트 마스크가 사용됩니다.\n\n```js\n// 각 작업을 위한 비트 마스크 정의\nconst EventBits_t TASK_1_BIT = (1 \u003c\u003c 0); // 00000001\nconst EventBits_t TASK_2_BIT = (1 \u003c\u003c 1); // 00000010\nconst EventBits_t TASK_3_BIT = (1 \u003c\u003c 2); // 00000100\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 주요 작업은 작업 번호를 매개변수로 전달하여 세 가지 작업을 생성합니다.\n\n```js\n// 작업에 전달할 매개변수, 작업 번호를 나타냄\nstatic int taskParams[3] = {1, 2, 3};\nfor (int i = 0; i \u003c 3; i++) {\n    xTaskCreate(\n        taskFunction,            // 작업 함수\n        \"Task\",                  // 작업 이름\n        2048,                    // 스택 크기\n        \u0026taskParams[i],          // 매개변수 (작업 번호)\n        1,                       // 우선 순위\n        NULL                     // 작업 핸들은 사용하지 않음\n    );\n}\n```\n\n- 작업 번호는 \"EventBits_t\" 변수를 생성하는 데 사용되며 해당하는 양 만큼 비트를 왼쪽으로 이동시킵니다.\n\n```js\nint taskNumber = ((int)pvParameters);\n// 작업 번호를 기반으로 설정할 비트를 계산\nEventBits_t taskBit = (1 \u003c\u003c (taskNumber - 1));\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 작업이 완료되면 그룹에 신호를 보내고 자체를 삭제합니다.\n\n```js\n// 이벤트 그룹에서이 작업에 대한 적절한 비트 설정\nSerial.printf(\"작업 %d가 완료되었고 비트가 설정되었습니다.\\n\", taskNumber);\nxEventGroupSetBits(eventGroup, taskBit);\n// 완료되면이 작업 삭제\nvTaskDelete(NULL);\n```\n\n- 주 작업은 비트 마스크를 사용하여 그룹 내 세 개의 비트가 1로 설정될 때까지 기다리고 즉시 실행을 다시 시작합니다.\n\n```js\n// 모든 작업이 비트를 설정 할 때까지 대기\nSerial.println(\"작업이 완료 될 때까지 대기 중 ...\");\nxEventGroupWaitBits(\n    eventGroup,                          // 테스트되는 이벤트 그룹.\n    TASK_1_BIT | TASK_2_BIT | TASK_3_BIT, // 대기해야 하는 이벤트 그룹 내의 비트.\n    pdTRUE,                              // 종료시 비트 지우기.\n    pdTRUE,                              // 모든 비트를 대기합니다.\n    portMAX_DELAY                        // 무기한 대기.\n);\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 마침내 이벤트 그룹이 삭제되었습니다.\n\n```js\nSerial.println(\"모든 작업이 완료되었습니다.\");\n// 이벤트 그룹 정리\nvEventGroupDelete(eventGroup);\n```\n\n# 결론\n\n이 유용한 기술은 FreeRTOS 기능만을 사용하여 동기화를 강제하는 간단한 방법입니다. 따라서 무분별한 코드 부하를 피할 수 있습니다. 여러분의 프로젝트에 유용하게 활용하시기를 바랍니다. 읽어주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png"},"coverImage":"/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup_0.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e웹 소프트웨어 엔지니어인 저와 같은 경우에는 실시간 프로그래밍 개념을 이해하기 어려울 수 있습니다.\n이 짧은 기사에서는 여러 멀티스레딩 작업의 완료를 기다리기 위한 세마포어 패턴을 구현하는 쉬운 기술을 소개하겠습니다.\u003c/p\u003e\n\u003ch1\u003e정의\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eFreeRTOS 작업\nFreeRTOS 작업은 FreeRTOS 실시간 운영 체제 내에서 실행되는 작고 독립적인 프로그램 세그먼트입니다. 각 작업은 특정 작업을 수행하도록 설계되었으며 FreeRTOS 스케줄러에 의해 관리되는 다른 작업과 준동시에 작동합니다. FreeRTOS의 작업은 우선 순위를 부여할 수 있어, 스케줄러가 작업 우선 순위에 따라 실행 흐름을 관리하고 시간에 민감한 작업을 효과적으로 처리할 수 있게 합니다. 이를 통해 응용 프로그램은 여러 작업 간에 작업을 나누어 다루므로 다양한 응용 프로그램 요구 사항을 처리할 수 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e카운팅 세마포어\nFreeRTOS의 카운팅 세마포어는 공유 리소스에 대한 액세스를 관리하거나 가용성에 따라 작업을 동기화하는 동기화 메커니즘입니다. 두 가지 상태만을 갖는 이진 세마포어와 달리 카운팅 세마포어는 가용 리소스의 개수나 이벤트가 발생하기 전에 실행 흐름을 차단/해제하는 횟수를 나타내는 값을 유지합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eTL;DR — The code\u003c/h1\u003e\n\u003cp\u003e데모 코드는 \"xTaskCreate\"를 사용하여 세 가지 작업을 실행하며 \"xEventGroupCreate\"로 생성된 이벤트 그룹을 사용하여 카운팅 세마포어를 구현합니다. 메인 작업은 생성된 모든 작업이 실행된 후에만 종료되도록 기다립니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#include \u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eArduino\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 카운팅 세마포어를 구현하는 그룹 핸들\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEventGroupHandle\u003c/span\u003e_t eventGroup;\n\n\u003cspan class=\"hljs-comment\"\u003e// 각 작업에 대한 비트 마스크 정의\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEventBits\u003c/span\u003e_t \u003cspan class=\"hljs-variable constant_\"\u003eTASK_1_BIT\u003c/span\u003e = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 00000001\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEventBits\u003c/span\u003e_t \u003cspan class=\"hljs-variable constant_\"\u003eTASK_2_BIT\u003c/span\u003e = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 00000010\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEventBits\u003c/span\u003e_t \u003cspan class=\"hljs-variable constant_\"\u003eTASK_3_BIT\u003c/span\u003e = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 00000100\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etaskFunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e *pvParameters\u003c/span\u003e) {\n    int taskNumber = ((int)pvParameters);\n    \u003cspan class=\"hljs-comment\"\u003e// 작업 번호를 기반으로 설정할 비트 계산\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eEventBits\u003c/span\u003e_t taskBit = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026#x3C;\u0026#x3C; (taskNumber - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e));\n\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(int i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e; i++) {\n        \u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Task %d is executing...\\n\"\u003c/span\u003e, taskNumber);\n        \u003cspan class=\"hljs-title function_\"\u003evTaskDelay\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003epdMS_TO_TICKS\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 작업 활동 시뮬레이션\u003c/span\u003e\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 이 작업을 위해 이벤트 그룹에 적합한 비트 설정\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Task %d completed and bit set.\\n\"\u003c/span\u003e, taskNumber);\n    \u003cspan class=\"hljs-title function_\"\u003exEventGroupSetBits\u003c/span\u003e(eventGroup, taskBit);\n    \u003cspan class=\"hljs-comment\"\u003e// 완료되면 이 작업 삭제\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003evTaskDelete\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eNULL\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetup\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebegin\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e115200\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (!\u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e);\n\n     \u003cspan class=\"hljs-comment\"\u003e// 이벤트 그룹 생성\u003c/span\u003e\n    eventGroup = \u003cspan class=\"hljs-title function_\"\u003exEventGroupCreate\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (eventGroup == \u003cspan class=\"hljs-variable constant_\"\u003eNULL\u003c/span\u003e) {\n        \u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"이벤트 그룹 생성 실패. 힙 부족일 수 있습니다.\"\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 작업에 전달할 매개변수, 작업 번호를 나타냄\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e int taskParams[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] = {\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e};\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (int i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e; i++) {\n        \u003cspan class=\"hljs-title function_\"\u003exTaskCreate\u003c/span\u003e(\n            taskFunction,            \u003cspan class=\"hljs-comment\"\u003e// 작업 함수\u003c/span\u003e\n            \u003cspan class=\"hljs-string\"\u003e\"Task\"\u003c/span\u003e,                  \u003cspan class=\"hljs-comment\"\u003e// 작업 이름\u003c/span\u003e\n            \u003cspan class=\"hljs-number\"\u003e2048\u003c/span\u003e,                    \u003cspan class=\"hljs-comment\"\u003e// 스택 크기\u003c/span\u003e\n            \u0026#x26;taskParams[i],          \u003cspan class=\"hljs-comment\"\u003e// 매개변수 (작업 번호)\u003c/span\u003e\n            \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,                       \u003cspan class=\"hljs-comment\"\u003e// 우선순위\u003c/span\u003e\n            \u003cspan class=\"hljs-variable constant_\"\u003eNULL\u003c/span\u003e                     \u003cspan class=\"hljs-comment\"\u003e// 사용하지 않는 작업 핸들\u003c/span\u003e\n        );\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 모든 작업이 비트를 설정할 때까지 기다림\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"작업 완료 대기 중...\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-title function_\"\u003exEventGroupWaitBits\u003c/span\u003e(\n        eventGroup,                          \u003cspan class=\"hljs-comment\"\u003e// 테스트할 이벤트 그룹.\u003c/span\u003e\n        \u003cspan class=\"hljs-variable constant_\"\u003eTASK_1_BIT\u003c/span\u003e | \u003cspan class=\"hljs-variable constant_\"\u003eTASK_2_BIT\u003c/span\u003e | \u003cspan class=\"hljs-variable constant_\"\u003eTASK_3_BIT\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 기다릴 이벤트 그룹 내 비트.\u003c/span\u003e\n        pdTRUE,                              \u003cspan class=\"hljs-comment\"\u003e// 종료 시 비트 지우기.\u003c/span\u003e\n        pdTRUE,                              \u003cspan class=\"hljs-comment\"\u003e// 모든 비트를 기다림.\u003c/span\u003e\n        portMAX_DELAY                        \u003cspan class=\"hljs-comment\"\u003e// 무기한 대기.\u003c/span\u003e\n    );\n\n    \u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"모든 작업 완료됨.\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-comment\"\u003e// 이벤트 그룹 정리\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003evEventGroupDelete\u003c/span\u003e(eventGroup);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloop\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e자세한 설명\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e이벤트 그룹 핸들이 선언되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 카운팅 세마포어를 구현하는 그룹 핸들\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEventGroupHandle\u003c/span\u003e_t eventGroup;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e각 작업은 숫자 ID에 연결되며, 이는 비트 시퀀스의 인덱스를 나타냅니다. 작업이 완료되었는지 확인하는 데 세 개의 비트 마스크가 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 각 작업을 위한 비트 마스크 정의\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEventBits\u003c/span\u003e_t \u003cspan class=\"hljs-variable constant_\"\u003eTASK_1_BIT\u003c/span\u003e = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 00000001\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEventBits\u003c/span\u003e_t \u003cspan class=\"hljs-variable constant_\"\u003eTASK_2_BIT\u003c/span\u003e = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 00000010\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEventBits\u003c/span\u003e_t \u003cspan class=\"hljs-variable constant_\"\u003eTASK_3_BIT\u003c/span\u003e = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 00000100\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e주요 작업은 작업 번호를 매개변수로 전달하여 세 가지 작업을 생성합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 작업에 전달할 매개변수, 작업 번호를 나타냄\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e int taskParams[\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e] = {\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e};\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (int i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e; i++) {\n    \u003cspan class=\"hljs-title function_\"\u003exTaskCreate\u003c/span\u003e(\n        taskFunction,            \u003cspan class=\"hljs-comment\"\u003e// 작업 함수\u003c/span\u003e\n        \u003cspan class=\"hljs-string\"\u003e\"Task\"\u003c/span\u003e,                  \u003cspan class=\"hljs-comment\"\u003e// 작업 이름\u003c/span\u003e\n        \u003cspan class=\"hljs-number\"\u003e2048\u003c/span\u003e,                    \u003cspan class=\"hljs-comment\"\u003e// 스택 크기\u003c/span\u003e\n        \u0026#x26;taskParams[i],          \u003cspan class=\"hljs-comment\"\u003e// 매개변수 (작업 번호)\u003c/span\u003e\n        \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,                       \u003cspan class=\"hljs-comment\"\u003e// 우선 순위\u003c/span\u003e\n        \u003cspan class=\"hljs-variable constant_\"\u003eNULL\u003c/span\u003e                     \u003cspan class=\"hljs-comment\"\u003e// 작업 핸들은 사용하지 않음\u003c/span\u003e\n    );\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e작업 번호는 \"EventBits_t\" 변수를 생성하는 데 사용되며 해당하는 양 만큼 비트를 왼쪽으로 이동시킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eint taskNumber = ((int)pvParameters);\n\u003cspan class=\"hljs-comment\"\u003e// 작업 번호를 기반으로 설정할 비트를 계산\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eEventBits\u003c/span\u003e_t taskBit = (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u0026#x3C;\u0026#x3C; (taskNumber - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e작업이 완료되면 그룹에 신호를 보내고 자체를 삭제합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 이벤트 그룹에서이 작업에 대한 적절한 비트 설정\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintf\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"작업 %d가 완료되었고 비트가 설정되었습니다.\\n\"\u003c/span\u003e, taskNumber);\n\u003cspan class=\"hljs-title function_\"\u003exEventGroupSetBits\u003c/span\u003e(eventGroup, taskBit);\n\u003cspan class=\"hljs-comment\"\u003e// 완료되면이 작업 삭제\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003evTaskDelete\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eNULL\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e주 작업은 비트 마스크를 사용하여 그룹 내 세 개의 비트가 1로 설정될 때까지 기다리고 즉시 실행을 다시 시작합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 모든 작업이 비트를 설정 할 때까지 대기\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"작업이 완료 될 때까지 대기 중 ...\"\u003c/span\u003e);\n\u003cspan class=\"hljs-title function_\"\u003exEventGroupWaitBits\u003c/span\u003e(\n    eventGroup,                          \u003cspan class=\"hljs-comment\"\u003e// 테스트되는 이벤트 그룹.\u003c/span\u003e\n    \u003cspan class=\"hljs-variable constant_\"\u003eTASK_1_BIT\u003c/span\u003e | \u003cspan class=\"hljs-variable constant_\"\u003eTASK_2_BIT\u003c/span\u003e | \u003cspan class=\"hljs-variable constant_\"\u003eTASK_3_BIT\u003c/span\u003e, \u003cspan class=\"hljs-comment\"\u003e// 대기해야 하는 이벤트 그룹 내의 비트.\u003c/span\u003e\n    pdTRUE,                              \u003cspan class=\"hljs-comment\"\u003e// 종료시 비트 지우기.\u003c/span\u003e\n    pdTRUE,                              \u003cspan class=\"hljs-comment\"\u003e// 모든 비트를 대기합니다.\u003c/span\u003e\n    portMAX_DELAY                        \u003cspan class=\"hljs-comment\"\u003e// 무기한 대기.\u003c/span\u003e\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e마침내 이벤트 그룹이 삭제되었습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eSerial\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eprintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"모든 작업이 완료되었습니다.\"\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 이벤트 그룹 정리\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003evEventGroupDelete\u003c/span\u003e(eventGroup);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 유용한 기술은 FreeRTOS 기능만을 사용하여 동기화를 강제하는 간단한 방법입니다. 따라서 무분별한 코드 부하를 피할 수 있습니다. 여러분의 프로젝트에 유용하게 활용하시기를 바랍니다. 읽어주셔서 감사합니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-FreeRTOSSimplesemaphoreimplementationusingeventgroup"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>