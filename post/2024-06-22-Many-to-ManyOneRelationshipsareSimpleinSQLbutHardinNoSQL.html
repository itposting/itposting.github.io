<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SQL에서는 쉽지만 NoSQL에서는 어려운 다대일 관계 설정 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SQL에서는 쉽지만 NoSQL에서는 어려운 다대일 관계 설정 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="SQL에서는 쉽지만 NoSQL에서는 어려운 다대일 관계 설정 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL" data-gatsby-head="true"/><meta name="twitter:title" content="SQL에서는 쉽지만 NoSQL에서는 어려운 다대일 관계 설정 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 17:31" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SQL에서는 쉽지만 NoSQL에서는 어려운 다대일 관계 설정 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SQL에서는 쉽지만 NoSQL에서는 어려운 다대일 관계 설정 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_0.png" alt="img"></p>
<ul>
<li>소개</li>
<li>일대다 관계
<ul>
<li>참조 패턴</li>
<li>내장 패턴</li>
<li>부분 내장 패턴</li>
</ul>
</li>
<li>다대다 관계
<ul>
<li>중간 컬렉션</li>
<li>양방향 및 단방향 다대다 관계</li>
</ul>
</li>
<li>결론</li>
</ul>
<h1>소개</h1>
<p>본 글에서는 SQL 및 NoSQL에서 일대다 및 다대다 관계를 모델링하는 방법의 차이점을 살펴볼 것입니다. 또한 NoSQL (문서 지향 데이터베이스)에서 사용되는 다양한 패턴을 탐구하고, 언제 어떤 것을 적용해야 하는지 이해해 보겠습니다.</p>
<div class="content-ad"></div>
<h1>일대다 관계</h1>
<p>우리가 Article과 Comment 엔티티를 가진 애플리케이션을 개발하고 있다고 상상해 봅시다. 또한 요구사항은 다음과 같습니다:</p>
<ul>
<li>하나의 글에는 하나 이상의 댓글이 포함될 수 있습니다.</li>
<li>하나의 댓글은 하나의 글에만 속할 수 있습니다.</li>
</ul>
<p>위 요구사항은 두 엔티티 간에 일대다 관계를 사용해야 함을 의미합니다.</p>
<div class="content-ad"></div>
<p>SQL 데이터베이스에서는 보통 Articles 및 Comments 두 테이블을 생성하고 외래 키(Comments 테이블에)를 생성하여 일대다 관계를 설정합니다. 클라이언트 코드는 이후 이 두 테이블을 조인하여 댓글이 달린 기사를 가져와야 합니다.</p>
<p><img src="/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_1.png" alt="이미지"></p>
<p>NoSQL 데이터베이스에서는 일대다 관계를 정의하는 데 더 많은 옵션이 있습니다. 참조, 삽입 또는 혼합 방식 중 하나를 선택할 수 있습니다.</p>
<p>참조 및 삽입 사이에서 선택하는 것은 NoSQL 문서 데이터베이스와 작업할 때 개발자들이 하는 주요 선택사항 중 하나입니다.</p>
<div class="content-ad"></div>
<h2>참조 패턴</h2>
<p>NoSQL에서 참조 패턴을 사용하는 것은 SQL에서 일대다 관계를 정의하는 것과 비슷합니다. 우리는 기사와 댓글의 두 개의 별도의 JSON 컬렉션을 정의하고, 그들 사이의 관계를 ID를 사용하여 수립할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//기사 컬렉션 (부모)</span>
[
  {
    <span class="hljs-string">"id"</span>: <span class="hljs-number">4</span>,
    <span class="hljs-string">"title"</span>: <span class="hljs-string">"SQL에서는 다대다/일대다 관계가 간단합니다..."</span>,
    <span class="hljs-string">"content"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"author"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"postedAt"</span>: <span class="hljs-string">"..."</span>
  }
]

<span class="hljs-comment">//댓글 컬렉션 (자식)</span>
[
  {
    <span class="hljs-string">"id"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"articleID"</span>: <span class="hljs-number">41</span>,
    <span class="hljs-string">"content"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"author"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"rating"</span>: <span class="hljs-string">"..."</span>
  }
]
</code></pre>
<p>이러한 방식으로 문서를 참조할 때, 기사에 댓글 ID의 배열을 포함하는 것도 고려할 수 있습니다. 그러나 이것은 최적의 해결책이 아닐 수 있습니다. 왜냐하면 기사에는 많은 수의 댓글이 포함될 수 있어서, 문서에는 많은 댓글 ID 배열이 포함될 수 있기 때문입니다.</p>
<div class="content-ad"></div>
<p>참조 패턴을 사용할 때, 보통 앱은 기사와 관련 댓글을 검색하기 위해 두 번의 쿼리를 수행해야 합니다. 그러나 MongoDB와 같은 문서 지향 데이터베이스는 컬렉션을 단일 읽기 쿼리에서 조인할 수 있는 기능을 제공합니다.</p>
<p>참조 패턴을 사용해야 하는 경우에 대한 일반적인 고려 사항:</p>
<p>✅ 자식 문서가 크거나 많은 경우. 또한 문서 데이터베이스의 문서 당 크기 제한을 고려해야 합니다. 참조 패턴은 이러한 제한을 피하는 데 도움이 됩니다.</p>
<p>✅ 부모 문서와 그 자식 문서가 거의 동시에 읽히거나 쓰이지 않는 경우. 자식 문서가 앱에서 부모 문서와 별도로 사용되는 경우, 이를 서로 다른 컬렉션에 저장함으로써 읽기 및 쓰기 작업이 간편해집니다.</p>
<div class="content-ad"></div>
<p>✅ 문서 데이터베이스에서 쿼리 기능이 제한적이기 때문에 복잡한 중첩 계층 컬렉션을 만드는 것을 피하는 것이 좋습니다.</p>
<p>✅ 자식 문서는 다른 컬렉션의 다른 유형의 상위 문서에 의해 참조되어야 하며, 데이터 일관성 관리를 간소화하기 위해 참조가 사용될 수 있습니다.</p>
<h2>임베디드 패턴</h2>
<p>반면에, 코멘트 배열은 아티클 문서에 완전히 임베드될 수 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-comment">// 글 모음</span>
[
  {
    <span class="hljs-string">"id"</span>: <span class="hljs-number">41</span>,
    <span class="hljs-string">"title"</span>: <span class="hljs-string">"매니-투-매니/원 관계는 SQL에서 간단합니다..."</span>,
    <span class="hljs-string">"content"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"author"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"postedAt"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"comments"</span>: [ 
      {
        <span class="hljs-string">"id"</span>: <span class="hljs-string">"..."</span>,
        <span class="hljs-string">"content"</span>: <span class="hljs-string">"..."</span>,
        <span class="hljs-string">"author"</span>: <span class="hljs-string">"..."</span>,
        <span class="hljs-string">"rating"</span>: <span class="hljs-string">"..."</span>
      }
    ]
  }
]
</code></pre>
<p>먼저, 포함은 연관된 댓글이 있는 글을 하나의 간단한 조회 작업으로 검색할 수 있도록 해줍니다.</p>
<p>포함 패턴을 사용해야 하는 경우에 대한 일반적인 고려 사항:</p>
<p>✅ 응용 프로그램이 부모 문서와 별도로 자식 문서를 검색(또는 업데이트)할 필요가 없는 경우(도메인 주도 설계의 집합 및 집합 루트 개념을 상기하세요).</p>
<div class="content-ad"></div>
<p>✅ 부모와 자식 문서를 한 번의 원자적 쓰기 작업으로 업데이트해야 하는 능력이 필요합니다 (대부분의 문서 지향형 데이터베이스에서 쓰기 작업은 보통 단일 문서 수준에서만 원자적입니다).</p>
<p>✅ 내장 문서는 작고, 그 수도 많지 않습니다 ("하나 대 소수" 관계).</p>
<p>✅ 자식 문서의 업데이트는 자식 문서가 생성된 후에 드물게 발생하거나 전혀 발생하지 않습니다.</p>
<h2>Partial Embedded Pattern</h2>
<div class="content-ad"></div>
<p>세 번째 방법은 참조 및 포함 패턴의 조합입니다. 부모 문서를 검색할 때 자식 문서의 하위 집합만 정기적으로 읽어야 할 경우 사용할 수 있습니다.</p>
<p>예를 들어, 글을 검색할 때 사용자에게 표시할 수 있는 최상위 댓글만 검색해야 할 수 있습니다. 다른 댓글은 나중에 필요할 때 검색하거나 전혀 필요하지 않을 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//Article collection (Parent)</span>
[
  {
    <span class="hljs-string">"id"</span>: <span class="hljs-number">41</span>,
    <span class="hljs-string">"title"</span>: <span class="hljs-string">"Many-to-Many/One Relationships are Simple in SQL..."</span>,
    <span class="hljs-string">"content"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"author"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"postedAt"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"comments"</span>: [ <span class="hljs-comment">//Only 1 of 2 comments included</span>
      {
        <span class="hljs-string">"id"</span>: <span class="hljs-number">1</span>,
        <span class="hljs-string">"content"</span>: <span class="hljs-string">"..."</span>,
        <span class="hljs-string">"author"</span>: <span class="hljs-string">"..."</span>,
        <span class="hljs-string">"rating"</span>: <span class="hljs-number">10</span>
       }
    ]
  }
]

<span class="hljs-comment">//Comment collection (Child)</span>
[
  {
    <span class="hljs-string">"id"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">"articleID"</span>: <span class="hljs-number">41</span>,
    <span class="hljs-string">"content"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"author"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"rating"</span>: <span class="hljs-string">"..."</span>
  },
  {
    <span class="hljs-string">"id"</span>: <span class="hljs-number">2</span>,
    <span class="hljs-string">"articleID"</span>: <span class="hljs-number">41</span>,
    <span class="hljs-string">"content"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"author"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"raing"</span>: <span class="hljs-number">3</span>
  }
]
</code></pre>
<p>부분 포함된 패턴은 성능을 향상시키기 위해 단일 읽기 작업에서 글과 최상위 댓글을 검색하는 애플리케이션에 사용될 수 있으며 모든 댓글을 별도의 컬렉션에 저장하는 이점 중 일부를 유지할 수 있습니다. 그러나 일부 자식 문서가 두 군데에 나타나기 때문에 응용 프로그램은 일관성을 보장하기 위해 추가 작업을 수행해야 할 수 있습니다.</p>
<div class="content-ad"></div>
<h1>다대다 관계</h1>
<p>우리가 프로젝트와 직원 엔티티를 가지고 있다고 상상해봅시다. 아래는 그들에 대한 요구 사항입니다:</p>
<ul>
<li>여러 직원이 하나의 프로젝트에서 일할 수 있습니다.</li>
<li>동일한 직원이 동시에 여러 다른 프로젝트에 할당될 수 있습니다.</li>
</ul>
<p>여기서 우리는 다대다 관계가 필요합니다.</p>
<div class="content-ad"></div>
<p>많은-대-많은 관계란 한 테이블의 여러 레코드가 다른 테이블의 여러 레코드와 관련이 있다는 것을 의미합니다.</p>
<p>SQL에서는 추가 테이블을 사용하여 많은-대-많은을 정의합니다:</p>
<p><img src="/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_2.png" alt="Many-to-Many Relationship"></p>
<p>EmployeeToProjectAssignment 중간 테이블에는 외래 키뿐만 아니라 할당 이벤트에 대한 자세한 정보(이유, 날짜 등)를 제공하는 추가 속성도 포함될 수 있다는 점에 유의하십시오.</p>
<div class="content-ad"></div>
<p>NoSQL에서는 두 개의 컬렉션 간의 다대다 관계를 정의하는 여러 가지 방법이 있습니다:</p>
<h2>중간 컬렉션</h2>
<p>첫 번째 옵션은 SQL과 유사한 중간 컬렉션을 생성하는 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//프로젝트 컬렉션</span>
[
  {
    <span class="hljs-string">"id"</span>: <span class="hljs-number">41</span>,
    <span class="hljs-string">"title"</span>: <span class="hljs-string">"전자 상거래"</span>,
    <span class="hljs-string">"priority"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"dueDate"</span>: <span class="hljs-string">"..."</span>
  }
]

<span class="hljs-comment">//직원 컬렉션</span>
[
  {
    <span class="hljs-string">"id"</span>: <span class="hljs-number">82</span>,
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"존 도우"</span>,
    <span class="hljs-string">"email"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"role"</span>: <span class="hljs-string">"..."</span>
  }
]

<span class="hljs-comment">//EmployeeToProjectAssignment (중간) 컬렉션</span>
[
  {
    <span class="hljs-string">"id"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">"projectID"</span>: <span class="hljs-number">41</span>,
    <span class="hljs-string">"employeeID"</span>: <span class="hljs-number">82</span>,
    <span class="hljs-string">"reason"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"date"</span>: <span class="hljs-string">"..."</span>
  }
]
</code></pre>
<div class="content-ad"></div>
<p>중간 컬렉션을 사용할 수 있는 경우:</p>
<p>✅ 다른 속성 (예: 이유, 날짜 등)을 외래 키 외에도 관계에 특정한 많은 속성을 저장해야 할 때</p>
<p>✅ 많은 문서가 관련된 다대다 관계인 경우 중간 컬렉션을 사용하면 문서 크기 제한을 피할 수 있음</p>
<p>✅ SQL에서 NoSQL로 테이블을 빠르게 마이그레이션해야 하는 경우? 중간 SQL 테이블에서 중간 NoSQL 컬렉션으로 데이터를 마이그레이션하는 것이 구현하기 가장 쉬운 방법일 수 있습니다.</p>
<div class="content-ad"></div>
<h2>양방향 및 단방향 다대다 관계</h2>
<p>다대다 관계를 정의하는 다음 옵션은 각 직원 문서에 프로젝트 ID 목록을 삽입하고 각 프로젝트 문서에 직원 ID 목록을 삽입하는 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//프로젝트 컬렉션</span>
[
  {
    <span class="hljs-string">"id"</span>: <span class="hljs-number">41</span>,
    <span class="hljs-string">"title"</span>: <span class="hljs-string">"전자 상거래"</span>,
    <span class="hljs-string">"priority"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"dueDate"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"employees"</span>: [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span> ]
  }
]

<span class="hljs-comment">//직원 컬렉션</span>
[
  {
    <span class="hljs-string">"id"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"존 도"</span>,
    <span class="hljs-string">"email"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"role"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"projects"</span>: [ <span class="hljs-number">41</span> ]
  },
  {
    <span class="hljs-string">"id"</span>: <span class="hljs-number">2</span>,
    <span class="hljs-string">"name"</span>: <span class="hljs-string">"제인 도"</span>,
    <span class="hljs-string">"email"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"role"</span>: <span class="hljs-string">"..."</span>,
    <span class="hljs-string">"projects"</span>: [ <span class="hljs-number">41</span> ]
  }
]
</code></pre>
<p>식별자를 포함하는 대신 문서 전체를 포함하는 것도 고려할 수 있습니다. 포함할 내용의 선택은 일대다 관계에 대해 설명된 것과 유사하며, 따라서 반복하지 않겠습니다.</p>
<div class="content-ad"></div>
<p>하지만 참조 또는 포함을 사용하여 다대다 관계를 정의할 때 더 고려해야 할 흥미로운 점이 또 있습니다:</p>
<p>이전의 JSON 예시로 돌아갑시다. 프로젝트 컬렉션에서 employees 배열을 완전히 제거해도 두 컬렉션 간의 다대다 관계가 유지될 수 있습니다. 프로젝트 문서가 검색되면 응용 프로그램에서 관련 직원을 찾기 위해 추가 작업을 수행해야 합니다(직원 컬렉션을 스캔하고 프로젝트 배열을 확인함).</p>
<p>이 방법으로 다대다 관계를 모델링하는 것은 한쪽의 문서 수가 많고 다른 쪽은 매우 적은 경우 선택할 수 있습니다. 예를 들어, 단일 프로젝트에 많은 직원이 참여할 수 있지만, 직원은 한 번에 1~2개의 프로젝트만 작업할 수 있습니다.</p>
<p>그러나 이 경우 문서 크기뿐만 아니라 고려해야 할 사항은 두 컬렉션/엔티티가 응용 프로그램에서 어떻게 사용될지도 중요합니다.</p>
<div class="content-ad"></div>
<p>다른 예시를 상상해봅시다. 국가와 공식 언어 엔티티 간의 다대다 관계입니다. 이 응용 프로그램의 사용 사례가 특정 국가에서 어떤 언어가 사용되는지에만 관심이 있다면 그 반대는 아니라면, 공식 언어 문서에 국가 배열을 저장하는 것은 단순히 중복일 뿐입니다. 국가 문서에 언어 배열을 저장하는 것이 충분합니다.</p>
<h1>결론</h1>
<p>SQL 및 NoSQL 데이터베이스에서 엔티티간 관계를 정의하기 위해 가장 일반적으로 사용되는 두 가지 방법을 비교해보았습니다. 유연한 문서 데이터베이스의 성격으로 인해, NoSQL은 SQL에 비해 일대다 및 다대다 관계를 정의하는 데 더 많은 옵션을 제공합니다.</p>
<p>특정 사례에 가장 적합한 옵션을 선택하려면 응용 프로그램 사용 사례, 데이터 액세스 패턴, 필요한 일관성 수준, 문서 크기 제한 및 기타 요소를 고려해야 합니다.</p>
<div class="content-ad"></div>
<p>읽어 주셔서 감사합니다. 내용이 마음에 드셨다면 아래 이야기도 확인해보세요:</p>
<p>🔔 그리고 Buy Me a Coffee에서 제를 지원해 주시는 걸 고려해 주세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SQL에서는 쉽지만 NoSQL에서는 어려운 다대일 관계 설정 방법","description":"","date":"2024-06-22 17:31","slug":"2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL","content":"\n\n![img](/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_0.png)\n\n- 소개\n- 일대다 관계\n  - 참조 패턴\n  - 내장 패턴\n  - 부분 내장 패턴\n- 다대다 관계\n  - 중간 컬렉션\n  - 양방향 및 단방향 다대다 관계\n- 결론\n\n# 소개\n\n본 글에서는 SQL 및 NoSQL에서 일대다 및 다대다 관계를 모델링하는 방법의 차이점을 살펴볼 것입니다. 또한 NoSQL (문서 지향 데이터베이스)에서 사용되는 다양한 패턴을 탐구하고, 언제 어떤 것을 적용해야 하는지 이해해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 일대다 관계\n\n우리가 Article과 Comment 엔티티를 가진 애플리케이션을 개발하고 있다고 상상해 봅시다. 또한 요구사항은 다음과 같습니다:\n\n- 하나의 글에는 하나 이상의 댓글이 포함될 수 있습니다.\n- 하나의 댓글은 하나의 글에만 속할 수 있습니다.\n\n위 요구사항은 두 엔티티 간에 일대다 관계를 사용해야 함을 의미합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQL 데이터베이스에서는 보통 Articles 및 Comments 두 테이블을 생성하고 외래 키(Comments 테이블에)를 생성하여 일대다 관계를 설정합니다. 클라이언트 코드는 이후 이 두 테이블을 조인하여 댓글이 달린 기사를 가져와야 합니다.\n\n![이미지](/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_1.png)\n\nNoSQL 데이터베이스에서는 일대다 관계를 정의하는 데 더 많은 옵션이 있습니다. 참조, 삽입 또는 혼합 방식 중 하나를 선택할 수 있습니다.\n\n참조 및 삽입 사이에서 선택하는 것은 NoSQL 문서 데이터베이스와 작업할 때 개발자들이 하는 주요 선택사항 중 하나입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 참조 패턴\n\nNoSQL에서 참조 패턴을 사용하는 것은 SQL에서 일대다 관계를 정의하는 것과 비슷합니다. 우리는 기사와 댓글의 두 개의 별도의 JSON 컬렉션을 정의하고, 그들 사이의 관계를 ID를 사용하여 수립할 수 있습니다:\n\n```js\n//기사 컬렉션 (부모)\n[\n  {\n    \"id\": 4,\n    \"title\": \"SQL에서는 다대다/일대다 관계가 간단합니다...\",\n    \"content\": \"...\",\n    \"author\": \"...\",\n    \"postedAt\": \"...\"\n  }\n]\n\n//댓글 컬렉션 (자식)\n[\n  {\n    \"id\": \"...\",\n    \"articleID\": 41,\n    \"content\": \"...\",\n    \"author\": \"...\",\n    \"rating\": \"...\"\n  }\n]\n```\n\n이러한 방식으로 문서를 참조할 때, 기사에 댓글 ID의 배열을 포함하는 것도 고려할 수 있습니다. 그러나 이것은 최적의 해결책이 아닐 수 있습니다. 왜냐하면 기사에는 많은 수의 댓글이 포함될 수 있어서, 문서에는 많은 댓글 ID 배열이 포함될 수 있기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참조 패턴을 사용할 때, 보통 앱은 기사와 관련 댓글을 검색하기 위해 두 번의 쿼리를 수행해야 합니다. 그러나 MongoDB와 같은 문서 지향 데이터베이스는 컬렉션을 단일 읽기 쿼리에서 조인할 수 있는 기능을 제공합니다.\n\n참조 패턴을 사용해야 하는 경우에 대한 일반적인 고려 사항:\n\n✅ 자식 문서가 크거나 많은 경우. 또한 문서 데이터베이스의 문서 당 크기 제한을 고려해야 합니다. 참조 패턴은 이러한 제한을 피하는 데 도움이 됩니다.\n\n✅ 부모 문서와 그 자식 문서가 거의 동시에 읽히거나 쓰이지 않는 경우. 자식 문서가 앱에서 부모 문서와 별도로 사용되는 경우, 이를 서로 다른 컬렉션에 저장함으로써 읽기 및 쓰기 작업이 간편해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✅ 문서 데이터베이스에서 쿼리 기능이 제한적이기 때문에 복잡한 중첩 계층 컬렉션을 만드는 것을 피하는 것이 좋습니다.\n\n✅ 자식 문서는 다른 컬렉션의 다른 유형의 상위 문서에 의해 참조되어야 하며, 데이터 일관성 관리를 간소화하기 위해 참조가 사용될 수 있습니다.\n\n## 임베디드 패턴\n\n반면에, 코멘트 배열은 아티클 문서에 완전히 임베드될 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n// 글 모음\n[\n  {\n    \"id\": 41,\n    \"title\": \"매니-투-매니/원 관계는 SQL에서 간단합니다...\",\n    \"content\": \"...\",\n    \"author\": \"...\",\n    \"postedAt\": \"...\",\n    \"comments\": [ \n      {\n        \"id\": \"...\",\n        \"content\": \"...\",\n        \"author\": \"...\",\n        \"rating\": \"...\"\n      }\n    ]\n  }\n]\n```\n\n먼저, 포함은 연관된 댓글이 있는 글을 하나의 간단한 조회 작업으로 검색할 수 있도록 해줍니다.\n\n포함 패턴을 사용해야 하는 경우에 대한 일반적인 고려 사항:\n\n✅ 응용 프로그램이 부모 문서와 별도로 자식 문서를 검색(또는 업데이트)할 필요가 없는 경우(도메인 주도 설계의 집합 및 집합 루트 개념을 상기하세요).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n✅ 부모와 자식 문서를 한 번의 원자적 쓰기 작업으로 업데이트해야 하는 능력이 필요합니다 (대부분의 문서 지향형 데이터베이스에서 쓰기 작업은 보통 단일 문서 수준에서만 원자적입니다).\n\n✅ 내장 문서는 작고, 그 수도 많지 않습니다 (\"하나 대 소수\" 관계).\n\n✅ 자식 문서의 업데이트는 자식 문서가 생성된 후에 드물게 발생하거나 전혀 발생하지 않습니다.\n\n## Partial Embedded Pattern\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n세 번째 방법은 참조 및 포함 패턴의 조합입니다. 부모 문서를 검색할 때 자식 문서의 하위 집합만 정기적으로 읽어야 할 경우 사용할 수 있습니다.\n\n예를 들어, 글을 검색할 때 사용자에게 표시할 수 있는 최상위 댓글만 검색해야 할 수 있습니다. 다른 댓글은 나중에 필요할 때 검색하거나 전혀 필요하지 않을 수 있습니다.\n\n```js\n//Article collection (Parent)\n[\n  {\n    \"id\": 41,\n    \"title\": \"Many-to-Many/One Relationships are Simple in SQL...\",\n    \"content\": \"...\",\n    \"author\": \"...\",\n    \"postedAt\": \"...\",\n    \"comments\": [ //Only 1 of 2 comments included\n      {\n        \"id\": 1,\n        \"content\": \"...\",\n        \"author\": \"...\",\n        \"rating\": 10\n       }\n    ]\n  }\n]\n\n//Comment collection (Child)\n[\n  {\n    \"id\": 1,\n    \"articleID\": 41,\n    \"content\": \"...\",\n    \"author\": \"...\",\n    \"rating\": \"...\"\n  },\n  {\n    \"id\": 2,\n    \"articleID\": 41,\n    \"content\": \"...\",\n    \"author\": \"...\",\n    \"raing\": 3\n  }\n]\n```\n\n부분 포함된 패턴은 성능을 향상시키기 위해 단일 읽기 작업에서 글과 최상위 댓글을 검색하는 애플리케이션에 사용될 수 있으며 모든 댓글을 별도의 컬렉션에 저장하는 이점 중 일부를 유지할 수 있습니다. 그러나 일부 자식 문서가 두 군데에 나타나기 때문에 응용 프로그램은 일관성을 보장하기 위해 추가 작업을 수행해야 할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 다대다 관계\n\n우리가 프로젝트와 직원 엔티티를 가지고 있다고 상상해봅시다. 아래는 그들에 대한 요구 사항입니다:\n\n- 여러 직원이 하나의 프로젝트에서 일할 수 있습니다.\n- 동일한 직원이 동시에 여러 다른 프로젝트에 할당될 수 있습니다.\n\n여기서 우리는 다대다 관계가 필요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n많은-대-많은 관계란 한 테이블의 여러 레코드가 다른 테이블의 여러 레코드와 관련이 있다는 것을 의미합니다.\n\nSQL에서는 추가 테이블을 사용하여 많은-대-많은을 정의합니다:\n\n![Many-to-Many Relationship](/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_2.png)\n\nEmployeeToProjectAssignment 중간 테이블에는 외래 키뿐만 아니라 할당 이벤트에 대한 자세한 정보(이유, 날짜 등)를 제공하는 추가 속성도 포함될 수 있다는 점에 유의하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNoSQL에서는 두 개의 컬렉션 간의 다대다 관계를 정의하는 여러 가지 방법이 있습니다:\n\n## 중간 컬렉션\n\n첫 번째 옵션은 SQL과 유사한 중간 컬렉션을 생성하는 것입니다:\n\n```js\n//프로젝트 컬렉션\n[\n  {\n    \"id\": 41,\n    \"title\": \"전자 상거래\",\n    \"priority\": \"...\",\n    \"dueDate\": \"...\"\n  }\n]\n\n//직원 컬렉션\n[\n  {\n    \"id\": 82,\n    \"name\": \"존 도우\",\n    \"email\": \"...\",\n    \"role\": \"...\"\n  }\n]\n\n//EmployeeToProjectAssignment (중간) 컬렉션\n[\n  {\n    \"id\": 1,\n    \"projectID\": 41,\n    \"employeeID\": 82,\n    \"reason\": \"...\",\n    \"date\": \"...\"\n  }\n]\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중간 컬렉션을 사용할 수 있는 경우:\n\n✅ 다른 속성 (예: 이유, 날짜 등)을 외래 키 외에도 관계에 특정한 많은 속성을 저장해야 할 때\n\n✅ 많은 문서가 관련된 다대다 관계인 경우 중간 컬렉션을 사용하면 문서 크기 제한을 피할 수 있음\n\n✅ SQL에서 NoSQL로 테이블을 빠르게 마이그레이션해야 하는 경우? 중간 SQL 테이블에서 중간 NoSQL 컬렉션으로 데이터를 마이그레이션하는 것이 구현하기 가장 쉬운 방법일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 양방향 및 단방향 다대다 관계\n\n다대다 관계를 정의하는 다음 옵션은 각 직원 문서에 프로젝트 ID 목록을 삽입하고 각 프로젝트 문서에 직원 ID 목록을 삽입하는 것입니다:\n\n```js\n//프로젝트 컬렉션\n[\n  {\n    \"id\": 41,\n    \"title\": \"전자 상거래\",\n    \"priority\": \"...\",\n    \"dueDate\": \"...\",\n    \"employees\": [ 1, 2 ]\n  }\n]\n\n//직원 컬렉션\n[\n  {\n    \"id\": 1,\n    \"name\": \"존 도\",\n    \"email\": \"...\",\n    \"role\": \"...\",\n    \"projects\": [ 41 ]\n  },\n  {\n    \"id\": 2,\n    \"name\": \"제인 도\",\n    \"email\": \"...\",\n    \"role\": \"...\",\n    \"projects\": [ 41 ]\n  }\n]\r\n```\n\n식별자를 포함하는 대신 문서 전체를 포함하는 것도 고려할 수 있습니다. 포함할 내용의 선택은 일대다 관계에 대해 설명된 것과 유사하며, 따라서 반복하지 않겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 참조 또는 포함을 사용하여 다대다 관계를 정의할 때 더 고려해야 할 흥미로운 점이 또 있습니다:\n\n이전의 JSON 예시로 돌아갑시다. 프로젝트 컬렉션에서 employees 배열을 완전히 제거해도 두 컬렉션 간의 다대다 관계가 유지될 수 있습니다. 프로젝트 문서가 검색되면 응용 프로그램에서 관련 직원을 찾기 위해 추가 작업을 수행해야 합니다(직원 컬렉션을 스캔하고 프로젝트 배열을 확인함).\n\n이 방법으로 다대다 관계를 모델링하는 것은 한쪽의 문서 수가 많고 다른 쪽은 매우 적은 경우 선택할 수 있습니다. 예를 들어, 단일 프로젝트에 많은 직원이 참여할 수 있지만, 직원은 한 번에 1~2개의 프로젝트만 작업할 수 있습니다. \n\n그러나 이 경우 문서 크기뿐만 아니라 고려해야 할 사항은 두 컬렉션/엔티티가 응용 프로그램에서 어떻게 사용될지도 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 예시를 상상해봅시다. 국가와 공식 언어 엔티티 간의 다대다 관계입니다. 이 응용 프로그램의 사용 사례가 특정 국가에서 어떤 언어가 사용되는지에만 관심이 있다면 그 반대는 아니라면, 공식 언어 문서에 국가 배열을 저장하는 것은 단순히 중복일 뿐입니다. 국가 문서에 언어 배열을 저장하는 것이 충분합니다.\n\n# 결론\n\nSQL 및 NoSQL 데이터베이스에서 엔티티간 관계를 정의하기 위해 가장 일반적으로 사용되는 두 가지 방법을 비교해보았습니다. 유연한 문서 데이터베이스의 성격으로 인해, NoSQL은 SQL에 비해 일대다 및 다대다 관계를 정의하는 데 더 많은 옵션을 제공합니다.\n\n특정 사례에 가장 적합한 옵션을 선택하려면 응용 프로그램 사용 사례, 데이터 액세스 패턴, 필요한 일관성 수준, 문서 크기 제한 및 기타 요소를 고려해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n읽어 주셔서 감사합니다. 내용이 마음에 드셨다면 아래 이야기도 확인해보세요:\n\n🔔 그리고 Buy Me a Coffee에서 제를 지원해 주시는 걸 고려해 주세요.","ogImage":{"url":"/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_0.png"},"coverImage":"/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_0.png\" alt=\"img\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e소개\u003c/li\u003e\n\u003cli\u003e일대다 관계\n\u003cul\u003e\n\u003cli\u003e참조 패턴\u003c/li\u003e\n\u003cli\u003e내장 패턴\u003c/li\u003e\n\u003cli\u003e부분 내장 패턴\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e다대다 관계\n\u003cul\u003e\n\u003cli\u003e중간 컬렉션\u003c/li\u003e\n\u003cli\u003e양방향 및 단방향 다대다 관계\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e결론\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e본 글에서는 SQL 및 NoSQL에서 일대다 및 다대다 관계를 모델링하는 방법의 차이점을 살펴볼 것입니다. 또한 NoSQL (문서 지향 데이터베이스)에서 사용되는 다양한 패턴을 탐구하고, 언제 어떤 것을 적용해야 하는지 이해해 보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e일대다 관계\u003c/h1\u003e\n\u003cp\u003e우리가 Article과 Comment 엔티티를 가진 애플리케이션을 개발하고 있다고 상상해 봅시다. 또한 요구사항은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e하나의 글에는 하나 이상의 댓글이 포함될 수 있습니다.\u003c/li\u003e\n\u003cli\u003e하나의 댓글은 하나의 글에만 속할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위 요구사항은 두 엔티티 간에 일대다 관계를 사용해야 함을 의미합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eSQL 데이터베이스에서는 보통 Articles 및 Comments 두 테이블을 생성하고 외래 키(Comments 테이블에)를 생성하여 일대다 관계를 설정합니다. 클라이언트 코드는 이후 이 두 테이블을 조인하여 댓글이 달린 기사를 가져와야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eNoSQL 데이터베이스에서는 일대다 관계를 정의하는 데 더 많은 옵션이 있습니다. 참조, 삽입 또는 혼합 방식 중 하나를 선택할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e참조 및 삽입 사이에서 선택하는 것은 NoSQL 문서 데이터베이스와 작업할 때 개발자들이 하는 주요 선택사항 중 하나입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e참조 패턴\u003c/h2\u003e\n\u003cp\u003eNoSQL에서 참조 패턴을 사용하는 것은 SQL에서 일대다 관계를 정의하는 것과 비슷합니다. 우리는 기사와 댓글의 두 개의 별도의 JSON 컬렉션을 정의하고, 그들 사이의 관계를 ID를 사용하여 수립할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//기사 컬렉션 (부모)\u003c/span\u003e\n[\n  {\n    \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"SQL에서는 다대다/일대다 관계가 간단합니다...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"author\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"postedAt\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e\n  }\n]\n\n\u003cspan class=\"hljs-comment\"\u003e//댓글 컬렉션 (자식)\u003c/span\u003e\n[\n  {\n    \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"articleID\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"author\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"rating\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e\n  }\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이러한 방식으로 문서를 참조할 때, 기사에 댓글 ID의 배열을 포함하는 것도 고려할 수 있습니다. 그러나 이것은 최적의 해결책이 아닐 수 있습니다. 왜냐하면 기사에는 많은 수의 댓글이 포함될 수 있어서, 문서에는 많은 댓글 ID 배열이 포함될 수 있기 때문입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e참조 패턴을 사용할 때, 보통 앱은 기사와 관련 댓글을 검색하기 위해 두 번의 쿼리를 수행해야 합니다. 그러나 MongoDB와 같은 문서 지향 데이터베이스는 컬렉션을 단일 읽기 쿼리에서 조인할 수 있는 기능을 제공합니다.\u003c/p\u003e\n\u003cp\u003e참조 패턴을 사용해야 하는 경우에 대한 일반적인 고려 사항:\u003c/p\u003e\n\u003cp\u003e✅ 자식 문서가 크거나 많은 경우. 또한 문서 데이터베이스의 문서 당 크기 제한을 고려해야 합니다. 참조 패턴은 이러한 제한을 피하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e✅ 부모 문서와 그 자식 문서가 거의 동시에 읽히거나 쓰이지 않는 경우. 자식 문서가 앱에서 부모 문서와 별도로 사용되는 경우, 이를 서로 다른 컬렉션에 저장함으로써 읽기 및 쓰기 작업이 간편해집니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e✅ 문서 데이터베이스에서 쿼리 기능이 제한적이기 때문에 복잡한 중첩 계층 컬렉션을 만드는 것을 피하는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003e✅ 자식 문서는 다른 컬렉션의 다른 유형의 상위 문서에 의해 참조되어야 하며, 데이터 일관성 관리를 간소화하기 위해 참조가 사용될 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e임베디드 패턴\u003c/h2\u003e\n\u003cp\u003e반면에, 코멘트 배열은 아티클 문서에 완전히 임베드될 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 글 모음\u003c/span\u003e\n[\n  {\n    \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"매니-투-매니/원 관계는 SQL에서 간단합니다...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"author\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"postedAt\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"comments\"\u003c/span\u003e: [ \n      {\n        \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"author\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"rating\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e\n      }\n    ]\n  }\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저, 포함은 연관된 댓글이 있는 글을 하나의 간단한 조회 작업으로 검색할 수 있도록 해줍니다.\u003c/p\u003e\n\u003cp\u003e포함 패턴을 사용해야 하는 경우에 대한 일반적인 고려 사항:\u003c/p\u003e\n\u003cp\u003e✅ 응용 프로그램이 부모 문서와 별도로 자식 문서를 검색(또는 업데이트)할 필요가 없는 경우(도메인 주도 설계의 집합 및 집합 루트 개념을 상기하세요).\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e✅ 부모와 자식 문서를 한 번의 원자적 쓰기 작업으로 업데이트해야 하는 능력이 필요합니다 (대부분의 문서 지향형 데이터베이스에서 쓰기 작업은 보통 단일 문서 수준에서만 원자적입니다).\u003c/p\u003e\n\u003cp\u003e✅ 내장 문서는 작고, 그 수도 많지 않습니다 (\"하나 대 소수\" 관계).\u003c/p\u003e\n\u003cp\u003e✅ 자식 문서의 업데이트는 자식 문서가 생성된 후에 드물게 발생하거나 전혀 발생하지 않습니다.\u003c/p\u003e\n\u003ch2\u003ePartial Embedded Pattern\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e세 번째 방법은 참조 및 포함 패턴의 조합입니다. 부모 문서를 검색할 때 자식 문서의 하위 집합만 정기적으로 읽어야 할 경우 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 글을 검색할 때 사용자에게 표시할 수 있는 최상위 댓글만 검색해야 할 수 있습니다. 다른 댓글은 나중에 필요할 때 검색하거나 전혀 필요하지 않을 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//Article collection (Parent)\u003c/span\u003e\n[\n  {\n    \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Many-to-Many/One Relationships are Simple in SQL...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"author\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"postedAt\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"comments\"\u003c/span\u003e: [ \u003cspan class=\"hljs-comment\"\u003e//Only 1 of 2 comments included\u003c/span\u003e\n      {\n        \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"author\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"rating\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\n       }\n    ]\n  }\n]\n\n\u003cspan class=\"hljs-comment\"\u003e//Comment collection (Child)\u003c/span\u003e\n[\n  {\n    \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"articleID\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"author\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"rating\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e\n  },\n  {\n    \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"articleID\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"author\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"raing\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n  }\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e부분 포함된 패턴은 성능을 향상시키기 위해 단일 읽기 작업에서 글과 최상위 댓글을 검색하는 애플리케이션에 사용될 수 있으며 모든 댓글을 별도의 컬렉션에 저장하는 이점 중 일부를 유지할 수 있습니다. 그러나 일부 자식 문서가 두 군데에 나타나기 때문에 응용 프로그램은 일관성을 보장하기 위해 추가 작업을 수행해야 할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e다대다 관계\u003c/h1\u003e\n\u003cp\u003e우리가 프로젝트와 직원 엔티티를 가지고 있다고 상상해봅시다. 아래는 그들에 대한 요구 사항입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e여러 직원이 하나의 프로젝트에서 일할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e동일한 직원이 동시에 여러 다른 프로젝트에 할당될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e여기서 우리는 다대다 관계가 필요합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e많은-대-많은 관계란 한 테이블의 여러 레코드가 다른 테이블의 여러 레코드와 관련이 있다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003eSQL에서는 추가 테이블을 사용하여 많은-대-많은을 정의합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL_2.png\" alt=\"Many-to-Many Relationship\"\u003e\u003c/p\u003e\n\u003cp\u003eEmployeeToProjectAssignment 중간 테이블에는 외래 키뿐만 아니라 할당 이벤트에 대한 자세한 정보(이유, 날짜 등)를 제공하는 추가 속성도 포함될 수 있다는 점에 유의하십시오.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eNoSQL에서는 두 개의 컬렉션 간의 다대다 관계를 정의하는 여러 가지 방법이 있습니다:\u003c/p\u003e\n\u003ch2\u003e중간 컬렉션\u003c/h2\u003e\n\u003cp\u003e첫 번째 옵션은 SQL과 유사한 중간 컬렉션을 생성하는 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//프로젝트 컬렉션\u003c/span\u003e\n[\n  {\n    \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"전자 상거래\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"priority\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"dueDate\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e\n  }\n]\n\n\u003cspan class=\"hljs-comment\"\u003e//직원 컬렉션\u003c/span\u003e\n[\n  {\n    \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e82\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"존 도우\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"email\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e\n  }\n]\n\n\u003cspan class=\"hljs-comment\"\u003e//EmployeeToProjectAssignment (중간) 컬렉션\u003c/span\u003e\n[\n  {\n    \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"projectID\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"employeeID\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e82\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"reason\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"date\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e\n  }\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e중간 컬렉션을 사용할 수 있는 경우:\u003c/p\u003e\n\u003cp\u003e✅ 다른 속성 (예: 이유, 날짜 등)을 외래 키 외에도 관계에 특정한 많은 속성을 저장해야 할 때\u003c/p\u003e\n\u003cp\u003e✅ 많은 문서가 관련된 다대다 관계인 경우 중간 컬렉션을 사용하면 문서 크기 제한을 피할 수 있음\u003c/p\u003e\n\u003cp\u003e✅ SQL에서 NoSQL로 테이블을 빠르게 마이그레이션해야 하는 경우? 중간 SQL 테이블에서 중간 NoSQL 컬렉션으로 데이터를 마이그레이션하는 것이 구현하기 가장 쉬운 방법일 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e양방향 및 단방향 다대다 관계\u003c/h2\u003e\n\u003cp\u003e다대다 관계를 정의하는 다음 옵션은 각 직원 문서에 프로젝트 ID 목록을 삽입하고 각 프로젝트 문서에 직원 ID 목록을 삽입하는 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//프로젝트 컬렉션\u003c/span\u003e\n[\n  {\n    \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"title\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"전자 상거래\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"priority\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"dueDate\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"employees\"\u003c/span\u003e: [ \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e ]\n  }\n]\n\n\u003cspan class=\"hljs-comment\"\u003e//직원 컬렉션\u003c/span\u003e\n[\n  {\n    \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"존 도\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"email\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"projects\"\u003c/span\u003e: [ \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e ]\n  },\n  {\n    \u003cspan class=\"hljs-string\"\u003e\"id\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"제인 도\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"email\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"projects\"\u003c/span\u003e: [ \u003cspan class=\"hljs-number\"\u003e41\u003c/span\u003e ]\n  }\n]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e식별자를 포함하는 대신 문서 전체를 포함하는 것도 고려할 수 있습니다. 포함할 내용의 선택은 일대다 관계에 대해 설명된 것과 유사하며, 따라서 반복하지 않겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e하지만 참조 또는 포함을 사용하여 다대다 관계를 정의할 때 더 고려해야 할 흥미로운 점이 또 있습니다:\u003c/p\u003e\n\u003cp\u003e이전의 JSON 예시로 돌아갑시다. 프로젝트 컬렉션에서 employees 배열을 완전히 제거해도 두 컬렉션 간의 다대다 관계가 유지될 수 있습니다. 프로젝트 문서가 검색되면 응용 프로그램에서 관련 직원을 찾기 위해 추가 작업을 수행해야 합니다(직원 컬렉션을 스캔하고 프로젝트 배열을 확인함).\u003c/p\u003e\n\u003cp\u003e이 방법으로 다대다 관계를 모델링하는 것은 한쪽의 문서 수가 많고 다른 쪽은 매우 적은 경우 선택할 수 있습니다. 예를 들어, 단일 프로젝트에 많은 직원이 참여할 수 있지만, 직원은 한 번에 1~2개의 프로젝트만 작업할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 이 경우 문서 크기뿐만 아니라 고려해야 할 사항은 두 컬렉션/엔티티가 응용 프로그램에서 어떻게 사용될지도 중요합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다른 예시를 상상해봅시다. 국가와 공식 언어 엔티티 간의 다대다 관계입니다. 이 응용 프로그램의 사용 사례가 특정 국가에서 어떤 언어가 사용되는지에만 관심이 있다면 그 반대는 아니라면, 공식 언어 문서에 국가 배열을 저장하는 것은 단순히 중복일 뿐입니다. 국가 문서에 언어 배열을 저장하는 것이 충분합니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eSQL 및 NoSQL 데이터베이스에서 엔티티간 관계를 정의하기 위해 가장 일반적으로 사용되는 두 가지 방법을 비교해보았습니다. 유연한 문서 데이터베이스의 성격으로 인해, NoSQL은 SQL에 비해 일대다 및 다대다 관계를 정의하는 데 더 많은 옵션을 제공합니다.\u003c/p\u003e\n\u003cp\u003e특정 사례에 가장 적합한 옵션을 선택하려면 응용 프로그램 사용 사례, 데이터 액세스 패턴, 필요한 일관성 수준, 문서 크기 제한 및 기타 요소를 고려해야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e읽어 주셔서 감사합니다. 내용이 마음에 드셨다면 아래 이야기도 확인해보세요:\u003c/p\u003e\n\u003cp\u003e🔔 그리고 Buy Me a Coffee에서 제를 지원해 주시는 걸 고려해 주세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-Many-to-ManyOneRelationshipsareSimpleinSQLbutHardinNoSQL"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>