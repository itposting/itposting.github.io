<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>윈도우 함수의 해부학 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-AnatomyofWindowsFunctions" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="윈도우 함수의 해부학 | itposting" data-gatsby-head="true"/><meta property="og:title" content="윈도우 함수의 해부학 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-AnatomyofWindowsFunctions_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-AnatomyofWindowsFunctions" data-gatsby-head="true"/><meta name="twitter:title" content="윈도우 함수의 해부학 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-AnatomyofWindowsFunctions_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 16:08" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">윈도우 함수의 해부학</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="윈도우 함수의 해부학" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-AnatomyofWindowsFunctions&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>소극적으로 여겨지는 SQL 작업의 이론과 실무</h2>
<p><img src="/assets/img/2024-06-19-AnatomyofWindowsFunctions_0.png" alt="이미지"></p>
<h1>소개</h1>
<p>IT 분야는 매일 새로운 도구, 새로운 프레임워크, 새로운 클라우드 제공업체, 그리고 새로운 LLM이 생성되는 등 끊임없는 변화로 유명합니다. 그러나 이 바쁜 세계에서도 몇 가지 원칙, 패러다임, 그리고 도구는 '모든 것이 영원하지 않다'는 상태 쿼를 도전하는 것처럼 보입니다. 특히 데이터 분야에서는 SQL 언어만큼 강제적인 예가 없습니다.</p>
<div class="content-ad"></div>
<p>80년대에 탄생한 이후 데이터 웨어하우스 시대를 지나 Hadoop/Data-lake/Big Data로 활용되어 Hive로 거듭난 뒤 지금은 Spark API 중 하나로 살아 숨 쉬고 있어요. 세상은 많이 변했지만 SQL은 여전히 중요하고 존재감이 크죠.</p>
<p>하지만 SQL은 마치 체스와 같아요. 기본 규칙을 이해하기 쉽지만 스스로를 완전히 다루기는 어려운 것 같아요! SQL은 많은 가능성을 지니고 있으며 같은 문제를 해결하는 다양한 방법, 다양한 함수와 키워드를 가지고 있습니다. 불행히도, 더 많이 알려지지 않은 기능들이 많아요. 이를 알면 쿼리를 작성할 때 많은 도움이 될 수 있습니다.</p>
<p>그래서 이번 포스트에서는, 일상적인 쿼리를 작성할 때 굉장히 유용하게 느껴졌던, 그리 잘 알려지지 않은 SQL의 기능 중 하나에 대해 이야기해보려고 해요: 윈도우 함수.</p>
<h1>윈도우 함수란 무엇인가</h1>
<div class="content-ad"></div>
<p>전통적이고 가장 유명한 SGBD(PostgreSQL, MySQL 및 Oracle)는 관계 대수 개념에 기반을 두고 있습니다. 여기에는 행이 튜플로 불리며 테이블은 관계로 불립니다. 관계란 튜플들의 집합으로, 즉 튜플 간의 순서 또는 연결이 없습니다. 그래서 테이블 내의 행에 대한 기본적인 순서가 없으며, 한 행에 수행된 계산은 다른 결과에 영향을 주지 않으며 다른 결과에도 영향을 받지 않습니다. ORDER BY와 같은 절조차도 테이블만을 정렬할 뿐, 다른 행의 값을 기반으로 한 행에서의 계산을 수행하는 것은 불가능합니다.</p>
<p>간단히 말하면, 윈도우 함수가 이를 해결해주며 SQL 기능을 확장하여 다른 행의 값을 기반으로 한 행에서 계산을 수행할 수 있습니다.</p>
<h1>이해를 돕는 기본 사례/해부학</h1>
<p>1- 집계 함수 사용하지 않고 집계하기</p>
<div class="content-ad"></div>
<p>Windows 함수를 이해하는 가장 단순한 예는 '집계하지 않고 집계하는' 능력입니다.</p>
<p>전통적인 GROUP BY를 사용하여 집계를 수행하면 전체 테이블이 두 번째 테이블로 압축되어 각 행이 그룹의 요소를 나타내게 됩니다. 그러나 Windows 함수를 사용하면 행을 압축하는 대신 동일한 테이블에 집계 결과가 포함된 새 열을 생성할 수 있습니다.</p>
<p>예를 들어, 비용 테이블에서 모든 지출을 더해야 한다면, 전통적으로는 다음과 같이 수행할 것입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">SUM</span>(value) <span class="hljs-variable constant_">AS</span> total <span class="hljs-variable constant_">FROM</span> myTable
</code></pre>
<div class="content-ad"></div>
<p>Windows 함수를 사용하면 아래와 같이 만들 수 있어요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> *, <span class="hljs-title function_">SUM</span>(value) <span class="hljs-title function_">OVER</span>() <span class="hljs-variable constant_">FROM</span> myTable
-- 창 함수(<span class="hljs-variable language_">window</span> <span class="hljs-keyword">function</span>)가 쿼리에서 열 레벨에 정의됨에 주목하세요
</code></pre>
<p>아래 이미지는 결과를 보여줍니다:</p>
<p><img src="/assets/img/2024-06-19-AnatomyofWindowsFunctions_1.png" alt="윈도우 함수의 구조"></p>
<div class="content-ad"></div>
<p>새로운 테이블을 생성하는 대신, 집계 값은 새로운 열에 반환됩니다. 값은 같지만 테이블이 '요약'되지 않았습니다. 원본 레코드가 유지되었고 계산된 집계를 집계하지는 않았다는 것을 주목하세요 ;)</p>
<p>OVER 절은 윈도우 함수를 생성함을 나타냅니다. 이 절은 계산이 이루어질 레코드를 정의합니다. 위의 코드가 비어있으므로 모든 레코드에 대해 SUM()을 계산합니다.</p>
<p>이는 열의 합계(또는 평균, 최솟값, 최댓값)을 기반으로 계산이 필요할 때 유용합니다. 예를 들어 각 비용이 총 비용에 대한 백분율로 얼마나 기여하는지를 계산하는 경우입니다.</p>
<p>실제 케이스에서는 회사 부서별로 비용이 있는 예처럼 특정 카테고리에 대한 자세한 내용이 필요할 수 있습니다. 다시 말해서, 각 부서별 총 지출을 간단한 GROUP BY로 얻을 수 있습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">myTable에서 depto 및 총합(value)을 그룹화하여 <span class="hljs-variable constant_">SELECT</span>합니다.

또는 윈도우 함수에서 <span class="hljs-variable constant_">PARTITION</span> 로직을 지정할 수 있습니다.

myTable을 <span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> depto로 지정하여 <span class="hljs-variable constant_">SELECT</span> 및 <span class="hljs-title function_">SUM</span>(value)을 실행합니다.

결과를 확인하세요.
</code></pre>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-19-AnatomyofWindowsFunctions_2.png" alt="AnatomyofWindowsFunctions_2"></p>
<p>이 예제는 해당 기능이 '창' 함수로 불리는 이유를 이해하는 데 도움이 됩니다. OVER 절은 해당 함수가 작동할 '창' 즉, 테이블의 일련의 줄을 정의합니다.</p>
<p>위의 경우, SUM() 함수는 depto 열 (RH 및 SALES)에 의해 생성된 파티션에서 작동합니다. 이 함수는 depto 열의 각 항목에 대해 '값' 열의 모든 값들을 각각 개별적으로 합산합니다. 줄이 속한 그룹 (RH 또는 SALES)에 따라 '총계' 열의 값이 결정됩니다.</p>
<p>2 — 시간과 순서의 인식</p>
<div class="content-ad"></div>
<p>가끔은 다른 행의 값에 기반하여 하나의 행 안의 열의 값을 계산해야 할 때가 있습니다. 전형적인 예로 현재 값과 이전 값에서 계산한 국가의 GDP의 연간 증가율이 있습니다.</p>
<p>지난 해의 값을 필요로 하는 이러한 계산, 현재 및 이전 행의 차이, 시리즈의 첫 번째 값 등을 필요로 하는 경우는 윈도우 함수의 강력함을 증명합니다. 사실, 표준 SQL 명령어로 이러한 동작을 달성할 수 있는지 모르겠습니다! 아마 가능할 것이지만, 매우 복잡한 쿼리가 될 것입니다...</p>
<p>그러나 윈도우 함수를 사용하면 간단하게 할 수 있습니다. 아래 이미지는 (어린이의 키를 기록하는 테이블입니다):</p>
<p><img src="/assets/img/2024-06-19-AnatomyofWindowsFunctions_3.png" alt="테이블 스냅샷"></p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
  year, height, 
  <span class="hljs-title function_">LAG</span>(height) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> year) <span class="hljs-variable constant_">AS</span> height_last_year
<span class="hljs-variable constant_">FROM</span> myTable
</code></pre>
<p>LAG('column') 함수는 이전 행의 'column' 값을 참조하는 역할을 합니다. 이것을 한 단계씩의 순차적인 단계로 상상해볼 수 있습니다: 두 번째 행에서는 첫 번째 값을 고려하고, 세 번째 행에서는 두 번째 값을 고려하고, 그 다음 계속 됩니다... 첫 번째 행은 카운트되지 않습니다(따라서 NULL 값이 반환되는 것), 이전 행이 없기 때문입니다.</p>
<p>당연히 '이전 행'을 정의하기 위해 어떤 순서 조건이 필요합니다. 여기에서 윈도우 함수의 또 다른 중요한 개념인 분석 함수가 필요합니다.</p>
<p>전통적인 SQL 함수와 대조적으로 분석 함수(LAG과 같은)는 행들 사이에 순서가 존재한다고 가정합니다 — 이 순서는 OVER() 안에 있는 ORDER BY 절에 의해 정의됩니다, 즉, 처음, 두 번째, 세 번째 행 등의 개념은 OVER 키워드 내에서 정의됩니다. 이러한 함수들의 주요 특징은 현재 행과 상대적인 다른 행을 참조할 수 있는 능력입니다: LAG는 이전 행을 참조하고, LEAD는 다음 행을 참조하고, FIRST는 분할 내 첫 번째 행을 참조하고, 등등이 있습니다.</p>
<div class="content-ad"></div>
<p>LAG 및 LEAD의 멋진 점 중 하나는 두 번째 인수인 오프셋을 받아들인다는 것입니다. 이 오프셋은 LEAD의 경우 앞으로 몇 개의 행(LEAD) 또는 뒤로 몇 개의 행(LAG)을 살펴볼지를 지정합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
    <span class="hljs-title function_">LAG</span>(height,  <span class="hljs-number">2</span>) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> year) <span class="hljs-keyword">as</span> height_two_years_ago,
    <span class="hljs-title function_">LAG</span>(height,  <span class="hljs-number">3</span>) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> year) <span class="hljs-keyword">as</span> height_three_years_ago,
    <span class="hljs-title function_">LEAD</span>(height)    <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> year) <span class="hljs-keyword">as</span> height_next_year
<span class="hljs-variable constant_">FROM</span> ...
</code></pre>
<p>또한 이러한 함수들로 계산을 수행하는 것도 완벽하게 가능합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
    <span class="hljs-number">100</span>*height/(<span class="hljs-title function_">LAG</span>(height) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> year)) 
    <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"annual_growth_%"</span>
<span class="hljs-variable constant_">FROM</span> ...
</code></pre>
<div class="content-ad"></div>
<p>3 - 시간 인식과 집계</p>
<p>시간과 공간은 하나라고 아인슈타인이 한번 말했던 적이 있는데, 그런 느낌인 것 같아요. 잘 모르겠어요 ¯_(ツ)_/¯</p>
<p>이제 파티션 분할과 정렬하는 방법을 알았으니, 두 가지를 함께 사용할 수 있어요! 이전 예제로 돌아와서, 그 표 위에 더 많은 아이들이 있다고 상상해 봅시다. 우리는 각 아이의 성장률을 계산해야 할 때가 왔어요. 매우 간단해요. 정렬과 파티션을 결합해 보세요! 년도별로 정렬하고 아이 이름별로 파티션하면 되겠네요.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> <span class="hljs-number">1</span>-height/<span class="hljs-title function_">LAG</span>(height) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> year <span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> name) ...
</code></pre>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-19-AnatomyofWindowsFunctions_4.png">
<p>위의 쿼리는 다음을 수행합니다 — child에 따라 테이블을 분할하고 각 분할에서 년도별로 값을 정렬한 후 현재 년도의 높이 값을 이전 값으로 나눈 다음 (결과를 1에서 빼서) 계산합니다.</p>
<p>'윈도우(window)'의 전체 개념에 점점 다가가고 있어요! 이것은 '윈도우(window)'가 테이블 슬라이스이며, PARTITION BY에서 정의된 열로 그룹화된 행 세트로서, ORDER BY에서 정의한 필드로 정렬되어, 동일한 그룹(분할) 내의 행만을 고려하며 특정 순서로 모든 계산이 이루어진다는 것입니다.</p>
<p>4-순위 및 위치</p>
<div class="content-ad"></div>
<p>Windows 함수는 세 가지 카테고리로 나뉠 수 있는데, 그 중 두 가지에 대해 이미 이야기했습니다: 집계 함수 ( COUNT, SUM, AVG, MAX, ... )와 분석 함수 ( LAG, LEAD, FIRST_VALUE, LAST_VALUE, ... ).</p>
<p>세 번째 그룹은 가장 간단한 순위 함수입니다. 그 중에서도 row_number() 함수가 가장 큰 영향을 미칩니다. 해당 함수는 그룹 내에서 행의 위치를 나타내는 정수를 반환합니다 (정의된 순서에 따라).</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> <span class="hljs-title function_">row_number</span>() <span class="hljs-title function_">OVER</span>(<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> score)
</code></pre>
<p>순위 함수는 이름에서 알 수 있듯이 그룹 내 라인의 위치에 따라 값이 반환되며, 정렬 기준에 따라 정의된 그룹입니다. ROW_NUMBER, RANK 및 NTILE이 가장 많이 사용되는 함수 몇 가지입니다.</p>
<div class="content-ad"></div>
<p>위의 이미지에서 각 플레이어의 점수에 기반한 행 번호가 생성됩니다.</p>
<p>... 그리고 네, 1부터 시작하는 끔찍한 프로그래밍 죄악을 저질립니다.</p>
<p>5-창 크기</p>
<div class="content-ad"></div>
<p>현재까지 소개된 모든 함수들은 결과를 계산할 때 파티션/그룹 내의 모든 행을 고려합니다. 예를 들어, 첫 번째 예제에서 설명한 SUM() 함수는 총계를 계산할 때 모든 부서의 행을 고려합니다.</p>
<p>하지만 더 작은 창 크기를 지정하여 현재 행 전후 몇 줄을 계산에 고려할 수도 있습니다. 이는 이동 평균/롤링 윈도우를 계산하는 데 유용한 기능입니다.</p>
<p>다음 예제를 고려해 봅시다. 특정 질병의 일일 발병 건수를 포함하는 표가 있고, 현재 날짜와 이전 2일을 고려하여 발병 건수의 평균을 계산해야 하는 경우를 생각해 봅시다. 앞서 소개된 LAG 함수로도 이 문제를 해결할 수 있다는 점을 주목해 주세요:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span>
( n_cases + <span class="hljs-title function_">LAG</span>(n_cases, <span class="hljs-number">1</span>) + <span class="hljs-title function_">LAG</span>(n_cases, <span class="hljs-number">2</span>) )/<span class="hljs-number">3</span>
<span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> date_reference)
</code></pre>
<div class="content-ad"></div>
<p>하지만 더 우아하게 동일한 결과를 얻을 수 있습니다. 프레임 개념을 사용하여:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span>
<span class="hljs-title function_">AVG</span>(n_cases)
<span class="hljs-variable constant_">OVER</span> (
 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> date_reference
 <span class="hljs-variable constant_">ROWS</span> <span class="hljs-variable constant_">BETWEEN</span> <span class="hljs-number">2</span> <span class="hljs-variable constant_">PRECEDING</span> <span class="hljs-variable constant_">AND</span> <span class="hljs-variable constant_">CURRENT</span> <span class="hljs-variable constant_">ROW</span> 
)
</code></pre>
<p>위의 프레임은 이전 2개의 행과 현재 행에 대해서만 평균을 계산해야 함을 지정합니다. 이전, 현재 행 및 다음 행을 모두 고려하고 싶다면, 프레임을 변경할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">AVG</span>(n_cases)
<span class="hljs-variable constant_">OVER</span> (
 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> date_reference
 <span class="hljs-variable constant_">ROWS</span> <span class="hljs-variable constant_">BETWEEN</span> <span class="hljs-number">1</span> <span class="hljs-variable constant_">PRECEDING</span> <span class="hljs-variable constant_">AND</span> <span class="hljs-number">1</span> <span class="hljs-variable constant_">FOLLOWING</span>
)
</code></pre>
<div class="content-ad"></div>
<p>테이블 태그를 Markdown 형식으로 변경하세요.</p>
<p>그것이 프레임이란 거에요 — 특정한 범위 내에서 함수의 작용을 제한하는 방법입니다. 대부분의 경우, 윈도우 함수는 다음과 같은 프레임을 고려합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">ROWS</span> <span class="hljs-variable constant_">BETWEEN</span> <span class="hljs-variable constant_">UNBOUDED</span> <span class="hljs-variable constant_">PRECEDING</span> <span class="hljs-variable constant_">AND</span> <span class="hljs-variable constant_">CURRENT</span> <span class="hljs-variable constant_">ROW</span>
-- 이전의 모든 행 + 현재 행
</code></pre>
<img src="/assets/img/2024-06-19-AnatomyofWindowsFunctions_6.png">
<p>이 소개가 윈도우 함수가 무엇이고, 어떻게 작동하며, 실제 구문은 어떻게 되는지 더 잘 이해하도록 도와드리기를 바랍니다. 당연히 윈도우 함수에는 많은 다른 키워드가 추가될 수 있지만, 이미 다룬 명령어들이 일상 생활에서 많이 사용될 것으로 생각합니다. 이제 제가 일상에서 문제를 해결하기 위해 사용하는 흥미로운 실용적인 응용 프로그램 중 일부를 살펴보겠습니다 — 아주 흥미로운 것들이 있답니다!</p>
<div class="content-ad"></div>
<h1>Windows 함수의 흥미로운 사용 사례</h1>
<h2>시간별 누적 합계</h2>
<p>이것은 Windows 함수를 사용하는 가장 고전적인 사례 중 하나입니다.</p>
<p>매월 당신의 급여가 나와 있는 표가 있다고 상상해보세요. 각 달에 얼마를 벌었는지 누적으로 알고 싶다면(이전 달 모두를 고려하여), 이것이 작동하는 방식입니다:</p>
<div class="content-ad"></div>
<p>아주 쉽죠?</p>
<p>이 쿼리에서 흥미로운 점은 SUM() 함수가 현재 행 및 이전 모든 행을 고려하여 집계를 계산한다는 것입니다.</p>
<h2>로그 테이블의 이벤트 지속 시간</h2>
<div class="content-ad"></div>
<p>제가 최근에 작성한 포스트인 "덕DB의 My First Billion (of Rows)"에서는 브라질의 전자 투표 기계에서 로그를 조작하는 내용을 다뤘어요. 대량의 데이터 처리에 관심이 있다면 한 번 확인해보세요.</p>
<p>요약하면, 각 이벤트가 시작된 시간을 나타내는 타임스탬프와 이름, 그리고 고유 식별자로 구성된 로그 테이블을 상상해보세요. 각 이벤트는 이전 이벤트가 끝날 때 시작되기 때문에, 이벤트 기간을 나타내는 열을 쉽게 추가할 수 있어요:</p>
<p><img src="/assets/img/2024-06-19-AnatomyofWindowsFunctions_8.png" alt="이미지"></p>
<h2>누락된 값 채우기 (마지막 발생으로)</h2>
<div class="content-ad"></div>
<p>판다스를 활용한 머신 러닝 클래식! fillna, bfill 또는 다른 방법으로 널 값을 채우는 것만으로도 데이터 처리를 해결할 수 있어요.</p>
<p>SQL에서는 이를 어떻게 할까요? 간단해요!</p>
<p><img src="/assets/img/2024-06-19-AnatomyofWindowsFunctions_9.png" alt="이미지"></p>
<p>머신 러닝을 처음 공부할 때는 판다스와 같은 고수준의 함수들을 많이 사용하곤 해요. 하지만 실제 프로젝트를 진행할 때는 데이터 양이 매우 많아 판다스를 사용할 수 없는 경우가 많아요. 그럴 때는 PySpark, Snowflake, Hive+hadoop 등의 도구를 사용해야 하는데, 이들은 어떤 식으로든 SQL에서 작업이 가능해요. 그렇기 때문에 SQL에서 이러한 처리와 전처리를 어떻게 하는지 배우는 것이 중요하다고 생각해요.</p>
<div class="content-ad"></div>
<h2>누락된 값 채우기 (앞 행의 평균으로)</h2>
<p>널(빈 값)을 채우는 더 다양한 방법, 그래도 간단합니다!</p>
<p><img src="/assets/img/2024-06-19-AnatomyofWindowsFunctions_10.png" alt="Windows Functions"></p>
<p>이 예는 윈도우 함수가 복잡하고 특별한 것으로 보일지라도 일반 열처럼 사용할 수 있다는 것을 강조합니다! CASE에 포함시킬 수 있고, 계산에 활용할 수 있습니다. 알고 있는 제한 사항 중 일부는 WHERE 절에 직접적으로 배치할 수 없다는 것뿐입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span>
<span class="hljs-keyword">WHERE</span> <span class="hljs-built_in">SUM</span>() <span class="hljs-keyword">OVER</span>() <span class="hljs-operator">></span> <span class="hljs-number">10</span> <span class="hljs-comment">-- 이 기능은 postgres에서는 불가능합니다.</span>
</code></pre>
<h2>특정 열 기반의 행 중복 제거</h2>
<p>윈도우 함수의 또 다른 고전적인 사례! 때로는 하나의 열 집합을 기준으로 하여 테이블의 행을 중복 제거해야 할 때가 있습니다.</p>
<p>물론 SQL에서는 DISTINCT 절을 사용할 수 있지만, 이는 전체 행이 중복될 때만 작동합니다. 테이블에 같은 ID 열의 값이지만 나머지 열에서는 다른 값이 있는 여러 행이 있는 경우 다음 로직을 사용하여 중복을 제거할 수 있습니다:</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-19-AnatomyofWindowsFunctions_11.png">
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> *
  <span class="hljs-variable constant_">FROM</span> (
   <span class="hljs-variable constant_">SELECT</span>
   <span class="hljs-title function_">ROW_NUMBER</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> id) <span class="hljs-keyword">as</span> row_number
  )
<span class="hljs-variable constant_">WHERE</span> row_number = <span class="hljs-number">1</span>
</code></pre>
<p>이 작업은 데이터 버전 관리도 가능합니다! 예를 들어, 시스템에서 사용자가 이름을 변경할 때마다 변경 날짜와 함께 새로운 줄을 저장하면(기존 줄을 변경하는 대신), 각 사용자의 현재 이름을 검색할 수 있습니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span>
    *
<span class="hljs-variable constant_">FROM</span>
(
  <span class="hljs-variable constant_">SELECT</span> 
    name, 
    <span class="hljs-title function_">row_number</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> id <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-variable constant_">DATE</span> <span class="hljs-variable constant_">DESC</span>) <span class="hljs-variable constant_">AS</span> row_number
  <span class="hljs-variable constant_">FROM</span> myTable
) <span class="hljs-variable constant_">AS</span> subquery
<span class="hljs-variable constant_">WHERE</span> row_number = <span class="hljs-number">1</span>
</code></pre>
<div class="content-ad"></div>
 태그를 Markdown 형식으로 변경해주세요.
<div class="content-ad"></div>
<p>그리고 여러분, Windows 함수의 흥미로운 케이스가 있나요? 공유하고 싶은 내용이 있다면 댓글에 남겨주세요!</p>
<h1>결론</h1>
<p>SQL이 고전적이거나 클래식하다고 말할 수 없겠죠. 이런 용어들은 과거를 가리키지만, SQL은 저에게 있어 현재에서 매우 중요하며 데이터 분야에서 일하는 사람들에게 꼭 필요한 언어입니다.</p>
<p>그렇지만 SQL로만 해결하기 어려운 문제들이 몇 가지 있을 수도 있습니다. 이럴 때는 언어와 그 능력에 대한 좋은 이해가 정말 중요합니다. Windows 함수가 없다면, Python 관점에서는 보편적으로 간주되는 많은 문제들이 매우 어려우거나 심지어 불가능할 수도 있습니다. 하지만 우리가 도구를 올바르게 사용하는 방법을 안다면 마법을 부릴 수 있습니다!</p>
<div class="content-ad"></div>
<p>이 게시물이 Windows 기능이 작동하는 방식과 실제로 해결할 수 있는 문제 유형을 더 잘 이해하는 데 도움이 되었으면 좋겠습니다. 여기에 제시된 모든 자료는 주로 PostgreSQL 구문을 기반으로 하고 있으며, 다른 데이터베이스에서는 바로 작동하지 않을 수 있지만 가장 중요한 것은 논리 자체입니다. 항상 전문가가 아니며, 해당 주제에 관심이 있는 모든 분들에게 깊이 있는 학습 및 많은 실습을 권장합니다.</p>
<p>독자 여러분, 감사합니다! ;)</p>
<h1>참고 문헌</h1>
<p>[1] PostgreSQL 윈도우 함수를 사용한 데이터 처리. (미상). Timescale. 링크.
[2] Kho, J. (2022, June 5). 고급 SQL 윈도우 함수 쉬운 안내 — Towards Data Science. Medium.
[3] Markingmyname. (2023, November 16). Funções analíticas (Transact-SQL) — SQL Server. Microsoft Learn.
[4] PostgreSQL Tutorial. (2021, April 27). PostgreSQL 윈도우 함수: 궁극의 안내. 링크.
[5] VanMSFT. (2023, May 23). OVER 절 (Transact-SQL) — SQL Server. Microsoft Learn.
[6] 윈도우 함수. (미상). SQLite 공식 문서.
[7] 윈도우 함수. (2014, July 24). PostgreSQL 문서.</p>
<div class="content-ad"></div>
<p>이 게시물의 모든 이미지는 저자가 제작했습니다.</p><table></table>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"윈도우 함수의 해부학","description":"","date":"2024-06-19 16:08","slug":"2024-06-19-AnatomyofWindowsFunctions","content":"\n\n## 소극적으로 여겨지는 SQL 작업의 이론과 실무\n\n![이미지](/assets/img/2024-06-19-AnatomyofWindowsFunctions_0.png)\n\n# 소개\n\nIT 분야는 매일 새로운 도구, 새로운 프레임워크, 새로운 클라우드 제공업체, 그리고 새로운 LLM이 생성되는 등 끊임없는 변화로 유명합니다. 그러나 이 바쁜 세계에서도 몇 가지 원칙, 패러다임, 그리고 도구는 '모든 것이 영원하지 않다'는 상태 쿼를 도전하는 것처럼 보입니다. 특히 데이터 분야에서는 SQL 언어만큼 강제적인 예가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n80년대에 탄생한 이후 데이터 웨어하우스 시대를 지나 Hadoop/Data-lake/Big Data로 활용되어 Hive로 거듭난 뒤 지금은 Spark API 중 하나로 살아 숨 쉬고 있어요. 세상은 많이 변했지만 SQL은 여전히 중요하고 존재감이 크죠.\n\n하지만 SQL은 마치 체스와 같아요. 기본 규칙을 이해하기 쉽지만 스스로를 완전히 다루기는 어려운 것 같아요! SQL은 많은 가능성을 지니고 있으며 같은 문제를 해결하는 다양한 방법, 다양한 함수와 키워드를 가지고 있습니다. 불행히도, 더 많이 알려지지 않은 기능들이 많아요. 이를 알면 쿼리를 작성할 때 많은 도움이 될 수 있습니다.\n\n그래서 이번 포스트에서는, 일상적인 쿼리를 작성할 때 굉장히 유용하게 느껴졌던, 그리 잘 알려지지 않은 SQL의 기능 중 하나에 대해 이야기해보려고 해요: 윈도우 함수.\n\n# 윈도우 함수란 무엇인가\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n전통적이고 가장 유명한 SGBD(PostgreSQL, MySQL 및 Oracle)는 관계 대수 개념에 기반을 두고 있습니다. 여기에는 행이 튜플로 불리며 테이블은 관계로 불립니다. 관계란 튜플들의 집합으로, 즉 튜플 간의 순서 또는 연결이 없습니다. 그래서 테이블 내의 행에 대한 기본적인 순서가 없으며, 한 행에 수행된 계산은 다른 결과에 영향을 주지 않으며 다른 결과에도 영향을 받지 않습니다. ORDER BY와 같은 절조차도 테이블만을 정렬할 뿐, 다른 행의 값을 기반으로 한 행에서의 계산을 수행하는 것은 불가능합니다.\n\n간단히 말하면, 윈도우 함수가 이를 해결해주며 SQL 기능을 확장하여 다른 행의 값을 기반으로 한 행에서 계산을 수행할 수 있습니다.\n\n# 이해를 돕는 기본 사례/해부학\n\n1- 집계 함수 사용하지 않고 집계하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWindows 함수를 이해하는 가장 단순한 예는 '집계하지 않고 집계하는' 능력입니다.\n\n전통적인 GROUP BY를 사용하여 집계를 수행하면 전체 테이블이 두 번째 테이블로 압축되어 각 행이 그룹의 요소를 나타내게 됩니다. 그러나 Windows 함수를 사용하면 행을 압축하는 대신 동일한 테이블에 집계 결과가 포함된 새 열을 생성할 수 있습니다.\n\n예를 들어, 비용 테이블에서 모든 지출을 더해야 한다면, 전통적으로는 다음과 같이 수행할 것입니다:\n\n```js\nSELECT SUM(value) AS total FROM myTable\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWindows 함수를 사용하면 아래와 같이 만들 수 있어요:\n\n```js\nSELECT *, SUM(value) OVER() FROM myTable\n-- 창 함수(window function)가 쿼리에서 열 레벨에 정의됨에 주목하세요\n```\n\n아래 이미지는 결과를 보여줍니다:\n\n![윈도우 함수의 구조](/assets/img/2024-06-19-AnatomyofWindowsFunctions_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 테이블을 생성하는 대신, 집계 값은 새로운 열에 반환됩니다. 값은 같지만 테이블이 '요약'되지 않았습니다. 원본 레코드가 유지되었고 계산된 집계를 집계하지는 않았다는 것을 주목하세요 ;)\n\nOVER 절은 윈도우 함수를 생성함을 나타냅니다. 이 절은 계산이 이루어질 레코드를 정의합니다. 위의 코드가 비어있으므로 모든 레코드에 대해 SUM()을 계산합니다.\n\n이는 열의 합계(또는 평균, 최솟값, 최댓값)을 기반으로 계산이 필요할 때 유용합니다. 예를 들어 각 비용이 총 비용에 대한 백분율로 얼마나 기여하는지를 계산하는 경우입니다.\n\n실제 케이스에서는 회사 부서별로 비용이 있는 예처럼 특정 카테고리에 대한 자세한 내용이 필요할 수 있습니다. 다시 말해서, 각 부서별 총 지출을 간단한 GROUP BY로 얻을 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmyTable에서 depto 및 총합(value)을 그룹화하여 SELECT합니다.\n\n또는 윈도우 함수에서 PARTITION 로직을 지정할 수 있습니다.\n\nmyTable을 PARTITION BY depto로 지정하여 SELECT 및 SUM(value)을 실행합니다.\n\n결과를 확인하세요.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![AnatomyofWindowsFunctions_2](/assets/img/2024-06-19-AnatomyofWindowsFunctions_2.png)\n\n이 예제는 해당 기능이 '창' 함수로 불리는 이유를 이해하는 데 도움이 됩니다. OVER 절은 해당 함수가 작동할 '창' 즉, 테이블의 일련의 줄을 정의합니다.\n\n위의 경우, SUM() 함수는 depto 열 (RH 및 SALES)에 의해 생성된 파티션에서 작동합니다. 이 함수는 depto 열의 각 항목에 대해 '값' 열의 모든 값들을 각각 개별적으로 합산합니다. 줄이 속한 그룹 (RH 또는 SALES)에 따라 '총계' 열의 값이 결정됩니다.\n\n2 — 시간과 순서의 인식\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가끔은 다른 행의 값에 기반하여 하나의 행 안의 열의 값을 계산해야 할 때가 있습니다. 전형적인 예로 현재 값과 이전 값에서 계산한 국가의 GDP의 연간 증가율이 있습니다.\n\n지난 해의 값을 필요로 하는 이러한 계산, 현재 및 이전 행의 차이, 시리즈의 첫 번째 값 등을 필요로 하는 경우는 윈도우 함수의 강력함을 증명합니다. 사실, 표준 SQL 명령어로 이러한 동작을 달성할 수 있는지 모르겠습니다! 아마 가능할 것이지만, 매우 복잡한 쿼리가 될 것입니다...\n\n그러나 윈도우 함수를 사용하면 간단하게 할 수 있습니다. 아래 이미지는 (어린이의 키를 기록하는 테이블입니다):\n\n![테이블 스냅샷](/assets/img/2024-06-19-AnatomyofWindowsFunctions_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nSELECT \n  year, height, \n  LAG(height) OVER (ORDER BY year) AS height_last_year\nFROM myTable\n```\n\nLAG('column') 함수는 이전 행의 'column' 값을 참조하는 역할을 합니다. 이것을 한 단계씩의 순차적인 단계로 상상해볼 수 있습니다: 두 번째 행에서는 첫 번째 값을 고려하고, 세 번째 행에서는 두 번째 값을 고려하고, 그 다음 계속 됩니다... 첫 번째 행은 카운트되지 않습니다(따라서 NULL 값이 반환되는 것), 이전 행이 없기 때문입니다.\n\n당연히 '이전 행'을 정의하기 위해 어떤 순서 조건이 필요합니다. 여기에서 윈도우 함수의 또 다른 중요한 개념인 분석 함수가 필요합니다.\n\n전통적인 SQL 함수와 대조적으로 분석 함수(LAG과 같은)는 행들 사이에 순서가 존재한다고 가정합니다 — 이 순서는 OVER() 안에 있는 ORDER BY 절에 의해 정의됩니다, 즉, 처음, 두 번째, 세 번째 행 등의 개념은 OVER 키워드 내에서 정의됩니다. 이러한 함수들의 주요 특징은 현재 행과 상대적인 다른 행을 참조할 수 있는 능력입니다: LAG는 이전 행을 참조하고, LEAD는 다음 행을 참조하고, FIRST는 분할 내 첫 번째 행을 참조하고, 등등이 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLAG 및 LEAD의 멋진 점 중 하나는 두 번째 인수인 오프셋을 받아들인다는 것입니다. 이 오프셋은 LEAD의 경우 앞으로 몇 개의 행(LEAD) 또는 뒤로 몇 개의 행(LAG)을 살펴볼지를 지정합니다.\n\n```js\nSELECT \n    LAG(height,  2) OVER (ORDER BY year) as height_two_years_ago,\n    LAG(height,  3) OVER (ORDER BY year) as height_three_years_ago,\n    LEAD(height)    OVER (ORDER BY year) as height_next_year\nFROM ...\n```\n\n또한 이러한 함수들로 계산을 수행하는 것도 완벽하게 가능합니다:\n\n```js\nSELECT \n    100*height/(LAG(height) OVER (ORDER BY year)) \n    AS \"annual_growth_%\"\nFROM ...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3 - 시간 인식과 집계\n\n시간과 공간은 하나라고 아인슈타인이 한번 말했던 적이 있는데, 그런 느낌인 것 같아요. 잘 모르겠어요 ¯\\_(ツ)_/¯\n\n이제 파티션 분할과 정렬하는 방법을 알았으니, 두 가지를 함께 사용할 수 있어요! 이전 예제로 돌아와서, 그 표 위에 더 많은 아이들이 있다고 상상해 봅시다. 우리는 각 아이의 성장률을 계산해야 할 때가 왔어요. 매우 간단해요. 정렬과 파티션을 결합해 보세요! 년도별로 정렬하고 아이 이름별로 파티션하면 되겠네요.\n\n```js\nSELECT 1-height/LAG(height) OVER (ORDER BY year PARTITION BY name) ...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_4.png\" /\u003e\n\n위의 쿼리는 다음을 수행합니다 — child에 따라 테이블을 분할하고 각 분할에서 년도별로 값을 정렬한 후 현재 년도의 높이 값을 이전 값으로 나눈 다음 (결과를 1에서 빼서) 계산합니다.\n\n'윈도우(window)'의 전체 개념에 점점 다가가고 있어요! 이것은 '윈도우(window)'가 테이블 슬라이스이며, PARTITION BY에서 정의된 열로 그룹화된 행 세트로서, ORDER BY에서 정의한 필드로 정렬되어, 동일한 그룹(분할) 내의 행만을 고려하며 특정 순서로 모든 계산이 이루어진다는 것입니다.\n\n4-순위 및 위치\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWindows 함수는 세 가지 카테고리로 나뉠 수 있는데, 그 중 두 가지에 대해 이미 이야기했습니다: 집계 함수 ( COUNT, SUM, AVG, MAX, ... )와 분석 함수 ( LAG, LEAD, FIRST_VALUE, LAST_VALUE, ... ).\n\n세 번째 그룹은 가장 간단한 순위 함수입니다. 그 중에서도 row_number() 함수가 가장 큰 영향을 미칩니다. 해당 함수는 그룹 내에서 행의 위치를 나타내는 정수를 반환합니다 (정의된 순서에 따라).\n\n```js\nSELECT row_number() OVER(ORDER BY score)\n```\n\n순위 함수는 이름에서 알 수 있듯이 그룹 내 라인의 위치에 따라 값이 반환되며, 정렬 기준에 따라 정의된 그룹입니다. ROW_NUMBER, RANK 및 NTILE이 가장 많이 사용되는 함수 몇 가지입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 이미지에서 각 플레이어의 점수에 기반한 행 번호가 생성됩니다.\n\n... 그리고 네, 1부터 시작하는 끔찍한 프로그래밍 죄악을 저질립니다.\n\n5-창 크기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n현재까지 소개된 모든 함수들은 결과를 계산할 때 파티션/그룹 내의 모든 행을 고려합니다. 예를 들어, 첫 번째 예제에서 설명한 SUM() 함수는 총계를 계산할 때 모든 부서의 행을 고려합니다.\n\n하지만 더 작은 창 크기를 지정하여 현재 행 전후 몇 줄을 계산에 고려할 수도 있습니다. 이는 이동 평균/롤링 윈도우를 계산하는 데 유용한 기능입니다.\n\n다음 예제를 고려해 봅시다. 특정 질병의 일일 발병 건수를 포함하는 표가 있고, 현재 날짜와 이전 2일을 고려하여 발병 건수의 평균을 계산해야 하는 경우를 생각해 봅시다. 앞서 소개된 LAG 함수로도 이 문제를 해결할 수 있다는 점을 주목해 주세요:\n\n```js\nSELECT\n( n_cases + LAG(n_cases, 1) + LAG(n_cases, 2) )/3\nOVER (ORDER BY date_reference)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 더 우아하게 동일한 결과를 얻을 수 있습니다. 프레임 개념을 사용하여:\n\n```js\nSELECT\nAVG(n_cases)\nOVER (\n ORDER BY date_reference\n ROWS BETWEEN 2 PRECEDING AND CURRENT ROW \n)\n```\n\n위의 프레임은 이전 2개의 행과 현재 행에 대해서만 평균을 계산해야 함을 지정합니다. 이전, 현재 행 및 다음 행을 모두 고려하고 싶다면, 프레임을 변경할 수 있습니다:\n\n```js\nAVG(n_cases)\nOVER (\n ORDER BY date_reference\n ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n그것이 프레임이란 거에요 — 특정한 범위 내에서 함수의 작용을 제한하는 방법입니다. 대부분의 경우, 윈도우 함수는 다음과 같은 프레임을 고려합니다:\n\n```js\nROWS BETWEEN UNBOUDED PRECEDING AND CURRENT ROW\n-- 이전의 모든 행 + 현재 행\n```\n\n\u003cimg src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_6.png\" /\u003e\n\n이 소개가 윈도우 함수가 무엇이고, 어떻게 작동하며, 실제 구문은 어떻게 되는지 더 잘 이해하도록 도와드리기를 바랍니다. 당연히 윈도우 함수에는 많은 다른 키워드가 추가될 수 있지만, 이미 다룬 명령어들이 일상 생활에서 많이 사용될 것으로 생각합니다. 이제 제가 일상에서 문제를 해결하기 위해 사용하는 흥미로운 실용적인 응용 프로그램 중 일부를 살펴보겠습니다 — 아주 흥미로운 것들이 있답니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Windows 함수의 흥미로운 사용 사례\n\n## 시간별 누적 합계\n\n이것은 Windows 함수를 사용하는 가장 고전적인 사례 중 하나입니다.\n\n매월 당신의 급여가 나와 있는 표가 있다고 상상해보세요. 각 달에 얼마를 벌었는지 누적으로 알고 싶다면(이전 달 모두를 고려하여), 이것이 작동하는 방식입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아주 쉽죠?\n\n이 쿼리에서 흥미로운 점은 SUM() 함수가 현재 행 및 이전 모든 행을 고려하여 집계를 계산한다는 것입니다.\n\n## 로그 테이블의 이벤트 지속 시간\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 최근에 작성한 포스트인 \"덕DB의 My First Billion (of Rows)\"에서는 브라질의 전자 투표 기계에서 로그를 조작하는 내용을 다뤘어요. 대량의 데이터 처리에 관심이 있다면 한 번 확인해보세요.\n\n요약하면, 각 이벤트가 시작된 시간을 나타내는 타임스탬프와 이름, 그리고 고유 식별자로 구성된 로그 테이블을 상상해보세요. 각 이벤트는 이전 이벤트가 끝날 때 시작되기 때문에, 이벤트 기간을 나타내는 열을 쉽게 추가할 수 있어요:\n\n![이미지](/assets/img/2024-06-19-AnatomyofWindowsFunctions_8.png)\n\n## 누락된 값 채우기 (마지막 발생으로)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n판다스를 활용한 머신 러닝 클래식! fillna, bfill 또는 다른 방법으로 널 값을 채우는 것만으로도 데이터 처리를 해결할 수 있어요.\n\nSQL에서는 이를 어떻게 할까요? 간단해요!\n\n![이미지](/assets/img/2024-06-19-AnatomyofWindowsFunctions_9.png)\n\n머신 러닝을 처음 공부할 때는 판다스와 같은 고수준의 함수들을 많이 사용하곤 해요. 하지만 실제 프로젝트를 진행할 때는 데이터 양이 매우 많아 판다스를 사용할 수 없는 경우가 많아요. 그럴 때는 PySpark, Snowflake, Hive+hadoop 등의 도구를 사용해야 하는데, 이들은 어떤 식으로든 SQL에서 작업이 가능해요. 그렇기 때문에 SQL에서 이러한 처리와 전처리를 어떻게 하는지 배우는 것이 중요하다고 생각해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 누락된 값 채우기 (앞 행의 평균으로)\n\n널(빈 값)을 채우는 더 다양한 방법, 그래도 간단합니다!\n\n![Windows Functions](/assets/img/2024-06-19-AnatomyofWindowsFunctions_10.png)\n\n이 예는 윈도우 함수가 복잡하고 특별한 것으로 보일지라도 일반 열처럼 사용할 수 있다는 것을 강조합니다! CASE에 포함시킬 수 있고, 계산에 활용할 수 있습니다. 알고 있는 제한 사항 중 일부는 WHERE 절에 직접적으로 배치할 수 없다는 것뿐입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sql\nSELECT * FROM\nWHERE SUM() OVER() \u003e 10 -- 이 기능은 postgres에서는 불가능합니다.\n```\n\n## 특정 열 기반의 행 중복 제거\n\n윈도우 함수의 또 다른 고전적인 사례! 때로는 하나의 열 집합을 기준으로 하여 테이블의 행을 중복 제거해야 할 때가 있습니다.\n\n물론 SQL에서는 DISTINCT 절을 사용할 수 있지만, 이는 전체 행이 중복될 때만 작동합니다. 테이블에 같은 ID 열의 값이지만 나머지 열에서는 다른 값이 있는 여러 행이 있는 경우 다음 로직을 사용하여 중복을 제거할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_11.png\" /\u003e\n\n```js\nSELECT *\n  FROM (\n   SELECT\n   ROW_NUMBER() OVER (PARTITION BY id) as row_number\n  )\nWHERE row_number = 1\n```\n\n이 작업은 데이터 버전 관리도 가능합니다! 예를 들어, 시스템에서 사용자가 이름을 변경할 때마다 변경 날짜와 함께 새로운 줄을 저장하면(기존 줄을 변경하는 대신), 각 사용자의 현재 이름을 검색할 수 있습니다:\n\n```js\nSELECT\n    *\nFROM\n(\n  SELECT \n    name, \n    row_number() OVER (PARTITION BY id ORDER BY DATE DESC) AS row_number\n  FROM myTable\n) AS subquery\nWHERE row_number = 1\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003ctable\u003e 태그를 Markdown 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그리고 여러분, Windows 함수의 흥미로운 케이스가 있나요? 공유하고 싶은 내용이 있다면 댓글에 남겨주세요!\n\n# 결론\n\nSQL이 고전적이거나 클래식하다고 말할 수 없겠죠. 이런 용어들은 과거를 가리키지만, SQL은 저에게 있어 현재에서 매우 중요하며 데이터 분야에서 일하는 사람들에게 꼭 필요한 언어입니다.\n\n그렇지만 SQL로만 해결하기 어려운 문제들이 몇 가지 있을 수도 있습니다. 이럴 때는 언어와 그 능력에 대한 좋은 이해가 정말 중요합니다. Windows 함수가 없다면, Python 관점에서는 보편적으로 간주되는 많은 문제들이 매우 어려우거나 심지어 불가능할 수도 있습니다. 하지만 우리가 도구를 올바르게 사용하는 방법을 안다면 마법을 부릴 수 있습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 게시물이 Windows 기능이 작동하는 방식과 실제로 해결할 수 있는 문제 유형을 더 잘 이해하는 데 도움이 되었으면 좋겠습니다. 여기에 제시된 모든 자료는 주로 PostgreSQL 구문을 기반으로 하고 있으며, 다른 데이터베이스에서는 바로 작동하지 않을 수 있지만 가장 중요한 것은 논리 자체입니다. 항상 전문가가 아니며, 해당 주제에 관심이 있는 모든 분들에게 깊이 있는 학습 및 많은 실습을 권장합니다.\n\n독자 여러분, 감사합니다! ;)\n\n# 참고 문헌\n\n[1] PostgreSQL 윈도우 함수를 사용한 데이터 처리. (미상). Timescale. 링크.\n[2] Kho, J. (2022, June 5). 고급 SQL 윈도우 함수 쉬운 안내 — Towards Data Science. Medium.\n[3] Markingmyname. (2023, November 16). Funções analíticas (Transact-SQL) — SQL Server. Microsoft Learn.\n[4] PostgreSQL Tutorial. (2021, April 27). PostgreSQL 윈도우 함수: 궁극의 안내. 링크.\n[5] VanMSFT. (2023, May 23). OVER 절 (Transact-SQL) — SQL Server. Microsoft Learn.\n[6] 윈도우 함수. (미상). SQLite 공식 문서.\n[7] 윈도우 함수. (2014, July 24). PostgreSQL 문서.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 게시물의 모든 이미지는 저자가 제작했습니다.","ogImage":{"url":"/assets/img/2024-06-19-AnatomyofWindowsFunctions_0.png"},"coverImage":"/assets/img/2024-06-19-AnatomyofWindowsFunctions_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e소극적으로 여겨지는 SQL 작업의 이론과 실무\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003eIT 분야는 매일 새로운 도구, 새로운 프레임워크, 새로운 클라우드 제공업체, 그리고 새로운 LLM이 생성되는 등 끊임없는 변화로 유명합니다. 그러나 이 바쁜 세계에서도 몇 가지 원칙, 패러다임, 그리고 도구는 '모든 것이 영원하지 않다'는 상태 쿼를 도전하는 것처럼 보입니다. 특히 데이터 분야에서는 SQL 언어만큼 강제적인 예가 없습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e80년대에 탄생한 이후 데이터 웨어하우스 시대를 지나 Hadoop/Data-lake/Big Data로 활용되어 Hive로 거듭난 뒤 지금은 Spark API 중 하나로 살아 숨 쉬고 있어요. 세상은 많이 변했지만 SQL은 여전히 중요하고 존재감이 크죠.\u003c/p\u003e\n\u003cp\u003e하지만 SQL은 마치 체스와 같아요. 기본 규칙을 이해하기 쉽지만 스스로를 완전히 다루기는 어려운 것 같아요! SQL은 많은 가능성을 지니고 있으며 같은 문제를 해결하는 다양한 방법, 다양한 함수와 키워드를 가지고 있습니다. 불행히도, 더 많이 알려지지 않은 기능들이 많아요. 이를 알면 쿼리를 작성할 때 많은 도움이 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그래서 이번 포스트에서는, 일상적인 쿼리를 작성할 때 굉장히 유용하게 느껴졌던, 그리 잘 알려지지 않은 SQL의 기능 중 하나에 대해 이야기해보려고 해요: 윈도우 함수.\u003c/p\u003e\n\u003ch1\u003e윈도우 함수란 무엇인가\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e전통적이고 가장 유명한 SGBD(PostgreSQL, MySQL 및 Oracle)는 관계 대수 개념에 기반을 두고 있습니다. 여기에는 행이 튜플로 불리며 테이블은 관계로 불립니다. 관계란 튜플들의 집합으로, 즉 튜플 간의 순서 또는 연결이 없습니다. 그래서 테이블 내의 행에 대한 기본적인 순서가 없으며, 한 행에 수행된 계산은 다른 결과에 영향을 주지 않으며 다른 결과에도 영향을 받지 않습니다. ORDER BY와 같은 절조차도 테이블만을 정렬할 뿐, 다른 행의 값을 기반으로 한 행에서의 계산을 수행하는 것은 불가능합니다.\u003c/p\u003e\n\u003cp\u003e간단히 말하면, 윈도우 함수가 이를 해결해주며 SQL 기능을 확장하여 다른 행의 값을 기반으로 한 행에서 계산을 수행할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e이해를 돕는 기본 사례/해부학\u003c/h1\u003e\n\u003cp\u003e1- 집계 함수 사용하지 않고 집계하기\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eWindows 함수를 이해하는 가장 단순한 예는 '집계하지 않고 집계하는' 능력입니다.\u003c/p\u003e\n\u003cp\u003e전통적인 GROUP BY를 사용하여 집계를 수행하면 전체 테이블이 두 번째 테이블로 압축되어 각 행이 그룹의 요소를 나타내게 됩니다. 그러나 Windows 함수를 사용하면 행을 압축하는 대신 동일한 테이블에 집계 결과가 포함된 새 열을 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예를 들어, 비용 테이블에서 모든 지출을 더해야 한다면, 전통적으로는 다음과 같이 수행할 것입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(value) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e total \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e myTable\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eWindows 함수를 사용하면 아래와 같이 만들 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e *, \u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(value) \u003cspan class=\"hljs-title function_\"\u003eOVER\u003c/span\u003e() \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e myTable\n-- 창 함수(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e)가 쿼리에서 열 레벨에 정의됨에 주목하세요\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래 이미지는 결과를 보여줍니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_1.png\" alt=\"윈도우 함수의 구조\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e새로운 테이블을 생성하는 대신, 집계 값은 새로운 열에 반환됩니다. 값은 같지만 테이블이 '요약'되지 않았습니다. 원본 레코드가 유지되었고 계산된 집계를 집계하지는 않았다는 것을 주목하세요 ;)\u003c/p\u003e\n\u003cp\u003eOVER 절은 윈도우 함수를 생성함을 나타냅니다. 이 절은 계산이 이루어질 레코드를 정의합니다. 위의 코드가 비어있으므로 모든 레코드에 대해 SUM()을 계산합니다.\u003c/p\u003e\n\u003cp\u003e이는 열의 합계(또는 평균, 최솟값, 최댓값)을 기반으로 계산이 필요할 때 유용합니다. 예를 들어 각 비용이 총 비용에 대한 백분율로 얼마나 기여하는지를 계산하는 경우입니다.\u003c/p\u003e\n\u003cp\u003e실제 케이스에서는 회사 부서별로 비용이 있는 예처럼 특정 카테고리에 대한 자세한 내용이 필요할 수 있습니다. 다시 말해서, 각 부서별 총 지출을 간단한 GROUP BY로 얻을 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emyTable에서 depto 및 총합(value)을 그룹화하여 \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e합니다.\n\n또는 윈도우 함수에서 \u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e 로직을 지정할 수 있습니다.\n\nmyTable을 \u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e depto로 지정하여 \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e 및 \u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(value)을 실행합니다.\n\n결과를 확인하세요.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_2.png\" alt=\"AnatomyofWindowsFunctions_2\"\u003e\u003c/p\u003e\n\u003cp\u003e이 예제는 해당 기능이 '창' 함수로 불리는 이유를 이해하는 데 도움이 됩니다. OVER 절은 해당 함수가 작동할 '창' 즉, 테이블의 일련의 줄을 정의합니다.\u003c/p\u003e\n\u003cp\u003e위의 경우, SUM() 함수는 depto 열 (RH 및 SALES)에 의해 생성된 파티션에서 작동합니다. 이 함수는 depto 열의 각 항목에 대해 '값' 열의 모든 값들을 각각 개별적으로 합산합니다. 줄이 속한 그룹 (RH 또는 SALES)에 따라 '총계' 열의 값이 결정됩니다.\u003c/p\u003e\n\u003cp\u003e2 — 시간과 순서의 인식\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e가끔은 다른 행의 값에 기반하여 하나의 행 안의 열의 값을 계산해야 할 때가 있습니다. 전형적인 예로 현재 값과 이전 값에서 계산한 국가의 GDP의 연간 증가율이 있습니다.\u003c/p\u003e\n\u003cp\u003e지난 해의 값을 필요로 하는 이러한 계산, 현재 및 이전 행의 차이, 시리즈의 첫 번째 값 등을 필요로 하는 경우는 윈도우 함수의 강력함을 증명합니다. 사실, 표준 SQL 명령어로 이러한 동작을 달성할 수 있는지 모르겠습니다! 아마 가능할 것이지만, 매우 복잡한 쿼리가 될 것입니다...\u003c/p\u003e\n\u003cp\u003e그러나 윈도우 함수를 사용하면 간단하게 할 수 있습니다. 아래 이미지는 (어린이의 키를 기록하는 테이블입니다):\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_3.png\" alt=\"테이블 스냅샷\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n  year, height, \n  \u003cspan class=\"hljs-title function_\"\u003eLAG\u003c/span\u003e(height) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e year) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e height_last_year\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e myTable\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLAG('column') 함수는 이전 행의 'column' 값을 참조하는 역할을 합니다. 이것을 한 단계씩의 순차적인 단계로 상상해볼 수 있습니다: 두 번째 행에서는 첫 번째 값을 고려하고, 세 번째 행에서는 두 번째 값을 고려하고, 그 다음 계속 됩니다... 첫 번째 행은 카운트되지 않습니다(따라서 NULL 값이 반환되는 것), 이전 행이 없기 때문입니다.\u003c/p\u003e\n\u003cp\u003e당연히 '이전 행'을 정의하기 위해 어떤 순서 조건이 필요합니다. 여기에서 윈도우 함수의 또 다른 중요한 개념인 분석 함수가 필요합니다.\u003c/p\u003e\n\u003cp\u003e전통적인 SQL 함수와 대조적으로 분석 함수(LAG과 같은)는 행들 사이에 순서가 존재한다고 가정합니다 — 이 순서는 OVER() 안에 있는 ORDER BY 절에 의해 정의됩니다, 즉, 처음, 두 번째, 세 번째 행 등의 개념은 OVER 키워드 내에서 정의됩니다. 이러한 함수들의 주요 특징은 현재 행과 상대적인 다른 행을 참조할 수 있는 능력입니다: LAG는 이전 행을 참조하고, LEAD는 다음 행을 참조하고, FIRST는 분할 내 첫 번째 행을 참조하고, 등등이 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eLAG 및 LEAD의 멋진 점 중 하나는 두 번째 인수인 오프셋을 받아들인다는 것입니다. 이 오프셋은 LEAD의 경우 앞으로 몇 개의 행(LEAD) 또는 뒤로 몇 개의 행(LAG)을 살펴볼지를 지정합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    \u003cspan class=\"hljs-title function_\"\u003eLAG\u003c/span\u003e(height,  \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e year) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e height_two_years_ago,\n    \u003cspan class=\"hljs-title function_\"\u003eLAG\u003c/span\u003e(height,  \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e year) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e height_three_years_ago,\n    \u003cspan class=\"hljs-title function_\"\u003eLEAD\u003c/span\u003e(height)    \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e year) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e height_next_year\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e또한 이러한 함수들로 계산을 수행하는 것도 완벽하게 가능합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e*height/(\u003cspan class=\"hljs-title function_\"\u003eLAG\u003c/span\u003e(height) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e year)) \n    \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"annual_growth_%\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e3 - 시간 인식과 집계\u003c/p\u003e\n\u003cp\u003e시간과 공간은 하나라고 아인슈타인이 한번 말했던 적이 있는데, 그런 느낌인 것 같아요. 잘 모르겠어요 ¯_(ツ)_/¯\u003c/p\u003e\n\u003cp\u003e이제 파티션 분할과 정렬하는 방법을 알았으니, 두 가지를 함께 사용할 수 있어요! 이전 예제로 돌아와서, 그 표 위에 더 많은 아이들이 있다고 상상해 봅시다. 우리는 각 아이의 성장률을 계산해야 할 때가 왔어요. 매우 간단해요. 정렬과 파티션을 결합해 보세요! 년도별로 정렬하고 아이 이름별로 파티션하면 되겠네요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e-height/\u003cspan class=\"hljs-title function_\"\u003eLAG\u003c/span\u003e(height) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e year \u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e name) ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_4.png\"\u003e\n\u003cp\u003e위의 쿼리는 다음을 수행합니다 — child에 따라 테이블을 분할하고 각 분할에서 년도별로 값을 정렬한 후 현재 년도의 높이 값을 이전 값으로 나눈 다음 (결과를 1에서 빼서) 계산합니다.\u003c/p\u003e\n\u003cp\u003e'윈도우(window)'의 전체 개념에 점점 다가가고 있어요! 이것은 '윈도우(window)'가 테이블 슬라이스이며, PARTITION BY에서 정의된 열로 그룹화된 행 세트로서, ORDER BY에서 정의한 필드로 정렬되어, 동일한 그룹(분할) 내의 행만을 고려하며 특정 순서로 모든 계산이 이루어진다는 것입니다.\u003c/p\u003e\n\u003cp\u003e4-순위 및 위치\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eWindows 함수는 세 가지 카테고리로 나뉠 수 있는데, 그 중 두 가지에 대해 이미 이야기했습니다: 집계 함수 ( COUNT, SUM, AVG, MAX, ... )와 분석 함수 ( LAG, LEAD, FIRST_VALUE, LAST_VALUE, ... ).\u003c/p\u003e\n\u003cp\u003e세 번째 그룹은 가장 간단한 순위 함수입니다. 그 중에서도 row_number() 함수가 가장 큰 영향을 미칩니다. 해당 함수는 그룹 내에서 행의 위치를 나타내는 정수를 반환합니다 (정의된 순서에 따라).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erow_number\u003c/span\u003e() \u003cspan class=\"hljs-title function_\"\u003eOVER\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e score)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e순위 함수는 이름에서 알 수 있듯이 그룹 내 라인의 위치에 따라 값이 반환되며, 정렬 기준에 따라 정의된 그룹입니다. ROW_NUMBER, RANK 및 NTILE이 가장 많이 사용되는 함수 몇 가지입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 이미지에서 각 플레이어의 점수에 기반한 행 번호가 생성됩니다.\u003c/p\u003e\n\u003cp\u003e... 그리고 네, 1부터 시작하는 끔찍한 프로그래밍 죄악을 저질립니다.\u003c/p\u003e\n\u003cp\u003e5-창 크기\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e현재까지 소개된 모든 함수들은 결과를 계산할 때 파티션/그룹 내의 모든 행을 고려합니다. 예를 들어, 첫 번째 예제에서 설명한 SUM() 함수는 총계를 계산할 때 모든 부서의 행을 고려합니다.\u003c/p\u003e\n\u003cp\u003e하지만 더 작은 창 크기를 지정하여 현재 행 전후 몇 줄을 계산에 고려할 수도 있습니다. 이는 이동 평균/롤링 윈도우를 계산하는 데 유용한 기능입니다.\u003c/p\u003e\n\u003cp\u003e다음 예제를 고려해 봅시다. 특정 질병의 일일 발병 건수를 포함하는 표가 있고, 현재 날짜와 이전 2일을 고려하여 발병 건수의 평균을 계산해야 하는 경우를 생각해 봅시다. 앞서 소개된 LAG 함수로도 이 문제를 해결할 수 있다는 점을 주목해 주세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n( n_cases + \u003cspan class=\"hljs-title function_\"\u003eLAG\u003c/span\u003e(n_cases, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) + \u003cspan class=\"hljs-title function_\"\u003eLAG\u003c/span\u003e(n_cases, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) )/\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e date_reference)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e하지만 더 우아하게 동일한 결과를 얻을 수 있습니다. 프레임 개념을 사용하여:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eAVG\u003c/span\u003e(n_cases)\n\u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\n \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e date_reference\n \u003cspan class=\"hljs-variable constant_\"\u003eROWS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRECEDING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCURRENT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROW\u003c/span\u003e \n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위의 프레임은 이전 2개의 행과 현재 행에 대해서만 평균을 계산해야 함을 지정합니다. 이전, 현재 행 및 다음 행을 모두 고려하고 싶다면, 프레임을 변경할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eAVG\u003c/span\u003e(n_cases)\n\u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\n \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e date_reference\n \u003cspan class=\"hljs-variable constant_\"\u003eROWS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRECEDING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eFOLLOWING\u003c/span\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e테이블 태그를 Markdown 형식으로 변경하세요.\u003c/p\u003e\n\u003cp\u003e그것이 프레임이란 거에요 — 특정한 범위 내에서 함수의 작용을 제한하는 방법입니다. 대부분의 경우, 윈도우 함수는 다음과 같은 프레임을 고려합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eROWS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eUNBOUDED\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRECEDING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCURRENT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROW\u003c/span\u003e\n-- 이전의 모든 행 + 현재 행\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_6.png\"\u003e\n\u003cp\u003e이 소개가 윈도우 함수가 무엇이고, 어떻게 작동하며, 실제 구문은 어떻게 되는지 더 잘 이해하도록 도와드리기를 바랍니다. 당연히 윈도우 함수에는 많은 다른 키워드가 추가될 수 있지만, 이미 다룬 명령어들이 일상 생활에서 많이 사용될 것으로 생각합니다. 이제 제가 일상에서 문제를 해결하기 위해 사용하는 흥미로운 실용적인 응용 프로그램 중 일부를 살펴보겠습니다 — 아주 흥미로운 것들이 있답니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eWindows 함수의 흥미로운 사용 사례\u003c/h1\u003e\n\u003ch2\u003e시간별 누적 합계\u003c/h2\u003e\n\u003cp\u003e이것은 Windows 함수를 사용하는 가장 고전적인 사례 중 하나입니다.\u003c/p\u003e\n\u003cp\u003e매월 당신의 급여가 나와 있는 표가 있다고 상상해보세요. 각 달에 얼마를 벌었는지 누적으로 알고 싶다면(이전 달 모두를 고려하여), 이것이 작동하는 방식입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아주 쉽죠?\u003c/p\u003e\n\u003cp\u003e이 쿼리에서 흥미로운 점은 SUM() 함수가 현재 행 및 이전 모든 행을 고려하여 집계를 계산한다는 것입니다.\u003c/p\u003e\n\u003ch2\u003e로그 테이블의 이벤트 지속 시간\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e제가 최근에 작성한 포스트인 \"덕DB의 My First Billion (of Rows)\"에서는 브라질의 전자 투표 기계에서 로그를 조작하는 내용을 다뤘어요. 대량의 데이터 처리에 관심이 있다면 한 번 확인해보세요.\u003c/p\u003e\n\u003cp\u003e요약하면, 각 이벤트가 시작된 시간을 나타내는 타임스탬프와 이름, 그리고 고유 식별자로 구성된 로그 테이블을 상상해보세요. 각 이벤트는 이전 이벤트가 끝날 때 시작되기 때문에, 이벤트 기간을 나타내는 열을 쉽게 추가할 수 있어요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e누락된 값 채우기 (마지막 발생으로)\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e판다스를 활용한 머신 러닝 클래식! fillna, bfill 또는 다른 방법으로 널 값을 채우는 것만으로도 데이터 처리를 해결할 수 있어요.\u003c/p\u003e\n\u003cp\u003eSQL에서는 이를 어떻게 할까요? 간단해요!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_9.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e머신 러닝을 처음 공부할 때는 판다스와 같은 고수준의 함수들을 많이 사용하곤 해요. 하지만 실제 프로젝트를 진행할 때는 데이터 양이 매우 많아 판다스를 사용할 수 없는 경우가 많아요. 그럴 때는 PySpark, Snowflake, Hive+hadoop 등의 도구를 사용해야 하는데, 이들은 어떤 식으로든 SQL에서 작업이 가능해요. 그렇기 때문에 SQL에서 이러한 처리와 전처리를 어떻게 하는지 배우는 것이 중요하다고 생각해요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e누락된 값 채우기 (앞 행의 평균으로)\u003c/h2\u003e\n\u003cp\u003e널(빈 값)을 채우는 더 다양한 방법, 그래도 간단합니다!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_10.png\" alt=\"Windows Functions\"\u003e\u003c/p\u003e\n\u003cp\u003e이 예는 윈도우 함수가 복잡하고 특별한 것으로 보일지라도 일반 열처럼 사용할 수 있다는 것을 강조합니다! CASE에 포함시킬 수 있고, 계산에 활용할 수 있습니다. 알고 있는 제한 사항 중 일부는 WHERE 절에 직접적으로 배치할 수 없다는 것뿐입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e*\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eWHERE\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eSUM\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003eOVER\u003c/span\u003e() \u003cspan class=\"hljs-operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e-- 이 기능은 postgres에서는 불가능합니다.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e특정 열 기반의 행 중복 제거\u003c/h2\u003e\n\u003cp\u003e윈도우 함수의 또 다른 고전적인 사례! 때로는 하나의 열 집합을 기준으로 하여 테이블의 행을 중복 제거해야 할 때가 있습니다.\u003c/p\u003e\n\u003cp\u003e물론 SQL에서는 DISTINCT 절을 사용할 수 있지만, 이는 전체 행이 중복될 때만 작동합니다. 테이블에 같은 ID 열의 값이지만 나머지 열에서는 다른 값이 있는 여러 행이 있는 경우 다음 로직을 사용하여 중복을 제거할 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_11.png\"\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e *\n  \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e (\n   \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n   \u003cspan class=\"hljs-title function_\"\u003eROW_NUMBER\u003c/span\u003e() \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e id) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e row_number\n  )\n\u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e row_number = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 작업은 데이터 버전 관리도 가능합니다! 예를 들어, 시스템에서 사용자가 이름을 변경할 때마다 변경 날짜와 함께 새로운 줄을 저장하면(기존 줄을 변경하는 대신), 각 사용자의 현재 이름을 검색할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n    *\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e\n(\n  \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    name, \n    \u003cspan class=\"hljs-title function_\"\u003erow_number\u003c/span\u003e() \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e id \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDATE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDESC\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e row_number\n  \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e myTable\n) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e subquery\n\u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e row_number = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n 태그를 Markdown 형식으로 변경해주세요.\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그리고 여러분, Windows 함수의 흥미로운 케이스가 있나요? 공유하고 싶은 내용이 있다면 댓글에 남겨주세요!\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eSQL이 고전적이거나 클래식하다고 말할 수 없겠죠. 이런 용어들은 과거를 가리키지만, SQL은 저에게 있어 현재에서 매우 중요하며 데이터 분야에서 일하는 사람들에게 꼭 필요한 언어입니다.\u003c/p\u003e\n\u003cp\u003e그렇지만 SQL로만 해결하기 어려운 문제들이 몇 가지 있을 수도 있습니다. 이럴 때는 언어와 그 능력에 대한 좋은 이해가 정말 중요합니다. Windows 함수가 없다면, Python 관점에서는 보편적으로 간주되는 많은 문제들이 매우 어려우거나 심지어 불가능할 수도 있습니다. 하지만 우리가 도구를 올바르게 사용하는 방법을 안다면 마법을 부릴 수 있습니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 게시물이 Windows 기능이 작동하는 방식과 실제로 해결할 수 있는 문제 유형을 더 잘 이해하는 데 도움이 되었으면 좋겠습니다. 여기에 제시된 모든 자료는 주로 PostgreSQL 구문을 기반으로 하고 있으며, 다른 데이터베이스에서는 바로 작동하지 않을 수 있지만 가장 중요한 것은 논리 자체입니다. 항상 전문가가 아니며, 해당 주제에 관심이 있는 모든 분들에게 깊이 있는 학습 및 많은 실습을 권장합니다.\u003c/p\u003e\n\u003cp\u003e독자 여러분, 감사합니다! ;)\u003c/p\u003e\n\u003ch1\u003e참고 문헌\u003c/h1\u003e\n\u003cp\u003e[1] PostgreSQL 윈도우 함수를 사용한 데이터 처리. (미상). Timescale. 링크.\n[2] Kho, J. (2022, June 5). 고급 SQL 윈도우 함수 쉬운 안내 — Towards Data Science. Medium.\n[3] Markingmyname. (2023, November 16). Funções analíticas (Transact-SQL) — SQL Server. Microsoft Learn.\n[4] PostgreSQL Tutorial. (2021, April 27). PostgreSQL 윈도우 함수: 궁극의 안내. 링크.\n[5] VanMSFT. (2023, May 23). OVER 절 (Transact-SQL) — SQL Server. Microsoft Learn.\n[6] 윈도우 함수. (미상). SQLite 공식 문서.\n[7] 윈도우 함수. (2014, July 24). PostgreSQL 문서.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 게시물의 모든 이미지는 저자가 제작했습니다.\u003c/p\u003e\u003ctable\u003e\u003c/table\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-AnatomyofWindowsFunctions"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>