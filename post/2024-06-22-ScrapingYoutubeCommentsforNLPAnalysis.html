<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>NLP 분석을 위한 Youtube 댓글 스크래핑 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="NLP 분석을 위한 Youtube 댓글 스크래핑 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="NLP 분석을 위한 Youtube 댓글 스크래핑 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis" data-gatsby-head="true"/><meta name="twitter:title" content="NLP 분석을 위한 Youtube 댓글 스크래핑 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 16:44" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_buildManifest.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">NLP 분석을 위한 Youtube 댓글 스크래핑 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="NLP 분석을 위한 Youtube 댓글 스크래핑 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_0.png" alt="image"></p>
<p>간단한 NLP 프로젝트를 시도해보고자 했는데, 유튜브 동영상에서 댓글을 가져와 분석해보려고 합니다.</p>
<p>사실 향수에 대해 연구 중이었는데, 인스타그램을 무심코 스크롤하다가 향수 광고에 끌려들어가게 되었습니다. 그렇게해서 향수 리뷰 동영상들을 찾게 되었고, Demi Rawling의 향수 리뷰 동영상을 발견하게 되었습니다... (너무 핫하네요).</p>
<p>유튜브 링크 - <a href="https://youtu.be/oJqc2tLMObg" rel="nofollow" target="_blank">https://youtu.be/oJqc2tLMObg</a></p>
<div class="content-ad"></div>
<p>이 동영상은 탑 10 톰 포드 향수에 관한 것입니다. 다소 오래된 동영상이긴 하지만(4년 전 영상입니다)</p>
<p>먼저, 만약 설치되어 있지 않다면 이곳에서 ChromeDriver를 설치해주세요. 저는 VS Code에서 실행을 시도해봤어요. 필요한 라이브러리는 다음과 같아요...</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime
<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
<span class="hljs-keyword">from</span> selenium.<span class="hljs-property">webdriver</span>.<span class="hljs-property">common</span>.<span class="hljs-property">keys</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Keys</span>
<span class="hljs-keyword">from</span> selenium.<span class="hljs-property">webdriver</span>.<span class="hljs-property">common</span>.<span class="hljs-property">by</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">By</span>
<span class="hljs-keyword">from</span> selenium.<span class="hljs-property">webdriver</span>.<span class="hljs-property">support</span>.<span class="hljs-property">ui</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">WebDriverWait</span>
<span class="hljs-keyword">from</span> selenium.<span class="hljs-property">webdriver</span>.<span class="hljs-property">support</span> <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">EC</span>
</code></pre>
<p>그런 다음 스크래핑 부분이 나옵니다...</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver
<span class="hljs-keyword">from</span> selenium.webdriver.common.keys <span class="hljs-keyword">import</span> Keys
<span class="hljs-keyword">from</span> selenium.webdriver.common.by <span class="hljs-keyword">import</span> By
<span class="hljs-keyword">from</span> selenium.webdriver.support.ui <span class="hljs-keyword">import</span> WebDriverWait
<span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime

<span class="hljs-comment"># WebDriver를 초기화하고 성능을 향상시키기 위한 옵션 설정</span>
options = webdriver.ChromeOptions()
options.add_argument(<span class="hljs-string">"--headless"</span>)  <span class="hljs-comment"># 헤드리스 모드로 실행</span>
options.add_argument(<span class="hljs-string">"--disable-gpu"</span>)  <span class="hljs-comment"># GPU 렌더링 비활성화</span>
options.add_argument(<span class="hljs-string">"--no-sandbox"</span>)  <span class="hljs-comment"># OS 보안 모델 우회</span>
options.add_argument(<span class="hljs-string">"--disable-dev-shm-usage"</span>)  <span class="hljs-comment"># 제한된 리소스 문제 극복</span>
options.add_argument(<span class="hljs-string">"--start-maximized"</span>)  <span class="hljs-comment"># 창 최대화</span>

driver = webdriver.Chrome(options=options)

data = []
youtube_video_url = <span class="hljs-string">"https://youtu.be/oJqc2tLMObg"</span>
wait = WebDriverWait(driver, <span class="hljs-number">30</span>) 

<span class="hljs-comment"># YouTube 비디오 URL 열기</span>
driver.get(youtube_video_url)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"YouTube URL을 열었습니다."</span>)

<span class="hljs-comment"># 댓글을 로드하기 위해 스크롤 다운</span>
<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">150</span>):  <span class="hljs-comment"># 여기에 스크롤 횟수 정의</span>
    <span class="hljs-keyword">try</span>:
        body = wait.until(EC.visibility_of_element_located((By.TAG_NAME, <span class="hljs-string">"body"</span>)))
        body.send_keys(Keys.END)
        sys.stdout.write(<span class="hljs-string">f"\r<span class="hljs-subst">{item + <span class="hljs-number">1</span>}</span>번 스크롤 중"</span>)
        sys.stdout.flush()
        time.sleep(<span class="hljs-number">1.5</span>)  <span class="hljs-comment"># 로딩을 위한 시간 증가</span>
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">f"스크롤 중 예외 발생: <span class="hljs-subst">{e}</span>"</span>)
        <span class="hljs-keyword">break</span>

<span class="hljs-comment"># 댓글 추출</span>
<span class="hljs-keyword">try</span>:
    wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, <span class="hljs-string">"#contents #contents"</span>)))
    comments = driver.find_elements(By.CSS_SELECTOR, <span class="hljs-string">"#content #content-text"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"\n<span class="hljs-subst">{<span class="hljs-built_in">len</span>(comments)}</span>개의 댓글 요소를 찾았습니다."</span>)

    user_id = <span class="hljs-number">1</span>  <span class="hljs-comment"># 고유한 사용자 ID 초기화</span>
    <span class="hljs-keyword">for</span> comment <span class="hljs-keyword">in</span> comments:
        timestamp = datetime.now().strftime(<span class="hljs-string">"%Y-%m-%d %H:%M:%S"</span>)
        data.append({<span class="hljs-string">"사용자 ID"</span>: user_id, <span class="hljs-string">"댓글"</span>: comment.text, <span class="hljs-string">"타임스탬프"</span>: timestamp})
        user_id += <span class="hljs-number">1</span>

    <span class="hljs-comment"># 중복 제거</span>
    data = [<span class="hljs-built_in">dict</span>(t) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> {<span class="hljs-built_in">tuple</span>(d.items()) <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> data}]
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"캡처된 댓글 수: <span class="hljs-subst">{<span class="hljs-built_in">len</span>(data)}</span>"</span>)
<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
    <span class="hljs-built_in">print</span>(<span class="hljs-string">f"댓글 추출 중 예외 발생: <span class="hljs-subst">{e}</span>"</span>)

driver.quit()

<span class="hljs-comment"># DataFrame 생성</span>
df = pd.DataFrame(data, columns=[<span class="hljs-string">"사용자 ID"</span>, <span class="hljs-string">"댓글"</span>, <span class="hljs-string">"타임스탬프"</span>])

<span class="hljs-comment"># DataFrame 표시</span>
<span class="hljs-built_in">print</span>(df)

<span class="hljs-comment"># DataFrame을 CSV 파일로 저장 (선택 사항)</span>
df.to_csv(<span class="hljs-string">"youtube_comments.csv"</span>, index=<span class="hljs-literal">False</span>)
</code></pre>
<p>여기서 댓글을 스크래핑하기 위해 스크롤 수를 사용했어요. 댓글 수의 최대값으로 변환할 수도 있지만, 현재 이 방법이 가장 잘 작동합니다.</p>
<p>그래서 이 몇 가지 가정과 제약들이 있어요.</p>
<p>가정과 제약사항: 각 댓글의 사용자 이름을 스크래핑하여 하나의 작성자가 여러 번 댓글을 작성했을 때 합칠 수 있도록 시도했지만 크롬 드라이버에서 많은 시간이 소요되고 있는 것을 고려하여 무모하게 반복된 댓글이 작성되지는 않았을 것이라고 가정하고, 추출된 날짜를 추가한 각 댓글을 고유한 것으로 간주했어요.</p>
<div class="content-ad"></div>
<p>크롬 드라이버를 헤드리스 모드로 실행하여 응답 속도를 높였어요. 코드에서 주석 처리하고 실행해보셔도 돼요. 만약 더 빠른 스크래핑 방법을 찾으시면 댓글로 알려주세요. François St-Amant의 코드를 참고했어요.</p>
<p>링크 — <a href="https://towardsdatascience.com/how-to-scrape-youtube-comments-with-python-61ff197115d" rel="nofollow" target="_blank">여기</a></p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
df = pd.DataFrame(data, columns=[<span class="hljs-string">'comment'</span>])
df.head()
</code></pre>
<p><img src="/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_1.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>지금은 Perplexity.ai와 함께 이 동영상에서 언급된 향수 목록을 두 번째 데이터프레임으로 가지고 있어요. 이 목록은 수동으로 가져왔지만 파이썬을 사용하여 동영상을 구문 분석하여 수행할 수도 있지만 그것은 다른 날을 위해 저장합시다. 또한 이에 대한 YouTube 동영상 요약기를 확인할 수도 있는데, 이것은 제 친구 Priyanshu Shukla가 만들었어요 – <a href="https://medium.com/@priyanshu-shkl7/implementing-generative-ai-into-your-apps-web-scraping-with-genai-f08711a404cb" rel="nofollow" target="_blank">https://medium.com/@priyanshu-shkl7/implementing-generative-ai-into-your-apps-web-scraping-with-genai-f08711a404cb</a></p>
<p><img src="/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_2.png" alt="이미지"></p>
<p>이제 NLP 부분으로 넘어가볼게요. 간단히 말씀드리면, 댓글 내에서 언급된 Tom Ford의 다양한 향수들을 얻으려고 노력 중이에요. 기본적으로 언급에 따라 각 향수를 지정하고 활동이 가장 많은 순서대로 정렬 중이에요.</p>
<p>이를 달성하기 위해 다양한 방법이 있지만, 저는 NLTK(Natural Language Toolkit)를 사용했어요. NLTK는 파이썬에서 인간의 언어 데이터를 처리하는 강력한 라이브러리예요. 이는 자연어 처리(NLP) 작업에 널리 사용되며, 의미론적 키워드 일치 및 감성 분석과 같은 작업에 적합해요.</p>
<div class="content-ad"></div>
<p>HuggingFace에서 제공하는 최고의 sentence transformers 중 하나를 사용하여 의미론적 문자열 매칭을 수행하거나 사용할 수 있습니다. 또한, 동일한 작업을 수행하기 위해 사용 가능한 LLM들을 사용할 수도 있지만 대규모 데이터셋에 대한 프로덕션 배포의 경우 sentence transformers가 가장 적합할 것입니다.</p>
<pre><code class="hljs language-python">!pip install nltk
<span class="hljs-keyword">import</span> nltk
nltk.download(<span class="hljs-string">'vader_lexicon'</span>)
</code></pre>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> nltk.sentiment <span class="hljs-keyword">import</span> SentimentIntensityAnalyzer

<span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_sentiment_scores</span>(<span class="hljs-params">comments, perfumes</span>):
    sentiment_scores = {<span class="hljs-built_in">str</span>(perfume): [] <span class="hljs-keyword">for</span> perfume <span class="hljs-keyword">in</span> perfumes}
    
    sid = SentimentIntensityAnalyzer()
    
    <span class="hljs-keyword">for</span> _, row <span class="hljs-keyword">in</span> comments.iterrows():
        comment = <span class="hljs-built_in">str</span>(row[<span class="hljs-string">'Comment'</span>])
        user_id = row[<span class="hljs-string">'User ID'</span>]
        sentiment_dict = sid.polarity_scores(comment)
        
        compound_score = sentiment_dict[<span class="hljs-string">'compound'</span>]
        
        <span class="hljs-keyword">for</span> perfume <span class="hljs-keyword">in</span> perfumes:
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>(perfume).lower() <span class="hljs-keyword">in</span> comment.lower():
                sentiment_scores[<span class="hljs-built_in">str</span>(perfume)].append((user_id, comment, compound_score))
    
    <span class="hljs-keyword">return</span> sentiment_scores

<span class="hljs-comment"># Load the comments DataFrame</span>
df_comments = df

<span class="hljs-comment"># Load the perfumes DataFrame</span>
df_perfumes = df2

<span class="hljs-comment"># Extract perfumes from df_perfumes</span>
perfumes = df2.iloc[:, <span class="hljs-number">0</span>].tolist()

<span class="hljs-comment"># Calculate sentiment scores for each perfume in the comments</span>
sentiment_scores = calculate_sentiment_scores(df_comments, perfumes)

<span class="hljs-comment"># Create a new DataFrame with 'user_id', 'comment', 'perfume', and 'sentiment_score' columns</span>
data = []
<span class="hljs-keyword">for</span> perfume, user_comment_list <span class="hljs-keyword">in</span> sentiment_scores.items():
    <span class="hljs-keyword">for</span> user_id, comment, sentiment_score <span class="hljs-keyword">in</span> user_comment_list:
        data.append([user_id, comment, perfume, sentiment_score])

df_result = pd.DataFrame(data, columns=[<span class="hljs-string">'user_id'</span>, <span class="hljs-string">'comment'</span>, <span class="hljs-string">'perfume'</span>, <span class="hljs-string">'sentiment_score'</span>])

<span class="hljs-comment"># Print the resulting DataFrame</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"User Comments with Sentiment Scores:"</span>)
df_result
</code></pre>
<p><img src="/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_3.png" alt="YouTube Comments"></p>
<div class="content-ad"></div>
<p>위에서 보듯이, 각 댓글에는 때때로 하나 이상의 향수가 언급되어서 각 향수에 대한 점수가 계산됩니다. 그래서 "나는 블랙 오키드를 소유하고 있다"는 댓글은 Beau de jour를 가지고 있습니다. 그래서 Beau de jour와 black orchid 각각 한 번씩 나타납니다.</p>
<p>하지만 이에 더해, 만일 우리가 이 감정 분석과 키워드 일치를 확인해야 한다면, 이를 위해 Tableau로 간단한 대시보드를 구축했습니다. Tableau 대시보드를 사용하면 빠르게 향수들과 그들의 감정 점수를 필터링할 수 있습니다.</p>
<p><a href="https://public.tableau.com/views/YoutubeSentimentAnalysis/YoutubeComments-NLPAnalysis?:language=en-GB&#x26;:sid=&#x26;:display_count=n&#x26;:origin=viz_share_link" rel="nofollow" target="_blank"><img src="/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_4.png" alt="테이블로 대시보드"></a></p>
<div class="content-ad"></div>
<p>어떤 생각이든 자유롭게 공유해 주시고, 댓글을 남기셔서 제 소식을 받아보세요! 읽어 주셔서 감사합니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"NLP 분석을 위한 Youtube 댓글 스크래핑 방법","description":"","date":"2024-06-22 16:44","slug":"2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis","content":"\n\n![image](/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_0.png)\n\n간단한 NLP 프로젝트를 시도해보고자 했는데, 유튜브 동영상에서 댓글을 가져와 분석해보려고 합니다.\n\n사실 향수에 대해 연구 중이었는데, 인스타그램을 무심코 스크롤하다가 향수 광고에 끌려들어가게 되었습니다. 그렇게해서 향수 리뷰 동영상들을 찾게 되었고, Demi Rawling의 향수 리뷰 동영상을 발견하게 되었습니다... (너무 핫하네요).\n\n유튜브 링크 - https://youtu.be/oJqc2tLMObg\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 동영상은 탑 10 톰 포드 향수에 관한 것입니다. 다소 오래된 동영상이긴 하지만(4년 전 영상입니다)\n\n먼저, 만약 설치되어 있지 않다면 이곳에서 ChromeDriver를 설치해주세요. 저는 VS Code에서 실행을 시도해봤어요. 필요한 라이브러리는 다음과 같아요...\n\n```js\nimport sys\nimport time\nimport pandas as pd\nfrom datetime import datetime\nfrom selenium import webdriver\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n```\n\n그런 다음 스크래핑 부분이 나옵니다...\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nimport pandas as pd\nfrom selenium import webdriver\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\nimport sys\nfrom datetime import datetime\n\n# WebDriver를 초기화하고 성능을 향상시키기 위한 옵션 설정\noptions = webdriver.ChromeOptions()\noptions.add_argument(\"--headless\")  # 헤드리스 모드로 실행\noptions.add_argument(\"--disable-gpu\")  # GPU 렌더링 비활성화\noptions.add_argument(\"--no-sandbox\")  # OS 보안 모델 우회\noptions.add_argument(\"--disable-dev-shm-usage\")  # 제한된 리소스 문제 극복\noptions.add_argument(\"--start-maximized\")  # 창 최대화\n\ndriver = webdriver.Chrome(options=options)\n\ndata = []\nyoutube_video_url = \"https://youtu.be/oJqc2tLMObg\"\nwait = WebDriverWait(driver, 30) \n\n# YouTube 비디오 URL 열기\ndriver.get(youtube_video_url)\nprint(\"YouTube URL을 열었습니다.\")\n\n# 댓글을 로드하기 위해 스크롤 다운\nfor item in range(150):  # 여기에 스크롤 횟수 정의\n    try:\n        body = wait.until(EC.visibility_of_element_located((By.TAG_NAME, \"body\")))\n        body.send_keys(Keys.END)\n        sys.stdout.write(f\"\\r{item + 1}번 스크롤 중\")\n        sys.stdout.flush()\n        time.sleep(1.5)  # 로딩을 위한 시간 증가\n    except Exception as e:\n        print(f\"스크롤 중 예외 발생: {e}\")\n        break\n\n# 댓글 추출\ntry:\n    wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, \"#contents #contents\")))\n    comments = driver.find_elements(By.CSS_SELECTOR, \"#content #content-text\")\n    print(f\"\\n{len(comments)}개의 댓글 요소를 찾았습니다.\")\n\n    user_id = 1  # 고유한 사용자 ID 초기화\n    for comment in comments:\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        data.append({\"사용자 ID\": user_id, \"댓글\": comment.text, \"타임스탬프\": timestamp})\n        user_id += 1\n\n    # 중복 제거\n    data = [dict(t) for t in {tuple(d.items()) for d in data}]\n    print(f\"캡처된 댓글 수: {len(data)}\")\nexcept Exception as e:\n    print(f\"댓글 추출 중 예외 발생: {e}\")\n\ndriver.quit()\n\n# DataFrame 생성\ndf = pd.DataFrame(data, columns=[\"사용자 ID\", \"댓글\", \"타임스탬프\"])\n\n# DataFrame 표시\nprint(df)\n\n# DataFrame을 CSV 파일로 저장 (선택 사항)\ndf.to_csv(\"youtube_comments.csv\", index=False)\n``` \n\n여기서 댓글을 스크래핑하기 위해 스크롤 수를 사용했어요. 댓글 수의 최대값으로 변환할 수도 있지만, 현재 이 방법이 가장 잘 작동합니다.\n\n그래서 이 몇 가지 가정과 제약들이 있어요.\n\n가정과 제약사항: 각 댓글의 사용자 이름을 스크래핑하여 하나의 작성자가 여러 번 댓글을 작성했을 때 합칠 수 있도록 시도했지만 크롬 드라이버에서 많은 시간이 소요되고 있는 것을 고려하여 무모하게 반복된 댓글이 작성되지는 않았을 것이라고 가정하고, 추출된 날짜를 추가한 각 댓글을 고유한 것으로 간주했어요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n크롬 드라이버를 헤드리스 모드로 실행하여 응답 속도를 높였어요. 코드에서 주석 처리하고 실행해보셔도 돼요. 만약 더 빠른 스크래핑 방법을 찾으시면 댓글로 알려주세요. François St-Amant의 코드를 참고했어요.\n\n링크 — [여기](https://towardsdatascience.com/how-to-scrape-youtube-comments-with-python-61ff197115d)\n\n```python\nimport pandas as pd\ndf = pd.DataFrame(data, columns=['comment'])\ndf.head()\n```\n\n![이미지](/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 Perplexity.ai와 함께 이 동영상에서 언급된 향수 목록을 두 번째 데이터프레임으로 가지고 있어요. 이 목록은 수동으로 가져왔지만 파이썬을 사용하여 동영상을 구문 분석하여 수행할 수도 있지만 그것은 다른 날을 위해 저장합시다. 또한 이에 대한 YouTube 동영상 요약기를 확인할 수도 있는데, 이것은 제 친구 Priyanshu Shukla가 만들었어요 – https://medium.com/@priyanshu-shkl7/implementing-generative-ai-into-your-apps-web-scraping-with-genai-f08711a404cb\n\n![이미지](/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_2.png)\n\n이제 NLP 부분으로 넘어가볼게요. 간단히 말씀드리면, 댓글 내에서 언급된 Tom Ford의 다양한 향수들을 얻으려고 노력 중이에요. 기본적으로 언급에 따라 각 향수를 지정하고 활동이 가장 많은 순서대로 정렬 중이에요.\n\n이를 달성하기 위해 다양한 방법이 있지만, 저는 NLTK(Natural Language Toolkit)를 사용했어요. NLTK는 파이썬에서 인간의 언어 데이터를 처리하는 강력한 라이브러리예요. 이는 자연어 처리(NLP) 작업에 널리 사용되며, 의미론적 키워드 일치 및 감성 분석과 같은 작업에 적합해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHuggingFace에서 제공하는 최고의 sentence transformers 중 하나를 사용하여 의미론적 문자열 매칭을 수행하거나 사용할 수 있습니다. 또한, 동일한 작업을 수행하기 위해 사용 가능한 LLM들을 사용할 수도 있지만 대규모 데이터셋에 대한 프로덕션 배포의 경우 sentence transformers가 가장 적합할 것입니다.\n\n```python\n!pip install nltk\nimport nltk\nnltk.download('vader_lexicon')\n```\n\n```python\nimport pandas as pd\nfrom nltk.sentiment import SentimentIntensityAnalyzer\n\ndef calculate_sentiment_scores(comments, perfumes):\n    sentiment_scores = {str(perfume): [] for perfume in perfumes}\n    \n    sid = SentimentIntensityAnalyzer()\n    \n    for _, row in comments.iterrows():\n        comment = str(row['Comment'])\n        user_id = row['User ID']\n        sentiment_dict = sid.polarity_scores(comment)\n        \n        compound_score = sentiment_dict['compound']\n        \n        for perfume in perfumes:\n            if str(perfume).lower() in comment.lower():\n                sentiment_scores[str(perfume)].append((user_id, comment, compound_score))\n    \n    return sentiment_scores\n\n# Load the comments DataFrame\ndf_comments = df\n\n# Load the perfumes DataFrame\ndf_perfumes = df2\n\n# Extract perfumes from df_perfumes\nperfumes = df2.iloc[:, 0].tolist()\n\n# Calculate sentiment scores for each perfume in the comments\nsentiment_scores = calculate_sentiment_scores(df_comments, perfumes)\n\n# Create a new DataFrame with 'user_id', 'comment', 'perfume', and 'sentiment_score' columns\ndata = []\nfor perfume, user_comment_list in sentiment_scores.items():\n    for user_id, comment, sentiment_score in user_comment_list:\n        data.append([user_id, comment, perfume, sentiment_score])\n\ndf_result = pd.DataFrame(data, columns=['user_id', 'comment', 'perfume', 'sentiment_score'])\n\n# Print the resulting DataFrame\nprint(\"User Comments with Sentiment Scores:\")\ndf_result\n```\n\n![YouTube Comments](/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_3.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 보듯이, 각 댓글에는 때때로 하나 이상의 향수가 언급되어서 각 향수에 대한 점수가 계산됩니다. 그래서 \"나는 블랙 오키드를 소유하고 있다\"는 댓글은 Beau de jour를 가지고 있습니다. 그래서 Beau de jour와 black orchid 각각 한 번씩 나타납니다.\n\n하지만 이에 더해, 만일 우리가 이 감정 분석과 키워드 일치를 확인해야 한다면, 이를 위해 Tableau로 간단한 대시보드를 구축했습니다. Tableau 대시보드를 사용하면 빠르게 향수들과 그들의 감정 점수를 필터링할 수 있습니다.\n\n[![테이블로 대시보드](/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_4.png)](https://public.tableau.com/views/YoutubeSentimentAnalysis/YoutubeComments-NLPAnalysis?:language=en-GB\u0026:sid=\u0026:display_count=n\u0026:origin=viz_share_link)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 생각이든 자유롭게 공유해 주시고, 댓글을 남기셔서 제 소식을 받아보세요! 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_0.png"},"coverImage":"/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e간단한 NLP 프로젝트를 시도해보고자 했는데, 유튜브 동영상에서 댓글을 가져와 분석해보려고 합니다.\u003c/p\u003e\n\u003cp\u003e사실 향수에 대해 연구 중이었는데, 인스타그램을 무심코 스크롤하다가 향수 광고에 끌려들어가게 되었습니다. 그렇게해서 향수 리뷰 동영상들을 찾게 되었고, Demi Rawling의 향수 리뷰 동영상을 발견하게 되었습니다... (너무 핫하네요).\u003c/p\u003e\n\u003cp\u003e유튜브 링크 - \u003ca href=\"https://youtu.be/oJqc2tLMObg\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://youtu.be/oJqc2tLMObg\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 동영상은 탑 10 톰 포드 향수에 관한 것입니다. 다소 오래된 동영상이긴 하지만(4년 전 영상입니다)\u003c/p\u003e\n\u003cp\u003e먼저, 만약 설치되어 있지 않다면 이곳에서 ChromeDriver를 설치해주세요. 저는 VS Code에서 실행을 시도해봤어요. 필요한 라이브러리는 다음과 같아요...\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e sys\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e time\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e datetime \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e datetime\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e selenium \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e webdriver\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e selenium.\u003cspan class=\"hljs-property\"\u003ewebdriver\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecommon\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ekeys\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eKeys\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e selenium.\u003cspan class=\"hljs-property\"\u003ewebdriver\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecommon\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eby\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBy\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e selenium.\u003cspan class=\"hljs-property\"\u003ewebdriver\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esupport\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eui\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWebDriverWait\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e selenium.\u003cspan class=\"hljs-property\"\u003ewebdriver\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esupport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e expected_conditions \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eEC\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 스크래핑 부분이 나옵니다...\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e selenium \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e webdriver\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e selenium.webdriver.common.keys \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Keys\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e selenium.webdriver.common.by \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e By\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e selenium.webdriver.support.ui \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e WebDriverWait\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e selenium.webdriver.support \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e expected_conditions \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e EC\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e time\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e sys\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e datetime \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e datetime\n\n\u003cspan class=\"hljs-comment\"\u003e# WebDriver를 초기화하고 성능을 향상시키기 위한 옵션 설정\u003c/span\u003e\noptions = webdriver.ChromeOptions()\noptions.add_argument(\u003cspan class=\"hljs-string\"\u003e\"--headless\"\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# 헤드리스 모드로 실행\u003c/span\u003e\noptions.add_argument(\u003cspan class=\"hljs-string\"\u003e\"--disable-gpu\"\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# GPU 렌더링 비활성화\u003c/span\u003e\noptions.add_argument(\u003cspan class=\"hljs-string\"\u003e\"--no-sandbox\"\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# OS 보안 모델 우회\u003c/span\u003e\noptions.add_argument(\u003cspan class=\"hljs-string\"\u003e\"--disable-dev-shm-usage\"\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# 제한된 리소스 문제 극복\u003c/span\u003e\noptions.add_argument(\u003cspan class=\"hljs-string\"\u003e\"--start-maximized\"\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# 창 최대화\u003c/span\u003e\n\ndriver = webdriver.Chrome(options=options)\n\ndata = []\nyoutube_video_url = \u003cspan class=\"hljs-string\"\u003e\"https://youtu.be/oJqc2tLMObg\"\u003c/span\u003e\nwait = WebDriverWait(driver, \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e) \n\n\u003cspan class=\"hljs-comment\"\u003e# YouTube 비디오 URL 열기\u003c/span\u003e\ndriver.get(youtube_video_url)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"YouTube URL을 열었습니다.\"\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e# 댓글을 로드하기 위해 스크롤 다운\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e item \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e150\u003c/span\u003e):  \u003cspan class=\"hljs-comment\"\u003e# 여기에 스크롤 횟수 정의\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e:\n        body = wait.until(EC.visibility_of_element_located((By.TAG_NAME, \u003cspan class=\"hljs-string\"\u003e\"body\"\u003c/span\u003e)))\n        body.send_keys(Keys.END)\n        sys.stdout.write(\u003cspan class=\"hljs-string\"\u003ef\"\\r\u003cspan class=\"hljs-subst\"\u003e{item + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e}\u003c/span\u003e번 스크롤 중\"\u003c/span\u003e)\n        sys.stdout.flush()\n        time.sleep(\u003cspan class=\"hljs-number\"\u003e1.5\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# 로딩을 위한 시간 증가\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eexcept\u003c/span\u003e Exception \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e e:\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"스크롤 중 예외 발생: \u003cspan class=\"hljs-subst\"\u003e{e}\u003c/span\u003e\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 댓글 추출\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e:\n    wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, \u003cspan class=\"hljs-string\"\u003e\"#contents #contents\"\u003c/span\u003e)))\n    comments = driver.find_elements(By.CSS_SELECTOR, \u003cspan class=\"hljs-string\"\u003e\"#content #content-text\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"\\n\u003cspan class=\"hljs-subst\"\u003e{\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(comments)}\u003c/span\u003e개의 댓글 요소를 찾았습니다.\"\u003c/span\u003e)\n\n    user_id = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e  \u003cspan class=\"hljs-comment\"\u003e# 고유한 사용자 ID 초기화\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e comment \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e comments:\n        timestamp = datetime.now().strftime(\u003cspan class=\"hljs-string\"\u003e\"%Y-%m-%d %H:%M:%S\"\u003c/span\u003e)\n        data.append({\u003cspan class=\"hljs-string\"\u003e\"사용자 ID\"\u003c/span\u003e: user_id, \u003cspan class=\"hljs-string\"\u003e\"댓글\"\u003c/span\u003e: comment.text, \u003cspan class=\"hljs-string\"\u003e\"타임스탬프\"\u003c/span\u003e: timestamp})\n        user_id += \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e# 중복 제거\u003c/span\u003e\n    data = [\u003cspan class=\"hljs-built_in\"\u003edict\u003c/span\u003e(t) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e t \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e {\u003cspan class=\"hljs-built_in\"\u003etuple\u003c/span\u003e(d.items()) \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e d \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e data}]\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"캡처된 댓글 수: \u003cspan class=\"hljs-subst\"\u003e{\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(data)}\u003c/span\u003e\"\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003eexcept\u003c/span\u003e Exception \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e e:\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003ef\"댓글 추출 중 예외 발생: \u003cspan class=\"hljs-subst\"\u003e{e}\u003c/span\u003e\"\u003c/span\u003e)\n\ndriver.quit()\n\n\u003cspan class=\"hljs-comment\"\u003e# DataFrame 생성\u003c/span\u003e\ndf = pd.DataFrame(data, columns=[\u003cspan class=\"hljs-string\"\u003e\"사용자 ID\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"댓글\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"타임스탬프\"\u003c/span\u003e])\n\n\u003cspan class=\"hljs-comment\"\u003e# DataFrame 표시\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(df)\n\n\u003cspan class=\"hljs-comment\"\u003e# DataFrame을 CSV 파일로 저장 (선택 사항)\u003c/span\u003e\ndf.to_csv(\u003cspan class=\"hljs-string\"\u003e\"youtube_comments.csv\"\u003c/span\u003e, index=\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 댓글을 스크래핑하기 위해 스크롤 수를 사용했어요. 댓글 수의 최대값으로 변환할 수도 있지만, 현재 이 방법이 가장 잘 작동합니다.\u003c/p\u003e\n\u003cp\u003e그래서 이 몇 가지 가정과 제약들이 있어요.\u003c/p\u003e\n\u003cp\u003e가정과 제약사항: 각 댓글의 사용자 이름을 스크래핑하여 하나의 작성자가 여러 번 댓글을 작성했을 때 합칠 수 있도록 시도했지만 크롬 드라이버에서 많은 시간이 소요되고 있는 것을 고려하여 무모하게 반복된 댓글이 작성되지는 않았을 것이라고 가정하고, 추출된 날짜를 추가한 각 댓글을 고유한 것으로 간주했어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e크롬 드라이버를 헤드리스 모드로 실행하여 응답 속도를 높였어요. 코드에서 주석 처리하고 실행해보셔도 돼요. 만약 더 빠른 스크래핑 방법을 찾으시면 댓글로 알려주세요. François St-Amant의 코드를 참고했어요.\u003c/p\u003e\n\u003cp\u003e링크 — \u003ca href=\"https://towardsdatascience.com/how-to-scrape-youtube-comments-with-python-61ff197115d\" rel=\"nofollow\" target=\"_blank\"\u003e여기\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\ndf = pd.DataFrame(data, columns=[\u003cspan class=\"hljs-string\"\u003e'comment'\u003c/span\u003e])\ndf.head()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e지금은 Perplexity.ai와 함께 이 동영상에서 언급된 향수 목록을 두 번째 데이터프레임으로 가지고 있어요. 이 목록은 수동으로 가져왔지만 파이썬을 사용하여 동영상을 구문 분석하여 수행할 수도 있지만 그것은 다른 날을 위해 저장합시다. 또한 이에 대한 YouTube 동영상 요약기를 확인할 수도 있는데, 이것은 제 친구 Priyanshu Shukla가 만들었어요 – \u003ca href=\"https://medium.com/@priyanshu-shkl7/implementing-generative-ai-into-your-apps-web-scraping-with-genai-f08711a404cb\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://medium.com/@priyanshu-shkl7/implementing-generative-ai-into-your-apps-web-scraping-with-genai-f08711a404cb\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 NLP 부분으로 넘어가볼게요. 간단히 말씀드리면, 댓글 내에서 언급된 Tom Ford의 다양한 향수들을 얻으려고 노력 중이에요. 기본적으로 언급에 따라 각 향수를 지정하고 활동이 가장 많은 순서대로 정렬 중이에요.\u003c/p\u003e\n\u003cp\u003e이를 달성하기 위해 다양한 방법이 있지만, 저는 NLTK(Natural Language Toolkit)를 사용했어요. NLTK는 파이썬에서 인간의 언어 데이터를 처리하는 강력한 라이브러리예요. 이는 자연어 처리(NLP) 작업에 널리 사용되며, 의미론적 키워드 일치 및 감성 분석과 같은 작업에 적합해요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eHuggingFace에서 제공하는 최고의 sentence transformers 중 하나를 사용하여 의미론적 문자열 매칭을 수행하거나 사용할 수 있습니다. 또한, 동일한 작업을 수행하기 위해 사용 가능한 LLM들을 사용할 수도 있지만 대규모 데이터셋에 대한 프로덕션 배포의 경우 sentence transformers가 가장 적합할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e!pip install nltk\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e nltk\nnltk.download(\u003cspan class=\"hljs-string\"\u003e'vader_lexicon'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e nltk.sentiment \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e SentimentIntensityAnalyzer\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculate_sentiment_scores\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecomments, perfumes\u003c/span\u003e):\n    sentiment_scores = {\u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e(perfume): [] \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e perfume \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e perfumes}\n    \n    sid = SentimentIntensityAnalyzer()\n    \n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e _, row \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e comments.iterrows():\n        comment = \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e(row[\u003cspan class=\"hljs-string\"\u003e'Comment'\u003c/span\u003e])\n        user_id = row[\u003cspan class=\"hljs-string\"\u003e'User ID'\u003c/span\u003e]\n        sentiment_dict = sid.polarity_scores(comment)\n        \n        compound_score = sentiment_dict[\u003cspan class=\"hljs-string\"\u003e'compound'\u003c/span\u003e]\n        \n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e perfume \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e perfumes:\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e(perfume).lower() \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e comment.lower():\n                sentiment_scores[\u003cspan class=\"hljs-built_in\"\u003estr\u003c/span\u003e(perfume)].append((user_id, comment, compound_score))\n    \n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e sentiment_scores\n\n\u003cspan class=\"hljs-comment\"\u003e# Load the comments DataFrame\u003c/span\u003e\ndf_comments = df\n\n\u003cspan class=\"hljs-comment\"\u003e# Load the perfumes DataFrame\u003c/span\u003e\ndf_perfumes = df2\n\n\u003cspan class=\"hljs-comment\"\u003e# Extract perfumes from df_perfumes\u003c/span\u003e\nperfumes = df2.iloc[:, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].tolist()\n\n\u003cspan class=\"hljs-comment\"\u003e# Calculate sentiment scores for each perfume in the comments\u003c/span\u003e\nsentiment_scores = calculate_sentiment_scores(df_comments, perfumes)\n\n\u003cspan class=\"hljs-comment\"\u003e# Create a new DataFrame with 'user_id', 'comment', 'perfume', and 'sentiment_score' columns\u003c/span\u003e\ndata = []\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e perfume, user_comment_list \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e sentiment_scores.items():\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e user_id, comment, sentiment_score \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e user_comment_list:\n        data.append([user_id, comment, perfume, sentiment_score])\n\ndf_result = pd.DataFrame(data, columns=[\u003cspan class=\"hljs-string\"\u003e'user_id'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'comment'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'perfume'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'sentiment_score'\u003c/span\u003e])\n\n\u003cspan class=\"hljs-comment\"\u003e# Print the resulting DataFrame\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"User Comments with Sentiment Scores:\"\u003c/span\u003e)\ndf_result\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_3.png\" alt=\"YouTube Comments\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위에서 보듯이, 각 댓글에는 때때로 하나 이상의 향수가 언급되어서 각 향수에 대한 점수가 계산됩니다. 그래서 \"나는 블랙 오키드를 소유하고 있다\"는 댓글은 Beau de jour를 가지고 있습니다. 그래서 Beau de jour와 black orchid 각각 한 번씩 나타납니다.\u003c/p\u003e\n\u003cp\u003e하지만 이에 더해, 만일 우리가 이 감정 분석과 키워드 일치를 확인해야 한다면, 이를 위해 Tableau로 간단한 대시보드를 구축했습니다. Tableau 대시보드를 사용하면 빠르게 향수들과 그들의 감정 점수를 필터링할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://public.tableau.com/views/YoutubeSentimentAnalysis/YoutubeComments-NLPAnalysis?:language=en-GB\u0026#x26;:sid=\u0026#x26;:display_count=n\u0026#x26;:origin=viz_share_link\" rel=\"nofollow\" target=\"_blank\"\u003e\u003cimg src=\"/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_4.png\" alt=\"테이블로 대시보드\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e어떤 생각이든 자유롭게 공유해 주시고, 댓글을 남기셔서 제 소식을 받아보세요! 읽어 주셔서 감사합니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis"},"buildId":"kkckKPyxcjJp_o8wb2unW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>