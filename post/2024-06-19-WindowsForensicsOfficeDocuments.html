<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>윈도우 포렌식 오피스 문서 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-WindowsForensicsOfficeDocuments" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="윈도우 포렌식 오피스 문서 | itposting" data-gatsby-head="true"/><meta property="og:title" content="윈도우 포렌식 오피스 문서 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-WindowsForensicsOfficeDocuments" data-gatsby-head="true"/><meta name="twitter:title" content="윈도우 포렌식 오피스 문서 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 09:02" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-0fd008072af5a644.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_buildManifest.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">윈도우 포렌식 오피스 문서</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="윈도우 포렌식 오피스 문서" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-WindowsForensicsOfficeDocuments&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>Windows 포렌식 - 파일/폴더 오픈, 응용프로그램 실행과 관련된 증거</h1>
<h2>개요</h2>
<p>이 글은 프리패치 파일부터 셸 항목 및 레지스트리 분석까지 여러 가지를 다룰 것입니다. 우리는 대상 사용자가 Microsoft Office 제품을 실행하고 Word 문서와 활발히 작업한 사실을 보여줄 것입니다. 마지막으로 우리는 Word에서 사용자가 본 정확한 페이지를 확인하고 해당 페이지를 우리 자신의 기계에서 재작성하여 용의자 사용자가 마지막으로 본 것을 확인할 수 있게 될 것입니다.</p>
<h2>시스템에서 Microsoft Office 제품이 실행되었는지 확인하는 방법</h2>
<h2>사전 로드 파일</h2>
<p>사전 로드 파일은 응용 프로그램 실행에 대한 자세한 정보를 제공합니다. 그들의 주요 기능은 응용 프로그램의 일부 메모리를 디스크에 기록하여 사용자가 특정 응용 프로그램을 두 번째로 실행할 때 일부 데이터가 이미 캐싱되어 있어 더 빨리 시작되도록 하는 것입니다. 사전 로드가 캐시하는 정보는 다음과 같습니다:</p>
<ul>
<li>로드된 DLL</li>
<li>응용 프로그램이 상호 작용한 다른 파일(다른 PE 파일 포함)</li>
<li>응용 프로그램이 상호 작용한 디렉터리의 상대 경로</li>
<li>응용 프로그램을 실행한 횟수</li>
<li>응용 프로그램을 실행한 마지막 8개의 타임스탬프</li>
<li>파일 시스템 타임스탬프(생성, 수정, 액세스)</li>
<li>파일 크기</li>
<li>응용 프로그램 해시</li>
<li>볼륨 정보</li>
</ul>
<p>사전 로드 파일은 C:\Windows\Prefetch에 저장되며 파일 확장자는 .pf입니다. 이것이 우리가 시작할 지점이 될 것이며, 대상 시스템에서 Office 제품이 실행되었는지 확인할 수 있습니다.</p>
<p>에릭 짐머만의 PECmd 도구를 사용하면 전체 디렉토리를 구문 분석하여 CSV 파일로 출력하거나 한 번에 하나의 .pf 파일을 구문 분석할 수 있습니다. 우리는 사무 문서에만 관심이 있기 때문에 Microsoft Word용 prefetch 파일 하나를 구문 분석할 것입니다.</p>
<h2>Word Prefetch (Application Execution)</h2>
<pre><code class="hljs language-js"># 하나의 prefetch 파일을 구문 분석하는 구문
pecmd -f $파일
</code></pre>
<p><img src="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_0.png" alt="이미지"></p>
<p>가장 먼저 지적하고 싶은 것은 최근 실행된 타임스탬프와 파일 시스템 수정된 타임스탬프 간의 불일치입니다. 이론적으로는 응용 프로그램이 실행될 때 NTFS 파일 시스템에서 수정된 타임스탬프가 업데이트되므로 이러한 타임스탬프는 일치해야 합니다. 그러나 최근 실행 시간이 파일 시스템보다 2초 빠르게 기록되었습니다. 이것은 중요한 고려 사항이며 파일 시스템 타임스탬프만 놓고 보면 고려해야 할 사항입니다. 실행 후 파일 시스템이 수정된 시간을 업데이트하기까지 최대 10초가 소요될 수 있습니다.</p>
<p>이제 우리는 컴퓨터에서 Word가 실행되었음을 알고 있으며 다음과 같은 세부 사항이 있습니다:</p>
<ul>
<li>Word가 23번 실행되었습니다</li>
<li>최근 실행 시간은 2024년 5월 30일 12:50:01에 있었습니다 (모든 타임스탬프는 UTC, 24시간 형식입니다)</li>
<li>볼륨 GUID</li>
<li>그리고 응용 프로그램이 상호 작용한 디렉토리 및 파일 목록 (스크린샷에 포함되지 않음)</li>
</ul>
<h1>문서가 열렸는지 확인하기</h1>
<h2>바로 가기 파일 (LNK)</h2>
<p>Word가 열려 있다고 해서 그와 함께 문서가 열리는 것은 아닙니다. LNK 파일을 활용하여 어떤 문서가 열렸는지 추측하는 데 도움을 받을 수 있습니다. 이러한 증거들은 사용자의 프로필에 저장됩니다: C:\Users$user\AppData\Roaming\Microsoft\Windows\Recent.</p>
<p>LNK 파일은 파일이나 폴더가 열릴 때 기록이 되며, 제어판 앱도 포함됩니다. 이러한 쉘 항목들은 다음을 기록합니다:</p>
<ul>
<li>파일 시스템 타임스탬프</li>
<li>대상 타임스탬프 (쉘 항목은 대상 파일을 가리키며, LNK 파일은 실제로 다른 개체에 액세스하는 방법에 대한 메타데이터를 저장)</li>
<li>파일 크기, 속성 및 플래그</li>
<li>대상 파일의 상대 경로</li>
<li>대상 파일의 작업 디렉토리</li>
<li>볼륨 정보</li>
<li>그리고 $MFT 레코드 정보</li>
</ul>
<p>에릭 짐머만의 도구 중 하나인 LECmd를 사용하여 이 파일들을 구문 분석할 수 있습니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">LECmd</span> 사용법
lecmd -f $file
</code></pre>
<p><img src="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_1.png" alt="이미지"></p>
<p>위 스크린샷에서 우리는 CIRT_SOP.docx라는 문서를 위한 LNK 파일을 볼 수 있습니다. 이 파일이 마지막으로 수정된 날짜는 Word가 마지막으로 실행된 날짜와 같음을 알 수 있습니다. 하나 이상의 문서가 열렸다는 것을 알기 때문에 사용자 레지스트리를 확인하여 파일이 마지막으로 열리고 닫힌 시간을 결정할 수 있습니다.</p>
<h1>파일 활동 기간 결정하기</h1>
<p>사용자의 NTUSER.dat 파일에서 Microsoft Office 문서와 관련된 레지스트리 키를 찾을 수 있습니다. 주로 이러한 키들은 NTUSER\Software\Microsoft\Office\16.0\Word 경로에 있습니다.</p>
<h2>파일이 마지막으로 열린 날짜</h2>
<p>저는 Microsoft 365 계정을 사용하고 있기 때문에 NTUSER\Software\Microsoft\Office\16.0\Word\File MRU에는 문서가 나열되지 않습니다. 대신 개인 Office 365 라이선스와 관련된 키를 참조해야 합니다: NTUSER\Software\Microsoft\Office\16.0\Word\User MRU\LiveId_$hash\File MRU. 이 항목들은 가장 최근에 사용된 순서대로 나열됩니다.</p>
<p><img src="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_2.png" alt="이미지 1"></p>
<p>파일이 처음 열린 시간을 나타내는 타임스탬프는 64비트 FILETIME에서, big endian 형식으로 “T” 뒤에 나오는 바이트 입니다. 아래 화면은 아이템 1에 대한 디코딩된 시간을 보여줍니다.</p>
<p><img src="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_3.png" alt="이미지 2"></p>
<p><img src="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_4.png" alt="이미지 3"></p>
<h2>파일 종료 날짜</h2>
<p>파일이 마지막으로 닫힌 날짜를 확인하려면 다른 레지스트리 키인 NTUSER\Software\Microsoft\Office\16.0\Word\Reading Locations로 전환해야 합니다. 각 문서에는 중요한 하위 키/값 쌍을 포함하는 자체 하위 키가 생성됩니다.</p>
<p><img src="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_5.png" alt="image"></p>
<p><img src="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_6.png" alt="image"></p>
<p>Datetime에 나열된 값에 유의하세요. 이 값은 시스템의 로컬 시간입니다 (정확한 시스템 프로필링이 반드시 필요함을 증명합니다). Datetime에 나열된 시간을 UTC로 변환하면 레지스트리의 마지막 쓰기 시간 (2024–05–30 20:45:56)과 일치하는 것을 볼 수 있습니다. 이것은 파일이 마지막으로 닫힌 시간입니다.</p>
<p>Position 값은 사용자가 마지막으로 보고 있던 문서의 위치를 기록합니다. 이것은 Word가 시행하는 "이전에 멈췄던 곳부터 다시 시작" 기능입니다. 이론적으로, 사용자가 마지막으로 머물렀던 정확한 페이지를 결정할 수 있습니다:</p>
<ul>
<li>해당 대상 파일을 우리 시스템으로 복사</li>
<li>문서를 열기</li>
<li>문서를 닫아 우리의 NTUSER 하이브에 기록되도록 함</li>
<li>용의자의 NTUSER 하이브에서 Position 값 복사하여 우리 NTUSER 하이브로 이동.</li>
</ul>
<h1>문서의 마지막 위치 결정</h1>
<p>일하고 있는 문서를 추적 중이었던 것이 회사 작업을 위해 작업 중이던 것이기 때문에 사용자가 마지막으로 중지한 위치를 확인할 때 concept 확인을 위해 다른 문서로 전환할 것입니다. Reading Locations에 나열된 Document 1이라는 파일을 사용할 것입니다.</p>
<p><img src="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_7.png" alt="이미지"></p>
<p><img src="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_8.png" alt="이미지"></p>
<p><img src="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_9.png" alt="이미지"></p>
<p>이론적으로는 Position에 나열된 값과 일치하도록 변경하여 사용자가 마지막으로 보고 있던 내용을 복원할 수 있어야 합니다.</p>
<p><img src="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_10.png" alt="image1"></p>
<p>이제 파일을 다시 열 때, 우리는 중단했던 곳부터 이어서 작업할 것을 요청받아야 합니다.</p>
<p><img src="/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_11.png" alt="image2"></p>
<h1>이 기사의 목적</h1>
<p>저는 이 기사를 쓴 이유는 학습하고 있는 개념을 강화하고 있는 것인데, 메모에 너무 의존하는 것을 줄이고 지식을 내재화하는 노력에 있습니다. 사용자가 마지막으로 머물렀던 정확한 페이지를 확인할 수 있는 것이 가능하다는 것을 알게 되었을 때 정말 멋있었고, HackTheBox 머신에서 사용자/루트 쉘을 얻는 것보다 더 흥미로웠습니다. 이 글을 통해 새로운 지식을 얻거나 흥미를 느낀 사람이 있다면 좋겠습니다. 배운 것들을 다른 사람들과 공유해주세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"윈도우 포렌식 오피스 문서","description":"","date":"2024-06-19 09:02","slug":"2024-06-19-WindowsForensicsOfficeDocuments","content":"\n\n# Windows 포렌식 - 파일/폴더 오픈, 응용프로그램 실행과 관련된 증거\n\n## 개요\n\n이 글은 프리패치 파일부터 셸 항목 및 레지스트리 분석까지 여러 가지를 다룰 것입니다. 우리는 대상 사용자가 Microsoft Office 제품을 실행하고 Word 문서와 활발히 작업한 사실을 보여줄 것입니다. 마지막으로 우리는 Word에서 사용자가 본 정확한 페이지를 확인하고 해당 페이지를 우리 자신의 기계에서 재작성하여 용의자 사용자가 마지막으로 본 것을 확인할 수 있게 될 것입니다.\n\n## 시스템에서 Microsoft Office 제품이 실행되었는지 확인하는 방법\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 사전 로드 파일\n\n사전 로드 파일은 응용 프로그램 실행에 대한 자세한 정보를 제공합니다. 그들의 주요 기능은 응용 프로그램의 일부 메모리를 디스크에 기록하여 사용자가 특정 응용 프로그램을 두 번째로 실행할 때 일부 데이터가 이미 캐싱되어 있어 더 빨리 시작되도록 하는 것입니다. 사전 로드가 캐시하는 정보는 다음과 같습니다:\n\n- 로드된 DLL\n- 응용 프로그램이 상호 작용한 다른 파일(다른 PE 파일 포함)\n- 응용 프로그램이 상호 작용한 디렉터리의 상대 경로\n- 응용 프로그램을 실행한 횟수\n- 응용 프로그램을 실행한 마지막 8개의 타임스탬프\n- 파일 시스템 타임스탬프(생성, 수정, 액세스)\n- 파일 크기\n- 응용 프로그램 해시\n- 볼륨 정보\n\n사전 로드 파일은 C:\\Windows\\Prefetch에 저장되며 파일 확장자는 .pf입니다. 이것이 우리가 시작할 지점이 될 것이며, 대상 시스템에서 Office 제품이 실행되었는지 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에릭 짐머만의 PECmd 도구를 사용하면 전체 디렉토리를 구문 분석하여 CSV 파일로 출력하거나 한 번에 하나의 .pf 파일을 구문 분석할 수 있습니다. 우리는 사무 문서에만 관심이 있기 때문에 Microsoft Word용 prefetch 파일 하나를 구문 분석할 것입니다.\n\n## Word Prefetch (Application Execution)\n\n```js\n# 하나의 prefetch 파일을 구문 분석하는 구문\npecmd -f $파일\n```\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 먼저 지적하고 싶은 것은 최근 실행된 타임스탬프와 파일 시스템 수정된 타임스탬프 간의 불일치입니다. 이론적으로는 응용 프로그램이 실행될 때 NTFS 파일 시스템에서 수정된 타임스탬프가 업데이트되므로 이러한 타임스탬프는 일치해야 합니다. 그러나 최근 실행 시간이 파일 시스템보다 2초 빠르게 기록되었습니다. 이것은 중요한 고려 사항이며 파일 시스템 타임스탬프만 놓고 보면 고려해야 할 사항입니다. 실행 후 파일 시스템이 수정된 시간을 업데이트하기까지 최대 10초가 소요될 수 있습니다.\n\n이제 우리는 컴퓨터에서 Word가 실행되었음을 알고 있으며 다음과 같은 세부 사항이 있습니다:\n\n- Word가 23번 실행되었습니다\n- 최근 실행 시간은 2024년 5월 30일 12:50:01에 있었습니다 (모든 타임스탬프는 UTC, 24시간 형식입니다)\n- 볼륨 GUID\n- 그리고 응용 프로그램이 상호 작용한 디렉토리 및 파일 목록 (스크린샷에 포함되지 않음)\n\n# 문서가 열렸는지 확인하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 바로 가기 파일 (LNK)\n\nWord가 열려 있다고 해서 그와 함께 문서가 열리는 것은 아닙니다. LNK 파일을 활용하여 어떤 문서가 열렸는지 추측하는 데 도움을 받을 수 있습니다. 이러한 증거들은 사용자의 프로필에 저장됩니다: C:\\Users\\$user\\AppData\\Roaming\\Microsoft\\Windows\\Recent.\n\nLNK 파일은 파일이나 폴더가 열릴 때 기록이 되며, 제어판 앱도 포함됩니다. 이러한 쉘 항목들은 다음을 기록합니다:\n\n- 파일 시스템 타임스탬프\n- 대상 타임스탬프 (쉘 항목은 대상 파일을 가리키며, LNK 파일은 실제로 다른 개체에 액세스하는 방법에 대한 메타데이터를 저장)\n- 파일 크기, 속성 및 플래그\n- 대상 파일의 상대 경로\n- 대상 파일의 작업 디렉토리\n- 볼륨 정보\n- 그리고 $MFT 레코드 정보\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에릭 짐머만의 도구 중 하나인 LECmd를 사용하여 이 파일들을 구문 분석할 수 있습니다.\n\n```js\n# LECmd 사용법\nlecmd -f $file\n```\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_1.png)\n\n위 스크린샷에서 우리는 CIRT_SOP.docx라는 문서를 위한 LNK 파일을 볼 수 있습니다. 이 파일이 마지막으로 수정된 날짜는 Word가 마지막으로 실행된 날짜와 같음을 알 수 있습니다. 하나 이상의 문서가 열렸다는 것을 알기 때문에 사용자 레지스트리를 확인하여 파일이 마지막으로 열리고 닫힌 시간을 결정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 파일 활동 기간 결정하기\n\n사용자의 NTUSER.dat 파일에서 Microsoft Office 문서와 관련된 레지스트리 키를 찾을 수 있습니다. 주로 이러한 키들은 NTUSER\\Software\\Microsoft\\Office\\16.0\\Word 경로에 있습니다.\n\n## 파일이 마지막으로 열린 날짜\n\n저는 Microsoft 365 계정을 사용하고 있기 때문에 NTUSER\\Software\\Microsoft\\Office\\16.0\\Word\\File MRU에는 문서가 나열되지 않습니다. 대신 개인 Office 365 라이선스와 관련된 키를 참조해야 합니다: NTUSER\\Software\\Microsoft\\Office\\16.0\\Word\\User MRU\\LiveId_$hash\\File MRU. 이 항목들은 가장 최근에 사용된 순서대로 나열됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지 1](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_2.png)\n\n파일이 처음 열린 시간을 나타내는 타임스탬프는 64비트 FILETIME에서, big endian 형식으로 “T” 뒤에 나오는 바이트 입니다. 아래 화면은 아이템 1에 대한 디코딩된 시간을 보여줍니다.\n\n![이미지 2](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_3.png)\n\n![이미지 3](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_4.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 파일 종료 날짜\n\n파일이 마지막으로 닫힌 날짜를 확인하려면 다른 레지스트리 키인 NTUSER\\Software\\Microsoft\\Office\\16.0\\Word\\Reading Locations로 전환해야 합니다. 각 문서에는 중요한 하위 키/값 쌍을 포함하는 자체 하위 키가 생성됩니다.\n\n![image](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_5.png)\n\n![image](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_6.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDatetime에 나열된 값에 유의하세요. 이 값은 시스템의 로컬 시간입니다 (정확한 시스템 프로필링이 반드시 필요함을 증명합니다). Datetime에 나열된 시간을 UTC로 변환하면 레지스트리의 마지막 쓰기 시간 (2024–05–30 20:45:56)과 일치하는 것을 볼 수 있습니다. 이것은 파일이 마지막으로 닫힌 시간입니다.\n\nPosition 값은 사용자가 마지막으로 보고 있던 문서의 위치를 기록합니다. 이것은 Word가 시행하는 \"이전에 멈췄던 곳부터 다시 시작\" 기능입니다. 이론적으로, 사용자가 마지막으로 머물렀던 정확한 페이지를 결정할 수 있습니다:\n\n- 해당 대상 파일을 우리 시스템으로 복사\n- 문서를 열기\n- 문서를 닫아 우리의 NTUSER 하이브에 기록되도록 함\n- 용의자의 NTUSER 하이브에서 Position 값 복사하여 우리 NTUSER 하이브로 이동.\n\n# 문서의 마지막 위치 결정\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일하고 있는 문서를 추적 중이었던 것이 회사 작업을 위해 작업 중이던 것이기 때문에 사용자가 마지막으로 중지한 위치를 확인할 때 concept 확인을 위해 다른 문서로 전환할 것입니다. Reading Locations에 나열된 Document 1이라는 파일을 사용할 것입니다.\n\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_7.png)\n\n\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_8.png)\n\n\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_9.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이론적으로는 Position에 나열된 값과 일치하도록 변경하여 사용자가 마지막으로 보고 있던 내용을 복원할 수 있어야 합니다.\n\n![image1](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_10.png)\n\n이제 파일을 다시 열 때, 우리는 중단했던 곳부터 이어서 작업할 것을 요청받아야 합니다.\n\n![image2](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_11.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_12.png\" /\u003e\n\n# 이 기사의 목적\n\n저는 이 기사를 쓴 이유는 학습하고 있는 개념을 강화하고 있는 것인데, 메모에 너무 의존하는 것을 줄이고 지식을 내재화하는 노력에 있습니다. 사용자가 마지막으로 머물렀던 정확한 페이지를 확인할 수 있는 것이 가능하다는 것을 알게 되었을 때 정말 멋있었고, HackTheBox 머신에서 사용자/루트 쉘을 얻는 것보다 더 흥미로웠습니다. 이 글을 통해 새로운 지식을 얻거나 흥미를 느낀 사람이 있다면 좋겠습니다. 배운 것들을 다른 사람들과 공유해주세요!","ogImage":{"url":"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_0.png"},"coverImage":"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eWindows 포렌식 - 파일/폴더 오픈, 응용프로그램 실행과 관련된 증거\u003c/h1\u003e\n\u003ch2\u003e개요\u003c/h2\u003e\n\u003cp\u003e이 글은 프리패치 파일부터 셸 항목 및 레지스트리 분석까지 여러 가지를 다룰 것입니다. 우리는 대상 사용자가 Microsoft Office 제품을 실행하고 Word 문서와 활발히 작업한 사실을 보여줄 것입니다. 마지막으로 우리는 Word에서 사용자가 본 정확한 페이지를 확인하고 해당 페이지를 우리 자신의 기계에서 재작성하여 용의자 사용자가 마지막으로 본 것을 확인할 수 있게 될 것입니다.\u003c/p\u003e\n\u003ch2\u003e시스템에서 Microsoft Office 제품이 실행되었는지 확인하는 방법\u003c/h2\u003e\n\u003ch2\u003e사전 로드 파일\u003c/h2\u003e\n\u003cp\u003e사전 로드 파일은 응용 프로그램 실행에 대한 자세한 정보를 제공합니다. 그들의 주요 기능은 응용 프로그램의 일부 메모리를 디스크에 기록하여 사용자가 특정 응용 프로그램을 두 번째로 실행할 때 일부 데이터가 이미 캐싱되어 있어 더 빨리 시작되도록 하는 것입니다. 사전 로드가 캐시하는 정보는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e로드된 DLL\u003c/li\u003e\n\u003cli\u003e응용 프로그램이 상호 작용한 다른 파일(다른 PE 파일 포함)\u003c/li\u003e\n\u003cli\u003e응용 프로그램이 상호 작용한 디렉터리의 상대 경로\u003c/li\u003e\n\u003cli\u003e응용 프로그램을 실행한 횟수\u003c/li\u003e\n\u003cli\u003e응용 프로그램을 실행한 마지막 8개의 타임스탬프\u003c/li\u003e\n\u003cli\u003e파일 시스템 타임스탬프(생성, 수정, 액세스)\u003c/li\u003e\n\u003cli\u003e파일 크기\u003c/li\u003e\n\u003cli\u003e응용 프로그램 해시\u003c/li\u003e\n\u003cli\u003e볼륨 정보\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e사전 로드 파일은 C:\\Windows\\Prefetch에 저장되며 파일 확장자는 .pf입니다. 이것이 우리가 시작할 지점이 될 것이며, 대상 시스템에서 Office 제품이 실행되었는지 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e에릭 짐머만의 PECmd 도구를 사용하면 전체 디렉토리를 구문 분석하여 CSV 파일로 출력하거나 한 번에 하나의 .pf 파일을 구문 분석할 수 있습니다. 우리는 사무 문서에만 관심이 있기 때문에 Microsoft Word용 prefetch 파일 하나를 구문 분석할 것입니다.\u003c/p\u003e\n\u003ch2\u003eWord Prefetch (Application Execution)\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 하나의 prefetch 파일을 구문 분석하는 구문\npecmd -f $파일\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e가장 먼저 지적하고 싶은 것은 최근 실행된 타임스탬프와 파일 시스템 수정된 타임스탬프 간의 불일치입니다. 이론적으로는 응용 프로그램이 실행될 때 NTFS 파일 시스템에서 수정된 타임스탬프가 업데이트되므로 이러한 타임스탬프는 일치해야 합니다. 그러나 최근 실행 시간이 파일 시스템보다 2초 빠르게 기록되었습니다. 이것은 중요한 고려 사항이며 파일 시스템 타임스탬프만 놓고 보면 고려해야 할 사항입니다. 실행 후 파일 시스템이 수정된 시간을 업데이트하기까지 최대 10초가 소요될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 우리는 컴퓨터에서 Word가 실행되었음을 알고 있으며 다음과 같은 세부 사항이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWord가 23번 실행되었습니다\u003c/li\u003e\n\u003cli\u003e최근 실행 시간은 2024년 5월 30일 12:50:01에 있었습니다 (모든 타임스탬프는 UTC, 24시간 형식입니다)\u003c/li\u003e\n\u003cli\u003e볼륨 GUID\u003c/li\u003e\n\u003cli\u003e그리고 응용 프로그램이 상호 작용한 디렉토리 및 파일 목록 (스크린샷에 포함되지 않음)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e문서가 열렸는지 확인하기\u003c/h1\u003e\n\u003ch2\u003e바로 가기 파일 (LNK)\u003c/h2\u003e\n\u003cp\u003eWord가 열려 있다고 해서 그와 함께 문서가 열리는 것은 아닙니다. LNK 파일을 활용하여 어떤 문서가 열렸는지 추측하는 데 도움을 받을 수 있습니다. 이러한 증거들은 사용자의 프로필에 저장됩니다: C:\\Users$user\\AppData\\Roaming\\Microsoft\\Windows\\Recent.\u003c/p\u003e\n\u003cp\u003eLNK 파일은 파일이나 폴더가 열릴 때 기록이 되며, 제어판 앱도 포함됩니다. 이러한 쉘 항목들은 다음을 기록합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e파일 시스템 타임스탬프\u003c/li\u003e\n\u003cli\u003e대상 타임스탬프 (쉘 항목은 대상 파일을 가리키며, LNK 파일은 실제로 다른 개체에 액세스하는 방법에 대한 메타데이터를 저장)\u003c/li\u003e\n\u003cli\u003e파일 크기, 속성 및 플래그\u003c/li\u003e\n\u003cli\u003e대상 파일의 상대 경로\u003c/li\u003e\n\u003cli\u003e대상 파일의 작업 디렉토리\u003c/li\u003e\n\u003cli\u003e볼륨 정보\u003c/li\u003e\n\u003cli\u003e그리고 $MFT 레코드 정보\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e에릭 짐머만의 도구 중 하나인 LECmd를 사용하여 이 파일들을 구문 분석할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eLECmd\u003c/span\u003e 사용법\nlecmd -f $file\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e위 스크린샷에서 우리는 CIRT_SOP.docx라는 문서를 위한 LNK 파일을 볼 수 있습니다. 이 파일이 마지막으로 수정된 날짜는 Word가 마지막으로 실행된 날짜와 같음을 알 수 있습니다. 하나 이상의 문서가 열렸다는 것을 알기 때문에 사용자 레지스트리를 확인하여 파일이 마지막으로 열리고 닫힌 시간을 결정할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e파일 활동 기간 결정하기\u003c/h1\u003e\n\u003cp\u003e사용자의 NTUSER.dat 파일에서 Microsoft Office 문서와 관련된 레지스트리 키를 찾을 수 있습니다. 주로 이러한 키들은 NTUSER\\Software\\Microsoft\\Office\\16.0\\Word 경로에 있습니다.\u003c/p\u003e\n\u003ch2\u003e파일이 마지막으로 열린 날짜\u003c/h2\u003e\n\u003cp\u003e저는 Microsoft 365 계정을 사용하고 있기 때문에 NTUSER\\Software\\Microsoft\\Office\\16.0\\Word\\File MRU에는 문서가 나열되지 않습니다. 대신 개인 Office 365 라이선스와 관련된 키를 참조해야 합니다: NTUSER\\Software\\Microsoft\\Office\\16.0\\Word\\User MRU\\LiveId_$hash\\File MRU. 이 항목들은 가장 최근에 사용된 순서대로 나열됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_2.png\" alt=\"이미지 1\"\u003e\u003c/p\u003e\n\u003cp\u003e파일이 처음 열린 시간을 나타내는 타임스탬프는 64비트 FILETIME에서, big endian 형식으로 “T” 뒤에 나오는 바이트 입니다. 아래 화면은 아이템 1에 대한 디코딩된 시간을 보여줍니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_3.png\" alt=\"이미지 2\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_4.png\" alt=\"이미지 3\"\u003e\u003c/p\u003e\n\u003ch2\u003e파일 종료 날짜\u003c/h2\u003e\n\u003cp\u003e파일이 마지막으로 닫힌 날짜를 확인하려면 다른 레지스트리 키인 NTUSER\\Software\\Microsoft\\Office\\16.0\\Word\\Reading Locations로 전환해야 합니다. 각 문서에는 중요한 하위 키/값 쌍을 포함하는 자체 하위 키가 생성됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_5.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_6.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eDatetime에 나열된 값에 유의하세요. 이 값은 시스템의 로컬 시간입니다 (정확한 시스템 프로필링이 반드시 필요함을 증명합니다). Datetime에 나열된 시간을 UTC로 변환하면 레지스트리의 마지막 쓰기 시간 (2024–05–30 20:45:56)과 일치하는 것을 볼 수 있습니다. 이것은 파일이 마지막으로 닫힌 시간입니다.\u003c/p\u003e\n\u003cp\u003ePosition 값은 사용자가 마지막으로 보고 있던 문서의 위치를 기록합니다. 이것은 Word가 시행하는 \"이전에 멈췄던 곳부터 다시 시작\" 기능입니다. 이론적으로, 사용자가 마지막으로 머물렀던 정확한 페이지를 결정할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e해당 대상 파일을 우리 시스템으로 복사\u003c/li\u003e\n\u003cli\u003e문서를 열기\u003c/li\u003e\n\u003cli\u003e문서를 닫아 우리의 NTUSER 하이브에 기록되도록 함\u003c/li\u003e\n\u003cli\u003e용의자의 NTUSER 하이브에서 Position 값 복사하여 우리 NTUSER 하이브로 이동.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e문서의 마지막 위치 결정\u003c/h1\u003e\n\u003cp\u003e일하고 있는 문서를 추적 중이었던 것이 회사 작업을 위해 작업 중이던 것이기 때문에 사용자가 마지막으로 중지한 위치를 확인할 때 concept 확인을 위해 다른 문서로 전환할 것입니다. Reading Locations에 나열된 Document 1이라는 파일을 사용할 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_9.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이론적으로는 Position에 나열된 값과 일치하도록 변경하여 사용자가 마지막으로 보고 있던 내용을 복원할 수 있어야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_10.png\" alt=\"image1\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 파일을 다시 열 때, 우리는 중단했던 곳부터 이어서 작업할 것을 요청받아야 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_11.png\" alt=\"image2\"\u003e\u003c/p\u003e\n\u003ch1\u003e이 기사의 목적\u003c/h1\u003e\n\u003cp\u003e저는 이 기사를 쓴 이유는 학습하고 있는 개념을 강화하고 있는 것인데, 메모에 너무 의존하는 것을 줄이고 지식을 내재화하는 노력에 있습니다. 사용자가 마지막으로 머물렀던 정확한 페이지를 확인할 수 있는 것이 가능하다는 것을 알게 되었을 때 정말 멋있었고, HackTheBox 머신에서 사용자/루트 쉘을 얻는 것보다 더 흥미로웠습니다. 이 글을 통해 새로운 지식을 얻거나 흥미를 느낀 사람이 있다면 좋겠습니다. 배운 것들을 다른 사람들과 공유해주세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-WindowsForensicsOfficeDocuments"},"buildId":"FH3Qr-mLAesqA0X5IFRQr","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>