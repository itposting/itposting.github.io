<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>윈도우에서 UEFI 프로그래밍을 위한 히치하이커 안내서 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="윈도우에서 UEFI 프로그래밍을 위한 히치하이커 안내서 | itposting" data-gatsby-head="true"/><meta property="og:title" content="윈도우에서 UEFI 프로그래밍을 위한 히치하이커 안내서 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows" data-gatsby-head="true"/><meta name="twitter:title" content="윈도우에서 UEFI 프로그래밍을 위한 히치하이커 안내서 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 12:32" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-0fd008072af5a644.js" defer=""></script><script src="/_next/static/O5JVeK6TDhbvSxBlchQwM/_buildManifest.js" defer=""></script><script src="/_next/static/O5JVeK6TDhbvSxBlchQwM/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">윈도우에서 UEFI 프로그래밍을 위한 히치하이커 안내서</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="윈도우에서 UEFI 프로그래밍을 위한 히치하이커 안내서" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">27<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>왕밍재는 Secure Boot가 활성화된 실제 시스템에 개발한 UEFI 프로그램의 전체 과정을 설명합니다. 그의 안내로 엔지니어들은 UEFI 환경의 다양한 요소를 이해하고 UEFI 프로그램의 실행과 배포에 미치는 영향을 파악할 수 있습니다. 민재는 다양한 실용적 고려 사항을 포함하여 독자들이 다양한 배포 옵션을 평가하는 데 도움을 줍니다.</h2>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_0.png" alt="이미지"></p>
<h1>소개</h1>
<p>UEFI (통합 확장 펌웨어 인터페이스) 개발은 대부분 EDK II (EFI 개발 키트 II) 리포를 사용하여 수행됩니다. EFI는 원래 BIOS를 대체하기 위해 Intel 내에서 시작된 프로젝트였습니다. 노력은 1998년 Tiano 프로젝트 내에서 시작되었으며 규격과 이를 구현하는 펌웨어로 이루어져 있습니다. 2004년, Intel은 EFI 펌웨어의 기본 코드를 오픈 소스로 공개했습니다. 2005년, 컴퓨터 산업의 주요 업체들이 UEFI 포럼을 결성하여 특정 규격을 소유하게 되었으며 2006년에 UEFI 2.0 규격을 발표했습니다. 이후 오픈 소스 코드는 EDK로 발전하고 마침내 오늘날의 EDK II로 이어졌습니다. 개발자 커뮤니티인 TianoCore는 GitHub에서 소스 코드를 유지보수합니다.</p>
<p>Windows에서 UEFI 개발은 예전에는 복잡한 프로세스였습니다. 많은 수동 단계가 필요했죠. UEFI는 사용자 지정 빌드 도구 체인을 구현하며 IDE를 통한 개발을 지원하지 않습니다. 온라인에서 다양한 안내서를 찾을 수 있고 컨테이너를 사용하여 빌드 프로세스가 개선되었지만, 여전히 IDE의 편리함에는 미치지 못합니다. 게다가 UEFI 실행 파일을 설치/배포하는 방법에 대한 충분한 자료가 없으며, Secure Boot를 활성화한 상태에서 실행시키는 방법에 대한 정보는 더 드물죠.</p>
<p>그래서 이 안내서는 이러한 공백을 메우고 UEFI 실행 파일을 배포하려는 사람들에게 도움이 되기를 희망합니다. 개인적인 용도든 제품 환경에서든 UEFI 실행 파일을 배포하려는 분들에게 도움이 될 것입니다.</p>
<p>이 안내서를 읽는 독자들은 다음을 기본적으로 이해하고 있을 것으로 예상됩니다:</p>
<ul>
<li>UEFI가 무엇인지</li>
<li>C 프로그래밍 언어</li>
<li>Visual Studio IDE</li>
</ul>
<h2>설치 및 빌드</h2>
<p>이전에 언급된 개발 도전에 직면하던 중, Windows Internals 저자 중 한 명인 Alex Ionescu는 VisualUefi를 만들어 EDK II의 소스 코드를 Visual Studio 솔루션으로 래핑하였습니다. IDE 내에서 빌드가 이루어지며, EDK II의 사용자 정의 빌드 툴 체인을 완전히 우회합니다. 사용자의 UEFI 실행 파일을 개발하기 위해서는 두 번째 솔루션을 사용합니다.</p>
<p>VisualUefi 저장소의 지침에 따라 진행하세요.</p>
<h2>실행</h2>
<p>UEFI 실행 파일은 OS에서 직접 실행되지 않고 OS 부팅 전에 있는 UEFI 환경에서만 실행될 수 있습니다. 따라서 VisualUEFI는 QEMU와 EDK II의 OVMF (Open Virtual Machine Firmware) 모듈을 사용하여 펌웨어 실행 환경을 에뮬레이트합니다. VisualUEFI는 UEFI 실행 파일이 일반적인 명령행 실행 파일과 거의 동일하게 실행될 수 있도록 QEMU와 OVMF를 통합합니다.</p>
<h2>EFI 셸에서 실행하기</h2>
<p>이 섹션은 VisualUEFI의 단계와 동일하며 스크린샷이 추가되었습니다.</p>
<p>샘플 솔루션에서 Ctrl+F5를 눌러 QEMU를 실행하세요. 이렇게 하면 EFI 셸로 직접 부팅되며 여기서 샘플 UEFI 실행 파일을 실행할 수 있습니다:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_1.png" alt="Screenshot 1"></p>
<p>F5를 사용해도 되지만, 이 방법은 Visual Studio 디버거를 시작하는데 이 경우에는 QEMU 또는 UEFI 실행 파일에 연결할 수 없기 때문에 쓸모가 없습니다.</p>
<p>해결책의 빌드 출력 디렉토리 VisualUefi\samples\x64\Release\은 가상 볼륨으로 fs1:라는 레이블 아래로 탑재됩니다. 이 디렉토리의 내용을 나열하면 Windows에서 볼 수 있는 것과 동일한 파일과 폴더가 표시됩니다:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_2.png" alt="Screenshot 2"></p>
<p>첫째로, UefiDriver.efi를 로드해주세요:</p>
<p><code>![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_3.png)</code></p>
<p>드라이버가 로드되었는지 확인하려면 devtree -b 명령을 사용하세요. -b 플래그는 출력을 한 번에 한 화면씩 표시합니다. 로딩 전후의 출력을 비교해보세요:</p>
<p>동일한 방식으로 drivers 명령어를 사용할 수도 있습니다.</p>
<p>어플리케이션을 실행하세요:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_4.png" alt="application"></p>
<h2>새 부팅 옵션에서 실행하기 — 어플리케이션 설치</h2>
<p>큐뮤를 실행한 후, 펌웨어 메뉴로 진입할 때까지 Esc 키를 누른 채로 유지하세요. 또는 EFI 셸에서 exit 명령을 입력하여 펌웨어 메뉴로 나갈 수 있습니다.</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_5.png" alt="Boot Maintenance Manager"></p>
<p>Select Boot Options.</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_7.png" alt="image"></p>
<p>Select Add Boot Option.</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_8.png" alt="image"></p>
<p>Select the first option.</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_9.png" alt="image 1"></p>
<p>Select UefiApplication.efi.</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_10.png" alt="image 2"></p>
<p>Enter any description; this will be the display name of the new boot option. The Optional Data field specifies the arguments that are passed to the UEFI executable. Leave it blank as the sample application does not use it.</p>
<p>변경 사항을 저장하고 펌웨어 메뉴 페이지로 돌아가세요. 부트 매니저 옵션을 선택하세요:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_11.png" alt="부트 매니저"></p>
<p>새로 추가된 부팅 옵션이 마지막 항목으로 표시됩니다. 실행하려면 그냥 선택하면 됩니다. 응용 프로그램이 종료되면 사용자는 즉시 펌웨어 메뉴로 돌아가며 출력은 빠르게 지나갑니다. 출력을 유지하려면 응용 프로그램의 코드를 변경해야 합니다.</p>
<p>사용자가 키를 눌러야 응용 프로그램이 돌아올 때까지 기다리도록 하는 방법이 있습니다. 이는 edk2\MdeModulePkg\Library\CustomizedDisplayLib\CustomizedDisplayLibInternal.c의 WaitForKeyStroke 함수를 사용하여 달성할 수 있습니다. 그러나 EDK-II 솔루션에 이 라이브러리가 포함되어 있지 않아 사용할 수 없습니다. Visual Studio 프로젝트를 만들어 새 라이브러리를 빌드하는 것은 본 안내서의 범위를 넘어서므로 지금은 응용 프로그램에 코드를 복제하는 것만으로 충분합니다.</p>
<p>EFI_STATUS
WaitForKeyStroke(
OUT  EFI_INPUT_KEY* Key
)
{
EFI_STATUS  Status;
UINTN       Index;
while (TRUE) {
Status = gST->ConIn->ReadKeyStroke(gST->ConIn, Key);
if (!EFI_ERROR(Status)) {
break;
}
if (Status != EFI_NOT_READY) {
continue;
}
gBS->WaitForEvent(1, &#x26;gST->ConIn->WaitForKey, &#x26;Index);
}
return Status;
}</p>
<p>호출하는 코드:</p>
<p>Print(L"Press any key to continue...\n");
EFI_INPUT_KEY keyInput;
efiStatus = WaitForKeyStroke(&#x26;keyInput);
if (EFI_ERROR(efiStatus))
{
Print(L"Failed to get keystroke: %lx\n", efiStatus);
goto Exit;
}</p>
<p>주의할 점: 샘플 응용 프로그램의 코드에 3가지 문제가 있습니다:</p>
<ul>
<li>94번 라인:</li>
</ul>
<pre><code class="hljs language-js">efiStatus = <span class="hljs-title class_">ShellInitialize</span>();
</code></pre>
<p>이 코드는 EFI 셸에서만 작동합니다. 셸 대신에 우리 애플리케이션을 먼저 실행하고 있기 때문에 ShellInitialize() 호출이 실패할 것입니다.</p>
<ul>
<li>104번 라인:</li>
</ul>
<pre><code class="hljs language-js">efiStatus = <span class="hljs-title class_">ShellOpenFileByName</span>(L<span class="hljs-string">"fs1:\\UefiApplication.efi"</span>,
</code></pre>
<p>볼륨 레이블 fs1:이 항상 사용 가능하고 실행 파일이 항상 거기에 저장되어 있다고 가정합니다. 그러나 볼륨 레이블을 할당하는 것은 EFI 셸의 역할이므로 EFI 셸이 없으면 fs1:이 없어지고 ShellOpenFileByName()은 실패할 것입니다.</p>
<ul>
<li>134번째 줄:</li>
</ul>
<pre><code class="hljs language-js">efiStatus = gBS-><span class="hljs-title class_">LocateProtocol</span>(&#x26;gEfiSampleDriverProtocolGuid, <span class="hljs-variable constant_">NULL</span>, &#x26;sampleProtocol);
</code></pre>
<p>샘플 드라이버에 액세스하려고 시도되었지만, 아직 드라이버를 설치하지 않았기 때문에 이 작업도 실패합니다.</p>
<p>코드는 항상 실패 시에 항상 "Exit;"으로 이동하므로 사용자의 키 입력을 읽는 코드를 제일 위에 삽입해야 실행이 보장됩니다.</p>
<p>부트 매니저 UI를 항상 입력해야 하는 것을 피하기 위해 부팅 순서를 EFI 셸 대신 새로운 옵션을 먼저 부팅하도록 변경할 수 있습니다. 그러려면, Boot Maintenance Manager <code>Boot Options</code> Change Boot Order로 이동하십시오:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_12.png" alt="이미지"></p>
<p>이 경우에는 애플리케이션이 펌웨어 메뉴 대신 EFI 셸로 종료됩니다. 부팅할 때 부팅 옵션이 EFI_SUCCESS를 반환하면 제어가 펌웨어 메뉴로 돌아가고, 그렇지 않으면 다음 부팅 옵션이 실행되며, 모든 부팅 옵션이 시도될 때까지 EFI_SUCCESS를 반환하거나 모든 부팅 옵션이 소진됩니다(UFI 사양서 섹션 3.1.1 참조). 위에서 언급한 3가지 문제로 인해 애플리케이션은 EFI_SUCCESS를 반환하지 않으므로 펌웨어는 다음 옵션인 UEFI 셸을 실행합니다.</p>
<p>위의 부팅 옵션 처리에 대한 예외 사항은 애플리케이션이 ExitBootServices()를 호출하는 경우에 있습니다. 그러나 이 내용은 이 안내서의 범위를 벗어납니다.</p>
<h2>새 부팅 옵션에서 실행 - 드라이버 설치</h2>
<p>부팅 유지 관리자 페이지에서 드라이버 옵션을 선택하세요:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_13.png" alt="이미지"></p>
<p>Add Driver 옵션을 선택하세요.</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_14.png" alt="이미지"></p>
<p>파일을 사용하여 Add Driver 옵션을 선택하세요.</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_15.png" alt="image"></p>
<p>Select the first option.</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_16.png" alt="image"></p>
<p>Select UefiDriver.efi.</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_17.png" alt="이미지"></p>
<p>어떤 설명을 입력하세요; 이는 새 드라이버 옵션의 표시 이름이 될 것입니다. 옵션 데이터 필드는 UEFI 실행 파일에 전달되는 인수를 지정합니다. 샘플 드라이버가 사용하지 않기 때문에 비워 두세요.</p>
<p>로드 옵션 Reconnect 필드는 펌웨어 부팅 관리자 실행 전에로드된 모든 드라이버를 무시하도록 드라이버에게 허용합니다 (UEFI 사양 섹션 3.1.3 참조). devtree 및 drivers 명령의 출력을 상기하세요 - 샘플 드라이버를 제외한 모든 항목은 펌웨어와 함께 제공된 드라이버이며 펌웨어 부팅 관리자 실행 전에 로드되었습니다. 호환성 문제가 발생할 수 있으므로 장치는 하나의 드라이버로 관리되어야 합니다. 샘플 드라이버는 기존 드라이버를 무시하지 않으므로 옵션을 활성화하는 것은 필요하지 않으며 순수한 효과가 없을 것입니다. 이 페이지를 저장하고 나가세요.</p>
<p>펌웨어 부팅 관리자는 부팅 시 부트와 드라이버 옵션을 자동으로 실행하는 펌웨어 구성 요소를 가리킵니다; 사용자가 수동으로 실행할 부트 옵션을 선택하는 부팅 관리자 UI와 혼동하면 안 됩니다. 또한 드라이버 오버라이드를 적용하려면 마지막 드라이버 옵션이 처리된 후 모든 UEFI 드라이버가 시스템에서 연결 해제되고 다시 연결되어야 합니다.</p>
<p>펌웨어 부트 매니저는 부팅 옵션을 처리하기 전에 모든 드라이버 옵션을 자동으로 처리합니다. 그러므로 부팅 옵션과는 달리 펌웨어 메뉴는 명시적으로 특정 드라이버 옵션을 로드할 수 있는 방법을 제공하지 않습니다. 또한 필요하지 않습니다. 설치된 모든 드라이버 옵션이 로드됩니다.</p>
<h2>EFI 쉘을 통한 수동 설치</h2>
<p>펌웨어 메뉴를 사용하는 것 외에도, EFI 쉘에서 bcfg 명령을 사용하여 새로운 부팅 및 드라이버 옵션을 설치할 수 있습니다. 자세한 내용은 도움말 bcfg의 결과를 확인하세요.</p>
<p>펌웨어가 새로운 부팅 옵션 및/또는 드라이버 옵션을 추가할 수 있는 능력을 제공하지 않는 시스템에서 유용합니다. 이는 UEFI 사양 섹션 3에서 정의된 메커니즘 (NVRAM 변수, UEFI 변수로도 불리는)에 따라 옵션이 구현된 방식 때문입니다. 즉, 모든 UEFI 호환 펌웨어는 설명된 방식으로 옵션을 구현하고 처리해야합니다. bcfg는 동일한 메커니즘으로 작동하기 때문에, 펌웨어가 명시적으로 이를 지원하지 않더라도 옵션을 수정할 수 있습니다.</p>
<p>사실 NVRAM 변수를 직접 수정하여 부팅 및 드라이버 옵션을 설치하거나 수정할 수 있습니다. 그러나 이것은 이 안내서의 범위를 벗어납니다.</p>
<h2>기존 부팅 옵션에서 실행</h2>
<p>부팅 매니저 페이지에서 샘플 애플리케이션 옵션의 장치 경로 설명을 볼 수 있습니다. 그러나 EFI 셸 옵션에는 실행 파일의 이름이 누락되어 있을 수 있습니다:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_18.png" alt="이미지"></p>
<p>해당 옵션의 Device Path(UEFI 셸에서 fs0: 볼륨 레이블로 할당)로 가리키는 파티션 내용을 나열하면 EnrollDefaultKeys.efi라는 유일한 UEFI 실행 파일만 있는 것을 알 수 있습니다. 이것이 EFI 셸처럼 들리지 않는 것이 분명합니다.</p>
<p>이것이 일어나는 것은 펌웨어 부트 관리자가 모든 탈착 가능 미디어 및 고정 미디어 장치를 열거하고, 각 장치에 대한 부팅 옵션을 만드는 것입니다(UEFI 사양 섹션 13.3에 자세히 설명된 것처럼, 파일 시스템이 FAT인 경우). 이러한 항목을 부팅할 때 펌웨어가 장치 경로에 다음을 추가합니다: \EFI\BOOT\BOOT'machine type short-name'.EFI 여기서 machine type short-name은 PE32+ 이미지 형식 아키텍처를 정의합니다. 가능한 값은:</p>
<p>PE(Portable Executable) 실행 파일 머신 유형은 Microsoft Portable Executable and Common Object File Format Specification, Revision 6.0에서 정의된 COFF 파일 헤더의 machine 필드에 지정됩니다.</p>
<p>여러 CPU 아키텍처를 지원하기 위해 장치는 \EFI\BOOT\ 하위 디렉터리에 서로 다른 아키텍처용으로 구축된 여러 실행 파일을 저장할 수 있습니다. 자세한 내용은 UEFI 명세의 섹션 3.1.2 및 3.5를 참조하십시오.</p>
<p>따라서 fs0: 내의 모든 .efi를 나열하면 FS0:\efi\boot\ 내에 bootx64.efi가 나타납니다. 이것이 EFI 셸입니다:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_21.png" alt="EFI Shell"></p>
<p>따라서 샘플 애플리케이션에 대해 동일한 방법을 적용할 수 있습니다. VisualUefi\samples\x64\Release\ 하위에 \EFI\BOOT\ 하위 디렉토리를 만들고 샘플 애플리케이션을 복사하여 BOOTx64.efi로 이름을 바꿉니다. 실행하려면 부트 매니저 UI에서 기존 UEFI Misc 장치 옵션을 선택하면 됩니다. 또는 부팅 옵션을 재정렬하여 QEMU가 먼저 부팅하도록 할 수도 있습니다.</p>
<p>이 접근 방식은 UEFI가 탈착식 미디어에서 부팅하는 방법을 지원하는 방식입니다. 예를 들어 Windows 설치 플래시 드라이브를 만들 때 설치 프로그램 실행 파일을 \EFI\BOOT\BOOTx64.efi에 저장합니다. 설치하려면 펌웨어 메뉴에 들어가서 플래시 드라이브에서 부팅 옵션을 선택합니다. 또는 이미 플래시 드라이브를 첫 번째 부팅 옵션으로 구성했다면 시스템은 자동으로 설치 프로그램으로 부팅합니다.</p>
<h2>EFI 셸</h2>
<p>셸은 본질적으로 UEFI 펌웨어의 명령 프롬프트 / bash 셸 버전입니다. bash와 동일한 명령어를 지원하며 모든 지원되는 명령을 나열하려면 help 명령을 사용하면 됩니다. 이를 통해 사용자는 OS에 부팅하지 않고 시스템의 파일에 접근하거나 수정할 수 있습니다. UEFI 펌웨어는 기본적으로 FAT 파일 시스템만 지원하므로 셸이 액세스할 수 있는 파일 시스템도 FAT 파일 시스템뿐입니다. 다른 파일 시스템의 지원은 관련 UEFI 드라이버가 설치되고 로드되어 있는지에 따라 달라집니다.</p>
<p>startup.nsh
쉘을 실행하면 다음과 같은 프롬프트가 나타납니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Press</span> <span class="hljs-variable constant_">ESC</span> <span class="hljs-keyword">in</span> <span class="hljs-number">5</span> seconds to skip startup.<span class="hljs-property">nsh</span>, any other key to <span class="hljs-keyword">continue</span>.
</code></pre>
<p>셸은 실행할 때마다 startup.nsh를 실행합니다. 셸을 첫 번째 부팅 옵션으로 구성하면(이미 QEMU의 기본값으로 설정되어 있음), 이를 통해 OS에 부팅하지 않고 시스템에서 자동으로 스크립트 작업을 실행할 수 있습니다.</p>
<p>기본적으로 스크립트 파일이 없지만 ESP(EFI 시스템 파티션)의 루트 디렉터리에 직접 만들 수 있습니다. 시험해보려면 셸에서 다음 명령을 입력하세요:</p>
<pre><code class="hljs language-md">echo "@echo test startup script" > fs0:\startup.nsh
</code></pre>
<p>여기서 ESP의 볼륨 라벨인 fs0:에 스크립트 파일을 만들었어요.</p>
<p>exit 명령어로 셸을 종료하고 다시 실행하세요:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_22.png" alt="이미지"></p>
<h2>EFI 시스템 파티션 (ESP)</h2>
<p>이것은 UEFI 사양에 의해 정의된 특수 파티션이며 UEFI 펌웨어에서 액세스할 수 있습니다. 이것이 무엇인지 궁금하다면, 파티션에 액세스하는 것은 기본 작업이므로 이것이 운영 체제에만 해당되었다는 것을 알아두세요. UEFI가 대체하는 BIOS는 디스크의 전체 파티션에 액세스할 수 없었습니다. BIOS가 디스크에서 액세스 할 수 있는 유일한 요소는 MBR (마스터 부트 레코드) 및 VBR (볼륨 부트 레코드)였는데, 이들은 UEFI에 의해 대체되었습니다.</p>
<p>ESP에는 일반적으로 OS 부트로더 및 / 또는 부트 매니저가 위치합니다. Windows에서는 이 파티션은 디스크 관리.msc에서 볼 수 있듯이 기본적으로 드라이브 문자가 할당되지 않으므로 직접 액세스 할 수 없습니다:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_23.png" alt="파티션 예시"></p>
<p>접근하려면 고정된 명령 프롬프트를 열고 명령 mountvol X: /S를 사용하여 드라이브 문자를 할당하십시오. 여기서 X는 사용되지 않는 드라이브 문자입니다.</p>
<p>Windows 부트 매니저의 위치를 확인하려면:</p>
<pre><code class="hljs language-js"><span class="hljs-attr">X</span>:\>dir /b/s *.<span class="hljs-property">efi</span>
<span class="hljs-attr">X</span>:\<span class="hljs-variable constant_">EFI</span>\<span class="hljs-title class_">Microsoft</span>\<span class="hljs-title class_">Boot</span>\bootmgr.<span class="hljs-property">efi</span>
<span class="hljs-attr">X</span>:\<span class="hljs-variable constant_">EFI</span>\<span class="hljs-title class_">Microsoft</span>\<span class="hljs-title class_">Boot</span>\memtest.<span class="hljs-property">efi</span>
<span class="hljs-attr">X</span>:\<span class="hljs-variable constant_">EFI</span>\<span class="hljs-title class_">Microsoft</span>\<span class="hljs-title class_">Boot</span>\bootmgfw.<span class="hljs-property">efi</span>
<span class="hljs-attr">X</span>:\<span class="hljs-variable constant_">EFI</span>\<span class="hljs-title class_">Microsoft</span>\<span class="hljs-title class_">Boot</span>\<span class="hljs-title class_">SecureBootRecovery</span>.<span class="hljs-property">efi</span>
<span class="hljs-attr">X</span>:\<span class="hljs-variable constant_">EFI</span>\<span class="hljs-title class_">Boot</span>\bootx64.<span class="hljs-property">efi</span>
</code></pre>
<p>bootmgfw.efi가 Windows 부팅 매니저입니다. 또한 EFI\Boot\bootx64.efi 항목에 주목하세요. 이것은 bootmgfw.efi의 사본이며, bootmgfw.efi가 없거나 손상된 경우 대비 용도로 제공됩니다.</p>
<h1>Secure Boot</h1>
<p>지금까지 모든 UEFI 실행 파일은 Secure Boot가 비활성화된 상태로 실행되었습니다. Secure Boot는 UEFI 펌웨어의 보안 기능으로 신뢰할 수 있는 UEFI 실행 파일만을 실행할 수 있게 합니다. 이를 통해 시스템이 악성 UEFI 실행 파일(예: 부트킷)로부터 안전하게 보호되며, 제품 환경에서 항상 활성화되어야 합니다. 신뢰는 실행 파일의 서명이 승인된 서명 데이터베이스에 있고 금지된 서명 데이터베이스에 없는 것으로 정의됩니다. 서명은 다음 중 하나로 정의됩니다:</p>
<ul>
<li>실행 파일의 SHA-1 Authenticode 해시</li>
<li>실행 파일의 SHA-256 Authenticode 해시</li>
<li>실행 파일의 SHA-224 Authenticode 해시</li>
<li>실행 파일의 SHA-384 Authenticode 해시</li>
<li>실행 파일의 SHA-512 Authenticode 해시</li>
<li>실행 파일의 SHA-256 Authenticode 해시에 대한 RSA-2048 서명</li>
<li>실행 파일의 SHA-1 Authenticode 해시에 대한 RSA-2048 서명</li>
<li>실행 파일을 서명한 RSA-2048 키의 모듈러스 (공개 키 지수는 0x10001로 가정)</li>
<li>실행 파일을 서명한 키의 DER로 인코딩된 X.509 인증서</li>
<li>타임스탬프를 포함하는 더 복잡한 것들</li>
</ul>
<p>Authenticode 해시가 어떻게 계산되는지에 대한 정보는 Windows Authenticode Portable Executable Signature Format에서 "PE 이미지 해시 계산" 섹션을 참조하십시오. X.509 인증서의 경우에는 UEFI 사양 섹션 8.2.6 및 32.6.3.3에 따라 실행 파일의 서명 인증서가 X.509 인증서 체인의 모든 수준에 존재하는 한 일치가 발견됩니다.</p>
<p>따라서 샘플 실행 파일이 안전 부팅이 활성화된 상태에서 실행되도록 하려면 이 중 하나의 서명을 안전 부팅 승인된 데이터베이스로 가져와야 합니다. 인증서를 사용하는 것이 더 유연한 옵션이며 해당 개인 키로 서명된 모든 실행 파일을 실행할 수 있습니다. 이로 인해 개발 및 테스트 중에 유용한 반복적인 수정 및 실행 파일 재구축이 가능해집니다. 그러나 해시를 사용하는 것보다 안전하지 않습니다. 왜냐하면 개인 키 침해의 위험이 있기 때문입니다.</p>
<p>서명을 설치하려면 펌웨어 메뉴로 이동하십시오:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_24.png" alt="이미지"></p>
<p>장치 관리자를 선택하십시오.</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_25.png" alt="Image"></p>
<p>Select Secure Boot Configuration.</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_26.png" alt="Image"></p>
<p>The Current Secure Boot State is set to Disabled. This entry is not configurable and is only meant to display the current state. The Attempt Secure Boot option itself is disabled (explained later), and the only option that can be changed is Secure Boot Mode. Change this from Standard Mode and Custom Mode which is the only other option available:</p>
<p>친구 안전 부팅 옵션을 선택하십시오.</p>
<p>다섯 가지 옵션 각각이 안전 부팅 키 유형에 해당합니다. DB는 승인된 서명 데이터베이스이며 DBX는 금지된 서명 데이터베이스입니다. UEFI 명세서에서 "키"라는 용어를 사용하고 있지만, 각 유형의 "키"에 저장된 항목은 실제로 앞서 언급한 유형의 서명 중 하나입니다. 명세서를 따라서 "키"를 일반적인 서명을 가리키는 용어로 사용하겠습니다. 각 항목을 살펴보면:</p>
<p>새 키를 등록하거나 기존 키를 삭제할 수 있는 옵션을 볼 수 있습니다. 기존 키 목록을 표시할 옵션은 없지만 삭제 옵션을 사용하여 삭제할 수 있습니다. 이렇게 하면 모든 키가 비어 있는 것을 확인할 수 있습니다. 이것이 안전 부팅을 활성화할 수 없는 이유입니다 — 안전 부팅을 활성화하려면 PK(플랫폼 키)가 있어야 합니다. 우리는 직접 하나 만들 수 있지만, 앞서 EnrollDefaultKeys.efi를 본 것을 기억해보세요.</p>
<h2>기본 안전 부팅 키 설치</h2>
<p>기본 안전 부팅 키를 설치하려면 EFI 셸에서 EnrollDefaultKeys.efi를 실행하십시오. 이 작업은 모든 기존 키를 덮어씁니다:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_29.png" alt="이미지"></p>
<p>Secure Boot은 PK가 없는 경우 설정 모드에 있습니다. PK를 설치하면 자동으로 Secure Boot가 사용자 모드로 전환됩니다 (UEFI 사양 섹션 32.3 참조, 이에 대해 나중에 자세히 논의할 예정입니다).</p>
<p>셸을 종료하고 다시 Secure Boot 구성을 확인하십시오:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_30.png" alt="Secure Boot Configuration"></p>
<p>이제 Secure Boot가 활성화되고 "Attempt Secure Boot" 옵션이 활성화되어 설정되어 있습니다.</p>
<p>안녕하세요! 다시 Secure Boot Mode를 Custom으로 변경하고 키를 나열해 보겠습니다:</p>
<ul>
<li>
<p>PK: 이전에 활성화되었던 Enroll PK 옵션이 이제 비활성화되었습니다. 시스템에는 하나의 PK만 있을 수 있기 때문에 그렇습니다.</p>
</li>
<li>
<p>KEK: GUID로 명명된 두 항목이 있습니다. 모든 Secure Boot 키는 키의 소유자를 나타내는 SignatureOwner GUID와 연결됩니다:</p>
<ul>
<li>d5c1df0b-1bac-4edf-ba48-08834009ca5a: 이 소유자는 알 수 없습니다.</li>
<li>77fa9abd-0359-4d32-bd60-28f4e78f784b: 이것은 Microsoft입니다 (나중에 설명될 것입니다).</li>
</ul>
</li>
<li>
<p>DB: Microsoft에 속한 두 항목이 있습니다 (나중에 설명될 것입니다).</p>
</li>
<li>
<p>DBX: 여기서 키는 유형에 따라 목록으로 그룹화됩니다. 유형이 SHA256인 목록만 한 개 존재합니다. Secure Boot 키의 모든 유형은 유형별 목록에 저장되는데, 이 펌웨어에서는 이 정보를 DBX에 대해서만 보여주기로 결정했습니다. 목록을 선택하면:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_31.png" alt="이미지"></p>
<p>KEK에 있는 알 수 없는 GUID와 같은 GUID가 나오며, 해시 E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855는 비어 있는 파일의 해시입니다. 이는 아마도 예제로 제공된 것일 것입니다. 최신 시스템에서는 DBX에 알려진 취약한 UEFI 실행 파일의 항목이 포함됩니다. 이러한 실행 파일 및 DBX를 업데이트하기 위한 이진 blob의 목록은 UEFI Forum에서 관리됩니다. Microsoft는 GitHub repo에서 이 목록의 미러를 유지합니다.</p>
</li>
</ul>
<ul>
<li>DBT: 여전히 비어 있습니다.</li>
</ul>
<p>이제 부팅을 시도해 봅시다:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_32.png" alt="부팅 이미지"></p>
<p>EFI 쉘 또는 샘플 응용 프로그램은 서명되지 않았으며, 그 서명 또한 DB에 없기 때문에 이는 예상대로입니다.</p>
<h1>EFI 서명 인증서 생성</h1>
<p>샘플 애플리케이션을 서명하기 위해 먼저 인증서를 생성할 것입니다. Windows SDK에 포함된 명령줄 도구를 사용할 것입니다. 이 도구들은 %programfiles(x86)%\Windows Kits\10\bin\10.0.22621.0\x64\에 위치해 있습니다. 설치된 SDK 버전에 따라 하위 디렉토리의 이름이 다를 수 있습니다.</p>
<p>먼저, 다음 명령을 명령 프롬프트에서 사용하여 개인 키와 해당 인증서를 생성해 보세요:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">MakeCert</span>.<span class="hljs-property">exe</span> -a sha256 -n <span class="hljs-string">"CN=SampleEfiSigner"</span> -r -sv <span class="hljs-title class_">SampleEfiSigner</span>.<span class="hljs-property">pvk</span> <span class="hljs-title class_">SampleEfiSigner</span>.<span class="hljs-property">cer</span>
</code></pre>
<p>출력 파일은 DER 인코딩된 X.509 형식으로 제공되며, 이는 지원되는 DB 서명 유형 중 하나입니다.</p>
<p>옵션에 대한 설명:</p>
<ul>
<li>-a 서명의 다이제스트 알고리즘(기본값은 SHA1)</li>
<li>-n 인증서 소유자 X509 이름</li>
<li>-r 자체 서명된 인증서 생성</li>
<li>-sv 서브젝트의 PVK 파일, 존재하지 않는 경우 생성됩니다.</li>
</ul>
<p>이 명령은 비공개 키 파일을 사용할 비밀번호를 요청하는 팝업 프롬프트를 생성합니다.</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_33.png" alt="이미지"></p>
<p>다음으로 임의의 암호를 설정하고 확인을 누르세요.</p>
<p>이렇게 하면 이전 단계에서 설정한 암호를 요청하는 두 번째 프롬프트가 생성됩니다. 이는 자체 서명 작업을 위한 것입니다:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_34.png" alt="이미지"></p>
<p>MakeCert 명령어의 결과는 다음과 같아야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Succeeded</span>;
</code></pre>
<p>그런 다음 .pvk 파일을 .pfx로 변환하여 signtool에서 UEFI 실행 파일에 서명할 수 있도록 합니다:</p>
<pre><code class="hljs language-js">pvk2pfx.<span class="hljs-property">exe</span> -pvk <span class="hljs-title class_">SampleEfiSigner</span>.<span class="hljs-property">pvk</span> -pi &#x3C;password> -spc <span class="hljs-title class_">SampleEfiSigner</span>.<span class="hljs-property">cer</span> -pfx <span class="hljs-title class_">SampleEfiSigner</span>.<span class="hljs-property">pfx</span>
</code></pre>
<p><code>password</code>를 개인 키 파일의 비밀번호로 바꾸세요. 이 명령은 출력물이 없습니다.</p>
<p>옵션 설명:</p>
<ul>
<li>-pvk 입력 PVK 파일 이름</li>
<li>-pi PVK 파일의 비밀번호</li>
<li>-spc 입력 SPC 파일 이름</li>
<li>-pfx 출력 PFX 파일 이름</li>
</ul>
<h2>UEFI 실행 파일에 서명하기</h2>
<p>이전 도구와 동일한 디렉토리에 있는 signtool을 사용해보세요:</p>
<pre><code class="hljs language-js">signtool.<span class="hljs-property">exe</span> sign /fd sha256 /ac <span class="hljs-title class_">SampleEfiSigner</span>.<span class="hljs-property">cer</span> /f <span class="hljs-title class_">SampleEfiSigner</span>.<span class="hljs-property">pfx</span> /p &#x3C;비밀번호> &#x3C;서명할 efi 파일>
</code></pre>
<p><code>비밀번호</code>를 개인 키 파일의 비밀번호로 대체하세요. <code>서명할 efi 파일</code>은 대상 파일 이름으로 대체하세요. 이 명령은 다음을 출력해야 합니다:</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Done</span> <span class="hljs-title class_">Adding</span> <span class="hljs-title class_">Additional</span> <span class="hljs-title class_">Store</span>
<span class="hljs-title class_">Successfully</span> <span class="hljs-attr">signed</span>: &#x3C;efiToSign>
</code></pre>
<p>옵션 설명:</p>
<ul>
<li>/fd 파일 서명에 사용할 파일 다이제스트 알고리즘 (기본값은 SHA1)</li>
<li>/ac 서명 블록에 추가 인증서 추가</li>
<li>/f 서명 인증서의 파일. 파일에 개인 키가 없는 경우 "/csp" 및 "/kc"를 사용하십시오.</li>
<li>/p PFX 파일의 암호</li>
</ul>
<p>파일의 속성 창을 열어 서명되었는지 확인하세요. 새로운 디지털 서명 탭이 있어야 합니다:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_35.png" alt="서명 확인"></p>
<h2>DB에 인증서 설치하기</h2>
<p>SampleEfiSigner.cer 파일을 VisualUefi\samples\x64\Release\ 폴더로 이동하세요. 우리는 이후 펌웨어 메뉴에서 이 파일에 접근해야 합니다. 펌웨어 메뉴에서 DB 옵션으로 이동하고 Enroll Signature를 선택하세요:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_36.png" alt="이미지"></p>
<p>Select Enroll Signature Using File.</p>
<p>첫 번째 옵션을 선택하세요.</p>
<p>SampleEfiSigner.cer를 선택하세요. 여기서 펌웨어는 DER로 인코딩된 X.509 인증서와 UEFI 실행 파일만 지원합니다. 후자의 경우 실행 파일의 SHA-256 Authenticode 해시를 계산하여 서명으로 저장할 것입니다.</p>
<p>UI가 등록 서명 페이지로 돌아갑니다. 서명 GUID 필드는 서명 소유자의 서명과 일치합니다. 임의의 값 입력하거나 기본값으로 모든 0의 GUID로 남겨 둡니다:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_39.png" alt="Enroll Signature"></p>
<p>서명은 이제 삭제 서명 메뉴에 표시됩니다:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_40.png" alt="Delete Signature"></p>
<p>UEFI 실행 파일 자체를 선택했을 경우, 항목 설명은 PKCS7_GUID가 아니라 SHA256_GUID가 됩니다.</p>
<p>다음으로 부팅을 시도해보세요:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_42.png" alt="부팅 시도 이미지"></p>
<h2>안전한 부팅 보안</h2>
<p>펌웨어 UI를 사용하여 서명을 등록하는 것 외에도 UEFI 런타임 서비스 함수 SetVariable()를 통해 프로그래밍 방식으로도 이를 수행할 수 있습니다. 이는 UEFI 실행 파일 및 OS 실행 파일 모두에서 호출할 수 있습니다 (Windows에서는 SetFirmwareEnvironmentVariable()로 노출됩니다). 그런데 여기서 의문이 생깁니다 - 이것이 안전한 방법인가요? Secure Boot가 활성화된 경우, 신뢰할 수 있는 UEFI 실행 파일만 실행되도록 허용되므로 서명을 수정할 수 있어야 합니다. 그러나 OS는 안전하지 않은 코드를 실행할 수 있으며, 악성 코드는 이에 대표적인 예시입니다 - 그들은 그들의 부트킷을 화이트리스트에 추가하거나 DBX에서 취약한 실행 파일을 제거할 수 있습니다. Windows는 SetFirmwareEnvironmentVariable()을 호출하는 것을 특권있는 사용자 (예: 관리자)만 허용하도록 제한하지만, 특권 상승 공격을 통해 여전히 우회될 수 있습니다. 이 때 PK와 KEK가 필요합니다.</p>
<p>Secure Boot가 설정 모드인 경우 (즉, PK가 없는 경우), 사용자는 PK가 없는 제약 없이 펌웨어 UI 또는 SetVariable()을 통해 모든 Secure Boot 키를 수정할 수 있습니다. Secure Boot가 사용자 모드로 진입하면 (즉, PK가 설치된 경우), 사용자는 Secure Boot 키를 계속 펌웨어 UI를 통해 수정할 수 있지만, SetVariable()의 경우, 펌웨어는 쓰여질 데이터가 서명되어야 한다고 요구할 것입니다. 대상 Secure Boot 키는 어떤 서명 키가 필요한지를 결정합니다:</p>
<ul>
<li>DB, DBX: PK 또는 KEK에 해당하는 개인 키로 서명</li>
<li>PK, KEK: PK에 해당하는 개인 키로 서명</li>
</ul>
<p>단일 유형의 키로 DB 및 DBX를 안전하게 보호하는 것이 충분했겠지만, Secure Boot 키의 소유권 수준을 구분하기 위해 PK와 KEK 사이에 차이를 두었습니다. PK는 컴퓨터 하드웨어의 OEM이 소유하며 컴퓨터 당 하나뿐입니다. HP 및 Dell의 경우:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_43.png" alt="Image"></p>
<p>PK의 역할은 KEK의 설치를 제어하는 것입니다. 컴퓨터 당 여러 KEK가 있을 수 있으며, 각각이 DB 및 DBX로 서명을 설치하는 데 신뢰되는 엔티티에 해당합니다. 일반적으로 OEM 및 운영 체제만 해당됩니다. HP 및 Dell의 경우:</p>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_44.png" alt="Image"></p>
<p>Windows 시스템의 경우, Microsoft의 KEK는 다음과 같습니다:</p>
<ul>
<li>Microsoft Corporation KEK CA 2011</li>
<li>Microsoft Corporation KEK 2K CA 2023</li>
</ul>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_45.png" alt="이미지"></p>
<p>2023 CA는 2026에 만료되는 2011 CA를 대체하기 위해 사용됩니다.</p>
<p>Secure Boot에 대한 자세한 내용은 UEFI 명세서 32장과 Microsoft의 Secure Boot 키 생성 및 관리 문서를 참조하세요.</p>
<h2>기본값으로 Microsoft 키</h2>
<p>웹 사이트 인증서의 경우 신뢰 여부는 Trusted Root 또는 중간 인증서에서의 체인 여부를 확인하는 것만으로 결정됩니다. 이러한 인증서는 종종 OS에 미리 설치되어 있으며 업데이트도 OS에서 처리됩니다.</p>
<p>그러나 Secure Boot와 호환되는 UEFI 실행 파일을 배포하고 싶다면, 서명 인증서를 얻기 위해 찾아갈 수 있는 CA도 없고 실행 파일에 서명할 수 있는 CA도 없습니다.</p>
<p>Windows의 부팅 관리자(UEFI 애플리케이션)는 기본적으로 세계 제조사들과 협력하여 제품을 제조하는 모든 소매용 PC와 마더보드에 Microsoft의 KEK 및 DB 키가 설치되어 있기 때문에 Secure Boot가 활성화된 상태에서 즉시 실행될 수 있습니다. 모든 사람이 마찬가지로 할 수 있는 능력을 갖고 있는 것은 아니지만, 다행히도 Microsoft는 Windows 드라이버 서명 서비스와 유사한 UEFI 서명 서비스를 제공합니다. 서명된 후에 UEFI 실행 파일은 Windows와 동일한 하드웨어 범위와 호환되는 Secure Boot가 가능해집니다.</p>
<p>이러한 협정은 마이크로소프트가 이름만 다르지 CA 등록인 Secure Boot CA인 것처럼 되어 있고, 이것이 또한 Microsoft의 키가 기본값으로 처리되는 이유이기도 합니다. 앞서 말한 KEK 외에도 Windows 시스템의 DB에는 다음과 같은 인증서가 설치되어 있습니다:</p>
<ul>
<li>Microsoft Windows Production PCA 2011</li>
<li>Windows UEFI CA 2023</li>
</ul>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_46.png" alt="image"></p>
<p>위의 두 개의 키 중 하나로 Windows 부팅 관리자가 서명되었습니다.</p>
<ul>
<li>Microsoft Corporation UEFI CA 2011</li>
<li>Microsoft UEFI CA 2023</li>
</ul>
<p><img src="/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_47.png" alt="이미지">
모든 타사 UEFI 실행 파일은 위의 두 키 중 하나로 서명됩니다.</p>
<p>EnrollDefaultKeys.efi를 실행한 후 DB에는 2011년 인증서인 두 개의 항목이 생성되었습니다. 2026년에 만료되는 2011년 인증서를 대체할 2023년 인증서가 있습니다.</p>
<p>UEFI 실행 파일을 직접 서명하는 것 외에도 Microsoft가 할 수 있는 옵션은 다음과 같습니다:</p>
<ul>
<li>Microsoft가 UEFI CA 인증서에 연결되는 인증서를 발행하고 이를 OS 업데이트를 통해 DB에 설치합니다.</li>
<li>개발자가 제출한 DB 업데이트를 Microsoft가 수락하여 원하는 서명을 설치할 수 있도록 KEK를 사용합니다.</li>
</ul>
<p>그러나 이러한 옵션들은 악의적인 사용자들이 부팅 킷을 모든 Windows 시스템에 배포하는 더 많은 길을 제공할 수 있습니다 (Microsoft에 요청을 제출할 때 합법적인 개발자로 위장하거나 신뢰할 수 있는 개발자들의 서명 키를 도난당할 수 있음). Microsoft는 분명히 제출자들을 심사하는 책임을 지기를 원하지 않으며, 시스템의 보안과 안정성에서 부팅 모듈의 중요성을 고려할 때 Microsoft에게 중요한 것은 다음을 보증하는 것입니다:</p>
<ul>
<li>해로운 저작물이 아니며 Secure Boot를 우회하는 수단을 제공하지 않습니다 (즉, 서명되지 않은 코드를 실행하지 않음)</li>
<li>Microsoft의 부팅 모듈과의 호환성 문제를 일으키지 않습니다.</li>
</ul>
<p>이것이 마이크로소프트가 실행 파일을 제출하도록 요청하는 유일한 옵션인 이유입니다.</p>
<p>이러한 규정은 마이크로소프트가 서명한 UEFI 실행 파일에서 취약점이 발견된 경우 해당 취약성을 차단하는 유일한 방법은 해당 파일의 Authenticode 해시를 DBX에 추가하는 것입니다. 마이크로소프트의 UEFI CA 인증서는 DBX에 추가할 수 없습니다. 그렇게 되면 다른 취약하지 않은 실행 파일도 차단됩니다. Windows 부팅 매니저 (BlackLotus) 및 shim/GRUB2 (Boot Hole)의 취약성으로 인해 DBX에는 수백 개의 항목이 추가되었습니다.</p>
<h2>키 사용자 정의하기</h2>
<p>더 많은 통제와 보안을 위해, 필요없는 기본 키를 제거하거나 사용자 정의 키를 설치하고 싶을 수 있습니다. UEFI 실행 파일을 Microsoft에 제출하지 않고 싶을 수도 있거나, 단순히 제출할 수 없을 수도 있습니다:</p>
<p>이 모든 것은 대상 컴퓨터의 Secure Boot 키를 사용자 정의하는 것을 의미합니다. 그러나 소매 시스템의 기본 Secure Boot 모드는 사용자 모드(예: PK가 설치됨)이므로, 이러한 변경을 수동으로 접근하는 것이 유일한 방법일 것입니다. 일부 제한된 배포에 대해서는 실행 가능하지만, 대규모 배포(예: 기업)에 대해서는 비현실적할 것입니다 — 모든 시스템을 직접 방문하거나 다시 수집하는 것은 너무 많은 시간과 노력이 필요할 것입니다. 원격으로 변경하는 것은 해당 키 업데이트가 관련 키(PK 또는 KEK)로 서명된 경우에만 가능할 것입니다. 그러나 위에서 설명했듯이, 이러한 요청을 OEM 또는 이 키를 소유한 Microsoft가 보안 문제로 인해 받아들일 가능성은 없을 것입니다.</p>
<p>대안으로 OEM이 키를 사용자 정의하거나 시스템을 전달하기 전에 PK를 제거하는 것이 가능할 수 있습니다; 그러나 이는 추가 비용이 발생하고 이미 전달된 시스템에 해당하지 않을 수 있습니다.</p>
<p>마지막으로, 기본 PK 또는 KEK를 사용자 정의로 대체한다면, 이후 OEM/Microsoft에 의한 KEK 또는 DB/DBX의 모든 업데이트는 실패할 것입니다. 따라서 해당 업데이트를 원한다면, 영향을 받는 컴퓨터에 배포되기 전에 해당 사용자 정의 PK/KEK에 해당하는 개인 키로 서명해야 합니다. 업데이트의 서명 및 설치는 앞서 언급한 signtool.exe 및 PowerShell 명령 Format-SecureBootUEFI 및 Set-SecureBootUEFI를 사용하여 수행할 수 있습니다. 이를 수행하는 방법에 대한 세부 내용은 이 가이드의 범위를 벗어납니다.</p>
<h2>실제 시스템에서 실행</h2>
<p>QEMU에서 UEFI 실행 파일을 실행하는 데 사용한 모든 방법은 실제 물리적 시스템에서도 적용됩니다. 주의해야 할 차이점은 다음과 같습니다:</p>
<ul>
<li>솔루션의 출력 디렉토리는 시스템에서 볼륨으로 마운트되지 않습니다. 따라서 실행할 실행 파일은 펌웨어에서 액세스 가능한 볼륨에 저장해야 합니다. 이는 ESP, 로컬 FAT 볼륨 또는 FAT 이동식 미디어가 될 수 있습니다.</li>
<li>BitLocker가 활성화되어 TPM을 키 보호자로 사용하도록 구성되어 있는 경우, Secure Boot를 비활성화하면 시스템이 BitLocker 복구 모드로 이동해야 할 수 있습니다. BitLocker 키를 봉인할 PCR 뱅크가 구성되어 있는 경우에는 심지어 서명된 UEFI 실행 파일이라도 BitLocker 복구 모드가 발생할 수 있습니다. 이는 이 안내서의 범위를 벗어난 이슈입니다. BitLocker 복구 키를 오프라인으로 가용하게 하고 펌웨어 설정을 변경하고 UEFI 실행 파일을 테스트하기 전에 BitLocker를 일시 중지하세요.</li>
<li>EFI 셸의 가용성은 시스템의 브랜드와 모델에 따라 다릅니다. 존재하는 경우 펌웨어 메뉴에서 액세스할 수 있어야 합니다. 없는 경우, 공식 edk2 릴리스 범위에서 다음과 같은 범위에서 얻을 수 있습니다: [edk2-stable201905, edk2-stable202002]. 이전 버전의 셸은 edk2 리포지토리의 ShellBinPkg 폴더의 일부로 커밋되었습니다. 해당 폴더는 2019년 4월 24일에 제거되었으며 내용은 릴리스 페이지로 이전되었습니다. 최신 버전의 경우 직접 빌드하거나 pbatard/UEFI-Shell과 같은 타사 소스에서 다운로드할 수 있습니다. 모든 edk2 릴리스는 서명되지 않았으며 펌웨어에 내장된 EFI 셸도 서명되지 않을 수 있으므로 이를 실행하려면 Secure Boot를 비활성화하거나 이들의 서명을 DB에 설치해야 합니다.</li>
<li>펌웨어 UI 및 사용 가능한 구성은 시스템의 브랜드와 모델에 따라 다를 수 있으므로 Secure Boot를 비활성화하고 새 부팅 및 드라이버 옵션을 추가하는 등 설정을 변경하는 단계도 다를 것입니다.</li>
</ul>
<h2>기타 주의 사항</h2>
<ul>
<li>VisualUefi 저장소는 더 이상 활발하게 유지되지 않으며 심각하게 오래되었습니다 — 동기화된 edk2 커밋은 2019년이며 openssl의 경우 2018년입니다. 누군가는 수동으로 서브모듈을 원격 최신 커밋으로 업데이트해야 하며, 그런 다음 서브모듈 소스 트리의 변경으로 인해 Visual Studio 프로젝트를 업데이트해야 합니다.</li>
<li>VisualUefi는 선택된 edk2 라이브러리만 빌드하며 모든 edk2 소스 코드를 포함하지 않습니다. 추가 라이브러리를 포함하려면 새 Visual Studio 프로젝트를 만들어야 합니다.</li>
<li>UEFI 실행 파일의 디버깅은 라이브 디버깅을 위한 디버거를 연결할 방법이 없어 어려울 수 있습니다. 콘솔에 로깅하는 것이 도움이 될 수 있지만, 대량 로깅이 있는 대규모 프로그램에는 실용적이지 않을 수 있습니다. 로그 파일에 쓰는 것도 해결책이지만, 프로그램이 실행을 완료할 때까지 로그 파일을 조사하기 전까지 기다려야 합니다. 다른 해결책으로는 UEFI 실행 파일을 가상 머신에서 실행하고 호스트에 연결된 파이프로 로깅하는 것이 있습니다. 호스트에서는 파이프의 내용을 읽고 콘솔에 인쇄하는 프로그램을 실행하여 로그를 실시간으로 검토할 수 있습니다. 이를 위해서는 VisualUefi를 수정하여 새 edk2 라이브러리를 빌드하고 edk2 소스 코드를 수정해야 합니다.</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"윈도우에서 UEFI 프로그래밍을 위한 히치하이커 안내서","description":"","date":"2024-05-27 12:32","slug":"2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows","content":"\n## 왕밍재는 Secure Boot가 활성화된 실제 시스템에 개발한 UEFI 프로그램의 전체 과정을 설명합니다. 그의 안내로 엔지니어들은 UEFI 환경의 다양한 요소를 이해하고 UEFI 프로그램의 실행과 배포에 미치는 영향을 파악할 수 있습니다. 민재는 다양한 실용적 고려 사항을 포함하여 독자들이 다양한 배포 옵션을 평가하는 데 도움을 줍니다.\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_0.png)\n\n# 소개\n\nUEFI (통합 확장 펌웨어 인터페이스) 개발은 대부분 EDK II (EFI 개발 키트 II) 리포를 사용하여 수행됩니다. EFI는 원래 BIOS를 대체하기 위해 Intel 내에서 시작된 프로젝트였습니다. 노력은 1998년 Tiano 프로젝트 내에서 시작되었으며 규격과 이를 구현하는 펌웨어로 이루어져 있습니다. 2004년, Intel은 EFI 펌웨어의 기본 코드를 오픈 소스로 공개했습니다. 2005년, 컴퓨터 산업의 주요 업체들이 UEFI 포럼을 결성하여 특정 규격을 소유하게 되었으며 2006년에 UEFI 2.0 규격을 발표했습니다. 이후 오픈 소스 코드는 EDK로 발전하고 마침내 오늘날의 EDK II로 이어졌습니다. 개발자 커뮤니티인 TianoCore는 GitHub에서 소스 코드를 유지보수합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWindows에서 UEFI 개발은 예전에는 복잡한 프로세스였습니다. 많은 수동 단계가 필요했죠. UEFI는 사용자 지정 빌드 도구 체인을 구현하며 IDE를 통한 개발을 지원하지 않습니다. 온라인에서 다양한 안내서를 찾을 수 있고 컨테이너를 사용하여 빌드 프로세스가 개선되었지만, 여전히 IDE의 편리함에는 미치지 못합니다. 게다가 UEFI 실행 파일을 설치/배포하는 방법에 대한 충분한 자료가 없으며, Secure Boot를 활성화한 상태에서 실행시키는 방법에 대한 정보는 더 드물죠.\n\n그래서 이 안내서는 이러한 공백을 메우고 UEFI 실행 파일을 배포하려는 사람들에게 도움이 되기를 희망합니다. 개인적인 용도든 제품 환경에서든 UEFI 실행 파일을 배포하려는 분들에게 도움이 될 것입니다.\n\n이 안내서를 읽는 독자들은 다음을 기본적으로 이해하고 있을 것으로 예상됩니다:\n\n- UEFI가 무엇인지\n- C 프로그래밍 언어\n- Visual Studio IDE\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 설치 및 빌드\n\n이전에 언급된 개발 도전에 직면하던 중, Windows Internals 저자 중 한 명인 Alex Ionescu는 VisualUefi를 만들어 EDK II의 소스 코드를 Visual Studio 솔루션으로 래핑하였습니다. IDE 내에서 빌드가 이루어지며, EDK II의 사용자 정의 빌드 툴 체인을 완전히 우회합니다. 사용자의 UEFI 실행 파일을 개발하기 위해서는 두 번째 솔루션을 사용합니다.\n\nVisualUefi 저장소의 지침에 따라 진행하세요.\n\n## 실행\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUEFI 실행 파일은 OS에서 직접 실행되지 않고 OS 부팅 전에 있는 UEFI 환경에서만 실행될 수 있습니다. 따라서 VisualUEFI는 QEMU와 EDK II의 OVMF (Open Virtual Machine Firmware) 모듈을 사용하여 펌웨어 실행 환경을 에뮬레이트합니다. VisualUEFI는 UEFI 실행 파일이 일반적인 명령행 실행 파일과 거의 동일하게 실행될 수 있도록 QEMU와 OVMF를 통합합니다.\n\n## EFI 셸에서 실행하기\n\n이 섹션은 VisualUEFI의 단계와 동일하며 스크린샷이 추가되었습니다.\n\n샘플 솔루션에서 Ctrl+F5를 눌러 QEMU를 실행하세요. 이렇게 하면 EFI 셸로 직접 부팅되며 여기서 샘플 UEFI 실행 파일을 실행할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Screenshot 1](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_1.png)\n\nF5를 사용해도 되지만, 이 방법은 Visual Studio 디버거를 시작하는데 이 경우에는 QEMU 또는 UEFI 실행 파일에 연결할 수 없기 때문에 쓸모가 없습니다.\n\n해결책의 빌드 출력 디렉토리 VisualUefi\\samples\\x64\\Release\\은 가상 볼륨으로 fs1:라는 레이블 아래로 탑재됩니다. 이 디렉토리의 내용을 나열하면 Windows에서 볼 수 있는 것과 동일한 파일과 폴더가 표시됩니다:\n\n![Screenshot 2](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫째로, UefiDriver.efi를 로드해주세요:\n\n`![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_3.png)`\n\n드라이버가 로드되었는지 확인하려면 devtree -b 명령을 사용하세요. -b 플래그는 출력을 한 번에 한 화면씩 표시합니다. 로딩 전후의 출력을 비교해보세요:\n\n동일한 방식으로 drivers 명령어를 사용할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어플리케이션을 실행하세요:\n\n![application](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_4.png)\n\n## 새 부팅 옵션에서 실행하기 — 어플리케이션 설치\n\n큐뮤를 실행한 후, 펌웨어 메뉴로 진입할 때까지 Esc 키를 누른 채로 유지하세요. 또는 EFI 셸에서 exit 명령을 입력하여 펌웨어 메뉴로 나갈 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Boot Maintenance Manager](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_5.png)\n\nSelect Boot Options.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_7.png)\n\nSelect Add Boot Option.\n\n![image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_8.png)\n\nSelect the first option.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image 1](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_9.png)\n\nSelect UefiApplication.efi.\n\n![image 2](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_10.png)\n\nEnter any description; this will be the display name of the new boot option. The Optional Data field specifies the arguments that are passed to the UEFI executable. Leave it blank as the sample application does not use it.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n변경 사항을 저장하고 펌웨어 메뉴 페이지로 돌아가세요. 부트 매니저 옵션을 선택하세요:\n\n![부트 매니저](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_11.png)\n\n새로 추가된 부팅 옵션이 마지막 항목으로 표시됩니다. 실행하려면 그냥 선택하면 됩니다. 응용 프로그램이 종료되면 사용자는 즉시 펌웨어 메뉴로 돌아가며 출력은 빠르게 지나갑니다. 출력을 유지하려면 응용 프로그램의 코드를 변경해야 합니다.\n\n사용자가 키를 눌러야 응용 프로그램이 돌아올 때까지 기다리도록 하는 방법이 있습니다. 이는 edk2\\MdeModulePkg\\Library\\CustomizedDisplayLib\\CustomizedDisplayLibInternal.c의 WaitForKeyStroke 함수를 사용하여 달성할 수 있습니다. 그러나 EDK-II 솔루션에 이 라이브러리가 포함되어 있지 않아 사용할 수 없습니다. Visual Studio 프로젝트를 만들어 새 라이브러리를 빌드하는 것은 본 안내서의 범위를 넘어서므로 지금은 응용 프로그램에 코드를 복제하는 것만으로 충분합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nEFI_STATUS\nWaitForKeyStroke(\n    OUT  EFI_INPUT_KEY* Key\n)\n{\n    EFI_STATUS  Status;\n    UINTN       Index;\n    while (TRUE) {\n        Status = gST-\u003eConIn-\u003eReadKeyStroke(gST-\u003eConIn, Key);\n        if (!EFI_ERROR(Status)) {\n            break;\n        }\n        if (Status != EFI_NOT_READY) {\n            continue;\n        }\n        gBS-\u003eWaitForEvent(1, \u0026gST-\u003eConIn-\u003eWaitForKey, \u0026Index);\n    }\n    return Status;\n}\n\n\n호출하는 코드:\n\n\nPrint(L\"Press any key to continue...\\n\");\nEFI_INPUT_KEY keyInput;\nefiStatus = WaitForKeyStroke(\u0026keyInput);\nif (EFI_ERROR(efiStatus))\n{\n    Print(L\"Failed to get keystroke: %lx\\n\", efiStatus);\n    goto Exit;\n}\n\n\n주의할 점: 샘플 응용 프로그램의 코드에 3가지 문제가 있습니다:\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 94번 라인:\n\n```js\nefiStatus = ShellInitialize();\n```\n\n이 코드는 EFI 셸에서만 작동합니다. 셸 대신에 우리 애플리케이션을 먼저 실행하고 있기 때문에 ShellInitialize() 호출이 실패할 것입니다.\n\n- 104번 라인:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nefiStatus = ShellOpenFileByName(L\"fs1:\\\\UefiApplication.efi\",\n```\n\n볼륨 레이블 fs1:이 항상 사용 가능하고 실행 파일이 항상 거기에 저장되어 있다고 가정합니다. 그러나 볼륨 레이블을 할당하는 것은 EFI 셸의 역할이므로 EFI 셸이 없으면 fs1:이 없어지고 ShellOpenFileByName()은 실패할 것입니다.\n\n- 134번째 줄:\n\n```js\nefiStatus = gBS-\u003eLocateProtocol(\u0026gEfiSampleDriverProtocolGuid, NULL, \u0026sampleProtocol);\n```\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n샘플 드라이버에 액세스하려고 시도되었지만, 아직 드라이버를 설치하지 않았기 때문에 이 작업도 실패합니다.\n\n코드는 항상 실패 시에 항상 \"Exit;\"으로 이동하므로 사용자의 키 입력을 읽는 코드를 제일 위에 삽입해야 실행이 보장됩니다.\n\n부트 매니저 UI를 항상 입력해야 하는 것을 피하기 위해 부팅 순서를 EFI 셸 대신 새로운 옵션을 먼저 부팅하도록 변경할 수 있습니다. 그러려면, Boot Maintenance Manager ` Boot Options ` Change Boot Order로 이동하십시오:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_12.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 경우에는 애플리케이션이 펌웨어 메뉴 대신 EFI 셸로 종료됩니다. 부팅할 때 부팅 옵션이 EFI_SUCCESS를 반환하면 제어가 펌웨어 메뉴로 돌아가고, 그렇지 않으면 다음 부팅 옵션이 실행되며, 모든 부팅 옵션이 시도될 때까지 EFI_SUCCESS를 반환하거나 모든 부팅 옵션이 소진됩니다(UFI 사양서 섹션 3.1.1 참조). 위에서 언급한 3가지 문제로 인해 애플리케이션은 EFI_SUCCESS를 반환하지 않으므로 펌웨어는 다음 옵션인 UEFI 셸을 실행합니다.\n\n위의 부팅 옵션 처리에 대한 예외 사항은 애플리케이션이 ExitBootServices()를 호출하는 경우에 있습니다. 그러나 이 내용은 이 안내서의 범위를 벗어납니다.\n\n## 새 부팅 옵션에서 실행 - 드라이버 설치\n\n부팅 유지 관리자 페이지에서 드라이버 옵션을 선택하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_13.png)\n\nAdd Driver 옵션을 선택하세요.\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_14.png)\n\n파일을 사용하여 Add Driver 옵션을 선택하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\n![image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_15.png)\n\nSelect the first option.\n\n![image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_16.png)\n\nSelect UefiDriver.efi.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_17.png)\n\n어떤 설명을 입력하세요; 이는 새 드라이버 옵션의 표시 이름이 될 것입니다. 옵션 데이터 필드는 UEFI 실행 파일에 전달되는 인수를 지정합니다. 샘플 드라이버가 사용하지 않기 때문에 비워 두세요.\n\n로드 옵션 Reconnect 필드는 펌웨어 부팅 관리자 실행 전에로드된 모든 드라이버를 무시하도록 드라이버에게 허용합니다 (UEFI 사양 섹션 3.1.3 참조). devtree 및 drivers 명령의 출력을 상기하세요 - 샘플 드라이버를 제외한 모든 항목은 펌웨어와 함께 제공된 드라이버이며 펌웨어 부팅 관리자 실행 전에 로드되었습니다. 호환성 문제가 발생할 수 있으므로 장치는 하나의 드라이버로 관리되어야 합니다. 샘플 드라이버는 기존 드라이버를 무시하지 않으므로 옵션을 활성화하는 것은 필요하지 않으며 순수한 효과가 없을 것입니다. 이 페이지를 저장하고 나가세요.\n\n펌웨어 부팅 관리자는 부팅 시 부트와 드라이버 옵션을 자동으로 실행하는 펌웨어 구성 요소를 가리킵니다; 사용자가 수동으로 실행할 부트 옵션을 선택하는 부팅 관리자 UI와 혼동하면 안 됩니다. 또한 드라이버 오버라이드를 적용하려면 마지막 드라이버 옵션이 처리된 후 모든 UEFI 드라이버가 시스템에서 연결 해제되고 다시 연결되어야 합니다.\n\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n펌웨어 부트 매니저는 부팅 옵션을 처리하기 전에 모든 드라이버 옵션을 자동으로 처리합니다. 그러므로 부팅 옵션과는 달리 펌웨어 메뉴는 명시적으로 특정 드라이버 옵션을 로드할 수 있는 방법을 제공하지 않습니다. 또한 필요하지 않습니다. 설치된 모든 드라이버 옵션이 로드됩니다.\n\n## EFI 쉘을 통한 수동 설치\n\n펌웨어 메뉴를 사용하는 것 외에도, EFI 쉘에서 bcfg 명령을 사용하여 새로운 부팅 및 드라이버 옵션을 설치할 수 있습니다. 자세한 내용은 도움말 bcfg의 결과를 확인하세요.\n\n펌웨어가 새로운 부팅 옵션 및/또는 드라이버 옵션을 추가할 수 있는 능력을 제공하지 않는 시스템에서 유용합니다. 이는 UEFI 사양 섹션 3에서 정의된 메커니즘 (NVRAM 변수, UEFI 변수로도 불리는)에 따라 옵션이 구현된 방식 때문입니다. 즉, 모든 UEFI 호환 펌웨어는 설명된 방식으로 옵션을 구현하고 처리해야합니다. bcfg는 동일한 메커니즘으로 작동하기 때문에, 펌웨어가 명시적으로 이를 지원하지 않더라도 옵션을 수정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사실 NVRAM 변수를 직접 수정하여 부팅 및 드라이버 옵션을 설치하거나 수정할 수 있습니다. 그러나 이것은 이 안내서의 범위를 벗어납니다.\n\n## 기존 부팅 옵션에서 실행\n\n부팅 매니저 페이지에서 샘플 애플리케이션 옵션의 장치 경로 설명을 볼 수 있습니다. 그러나 EFI 셸 옵션에는 실행 파일의 이름이 누락되어 있을 수 있습니다:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_18.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n해당 옵션의 Device Path(UEFI 셸에서 fs0: 볼륨 레이블로 할당)로 가리키는 파티션 내용을 나열하면 EnrollDefaultKeys.efi라는 유일한 UEFI 실행 파일만 있는 것을 알 수 있습니다. 이것이 EFI 셸처럼 들리지 않는 것이 분명합니다.\n\n이것이 일어나는 것은 펌웨어 부트 관리자가 모든 탈착 가능 미디어 및 고정 미디어 장치를 열거하고, 각 장치에 대한 부팅 옵션을 만드는 것입니다(UEFI 사양 섹션 13.3에 자세히 설명된 것처럼, 파일 시스템이 FAT인 경우). 이러한 항목을 부팅할 때 펌웨어가 장치 경로에 다음을 추가합니다: \\EFI\\BOOT\\BOOT'machine type short-name'.EFI 여기서 machine type short-name은 PE32+ 이미지 형식 아키텍처를 정의합니다. 가능한 값은:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPE(Portable Executable) 실행 파일 머신 유형은 Microsoft Portable Executable and Common Object File Format Specification, Revision 6.0에서 정의된 COFF 파일 헤더의 machine 필드에 지정됩니다.\n\n여러 CPU 아키텍처를 지원하기 위해 장치는 \\EFI\\BOOT\\ 하위 디렉터리에 서로 다른 아키텍처용으로 구축된 여러 실행 파일을 저장할 수 있습니다. 자세한 내용은 UEFI 명세의 섹션 3.1.2 및 3.5를 참조하십시오.\n\n따라서 fs0: 내의 모든 .efi를 나열하면 FS0:\\efi\\boot\\ 내에 bootx64.efi가 나타납니다. 이것이 EFI 셸입니다:\n\n![EFI Shell](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_21.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n따라서 샘플 애플리케이션에 대해 동일한 방법을 적용할 수 있습니다. VisualUefi\\samples\\x64\\Release\\ 하위에 \\EFI\\BOOT\\ 하위 디렉토리를 만들고 샘플 애플리케이션을 복사하여 BOOTx64.efi로 이름을 바꿉니다. 실행하려면 부트 매니저 UI에서 기존 UEFI Misc 장치 옵션을 선택하면 됩니다. 또는 부팅 옵션을 재정렬하여 QEMU가 먼저 부팅하도록 할 수도 있습니다.\n\n이 접근 방식은 UEFI가 탈착식 미디어에서 부팅하는 방법을 지원하는 방식입니다. 예를 들어 Windows 설치 플래시 드라이브를 만들 때 설치 프로그램 실행 파일을 \\EFI\\BOOT\\BOOTx64.efi에 저장합니다. 설치하려면 펌웨어 메뉴에 들어가서 플래시 드라이브에서 부팅 옵션을 선택합니다. 또는 이미 플래시 드라이브를 첫 번째 부팅 옵션으로 구성했다면 시스템은 자동으로 설치 프로그램으로 부팅합니다.\n\n## EFI 셸\n\n셸은 본질적으로 UEFI 펌웨어의 명령 프롬프트 / bash 셸 버전입니다. bash와 동일한 명령어를 지원하며 모든 지원되는 명령을 나열하려면 help 명령을 사용하면 됩니다. 이를 통해 사용자는 OS에 부팅하지 않고 시스템의 파일에 접근하거나 수정할 수 있습니다. UEFI 펌웨어는 기본적으로 FAT 파일 시스템만 지원하므로 셸이 액세스할 수 있는 파일 시스템도 FAT 파일 시스템뿐입니다. 다른 파일 시스템의 지원은 관련 UEFI 드라이버가 설치되고 로드되어 있는지에 따라 달라집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nstartup.nsh\n쉘을 실행하면 다음과 같은 프롬프트가 나타납니다:\n\n```js\nPress ESC in 5 seconds to skip startup.nsh, any other key to continue.\n```\n\n셸은 실행할 때마다 startup.nsh를 실행합니다. 셸을 첫 번째 부팅 옵션으로 구성하면(이미 QEMU의 기본값으로 설정되어 있음), 이를 통해 OS에 부팅하지 않고 시스템에서 자동으로 스크립트 작업을 실행할 수 있습니다.\n\n기본적으로 스크립트 파일이 없지만 ESP(EFI 시스템 파티션)의 루트 디렉터리에 직접 만들 수 있습니다. 시험해보려면 셸에서 다음 명령을 입력하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```md\necho \"@echo test startup script\" \u003e fs0:\\startup.nsh\n```\n\n여기서 ESP의 볼륨 라벨인 fs0:에 스크립트 파일을 만들었어요.\n\nexit 명령어로 셸을 종료하고 다시 실행하세요:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_22.png)\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## EFI 시스템 파티션 (ESP)\n\n이것은 UEFI 사양에 의해 정의된 특수 파티션이며 UEFI 펌웨어에서 액세스할 수 있습니다. 이것이 무엇인지 궁금하다면, 파티션에 액세스하는 것은 기본 작업이므로 이것이 운영 체제에만 해당되었다는 것을 알아두세요. UEFI가 대체하는 BIOS는 디스크의 전체 파티션에 액세스할 수 없었습니다. BIOS가 디스크에서 액세스 할 수 있는 유일한 요소는 MBR (마스터 부트 레코드) 및 VBR (볼륨 부트 레코드)였는데, 이들은 UEFI에 의해 대체되었습니다.\n\nESP에는 일반적으로 OS 부트로더 및 / 또는 부트 매니저가 위치합니다. Windows에서는 이 파티션은 디스크 관리.msc에서 볼 수 있듯이 기본적으로 드라이브 문자가 할당되지 않으므로 직접 액세스 할 수 없습니다:\n\n![파티션 예시](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_23.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n접근하려면 고정된 명령 프롬프트를 열고 명령 mountvol X: /S를 사용하여 드라이브 문자를 할당하십시오. 여기서 X는 사용되지 않는 드라이브 문자입니다.\n\nWindows 부트 매니저의 위치를 확인하려면:\n\n```js\nX:\\\u003edir /b/s *.efi\nX:\\EFI\\Microsoft\\Boot\\bootmgr.efi\nX:\\EFI\\Microsoft\\Boot\\memtest.efi\nX:\\EFI\\Microsoft\\Boot\\bootmgfw.efi\nX:\\EFI\\Microsoft\\Boot\\SecureBootRecovery.efi\nX:\\EFI\\Boot\\bootx64.efi\n```\n\nbootmgfw.efi가 Windows 부팅 매니저입니다. 또한 EFI\\Boot\\bootx64.efi 항목에 주목하세요. 이것은 bootmgfw.efi의 사본이며, bootmgfw.efi가 없거나 손상된 경우 대비 용도로 제공됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Secure Boot\n\n지금까지 모든 UEFI 실행 파일은 Secure Boot가 비활성화된 상태로 실행되었습니다. Secure Boot는 UEFI 펌웨어의 보안 기능으로 신뢰할 수 있는 UEFI 실행 파일만을 실행할 수 있게 합니다. 이를 통해 시스템이 악성 UEFI 실행 파일(예: 부트킷)로부터 안전하게 보호되며, 제품 환경에서 항상 활성화되어야 합니다. 신뢰는 실행 파일의 서명이 승인된 서명 데이터베이스에 있고 금지된 서명 데이터베이스에 없는 것으로 정의됩니다. 서명은 다음 중 하나로 정의됩니다:\n\n- 실행 파일의 SHA-1 Authenticode 해시\n- 실행 파일의 SHA-256 Authenticode 해시\n- 실행 파일의 SHA-224 Authenticode 해시\n- 실행 파일의 SHA-384 Authenticode 해시\n- 실행 파일의 SHA-512 Authenticode 해시\n- 실행 파일의 SHA-256 Authenticode 해시에 대한 RSA-2048 서명\n- 실행 파일의 SHA-1 Authenticode 해시에 대한 RSA-2048 서명\n- 실행 파일을 서명한 RSA-2048 키의 모듈러스 (공개 키 지수는 0x10001로 가정)\n- 실행 파일을 서명한 키의 DER로 인코딩된 X.509 인증서\n- 타임스탬프를 포함하는 더 복잡한 것들\n\nAuthenticode 해시가 어떻게 계산되는지에 대한 정보는 Windows Authenticode Portable Executable Signature Format에서 \"PE 이미지 해시 계산\" 섹션을 참조하십시오. X.509 인증서의 경우에는 UEFI 사양 섹션 8.2.6 및 32.6.3.3에 따라 실행 파일의 서명 인증서가 X.509 인증서 체인의 모든 수준에 존재하는 한 일치가 발견됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n따라서 샘플 실행 파일이 안전 부팅이 활성화된 상태에서 실행되도록 하려면 이 중 하나의 서명을 안전 부팅 승인된 데이터베이스로 가져와야 합니다. 인증서를 사용하는 것이 더 유연한 옵션이며 해당 개인 키로 서명된 모든 실행 파일을 실행할 수 있습니다. 이로 인해 개발 및 테스트 중에 유용한 반복적인 수정 및 실행 파일 재구축이 가능해집니다. 그러나 해시를 사용하는 것보다 안전하지 않습니다. 왜냐하면 개인 키 침해의 위험이 있기 때문입니다.\n\n서명을 설치하려면 펌웨어 메뉴로 이동하십시오:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_24.png)\n\n장치 관리자를 선택하십시오.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_25.png)\n\nSelect Secure Boot Configuration.\n\n![Image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_26.png)\n\nThe Current Secure Boot State is set to Disabled. This entry is not configurable and is only meant to display the current state. The Attempt Secure Boot option itself is disabled (explained later), and the only option that can be changed is Secure Boot Mode. Change this from Standard Mode and Custom Mode which is the only other option available:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003ctd\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_27.png\" /\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\n친구 안전 부팅 옵션을 선택하십시오.\n\n\u003ctable\u003e\n  \u003ctr\u003e\n    \u003ctd\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_28.png\" /\u003e\u003c/td\u003e\n  \u003c/tr\u003e\n\u003c/table\u003e\n\n다섯 가지 옵션 각각이 안전 부팅 키 유형에 해당합니다. DB는 승인된 서명 데이터베이스이며 DBX는 금지된 서명 데이터베이스입니다. UEFI 명세서에서 \"키\"라는 용어를 사용하고 있지만, 각 유형의 \"키\"에 저장된 항목은 실제로 앞서 언급한 유형의 서명 중 하나입니다. 명세서를 따라서 \"키\"를 일반적인 서명을 가리키는 용어로 사용하겠습니다. 각 항목을 살펴보면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새 키를 등록하거나 기존 키를 삭제할 수 있는 옵션을 볼 수 있습니다. 기존 키 목록을 표시할 옵션은 없지만 삭제 옵션을 사용하여 삭제할 수 있습니다. 이렇게 하면 모든 키가 비어 있는 것을 확인할 수 있습니다. 이것이 안전 부팅을 활성화할 수 없는 이유입니다 — 안전 부팅을 활성화하려면 PK(플랫폼 키)가 있어야 합니다. 우리는 직접 하나 만들 수 있지만, 앞서 EnrollDefaultKeys.efi를 본 것을 기억해보세요.\n\n## 기본 안전 부팅 키 설치\n\n기본 안전 부팅 키를 설치하려면 EFI 셸에서 EnrollDefaultKeys.efi를 실행하십시오. 이 작업은 모든 기존 키를 덮어씁니다:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_29.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSecure Boot은 PK가 없는 경우 설정 모드에 있습니다. PK를 설치하면 자동으로 Secure Boot가 사용자 모드로 전환됩니다 (UEFI 사양 섹션 32.3 참조, 이에 대해 나중에 자세히 논의할 예정입니다).\n\n셸을 종료하고 다시 Secure Boot 구성을 확인하십시오:\n\n![Secure Boot Configuration](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_30.png)\n\n이제 Secure Boot가 활성화되고 \"Attempt Secure Boot\" 옵션이 활성화되어 설정되어 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n안녕하세요! 다시 Secure Boot Mode를 Custom으로 변경하고 키를 나열해 보겠습니다:\n\n- PK: 이전에 활성화되었던 Enroll PK 옵션이 이제 비활성화되었습니다. 시스템에는 하나의 PK만 있을 수 있기 때문에 그렇습니다.\n- KEK: GUID로 명명된 두 항목이 있습니다. 모든 Secure Boot 키는 키의 소유자를 나타내는 SignatureOwner GUID와 연결됩니다:\n  - d5c1df0b-1bac-4edf-ba48-08834009ca5a: 이 소유자는 알 수 없습니다.\n  - 77fa9abd-0359-4d32-bd60-28f4e78f784b: 이것은 Microsoft입니다 (나중에 설명될 것입니다).\n- DB: Microsoft에 속한 두 항목이 있습니다 (나중에 설명될 것입니다).\n- DBX: 여기서 키는 유형에 따라 목록으로 그룹화됩니다. 유형이 SHA256인 목록만 한 개 존재합니다. Secure Boot 키의 모든 유형은 유형별 목록에 저장되는데, 이 펌웨어에서는 이 정보를 DBX에 대해서만 보여주기로 결정했습니다. 목록을 선택하면:\n\n  ![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_31.png)\n\n  KEK에 있는 알 수 없는 GUID와 같은 GUID가 나오며, 해시 E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855는 비어 있는 파일의 해시입니다. 이는 아마도 예제로 제공된 것일 것입니다. 최신 시스템에서는 DBX에 알려진 취약한 UEFI 실행 파일의 항목이 포함됩니다. 이러한 실행 파일 및 DBX를 업데이트하기 위한 이진 blob의 목록은 UEFI Forum에서 관리됩니다. Microsoft는 GitHub repo에서 이 목록의 미러를 유지합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DBT: 여전히 비어 있습니다.\n\n이제 부팅을 시도해 봅시다:\n\n![부팅 이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_32.png)\n\nEFI 쉘 또는 샘플 응용 프로그램은 서명되지 않았으며, 그 서명 또한 DB에 없기 때문에 이는 예상대로입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# EFI 서명 인증서 생성\n\n샘플 애플리케이션을 서명하기 위해 먼저 인증서를 생성할 것입니다. Windows SDK에 포함된 명령줄 도구를 사용할 것입니다. 이 도구들은 %programfiles(x86)%\\Windows Kits\\10\\bin\\10.0.22621.0\\x64\\에 위치해 있습니다. 설치된 SDK 버전에 따라 하위 디렉토리의 이름이 다를 수 있습니다.\n\n먼저, 다음 명령을 명령 프롬프트에서 사용하여 개인 키와 해당 인증서를 생성해 보세요:\n\n```js\nMakeCert.exe -a sha256 -n \"CN=SampleEfiSigner\" -r -sv SampleEfiSigner.pvk SampleEfiSigner.cer\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n출력 파일은 DER 인코딩된 X.509 형식으로 제공되며, 이는 지원되는 DB 서명 유형 중 하나입니다.\n\n옵션에 대한 설명:\n\n- -a 서명의 다이제스트 알고리즘(기본값은 SHA1)\n- -n 인증서 소유자 X509 이름\n- -r 자체 서명된 인증서 생성\n- -sv 서브젝트의 PVK 파일, 존재하지 않는 경우 생성됩니다.\n\n이 명령은 비공개 키 파일을 사용할 비밀번호를 요청하는 팝업 프롬프트를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_33.png)\n\n다음으로 임의의 암호를 설정하고 확인을 누르세요.\n\n이렇게 하면 이전 단계에서 설정한 암호를 요청하는 두 번째 프롬프트가 생성됩니다. 이는 자체 서명 작업을 위한 것입니다:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_34.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMakeCert 명령어의 결과는 다음과 같아야 합니다:\n\n```js\nSucceeded;\n```\n\n그런 다음 .pvk 파일을 .pfx로 변환하여 signtool에서 UEFI 실행 파일에 서명할 수 있도록 합니다:\n\n```js\npvk2pfx.exe -pvk SampleEfiSigner.pvk -pi \u003cpassword\u003e -spc SampleEfiSigner.cer -pfx SampleEfiSigner.pfx\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`password`를 개인 키 파일의 비밀번호로 바꾸세요. 이 명령은 출력물이 없습니다.\n\n옵션 설명:\n\n- -pvk 입력 PVK 파일 이름\n- -pi PVK 파일의 비밀번호\n- -spc 입력 SPC 파일 이름\n- -pfx 출력 PFX 파일 이름\n\n## UEFI 실행 파일에 서명하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 도구와 동일한 디렉토리에 있는 signtool을 사용해보세요:\n\n```js\nsigntool.exe sign /fd sha256 /ac SampleEfiSigner.cer /f SampleEfiSigner.pfx /p \u003c비밀번호\u003e \u003c서명할 efi 파일\u003e\n```\n\n`비밀번호`를 개인 키 파일의 비밀번호로 대체하세요. `서명할 efi 파일`은 대상 파일 이름으로 대체하세요. 이 명령은 다음을 출력해야 합니다:\n\n```js\nDone Adding Additional Store\nSuccessfully signed: \u003cefiToSign\u003e\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n옵션 설명:\n\n- /fd 파일 서명에 사용할 파일 다이제스트 알고리즘 (기본값은 SHA1)\n- /ac 서명 블록에 추가 인증서 추가\n- /f 서명 인증서의 파일. 파일에 개인 키가 없는 경우 \"/csp\" 및 \"/kc\"를 사용하십시오.\n- /p PFX 파일의 암호\n\n파일의 속성 창을 열어 서명되었는지 확인하세요. 새로운 디지털 서명 탭이 있어야 합니다:\n\n![서명 확인](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_35.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## DB에 인증서 설치하기\n\nSampleEfiSigner.cer 파일을 VisualUefi\\samples\\x64\\Release\\ 폴더로 이동하세요. 우리는 이후 펌웨어 메뉴에서 이 파일에 접근해야 합니다. 펌웨어 메뉴에서 DB 옵션으로 이동하고 Enroll Signature를 선택하세요:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_36.png)\n\nSelect Enroll Signature Using File.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_37.png\" /\u003e\n\n첫 번째 옵션을 선택하세요.\n\n\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_38.png\" /\u003e\n\nSampleEfiSigner.cer를 선택하세요. 여기서 펌웨어는 DER로 인코딩된 X.509 인증서와 UEFI 실행 파일만 지원합니다. 후자의 경우 실행 파일의 SHA-256 Authenticode 해시를 계산하여 서명으로 저장할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUI가 등록 서명 페이지로 돌아갑니다. 서명 GUID 필드는 서명 소유자의 서명과 일치합니다. 임의의 값 입력하거나 기본값으로 모든 0의 GUID로 남겨 둡니다:\n\n![Enroll Signature](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_39.png)\n\n서명은 이제 삭제 서명 메뉴에 표시됩니다:\n\n![Delete Signature](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_40.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nUEFI 실행 파일 자체를 선택했을 경우, 항목 설명은 PKCS7_GUID가 아니라 SHA256_GUID가 됩니다.\n\n다음으로 부팅을 시도해보세요:\n\n![부팅 시도 이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_42.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 안전한 부팅 보안\n\n펌웨어 UI를 사용하여 서명을 등록하는 것 외에도 UEFI 런타임 서비스 함수 SetVariable()를 통해 프로그래밍 방식으로도 이를 수행할 수 있습니다. 이는 UEFI 실행 파일 및 OS 실행 파일 모두에서 호출할 수 있습니다 (Windows에서는 SetFirmwareEnvironmentVariable()로 노출됩니다). 그런데 여기서 의문이 생깁니다 - 이것이 안전한 방법인가요? Secure Boot가 활성화된 경우, 신뢰할 수 있는 UEFI 실행 파일만 실행되도록 허용되므로 서명을 수정할 수 있어야 합니다. 그러나 OS는 안전하지 않은 코드를 실행할 수 있으며, 악성 코드는 이에 대표적인 예시입니다 - 그들은 그들의 부트킷을 화이트리스트에 추가하거나 DBX에서 취약한 실행 파일을 제거할 수 있습니다. Windows는 SetFirmwareEnvironmentVariable()을 호출하는 것을 특권있는 사용자 (예: 관리자)만 허용하도록 제한하지만, 특권 상승 공격을 통해 여전히 우회될 수 있습니다. 이 때 PK와 KEK가 필요합니다.\n\nSecure Boot가 설정 모드인 경우 (즉, PK가 없는 경우), 사용자는 PK가 없는 제약 없이 펌웨어 UI 또는 SetVariable()을 통해 모든 Secure Boot 키를 수정할 수 있습니다. Secure Boot가 사용자 모드로 진입하면 (즉, PK가 설치된 경우), 사용자는 Secure Boot 키를 계속 펌웨어 UI를 통해 수정할 수 있지만, SetVariable()의 경우, 펌웨어는 쓰여질 데이터가 서명되어야 한다고 요구할 것입니다. 대상 Secure Boot 키는 어떤 서명 키가 필요한지를 결정합니다:\n\n- DB, DBX: PK 또는 KEK에 해당하는 개인 키로 서명\n- PK, KEK: PK에 해당하는 개인 키로 서명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단일 유형의 키로 DB 및 DBX를 안전하게 보호하는 것이 충분했겠지만, Secure Boot 키의 소유권 수준을 구분하기 위해 PK와 KEK 사이에 차이를 두었습니다. PK는 컴퓨터 하드웨어의 OEM이 소유하며 컴퓨터 당 하나뿐입니다. HP 및 Dell의 경우:\n\n![Image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_43.png)\n\nPK의 역할은 KEK의 설치를 제어하는 것입니다. 컴퓨터 당 여러 KEK가 있을 수 있으며, 각각이 DB 및 DBX로 서명을 설치하는 데 신뢰되는 엔티티에 해당합니다. 일반적으로 OEM 및 운영 체제만 해당됩니다. HP 및 Dell의 경우:\n\n![Image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_44.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWindows 시스템의 경우, Microsoft의 KEK는 다음과 같습니다:\n\n- Microsoft Corporation KEK CA 2011\n- Microsoft Corporation KEK 2K CA 2023\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_45.png)\n\n2023 CA는 2026에 만료되는 2011 CA를 대체하기 위해 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSecure Boot에 대한 자세한 내용은 UEFI 명세서 32장과 Microsoft의 Secure Boot 키 생성 및 관리 문서를 참조하세요.\n\n## 기본값으로 Microsoft 키\n\n웹 사이트 인증서의 경우 신뢰 여부는 Trusted Root 또는 중간 인증서에서의 체인 여부를 확인하는 것만으로 결정됩니다. 이러한 인증서는 종종 OS에 미리 설치되어 있으며 업데이트도 OS에서 처리됩니다.\n\n그러나 Secure Boot와 호환되는 UEFI 실행 파일을 배포하고 싶다면, 서명 인증서를 얻기 위해 찾아갈 수 있는 CA도 없고 실행 파일에 서명할 수 있는 CA도 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWindows의 부팅 관리자(UEFI 애플리케이션)는 기본적으로 세계 제조사들과 협력하여 제품을 제조하는 모든 소매용 PC와 마더보드에 Microsoft의 KEK 및 DB 키가 설치되어 있기 때문에 Secure Boot가 활성화된 상태에서 즉시 실행될 수 있습니다. 모든 사람이 마찬가지로 할 수 있는 능력을 갖고 있는 것은 아니지만, 다행히도 Microsoft는 Windows 드라이버 서명 서비스와 유사한 UEFI 서명 서비스를 제공합니다. 서명된 후에 UEFI 실행 파일은 Windows와 동일한 하드웨어 범위와 호환되는 Secure Boot가 가능해집니다.\n\n이러한 협정은 마이크로소프트가 이름만 다르지 CA 등록인 Secure Boot CA인 것처럼 되어 있고, 이것이 또한 Microsoft의 키가 기본값으로 처리되는 이유이기도 합니다. 앞서 말한 KEK 외에도 Windows 시스템의 DB에는 다음과 같은 인증서가 설치되어 있습니다:\n\n- Microsoft Windows Production PCA 2011\n- Windows UEFI CA 2023\n\n![image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_46.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 두 개의 키 중 하나로 Windows 부팅 관리자가 서명되었습니다.\n\n- Microsoft Corporation UEFI CA 2011\n- Microsoft UEFI CA 2023\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_47.png)\n모든 타사 UEFI 실행 파일은 위의 두 키 중 하나로 서명됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nEnrollDefaultKeys.efi를 실행한 후 DB에는 2011년 인증서인 두 개의 항목이 생성되었습니다. 2026년에 만료되는 2011년 인증서를 대체할 2023년 인증서가 있습니다.\n\nUEFI 실행 파일을 직접 서명하는 것 외에도 Microsoft가 할 수 있는 옵션은 다음과 같습니다:\n\n- Microsoft가 UEFI CA 인증서에 연결되는 인증서를 발행하고 이를 OS 업데이트를 통해 DB에 설치합니다.\n- 개발자가 제출한 DB 업데이트를 Microsoft가 수락하여 원하는 서명을 설치할 수 있도록 KEK를 사용합니다.\n\n그러나 이러한 옵션들은 악의적인 사용자들이 부팅 킷을 모든 Windows 시스템에 배포하는 더 많은 길을 제공할 수 있습니다 (Microsoft에 요청을 제출할 때 합법적인 개발자로 위장하거나 신뢰할 수 있는 개발자들의 서명 키를 도난당할 수 있음). Microsoft는 분명히 제출자들을 심사하는 책임을 지기를 원하지 않으며, 시스템의 보안과 안정성에서 부팅 모듈의 중요성을 고려할 때 Microsoft에게 중요한 것은 다음을 보증하는 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 해로운 저작물이 아니며 Secure Boot를 우회하는 수단을 제공하지 않습니다 (즉, 서명되지 않은 코드를 실행하지 않음)\n- Microsoft의 부팅 모듈과의 호환성 문제를 일으키지 않습니다.\n\n이것이 마이크로소프트가 실행 파일을 제출하도록 요청하는 유일한 옵션인 이유입니다.\n\n이러한 규정은 마이크로소프트가 서명한 UEFI 실행 파일에서 취약점이 발견된 경우 해당 취약성을 차단하는 유일한 방법은 해당 파일의 Authenticode 해시를 DBX에 추가하는 것입니다. 마이크로소프트의 UEFI CA 인증서는 DBX에 추가할 수 없습니다. 그렇게 되면 다른 취약하지 않은 실행 파일도 차단됩니다. Windows 부팅 매니저 (BlackLotus) 및 shim/GRUB2 (Boot Hole)의 취약성으로 인해 DBX에는 수백 개의 항목이 추가되었습니다.\n\n## 키 사용자 정의하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n더 많은 통제와 보안을 위해, 필요없는 기본 키를 제거하거나 사용자 정의 키를 설치하고 싶을 수 있습니다. UEFI 실행 파일을 Microsoft에 제출하지 않고 싶을 수도 있거나, 단순히 제출할 수 없을 수도 있습니다:\n\n이 모든 것은 대상 컴퓨터의 Secure Boot 키를 사용자 정의하는 것을 의미합니다. 그러나 소매 시스템의 기본 Secure Boot 모드는 사용자 모드(예: PK가 설치됨)이므로, 이러한 변경을 수동으로 접근하는 것이 유일한 방법일 것입니다. 일부 제한된 배포에 대해서는 실행 가능하지만, 대규모 배포(예: 기업)에 대해서는 비현실적할 것입니다 — 모든 시스템을 직접 방문하거나 다시 수집하는 것은 너무 많은 시간과 노력이 필요할 것입니다. 원격으로 변경하는 것은 해당 키 업데이트가 관련 키(PK 또는 KEK)로 서명된 경우에만 가능할 것입니다. 그러나 위에서 설명했듯이, 이러한 요청을 OEM 또는 이 키를 소유한 Microsoft가 보안 문제로 인해 받아들일 가능성은 없을 것입니다.\n\n대안으로 OEM이 키를 사용자 정의하거나 시스템을 전달하기 전에 PK를 제거하는 것이 가능할 수 있습니다; 그러나 이는 추가 비용이 발생하고 이미 전달된 시스템에 해당하지 않을 수 있습니다.\n\n마지막으로, 기본 PK 또는 KEK를 사용자 정의로 대체한다면, 이후 OEM/Microsoft에 의한 KEK 또는 DB/DBX의 모든 업데이트는 실패할 것입니다. 따라서 해당 업데이트를 원한다면, 영향을 받는 컴퓨터에 배포되기 전에 해당 사용자 정의 PK/KEK에 해당하는 개인 키로 서명해야 합니다. 업데이트의 서명 및 설치는 앞서 언급한 signtool.exe 및 PowerShell 명령 Format-SecureBootUEFI 및 Set-SecureBootUEFI를 사용하여 수행할 수 있습니다. 이를 수행하는 방법에 대한 세부 내용은 이 가이드의 범위를 벗어납니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 실제 시스템에서 실행\n\nQEMU에서 UEFI 실행 파일을 실행하는 데 사용한 모든 방법은 실제 물리적 시스템에서도 적용됩니다. 주의해야 할 차이점은 다음과 같습니다:\n\n- 솔루션의 출력 디렉토리는 시스템에서 볼륨으로 마운트되지 않습니다. 따라서 실행할 실행 파일은 펌웨어에서 액세스 가능한 볼륨에 저장해야 합니다. 이는 ESP, 로컬 FAT 볼륨 또는 FAT 이동식 미디어가 될 수 있습니다.\n- BitLocker가 활성화되어 TPM을 키 보호자로 사용하도록 구성되어 있는 경우, Secure Boot를 비활성화하면 시스템이 BitLocker 복구 모드로 이동해야 할 수 있습니다. BitLocker 키를 봉인할 PCR 뱅크가 구성되어 있는 경우에는 심지어 서명된 UEFI 실행 파일이라도 BitLocker 복구 모드가 발생할 수 있습니다. 이는 이 안내서의 범위를 벗어난 이슈입니다. BitLocker 복구 키를 오프라인으로 가용하게 하고 펌웨어 설정을 변경하고 UEFI 실행 파일을 테스트하기 전에 BitLocker를 일시 중지하세요.\n- EFI 셸의 가용성은 시스템의 브랜드와 모델에 따라 다릅니다. 존재하는 경우 펌웨어 메뉴에서 액세스할 수 있어야 합니다. 없는 경우, 공식 edk2 릴리스 범위에서 다음과 같은 범위에서 얻을 수 있습니다: [edk2-stable201905, edk2-stable202002]. 이전 버전의 셸은 edk2 리포지토리의 ShellBinPkg 폴더의 일부로 커밋되었습니다. 해당 폴더는 2019년 4월 24일에 제거되었으며 내용은 릴리스 페이지로 이전되었습니다. 최신 버전의 경우 직접 빌드하거나 pbatard/UEFI-Shell과 같은 타사 소스에서 다운로드할 수 있습니다. 모든 edk2 릴리스는 서명되지 않았으며 펌웨어에 내장된 EFI 셸도 서명되지 않을 수 있으므로 이를 실행하려면 Secure Boot를 비활성화하거나 이들의 서명을 DB에 설치해야 합니다.\n- 펌웨어 UI 및 사용 가능한 구성은 시스템의 브랜드와 모델에 따라 다를 수 있으므로 Secure Boot를 비활성화하고 새 부팅 및 드라이버 옵션을 추가하는 등 설정을 변경하는 단계도 다를 것입니다.\n\n## 기타 주의 사항\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- VisualUefi 저장소는 더 이상 활발하게 유지되지 않으며 심각하게 오래되었습니다 — 동기화된 edk2 커밋은 2019년이며 openssl의 경우 2018년입니다. 누군가는 수동으로 서브모듈을 원격 최신 커밋으로 업데이트해야 하며, 그런 다음 서브모듈 소스 트리의 변경으로 인해 Visual Studio 프로젝트를 업데이트해야 합니다.\n- VisualUefi는 선택된 edk2 라이브러리만 빌드하며 모든 edk2 소스 코드를 포함하지 않습니다. 추가 라이브러리를 포함하려면 새 Visual Studio 프로젝트를 만들어야 합니다.\n- UEFI 실행 파일의 디버깅은 라이브 디버깅을 위한 디버거를 연결할 방법이 없어 어려울 수 있습니다. 콘솔에 로깅하는 것이 도움이 될 수 있지만, 대량 로깅이 있는 대규모 프로그램에는 실용적이지 않을 수 있습니다. 로그 파일에 쓰는 것도 해결책이지만, 프로그램이 실행을 완료할 때까지 로그 파일을 조사하기 전까지 기다려야 합니다. 다른 해결책으로는 UEFI 실행 파일을 가상 머신에서 실행하고 호스트에 연결된 파이프로 로깅하는 것이 있습니다. 호스트에서는 파이프의 내용을 읽고 콘솔에 인쇄하는 프로그램을 실행하여 로그를 실시간으로 검토할 수 있습니다. 이를 위해서는 VisualUefi를 수정하여 새 edk2 라이브러리를 빌드하고 edk2 소스 코드를 수정해야 합니다.\n","ogImage":{"url":"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_0.png"},"coverImage":"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_0.png","tag":["Tech"],"readingTime":27},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e왕밍재는 Secure Boot가 활성화된 실제 시스템에 개발한 UEFI 프로그램의 전체 과정을 설명합니다. 그의 안내로 엔지니어들은 UEFI 환경의 다양한 요소를 이해하고 UEFI 프로그램의 실행과 배포에 미치는 영향을 파악할 수 있습니다. 민재는 다양한 실용적 고려 사항을 포함하여 독자들이 다양한 배포 옵션을 평가하는 데 도움을 줍니다.\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003eUEFI (통합 확장 펌웨어 인터페이스) 개발은 대부분 EDK II (EFI 개발 키트 II) 리포를 사용하여 수행됩니다. EFI는 원래 BIOS를 대체하기 위해 Intel 내에서 시작된 프로젝트였습니다. 노력은 1998년 Tiano 프로젝트 내에서 시작되었으며 규격과 이를 구현하는 펌웨어로 이루어져 있습니다. 2004년, Intel은 EFI 펌웨어의 기본 코드를 오픈 소스로 공개했습니다. 2005년, 컴퓨터 산업의 주요 업체들이 UEFI 포럼을 결성하여 특정 규격을 소유하게 되었으며 2006년에 UEFI 2.0 규격을 발표했습니다. 이후 오픈 소스 코드는 EDK로 발전하고 마침내 오늘날의 EDK II로 이어졌습니다. 개발자 커뮤니티인 TianoCore는 GitHub에서 소스 코드를 유지보수합니다.\u003c/p\u003e\n\u003cp\u003eWindows에서 UEFI 개발은 예전에는 복잡한 프로세스였습니다. 많은 수동 단계가 필요했죠. UEFI는 사용자 지정 빌드 도구 체인을 구현하며 IDE를 통한 개발을 지원하지 않습니다. 온라인에서 다양한 안내서를 찾을 수 있고 컨테이너를 사용하여 빌드 프로세스가 개선되었지만, 여전히 IDE의 편리함에는 미치지 못합니다. 게다가 UEFI 실행 파일을 설치/배포하는 방법에 대한 충분한 자료가 없으며, Secure Boot를 활성화한 상태에서 실행시키는 방법에 대한 정보는 더 드물죠.\u003c/p\u003e\n\u003cp\u003e그래서 이 안내서는 이러한 공백을 메우고 UEFI 실행 파일을 배포하려는 사람들에게 도움이 되기를 희망합니다. 개인적인 용도든 제품 환경에서든 UEFI 실행 파일을 배포하려는 분들에게 도움이 될 것입니다.\u003c/p\u003e\n\u003cp\u003e이 안내서를 읽는 독자들은 다음을 기본적으로 이해하고 있을 것으로 예상됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUEFI가 무엇인지\u003c/li\u003e\n\u003cli\u003eC 프로그래밍 언어\u003c/li\u003e\n\u003cli\u003eVisual Studio IDE\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e설치 및 빌드\u003c/h2\u003e\n\u003cp\u003e이전에 언급된 개발 도전에 직면하던 중, Windows Internals 저자 중 한 명인 Alex Ionescu는 VisualUefi를 만들어 EDK II의 소스 코드를 Visual Studio 솔루션으로 래핑하였습니다. IDE 내에서 빌드가 이루어지며, EDK II의 사용자 정의 빌드 툴 체인을 완전히 우회합니다. 사용자의 UEFI 실행 파일을 개발하기 위해서는 두 번째 솔루션을 사용합니다.\u003c/p\u003e\n\u003cp\u003eVisualUefi 저장소의 지침에 따라 진행하세요.\u003c/p\u003e\n\u003ch2\u003e실행\u003c/h2\u003e\n\u003cp\u003eUEFI 실행 파일은 OS에서 직접 실행되지 않고 OS 부팅 전에 있는 UEFI 환경에서만 실행될 수 있습니다. 따라서 VisualUEFI는 QEMU와 EDK II의 OVMF (Open Virtual Machine Firmware) 모듈을 사용하여 펌웨어 실행 환경을 에뮬레이트합니다. VisualUEFI는 UEFI 실행 파일이 일반적인 명령행 실행 파일과 거의 동일하게 실행될 수 있도록 QEMU와 OVMF를 통합합니다.\u003c/p\u003e\n\u003ch2\u003eEFI 셸에서 실행하기\u003c/h2\u003e\n\u003cp\u003e이 섹션은 VisualUEFI의 단계와 동일하며 스크린샷이 추가되었습니다.\u003c/p\u003e\n\u003cp\u003e샘플 솔루션에서 Ctrl+F5를 눌러 QEMU를 실행하세요. 이렇게 하면 EFI 셸로 직접 부팅되며 여기서 샘플 UEFI 실행 파일을 실행할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_1.png\" alt=\"Screenshot 1\"\u003e\u003c/p\u003e\n\u003cp\u003eF5를 사용해도 되지만, 이 방법은 Visual Studio 디버거를 시작하는데 이 경우에는 QEMU 또는 UEFI 실행 파일에 연결할 수 없기 때문에 쓸모가 없습니다.\u003c/p\u003e\n\u003cp\u003e해결책의 빌드 출력 디렉토리 VisualUefi\\samples\\x64\\Release\\은 가상 볼륨으로 fs1:라는 레이블 아래로 탑재됩니다. 이 디렉토리의 내용을 나열하면 Windows에서 볼 수 있는 것과 동일한 파일과 폴더가 표시됩니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_2.png\" alt=\"Screenshot 2\"\u003e\u003c/p\u003e\n\u003cp\u003e첫째로, UefiDriver.efi를 로드해주세요:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_3.png)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e드라이버가 로드되었는지 확인하려면 devtree -b 명령을 사용하세요. -b 플래그는 출력을 한 번에 한 화면씩 표시합니다. 로딩 전후의 출력을 비교해보세요:\u003c/p\u003e\n\u003cp\u003e동일한 방식으로 drivers 명령어를 사용할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e어플리케이션을 실행하세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_4.png\" alt=\"application\"\u003e\u003c/p\u003e\n\u003ch2\u003e새 부팅 옵션에서 실행하기 — 어플리케이션 설치\u003c/h2\u003e\n\u003cp\u003e큐뮤를 실행한 후, 펌웨어 메뉴로 진입할 때까지 Esc 키를 누른 채로 유지하세요. 또는 EFI 셸에서 exit 명령을 입력하여 펌웨어 메뉴로 나갈 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_5.png\" alt=\"Boot Maintenance Manager\"\u003e\u003c/p\u003e\n\u003cp\u003eSelect Boot Options.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_7.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eSelect Add Boot Option.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_8.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eSelect the first option.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_9.png\" alt=\"image 1\"\u003e\u003c/p\u003e\n\u003cp\u003eSelect UefiApplication.efi.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_10.png\" alt=\"image 2\"\u003e\u003c/p\u003e\n\u003cp\u003eEnter any description; this will be the display name of the new boot option. The Optional Data field specifies the arguments that are passed to the UEFI executable. Leave it blank as the sample application does not use it.\u003c/p\u003e\n\u003cp\u003e변경 사항을 저장하고 펌웨어 메뉴 페이지로 돌아가세요. 부트 매니저 옵션을 선택하세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_11.png\" alt=\"부트 매니저\"\u003e\u003c/p\u003e\n\u003cp\u003e새로 추가된 부팅 옵션이 마지막 항목으로 표시됩니다. 실행하려면 그냥 선택하면 됩니다. 응용 프로그램이 종료되면 사용자는 즉시 펌웨어 메뉴로 돌아가며 출력은 빠르게 지나갑니다. 출력을 유지하려면 응용 프로그램의 코드를 변경해야 합니다.\u003c/p\u003e\n\u003cp\u003e사용자가 키를 눌러야 응용 프로그램이 돌아올 때까지 기다리도록 하는 방법이 있습니다. 이는 edk2\\MdeModulePkg\\Library\\CustomizedDisplayLib\\CustomizedDisplayLibInternal.c의 WaitForKeyStroke 함수를 사용하여 달성할 수 있습니다. 그러나 EDK-II 솔루션에 이 라이브러리가 포함되어 있지 않아 사용할 수 없습니다. Visual Studio 프로젝트를 만들어 새 라이브러리를 빌드하는 것은 본 안내서의 범위를 넘어서므로 지금은 응용 프로그램에 코드를 복제하는 것만으로 충분합니다.\u003c/p\u003e\n\u003cp\u003eEFI_STATUS\nWaitForKeyStroke(\nOUT  EFI_INPUT_KEY* Key\n)\n{\nEFI_STATUS  Status;\nUINTN       Index;\nwhile (TRUE) {\nStatus = gST-\u003eConIn-\u003eReadKeyStroke(gST-\u003eConIn, Key);\nif (!EFI_ERROR(Status)) {\nbreak;\n}\nif (Status != EFI_NOT_READY) {\ncontinue;\n}\ngBS-\u003eWaitForEvent(1, \u0026#x26;gST-\u003eConIn-\u003eWaitForKey, \u0026#x26;Index);\n}\nreturn Status;\n}\u003c/p\u003e\n\u003cp\u003e호출하는 코드:\u003c/p\u003e\n\u003cp\u003ePrint(L\"Press any key to continue...\\n\");\nEFI_INPUT_KEY keyInput;\nefiStatus = WaitForKeyStroke(\u0026#x26;keyInput);\nif (EFI_ERROR(efiStatus))\n{\nPrint(L\"Failed to get keystroke: %lx\\n\", efiStatus);\ngoto Exit;\n}\u003c/p\u003e\n\u003cp\u003e주의할 점: 샘플 응용 프로그램의 코드에 3가지 문제가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e94번 라인:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eefiStatus = \u003cspan class=\"hljs-title class_\"\u003eShellInitialize\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 EFI 셸에서만 작동합니다. 셸 대신에 우리 애플리케이션을 먼저 실행하고 있기 때문에 ShellInitialize() 호출이 실패할 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e104번 라인:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eefiStatus = \u003cspan class=\"hljs-title class_\"\u003eShellOpenFileByName\u003c/span\u003e(L\u003cspan class=\"hljs-string\"\u003e\"fs1:\\\\UefiApplication.efi\"\u003c/span\u003e,\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e볼륨 레이블 fs1:이 항상 사용 가능하고 실행 파일이 항상 거기에 저장되어 있다고 가정합니다. 그러나 볼륨 레이블을 할당하는 것은 EFI 셸의 역할이므로 EFI 셸이 없으면 fs1:이 없어지고 ShellOpenFileByName()은 실패할 것입니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e134번째 줄:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eefiStatus = gBS-\u003e\u003cspan class=\"hljs-title class_\"\u003eLocateProtocol\u003c/span\u003e(\u0026#x26;gEfiSampleDriverProtocolGuid, \u003cspan class=\"hljs-variable constant_\"\u003eNULL\u003c/span\u003e, \u0026#x26;sampleProtocol);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e샘플 드라이버에 액세스하려고 시도되었지만, 아직 드라이버를 설치하지 않았기 때문에 이 작업도 실패합니다.\u003c/p\u003e\n\u003cp\u003e코드는 항상 실패 시에 항상 \"Exit;\"으로 이동하므로 사용자의 키 입력을 읽는 코드를 제일 위에 삽입해야 실행이 보장됩니다.\u003c/p\u003e\n\u003cp\u003e부트 매니저 UI를 항상 입력해야 하는 것을 피하기 위해 부팅 순서를 EFI 셸 대신 새로운 옵션을 먼저 부팅하도록 변경할 수 있습니다. 그러려면, Boot Maintenance Manager \u003ccode\u003eBoot Options\u003c/code\u003e Change Boot Order로 이동하십시오:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_12.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 경우에는 애플리케이션이 펌웨어 메뉴 대신 EFI 셸로 종료됩니다. 부팅할 때 부팅 옵션이 EFI_SUCCESS를 반환하면 제어가 펌웨어 메뉴로 돌아가고, 그렇지 않으면 다음 부팅 옵션이 실행되며, 모든 부팅 옵션이 시도될 때까지 EFI_SUCCESS를 반환하거나 모든 부팅 옵션이 소진됩니다(UFI 사양서 섹션 3.1.1 참조). 위에서 언급한 3가지 문제로 인해 애플리케이션은 EFI_SUCCESS를 반환하지 않으므로 펌웨어는 다음 옵션인 UEFI 셸을 실행합니다.\u003c/p\u003e\n\u003cp\u003e위의 부팅 옵션 처리에 대한 예외 사항은 애플리케이션이 ExitBootServices()를 호출하는 경우에 있습니다. 그러나 이 내용은 이 안내서의 범위를 벗어납니다.\u003c/p\u003e\n\u003ch2\u003e새 부팅 옵션에서 실행 - 드라이버 설치\u003c/h2\u003e\n\u003cp\u003e부팅 유지 관리자 페이지에서 드라이버 옵션을 선택하세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_13.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eAdd Driver 옵션을 선택하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_14.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e파일을 사용하여 Add Driver 옵션을 선택하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_15.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eSelect the first option.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_16.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003eSelect UefiDriver.efi.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_17.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e어떤 설명을 입력하세요; 이는 새 드라이버 옵션의 표시 이름이 될 것입니다. 옵션 데이터 필드는 UEFI 실행 파일에 전달되는 인수를 지정합니다. 샘플 드라이버가 사용하지 않기 때문에 비워 두세요.\u003c/p\u003e\n\u003cp\u003e로드 옵션 Reconnect 필드는 펌웨어 부팅 관리자 실행 전에로드된 모든 드라이버를 무시하도록 드라이버에게 허용합니다 (UEFI 사양 섹션 3.1.3 참조). devtree 및 drivers 명령의 출력을 상기하세요 - 샘플 드라이버를 제외한 모든 항목은 펌웨어와 함께 제공된 드라이버이며 펌웨어 부팅 관리자 실행 전에 로드되었습니다. 호환성 문제가 발생할 수 있으므로 장치는 하나의 드라이버로 관리되어야 합니다. 샘플 드라이버는 기존 드라이버를 무시하지 않으므로 옵션을 활성화하는 것은 필요하지 않으며 순수한 효과가 없을 것입니다. 이 페이지를 저장하고 나가세요.\u003c/p\u003e\n\u003cp\u003e펌웨어 부팅 관리자는 부팅 시 부트와 드라이버 옵션을 자동으로 실행하는 펌웨어 구성 요소를 가리킵니다; 사용자가 수동으로 실행할 부트 옵션을 선택하는 부팅 관리자 UI와 혼동하면 안 됩니다. 또한 드라이버 오버라이드를 적용하려면 마지막 드라이버 옵션이 처리된 후 모든 UEFI 드라이버가 시스템에서 연결 해제되고 다시 연결되어야 합니다.\u003c/p\u003e\n\u003cp\u003e펌웨어 부트 매니저는 부팅 옵션을 처리하기 전에 모든 드라이버 옵션을 자동으로 처리합니다. 그러므로 부팅 옵션과는 달리 펌웨어 메뉴는 명시적으로 특정 드라이버 옵션을 로드할 수 있는 방법을 제공하지 않습니다. 또한 필요하지 않습니다. 설치된 모든 드라이버 옵션이 로드됩니다.\u003c/p\u003e\n\u003ch2\u003eEFI 쉘을 통한 수동 설치\u003c/h2\u003e\n\u003cp\u003e펌웨어 메뉴를 사용하는 것 외에도, EFI 쉘에서 bcfg 명령을 사용하여 새로운 부팅 및 드라이버 옵션을 설치할 수 있습니다. 자세한 내용은 도움말 bcfg의 결과를 확인하세요.\u003c/p\u003e\n\u003cp\u003e펌웨어가 새로운 부팅 옵션 및/또는 드라이버 옵션을 추가할 수 있는 능력을 제공하지 않는 시스템에서 유용합니다. 이는 UEFI 사양 섹션 3에서 정의된 메커니즘 (NVRAM 변수, UEFI 변수로도 불리는)에 따라 옵션이 구현된 방식 때문입니다. 즉, 모든 UEFI 호환 펌웨어는 설명된 방식으로 옵션을 구현하고 처리해야합니다. bcfg는 동일한 메커니즘으로 작동하기 때문에, 펌웨어가 명시적으로 이를 지원하지 않더라도 옵션을 수정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e사실 NVRAM 변수를 직접 수정하여 부팅 및 드라이버 옵션을 설치하거나 수정할 수 있습니다. 그러나 이것은 이 안내서의 범위를 벗어납니다.\u003c/p\u003e\n\u003ch2\u003e기존 부팅 옵션에서 실행\u003c/h2\u003e\n\u003cp\u003e부팅 매니저 페이지에서 샘플 애플리케이션 옵션의 장치 경로 설명을 볼 수 있습니다. 그러나 EFI 셸 옵션에는 실행 파일의 이름이 누락되어 있을 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_18.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e해당 옵션의 Device Path(UEFI 셸에서 fs0: 볼륨 레이블로 할당)로 가리키는 파티션 내용을 나열하면 EnrollDefaultKeys.efi라는 유일한 UEFI 실행 파일만 있는 것을 알 수 있습니다. 이것이 EFI 셸처럼 들리지 않는 것이 분명합니다.\u003c/p\u003e\n\u003cp\u003e이것이 일어나는 것은 펌웨어 부트 관리자가 모든 탈착 가능 미디어 및 고정 미디어 장치를 열거하고, 각 장치에 대한 부팅 옵션을 만드는 것입니다(UEFI 사양 섹션 13.3에 자세히 설명된 것처럼, 파일 시스템이 FAT인 경우). 이러한 항목을 부팅할 때 펌웨어가 장치 경로에 다음을 추가합니다: \\EFI\\BOOT\\BOOT'machine type short-name'.EFI 여기서 machine type short-name은 PE32+ 이미지 형식 아키텍처를 정의합니다. 가능한 값은:\u003c/p\u003e\n\u003cp\u003ePE(Portable Executable) 실행 파일 머신 유형은 Microsoft Portable Executable and Common Object File Format Specification, Revision 6.0에서 정의된 COFF 파일 헤더의 machine 필드에 지정됩니다.\u003c/p\u003e\n\u003cp\u003e여러 CPU 아키텍처를 지원하기 위해 장치는 \\EFI\\BOOT\\ 하위 디렉터리에 서로 다른 아키텍처용으로 구축된 여러 실행 파일을 저장할 수 있습니다. 자세한 내용은 UEFI 명세의 섹션 3.1.2 및 3.5를 참조하십시오.\u003c/p\u003e\n\u003cp\u003e따라서 fs0: 내의 모든 .efi를 나열하면 FS0:\\efi\\boot\\ 내에 bootx64.efi가 나타납니다. 이것이 EFI 셸입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_21.png\" alt=\"EFI Shell\"\u003e\u003c/p\u003e\n\u003cp\u003e따라서 샘플 애플리케이션에 대해 동일한 방법을 적용할 수 있습니다. VisualUefi\\samples\\x64\\Release\\ 하위에 \\EFI\\BOOT\\ 하위 디렉토리를 만들고 샘플 애플리케이션을 복사하여 BOOTx64.efi로 이름을 바꿉니다. 실행하려면 부트 매니저 UI에서 기존 UEFI Misc 장치 옵션을 선택하면 됩니다. 또는 부팅 옵션을 재정렬하여 QEMU가 먼저 부팅하도록 할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e이 접근 방식은 UEFI가 탈착식 미디어에서 부팅하는 방법을 지원하는 방식입니다. 예를 들어 Windows 설치 플래시 드라이브를 만들 때 설치 프로그램 실행 파일을 \\EFI\\BOOT\\BOOTx64.efi에 저장합니다. 설치하려면 펌웨어 메뉴에 들어가서 플래시 드라이브에서 부팅 옵션을 선택합니다. 또는 이미 플래시 드라이브를 첫 번째 부팅 옵션으로 구성했다면 시스템은 자동으로 설치 프로그램으로 부팅합니다.\u003c/p\u003e\n\u003ch2\u003eEFI 셸\u003c/h2\u003e\n\u003cp\u003e셸은 본질적으로 UEFI 펌웨어의 명령 프롬프트 / bash 셸 버전입니다. bash와 동일한 명령어를 지원하며 모든 지원되는 명령을 나열하려면 help 명령을 사용하면 됩니다. 이를 통해 사용자는 OS에 부팅하지 않고 시스템의 파일에 접근하거나 수정할 수 있습니다. UEFI 펌웨어는 기본적으로 FAT 파일 시스템만 지원하므로 셸이 액세스할 수 있는 파일 시스템도 FAT 파일 시스템뿐입니다. 다른 파일 시스템의 지원은 관련 UEFI 드라이버가 설치되고 로드되어 있는지에 따라 달라집니다.\u003c/p\u003e\n\u003cp\u003estartup.nsh\n쉘을 실행하면 다음과 같은 프롬프트가 나타납니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003ePress\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eESC\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e seconds to skip startup.\u003cspan class=\"hljs-property\"\u003ensh\u003c/span\u003e, any other key to \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e셸은 실행할 때마다 startup.nsh를 실행합니다. 셸을 첫 번째 부팅 옵션으로 구성하면(이미 QEMU의 기본값으로 설정되어 있음), 이를 통해 OS에 부팅하지 않고 시스템에서 자동으로 스크립트 작업을 실행할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e기본적으로 스크립트 파일이 없지만 ESP(EFI 시스템 파티션)의 루트 디렉터리에 직접 만들 수 있습니다. 시험해보려면 셸에서 다음 명령을 입력하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-md\"\u003eecho \"@echo test startup script\" \u003e fs0:\\startup.nsh\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 ESP의 볼륨 라벨인 fs0:에 스크립트 파일을 만들었어요.\u003c/p\u003e\n\u003cp\u003eexit 명령어로 셸을 종료하고 다시 실행하세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_22.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003eEFI 시스템 파티션 (ESP)\u003c/h2\u003e\n\u003cp\u003e이것은 UEFI 사양에 의해 정의된 특수 파티션이며 UEFI 펌웨어에서 액세스할 수 있습니다. 이것이 무엇인지 궁금하다면, 파티션에 액세스하는 것은 기본 작업이므로 이것이 운영 체제에만 해당되었다는 것을 알아두세요. UEFI가 대체하는 BIOS는 디스크의 전체 파티션에 액세스할 수 없었습니다. BIOS가 디스크에서 액세스 할 수 있는 유일한 요소는 MBR (마스터 부트 레코드) 및 VBR (볼륨 부트 레코드)였는데, 이들은 UEFI에 의해 대체되었습니다.\u003c/p\u003e\n\u003cp\u003eESP에는 일반적으로 OS 부트로더 및 / 또는 부트 매니저가 위치합니다. Windows에서는 이 파티션은 디스크 관리.msc에서 볼 수 있듯이 기본적으로 드라이브 문자가 할당되지 않으므로 직접 액세스 할 수 없습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_23.png\" alt=\"파티션 예시\"\u003e\u003c/p\u003e\n\u003cp\u003e접근하려면 고정된 명령 프롬프트를 열고 명령 mountvol X: /S를 사용하여 드라이브 문자를 할당하십시오. 여기서 X는 사용되지 않는 드라이브 문자입니다.\u003c/p\u003e\n\u003cp\u003eWindows 부트 매니저의 위치를 확인하려면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003eX\u003c/span\u003e:\\\u003edir /b/s *.\u003cspan class=\"hljs-property\"\u003eefi\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eX\u003c/span\u003e:\\\u003cspan class=\"hljs-variable constant_\"\u003eEFI\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eMicrosoft\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eBoot\u003c/span\u003e\\bootmgr.\u003cspan class=\"hljs-property\"\u003eefi\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eX\u003c/span\u003e:\\\u003cspan class=\"hljs-variable constant_\"\u003eEFI\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eMicrosoft\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eBoot\u003c/span\u003e\\memtest.\u003cspan class=\"hljs-property\"\u003eefi\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eX\u003c/span\u003e:\\\u003cspan class=\"hljs-variable constant_\"\u003eEFI\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eMicrosoft\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eBoot\u003c/span\u003e\\bootmgfw.\u003cspan class=\"hljs-property\"\u003eefi\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eX\u003c/span\u003e:\\\u003cspan class=\"hljs-variable constant_\"\u003eEFI\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eMicrosoft\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eBoot\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eSecureBootRecovery\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eefi\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eX\u003c/span\u003e:\\\u003cspan class=\"hljs-variable constant_\"\u003eEFI\u003c/span\u003e\\\u003cspan class=\"hljs-title class_\"\u003eBoot\u003c/span\u003e\\bootx64.\u003cspan class=\"hljs-property\"\u003eefi\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebootmgfw.efi가 Windows 부팅 매니저입니다. 또한 EFI\\Boot\\bootx64.efi 항목에 주목하세요. 이것은 bootmgfw.efi의 사본이며, bootmgfw.efi가 없거나 손상된 경우 대비 용도로 제공됩니다.\u003c/p\u003e\n\u003ch1\u003eSecure Boot\u003c/h1\u003e\n\u003cp\u003e지금까지 모든 UEFI 실행 파일은 Secure Boot가 비활성화된 상태로 실행되었습니다. Secure Boot는 UEFI 펌웨어의 보안 기능으로 신뢰할 수 있는 UEFI 실행 파일만을 실행할 수 있게 합니다. 이를 통해 시스템이 악성 UEFI 실행 파일(예: 부트킷)로부터 안전하게 보호되며, 제품 환경에서 항상 활성화되어야 합니다. 신뢰는 실행 파일의 서명이 승인된 서명 데이터베이스에 있고 금지된 서명 데이터베이스에 없는 것으로 정의됩니다. 서명은 다음 중 하나로 정의됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e실행 파일의 SHA-1 Authenticode 해시\u003c/li\u003e\n\u003cli\u003e실행 파일의 SHA-256 Authenticode 해시\u003c/li\u003e\n\u003cli\u003e실행 파일의 SHA-224 Authenticode 해시\u003c/li\u003e\n\u003cli\u003e실행 파일의 SHA-384 Authenticode 해시\u003c/li\u003e\n\u003cli\u003e실행 파일의 SHA-512 Authenticode 해시\u003c/li\u003e\n\u003cli\u003e실행 파일의 SHA-256 Authenticode 해시에 대한 RSA-2048 서명\u003c/li\u003e\n\u003cli\u003e실행 파일의 SHA-1 Authenticode 해시에 대한 RSA-2048 서명\u003c/li\u003e\n\u003cli\u003e실행 파일을 서명한 RSA-2048 키의 모듈러스 (공개 키 지수는 0x10001로 가정)\u003c/li\u003e\n\u003cli\u003e실행 파일을 서명한 키의 DER로 인코딩된 X.509 인증서\u003c/li\u003e\n\u003cli\u003e타임스탬프를 포함하는 더 복잡한 것들\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAuthenticode 해시가 어떻게 계산되는지에 대한 정보는 Windows Authenticode Portable Executable Signature Format에서 \"PE 이미지 해시 계산\" 섹션을 참조하십시오. X.509 인증서의 경우에는 UEFI 사양 섹션 8.2.6 및 32.6.3.3에 따라 실행 파일의 서명 인증서가 X.509 인증서 체인의 모든 수준에 존재하는 한 일치가 발견됩니다.\u003c/p\u003e\n\u003cp\u003e따라서 샘플 실행 파일이 안전 부팅이 활성화된 상태에서 실행되도록 하려면 이 중 하나의 서명을 안전 부팅 승인된 데이터베이스로 가져와야 합니다. 인증서를 사용하는 것이 더 유연한 옵션이며 해당 개인 키로 서명된 모든 실행 파일을 실행할 수 있습니다. 이로 인해 개발 및 테스트 중에 유용한 반복적인 수정 및 실행 파일 재구축이 가능해집니다. 그러나 해시를 사용하는 것보다 안전하지 않습니다. 왜냐하면 개인 키 침해의 위험이 있기 때문입니다.\u003c/p\u003e\n\u003cp\u003e서명을 설치하려면 펌웨어 메뉴로 이동하십시오:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_24.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e장치 관리자를 선택하십시오.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_25.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003eSelect Secure Boot Configuration.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_26.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003eThe Current Secure Boot State is set to Disabled. This entry is not configurable and is only meant to display the current state. The Attempt Secure Boot option itself is disabled (explained later), and the only option that can be changed is Secure Boot Mode. Change this from Standard Mode and Custom Mode which is the only other option available:\u003c/p\u003e\n\u003cp\u003e친구 안전 부팅 옵션을 선택하십시오.\u003c/p\u003e\n\u003cp\u003e다섯 가지 옵션 각각이 안전 부팅 키 유형에 해당합니다. DB는 승인된 서명 데이터베이스이며 DBX는 금지된 서명 데이터베이스입니다. UEFI 명세서에서 \"키\"라는 용어를 사용하고 있지만, 각 유형의 \"키\"에 저장된 항목은 실제로 앞서 언급한 유형의 서명 중 하나입니다. 명세서를 따라서 \"키\"를 일반적인 서명을 가리키는 용어로 사용하겠습니다. 각 항목을 살펴보면:\u003c/p\u003e\n\u003cp\u003e새 키를 등록하거나 기존 키를 삭제할 수 있는 옵션을 볼 수 있습니다. 기존 키 목록을 표시할 옵션은 없지만 삭제 옵션을 사용하여 삭제할 수 있습니다. 이렇게 하면 모든 키가 비어 있는 것을 확인할 수 있습니다. 이것이 안전 부팅을 활성화할 수 없는 이유입니다 — 안전 부팅을 활성화하려면 PK(플랫폼 키)가 있어야 합니다. 우리는 직접 하나 만들 수 있지만, 앞서 EnrollDefaultKeys.efi를 본 것을 기억해보세요.\u003c/p\u003e\n\u003ch2\u003e기본 안전 부팅 키 설치\u003c/h2\u003e\n\u003cp\u003e기본 안전 부팅 키를 설치하려면 EFI 셸에서 EnrollDefaultKeys.efi를 실행하십시오. 이 작업은 모든 기존 키를 덮어씁니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_29.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eSecure Boot은 PK가 없는 경우 설정 모드에 있습니다. PK를 설치하면 자동으로 Secure Boot가 사용자 모드로 전환됩니다 (UEFI 사양 섹션 32.3 참조, 이에 대해 나중에 자세히 논의할 예정입니다).\u003c/p\u003e\n\u003cp\u003e셸을 종료하고 다시 Secure Boot 구성을 확인하십시오:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_30.png\" alt=\"Secure Boot Configuration\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 Secure Boot가 활성화되고 \"Attempt Secure Boot\" 옵션이 활성화되어 설정되어 있습니다.\u003c/p\u003e\n\u003cp\u003e안녕하세요! 다시 Secure Boot Mode를 Custom으로 변경하고 키를 나열해 보겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003ePK: 이전에 활성화되었던 Enroll PK 옵션이 이제 비활성화되었습니다. 시스템에는 하나의 PK만 있을 수 있기 때문에 그렇습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eKEK: GUID로 명명된 두 항목이 있습니다. 모든 Secure Boot 키는 키의 소유자를 나타내는 SignatureOwner GUID와 연결됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ed5c1df0b-1bac-4edf-ba48-08834009ca5a: 이 소유자는 알 수 없습니다.\u003c/li\u003e\n\u003cli\u003e77fa9abd-0359-4d32-bd60-28f4e78f784b: 이것은 Microsoft입니다 (나중에 설명될 것입니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDB: Microsoft에 속한 두 항목이 있습니다 (나중에 설명될 것입니다).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDBX: 여기서 키는 유형에 따라 목록으로 그룹화됩니다. 유형이 SHA256인 목록만 한 개 존재합니다. Secure Boot 키의 모든 유형은 유형별 목록에 저장되는데, 이 펌웨어에서는 이 정보를 DBX에 대해서만 보여주기로 결정했습니다. 목록을 선택하면:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_31.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eKEK에 있는 알 수 없는 GUID와 같은 GUID가 나오며, 해시 E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855는 비어 있는 파일의 해시입니다. 이는 아마도 예제로 제공된 것일 것입니다. 최신 시스템에서는 DBX에 알려진 취약한 UEFI 실행 파일의 항목이 포함됩니다. 이러한 실행 파일 및 DBX를 업데이트하기 위한 이진 blob의 목록은 UEFI Forum에서 관리됩니다. Microsoft는 GitHub repo에서 이 목록의 미러를 유지합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003eDBT: 여전히 비어 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 부팅을 시도해 봅시다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_32.png\" alt=\"부팅 이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eEFI 쉘 또는 샘플 응용 프로그램은 서명되지 않았으며, 그 서명 또한 DB에 없기 때문에 이는 예상대로입니다.\u003c/p\u003e\n\u003ch1\u003eEFI 서명 인증서 생성\u003c/h1\u003e\n\u003cp\u003e샘플 애플리케이션을 서명하기 위해 먼저 인증서를 생성할 것입니다. Windows SDK에 포함된 명령줄 도구를 사용할 것입니다. 이 도구들은 %programfiles(x86)%\\Windows Kits\\10\\bin\\10.0.22621.0\\x64\\에 위치해 있습니다. 설치된 SDK 버전에 따라 하위 디렉토리의 이름이 다를 수 있습니다.\u003c/p\u003e\n\u003cp\u003e먼저, 다음 명령을 명령 프롬프트에서 사용하여 개인 키와 해당 인증서를 생성해 보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eMakeCert\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexe\u003c/span\u003e -a sha256 -n \u003cspan class=\"hljs-string\"\u003e\"CN=SampleEfiSigner\"\u003c/span\u003e -r -sv \u003cspan class=\"hljs-title class_\"\u003eSampleEfiSigner\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003epvk\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSampleEfiSigner\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecer\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e출력 파일은 DER 인코딩된 X.509 형식으로 제공되며, 이는 지원되는 DB 서명 유형 중 하나입니다.\u003c/p\u003e\n\u003cp\u003e옵션에 대한 설명:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e-a 서명의 다이제스트 알고리즘(기본값은 SHA1)\u003c/li\u003e\n\u003cli\u003e-n 인증서 소유자 X509 이름\u003c/li\u003e\n\u003cli\u003e-r 자체 서명된 인증서 생성\u003c/li\u003e\n\u003cli\u003e-sv 서브젝트의 PVK 파일, 존재하지 않는 경우 생성됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 명령은 비공개 키 파일을 사용할 비밀번호를 요청하는 팝업 프롬프트를 생성합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_33.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e다음으로 임의의 암호를 설정하고 확인을 누르세요.\u003c/p\u003e\n\u003cp\u003e이렇게 하면 이전 단계에서 설정한 암호를 요청하는 두 번째 프롬프트가 생성됩니다. 이는 자체 서명 작업을 위한 것입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_34.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eMakeCert 명령어의 결과는 다음과 같아야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eSucceeded\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 .pvk 파일을 .pfx로 변환하여 signtool에서 UEFI 실행 파일에 서명할 수 있도록 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epvk2pfx.\u003cspan class=\"hljs-property\"\u003eexe\u003c/span\u003e -pvk \u003cspan class=\"hljs-title class_\"\u003eSampleEfiSigner\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003epvk\u003c/span\u003e -pi \u0026#x3C;password\u003e -spc \u003cspan class=\"hljs-title class_\"\u003eSampleEfiSigner\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecer\u003c/span\u003e -pfx \u003cspan class=\"hljs-title class_\"\u003eSampleEfiSigner\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003epfx\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003epassword\u003c/code\u003e를 개인 키 파일의 비밀번호로 바꾸세요. 이 명령은 출력물이 없습니다.\u003c/p\u003e\n\u003cp\u003e옵션 설명:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e-pvk 입력 PVK 파일 이름\u003c/li\u003e\n\u003cli\u003e-pi PVK 파일의 비밀번호\u003c/li\u003e\n\u003cli\u003e-spc 입력 SPC 파일 이름\u003c/li\u003e\n\u003cli\u003e-pfx 출력 PFX 파일 이름\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eUEFI 실행 파일에 서명하기\u003c/h2\u003e\n\u003cp\u003e이전 도구와 동일한 디렉토리에 있는 signtool을 사용해보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esigntool.\u003cspan class=\"hljs-property\"\u003eexe\u003c/span\u003e sign /fd sha256 /ac \u003cspan class=\"hljs-title class_\"\u003eSampleEfiSigner\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecer\u003c/span\u003e /f \u003cspan class=\"hljs-title class_\"\u003eSampleEfiSigner\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003epfx\u003c/span\u003e /p \u0026#x3C;비밀번호\u003e \u0026#x3C;서명할 efi 파일\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e비밀번호\u003c/code\u003e를 개인 키 파일의 비밀번호로 대체하세요. \u003ccode\u003e서명할 efi 파일\u003c/code\u003e은 대상 파일 이름으로 대체하세요. 이 명령은 다음을 출력해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eDone\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAdding\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAdditional\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStore\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eSuccessfully\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esigned\u003c/span\u003e: \u0026#x3C;efiToSign\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e옵션 설명:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e/fd 파일 서명에 사용할 파일 다이제스트 알고리즘 (기본값은 SHA1)\u003c/li\u003e\n\u003cli\u003e/ac 서명 블록에 추가 인증서 추가\u003c/li\u003e\n\u003cli\u003e/f 서명 인증서의 파일. 파일에 개인 키가 없는 경우 \"/csp\" 및 \"/kc\"를 사용하십시오.\u003c/li\u003e\n\u003cli\u003e/p PFX 파일의 암호\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e파일의 속성 창을 열어 서명되었는지 확인하세요. 새로운 디지털 서명 탭이 있어야 합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_35.png\" alt=\"서명 확인\"\u003e\u003c/p\u003e\n\u003ch2\u003eDB에 인증서 설치하기\u003c/h2\u003e\n\u003cp\u003eSampleEfiSigner.cer 파일을 VisualUefi\\samples\\x64\\Release\\ 폴더로 이동하세요. 우리는 이후 펌웨어 메뉴에서 이 파일에 접근해야 합니다. 펌웨어 메뉴에서 DB 옵션으로 이동하고 Enroll Signature를 선택하세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_36.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eSelect Enroll Signature Using File.\u003c/p\u003e\n\u003cp\u003e첫 번째 옵션을 선택하세요.\u003c/p\u003e\n\u003cp\u003eSampleEfiSigner.cer를 선택하세요. 여기서 펌웨어는 DER로 인코딩된 X.509 인증서와 UEFI 실행 파일만 지원합니다. 후자의 경우 실행 파일의 SHA-256 Authenticode 해시를 계산하여 서명으로 저장할 것입니다.\u003c/p\u003e\n\u003cp\u003eUI가 등록 서명 페이지로 돌아갑니다. 서명 GUID 필드는 서명 소유자의 서명과 일치합니다. 임의의 값 입력하거나 기본값으로 모든 0의 GUID로 남겨 둡니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_39.png\" alt=\"Enroll Signature\"\u003e\u003c/p\u003e\n\u003cp\u003e서명은 이제 삭제 서명 메뉴에 표시됩니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_40.png\" alt=\"Delete Signature\"\u003e\u003c/p\u003e\n\u003cp\u003eUEFI 실행 파일 자체를 선택했을 경우, 항목 설명은 PKCS7_GUID가 아니라 SHA256_GUID가 됩니다.\u003c/p\u003e\n\u003cp\u003e다음으로 부팅을 시도해보세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_42.png\" alt=\"부팅 시도 이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e안전한 부팅 보안\u003c/h2\u003e\n\u003cp\u003e펌웨어 UI를 사용하여 서명을 등록하는 것 외에도 UEFI 런타임 서비스 함수 SetVariable()를 통해 프로그래밍 방식으로도 이를 수행할 수 있습니다. 이는 UEFI 실행 파일 및 OS 실행 파일 모두에서 호출할 수 있습니다 (Windows에서는 SetFirmwareEnvironmentVariable()로 노출됩니다). 그런데 여기서 의문이 생깁니다 - 이것이 안전한 방법인가요? Secure Boot가 활성화된 경우, 신뢰할 수 있는 UEFI 실행 파일만 실행되도록 허용되므로 서명을 수정할 수 있어야 합니다. 그러나 OS는 안전하지 않은 코드를 실행할 수 있으며, 악성 코드는 이에 대표적인 예시입니다 - 그들은 그들의 부트킷을 화이트리스트에 추가하거나 DBX에서 취약한 실행 파일을 제거할 수 있습니다. Windows는 SetFirmwareEnvironmentVariable()을 호출하는 것을 특권있는 사용자 (예: 관리자)만 허용하도록 제한하지만, 특권 상승 공격을 통해 여전히 우회될 수 있습니다. 이 때 PK와 KEK가 필요합니다.\u003c/p\u003e\n\u003cp\u003eSecure Boot가 설정 모드인 경우 (즉, PK가 없는 경우), 사용자는 PK가 없는 제약 없이 펌웨어 UI 또는 SetVariable()을 통해 모든 Secure Boot 키를 수정할 수 있습니다. Secure Boot가 사용자 모드로 진입하면 (즉, PK가 설치된 경우), 사용자는 Secure Boot 키를 계속 펌웨어 UI를 통해 수정할 수 있지만, SetVariable()의 경우, 펌웨어는 쓰여질 데이터가 서명되어야 한다고 요구할 것입니다. 대상 Secure Boot 키는 어떤 서명 키가 필요한지를 결정합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDB, DBX: PK 또는 KEK에 해당하는 개인 키로 서명\u003c/li\u003e\n\u003cli\u003ePK, KEK: PK에 해당하는 개인 키로 서명\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e단일 유형의 키로 DB 및 DBX를 안전하게 보호하는 것이 충분했겠지만, Secure Boot 키의 소유권 수준을 구분하기 위해 PK와 KEK 사이에 차이를 두었습니다. PK는 컴퓨터 하드웨어의 OEM이 소유하며 컴퓨터 당 하나뿐입니다. HP 및 Dell의 경우:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_43.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003ePK의 역할은 KEK의 설치를 제어하는 것입니다. 컴퓨터 당 여러 KEK가 있을 수 있으며, 각각이 DB 및 DBX로 서명을 설치하는 데 신뢰되는 엔티티에 해당합니다. 일반적으로 OEM 및 운영 체제만 해당됩니다. HP 및 Dell의 경우:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_44.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003eWindows 시스템의 경우, Microsoft의 KEK는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMicrosoft Corporation KEK CA 2011\u003c/li\u003e\n\u003cli\u003eMicrosoft Corporation KEK 2K CA 2023\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_45.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e2023 CA는 2026에 만료되는 2011 CA를 대체하기 위해 사용됩니다.\u003c/p\u003e\n\u003cp\u003eSecure Boot에 대한 자세한 내용은 UEFI 명세서 32장과 Microsoft의 Secure Boot 키 생성 및 관리 문서를 참조하세요.\u003c/p\u003e\n\u003ch2\u003e기본값으로 Microsoft 키\u003c/h2\u003e\n\u003cp\u003e웹 사이트 인증서의 경우 신뢰 여부는 Trusted Root 또는 중간 인증서에서의 체인 여부를 확인하는 것만으로 결정됩니다. 이러한 인증서는 종종 OS에 미리 설치되어 있으며 업데이트도 OS에서 처리됩니다.\u003c/p\u003e\n\u003cp\u003e그러나 Secure Boot와 호환되는 UEFI 실행 파일을 배포하고 싶다면, 서명 인증서를 얻기 위해 찾아갈 수 있는 CA도 없고 실행 파일에 서명할 수 있는 CA도 없습니다.\u003c/p\u003e\n\u003cp\u003eWindows의 부팅 관리자(UEFI 애플리케이션)는 기본적으로 세계 제조사들과 협력하여 제품을 제조하는 모든 소매용 PC와 마더보드에 Microsoft의 KEK 및 DB 키가 설치되어 있기 때문에 Secure Boot가 활성화된 상태에서 즉시 실행될 수 있습니다. 모든 사람이 마찬가지로 할 수 있는 능력을 갖고 있는 것은 아니지만, 다행히도 Microsoft는 Windows 드라이버 서명 서비스와 유사한 UEFI 서명 서비스를 제공합니다. 서명된 후에 UEFI 실행 파일은 Windows와 동일한 하드웨어 범위와 호환되는 Secure Boot가 가능해집니다.\u003c/p\u003e\n\u003cp\u003e이러한 협정은 마이크로소프트가 이름만 다르지 CA 등록인 Secure Boot CA인 것처럼 되어 있고, 이것이 또한 Microsoft의 키가 기본값으로 처리되는 이유이기도 합니다. 앞서 말한 KEK 외에도 Windows 시스템의 DB에는 다음과 같은 인증서가 설치되어 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMicrosoft Windows Production PCA 2011\u003c/li\u003e\n\u003cli\u003eWindows UEFI CA 2023\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_46.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e위의 두 개의 키 중 하나로 Windows 부팅 관리자가 서명되었습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMicrosoft Corporation UEFI CA 2011\u003c/li\u003e\n\u003cli\u003eMicrosoft UEFI CA 2023\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_47.png\" alt=\"이미지\"\u003e\n모든 타사 UEFI 실행 파일은 위의 두 키 중 하나로 서명됩니다.\u003c/p\u003e\n\u003cp\u003eEnrollDefaultKeys.efi를 실행한 후 DB에는 2011년 인증서인 두 개의 항목이 생성되었습니다. 2026년에 만료되는 2011년 인증서를 대체할 2023년 인증서가 있습니다.\u003c/p\u003e\n\u003cp\u003eUEFI 실행 파일을 직접 서명하는 것 외에도 Microsoft가 할 수 있는 옵션은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMicrosoft가 UEFI CA 인증서에 연결되는 인증서를 발행하고 이를 OS 업데이트를 통해 DB에 설치합니다.\u003c/li\u003e\n\u003cli\u003e개발자가 제출한 DB 업데이트를 Microsoft가 수락하여 원하는 서명을 설치할 수 있도록 KEK를 사용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그러나 이러한 옵션들은 악의적인 사용자들이 부팅 킷을 모든 Windows 시스템에 배포하는 더 많은 길을 제공할 수 있습니다 (Microsoft에 요청을 제출할 때 합법적인 개발자로 위장하거나 신뢰할 수 있는 개발자들의 서명 키를 도난당할 수 있음). Microsoft는 분명히 제출자들을 심사하는 책임을 지기를 원하지 않으며, 시스템의 보안과 안정성에서 부팅 모듈의 중요성을 고려할 때 Microsoft에게 중요한 것은 다음을 보증하는 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e해로운 저작물이 아니며 Secure Boot를 우회하는 수단을 제공하지 않습니다 (즉, 서명되지 않은 코드를 실행하지 않음)\u003c/li\u003e\n\u003cli\u003eMicrosoft의 부팅 모듈과의 호환성 문제를 일으키지 않습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이것이 마이크로소프트가 실행 파일을 제출하도록 요청하는 유일한 옵션인 이유입니다.\u003c/p\u003e\n\u003cp\u003e이러한 규정은 마이크로소프트가 서명한 UEFI 실행 파일에서 취약점이 발견된 경우 해당 취약성을 차단하는 유일한 방법은 해당 파일의 Authenticode 해시를 DBX에 추가하는 것입니다. 마이크로소프트의 UEFI CA 인증서는 DBX에 추가할 수 없습니다. 그렇게 되면 다른 취약하지 않은 실행 파일도 차단됩니다. Windows 부팅 매니저 (BlackLotus) 및 shim/GRUB2 (Boot Hole)의 취약성으로 인해 DBX에는 수백 개의 항목이 추가되었습니다.\u003c/p\u003e\n\u003ch2\u003e키 사용자 정의하기\u003c/h2\u003e\n\u003cp\u003e더 많은 통제와 보안을 위해, 필요없는 기본 키를 제거하거나 사용자 정의 키를 설치하고 싶을 수 있습니다. UEFI 실행 파일을 Microsoft에 제출하지 않고 싶을 수도 있거나, 단순히 제출할 수 없을 수도 있습니다:\u003c/p\u003e\n\u003cp\u003e이 모든 것은 대상 컴퓨터의 Secure Boot 키를 사용자 정의하는 것을 의미합니다. 그러나 소매 시스템의 기본 Secure Boot 모드는 사용자 모드(예: PK가 설치됨)이므로, 이러한 변경을 수동으로 접근하는 것이 유일한 방법일 것입니다. 일부 제한된 배포에 대해서는 실행 가능하지만, 대규모 배포(예: 기업)에 대해서는 비현실적할 것입니다 — 모든 시스템을 직접 방문하거나 다시 수집하는 것은 너무 많은 시간과 노력이 필요할 것입니다. 원격으로 변경하는 것은 해당 키 업데이트가 관련 키(PK 또는 KEK)로 서명된 경우에만 가능할 것입니다. 그러나 위에서 설명했듯이, 이러한 요청을 OEM 또는 이 키를 소유한 Microsoft가 보안 문제로 인해 받아들일 가능성은 없을 것입니다.\u003c/p\u003e\n\u003cp\u003e대안으로 OEM이 키를 사용자 정의하거나 시스템을 전달하기 전에 PK를 제거하는 것이 가능할 수 있습니다; 그러나 이는 추가 비용이 발생하고 이미 전달된 시스템에 해당하지 않을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e마지막으로, 기본 PK 또는 KEK를 사용자 정의로 대체한다면, 이후 OEM/Microsoft에 의한 KEK 또는 DB/DBX의 모든 업데이트는 실패할 것입니다. 따라서 해당 업데이트를 원한다면, 영향을 받는 컴퓨터에 배포되기 전에 해당 사용자 정의 PK/KEK에 해당하는 개인 키로 서명해야 합니다. 업데이트의 서명 및 설치는 앞서 언급한 signtool.exe 및 PowerShell 명령 Format-SecureBootUEFI 및 Set-SecureBootUEFI를 사용하여 수행할 수 있습니다. 이를 수행하는 방법에 대한 세부 내용은 이 가이드의 범위를 벗어납니다.\u003c/p\u003e\n\u003ch2\u003e실제 시스템에서 실행\u003c/h2\u003e\n\u003cp\u003eQEMU에서 UEFI 실행 파일을 실행하는 데 사용한 모든 방법은 실제 물리적 시스템에서도 적용됩니다. 주의해야 할 차이점은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e솔루션의 출력 디렉토리는 시스템에서 볼륨으로 마운트되지 않습니다. 따라서 실행할 실행 파일은 펌웨어에서 액세스 가능한 볼륨에 저장해야 합니다. 이는 ESP, 로컬 FAT 볼륨 또는 FAT 이동식 미디어가 될 수 있습니다.\u003c/li\u003e\n\u003cli\u003eBitLocker가 활성화되어 TPM을 키 보호자로 사용하도록 구성되어 있는 경우, Secure Boot를 비활성화하면 시스템이 BitLocker 복구 모드로 이동해야 할 수 있습니다. BitLocker 키를 봉인할 PCR 뱅크가 구성되어 있는 경우에는 심지어 서명된 UEFI 실행 파일이라도 BitLocker 복구 모드가 발생할 수 있습니다. 이는 이 안내서의 범위를 벗어난 이슈입니다. BitLocker 복구 키를 오프라인으로 가용하게 하고 펌웨어 설정을 변경하고 UEFI 실행 파일을 테스트하기 전에 BitLocker를 일시 중지하세요.\u003c/li\u003e\n\u003cli\u003eEFI 셸의 가용성은 시스템의 브랜드와 모델에 따라 다릅니다. 존재하는 경우 펌웨어 메뉴에서 액세스할 수 있어야 합니다. 없는 경우, 공식 edk2 릴리스 범위에서 다음과 같은 범위에서 얻을 수 있습니다: [edk2-stable201905, edk2-stable202002]. 이전 버전의 셸은 edk2 리포지토리의 ShellBinPkg 폴더의 일부로 커밋되었습니다. 해당 폴더는 2019년 4월 24일에 제거되었으며 내용은 릴리스 페이지로 이전되었습니다. 최신 버전의 경우 직접 빌드하거나 pbatard/UEFI-Shell과 같은 타사 소스에서 다운로드할 수 있습니다. 모든 edk2 릴리스는 서명되지 않았으며 펌웨어에 내장된 EFI 셸도 서명되지 않을 수 있으므로 이를 실행하려면 Secure Boot를 비활성화하거나 이들의 서명을 DB에 설치해야 합니다.\u003c/li\u003e\n\u003cli\u003e펌웨어 UI 및 사용 가능한 구성은 시스템의 브랜드와 모델에 따라 다를 수 있으므로 Secure Boot를 비활성화하고 새 부팅 및 드라이버 옵션을 추가하는 등 설정을 변경하는 단계도 다를 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e기타 주의 사항\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eVisualUefi 저장소는 더 이상 활발하게 유지되지 않으며 심각하게 오래되었습니다 — 동기화된 edk2 커밋은 2019년이며 openssl의 경우 2018년입니다. 누군가는 수동으로 서브모듈을 원격 최신 커밋으로 업데이트해야 하며, 그런 다음 서브모듈 소스 트리의 변경으로 인해 Visual Studio 프로젝트를 업데이트해야 합니다.\u003c/li\u003e\n\u003cli\u003eVisualUefi는 선택된 edk2 라이브러리만 빌드하며 모든 edk2 소스 코드를 포함하지 않습니다. 추가 라이브러리를 포함하려면 새 Visual Studio 프로젝트를 만들어야 합니다.\u003c/li\u003e\n\u003cli\u003eUEFI 실행 파일의 디버깅은 라이브 디버깅을 위한 디버거를 연결할 방법이 없어 어려울 수 있습니다. 콘솔에 로깅하는 것이 도움이 될 수 있지만, 대량 로깅이 있는 대규모 프로그램에는 실용적이지 않을 수 있습니다. 로그 파일에 쓰는 것도 해결책이지만, 프로그램이 실행을 완료할 때까지 로그 파일을 조사하기 전까지 기다려야 합니다. 다른 해결책으로는 UEFI 실행 파일을 가상 머신에서 실행하고 호스트에 연결된 파이프로 로깅하는 것이 있습니다. 호스트에서는 파이프의 내용을 읽고 콘솔에 인쇄하는 프로그램을 실행하여 로그를 실시간으로 검토할 수 있습니다. 이를 위해서는 VisualUefi를 수정하여 새 edk2 라이브러리를 빌드하고 edk2 소스 코드를 수정해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows"},"buildId":"O5JVeK6TDhbvSxBlchQwM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>