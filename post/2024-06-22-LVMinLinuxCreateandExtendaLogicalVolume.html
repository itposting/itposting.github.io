<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>리눅스에서 LVM 사용하여 논리 볼륨 생성 및 확장하는 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="리눅스에서 LVM 사용하여 논리 볼륨 생성 및 확장하는 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="리눅스에서 LVM 사용하여 논리 볼륨 생성 및 확장하는 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume" data-gatsby-head="true"/><meta name="twitter:title" content="리눅스에서 LVM 사용하여 논리 볼륨 생성 및 확장하는 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 16:12" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">리눅스에서 LVM 사용하여 논리 볼륨 생성 및 확장하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="리눅스에서 LVM 사용하여 논리 볼륨 생성 및 확장하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>XFS 파일 시스템에 LVM 논리 볼륨을 생성하고 확장하는 방법 안내서</h2>
<p><img src="/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_0.png" alt="image"></p>
<h2>LVM에 대해 간단히 알아봅시다</h2>
<p>논리 볼륨 관리자는 기존의 디스크 관리보다 훨씬 더 효율적인 방식으로 저장소를 다룹니다. 표준 디스크 파티션은 각 디스크의 용량에 기반하여 저장 공간을 할당하지만 LVM은 사용 가능한 모든 물리 하드 드라이브를 하나의 풀의 일부인 것처럼 결합하여 저장 공간을 효율적으로 관리하며 개별적으로 다루는 대신 전체로 사용할 수 있게 만듭니다.</p>
<div class="content-ad"></div>
<p>가정 해 보겠습니다. 4개의 1TB 드라이브가 있습니다. 전통적인 디스크 체계에서는 개별적으로 처리하지만 LVM을 사용하면 이 4개의 1TB 드라이브가 4TB 단일 청크 또는 집계된 저장 용량으로 간주됩니다. 이를 통해 디스크 레이아웃에 대한 더 큰 유연성과 제어권을 얻을 수 있으며 디스크를 더 쉽게 조작할 수 있습니다. LVM을 사용하는 주요 이점 중 하나는 파일 시스템을 쉽게 확장할 수 있는 능력입니다.</p>
<p>LVM을 이해하고 사용하기 위해서 우리는 세 가지 주요 구성 요소를 이해해야 합니다. 이들은 서로 연결되어 있으며 함께 하나의 논리적 볼륨이라는 것을 만듭니다. 이러한 구성 요소는 다음과 같습니다:</p>
<ul>
<li>물리적 볼륨</li>
<li>볼륨 그룹</li>
<li>논리적 볼륨</li>
</ul>
<p>물리적 볼륨: 이들은 LVM을 만들기 위해 사용되는 기본 블록입니다. 물리적 볼륨 또는 "PVs"는 단순히 물리적 저장 장치인 SSD 또는 HDD 드라이브입니다. 하드 드라이브가 물리적 볼륨로 간주되려면 물리적 볼륨로 초기화되어야 하므로 LVM에서 사용할 수 있습니다.</p>
<div class="content-ad"></div>
<p>Volume Group: 우리는 볼륨 그룹 "VG"를 물리적 볼륨으로 구성된 풀로 생각할 수 있습니다. 예를 들어, 1TB SSD 하드 드라이브 세 개가 볼륨 그룹의 일부인 경우, 이 "VG"는 총 저장 용량이 3TB로 나타나며, 논리적 볼륨을 생성하는 데 사용됩니다.</p>
<p>논리적 볼륨: 우리의 VG가 생성되면, 마침내 논리적 볼륨을 생성할 수 있습니다. 단일 볼륨 그룹에서 하나 이상의 논리적 볼륨을 생성할 수 있습니다. 논리적 볼륨은 디렉터리에 마운트된 기존 파티션으로 처리되고 사용될 것입니다.</p>
<p>아래 그림은 논리적 볼륨의 구조를 설명합니다:</p>
<p><img src="/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_1.png" alt="논리적 볼륨 구조"></p>
<div class="content-ad"></div>
<p>(특정 예시에서 우리가 사용하는 데모 서버가 구성된대로, 여러 논리 볼륨 및 볼륨 그룹이 있습니다.)</p>
<p>물리 장치인 하드 드라이브로부터 시작해요, 이들은 물리 볼륨 또는 PVs를 만드는 데 사용됩니다. 이 예에서, 우리는 세 개의 별도 HDD가 있으며, 각각은 하나의 물리 볼륨을 만드는 데 사용됩니다. 파티션 /dev/sda2는 첫 번째 PV를 만들고, /dev/sdb1은 두 번째이며 sdc1은 세 번째입니다.</p>
<p>이어서 두 개의 별도 볼륨 그룹이 있고, 각각에는 개별적인 논리 볼륨이 있습니다. 언급한 대로, LVs는 볼륨 그룹에서 잘려 나온 것입니다. 한 VG에서 하나 이상의 논리 볼륨이 올 수 있습니다.</p>
<p>이 추상화에서 최종 계층은 논리 볼륨입니다. 예를 들어, vg-data 볼륨 그룹에서 나온 lv-data가 있습니다. lv-data가 준비되면 포맷하여 마운트 지점으로 사용할 수 있습니다. 이 경우: /dev/vg-data/lv-data.</p>
<div class="content-ad"></div>
<h2>LVM 논리 볼륨 만드는 방법:</h2>
<p>기존 논리 볼륨을 확장/확장하는 것에 대한 내용을 살펴보기 전에, 이전에 설정되지 않은 시스템에서 처음부터 하나를 만드는 방법을 살펴보고, 그 다음 섹션에서 확장하는 방법을 살펴보겠습니다. 이미 존재하는 LV를 확장하고 싶다면, 이 섹션을 건너뛰시면 됩니다.</p>
<p>새로운 논리 볼륨을 설정하려면 다음 순서대로 진행해야 합니다:</p>
<ul>
<li>기존 하드 드라이브에서 물리 볼륨을 생성합니다.</li>
<li>볼륨 그룹을 생성하고 물리 볼륨을 추가합니다.</li>
<li>볼륨 그룹에서 논리 볼륨을 생성합니다.</li>
<li>필요에 따라 논리 볼륨을 포맷합니다 — xfs, ext4 등.</li>
<li>마지막으로 새 파일 시스템을 마운트합니다.</li>
</ul>
<div class="content-ad"></div>
<p>— 물리 볼륨을 생성하려면 디스크 공간을 사용할 수 있어야 합니다. 이 서버(가상 머신)에서는 논리 볼륨 생성 데모에 사용할 두 개의 별도의 원시 하드 드라이브가 있습니다.</p>
<p><img src="/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_2.png" alt="이미지"></p>
<p>/dev/sdb 및 /dev/sdc 두 개의 원시 디스크가 있는 것을 확인할 수 있습니다. 아직 사용할 수 없으므로 이를 포맷해야 합니다.</p>
<p>이 새 디스크 /dev/sdb를 사용할 수 있게 하는 방법을 빠르게 살펴보겠습니다:</p>
<div class="content-ad"></div>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*XLof11Om75NHy4PY2-2S2Q.gif" alt="이미지"></p>
<p>저희가 한 몇가지에 대해 몇 가지 소식을 전합니다:</p>
<ul>
<li>새로운 드라이브 /dev/sdb를 사용할 수 있도록 새로운 파티션을 생성하고 적절한 레이블을 할당함으로써 진행되고 있습니다.</li>
<li>이 파티션의 특정 크기를 지정하지 않았지만, 기본값을 선택하여 전체 디스크를 사용할 수 있습니다. 크기를 지정하지 않고 엔터를 누르면 사용 가능한 전체 공간이 할당됩니다.</li>
<li>여기서 중요한 부분은 이 새로운 파티션을 레이블링하여 LVM 유형으로 지정하는 “8e” 16진수 코드를 선택하는 것입니다. ext4 파티션을 만들고자 한다면 레이블 코드가 다를 것입니다. 새로운 파티션을 만들 때, 사용하기 전에 레이블링해야 합니다.</li>
<li>우리가 한 변경 사항을 저장하기 위해 “w”를 입력해야 합니다.</li>
</ul>
<p>이제 디스크가 준비되었으니, pvcreate로 물리적 볼륨을 생성하는 것부터 시작해보겠습니다:</p>
<div class="content-ad"></div>
<p>피지컬 볼륨이 성공적으로 생성되었습니다! 이제 pvdisplay를 사용하여 PV가 만들어졌는지 확인해봅시다 (pvs도 사용할 수 있습니다):</p>
<p>[itadmin@localhost ~]$ sudo pvdisplay
[sudo] password for itadmin:
--- Physical volume ---
PV Name               /dev/sda2
VG Name               centos
PV Size               &#x3C;19.00 GiB / not usable 3.00 MiB
Allocatable           yes (but full)
PE Size               4.00 MiB
Total PE              4863
Free PE               0
Allocated PE          4863
PV UUID               sa3xFR-jbDb-SKuS-yQN1-VzzW-bveG-aA0yha
"/dev/sdb1"은 "&#x3C;30.00 GiB"의 새로운 피지컬 볼륨입니다
--- NEW Physical volume ---
PV Name               /dev/sdb1
VG Name
PV Size               &#x3C;30.00 GiB
Allocatable           NO
PE Size               0
Total PE              0
Free PE               0
Allocated PE          0
PV UUID               Q54fqC-Np3X-XUaF-j5vE-Px29-pT9H-JYsDUh
[itadmin@localhost ~]$</p>
<p>이미 /dev/sda2에 PV가 있습니다. 이는 루트 파티션도 논리 볼륨 위에 구축되어 있음을 의미합니다. 새로운 디스크 /dev/sdb1은 이제 피지컬 볼륨입니다. 이 새로운 피지컬 볼륨의 VG 이름이 비어있는 것을 알 수 있습니다! 이는 이제까지 볼륨 그룹에 추가되지 않았기 때문입니다! 이를 바로 해결해봅시다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-bash">[itadmin@localhost ~]$ sudo vgcreate vg-data /dev/sdb1
  Volume group <span class="hljs-string">"vg-data"</span> successfully created
[itadmin@localhost ~]$
</code></pre>
<ul>
<li>새 볼륨 그룹을 만들 때 vgcreate를 사용하며, 새 볼륨 그룹에 이름을 할당하고 물리 볼륨 또는 볼륨을 추가합니다. 이 경우에는 /dev/sdb1을 이 VG의 일부로 만듭니다.</li>
</ul>
<p>새로 만든 볼륨 그룹을 확인해봅시다:</p>
<pre><code class="hljs language-bash">[itadmin@localhost ~]$ sudo vgs
  VG      <span class="hljs-comment">#PV #LV #SN Attr   VSize   VFree</span>
  centos    1   2   0 wz--n- &#x3C;19.00g      0
  vg-data   1   0   0 wz--n- &#x3C;30.00g &#x3C;30.00g
[itadmin@localhost ~]$
</code></pre>
<div class="content-ad"></div>
<ul>
<li>vg-data은 실제로 존재하며 30GB의 여유 공간이 있어요 — 이는 이전에 추가한 물리 볼륨(새로운 파티션)의 크기입니다.</li>
</ul>
<p>이제 lvcreate을 사용하여 논리 볼륨을 생성합니다:</p>
<pre><code class="hljs language-bash">[itadmin@localhost ~]$ sudo lvcreate --name lv-data -l 100%FREE vg-data
논리 볼륨 <span class="hljs-string">"lv-data"</span>이(가) 생성되었습니다.
[itadmin@localhost ~]$
</code></pre>
<ul>
<li>-l : 우리가 볼륨 그룹에서 얼마의 공간을 사용할지를 지정하는 데 사용됩니다. 여기서는 해당 그룹의 100%를 할당합니다. 명령어에 볼륨 그룹 이름을 명시해야 합니다.</li>
</ul>
<div class="content-ad"></div>
<p>새로운 Logical Volume을 lvdisplay로 확인하고 있어요:</p>
<p><img src="/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_3.png" alt="LV"></p>
<p>우리의 Logical Volume이 성공적으로 생성되었어요!</p>
<p>이제 사용할 수 있도록 이 논리적 볼륨을 포맷해야 해요. 새로운 LV를 포맷하는 방법은 mkfs.xfs 명령을 사용하는 거에요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-bash">[itadmin@localhost ~]$ sudo mkfs.xfs /dev/vg-data/lv-data
[sudo] itadmin 님의 암호:
meta-data=/dev/vg-data/lv-data   isize=512    agcount=4, agsize=1965824 블록
         =                       sectsz=512   attr=2, projid32bit=1
         =                       crc=1        finobt=0, sparse=0
data     =                       bsize=4096   블록=7863296, imaxpct=25
         =                       sunit=0      swidth=0 블록
naming   =version 2              bsize=4096   ascii-ci=0 ftype=1
<span class="hljs-built_in">log</span>      =internal <span class="hljs-built_in">log</span>           bsize=4096   블록=3839, version=2
         =                       sectsz=512   sunit=0 blks, lazy-count=1
realtime =none                   extsz=4096   블록=0, rtextents=0
[itadmin@localhost ~]$
</code></pre>
<p>.mkfs는 "파일 시스템 생성"을 의미하며, 이를 수행합니다. 이 경우에는 xfs 파일 시스템을 생성하려고 하므로 mkfs.xfs를 사용합니다. xfs 파일 시스템은 여러 측면에서 ext4보다 업그레이드된 것이며 RHEL 서버에서 기본 파일 시스템입니다. 그럼에도 불구하고 상황에 따라 ext4를 사용하는 것이 xfs보다 우위를 가질 수 있습니다.</p>
<p>새로 생성된 논리 볼륨을 마운트하려면 해당 마운트 포인트를 만들고 다음 단계를 수행합니다:</p>
<pre><code class="hljs language-bash">[itadmin@localhost ~]$ sudo <span class="hljs-built_in">mkdir</span> /data
[itadmin@localhost ~]$ sudo mount /dev/vg-data/lv-data /data
</code></pre>
<div class="content-ad"></div>
<p>저희는 새 파일 시스템이 마운트될 새로운 디렉토리를 생성했어요. /data 하위에 있는 모든 것들은 이 새 논리 볼륨에 속합니다.</p>
<p>— 부가적인 사항으로 — 새로운 마운트 포인트를 /etc/fstab 파일에 추가해야 부팅 중에도 지속되도록 해야 해요.</p>
<p>새롭게 마운트된 /data 디렉토리를 df 명령어로 살펴봅시다:</p>
<p><img src="/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_4.png" alt="이미지"></p>
<div class="content-ad"></div>
<ul>
<li>파일 시스템이 실제로 XFS인지 확인해야 하기 때문에 df 명령에 "T" 스위치가 필요합니다. 이 스위치는 파일 시스템 유형을 보여주는 데 사용됩니다.</li>
<li>우리의 논리 볼륨 lv-data는 모두 준비되어 있고 /data에 마운트되어 있습니다!</li>
</ul>
<p>작업이 완료되었습니다!</p>
<h2>논리 볼륨 확장 방법</h2>
<p>우리는 처음부터 논리 볼륨을 만드는 방법을 보았지만, 대부분의 경우 이미 존재하는 논리 볼륨의 크기를 늘려야 하므로 더 많은 데이터를 수용할 수 있게 할 필요가 있습니다.</p>
<div class="content-ad"></div>
<p>테이블 태그를 Markdown 형식으로 변경해주세요.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_5.png" alt="image"></p>
<ul>
<li>우리는 Volume Group vg-data에 사용 가능한 빈 공간이 없음을 확인할 수 있습니다. 새 물리 볼륨을 추가해 보겠습니다.</li>
</ul>
<p>먼저, 이 새 드라이브를 사용할 수 있도록 새 파티션을 만들고 "LVM" 레이블을 할당해야 합니다. 이를 위해 아래와 같이 fdisk를 사용하여 수행합니다:</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*qB2R3x5Zc2Lt46xIq-bEFQ.gif" alt="image"></p>
<div class="content-ad"></div>
<ul>
<li>fdisk를 사용하여 새 파티션을 만들고, 크기를 지정하지 않은 전체 크기를 할당했어요 (값을 지정하지 않고 Enter를 누르면 사용 가능한 크기를 할당합니다).</li>
<li>정확한 라벨을 지정해야 해요, "LVM 타입"으로 만들기 위해 필요한 라벨은 8e에요.</li>
</ul>
<p>디스크가 준비되었고, 이제 물리 볼륨을 생성할 수 있어요:</p>
<pre><code class="hljs language-js">[root@localhost ~]$ pvcreate /dev/sdc1
  <span class="hljs-title class_">Physical</span> volume <span class="hljs-string">"/dev/sdc1"</span> successfully created.
[root@localhost ~]$
</code></pre>
<p>생성 완료! 이제 vg-data 볼륨 그룹에 추가하려면, vgextend 명령어를 사용해요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-bash">[root@localhost ~]$ vgextend vg-data /dev/sdc1
  Volume group <span class="hljs-string">"vg-data"</span> successfully extended
[root@localhost ~]$
</code></pre>
<p>VG가 확장되었습니다! 한 번 더 확인해 봐요:</p>
<p><img src="/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_6.png" alt="이미지"></p>
<p>훌륭해요! 이제 vg-data에 25GB의 여유 공간이 있는 것을 확인할 수 있어요.</p>
<div class="content-ad"></div>
<p>지금은 Logical Volume에 뛰어들어 보겠습니다. 지금 상태는 다음과 같습니다:</p>
<p><img src="/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_7.png" alt="Logical Volume Status"></p>
<p>우리는 lvextend 명령어로 lv-data Logical Volume을 확장했습니다:</p>
<pre><code class="hljs language-js">[root@localhost ~]$ lvextend -l +<span class="hljs-number">100</span>%<span class="hljs-variable constant_">FREE</span> /dev/vg-data/lv-data
  <span class="hljs-title class_">Size</span> <span class="hljs-keyword">of</span> logical volume vg-data/lv-data changed <span class="hljs-keyword">from</span> &#x3C;<span class="hljs-number">30.00</span> <span class="hljs-title class_">GiB</span> (<span class="hljs-number">7679</span> extents) to <span class="hljs-number">54.99</span> <span class="hljs-title class_">GiB</span> (<span class="hljs-number">14078</span> extents).
  <span class="hljs-title class_">Logical</span> volume vg-data/lv-data successfully resized.
[root@localhost ~]$
</code></pre>
<div class="content-ad"></div>
<ul>
<li>lvextend 명령은 lv-data 논리 볼륨을 확장하며, +100%FREE 옵션은 해당 볼륨을 볼륨 그룹에서 남아있는 모든 가능한 크기로 확장합니다.</li>
<li>만약 우리가 논리 볼륨을 특정 크기로 확장하고 싶었다면, 예를 들어 5GB로 확장하고 싶다면 다음과 같이 진행할 것입니다:</li>
</ul>
<pre><code class="hljs language-js">[root@localhost ~]$ lvextend -L +5G /dev/vg-data/lv-data
</code></pre>
<p>이제 우리의 논리 볼륨 상태를 확인해봅시다:</p>
<p><img src="/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_8.png" alt="논리 볼륨 상태"></p>
<div class="content-ad"></div>
<p>출력을 통해 LSize가 실제로 증가했고, 논리 볼륨이 확장되었습니다!</p>
<p>아직 끝나지 않았어요! 마지막 단계는 새로 추가된 저장 용량을 사용할 수 있도록 파일 시스템의 크기를 조정하는 것입니다. 이 작업은 xfs_growfs 명령으로 수행할 수 있어요:</p>
<pre><code class="hljs language-js">[root@localhost ~]$ xfs_growfs /dev/vg-data/lv-data
</code></pre>
<img src="https://miro.medium.com/v2/resize:fit:1400/1*yu72eMpz12FUdIOTeL0qgg.gif">
<div class="content-ad"></div>
<ul>
<li>데이터 블록이 변경되고 파일 시스템이 확장되었음을 알 수 있습니다.</li>
<li>여기서 언급해야 할 또 다른 훌륭한 점은 파일 시스템을 확장할 때 마운트 포인트인 /data를 해제할 필요가 없었다는 것입니다!</li>
</ul>
<p>df -kh 명령의 출력에서 /data 마운트 포인트가 확장되었음을 확인할 수 있습니다. 여기에는 lv-data 논리 볼륨이 마운트된 곳입니다:</p>
<p><img src="/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_9.png" alt="Image"></p>
<p>모두 완료되었습니다. 논리 볼륨이 성공적으로 확장되었습니다!</p>
<div class="content-ad"></div>
<p>이 글은 Linux에서 논리 볼륨 매니저에 대해 간략히 다룬 내용이었습니다. 논리 볼륨을 생성하고 확장하는 방법에 대해 설명했습니다. 궁금한 점이나 의견, 추가할 내용이 있으면 자유롭게 남겨주세요.</p>
<p>읽어주셔서 감사합니다! 다음 포스트에서 만나요 :)</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"리눅스에서 LVM 사용하여 논리 볼륨 생성 및 확장하는 방법","description":"","date":"2024-06-22 16:12","slug":"2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume","content":"\n\n## XFS 파일 시스템에 LVM 논리 볼륨을 생성하고 확장하는 방법 안내서\n\n![image](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_0.png)\n\n## LVM에 대해 간단히 알아봅시다\n\n논리 볼륨 관리자는 기존의 디스크 관리보다 훨씬 더 효율적인 방식으로 저장소를 다룹니다. 표준 디스크 파티션은 각 디스크의 용량에 기반하여 저장 공간을 할당하지만 LVM은 사용 가능한 모든 물리 하드 드라이브를 하나의 풀의 일부인 것처럼 결합하여 저장 공간을 효율적으로 관리하며 개별적으로 다루는 대신 전체로 사용할 수 있게 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가정 해 보겠습니다. 4개의 1TB 드라이브가 있습니다. 전통적인 디스크 체계에서는 개별적으로 처리하지만 LVM을 사용하면 이 4개의 1TB 드라이브가 4TB 단일 청크 또는 집계된 저장 용량으로 간주됩니다. 이를 통해 디스크 레이아웃에 대한 더 큰 유연성과 제어권을 얻을 수 있으며 디스크를 더 쉽게 조작할 수 있습니다. LVM을 사용하는 주요 이점 중 하나는 파일 시스템을 쉽게 확장할 수 있는 능력입니다.\n\nLVM을 이해하고 사용하기 위해서 우리는 세 가지 주요 구성 요소를 이해해야 합니다. 이들은 서로 연결되어 있으며 함께 하나의 논리적 볼륨이라는 것을 만듭니다. 이러한 구성 요소는 다음과 같습니다:\n\n- 물리적 볼륨\n- 볼륨 그룹\n- 논리적 볼륨\n\n물리적 볼륨: 이들은 LVM을 만들기 위해 사용되는 기본 블록입니다. 물리적 볼륨 또는 \"PVs\"는 단순히 물리적 저장 장치인 SSD 또는 HDD 드라이브입니다. 하드 드라이브가 물리적 볼륨로 간주되려면 물리적 볼륨로 초기화되어야 하므로 LVM에서 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVolume Group: 우리는 볼륨 그룹 \"VG\"를 물리적 볼륨으로 구성된 풀로 생각할 수 있습니다. 예를 들어, 1TB SSD 하드 드라이브 세 개가 볼륨 그룹의 일부인 경우, 이 \"VG\"는 총 저장 용량이 3TB로 나타나며, 논리적 볼륨을 생성하는 데 사용됩니다.\n\n논리적 볼륨: 우리의 VG가 생성되면, 마침내 논리적 볼륨을 생성할 수 있습니다. 단일 볼륨 그룹에서 하나 이상의 논리적 볼륨을 생성할 수 있습니다. 논리적 볼륨은 디렉터리에 마운트된 기존 파티션으로 처리되고 사용될 것입니다.\n\n아래 그림은 논리적 볼륨의 구조를 설명합니다:\n\n![논리적 볼륨 구조](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n(특정 예시에서 우리가 사용하는 데모 서버가 구성된대로, 여러 논리 볼륨 및 볼륨 그룹이 있습니다.)\n\n물리 장치인 하드 드라이브로부터 시작해요, 이들은 물리 볼륨 또는 PVs를 만드는 데 사용됩니다. 이 예에서, 우리는 세 개의 별도 HDD가 있으며, 각각은 하나의 물리 볼륨을 만드는 데 사용됩니다. 파티션 /dev/sda2는 첫 번째 PV를 만들고, /dev/sdb1은 두 번째이며 sdc1은 세 번째입니다.\n\n이어서 두 개의 별도 볼륨 그룹이 있고, 각각에는 개별적인 논리 볼륨이 있습니다. 언급한 대로, LVs는 볼륨 그룹에서 잘려 나온 것입니다. 한 VG에서 하나 이상의 논리 볼륨이 올 수 있습니다.\n\n이 추상화에서 최종 계층은 논리 볼륨입니다. 예를 들어, vg-data 볼륨 그룹에서 나온 lv-data가 있습니다. lv-data가 준비되면 포맷하여 마운트 지점으로 사용할 수 있습니다. 이 경우: /dev/vg-data/lv-data.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## LVM 논리 볼륨 만드는 방법:\n\n기존 논리 볼륨을 확장/확장하는 것에 대한 내용을 살펴보기 전에, 이전에 설정되지 않은 시스템에서 처음부터 하나를 만드는 방법을 살펴보고, 그 다음 섹션에서 확장하는 방법을 살펴보겠습니다. 이미 존재하는 LV를 확장하고 싶다면, 이 섹션을 건너뛰시면 됩니다.\n\n새로운 논리 볼륨을 설정하려면 다음 순서대로 진행해야 합니다:\n\n- 기존 하드 드라이브에서 물리 볼륨을 생성합니다.\n- 볼륨 그룹을 생성하고 물리 볼륨을 추가합니다.\n- 볼륨 그룹에서 논리 볼륨을 생성합니다.\n- 필요에 따라 논리 볼륨을 포맷합니다 — xfs, ext4 등.\n- 마지막으로 새 파일 시스템을 마운트합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n— 물리 볼륨을 생성하려면 디스크 공간을 사용할 수 있어야 합니다. 이 서버(가상 머신)에서는 논리 볼륨 생성 데모에 사용할 두 개의 별도의 원시 하드 드라이브가 있습니다.\n\n![이미지](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_2.png)\n\n/dev/sdb 및 /dev/sdc 두 개의 원시 디스크가 있는 것을 확인할 수 있습니다. 아직 사용할 수 없으므로 이를 포맷해야 합니다.\n\n이 새 디스크 /dev/sdb를 사용할 수 있게 하는 방법을 빠르게 살펴보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*XLof11Om75NHy4PY2-2S2Q.gif)\n\n저희가 한 몇가지에 대해 몇 가지 소식을 전합니다:\n\n- 새로운 드라이브 /dev/sdb를 사용할 수 있도록 새로운 파티션을 생성하고 적절한 레이블을 할당함으로써 진행되고 있습니다.\n- 이 파티션의 특정 크기를 지정하지 않았지만, 기본값을 선택하여 전체 디스크를 사용할 수 있습니다. 크기를 지정하지 않고 엔터를 누르면 사용 가능한 전체 공간이 할당됩니다.\n- 여기서 중요한 부분은 이 새로운 파티션을 레이블링하여 LVM 유형으로 지정하는 “8e” 16진수 코드를 선택하는 것입니다. ext4 파티션을 만들고자 한다면 레이블 코드가 다를 것입니다. 새로운 파티션을 만들 때, 사용하기 전에 레이블링해야 합니다.\n- 우리가 한 변경 사항을 저장하기 위해 “w”를 입력해야 합니다.\n\n이제 디스크가 준비되었으니, pvcreate로 물리적 볼륨을 생성하는 것부터 시작해보겠습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n피지컬 볼륨이 성공적으로 생성되었습니다! 이제 pvdisplay를 사용하여 PV가 만들어졌는지 확인해봅시다 (pvs도 사용할 수 있습니다):\n\n\n[itadmin@localhost ~]$ sudo pvdisplay\n[sudo] password for itadmin:\n  --- Physical volume ---\n  PV Name               /dev/sda2\n  VG Name               centos\n  PV Size               \u003c19.00 GiB / not usable 3.00 MiB\n  Allocatable           yes (but full)\n  PE Size               4.00 MiB\n  Total PE              4863\n  Free PE               0\n  Allocated PE          4863\n  PV UUID               sa3xFR-jbDb-SKuS-yQN1-VzzW-bveG-aA0yha\n\"/dev/sdb1\"은 \"\u003c30.00 GiB\"의 새로운 피지컬 볼륨입니다\n  --- NEW Physical volume ---\n  PV Name               /dev/sdb1\n  VG Name\n  PV Size               \u003c30.00 GiB\n  Allocatable           NO\n  PE Size               0\n  Total PE              0\n  Free PE               0\n  Allocated PE          0\n  PV UUID               Q54fqC-Np3X-XUaF-j5vE-Px29-pT9H-JYsDUh\n[itadmin@localhost ~]$\n\n\n이미 /dev/sda2에 PV가 있습니다. 이는 루트 파티션도 논리 볼륨 위에 구축되어 있음을 의미합니다. 새로운 디스크 /dev/sdb1은 이제 피지컬 볼륨입니다. 이 새로운 피지컬 볼륨의 VG 이름이 비어있는 것을 알 수 있습니다! 이는 이제까지 볼륨 그룹에 추가되지 않았기 때문입니다! 이를 바로 해결해봅시다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n[itadmin@localhost ~]$ sudo vgcreate vg-data /dev/sdb1\n  Volume group \"vg-data\" successfully created\n[itadmin@localhost ~]$\n```\n\n- 새 볼륨 그룹을 만들 때 vgcreate를 사용하며, 새 볼륨 그룹에 이름을 할당하고 물리 볼륨 또는 볼륨을 추가합니다. 이 경우에는 /dev/sdb1을 이 VG의 일부로 만듭니다.\n\n새로 만든 볼륨 그룹을 확인해봅시다:\n\n```bash\n[itadmin@localhost ~]$ sudo vgs\n  VG      #PV #LV #SN Attr   VSize   VFree\n  centos    1   2   0 wz--n- \u003c19.00g      0\n  vg-data   1   0   0 wz--n- \u003c30.00g \u003c30.00g\n[itadmin@localhost ~]$\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- vg-data은 실제로 존재하며 30GB의 여유 공간이 있어요 — 이는 이전에 추가한 물리 볼륨(새로운 파티션)의 크기입니다.\n\n이제 lvcreate을 사용하여 논리 볼륨을 생성합니다:\n\n```bash\n[itadmin@localhost ~]$ sudo lvcreate --name lv-data -l 100%FREE vg-data\n논리 볼륨 \"lv-data\"이(가) 생성되었습니다.\n[itadmin@localhost ~]$\n```\n\n- -l : 우리가 볼륨 그룹에서 얼마의 공간을 사용할지를 지정하는 데 사용됩니다. 여기서는 해당 그룹의 100%를 할당합니다. 명령어에 볼륨 그룹 이름을 명시해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 Logical Volume을 lvdisplay로 확인하고 있어요:\n\n![LV](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_3.png)\n\n우리의 Logical Volume이 성공적으로 생성되었어요!\n\n이제 사용할 수 있도록 이 논리적 볼륨을 포맷해야 해요. 새로운 LV를 포맷하는 방법은 mkfs.xfs 명령을 사용하는 거에요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n[itadmin@localhost ~]$ sudo mkfs.xfs /dev/vg-data/lv-data\n[sudo] itadmin 님의 암호:\nmeta-data=/dev/vg-data/lv-data   isize=512    agcount=4, agsize=1965824 블록\n         =                       sectsz=512   attr=2, projid32bit=1\n         =                       crc=1        finobt=0, sparse=0\ndata     =                       bsize=4096   블록=7863296, imaxpct=25\n         =                       sunit=0      swidth=0 블록\nnaming   =version 2              bsize=4096   ascii-ci=0 ftype=1\nlog      =internal log           bsize=4096   블록=3839, version=2\n         =                       sectsz=512   sunit=0 blks, lazy-count=1\nrealtime =none                   extsz=4096   블록=0, rtextents=0\n[itadmin@localhost ~]$\n```\n\n.mkfs는 \"파일 시스템 생성\"을 의미하며, 이를 수행합니다. 이 경우에는 xfs 파일 시스템을 생성하려고 하므로 mkfs.xfs를 사용합니다. xfs 파일 시스템은 여러 측면에서 ext4보다 업그레이드된 것이며 RHEL 서버에서 기본 파일 시스템입니다. 그럼에도 불구하고 상황에 따라 ext4를 사용하는 것이 xfs보다 우위를 가질 수 있습니다.\n\n새로 생성된 논리 볼륨을 마운트하려면 해당 마운트 포인트를 만들고 다음 단계를 수행합니다:\n\n```bash\n[itadmin@localhost ~]$ sudo mkdir /data\n[itadmin@localhost ~]$ sudo mount /dev/vg-data/lv-data /data\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 새 파일 시스템이 마운트될 새로운 디렉토리를 생성했어요. /data 하위에 있는 모든 것들은 이 새 논리 볼륨에 속합니다.\n\n— 부가적인 사항으로 — 새로운 마운트 포인트를 /etc/fstab 파일에 추가해야 부팅 중에도 지속되도록 해야 해요.\n\n새롭게 마운트된 /data 디렉토리를 df 명령어로 살펴봅시다:\n\n![이미지](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 파일 시스템이 실제로 XFS인지 확인해야 하기 때문에 df 명령에 \"T\" 스위치가 필요합니다. 이 스위치는 파일 시스템 유형을 보여주는 데 사용됩니다.\n- 우리의 논리 볼륨 lv-data는 모두 준비되어 있고 /data에 마운트되어 있습니다!\n\n작업이 완료되었습니다!\n\n## 논리 볼륨 확장 방법\n\n우리는 처음부터 논리 볼륨을 만드는 방법을 보았지만, 대부분의 경우 이미 존재하는 논리 볼륨의 크기를 늘려야 하므로 더 많은 데이터를 수용할 수 있게 할 필요가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_5.png)\n\n- 우리는 Volume Group vg-data에 사용 가능한 빈 공간이 없음을 확인할 수 있습니다. 새 물리 볼륨을 추가해 보겠습니다.\n\n먼저, 이 새 드라이브를 사용할 수 있도록 새 파티션을 만들고 \"LVM\" 레이블을 할당해야 합니다. 이를 위해 아래와 같이 fdisk를 사용하여 수행합니다:\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*qB2R3x5Zc2Lt46xIq-bEFQ.gif)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- fdisk를 사용하여 새 파티션을 만들고, 크기를 지정하지 않은 전체 크기를 할당했어요 (값을 지정하지 않고 Enter를 누르면 사용 가능한 크기를 할당합니다).\n- 정확한 라벨을 지정해야 해요, \"LVM 타입\"으로 만들기 위해 필요한 라벨은 8e에요.\n\n디스크가 준비되었고, 이제 물리 볼륨을 생성할 수 있어요:\n\n```js\n[root@localhost ~]$ pvcreate /dev/sdc1\n  Physical volume \"/dev/sdc1\" successfully created.\n[root@localhost ~]$\n```\n\n생성 완료! 이제 vg-data 볼륨 그룹에 추가하려면, vgextend 명령어를 사용해요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```bash\n[root@localhost ~]$ vgextend vg-data /dev/sdc1\n  Volume group \"vg-data\" successfully extended\n[root@localhost ~]$\n```\n\nVG가 확장되었습니다! 한 번 더 확인해 봐요:\n\n![이미지](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_6.png)\n\n훌륭해요! 이제 vg-data에 25GB의 여유 공간이 있는 것을 확인할 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금은 Logical Volume에 뛰어들어 보겠습니다. 지금 상태는 다음과 같습니다:\n\n![Logical Volume Status](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_7.png)\n\n우리는 lvextend 명령어로 lv-data Logical Volume을 확장했습니다:\n\n```js\n[root@localhost ~]$ lvextend -l +100%FREE /dev/vg-data/lv-data\n  Size of logical volume vg-data/lv-data changed from \u003c30.00 GiB (7679 extents) to 54.99 GiB (14078 extents).\n  Logical volume vg-data/lv-data successfully resized.\n[root@localhost ~]$\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- lvextend 명령은 lv-data 논리 볼륨을 확장하며, +100%FREE 옵션은 해당 볼륨을 볼륨 그룹에서 남아있는 모든 가능한 크기로 확장합니다.\n- 만약 우리가 논리 볼륨을 특정 크기로 확장하고 싶었다면, 예를 들어 5GB로 확장하고 싶다면 다음과 같이 진행할 것입니다:\n\n```js\n[root@localhost ~]$ lvextend -L +5G /dev/vg-data/lv-data\n```\n\n이제 우리의 논리 볼륨 상태를 확인해봅시다:\n\n![논리 볼륨 상태](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n출력을 통해 LSize가 실제로 증가했고, 논리 볼륨이 확장되었습니다!\n\n아직 끝나지 않았어요! 마지막 단계는 새로 추가된 저장 용량을 사용할 수 있도록 파일 시스템의 크기를 조정하는 것입니다. 이 작업은 xfs_growfs 명령으로 수행할 수 있어요:\n\n```js\n[root@localhost ~]$ xfs_growfs /dev/vg-data/lv-data\n```\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*yu72eMpz12FUdIOTeL0qgg.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터 블록이 변경되고 파일 시스템이 확장되었음을 알 수 있습니다.\n- 여기서 언급해야 할 또 다른 훌륭한 점은 파일 시스템을 확장할 때 마운트 포인트인 /data를 해제할 필요가 없었다는 것입니다!\n\ndf -kh 명령의 출력에서 /data 마운트 포인트가 확장되었음을 확인할 수 있습니다. 여기에는 lv-data 논리 볼륨이 마운트된 곳입니다:\n\n![Image](/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_9.png)\n\n모두 완료되었습니다. 논리 볼륨이 성공적으로 확장되었습니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글은 Linux에서 논리 볼륨 매니저에 대해 간략히 다룬 내용이었습니다. 논리 볼륨을 생성하고 확장하는 방법에 대해 설명했습니다. 궁금한 점이나 의견, 추가할 내용이 있으면 자유롭게 남겨주세요.\n\n읽어주셔서 감사합니다! 다음 포스트에서 만나요 :)","ogImage":{"url":"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_0.png"},"coverImage":"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003eXFS 파일 시스템에 LVM 논리 볼륨을 생성하고 확장하는 방법 안내서\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003eLVM에 대해 간단히 알아봅시다\u003c/h2\u003e\n\u003cp\u003e논리 볼륨 관리자는 기존의 디스크 관리보다 훨씬 더 효율적인 방식으로 저장소를 다룹니다. 표준 디스크 파티션은 각 디스크의 용량에 기반하여 저장 공간을 할당하지만 LVM은 사용 가능한 모든 물리 하드 드라이브를 하나의 풀의 일부인 것처럼 결합하여 저장 공간을 효율적으로 관리하며 개별적으로 다루는 대신 전체로 사용할 수 있게 만듭니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e가정 해 보겠습니다. 4개의 1TB 드라이브가 있습니다. 전통적인 디스크 체계에서는 개별적으로 처리하지만 LVM을 사용하면 이 4개의 1TB 드라이브가 4TB 단일 청크 또는 집계된 저장 용량으로 간주됩니다. 이를 통해 디스크 레이아웃에 대한 더 큰 유연성과 제어권을 얻을 수 있으며 디스크를 더 쉽게 조작할 수 있습니다. LVM을 사용하는 주요 이점 중 하나는 파일 시스템을 쉽게 확장할 수 있는 능력입니다.\u003c/p\u003e\n\u003cp\u003eLVM을 이해하고 사용하기 위해서 우리는 세 가지 주요 구성 요소를 이해해야 합니다. 이들은 서로 연결되어 있으며 함께 하나의 논리적 볼륨이라는 것을 만듭니다. 이러한 구성 요소는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e물리적 볼륨\u003c/li\u003e\n\u003cli\u003e볼륨 그룹\u003c/li\u003e\n\u003cli\u003e논리적 볼륨\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e물리적 볼륨: 이들은 LVM을 만들기 위해 사용되는 기본 블록입니다. 물리적 볼륨 또는 \"PVs\"는 단순히 물리적 저장 장치인 SSD 또는 HDD 드라이브입니다. 하드 드라이브가 물리적 볼륨로 간주되려면 물리적 볼륨로 초기화되어야 하므로 LVM에서 사용할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eVolume Group: 우리는 볼륨 그룹 \"VG\"를 물리적 볼륨으로 구성된 풀로 생각할 수 있습니다. 예를 들어, 1TB SSD 하드 드라이브 세 개가 볼륨 그룹의 일부인 경우, 이 \"VG\"는 총 저장 용량이 3TB로 나타나며, 논리적 볼륨을 생성하는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e논리적 볼륨: 우리의 VG가 생성되면, 마침내 논리적 볼륨을 생성할 수 있습니다. 단일 볼륨 그룹에서 하나 이상의 논리적 볼륨을 생성할 수 있습니다. 논리적 볼륨은 디렉터리에 마운트된 기존 파티션으로 처리되고 사용될 것입니다.\u003c/p\u003e\n\u003cp\u003e아래 그림은 논리적 볼륨의 구조를 설명합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_1.png\" alt=\"논리적 볼륨 구조\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e(특정 예시에서 우리가 사용하는 데모 서버가 구성된대로, 여러 논리 볼륨 및 볼륨 그룹이 있습니다.)\u003c/p\u003e\n\u003cp\u003e물리 장치인 하드 드라이브로부터 시작해요, 이들은 물리 볼륨 또는 PVs를 만드는 데 사용됩니다. 이 예에서, 우리는 세 개의 별도 HDD가 있으며, 각각은 하나의 물리 볼륨을 만드는 데 사용됩니다. 파티션 /dev/sda2는 첫 번째 PV를 만들고, /dev/sdb1은 두 번째이며 sdc1은 세 번째입니다.\u003c/p\u003e\n\u003cp\u003e이어서 두 개의 별도 볼륨 그룹이 있고, 각각에는 개별적인 논리 볼륨이 있습니다. 언급한 대로, LVs는 볼륨 그룹에서 잘려 나온 것입니다. 한 VG에서 하나 이상의 논리 볼륨이 올 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 추상화에서 최종 계층은 논리 볼륨입니다. 예를 들어, vg-data 볼륨 그룹에서 나온 lv-data가 있습니다. lv-data가 준비되면 포맷하여 마운트 지점으로 사용할 수 있습니다. 이 경우: /dev/vg-data/lv-data.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003eLVM 논리 볼륨 만드는 방법:\u003c/h2\u003e\n\u003cp\u003e기존 논리 볼륨을 확장/확장하는 것에 대한 내용을 살펴보기 전에, 이전에 설정되지 않은 시스템에서 처음부터 하나를 만드는 방법을 살펴보고, 그 다음 섹션에서 확장하는 방법을 살펴보겠습니다. 이미 존재하는 LV를 확장하고 싶다면, 이 섹션을 건너뛰시면 됩니다.\u003c/p\u003e\n\u003cp\u003e새로운 논리 볼륨을 설정하려면 다음 순서대로 진행해야 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e기존 하드 드라이브에서 물리 볼륨을 생성합니다.\u003c/li\u003e\n\u003cli\u003e볼륨 그룹을 생성하고 물리 볼륨을 추가합니다.\u003c/li\u003e\n\u003cli\u003e볼륨 그룹에서 논리 볼륨을 생성합니다.\u003c/li\u003e\n\u003cli\u003e필요에 따라 논리 볼륨을 포맷합니다 — xfs, ext4 등.\u003c/li\u003e\n\u003cli\u003e마지막으로 새 파일 시스템을 마운트합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e— 물리 볼륨을 생성하려면 디스크 공간을 사용할 수 있어야 합니다. 이 서버(가상 머신)에서는 논리 볼륨 생성 데모에 사용할 두 개의 별도의 원시 하드 드라이브가 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e/dev/sdb 및 /dev/sdc 두 개의 원시 디스크가 있는 것을 확인할 수 있습니다. 아직 사용할 수 없으므로 이를 포맷해야 합니다.\u003c/p\u003e\n\u003cp\u003e이 새 디스크 /dev/sdb를 사용할 수 있게 하는 방법을 빠르게 살펴보겠습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*XLof11Om75NHy4PY2-2S2Q.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e저희가 한 몇가지에 대해 몇 가지 소식을 전합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e새로운 드라이브 /dev/sdb를 사용할 수 있도록 새로운 파티션을 생성하고 적절한 레이블을 할당함으로써 진행되고 있습니다.\u003c/li\u003e\n\u003cli\u003e이 파티션의 특정 크기를 지정하지 않았지만, 기본값을 선택하여 전체 디스크를 사용할 수 있습니다. 크기를 지정하지 않고 엔터를 누르면 사용 가능한 전체 공간이 할당됩니다.\u003c/li\u003e\n\u003cli\u003e여기서 중요한 부분은 이 새로운 파티션을 레이블링하여 LVM 유형으로 지정하는 “8e” 16진수 코드를 선택하는 것입니다. ext4 파티션을 만들고자 한다면 레이블 코드가 다를 것입니다. 새로운 파티션을 만들 때, 사용하기 전에 레이블링해야 합니다.\u003c/li\u003e\n\u003cli\u003e우리가 한 변경 사항을 저장하기 위해 “w”를 입력해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 디스크가 준비되었으니, pvcreate로 물리적 볼륨을 생성하는 것부터 시작해보겠습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e피지컬 볼륨이 성공적으로 생성되었습니다! 이제 pvdisplay를 사용하여 PV가 만들어졌는지 확인해봅시다 (pvs도 사용할 수 있습니다):\u003c/p\u003e\n\u003cp\u003e[itadmin@localhost ~]$ sudo pvdisplay\n[sudo] password for itadmin:\n--- Physical volume ---\nPV Name               /dev/sda2\nVG Name               centos\nPV Size               \u0026#x3C;19.00 GiB / not usable 3.00 MiB\nAllocatable           yes (but full)\nPE Size               4.00 MiB\nTotal PE              4863\nFree PE               0\nAllocated PE          4863\nPV UUID               sa3xFR-jbDb-SKuS-yQN1-VzzW-bveG-aA0yha\n\"/dev/sdb1\"은 \"\u0026#x3C;30.00 GiB\"의 새로운 피지컬 볼륨입니다\n--- NEW Physical volume ---\nPV Name               /dev/sdb1\nVG Name\nPV Size               \u0026#x3C;30.00 GiB\nAllocatable           NO\nPE Size               0\nTotal PE              0\nFree PE               0\nAllocated PE          0\nPV UUID               Q54fqC-Np3X-XUaF-j5vE-Px29-pT9H-JYsDUh\n[itadmin@localhost ~]$\u003c/p\u003e\n\u003cp\u003e이미 /dev/sda2에 PV가 있습니다. 이는 루트 파티션도 논리 볼륨 위에 구축되어 있음을 의미합니다. 새로운 디스크 /dev/sdb1은 이제 피지컬 볼륨입니다. 이 새로운 피지컬 볼륨의 VG 이름이 비어있는 것을 알 수 있습니다! 이는 이제까지 볼륨 그룹에 추가되지 않았기 때문입니다! 이를 바로 해결해봅시다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e[itadmin@localhost ~]$ sudo vgcreate vg-data /dev/sdb1\n  Volume group \u003cspan class=\"hljs-string\"\u003e\"vg-data\"\u003c/span\u003e successfully created\n[itadmin@localhost ~]$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e새 볼륨 그룹을 만들 때 vgcreate를 사용하며, 새 볼륨 그룹에 이름을 할당하고 물리 볼륨 또는 볼륨을 추가합니다. 이 경우에는 /dev/sdb1을 이 VG의 일부로 만듭니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e새로 만든 볼륨 그룹을 확인해봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e[itadmin@localhost ~]$ sudo vgs\n  VG      \u003cspan class=\"hljs-comment\"\u003e#PV #LV #SN Attr   VSize   VFree\u003c/span\u003e\n  centos    1   2   0 wz--n- \u0026#x3C;19.00g      0\n  vg-data   1   0   0 wz--n- \u0026#x3C;30.00g \u0026#x3C;30.00g\n[itadmin@localhost ~]$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003evg-data은 실제로 존재하며 30GB의 여유 공간이 있어요 — 이는 이전에 추가한 물리 볼륨(새로운 파티션)의 크기입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이제 lvcreate을 사용하여 논리 볼륨을 생성합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e[itadmin@localhost ~]$ sudo lvcreate --name lv-data -l 100%FREE vg-data\n논리 볼륨 \u003cspan class=\"hljs-string\"\u003e\"lv-data\"\u003c/span\u003e이(가) 생성되었습니다.\n[itadmin@localhost ~]$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e-l : 우리가 볼륨 그룹에서 얼마의 공간을 사용할지를 지정하는 데 사용됩니다. 여기서는 해당 그룹의 100%를 할당합니다. 명령어에 볼륨 그룹 이름을 명시해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e새로운 Logical Volume을 lvdisplay로 확인하고 있어요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_3.png\" alt=\"LV\"\u003e\u003c/p\u003e\n\u003cp\u003e우리의 Logical Volume이 성공적으로 생성되었어요!\u003c/p\u003e\n\u003cp\u003e이제 사용할 수 있도록 이 논리적 볼륨을 포맷해야 해요. 새로운 LV를 포맷하는 방법은 mkfs.xfs 명령을 사용하는 거에요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e[itadmin@localhost ~]$ sudo mkfs.xfs /dev/vg-data/lv-data\n[sudo] itadmin 님의 암호:\nmeta-data=/dev/vg-data/lv-data   isize=512    agcount=4, agsize=1965824 블록\n         =                       sectsz=512   attr=2, projid32bit=1\n         =                       crc=1        finobt=0, sparse=0\ndata     =                       bsize=4096   블록=7863296, imaxpct=25\n         =                       sunit=0      swidth=0 블록\nnaming   =version 2              bsize=4096   ascii-ci=0 ftype=1\n\u003cspan class=\"hljs-built_in\"\u003elog\u003c/span\u003e      =internal \u003cspan class=\"hljs-built_in\"\u003elog\u003c/span\u003e           bsize=4096   블록=3839, version=2\n         =                       sectsz=512   sunit=0 blks, lazy-count=1\nrealtime =none                   extsz=4096   블록=0, rtextents=0\n[itadmin@localhost ~]$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e.mkfs는 \"파일 시스템 생성\"을 의미하며, 이를 수행합니다. 이 경우에는 xfs 파일 시스템을 생성하려고 하므로 mkfs.xfs를 사용합니다. xfs 파일 시스템은 여러 측면에서 ext4보다 업그레이드된 것이며 RHEL 서버에서 기본 파일 시스템입니다. 그럼에도 불구하고 상황에 따라 ext4를 사용하는 것이 xfs보다 우위를 가질 수 있습니다.\u003c/p\u003e\n\u003cp\u003e새로 생성된 논리 볼륨을 마운트하려면 해당 마운트 포인트를 만들고 다음 단계를 수행합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e[itadmin@localhost ~]$ sudo \u003cspan class=\"hljs-built_in\"\u003emkdir\u003c/span\u003e /data\n[itadmin@localhost ~]$ sudo mount /dev/vg-data/lv-data /data\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저희는 새 파일 시스템이 마운트될 새로운 디렉토리를 생성했어요. /data 하위에 있는 모든 것들은 이 새 논리 볼륨에 속합니다.\u003c/p\u003e\n\u003cp\u003e— 부가적인 사항으로 — 새로운 마운트 포인트를 /etc/fstab 파일에 추가해야 부팅 중에도 지속되도록 해야 해요.\u003c/p\u003e\n\u003cp\u003e새롭게 마운트된 /data 디렉토리를 df 명령어로 살펴봅시다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e파일 시스템이 실제로 XFS인지 확인해야 하기 때문에 df 명령에 \"T\" 스위치가 필요합니다. 이 스위치는 파일 시스템 유형을 보여주는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e우리의 논리 볼륨 lv-data는 모두 준비되어 있고 /data에 마운트되어 있습니다!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e작업이 완료되었습니다!\u003c/p\u003e\n\u003ch2\u003e논리 볼륨 확장 방법\u003c/h2\u003e\n\u003cp\u003e우리는 처음부터 논리 볼륨을 만드는 방법을 보았지만, 대부분의 경우 이미 존재하는 논리 볼륨의 크기를 늘려야 하므로 더 많은 데이터를 수용할 수 있게 할 필요가 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e테이블 태그를 Markdown 형식으로 변경해주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_5.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e우리는 Volume Group vg-data에 사용 가능한 빈 공간이 없음을 확인할 수 있습니다. 새 물리 볼륨을 추가해 보겠습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e먼저, 이 새 드라이브를 사용할 수 있도록 새 파티션을 만들고 \"LVM\" 레이블을 할당해야 합니다. 이를 위해 아래와 같이 fdisk를 사용하여 수행합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*qB2R3x5Zc2Lt46xIq-bEFQ.gif\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003efdisk를 사용하여 새 파티션을 만들고, 크기를 지정하지 않은 전체 크기를 할당했어요 (값을 지정하지 않고 Enter를 누르면 사용 가능한 크기를 할당합니다).\u003c/li\u003e\n\u003cli\u003e정확한 라벨을 지정해야 해요, \"LVM 타입\"으로 만들기 위해 필요한 라벨은 8e에요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e디스크가 준비되었고, 이제 물리 볼륨을 생성할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[root@localhost ~]$ pvcreate /dev/sdc1\n  \u003cspan class=\"hljs-title class_\"\u003ePhysical\u003c/span\u003e volume \u003cspan class=\"hljs-string\"\u003e\"/dev/sdc1\"\u003c/span\u003e successfully created.\n[root@localhost ~]$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e생성 완료! 이제 vg-data 볼륨 그룹에 추가하려면, vgextend 명령어를 사용해요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e[root@localhost ~]$ vgextend vg-data /dev/sdc1\n  Volume group \u003cspan class=\"hljs-string\"\u003e\"vg-data\"\u003c/span\u003e successfully extended\n[root@localhost ~]$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVG가 확장되었습니다! 한 번 더 확인해 봐요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e훌륭해요! 이제 vg-data에 25GB의 여유 공간이 있는 것을 확인할 수 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e지금은 Logical Volume에 뛰어들어 보겠습니다. 지금 상태는 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_7.png\" alt=\"Logical Volume Status\"\u003e\u003c/p\u003e\n\u003cp\u003e우리는 lvextend 명령어로 lv-data Logical Volume을 확장했습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[root@localhost ~]$ lvextend -l +\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e%\u003cspan class=\"hljs-variable constant_\"\u003eFREE\u003c/span\u003e /dev/vg-data/lv-data\n  \u003cspan class=\"hljs-title class_\"\u003eSize\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e logical volume vg-data/lv-data changed \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u0026#x3C;\u003cspan class=\"hljs-number\"\u003e30.00\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGiB\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e7679\u003c/span\u003e extents) to \u003cspan class=\"hljs-number\"\u003e54.99\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGiB\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e14078\u003c/span\u003e extents).\n  \u003cspan class=\"hljs-title class_\"\u003eLogical\u003c/span\u003e volume vg-data/lv-data successfully resized.\n[root@localhost ~]$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003elvextend 명령은 lv-data 논리 볼륨을 확장하며, +100%FREE 옵션은 해당 볼륨을 볼륨 그룹에서 남아있는 모든 가능한 크기로 확장합니다.\u003c/li\u003e\n\u003cli\u003e만약 우리가 논리 볼륨을 특정 크기로 확장하고 싶었다면, 예를 들어 5GB로 확장하고 싶다면 다음과 같이 진행할 것입니다:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[root@localhost ~]$ lvextend -L +5G /dev/vg-data/lv-data\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 우리의 논리 볼륨 상태를 확인해봅시다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_8.png\" alt=\"논리 볼륨 상태\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e출력을 통해 LSize가 실제로 증가했고, 논리 볼륨이 확장되었습니다!\u003c/p\u003e\n\u003cp\u003e아직 끝나지 않았어요! 마지막 단계는 새로 추가된 저장 용량을 사용할 수 있도록 파일 시스템의 크기를 조정하는 것입니다. 이 작업은 xfs_growfs 명령으로 수행할 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[root@localhost ~]$ xfs_growfs /dev/vg-data/lv-data\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*yu72eMpz12FUdIOTeL0qgg.gif\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e데이터 블록이 변경되고 파일 시스템이 확장되었음을 알 수 있습니다.\u003c/li\u003e\n\u003cli\u003e여기서 언급해야 할 또 다른 훌륭한 점은 파일 시스템을 확장할 때 마운트 포인트인 /data를 해제할 필요가 없었다는 것입니다!\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003edf -kh 명령의 출력에서 /data 마운트 포인트가 확장되었음을 확인할 수 있습니다. 여기에는 lv-data 논리 볼륨이 마운트된 곳입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume_9.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e모두 완료되었습니다. 논리 볼륨이 성공적으로 확장되었습니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 글은 Linux에서 논리 볼륨 매니저에 대해 간략히 다룬 내용이었습니다. 논리 볼륨을 생성하고 확장하는 방법에 대해 설명했습니다. 궁금한 점이나 의견, 추가할 내용이 있으면 자유롭게 남겨주세요.\u003c/p\u003e\n\u003cp\u003e읽어주셔서 감사합니다! 다음 포스트에서 만나요 :)\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-LVMinLinuxCreateandExtendaLogicalVolume"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>