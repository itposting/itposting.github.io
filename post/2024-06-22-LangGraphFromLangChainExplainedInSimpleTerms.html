<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>LangChain의 새로운 도구, LangGraph 쉽게 설명하기 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="LangChain의 새로운 도구, LangGraph 쉽게 설명하기 | itposting" data-gatsby-head="true"/><meta property="og:title" content="LangChain의 새로운 도구, LangGraph 쉽게 설명하기 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms" data-gatsby-head="true"/><meta name="twitter:title" content="LangChain의 새로운 도구, LangGraph 쉽게 설명하기 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 20:43" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_buildManifest.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">LangChain의 새로운 도구, LangGraph 쉽게 설명하기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="LangChain의 새로운 도구, LangGraph 쉽게 설명하기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>소개</h1>
<p>하지만 왜 우리는 상태와 상태 전이 제어로 다시 돌아가고 있을까요? 자율 인공 지능 에이전트와 함께 우리는 상태 제어와 전이 개념을 넘어서 왔다고 생각했는데요?</p>
<p>자율 에이전트의 출력을 살펴보면, 에이전트가 지속적으로 생성하는 작업 순서를 주목할 것입니다.</p>
<p>LangGraph의 목표는 자율 인공 지능 에이전트를 실행할 때 일정한 수준의 제어를 갖는 것입니다.</p>
<div class="content-ad"></div>
<p>죄송합니다. 이 기사가 길었지만, Graph의 기본 원칙이 무엇인지 정말로 파악하고 싶었습니다.</p>
<h1>현황</h1>
<p>아래 이미지를 고려해보면, 이것이 대부분의 사람들이 대화형 UI를 위한 대화와 프로세스 흐름을 생성하는 사용자 인터페이스의 디자인 및 개발을 알게 된 방식입니다.</p>
<p>디자인 기능은 노드 및 엣지라는 두 가지 주요 범주로 나뉠 수 있습니다.</p>
<div class="content-ad"></div>
<p>노드는 블록으로, 때로는 자산으로도 불립니다. 아래 그림에서 디자인 캔버스에는 다섯 개의 노드가 있습니다. 이 노드 간에는 링크 또는 엣지라고도 하는 연결이 있습니다. 엣지는 가능한 대상 노드나 노드를 보여줍니다.</p>
<h2>프롬프트 체이닝</h2>
<p>대형 언어 모델의 출현과 함께 프롬프트 체이닝이 등장했습니다...</p>
<p>프롬프트 체이닝은 언어 모델과 작업할 때 사용되는 기술로, 여러 프롬프트(노드)가 서로 순차적으로 연결(엣지를 통해)되어 서로 관련된 작업이나 단계를 안내하는 것으로 설명될 수 있습니다.</p>
<div class="content-ad"></div>
<p>이 방법은 큰 작업을 작은 관리 가능한 부분으로 나눠 더 복잡하고 세밀한 결과물을 얻는 데 사용됩니다.</p>
<p>다음은 프롬프트 체이닝 작동 방식에 대해 간단히 설명한 것입니다:</p>
<ul>
<li>작업 분해(노드): 복잡한 작업이 작은 순차적인 단계로 나누어집니다. 각 단계는 전체 목표의 특정 부분을 달성하는 데 사용됩니다.</li>
<li>각 단계에 대한 프롬프트 생성(엣지): 각 단계에 대해 필수 출력물 생성을 위해 구체적인 프롬프트가 만들어집니다. 이러한 프롬프트는 해당 부분 작업에 집중되고 명확하게 설계됩니다.</li>
<li>순차 실행: 언어 모델은 첫 번째 프롬프트를 처리하고 출력물을 생성합니다. 이 출력물은 다음 시퀀스의 다음 프롬프트의 일부로 사용됩니다.</li>
</ul>
<p>그러나 알아둬야 할 점은, 프롬프트 체이닝은 챗봇 흐름 구축과 동일한 원칙에 기반합니다. 따라서 이전과 같은 문제, 즉 엄격한 상태 머신이 존재합니다.</p>
<div class="content-ad"></div>
<p>참으로, 프롬프트 체이닝에는 각 노드의 입력에 몇 가지 유연성을 도입하는 요소가 있어서 출력에는 동적 변화가 발생합니다. 그러나 전반적으로 시퀀스는 고정되고 엄격하게 유지됩니다.</p>
<h2>도전 과제</h2>
<p>이 방법론은 흐름을 세심하게 지정해야 하며 각 결정 지점을 정의해야 합니다. 이러한 이유로 본질적으로 상태 기계이며 대화 트리는 서로 다른 상태(노드)와 대화가 이동해야 하는 결정 지점(엣지)에 의해 정의됩니다.</p>
<p>엣지는 대화 상태/대화 턴이 이동할 수 있는 옵션으로 볼 수도 있습니다.</p>
<div class="content-ad"></div>
<p>그래서 이 방법론의 한계로 인해 너무 엄격하다는 도전 과제에 닥치게 되었습니다. 대체로 변화를 원하는 욕구가 있으며, 융통성을 도입하고 싶어하는 분위기입니다.</p>
<h1>에이전트 입력</h1>
<p>자율 주체들은 최근에 소개되었으며, 에이전트의 자율성 수준은 놀라울 정도였습니다. 에이전트는 실시간으로 사건의 연쇄 또는 순서를 생성하고 이 일시적인 연쇄를 따라 최종적인 답변이 도출될 때까지 따릅니다.</p>
<p>이것을 일회용 연쇄로 생각할 수 있습니다.</p>
<div class="content-ad"></div>
<p>아래 예시를 고려해보면, 에이전트에게 매우 모호한 질문을 할 수 있습니다. 예를 들어 "아이폰의 아버지로 평가받는 사람은 누구이며, 그의 출생 연도의 제곱근은 무엇입니까?"</p>
<p>또는</p>
<p>"일반적으로 아이폰의 아버지로 평가받는 사람의 출생 연도의 제곱근은 무엇입니까?"</p>
<p>그리고 아래와 같이, 에이전트는 실시간으로 체인을 생성하여 질문을 반영하고 행동, 관찰, 사고, 행동, 관찰, 사고의 프로세스를 거쳐 최종 답변에 도달합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">> 새 <span class="hljs-title class_">AgentExecutor</span> 체인에 들어갔어요...
아이폰의 아버지로 알려진 사람과 태어난 해를 알아내야 해요. 그리고 그의 출생 연도의 제곱근을 계산할 거예요.
행동: 검색
행동 입력: 아이폰 아버지 출생 연도
관찰: 가족. 스티븐 폴 잡스는 조앤 캐롤 스키블과 아브둘파타 <span class="hljs-string">"존"</span> 잔달리(아랍어: عبد الف ...)가 산프란시스코, 캘리포니아에서 <span class="hljs-number">1955</span>년 <span class="hljs-number">2</span>월 <span class="hljs-number">24</span>일에 태어났어요.
생각: 스티브 잡스가 아이폰의 아버지로 알려지고 <span class="hljs-number">1955</span>년에 태어났다는 걸 알았어요. 이제 그의 출생 연도의 제곱근을 계산할 거예요.
행동: 계산기
행동 입력: <span class="hljs-title function_">sqrt</span>(<span class="hljs-number">1955</span>)
관찰: 답변: <span class="hljs-number">44.21538193886829</span>
생각: 이제 마지막 답을 알게 되었어요.
최종 답변: 스티브 잡스가 아이폰의 아버지로 알려지고, 그의 태어난 연도(<span class="hljs-number">1955</span>년)의 제곱근은 약 <span class="hljs-number">44.22</span>입니다.

> 체인을 마쳤어요.
<span class="hljs-string">'스티브 잡스가 아이폰의 아버지로 알려지고, 그의 태어난 연도(1955년)의 제곱근은 약 44.22입니다.
</span></code></pre>
<h2>도전과제</h2>
<p>에이전트와 저에게 가장 많이 들은 상수적 비판점은 에이전트들의 높은 자율성입니다.</p>
<p>생산자들은 에이전트에 어느 정도의 통제권을 가지고 싶어해요.</p>
<div class="content-ad"></div>
<p>헤이, 에이전트의 등장으로 우리는 지나치게 제어되고 엄격한 상황에서 더 큰 유연성으로 이동했지만 제어 부재로 인한 문제가 있습니다.</p>
<h1>LangChain에서 LangGraph로 전환해보세요</h1>
<h2>하지만 먼저, 데이터 유형으로서의 그래프란 무엇인가요?</h2>
<h2>그래프(추상 데이터 유형)은 무엇인가요?</h2>
<div class="content-ad"></div>
<p>그래프 데이터의 개념은 처음에는 어렵게 느껴질 수 있지만, 여기서 그것을 쉽게 설명해보겠습니다.</p>
<p>실제로 그래프는 추상 데이터 유형이에요...</p>
<p>추상 데이터 유형은 데이터 유형에 대한 수학적 모델로, 데이터를 사용하는 사람의 관점에서 정의된 동작 (의미론)에 의해 정의됩니다.</p>
<p>추상 데이터 유형은 데이터 구조와 대조적입니다. 데이터 구조는 데이터의 구체적 표현이며, 구현자의 관점이 아닌 사용자의 관점에서 정의됩니다. 이 데이터 구조는 덜 해석하기 어려우며 해석하기 쉬워요.</p>
<div class="content-ad"></div>
<h2>방향 그래프</h2>
<p>방향 그래프(또는 유향 그래프)는 방향성이 있는 엣지로 연결된 노드 집합으로 이루어진 그래프입니다.</p>
<p>그래프 데이터 구조는 유향 그래프의 경우 노드의 유한 집합과 무방향 그래프의 경우 이러한 노드들의 순서가 없는 쌍의 집합으로 구성됩니다.</p>
<p>아래의 그래프 표현을 고려할 때, 노드와 함께 엣지 및 엣지 옵션이 표시됩니다.</p>
<div class="content-ad"></div>
<h2>LangGraph</h2>
<p>다시 한번 아래 이미지를 보시면, 왼쪽에는 LangGraph Python 코드 조각이 표시되어 있고, 오른쪽에는 해당 그래프가 그려져 있습니다. 코드에서 노드가 정의된 부분을 보면, builder.add_node에 ReturnNodeValue가 사용되어 있습니다. 각 엣지가 정의된 노드에 대해 builder.add_edge가 호출됩니다.</p>
<p>또한 a를 시작점으로, d를 완료점으로 설정해 두었음을 확인할 수 있습니다.</p>
<p>LangGraph는 에이전트 런타임에서 자주 필요한 순환 그래프를 생성하기 위해 LangChain 위에 구축된 모듈입니다.</p>
<div class="content-ad"></div>
<p>LangChain의 큰 가치 제안 중 하나는 사용자 정의 체인을 쉽게 만들 수 있는 능력, 즉 flow engineering입니다. LangGraph를 LangChain 에이전트와 결합하여, 에이전트는 지향적이며 순환이 될 수 있습니다.</p>
<p>Directed Acyclic Graph (DAG)는 컴퓨터 과학과 수학에서 사용되는 그래프 유형입니다. 간단히 설명하면 다음과 같습니다:</p>
<p>Directed: 노드(또는 정점) 사이의 각 연결(또는 에지)에는 일방향의 방향이 있습니다. 한 노드에서 다른 노드로 갈 수 있는 방향을 보여줍니다.</p>
<p>Acyclic: 어떤 사이클도 없습니다. 즉, 한 노드에서 시작하여 방향을 따라가면 결코 같은 노드로 되돌아갈 수 없습니다. 루프에 갇히는 방법이 없습니다.</p>
<div class="content-ad"></div>
<p>가족 트리나 플로우차트와 같이 앞으로만 움직이고 시작점으로 돌아갈 수 없는 구조로 생각해보세요.</p>
<p>더 복잡한 LLM 응용 프로그램을 개발할 때 관찰되는 일반적인 패턴은 런타임에 순환이 도입되는 것입니다. 이러한 순환이 자주 발생하며 프로세스의 다음 단계를 결정하는 데 LLM을 사용합니다.</p>
<p>LLM의 중요한 장점 중 하나는 이러한 추론 작업을 수행할 수 있는 능력이며, 사실상 for 루프에서 LLM과 같이 작동하는 것처럼 기능합니다. 이러한 접근 방식을 사용하는 시스템들은 종종 에이전트로 언급됩니다.</p>
<h1>에이전트 및 제어</h1>
<div class="content-ad"></div>
<p>하지만 루핑 에이전트는 종종 다양한 단계에서 세부적인 제어가 필요합니다.</p>
<p>제작자들은 에이전트가 항상 특정 도구를 먼저 호출하도록 보장하거나 도구를 활용하는 방법에 대해 더 많은 제어를 필요로 할 수 있습니다.</p>
<p>게다가, 현재 상태에 따라 에이전트에 대해 다른 프롬프트를 사용하길 원할 수도 있습니다.</p>
<h1>좁은 인터페이스 노출</h1>
<div class="content-ad"></div>
<p>LangGraph은 LangChain을 기반으로 한 간소화된 인터페이스를 제공합니다.</p>
<h1>LangGraph을 선택하는 이유</h1>
<p>LangGraph는 프레임워크에 구애받지 않으며, 각 노드는 일반 Python 함수로 작동합니다.</p>
<p>스트리밍, 비동기, 일괄 호출에 대한 공통 인터페이스인 Runnable API를 확장하여 다음과 같은 기능을 지원합니다:</p>
<div class="content-ad"></div>
<ul>
<li>여러 대화 턴이나 도구 사용 사이에서 매끄러운 상태 관리</li>
<li>동적 기준에 따라 노드 간 유연한 라우팅</li>
<li>LLM과 인간 개입 간 부드러운 전환</li>
<li>장기간 또는 다중 세션 애플리케이션을 위한 지속성</li>
</ul>
<h1>LangGraph 챗봇</h1>
<p>아래는 Anthropik 모델을 기반으로 한 작동 중인 LangChain 챗봇입니다. 기본 코드는 그들의 요리책에 있는 LangChain 예제 코드를 복사했습니다.</p>
<pre><code class="hljs language-js">%%capture --no-stderr
%pip install -U langgraph langsmith

# 이 튜토리얼에서 사용합니다; <span class="hljs-title class_">LangGraph</span>에 필요한 것은 아닙니다
%pip install -U langchain_anthropic


#################################
<span class="hljs-keyword">import</span> getpass
<span class="hljs-keyword">import</span> os


def <span class="hljs-title function_">_set_env</span>(<span class="hljs-attr">var</span>: str):
    <span class="hljs-keyword">if</span> not os.<span class="hljs-property">environ</span>.<span class="hljs-title function_">get</span>(<span class="hljs-keyword">var</span>):
        os.<span class="hljs-property">environ</span>[<span class="hljs-keyword">var</span>] = getpass.<span class="hljs-title function_">getpass</span>(f<span class="hljs-string">"{var}: "</span>)


<span class="hljs-title function_">_set_env</span>(<span class="hljs-string">"ANTHROPIC_API_KEY"</span>)
#################################
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-title class_">Annotated</span>

<span class="hljs-keyword">from</span> typing_extensions <span class="hljs-keyword">import</span> <span class="hljs-title class_">TypedDict</span>

<span class="hljs-keyword">from</span> langgraph.<span class="hljs-property">graph</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">StateGraph</span>
<span class="hljs-keyword">from</span> langgraph.<span class="hljs-property">graph</span>.<span class="hljs-property">message</span> <span class="hljs-keyword">import</span> add_messages


<span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span>(<span class="hljs-title class_">TypedDict</span>):
    # 메시지는 <span class="hljs-string">"list"</span> 유형입니다. 주석의 <span class="hljs-string">`add_messages`</span> 함수
    #은이 상태 키가 어떻게 업데이트되어야하는지 정의합니다.
    #(이 경우, 목록에 메시지를 추가하여 덮어쓰지 않는 것)
    <span class="hljs-attr">messages</span>: <span class="hljs-title class_">Annotated</span>[list, add_messages]


graph_builder = <span class="hljs-title class_">StateGraph</span>(<span class="hljs-title class_">State</span>)
#################################
<span class="hljs-keyword">from</span> langchain_anthropic <span class="hljs-keyword">import</span> <span class="hljs-title class_">ChatAnthropic</span>

llm = <span class="hljs-title class_">ChatAnthropic</span>(model=<span class="hljs-string">"claude-3-haiku-20240307"</span>)


def <span class="hljs-title function_">chatbot</span>(<span class="hljs-attr">state</span>: <span class="hljs-title class_">State</span>):
    <span class="hljs-keyword">return</span> {<span class="hljs-string">"messages"</span>: [llm.<span class="hljs-title function_">invoke</span>(state[<span class="hljs-string">"messages"</span>])]}


# 첫 번째 인수는 고유한 노드 이름입니다.
# 두 번째 인수는 노드가 사용될 때 호출되는 함수 또는 객체입니다.
graph_builder.<span class="hljs-title function_">add_node</span>(<span class="hljs-string">"chatbot"</span>, chatbot)
#################################
graph_builder.<span class="hljs-title function_">set_entry_point</span>(<span class="hljs-string">"chatbot"</span>)

#################################
graph_builder.<span class="hljs-title function_">set_finish_point</span>(<span class="hljs-string">"chatbot"</span>)
#################################
graph = graph_builder.<span class="hljs-title function_">compile</span>()
#################################
<span class="hljs-keyword">from</span> <span class="hljs-title class_">IPython</span>.<span class="hljs-property">display</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Image</span>, display

<span class="hljs-attr">try</span>:
    <span class="hljs-title function_">display</span>(<span class="hljs-title class_">Image</span>(graph.<span class="hljs-title function_">get_graph</span>().<span class="hljs-title function_">draw_mermaid_png</span>()))
except <span class="hljs-title class_">Exception</span>:
    # 추가적인 종속성이 필요하며 선택 사항입니다
    pass
#################################
<span class="hljs-keyword">while</span> <span class="hljs-title class_">True</span>:
    user_input = <span class="hljs-title function_">input</span>(<span class="hljs-string">"사용자: "</span>)
    <span class="hljs-keyword">if</span> user_input.<span class="hljs-title function_">lower</span>() <span class="hljs-keyword">in</span> [<span class="hljs-string">"quit"</span>, <span class="hljs-string">"exit"</span>, <span class="hljs-string">"q"</span>]:
        <span class="hljs-title function_">print</span>(<span class="hljs-string">"안녕히가세요!"</span>)
        <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> graph.<span class="hljs-title function_">stream</span>({<span class="hljs-string">"messages"</span>: (<span class="hljs-string">"user"</span>, user_input)}):
        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> event.<span class="hljs-title function_">values</span>():
            <span class="hljs-title function_">print</span>(<span class="hljs-string">"보조:"</span>, value[<span class="hljs-string">"messages"</span>][-<span class="hljs-number">1</span>].<span class="hljs-property">content</span>)
#################################
</code></pre>
<div class="content-ad"></div>
<p>아래는 그래픽이 데이터의 흐름을 보여주는 방법을 보여줍니다.</p>
<hr>
<p>마지막으로</p>
<p>그래프 데이터 유형은 데이터의 시각적 표현을 보여주는 강력한 도구입니다. 시각적 표현 이상으로, 서로 다른 노드 간의 표현은 데이터 노드의 공간적 표현을 만드는 데 이상적입니다.</p>
<p>데이터 사용자의 관점에서 그래프 데이터 유형은 데이터의 의미론적 행동에 이상적입니다.</p>
<div class="content-ad"></div>
<p>⭐️ 저를 팔로우해서 대형 언어 모델에 관한 업데이트를 받아보세요 ⭐️</p>
<p><img src="/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_0.png" alt="이미지"></p>
<p>저는 현재 Kore AI의 Chief Evangelist입니다. AI와 언어가 교차하는 모든 것을 탐구하고 쓰고 있습니다. 대형 언어 모델, 챗봇, 음성봇, 개발 프레임워크, 데이터 중심의 잠재 공간 등 다양한 주제에 대해 다룹니다.</p>
<p><img src="/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_1.png" alt="이미지"></p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_2.png" alt="Image 2"></p>
<p><img src="/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_3.png" alt="Image 3"></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"LangChain의 새로운 도구, LangGraph 쉽게 설명하기","description":"","date":"2024-06-22 20:43","slug":"2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms","content":"\n\n# 소개\n\n하지만 왜 우리는 상태와 상태 전이 제어로 다시 돌아가고 있을까요? 자율 인공 지능 에이전트와 함께 우리는 상태 제어와 전이 개념을 넘어서 왔다고 생각했는데요?\n\n자율 에이전트의 출력을 살펴보면, 에이전트가 지속적으로 생성하는 작업 순서를 주목할 것입니다.\n\nLangGraph의 목표는 자율 인공 지능 에이전트를 실행할 때 일정한 수준의 제어를 갖는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n죄송합니다. 이 기사가 길었지만, Graph의 기본 원칙이 무엇인지 정말로 파악하고 싶었습니다.\n\n# 현황\n\n아래 이미지를 고려해보면, 이것이 대부분의 사람들이 대화형 UI를 위한 대화와 프로세스 흐름을 생성하는 사용자 인터페이스의 디자인 및 개발을 알게 된 방식입니다.\n\n디자인 기능은 노드 및 엣지라는 두 가지 주요 범주로 나뉠 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n노드는 블록으로, 때로는 자산으로도 불립니다. 아래 그림에서 디자인 캔버스에는 다섯 개의 노드가 있습니다. 이 노드 간에는 링크 또는 엣지라고도 하는 연결이 있습니다. 엣지는 가능한 대상 노드나 노드를 보여줍니다.\n\n## 프롬프트 체이닝\n\n대형 언어 모델의 출현과 함께 프롬프트 체이닝이 등장했습니다...\n\n프롬프트 체이닝은 언어 모델과 작업할 때 사용되는 기술로, 여러 프롬프트(노드)가 서로 순차적으로 연결(엣지를 통해)되어 서로 관련된 작업이나 단계를 안내하는 것으로 설명될 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법은 큰 작업을 작은 관리 가능한 부분으로 나눠 더 복잡하고 세밀한 결과물을 얻는 데 사용됩니다.\n\n다음은 프롬프트 체이닝 작동 방식에 대해 간단히 설명한 것입니다:\n\n- 작업 분해(노드): 복잡한 작업이 작은 순차적인 단계로 나누어집니다. 각 단계는 전체 목표의 특정 부분을 달성하는 데 사용됩니다.\n- 각 단계에 대한 프롬프트 생성(엣지): 각 단계에 대해 필수 출력물 생성을 위해 구체적인 프롬프트가 만들어집니다. 이러한 프롬프트는 해당 부분 작업에 집중되고 명확하게 설계됩니다.\n- 순차 실행: 언어 모델은 첫 번째 프롬프트를 처리하고 출력물을 생성합니다. 이 출력물은 다음 시퀀스의 다음 프롬프트의 일부로 사용됩니다.\n\n그러나 알아둬야 할 점은, 프롬프트 체이닝은 챗봇 흐름 구축과 동일한 원칙에 기반합니다. 따라서 이전과 같은 문제, 즉 엄격한 상태 머신이 존재합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참으로, 프롬프트 체이닝에는 각 노드의 입력에 몇 가지 유연성을 도입하는 요소가 있어서 출력에는 동적 변화가 발생합니다. 그러나 전반적으로 시퀀스는 고정되고 엄격하게 유지됩니다.\n\n## 도전 과제\n\n이 방법론은 흐름을 세심하게 지정해야 하며 각 결정 지점을 정의해야 합니다. 이러한 이유로 본질적으로 상태 기계이며 대화 트리는 서로 다른 상태(노드)와 대화가 이동해야 하는 결정 지점(엣지)에 의해 정의됩니다.\n\n엣지는 대화 상태/대화 턴이 이동할 수 있는 옵션으로 볼 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래서 이 방법론의 한계로 인해 너무 엄격하다는 도전 과제에 닥치게 되었습니다. 대체로 변화를 원하는 욕구가 있으며, 융통성을 도입하고 싶어하는 분위기입니다.\n\n# 에이전트 입력\n\n자율 주체들은 최근에 소개되었으며, 에이전트의 자율성 수준은 놀라울 정도였습니다. 에이전트는 실시간으로 사건의 연쇄 또는 순서를 생성하고 이 일시적인 연쇄를 따라 최종적인 답변이 도출될 때까지 따릅니다.\n\n이것을 일회용 연쇄로 생각할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 예시를 고려해보면, 에이전트에게 매우 모호한 질문을 할 수 있습니다. 예를 들어 \"아이폰의 아버지로 평가받는 사람은 누구이며, 그의 출생 연도의 제곱근은 무엇입니까?\"\n\n또는 \n\n\"일반적으로 아이폰의 아버지로 평가받는 사람의 출생 연도의 제곱근은 무엇입니까?\" \n\n그리고 아래와 같이, 에이전트는 실시간으로 체인을 생성하여 질문을 반영하고 행동, 관찰, 사고, 행동, 관찰, 사고의 프로세스를 거쳐 최종 답변에 도달합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e 새 AgentExecutor 체인에 들어갔어요...\n아이폰의 아버지로 알려진 사람과 태어난 해를 알아내야 해요. 그리고 그의 출생 연도의 제곱근을 계산할 거예요.\n행동: 검색\n행동 입력: 아이폰 아버지 출생 연도\n관찰: 가족. 스티븐 폴 잡스는 조앤 캐롤 스키블과 아브둘파타 \"존\" 잔달리(아랍어: عبد الف ...)가 산프란시스코, 캘리포니아에서 1955년 2월 24일에 태어났어요.\n생각: 스티브 잡스가 아이폰의 아버지로 알려지고 1955년에 태어났다는 걸 알았어요. 이제 그의 출생 연도의 제곱근을 계산할 거예요.\n행동: 계산기\n행동 입력: sqrt(1955)\n관찰: 답변: 44.21538193886829\n생각: 이제 마지막 답을 알게 되었어요.\n최종 답변: 스티브 잡스가 아이폰의 아버지로 알려지고, 그의 태어난 연도(1955년)의 제곱근은 약 44.22입니다.\n\n\u003e 체인을 마쳤어요.\n'스티브 잡스가 아이폰의 아버지로 알려지고, 그의 태어난 연도(1955년)의 제곱근은 약 44.22입니다.\n```\n\n## 도전과제\n\n에이전트와 저에게 가장 많이 들은 상수적 비판점은 에이전트들의 높은 자율성입니다.\n\n생산자들은 에이전트에 어느 정도의 통제권을 가지고 싶어해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n헤이, 에이전트의 등장으로 우리는 지나치게 제어되고 엄격한 상황에서 더 큰 유연성으로 이동했지만 제어 부재로 인한 문제가 있습니다.\n\n# LangChain에서 LangGraph로 전환해보세요\n\n## 하지만 먼저, 데이터 유형으로서의 그래프란 무엇인가요?\n\n## 그래프(추상 데이터 유형)은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그래프 데이터의 개념은 처음에는 어렵게 느껴질 수 있지만, 여기서 그것을 쉽게 설명해보겠습니다.\n\n실제로 그래프는 추상 데이터 유형이에요...\n\n추상 데이터 유형은 데이터 유형에 대한 수학적 모델로, 데이터를 사용하는 사람의 관점에서 정의된 동작 (의미론)에 의해 정의됩니다.\n\n추상 데이터 유형은 데이터 구조와 대조적입니다. 데이터 구조는 데이터의 구체적 표현이며, 구현자의 관점이 아닌 사용자의 관점에서 정의됩니다. 이 데이터 구조는 덜 해석하기 어려우며 해석하기 쉬워요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 방향 그래프\n\n방향 그래프(또는 유향 그래프)는 방향성이 있는 엣지로 연결된 노드 집합으로 이루어진 그래프입니다.\n\n그래프 데이터 구조는 유향 그래프의 경우 노드의 유한 집합과 무방향 그래프의 경우 이러한 노드들의 순서가 없는 쌍의 집합으로 구성됩니다.\n\n아래의 그래프 표현을 고려할 때, 노드와 함께 엣지 및 엣지 옵션이 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## LangGraph\n\n다시 한번 아래 이미지를 보시면, 왼쪽에는 LangGraph Python 코드 조각이 표시되어 있고, 오른쪽에는 해당 그래프가 그려져 있습니다. 코드에서 노드가 정의된 부분을 보면, builder.add_node에 ReturnNodeValue가 사용되어 있습니다. 각 엣지가 정의된 노드에 대해 builder.add_edge가 호출됩니다.\n\n또한 a를 시작점으로, d를 완료점으로 설정해 두었음을 확인할 수 있습니다.\n\nLangGraph는 에이전트 런타임에서 자주 필요한 순환 그래프를 생성하기 위해 LangChain 위에 구축된 모듈입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLangChain의 큰 가치 제안 중 하나는 사용자 정의 체인을 쉽게 만들 수 있는 능력, 즉 flow engineering입니다. LangGraph를 LangChain 에이전트와 결합하여, 에이전트는 지향적이며 순환이 될 수 있습니다.\n\nDirected Acyclic Graph (DAG)는 컴퓨터 과학과 수학에서 사용되는 그래프 유형입니다. 간단히 설명하면 다음과 같습니다:\n\nDirected: 노드(또는 정점) 사이의 각 연결(또는 에지)에는 일방향의 방향이 있습니다. 한 노드에서 다른 노드로 갈 수 있는 방향을 보여줍니다.\n\nAcyclic: 어떤 사이클도 없습니다. 즉, 한 노드에서 시작하여 방향을 따라가면 결코 같은 노드로 되돌아갈 수 없습니다. 루프에 갇히는 방법이 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가족 트리나 플로우차트와 같이 앞으로만 움직이고 시작점으로 돌아갈 수 없는 구조로 생각해보세요.\n\n더 복잡한 LLM 응용 프로그램을 개발할 때 관찰되는 일반적인 패턴은 런타임에 순환이 도입되는 것입니다. 이러한 순환이 자주 발생하며 프로세스의 다음 단계를 결정하는 데 LLM을 사용합니다.\n\nLLM의 중요한 장점 중 하나는 이러한 추론 작업을 수행할 수 있는 능력이며, 사실상 for 루프에서 LLM과 같이 작동하는 것처럼 기능합니다. 이러한 접근 방식을 사용하는 시스템들은 종종 에이전트로 언급됩니다.\n\n# 에이전트 및 제어\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n하지만 루핑 에이전트는 종종 다양한 단계에서 세부적인 제어가 필요합니다.\n\n제작자들은 에이전트가 항상 특정 도구를 먼저 호출하도록 보장하거나 도구를 활용하는 방법에 대해 더 많은 제어를 필요로 할 수 있습니다.\n\n게다가, 현재 상태에 따라 에이전트에 대해 다른 프롬프트를 사용하길 원할 수도 있습니다.\n\n# 좁은 인터페이스 노출\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLangGraph은 LangChain을 기반으로 한 간소화된 인터페이스를 제공합니다.\n\n# LangGraph을 선택하는 이유\n\nLangGraph는 프레임워크에 구애받지 않으며, 각 노드는 일반 Python 함수로 작동합니다.\n\n스트리밍, 비동기, 일괄 호출에 대한 공통 인터페이스인 Runnable API를 확장하여 다음과 같은 기능을 지원합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 여러 대화 턴이나 도구 사용 사이에서 매끄러운 상태 관리\n- 동적 기준에 따라 노드 간 유연한 라우팅\n- LLM과 인간 개입 간 부드러운 전환\n- 장기간 또는 다중 세션 애플리케이션을 위한 지속성\n\n# LangGraph 챗봇\n\n아래는 Anthropik 모델을 기반으로 한 작동 중인 LangChain 챗봇입니다. 기본 코드는 그들의 요리책에 있는 LangChain 예제 코드를 복사했습니다.\n\n```js\n%%capture --no-stderr\n%pip install -U langgraph langsmith\n\n# 이 튜토리얼에서 사용합니다; LangGraph에 필요한 것은 아닙니다\n%pip install -U langchain_anthropic\n\n\n#################################\nimport getpass\nimport os\n\n\ndef _set_env(var: str):\n    if not os.environ.get(var):\n        os.environ[var] = getpass.getpass(f\"{var}: \")\n\n\n_set_env(\"ANTHROPIC_API_KEY\")\n#################################\nfrom typing import Annotated\n\nfrom typing_extensions import TypedDict\n\nfrom langgraph.graph import StateGraph\nfrom langgraph.graph.message import add_messages\n\n\nclass State(TypedDict):\n    # 메시지는 \"list\" 유형입니다. 주석의 `add_messages` 함수\n    #은이 상태 키가 어떻게 업데이트되어야하는지 정의합니다.\n    #(이 경우, 목록에 메시지를 추가하여 덮어쓰지 않는 것)\n    messages: Annotated[list, add_messages]\n\n\ngraph_builder = StateGraph(State)\n#################################\nfrom langchain_anthropic import ChatAnthropic\n\nllm = ChatAnthropic(model=\"claude-3-haiku-20240307\")\n\n\ndef chatbot(state: State):\n    return {\"messages\": [llm.invoke(state[\"messages\"])]}\n\n\n# 첫 번째 인수는 고유한 노드 이름입니다.\n# 두 번째 인수는 노드가 사용될 때 호출되는 함수 또는 객체입니다.\ngraph_builder.add_node(\"chatbot\", chatbot)\n#################################\ngraph_builder.set_entry_point(\"chatbot\")\n\n#################################\ngraph_builder.set_finish_point(\"chatbot\")\n#################################\ngraph = graph_builder.compile()\n#################################\nfrom IPython.display import Image, display\n\ntry:\n    display(Image(graph.get_graph().draw_mermaid_png()))\nexcept Exception:\n    # 추가적인 종속성이 필요하며 선택 사항입니다\n    pass\n#################################\nwhile True:\n    user_input = input(\"사용자: \")\n    if user_input.lower() in [\"quit\", \"exit\", \"q\"]:\n        print(\"안녕히가세요!\")\n        break\n    for event in graph.stream({\"messages\": (\"user\", user_input)}):\n        for value in event.values():\n            print(\"보조:\", value[\"messages\"][-1].content)\n#################################\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 그래픽이 데이터의 흐름을 보여주는 방법을 보여줍니다.\n\n---\n마지막으로\n\n그래프 데이터 유형은 데이터의 시각적 표현을 보여주는 강력한 도구입니다. 시각적 표현 이상으로, 서로 다른 노드 간의 표현은 데이터 노드의 공간적 표현을 만드는 데 이상적입니다.\n\n데이터 사용자의 관점에서 그래프 데이터 유형은 데이터의 의미론적 행동에 이상적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n⭐️ 저를 팔로우해서 대형 언어 모델에 관한 업데이트를 받아보세요 ⭐️\n\n![이미지](/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_0.png)\n\n저는 현재 Kore AI의 Chief Evangelist입니다. AI와 언어가 교차하는 모든 것을 탐구하고 쓰고 있습니다. 대형 언어 모델, 챗봇, 음성봇, 개발 프레임워크, 데이터 중심의 잠재 공간 등 다양한 주제에 대해 다룹니다.\n\n![이미지](/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image 2](/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_2.png)\n\n![Image 3](/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_3.png)\n","ogImage":{"url":"/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_0.png"},"coverImage":"/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e하지만 왜 우리는 상태와 상태 전이 제어로 다시 돌아가고 있을까요? 자율 인공 지능 에이전트와 함께 우리는 상태 제어와 전이 개념을 넘어서 왔다고 생각했는데요?\u003c/p\u003e\n\u003cp\u003e자율 에이전트의 출력을 살펴보면, 에이전트가 지속적으로 생성하는 작업 순서를 주목할 것입니다.\u003c/p\u003e\n\u003cp\u003eLangGraph의 목표는 자율 인공 지능 에이전트를 실행할 때 일정한 수준의 제어를 갖는 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e죄송합니다. 이 기사가 길었지만, Graph의 기본 원칙이 무엇인지 정말로 파악하고 싶었습니다.\u003c/p\u003e\n\u003ch1\u003e현황\u003c/h1\u003e\n\u003cp\u003e아래 이미지를 고려해보면, 이것이 대부분의 사람들이 대화형 UI를 위한 대화와 프로세스 흐름을 생성하는 사용자 인터페이스의 디자인 및 개발을 알게 된 방식입니다.\u003c/p\u003e\n\u003cp\u003e디자인 기능은 노드 및 엣지라는 두 가지 주요 범주로 나뉠 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e노드는 블록으로, 때로는 자산으로도 불립니다. 아래 그림에서 디자인 캔버스에는 다섯 개의 노드가 있습니다. 이 노드 간에는 링크 또는 엣지라고도 하는 연결이 있습니다. 엣지는 가능한 대상 노드나 노드를 보여줍니다.\u003c/p\u003e\n\u003ch2\u003e프롬프트 체이닝\u003c/h2\u003e\n\u003cp\u003e대형 언어 모델의 출현과 함께 프롬프트 체이닝이 등장했습니다...\u003c/p\u003e\n\u003cp\u003e프롬프트 체이닝은 언어 모델과 작업할 때 사용되는 기술로, 여러 프롬프트(노드)가 서로 순차적으로 연결(엣지를 통해)되어 서로 관련된 작업이나 단계를 안내하는 것으로 설명될 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 방법은 큰 작업을 작은 관리 가능한 부분으로 나눠 더 복잡하고 세밀한 결과물을 얻는 데 사용됩니다.\u003c/p\u003e\n\u003cp\u003e다음은 프롬프트 체이닝 작동 방식에 대해 간단히 설명한 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작업 분해(노드): 복잡한 작업이 작은 순차적인 단계로 나누어집니다. 각 단계는 전체 목표의 특정 부분을 달성하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003e각 단계에 대한 프롬프트 생성(엣지): 각 단계에 대해 필수 출력물 생성을 위해 구체적인 프롬프트가 만들어집니다. 이러한 프롬프트는 해당 부분 작업에 집중되고 명확하게 설계됩니다.\u003c/li\u003e\n\u003cli\u003e순차 실행: 언어 모델은 첫 번째 프롬프트를 처리하고 출력물을 생성합니다. 이 출력물은 다음 시퀀스의 다음 프롬프트의 일부로 사용됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그러나 알아둬야 할 점은, 프롬프트 체이닝은 챗봇 흐름 구축과 동일한 원칙에 기반합니다. 따라서 이전과 같은 문제, 즉 엄격한 상태 머신이 존재합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e참으로, 프롬프트 체이닝에는 각 노드의 입력에 몇 가지 유연성을 도입하는 요소가 있어서 출력에는 동적 변화가 발생합니다. 그러나 전반적으로 시퀀스는 고정되고 엄격하게 유지됩니다.\u003c/p\u003e\n\u003ch2\u003e도전 과제\u003c/h2\u003e\n\u003cp\u003e이 방법론은 흐름을 세심하게 지정해야 하며 각 결정 지점을 정의해야 합니다. 이러한 이유로 본질적으로 상태 기계이며 대화 트리는 서로 다른 상태(노드)와 대화가 이동해야 하는 결정 지점(엣지)에 의해 정의됩니다.\u003c/p\u003e\n\u003cp\u003e엣지는 대화 상태/대화 턴이 이동할 수 있는 옵션으로 볼 수도 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그래서 이 방법론의 한계로 인해 너무 엄격하다는 도전 과제에 닥치게 되었습니다. 대체로 변화를 원하는 욕구가 있으며, 융통성을 도입하고 싶어하는 분위기입니다.\u003c/p\u003e\n\u003ch1\u003e에이전트 입력\u003c/h1\u003e\n\u003cp\u003e자율 주체들은 최근에 소개되었으며, 에이전트의 자율성 수준은 놀라울 정도였습니다. 에이전트는 실시간으로 사건의 연쇄 또는 순서를 생성하고 이 일시적인 연쇄를 따라 최종적인 답변이 도출될 때까지 따릅니다.\u003c/p\u003e\n\u003cp\u003e이것을 일회용 연쇄로 생각할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래 예시를 고려해보면, 에이전트에게 매우 모호한 질문을 할 수 있습니다. 예를 들어 \"아이폰의 아버지로 평가받는 사람은 누구이며, 그의 출생 연도의 제곱근은 무엇입니까?\"\u003c/p\u003e\n\u003cp\u003e또는\u003c/p\u003e\n\u003cp\u003e\"일반적으로 아이폰의 아버지로 평가받는 사람의 출생 연도의 제곱근은 무엇입니까?\"\u003c/p\u003e\n\u003cp\u003e그리고 아래와 같이, 에이전트는 실시간으로 체인을 생성하여 질문을 반영하고 행동, 관찰, 사고, 행동, 관찰, 사고의 프로세스를 거쳐 최종 답변에 도달합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e 새 \u003cspan class=\"hljs-title class_\"\u003eAgentExecutor\u003c/span\u003e 체인에 들어갔어요...\n아이폰의 아버지로 알려진 사람과 태어난 해를 알아내야 해요. 그리고 그의 출생 연도의 제곱근을 계산할 거예요.\n행동: 검색\n행동 입력: 아이폰 아버지 출생 연도\n관찰: 가족. 스티븐 폴 잡스는 조앤 캐롤 스키블과 아브둘파타 \u003cspan class=\"hljs-string\"\u003e\"존\"\u003c/span\u003e 잔달리(아랍어: عبد الف ...)가 산프란시스코, 캘리포니아에서 \u003cspan class=\"hljs-number\"\u003e1955\u003c/span\u003e년 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e월 \u003cspan class=\"hljs-number\"\u003e24\u003c/span\u003e일에 태어났어요.\n생각: 스티브 잡스가 아이폰의 아버지로 알려지고 \u003cspan class=\"hljs-number\"\u003e1955\u003c/span\u003e년에 태어났다는 걸 알았어요. 이제 그의 출생 연도의 제곱근을 계산할 거예요.\n행동: 계산기\n행동 입력: \u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1955\u003c/span\u003e)\n관찰: 답변: \u003cspan class=\"hljs-number\"\u003e44.21538193886829\u003c/span\u003e\n생각: 이제 마지막 답을 알게 되었어요.\n최종 답변: 스티브 잡스가 아이폰의 아버지로 알려지고, 그의 태어난 연도(\u003cspan class=\"hljs-number\"\u003e1955\u003c/span\u003e년)의 제곱근은 약 \u003cspan class=\"hljs-number\"\u003e44.22\u003c/span\u003e입니다.\n\n\u003e 체인을 마쳤어요.\n\u003cspan class=\"hljs-string\"\u003e'스티브 잡스가 아이폰의 아버지로 알려지고, 그의 태어난 연도(1955년)의 제곱근은 약 44.22입니다.\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e도전과제\u003c/h2\u003e\n\u003cp\u003e에이전트와 저에게 가장 많이 들은 상수적 비판점은 에이전트들의 높은 자율성입니다.\u003c/p\u003e\n\u003cp\u003e생산자들은 에이전트에 어느 정도의 통제권을 가지고 싶어해요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e헤이, 에이전트의 등장으로 우리는 지나치게 제어되고 엄격한 상황에서 더 큰 유연성으로 이동했지만 제어 부재로 인한 문제가 있습니다.\u003c/p\u003e\n\u003ch1\u003eLangChain에서 LangGraph로 전환해보세요\u003c/h1\u003e\n\u003ch2\u003e하지만 먼저, 데이터 유형으로서의 그래프란 무엇인가요?\u003c/h2\u003e\n\u003ch2\u003e그래프(추상 데이터 유형)은 무엇인가요?\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그래프 데이터의 개념은 처음에는 어렵게 느껴질 수 있지만, 여기서 그것을 쉽게 설명해보겠습니다.\u003c/p\u003e\n\u003cp\u003e실제로 그래프는 추상 데이터 유형이에요...\u003c/p\u003e\n\u003cp\u003e추상 데이터 유형은 데이터 유형에 대한 수학적 모델로, 데이터를 사용하는 사람의 관점에서 정의된 동작 (의미론)에 의해 정의됩니다.\u003c/p\u003e\n\u003cp\u003e추상 데이터 유형은 데이터 구조와 대조적입니다. 데이터 구조는 데이터의 구체적 표현이며, 구현자의 관점이 아닌 사용자의 관점에서 정의됩니다. 이 데이터 구조는 덜 해석하기 어려우며 해석하기 쉬워요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e방향 그래프\u003c/h2\u003e\n\u003cp\u003e방향 그래프(또는 유향 그래프)는 방향성이 있는 엣지로 연결된 노드 집합으로 이루어진 그래프입니다.\u003c/p\u003e\n\u003cp\u003e그래프 데이터 구조는 유향 그래프의 경우 노드의 유한 집합과 무방향 그래프의 경우 이러한 노드들의 순서가 없는 쌍의 집합으로 구성됩니다.\u003c/p\u003e\n\u003cp\u003e아래의 그래프 표현을 고려할 때, 노드와 함께 엣지 및 엣지 옵션이 표시됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003eLangGraph\u003c/h2\u003e\n\u003cp\u003e다시 한번 아래 이미지를 보시면, 왼쪽에는 LangGraph Python 코드 조각이 표시되어 있고, 오른쪽에는 해당 그래프가 그려져 있습니다. 코드에서 노드가 정의된 부분을 보면, builder.add_node에 ReturnNodeValue가 사용되어 있습니다. 각 엣지가 정의된 노드에 대해 builder.add_edge가 호출됩니다.\u003c/p\u003e\n\u003cp\u003e또한 a를 시작점으로, d를 완료점으로 설정해 두었음을 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eLangGraph는 에이전트 런타임에서 자주 필요한 순환 그래프를 생성하기 위해 LangChain 위에 구축된 모듈입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eLangChain의 큰 가치 제안 중 하나는 사용자 정의 체인을 쉽게 만들 수 있는 능력, 즉 flow engineering입니다. LangGraph를 LangChain 에이전트와 결합하여, 에이전트는 지향적이며 순환이 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003eDirected Acyclic Graph (DAG)는 컴퓨터 과학과 수학에서 사용되는 그래프 유형입니다. 간단히 설명하면 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003eDirected: 노드(또는 정점) 사이의 각 연결(또는 에지)에는 일방향의 방향이 있습니다. 한 노드에서 다른 노드로 갈 수 있는 방향을 보여줍니다.\u003c/p\u003e\n\u003cp\u003eAcyclic: 어떤 사이클도 없습니다. 즉, 한 노드에서 시작하여 방향을 따라가면 결코 같은 노드로 되돌아갈 수 없습니다. 루프에 갇히는 방법이 없습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e가족 트리나 플로우차트와 같이 앞으로만 움직이고 시작점으로 돌아갈 수 없는 구조로 생각해보세요.\u003c/p\u003e\n\u003cp\u003e더 복잡한 LLM 응용 프로그램을 개발할 때 관찰되는 일반적인 패턴은 런타임에 순환이 도입되는 것입니다. 이러한 순환이 자주 발생하며 프로세스의 다음 단계를 결정하는 데 LLM을 사용합니다.\u003c/p\u003e\n\u003cp\u003eLLM의 중요한 장점 중 하나는 이러한 추론 작업을 수행할 수 있는 능력이며, 사실상 for 루프에서 LLM과 같이 작동하는 것처럼 기능합니다. 이러한 접근 방식을 사용하는 시스템들은 종종 에이전트로 언급됩니다.\u003c/p\u003e\n\u003ch1\u003e에이전트 및 제어\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e하지만 루핑 에이전트는 종종 다양한 단계에서 세부적인 제어가 필요합니다.\u003c/p\u003e\n\u003cp\u003e제작자들은 에이전트가 항상 특정 도구를 먼저 호출하도록 보장하거나 도구를 활용하는 방법에 대해 더 많은 제어를 필요로 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e게다가, 현재 상태에 따라 에이전트에 대해 다른 프롬프트를 사용하길 원할 수도 있습니다.\u003c/p\u003e\n\u003ch1\u003e좁은 인터페이스 노출\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eLangGraph은 LangChain을 기반으로 한 간소화된 인터페이스를 제공합니다.\u003c/p\u003e\n\u003ch1\u003eLangGraph을 선택하는 이유\u003c/h1\u003e\n\u003cp\u003eLangGraph는 프레임워크에 구애받지 않으며, 각 노드는 일반 Python 함수로 작동합니다.\u003c/p\u003e\n\u003cp\u003e스트리밍, 비동기, 일괄 호출에 대한 공통 인터페이스인 Runnable API를 확장하여 다음과 같은 기능을 지원합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e여러 대화 턴이나 도구 사용 사이에서 매끄러운 상태 관리\u003c/li\u003e\n\u003cli\u003e동적 기준에 따라 노드 간 유연한 라우팅\u003c/li\u003e\n\u003cli\u003eLLM과 인간 개입 간 부드러운 전환\u003c/li\u003e\n\u003cli\u003e장기간 또는 다중 세션 애플리케이션을 위한 지속성\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eLangGraph 챗봇\u003c/h1\u003e\n\u003cp\u003e아래는 Anthropik 모델을 기반으로 한 작동 중인 LangChain 챗봇입니다. 기본 코드는 그들의 요리책에 있는 LangChain 예제 코드를 복사했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e%%capture --no-stderr\n%pip install -U langgraph langsmith\n\n# 이 튜토리얼에서 사용합니다; \u003cspan class=\"hljs-title class_\"\u003eLangGraph\u003c/span\u003e에 필요한 것은 아닙니다\n%pip install -U langchain_anthropic\n\n\n#################################\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e getpass\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\n\ndef \u003cspan class=\"hljs-title function_\"\u003e_set_env\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003evar\u003c/span\u003e: str):\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e not os.\u003cspan class=\"hljs-property\"\u003eenviron\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e):\n        os.\u003cspan class=\"hljs-property\"\u003eenviron\u003c/span\u003e[\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e] = getpass.\u003cspan class=\"hljs-title function_\"\u003egetpass\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{var}: \"\u003c/span\u003e)\n\n\n\u003cspan class=\"hljs-title function_\"\u003e_set_env\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ANTHROPIC_API_KEY\"\u003c/span\u003e)\n#################################\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e typing \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAnnotated\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e typing_extensions \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTypedDict\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langgraph.\u003cspan class=\"hljs-property\"\u003egraph\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStateGraph\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langgraph.\u003cspan class=\"hljs-property\"\u003egraph\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessage\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e add_messages\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eTypedDict\u003c/span\u003e):\n    # 메시지는 \u003cspan class=\"hljs-string\"\u003e\"list\"\u003c/span\u003e 유형입니다. 주석의 \u003cspan class=\"hljs-string\"\u003e`add_messages`\u003c/span\u003e 함수\n    #은이 상태 키가 어떻게 업데이트되어야하는지 정의합니다.\n    #(이 경우, 목록에 메시지를 추가하여 덮어쓰지 않는 것)\n    \u003cspan class=\"hljs-attr\"\u003emessages\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAnnotated\u003c/span\u003e[list, add_messages]\n\n\ngraph_builder = \u003cspan class=\"hljs-title class_\"\u003eStateGraph\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e)\n#################################\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain_anthropic \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatAnthropic\u003c/span\u003e\n\nllm = \u003cspan class=\"hljs-title class_\"\u003eChatAnthropic\u003c/span\u003e(model=\u003cspan class=\"hljs-string\"\u003e\"claude-3-haiku-20240307\"\u003c/span\u003e)\n\n\ndef \u003cspan class=\"hljs-title function_\"\u003echatbot\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003estate\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\u003cspan class=\"hljs-string\"\u003e\"messages\"\u003c/span\u003e: [llm.\u003cspan class=\"hljs-title function_\"\u003einvoke\u003c/span\u003e(state[\u003cspan class=\"hljs-string\"\u003e\"messages\"\u003c/span\u003e])]}\n\n\n# 첫 번째 인수는 고유한 노드 이름입니다.\n# 두 번째 인수는 노드가 사용될 때 호출되는 함수 또는 객체입니다.\ngraph_builder.\u003cspan class=\"hljs-title function_\"\u003eadd_node\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"chatbot\"\u003c/span\u003e, chatbot)\n#################################\ngraph_builder.\u003cspan class=\"hljs-title function_\"\u003eset_entry_point\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"chatbot\"\u003c/span\u003e)\n\n#################################\ngraph_builder.\u003cspan class=\"hljs-title function_\"\u003eset_finish_point\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"chatbot\"\u003c/span\u003e)\n#################################\ngraph = graph_builder.\u003cspan class=\"hljs-title function_\"\u003ecompile\u003c/span\u003e()\n#################################\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIPython\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edisplay\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e, display\n\n\u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n    \u003cspan class=\"hljs-title function_\"\u003edisplay\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e(graph.\u003cspan class=\"hljs-title function_\"\u003eget_graph\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003edraw_mermaid_png\u003c/span\u003e()))\nexcept \u003cspan class=\"hljs-title class_\"\u003eException\u003c/span\u003e:\n    # 추가적인 종속성이 필요하며 선택 사항입니다\n    pass\n#################################\n\u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e:\n    user_input = \u003cspan class=\"hljs-title function_\"\u003einput\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"사용자: \"\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e user_input.\u003cspan class=\"hljs-title function_\"\u003elower\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e [\u003cspan class=\"hljs-string\"\u003e\"quit\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"exit\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"q\"\u003c/span\u003e]:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"안녕히가세요!\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e event \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e graph.\u003cspan class=\"hljs-title function_\"\u003estream\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"messages\"\u003c/span\u003e: (\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, user_input)}):\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e value \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e event.\u003cspan class=\"hljs-title function_\"\u003evalues\u003c/span\u003e():\n            \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"보조:\"\u003c/span\u003e, value[\u003cspan class=\"hljs-string\"\u003e\"messages\"\u003c/span\u003e][-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003econtent\u003c/span\u003e)\n#################################\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 그래픽이 데이터의 흐름을 보여주는 방법을 보여줍니다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e마지막으로\u003c/p\u003e\n\u003cp\u003e그래프 데이터 유형은 데이터의 시각적 표현을 보여주는 강력한 도구입니다. 시각적 표현 이상으로, 서로 다른 노드 간의 표현은 데이터 노드의 공간적 표현을 만드는 데 이상적입니다.\u003c/p\u003e\n\u003cp\u003e데이터 사용자의 관점에서 그래프 데이터 유형은 데이터의 의미론적 행동에 이상적입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e⭐️ 저를 팔로우해서 대형 언어 모델에 관한 업데이트를 받아보세요 ⭐️\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e저는 현재 Kore AI의 Chief Evangelist입니다. AI와 언어가 교차하는 모든 것을 탐구하고 쓰고 있습니다. 대형 언어 모델, 챗봇, 음성봇, 개발 프레임워크, 데이터 중심의 잠재 공간 등 다양한 주제에 대해 다룹니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_2.png\" alt=\"Image 2\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms_3.png\" alt=\"Image 3\"\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-LangGraphFromLangChainExplainedInSimpleTerms"},"buildId":"8coAiP0lmiEK5aH6nkQkj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>