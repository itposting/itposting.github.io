<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>프로젝트 proxymity 파트 III - 로봇 제어 메커니즘 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-projectproxymitypartIIIRobotControlmechanism" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="프로젝트 proxymity 파트 III - 로봇 제어 메커니즘 | itposting" data-gatsby-head="true"/><meta property="og:title" content="프로젝트 proxymity 파트 III - 로봇 제어 메커니즘 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-projectproxymitypartIIIRobotControlmechanism" data-gatsby-head="true"/><meta name="twitter:title" content="프로젝트 proxymity 파트 III - 로봇 제어 메커니즘 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 02:31" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">프로젝트 proxymity 파트 III - 로봇 제어 메커니즘</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="프로젝트 proxymity 파트 III - 로봇 제어 메커니즘" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">2<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-projectproxymitypartIIIRobotControlmechanism&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>로봇을 이동시키고 제어 신호를 해석하기</p>
<p>제어 신호 스트림을 기반으로 로봇을 이동시키기 위해 시도한 두 가지 방법이 있었습니다. 각각의 신호를 포함하는 개별 패킷들과 관련된 네트워크 속도 문제를 해소하는 것이 주요 과제였죠.</p>
<p>두 가지 방법 중 어떤 것이 더 나은지 알아봅시다. 아래 애니메이션의 구조를 간략히 살펴보면 미묘한 차이를 이해하는 데 도움이 될 것입니다.</p>
<p><img src="/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_0.png" alt="로봇 제어 메커니즘"></p>
<div class="content-ad"></div>
<p><strong>접근 방법 1 (구현하기 쉽지만 움직임이 떨리는 움직임을 일으킴)</strong></p>
<p>첫 번째 방법은 로봇을 빵갈루루에서 제어 신호를 받을 때마다 짧은 거리만 이동시키는 것이었습니다. 따라서 로봇이 연속적으로 "8"을 받아 "전진" 명령을 20번 수신하면 조금씩 20번 전진했습니다. 이는 네트워크를 통해 수신되는 신호가 균일하게 도착하지 않아 매우 불안정한 움직임을 유발했습니다. 이것은 약간의 전진 Arduino 코드로 완화되지 않을까 생각하지만 더 탐구해봐야 할 것 같습니다.</p>
<p><a href="/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_1.png">2024-06-19-projectproxymitypartIIIRobotControlmechanism_1</a></p>
<p><strong>접근 방법 2(조금 더 다루기 어려움이 있으나 더 부드러움이 필요함)</strong></p>
<div class="content-ad"></div>
<p>네트워크 속도와 대역폭의 예측할 수 없는 문제를 극복하기 위한 다른 방법은 로봇을 다른 신호를 받을 때까지 계속 이동시키거나 신호를 받지 않는 상태로 유지하는 것이었습니다.</p>
<p><img src="/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_2.png" alt="로봇 제어 메커니즘"></p>
<p>두 번째 방법이 더 나은 결과를 얻을 수 있었던 이유는 설정된 시간(예: 1초)동안 이동을 시작하고 다른 신호가 수신될 때까지 계속 이동하는 것이기 때문이었습니다. 신호를 받지 못했을 경우, 이동이 만료되고 로봇이 멈출 것이었습니다. 이 방법은 훨씬 부드럽고 더 유연한 사용자 경험을 제공했습니다.</p>
<p>주로 다음 코드를 사용하여 C# 레이어에서 대부분 구현되었습니다.</p>
<div class="content-ad"></div>
<p>아래는 Markdown 형식으로 변경한 내용입니다.</p>
<p><img src="/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_3.png" alt="Projects"></p>
<p>이 프로젝트에는 개선할 점이 많이 있습니다. 내 방식으로 조금씩 계속 개선해 나갈 예정입니다. 인도 휴가 동안에도 작업할 계획입니다.</p>
<p>Build and Introduction</p>
<p>Part I — AI Vision Control</p>
<div class="content-ad"></div>
<p>제 II 부 — 신호 전송</p>
<p>제 III 부 — 로봇 제어 메커니즘 (이 이야기)</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"프로젝트 proxymity 파트 III - 로봇 제어 메커니즘","description":"","date":"2024-06-19 02:31","slug":"2024-06-19-projectproxymitypartIIIRobotControlmechanism","content":"\n\n로봇을 이동시키고 제어 신호를 해석하기\n\n제어 신호 스트림을 기반으로 로봇을 이동시키기 위해 시도한 두 가지 방법이 있었습니다. 각각의 신호를 포함하는 개별 패킷들과 관련된 네트워크 속도 문제를 해소하는 것이 주요 과제였죠.\n\n두 가지 방법 중 어떤 것이 더 나은지 알아봅시다. 아래 애니메이션의 구조를 간략히 살펴보면 미묘한 차이를 이해하는 데 도움이 될 것입니다.\n\n![로봇 제어 메커니즘](/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n**접근 방법 1 (구현하기 쉽지만 움직임이 떨리는 움직임을 일으킴)**\n\n첫 번째 방법은 로봇을 빵갈루루에서 제어 신호를 받을 때마다 짧은 거리만 이동시키는 것이었습니다. 따라서 로봇이 연속적으로 \"8\"을 받아 \"전진\" 명령을 20번 수신하면 조금씩 20번 전진했습니다. 이는 네트워크를 통해 수신되는 신호가 균일하게 도착하지 않아 매우 불안정한 움직임을 유발했습니다. 이것은 약간의 전진 Arduino 코드로 완화되지 않을까 생각하지만 더 탐구해봐야 할 것 같습니다.\n\n[2024-06-19-projectproxymitypartIIIRobotControlmechanism_1](/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_1.png)\n\n**접근 방법 2(조금 더 다루기 어려움이 있으나 더 부드러움이 필요함)**\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n네트워크 속도와 대역폭의 예측할 수 없는 문제를 극복하기 위한 다른 방법은 로봇을 다른 신호를 받을 때까지 계속 이동시키거나 신호를 받지 않는 상태로 유지하는 것이었습니다.\n\n![로봇 제어 메커니즘](/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_2.png)\n\n두 번째 방법이 더 나은 결과를 얻을 수 있었던 이유는 설정된 시간(예: 1초)동안 이동을 시작하고 다른 신호가 수신될 때까지 계속 이동하는 것이기 때문이었습니다. 신호를 받지 못했을 경우, 이동이 만료되고 로봇이 멈출 것이었습니다. 이 방법은 훨씬 부드럽고 더 유연한 사용자 경험을 제공했습니다.\n\n주로 다음 코드를 사용하여 C# 레이어에서 대부분 구현되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 Markdown 형식으로 변경한 내용입니다.\n\n\n![Projects](/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_3.png)\n\n이 프로젝트에는 개선할 점이 많이 있습니다. 내 방식으로 조금씩 계속 개선해 나갈 예정입니다. 인도 휴가 동안에도 작업할 계획입니다.\n\nBuild and Introduction\n\nPart I — AI Vision Control\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제 II 부 — 신호 전송\n\n제 III 부 — 로봇 제어 메커니즘 (이 이야기)","ogImage":{"url":"/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_0.png"},"coverImage":"/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_0.png","tag":["Tech"],"readingTime":2},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e로봇을 이동시키고 제어 신호를 해석하기\u003c/p\u003e\n\u003cp\u003e제어 신호 스트림을 기반으로 로봇을 이동시키기 위해 시도한 두 가지 방법이 있었습니다. 각각의 신호를 포함하는 개별 패킷들과 관련된 네트워크 속도 문제를 해소하는 것이 주요 과제였죠.\u003c/p\u003e\n\u003cp\u003e두 가지 방법 중 어떤 것이 더 나은지 알아봅시다. 아래 애니메이션의 구조를 간략히 살펴보면 미묘한 차이를 이해하는 데 도움이 될 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_0.png\" alt=\"로봇 제어 메커니즘\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cstrong\u003e접근 방법 1 (구현하기 쉽지만 움직임이 떨리는 움직임을 일으킴)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e첫 번째 방법은 로봇을 빵갈루루에서 제어 신호를 받을 때마다 짧은 거리만 이동시키는 것이었습니다. 따라서 로봇이 연속적으로 \"8\"을 받아 \"전진\" 명령을 20번 수신하면 조금씩 20번 전진했습니다. 이는 네트워크를 통해 수신되는 신호가 균일하게 도착하지 않아 매우 불안정한 움직임을 유발했습니다. 이것은 약간의 전진 Arduino 코드로 완화되지 않을까 생각하지만 더 탐구해봐야 할 것 같습니다.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_1.png\"\u003e2024-06-19-projectproxymitypartIIIRobotControlmechanism_1\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e접근 방법 2(조금 더 다루기 어려움이 있으나 더 부드러움이 필요함)\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e네트워크 속도와 대역폭의 예측할 수 없는 문제를 극복하기 위한 다른 방법은 로봇을 다른 신호를 받을 때까지 계속 이동시키거나 신호를 받지 않는 상태로 유지하는 것이었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_2.png\" alt=\"로봇 제어 메커니즘\"\u003e\u003c/p\u003e\n\u003cp\u003e두 번째 방법이 더 나은 결과를 얻을 수 있었던 이유는 설정된 시간(예: 1초)동안 이동을 시작하고 다른 신호가 수신될 때까지 계속 이동하는 것이기 때문이었습니다. 신호를 받지 못했을 경우, 이동이 만료되고 로봇이 멈출 것이었습니다. 이 방법은 훨씬 부드럽고 더 유연한 사용자 경험을 제공했습니다.\u003c/p\u003e\n\u003cp\u003e주로 다음 코드를 사용하여 C# 레이어에서 대부분 구현되었습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 Markdown 형식으로 변경한 내용입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_3.png\" alt=\"Projects\"\u003e\u003c/p\u003e\n\u003cp\u003e이 프로젝트에는 개선할 점이 많이 있습니다. 내 방식으로 조금씩 계속 개선해 나갈 예정입니다. 인도 휴가 동안에도 작업할 계획입니다.\u003c/p\u003e\n\u003cp\u003eBuild and Introduction\u003c/p\u003e\n\u003cp\u003ePart I — AI Vision Control\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e제 II 부 — 신호 전송\u003c/p\u003e\n\u003cp\u003e제 III 부 — 로봇 제어 메커니즘 (이 이야기)\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-projectproxymitypartIIIRobotControlmechanism"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>