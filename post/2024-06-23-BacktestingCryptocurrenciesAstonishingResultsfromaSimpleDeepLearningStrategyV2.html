<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>간단한 딥러닝 전략으로 암호화폐 백테스팅 결과 공개 버전 2 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="간단한 딥러닝 전략으로 암호화폐 백테스팅 결과 공개 버전 2 | itposting" data-gatsby-head="true"/><meta property="og:title" content="간단한 딥러닝 전략으로 암호화폐 백테스팅 결과 공개 버전 2 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2" data-gatsby-head="true"/><meta name="twitter:title" content="간단한 딥러닝 전략으로 암호화폐 백테스팅 결과 공개 버전 2 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 18:42" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_buildManifest.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">간단한 딥러닝 전략으로 암호화폐 백테스팅 결과 공개 버전 2</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="간단한 딥러닝 전략으로 암호화폐 백테스팅 결과 공개 버전 2" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>과거 글이 많은 댓글을 유발하고 의심스럽다는 점을 감안해 코드를 수정하고 결과를 보여드렸어요. 만약 수정할 부분을 발견하시면 알려주세요. 코드나 ONNX 모델이 필요하면 Github 페이지 링크를 남겨드릴게요.</p>
<p>수정한 코드 결과는 다음과 같아요:</p>
<p><img src="/assets/img/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2_0.png" alt="image"></p>
<pre><code class="hljs language-js">평균 절대 오차(<span class="hljs-variable constant_">MAE</span>): <span class="hljs-number">3.343354936528137</span>
제곱근 평균 제곱 오차(<span class="hljs-variable constant_">RMSE</span>): <span class="hljs-number">4.441722762531883</span>
R-제곱(<span class="hljs-variable constant_">R2</span>): <span class="hljs-number">0.980843427945431</span>
평균 절대 백분율 오차(<span class="hljs-variable constant_">MAPE</span>): <span class="hljs-number">0.023306784351538545</span>
<span class="hljs-string">'SOL_USDT_price_prediction.png'</span>로 저장된 그래프
실제 가격과 예측 가격의 상관 관계: <span class="hljs-number">0.9927086445091788</span>
<span class="hljs-string">'Estrategia Original'</span>의 샤프 비율: -<span class="hljs-number">5.9404285882999135</span>
<span class="hljs-string">'New Strategy'</span>의 샤프 비율: <span class="hljs-number">18.33714244833774</span>
<span class="hljs-string">'New Strategy'</span>의 <span class="hljs-title class_">Sortino</span> <span class="hljs-title class_">Ratio</span>: <span class="hljs-number">117.31843386969027</span>
<span class="hljs-string">'New Strategy'</span>의 <span class="hljs-title class_">Beta</span>: <span class="hljs-number">0.09456945402128551</span>
<span class="hljs-string">'New Strategy'</span>의 <span class="hljs-title class_">Alpha</span>: <span class="hljs-number">0.03367816559565025</span>
<span class="hljs-title class_">Cross</span>-<span class="hljs-title class_">Validation</span> 평균 절대 오차: <span class="hljs-number">91.0050376257974</span> ± <span class="hljs-number">41.98080676345999</span>
<span class="hljs-variable constant_">SMA</span> 평균 절대 오차(<span class="hljs-variable constant_">MAE</span>): <span class="hljs-number">21.129903598484848</span>
<span class="hljs-variable constant_">SMA</span> 제곱근 평균 제곱 오차(<span class="hljs-variable constant_">RMSE</span>): <span class="hljs-number">30.88072668067209</span>
<span class="hljs-variable constant_">SMA</span> R-제곱(<span class="hljs-variable constant_">R2</span>): <span class="hljs-number">0.6086608043283657</span>
</code></pre>
<div class="content-ad"></div>
<p>이것은 설명 동영상입니다:</p>
<p>다음은 수정된 코드입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> ccxt
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> onnx
<span class="hljs-keyword">import</span> onnxruntime <span class="hljs-keyword">as</span> ort
<span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">metrics</span> <span class="hljs-keyword">import</span> mean_absolute_error, mean_squared_error, r2_score, mean_absolute_percentage_error
<span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">model_selection</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">TimeSeriesSplit</span>

# 바이낸스 거래소의 인스턴스 생성
binance = ccxt.<span class="hljs-title function_">binance</span>()

# 시장 심볼과 시간 간격 설정
symbol = <span class="hljs-string">'SOL/USDT'</span>
timeframe = <span class="hljs-string">'1d'</span>
limit = <span class="hljs-number">1000</span>  # <span class="hljs-number">120</span>일의 데이터 윈도우를 보장하기 위한 충분한 데이터 다운로드

# 과거 데이터 다운로드
ohlcv = binance.<span class="hljs-title function_">fetch_ohlcv</span>(symbol, timeframe, limit=limit)

# 데이터를 판다스 <span class="hljs-title class_">DataFrame</span>으로 변환
df = pd.<span class="hljs-title class_">DataFrame</span>(ohlcv, columns=[<span class="hljs-string">'timestamp'</span>, <span class="hljs-string">'open'</span>, <span class="hljs-string">'high'</span>, <span class="hljs-string">'low'</span>, <span class="hljs-string">'close'</span>, <span class="hljs-string">'volume'</span>])
df[<span class="hljs-string">'timestamp'</span>] = pd.<span class="hljs-title function_">to_datetime</span>(df[<span class="hljs-string">'timestamp'</span>], unit=<span class="hljs-string">'ms'</span>)

# 데이터를 <span class="hljs-variable constant_">CSV</span> 파일로 저장
df.<span class="hljs-title function_">to_csv</span>(<span class="hljs-string">'binance_data.csv'</span>, index=<span class="hljs-title class_">False</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">"'binance_data.csv'에 다운로드 및 저장된 데이터"</span>)

# 다운로드된 데이터 로드
data = pd.<span class="hljs-title function_">read_csv</span>(<span class="hljs-string">'binance_data.csv'</span>)

# <span class="hljs-string">'timestamp'</span> 열을 날짜 형식으로 변경
data[<span class="hljs-string">'timestamp'</span>] = pd.<span class="hljs-title function_">to_datetime</span>(data[<span class="hljs-string">'timestamp'</span>])

# 정규화 값 (사용한 값에 맞게 조정)
min_close = data[<span class="hljs-string">'close'</span>].<span class="hljs-title function_">min</span>()
max_close = data[<span class="hljs-string">'close'</span>].<span class="hljs-title function_">max</span>()

# 종가 데이터를 정규화
data[<span class="hljs-string">'close_normalized'</span>] = (data[<span class="hljs-string">'close'</span>] - min_close) / (max_close - min_close)

# <span class="hljs-variable constant_">ONNX</span> 모델 로드
model = onnx.<span class="hljs-title function_">load</span>(<span class="hljs-string">'model_solusdt.onnx'</span>)
onnx.<span class="hljs-property">checker</span>.<span class="hljs-title function_">check_model</span>(model)

# 런타임 세션 생성
ort_session = ort.<span class="hljs-title class_">InferenceSession</span>(<span class="hljs-string">'model_solusdt.onnx'</span>)

# 슬라이딩 윈도우 형태로 모델에 입력할 데이터 준비
input_name = ort_session.<span class="hljs-title function_">get_inputs</span>()[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>
sequence_length = <span class="hljs-number">120</span>  # 모델에 따라 조정

# 예측값 저장할 리스트 생성
predictions_list = []

# 예측 시작 날짜 설정
start_date = pd.<span class="hljs-title class_">Timestamp</span>(<span class="hljs-string">'2024-01-01'</span>)
end_date = pd.<span class="hljs-property">Timestamp</span>.<span class="hljs-title function_">today</span>()

# 하루씩 추론 실행
current_date = start_date
<span class="hljs-keyword">while</span> current_date &#x3C; <span class="hljs-attr">end_date</span>:
    # 현재 날짜 이전 <span class="hljs-number">120</span>일 데이터 선택
    end_idx = data[data[<span class="hljs-string">'timestamp'</span>] &#x3C; current_date].<span class="hljs-property">index</span>[-<span class="hljs-number">1</span>]
    start_idx = end_idx - sequence_length + <span class="hljs-number">1</span>
    
    <span class="hljs-keyword">if</span> start_idx &#x3C; <span class="hljs-number">0</span>:
        <span class="hljs-title function_">print</span>(f<span class="hljs-string">"{current_date}일에 대한 충분한 데이터가 없습니다."</span>)
        <span class="hljs-keyword">break</span>
    
    # 정규화된 데이터 윈도우 가져오기
    <span class="hljs-variable language_">window</span> = data[<span class="hljs-string">'close_normalized'</span>].<span class="hljs-property">values</span>[<span class="hljs-attr">start_idx</span>:end_idx+<span class="hljs-number">1</span>]
    
    <span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span>(<span class="hljs-variable language_">window</span>) &#x3C; <span class="hljs-attr">sequence_length</span>:
        <span class="hljs-title function_">print</span>(f<span class="hljs-string">"{current_date}일에 대한 충분한 데이터가 없습니다."</span>)
        <span class="hljs-keyword">break</span>
    
    # 모델을 위한 데이터 준비
    input_window = np.<span class="hljs-title function_">array</span>(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">astype</span>(np.<span class="hljs-property">float32</span>)
    input_window = np.<span class="hljs-title function_">expand_dims</span>(input_window, axis=<span class="hljs-number">0</span>)  # 배치 사이즈 차원 추가
    input_window = np.<span class="hljs-title function_">expand_dims</span>(input_window, axis=<span class="hljs-number">2</span>)  # 특성 차원 추가
    
    # 추론 실행
    output = ort_session.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">None</span>, {<span class="hljs-attr">input_name</span>: input_window})
    prediction = output[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
    
    # 예측값 역정규화
    prediction = prediction * (max_close - min_close) + min_close
    
    # 예측값 저장
    predictions_list.<span class="hljs-title function_">append</span>({<span class="hljs-string">'date'</span>: current_date, <span class="hljs-string">'prediction'</span>: prediction})
    
    # 날짜 증가
    current_date += pd.<span class="hljs-title class_">Timedelta</span>(days=<span class="hljs-number">1</span>)

# 예측값 리스트를 <span class="hljs-title class_">DataFrame</span>으로 변환
predictions_df = pd.<span class="hljs-title class_">DataFrame</span>(predictions_list)

# 예측값을 <span class="hljs-variable constant_">CSV</span> 파일로 저장
predictions_df.<span class="hljs-title function_">to_csv</span>(<span class="hljs-string">'predicted_data.csv'</span>, index=<span class="hljs-title class_">False</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">"'predicted_data.csv'에 저장된 예측값"</span>)

# 예측값과 실제값 비교
comparison_df = pd.<span class="hljs-title function_">merge</span>(predictions_df, data[[<span class="hljs-string">'timestamp'</span>, <span class="hljs-string">'close'</span>]], left_on=<span class="hljs-string">'date'</span>, right_on=<span class="hljs-string">'timestamp'</span>)
comparison_df = comparison_df.<span class="hljs-title function_">drop</span>(columns=[<span class="hljs-string">'timestamp'</span>])
comparison_df = comparison_df.<span class="hljs-title function_">rename</span>(columns={<span class="hljs-string">'close'</span>: <span class="hljs-string">'actual'</span>})

# 에러 메트릭스 계산
mae = <span class="hljs-title function_">mean_absolute_error</span>(comparison_df[<span class="hljs-string">'actual'</span>], comparison_df[<span class="hljs-string">'prediction'</span>])
rmse = np.<span class="hljs-title function_">sqrt</span>(<span class="hljs-title function_">mean_squared_error</span>(comparison_df[<span class="hljs-string">'actual'</span>], comparison_df[<span class="hljs-string">'prediction'</span>])
r2 = <span class="hljs-title function_">r2_score</span>(comparison_df[<span class="hljs-string">'actual'</span>], comparison_df[<span class="hljs-string">'prediction'</span>])
mape = <span class="hljs-title function_">mean_absolute_percentage_error</span>(comparison_df[<span class="hljs-string">'actual'</span>], comparison_df[<span class="hljs-string">'prediction'</span>])
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'Mean Absolute Error (MAE): {mae}'</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'Root Mean Squared Error (RMSE): {rmse}'</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'R-squared (R2): {r2}'</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'Mean Absolute Percentage Error (MAPE): {mape}'</span>)

# 그래프 그리기
plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">7</span>))
plt.<span class="hljs-title function_">plot</span>(comparison_df[<span class="hljs-string">'date'</span>], comparison_df[<span class="hljs-string">'actual'</span>], label=<span class="hljs-string">'실제 가격'</span>, color=<span class="hljs-string">'blue'</span>)
plt.<span class="hljs-title function_">plot</span>(comparison_df[<span class="hljs-string">'date'</span>], comparison_df[<span class="hljs-string">'prediction'</span>], label=<span class="hljs-string">'예측된 가격'</span>, color=<span class="hljs-string">'red'</span>)
plt.<span class="hljs-title function_">fill_between</span>(comparison_df[<span class="hljs-string">'date'</span>], comparison_df[<span class="hljs-string">'prediction'</span>] - mae, comparison_df[<span class="hljs-string">'prediction'</span>] + mae, color=<span class="hljs-string">'gray'</span>, alpha=<span class="hljs-number">0.2</span>, label=<span class="hljs-string">'에러 밴드 (MAE)'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'날짜'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'가격'</span>)
plt.<span class="hljs-title function_">title</span>(f<span class="hljs-string">'{symbol} 가격 예측 대 비교'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">savefig</span>(f<span class="hljs-string">"{symbol.replace('/', '_')}_price_prediction.png"</span>)
plt.<span class="hljs-title function_">show</span>()
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"'{symbol.replace('/', '_')}_price_prediction.png'로 그래프 저장됨"</span>)

# 잔차 분석
residuals = comparison_df[<span class="hljs-string">'actual'</span>] - comparison_df[<span class="hljs-string">'prediction'</span>]
plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">7</span>))
plt.<span class="hljs-title function_">plot</span>(comparison_df[<span class="hljs-string">'date'</span>], residuals, label=<span class="hljs-string">'잔차'</span>, color=<span class="hljs-string">'purple'</span>)
plt.<span class="hljs-title function_">axhline</span>(<span class="hljs-number">0</span>, color=<span class="hljs-string">'black'</span>, linestyle=<span class="hljs-string">'--'</span>, linewidth=<span class="hljs-number">0.8</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'날짜'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'잔차'</span>)
plt.<span class="hljs-title function_">title</span>(f<span class="hljs-string">'{symbol} 예측 잔차'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">savefig</span>(f<span class="hljs-string">"{symbol.replace('/', '_')}_residuals.png"</span>)
plt.<span class="hljs-title function_">show</span>()
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"'{symbol.replace('/', '_')}_residuals.png'로 잔차 그래프 저장됨"</span>)

# 상관 관계 분석
correlation = comparison_df[<span class="hljs-string">'actual'</span>].<span class="hljs-title function_">corr</span>(comparison_df[<span class="hljs-string">'prediction'</span>])
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'실제 가격과 예측 가격 간 상관 관계: {correlation}'</span>)

# 투자 전략 시뮬레이션 (기존 전략)
investment_df = comparison_df.<span class="hljs-title function_">copy</span>()
investment_df[<span class="hljs-string">'strategy_returns'</span>] = (investment_df[<span class="hljs-string">'prediction'</span>].<span class="hljs-title function_">shift</span>(-<span class="hljs-number">1</span>) - investment_df[<span class="hljs-string">'actual'</span>]) / investment_df[<span class="hljs-string">'actual'</span>]
investment_df[<span class="hljs-string">'buy_and_hold_returns'</span>] = (investment_df[<span class="hljs-string">'actual'</span>].<span class="hljs-title function_">shift</span>(-<span class="hljs-number">1</span>) - investment_df[<span class="hljs-string">'actual'</span>]) / investment_df[<span class="hljs-string">'actual'</span>]

strategy_cumulative_returns = (investment_df[<span class="hljs-string">'strategy_returns'</span>] + <span class="hljs-number">1</span>).<span class="hljs-title function_">cumprod</span>() - <span class="hljs-number">1</span>
buy_and_hold_cumulative_returns = (investment_df[<span class="hljs-string">'buy_and_hold_returns'</span>] + <span class="hljs-number">1</span>).<span class="hljs-title function_">cumprod</span>() - <span class="hljs-number">1</span>

plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">7</span>))
plt.<span class="hljs-title function_">plot</span>(investment_df[<span class="hljs-string">'date'</span>], strategy_cumulative_returns, label=<span class="hljs-string">'전략 누적 수익'</span>, color=<span class="hljs-string">'green'</span>)
plt.<span class="hljs-title function_">plot</span>(investment_df[<span class="hljs-string">'date'</span>], buy_and_hold_cumulative_returns, label=<span class="hljs-string">'보유 및 보유 누적 수익'</span>, color=<span class="hljs-string">'orange'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'날짜'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'누적 수익'</span>)
plt.<span class="hljs-title function_">title</span>(f<span class="hljs-string">'{symbol} 투자 전략 대 보유 및 보유'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">savefig</span>(f<span class="hljs-string">"{symbol.replace('/', '_')}_investment_strategy.png"</span>)
plt.<span class="hljs-title function_">show</span>()
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"'{symbol.replace('/', '_')}_investment_strategy.png'로 투자 전략 그래프 저장됨"</span>)

# 손실 표시 계산
investment_df[<span class="hljs-string">'drawdown'</span>] = strategy_cumulative_returns.<span class="hljs-title function_">cummax</span>() - strategy_cumulative_returns
investment_df[<span class="hljs-string">'max_drawdown'</span>] = investment_df[<span class="hljs-string">'drawdown'</span>].<span class="hljs-title function_">max</span>()

plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">7</span>))
plt.<span class="hljs-title function_">plot</span>(investment_df[<span class="hljs-string">'date'</span>], investment_df[<span class="hljs-string">'drawdown'</span>], label=<span class="hljs-string">'손실'</span>, color=<span class="hljs-string">'red'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'날짜'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'손실'</span>)
plt.<span class="hljs-title function_">title</span>(f<span class="hljs-string">'{symbol} 전략 손실'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">savefig</span>(f<span class="hljs-string">"{symbol.replace('/', '_')}_drawdown.png"</span>)
plt.<span class="hljs-title function_">show</span>()
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"'{symbol.replace

&#x3C;div class="</span>content-ad<span class="hljs-string">">&#x3C;/div>

</span></code></pre>
<p>import ccxt
import pandas as pd
from datetime import datetime, timedelta
from sklearn.preprocessing import MinMaxScaler
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Conv1D, MaxPooling1D, Dropout, Flatten
import tf2onnx
import matplotlib.pyplot as plt
import numpy as np
from tensorflow.keras import callbacks
from tensorflow.keras.callbacks import ModelCheckpoint</p>
<h1>Binance 데이터를 다운로드하는 함수</h1>
<p>def descargar_datos(symbol, timeframe='1d', start_date='2000-01-01T00:00:00Z', end_date='2024-01-01T00:00:00Z'):
exchange = ccxt.binance({'enableRateLimit': False})
since = exchange.parse8601(start_date)
end_date_timestamp = pd.to_datetime(end_date, utc=True)
all_data = []</p>
<pre><code>while since &#x3C; end_date_timestamp.timestamp() * 1000:
    ohlc = exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=since)
    all_data.extend(ohlc)
    since = ohlc[-1][0] + 1  # `since`를 1밀리초 증가

df = pd.DataFrame(all_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
df.set_index('timestamp', inplace=True)

# 두 시간대가 timezone-aware하지 않으면 변환
if df.index.tz is None:
    df.index = df.index.tz_localize('utc')

df = df[df.index &#x3C;= end_date_timestamp]
print(df)
return df['close'].values
</code></pre>
<h1>데이터 불러오기</h1>
<p>data = descargar_datos('SOL/USDT')</p>
<h1>데이터 정규화</h1>
<p>scaler = MinMaxScaler(feature_range=(0, 1))
data = scaler.fit_transform(data.reshape(-1, 1))</p>
<h1>시퀀스에서 샘플을 생성하는 함수</h1>
<p>def crear_muestras(dataset, pasos_de_tiempo=120):
X, y = [], []
for i in range(pasos_de_tiempo, len(dataset)):
X.append(dataset[i-pasos_de_tiempo:i, 0])
y.append(dataset[i, 0])
return np.array(X), np.array(y)</p>
<h1>훈련 및 테스트 데이터 준비</h1>
<p>pasos_de_tiempo = 120
X, y = crear_muestras(data, pasos_de_tiempo)
X = X.reshape(X.shape[0], X.shape[1], 1)  # LSTM에 맞게 재구성</p>
<h1>데이터 분할 (훈련용 80%)</h1>
<p>split = int(0.8 * len(X))
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]</p>
<h1>모델 훈련</h1>
<p>model = Sequential()
model.add(Conv1D(filters=256, kernel_size=2, activation='relu',padding = 'same',input_shape=(X_train.shape[1],1)))
model.add(MaxPooling1D(pool_size=2))
model.add(LSTM(100, return_sequences = True))
model.add(Dropout(0.3))
model.add(LSTM(100, return_sequences = False))
model.add(Dropout(0.3))
model.add(Dense(units=1, activation = 'sigmoid'))
model.compile(optimizer='adam', loss= 'mse' , metrics = [tf.keras.metrics.RootMeanSquaredError(name='rmse')])</p>
<h1>조기 종료 설정</h1>
<p>early_stopping = callbacks.EarlyStopping(
monitor='val_loss',
patience=5,
restore_best_weights=True,
)</p>
<h1>가장 좋은 모델 저장</h1>
<p>checkpoint = ModelCheckpoint(
'best_model.h5',
monitor='val_loss',
save_best_only=True,
save_weights_only=False
)</p>
<h1>300 에포크로 모델 훈련</h1>
<p>history = model.fit(X_train, y_train, epochs = 300 , validation_data = (X_test,y_test), batch_size=32, callbacks=[early_stopping, checkpoint], verbose=2)</p>
<h1>훈련 이력 그래프</h1>
<p>plt.figure(figsize=(10, 5))
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.plot(history.history['rmse'], label='Train RMSE')
plt.plot(history.history['val_rmse'], label='Validation RMSE')
plt.title('Model Training History')
plt.xlabel('Epochs')
plt.ylabel('Loss/RMSE')
plt.legend()
plt.savefig('SOLUSDT.png')  # 그래프를 이미지 파일로 저장</p>
<h1>모델을 ONNX로 변환</h1>
<p>onnx_model, _ = tf2onnx.convert.from_keras(model, opset=13, output_path="model_solusdt.onnx")
print("ONNX 모델을 'model_solusdt.onnx'로 저장했습니다.")</p>
<h1>모델 평가</h1>
<p>train_loss, train_rmse = model.evaluate(X_train, y_train, verbose=0)
test_loss, test_rmse = model.evaluate(X_test, y_test, verbose=0)
print(f"train_loss={train_loss:.3f}, train_rmse={train_rmse:.3f}")
print(f"test_loss={test_loss:.3f}, test_rmse={test_rmse:.3f}")</p>
<p>github: Back-testing Cryptocurrencies Astonishing Results from a Simple Deep Learning Strategy</p>
<p>youtube explanation: <a href="https://youtu.be/z_taWHp_HaI" rel="nofollow" target="_blank">여기를 클릭하여 유튜브 설명 보기</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"간단한 딥러닝 전략으로 암호화폐 백테스팅 결과 공개 버전 2","description":"","date":"2024-06-23 18:42","slug":"2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2","content":"\n\n과거 글이 많은 댓글을 유발하고 의심스럽다는 점을 감안해 코드를 수정하고 결과를 보여드렸어요. 만약 수정할 부분을 발견하시면 알려주세요. 코드나 ONNX 모델이 필요하면 Github 페이지 링크를 남겨드릴게요.\n\n수정한 코드 결과는 다음과 같아요:\n\n![image](/assets/img/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2_0.png)\n\n```js\n평균 절대 오차(MAE): 3.343354936528137\n제곱근 평균 제곱 오차(RMSE): 4.441722762531883\nR-제곱(R2): 0.980843427945431\n평균 절대 백분율 오차(MAPE): 0.023306784351538545\n'SOL_USDT_price_prediction.png'로 저장된 그래프\n실제 가격과 예측 가격의 상관 관계: 0.9927086445091788\n'Estrategia Original'의 샤프 비율: -5.9404285882999135\n'New Strategy'의 샤프 비율: 18.33714244833774\n'New Strategy'의 Sortino Ratio: 117.31843386969027\n'New Strategy'의 Beta: 0.09456945402128551\n'New Strategy'의 Alpha: 0.03367816559565025\nCross-Validation 평균 절대 오차: 91.0050376257974 ± 41.98080676345999\nSMA 평균 절대 오차(MAE): 21.129903598484848\nSMA 제곱근 평균 제곱 오차(RMSE): 30.88072668067209\nSMA R-제곱(R2): 0.6086608043283657\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것은 설명 동영상입니다:\n\n다음은 수정된 코드입니다:\n\n```js\nimport ccxt\nimport pandas as pd\nimport numpy as np\nimport onnx\nimport onnxruntime as ort\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score, mean_absolute_percentage_error\nfrom sklearn.model_selection import TimeSeriesSplit\n\n# 바이낸스 거래소의 인스턴스 생성\nbinance = ccxt.binance()\n\n# 시장 심볼과 시간 간격 설정\nsymbol = 'SOL/USDT'\ntimeframe = '1d'\nlimit = 1000  # 120일의 데이터 윈도우를 보장하기 위한 충분한 데이터 다운로드\n\n# 과거 데이터 다운로드\nohlcv = binance.fetch_ohlcv(symbol, timeframe, limit=limit)\n\n# 데이터를 판다스 DataFrame으로 변환\ndf = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\ndf['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')\n\n# 데이터를 CSV 파일로 저장\ndf.to_csv('binance_data.csv', index=False)\nprint(\"'binance_data.csv'에 다운로드 및 저장된 데이터\")\n\n# 다운로드된 데이터 로드\ndata = pd.read_csv('binance_data.csv')\n\n# 'timestamp' 열을 날짜 형식으로 변경\ndata['timestamp'] = pd.to_datetime(data['timestamp'])\n\n# 정규화 값 (사용한 값에 맞게 조정)\nmin_close = data['close'].min()\nmax_close = data['close'].max()\n\n# 종가 데이터를 정규화\ndata['close_normalized'] = (data['close'] - min_close) / (max_close - min_close)\n\n# ONNX 모델 로드\nmodel = onnx.load('model_solusdt.onnx')\nonnx.checker.check_model(model)\n\n# 런타임 세션 생성\nort_session = ort.InferenceSession('model_solusdt.onnx')\n\n# 슬라이딩 윈도우 형태로 모델에 입력할 데이터 준비\ninput_name = ort_session.get_inputs()[0].name\nsequence_length = 120  # 모델에 따라 조정\n\n# 예측값 저장할 리스트 생성\npredictions_list = []\n\n# 예측 시작 날짜 설정\nstart_date = pd.Timestamp('2024-01-01')\nend_date = pd.Timestamp.today()\n\n# 하루씩 추론 실행\ncurrent_date = start_date\nwhile current_date \u003c end_date:\n    # 현재 날짜 이전 120일 데이터 선택\n    end_idx = data[data['timestamp'] \u003c current_date].index[-1]\n    start_idx = end_idx - sequence_length + 1\n    \n    if start_idx \u003c 0:\n        print(f\"{current_date}일에 대한 충분한 데이터가 없습니다.\")\n        break\n    \n    # 정규화된 데이터 윈도우 가져오기\n    window = data['close_normalized'].values[start_idx:end_idx+1]\n    \n    if len(window) \u003c sequence_length:\n        print(f\"{current_date}일에 대한 충분한 데이터가 없습니다.\")\n        break\n    \n    # 모델을 위한 데이터 준비\n    input_window = np.array(window).astype(np.float32)\n    input_window = np.expand_dims(input_window, axis=0)  # 배치 사이즈 차원 추가\n    input_window = np.expand_dims(input_window, axis=2)  # 특성 차원 추가\n    \n    # 추론 실행\n    output = ort_session.run(None, {input_name: input_window})\n    prediction = output[0][0][0]\n    \n    # 예측값 역정규화\n    prediction = prediction * (max_close - min_close) + min_close\n    \n    # 예측값 저장\n    predictions_list.append({'date': current_date, 'prediction': prediction})\n    \n    # 날짜 증가\n    current_date += pd.Timedelta(days=1)\n\n# 예측값 리스트를 DataFrame으로 변환\npredictions_df = pd.DataFrame(predictions_list)\n\n# 예측값을 CSV 파일로 저장\npredictions_df.to_csv('predicted_data.csv', index=False)\nprint(\"'predicted_data.csv'에 저장된 예측값\")\n\n# 예측값과 실제값 비교\ncomparison_df = pd.merge(predictions_df, data[['timestamp', 'close']], left_on='date', right_on='timestamp')\ncomparison_df = comparison_df.drop(columns=['timestamp'])\ncomparison_df = comparison_df.rename(columns={'close': 'actual'})\n\n# 에러 메트릭스 계산\nmae = mean_absolute_error(comparison_df['actual'], comparison_df['prediction'])\nrmse = np.sqrt(mean_squared_error(comparison_df['actual'], comparison_df['prediction'])\nr2 = r2_score(comparison_df['actual'], comparison_df['prediction'])\nmape = mean_absolute_percentage_error(comparison_df['actual'], comparison_df['prediction'])\nprint(f'Mean Absolute Error (MAE): {mae}')\nprint(f'Root Mean Squared Error (RMSE): {rmse}')\nprint(f'R-squared (R2): {r2}')\nprint(f'Mean Absolute Percentage Error (MAPE): {mape}')\n\n# 그래프 그리기\nplt.figure(figsize=(14, 7))\nplt.plot(comparison_df['date'], comparison_df['actual'], label='실제 가격', color='blue')\nplt.plot(comparison_df['date'], comparison_df['prediction'], label='예측된 가격', color='red')\nplt.fill_between(comparison_df['date'], comparison_df['prediction'] - mae, comparison_df['prediction'] + mae, color='gray', alpha=0.2, label='에러 밴드 (MAE)')\nplt.xlabel('날짜')\nplt.ylabel('가격')\nplt.title(f'{symbol} 가격 예측 대 비교')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_price_prediction.png\")\nplt.show()\nprint(f\"'{symbol.replace('/', '_')}_price_prediction.png'로 그래프 저장됨\")\n\n# 잔차 분석\nresiduals = comparison_df['actual'] - comparison_df['prediction']\nplt.figure(figsize=(14, 7))\nplt.plot(comparison_df['date'], residuals, label='잔차', color='purple')\nplt.axhline(0, color='black', linestyle='--', linewidth=0.8)\nplt.xlabel('날짜')\nplt.ylabel('잔차')\nplt.title(f'{symbol} 예측 잔차')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_residuals.png\")\nplt.show()\nprint(f\"'{symbol.replace('/', '_')}_residuals.png'로 잔차 그래프 저장됨\")\n\n# 상관 관계 분석\ncorrelation = comparison_df['actual'].corr(comparison_df['prediction'])\nprint(f'실제 가격과 예측 가격 간 상관 관계: {correlation}')\n\n# 투자 전략 시뮬레이션 (기존 전략)\ninvestment_df = comparison_df.copy()\ninvestment_df['strategy_returns'] = (investment_df['prediction'].shift(-1) - investment_df['actual']) / investment_df['actual']\ninvestment_df['buy_and_hold_returns'] = (investment_df['actual'].shift(-1) - investment_df['actual']) / investment_df['actual']\n\nstrategy_cumulative_returns = (investment_df['strategy_returns'] + 1).cumprod() - 1\nbuy_and_hold_cumulative_returns = (investment_df['buy_and_hold_returns'] + 1).cumprod() - 1\n\nplt.figure(figsize=(14, 7))\nplt.plot(investment_df['date'], strategy_cumulative_returns, label='전략 누적 수익', color='green')\nplt.plot(investment_df['date'], buy_and_hold_cumulative_returns, label='보유 및 보유 누적 수익', color='orange')\nplt.xlabel('날짜')\nplt.ylabel('누적 수익')\nplt.title(f'{symbol} 투자 전략 대 보유 및 보유')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_investment_strategy.png\")\nplt.show()\nprint(f\"'{symbol.replace('/', '_')}_investment_strategy.png'로 투자 전략 그래프 저장됨\")\n\n# 손실 표시 계산\ninvestment_df['drawdown'] = strategy_cumulative_returns.cummax() - strategy_cumulative_returns\ninvestment_df['max_drawdown'] = investment_df['drawdown'].max()\n\nplt.figure(figsize=(14, 7))\nplt.plot(investment_df['date'], investment_df['drawdown'], label='손실', color='red')\nplt.xlabel('날짜')\nplt.ylabel('손실')\nplt.title(f'{symbol} 전략 손실')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_drawdown.png\")\nplt.show()\nprint(f\"'{symbol.replace\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```\nimport ccxt\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom sklearn.preprocessing import MinMaxScaler\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Conv1D, MaxPooling1D, Dropout, Flatten\nimport tf2onnx\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom tensorflow.keras import callbacks\nfrom tensorflow.keras.callbacks import ModelCheckpoint\n\n# Binance 데이터를 다운로드하는 함수\ndef descargar_datos(symbol, timeframe='1d', start_date='2000-01-01T00:00:00Z', end_date='2024-01-01T00:00:00Z'):\n    exchange = ccxt.binance({'enableRateLimit': False})\n    since = exchange.parse8601(start_date)\n    end_date_timestamp = pd.to_datetime(end_date, utc=True)\n    all_data = []\n\n    while since \u003c end_date_timestamp.timestamp() * 1000:\n        ohlc = exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=since)\n        all_data.extend(ohlc)\n        since = ohlc[-1][0] + 1  # `since`를 1밀리초 증가\n\n    df = pd.DataFrame(all_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\n    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')\n    df.set_index('timestamp', inplace=True)\n\n    # 두 시간대가 timezone-aware하지 않으면 변환\n    if df.index.tz is None:\n        df.index = df.index.tz_localize('utc')\n    \n    df = df[df.index \u003c= end_date_timestamp]\n    print(df)\n    return df['close'].values\n\n# 데이터 불러오기\ndata = descargar_datos('SOL/USDT')\n\n# 데이터 정규화\nscaler = MinMaxScaler(feature_range=(0, 1))\ndata = scaler.fit_transform(data.reshape(-1, 1))\n\n# 시퀀스에서 샘플을 생성하는 함수\ndef crear_muestras(dataset, pasos_de_tiempo=120):\n    X, y = [], []\n    for i in range(pasos_de_tiempo, len(dataset)):\n        X.append(dataset[i-pasos_de_tiempo:i, 0])\n        y.append(dataset[i, 0])\n    return np.array(X), np.array(y)\n\n# 훈련 및 테스트 데이터 준비\npasos_de_tiempo = 120\nX, y = crear_muestras(data, pasos_de_tiempo)\nX = X.reshape(X.shape[0], X.shape[1], 1)  # LSTM에 맞게 재구성\n\n# 데이터 분할 (훈련용 80%)\nsplit = int(0.8 * len(X))\nX_train, X_test = X[:split], X[split:]\ny_train, y_test = y[:split], y[split:]\n\n# 모델 훈련\n\nmodel = Sequential()\nmodel.add(Conv1D(filters=256, kernel_size=2, activation='relu',padding = 'same',input_shape=(X_train.shape[1],1)))\nmodel.add(MaxPooling1D(pool_size=2))\nmodel.add(LSTM(100, return_sequences = True))\nmodel.add(Dropout(0.3))\nmodel.add(LSTM(100, return_sequences = False))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(units=1, activation = 'sigmoid'))\nmodel.compile(optimizer='adam', loss= 'mse' , metrics = [tf.keras.metrics.RootMeanSquaredError(name='rmse')])\n\n# 조기 종료 설정\nearly_stopping = callbacks.EarlyStopping(\n    monitor='val_loss',\n    patience=5,\n    restore_best_weights=True,\n)\n# 가장 좋은 모델 저장\ncheckpoint = ModelCheckpoint(\n    'best_model.h5', \n    monitor='val_loss', \n    save_best_only=True, \n    save_weights_only=False\n)\n\n\n# 300 에포크로 모델 훈련\nhistory = model.fit(X_train, y_train, epochs = 300 , validation_data = (X_test,y_test), batch_size=32, callbacks=[early_stopping, checkpoint], verbose=2)\n\n# 훈련 이력 그래프\nplt.figure(figsize=(10, 5))\nplt.plot(history.history['loss'], label='Train Loss')\nplt.plot(history.history['val_loss'], label='Validation Loss')\nplt.plot(history.history['rmse'], label='Train RMSE')\nplt.plot(history.history['val_rmse'], label='Validation RMSE')\nplt.title('Model Training History')\nplt.xlabel('Epochs')\nplt.ylabel('Loss/RMSE')\nplt.legend()\nplt.savefig('SOLUSDT.png')  # 그래프를 이미지 파일로 저장\n\n# 모델을 ONNX로 변환\nonnx_model, _ = tf2onnx.convert.from_keras(model, opset=13, output_path=\"model_solusdt.onnx\")\nprint(\"ONNX 모델을 'model_solusdt.onnx'로 저장했습니다.\")\n\n# 모델 평가\ntrain_loss, train_rmse = model.evaluate(X_train, y_train, verbose=0)\ntest_loss, test_rmse = model.evaluate(X_test, y_test, verbose=0)\nprint(f\"train_loss={train_loss:.3f}, train_rmse={train_rmse:.3f}\")\nprint(f\"test_loss={test_loss:.3f}, test_rmse={test_rmse:.3f}\")\n\n\ngithub: Back-testing Cryptocurrencies Astonishing Results from a Simple Deep Learning Strategy\n\nyoutube explanation: [여기를 클릭하여 유튜브 설명 보기](https://youtu.be/z_taWHp_HaI)\n","ogImage":{"url":"/assets/img/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2_0.png"},"coverImage":"/assets/img/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e과거 글이 많은 댓글을 유발하고 의심스럽다는 점을 감안해 코드를 수정하고 결과를 보여드렸어요. 만약 수정할 부분을 발견하시면 알려주세요. 코드나 ONNX 모델이 필요하면 Github 페이지 링크를 남겨드릴게요.\u003c/p\u003e\n\u003cp\u003e수정한 코드 결과는 다음과 같아요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e평균 절대 오차(\u003cspan class=\"hljs-variable constant_\"\u003eMAE\u003c/span\u003e): \u003cspan class=\"hljs-number\"\u003e3.343354936528137\u003c/span\u003e\n제곱근 평균 제곱 오차(\u003cspan class=\"hljs-variable constant_\"\u003eRMSE\u003c/span\u003e): \u003cspan class=\"hljs-number\"\u003e4.441722762531883\u003c/span\u003e\nR-제곱(\u003cspan class=\"hljs-variable constant_\"\u003eR2\u003c/span\u003e): \u003cspan class=\"hljs-number\"\u003e0.980843427945431\u003c/span\u003e\n평균 절대 백분율 오차(\u003cspan class=\"hljs-variable constant_\"\u003eMAPE\u003c/span\u003e): \u003cspan class=\"hljs-number\"\u003e0.023306784351538545\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e'SOL_USDT_price_prediction.png'\u003c/span\u003e로 저장된 그래프\n실제 가격과 예측 가격의 상관 관계: \u003cspan class=\"hljs-number\"\u003e0.9927086445091788\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e'Estrategia Original'\u003c/span\u003e의 샤프 비율: -\u003cspan class=\"hljs-number\"\u003e5.9404285882999135\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e'New Strategy'\u003c/span\u003e의 샤프 비율: \u003cspan class=\"hljs-number\"\u003e18.33714244833774\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e'New Strategy'\u003c/span\u003e의 \u003cspan class=\"hljs-title class_\"\u003eSortino\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRatio\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e117.31843386969027\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e'New Strategy'\u003c/span\u003e의 \u003cspan class=\"hljs-title class_\"\u003eBeta\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.09456945402128551\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e'New Strategy'\u003c/span\u003e의 \u003cspan class=\"hljs-title class_\"\u003eAlpha\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0.03367816559565025\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eCross\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eValidation\u003c/span\u003e 평균 절대 오차: \u003cspan class=\"hljs-number\"\u003e91.0050376257974\u003c/span\u003e ± \u003cspan class=\"hljs-number\"\u003e41.98080676345999\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eSMA\u003c/span\u003e 평균 절대 오차(\u003cspan class=\"hljs-variable constant_\"\u003eMAE\u003c/span\u003e): \u003cspan class=\"hljs-number\"\u003e21.129903598484848\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eSMA\u003c/span\u003e 제곱근 평균 제곱 오차(\u003cspan class=\"hljs-variable constant_\"\u003eRMSE\u003c/span\u003e): \u003cspan class=\"hljs-number\"\u003e30.88072668067209\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eSMA\u003c/span\u003e R-제곱(\u003cspan class=\"hljs-variable constant_\"\u003eR2\u003c/span\u003e): \u003cspan class=\"hljs-number\"\u003e0.6086608043283657\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이것은 설명 동영상입니다:\u003c/p\u003e\n\u003cp\u003e다음은 수정된 코드입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ccxt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e onnx\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e onnxruntime \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e ort\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.\u003cspan class=\"hljs-property\"\u003emetrics\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e mean_absolute_error, mean_squared_error, r2_score, mean_absolute_percentage_error\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.\u003cspan class=\"hljs-property\"\u003emodel_selection\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTimeSeriesSplit\u003c/span\u003e\n\n# 바이낸스 거래소의 인스턴스 생성\nbinance = ccxt.\u003cspan class=\"hljs-title function_\"\u003ebinance\u003c/span\u003e()\n\n# 시장 심볼과 시간 간격 설정\nsymbol = \u003cspan class=\"hljs-string\"\u003e'SOL/USDT'\u003c/span\u003e\ntimeframe = \u003cspan class=\"hljs-string\"\u003e'1d'\u003c/span\u003e\nlimit = \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e  # \u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e일의 데이터 윈도우를 보장하기 위한 충분한 데이터 다운로드\n\n# 과거 데이터 다운로드\nohlcv = binance.\u003cspan class=\"hljs-title function_\"\u003efetch_ohlcv\u003c/span\u003e(symbol, timeframe, limit=limit)\n\n# 데이터를 판다스 \u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e으로 변환\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(ohlcv, columns=[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'open'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'high'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'low'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'volume'\u003c/span\u003e])\ndf[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e] = pd.\u003cspan class=\"hljs-title function_\"\u003eto_datetime\u003c/span\u003e(df[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e], unit=\u003cspan class=\"hljs-string\"\u003e'ms'\u003c/span\u003e)\n\n# 데이터를 \u003cspan class=\"hljs-variable constant_\"\u003eCSV\u003c/span\u003e 파일로 저장\ndf.\u003cspan class=\"hljs-title function_\"\u003eto_csv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'binance_data.csv'\u003c/span\u003e, index=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"'binance_data.csv'에 다운로드 및 저장된 데이터\"\u003c/span\u003e)\n\n# 다운로드된 데이터 로드\ndata = pd.\u003cspan class=\"hljs-title function_\"\u003eread_csv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'binance_data.csv'\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e 열을 날짜 형식으로 변경\ndata[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e] = pd.\u003cspan class=\"hljs-title function_\"\u003eto_datetime\u003c/span\u003e(data[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e])\n\n# 정규화 값 (사용한 값에 맞게 조정)\nmin_close = data[\u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e()\nmax_close = data[\u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e()\n\n# 종가 데이터를 정규화\ndata[\u003cspan class=\"hljs-string\"\u003e'close_normalized'\u003c/span\u003e] = (data[\u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e] - min_close) / (max_close - min_close)\n\n# \u003cspan class=\"hljs-variable constant_\"\u003eONNX\u003c/span\u003e 모델 로드\nmodel = onnx.\u003cspan class=\"hljs-title function_\"\u003eload\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'model_solusdt.onnx'\u003c/span\u003e)\nonnx.\u003cspan class=\"hljs-property\"\u003echecker\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003echeck_model\u003c/span\u003e(model)\n\n# 런타임 세션 생성\nort_session = ort.\u003cspan class=\"hljs-title class_\"\u003eInferenceSession\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'model_solusdt.onnx'\u003c/span\u003e)\n\n# 슬라이딩 윈도우 형태로 모델에 입력할 데이터 준비\ninput_name = ort_session.\u003cspan class=\"hljs-title function_\"\u003eget_inputs\u003c/span\u003e()[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\nsequence_length = \u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e  # 모델에 따라 조정\n\n# 예측값 저장할 리스트 생성\npredictions_list = []\n\n# 예측 시작 날짜 설정\nstart_date = pd.\u003cspan class=\"hljs-title class_\"\u003eTimestamp\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'2024-01-01'\u003c/span\u003e)\nend_date = pd.\u003cspan class=\"hljs-property\"\u003eTimestamp\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoday\u003c/span\u003e()\n\n# 하루씩 추론 실행\ncurrent_date = start_date\n\u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e current_date \u0026#x3C; \u003cspan class=\"hljs-attr\"\u003eend_date\u003c/span\u003e:\n    # 현재 날짜 이전 \u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e일 데이터 선택\n    end_idx = data[data[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e] \u0026#x3C; current_date].\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n    start_idx = end_idx - sequence_length + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n    \n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e start_idx \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{current_date}일에 대한 충분한 데이터가 없습니다.\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n    \n    # 정규화된 데이터 윈도우 가져오기\n    \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e = data[\u003cspan class=\"hljs-string\"\u003e'close_normalized'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003evalues\u003c/span\u003e[\u003cspan class=\"hljs-attr\"\u003estart_idx\u003c/span\u003e:end_idx+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n    \n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e) \u0026#x3C; \u003cspan class=\"hljs-attr\"\u003esequence_length\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{current_date}일에 대한 충분한 데이터가 없습니다.\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n    \n    # 모델을 위한 데이터 준비\n    input_window = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eastype\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003efloat32\u003c/span\u003e)\n    input_window = np.\u003cspan class=\"hljs-title function_\"\u003eexpand_dims\u003c/span\u003e(input_window, axis=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)  # 배치 사이즈 차원 추가\n    input_window = np.\u003cspan class=\"hljs-title function_\"\u003eexpand_dims\u003c/span\u003e(input_window, axis=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)  # 특성 차원 추가\n    \n    # 추론 실행\n    output = ort_session.\u003cspan class=\"hljs-title function_\"\u003erun\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e, {\u003cspan class=\"hljs-attr\"\u003einput_name\u003c/span\u003e: input_window})\n    prediction = output[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n    \n    # 예측값 역정규화\n    prediction = prediction * (max_close - min_close) + min_close\n    \n    # 예측값 저장\n    predictions_list.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e: current_date, \u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e: prediction})\n    \n    # 날짜 증가\n    current_date += pd.\u003cspan class=\"hljs-title class_\"\u003eTimedelta\u003c/span\u003e(days=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\n# 예측값 리스트를 \u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e으로 변환\npredictions_df = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(predictions_list)\n\n# 예측값을 \u003cspan class=\"hljs-variable constant_\"\u003eCSV\u003c/span\u003e 파일로 저장\npredictions_df.\u003cspan class=\"hljs-title function_\"\u003eto_csv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'predicted_data.csv'\u003c/span\u003e, index=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"'predicted_data.csv'에 저장된 예측값\"\u003c/span\u003e)\n\n# 예측값과 실제값 비교\ncomparison_df = pd.\u003cspan class=\"hljs-title function_\"\u003emerge\u003c/span\u003e(predictions_df, data[[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e]], left_on=\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e, right_on=\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e)\ncomparison_df = comparison_df.\u003cspan class=\"hljs-title function_\"\u003edrop\u003c/span\u003e(columns=[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e])\ncomparison_df = comparison_df.\u003cspan class=\"hljs-title function_\"\u003erename\u003c/span\u003e(columns={\u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e})\n\n# 에러 메트릭스 계산\nmae = \u003cspan class=\"hljs-title function_\"\u003emean_absolute_error\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e])\nrmse = np.\u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003emean_squared_error\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e])\nr2 = \u003cspan class=\"hljs-title function_\"\u003er2_score\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e])\nmape = \u003cspan class=\"hljs-title function_\"\u003emean_absolute_percentage_error\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e])\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'Mean Absolute Error (MAE): {mae}'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'Root Mean Squared Error (RMSE): {rmse}'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'R-squared (R2): {r2}'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'Mean Absolute Percentage Error (MAPE): {mape}'\u003c/span\u003e)\n\n# 그래프 그리기\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e))\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e], label=\u003cspan class=\"hljs-string\"\u003e'실제 가격'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'blue'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e], label=\u003cspan class=\"hljs-string\"\u003e'예측된 가격'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'red'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003efill_between\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e] - mae, comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e] + mae, color=\u003cspan class=\"hljs-string\"\u003e'gray'\u003c/span\u003e, alpha=\u003cspan class=\"hljs-number\"\u003e0.2\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e'에러 밴드 (MAE)'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'날짜'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'가격'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'{symbol} 가격 예측 대 비교'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\nplt.\u003cspan class=\"hljs-title function_\"\u003esavefig\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{symbol.replace('/', '_')}_price_prediction.png\"\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"'{symbol.replace('/', '_')}_price_prediction.png'로 그래프 저장됨\"\u003c/span\u003e)\n\n# 잔차 분석\nresiduals = comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e] - comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e]\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e))\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], residuals, label=\u003cspan class=\"hljs-string\"\u003e'잔차'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'purple'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eaxhline\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e, linestyle=\u003cspan class=\"hljs-string\"\u003e'--'\u003c/span\u003e, linewidth=\u003cspan class=\"hljs-number\"\u003e0.8\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'날짜'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'잔차'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'{symbol} 예측 잔차'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\nplt.\u003cspan class=\"hljs-title function_\"\u003esavefig\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{symbol.replace('/', '_')}_residuals.png\"\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"'{symbol.replace('/', '_')}_residuals.png'로 잔차 그래프 저장됨\"\u003c/span\u003e)\n\n# 상관 관계 분석\ncorrelation = comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003ecorr\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e])\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'실제 가격과 예측 가격 간 상관 관계: {correlation}'\u003c/span\u003e)\n\n# 투자 전략 시뮬레이션 (기존 전략)\ninvestment_df = comparison_df.\u003cspan class=\"hljs-title function_\"\u003ecopy\u003c/span\u003e()\ninvestment_df[\u003cspan class=\"hljs-string\"\u003e'strategy_returns'\u003c/span\u003e] = (investment_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eshift\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) - investment_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e]) / investment_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e]\ninvestment_df[\u003cspan class=\"hljs-string\"\u003e'buy_and_hold_returns'\u003c/span\u003e] = (investment_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eshift\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) - investment_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e]) / investment_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e]\n\nstrategy_cumulative_returns = (investment_df[\u003cspan class=\"hljs-string\"\u003e'strategy_returns'\u003c/span\u003e] + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ecumprod\u003c/span\u003e() - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\nbuy_and_hold_cumulative_returns = (investment_df[\u003cspan class=\"hljs-string\"\u003e'buy_and_hold_returns'\u003c/span\u003e] + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ecumprod\u003c/span\u003e() - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e))\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(investment_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], strategy_cumulative_returns, label=\u003cspan class=\"hljs-string\"\u003e'전략 누적 수익'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'green'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(investment_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], buy_and_hold_cumulative_returns, label=\u003cspan class=\"hljs-string\"\u003e'보유 및 보유 누적 수익'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'orange'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'날짜'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'누적 수익'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'{symbol} 투자 전략 대 보유 및 보유'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\nplt.\u003cspan class=\"hljs-title function_\"\u003esavefig\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{symbol.replace('/', '_')}_investment_strategy.png\"\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"'{symbol.replace('/', '_')}_investment_strategy.png'로 투자 전략 그래프 저장됨\"\u003c/span\u003e)\n\n# 손실 표시 계산\ninvestment_df[\u003cspan class=\"hljs-string\"\u003e'drawdown'\u003c/span\u003e] = strategy_cumulative_returns.\u003cspan class=\"hljs-title function_\"\u003ecummax\u003c/span\u003e() - strategy_cumulative_returns\ninvestment_df[\u003cspan class=\"hljs-string\"\u003e'max_drawdown'\u003c/span\u003e] = investment_df[\u003cspan class=\"hljs-string\"\u003e'drawdown'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e()\n\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e))\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(investment_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], investment_df[\u003cspan class=\"hljs-string\"\u003e'drawdown'\u003c/span\u003e], label=\u003cspan class=\"hljs-string\"\u003e'손실'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'red'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'날짜'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'손실'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'{symbol} 전략 손실'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\nplt.\u003cspan class=\"hljs-title function_\"\u003esavefig\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{symbol.replace('/', '_')}_drawdown.png\"\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"'{symbol.replace\n\n\u0026#x3C;div class=\"\u003c/span\u003econtent-ad\u003cspan class=\"hljs-string\"\u003e\"\u003e\u0026#x3C;/div\u003e\n\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eimport ccxt\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom sklearn.preprocessing import MinMaxScaler\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Conv1D, MaxPooling1D, Dropout, Flatten\nimport tf2onnx\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom tensorflow.keras import callbacks\nfrom tensorflow.keras.callbacks import ModelCheckpoint\u003c/p\u003e\n\u003ch1\u003eBinance 데이터를 다운로드하는 함수\u003c/h1\u003e\n\u003cp\u003edef descargar_datos(symbol, timeframe='1d', start_date='2000-01-01T00:00:00Z', end_date='2024-01-01T00:00:00Z'):\nexchange = ccxt.binance({'enableRateLimit': False})\nsince = exchange.parse8601(start_date)\nend_date_timestamp = pd.to_datetime(end_date, utc=True)\nall_data = []\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewhile since \u0026#x3C; end_date_timestamp.timestamp() * 1000:\n    ohlc = exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=since)\n    all_data.extend(ohlc)\n    since = ohlc[-1][0] + 1  # `since`를 1밀리초 증가\n\ndf = pd.DataFrame(all_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\ndf['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')\ndf.set_index('timestamp', inplace=True)\n\n# 두 시간대가 timezone-aware하지 않으면 변환\nif df.index.tz is None:\n    df.index = df.index.tz_localize('utc')\n\ndf = df[df.index \u0026#x3C;= end_date_timestamp]\nprint(df)\nreturn df['close'].values\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e데이터 불러오기\u003c/h1\u003e\n\u003cp\u003edata = descargar_datos('SOL/USDT')\u003c/p\u003e\n\u003ch1\u003e데이터 정규화\u003c/h1\u003e\n\u003cp\u003escaler = MinMaxScaler(feature_range=(0, 1))\ndata = scaler.fit_transform(data.reshape(-1, 1))\u003c/p\u003e\n\u003ch1\u003e시퀀스에서 샘플을 생성하는 함수\u003c/h1\u003e\n\u003cp\u003edef crear_muestras(dataset, pasos_de_tiempo=120):\nX, y = [], []\nfor i in range(pasos_de_tiempo, len(dataset)):\nX.append(dataset[i-pasos_de_tiempo:i, 0])\ny.append(dataset[i, 0])\nreturn np.array(X), np.array(y)\u003c/p\u003e\n\u003ch1\u003e훈련 및 테스트 데이터 준비\u003c/h1\u003e\n\u003cp\u003epasos_de_tiempo = 120\nX, y = crear_muestras(data, pasos_de_tiempo)\nX = X.reshape(X.shape[0], X.shape[1], 1)  # LSTM에 맞게 재구성\u003c/p\u003e\n\u003ch1\u003e데이터 분할 (훈련용 80%)\u003c/h1\u003e\n\u003cp\u003esplit = int(0.8 * len(X))\nX_train, X_test = X[:split], X[split:]\ny_train, y_test = y[:split], y[split:]\u003c/p\u003e\n\u003ch1\u003e모델 훈련\u003c/h1\u003e\n\u003cp\u003emodel = Sequential()\nmodel.add(Conv1D(filters=256, kernel_size=2, activation='relu',padding = 'same',input_shape=(X_train.shape[1],1)))\nmodel.add(MaxPooling1D(pool_size=2))\nmodel.add(LSTM(100, return_sequences = True))\nmodel.add(Dropout(0.3))\nmodel.add(LSTM(100, return_sequences = False))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(units=1, activation = 'sigmoid'))\nmodel.compile(optimizer='adam', loss= 'mse' , metrics = [tf.keras.metrics.RootMeanSquaredError(name='rmse')])\u003c/p\u003e\n\u003ch1\u003e조기 종료 설정\u003c/h1\u003e\n\u003cp\u003eearly_stopping = callbacks.EarlyStopping(\nmonitor='val_loss',\npatience=5,\nrestore_best_weights=True,\n)\u003c/p\u003e\n\u003ch1\u003e가장 좋은 모델 저장\u003c/h1\u003e\n\u003cp\u003echeckpoint = ModelCheckpoint(\n'best_model.h5',\nmonitor='val_loss',\nsave_best_only=True,\nsave_weights_only=False\n)\u003c/p\u003e\n\u003ch1\u003e300 에포크로 모델 훈련\u003c/h1\u003e\n\u003cp\u003ehistory = model.fit(X_train, y_train, epochs = 300 , validation_data = (X_test,y_test), batch_size=32, callbacks=[early_stopping, checkpoint], verbose=2)\u003c/p\u003e\n\u003ch1\u003e훈련 이력 그래프\u003c/h1\u003e\n\u003cp\u003eplt.figure(figsize=(10, 5))\nplt.plot(history.history['loss'], label='Train Loss')\nplt.plot(history.history['val_loss'], label='Validation Loss')\nplt.plot(history.history['rmse'], label='Train RMSE')\nplt.plot(history.history['val_rmse'], label='Validation RMSE')\nplt.title('Model Training History')\nplt.xlabel('Epochs')\nplt.ylabel('Loss/RMSE')\nplt.legend()\nplt.savefig('SOLUSDT.png')  # 그래프를 이미지 파일로 저장\u003c/p\u003e\n\u003ch1\u003e모델을 ONNX로 변환\u003c/h1\u003e\n\u003cp\u003eonnx_model, _ = tf2onnx.convert.from_keras(model, opset=13, output_path=\"model_solusdt.onnx\")\nprint(\"ONNX 모델을 'model_solusdt.onnx'로 저장했습니다.\")\u003c/p\u003e\n\u003ch1\u003e모델 평가\u003c/h1\u003e\n\u003cp\u003etrain_loss, train_rmse = model.evaluate(X_train, y_train, verbose=0)\ntest_loss, test_rmse = model.evaluate(X_test, y_test, verbose=0)\nprint(f\"train_loss={train_loss:.3f}, train_rmse={train_rmse:.3f}\")\nprint(f\"test_loss={test_loss:.3f}, test_rmse={test_rmse:.3f}\")\u003c/p\u003e\n\u003cp\u003egithub: Back-testing Cryptocurrencies Astonishing Results from a Simple Deep Learning Strategy\u003c/p\u003e\n\u003cp\u003eyoutube explanation: \u003ca href=\"https://youtu.be/z_taWHp_HaI\" rel=\"nofollow\" target=\"_blank\"\u003e여기를 클릭하여 유튜브 설명 보기\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2"},"buildId":"kkckKPyxcjJp_o8wb2unW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>