<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>이해할 수 있는 이상 탐지 Frequent Patterns Outlier Factor FPOF | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="이해할 수 있는 이상 탐지 Frequent Patterns Outlier Factor FPOF | itposting" data-gatsby-head="true"/><meta property="og:title" content="이해할 수 있는 이상 탐지 Frequent Patterns Outlier Factor FPOF | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF" data-gatsby-head="true"/><meta name="twitter:title" content="이해할 수 있는 이상 탐지 Frequent Patterns Outlier Factor FPOF | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-05-27 15:02" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/acd99c507555fdc6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/acd99c507555fdc6.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-0fd008072af5a644.js" defer=""></script><script src="/_next/static/O5JVeK6TDhbvSxBlchQwM/_buildManifest.js" defer=""></script><script src="/_next/static/O5JVeK6TDhbvSxBlchQwM/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">이해할 수 있는 이상 탐지 Frequent Patterns Outlier Factor FPOF</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="이해할 수 있는 이상 탐지 Frequent Patterns Outlier Factor FPOF" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On May 27, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>범주형 데이터를 지원하며 이상치를 감지하고, 이상치에 대한 설명을 제공하는 감지 방법</h2>
<p>이상치 탐지는 기계 학습에서 흔한 작업입니다. 구체적으로, 이는 지도 레이블이 없는 데이터를 분석하는 비지도학습의 한 형태입니다. 데이터 집합에서 다른 항목에 비해 이례적인 항목을 찾는 작업입니다.</p>
<p>데이터에서 이상치를 식별하려는 이유는 여러 가지가 있을 수 있습니다. 분석 중인 데이터가 회계 기록이고 오류 또는 사기를 찾고자 한다면, 데이터에는 수동으로 각 거래를 검토하기에는 너무 많은 거래가 포함되어 있어서 소수의 거래를 조사해야 합니다. 가장 이상한 레코드를 찾아 이를 조사하는 것이 좋은 시작점일 수 있습니다. 이는 오류와 사기가 모두 드물어서 이상치로 드러날 것이라는 생각으로 이루어진 것입니다.</p>
<p>다시 말하지만, 모든 이상치가 흥미로운 것은 아니지만, 오류와 사기는 아마도 이상치가 될 가능성이 있으므로 이를 찾을 때 이상치를 식별하는 것은 매우 실용적인 기술일 수 있습니다.</p>
<p>또는 데이터에는 신용 카드 거래, 센서 읽기, 기상 측정, 생물학적 데이터 또는 웹 사이트 로그가 포함될 수 있습니다. 모든 경우에, 오류나 다른 문제를 시사하는 레코드를 식별하는 것이 유용할 수 있으며, 가장 흥미로운 레코드를 찾는 것도 도움이 될 수 있습니다.</p>
<p>또한 이상값 탐지는 비즈니스나 과학적 발견의 일부로 사용되어 데이터와 데이터에 설명된 프로세스를 더 잘 이해하는 데 도움이 될 수 있습니다. 과학적 데이터의 경우, 가장 이례적인 레코드를 찾는 것이 종종 가장 과학적으로 흥미로울 수 있습니다.</p>
<h2>이상값 탐지에서 해석 가능성의 필요성</h2>
<p>분류 및 회귀 문제의 경우 해석 가능한 모델을 사용하는 것이 종종 바람직합니다. 이는 정확도가 낮아질 수 있지만(탭화면 데이터의 경우 가장 높은 정확도는 일반적으로 해석하기 어려운 부스트 모델에서 얻어집니다), 안전성이 높아집니다. 우리는 모델이 보지 못한 데이터를 어떻게 다루게 될지 알고 있습니다. 그러나 분류 및 회귀 문제의 경우에는 개별 예측이 이루어지는 이유를 이해할 필요가 없는 경우도 흔합니다. 모델이 상당히 정확하다면, 모델이 예측을 만들도록만 하는 것만으로 충분할 수도 있습니다.</p>
<p>이상치 탐지를 수행하면 해석 가능성이 훨씬 더 높아집니다. 이상치 탐지기가 레코드를 매우 이상하다고 예측하는 경우, 왜 이렇게 예측되었는지 명확하지 않으면 해당 항목을 처리하는 방법을 알 수 없을 수도 있고, 그것이 이상할 수도 있는지 여부조차 알 수 없습니다.</p>
<p>사실, 상황에 따라 이상치 탐지를 수행해도, 왜 이상치로 표시된 항목이 표시되었는지를 잘 이해하지 못하면 그 가치가 제한될 수 있습니다. 신용 카드 거래 데이터 세트를 확인하는 경우 이상치 탐지 루틴이 매우 이례적인 것으로 보이는 일련의 구매를 식별하고, 따라서 의심스럽다고 식별할 경우, 이것들을 효과적으로 조사할 수 있는 방법은 무엇인지 알고 있어야만 합니다. 경우에 따라 이것이 명백하거나, 시간을 들여 조사한 후에 분명해질 수도 있지만, 발견된 시점에서 이상 점의 특성이 명확하다면 훨씬 효율적입니다.</p>
<p>분류 및 회귀와 마찬가지로 해석 가능성이 불가능한 경우, 사후 해설이라고 하는 것을 사용하여 예측을 이해하려는 시도를 하는 것이 종종 가능합니다. Feature importances, proxy models, ALE plots 등을 사용하는 XAI(Explainable AI) 기법을 사용합니다. 이들은 아주 유용하며 앞으로의 기사에서도 다룰 것입니다. 그러나, 처음부터 결과가 명확한 것의 장점도 아주 큽니다.</p>
<p>이 기사에서는 특히 표 형식의 데이터에 초점을 맞추지만, 이후의 기사에서 다른 형식을 살펴볼 것입니다. 오늘날 흔히 사용되는 탭 데이터를위한 이상치 검출 알고리즘 중에는 Isolation Forests, Local Outlier Factor (LOF), KNNs, One-Class SVM 등 여러 가지가 있습니다. 이들은 종종 매우 잘 작동하지만, 불행히도 대부분의 경우 이상치를 찾은 이유에 대한 설명을 제공하지 않습니다.</p>
<p>대부분의 이상치 탐지 방법은 알고리즘 수준에서 이해하기 쉽지만, 그래도 어떤 레코드가 탐지기에 의해 높은 점수를 받았고 다른 레코드가 그렇지 않았는지를 결정하는 것은 어렵습니다. 예를 들어 금융 거래 데이터 세트를 Isolation Forest와 같은 방법으로 처리하면 가장 이롭은 레코드를 볼 수 있지만, 특히 테이블에 많은 특성이 있는 경우, 이상치가 드문 조합의 다중 특성을 포함하거나 이상치가 특성이 높지만 다중 특성이 다소 이상한 경우에는 왜 그런지 이해하는 것이 어려울 수 있습니다.</p>
<h2>FPOF(Frequent Patterns Outlier Factor)</h2>
<p>지금은 최소한 빠르게라도 이상치 탐지와 해석에 대해 살펴보았습니다. 이 기사의 나머지는 저의 책인 파이썬에서의 이상치 탐지(<a href="https://www.manning.com/books/outlier-detection-in-python)%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">https://www.manning.com/books/outlier-detection-in-python)에서</a> 다루는 FPOF에 대한 발췌문입니다.</p>
<p>FPOF(FP-outlier: Frequent pattern based outlier detection)은 이상치 탐지에 어느 정도의 해석 가능성을 제공할 수 있는 소수의 탐지기 중 하나이며, 이상치 탐지에서 더 많이 사용되어야 할 가치가 있습니다.</p>
<p>카테고리 데이터와 함께 작동하도록 설계된 매력적인 속성을 갖고 있습니다. 대부분의 현실 세계의 표 데이터는 숫자 및 범주형 열을 모두 포함하는 혼합된 형태입니다. 그러나 대부분의 검출기는 모든 열이 숫자인 것으로 가정하며, 모든 범주형 열을 숫자로 인코딩해야 합니다(원핫, 서수 또는 다른 인코딩을 사용하여).</p>
<p>FPOF와 같은 검출기가 데이터가 범주형이라고 가정하는 경우, 우리는 반대의 문제를 겪습니다: 모든 숫자 특성은 범주형 형식으로 변환되어야 합니다. 둘 중 어느 것이라도 사용 가능하지만, 데이터가 주로 범주형인 경우 FPOF와 같은 검출기를 사용할 수 있는 것이 편리합니다.</p>
<p>그리고 이상 탐지를 수행할 때 일부 숫자 검출기와 일부 범주형 검출기를 함께 사용할 때 혜택이 있습니다. 불행히도, 비교적 적은 수의 범주형 검출기가 있기 때문에 FPOF는 이런 면에서도 유용하며, 해석력이 필요하지 않은 경우에도 유용합니다.</p>
<h2>FPOF 알고리즘</h2>
<p>FPOF는 테이블에서 빈발 아이템 세트(Frequent Item Sets, FISs)를 식별하여 작동합니다. 이것들은 하나의 특성에서 매우 흔한 값이거나 함께 자주 나타나는 여러 열에 걸친 값의 세트일 수 있습니다.</p>
<p>거의 모든 테이블에는 상당수의 FIS가 포함되어 있습니다. 단일 값에 기초한 FIS는 한 열의 일부 값이 다른 값보다 매우 흔하기 때문에 항상 발생하며, 이는 거의 항상 사실입니다. 그리고 여러 열에 걸친 FIS는 열 사이에 연관성이 있을 때 발생합니다: 특정 값(또는 숫자 값의 범위)이 다른 열에서 다른 값(또는 다시 말해 숫자 값의 범위)과 연관이 있을 때 발생합니다.</p>
<p>FPOF는 데이터셋에 많은 빈발 아이템 세트를 포함하고 있다는 아이디어에 기반을 두고 있습니다(거의 모든 데이터셋이 해당됩니다). 그러므로 대부분의 행에는 여러 빈발 아이템 세트가 포함되며, 정상 레코드에는 이상 값(이상치) 행보다 훨씬 더 빈발한 아이템 세트가 포함됩니다. 이를 활용하여 대부분의 행보다 훨씬 적고 훨씬 덜 빈발한 FIS를 포함하는 행을 이상치로 식별할 수 있습니다.</p>
<h2>실제 데이터 예시</h2>
<p>실제로 FPOF를 사용하는 실제 예제를 살펴보면 OpenML의 SpeedDating 세트를 살펴봅니다 (<a href="https://www.openml.org/search?type=data&#x26;sort=nr_of_likes&#x26;status=active&#x26;id=40536" rel="nofollow" target="_blank">https://www.openml.org/search?type=data&#x26;sort=nr_of_likes&#x26;status=active&#x26;id=40536</a>, CC BY 4.0 DEED 라이선스).</p>
<p>FPOF를 실행하는 것은 먼저 데이터 집합에서 FIS를 채굴하는 것으로 시작합니다. 이를 지원하기 위해 Python에서 사용할 수 있는 여러 라이브러리가 있습니다. 이 예제에서는 머신러닝을 위한 범용 라이브러리 인 mlxtend (<a href="https://rasbt.github.io/mlxtend/)%EB%A5%BC" rel="nofollow" target="_blank">https://rasbt.github.io/mlxtend/)를</a> 사용합니다. 빈발 항목 집합을 식별하는 여러 알고리즘을 제공하며, 여기서는 apriori라는 알고리즘을 사용합니다.</p>
<p>먼저 OpenML에서 데이터를 수집합니다. 보통 범주형 및 (binned) 숫자형 특성을 모두 사용할 것이지만, 여기서는 간단하게 일부 특성만 사용할 것입니다.</p>
<p>언급했듯이 FPOF는 숫자형 특성의 binning을 필요로 합니다. 일반적으로 각 숫자 열에 대해 작은 수의 (5에서 20개 정도) 폭이 동일한 bin을 사용합니다. 이를 위해 pandas의 cut() 메서드가 편리합니다. 이 예제는 더 간단합니다. 여기서는 범주형 열만 다룹니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> mlxtend.frequent_patterns <span class="hljs-keyword">import</span> apriori
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> fetch_openml
<span class="hljs-keyword">import</span> warnings

warnings.filterwarnings(action=<span class="hljs-string">'ignore'</span>, category=DeprecationWarning)

data = fetch_openml(<span class="hljs-string">'SpeedDating'</span>, version=<span class="hljs-number">1</span>, parser=<span class="hljs-string">'auto'</span>)
data_df = pd.DataFrame(data.data, columns=data.feature_names)

data_df = data_df[[<span class="hljs-string">'d_pref_o_attractive'</span>, <span class="hljs-string">'d_pref_o_sincere'</span>,
                   <span class="hljs-string">'d_pref_o_intelligence'</span>, <span class="hljs-string">'d_pref_o_funny'</span>,
                   <span class="hljs-string">'d_pref_o_ambitious'</span>, <span class="hljs-string">'d_pref_o_shared_interests'</span>]]
data_df = pd.get_dummies(data_df)
<span class="hljs-keyword">for</span> col_name <span class="hljs-keyword">in</span> data_df.columns:
    data_df[col_name] = data_df[col_name].<span class="hljs-built_in">map</span>({<span class="hljs-number">0</span>: <span class="hljs-literal">False</span>, <span class="hljs-number">1</span>: <span class="hljs-literal">True</span>})

frequent_itemsets = apriori(data_df, min_support=<span class="hljs-number">0.3</span>, use_colnames=<span class="hljs-literal">True</span>)

data_df[<span class="hljs-string">'FPOF_Score'</span>] = <span class="hljs-number">0</span>

<span class="hljs-keyword">for</span> fis_idx <span class="hljs-keyword">in</span> frequent_itemsets.index:
    fis = frequent_itemsets.loc[fis_idx, <span class="hljs-string">'itemsets'</span>]
    support = frequent_itemsets.loc[fis_idx, <span class="hljs-string">'support'</span>]
    col_list = (<span class="hljs-built_in">list</span>(fis))
    cond = <span class="hljs-literal">True</span>
    <span class="hljs-keyword">for</span> col_name <span class="hljs-keyword">in</span> col_list:
        cond = cond &#x26; (data_df[col_name])

    data_df.loc[data_df[cond].index, <span class="hljs-string">'FPOF_Score'</span>] += support

min_score = data_df[<span class="hljs-string">'FPOF_Score'</span>].<span class="hljs-built_in">min</span>()
max_score = data_df[<span class="hljs-string">'FPOF_Score'</span>].<span class="hljs-built_in">max</span>()
data_df[<span class="hljs-string">'FPOF_Score'</span>] = [(max_score - x) / (max_score - min_score)
                         <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> data_df[<span class="hljs-string">'FPOF_Score'</span>]]
</code></pre>
<p>아프리오리 알고리즘은 모든 기능이 원-핫 인코딩되어 있어야합니다. 이를 위해 판다의 get_dummies() 메서드를 사용합니다.</p>
<p>그런 다음 apriori 메서드를 호출하여 빈번한 항목 집합을 결정합니다. 이를 수행하기 위해 FIS가 나타나는 행의 최소 분수 인 최소 지원을 지정해야합니다. 이 값을 너무 높게 설정하면 강한 이상값도 FIS를 포함 시키지 않으며 FIS가 적게 포함 된 레코드를 어렵게 구별하게됩니다. 그리고 이 값을 너무 낮게 설정하면 FIS가 의미없을 수 있으며 이상값도 이니셜과 동일한 수의 FIS를 포함 할 수 있습니다. 낮은 최소 지원으로 apriori를 사용하면 매우 많은 수의 FIS를 생성 할 수 있으며 실행 속도가 느려지고 해석 가능성이 낮아질 수 있습니다. 이 예에서는 0.3을 사용합니다.</p>
<p>FIS의 크기에 제한을 둘 수도 있고 때로는 그렇게합니다. 최소 및 최대 열 수 사이에 관련되도록 요구하는 여러 항목 집합의 크기에 제한을 둘 수 있으며 가장 관심 있는 이상값의 형태를 좁히는 데 도움이 될 수 있습니다.</p>
<p>빈도가 높은 항목 집합은 지원과 열 값을 나타내는 팬더 데이터프레임에서 반환됩니다. 이 값은 원-핫 인코딩된 열 형식으로 표시되며 원본 열과 값을 나타냅니다.</p>
<p>결과를 해석하기 위해 먼저 자주 등장하는 항목 집합(frequent_itemsets)을 확인할 수 있습니다. 각 FIS의 길이를 포함하려면:</p>
<pre><code class="hljs language-js">frequent_itemsets[<span class="hljs-string">'length'</span>] = \
    frequent_itemsets[<span class="hljs-string">'itemsets'</span>].<span class="hljs-title function_">apply</span>(lambda <span class="hljs-attr">x</span>: <span class="hljs-title function_">len</span>(x))
</code></pre>
<p>총 24개의 FIS가 발견되었으며, 가장 긴 것은 세 가지 특징을 포함하고 있습니다. 다음 표는 지원에 따라 정렬된 처음 열 개의 행을 표시합니다.</p>
<p><img src="/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_0.png" alt="image"></p>
<p>그런 다음 각 빈번한 항목 집합을 루프하고 지원하는 빈번한 항목 집합을 포함하는 각 행에 대해 점수를 증가시킵니다. 이는 선택적으로 길이가 더 큰 빈번한 항목 집합을 선호하도록 조정할 수 있습니다(예를 들어, 지원이 0.4이고 5개 열을 포함하는 FIS는, 그 외의 조건이 동일한 경우, 2개 열을 포함하는 지원이 0.4인 FIS보다 관련성이 더 높습니다), 하지만 여기서는 각 행의 FIS 수 및 지원을 간단히 사용합니다.</p>
<p>실제로 이것은 정상성에 대한 점수를 생성하고 이상값이 아닙니다. 따라서 점수를 0.0과 1.0 사이로 정규화할 때 순서를 뒤집습니다. 이제 가장 높은 점수를 가진 행이 가장 강한 이상값입니다: 가장 적고 가장 일반적인 빈번한 항목 집합을 가진 행입니다.</p>
<p>원래 데이터프레임에 점수 열을 추가하고 점수별로 정렬하면 가장 정상적인 행을 확인할 수 있습니다:</p>
<p><img src="/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_1.png" alt="이미지"></p>
<p>이 행의 값들이 FISs와 잘 일치하는 것을 볼 수 있습니다. d_pref_o_attractive의 값은 [21-100]이며 이는 FIS(지원 0.36)와 일치합니다. d_pref_o_ambitious와 d_pref_o_shared_interests의 값은 각각 [0-15]로, 이 또한 FIS(지원 0.59)와 일치합니다. 다른 값들도 대부분 FIS들과 일치합니다.</p>
<p>가장 이상한 행은 다음과 같이 표시됩니다. 이는 식별된 FIS들과 일치하지 않습니다.</p>
<p><img src="/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_2.png" alt="이미지"></p>
<p>자주 나오는 항목 집합 자체가 꽤 이해하기 쉬우므로,이 방법은 상당히 해석 가능한 결과를 얻는 장점이 있습니다. 다만, 자주 나오는 항목 집합이 많이 사용되는 경우에는 이러한 장점이 적을 수 있습니다.</p>
<p><img src="/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_3.png" alt="image"></p>
<p>해석력은 향상될 수 있지만, 이상치는 "포함하지 않는다"는 방식으로 식별되기 때문에, 각 이상치의 점수를 설명하는 것은 해당 이상치에 포함되지 않는 모든 항목 집합을 나열하는 것을 의미합니다. 그러나 각 이상치를 설명하기 위해 모든 누락된 항목 집합을 나열하는 것이 반드시 필요한 것은 아닙니다. 누락된 가장 일반적인 항목 집합을 나열하는 것은 대부분의 목적에 충분할 것입니다. 행에 나타나는 항목 집합과 있는 항목 집합의 통계와 빈도를 비교하는 것은 좋은 컨텍스트를 제공합니다.</p>
<p>이 방법의 변형 중 하나는 자주 나오는 것이 아닌 드문 항목 집합을 사용하는 것인데, 각 행의 드문 항목 집합의 수와 희귀성에 따라 각 행을 점수 매깁니다. 이 방법도 유용한 결과를 얻을 수 있지만, 계산 비용이 상당히 많이 소요되며, 더 많은 항목 집합이 채굴되어야 하고, 각 행은 많은 항목 집합과 테스트되어야 합니다. 그러나 최종 점수는 각 행에 누락된 대신 발견된 항목 집합을 기반으로 하므로 더 해석하기 쉬울 수 있습니다.</p>
<h2>결론</h2>
<p>여기에 나와 있는 코드 외에는 파이썬에서 FPOF를 구현한 것을 알지 못합니다. 그러나 R에서는 구현된 것이 있습니다. FPOF 작업의 주요 부분은 FISs를 채굴하는 것이며, 여기에서 사용된 mlxtend 라이브러리를 포함하여 이를 수행할 수 있는 다양한 파이썬 도구가 있습니다. 위에서 본 FPOP의 나머지 코드는 꽤 간단합니다.</p>
<p>이상 탐지에서 해석 가능성의 중요성을 고려할 때, FPOF는 매우 유용할 수 있습니다.</p>
<p>향후 기사에서는 이상 탐지를 위한 다른 해석 가능한 방법에 대해 알아볼 것입니다.</p>
<p>모든 그림은 저자에 의해 생성되었습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"이해할 수 있는 이상 탐지 Frequent Patterns Outlier Factor FPOF","description":"","date":"2024-05-27 15:02","slug":"2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF","content":"\n## 범주형 데이터를 지원하며 이상치를 감지하고, 이상치에 대한 설명을 제공하는 감지 방법\n\n이상치 탐지는 기계 학습에서 흔한 작업입니다. 구체적으로, 이는 지도 레이블이 없는 데이터를 분석하는 비지도학습의 한 형태입니다. 데이터 집합에서 다른 항목에 비해 이례적인 항목을 찾는 작업입니다.\n\n데이터에서 이상치를 식별하려는 이유는 여러 가지가 있을 수 있습니다. 분석 중인 데이터가 회계 기록이고 오류 또는 사기를 찾고자 한다면, 데이터에는 수동으로 각 거래를 검토하기에는 너무 많은 거래가 포함되어 있어서 소수의 거래를 조사해야 합니다. 가장 이상한 레코드를 찾아 이를 조사하는 것이 좋은 시작점일 수 있습니다. 이는 오류와 사기가 모두 드물어서 이상치로 드러날 것이라는 생각으로 이루어진 것입니다.\n\n다시 말하지만, 모든 이상치가 흥미로운 것은 아니지만, 오류와 사기는 아마도 이상치가 될 가능성이 있으므로 이를 찾을 때 이상치를 식별하는 것은 매우 실용적인 기술일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또는 데이터에는 신용 카드 거래, 센서 읽기, 기상 측정, 생물학적 데이터 또는 웹 사이트 로그가 포함될 수 있습니다. 모든 경우에, 오류나 다른 문제를 시사하는 레코드를 식별하는 것이 유용할 수 있으며, 가장 흥미로운 레코드를 찾는 것도 도움이 될 수 있습니다.\n\n또한 이상값 탐지는 비즈니스나 과학적 발견의 일부로 사용되어 데이터와 데이터에 설명된 프로세스를 더 잘 이해하는 데 도움이 될 수 있습니다. 과학적 데이터의 경우, 가장 이례적인 레코드를 찾는 것이 종종 가장 과학적으로 흥미로울 수 있습니다.\n\n## 이상값 탐지에서 해석 가능성의 필요성\n\n분류 및 회귀 문제의 경우 해석 가능한 모델을 사용하는 것이 종종 바람직합니다. 이는 정확도가 낮아질 수 있지만(탭화면 데이터의 경우 가장 높은 정확도는 일반적으로 해석하기 어려운 부스트 모델에서 얻어집니다), 안전성이 높아집니다. 우리는 모델이 보지 못한 데이터를 어떻게 다루게 될지 알고 있습니다. 그러나 분류 및 회귀 문제의 경우에는 개별 예측이 이루어지는 이유를 이해할 필요가 없는 경우도 흔합니다. 모델이 상당히 정확하다면, 모델이 예측을 만들도록만 하는 것만으로 충분할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이상치 탐지를 수행하면 해석 가능성이 훨씬 더 높아집니다. 이상치 탐지기가 레코드를 매우 이상하다고 예측하는 경우, 왜 이렇게 예측되었는지 명확하지 않으면 해당 항목을 처리하는 방법을 알 수 없을 수도 있고, 그것이 이상할 수도 있는지 여부조차 알 수 없습니다.\n\n사실, 상황에 따라 이상치 탐지를 수행해도, 왜 이상치로 표시된 항목이 표시되었는지를 잘 이해하지 못하면 그 가치가 제한될 수 있습니다. 신용 카드 거래 데이터 세트를 확인하는 경우 이상치 탐지 루틴이 매우 이례적인 것으로 보이는 일련의 구매를 식별하고, 따라서 의심스럽다고 식별할 경우, 이것들을 효과적으로 조사할 수 있는 방법은 무엇인지 알고 있어야만 합니다. 경우에 따라 이것이 명백하거나, 시간을 들여 조사한 후에 분명해질 수도 있지만, 발견된 시점에서 이상 점의 특성이 명확하다면 훨씬 효율적입니다.\n\n분류 및 회귀와 마찬가지로 해석 가능성이 불가능한 경우, 사후 해설이라고 하는 것을 사용하여 예측을 이해하려는 시도를 하는 것이 종종 가능합니다. Feature importances, proxy models, ALE plots 등을 사용하는 XAI(Explainable AI) 기법을 사용합니다. 이들은 아주 유용하며 앞으로의 기사에서도 다룰 것입니다. 그러나, 처음부터 결과가 명확한 것의 장점도 아주 큽니다.\n\n이 기사에서는 특히 표 형식의 데이터에 초점을 맞추지만, 이후의 기사에서 다른 형식을 살펴볼 것입니다. 오늘날 흔히 사용되는 탭 데이터를위한 이상치 검출 알고리즘 중에는 Isolation Forests, Local Outlier Factor (LOF), KNNs, One-Class SVM 등 여러 가지가 있습니다. 이들은 종종 매우 잘 작동하지만, 불행히도 대부분의 경우 이상치를 찾은 이유에 대한 설명을 제공하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대부분의 이상치 탐지 방법은 알고리즘 수준에서 이해하기 쉽지만, 그래도 어떤 레코드가 탐지기에 의해 높은 점수를 받았고 다른 레코드가 그렇지 않았는지를 결정하는 것은 어렵습니다. 예를 들어 금융 거래 데이터 세트를 Isolation Forest와 같은 방법으로 처리하면 가장 이롭은 레코드를 볼 수 있지만, 특히 테이블에 많은 특성이 있는 경우, 이상치가 드문 조합의 다중 특성을 포함하거나 이상치가 특성이 높지만 다중 특성이 다소 이상한 경우에는 왜 그런지 이해하는 것이 어려울 수 있습니다.\n\n## FPOF(Frequent Patterns Outlier Factor)\n\n지금은 최소한 빠르게라도 이상치 탐지와 해석에 대해 살펴보았습니다. 이 기사의 나머지는 저의 책인 파이썬에서의 이상치 탐지(https://www.manning.com/books/outlier-detection-in-python)에서 다루는 FPOF에 대한 발췌문입니다.\n\nFPOF(FP-outlier: Frequent pattern based outlier detection)은 이상치 탐지에 어느 정도의 해석 가능성을 제공할 수 있는 소수의 탐지기 중 하나이며, 이상치 탐지에서 더 많이 사용되어야 할 가치가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n카테고리 데이터와 함께 작동하도록 설계된 매력적인 속성을 갖고 있습니다. 대부분의 현실 세계의 표 데이터는 숫자 및 범주형 열을 모두 포함하는 혼합된 형태입니다. 그러나 대부분의 검출기는 모든 열이 숫자인 것으로 가정하며, 모든 범주형 열을 숫자로 인코딩해야 합니다(원핫, 서수 또는 다른 인코딩을 사용하여).\n\nFPOF와 같은 검출기가 데이터가 범주형이라고 가정하는 경우, 우리는 반대의 문제를 겪습니다: 모든 숫자 특성은 범주형 형식으로 변환되어야 합니다. 둘 중 어느 것이라도 사용 가능하지만, 데이터가 주로 범주형인 경우 FPOF와 같은 검출기를 사용할 수 있는 것이 편리합니다.\n\n그리고 이상 탐지를 수행할 때 일부 숫자 검출기와 일부 범주형 검출기를 함께 사용할 때 혜택이 있습니다. 불행히도, 비교적 적은 수의 범주형 검출기가 있기 때문에 FPOF는 이런 면에서도 유용하며, 해석력이 필요하지 않은 경우에도 유용합니다.\n\n## FPOF 알고리즘\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nFPOF는 테이블에서 빈발 아이템 세트(Frequent Item Sets, FISs)를 식별하여 작동합니다. 이것들은 하나의 특성에서 매우 흔한 값이거나 함께 자주 나타나는 여러 열에 걸친 값의 세트일 수 있습니다.\n\n거의 모든 테이블에는 상당수의 FIS가 포함되어 있습니다. 단일 값에 기초한 FIS는 한 열의 일부 값이 다른 값보다 매우 흔하기 때문에 항상 발생하며, 이는 거의 항상 사실입니다. 그리고 여러 열에 걸친 FIS는 열 사이에 연관성이 있을 때 발생합니다: 특정 값(또는 숫자 값의 범위)이 다른 열에서 다른 값(또는 다시 말해 숫자 값의 범위)과 연관이 있을 때 발생합니다.\n\nFPOF는 데이터셋에 많은 빈발 아이템 세트를 포함하고 있다는 아이디어에 기반을 두고 있습니다(거의 모든 데이터셋이 해당됩니다). 그러므로 대부분의 행에는 여러 빈발 아이템 세트가 포함되며, 정상 레코드에는 이상 값(이상치) 행보다 훨씬 더 빈발한 아이템 세트가 포함됩니다. 이를 활용하여 대부분의 행보다 훨씬 적고 훨씬 덜 빈발한 FIS를 포함하는 행을 이상치로 식별할 수 있습니다.\n\n## 실제 데이터 예시\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n실제로 FPOF를 사용하는 실제 예제를 살펴보면 OpenML의 SpeedDating 세트를 살펴봅니다 (https://www.openml.org/search?type=data\u0026sort=nr_of_likes\u0026status=active\u0026id=40536, CC BY 4.0 DEED 라이선스).\n\nFPOF를 실행하는 것은 먼저 데이터 집합에서 FIS를 채굴하는 것으로 시작합니다. 이를 지원하기 위해 Python에서 사용할 수 있는 여러 라이브러리가 있습니다. 이 예제에서는 머신러닝을 위한 범용 라이브러리 인 mlxtend (https://rasbt.github.io/mlxtend/)를 사용합니다. 빈발 항목 집합을 식별하는 여러 알고리즘을 제공하며, 여기서는 apriori라는 알고리즘을 사용합니다.\n\n먼저 OpenML에서 데이터를 수집합니다. 보통 범주형 및 (binned) 숫자형 특성을 모두 사용할 것이지만, 여기서는 간단하게 일부 특성만 사용할 것입니다.\n\n언급했듯이 FPOF는 숫자형 특성의 binning을 필요로 합니다. 일반적으로 각 숫자 열에 대해 작은 수의 (5에서 20개 정도) 폭이 동일한 bin을 사용합니다. 이를 위해 pandas의 cut() 메서드가 편리합니다. 이 예제는 더 간단합니다. 여기서는 범주형 열만 다룹니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom mlxtend.frequent_patterns import apriori\nimport pandas as pd\nfrom sklearn.datasets import fetch_openml\nimport warnings\n\nwarnings.filterwarnings(action='ignore', category=DeprecationWarning)\n\ndata = fetch_openml('SpeedDating', version=1, parser='auto')\ndata_df = pd.DataFrame(data.data, columns=data.feature_names)\n\ndata_df = data_df[['d_pref_o_attractive', 'd_pref_o_sincere',\n                   'd_pref_o_intelligence', 'd_pref_o_funny',\n                   'd_pref_o_ambitious', 'd_pref_o_shared_interests']]\ndata_df = pd.get_dummies(data_df)\nfor col_name in data_df.columns:\n    data_df[col_name] = data_df[col_name].map({0: False, 1: True})\n\nfrequent_itemsets = apriori(data_df, min_support=0.3, use_colnames=True)\n\ndata_df['FPOF_Score'] = 0\n\nfor fis_idx in frequent_itemsets.index:\n    fis = frequent_itemsets.loc[fis_idx, 'itemsets']\n    support = frequent_itemsets.loc[fis_idx, 'support']\n    col_list = (list(fis))\n    cond = True\n    for col_name in col_list:\n        cond = cond \u0026 (data_df[col_name])\n\n    data_df.loc[data_df[cond].index, 'FPOF_Score'] += support\n\nmin_score = data_df['FPOF_Score'].min()\nmax_score = data_df['FPOF_Score'].max()\ndata_df['FPOF_Score'] = [(max_score - x) / (max_score - min_score)\n                         for x in data_df['FPOF_Score']]\n```\n\n아프리오리 알고리즘은 모든 기능이 원-핫 인코딩되어 있어야합니다. 이를 위해 판다의 get_dummies() 메서드를 사용합니다.\n\n그런 다음 apriori 메서드를 호출하여 빈번한 항목 집합을 결정합니다. 이를 수행하기 위해 FIS가 나타나는 행의 최소 분수 인 최소 지원을 지정해야합니다. 이 값을 너무 높게 설정하면 강한 이상값도 FIS를 포함 시키지 않으며 FIS가 적게 포함 된 레코드를 어렵게 구별하게됩니다. 그리고 이 값을 너무 낮게 설정하면 FIS가 의미없을 수 있으며 이상값도 이니셜과 동일한 수의 FIS를 포함 할 수 있습니다. 낮은 최소 지원으로 apriori를 사용하면 매우 많은 수의 FIS를 생성 할 수 있으며 실행 속도가 느려지고 해석 가능성이 낮아질 수 있습니다. 이 예에서는 0.3을 사용합니다.\n\nFIS의 크기에 제한을 둘 수도 있고 때로는 그렇게합니다. 최소 및 최대 열 수 사이에 관련되도록 요구하는 여러 항목 집합의 크기에 제한을 둘 수 있으며 가장 관심 있는 이상값의 형태를 좁히는 데 도움이 될 수 있습니다.\n\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n빈도가 높은 항목 집합은 지원과 열 값을 나타내는 팬더 데이터프레임에서 반환됩니다. 이 값은 원-핫 인코딩된 열 형식으로 표시되며 원본 열과 값을 나타냅니다.\n\n결과를 해석하기 위해 먼저 자주 등장하는 항목 집합(frequent_itemsets)을 확인할 수 있습니다. 각 FIS의 길이를 포함하려면:\n\n```js\nfrequent_itemsets['length'] = \\\n    frequent_itemsets['itemsets'].apply(lambda x: len(x))\n```\n\n총 24개의 FIS가 발견되었으며, 가장 긴 것은 세 가지 특징을 포함하고 있습니다. 다음 표는 지원에 따라 정렬된 처음 열 개의 행을 표시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_0.png)\n\n그런 다음 각 빈번한 항목 집합을 루프하고 지원하는 빈번한 항목 집합을 포함하는 각 행에 대해 점수를 증가시킵니다. 이는 선택적으로 길이가 더 큰 빈번한 항목 집합을 선호하도록 조정할 수 있습니다(예를 들어, 지원이 0.4이고 5개 열을 포함하는 FIS는, 그 외의 조건이 동일한 경우, 2개 열을 포함하는 지원이 0.4인 FIS보다 관련성이 더 높습니다), 하지만 여기서는 각 행의 FIS 수 및 지원을 간단히 사용합니다.\n\n실제로 이것은 정상성에 대한 점수를 생성하고 이상값이 아닙니다. 따라서 점수를 0.0과 1.0 사이로 정규화할 때 순서를 뒤집습니다. 이제 가장 높은 점수를 가진 행이 가장 강한 이상값입니다: 가장 적고 가장 일반적인 빈번한 항목 집합을 가진 행입니다.\n\n원래 데이터프레임에 점수 열을 추가하고 점수별로 정렬하면 가장 정상적인 행을 확인할 수 있습니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_1.png)\n\n이 행의 값들이 FISs와 잘 일치하는 것을 볼 수 있습니다. d_pref_o_attractive의 값은 [21-100]이며 이는 FIS(지원 0.36)와 일치합니다. d_pref_o_ambitious와 d_pref_o_shared_interests의 값은 각각 [0-15]로, 이 또한 FIS(지원 0.59)와 일치합니다. 다른 값들도 대부분 FIS들과 일치합니다.\n\n가장 이상한 행은 다음과 같이 표시됩니다. 이는 식별된 FIS들과 일치하지 않습니다.\n\n![이미지](/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자주 나오는 항목 집합 자체가 꽤 이해하기 쉬우므로,이 방법은 상당히 해석 가능한 결과를 얻는 장점이 있습니다. 다만, 자주 나오는 항목 집합이 많이 사용되는 경우에는 이러한 장점이 적을 수 있습니다.\n\n![image](/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_3.png)\n\n해석력은 향상될 수 있지만, 이상치는 \"포함하지 않는다\"는 방식으로 식별되기 때문에, 각 이상치의 점수를 설명하는 것은 해당 이상치에 포함되지 않는 모든 항목 집합을 나열하는 것을 의미합니다. 그러나 각 이상치를 설명하기 위해 모든 누락된 항목 집합을 나열하는 것이 반드시 필요한 것은 아닙니다. 누락된 가장 일반적인 항목 집합을 나열하는 것은 대부분의 목적에 충분할 것입니다. 행에 나타나는 항목 집합과 있는 항목 집합의 통계와 빈도를 비교하는 것은 좋은 컨텍스트를 제공합니다.\n\n이 방법의 변형 중 하나는 자주 나오는 것이 아닌 드문 항목 집합을 사용하는 것인데, 각 행의 드문 항목 집합의 수와 희귀성에 따라 각 행을 점수 매깁니다. 이 방법도 유용한 결과를 얻을 수 있지만, 계산 비용이 상당히 많이 소요되며, 더 많은 항목 집합이 채굴되어야 하고, 각 행은 많은 항목 집합과 테스트되어야 합니다. 그러나 최종 점수는 각 행에 누락된 대신 발견된 항목 집합을 기반으로 하므로 더 해석하기 쉬울 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 결론\n\n여기에 나와 있는 코드 외에는 파이썬에서 FPOF를 구현한 것을 알지 못합니다. 그러나 R에서는 구현된 것이 있습니다. FPOF 작업의 주요 부분은 FISs를 채굴하는 것이며, 여기에서 사용된 mlxtend 라이브러리를 포함하여 이를 수행할 수 있는 다양한 파이썬 도구가 있습니다. 위에서 본 FPOP의 나머지 코드는 꽤 간단합니다.\n\n이상 탐지에서 해석 가능성의 중요성을 고려할 때, FPOF는 매우 유용할 수 있습니다.\n\n향후 기사에서는 이상 탐지를 위한 다른 해석 가능한 방법에 대해 알아볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 그림은 저자에 의해 생성되었습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_0.png"},"coverImage":"/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e범주형 데이터를 지원하며 이상치를 감지하고, 이상치에 대한 설명을 제공하는 감지 방법\u003c/h2\u003e\n\u003cp\u003e이상치 탐지는 기계 학습에서 흔한 작업입니다. 구체적으로, 이는 지도 레이블이 없는 데이터를 분석하는 비지도학습의 한 형태입니다. 데이터 집합에서 다른 항목에 비해 이례적인 항목을 찾는 작업입니다.\u003c/p\u003e\n\u003cp\u003e데이터에서 이상치를 식별하려는 이유는 여러 가지가 있을 수 있습니다. 분석 중인 데이터가 회계 기록이고 오류 또는 사기를 찾고자 한다면, 데이터에는 수동으로 각 거래를 검토하기에는 너무 많은 거래가 포함되어 있어서 소수의 거래를 조사해야 합니다. 가장 이상한 레코드를 찾아 이를 조사하는 것이 좋은 시작점일 수 있습니다. 이는 오류와 사기가 모두 드물어서 이상치로 드러날 것이라는 생각으로 이루어진 것입니다.\u003c/p\u003e\n\u003cp\u003e다시 말하지만, 모든 이상치가 흥미로운 것은 아니지만, 오류와 사기는 아마도 이상치가 될 가능성이 있으므로 이를 찾을 때 이상치를 식별하는 것은 매우 실용적인 기술일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또는 데이터에는 신용 카드 거래, 센서 읽기, 기상 측정, 생물학적 데이터 또는 웹 사이트 로그가 포함될 수 있습니다. 모든 경우에, 오류나 다른 문제를 시사하는 레코드를 식별하는 것이 유용할 수 있으며, 가장 흥미로운 레코드를 찾는 것도 도움이 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e또한 이상값 탐지는 비즈니스나 과학적 발견의 일부로 사용되어 데이터와 데이터에 설명된 프로세스를 더 잘 이해하는 데 도움이 될 수 있습니다. 과학적 데이터의 경우, 가장 이례적인 레코드를 찾는 것이 종종 가장 과학적으로 흥미로울 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e이상값 탐지에서 해석 가능성의 필요성\u003c/h2\u003e\n\u003cp\u003e분류 및 회귀 문제의 경우 해석 가능한 모델을 사용하는 것이 종종 바람직합니다. 이는 정확도가 낮아질 수 있지만(탭화면 데이터의 경우 가장 높은 정확도는 일반적으로 해석하기 어려운 부스트 모델에서 얻어집니다), 안전성이 높아집니다. 우리는 모델이 보지 못한 데이터를 어떻게 다루게 될지 알고 있습니다. 그러나 분류 및 회귀 문제의 경우에는 개별 예측이 이루어지는 이유를 이해할 필요가 없는 경우도 흔합니다. 모델이 상당히 정확하다면, 모델이 예측을 만들도록만 하는 것만으로 충분할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e이상치 탐지를 수행하면 해석 가능성이 훨씬 더 높아집니다. 이상치 탐지기가 레코드를 매우 이상하다고 예측하는 경우, 왜 이렇게 예측되었는지 명확하지 않으면 해당 항목을 처리하는 방법을 알 수 없을 수도 있고, 그것이 이상할 수도 있는지 여부조차 알 수 없습니다.\u003c/p\u003e\n\u003cp\u003e사실, 상황에 따라 이상치 탐지를 수행해도, 왜 이상치로 표시된 항목이 표시되었는지를 잘 이해하지 못하면 그 가치가 제한될 수 있습니다. 신용 카드 거래 데이터 세트를 확인하는 경우 이상치 탐지 루틴이 매우 이례적인 것으로 보이는 일련의 구매를 식별하고, 따라서 의심스럽다고 식별할 경우, 이것들을 효과적으로 조사할 수 있는 방법은 무엇인지 알고 있어야만 합니다. 경우에 따라 이것이 명백하거나, 시간을 들여 조사한 후에 분명해질 수도 있지만, 발견된 시점에서 이상 점의 특성이 명확하다면 훨씬 효율적입니다.\u003c/p\u003e\n\u003cp\u003e분류 및 회귀와 마찬가지로 해석 가능성이 불가능한 경우, 사후 해설이라고 하는 것을 사용하여 예측을 이해하려는 시도를 하는 것이 종종 가능합니다. Feature importances, proxy models, ALE plots 등을 사용하는 XAI(Explainable AI) 기법을 사용합니다. 이들은 아주 유용하며 앞으로의 기사에서도 다룰 것입니다. 그러나, 처음부터 결과가 명확한 것의 장점도 아주 큽니다.\u003c/p\u003e\n\u003cp\u003e이 기사에서는 특히 표 형식의 데이터에 초점을 맞추지만, 이후의 기사에서 다른 형식을 살펴볼 것입니다. 오늘날 흔히 사용되는 탭 데이터를위한 이상치 검출 알고리즘 중에는 Isolation Forests, Local Outlier Factor (LOF), KNNs, One-Class SVM 등 여러 가지가 있습니다. 이들은 종종 매우 잘 작동하지만, 불행히도 대부분의 경우 이상치를 찾은 이유에 대한 설명을 제공하지 않습니다.\u003c/p\u003e\n\u003cp\u003e대부분의 이상치 탐지 방법은 알고리즘 수준에서 이해하기 쉽지만, 그래도 어떤 레코드가 탐지기에 의해 높은 점수를 받았고 다른 레코드가 그렇지 않았는지를 결정하는 것은 어렵습니다. 예를 들어 금융 거래 데이터 세트를 Isolation Forest와 같은 방법으로 처리하면 가장 이롭은 레코드를 볼 수 있지만, 특히 테이블에 많은 특성이 있는 경우, 이상치가 드문 조합의 다중 특성을 포함하거나 이상치가 특성이 높지만 다중 특성이 다소 이상한 경우에는 왜 그런지 이해하는 것이 어려울 수 있습니다.\u003c/p\u003e\n\u003ch2\u003eFPOF(Frequent Patterns Outlier Factor)\u003c/h2\u003e\n\u003cp\u003e지금은 최소한 빠르게라도 이상치 탐지와 해석에 대해 살펴보았습니다. 이 기사의 나머지는 저의 책인 파이썬에서의 이상치 탐지(\u003ca href=\"https://www.manning.com/books/outlier-detection-in-python)%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.manning.com/books/outlier-detection-in-python)에서\u003c/a\u003e 다루는 FPOF에 대한 발췌문입니다.\u003c/p\u003e\n\u003cp\u003eFPOF(FP-outlier: Frequent pattern based outlier detection)은 이상치 탐지에 어느 정도의 해석 가능성을 제공할 수 있는 소수의 탐지기 중 하나이며, 이상치 탐지에서 더 많이 사용되어야 할 가치가 있습니다.\u003c/p\u003e\n\u003cp\u003e카테고리 데이터와 함께 작동하도록 설계된 매력적인 속성을 갖고 있습니다. 대부분의 현실 세계의 표 데이터는 숫자 및 범주형 열을 모두 포함하는 혼합된 형태입니다. 그러나 대부분의 검출기는 모든 열이 숫자인 것으로 가정하며, 모든 범주형 열을 숫자로 인코딩해야 합니다(원핫, 서수 또는 다른 인코딩을 사용하여).\u003c/p\u003e\n\u003cp\u003eFPOF와 같은 검출기가 데이터가 범주형이라고 가정하는 경우, 우리는 반대의 문제를 겪습니다: 모든 숫자 특성은 범주형 형식으로 변환되어야 합니다. 둘 중 어느 것이라도 사용 가능하지만, 데이터가 주로 범주형인 경우 FPOF와 같은 검출기를 사용할 수 있는 것이 편리합니다.\u003c/p\u003e\n\u003cp\u003e그리고 이상 탐지를 수행할 때 일부 숫자 검출기와 일부 범주형 검출기를 함께 사용할 때 혜택이 있습니다. 불행히도, 비교적 적은 수의 범주형 검출기가 있기 때문에 FPOF는 이런 면에서도 유용하며, 해석력이 필요하지 않은 경우에도 유용합니다.\u003c/p\u003e\n\u003ch2\u003eFPOF 알고리즘\u003c/h2\u003e\n\u003cp\u003eFPOF는 테이블에서 빈발 아이템 세트(Frequent Item Sets, FISs)를 식별하여 작동합니다. 이것들은 하나의 특성에서 매우 흔한 값이거나 함께 자주 나타나는 여러 열에 걸친 값의 세트일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e거의 모든 테이블에는 상당수의 FIS가 포함되어 있습니다. 단일 값에 기초한 FIS는 한 열의 일부 값이 다른 값보다 매우 흔하기 때문에 항상 발생하며, 이는 거의 항상 사실입니다. 그리고 여러 열에 걸친 FIS는 열 사이에 연관성이 있을 때 발생합니다: 특정 값(또는 숫자 값의 범위)이 다른 열에서 다른 값(또는 다시 말해 숫자 값의 범위)과 연관이 있을 때 발생합니다.\u003c/p\u003e\n\u003cp\u003eFPOF는 데이터셋에 많은 빈발 아이템 세트를 포함하고 있다는 아이디어에 기반을 두고 있습니다(거의 모든 데이터셋이 해당됩니다). 그러므로 대부분의 행에는 여러 빈발 아이템 세트가 포함되며, 정상 레코드에는 이상 값(이상치) 행보다 훨씬 더 빈발한 아이템 세트가 포함됩니다. 이를 활용하여 대부분의 행보다 훨씬 적고 훨씬 덜 빈발한 FIS를 포함하는 행을 이상치로 식별할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e실제 데이터 예시\u003c/h2\u003e\n\u003cp\u003e실제로 FPOF를 사용하는 실제 예제를 살펴보면 OpenML의 SpeedDating 세트를 살펴봅니다 (\u003ca href=\"https://www.openml.org/search?type=data\u0026#x26;sort=nr_of_likes\u0026#x26;status=active\u0026#x26;id=40536\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.openml.org/search?type=data\u0026#x26;sort=nr_of_likes\u0026#x26;status=active\u0026#x26;id=40536\u003c/a\u003e, CC BY 4.0 DEED 라이선스).\u003c/p\u003e\n\u003cp\u003eFPOF를 실행하는 것은 먼저 데이터 집합에서 FIS를 채굴하는 것으로 시작합니다. 이를 지원하기 위해 Python에서 사용할 수 있는 여러 라이브러리가 있습니다. 이 예제에서는 머신러닝을 위한 범용 라이브러리 인 mlxtend (\u003ca href=\"https://rasbt.github.io/mlxtend/)%EB%A5%BC\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://rasbt.github.io/mlxtend/)를\u003c/a\u003e 사용합니다. 빈발 항목 집합을 식별하는 여러 알고리즘을 제공하며, 여기서는 apriori라는 알고리즘을 사용합니다.\u003c/p\u003e\n\u003cp\u003e먼저 OpenML에서 데이터를 수집합니다. 보통 범주형 및 (binned) 숫자형 특성을 모두 사용할 것이지만, 여기서는 간단하게 일부 특성만 사용할 것입니다.\u003c/p\u003e\n\u003cp\u003e언급했듯이 FPOF는 숫자형 특성의 binning을 필요로 합니다. 일반적으로 각 숫자 열에 대해 작은 수의 (5에서 20개 정도) 폭이 동일한 bin을 사용합니다. 이를 위해 pandas의 cut() 메서드가 편리합니다. 이 예제는 더 간단합니다. 여기서는 범주형 열만 다룹니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e mlxtend.frequent_patterns \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e apriori\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.datasets \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e fetch_openml\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e warnings\n\nwarnings.filterwarnings(action=\u003cspan class=\"hljs-string\"\u003e'ignore'\u003c/span\u003e, category=DeprecationWarning)\n\ndata = fetch_openml(\u003cspan class=\"hljs-string\"\u003e'SpeedDating'\u003c/span\u003e, version=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, parser=\u003cspan class=\"hljs-string\"\u003e'auto'\u003c/span\u003e)\ndata_df = pd.DataFrame(data.data, columns=data.feature_names)\n\ndata_df = data_df[[\u003cspan class=\"hljs-string\"\u003e'd_pref_o_attractive'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'd_pref_o_sincere'\u003c/span\u003e,\n                   \u003cspan class=\"hljs-string\"\u003e'd_pref_o_intelligence'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'd_pref_o_funny'\u003c/span\u003e,\n                   \u003cspan class=\"hljs-string\"\u003e'd_pref_o_ambitious'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'd_pref_o_shared_interests'\u003c/span\u003e]]\ndata_df = pd.get_dummies(data_df)\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e col_name \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e data_df.columns:\n    data_df[col_name] = data_df[col_name].\u003cspan class=\"hljs-built_in\"\u003emap\u003c/span\u003e({\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e})\n\nfrequent_itemsets = apriori(data_df, min_support=\u003cspan class=\"hljs-number\"\u003e0.3\u003c/span\u003e, use_colnames=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\n\ndata_df[\u003cspan class=\"hljs-string\"\u003e'FPOF_Score'\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e fis_idx \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e frequent_itemsets.index:\n    fis = frequent_itemsets.loc[fis_idx, \u003cspan class=\"hljs-string\"\u003e'itemsets'\u003c/span\u003e]\n    support = frequent_itemsets.loc[fis_idx, \u003cspan class=\"hljs-string\"\u003e'support'\u003c/span\u003e]\n    col_list = (\u003cspan class=\"hljs-built_in\"\u003elist\u003c/span\u003e(fis))\n    cond = \u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e col_name \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e col_list:\n        cond = cond \u0026#x26; (data_df[col_name])\n\n    data_df.loc[data_df[cond].index, \u003cspan class=\"hljs-string\"\u003e'FPOF_Score'\u003c/span\u003e] += support\n\nmin_score = data_df[\u003cspan class=\"hljs-string\"\u003e'FPOF_Score'\u003c/span\u003e].\u003cspan class=\"hljs-built_in\"\u003emin\u003c/span\u003e()\nmax_score = data_df[\u003cspan class=\"hljs-string\"\u003e'FPOF_Score'\u003c/span\u003e].\u003cspan class=\"hljs-built_in\"\u003emax\u003c/span\u003e()\ndata_df[\u003cspan class=\"hljs-string\"\u003e'FPOF_Score'\u003c/span\u003e] = [(max_score - x) / (max_score - min_score)\n                         \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e data_df[\u003cspan class=\"hljs-string\"\u003e'FPOF_Score'\u003c/span\u003e]]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아프리오리 알고리즘은 모든 기능이 원-핫 인코딩되어 있어야합니다. 이를 위해 판다의 get_dummies() 메서드를 사용합니다.\u003c/p\u003e\n\u003cp\u003e그런 다음 apriori 메서드를 호출하여 빈번한 항목 집합을 결정합니다. 이를 수행하기 위해 FIS가 나타나는 행의 최소 분수 인 최소 지원을 지정해야합니다. 이 값을 너무 높게 설정하면 강한 이상값도 FIS를 포함 시키지 않으며 FIS가 적게 포함 된 레코드를 어렵게 구별하게됩니다. 그리고 이 값을 너무 낮게 설정하면 FIS가 의미없을 수 있으며 이상값도 이니셜과 동일한 수의 FIS를 포함 할 수 있습니다. 낮은 최소 지원으로 apriori를 사용하면 매우 많은 수의 FIS를 생성 할 수 있으며 실행 속도가 느려지고 해석 가능성이 낮아질 수 있습니다. 이 예에서는 0.3을 사용합니다.\u003c/p\u003e\n\u003cp\u003eFIS의 크기에 제한을 둘 수도 있고 때로는 그렇게합니다. 최소 및 최대 열 수 사이에 관련되도록 요구하는 여러 항목 집합의 크기에 제한을 둘 수 있으며 가장 관심 있는 이상값의 형태를 좁히는 데 도움이 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e빈도가 높은 항목 집합은 지원과 열 값을 나타내는 팬더 데이터프레임에서 반환됩니다. 이 값은 원-핫 인코딩된 열 형식으로 표시되며 원본 열과 값을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e결과를 해석하기 위해 먼저 자주 등장하는 항목 집합(frequent_itemsets)을 확인할 수 있습니다. 각 FIS의 길이를 포함하려면:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efrequent_itemsets[\u003cspan class=\"hljs-string\"\u003e'length'\u003c/span\u003e] = \\\n    frequent_itemsets[\u003cspan class=\"hljs-string\"\u003e'itemsets'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(lambda \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(x))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e총 24개의 FIS가 발견되었으며, 가장 긴 것은 세 가지 특징을 포함하고 있습니다. 다음 표는 지원에 따라 정렬된 처음 열 개의 행을 표시합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e그런 다음 각 빈번한 항목 집합을 루프하고 지원하는 빈번한 항목 집합을 포함하는 각 행에 대해 점수를 증가시킵니다. 이는 선택적으로 길이가 더 큰 빈번한 항목 집합을 선호하도록 조정할 수 있습니다(예를 들어, 지원이 0.4이고 5개 열을 포함하는 FIS는, 그 외의 조건이 동일한 경우, 2개 열을 포함하는 지원이 0.4인 FIS보다 관련성이 더 높습니다), 하지만 여기서는 각 행의 FIS 수 및 지원을 간단히 사용합니다.\u003c/p\u003e\n\u003cp\u003e실제로 이것은 정상성에 대한 점수를 생성하고 이상값이 아닙니다. 따라서 점수를 0.0과 1.0 사이로 정규화할 때 순서를 뒤집습니다. 이제 가장 높은 점수를 가진 행이 가장 강한 이상값입니다: 가장 적고 가장 일반적인 빈번한 항목 집합을 가진 행입니다.\u003c/p\u003e\n\u003cp\u003e원래 데이터프레임에 점수 열을 추가하고 점수별로 정렬하면 가장 정상적인 행을 확인할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 행의 값들이 FISs와 잘 일치하는 것을 볼 수 있습니다. d_pref_o_attractive의 값은 [21-100]이며 이는 FIS(지원 0.36)와 일치합니다. d_pref_o_ambitious와 d_pref_o_shared_interests의 값은 각각 [0-15]로, 이 또한 FIS(지원 0.59)와 일치합니다. 다른 값들도 대부분 FIS들과 일치합니다.\u003c/p\u003e\n\u003cp\u003e가장 이상한 행은 다음과 같이 표시됩니다. 이는 식별된 FIS들과 일치하지 않습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e자주 나오는 항목 집합 자체가 꽤 이해하기 쉬우므로,이 방법은 상당히 해석 가능한 결과를 얻는 장점이 있습니다. 다만, 자주 나오는 항목 집합이 많이 사용되는 경우에는 이러한 장점이 적을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF_3.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e해석력은 향상될 수 있지만, 이상치는 \"포함하지 않는다\"는 방식으로 식별되기 때문에, 각 이상치의 점수를 설명하는 것은 해당 이상치에 포함되지 않는 모든 항목 집합을 나열하는 것을 의미합니다. 그러나 각 이상치를 설명하기 위해 모든 누락된 항목 집합을 나열하는 것이 반드시 필요한 것은 아닙니다. 누락된 가장 일반적인 항목 집합을 나열하는 것은 대부분의 목적에 충분할 것입니다. 행에 나타나는 항목 집합과 있는 항목 집합의 통계와 빈도를 비교하는 것은 좋은 컨텍스트를 제공합니다.\u003c/p\u003e\n\u003cp\u003e이 방법의 변형 중 하나는 자주 나오는 것이 아닌 드문 항목 집합을 사용하는 것인데, 각 행의 드문 항목 집합의 수와 희귀성에 따라 각 행을 점수 매깁니다. 이 방법도 유용한 결과를 얻을 수 있지만, 계산 비용이 상당히 많이 소요되며, 더 많은 항목 집합이 채굴되어야 하고, 각 행은 많은 항목 집합과 테스트되어야 합니다. 그러나 최종 점수는 각 행에 누락된 대신 발견된 항목 집합을 기반으로 하므로 더 해석하기 쉬울 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e결론\u003c/h2\u003e\n\u003cp\u003e여기에 나와 있는 코드 외에는 파이썬에서 FPOF를 구현한 것을 알지 못합니다. 그러나 R에서는 구현된 것이 있습니다. FPOF 작업의 주요 부분은 FISs를 채굴하는 것이며, 여기에서 사용된 mlxtend 라이브러리를 포함하여 이를 수행할 수 있는 다양한 파이썬 도구가 있습니다. 위에서 본 FPOP의 나머지 코드는 꽤 간단합니다.\u003c/p\u003e\n\u003cp\u003e이상 탐지에서 해석 가능성의 중요성을 고려할 때, FPOF는 매우 유용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e향후 기사에서는 이상 탐지를 위한 다른 해석 가능한 방법에 대해 알아볼 것입니다.\u003c/p\u003e\n\u003cp\u003e모든 그림은 저자에 의해 생성되었습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-05-27-InterpretableOutlierDetectionFrequentPatternsOutlierFactorFPOF"},"buildId":"O5JVeK6TDhbvSxBlchQwM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>