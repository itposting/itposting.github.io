<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>파이썬으로 간단한 ROS2 장애물 회피 로봇 만들기 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="파이썬으로 간단한 ROS2 장애물 회피 로봇 만들기 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="파이썬으로 간단한 ROS2 장애물 회피 로봇 만들기 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython" data-gatsby-head="true"/><meta name="twitter:title" content="파이썬으로 간단한 ROS2 장애물 회피 로봇 만들기 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 18:23" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_buildManifest.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">파이썬으로 간단한 ROS2 장애물 회피 로봇 만들기 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="파이썬으로 간단한 ROS2 장애물 회피 로봇 만들기 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png">
<p>이 튜토리얼에서는 ROS2 (로봇 운영 시스템 2) 및 Python을 사용하여 간단한 물체 회피 로봇을 구축할 것입니다. 이 로봇은 장애물을 감지하기 위해 LIDAR 센서를 사용하고, 이동을 조정하여 주변을 피해 이동합니다. 이 프로젝트는 ROS2를 시작하는 좋은 방법이며, 센서를 사용하고 로봇의 이동을 제어하는 방법을 배우는 데 도움이 될 것입니다.</p>
<h1>준비물</h1>
<p>시작하기 전에 다음을 갖추고 있는지 확인하세요:</p>
<div class="content-ad"></div>
<ul>
<li>ROS2 설치 (Foxy, Galactic 또는 그 이후 버전).</li>
<li>Python 프로그래밍에 대한 기본 지식.</li>
<li>ROS2를 사용하여 제어되는 LIDAR 센서가 장착된 시뮬레이션된 또는 실제 로봇.</li>
</ul>
<h1>프로젝트 개요</h1>
<p>우리 프로젝트의 주요 구성 요소는 다음과 같습니다:</p>
<ul>
<li>LIDAR 센서: 로봇 주변의 장애물을 감지하는 데 사용됩니다.</li>
<li>LaserScan 메시지: LIDAR에서의 거리 데이터를 포함하는 ROS 메시지 유형.</li>
<li>Twist 메시지: 로봇의 선형 및 각속도를 제어하는 ROS 메시지 유형.</li>
<li>노드: LIDAR 데이터를 구독하고 속도 명령을 게시하는 ROS2 노드.</li>
</ul>
<div class="content-ad"></div>
<h1>코드 설명</h1>
<p>아래는 우리의 객체 회피 노드에 대한 완전한 코드입니다:</p>
<pre><code class="hljs language-python"><span class="hljs-comment">#!/usr/bin/env python3</span>

<span class="hljs-keyword">import</span> rclpy
<span class="hljs-keyword">from</span> rclpy.node <span class="hljs-keyword">import</span> Node
<span class="hljs-keyword">from</span> sensor_msgs.msg <span class="hljs-keyword">import</span> LaserScan
<span class="hljs-keyword">from</span> geometry_msgs.msg <span class="hljs-keyword">import</span> Twist

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ObjectAvoidanceNode</span>(<span class="hljs-title class_ inherited__">Node</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-built_in">super</span>().__init__(<span class="hljs-string">'object_avoidance_node'</span>)
        self.subscription = self.create_subscription(
            LaserScan,
            <span class="hljs-string">'scan'</span>,
            self.lidar_callback,
            <span class="hljs-number">10</span>)
        self.publisher = self.create_publisher(Twist, <span class="hljs-string">'cmd_vel'</span>, <span class="hljs-number">10</span>)
        self.safe_distance = <span class="hljs-number">0.5</span>  <span class="hljs-comment"># 미터</span>
        self.get_logger().info(<span class="hljs-string">'Object Avoidance Node Started'</span>)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">lidar_callback</span>(<span class="hljs-params">self, msg</span>):
        ranges = msg.ranges
        min_distance = <span class="hljs-built_in">min</span>(ranges)
        
        twist_msg = Twist()

        <span class="hljs-keyword">if</span> min_distance &#x3C; self.safe_distance:
            <span class="hljs-comment"># 장애물 감지, 로봇을 회전시킵니다</span>
            twist_msg.linear.x = <span class="hljs-number">0.0</span>
            twist_msg.angular.z = <span class="hljs-number">0.5</span>  <span class="hljs-comment"># 시계 반대방향으로 회전</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># 장애물 감지되지 않음, 전진합니다</span>
            twist_msg.linear.x = <span class="hljs-number">0.2</span>
            twist_msg.angular.z = <span class="hljs-number">0.0</span>

        self.publisher.publish(twist_msg)

<span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">args=<span class="hljs-literal">None</span></span>):
    rclpy.init(args=args)
    node = ObjectAvoidanceNode()

    <span class="hljs-keyword">try</span>:
        rclpy.spin(node)
    <span class="hljs-keyword">except</span> KeyboardInterrupt:
        node.get_logger().info(<span class="hljs-string">'Keyboard Interrupt (SIGINT)'</span>)
    <span class="hljs-keyword">finally</span>:
        node.destroy_node()
        rclpy.shutdown()

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    main()
</code></pre>
<h1>코드 설명</h1>
<div class="content-ad"></div>
<ul>
<li>Imports: 필요한 모듈을 rclpy, sensor_msgs.msg 및 geometry_msgs.msg에서 가져옵니다.</li>
<li>노드 초기화: Node를 상속하는 ObjectAvoidanceNode 클래스를 정의합니다. 생성자에서는 LaserScan 메시지를 수신할 /scan 토픽에 대한 구독 및 Twist 메시지를 보낼 /cmd_vel 토픽에 대한 게시자를 설정합니다.</li>
<li>LIDAR 콜백: lidar_callback 메서드는 수신된 LaserScan 메시지를 처리합니다. LIDAR가 감지한 장애물까지의 최소 거리를 찾습니다. 이 거리가 self.safe_distance(0.5 미터)보다 작으면 로봇은 전진을 멈추고 장애물을 피하기 위해 회전을 시작합니다. 안전 거리 내에 장애물이 없으면 로봇은 전진합니다.</li>
<li>명령 게시: 감지된 거리에 따라 Twist 메시지에 적절한 선형 및 각속도를 할당하고 /cmd_vel 토픽으로 게시합니다.</li>
<li>메인 함수: 메인 함수는 ROS2 Python 클라이언트 라이브러리를 초기화하고 ObjectAvoidanceNode의 인스턴스를 생성한 다음 (콜백을 처리하며) 스핀을 시작합니다. 노드가 (예: Ctrl+C를 눌러) 중단되면 깔끔하게 종료됩니다.</li>
</ul>
<h1>노드 실행</h1>
<p>ROS2 환경이 정상적으로 소스로드되고 필요한 토픽 (/scan 및 /cmd_vel)이 사용 가능한지 확인하세요.</p>
<img src="https://miro.medium.com/v2/resize:fit:1400/1*XNR1_8EGSFbgsAnJUJ05FQ.gif">
<div class="content-ad"></div>
<h1>결론</h1>
<p>이 튜토리얼은 ROS2와 Python을 사용하여 객체 회피 로봇의 기본 프레임워크를 제공합니다. 이 코드를 확장하여 장애물 맵핑, 경로 계획 및 다른 센서 통합과 같은 고급 기능을 구현할 수 있습니다. ROS2의 모듈식 아키텍처와 방대한 커뮤니티 지원으로 로봇 개발에 우수한 선택지입니다. 즐거운 코딩되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"파이썬으로 간단한 ROS2 장애물 회피 로봇 만들기 방법","description":"","date":"2024-06-23 18:23","slug":"2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png\" /\u003e\n\n이 튜토리얼에서는 ROS2 (로봇 운영 시스템 2) 및 Python을 사용하여 간단한 물체 회피 로봇을 구축할 것입니다. 이 로봇은 장애물을 감지하기 위해 LIDAR 센서를 사용하고, 이동을 조정하여 주변을 피해 이동합니다. 이 프로젝트는 ROS2를 시작하는 좋은 방법이며, 센서를 사용하고 로봇의 이동을 제어하는 방법을 배우는 데 도움이 될 것입니다.\n\n# 준비물\n\n시작하기 전에 다음을 갖추고 있는지 확인하세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- ROS2 설치 (Foxy, Galactic 또는 그 이후 버전).\n- Python 프로그래밍에 대한 기본 지식.\n- ROS2를 사용하여 제어되는 LIDAR 센서가 장착된 시뮬레이션된 또는 실제 로봇.\n\n# 프로젝트 개요\n\n우리 프로젝트의 주요 구성 요소는 다음과 같습니다:\n\n- LIDAR 센서: 로봇 주변의 장애물을 감지하는 데 사용됩니다.\n- LaserScan 메시지: LIDAR에서의 거리 데이터를 포함하는 ROS 메시지 유형.\n- Twist 메시지: 로봇의 선형 및 각속도를 제어하는 ROS 메시지 유형.\n- 노드: LIDAR 데이터를 구독하고 속도 명령을 게시하는 ROS2 노드.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 코드 설명\n\n아래는 우리의 객체 회피 노드에 대한 완전한 코드입니다:\n\n```python\n#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom geometry_msgs.msg import Twist\n\nclass ObjectAvoidanceNode(Node):\n    def __init__(self):\n        super().__init__('object_avoidance_node')\n        self.subscription = self.create_subscription(\n            LaserScan,\n            'scan',\n            self.lidar_callback,\n            10)\n        self.publisher = self.create_publisher(Twist, 'cmd_vel', 10)\n        self.safe_distance = 0.5  # 미터\n        self.get_logger().info('Object Avoidance Node Started')\n\n    def lidar_callback(self, msg):\n        ranges = msg.ranges\n        min_distance = min(ranges)\n        \n        twist_msg = Twist()\n\n        if min_distance \u003c self.safe_distance:\n            # 장애물 감지, 로봇을 회전시킵니다\n            twist_msg.linear.x = 0.0\n            twist_msg.angular.z = 0.5  # 시계 반대방향으로 회전\n        else:\n            # 장애물 감지되지 않음, 전진합니다\n            twist_msg.linear.x = 0.2\n            twist_msg.angular.z = 0.0\n\n        self.publisher.publish(twist_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ObjectAvoidanceNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Keyboard Interrupt (SIGINT)')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n```\n\n# 코드 설명\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Imports: 필요한 모듈을 rclpy, sensor_msgs.msg 및 geometry_msgs.msg에서 가져옵니다.\n- 노드 초기화: Node를 상속하는 ObjectAvoidanceNode 클래스를 정의합니다. 생성자에서는 LaserScan 메시지를 수신할 /scan 토픽에 대한 구독 및 Twist 메시지를 보낼 /cmd_vel 토픽에 대한 게시자를 설정합니다.\n- LIDAR 콜백: lidar_callback 메서드는 수신된 LaserScan 메시지를 처리합니다. LIDAR가 감지한 장애물까지의 최소 거리를 찾습니다. 이 거리가 self.safe_distance(0.5 미터)보다 작으면 로봇은 전진을 멈추고 장애물을 피하기 위해 회전을 시작합니다. 안전 거리 내에 장애물이 없으면 로봇은 전진합니다.\n- 명령 게시: 감지된 거리에 따라 Twist 메시지에 적절한 선형 및 각속도를 할당하고 /cmd_vel 토픽으로 게시합니다.\n- 메인 함수: 메인 함수는 ROS2 Python 클라이언트 라이브러리를 초기화하고 ObjectAvoidanceNode의 인스턴스를 생성한 다음 (콜백을 처리하며) 스핀을 시작합니다. 노드가 (예: Ctrl+C를 눌러) 중단되면 깔끔하게 종료됩니다.\n\n# 노드 실행\n\nROS2 환경이 정상적으로 소스로드되고 필요한 토픽 (/scan 및 /cmd_vel)이 사용 가능한지 확인하세요.\n\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*XNR1_8EGSFbgsAnJUJ05FQ.gif\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n이 튜토리얼은 ROS2와 Python을 사용하여 객체 회피 로봇의 기본 프레임워크를 제공합니다. 이 코드를 확장하여 장애물 맵핑, 경로 계획 및 다른 센서 통합과 같은 고급 기능을 구현할 수 있습니다. ROS2의 모듈식 아키텍처와 방대한 커뮤니티 지원으로 로봇 개발에 우수한 선택지입니다. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png"},"coverImage":"/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png\"\u003e\n\u003cp\u003e이 튜토리얼에서는 ROS2 (로봇 운영 시스템 2) 및 Python을 사용하여 간단한 물체 회피 로봇을 구축할 것입니다. 이 로봇은 장애물을 감지하기 위해 LIDAR 센서를 사용하고, 이동을 조정하여 주변을 피해 이동합니다. 이 프로젝트는 ROS2를 시작하는 좋은 방법이며, 센서를 사용하고 로봇의 이동을 제어하는 방법을 배우는 데 도움이 될 것입니다.\u003c/p\u003e\n\u003ch1\u003e준비물\u003c/h1\u003e\n\u003cp\u003e시작하기 전에 다음을 갖추고 있는지 확인하세요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eROS2 설치 (Foxy, Galactic 또는 그 이후 버전).\u003c/li\u003e\n\u003cli\u003ePython 프로그래밍에 대한 기본 지식.\u003c/li\u003e\n\u003cli\u003eROS2를 사용하여 제어되는 LIDAR 센서가 장착된 시뮬레이션된 또는 실제 로봇.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e프로젝트 개요\u003c/h1\u003e\n\u003cp\u003e우리 프로젝트의 주요 구성 요소는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLIDAR 센서: 로봇 주변의 장애물을 감지하는 데 사용됩니다.\u003c/li\u003e\n\u003cli\u003eLaserScan 메시지: LIDAR에서의 거리 데이터를 포함하는 ROS 메시지 유형.\u003c/li\u003e\n\u003cli\u003eTwist 메시지: 로봇의 선형 및 각속도를 제어하는 ROS 메시지 유형.\u003c/li\u003e\n\u003cli\u003e노드: LIDAR 데이터를 구독하고 속도 명령을 게시하는 ROS2 노드.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e코드 설명\u003c/h1\u003e\n\u003cp\u003e아래는 우리의 객체 회피 노드에 대한 완전한 코드입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e#!/usr/bin/env python3\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e rclpy\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e rclpy.node \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Node\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sensor_msgs.msg \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e LaserScan\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e geometry_msgs.msg \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Twist\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObjectAvoidanceNode\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eNode\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-built_in\"\u003esuper\u003c/span\u003e().__init__(\u003cspan class=\"hljs-string\"\u003e'object_avoidance_node'\u003c/span\u003e)\n        self.subscription = self.create_subscription(\n            LaserScan,\n            \u003cspan class=\"hljs-string\"\u003e'scan'\u003c/span\u003e,\n            self.lidar_callback,\n            \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n        self.publisher = self.create_publisher(Twist, \u003cspan class=\"hljs-string\"\u003e'cmd_vel'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n        self.safe_distance = \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e  \u003cspan class=\"hljs-comment\"\u003e# 미터\u003c/span\u003e\n        self.get_logger().info(\u003cspan class=\"hljs-string\"\u003e'Object Avoidance Node Started'\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elidar_callback\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, msg\u003c/span\u003e):\n        ranges = msg.ranges\n        min_distance = \u003cspan class=\"hljs-built_in\"\u003emin\u003c/span\u003e(ranges)\n        \n        twist_msg = Twist()\n\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e min_distance \u0026#x3C; self.safe_distance:\n            \u003cspan class=\"hljs-comment\"\u003e# 장애물 감지, 로봇을 회전시킵니다\u003c/span\u003e\n            twist_msg.linear.x = \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\n            twist_msg.angular.z = \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e  \u003cspan class=\"hljs-comment\"\u003e# 시계 반대방향으로 회전\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n            \u003cspan class=\"hljs-comment\"\u003e# 장애물 감지되지 않음, 전진합니다\u003c/span\u003e\n            twist_msg.linear.x = \u003cspan class=\"hljs-number\"\u003e0.2\u003c/span\u003e\n            twist_msg.angular.z = \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\n\n        self.publisher.publish(twist_msg)\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eargs=\u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\u003c/span\u003e):\n    rclpy.init(args=args)\n    node = ObjectAvoidanceNode()\n\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e:\n        rclpy.spin(node)\n    \u003cspan class=\"hljs-keyword\"\u003eexcept\u003c/span\u003e KeyboardInterrupt:\n        node.get_logger().info(\u003cspan class=\"hljs-string\"\u003e'Keyboard Interrupt (SIGINT)'\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003efinally\u003c/span\u003e:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e'__main__'\u003c/span\u003e:\n    main()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e코드 설명\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eImports: 필요한 모듈을 rclpy, sensor_msgs.msg 및 geometry_msgs.msg에서 가져옵니다.\u003c/li\u003e\n\u003cli\u003e노드 초기화: Node를 상속하는 ObjectAvoidanceNode 클래스를 정의합니다. 생성자에서는 LaserScan 메시지를 수신할 /scan 토픽에 대한 구독 및 Twist 메시지를 보낼 /cmd_vel 토픽에 대한 게시자를 설정합니다.\u003c/li\u003e\n\u003cli\u003eLIDAR 콜백: lidar_callback 메서드는 수신된 LaserScan 메시지를 처리합니다. LIDAR가 감지한 장애물까지의 최소 거리를 찾습니다. 이 거리가 self.safe_distance(0.5 미터)보다 작으면 로봇은 전진을 멈추고 장애물을 피하기 위해 회전을 시작합니다. 안전 거리 내에 장애물이 없으면 로봇은 전진합니다.\u003c/li\u003e\n\u003cli\u003e명령 게시: 감지된 거리에 따라 Twist 메시지에 적절한 선형 및 각속도를 할당하고 /cmd_vel 토픽으로 게시합니다.\u003c/li\u003e\n\u003cli\u003e메인 함수: 메인 함수는 ROS2 Python 클라이언트 라이브러리를 초기화하고 ObjectAvoidanceNode의 인스턴스를 생성한 다음 (콜백을 처리하며) 스핀을 시작합니다. 노드가 (예: Ctrl+C를 눌러) 중단되면 깔끔하게 종료됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e노드 실행\u003c/h1\u003e\n\u003cp\u003eROS2 환경이 정상적으로 소스로드되고 필요한 토픽 (/scan 및 /cmd_vel)이 사용 가능한지 확인하세요.\u003c/p\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1400/1*XNR1_8EGSFbgsAnJUJ05FQ.gif\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 튜토리얼은 ROS2와 Python을 사용하여 객체 회피 로봇의 기본 프레임워크를 제공합니다. 이 코드를 확장하여 장애물 맵핑, 경로 계획 및 다른 센서 통합과 같은 고급 기능을 구현할 수 있습니다. ROS2의 모듈식 아키텍처와 방대한 커뮤니티 지원으로 로봇 개발에 우수한 선택지입니다. 즐거운 코딩되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython"},"buildId":"8coAiP0lmiEK5aH6nkQkj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>