<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>이상치 탐지를 위한 3가지 간단한 통계적 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="이상치 탐지를 위한 3가지 간단한 통계적 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="이상치 탐지를 위한 3가지 간단한 통계적 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection" data-gatsby-head="true"/><meta name="twitter:title" content="이상치 탐지를 위한 3가지 간단한 통계적 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 20:07" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_buildManifest.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">이상치 탐지를 위한 3가지 간단한 통계적 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="이상치 탐지를 위한 3가지 간단한 통계적 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_0.png">
<p>데이터 과학자의 일 중 중요한 부분은 데이터를 정제하고 전처리하는 것입니다. 이 과정 중 하나인 이상치 탐지와 제거는 매우 중요합니다. 대규모의 이상치, 급증, 그리고 나쁜 데이터는 정확한 기계 학습 모델을 학습하는 데 방해가 될 수 있기 때문에, 이상치를 적절하게 처리하는 것이 중요합니다.</p>
<p>하지만 데이터 과학자들이 항상 이상치를 식별하기 위해 격리 숲 또는 국소 이상치 요소처럼 기계 학습 모델을 사용하는 것은 아닙니다. 제 데이터 과학 경력에서 배운 한 가지는 간단한 해결 방법이 효과적이면 그것을 사용해야 한다는 것입니다.</p>
<p>이번에는 대부분의 시간에 잘 동작하는 이상치를 탐지하는 데 유용한 3가지 간단한 통계적 솔루션을 제공하고자 합니다. 또한 이를 Python에서 어떻게 수행하는지도 보여드릴 것입니다.</p>
<div class="content-ad"></div>
<h1>1. Z 점수</h1>
<p>Z 점수는 표준 점수로도 알려져 있으며, 특이값을 감지하는 데 사용되는 잘 알려진 방법 중 하나입니다. 기본적으로 어떤 데이터 포인트가 평균에서 몇 개의 표준 편차만큼 떨어져 있는지를 나타냅니다.</p>
<p>어떤 데이터셋의 특정 데이터 포인트의 Z 점수는 다음과 같이 계산됩니다:</p>
<p><img src="/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_1.png" alt=""></p>
<div class="content-ad"></div>
<p>어디서:</p>
<ul>
<li>Z는 Z 점수 값입니다.</li>
<li>x는 데이터 포인트입니다.</li>
<li>μ는 데이터 집합의 평균입니다.</li>
<li>σ는 표준 편차입니다.</li>
</ul>
<p>따라서 Z 점수가 4인 경우 데이터 포인트가 평균보다 4 표준 편차 위에 있음을 의미합니다. Z 점수가 -4인 경우에는 평균보다 4 표준 편차 아래에 있습니다.</p>
<p>Z 점수의 경우, 일반적으로 3 이상 또는 -3 미만의 값은 이상치로 간주됩니다. 그러나이 기준은 유연하며 프로그래머에 따라 조정할 수 있습니다.</p>
<div class="content-ad"></div>
<p>아래와 같이 Python과 scipy.stats 패키지를 사용하여 데이터프레임 열의 각 값의 z 점수를 계산하는 간단한 방법이 있어요:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats

df[<span class="hljs-string">"z_score"</span>] = stats.zscore(df[<span class="hljs-string">"column_of_interest"</span>])
</code></pre>
<p>데이터셋의 각 값에 대한 z 점수를 얻은 후에는 이상값을 걸러낼 수 있어요:</p>
<pre><code class="hljs language-python">df_clean = df[(df[<span class="hljs-string">"z_score"</span>] &#x3C;= <span class="hljs-number">3</span>) &#x26; (df[<span class="hljs-string">"z_score"</span>] >= -<span class="hljs-number">3</span>)]
</code></pre>
<div class="content-ad"></div>
<p>z 점수의 단점 중 하나는 이상치 탐지 방법임에도 불구하고 이상치에 민감하다는 것입니다. 데이터 세트에 매우 큰 이상치가 있는 경우 평균을 왜곡할 수 있습니다 (평균은 이상치에 민감하기 때문입니다). 평균이 왜곡되면 더 작지만 여전히 관련 있는 이상치를 잡지 못할 수 있습니다.</p>
<h2>2. IQR</h2>
<p>IQR (사분위 범위)는 평균 대신 중앙값을 기준점으로 사용하기 때문에 z 점수보다 견고합니다.</p>
<p><img src="/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_2.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>이제 IQR 값을 구했으니, 다른 점들이 이상값인지 판별하는 기준점으로 사용될 것입니다. Q1 값보다 1.5 * IQR 이상 또는 Q3 값보다 1.5 * IQR 이하인 모든 점은 이상치로 간주됩니다.</p>
<p>이 경우, 46.5(27 + 13 * 1.5)보다 큰 값 또는 -5.5(14 - 13 * 1.5)보다 작은 값은 이상치로 간주됩니다.</p>
<p>파이썬에서 numpy의 percentile 및 scipy stats의 IQR 함수를 사용하여 이를 계산하는 방법은 다음과 같습니다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> iqr
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

<span class="hljs-comment"># 데이터의 IQR 구하기</span>
iqr_data = iqr(df[<span class="hljs-string">"column_of_interest"</span>])
<span class="hljs-comment"># 범위를 벗어나는 값을 얻기 위한 참조점 계산 (1.5 * IQR)</span>
iqr_lim = <span class="hljs-number">1.5</span> * iqr_data

<span class="hljs-comment"># 상위 (Q3 또는 75번째 백분위수)와 하위사분위 (Q1 또는 25번째 백분위수) 계산</span>
q1 = np.percentile(df[<span class="hljs-string">"column_of_interest"</span>], <span class="hljs-number">25</span>)
q3 = np.percentile(df[<span class="hljs-string">"column_of_interest"</span>], <span class="hljs-number">75</span>)

<span class="hljs-comment"># 사분위수와 IQR*1.5를 사용하여 상한선과 하한선 결정</span>
상한선 = q3 + iqr_lim
하한선 = q1 - iqr_lim

<span class="hljs-comment"># 상한선보다 작거나 하한선보다 큰 값은 이상치로 간주하고 제거</span>
df_clean_iqr = df[(df[<span class="hljs-string">"column_of_interest"</span>] >= lower_limit) 
&#x26; (df[<span class="hljs-string">"column_of_interest"</span>] &#x3C;= upper_limit)]
</code></pre>
<div class="content-ad"></div>
<p>위에서 볼 수 있듯이 데이터 세트의 IQR을 계산하려면 z 점수보다 몇 가지 더 많은 단계/코드 줄이 필요합니다. 또한 각 데이터 포인트에 대한 가시적인 "점수"를 얻지 못하므로 얼마나 이상하게 큰지를 나타내지 않습니다. 여기서는 어떤 것이 범위를 벗어났는지 여부만을 알 수 있습니다.</p>
<p>그러나 중앙값을 사용하기 때문에 평균보다 쉽게 왜곡되지 않아서 데이터 세트의 이상치에 덜 민감합니다.</p>
<h1>3. 수정된 z 점수</h1>
<p>수정된 z 점수는 z 점수와 IQR의 측면을 모두 고려하여 표준 z 점수의 더 견고한 버전을 만듭니다. 데이터 점이 얼마나 "멀리 떨어져" 있는지를 대략적으로 알려주는 점수를 제공하면서도 이상치에 민감하지 않습니다.</p>
<div class="content-ad"></div>
<p>z 점수와 수정된 z 점수의 주요 차이점은 수정된 z 점수가 평균 대신 중앙값을 기준점으로 사용한다는 것입니다. 표준 편차가 평균과 직접적으로 관련되어 있기 때문에, 수정된 z 점수는 정확한 표준 편차를 측정하지 않습니다. 그러나 중위수 절대 편차(MAD)를 사용하여 표준 편차를 근사하려고 합니다.</p>
<p><img src="/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_3.png" alt="image"></p>
<p>여기서,</p>
<ul>
<li>0.6745는 표준 편차의 중위수에 해당하는 값을 근사화하는 데 사용되는 상수입니다.</li>
<li>xi는 조사하는 데이터 포인트입니다.</li>
<li>x͂는 데이터셋의 중앙값입니다.</li>
<li>MAD는 데이터셋의 중위수 절대 편차입니다.</li>
</ul>
<div class="content-ad"></div>
<p>중앙값 절대 편차를 계산하려면 데이터 세트의 중앙값에서 각 데이터 포인트를 빼면 됩니다. 이 뺄셈의 절대값을 취하세요. 마지막으로, 이러한 절대 차이의 중앙값을 취하면 됩니다.</p>
<p>일반적으로 수정된 z 점수에서는 점수가 <code>3.5 또는</code>-3.5 인 값이 이상치로 간주됩니다.</p>
<p>수정된 z 점수의 계산 방법과 Python에서의 실제 예제에 대한 더 자세한 정보가 필요하시면 수정된 z 점수에 관한 제 글을 참조해주세요:</p>
<p>Python에서 수정된 z 점수를 구현하는 방법은 다음과 같습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 이 함수는 값을 취하고 데이터 집합을 취하여 하나의 값을 위한 수정된 z 점수를 반환합니다.
def <span class="hljs-title function_">compute_mod_z_score</span>(value,df):
    # 데이터 집합의 <span class="hljs-title function_">MAD</span>(흑백절대편차) 계산 (관심 있는 열)
    med_abs_dev = (np.<span class="hljs-title function_">abs</span>(df[<span class="hljs-string">"column_of_interest"</span>] - 
                  df[<span class="hljs-string">"column_of_interest"</span>].<span class="hljs-title function_">median</span>())).<span class="hljs-title function_">median</span>()
    <span class="hljs-keyword">const</span> = <span class="hljs-number">0.6745</span>
    mod_z = (<span class="hljs-keyword">const</span> * (value - df[<span class="hljs-string">"column_of_interest"</span>].<span class="hljs-title function_">median</span>()) 
            / med_abs_dev)
    <span class="hljs-keyword">return</span> mod_z

# 위의 함수를 전체 열에 적용하여 수정된 Z 점수를 모든 데이터 점에 대해 얻습니다.
df[<span class="hljs-string">"mod_zscore"</span>]=df[<span class="hljs-string">"column_of_interest"</span>].<span class="hljs-title function_">apply</span>(compute_mod_z_score,df=df)
</code></pre>
<p>수정된 Z 점수의 주요 단점은 덜 알려져 있으며 MAD와 같은 변수를 사용하기 때문에 설명하기가 조금 더 복잡하고 어려울 수 있다는 것입니다. 또한 저는 아는 한 Python 라이브러리 중에 수정된 Z 점수를 계산하는 것이 없습니다.</p>
<h1>결론</h1>
<p>보시다시피, 이상치 탐지의 각 통계적 방법마다 이점과 단점이 있습니다. 제가 일하는 곳에서는 이를 모두 사용했지만 다른 데이터 집합과 사용 사례에 대해 사용했습니다. 데이터를 탐색하여 문제에 접근하는 방법을 알아야 한다는 점의 중요성을 강조할 수 없습니다.</p>
<div class="content-ad"></div>
<p>만약 데이터셋이 급격한 변동이 있는 경우에는 수정된 z 점수나 IQR이 가장 적합할 수 있습니다. 가장 간단하고 설명하기 쉬운 해결책을 찾고 있다면 z 점수 / 표준 점수를 선택하는 것이 좋습니다.</p>
<p>언제나 여러분만의 테스트를 실행하고 다른 데이터 과학자들이나 결과에 혜택을 받을 수 있는 관련 이해당사자들과 상의하는 것이 중요합니다.</p>
<h1>읽어주셔서 감사합니다</h1>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"이상치 탐지를 위한 3가지 간단한 통계적 방법","description":"","date":"2024-06-19 20:07","slug":"2024-06-19-3SimpleStatisticalMethodsforOutlierDetection","content":"\n\n\u003cimg src=\"/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_0.png\" /\u003e\n\n데이터 과학자의 일 중 중요한 부분은 데이터를 정제하고 전처리하는 것입니다. 이 과정 중 하나인 이상치 탐지와 제거는 매우 중요합니다. 대규모의 이상치, 급증, 그리고 나쁜 데이터는 정확한 기계 학습 모델을 학습하는 데 방해가 될 수 있기 때문에, 이상치를 적절하게 처리하는 것이 중요합니다.\n\n하지만 데이터 과학자들이 항상 이상치를 식별하기 위해 격리 숲 또는 국소 이상치 요소처럼 기계 학습 모델을 사용하는 것은 아닙니다. 제 데이터 과학 경력에서 배운 한 가지는 간단한 해결 방법이 효과적이면 그것을 사용해야 한다는 것입니다.\n\n이번에는 대부분의 시간에 잘 동작하는 이상치를 탐지하는 데 유용한 3가지 간단한 통계적 솔루션을 제공하고자 합니다. 또한 이를 Python에서 어떻게 수행하는지도 보여드릴 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. Z 점수\n\nZ 점수는 표준 점수로도 알려져 있으며, 특이값을 감지하는 데 사용되는 잘 알려진 방법 중 하나입니다. 기본적으로 어떤 데이터 포인트가 평균에서 몇 개의 표준 편차만큼 떨어져 있는지를 나타냅니다.\n\n어떤 데이터셋의 특정 데이터 포인트의 Z 점수는 다음과 같이 계산됩니다:\n\n![](/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_1.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어디서:\n\n- Z는 Z 점수 값입니다.\n- x는 데이터 포인트입니다.\n- μ는 데이터 집합의 평균입니다.\n- σ는 표준 편차입니다.\n\n따라서 Z 점수가 4인 경우 데이터 포인트가 평균보다 4 표준 편차 위에 있음을 의미합니다. Z 점수가 -4인 경우에는 평균보다 4 표준 편차 아래에 있습니다.\n\nZ 점수의 경우, 일반적으로 3 이상 또는 -3 미만의 값은 이상치로 간주됩니다. 그러나이 기준은 유연하며 프로그래머에 따라 조정할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같이 Python과 scipy.stats 패키지를 사용하여 데이터프레임 열의 각 값의 z 점수를 계산하는 간단한 방법이 있어요:\n\n```python\nfrom scipy import stats\n\ndf[\"z_score\"] = stats.zscore(df[\"column_of_interest\"])\n```\n\n데이터셋의 각 값에 대한 z 점수를 얻은 후에는 이상값을 걸러낼 수 있어요:\n\n```python\ndf_clean = df[(df[\"z_score\"] \u003c= 3) \u0026 (df[\"z_score\"] \u003e= -3)]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nz 점수의 단점 중 하나는 이상치 탐지 방법임에도 불구하고 이상치에 민감하다는 것입니다. 데이터 세트에 매우 큰 이상치가 있는 경우 평균을 왜곡할 수 있습니다 (평균은 이상치에 민감하기 때문입니다). 평균이 왜곡되면 더 작지만 여전히 관련 있는 이상치를 잡지 못할 수 있습니다.\n\n## 2. IQR\n\nIQR (사분위 범위)는 평균 대신 중앙값을 기준점으로 사용하기 때문에 z 점수보다 견고합니다.\n\n![이미지](/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 IQR 값을 구했으니, 다른 점들이 이상값인지 판별하는 기준점으로 사용될 것입니다. Q1 값보다 1.5 * IQR 이상 또는 Q3 값보다 1.5 * IQR 이하인 모든 점은 이상치로 간주됩니다.\n\n이 경우, 46.5(27 + 13 * 1.5)보다 큰 값 또는 -5.5(14 - 13 * 1.5)보다 작은 값은 이상치로 간주됩니다.\n\n파이썬에서 numpy의 percentile 및 scipy stats의 IQR 함수를 사용하여 이를 계산하는 방법은 다음과 같습니다:\n\n```python\nfrom scipy.stats import iqr\nimport numpy as np\n\n# 데이터의 IQR 구하기\niqr_data = iqr(df[\"column_of_interest\"])\n# 범위를 벗어나는 값을 얻기 위한 참조점 계산 (1.5 * IQR)\niqr_lim = 1.5 * iqr_data\n\n# 상위 (Q3 또는 75번째 백분위수)와 하위사분위 (Q1 또는 25번째 백분위수) 계산\nq1 = np.percentile(df[\"column_of_interest\"], 25)\nq3 = np.percentile(df[\"column_of_interest\"], 75)\n\n# 사분위수와 IQR*1.5를 사용하여 상한선과 하한선 결정\n상한선 = q3 + iqr_lim\n하한선 = q1 - iqr_lim\n\n# 상한선보다 작거나 하한선보다 큰 값은 이상치로 간주하고 제거\ndf_clean_iqr = df[(df[\"column_of_interest\"] \u003e= lower_limit) \n\u0026 (df[\"column_of_interest\"] \u003c= upper_limit)]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위에서 볼 수 있듯이 데이터 세트의 IQR을 계산하려면 z 점수보다 몇 가지 더 많은 단계/코드 줄이 필요합니다. 또한 각 데이터 포인트에 대한 가시적인 \"점수\"를 얻지 못하므로 얼마나 이상하게 큰지를 나타내지 않습니다. 여기서는 어떤 것이 범위를 벗어났는지 여부만을 알 수 있습니다.\n\n그러나 중앙값을 사용하기 때문에 평균보다 쉽게 왜곡되지 않아서 데이터 세트의 이상치에 덜 민감합니다.\n\n# 3. 수정된 z 점수\n\n수정된 z 점수는 z 점수와 IQR의 측면을 모두 고려하여 표준 z 점수의 더 견고한 버전을 만듭니다. 데이터 점이 얼마나 \"멀리 떨어져\" 있는지를 대략적으로 알려주는 점수를 제공하면서도 이상치에 민감하지 않습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nz 점수와 수정된 z 점수의 주요 차이점은 수정된 z 점수가 평균 대신 중앙값을 기준점으로 사용한다는 것입니다. 표준 편차가 평균과 직접적으로 관련되어 있기 때문에, 수정된 z 점수는 정확한 표준 편차를 측정하지 않습니다. 그러나 중위수 절대 편차(MAD)를 사용하여 표준 편차를 근사하려고 합니다.\n\n![image](/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_3.png)\n\n여기서,\n\n- 0.6745는 표준 편차의 중위수에 해당하는 값을 근사화하는 데 사용되는 상수입니다.\n- xi는 조사하는 데이터 포인트입니다.\n- x͂는 데이터셋의 중앙값입니다.\n- MAD는 데이터셋의 중위수 절대 편차입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n중앙값 절대 편차를 계산하려면 데이터 세트의 중앙값에서 각 데이터 포인트를 빼면 됩니다. 이 뺄셈의 절대값을 취하세요. 마지막으로, 이러한 절대 차이의 중앙값을 취하면 됩니다.\n\n일반적으로 수정된 z 점수에서는 점수가 ` 3.5 또는 `-3.5 인 값이 이상치로 간주됩니다.\n\n수정된 z 점수의 계산 방법과 Python에서의 실제 예제에 대한 더 자세한 정보가 필요하시면 수정된 z 점수에 관한 제 글을 참조해주세요:\n\nPython에서 수정된 z 점수를 구현하는 방법은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 이 함수는 값을 취하고 데이터 집합을 취하여 하나의 값을 위한 수정된 z 점수를 반환합니다.\ndef compute_mod_z_score(value,df):\n    # 데이터 집합의 MAD(흑백절대편차) 계산 (관심 있는 열)\n    med_abs_dev = (np.abs(df[\"column_of_interest\"] - \n                  df[\"column_of_interest\"].median())).median()\n    const = 0.6745\n    mod_z = (const * (value - df[\"column_of_interest\"].median()) \n            / med_abs_dev)\n    return mod_z\n\n# 위의 함수를 전체 열에 적용하여 수정된 Z 점수를 모든 데이터 점에 대해 얻습니다.\ndf[\"mod_zscore\"]=df[\"column_of_interest\"].apply(compute_mod_z_score,df=df)\n```\n\n수정된 Z 점수의 주요 단점은 덜 알려져 있으며 MAD와 같은 변수를 사용하기 때문에 설명하기가 조금 더 복잡하고 어려울 수 있다는 것입니다. 또한 저는 아는 한 Python 라이브러리 중에 수정된 Z 점수를 계산하는 것이 없습니다.\n\n# 결론\n\n보시다시피, 이상치 탐지의 각 통계적 방법마다 이점과 단점이 있습니다. 제가 일하는 곳에서는 이를 모두 사용했지만 다른 데이터 집합과 사용 사례에 대해 사용했습니다. 데이터를 탐색하여 문제에 접근하는 방법을 알아야 한다는 점의 중요성을 강조할 수 없습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n만약 데이터셋이 급격한 변동이 있는 경우에는 수정된 z 점수나 IQR이 가장 적합할 수 있습니다. 가장 간단하고 설명하기 쉬운 해결책을 찾고 있다면 z 점수 / 표준 점수를 선택하는 것이 좋습니다. \n\n언제나 여러분만의 테스트를 실행하고 다른 데이터 과학자들이나 결과에 혜택을 받을 수 있는 관련 이해당사자들과 상의하는 것이 중요합니다.\n\n# 읽어주셔서 감사합니다","ogImage":{"url":"/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_0.png"},"coverImage":"/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_0.png\"\u003e\n\u003cp\u003e데이터 과학자의 일 중 중요한 부분은 데이터를 정제하고 전처리하는 것입니다. 이 과정 중 하나인 이상치 탐지와 제거는 매우 중요합니다. 대규모의 이상치, 급증, 그리고 나쁜 데이터는 정확한 기계 학습 모델을 학습하는 데 방해가 될 수 있기 때문에, 이상치를 적절하게 처리하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e하지만 데이터 과학자들이 항상 이상치를 식별하기 위해 격리 숲 또는 국소 이상치 요소처럼 기계 학습 모델을 사용하는 것은 아닙니다. 제 데이터 과학 경력에서 배운 한 가지는 간단한 해결 방법이 효과적이면 그것을 사용해야 한다는 것입니다.\u003c/p\u003e\n\u003cp\u003e이번에는 대부분의 시간에 잘 동작하는 이상치를 탐지하는 데 유용한 3가지 간단한 통계적 솔루션을 제공하고자 합니다. 또한 이를 Python에서 어떻게 수행하는지도 보여드릴 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e1. Z 점수\u003c/h1\u003e\n\u003cp\u003eZ 점수는 표준 점수로도 알려져 있으며, 특이값을 감지하는 데 사용되는 잘 알려진 방법 중 하나입니다. 기본적으로 어떤 데이터 포인트가 평균에서 몇 개의 표준 편차만큼 떨어져 있는지를 나타냅니다.\u003c/p\u003e\n\u003cp\u003e어떤 데이터셋의 특정 데이터 포인트의 Z 점수는 다음과 같이 계산됩니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_1.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e어디서:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eZ는 Z 점수 값입니다.\u003c/li\u003e\n\u003cli\u003ex는 데이터 포인트입니다.\u003c/li\u003e\n\u003cli\u003eμ는 데이터 집합의 평균입니다.\u003c/li\u003e\n\u003cli\u003eσ는 표준 편차입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e따라서 Z 점수가 4인 경우 데이터 포인트가 평균보다 4 표준 편차 위에 있음을 의미합니다. Z 점수가 -4인 경우에는 평균보다 4 표준 편차 아래에 있습니다.\u003c/p\u003e\n\u003cp\u003eZ 점수의 경우, 일반적으로 3 이상 또는 -3 미만의 값은 이상치로 간주됩니다. 그러나이 기준은 유연하며 프로그래머에 따라 조정할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래와 같이 Python과 scipy.stats 패키지를 사용하여 데이터프레임 열의 각 값의 z 점수를 계산하는 간단한 방법이 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e scipy \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e stats\n\ndf[\u003cspan class=\"hljs-string\"\u003e\"z_score\"\u003c/span\u003e] = stats.zscore(df[\u003cspan class=\"hljs-string\"\u003e\"column_of_interest\"\u003c/span\u003e])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e데이터셋의 각 값에 대한 z 점수를 얻은 후에는 이상값을 걸러낼 수 있어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003edf_clean = df[(df[\u003cspan class=\"hljs-string\"\u003e\"z_score\"\u003c/span\u003e] \u0026#x3C;= \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e) \u0026#x26; (df[\u003cspan class=\"hljs-string\"\u003e\"z_score\"\u003c/span\u003e] \u003e= -\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003ez 점수의 단점 중 하나는 이상치 탐지 방법임에도 불구하고 이상치에 민감하다는 것입니다. 데이터 세트에 매우 큰 이상치가 있는 경우 평균을 왜곡할 수 있습니다 (평균은 이상치에 민감하기 때문입니다). 평균이 왜곡되면 더 작지만 여전히 관련 있는 이상치를 잡지 못할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e2. IQR\u003c/h2\u003e\n\u003cp\u003eIQR (사분위 범위)는 평균 대신 중앙값을 기준점으로 사용하기 때문에 z 점수보다 견고합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 IQR 값을 구했으니, 다른 점들이 이상값인지 판별하는 기준점으로 사용될 것입니다. Q1 값보다 1.5 * IQR 이상 또는 Q3 값보다 1.5 * IQR 이하인 모든 점은 이상치로 간주됩니다.\u003c/p\u003e\n\u003cp\u003e이 경우, 46.5(27 + 13 * 1.5)보다 큰 값 또는 -5.5(14 - 13 * 1.5)보다 작은 값은 이상치로 간주됩니다.\u003c/p\u003e\n\u003cp\u003e파이썬에서 numpy의 percentile 및 scipy stats의 IQR 함수를 사용하여 이를 계산하는 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e scipy.stats \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e iqr\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\n\u003cspan class=\"hljs-comment\"\u003e# 데이터의 IQR 구하기\u003c/span\u003e\niqr_data = iqr(df[\u003cspan class=\"hljs-string\"\u003e\"column_of_interest\"\u003c/span\u003e])\n\u003cspan class=\"hljs-comment\"\u003e# 범위를 벗어나는 값을 얻기 위한 참조점 계산 (1.5 * IQR)\u003c/span\u003e\niqr_lim = \u003cspan class=\"hljs-number\"\u003e1.5\u003c/span\u003e * iqr_data\n\n\u003cspan class=\"hljs-comment\"\u003e# 상위 (Q3 또는 75번째 백분위수)와 하위사분위 (Q1 또는 25번째 백분위수) 계산\u003c/span\u003e\nq1 = np.percentile(df[\u003cspan class=\"hljs-string\"\u003e\"column_of_interest\"\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e)\nq3 = np.percentile(df[\u003cspan class=\"hljs-string\"\u003e\"column_of_interest\"\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e# 사분위수와 IQR*1.5를 사용하여 상한선과 하한선 결정\u003c/span\u003e\n상한선 = q3 + iqr_lim\n하한선 = q1 - iqr_lim\n\n\u003cspan class=\"hljs-comment\"\u003e# 상한선보다 작거나 하한선보다 큰 값은 이상치로 간주하고 제거\u003c/span\u003e\ndf_clean_iqr = df[(df[\u003cspan class=\"hljs-string\"\u003e\"column_of_interest\"\u003c/span\u003e] \u003e= lower_limit) \n\u0026#x26; (df[\u003cspan class=\"hljs-string\"\u003e\"column_of_interest\"\u003c/span\u003e] \u0026#x3C;= upper_limit)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위에서 볼 수 있듯이 데이터 세트의 IQR을 계산하려면 z 점수보다 몇 가지 더 많은 단계/코드 줄이 필요합니다. 또한 각 데이터 포인트에 대한 가시적인 \"점수\"를 얻지 못하므로 얼마나 이상하게 큰지를 나타내지 않습니다. 여기서는 어떤 것이 범위를 벗어났는지 여부만을 알 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 중앙값을 사용하기 때문에 평균보다 쉽게 왜곡되지 않아서 데이터 세트의 이상치에 덜 민감합니다.\u003c/p\u003e\n\u003ch1\u003e3. 수정된 z 점수\u003c/h1\u003e\n\u003cp\u003e수정된 z 점수는 z 점수와 IQR의 측면을 모두 고려하여 표준 z 점수의 더 견고한 버전을 만듭니다. 데이터 점이 얼마나 \"멀리 떨어져\" 있는지를 대략적으로 알려주는 점수를 제공하면서도 이상치에 민감하지 않습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003ez 점수와 수정된 z 점수의 주요 차이점은 수정된 z 점수가 평균 대신 중앙값을 기준점으로 사용한다는 것입니다. 표준 편차가 평균과 직접적으로 관련되어 있기 때문에, 수정된 z 점수는 정확한 표준 편차를 측정하지 않습니다. 그러나 중위수 절대 편차(MAD)를 사용하여 표준 편차를 근사하려고 합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-3SimpleStatisticalMethodsforOutlierDetection_3.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e여기서,\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e0.6745는 표준 편차의 중위수에 해당하는 값을 근사화하는 데 사용되는 상수입니다.\u003c/li\u003e\n\u003cli\u003exi는 조사하는 데이터 포인트입니다.\u003c/li\u003e\n\u003cli\u003ex͂는 데이터셋의 중앙값입니다.\u003c/li\u003e\n\u003cli\u003eMAD는 데이터셋의 중위수 절대 편차입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e중앙값 절대 편차를 계산하려면 데이터 세트의 중앙값에서 각 데이터 포인트를 빼면 됩니다. 이 뺄셈의 절대값을 취하세요. 마지막으로, 이러한 절대 차이의 중앙값을 취하면 됩니다.\u003c/p\u003e\n\u003cp\u003e일반적으로 수정된 z 점수에서는 점수가 \u003ccode\u003e3.5 또는\u003c/code\u003e-3.5 인 값이 이상치로 간주됩니다.\u003c/p\u003e\n\u003cp\u003e수정된 z 점수의 계산 방법과 Python에서의 실제 예제에 대한 더 자세한 정보가 필요하시면 수정된 z 점수에 관한 제 글을 참조해주세요:\u003c/p\u003e\n\u003cp\u003ePython에서 수정된 z 점수를 구현하는 방법은 다음과 같습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 이 함수는 값을 취하고 데이터 집합을 취하여 하나의 값을 위한 수정된 z 점수를 반환합니다.\ndef \u003cspan class=\"hljs-title function_\"\u003ecompute_mod_z_score\u003c/span\u003e(value,df):\n    # 데이터 집합의 \u003cspan class=\"hljs-title function_\"\u003eMAD\u003c/span\u003e(흑백절대편차) 계산 (관심 있는 열)\n    med_abs_dev = (np.\u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(df[\u003cspan class=\"hljs-string\"\u003e\"column_of_interest\"\u003c/span\u003e] - \n                  df[\u003cspan class=\"hljs-string\"\u003e\"column_of_interest\"\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003emedian\u003c/span\u003e())).\u003cspan class=\"hljs-title function_\"\u003emedian\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0.6745\u003c/span\u003e\n    mod_z = (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e * (value - df[\u003cspan class=\"hljs-string\"\u003e\"column_of_interest\"\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003emedian\u003c/span\u003e()) \n            / med_abs_dev)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e mod_z\n\n# 위의 함수를 전체 열에 적용하여 수정된 Z 점수를 모든 데이터 점에 대해 얻습니다.\ndf[\u003cspan class=\"hljs-string\"\u003e\"mod_zscore\"\u003c/span\u003e]=df[\u003cspan class=\"hljs-string\"\u003e\"column_of_interest\"\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(compute_mod_z_score,df=df)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e수정된 Z 점수의 주요 단점은 덜 알려져 있으며 MAD와 같은 변수를 사용하기 때문에 설명하기가 조금 더 복잡하고 어려울 수 있다는 것입니다. 또한 저는 아는 한 Python 라이브러리 중에 수정된 Z 점수를 계산하는 것이 없습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e보시다시피, 이상치 탐지의 각 통계적 방법마다 이점과 단점이 있습니다. 제가 일하는 곳에서는 이를 모두 사용했지만 다른 데이터 집합과 사용 사례에 대해 사용했습니다. 데이터를 탐색하여 문제에 접근하는 방법을 알아야 한다는 점의 중요성을 강조할 수 없습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e만약 데이터셋이 급격한 변동이 있는 경우에는 수정된 z 점수나 IQR이 가장 적합할 수 있습니다. 가장 간단하고 설명하기 쉬운 해결책을 찾고 있다면 z 점수 / 표준 점수를 선택하는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003e언제나 여러분만의 테스트를 실행하고 다른 데이터 과학자들이나 결과에 혜택을 받을 수 있는 관련 이해당사자들과 상의하는 것이 중요합니다.\u003c/p\u003e\n\u003ch1\u003e읽어주셔서 감사합니다\u003c/h1\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-3SimpleStatisticalMethodsforOutlierDetection"},"buildId":"8coAiP0lmiEK5aH6nkQkj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>