<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>대형 언어 모델LLMs로 Next-Token 예측을 분류로 전환하는 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-23-TransformingNext-TokenPredictionintoClassificationwithLLMs" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="대형 언어 모델LLMs로 Next-Token 예측을 분류로 전환하는 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="대형 언어 모델LLMs로 Next-Token 예측을 분류로 전환하는 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-TransformingNext-TokenPredictionintoClassificationwithLLMs_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-23-TransformingNext-TokenPredictionintoClassificationwithLLMs" data-gatsby-head="true"/><meta name="twitter:title" content="대형 언어 모델LLMs로 Next-Token 예측을 분류로 전환하는 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-TransformingNext-TokenPredictionintoClassificationwithLLMs_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 19:36" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">대형 언어 모델LLMs로 Next-Token 예측을 분류로 전환하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="대형 언어 모델LLMs로 Next-Token 예측을 분류로 전환하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-TransformingNext-TokenPredictionintoClassificationwithLLMs&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-23-TransformingNext-TokenPredictionintoClassificationwithLLMs_0.png" alt="이미지"></p>
<p>대규모 언어 모델(Large Language Models, LLMs)은 방대한 양의 인터넷 데이터로 훈련되어 다양한 자연어 작업을 수행할 수 있습니다. 그 중 하나인 분류는 주제를 미리 정의된 레이블로 분류하는 지도 학습 작업입니다. 제로샷 및 퓨샷 분류는 인기 있는 기술로, LLMs가 훈련 데이터 없이 또는 몇 가지 예제로 분류 작업을 수행할 수 있습니다. 그러나 보다 정확도를 높이기 위해 가이드 미세 조정을 통해 LLMs의 성능을 향상시킬 수 있음이 입증되었습니다.</p>
<h1>가이드 미세 조정 LLMs</h1>
<p>가이드 미세 조정을 위한 일반적인 방법은 질문-답변 쌍으로 구성된 데이터셋을 작성하는 것입니다. 사전 훈련된 LLMs는 이러한 쌍을 사용하여 지도 학습 방식으로 추가로 미세 조정됩니다.</p>
<div class="content-ad"></div>
<p>당신은 지난 포스트에서 이 접근법을 확인할 수 있어요.</p>
<p>선택적으로, 데이터셋을 좋아하는 조합과 덜 선호하는 조합의 쌍으로 구성된 직접 선호도 최적화(DPO)를 사용하여 성능을 더 개선할 수 있어요. 상위 순위의 오픈소스 LLMs가 이러한 접근법 중 하나를 사용하여 훈련되는 것은 놀라운 일이 아니에요.</p>
<h1>LLMs는 딥 뉴럴 네트워크입니다</h1>
<p>직관적으로, 이러한 방법은 LLMs가 토큰을 기반으로 하는 아키텍처를 사용한다는 사실을 활용해요. 지시된 데이터와 선호도 데이터셋 모두에서 텍스트 쌍이 토큰으로 변환됩니다. 교차 엔트로피 손실과 디코더만을 사용하는 오토레그레시브 속성을 이용하여, LLMs의 가중치가 업데이트되는데, 레이블 토큰은 입력 토큰으로부터 복사되지만 하나씩 밀려서 사용됩니다.</p>
<div class="content-ad"></div>
<p>주어진 것을 감안하면 우리는 어휘를 분류 라벨로 교체할 수 있습니다! 다음 토큰을 어휘에서 예측하는 대신, 앞선 문맥 토큰에서 분류 작업의 범주를 예측하는 데 관심이 있습니다. 이것은 일반적으로 lm_head로 구현되는 LLMs의 헤드를 변경함으로써 가능합니다. 텍스트 생성에서, lm_head는 (임베딩 차원, 어휘 크기)의 모양을 가지고 있습니다. 분류를 위해 우리는 이것을 (임베딩 차원, 분류 수)로 수정합니다.</p>
<h1>분류 작업을 위해 LLMs 학습하기</h1>
<h2>모델 및 토크나이저 불러오기</h2>
<p>이 접근 방식이 작동하는지 확인하기 위한 실험을 수행해 봅시다. 먼저, HuggingFace에서 사전 훈련된 LLM 및 해당 토크나이저를 사용하여 시작하겠습니다. 본 연구에서는 경량화된 38억 개의 파라미터 모델 microsoft/Phi-3-mini-4k-instruct를 선택했습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer

model_name = <span class="hljs-string">"microsoft/Phi-3-mini-4k-instruct"</span>
device_map = <span class="hljs-string">"auto"</span>
trust_remote_code = <span class="hljs-literal">True</span>

model = AutoModelForCausalLM.from_pretrained(
model_name, device_map=device_map, trust_remote_code=trust_remote_code
)
tokenizer = AutoTokenizer.from_pretrained(model_name)
tokenizer.padding_side = <span class="hljs-string">"right"</span>
tokenizer.pad_token = tokenizer.eos_token
tokenizer.add_eos_token = <span class="hljs-literal">True</span>
</code></pre>
<p>우리의 분류 실험을 간단히 하기 위해 이진 분류 작업을 선택할 것입니다. 나중에 여러 클래스로 확장할 수 있음을 알고 있습니다. 이진 분류에서 클래스 수는 두 개이므로 torch.nn.Linear(hidden_size, 2)입니다. to("cuda:<code>number</code>") 함수는 이 레이어가 할당된 GPU 기기를 지정합니다. 이 레이어가 model_name = "auto"을 사용하여 초기로드된 모델이 있는 동일한 기기에 할당되었는지 확인해주세요.</p>
<h2>Modify LLMs Head</h2>
<pre><code class="hljs language-python"><span class="hljs-comment"># 모델 수정 및 세밀 조정</span>
hidden_size = <span class="hljs-number">3072</span>
model.lm_head = torch.nn.Linear(hidden_size, <span class="hljs-number">2</span>).to(<span class="hljs-string">"cuda:3"</span>)
</code></pre>
<div class="content-ad"></div>
<p>또 다른 흥미로운 실험은 fe-fine-tuning을 위해 필요한 레이어를 결정하는 것입니다. 이 게시물에서는 모델이 모든 다른 레이어에서 토큰의 문맥적 의미를 학습했다는 가정에 기반하여, 마지막 블록의 마지막 정규화 레이어에 초점을 맞출 것입니다. 이 레이어는 lm_head 이전의 끝에서 두 번째 레이어입니다.</p>
<p>먼저, 모든 레이어의 Weight를 'param.requires_grad = False'로 지정하여 동결시킵니다. 그리고 나서 마지막 블록의 마지막 정규화 레이어를 찾아 'param.requires_grad = True'로 가중치를 조정 가능하도록 변경합니다. HuggingFace의 모델 클래스에서는 아래 코드 스니펫에서 보여주는 대로 dot 연산을 사용하여 어떤 레이어로든 이동할 수 있습니다.</p>
<pre><code class="hljs language-js"># 마지막 블록과 마지막 정규화 레이어만 fine-tune
<span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.<span class="hljs-title function_">parameters</span>():
    param.<span class="hljs-property">requires_grad</span> = <span class="hljs-title class_">False</span>

# 마지막 정규화 레이어만 fine-tune
last_block = model.<span class="hljs-property">model</span>.<span class="hljs-property">layers</span>[-<span class="hljs-number">1</span>].<span class="hljs-title function_">to</span>(<span class="hljs-string">"cuda:3"</span>)
final_norm = model.<span class="hljs-property">model</span>.<span class="hljs-property">norm</span>.<span class="hljs-title function_">to</span>(<span class="hljs-string">"cuda:3"</span>)

<span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> final_norm.<span class="hljs-title function_">parameters</span>():
    param.<span class="hljs-property">requires_grad</span> = <span class="hljs-title class_">True</span>
</code></pre>
<h2>Cross Entropy Loss 정의</h2>
<div class="content-ad"></div>
<p>이전 게시물에서 lm_head의 가장 중요한 로짓이 문장의 마지막 토큰과 관련이 있다고 설명했습니다. 이는 self-attention 메커니즘에서 기인하는데, 마지막 토큰은 이전 모든 문맥 토큰들로부터의 주의 점수를 가지고 있습니다. 따라서 우리는 logits[:, -1, :]를 사용합니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> torch

<span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_loss_batch</span>(<span class="hljs-params">input_batch, target_batch, model</span>):
    input_batch, target_batch = input_batch.to(<span class="hljs-string">"cuda"</span>), target_batch.to(<span class="hljs-string">"cuda"</span>)
    logits = model(input_batch).logits[:, -<span class="hljs-number">1</span>, :]  <span class="hljs-comment"># 마지막 출력 토큰의 로짓</span>
    loss = torch.nn.functional.cross_entropy(logits, target_batch).to(<span class="hljs-string">"cuda"</span>)
    <span class="hljs-keyword">return</span> loss
</code></pre>
<h2>데이터셋 준비</h2>
<p>데이터셋은 텍스트와 레이블 두 개의 리스트로 구성되어 있습니다. 먼저, 토크나이저를 사용하여 텍스트 문자열을 토큰화된 ID로 변환합니다. 토크나이저는 정의된 최대 길이보다 긴 토큰을 자르거나 최대 길이보다 짧은 경우 패딩합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">ecoding = <span class="hljs-title function_">tokenizer</span>(
            text,
            add_special_tokens=<span class="hljs-title class_">True</span>,
            max_length=self.<span class="hljs-property">max_length</span>,
            padding=<span class="hljs-string">'max_length'</span>,
            truncation=<span class="hljs-title class_">True</span>,
            return_tensors=<span class="hljs-string">'pt'</span>
)
</code></pre>
<p>그 다음으로, torch에서 DataLoader 객체를 사용하여 데이터를 모델 튜닝을 위해 반복적으로 공급합니다. BinaryClassification Dataset 객체는 torch의 Dataset 객체를 상속하며, 이 데이터셋을 DataLoader 객체로 로드합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryClassificationDataset</span>(<span class="hljs-title class_">Dataset</span>):
      pass

dataset = <span class="hljs-title class_">BinaryClassificationDataset</span>(texts, labels, tokenizer, max_length)

# <span class="hljs-title class_">DataLoader</span>
dataloader = <span class="hljs-title class_">DataLoader</span>(dataset, batch_size=<span class="hljs-number">2</span>, shuffle=<span class="hljs-title class_">True</span>)
</code></pre>
<p>1단계와 2단계를 합쳐서, 이것이 완전한 구현입니다. 메인 함수에 예제를 제공하여 BinaryClassificationDataset 객체를 인스턴스화하고 DataLoader 객체를 만들어 데이터를 생성하는 방법을 보여줍니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset, DataLoader
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryClassificationDataset</span>(<span class="hljs-title class_ inherited__">Dataset</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, texts, labels, tokenizer, max_length</span>):
        self.texts = texts
        self.labels = labels
        self.tokenizer = tokenizer
        self.max_length = max_length

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.texts)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):
        text = self.texts[idx]
        label = self.labels[idx]

        encoding = self.tokenizer(
            text,
            add_special_tokens=<span class="hljs-literal">True</span>,
            max_length=self.max_length,
            padding=<span class="hljs-string">'max_length'</span>,
            truncation=<span class="hljs-literal">True</span>,
            return_tensors=<span class="hljs-string">'pt'</span>
        )

        input_ids = encoding[<span class="hljs-string">'input_ids'</span>].squeeze(<span class="hljs-number">0</span>)  <span class="hljs-comment"># Remove batch dimension</span>
        attention_mask = encoding[<span class="hljs-string">'attention_mask'</span>].squeeze(<span class="hljs-number">0</span>)  <span class="hljs-comment"># Remove batch dimension</span>

        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">'input_ids'</span>: input_ids.long(),
            <span class="hljs-string">'attention_mask'</span>: attention_mask.long(),
            <span class="hljs-string">'labels'</span>: torch.tensor(label, dtype=torch.long)
        }

<span class="hljs-comment"># Example usage</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-comment"># Sample data</span>
    texts = [<span class="hljs-string">"Hello, this is a sample sentence."</span>, <span class="hljs-string">"Another sample text for classification."</span>]
    labels = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]

    <span class="hljs-comment"># Load tokenizer</span>
    tokenizer = AutoTokenizer.from_pretrained(model_name)
    
    <span class="hljs-comment"># Define dataset</span>
    max_length = <span class="hljs-number">128</span>
    dataset = BinaryClassificationDataset(texts, labels, tokenizer, max_length)

    <span class="hljs-comment"># DataLoader</span>
    dataloader = DataLoader(dataset, batch_size=<span class="hljs-number">2</span>, shuffle=<span class="hljs-literal">True</span>)

    <span class="hljs-comment"># Iterate through the dataloader</span>
    <span class="hljs-keyword">for</span> batch <span class="hljs-keyword">in</span> dataloader:
        input_ids = batch[<span class="hljs-string">'input_ids'</span>]
        attention_mask = batch[<span class="hljs-string">'attention_mask'</span>]
        labels = batch[<span class="hljs-string">'labels'</span>]

        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Input IDs:"</span>, input_ids)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Attention Mask:"</span>, attention_mask)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Labels:"</span>, labels)
      
</code></pre>
<h2>모델 훈련</h2>
<p>손실 함수를 정의하고 데이터셋을 준비한 후, 모델 훈련을 시작할 수 있습니다. calculate_loss_loader 함수는 losses를 0으로 초기화합니다. 지정된 배치 수(num_batches)를 지정하면, calculate_loss_batch 함수를 사용하여 각 배치의 손실을 계산합니다. DataLoader 객체를 사용하여 calculate_loss_batch 함수에 배치 데이터를 반복적으로 제공하고, 각 반복에 대해 손실을 누적합니다. 재현성을 위해 torch.manual_seed(1234)를 사용합니다. 이 실험에서 0.68의 손실을 달성했습니다.</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_loss_loader</span>(<span class="hljs-params">data_loader, model, num_batches=<span class="hljs-literal">None</span></span>):
    losses = <span class="hljs-number">0.</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(data_loader) == <span class="hljs-number">0</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Please provide dataset, data loader is empty."</span>
    <span class="hljs-keyword">elif</span> num_batches <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        num_batches = <span class="hljs-built_in">len</span>(data_loader)
    <span class="hljs-keyword">else</span>:
        num_batches = <span class="hljs-built_in">min</span>(num_batches, <span class="hljs-built_in">len</span>(data_loader))
    <span class="hljs-keyword">for</span> index, batch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_loader):
        <span class="hljs-keyword">if</span> index &#x3C; num_batches:
            loss = calculate_loss_batch(
              batch[<span class="hljs-string">"input_ids"</span>], batch[<span class="hljs-string">"labels"</span>], model
            )
            losses += loss.item()
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">return</span> total_loss / num_batches


torch.manual_seed(<span class="hljs-number">1234</span>) <span class="hljs-comment"># 재현성을 위해</span>
<span class="hljs-keyword">with</span> torch.no_grad():
    train_loss = calculate_loss_loader(dataloader, model, num_batches=<span class="hljs-number">2</span>)
</code></pre>
<div class="content-ad"></div>
<h1>트레이드오프</h1>
<p>다음 토큰 예측에서 트랜스포머를 처음 원리를 통해 분류 예측으로 활용할 수 있다는 것은 흥미롭습니다. 미리 훈련된 트랜스포머 모델은 언어 패턴의 풍부한 표현을 포착합니다. 그러나 가벼운 모델이지만 38 억 개의 매개변수를 가지고 있습니다. 독자들은 정확성과 교육 그리고 추론 처리량(초당 생성된 토큰 수) 사이의 트레이드오프를 인식해야 합니다. 저는 기준선으로 더 작은 모델을 시작하는 것을 제안합니다. 예를 들어, 6700만 개의 매개변수를 가진 distilbert-base-uncased 모델을 사용할 수 있습니다. 또는 XGBoost와 같은 더 전통적인 머신러닝 모델을 시도할 수도 있습니다.</p>
<h1>결론</h1>
<p>본 블로그 포스트에서는 처음 원리를 사용하여 다음 토큰 예측 문제를 분류 레이블 예측으로 변환하는 방법을 보여드렸습니다. 이 데모를 통해 LLM의 복잡한 구조를 해체하고 도메인별 문제에 동일한 개념을 적용하는 지식을 습득할 수 있기를 희망합니다. 전체 분류 작업에 대해 트랜스포머가 최적화된 솔루션이 아닐 수 있으며, 다른 더 작은 모델과 데이터를 학습하고 평가해야 함을 상기해야 합니다. 읽어 주셔서 감사합니다. 행복한 학습 되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"대형 언어 모델LLMs로 Next-Token 예측을 분류로 전환하는 방법","description":"","date":"2024-06-23 19:36","slug":"2024-06-23-TransformingNext-TokenPredictionintoClassificationwithLLMs","content":"\n\n![이미지](/assets/img/2024-06-23-TransformingNext-TokenPredictionintoClassificationwithLLMs_0.png)\n\n대규모 언어 모델(Large Language Models, LLMs)은 방대한 양의 인터넷 데이터로 훈련되어 다양한 자연어 작업을 수행할 수 있습니다. 그 중 하나인 분류는 주제를 미리 정의된 레이블로 분류하는 지도 학습 작업입니다. 제로샷 및 퓨샷 분류는 인기 있는 기술로, LLMs가 훈련 데이터 없이 또는 몇 가지 예제로 분류 작업을 수행할 수 있습니다. 그러나 보다 정확도를 높이기 위해 가이드 미세 조정을 통해 LLMs의 성능을 향상시킬 수 있음이 입증되었습니다.\n\n# 가이드 미세 조정 LLMs\n\n가이드 미세 조정을 위한 일반적인 방법은 질문-답변 쌍으로 구성된 데이터셋을 작성하는 것입니다. 사전 훈련된 LLMs는 이러한 쌍을 사용하여 지도 학습 방식으로 추가로 미세 조정됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n당신은 지난 포스트에서 이 접근법을 확인할 수 있어요.\n\n선택적으로, 데이터셋을 좋아하는 조합과 덜 선호하는 조합의 쌍으로 구성된 직접 선호도 최적화(DPO)를 사용하여 성능을 더 개선할 수 있어요. 상위 순위의 오픈소스 LLMs가 이러한 접근법 중 하나를 사용하여 훈련되는 것은 놀라운 일이 아니에요.\n\n# LLMs는 딥 뉴럴 네트워크입니다\n\n직관적으로, 이러한 방법은 LLMs가 토큰을 기반으로 하는 아키텍처를 사용한다는 사실을 활용해요. 지시된 데이터와 선호도 데이터셋 모두에서 텍스트 쌍이 토큰으로 변환됩니다. 교차 엔트로피 손실과 디코더만을 사용하는 오토레그레시브 속성을 이용하여, LLMs의 가중치가 업데이트되는데, 레이블 토큰은 입력 토큰으로부터 복사되지만 하나씩 밀려서 사용됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주어진 것을 감안하면 우리는 어휘를 분류 라벨로 교체할 수 있습니다! 다음 토큰을 어휘에서 예측하는 대신, 앞선 문맥 토큰에서 분류 작업의 범주를 예측하는 데 관심이 있습니다. 이것은 일반적으로 lm_head로 구현되는 LLMs의 헤드를 변경함으로써 가능합니다. 텍스트 생성에서, lm_head는 (임베딩 차원, 어휘 크기)의 모양을 가지고 있습니다. 분류를 위해 우리는 이것을 (임베딩 차원, 분류 수)로 수정합니다.\n\n# 분류 작업을 위해 LLMs 학습하기\n\n## 모델 및 토크나이저 불러오기\n\n이 접근 방식이 작동하는지 확인하기 위한 실험을 수행해 봅시다. 먼저, HuggingFace에서 사전 훈련된 LLM 및 해당 토크나이저를 사용하여 시작하겠습니다. 본 연구에서는 경량화된 38억 개의 파라미터 모델 microsoft/Phi-3-mini-4k-instruct를 선택했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nmodel_name = \"microsoft/Phi-3-mini-4k-instruct\"\ndevice_map = \"auto\"\ntrust_remote_code = True\n\nmodel = AutoModelForCausalLM.from_pretrained(\nmodel_name, device_map=device_map, trust_remote_code=trust_remote_code\n)\ntokenizer = AutoTokenizer.from_pretrained(model_name)\ntokenizer.padding_side = \"right\"\ntokenizer.pad_token = tokenizer.eos_token\ntokenizer.add_eos_token = True\n```\n\n우리의 분류 실험을 간단히 하기 위해 이진 분류 작업을 선택할 것입니다. 나중에 여러 클래스로 확장할 수 있음을 알고 있습니다. 이진 분류에서 클래스 수는 두 개이므로 torch.nn.Linear(hidden_size, 2)입니다. to(\"cuda:`number`\") 함수는 이 레이어가 할당된 GPU 기기를 지정합니다. 이 레이어가 model_name = \"auto\"을 사용하여 초기로드된 모델이 있는 동일한 기기에 할당되었는지 확인해주세요.\n\n## Modify LLMs Head\n\n```python\n# 모델 수정 및 세밀 조정\nhidden_size = 3072\nmodel.lm_head = torch.nn.Linear(hidden_size, 2).to(\"cuda:3\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또 다른 흥미로운 실험은 fe-fine-tuning을 위해 필요한 레이어를 결정하는 것입니다. 이 게시물에서는 모델이 모든 다른 레이어에서 토큰의 문맥적 의미를 학습했다는 가정에 기반하여, 마지막 블록의 마지막 정규화 레이어에 초점을 맞출 것입니다. 이 레이어는 lm_head 이전의 끝에서 두 번째 레이어입니다.\n\n먼저, 모든 레이어의 Weight를 'param.requires_grad = False'로 지정하여 동결시킵니다. 그리고 나서 마지막 블록의 마지막 정규화 레이어를 찾아 'param.requires_grad = True'로 가중치를 조정 가능하도록 변경합니다. HuggingFace의 모델 클래스에서는 아래 코드 스니펫에서 보여주는 대로 dot 연산을 사용하여 어떤 레이어로든 이동할 수 있습니다.\n\n```js\n# 마지막 블록과 마지막 정규화 레이어만 fine-tune\nfor param in model.parameters():\n    param.requires_grad = False\n\n# 마지막 정규화 레이어만 fine-tune\nlast_block = model.model.layers[-1].to(\"cuda:3\")\nfinal_norm = model.model.norm.to(\"cuda:3\")\n\nfor param in final_norm.parameters():\n    param.requires_grad = True\n```\n\n## Cross Entropy Loss 정의\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 게시물에서 lm_head의 가장 중요한 로짓이 문장의 마지막 토큰과 관련이 있다고 설명했습니다. 이는 self-attention 메커니즘에서 기인하는데, 마지막 토큰은 이전 모든 문맥 토큰들로부터의 주의 점수를 가지고 있습니다. 따라서 우리는 logits[:, -1, :]를 사용합니다.\n\n```python\nimport torch\n\ndef calculate_loss_batch(input_batch, target_batch, model):\n    input_batch, target_batch = input_batch.to(\"cuda\"), target_batch.to(\"cuda\")\n    logits = model(input_batch).logits[:, -1, :]  # 마지막 출력 토큰의 로짓\n    loss = torch.nn.functional.cross_entropy(logits, target_batch).to(\"cuda\")\n    return loss\n```\n\n## 데이터셋 준비\n\n데이터셋은 텍스트와 레이블 두 개의 리스트로 구성되어 있습니다. 먼저, 토크나이저를 사용하여 텍스트 문자열을 토큰화된 ID로 변환합니다. 토크나이저는 정의된 최대 길이보다 긴 토큰을 자르거나 최대 길이보다 짧은 경우 패딩합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\necoding = tokenizer(\n            text,\n            add_special_tokens=True,\n            max_length=self.max_length,\n            padding='max_length',\n            truncation=True,\n            return_tensors='pt'\n)\n```\n\n그 다음으로, torch에서 DataLoader 객체를 사용하여 데이터를 모델 튜닝을 위해 반복적으로 공급합니다. BinaryClassification Dataset 객체는 torch의 Dataset 객체를 상속하며, 이 데이터셋을 DataLoader 객체로 로드합니다.\n\n```js\nclass BinaryClassificationDataset(Dataset):\n      pass\n\ndataset = BinaryClassificationDataset(texts, labels, tokenizer, max_length)\n\n# DataLoader\ndataloader = DataLoader(dataset, batch_size=2, shuffle=True)\n```\n\n1단계와 2단계를 합쳐서, 이것이 완전한 구현입니다. 메인 함수에 예제를 제공하여 BinaryClassificationDataset 객체를 인스턴스화하고 DataLoader 객체를 만들어 데이터를 생성하는 방법을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nimport torch\nfrom torch.utils.data import Dataset, DataLoader\nfrom transformers import AutoTokenizer\n\nclass BinaryClassificationDataset(Dataset):\n    def __init__(self, texts, labels, tokenizer, max_length):\n        self.texts = texts\n        self.labels = labels\n        self.tokenizer = tokenizer\n        self.max_length = max_length\n\n    def __len__(self):\n        return len(self.texts)\n\n    def __getitem__(self, idx):\n        text = self.texts[idx]\n        label = self.labels[idx]\n\n        encoding = self.tokenizer(\n            text,\n            add_special_tokens=True,\n            max_length=self.max_length,\n            padding='max_length',\n            truncation=True,\n            return_tensors='pt'\n        )\n\n        input_ids = encoding['input_ids'].squeeze(0)  # Remove batch dimension\n        attention_mask = encoding['attention_mask'].squeeze(0)  # Remove batch dimension\n\n        return {\n            'input_ids': input_ids.long(),\n            'attention_mask': attention_mask.long(),\n            'labels': torch.tensor(label, dtype=torch.long)\n        }\n\n# Example usage\nif __name__ == \"__main__\":\n    # Sample data\n    texts = [\"Hello, this is a sample sentence.\", \"Another sample text for classification.\"]\n    labels = [0, 1]\n\n    # Load tokenizer\n    tokenizer = AutoTokenizer.from_pretrained(model_name)\n    \n    # Define dataset\n    max_length = 128\n    dataset = BinaryClassificationDataset(texts, labels, tokenizer, max_length)\n\n    # DataLoader\n    dataloader = DataLoader(dataset, batch_size=2, shuffle=True)\n\n    # Iterate through the dataloader\n    for batch in dataloader:\n        input_ids = batch['input_ids']\n        attention_mask = batch['attention_mask']\n        labels = batch['labels']\n\n        print(\"Input IDs:\", input_ids)\n        print(\"Attention Mask:\", attention_mask)\n        print(\"Labels:\", labels)\n      \n```\n\n## 모델 훈련\n\n손실 함수를 정의하고 데이터셋을 준비한 후, 모델 훈련을 시작할 수 있습니다. calculate_loss_loader 함수는 losses를 0으로 초기화합니다. 지정된 배치 수(num_batches)를 지정하면, calculate_loss_batch 함수를 사용하여 각 배치의 손실을 계산합니다. DataLoader 객체를 사용하여 calculate_loss_batch 함수에 배치 데이터를 반복적으로 제공하고, 각 반복에 대해 손실을 누적합니다. 재현성을 위해 torch.manual_seed(1234)를 사용합니다. 이 실험에서 0.68의 손실을 달성했습니다.\n\n```python\ndef calculate_loss_loader(data_loader, model, num_batches=None):\n    losses = 0.\n    if len(data_loader) == 0:\n        return \"Please provide dataset, data loader is empty.\"\n    elif num_batches is None:\n        num_batches = len(data_loader)\n    else:\n        num_batches = min(num_batches, len(data_loader))\n    for index, batch in enumerate(data_loader):\n        if index \u003c num_batches:\n            loss = calculate_loss_batch(\n              batch[\"input_ids\"], batch[\"labels\"], model\n            )\n            losses += loss.item()\n        else:\n            break\n    return total_loss / num_batches\n\n\ntorch.manual_seed(1234) # 재현성을 위해\nwith torch.no_grad():\n    train_loss = calculate_loss_loader(dataloader, model, num_batches=2)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 트레이드오프\n\n다음 토큰 예측에서 트랜스포머를 처음 원리를 통해 분류 예측으로 활용할 수 있다는 것은 흥미롭습니다. 미리 훈련된 트랜스포머 모델은 언어 패턴의 풍부한 표현을 포착합니다. 그러나 가벼운 모델이지만 38 억 개의 매개변수를 가지고 있습니다. 독자들은 정확성과 교육 그리고 추론 처리량(초당 생성된 토큰 수) 사이의 트레이드오프를 인식해야 합니다. 저는 기준선으로 더 작은 모델을 시작하는 것을 제안합니다. 예를 들어, 6700만 개의 매개변수를 가진 distilbert-base-uncased 모델을 사용할 수 있습니다. 또는 XGBoost와 같은 더 전통적인 머신러닝 모델을 시도할 수도 있습니다.\n\n# 결론\n\n본 블로그 포스트에서는 처음 원리를 사용하여 다음 토큰 예측 문제를 분류 레이블 예측으로 변환하는 방법을 보여드렸습니다. 이 데모를 통해 LLM의 복잡한 구조를 해체하고 도메인별 문제에 동일한 개념을 적용하는 지식을 습득할 수 있기를 희망합니다. 전체 분류 작업에 대해 트랜스포머가 최적화된 솔루션이 아닐 수 있으며, 다른 더 작은 모델과 데이터를 학습하고 평가해야 함을 상기해야 합니다. 읽어 주셔서 감사합니다. 행복한 학습 되세요!","ogImage":{"url":"/assets/img/2024-06-23-TransformingNext-TokenPredictionintoClassificationwithLLMs_0.png"},"coverImage":"/assets/img/2024-06-23-TransformingNext-TokenPredictionintoClassificationwithLLMs_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-TransformingNext-TokenPredictionintoClassificationwithLLMs_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e대규모 언어 모델(Large Language Models, LLMs)은 방대한 양의 인터넷 데이터로 훈련되어 다양한 자연어 작업을 수행할 수 있습니다. 그 중 하나인 분류는 주제를 미리 정의된 레이블로 분류하는 지도 학습 작업입니다. 제로샷 및 퓨샷 분류는 인기 있는 기술로, LLMs가 훈련 데이터 없이 또는 몇 가지 예제로 분류 작업을 수행할 수 있습니다. 그러나 보다 정확도를 높이기 위해 가이드 미세 조정을 통해 LLMs의 성능을 향상시킬 수 있음이 입증되었습니다.\u003c/p\u003e\n\u003ch1\u003e가이드 미세 조정 LLMs\u003c/h1\u003e\n\u003cp\u003e가이드 미세 조정을 위한 일반적인 방법은 질문-답변 쌍으로 구성된 데이터셋을 작성하는 것입니다. 사전 훈련된 LLMs는 이러한 쌍을 사용하여 지도 학습 방식으로 추가로 미세 조정됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e당신은 지난 포스트에서 이 접근법을 확인할 수 있어요.\u003c/p\u003e\n\u003cp\u003e선택적으로, 데이터셋을 좋아하는 조합과 덜 선호하는 조합의 쌍으로 구성된 직접 선호도 최적화(DPO)를 사용하여 성능을 더 개선할 수 있어요. 상위 순위의 오픈소스 LLMs가 이러한 접근법 중 하나를 사용하여 훈련되는 것은 놀라운 일이 아니에요.\u003c/p\u003e\n\u003ch1\u003eLLMs는 딥 뉴럴 네트워크입니다\u003c/h1\u003e\n\u003cp\u003e직관적으로, 이러한 방법은 LLMs가 토큰을 기반으로 하는 아키텍처를 사용한다는 사실을 활용해요. 지시된 데이터와 선호도 데이터셋 모두에서 텍스트 쌍이 토큰으로 변환됩니다. 교차 엔트로피 손실과 디코더만을 사용하는 오토레그레시브 속성을 이용하여, LLMs의 가중치가 업데이트되는데, 레이블 토큰은 입력 토큰으로부터 복사되지만 하나씩 밀려서 사용됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e주어진 것을 감안하면 우리는 어휘를 분류 라벨로 교체할 수 있습니다! 다음 토큰을 어휘에서 예측하는 대신, 앞선 문맥 토큰에서 분류 작업의 범주를 예측하는 데 관심이 있습니다. 이것은 일반적으로 lm_head로 구현되는 LLMs의 헤드를 변경함으로써 가능합니다. 텍스트 생성에서, lm_head는 (임베딩 차원, 어휘 크기)의 모양을 가지고 있습니다. 분류를 위해 우리는 이것을 (임베딩 차원, 분류 수)로 수정합니다.\u003c/p\u003e\n\u003ch1\u003e분류 작업을 위해 LLMs 학습하기\u003c/h1\u003e\n\u003ch2\u003e모델 및 토크나이저 불러오기\u003c/h2\u003e\n\u003cp\u003e이 접근 방식이 작동하는지 확인하기 위한 실험을 수행해 봅시다. 먼저, HuggingFace에서 사전 훈련된 LLM 및 해당 토크나이저를 사용하여 시작하겠습니다. 본 연구에서는 경량화된 38억 개의 파라미터 모델 microsoft/Phi-3-mini-4k-instruct를 선택했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e transformers \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e AutoModelForCausalLM, AutoTokenizer\n\nmodel_name = \u003cspan class=\"hljs-string\"\u003e\"microsoft/Phi-3-mini-4k-instruct\"\u003c/span\u003e\ndevice_map = \u003cspan class=\"hljs-string\"\u003e\"auto\"\u003c/span\u003e\ntrust_remote_code = \u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e\n\nmodel = AutoModelForCausalLM.from_pretrained(\nmodel_name, device_map=device_map, trust_remote_code=trust_remote_code\n)\ntokenizer = AutoTokenizer.from_pretrained(model_name)\ntokenizer.padding_side = \u003cspan class=\"hljs-string\"\u003e\"right\"\u003c/span\u003e\ntokenizer.pad_token = tokenizer.eos_token\ntokenizer.add_eos_token = \u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리의 분류 실험을 간단히 하기 위해 이진 분류 작업을 선택할 것입니다. 나중에 여러 클래스로 확장할 수 있음을 알고 있습니다. 이진 분류에서 클래스 수는 두 개이므로 torch.nn.Linear(hidden_size, 2)입니다. to(\"cuda:\u003ccode\u003enumber\u003c/code\u003e\") 함수는 이 레이어가 할당된 GPU 기기를 지정합니다. 이 레이어가 model_name = \"auto\"을 사용하여 초기로드된 모델이 있는 동일한 기기에 할당되었는지 확인해주세요.\u003c/p\u003e\n\u003ch2\u003eModify LLMs Head\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 모델 수정 및 세밀 조정\u003c/span\u003e\nhidden_size = \u003cspan class=\"hljs-number\"\u003e3072\u003c/span\u003e\nmodel.lm_head = torch.nn.Linear(hidden_size, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e).to(\u003cspan class=\"hljs-string\"\u003e\"cuda:3\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e또 다른 흥미로운 실험은 fe-fine-tuning을 위해 필요한 레이어를 결정하는 것입니다. 이 게시물에서는 모델이 모든 다른 레이어에서 토큰의 문맥적 의미를 학습했다는 가정에 기반하여, 마지막 블록의 마지막 정규화 레이어에 초점을 맞출 것입니다. 이 레이어는 lm_head 이전의 끝에서 두 번째 레이어입니다.\u003c/p\u003e\n\u003cp\u003e먼저, 모든 레이어의 Weight를 'param.requires_grad = False'로 지정하여 동결시킵니다. 그리고 나서 마지막 블록의 마지막 정규화 레이어를 찾아 'param.requires_grad = True'로 가중치를 조정 가능하도록 변경합니다. HuggingFace의 모델 클래스에서는 아래 코드 스니펫에서 보여주는 대로 dot 연산을 사용하여 어떤 레이어로든 이동할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 마지막 블록과 마지막 정규화 레이어만 fine-tune\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e param \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e model.\u003cspan class=\"hljs-title function_\"\u003eparameters\u003c/span\u003e():\n    param.\u003cspan class=\"hljs-property\"\u003erequires_grad\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n\n# 마지막 정규화 레이어만 fine-tune\nlast_block = model.\u003cspan class=\"hljs-property\"\u003emodel\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elayers\u003c/span\u003e[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eto\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"cuda:3\"\u003c/span\u003e)\nfinal_norm = model.\u003cspan class=\"hljs-property\"\u003emodel\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enorm\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eto\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"cuda:3\"\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e param \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e final_norm.\u003cspan class=\"hljs-title function_\"\u003eparameters\u003c/span\u003e():\n    param.\u003cspan class=\"hljs-property\"\u003erequires_grad\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eCross Entropy Loss 정의\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이전 게시물에서 lm_head의 가장 중요한 로짓이 문장의 마지막 토큰과 관련이 있다고 설명했습니다. 이는 self-attention 메커니즘에서 기인하는데, 마지막 토큰은 이전 모든 문맥 토큰들로부터의 주의 점수를 가지고 있습니다. 따라서 우리는 logits[:, -1, :]를 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e torch\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculate_loss_batch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003einput_batch, target_batch, model\u003c/span\u003e):\n    input_batch, target_batch = input_batch.to(\u003cspan class=\"hljs-string\"\u003e\"cuda\"\u003c/span\u003e), target_batch.to(\u003cspan class=\"hljs-string\"\u003e\"cuda\"\u003c/span\u003e)\n    logits = model(input_batch).logits[:, -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, :]  \u003cspan class=\"hljs-comment\"\u003e# 마지막 출력 토큰의 로짓\u003c/span\u003e\n    loss = torch.nn.functional.cross_entropy(logits, target_batch).to(\u003cspan class=\"hljs-string\"\u003e\"cuda\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e loss\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e데이터셋 준비\u003c/h2\u003e\n\u003cp\u003e데이터셋은 텍스트와 레이블 두 개의 리스트로 구성되어 있습니다. 먼저, 토크나이저를 사용하여 텍스트 문자열을 토큰화된 ID로 변환합니다. 토크나이저는 정의된 최대 길이보다 긴 토큰을 자르거나 최대 길이보다 짧은 경우 패딩합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eecoding = \u003cspan class=\"hljs-title function_\"\u003etokenizer\u003c/span\u003e(\n            text,\n            add_special_tokens=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e,\n            max_length=self.\u003cspan class=\"hljs-property\"\u003emax_length\u003c/span\u003e,\n            padding=\u003cspan class=\"hljs-string\"\u003e'max_length'\u003c/span\u003e,\n            truncation=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e,\n            return_tensors=\u003cspan class=\"hljs-string\"\u003e'pt'\u003c/span\u003e\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그 다음으로, torch에서 DataLoader 객체를 사용하여 데이터를 모델 튜닝을 위해 반복적으로 공급합니다. BinaryClassification Dataset 객체는 torch의 Dataset 객체를 상속하며, 이 데이터셋을 DataLoader 객체로 로드합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBinaryClassificationDataset\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDataset\u003c/span\u003e):\n      pass\n\ndataset = \u003cspan class=\"hljs-title class_\"\u003eBinaryClassificationDataset\u003c/span\u003e(texts, labels, tokenizer, max_length)\n\n# \u003cspan class=\"hljs-title class_\"\u003eDataLoader\u003c/span\u003e\ndataloader = \u003cspan class=\"hljs-title class_\"\u003eDataLoader\u003c/span\u003e(dataset, batch_size=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, shuffle=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e1단계와 2단계를 합쳐서, 이것이 완전한 구현입니다. 메인 함수에 예제를 제공하여 BinaryClassificationDataset 객체를 인스턴스화하고 DataLoader 객체를 만들어 데이터를 생성하는 방법을 보여줍니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e torch\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e torch.utils.data \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Dataset, DataLoader\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e transformers \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e AutoTokenizer\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBinaryClassificationDataset\u003c/span\u003e(\u003cspan class=\"hljs-title class_ inherited__\"\u003eDataset\u003c/span\u003e):\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, texts, labels, tokenizer, max_length\u003c/span\u003e):\n        self.texts = texts\n        self.labels = labels\n        self.tokenizer = tokenizer\n        self.max_length = max_length\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__len__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself\u003c/span\u003e):\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(self.texts)\n\n    \u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003e__getitem__\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, idx\u003c/span\u003e):\n        text = self.texts[idx]\n        label = self.labels[idx]\n\n        encoding = self.tokenizer(\n            text,\n            add_special_tokens=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e,\n            max_length=self.max_length,\n            padding=\u003cspan class=\"hljs-string\"\u003e'max_length'\u003c/span\u003e,\n            truncation=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e,\n            return_tensors=\u003cspan class=\"hljs-string\"\u003e'pt'\u003c/span\u003e\n        )\n\n        input_ids = encoding[\u003cspan class=\"hljs-string\"\u003e'input_ids'\u003c/span\u003e].squeeze(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# Remove batch dimension\u003c/span\u003e\n        attention_mask = encoding[\u003cspan class=\"hljs-string\"\u003e'attention_mask'\u003c/span\u003e].squeeze(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# Remove batch dimension\u003c/span\u003e\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n            \u003cspan class=\"hljs-string\"\u003e'input_ids'\u003c/span\u003e: input_ids.long(),\n            \u003cspan class=\"hljs-string\"\u003e'attention_mask'\u003c/span\u003e: attention_mask.long(),\n            \u003cspan class=\"hljs-string\"\u003e'labels'\u003c/span\u003e: torch.tensor(label, dtype=torch.long)\n        }\n\n\u003cspan class=\"hljs-comment\"\u003e# Example usage\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main__\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e# Sample data\u003c/span\u003e\n    texts = [\u003cspan class=\"hljs-string\"\u003e\"Hello, this is a sample sentence.\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Another sample text for classification.\"\u003c/span\u003e]\n    labels = [\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n\n    \u003cspan class=\"hljs-comment\"\u003e# Load tokenizer\u003c/span\u003e\n    tokenizer = AutoTokenizer.from_pretrained(model_name)\n    \n    \u003cspan class=\"hljs-comment\"\u003e# Define dataset\u003c/span\u003e\n    max_length = \u003cspan class=\"hljs-number\"\u003e128\u003c/span\u003e\n    dataset = BinaryClassificationDataset(texts, labels, tokenizer, max_length)\n\n    \u003cspan class=\"hljs-comment\"\u003e# DataLoader\u003c/span\u003e\n    dataloader = DataLoader(dataset, batch_size=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, shuffle=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-comment\"\u003e# Iterate through the dataloader\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e batch \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e dataloader:\n        input_ids = batch[\u003cspan class=\"hljs-string\"\u003e'input_ids'\u003c/span\u003e]\n        attention_mask = batch[\u003cspan class=\"hljs-string\"\u003e'attention_mask'\u003c/span\u003e]\n        labels = batch[\u003cspan class=\"hljs-string\"\u003e'labels'\u003c/span\u003e]\n\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Input IDs:\"\u003c/span\u003e, input_ids)\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Attention Mask:\"\u003c/span\u003e, attention_mask)\n        \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Labels:\"\u003c/span\u003e, labels)\n      \n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e모델 훈련\u003c/h2\u003e\n\u003cp\u003e손실 함수를 정의하고 데이터셋을 준비한 후, 모델 훈련을 시작할 수 있습니다. calculate_loss_loader 함수는 losses를 0으로 초기화합니다. 지정된 배치 수(num_batches)를 지정하면, calculate_loss_batch 함수를 사용하여 각 배치의 손실을 계산합니다. DataLoader 객체를 사용하여 calculate_loss_batch 함수에 배치 데이터를 반복적으로 제공하고, 각 반복에 대해 손실을 누적합니다. 재현성을 위해 torch.manual_seed(1234)를 사용합니다. 이 실험에서 0.68의 손실을 달성했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculate_loss_loader\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003edata_loader, model, num_batches=\u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e\u003c/span\u003e):\n    losses = \u003cspan class=\"hljs-number\"\u003e0.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(data_loader) == \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Please provide dataset, data loader is empty.\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eelif\u003c/span\u003e num_batches \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        num_batches = \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(data_loader)\n    \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n        num_batches = \u003cspan class=\"hljs-built_in\"\u003emin\u003c/span\u003e(num_batches, \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(data_loader))\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e index, batch \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eenumerate\u003c/span\u003e(data_loader):\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e index \u0026#x3C; num_batches:\n            loss = calculate_loss_batch(\n              batch[\u003cspan class=\"hljs-string\"\u003e\"input_ids\"\u003c/span\u003e], batch[\u003cspan class=\"hljs-string\"\u003e\"labels\"\u003c/span\u003e], model\n            )\n            losses += loss.item()\n        \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e total_loss / num_batches\n\n\ntorch.manual_seed(\u003cspan class=\"hljs-number\"\u003e1234\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# 재현성을 위해\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e torch.no_grad():\n    train_loss = calculate_loss_loader(dataloader, model, num_batches=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e트레이드오프\u003c/h1\u003e\n\u003cp\u003e다음 토큰 예측에서 트랜스포머를 처음 원리를 통해 분류 예측으로 활용할 수 있다는 것은 흥미롭습니다. 미리 훈련된 트랜스포머 모델은 언어 패턴의 풍부한 표현을 포착합니다. 그러나 가벼운 모델이지만 38 억 개의 매개변수를 가지고 있습니다. 독자들은 정확성과 교육 그리고 추론 처리량(초당 생성된 토큰 수) 사이의 트레이드오프를 인식해야 합니다. 저는 기준선으로 더 작은 모델을 시작하는 것을 제안합니다. 예를 들어, 6700만 개의 매개변수를 가진 distilbert-base-uncased 모델을 사용할 수 있습니다. 또는 XGBoost와 같은 더 전통적인 머신러닝 모델을 시도할 수도 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e본 블로그 포스트에서는 처음 원리를 사용하여 다음 토큰 예측 문제를 분류 레이블 예측으로 변환하는 방법을 보여드렸습니다. 이 데모를 통해 LLM의 복잡한 구조를 해체하고 도메인별 문제에 동일한 개념을 적용하는 지식을 습득할 수 있기를 희망합니다. 전체 분류 작업에 대해 트랜스포머가 최적화된 솔루션이 아닐 수 있으며, 다른 더 작은 모델과 데이터를 학습하고 평가해야 함을 상기해야 합니다. 읽어 주셔서 감사합니다. 행복한 학습 되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-TransformingNext-TokenPredictionintoClassificationwithLLMs"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>