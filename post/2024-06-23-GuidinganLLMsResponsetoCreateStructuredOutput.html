<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>LLM 출력 구조화하는 방법 안내 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="LLM 출력 구조화하는 방법 안내 | itposting" data-gatsby-head="true"/><meta property="og:title" content="LLM 출력 구조화하는 방법 안내 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput" data-gatsby-head="true"/><meta name="twitter:title" content="LLM 출력 구조화하는 방법 안내 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 19:40" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">LLM 출력 구조화하는 방법 안내</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="LLM 출력 구조화하는 방법 안내" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput_0.png" alt="2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput_0.png"></p>
<p>이 기사는 Python에서 유효성 검사 라이브러리를 사용하여 GPT-4 또는 Llama 3와 같은 LLM 응답을 구조화하는 방법을 가르쳐줍니다.</p>
<p>JSON 형식에서 구조화된 정보를 추출해야 하는 필요성은 매우 중요한 주제이며, 이것은 데이터 마이닝 작업에서 정확한 정보를 비구조적 형식(예: 자유 텍스트)에서 추출하는 데 기본적입니다.</p>
<p>또한, LLM의 출력 토큰을 생성하는 과정에서 발생하는 확률적 특성으로 인해 GPT와 같은 상업용 시스템에서도 구조화된 응답 형식이 신뢰할 수 없습니다.</p>
<div class="content-ad"></div>
<p>우리는 유효성 검사와 스키마 모델링을 위해 Pydantic와 Instructor와 같은 여러 라이브러리를 사용할 것이고, LLM 부분에는 OpenAI와 ollama를 활용할 것입니다. 제안된 내용은 OpenAI나 Anthropic과 같은 폐쇄 소스 모델뿐만 아니라 Llama 3와 같은 오픈 소스 모델에 대해서도 유효합니다.</p>
<p>본 기사를 통해 아래 내용을 배울 수 있습니다:</p>
<ul>
<li>데이터 모델을 정의하는 방법과 그것이 무엇인지</li>
<li>LLM이 출력 형식을 준수하는지를 유효성 규칙을 통해 확인하는 방법</li>
<li>Instructor와 Pydantic 라이브러리를 사용하는 방법</li>
</ul>
<p>즐거운 독해 되세요!</p>
<div class="content-ad"></div>
<h1>구조화된 출력이 필요한 이유</h1>
<p>GPT-4와 같은 LLM은 특정 패턴을 따르지 않고도 상당한 가치를 제공할 수 있습니다. 하지만 데이터를 다루는 프로그래머들에게는 사용자의 의지에 따라 가능한 출력 패턴을 준수하는 것이 중요합니다.</p>
<p>GPT-3.5의 특정 버전부터 OpenAI는 완성 API에 response_format 매개변수를 추가했습니다. 이를 통해 사용자는 json_object와 같은 다른 키를 정의하여 모델을 입력한 프롬프트에 더 적합한 응답 방향으로 안내할 수 있습니다.</p>
<p>다음은 예시입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI
client = OpenAI()

response = client.chat.completions.create(
  model=<span class="hljs-string">"gpt-3.5-turbo-0125"</span>,
  response_format={ <span class="hljs-string">"type"</span>: <span class="hljs-string">"json_object"</span> },
  messages=[
    {<span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"You are a helpful assistant designed to output JSON."</span>},
    {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"Who won the world series in 2020?"</span>}
  ]
)
<span class="hljs-built_in">print</span>(response.choices[<span class="hljs-number">0</span>].message.content)

<span class="hljs-meta">>>> </span><span class="hljs-string">"content"</span>: <span class="hljs-string">"{\"winner\": \"Los Angeles Dodgers\"}"</span>
</code></pre>
<p>하지만 이러한 로직이 항상 작동하는 것은 아닙니다. 실제로 OpenAI의 문서에서는 GPT가 이를 생성하는 데 도움을 주기 위해 프롬프트에 "JSON"이라는 단어를 명확하게 작성할 것을 제안합니다. 이는 "response_format={ "type": "json_object" }"를 사용할 때 프롬프트 어딘가에 이를 작성해야만 하는 중요한 팁이기 때문에 강제적으로 작성해야 합니다.</p>
<h2>LLM이 일관된 JSON 출력을 생성하기 어려운 이유는 무엇인가요?</h2>
<p>LLM은 입력 프롬프트가 주어졌을 때 이전 토큰 다음에 더 많이 나올 가능성이 있는 다음 토큰을 반환하는 기계로서의 역할을 합니다. 실제로 이러한 형식을 보고 이해하려면 모델이 훈련 단계에서 명시적으로 이러한 형식을 보고 이해하기 위해 안내받아야만 하므로 이러한 패턴을 "자연"에서 만나기 어렵습니다.</p>
<div class="content-ad"></div>
<p>최신 LLM의 JSON 모드는 출력이 특정 패턴과 일치한다고 보장하지 않습니다. 단지 유효하고 오류 없이 파싱된다는 것만을 보장합니다.</p>
<p>따라서 이러한 출력물 안에 무엇이 포함되어 있는지를 유효성 검사할 수 있고, 데이터 모델과 일치하지 않는 경우 예외와 오류를 발생시키는 것이 중요합니다.</p>
<h1>사용 사례</h1>
<p>우리는 GPT-4 또는 Llama3와 같은 LLM에 간단한 질문에서 시작하여 JSON에서 정보를 추출하는 예제를 살펴볼 것입니다.</p>
<div class="content-ad"></div>
<p>우리는 무엇이든 물어볼 수 있지만, 모델에게 시간이 지남에 따른 축구 월드컵 우승팀에 관한 질문을 하려고 합니다.</p>
<p>특히 우리는 다음을 추출하고 싶습니다.</p>
<ul>
<li>결승 일자</li>
<li>대회의 개최 국가</li>
<li>우승 팀</li>
<li>최다 득점자</li>
</ul>
<p>우리는 데이터의 정확성을 확인하는 것이 아니라, LLM의 문장 응답을 다음으로 보여줄 스키마에 맞추는 것에만 신경을 쓸 것입니다.</p>
<div class="content-ad"></div>
<p>이 기사에서는 이 예제를 살펴보고 다른 것들도 살펴볼 수 있을 것 같아요.</p>
<h2>필수 종속성</h2>
<p>이제 이 튜토리얼을 실행하기 위해 설치해야 할 종속성을 살펴봅시다.</p>
<p>당연히, 이미 활성화된 개발 환경이 있다고 가정하고 Pydantic, Instructor, OpenAI 클라이언트 및 ollama를 설치할 거예요.</p>
<div class="content-ad"></div>
<ul>
<li>Pydantic: 커뮤니티에서 널리 사용되는 데이터 모델 정의 및 유효성 검사 라이브러리로, 사용 편의성, 효율성 및 데이터 과학에서의 중요성으로 유명합니다.</li>
<li>Instructor: LLMs와 작업하기 위해 특별히 제작된 Pydantic을 감싸는 래퍼로, 유효성 검사 로직을 생성할 수 있는 라이브러리입니다.</li>
<li>OpenAI: GPT와 다른 OpenAI 모델에 쿼리를 요청하기 위한 유명한 클라이언트입니다.</li>
<li>ollama: llama3와 같은 오픈 소스 LLM에 대한 매우 편리한 인터페이스입니다.</li>
</ul>
<p>개발 환경에서는 다음 명령어를 사용하여 시작합니다.</p>
<pre><code class="hljs language-bash">pip install pydantic instructor openai ollama
</code></pre>
<p>오픈 소스 모델을 테스트하고자 하기 때문에 다음 단계는 ollama를 시스템 전역에 설치하는 것입니다. ollama의 설치 및 사용 방법은 이 특별한 기사에서 읽어보실 수 있습니다.</p>
<div class="content-ad"></div>
<p>이제 개발에 집중할 수 있겠네요.</p>
<h2>데이터 모델 정의</h2>
<p>데이터 모델은 데이터를 구조화하기 위해 따를 논리적인 패턴입니다. 데이터베이스의 테이블을 정의하는 것부터 입력 데이터를 유효성 검사하는 데까지 여러 맥락에서 사용됩니다.</p>
<p>아래 포스트에서 Pydantic을 활용한 데이터 과학과 머신러닝에서의 데이터 모델링에 대해 이미 약간 다룬 적이 있습니다 👇</p>
<div class="content-ad"></div>
<p>파이던틱 데이터 모델을 만들어 보면 좋겠어요:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> <span class="hljs-title class_">BaseModel</span>, <span class="hljs-title class_">Field</span>
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span>
<span class="hljs-keyword">import</span> datetime

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SoccerData</span>(<span class="hljs-title class_">BaseModel</span>):
    <span class="hljs-attr">date_of_final</span>: datetime.<span class="hljs-property">date</span> = <span class="hljs-title class_">Field</span>(..., description=<span class="hljs-string">"최종 이벤트 날짜"</span>)
    <span class="hljs-attr">hosting_country</span>: str = <span class="hljs-title class_">Field</span>(..., description=<span class="hljs-string">"대회를 개최하는 국가"</span>)
    <span class="hljs-attr">winner</span>: str = <span class="hljs-title class_">Field</span>(..., description=<span class="hljs-string">"최종 경기에서 우승한 축구팀"</span>)
    <span class="hljs-attr">top_scorers</span>: list = <span class="hljs-title class_">Field</span>(
        ..., description=<span class="hljs-string">"대회의 상위 3명 스코어러 목록"</span>
    )

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SoccerDataset</span>(<span class="hljs-title class_">BaseModel</span>):
    <span class="hljs-attr">reports</span>: <span class="hljs-title class_">List</span>[<span class="hljs-title class_">SoccerData</span>] = []
</code></pre>
<p>이 스크립트에서는 Pydantic에서 BaseModel 및 Field 클래스를 가져와 데이터 모델을 만드는 작업을 시작합니다. 사실, 최종 결과가 가져야 할 구조를 만들고 있습니다.</p>
<p>Pydantic은 모델에 들어가는 데이터 유형을 선언해야 합니다. 예를 들어 datetime.date는 날짜 필드가 문자열이 아니라 날짜여야 함을 강제합니다. 동시에 top_scorers 필드는 반드시 목록이어야 하며, 그렇지 않으면 Pydantic이 유효성 검사 오류를 반환할 것입니다.</p>
<div class="content-ad"></div>
<p>마침내, 여러 인스턴스를 수집하는 데이터 모델을 만들었습니다. 이것은 SoccerData 모델의 모음을 수집하는 SoccerDataset이라고 합니다. 이 모델은 한 개 이상의 보고서가 있는지 확인하기 위해 강사에 의해 사용될 것입니다.</p>
<h1>시스템 프롬프트 생성</h1>
<p>매우 간단히, 모델이 수행해야 하는 작업을 영어로 적어봅시다. 예를 통해 결과의 의도와 구조를 강조하면서 설명합니다.</p>
<pre><code class="hljs language-js">system_prompt = <span class="hljs-string">""</span><span class="hljs-string">"당신은 숙련된 스포츠 기자입니다. 특정 연도의 축구 월드컵에서 우승한 팀에 대한 작은 리포트를 작성할 것입니다. 대회 결승전 날짜, 대회 전체에서 상위 3 스코어러, 우승 팀, 그리고 대회를 주최한 국가를 보고합니다. 다음 필드를 포함하는 JSON 객체를 반환하세요: date_of_final, hosting_country, winner, top_scorers.\
 
만약 다수 연도가 입력되면, 보고서를 쉼표로 구분하세요.\
 
다음은 예시입니다.
 [
    {
        "</span>date_of_final<span class="hljs-string">": "</span><span class="hljs-number">1966</span><span class="hljs-string">",
        "</span>hosting_country<span class="hljs-string">": "</span><span class="hljs-title class_">England</span><span class="hljs-string">",
        "</span>winner<span class="hljs-string">": "</span><span class="hljs-title class_">England</span><span class="hljs-string">",
        "</span>top_scorers<span class="hljs-string">": ["</span><span class="hljs-title class_">Player</span> A<span class="hljs-string">", "</span><span class="hljs-title class_">Player</span> B<span class="hljs-string">", "</span><span class="hljs-title class_">Player</span> C<span class="hljs-string">"]
    },
    {
        "</span>date_of_final<span class="hljs-string">": ...
        "</span>hosting_country<span class="hljs-string">": ...
        "</span>winner<span class="hljs-string">": ...
        "</span>top_scorers<span class="hljs-string">": ...
    },

]

다음 연도들에 대해 보고해야 할 것입니다:

 "</span><span class="hljs-string">""</span>
</code></pre>
<div class="content-ad"></div>
<p>시스템 프롬프트로 사용되며 단순히 쉼표로 구분된 연도를 전달할 수 있습니다.</p>
<h1>강사 코드 생성</h1>
<p>여기서는 Instructor를 사용하여 JSON 유효성 검사 및 구조화의 주요 로직을 만들 것입니다. 이를 통해 GPT를 API를 통해 호출하는 OpenAI에서 제공하는 인터페이스와 유사한 인터페이스를 사용합니다.</p>
<p>먼저 우리는 query_gpt라는 함수를 사용하여 OpenAI를 사용하여 프롬프트를 매개변수화할 것입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> <span class="hljs-title class_">OpenAI</span>
<span class="hljs-keyword">import</span> instructor

def <span class="hljs-title function_">query_gpt</span>(<span class="hljs-attr">prompt</span>: str) -> <span class="hljs-attr">list</span>:
    client = instructor.<span class="hljs-title function_">from_openai</span>(<span class="hljs-title class_">OpenAI</span>(api_key=<span class="hljs-string">"..."</span>))
    resp = client.<span class="hljs-property">chat</span>.<span class="hljs-property">completions</span>.<span class="hljs-title function_">create</span>(
        model=<span class="hljs-string">"gpt-3.5-turbo"</span>,
        response_model=<span class="hljs-title class_">SoccerDataset</span>,
        messages=[
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>, <span class="hljs-string">"content"</span>: system_prompt},
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: prompt},
        ],
    )
    <span class="hljs-keyword">return</span> resp.<span class="hljs-title function_">model_dump_json</span>(indent=<span class="hljs-number">4</span>)
</code></pre>
<p>OpenAI API 키를 새롭게 생성된 클라이언트에 전달하는 것을 잊지 말자. 우리는 GPT-3.5-Turbo를 사용하고, 응답 모델로 SoccerDataset을 전달할 것이다. 또한, 이 기사를 작성하는 시점에서 가장 강력한 모델인 "gpt-4o"를 사용할 수도 있다.</p>
<p>모든 것을 함께 조합하여 소프트웨어를 실행해 보자. 사용자 프롬프트로 입력할 내용으로 "2010, 2014 및 2018"년을 내용으로 전달하여 구조화된 보고서를 생성하고자 한다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> <span class="hljs-title class_">OpenAI</span>
<span class="hljs-keyword">import</span> instructor

<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span>
<span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> <span class="hljs-title class_">BaseModel</span>, <span class="hljs-title class_">Field</span>
<span class="hljs-keyword">import</span> datetime


<span class="hljs-keyword">class</span> <span class="hljs-title class_">SoccerData</span>(<span class="hljs-title class_">BaseModel</span>):
    <span class="hljs-attr">date_of_final</span>: datetime.<span class="hljs-property">date</span> = <span class="hljs-title class_">Field</span>(..., description=<span class="hljs-string">"최종 이벤트의 날짜"</span>)
    <span class="hljs-attr">hosting_country</span>: str = <span class="hljs-title class_">Field</span>(..., description=<span class="hljs-string">"대회를 주최하는 나라"</span>)
    <span class="hljs-attr">winner</span>: str = <span class="hljs-title class_">Field</span>(..., description=<span class="hljs-string">"최종 경기에서 승리한 축구팀"</span>)
    <span class="hljs-attr">top_scorers</span>: list = <span class="hljs-title class_">Field</span>(
        ..., description=<span class="hljs-string">"대회의 상위 3명의 득점수 리스트"</span>
    )


<span class="hljs-keyword">class</span> <span class="hljs-title class_">SoccerDataset</span>(<span class="hljs-title class_">BaseModel</span>):
    <span class="hljs-attr">reports</span>: <span class="hljs-title class_">List</span>[<span class="hljs-title class_">SoccerData</span>] = []


system_prompt = <span class="hljs-string">""</span><span class="hljs-string">"당신은 전문 스포츠 기자입니다. 특정 연도의 축구 월드컵에서 승자를 작은 보고서로 작성해야 합니다.
대회 최종일, 대회의 전체 득점수 상위 3명, 우승 팀 및 대회를 개최하는 국가를 보고해야 합니다.
다음 필드를 포함한 JSON 객체를 반환하세요: date_of_final, hosting_country, winner, top_scorers.

쿼리가 유효하지 않은 경우 빈 보고서를 반환하세요.

여러 연도가 입력된 경우 보고서를 쉼표로 구분하세요.

예시입니다
[
    {
        "</span>date_of_final<span class="hljs-string">": "</span><span class="hljs-number">1966</span><span class="hljs-string">",
        "</span>hosting_country<span class="hljs-string">": "</span><span class="hljs-title class_">England</span><span class="hljs-string">",
        "</span>winner<span class="hljs-string">": "</span><span class="hljs-title class_">England</span><span class="hljs-string">",
        "</span>top_scorers<span class="hljs-string">": ["</span><span class="hljs-title class_">Player</span> A<span class="hljs-string">", "</span><span class="hljs-title class_">Player</span> B<span class="hljs-string">", "</span><span class="hljs-title class_">Player</span> C<span class="hljs-string">"]
    },
    {
        "</span>date_of_final<span class="hljs-string">": ...
        "</span>hosting_country<span class="hljs-string">": ...
        "</span>winner<span class="hljs-string">": ...
        "</span>top_scorers<span class="hljs-string">": ...
    },

]

다음 보고가 필요한 연도입니다:

"</span><span class="hljs-string">""</span>

def <span class="hljs-title function_">query_gpt</span>(<span class="hljs-attr">prompt</span>: str) -> <span class="hljs-attr">list</span>:
    client = instructor.<span class="hljs-title function_">from_openai</span>(<span class="hljs-title class_">OpenAI</span>())
    resp = client.<span class="hljs-property">chat</span>.<span class="hljs-property">completions</span>.<span class="hljs-title function_">create</span>(
        model=<span class="hljs-string">"gpt-3.5-turbo"</span>,
        response_model=<span class="hljs-title class_">SoccerDataset</span>,
        messages=[
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>, <span class="hljs-string">"content"</span>: system_prompt},
            {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: prompt},
        ],
    )
    <span class="hljs-keyword">return</span> resp.<span class="hljs-title function_">model_dump_json</span>(indent=<span class="hljs-number">4</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
  resp = <span class="hljs-title function_">query_llm</span>(<span class="hljs-string">"2010, 2014, 2018"</span>)
  <span class="hljs-title function_">print</span>(resp)
</code></pre>
<div class="content-ad"></div>
<p>위 문구를 Markdown 형식으로 변환한 결과입니다:</p>
<pre><code class="hljs language-json"><span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"reports"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"date_of_final"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2010-07-11"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"hosting_country"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"South Africa"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"winner"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Spain"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"top_scorers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
                <span class="hljs-string">"Thomas Müller"</span><span class="hljs-punctuation">,</span>
                <span class="hljs-string">"David Villa"</span><span class="hljs-punctuation">,</span>
                <span class="hljs-string">"Wesley Sneijder"</span>
            <span class="hljs-punctuation">]</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"date_of_final"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2014-07-13"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"hosting_country"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Brazil"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"winner"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Germany"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"top_scorers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
                <span class="hljs-string">"James Rodríguez"</span><span class="hljs-punctuation">,</span>
                <span class="hljs-string">"Thomas Müller"</span><span class="hljs-punctuation">,</span>
                <span class="hljs-string">"Neymar"</span>
            <span class="hljs-punctuation">]</span>
        <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"date_of_final"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"2018-07-15"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"hosting_country"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"Russia"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"winner"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"France"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"top_scorers"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
                <span class="hljs-string">"Harry Kane"</span><span class="hljs-punctuation">,</span>
                <span class="hljs-string">"Antoine Griezmann"</span><span class="hljs-punctuation">,</span>
                <span class="hljs-string">"Romelu Lukaku"</span>
            <span class="hljs-punctuation">]</span>
        <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>
<p>멋지네요. GPT-3.5-Turbo가 우리의 지시를 완벽하게 따르고, Instructor가 데이터 모델과 일치하는 구조를 만들어내었습니다. 실제로 이 결과는 GPT와 같은 대형 언어 모델이 일반적으로 반환하는 문자열이 아니라, 파이썬 사전의 리스트입니다.</p>
<p>이제 이상한 입력을 넣어보려고 해봅시다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main()"</span>:
      <span class="hljs-title function_">print</span>(<span class="hljs-title function_">query_gpt</span>(<span class="hljs-string">"안녕, 어떻게 지내?"</span>))

>>>
{
 <span class="hljs-string">"리포트"</span>: []
}
</code></pre>
<p>LLM은 시스템 프롬프트를 통해 잘못된 쿼리를 처리하는 방법을 요청했기 때문에 올바르게 비어있는 리포트를 반환합니다.</p>
<h1>Instructor와 함께 오픈 소스 템플릿 사용</h1>
<p>Instructor를 사용하여 GPT를 어떻게 사용하여 구조화된 JSON 출력을 얻는지 알아보았습니다. 이제 llama3와 같은 오픈 소스 템플릿을 사용하는 방법을 살펴보겠습니다.</p>
<div class="content-ad"></div>
<p>새로운 함수인 query_llama을 생성해 봅시다.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">query_llama</span>(<span class="hljs-attr">prompt</span>: str) -> <span class="hljs-attr">list</span>:
    client = instructor.<span class="hljs-title function_">from_openai</span>(
        <span class="hljs-title class_">OpenAI</span>(
            base_url=<span class="hljs-string">"http://localhost:11434/v1"</span>,
            api_key=<span class="hljs-string">"ollama"</span>,  # 요청은 필요하지만 영향을 미치지 않습니다
        ),
        mode=instructor.<span class="hljs-property">Mode</span>.<span class="hljs-property">JSON</span>,
    )
    resp = client.<span class="hljs-property">chat</span>.<span class="hljs-property">completions</span>.<span class="hljs-title function_">create</span>(
        model=<span class="hljs-string">"llama3"</span>,
        messages=[
            {
                <span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>,
                <span class="hljs-string">"content"</span>: system_prompt
            },
            {
                <span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>,
                <span class="hljs-string">"content"</span>: prompt
            }
        ],
        response_model=<span class="hljs-title class_">SoccerDataset</span>,
    )
    <span class="hljs-keyword">return</span> resp.<span class="hljs-title function_">model_dump_json</span>(indent=<span class="hljs-number">4</span>)
</code></pre>
<p>GPT 코드와 약간의 차이가 있습니다. 함께 살펴보겠습니다.</p>
<ul>
<li>ollama는 GPT와 동일한 인터페이스를 통해 호출되지만, 기본 URL 포인터(base_url) 및 필수적이지만 올바른 작동에 필요하지 않은 API 키를 변경합니다(왜냐면 모르겠어요)</li>
<li>JSON 모드를 mode 매개변수를 통해 설명해야 합니다.
새로운 함수를 실행해 봅시다.</li>
</ul>
<div class="content-ad"></div>
<p>함수를 실행해 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    <span class="hljs-title function_">print</span>(<span class="hljs-title function_">query_llama</span>(<span class="hljs-string">"2010, 2014, 2018"</span>))
</code></pre>
<p>그리고 여기에 결과가 있습니다:</p>
<pre><code class="hljs language-js">{
    <span class="hljs-string">"reports"</span>: [
        {
            <span class="hljs-string">"date_of_final"</span>: <span class="hljs-string">"2010-07-11"</span>,
            <span class="hljs-string">"hosting_country"</span>: <span class="hljs-string">"South Africa"</span>,
            <span class="hljs-string">"winner"</span>: <span class="hljs-string">"Spain"</span>,
            <span class="hljs-string">"top_scorers"</span>: [
                <span class="hljs-string">"Thomas Müller"</span>,
                <span class="hljs-string">"Wolfram Toloi"</span>,
                <span class="hljs-string">"Landon Donovan"</span>
            ]
        },
        {
            <span class="hljs-string">"date_of_final"</span>: <span class="hljs-string">"2014-07-13"</span>,
            <span class="hljs-string">"hosting_country"</span>: <span class="hljs-string">"Brazil"</span>,
            <span class="hljs-string">"winner"</span>: <span class="hljs-string">"Germany"</span>,
            <span class="hljs-string">"top_scorers"</span>: [
                <span class="hljs-string">"James Rodríguez"</span>,
                <span class="hljs-string">"Miroslav Klose"</span>,
                <span class="hljs-string">"Thomas Müller"</span>
            ]
        },
        {
            <span class="hljs-string">"date_of_final"</span>: <span class="hljs-string">"2018-07-15"</span>,
            <span class="hljs-string">"hosting_country"</span>: <span class="hljs-string">"Russia"</span>,
            <span class="hljs-string">"winner"</span>: <span class="hljs-string">"France"</span>,
            <span class="hljs-string">"top_scorers"</span>: [
                <span class="hljs-string">"Harry Kane"</span>,
                <span class="hljs-string">"Kylian Mbappé"</span>,
                <span class="hljs-string">"Antoine Griezmann"</span>
            ]
        }
    ]
}
</code></pre>
<div class="content-ad"></div>
<p>우리는 올바른 JSON이 있는 목록을 가지고 있어요! 이 모든 것은 Llama 3로 로컬에서 이루어져요.</p>
<p>이전에 말한대로, 유효성 검사는 구조를 기반으로 하고 있어요. 실제로, 이 내용은 GPT에서 생성된 내용과 다를 수 있어요.</p>
<p>어떻게 마커들이 다른지 살펴봅시다. 아마도 우리가 받고 싶은 마커들을 명확히 지정하면 올바른 목록을 얻을 수도 있겠죠.</p>
<h1>결론</h1>
<div class="content-ad"></div>
<p>Pydantic, Instructors, 그리고 ollama를 사용하여 LLM의 출력을 JSON과 같은 구조화된 형식으로 변환하는 방법을 살펴봤습니다.</p>
<p>이 과정에서 모델이 실제로 지도되므로 결정론적이지 않습니다. JSON이 LLM의 결정론적이지 않은 성질로 인해 준수되지 않을 수 있는 경우가 있을 것입니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"LLM 출력 구조화하는 방법 안내","description":"","date":"2024-06-23 19:40","slug":"2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput","content":"\n\n![2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput_0.png](/assets/img/2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput_0.png)\n\n이 기사는 Python에서 유효성 검사 라이브러리를 사용하여 GPT-4 또는 Llama 3와 같은 LLM 응답을 구조화하는 방법을 가르쳐줍니다.\n\nJSON 형식에서 구조화된 정보를 추출해야 하는 필요성은 매우 중요한 주제이며, 이것은 데이터 마이닝 작업에서 정확한 정보를 비구조적 형식(예: 자유 텍스트)에서 추출하는 데 기본적입니다.\n\n또한, LLM의 출력 토큰을 생성하는 과정에서 발생하는 확률적 특성으로 인해 GPT와 같은 상업용 시스템에서도 구조화된 응답 형식이 신뢰할 수 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 유효성 검사와 스키마 모델링을 위해 Pydantic와 Instructor와 같은 여러 라이브러리를 사용할 것이고, LLM 부분에는 OpenAI와 ollama를 활용할 것입니다. 제안된 내용은 OpenAI나 Anthropic과 같은 폐쇄 소스 모델뿐만 아니라 Llama 3와 같은 오픈 소스 모델에 대해서도 유효합니다.\n\n본 기사를 통해 아래 내용을 배울 수 있습니다:\n\n- 데이터 모델을 정의하는 방법과 그것이 무엇인지\n- LLM이 출력 형식을 준수하는지를 유효성 규칙을 통해 확인하는 방법\n- Instructor와 Pydantic 라이브러리를 사용하는 방법\n\n즐거운 독해 되세요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 구조화된 출력이 필요한 이유\n\nGPT-4와 같은 LLM은 특정 패턴을 따르지 않고도 상당한 가치를 제공할 수 있습니다. 하지만 데이터를 다루는 프로그래머들에게는 사용자의 의지에 따라 가능한 출력 패턴을 준수하는 것이 중요합니다.\n\nGPT-3.5의 특정 버전부터 OpenAI는 완성 API에 response_format 매개변수를 추가했습니다. 이를 통해 사용자는 json_object와 같은 다른 키를 정의하여 모델을 입력한 프롬프트에 더 적합한 응답 방향으로 안내할 수 있습니다.\n\n다음은 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```python\nfrom openai import OpenAI\nclient = OpenAI()\n\nresponse = client.chat.completions.create(\n  model=\"gpt-3.5-turbo-0125\",\n  response_format={ \"type\": \"json_object\" },\n  messages=[\n    {\"role\": \"system\", \"content\": \"You are a helpful assistant designed to output JSON.\"},\n    {\"role\": \"user\", \"content\": \"Who won the world series in 2020?\"}\n  ]\n)\nprint(response.choices[0].message.content)\n\n\u003e\u003e\u003e \"content\": \"{\\\"winner\\\": \\\"Los Angeles Dodgers\\\"}\"\n```\n\n하지만 이러한 로직이 항상 작동하는 것은 아닙니다. 실제로 OpenAI의 문서에서는 GPT가 이를 생성하는 데 도움을 주기 위해 프롬프트에 \"JSON\"이라는 단어를 명확하게 작성할 것을 제안합니다. 이는 \"response_format={ \"type\": \"json_object\" }\"를 사용할 때 프롬프트 어딘가에 이를 작성해야만 하는 중요한 팁이기 때문에 강제적으로 작성해야 합니다.\n\n## LLM이 일관된 JSON 출력을 생성하기 어려운 이유는 무엇인가요?\n\nLLM은 입력 프롬프트가 주어졌을 때 이전 토큰 다음에 더 많이 나올 가능성이 있는 다음 토큰을 반환하는 기계로서의 역할을 합니다. 실제로 이러한 형식을 보고 이해하려면 모델이 훈련 단계에서 명시적으로 이러한 형식을 보고 이해하기 위해 안내받아야만 하므로 이러한 패턴을 \"자연\"에서 만나기 어렵습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최신 LLM의 JSON 모드는 출력이 특정 패턴과 일치한다고 보장하지 않습니다. 단지 유효하고 오류 없이 파싱된다는 것만을 보장합니다.\n\n따라서 이러한 출력물 안에 무엇이 포함되어 있는지를 유효성 검사할 수 있고, 데이터 모델과 일치하지 않는 경우 예외와 오류를 발생시키는 것이 중요합니다.\n\n# 사용 사례\n\n우리는 GPT-4 또는 Llama3와 같은 LLM에 간단한 질문에서 시작하여 JSON에서 정보를 추출하는 예제를 살펴볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 무엇이든 물어볼 수 있지만, 모델에게 시간이 지남에 따른 축구 월드컵 우승팀에 관한 질문을 하려고 합니다.\n\n특히 우리는 다음을 추출하고 싶습니다.\n\n- 결승 일자\n- 대회의 개최 국가\n- 우승 팀\n- 최다 득점자\n\n우리는 데이터의 정확성을 확인하는 것이 아니라, LLM의 문장 응답을 다음으로 보여줄 스키마에 맞추는 것에만 신경을 쓸 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사에서는 이 예제를 살펴보고 다른 것들도 살펴볼 수 있을 것 같아요.\n\n## 필수 종속성\n\n이제 이 튜토리얼을 실행하기 위해 설치해야 할 종속성을 살펴봅시다.\n\n당연히, 이미 활성화된 개발 환경이 있다고 가정하고 Pydantic, Instructor, OpenAI 클라이언트 및 ollama를 설치할 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Pydantic: 커뮤니티에서 널리 사용되는 데이터 모델 정의 및 유효성 검사 라이브러리로, 사용 편의성, 효율성 및 데이터 과학에서의 중요성으로 유명합니다.\n- Instructor: LLMs와 작업하기 위해 특별히 제작된 Pydantic을 감싸는 래퍼로, 유효성 검사 로직을 생성할 수 있는 라이브러리입니다.\n- OpenAI: GPT와 다른 OpenAI 모델에 쿼리를 요청하기 위한 유명한 클라이언트입니다.\n- ollama: llama3와 같은 오픈 소스 LLM에 대한 매우 편리한 인터페이스입니다.\n\n개발 환경에서는 다음 명령어를 사용하여 시작합니다.\n\n```bash\npip install pydantic instructor openai ollama\n```\n\n오픈 소스 모델을 테스트하고자 하기 때문에 다음 단계는 ollama를 시스템 전역에 설치하는 것입니다. ollama의 설치 및 사용 방법은 이 특별한 기사에서 읽어보실 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 개발에 집중할 수 있겠네요.\n\n## 데이터 모델 정의\n\n데이터 모델은 데이터를 구조화하기 위해 따를 논리적인 패턴입니다. 데이터베이스의 테이블을 정의하는 것부터 입력 데이터를 유효성 검사하는 데까지 여러 맥락에서 사용됩니다.\n\n아래 포스트에서 Pydantic을 활용한 데이터 과학과 머신러닝에서의 데이터 모델링에 대해 이미 약간 다룬 적이 있습니다 👇\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이던틱 데이터 모델을 만들어 보면 좋겠어요:\n\n```js\nfrom pydantic import BaseModel, Field\nfrom typing import List\nimport datetime\n\nclass SoccerData(BaseModel):\n    date_of_final: datetime.date = Field(..., description=\"최종 이벤트 날짜\")\n    hosting_country: str = Field(..., description=\"대회를 개최하는 국가\")\n    winner: str = Field(..., description=\"최종 경기에서 우승한 축구팀\")\n    top_scorers: list = Field(\n        ..., description=\"대회의 상위 3명 스코어러 목록\"\n    )\n\nclass SoccerDataset(BaseModel):\n    reports: List[SoccerData] = []\n```\n\n이 스크립트에서는 Pydantic에서 BaseModel 및 Field 클래스를 가져와 데이터 모델을 만드는 작업을 시작합니다. 사실, 최종 결과가 가져야 할 구조를 만들고 있습니다.\n\nPydantic은 모델에 들어가는 데이터 유형을 선언해야 합니다. 예를 들어 datetime.date는 날짜 필드가 문자열이 아니라 날짜여야 함을 강제합니다. 동시에 top_scorers 필드는 반드시 목록이어야 하며, 그렇지 않으면 Pydantic이 유효성 검사 오류를 반환할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내, 여러 인스턴스를 수집하는 데이터 모델을 만들었습니다. 이것은 SoccerData 모델의 모음을 수집하는 SoccerDataset이라고 합니다. 이 모델은 한 개 이상의 보고서가 있는지 확인하기 위해 강사에 의해 사용될 것입니다.\n\n# 시스템 프롬프트 생성\n\n매우 간단히, 모델이 수행해야 하는 작업을 영어로 적어봅시다. 예를 통해 결과의 의도와 구조를 강조하면서 설명합니다.\n\n```js\nsystem_prompt = \"\"\"당신은 숙련된 스포츠 기자입니다. 특정 연도의 축구 월드컵에서 우승한 팀에 대한 작은 리포트를 작성할 것입니다. 대회 결승전 날짜, 대회 전체에서 상위 3 스코어러, 우승 팀, 그리고 대회를 주최한 국가를 보고합니다. 다음 필드를 포함하는 JSON 객체를 반환하세요: date_of_final, hosting_country, winner, top_scorers.\\\n \n만약 다수 연도가 입력되면, 보고서를 쉼표로 구분하세요.\\\n \n다음은 예시입니다.\n [\n    {\n        \"date_of_final\": \"1966\",\n        \"hosting_country\": \"England\",\n        \"winner\": \"England\",\n        \"top_scorers\": [\"Player A\", \"Player B\", \"Player C\"]\n    },\n    {\n        \"date_of_final\": ...\n        \"hosting_country\": ...\n        \"winner\": ...\n        \"top_scorers\": ...\n    },\n\n]\n\n다음 연도들에 대해 보고해야 할 것입니다:\n\n \"\"\"\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시스템 프롬프트로 사용되며 단순히 쉼표로 구분된 연도를 전달할 수 있습니다.\n\n# 강사 코드 생성\n\n여기서는 Instructor를 사용하여 JSON 유효성 검사 및 구조화의 주요 로직을 만들 것입니다. 이를 통해 GPT를 API를 통해 호출하는 OpenAI에서 제공하는 인터페이스와 유사한 인터페이스를 사용합니다.\n\n먼저 우리는 query_gpt라는 함수를 사용하여 OpenAI를 사용하여 프롬프트를 매개변수화할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfrom openai import OpenAI\nimport instructor\n\ndef query_gpt(prompt: str) -\u003e list:\n    client = instructor.from_openai(OpenAI(api_key=\"...\"))\n    resp = client.chat.completions.create(\n        model=\"gpt-3.5-turbo\",\n        response_model=SoccerDataset,\n        messages=[\n            {\"role\": \"system\", \"content\": system_prompt},\n            {\"role\": \"user\", \"content\": prompt},\n        ],\n    )\n    return resp.model_dump_json(indent=4)\n```\n\nOpenAI API 키를 새롭게 생성된 클라이언트에 전달하는 것을 잊지 말자. 우리는 GPT-3.5-Turbo를 사용하고, 응답 모델로 SoccerDataset을 전달할 것이다. 또한, 이 기사를 작성하는 시점에서 가장 강력한 모델인 \"gpt-4o\"를 사용할 수도 있다.\n\n모든 것을 함께 조합하여 소프트웨어를 실행해 보자. 사용자 프롬프트로 입력할 내용으로 \"2010, 2014 및 2018\"년을 내용으로 전달하여 구조화된 보고서를 생성하고자 한다. \n\n```js\nfrom openai import OpenAI\nimport instructor\n\nfrom typing import List\nfrom pydantic import BaseModel, Field\nimport datetime\n\n\nclass SoccerData(BaseModel):\n    date_of_final: datetime.date = Field(..., description=\"최종 이벤트의 날짜\")\n    hosting_country: str = Field(..., description=\"대회를 주최하는 나라\")\n    winner: str = Field(..., description=\"최종 경기에서 승리한 축구팀\")\n    top_scorers: list = Field(\n        ..., description=\"대회의 상위 3명의 득점수 리스트\"\n    )\n\n\nclass SoccerDataset(BaseModel):\n    reports: List[SoccerData] = []\n\n\nsystem_prompt = \"\"\"당신은 전문 스포츠 기자입니다. 특정 연도의 축구 월드컵에서 승자를 작은 보고서로 작성해야 합니다.\n대회 최종일, 대회의 전체 득점수 상위 3명, 우승 팀 및 대회를 개최하는 국가를 보고해야 합니다.\n다음 필드를 포함한 JSON 객체를 반환하세요: date_of_final, hosting_country, winner, top_scorers.\n\n쿼리가 유효하지 않은 경우 빈 보고서를 반환하세요.\n\n여러 연도가 입력된 경우 보고서를 쉼표로 구분하세요.\n\n예시입니다\n[\n    {\n        \"date_of_final\": \"1966\",\n        \"hosting_country\": \"England\",\n        \"winner\": \"England\",\n        \"top_scorers\": [\"Player A\", \"Player B\", \"Player C\"]\n    },\n    {\n        \"date_of_final\": ...\n        \"hosting_country\": ...\n        \"winner\": ...\n        \"top_scorers\": ...\n    },\n\n]\n\n다음 보고가 필요한 연도입니다:\n\n\"\"\"\n\ndef query_gpt(prompt: str) -\u003e list:\n    client = instructor.from_openai(OpenAI())\n    resp = client.chat.completions.create(\n        model=\"gpt-3.5-turbo\",\n        response_model=SoccerDataset,\n        messages=[\n            {\"role\": \"system\", \"content\": system_prompt},\n            {\"role\": \"user\", \"content\": prompt},\n        ],\n    )\n    return resp.model_dump_json(indent=4)\n\nif __name__ == \"__main__\":\n  resp = query_llm(\"2010, 2014, 2018\")\n  print(resp)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 문구를 Markdown 형식으로 변환한 결과입니다:\n\n```json\n{\n    \"reports\": [\n        {\n            \"date_of_final\": \"2010-07-11\",\n            \"hosting_country\": \"South Africa\",\n            \"winner\": \"Spain\",\n            \"top_scorers\": [\n                \"Thomas Müller\",\n                \"David Villa\",\n                \"Wesley Sneijder\"\n            ]\n        },\n        {\n            \"date_of_final\": \"2014-07-13\",\n            \"hosting_country\": \"Brazil\",\n            \"winner\": \"Germany\",\n            \"top_scorers\": [\n                \"James Rodríguez\",\n                \"Thomas Müller\",\n                \"Neymar\"\n            ]\n        },\n        {\n            \"date_of_final\": \"2018-07-15\",\n            \"hosting_country\": \"Russia\",\n            \"winner\": \"France\",\n            \"top_scorers\": [\n                \"Harry Kane\",\n                \"Antoine Griezmann\",\n                \"Romelu Lukaku\"\n            ]\n        }\n    ]\n}\n```\n\n멋지네요. GPT-3.5-Turbo가 우리의 지시를 완벽하게 따르고, Instructor가 데이터 모델과 일치하는 구조를 만들어내었습니다. 실제로 이 결과는 GPT와 같은 대형 언어 모델이 일반적으로 반환하는 문자열이 아니라, 파이썬 사전의 리스트입니다.\n\n이제 이상한 입력을 넣어보려고 해봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nif __name__ == \"__main()\":\n      print(query_gpt(\"안녕, 어떻게 지내?\"))\n\n\u003e\u003e\u003e\n{\n \"리포트\": []\n}\n```\n\nLLM은 시스템 프롬프트를 통해 잘못된 쿼리를 처리하는 방법을 요청했기 때문에 올바르게 비어있는 리포트를 반환합니다.\n\n# Instructor와 함께 오픈 소스 템플릿 사용\n\nInstructor를 사용하여 GPT를 어떻게 사용하여 구조화된 JSON 출력을 얻는지 알아보았습니다. 이제 llama3와 같은 오픈 소스 템플릿을 사용하는 방법을 살펴보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 함수인 query_llama을 생성해 봅시다.\n\n```js\ndef query_llama(prompt: str) -\u003e list:\n    client = instructor.from_openai(\n        OpenAI(\n            base_url=\"http://localhost:11434/v1\",\n            api_key=\"ollama\",  # 요청은 필요하지만 영향을 미치지 않습니다\n        ),\n        mode=instructor.Mode.JSON,\n    )\n    resp = client.chat.completions.create(\n        model=\"llama3\",\n        messages=[\n            {\n                \"role\": \"system\",\n                \"content\": system_prompt\n            },\n            {\n                \"role\": \"user\",\n                \"content\": prompt\n            }\n        ],\n        response_model=SoccerDataset,\n    )\n    return resp.model_dump_json(indent=4)\n```\n\nGPT 코드와 약간의 차이가 있습니다. 함께 살펴보겠습니다.\n\n- ollama는 GPT와 동일한 인터페이스를 통해 호출되지만, 기본 URL 포인터(base_url) 및 필수적이지만 올바른 작동에 필요하지 않은 API 키를 변경합니다(왜냐면 모르겠어요)\n- JSON 모드를 mode 매개변수를 통해 설명해야 합니다.\n새로운 함수를 실행해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n함수를 실행해 봅시다.\n\n```js\r\nif __name__ == \"__main__\":\n    print(query_llama(\"2010, 2014, 2018\"))\r\n```\n\n그리고 여기에 결과가 있습니다:\n\n```js\r\n{\n    \"reports\": [\n        {\n            \"date_of_final\": \"2010-07-11\",\n            \"hosting_country\": \"South Africa\",\n            \"winner\": \"Spain\",\n            \"top_scorers\": [\n                \"Thomas Müller\",\n                \"Wolfram Toloi\",\n                \"Landon Donovan\"\n            ]\n        },\n        {\n            \"date_of_final\": \"2014-07-13\",\n            \"hosting_country\": \"Brazil\",\n            \"winner\": \"Germany\",\n            \"top_scorers\": [\n                \"James Rodríguez\",\n                \"Miroslav Klose\",\n                \"Thomas Müller\"\n            ]\n        },\n        {\n            \"date_of_final\": \"2018-07-15\",\n            \"hosting_country\": \"Russia\",\n            \"winner\": \"France\",\n            \"top_scorers\": [\n                \"Harry Kane\",\n                \"Kylian Mbappé\",\n                \"Antoine Griezmann\"\n            ]\n        }\n    ]\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n우리는 올바른 JSON이 있는 목록을 가지고 있어요! 이 모든 것은 Llama 3로 로컬에서 이루어져요.\n\n이전에 말한대로, 유효성 검사는 구조를 기반으로 하고 있어요. 실제로, 이 내용은 GPT에서 생성된 내용과 다를 수 있어요.\n\n어떻게 마커들이 다른지 살펴봅시다. 아마도 우리가 받고 싶은 마커들을 명확히 지정하면 올바른 목록을 얻을 수도 있겠죠.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPydantic, Instructors, 그리고 ollama를 사용하여 LLM의 출력을 JSON과 같은 구조화된 형식으로 변환하는 방법을 살펴봤습니다.\n\n이 과정에서 모델이 실제로 지도되므로 결정론적이지 않습니다. JSON이 LLM의 결정론적이지 않은 성질로 인해 준수되지 않을 수 있는 경우가 있을 것입니다.","ogImage":{"url":"/assets/img/2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput_0.png"},"coverImage":"/assets/img/2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput_0.png\" alt=\"2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput_0.png\"\u003e\u003c/p\u003e\n\u003cp\u003e이 기사는 Python에서 유효성 검사 라이브러리를 사용하여 GPT-4 또는 Llama 3와 같은 LLM 응답을 구조화하는 방법을 가르쳐줍니다.\u003c/p\u003e\n\u003cp\u003eJSON 형식에서 구조화된 정보를 추출해야 하는 필요성은 매우 중요한 주제이며, 이것은 데이터 마이닝 작업에서 정확한 정보를 비구조적 형식(예: 자유 텍스트)에서 추출하는 데 기본적입니다.\u003c/p\u003e\n\u003cp\u003e또한, LLM의 출력 토큰을 생성하는 과정에서 발생하는 확률적 특성으로 인해 GPT와 같은 상업용 시스템에서도 구조화된 응답 형식이 신뢰할 수 없습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리는 유효성 검사와 스키마 모델링을 위해 Pydantic와 Instructor와 같은 여러 라이브러리를 사용할 것이고, LLM 부분에는 OpenAI와 ollama를 활용할 것입니다. 제안된 내용은 OpenAI나 Anthropic과 같은 폐쇄 소스 모델뿐만 아니라 Llama 3와 같은 오픈 소스 모델에 대해서도 유효합니다.\u003c/p\u003e\n\u003cp\u003e본 기사를 통해 아래 내용을 배울 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e데이터 모델을 정의하는 방법과 그것이 무엇인지\u003c/li\u003e\n\u003cli\u003eLLM이 출력 형식을 준수하는지를 유효성 규칙을 통해 확인하는 방법\u003c/li\u003e\n\u003cli\u003eInstructor와 Pydantic 라이브러리를 사용하는 방법\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e즐거운 독해 되세요!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e구조화된 출력이 필요한 이유\u003c/h1\u003e\n\u003cp\u003eGPT-4와 같은 LLM은 특정 패턴을 따르지 않고도 상당한 가치를 제공할 수 있습니다. 하지만 데이터를 다루는 프로그래머들에게는 사용자의 의지에 따라 가능한 출력 패턴을 준수하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003eGPT-3.5의 특정 버전부터 OpenAI는 완성 API에 response_format 매개변수를 추가했습니다. 이를 통해 사용자는 json_object와 같은 다른 키를 정의하여 모델을 입력한 프롬프트에 더 적합한 응답 방향으로 안내할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 예시입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e openai \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e OpenAI\nclient = OpenAI()\n\nresponse = client.chat.completions.create(\n  model=\u003cspan class=\"hljs-string\"\u003e\"gpt-3.5-turbo-0125\"\u003c/span\u003e,\n  response_format={ \u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"json_object\"\u003c/span\u003e },\n  messages=[\n    {\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"You are a helpful assistant designed to output JSON.\"\u003c/span\u003e},\n    {\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Who won the world series in 2020?\"\u003c/span\u003e}\n  ]\n)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(response.choices[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].message.content)\n\n\u003cspan class=\"hljs-meta\"\u003e\u003e\u003e\u003e \u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"{\\\"winner\\\": \\\"Los Angeles Dodgers\\\"}\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e하지만 이러한 로직이 항상 작동하는 것은 아닙니다. 실제로 OpenAI의 문서에서는 GPT가 이를 생성하는 데 도움을 주기 위해 프롬프트에 \"JSON\"이라는 단어를 명확하게 작성할 것을 제안합니다. 이는 \"response_format={ \"type\": \"json_object\" }\"를 사용할 때 프롬프트 어딘가에 이를 작성해야만 하는 중요한 팁이기 때문에 강제적으로 작성해야 합니다.\u003c/p\u003e\n\u003ch2\u003eLLM이 일관된 JSON 출력을 생성하기 어려운 이유는 무엇인가요?\u003c/h2\u003e\n\u003cp\u003eLLM은 입력 프롬프트가 주어졌을 때 이전 토큰 다음에 더 많이 나올 가능성이 있는 다음 토큰을 반환하는 기계로서의 역할을 합니다. 실제로 이러한 형식을 보고 이해하려면 모델이 훈련 단계에서 명시적으로 이러한 형식을 보고 이해하기 위해 안내받아야만 하므로 이러한 패턴을 \"자연\"에서 만나기 어렵습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e최신 LLM의 JSON 모드는 출력이 특정 패턴과 일치한다고 보장하지 않습니다. 단지 유효하고 오류 없이 파싱된다는 것만을 보장합니다.\u003c/p\u003e\n\u003cp\u003e따라서 이러한 출력물 안에 무엇이 포함되어 있는지를 유효성 검사할 수 있고, 데이터 모델과 일치하지 않는 경우 예외와 오류를 발생시키는 것이 중요합니다.\u003c/p\u003e\n\u003ch1\u003e사용 사례\u003c/h1\u003e\n\u003cp\u003e우리는 GPT-4 또는 Llama3와 같은 LLM에 간단한 질문에서 시작하여 JSON에서 정보를 추출하는 예제를 살펴볼 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리는 무엇이든 물어볼 수 있지만, 모델에게 시간이 지남에 따른 축구 월드컵 우승팀에 관한 질문을 하려고 합니다.\u003c/p\u003e\n\u003cp\u003e특히 우리는 다음을 추출하고 싶습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e결승 일자\u003c/li\u003e\n\u003cli\u003e대회의 개최 국가\u003c/li\u003e\n\u003cli\u003e우승 팀\u003c/li\u003e\n\u003cli\u003e최다 득점자\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e우리는 데이터의 정확성을 확인하는 것이 아니라, LLM의 문장 응답을 다음으로 보여줄 스키마에 맞추는 것에만 신경을 쓸 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 기사에서는 이 예제를 살펴보고 다른 것들도 살펴볼 수 있을 것 같아요.\u003c/p\u003e\n\u003ch2\u003e필수 종속성\u003c/h2\u003e\n\u003cp\u003e이제 이 튜토리얼을 실행하기 위해 설치해야 할 종속성을 살펴봅시다.\u003c/p\u003e\n\u003cp\u003e당연히, 이미 활성화된 개발 환경이 있다고 가정하고 Pydantic, Instructor, OpenAI 클라이언트 및 ollama를 설치할 거예요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003ePydantic: 커뮤니티에서 널리 사용되는 데이터 모델 정의 및 유효성 검사 라이브러리로, 사용 편의성, 효율성 및 데이터 과학에서의 중요성으로 유명합니다.\u003c/li\u003e\n\u003cli\u003eInstructor: LLMs와 작업하기 위해 특별히 제작된 Pydantic을 감싸는 래퍼로, 유효성 검사 로직을 생성할 수 있는 라이브러리입니다.\u003c/li\u003e\n\u003cli\u003eOpenAI: GPT와 다른 OpenAI 모델에 쿼리를 요청하기 위한 유명한 클라이언트입니다.\u003c/li\u003e\n\u003cli\u003eollama: llama3와 같은 오픈 소스 LLM에 대한 매우 편리한 인터페이스입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e개발 환경에서는 다음 명령어를 사용하여 시작합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003epip install pydantic instructor openai ollama\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e오픈 소스 모델을 테스트하고자 하기 때문에 다음 단계는 ollama를 시스템 전역에 설치하는 것입니다. ollama의 설치 및 사용 방법은 이 특별한 기사에서 읽어보실 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 개발에 집중할 수 있겠네요.\u003c/p\u003e\n\u003ch2\u003e데이터 모델 정의\u003c/h2\u003e\n\u003cp\u003e데이터 모델은 데이터를 구조화하기 위해 따를 논리적인 패턴입니다. 데이터베이스의 테이블을 정의하는 것부터 입력 데이터를 유효성 검사하는 데까지 여러 맥락에서 사용됩니다.\u003c/p\u003e\n\u003cp\u003e아래 포스트에서 Pydantic을 활용한 데이터 과학과 머신러닝에서의 데이터 모델링에 대해 이미 약간 다룬 적이 있습니다 👇\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e파이던틱 데이터 모델을 만들어 보면 좋겠어요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e pydantic \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eField\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e typing \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e datetime\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSoccerData\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003edate_of_final\u003c/span\u003e: datetime.\u003cspan class=\"hljs-property\"\u003edate\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eField\u003c/span\u003e(..., description=\u003cspan class=\"hljs-string\"\u003e\"최종 이벤트 날짜\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-attr\"\u003ehosting_country\u003c/span\u003e: str = \u003cspan class=\"hljs-title class_\"\u003eField\u003c/span\u003e(..., description=\u003cspan class=\"hljs-string\"\u003e\"대회를 개최하는 국가\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-attr\"\u003ewinner\u003c/span\u003e: str = \u003cspan class=\"hljs-title class_\"\u003eField\u003c/span\u003e(..., description=\u003cspan class=\"hljs-string\"\u003e\"최종 경기에서 우승한 축구팀\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-attr\"\u003etop_scorers\u003c/span\u003e: list = \u003cspan class=\"hljs-title class_\"\u003eField\u003c/span\u003e(\n        ..., description=\u003cspan class=\"hljs-string\"\u003e\"대회의 상위 3명 스코어러 목록\"\u003c/span\u003e\n    )\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSoccerDataset\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003ereports\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e[\u003cspan class=\"hljs-title class_\"\u003eSoccerData\u003c/span\u003e] = []\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 스크립트에서는 Pydantic에서 BaseModel 및 Field 클래스를 가져와 데이터 모델을 만드는 작업을 시작합니다. 사실, 최종 결과가 가져야 할 구조를 만들고 있습니다.\u003c/p\u003e\n\u003cp\u003ePydantic은 모델에 들어가는 데이터 유형을 선언해야 합니다. 예를 들어 datetime.date는 날짜 필드가 문자열이 아니라 날짜여야 함을 강제합니다. 동시에 top_scorers 필드는 반드시 목록이어야 하며, 그렇지 않으면 Pydantic이 유효성 검사 오류를 반환할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e마침내, 여러 인스턴스를 수집하는 데이터 모델을 만들었습니다. 이것은 SoccerData 모델의 모음을 수집하는 SoccerDataset이라고 합니다. 이 모델은 한 개 이상의 보고서가 있는지 확인하기 위해 강사에 의해 사용될 것입니다.\u003c/p\u003e\n\u003ch1\u003e시스템 프롬프트 생성\u003c/h1\u003e\n\u003cp\u003e매우 간단히, 모델이 수행해야 하는 작업을 영어로 적어봅시다. 예를 통해 결과의 의도와 구조를 강조하면서 설명합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esystem_prompt = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"당신은 숙련된 스포츠 기자입니다. 특정 연도의 축구 월드컵에서 우승한 팀에 대한 작은 리포트를 작성할 것입니다. 대회 결승전 날짜, 대회 전체에서 상위 3 스코어러, 우승 팀, 그리고 대회를 주최한 국가를 보고합니다. 다음 필드를 포함하는 JSON 객체를 반환하세요: date_of_final, hosting_country, winner, top_scorers.\\\n \n만약 다수 연도가 입력되면, 보고서를 쉼표로 구분하세요.\\\n \n다음은 예시입니다.\n [\n    {\n        \"\u003c/span\u003edate_of_final\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e1966\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\",\n        \"\u003c/span\u003ehosting_country\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003eEngland\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\",\n        \"\u003c/span\u003ewinner\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003eEngland\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\",\n        \"\u003c/span\u003etop_scorers\u003cspan class=\"hljs-string\"\u003e\": [\"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e A\u003cspan class=\"hljs-string\"\u003e\", \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e B\u003cspan class=\"hljs-string\"\u003e\", \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e C\u003cspan class=\"hljs-string\"\u003e\"]\n    },\n    {\n        \"\u003c/span\u003edate_of_final\u003cspan class=\"hljs-string\"\u003e\": ...\n        \"\u003c/span\u003ehosting_country\u003cspan class=\"hljs-string\"\u003e\": ...\n        \"\u003c/span\u003ewinner\u003cspan class=\"hljs-string\"\u003e\": ...\n        \"\u003c/span\u003etop_scorers\u003cspan class=\"hljs-string\"\u003e\": ...\n    },\n\n]\n\n다음 연도들에 대해 보고해야 할 것입니다:\n\n \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e시스템 프롬프트로 사용되며 단순히 쉼표로 구분된 연도를 전달할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e강사 코드 생성\u003c/h1\u003e\n\u003cp\u003e여기서는 Instructor를 사용하여 JSON 유효성 검사 및 구조화의 주요 로직을 만들 것입니다. 이를 통해 GPT를 API를 통해 호출하는 OpenAI에서 제공하는 인터페이스와 유사한 인터페이스를 사용합니다.\u003c/p\u003e\n\u003cp\u003e먼저 우리는 query_gpt라는 함수를 사용하여 OpenAI를 사용하여 프롬프트를 매개변수화할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e openai \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e instructor\n\ndef \u003cspan class=\"hljs-title function_\"\u003equery_gpt\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eprompt\u003c/span\u003e: str) -\u003e \u003cspan class=\"hljs-attr\"\u003elist\u003c/span\u003e:\n    client = instructor.\u003cspan class=\"hljs-title function_\"\u003efrom_openai\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e(api_key=\u003cspan class=\"hljs-string\"\u003e\"...\"\u003c/span\u003e))\n    resp = client.\u003cspan class=\"hljs-property\"\u003echat\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecompletions\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\n        model=\u003cspan class=\"hljs-string\"\u003e\"gpt-3.5-turbo\"\u003c/span\u003e,\n        response_model=\u003cspan class=\"hljs-title class_\"\u003eSoccerDataset\u003c/span\u003e,\n        messages=[\n            {\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: system_prompt},\n            {\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: prompt},\n        ],\n    )\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e resp.\u003cspan class=\"hljs-title function_\"\u003emodel_dump_json\u003c/span\u003e(indent=\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOpenAI API 키를 새롭게 생성된 클라이언트에 전달하는 것을 잊지 말자. 우리는 GPT-3.5-Turbo를 사용하고, 응답 모델로 SoccerDataset을 전달할 것이다. 또한, 이 기사를 작성하는 시점에서 가장 강력한 모델인 \"gpt-4o\"를 사용할 수도 있다.\u003c/p\u003e\n\u003cp\u003e모든 것을 함께 조합하여 소프트웨어를 실행해 보자. 사용자 프롬프트로 입력할 내용으로 \"2010, 2014 및 2018\"년을 내용으로 전달하여 구조화된 보고서를 생성하고자 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e openai \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e instructor\n\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e typing \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e pydantic \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eField\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e datetime\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSoccerData\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003edate_of_final\u003c/span\u003e: datetime.\u003cspan class=\"hljs-property\"\u003edate\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eField\u003c/span\u003e(..., description=\u003cspan class=\"hljs-string\"\u003e\"최종 이벤트의 날짜\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-attr\"\u003ehosting_country\u003c/span\u003e: str = \u003cspan class=\"hljs-title class_\"\u003eField\u003c/span\u003e(..., description=\u003cspan class=\"hljs-string\"\u003e\"대회를 주최하는 나라\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-attr\"\u003ewinner\u003c/span\u003e: str = \u003cspan class=\"hljs-title class_\"\u003eField\u003c/span\u003e(..., description=\u003cspan class=\"hljs-string\"\u003e\"최종 경기에서 승리한 축구팀\"\u003c/span\u003e)\n    \u003cspan class=\"hljs-attr\"\u003etop_scorers\u003c/span\u003e: list = \u003cspan class=\"hljs-title class_\"\u003eField\u003c/span\u003e(\n        ..., description=\u003cspan class=\"hljs-string\"\u003e\"대회의 상위 3명의 득점수 리스트\"\u003c/span\u003e\n    )\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSoccerDataset\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBaseModel\u003c/span\u003e):\n    \u003cspan class=\"hljs-attr\"\u003ereports\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e[\u003cspan class=\"hljs-title class_\"\u003eSoccerData\u003c/span\u003e] = []\n\n\nsystem_prompt = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"당신은 전문 스포츠 기자입니다. 특정 연도의 축구 월드컵에서 승자를 작은 보고서로 작성해야 합니다.\n대회 최종일, 대회의 전체 득점수 상위 3명, 우승 팀 및 대회를 개최하는 국가를 보고해야 합니다.\n다음 필드를 포함한 JSON 객체를 반환하세요: date_of_final, hosting_country, winner, top_scorers.\n\n쿼리가 유효하지 않은 경우 빈 보고서를 반환하세요.\n\n여러 연도가 입력된 경우 보고서를 쉼표로 구분하세요.\n\n예시입니다\n[\n    {\n        \"\u003c/span\u003edate_of_final\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e1966\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\",\n        \"\u003c/span\u003ehosting_country\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003eEngland\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\",\n        \"\u003c/span\u003ewinner\u003cspan class=\"hljs-string\"\u003e\": \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003eEngland\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\",\n        \"\u003c/span\u003etop_scorers\u003cspan class=\"hljs-string\"\u003e\": [\"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e A\u003cspan class=\"hljs-string\"\u003e\", \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e B\u003cspan class=\"hljs-string\"\u003e\", \"\u003c/span\u003e\u003cspan class=\"hljs-title class_\"\u003ePlayer\u003c/span\u003e C\u003cspan class=\"hljs-string\"\u003e\"]\n    },\n    {\n        \"\u003c/span\u003edate_of_final\u003cspan class=\"hljs-string\"\u003e\": ...\n        \"\u003c/span\u003ehosting_country\u003cspan class=\"hljs-string\"\u003e\": ...\n        \"\u003c/span\u003ewinner\u003cspan class=\"hljs-string\"\u003e\": ...\n        \"\u003c/span\u003etop_scorers\u003cspan class=\"hljs-string\"\u003e\": ...\n    },\n\n]\n\n다음 보고가 필요한 연도입니다:\n\n\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\ndef \u003cspan class=\"hljs-title function_\"\u003equery_gpt\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eprompt\u003c/span\u003e: str) -\u003e \u003cspan class=\"hljs-attr\"\u003elist\u003c/span\u003e:\n    client = instructor.\u003cspan class=\"hljs-title function_\"\u003efrom_openai\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e())\n    resp = client.\u003cspan class=\"hljs-property\"\u003echat\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecompletions\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\n        model=\u003cspan class=\"hljs-string\"\u003e\"gpt-3.5-turbo\"\u003c/span\u003e,\n        response_model=\u003cspan class=\"hljs-title class_\"\u003eSoccerDataset\u003c/span\u003e,\n        messages=[\n            {\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: system_prompt},\n            {\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: prompt},\n        ],\n    )\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e resp.\u003cspan class=\"hljs-title function_\"\u003emodel_dump_json\u003c/span\u003e(indent=\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main__\"\u003c/span\u003e:\n  resp = \u003cspan class=\"hljs-title function_\"\u003equery_llm\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"2010, 2014, 2018\"\u003c/span\u003e)\n  \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(resp)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위 문구를 Markdown 형식으로 변환한 결과입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-json\"\u003e\u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003e\"reports\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\n        \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003e\"date_of_final\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"2010-07-11\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003e\"hosting_country\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"South Africa\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003e\"winner\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Spain\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003e\"top_scorers\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\n                \u003cspan class=\"hljs-string\"\u003e\"Thomas Müller\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n                \u003cspan class=\"hljs-string\"\u003e\"David Villa\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n                \u003cspan class=\"hljs-string\"\u003e\"Wesley Sneijder\"\u003c/span\u003e\n            \u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\n        \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003e\"date_of_final\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"2014-07-13\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003e\"hosting_country\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Brazil\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003e\"winner\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Germany\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003e\"top_scorers\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\n                \u003cspan class=\"hljs-string\"\u003e\"James Rodríguez\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n                \u003cspan class=\"hljs-string\"\u003e\"Thomas Müller\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n                \u003cspan class=\"hljs-string\"\u003e\"Neymar\"\u003c/span\u003e\n            \u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\n        \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"hljs-punctuation\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003e\"date_of_final\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"2018-07-15\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003e\"hosting_country\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Russia\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003e\"winner\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"France\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"hljs-attr\"\u003e\"top_scorers\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"hljs-punctuation\"\u003e[\u003c/span\u003e\n                \u003cspan class=\"hljs-string\"\u003e\"Harry Kane\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n                \u003cspan class=\"hljs-string\"\u003e\"Antoine Griezmann\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n                \u003cspan class=\"hljs-string\"\u003e\"Romelu Lukaku\"\u003c/span\u003e\n            \u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\n        \u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"hljs-punctuation\"\u003e]\u003c/span\u003e\n\u003cspan class=\"hljs-punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e멋지네요. GPT-3.5-Turbo가 우리의 지시를 완벽하게 따르고, Instructor가 데이터 모델과 일치하는 구조를 만들어내었습니다. 실제로 이 결과는 GPT와 같은 대형 언어 모델이 일반적으로 반환하는 문자열이 아니라, 파이썬 사전의 리스트입니다.\u003c/p\u003e\n\u003cp\u003e이제 이상한 입력을 넣어보려고 해봅시다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main()\"\u003c/span\u003e:\n      \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003equery_gpt\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"안녕, 어떻게 지내?\"\u003c/span\u003e))\n\n\u003e\u003e\u003e\n{\n \u003cspan class=\"hljs-string\"\u003e\"리포트\"\u003c/span\u003e: []\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLLM은 시스템 프롬프트를 통해 잘못된 쿼리를 처리하는 방법을 요청했기 때문에 올바르게 비어있는 리포트를 반환합니다.\u003c/p\u003e\n\u003ch1\u003eInstructor와 함께 오픈 소스 템플릿 사용\u003c/h1\u003e\n\u003cp\u003eInstructor를 사용하여 GPT를 어떻게 사용하여 구조화된 JSON 출력을 얻는지 알아보았습니다. 이제 llama3와 같은 오픈 소스 템플릿을 사용하는 방법을 살펴보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e새로운 함수인 query_llama을 생성해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003equery_llama\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eprompt\u003c/span\u003e: str) -\u003e \u003cspan class=\"hljs-attr\"\u003elist\u003c/span\u003e:\n    client = instructor.\u003cspan class=\"hljs-title function_\"\u003efrom_openai\u003c/span\u003e(\n        \u003cspan class=\"hljs-title class_\"\u003eOpenAI\u003c/span\u003e(\n            base_url=\u003cspan class=\"hljs-string\"\u003e\"http://localhost:11434/v1\"\u003c/span\u003e,\n            api_key=\u003cspan class=\"hljs-string\"\u003e\"ollama\"\u003c/span\u003e,  # 요청은 필요하지만 영향을 미치지 않습니다\n        ),\n        mode=instructor.\u003cspan class=\"hljs-property\"\u003eMode\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eJSON\u003c/span\u003e,\n    )\n    resp = client.\u003cspan class=\"hljs-property\"\u003echat\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecompletions\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\n        model=\u003cspan class=\"hljs-string\"\u003e\"llama3\"\u003c/span\u003e,\n        messages=[\n            {\n                \u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: system_prompt\n            },\n            {\n                \u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: prompt\n            }\n        ],\n        response_model=\u003cspan class=\"hljs-title class_\"\u003eSoccerDataset\u003c/span\u003e,\n    )\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e resp.\u003cspan class=\"hljs-title function_\"\u003emodel_dump_json\u003c/span\u003e(indent=\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGPT 코드와 약간의 차이가 있습니다. 함께 살펴보겠습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eollama는 GPT와 동일한 인터페이스를 통해 호출되지만, 기본 URL 포인터(base_url) 및 필수적이지만 올바른 작동에 필요하지 않은 API 키를 변경합니다(왜냐면 모르겠어요)\u003c/li\u003e\n\u003cli\u003eJSON 모드를 mode 매개변수를 통해 설명해야 합니다.\n새로운 함수를 실행해 봅시다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e함수를 실행해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"hljs-string\"\u003e\"__main__\"\u003c/span\u003e:\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003equery_llama\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"2010, 2014, 2018\"\u003c/span\u003e))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 여기에 결과가 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e{\n    \u003cspan class=\"hljs-string\"\u003e\"reports\"\u003c/span\u003e: [\n        {\n            \u003cspan class=\"hljs-string\"\u003e\"date_of_final\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"2010-07-11\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"hosting_country\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"South Africa\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"winner\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Spain\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"top_scorers\"\u003c/span\u003e: [\n                \u003cspan class=\"hljs-string\"\u003e\"Thomas Müller\"\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e\"Wolfram Toloi\"\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e\"Landon Donovan\"\u003c/span\u003e\n            ]\n        },\n        {\n            \u003cspan class=\"hljs-string\"\u003e\"date_of_final\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"2014-07-13\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"hosting_country\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Brazil\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"winner\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Germany\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"top_scorers\"\u003c/span\u003e: [\n                \u003cspan class=\"hljs-string\"\u003e\"James Rodríguez\"\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e\"Miroslav Klose\"\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e\"Thomas Müller\"\u003c/span\u003e\n            ]\n        },\n        {\n            \u003cspan class=\"hljs-string\"\u003e\"date_of_final\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"2018-07-15\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"hosting_country\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Russia\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"winner\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"France\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"top_scorers\"\u003c/span\u003e: [\n                \u003cspan class=\"hljs-string\"\u003e\"Harry Kane\"\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e\"Kylian Mbappé\"\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e\"Antoine Griezmann\"\u003c/span\u003e\n            ]\n        }\n    ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e우리는 올바른 JSON이 있는 목록을 가지고 있어요! 이 모든 것은 Llama 3로 로컬에서 이루어져요.\u003c/p\u003e\n\u003cp\u003e이전에 말한대로, 유효성 검사는 구조를 기반으로 하고 있어요. 실제로, 이 내용은 GPT에서 생성된 내용과 다를 수 있어요.\u003c/p\u003e\n\u003cp\u003e어떻게 마커들이 다른지 살펴봅시다. 아마도 우리가 받고 싶은 마커들을 명확히 지정하면 올바른 목록을 얻을 수도 있겠죠.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003ePydantic, Instructors, 그리고 ollama를 사용하여 LLM의 출력을 JSON과 같은 구조화된 형식으로 변환하는 방법을 살펴봤습니다.\u003c/p\u003e\n\u003cp\u003e이 과정에서 모델이 실제로 지도되므로 결정론적이지 않습니다. JSON이 LLM의 결정론적이지 않은 성질로 인해 준수되지 않을 수 있는 경우가 있을 것입니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-GuidinganLLMsResponsetoCreateStructuredOutput"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>