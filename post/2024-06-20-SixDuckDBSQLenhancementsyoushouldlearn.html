<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>여러분이 배워야 할 6가지 DuckDB SQL 향상 기능 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-20-SixDuckDBSQLenhancementsyoushouldlearn" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="여러분이 배워야 할 6가지 DuckDB SQL 향상 기능 | itposting" data-gatsby-head="true"/><meta property="og:title" content="여러분이 배워야 할 6가지 DuckDB SQL 향상 기능 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-SixDuckDBSQLenhancementsyoushouldlearn_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-20-SixDuckDBSQLenhancementsyoushouldlearn" data-gatsby-head="true"/><meta name="twitter:title" content="여러분이 배워야 할 6가지 DuckDB SQL 향상 기능 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-SixDuckDBSQLenhancementsyoushouldlearn_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 15:45" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_buildManifest.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">여러분이 배워야 할 6가지 DuckDB SQL 향상 기능</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="여러분이 배워야 할 6가지 DuckDB SQL 향상 기능" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-SixDuckDBSQLenhancementsyoushouldlearn&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-20-SixDuckDBSQLenhancementsyoushouldlearn_0.png" alt="Image"></p>
<p>DuckDB의 SQL은 원래 PostgreSQL을 기반으로 하였으며, 이는 모방하기에 좋은 SQL 버전입니다. 그러나 시간이 흐름에 따라 DuckDB는 SQL 제공에 몇 가지 유용한 추가 기능을 도입하여 여러분의 삶을 조금 더 쉽게 만들었습니다. 다른 보다 인기 있는 RDBMS들이 언젠가는 이러한 유용한 SQL 확장을 본뜬다면 전혀 놀라지 않을 것입니다.</p>
<p>DuckDB에 대해 들어보지 못한 분들을 위해, 이는 C++로 작성된 인메모리 데이터베이스로서 분석용 SQL 워크로드를 위해 설계되었습니다. 또한 Polars와 같은 성능으로 빠르며 경쟁력이 있습니다.</p>
<p>아래 링크를 통해 DuckDB의 기능에 대해 깊이 있는 탐구를 해보세요.</p>
<div class="content-ad"></div>
<p>알겠어요. 이 기사에 나온 유용한 SQL 명령어 몇 가지를 살펴봐요.</p>
<h2>1. 정규 표현식을 사용한 동적 열 선택</h2>
<p>정규 표현식을 사용한 동적 열 선택을 통해 쿼리할 때 테이블에 포함된 정확한 열 이름을 사용할 필요가 없어져요. 이는 쿼리에서 유용한 단축키로 이어질 수 있어요.</p>
<p>대신, COLUMNS() 키워드를 사용하고 해당 키워드와 적합한 와일드카드를 함께 사용하여 열 이름에 와일드카드 표현식을 넣을 수 있어요. DuckDB는 COLUMNS() 표현식 내에서 와일드카드와 일치하는 열에 대한 데이터만 검색해 줄 거예요.</p>
<div class="content-ad"></div>
<p>아래와 같이 테이블이 있다고 가정해 봅시다.</p>
<pre><code class="hljs language-js">db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"CREATE TABLE departments (department varchar, exmployee_count INT, average_salary INT, max_salary INT, min_salary INT)"</span>)

db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"INSERT INTO departments VALUES ('영업', 300, 25000, 40000, 19000), ('인사', 50, 22000, 50000, 18500)"</span>);

db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"SELECT * FROM departments"</span>)
</code></pre>
<p>위와 같이, 예를 들어 부서와 최저/최고 급여만 가져오고 싶다면 다음과 같이 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"># average_salary와 employee_count 열을 제외
db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"SELECT department, COLUMNS('m.*salary') FROM departments"</span>)
</code></pre>
<div class="content-ad"></div>
<p>WHERE 절에서 COLUMNS 식을 사용하여 DuckDB는 와일드카드에서 나온 각 식 사이에 암시적 AND를 넣을 것입니다. 예를 들어,</p>
<pre><code class="hljs language-js">db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"SELECT department, COLUMNS('m.*salary') FROM departments \
       WHERE COLUMNS('m.*salary') >= 19000"</span>)

# 위 <span class="hljs-variable constant_">WHERE</span> 절은 다음과 동일합니다.
# <span class="hljs-variable constant_">WHERE</span> max_salary >= <span class="hljs-number">19000</span> <span class="hljs-variable constant_">AND</span> min_salary >= <span class="hljs-number">19000</span>
#

| department | max_salary | min_salary |
|  varchar   |   int32    |   int32    |
|------------|------------|------------|
| <span class="hljs-title class_">Sales</span>      |      <span class="hljs-number">40000</span> |      <span class="hljs-number">19000</span> |

</code></pre>
<p>컬럼에 계산을 적용할 때도 이 구문을 사용할 수 있습니다. 부서 데이터 세트를 사용하면서, 컬럼에 대한 몇 가지 집계를 수행하려면 다음과 같이 할 수 있습니다.</p>
<pre><code class="hljs language-js">db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"SELECT MAX(COLUMNS('m.*salary')) FROM departments"</span>)

| <span class="hljs-title function_">max</span>(departments.<span class="hljs-property">max_salary</span>) | <span class="hljs-title function_">max</span>(departments.<span class="hljs-property">min_salary</span>) |
|            int32             |            int32            |
|----------------------------- |-----------------------------|
|             <span class="hljs-number">50000</span>            |             <span class="hljs-number">19000</span>          |
</code></pre>
<div class="content-ad"></div>
<h2>2. 피벗/언피벗</h2>
<p>관계형 데이터베이스 시스템에서 가장 어려운 작업 중 하나인 데이터 집합을 피벗하고 언피벗하는 기능을 활용하면 데이터 분석이 훨씬 쉬워질 수 있어요.</p>
<p>먼저 테스트 테이블 데이터를 설정해봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> duckdb <span class="hljs-keyword">as</span> db

db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"CREATE TABLE purchases (productID int, year INT, sales INT)"</span>)

db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"INSERT INTO purchases VALUES (12345, 2019, 15000), (12345,2020, 19500), (12345, 2021, 22000), (987654, 2019, 510), (987654,2020, 1900), (987654, 2021, 2100)"</span>)

db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"SELECT * FROM purchases"</span>)
</code></pre>








































<table><thead><tr><th>productID</th><th>year</th><th>sales</th></tr></thead><tbody><tr><td>12345</td><td>2019</td><td>15000</td></tr><tr><td>12345</td><td>2020</td><td>19500</td></tr><tr><td>12345</td><td>2021</td><td>22000</td></tr><tr><td>987654</td><td>2019</td><td>510</td></tr><tr><td>987654</td><td>2020</td><td>1900</td></tr><tr><td>987654</td><td>2021</td><td>2100</td></tr></tbody></table>
<div class="content-ad"></div>
<p>요청하신 데이터가 아래와 같이 보이도록 하겠습니다.</p>
<pre><code class="hljs language-js">┌───────────┬────────┬────────┬────────┐
│ productID │  <span class="hljs-number">2019</span>  │  <span class="hljs-number">2020</span>  │  <span class="hljs-number">2021</span>  │
│   int32   │ int128 │ int128 │ int128 │
├───────────┼────────┼────────┼────────┤
│     <span class="hljs-number">12345</span> │  <span class="hljs-number">15000</span> │  <span class="hljs-number">19500</span> │  <span class="hljs-number">22000</span> │
│    <span class="hljs-number">987654</span> │    <span class="hljs-number">510</span> │   <span class="hljs-number">1900</span> │   <span class="hljs-number">2100</span> │
└───────────┴────────┴────────┴────────┘
</code></pre>
<p>이를 위해 PIVOT를 사용할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> duckdb <span class="hljs-keyword">as</span> db


db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"create table pivoted_purchases as PIVOT purchases ON year USING SUM(sales)  GROUP BY productID"</span>)
db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"SELECT * FROM pivoted_purchases"</span>)

# <span class="hljs-variable constant_">PIVOT</span>에 기반한 테이블을 생성하고 싶지 않을 경우 
# 단순히 값을 표시하고 싶으면 이렇게도 할 수 있습니다
# db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"PIVOT purchases ON year USING SUM(sales)  GROUP BY productID"</span>)

┌───────────┬────────┬────────┬────────┐
│ productID │  <span class="hljs-number">2019</span>  │  <span class="hljs-number">2020</span>  │  <span class="hljs-number">2021</span>  │
│   int32   │ int128 │ int128 │ int128 │
├───────────┼────────┼────────┼────────┤
│     <span class="hljs-number">12345</span> │  <span class="hljs-number">15000</span> │  <span class="hljs-number">19500</span> │  <span class="hljs-number">22000</span> │
│    <span class="hljs-number">987654</span> │    <span class="hljs-number">510</span> │   <span class="hljs-number">1900</span> │   <span class="hljs-number">2100</span> │
└───────────┴────────┴────────┴────────┘
</code></pre>
<div class="content-ad"></div>
<p>PIVOT 명령어에서 수행한 SUM(salary) 집계는 숫자 데이터를 전혀 변경하지 않았기 때문에 이 프로세스를 UNPIVOT 및 이미 이야기한 COLUMNS 기능을 사용하여 반대로도 수행할 수 있습니다.</p>
<pre><code class="hljs language-js">db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"UNPIVOT pivoted_purchases ON COLUMNS(* EXCLUDE productID) INTO NAME year VALUE sales"</span>)

| productID |  year   | sales  |
|   int32   | varchar | int128 |
|-----------|---------|--------|
|    <span class="hljs-number">12345</span>  |  <span class="hljs-number">2019</span>   | <span class="hljs-number">15000</span>  |
|    <span class="hljs-number">12345</span>  |  <span class="hljs-number">2020</span>   | <span class="hljs-number">19500</span>  |
|    <span class="hljs-number">12345</span>  |  <span class="hljs-number">2021</span>   | <span class="hljs-number">22000</span>  |
|   <span class="hljs-number">987654</span>  |  <span class="hljs-number">2019</span>   |  <span class="hljs-number">510</span>   |
|   <span class="hljs-number">987654</span>  |  <span class="hljs-number">2020</span>   |  <span class="hljs-number">1900</span>  |
|   <span class="hljs-number">987654</span>  |  <span class="hljs-number">2021</span>   |  <span class="hljs-number">2100</span>  |
</code></pre>
<h2>3. Union 데이터 유형</h2>
<p>이제 서로 다른 데이터 유형을 유니언할 수 있습니다. 네, 들으신 대로, 제 SQL 고통 중 하나가 사라졌습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"SELECT '나는 문자열입니다' as col1 union select 100 union select 42.0"</span>)



┌───────────────┐
│     col1      │
│    varchar    │
├───────────────┤
│ 나는 문자열입니다 │
│ <span class="hljs-number">42.0</span>          │
│ <span class="hljs-number">100</span>           │
└───────────────┘
</code></pre>
<p>DuckDB는 서로 다른 데이터 유형을 가져오는 모든 유형을 지원하는 "가장 낮은 공통 분모"로 강제로 변환합니다. 여기서 FLOAT 및 INT 열 값은 VARCHAR로 강제 변환됩니다.</p>
<h2>4. 재사용 가능한 열 별칭</h2>
<p>전통적인 SQL에서는 select 문 내에서 점진적으로 계산된 표현식을 처리할 때 일반적으로 각 열에 대해 전체 표현식을 복제하거나 각 계산 단계를 공통 테이블 표현식(CTE)으로 캡슐화해야 합니다. 그러나 재사용 가능한 열 별칭을 사용하면 이제 열 별칭을 동일한 select 문 전체에서 사용할 수 있으며, where 및 order by 절에서도 사용할 수 있어 프로세스를 간소화하고 중복을 줄일 수 있습니다. 예를 들어,</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"SELECT 'The quick brown fox jumped over the lazy dog' AS my_text,\
substring(my_text, 17,3) AS my_text_substr,\
length(my_text) AS my_text_len,\
my_text_len * my_text_len AS my_text_calc"</span>)

## <span class="hljs-number">5.</span> 리스트 내포

이 기능은 파이썬 스타일의 리스트 내포를 모델로 하며, 리스트 내 요소들에 대한 표현식을 계산하는 데 사용할 수 있습니다. 예를 들어, 다음과 같이 숫자 목록이 있는 경우:

[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]
</code></pre>
<div class="content-ad"></div>
<p>파이썬에서는 우리가 원한다면, 위의 리스트의 각 숫자를 제곱하여 두 번째 리스트를 출력하고 싶다면 다음과 같이 진행될 것입니다.</p>
<pre><code class="hljs language-js">[x*x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]]


# 위의 파이썬 코드는 다음과 같은 출력을 생성합니다
#
# [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]
</code></pre>
<p>DuckDB SQL에서도 매우 유사한 작업을 수행할 수 있습니다.</p>
<pre><code class="hljs language-js">db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"SELECT [x*x for x in nums] as squares FROM (VALUES ([1,2,3,4,5,6,7,8,9])) t(nums)"</span>)



┌───────────────────────────────────┐
│              squares              │
│              int32[]              │
├───────────────────────────────────┤
│ [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>] │
└───────────────────────────────────┘
</code></pre>
<div class="content-ad"></div>
<p>쿼리를 분석해보면 무엇을 하는 지 이해할 수 있습니다:</p>
<p>다음 (VALUES([1,2,3,4,5,6,7,8,9])) t(nums)</p>
<ul>
<li>이 쿼리의 이 부분은 nums라는 단일 열을 갖는 임시 테이블 (또는 파생 테이블) t를 생성합니다.</li>
<li>VALUES 절은 리터럴 값을 제공하는 데 사용됩니다. 여기서는 1부터 9까지의 정수로 이루어진 목록(또는 배열)입니다.</li>
<li>t(nums)는 파생 테이블에 t라는 이름을 지어주고, 그 안의 배열을 포함하는 열을 nums로 명명한 부분입니다.</li>
</ul>
<p>다음과 같이 MARKDOWN 형식의 테이블 태그를 변경해 보세요:</p>
<p>SELECT [x*x for x in nums] as squares</p>
<div class="content-ad"></div>
<ul>
<li>이것은 계산이 발생하는 쿼리의 주요 부분입니다.</li>
<li>이 쿼리는 파이썬에서 일반적으로 볼 수 있는 작업인 리스트 내포 [x*x for x in nums]을 사용합니다. 이 문맥에서 nums 배열의 각 요소 x에 대해 x의 제곱을 계산합니다.</li>
<li>결과는 제곱된 값들의 배열입니다. 입력 배열에 대한 출력인 [1,2,3,4,5,6,7,8,9]는 [1,4,9,16,25,36,49,64,81]이 됩니다.</li>
<li>squares로 이 계산된 배열을 별칭 지어주고 있습니다.</li>
</ul>
<p>요약하자면, 이 쿼리는 1에서 9까지의 숫자 배열을 만든 다음, 각 숫자의 제곱을 계산하고 squares라는 배열로 결과를 반환합니다.</p>
<h2>6. 함수 체이닝</h2>
<p>DuckDB는 점 표기법(dot notation)을 사용하여 별도의 SQL 함수를 연결하는 것을 쉽게 만들어줍니다. 이렇게 하면 한 개의 SQL 문에서 함수 파이프라인을 구축할 수 있습니다.</p>
<div class="content-ad"></div>
<p>예를 들어, 많은 데이터베이스 시스템에서 INITCAP과 같은 이름의 SQL 함수가 있습니다. 이 함수는 텍스트 문자열의 모든 단어를 대문자로 만듭니다. 안타깝게도 DuckDB에는 이 기능이 내장되어 있지 않으므로, 우리는 함수 체이닝 (그리고 리스트 내포)을 사용하여 이를 흉내 내볼 수 있는지 살펴볼까요?</p>
<p>다음은 "the quick brown fox jumped over the lazy dog"이라는 문구에서 각 단어를 대문자로 바꾸고 싶을 때의 빠른 예제입니다.</p>
<pre><code class="hljs language-js">db.<span class="hljs-title function_">sql</span>(<span class="hljs-string">"SELECT ([upper(x[1])||x[2:] for x in \
('the quick brown fox jumped over the lazy dog')\
.string_split(' ')]).list_aggr('string_agg',' ') as final_str"</span>)


┌──────────────────────────────────────────────┐
│                  final_str                   │
│                   varchar                    │
├──────────────────────────────────────────────┤
│ <span class="hljs-title class_">The</span> <span class="hljs-title class_">Quick</span> <span class="hljs-title class_">Brown</span> <span class="hljs-title class_">Fox</span> <span class="hljs-title class_">Jumped</span> <span class="hljs-title class_">Over</span> <span class="hljs-title class_">The</span> <span class="hljs-title class_">Lazy</span> <span class="hljs-title class_">Dog</span> │
└──────────────────────────────────────────────┘
</code></pre>
<p>string_split 함수는 문구를 구성하는 개별 단어로 나누어주며, Python 리스트와 유사한 단어 목록을 생성합니다.</p>
<div class="content-ad"></div>
<p>[the, quick, brown, fox, jumped, over, the, lazy, dog]</p>
<p>다음으로, 우리는 단어 목록 위에 리스트 컴프리헨션을 실행합니다. 목록의 각 단어마다 첫 글자를 대문자로 설정한 후 단어의 나머지 부분을 연결합니다. 이것이 표현식의 upper(x[1])||x[2:] 부분이 하는 일입니다.</p>
<p>이후에 우리의 중간 단어 목록은 다음과 같이 됩니다,</p>
<p>[The, Quick, Brown, Fox, Jumped, Over, The, Lazy, Dog]</p>
<div class="content-ad"></div>
<p>위 단어 목록에 대해 list_agg 함수를 실행합니다. 이 함수는 단어 목록을 다시 단어 문자열로 변환하고 각 단어를 공백 문자로 분리합니다.</p>
<p>Medium은 이 두 기사의 내용이 특히 흥미롭다고 생각합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"여러분이 배워야 할 6가지 DuckDB SQL 향상 기능","description":"","date":"2024-06-20 15:45","slug":"2024-06-20-SixDuckDBSQLenhancementsyoushouldlearn","content":"\n\n\n![Image](/assets/img/2024-06-20-SixDuckDBSQLenhancementsyoushouldlearn_0.png)\n\nDuckDB의 SQL은 원래 PostgreSQL을 기반으로 하였으며, 이는 모방하기에 좋은 SQL 버전입니다. 그러나 시간이 흐름에 따라 DuckDB는 SQL 제공에 몇 가지 유용한 추가 기능을 도입하여 여러분의 삶을 조금 더 쉽게 만들었습니다. 다른 보다 인기 있는 RDBMS들이 언젠가는 이러한 유용한 SQL 확장을 본뜬다면 전혀 놀라지 않을 것입니다.\n\nDuckDB에 대해 들어보지 못한 분들을 위해, 이는 C++로 작성된 인메모리 데이터베이스로서 분석용 SQL 워크로드를 위해 설계되었습니다. 또한 Polars와 같은 성능으로 빠르며 경쟁력이 있습니다.\n\n아래 링크를 통해 DuckDB의 기능에 대해 깊이 있는 탐구를 해보세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n알겠어요. 이 기사에 나온 유용한 SQL 명령어 몇 가지를 살펴봐요.\n\n## 1. 정규 표현식을 사용한 동적 열 선택\n\n정규 표현식을 사용한 동적 열 선택을 통해 쿼리할 때 테이블에 포함된 정확한 열 이름을 사용할 필요가 없어져요. 이는 쿼리에서 유용한 단축키로 이어질 수 있어요.\n\n대신, COLUMNS() 키워드를 사용하고 해당 키워드와 적합한 와일드카드를 함께 사용하여 열 이름에 와일드카드 표현식을 넣을 수 있어요. DuckDB는 COLUMNS() 표현식 내에서 와일드카드와 일치하는 열에 대한 데이터만 검색해 줄 거예요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같이 테이블이 있다고 가정해 봅시다.\n\n```js\ndb.sql(\"CREATE TABLE departments (department varchar, exmployee_count INT, average_salary INT, max_salary INT, min_salary INT)\")\n\ndb.sql(\"INSERT INTO departments VALUES ('영업', 300, 25000, 40000, 19000), ('인사', 50, 22000, 50000, 18500)\");\n\ndb.sql(\"SELECT * FROM departments\")\n```\n\n위와 같이, 예를 들어 부서와 최저/최고 급여만 가져오고 싶다면 다음과 같이 사용할 수 있습니다.\n\n```js\n# average_salary와 employee_count 열을 제외\ndb.sql(\"SELECT department, COLUMNS('m.*salary') FROM departments\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nWHERE 절에서 COLUMNS 식을 사용하여 DuckDB는 와일드카드에서 나온 각 식 사이에 암시적 AND를 넣을 것입니다. 예를 들어,\n\n```js\ndb.sql(\"SELECT department, COLUMNS('m.*salary') FROM departments \\\n       WHERE COLUMNS('m.*salary') \u003e= 19000\")\n\n# 위 WHERE 절은 다음과 동일합니다.\n# WHERE max_salary \u003e= 19000 AND min_salary \u003e= 19000\n#\n\n| department | max_salary | min_salary |\n|  varchar   |   int32    |   int32    |\n|------------|------------|------------|\n| Sales      |      40000 |      19000 |\n\n```\n\n컬럼에 계산을 적용할 때도 이 구문을 사용할 수 있습니다. 부서 데이터 세트를 사용하면서, 컬럼에 대한 몇 가지 집계를 수행하려면 다음과 같이 할 수 있습니다.\n\n```js\ndb.sql(\"SELECT MAX(COLUMNS('m.*salary')) FROM departments\")\n\n| max(departments.max_salary) | max(departments.min_salary) |\n|            int32             |            int32            |\n|----------------------------- |-----------------------------|\n|             50000            |             19000          |\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 피벗/언피벗\n\n관계형 데이터베이스 시스템에서 가장 어려운 작업 중 하나인 데이터 집합을 피벗하고 언피벗하는 기능을 활용하면 데이터 분석이 훨씬 쉬워질 수 있어요.\n\n먼저 테스트 테이블 데이터를 설정해봅시다.\n\n```js\nimport duckdb as db\n\ndb.sql(\"CREATE TABLE purchases (productID int, year INT, sales INT)\")\n\ndb.sql(\"INSERT INTO purchases VALUES (12345, 2019, 15000), (12345,2020, 19500), (12345, 2021, 22000), (987654, 2019, 510), (987654,2020, 1900), (987654, 2021, 2100)\")\n\ndb.sql(\"SELECT * FROM purchases\")\n```\n\n\n| productID | year  | sales |\n|-----------|-------|-------|\n|     12345 |  2019 | 15000 |\n|     12345 |  2020 | 19500 |\n|     12345 |  2021 | 22000 |\n|    987654 |  2019 |   510 |\n|    987654 |  2020 |  1900 |\n|    987654 |  2021 |  2100 |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n요청하신 데이터가 아래와 같이 보이도록 하겠습니다.\n\n```js\n┌───────────┬────────┬────────┬────────┐\n│ productID │  2019  │  2020  │  2021  │\n│   int32   │ int128 │ int128 │ int128 │\n├───────────┼────────┼────────┼────────┤\n│     12345 │  15000 │  19500 │  22000 │\n│    987654 │    510 │   1900 │   2100 │\n└───────────┴────────┴────────┴────────┘\n```\n\n이를 위해 PIVOT를 사용할 수 있습니다.\n\n```js\nimport duckdb as db\n\n\ndb.sql(\"create table pivoted_purchases as PIVOT purchases ON year USING SUM(sales)  GROUP BY productID\")\ndb.sql(\"SELECT * FROM pivoted_purchases\")\n\n# PIVOT에 기반한 테이블을 생성하고 싶지 않을 경우 \n# 단순히 값을 표시하고 싶으면 이렇게도 할 수 있습니다\n# db.sql(\"PIVOT purchases ON year USING SUM(sales)  GROUP BY productID\")\n\n┌───────────┬────────┬────────┬────────┐\n│ productID │  2019  │  2020  │  2021  │\n│   int32   │ int128 │ int128 │ int128 │\n├───────────┼────────┼────────┼────────┤\n│     12345 │  15000 │  19500 │  22000 │\n│    987654 │    510 │   1900 │   2100 │\n└───────────┴────────┴────────┴────────┘\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPIVOT 명령어에서 수행한 SUM(salary) 집계는 숫자 데이터를 전혀 변경하지 않았기 때문에 이 프로세스를 UNPIVOT 및 이미 이야기한 COLUMNS 기능을 사용하여 반대로도 수행할 수 있습니다.\n\n```js\ndb.sql(\"UNPIVOT pivoted_purchases ON COLUMNS(* EXCLUDE productID) INTO NAME year VALUE sales\")\n\n| productID |  year   | sales  |\n|   int32   | varchar | int128 |\n|-----------|---------|--------|\n|    12345  |  2019   | 15000  |\n|    12345  |  2020   | 19500  |\n|    12345  |  2021   | 22000  |\n|   987654  |  2019   |  510   |\n|   987654  |  2020   |  1900  |\n|   987654  |  2021   |  2100  |\n```\n\n## 3. Union 데이터 유형\n\n이제 서로 다른 데이터 유형을 유니언할 수 있습니다. 네, 들으신 대로, 제 SQL 고통 중 하나가 사라졌습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndb.sql(\"SELECT '나는 문자열입니다' as col1 union select 100 union select 42.0\")\n\n\n\n┌───────────────┐\n│     col1      │\n│    varchar    │\n├───────────────┤\n│ 나는 문자열입니다 │\n│ 42.0          │\n│ 100           │\n└───────────────┘\n```\n\nDuckDB는 서로 다른 데이터 유형을 가져오는 모든 유형을 지원하는 \"가장 낮은 공통 분모\"로 강제로 변환합니다. 여기서 FLOAT 및 INT 열 값은 VARCHAR로 강제 변환됩니다.\n\n## 4. 재사용 가능한 열 별칭\n\n전통적인 SQL에서는 select 문 내에서 점진적으로 계산된 표현식을 처리할 때 일반적으로 각 열에 대해 전체 표현식을 복제하거나 각 계산 단계를 공통 테이블 표현식(CTE)으로 캡슐화해야 합니다. 그러나 재사용 가능한 열 별칭을 사용하면 이제 열 별칭을 동일한 select 문 전체에서 사용할 수 있으며, where 및 order by 절에서도 사용할 수 있어 프로세스를 간소화하고 중복을 줄일 수 있습니다. 예를 들어,\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndb.sql(\"SELECT 'The quick brown fox jumped over the lazy dog' AS my_text,\\\nsubstring(my_text, 17,3) AS my_text_substr,\\\nlength(my_text) AS my_text_len,\\\nmy_text_len * my_text_len AS my_text_calc\")\n\n## 5. 리스트 내포\n\n이 기능은 파이썬 스타일의 리스트 내포를 모델로 하며, 리스트 내 요소들에 대한 표현식을 계산하는 데 사용할 수 있습니다. 예를 들어, 다음과 같이 숫자 목록이 있는 경우:\n\n[1,2,3,4,5,6,7,8,9]\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬에서는 우리가 원한다면, 위의 리스트의 각 숫자를 제곱하여 두 번째 리스트를 출력하고 싶다면 다음과 같이 진행될 것입니다.\n\n```js\n[x*x for x in [1,2,3,4,5,6,7,8,9]]\n\n\n# 위의 파이썬 코드는 다음과 같은 출력을 생성합니다\n#\n# [1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\nDuckDB SQL에서도 매우 유사한 작업을 수행할 수 있습니다.\n\n```js\ndb.sql(\"SELECT [x*x for x in nums] as squares FROM (VALUES ([1,2,3,4,5,6,7,8,9])) t(nums)\")\n\n\n\n┌───────────────────────────────────┐\n│              squares              │\n│              int32[]              │\n├───────────────────────────────────┤\n│ [1, 4, 9, 16, 25, 36, 49, 64, 81] │\n└───────────────────────────────────┘\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쿼리를 분석해보면 무엇을 하는 지 이해할 수 있습니다:\n\n다음 (VALUES([1,2,3,4,5,6,7,8,9])) t(nums)\n\n- 이 쿼리의 이 부분은 nums라는 단일 열을 갖는 임시 테이블 (또는 파생 테이블) t를 생성합니다.\n- VALUES 절은 리터럴 값을 제공하는 데 사용됩니다. 여기서는 1부터 9까지의 정수로 이루어진 목록(또는 배열)입니다.\n- t(nums)는 파생 테이블에 t라는 이름을 지어주고, 그 안의 배열을 포함하는 열을 nums로 명명한 부분입니다.\n\n다음과 같이 MARKDOWN 형식의 테이블 태그를 변경해 보세요:\n\nSELECT [x*x for x in nums] as squares\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이것은 계산이 발생하는 쿼리의 주요 부분입니다.\n- 이 쿼리는 파이썬에서 일반적으로 볼 수 있는 작업인 리스트 내포 [x*x for x in nums]을 사용합니다. 이 문맥에서 nums 배열의 각 요소 x에 대해 x의 제곱을 계산합니다.\n- 결과는 제곱된 값들의 배열입니다. 입력 배열에 대한 출력인 [1,2,3,4,5,6,7,8,9]는 [1,4,9,16,25,36,49,64,81]이 됩니다.\n- squares로 이 계산된 배열을 별칭 지어주고 있습니다.\n\n요약하자면, 이 쿼리는 1에서 9까지의 숫자 배열을 만든 다음, 각 숫자의 제곱을 계산하고 squares라는 배열로 결과를 반환합니다.\n\n## 6. 함수 체이닝\n\nDuckDB는 점 표기법(dot notation)을 사용하여 별도의 SQL 함수를 연결하는 것을 쉽게 만들어줍니다. 이렇게 하면 한 개의 SQL 문에서 함수 파이프라인을 구축할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 많은 데이터베이스 시스템에서 INITCAP과 같은 이름의 SQL 함수가 있습니다. 이 함수는 텍스트 문자열의 모든 단어를 대문자로 만듭니다. 안타깝게도 DuckDB에는 이 기능이 내장되어 있지 않으므로, 우리는 함수 체이닝 (그리고 리스트 내포)을 사용하여 이를 흉내 내볼 수 있는지 살펴볼까요?\n\n다음은 \"the quick brown fox jumped over the lazy dog\"이라는 문구에서 각 단어를 대문자로 바꾸고 싶을 때의 빠른 예제입니다.\n\n```js\ndb.sql(\"SELECT ([upper(x[1])||x[2:] for x in \\\n('the quick brown fox jumped over the lazy dog')\\\n.string_split(' ')]).list_aggr('string_agg',' ') as final_str\")\n\n\n┌──────────────────────────────────────────────┐\n│                  final_str                   │\n│                   varchar                    │\n├──────────────────────────────────────────────┤\n│ The Quick Brown Fox Jumped Over The Lazy Dog │\n└──────────────────────────────────────────────┘\n```\n\nstring_split 함수는 문구를 구성하는 개별 단어로 나누어주며, Python 리스트와 유사한 단어 목록을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[the, quick, brown, fox, jumped, over, the, lazy, dog]\n\n다음으로, 우리는 단어 목록 위에 리스트 컴프리헨션을 실행합니다. 목록의 각 단어마다 첫 글자를 대문자로 설정한 후 단어의 나머지 부분을 연결합니다. 이것이 표현식의 upper(x[1])||x[2:] 부분이 하는 일입니다.\n\n이후에 우리의 중간 단어 목록은 다음과 같이 됩니다,\n\n[The, Quick, Brown, Fox, Jumped, Over, The, Lazy, Dog]\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위 단어 목록에 대해 list_agg 함수를 실행합니다. 이 함수는 단어 목록을 다시 단어 문자열로 변환하고 각 단어를 공백 문자로 분리합니다.\n\nMedium은 이 두 기사의 내용이 특히 흥미롭다고 생각합니다.","ogImage":{"url":"/assets/img/2024-06-20-SixDuckDBSQLenhancementsyoushouldlearn_0.png"},"coverImage":"/assets/img/2024-06-20-SixDuckDBSQLenhancementsyoushouldlearn_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-SixDuckDBSQLenhancementsyoushouldlearn_0.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003eDuckDB의 SQL은 원래 PostgreSQL을 기반으로 하였으며, 이는 모방하기에 좋은 SQL 버전입니다. 그러나 시간이 흐름에 따라 DuckDB는 SQL 제공에 몇 가지 유용한 추가 기능을 도입하여 여러분의 삶을 조금 더 쉽게 만들었습니다. 다른 보다 인기 있는 RDBMS들이 언젠가는 이러한 유용한 SQL 확장을 본뜬다면 전혀 놀라지 않을 것입니다.\u003c/p\u003e\n\u003cp\u003eDuckDB에 대해 들어보지 못한 분들을 위해, 이는 C++로 작성된 인메모리 데이터베이스로서 분석용 SQL 워크로드를 위해 설계되었습니다. 또한 Polars와 같은 성능으로 빠르며 경쟁력이 있습니다.\u003c/p\u003e\n\u003cp\u003e아래 링크를 통해 DuckDB의 기능에 대해 깊이 있는 탐구를 해보세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e알겠어요. 이 기사에 나온 유용한 SQL 명령어 몇 가지를 살펴봐요.\u003c/p\u003e\n\u003ch2\u003e1. 정규 표현식을 사용한 동적 열 선택\u003c/h2\u003e\n\u003cp\u003e정규 표현식을 사용한 동적 열 선택을 통해 쿼리할 때 테이블에 포함된 정확한 열 이름을 사용할 필요가 없어져요. 이는 쿼리에서 유용한 단축키로 이어질 수 있어요.\u003c/p\u003e\n\u003cp\u003e대신, COLUMNS() 키워드를 사용하고 해당 키워드와 적합한 와일드카드를 함께 사용하여 열 이름에 와일드카드 표현식을 넣을 수 있어요. DuckDB는 COLUMNS() 표현식 내에서 와일드카드와 일치하는 열에 대한 데이터만 검색해 줄 거예요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래와 같이 테이블이 있다고 가정해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"CREATE TABLE departments (department varchar, exmployee_count INT, average_salary INT, max_salary INT, min_salary INT)\"\u003c/span\u003e)\n\ndb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"INSERT INTO departments VALUES ('영업', 300, 25000, 40000, 19000), ('인사', 50, 22000, 50000, 18500)\"\u003c/span\u003e);\n\ndb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"SELECT * FROM departments\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같이, 예를 들어 부서와 최저/최고 급여만 가져오고 싶다면 다음과 같이 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# average_salary와 employee_count 열을 제외\ndb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"SELECT department, COLUMNS('m.*salary') FROM departments\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eWHERE 절에서 COLUMNS 식을 사용하여 DuckDB는 와일드카드에서 나온 각 식 사이에 암시적 AND를 넣을 것입니다. 예를 들어,\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"SELECT department, COLUMNS('m.*salary') FROM departments \\\n       WHERE COLUMNS('m.*salary') \u003e= 19000\"\u003c/span\u003e)\n\n# 위 \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e 절은 다음과 동일합니다.\n# \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e max_salary \u003e= \u003cspan class=\"hljs-number\"\u003e19000\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e min_salary \u003e= \u003cspan class=\"hljs-number\"\u003e19000\u003c/span\u003e\n#\n\n| department | max_salary | min_salary |\n|  varchar   |   int32    |   int32    |\n|------------|------------|------------|\n| \u003cspan class=\"hljs-title class_\"\u003eSales\u003c/span\u003e      |      \u003cspan class=\"hljs-number\"\u003e40000\u003c/span\u003e |      \u003cspan class=\"hljs-number\"\u003e19000\u003c/span\u003e |\n\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e컬럼에 계산을 적용할 때도 이 구문을 사용할 수 있습니다. 부서 데이터 세트를 사용하면서, 컬럼에 대한 몇 가지 집계를 수행하려면 다음과 같이 할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"SELECT MAX(COLUMNS('m.*salary')) FROM departments\"\u003c/span\u003e)\n\n| \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(departments.\u003cspan class=\"hljs-property\"\u003emax_salary\u003c/span\u003e) | \u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e(departments.\u003cspan class=\"hljs-property\"\u003emin_salary\u003c/span\u003e) |\n|            int32             |            int32            |\n|----------------------------- |-----------------------------|\n|             \u003cspan class=\"hljs-number\"\u003e50000\u003c/span\u003e            |             \u003cspan class=\"hljs-number\"\u003e19000\u003c/span\u003e          |\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e2. 피벗/언피벗\u003c/h2\u003e\n\u003cp\u003e관계형 데이터베이스 시스템에서 가장 어려운 작업 중 하나인 데이터 집합을 피벗하고 언피벗하는 기능을 활용하면 데이터 분석이 훨씬 쉬워질 수 있어요.\u003c/p\u003e\n\u003cp\u003e먼저 테스트 테이블 데이터를 설정해봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e duckdb \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e db\n\ndb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"CREATE TABLE purchases (productID int, year INT, sales INT)\"\u003c/span\u003e)\n\ndb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"INSERT INTO purchases VALUES (12345, 2019, 15000), (12345,2020, 19500), (12345, 2021, 22000), (987654, 2019, 510), (987654,2020, 1900), (987654, 2021, 2100)\"\u003c/span\u003e)\n\ndb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"SELECT * FROM purchases\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eproductID\u003c/th\u003e\u003cth\u003eyear\u003c/th\u003e\u003cth\u003esales\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e12345\u003c/td\u003e\u003ctd\u003e2019\u003c/td\u003e\u003ctd\u003e15000\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e12345\u003c/td\u003e\u003ctd\u003e2020\u003c/td\u003e\u003ctd\u003e19500\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e12345\u003c/td\u003e\u003ctd\u003e2021\u003c/td\u003e\u003ctd\u003e22000\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e987654\u003c/td\u003e\u003ctd\u003e2019\u003c/td\u003e\u003ctd\u003e510\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e987654\u003c/td\u003e\u003ctd\u003e2020\u003c/td\u003e\u003ctd\u003e1900\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e987654\u003c/td\u003e\u003ctd\u003e2021\u003c/td\u003e\u003ctd\u003e2100\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e요청하신 데이터가 아래와 같이 보이도록 하겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e┌───────────┬────────┬────────┬────────┐\n│ productID │  \u003cspan class=\"hljs-number\"\u003e2019\u003c/span\u003e  │  \u003cspan class=\"hljs-number\"\u003e2020\u003c/span\u003e  │  \u003cspan class=\"hljs-number\"\u003e2021\u003c/span\u003e  │\n│   int32   │ int128 │ int128 │ int128 │\n├───────────┼────────┼────────┼────────┤\n│     \u003cspan class=\"hljs-number\"\u003e12345\u003c/span\u003e │  \u003cspan class=\"hljs-number\"\u003e15000\u003c/span\u003e │  \u003cspan class=\"hljs-number\"\u003e19500\u003c/span\u003e │  \u003cspan class=\"hljs-number\"\u003e22000\u003c/span\u003e │\n│    \u003cspan class=\"hljs-number\"\u003e987654\u003c/span\u003e │    \u003cspan class=\"hljs-number\"\u003e510\u003c/span\u003e │   \u003cspan class=\"hljs-number\"\u003e1900\u003c/span\u003e │   \u003cspan class=\"hljs-number\"\u003e2100\u003c/span\u003e │\n└───────────┴────────┴────────┴────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이를 위해 PIVOT를 사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e duckdb \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e db\n\n\ndb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"create table pivoted_purchases as PIVOT purchases ON year USING SUM(sales)  GROUP BY productID\"\u003c/span\u003e)\ndb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"SELECT * FROM pivoted_purchases\"\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-variable constant_\"\u003ePIVOT\u003c/span\u003e에 기반한 테이블을 생성하고 싶지 않을 경우 \n# 단순히 값을 표시하고 싶으면 이렇게도 할 수 있습니다\n# db.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"PIVOT purchases ON year USING SUM(sales)  GROUP BY productID\"\u003c/span\u003e)\n\n┌───────────┬────────┬────────┬────────┐\n│ productID │  \u003cspan class=\"hljs-number\"\u003e2019\u003c/span\u003e  │  \u003cspan class=\"hljs-number\"\u003e2020\u003c/span\u003e  │  \u003cspan class=\"hljs-number\"\u003e2021\u003c/span\u003e  │\n│   int32   │ int128 │ int128 │ int128 │\n├───────────┼────────┼────────┼────────┤\n│     \u003cspan class=\"hljs-number\"\u003e12345\u003c/span\u003e │  \u003cspan class=\"hljs-number\"\u003e15000\u003c/span\u003e │  \u003cspan class=\"hljs-number\"\u003e19500\u003c/span\u003e │  \u003cspan class=\"hljs-number\"\u003e22000\u003c/span\u003e │\n│    \u003cspan class=\"hljs-number\"\u003e987654\u003c/span\u003e │    \u003cspan class=\"hljs-number\"\u003e510\u003c/span\u003e │   \u003cspan class=\"hljs-number\"\u003e1900\u003c/span\u003e │   \u003cspan class=\"hljs-number\"\u003e2100\u003c/span\u003e │\n└───────────┴────────┴────────┴────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003ePIVOT 명령어에서 수행한 SUM(salary) 집계는 숫자 데이터를 전혀 변경하지 않았기 때문에 이 프로세스를 UNPIVOT 및 이미 이야기한 COLUMNS 기능을 사용하여 반대로도 수행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"UNPIVOT pivoted_purchases ON COLUMNS(* EXCLUDE productID) INTO NAME year VALUE sales\"\u003c/span\u003e)\n\n| productID |  year   | sales  |\n|   int32   | varchar | int128 |\n|-----------|---------|--------|\n|    \u003cspan class=\"hljs-number\"\u003e12345\u003c/span\u003e  |  \u003cspan class=\"hljs-number\"\u003e2019\u003c/span\u003e   | \u003cspan class=\"hljs-number\"\u003e15000\u003c/span\u003e  |\n|    \u003cspan class=\"hljs-number\"\u003e12345\u003c/span\u003e  |  \u003cspan class=\"hljs-number\"\u003e2020\u003c/span\u003e   | \u003cspan class=\"hljs-number\"\u003e19500\u003c/span\u003e  |\n|    \u003cspan class=\"hljs-number\"\u003e12345\u003c/span\u003e  |  \u003cspan class=\"hljs-number\"\u003e2021\u003c/span\u003e   | \u003cspan class=\"hljs-number\"\u003e22000\u003c/span\u003e  |\n|   \u003cspan class=\"hljs-number\"\u003e987654\u003c/span\u003e  |  \u003cspan class=\"hljs-number\"\u003e2019\u003c/span\u003e   |  \u003cspan class=\"hljs-number\"\u003e510\u003c/span\u003e   |\n|   \u003cspan class=\"hljs-number\"\u003e987654\u003c/span\u003e  |  \u003cspan class=\"hljs-number\"\u003e2020\u003c/span\u003e   |  \u003cspan class=\"hljs-number\"\u003e1900\u003c/span\u003e  |\n|   \u003cspan class=\"hljs-number\"\u003e987654\u003c/span\u003e  |  \u003cspan class=\"hljs-number\"\u003e2021\u003c/span\u003e   |  \u003cspan class=\"hljs-number\"\u003e2100\u003c/span\u003e  |\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e3. Union 데이터 유형\u003c/h2\u003e\n\u003cp\u003e이제 서로 다른 데이터 유형을 유니언할 수 있습니다. 네, 들으신 대로, 제 SQL 고통 중 하나가 사라졌습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"SELECT '나는 문자열입니다' as col1 union select 100 union select 42.0\"\u003c/span\u003e)\n\n\n\n┌───────────────┐\n│     col1      │\n│    varchar    │\n├───────────────┤\n│ 나는 문자열입니다 │\n│ \u003cspan class=\"hljs-number\"\u003e42.0\u003c/span\u003e          │\n│ \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e           │\n└───────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDuckDB는 서로 다른 데이터 유형을 가져오는 모든 유형을 지원하는 \"가장 낮은 공통 분모\"로 강제로 변환합니다. 여기서 FLOAT 및 INT 열 값은 VARCHAR로 강제 변환됩니다.\u003c/p\u003e\n\u003ch2\u003e4. 재사용 가능한 열 별칭\u003c/h2\u003e\n\u003cp\u003e전통적인 SQL에서는 select 문 내에서 점진적으로 계산된 표현식을 처리할 때 일반적으로 각 열에 대해 전체 표현식을 복제하거나 각 계산 단계를 공통 테이블 표현식(CTE)으로 캡슐화해야 합니다. 그러나 재사용 가능한 열 별칭을 사용하면 이제 열 별칭을 동일한 select 문 전체에서 사용할 수 있으며, where 및 order by 절에서도 사용할 수 있어 프로세스를 간소화하고 중복을 줄일 수 있습니다. 예를 들어,\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"SELECT 'The quick brown fox jumped over the lazy dog' AS my_text,\\\nsubstring(my_text, 17,3) AS my_text_substr,\\\nlength(my_text) AS my_text_len,\\\nmy_text_len * my_text_len AS my_text_calc\"\u003c/span\u003e)\n\n## \u003cspan class=\"hljs-number\"\u003e5.\u003c/span\u003e 리스트 내포\n\n이 기능은 파이썬 스타일의 리스트 내포를 모델로 하며, 리스트 내 요소들에 대한 표현식을 계산하는 데 사용할 수 있습니다. 예를 들어, 다음과 같이 숫자 목록이 있는 경우:\n\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e파이썬에서는 우리가 원한다면, 위의 리스트의 각 숫자를 제곱하여 두 번째 리스트를 출력하고 싶다면 다음과 같이 진행될 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[x*x \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e x \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e,\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e]]\n\n\n# 위의 파이썬 코드는 다음과 같은 출력을 생성합니다\n#\n# [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e36\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e49\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e64\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e81\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDuckDB SQL에서도 매우 유사한 작업을 수행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"SELECT [x*x for x in nums] as squares FROM (VALUES ([1,2,3,4,5,6,7,8,9])) t(nums)\"\u003c/span\u003e)\n\n\n\n┌───────────────────────────────────┐\n│              squares              │\n│              int32[]              │\n├───────────────────────────────────┤\n│ [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e16\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e36\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e49\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e64\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e81\u003c/span\u003e] │\n└───────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e쿼리를 분석해보면 무엇을 하는 지 이해할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e다음 (VALUES([1,2,3,4,5,6,7,8,9])) t(nums)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 쿼리의 이 부분은 nums라는 단일 열을 갖는 임시 테이블 (또는 파생 테이블) t를 생성합니다.\u003c/li\u003e\n\u003cli\u003eVALUES 절은 리터럴 값을 제공하는 데 사용됩니다. 여기서는 1부터 9까지의 정수로 이루어진 목록(또는 배열)입니다.\u003c/li\u003e\n\u003cli\u003et(nums)는 파생 테이블에 t라는 이름을 지어주고, 그 안의 배열을 포함하는 열을 nums로 명명한 부분입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음과 같이 MARKDOWN 형식의 테이블 태그를 변경해 보세요:\u003c/p\u003e\n\u003cp\u003eSELECT [x*x for x in nums] as squares\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e이것은 계산이 발생하는 쿼리의 주요 부분입니다.\u003c/li\u003e\n\u003cli\u003e이 쿼리는 파이썬에서 일반적으로 볼 수 있는 작업인 리스트 내포 [x*x for x in nums]을 사용합니다. 이 문맥에서 nums 배열의 각 요소 x에 대해 x의 제곱을 계산합니다.\u003c/li\u003e\n\u003cli\u003e결과는 제곱된 값들의 배열입니다. 입력 배열에 대한 출력인 [1,2,3,4,5,6,7,8,9]는 [1,4,9,16,25,36,49,64,81]이 됩니다.\u003c/li\u003e\n\u003cli\u003esquares로 이 계산된 배열을 별칭 지어주고 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e요약하자면, 이 쿼리는 1에서 9까지의 숫자 배열을 만든 다음, 각 숫자의 제곱을 계산하고 squares라는 배열로 결과를 반환합니다.\u003c/p\u003e\n\u003ch2\u003e6. 함수 체이닝\u003c/h2\u003e\n\u003cp\u003eDuckDB는 점 표기법(dot notation)을 사용하여 별도의 SQL 함수를 연결하는 것을 쉽게 만들어줍니다. 이렇게 하면 한 개의 SQL 문에서 함수 파이프라인을 구축할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예를 들어, 많은 데이터베이스 시스템에서 INITCAP과 같은 이름의 SQL 함수가 있습니다. 이 함수는 텍스트 문자열의 모든 단어를 대문자로 만듭니다. 안타깝게도 DuckDB에는 이 기능이 내장되어 있지 않으므로, 우리는 함수 체이닝 (그리고 리스트 내포)을 사용하여 이를 흉내 내볼 수 있는지 살펴볼까요?\u003c/p\u003e\n\u003cp\u003e다음은 \"the quick brown fox jumped over the lazy dog\"이라는 문구에서 각 단어를 대문자로 바꾸고 싶을 때의 빠른 예제입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edb.\u003cspan class=\"hljs-title function_\"\u003esql\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"SELECT ([upper(x[1])||x[2:] for x in \\\n('the quick brown fox jumped over the lazy dog')\\\n.string_split(' ')]).list_aggr('string_agg',' ') as final_str\"\u003c/span\u003e)\n\n\n┌──────────────────────────────────────────────┐\n│                  final_str                   │\n│                   varchar                    │\n├──────────────────────────────────────────────┤\n│ \u003cspan class=\"hljs-title class_\"\u003eThe\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eQuick\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBrown\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFox\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eJumped\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOver\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eThe\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLazy\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDog\u003c/span\u003e │\n└──────────────────────────────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003estring_split 함수는 문구를 구성하는 개별 단어로 나누어주며, Python 리스트와 유사한 단어 목록을 생성합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e[the, quick, brown, fox, jumped, over, the, lazy, dog]\u003c/p\u003e\n\u003cp\u003e다음으로, 우리는 단어 목록 위에 리스트 컴프리헨션을 실행합니다. 목록의 각 단어마다 첫 글자를 대문자로 설정한 후 단어의 나머지 부분을 연결합니다. 이것이 표현식의 upper(x[1])||x[2:] 부분이 하는 일입니다.\u003c/p\u003e\n\u003cp\u003e이후에 우리의 중간 단어 목록은 다음과 같이 됩니다,\u003c/p\u003e\n\u003cp\u003e[The, Quick, Brown, Fox, Jumped, Over, The, Lazy, Dog]\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위 단어 목록에 대해 list_agg 함수를 실행합니다. 이 함수는 단어 목록을 다시 단어 문자열로 변환하고 각 단어를 공백 문자로 분리합니다.\u003c/p\u003e\n\u003cp\u003eMedium은 이 두 기사의 내용이 특히 흥미롭다고 생각합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-SixDuckDBSQLenhancementsyoushouldlearn"},"buildId":"8coAiP0lmiEK5aH6nkQkj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>