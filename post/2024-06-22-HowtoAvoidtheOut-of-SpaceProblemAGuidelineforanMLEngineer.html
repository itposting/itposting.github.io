<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ML 엔지니어를 위한 저장 공간 부족 문제 피하는 방법 가이드라인 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-22-HowtoAvoidtheOut-of-SpaceProblemAGuidelineforanMLEngineer" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ML 엔지니어를 위한 저장 공간 부족 문제 피하는 방법 가이드라인 | itposting" data-gatsby-head="true"/><meta property="og:title" content="ML 엔지니어를 위한 저장 공간 부족 문제 피하는 방법 가이드라인 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-HowtoAvoidtheOut-of-SpaceProblemAGuidelineforanMLEngineer_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-22-HowtoAvoidtheOut-of-SpaceProblemAGuidelineforanMLEngineer" data-gatsby-head="true"/><meta name="twitter:title" content="ML 엔지니어를 위한 저장 공간 부족 문제 피하는 방법 가이드라인 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-HowtoAvoidtheOut-of-SpaceProblemAGuidelineforanMLEngineer_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 19:50" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">ML 엔지니어를 위한 저장 공간 부족 문제 피하는 방법 가이드라인</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="ML 엔지니어를 위한 저장 공간 부족 문제 피하는 방법 가이드라인" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-HowtoAvoidtheOut-of-SpaceProblemAGuidelineforanMLEngineer&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>체크포인트, 도커 이미지, Python 환경, HF 모델 및 pip 캐시는 귀하가 완전한 인식 없이 시간이 지남에 따라 성장하여 디스크 공간을 더 많이 차지할 수 있습니다. 공간 부족 문제에 빠지지 않도록 주의하십시오.</p>
<h1>소개</h1>
<p>하드 드라이브가 얼마나 큰지 상관없이 언젠가는 공간 부족 문제에 직면하게 될 것입니다. 머신러닝 엔지니어 또는 데이터 과학자로서, 홈 폴더, 시스템 구조 또는 작업 공간 내 특정 위치가 시간이 지남에 따라 성장합니다. 이들은 주로 작업을 가속화하는 캐시이거나 특정 데이터의 전역 위치입니다. 이 글에서는 디스크의 일부 공간을 확보하기 위해 점검하고 조사해야 할 일반적인 위치 몇 군데를 모았습니다.</p>
<p>아래는 여러 달 동안 큰 정기 청소 없이 작업한 후 공간 사용 현황을 이해하기 위해 위치별로 나눈 것입니다.</p>
<div class="content-ad"></div>
<p>600G - 모델 체크포인트
290G - Docker 이미지, 컨테이너 및 캐시
231G - ~/miniconda3/envs
87G - ~/.cache/huggingface
41G - ~/miniconda3/pkgs
15G - ~/.cache/pip</p>
<p>동일한 분할을 파이 차트로도 제시했습니다:</p>
<p>데이터 1TB는 많지 않아 보일 수 있습니다. HDD 디스크는 비교적 저렴하며, 4-8TB 디스크를 가지는 것은 비싸지 않을 수 있습니다. 그러나 GPU를 사용한 컴퓨팅을 허용하는 Macbook M1/2/3/4 칩을 갖고 있는 노트북의 경우 비쌔 일 수 있습니다. 그러므로 주의와 정기적인 저장 공간 정리가 도움이 될 수 있습니다.</p>
<h1>모델 체크포인트</h1>
<div class="content-ad"></div>
<p>transformers 라이브러리를 사용하여 ML 모델을 매일 훈련한다면, 알지 못할 수도 있는 많은 체크포인트를 얻게 될 수 있습니다. 체크포인트는 훈련 과정 중에 모델의 중간 복사본으로 생성되어, 훈련 중단의 경우 모델을 백업하는 역할을 합니다. 훈련이 완료되면 체크포인트를 제거해야 합니다. 하지만 이러한 체크포인트는 종종 무심코 하드 드라이브에 남아 있는 경우가 있습니다.</p>
<p>사용 중인 체크포인트의 개수에 대해 궁금하다면, 다음을 실행해 보세요.</p>
<pre><code class="hljs language-js">find . -name <span class="hljs-string">"checkpoint-*"</span> | wc -l
</code></pre>
<p>제 경우에는 509개의 체크포인트가 있었습니다. 그들이 차지하는 용량을 확인해보겠습니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-sh">find . -name <span class="hljs-string">"checkpoint-*"</span> | \
  xargs -I {} <span class="hljs-built_in">du</span> --bytes {} | \
  awk <span class="hljs-string">'{ print; total += $1 }; END { print "Total: " total/1024/1024/1024 " GB" }'</span>
</code></pre>
<p>오버 600GB이네요. 상당한 용량이에요!</p>
<p>간단히 bash 스크립트를 설명하면:</p>
<ul>
<li>find — 모델 체크포인트의 기본 이름인 "checkpoint-"로 시작하는 폴더 목록을 생성합니다.</li>
<li>xargs — 각 폴더를 du 명령어에 전달합니다. du 명령어는 find로 반환된 각 폴더에 대해 실행됩니다.</li>
<li>du — 바이트 단위로 폴더의 총 크기를 계산합니다.</li>
<li>awk — du에서 크기를 추출하여 합하여 단일 값으로 출력합니다.</li>
</ul>
<div class="content-ad"></div>
<p>가장 큰 체크포인트부터 순서대로 나열하려면 다음 명령을 사용하면 됩니다:</p>
<pre><code class="hljs language-js">find . -name <span class="hljs-string">"checkpoint-*"</span> | \
  xargs -I {} du --bytes {} | \
  sort -n | \
  awk <span class="hljs-string">'{ print $1/1024/1024/1024 " GB " $2 }'</span>
</code></pre>
<p>이 명령을 실행하면 다음과 같이 출력됩니다 (가독성을 위해 경로는 체크포인트 이름으로 줄였습니다):</p>
<pre><code class="hljs language-js"><span class="hljs-number">4.59175</span> <span class="hljs-variable constant_">GB</span> (...)/checkpoint-<span class="hljs-number">19960</span>-epoch-<span class="hljs-number">2</span>
<span class="hljs-number">4.59175</span> <span class="hljs-variable constant_">GB</span> (...)/checkpoint-<span class="hljs-number">29940</span>-epoch-<span class="hljs-number">3</span>
<span class="hljs-number">4.59175</span> <span class="hljs-variable constant_">GB</span> (...)/checkpoint-<span class="hljs-number">39920</span>-epoch-<span class="hljs-number">4</span>
<span class="hljs-number">4.59175</span> <span class="hljs-variable constant_">GB</span> (...)/checkpoint-<span class="hljs-number">9980</span>-epoch-<span class="hljs-number">1</span>
<span class="hljs-number">4.60686</span> <span class="hljs-variable constant_">GB</span> (...)/checkpoint-<span class="hljs-number">20000</span>
<span class="hljs-number">4.60687</span> <span class="hljs-variable constant_">GB</span> (...)/checkpoint-<span class="hljs-number">12000</span>
<span class="hljs-number">4.60687</span> <span class="hljs-variable constant_">GB</span> (...)/checkpoint-<span class="hljs-number">13000</span>
<span class="hljs-number">4.60688</span> <span class="hljs-variable constant_">GB</span> (...)/checkpoint-<span class="hljs-number">17000</span>
<span class="hljs-number">6.52057</span> <span class="hljs-variable constant_">GB</span> (...)/checkpoint-<span class="hljs-number">6605</span>
<span class="hljs-number">6.52059</span> <span class="hljs-variable constant_">GB</span> (...)/checkpoint-<span class="hljs-number">2310</span>
<span class="hljs-number">9.16658</span> <span class="hljs-variable constant_">GB</span> (...)/checkpoint-<span class="hljs-number">21139</span>
<span class="hljs-number">9.16682</span> <span class="hljs-variable constant_">GB</span> (...)/checkpoint-<span class="hljs-number">42278</span>
</code></pre>
<div class="content-ad"></div>
<p>이 목록을 사용하여 각 체크포인트를 검토하고 유지 또는 제거할지 결정할 수 있습니다.</p>
<h1>Docker 이미지</h1>
<p>도커 컨테이너는 ML 모델을 포함한 다양한 응용 프로그램을 배포하는 편리한 방법입니다. 도커 이미지를 만들거나 외부 레지스트리에서 가져올 수 있습니다. 이미지를 빌드하거나 가져오면 작업 스테이션에 그대로 남아 있습니다. 시간이 지남에 따라 가지고 있는 이미지의 수와 차지하는 디스크 공간의 양에 놀라게 될 수 있습니다.</p>
<p>도커가 사용한 공간을 확인하려면 다음 명령어를 실행하세요 [2]:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">도커 시스템 df
</code></pre>
<p>위 명령어를 실행하면 다음과 같은 결과가 출력됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">TYPE</span> <span class="hljs-variable constant_">TOTAL</span> <span class="hljs-variable constant_">ACTIVE</span> <span class="hljs-variable constant_">SIZE</span> <span class="hljs-variable constant_">RECLAIMABLE</span>
<span class="hljs-title class_">Images</span> <span class="hljs-number">133</span> <span class="hljs-number">69</span> <span class="hljs-number">264.</span>4GB <span class="hljs-number">180.</span>6GB (<span class="hljs-number">68</span>%)
<span class="hljs-title class_">Containers</span> <span class="hljs-number">160</span> <span class="hljs-number">3</span> <span class="hljs-number">11.</span>54GB <span class="hljs-number">9.</span>582GB (<span class="hljs-number">83</span>%)
<span class="hljs-title class_">Local</span> <span class="hljs-title class_">Volumes</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span> <span class="hljs-number">256.</span>9MB <span class="hljs-number">5.</span>419kB (<span class="hljs-number">0</span>%)
<span class="hljs-title class_">Build</span> <span class="hljs-title class_">Cache</span> <span class="hljs-number">473</span> <span class="hljs-number">0</span> <span class="hljs-number">14.</span>56GB <span class="hljs-number">14.</span>56GB
</code></pre>
<p>여기서, 우리는 도커 이미지의 총 크기에만 초점을 맞출 것입니다. 제 경우에는 180GB가 넘습니다.</p>
<div class="content-ad"></div>
<p>도커 정리를 처리하는 한 가지 방법은 프룬 명령어를 사용하는 것입니다 [3]. 문서에 따르면:</p>
<p>이 명령은 직접적인 경우만 제거합니다. 이미지를 개별적으로 확인하고 남은 것이 여전히 필요한지 결정해야 할 것입니다. 한 번만 시도해본 이미지거나 더 이상 필요하지 않은 이미지가 있을 수도 있습니다. 제거할 수 있는 더 오래된 이미지 버전도 있을 수 있습니다. 다른 경우에는 더 오래된 버전을 남겨두어 더 최신 버전과 비교하고 싶을 수도 있습니다.</p>
<p>이미지를 크기순으로 나열하기 위해 다음 명령어를 사용하세요:</p>
<pre><code class="hljs language-js">docker image ls --format <span class="hljs-string">"{.Size} {.ID} {.Repository}:{.Tag}"</span> | \
  <span class="hljs-variable constant_">LANG</span>=en_US sort -h | \
  column -t
</code></pre>
<div class="content-ad"></div>
<p>아래와 같이 출력됩니다:</p>
<pre><code class="hljs language-js">(...)
<span class="hljs-number">9.</span>43GB  8ab26e6b7035  mczuk/<span class="hljs-attr">poldeepner2</span>:kpwr_timex_1<span class="hljs-number">.0</span>
<span class="hljs-number">9.</span>58GB  8b50a5264fa1  mczuk/<span class="hljs-attr">poldeepner2</span>:nkjp_base_sq
<span class="hljs-number">9.</span>74GB  46d6ea3f8fea  nvidia/<span class="hljs-attr">cuda</span>:<span class="hljs-number">11.8</span><span class="hljs-number">.0</span>-cudnn8-devel-ubuntu20<span class="hljs-number">.04</span>
<span class="hljs-number">10.</span>5GB  9788da8da088  &#x3C;none>:&#x3C;none>
<span class="hljs-number">10.</span>8GB  484fc54f67e7  &#x3C;none>:&#x3C;none>
<span class="hljs-number">10.</span>8GB  b9bb30fe2458  &#x3C;none>:&#x3C;none>
<span class="hljs-number">11.</span>3GB  d37700724b89  &#x3C;none>:&#x3C;none>
<span class="hljs-number">18.</span>3GB  1d9a58a6fcf5  nvcr.<span class="hljs-property">io</span>/nvidia/<span class="hljs-attr">pytorch</span>:<span class="hljs-number">22.12</span>-py3
</code></pre>
<p>특정 도커 이미지를 제거하려면 docker image rm ID [4]를 사용합니다.</p>
<h1>Miniconda 환경</h1>
<div class="content-ad"></div>
<p>각 프로젝트마다 별도의 Python 환경을 실행하는 것은 좋은 습관입니다. 이렇게 하면 라이브러리 의존성 간 충돌을 피하거나 두 개 이상의 프로젝트가 동일한 환경을 공유하는 상황을 방지할 수 있습니다. 한 프로젝트를 업데이트하면 다른 프로젝트가 작동을 중지하는 일도 없어집니다.</p>
<p>Python 환경을 관리하는 인기 있는 솔루션 중 하나는 Miniconda입니다. Miniconda는 모든 환경을 한 곳에 유지함으로써, 보유한 환경 수와 사용 용량을 확인하기 쉽습니다. 환경은 ~/miniconda3/envs에 저장됩니다. 여러 환경을 보유하는 것은 문제가 되지 않을 수 있지만, GPU를 사용한 ML 모델 학습이나 추론을 할 때 NVidia 라이브러리(CUDA, cuDNN, cuBLAS 등)를 사용하는 경우가 많습니다. 이들은 상당히 많은 용량을 차지하고 있습니다. 기본 설정만 해도 약 10GB가 필요하며, 다른 의존성을 고려하지 않았습니다. Miniconda에서는 각 환경이 모듈의 복사본을 가지고 있기 때문에 공간 사용량이 더해지게 됩니다.</p>
<p>저의 경우, miniconda3/envs 폴더는 230GB를 차지하고 있으며 100개 이상의 환경이 있습니다. 이미 일부 환경을 용량 부족으로 제거했었죠 ;-)</p>
<p>오래된, 사용하지 않는 환경은 신중히 제거해야 합니다. 일부 오래된 프로젝트는 문제없이 함께 작동하는 라이브러리 조합을 가질 수 있습니다. 대부분의 프로젝트들은 환경을 생성할 수 있는 필수 라이브러리 목록(requirements.txt 또는 pyproject.toml)을 갖고 있어야 합니다. 그러나 몇 가지 모듈은 요구사항 목록이나 사용하는 라이브러리 중 하나에 특정 버전이 누락될 수 있습니다. 이러한 경우 정확한 라이브러리 조합을 다시 만드는 것이 어려울 수 있습니다. 이에 대한 해결책으로 pip freeze 명령을 사용하여 라이브러리의 정확한 버전을 덤프하고 나중에 검증할 수 있습니다. 기억해야 할 점은, 심지어 작은 변경이나 패치라도 라이브러리 간의 호환성에 일부 문제를 초래할 수 있는 일반적인 문제입니다. 해서서는 안 되지만 그렇게 됩니다.</p>
<div class="content-ad"></div>
<h1>Miniconda 패키지</h1>
<p>Miniconda는 conda install 명령어로 설치된 패키지를 캐시합니다. 캐시는 ~/miniconda3/pkgs 폴더에 위치해 있습니다. 제 경우엔 62GB입니다. 해당 폴더를 열어보면 여러 버전의 패키지가 몇 개만 있는 것을 볼 수 있습니다. 예전 버전은 종종 필요하지 않을 수 있어 쉽게 삭제할 수 있습니다.</p>
<h1>Huggingface 모델 및 데이터셋</h1>
<p>Huggingface는 transformers 라이브러리를 통해 사용하는 모델 및 데이터셋을 모두 캐시합니다. 제 캐시의 분석을 통해 알 수 있는 정보가 여기에 있습니다.</p>
<div class="content-ad"></div>
<p>허깅페이스 캐시에서 모델을 제거하는 것이 이전 파이썬 환경을 제거하는 것보다 안전합니다. 모델은 리포지토리에서 다시 다운로드할 수 있습니다. (단, 리포지토리에서 제거되지 않은 경우) 그럼에도 불구하고 캐시에는 기억하지 못하는 모델이 많이 있음을 알게 될 것입니다.</p>
<h1>파이썬 pip 캐시</h1>
<p>마지막 위치는 pip 캐시로, pip로 설치된 파이썬 모듈을 보관합니다. 캐시에 대한 정보를 표시하려면 pip cache info [6]를 사용할 수 있습니다. 아래와 같이 출력됩니다:</p>
<pre><code class="hljs language-js">패키지 인덱스 페이지 캐시 위치 (pip v23<span class="hljs-number">.3</span>+): <span class="hljs-regexp">/home/</span>czuk/.<span class="hljs-property">cache</span>/pip/http-v2
패키지 인덱스 페이지 캐시 위치 (이전 버전 pips): <span class="hljs-regexp">/home/</span>czuk/.<span class="hljs-property">cache</span>/pip/http
패키지 인덱스 페이지 캐시 크기: <span class="hljs-number">18297.6</span> <span class="hljs-variable constant_">MB</span>
<span class="hljs-variable constant_">HTTP</span> 파일 수: <span class="hljs-number">3025</span>
로컬 빌드된 휠 위치: <span class="hljs-regexp">/home/</span>czuk/.<span class="hljs-property">cache</span>/pip/wheels
로컬 빌드된 휠 크기: <span class="hljs-number">457</span> kB
로컬 빌드된 휠 수: <span class="hljs-number">5</span>
</code></pre>
<div class="content-ad"></div>
<p>저의 경우에는 18 GB입니다. pip 캐시를 정리하기 위해 pip cache purge 명령을 사용할 수 있습니다.</p>
<h1>결론</h1>
<p>정기적인 디스크 사용량 관리는 공간 부족 오류로부터 자신을 보호하는 데 중요합니다. 급한 계산을 해야 할 때 메시지가 나타나면 정말 골치 아플 수 있습니다. 그런데 공간이 부족해서 계산 작업을 완료할 수 없는 경우가 발생할 수 있습니다. 로컬 워크스테이션이 아닌 워크스테이션에서 모델 훈련이나 다른 계산을 수행하고 있을 때 심지어 작업이 중단될 수도 있습니다.</p>
<p>클라우드 서비스를 사용할 때는 디스크 사용량 관리가 특히 중요합니다. 원격 인스턴스나 SageMaker와 같은 ML 플랫폼을 사용할 때 공간을 사용하면 요금이 청구됩니다. 로컬 워크스테이션에서 공간이 부족한 메시지가 나타날 수 있습니다. 클라우드에서는 저장 용량이 거의 무한합니다.</p>
<div class="content-ad"></div>
<h1>참고 자료</h1>
<ul>
<li><a href="https://www.rapidtables.com/tools/bar-graph.html" rel="nofollow" target="_blank">바 그래프 도구</a></li>
<li><a href="https://docs.docker.com/reference/cli/docker/system/df/" rel="nofollow" target="_blank">도커 CLI 시스템 리소스 확인</a></li>
<li><a href="https://docs.docker.com/config/pruning/" rel="nofollow" target="_blank">도커 자원 정리 설정</a></li>
</ul>
<div class="content-ad"></div>
<p>[4] <a href="https://docs.docker.com/reference/cli/docker/image/rm/" rel="nofollow" target="_blank">https://docs.docker.com/reference/cli/docker/image/rm/</a></p>
<p>[5] <a href="https://docs.anaconda.com/" rel="nofollow" target="_blank">https://docs.anaconda.com/</a></p>
<p>[6] <a href="https://pip.pypa.io/en/stable/cli/pip_cache/" rel="nofollow" target="_blank">https://pip.pypa.io/en/stable/cli/pip_cache/</a></p>
<p>[7] <a href="https://aws.amazon.com/pm/sagemaker" rel="nofollow" target="_blank">https://aws.amazon.com/pm/sagemaker</a></p>
<div class="content-ad"></div>
<p>[8] <a href="https://medium.com/codenlp/6-things-about-sagemaker-i-wish-i-had-known-earlier-revision-2-e90511d58ca5#beed" rel="nofollow" target="_blank">https://medium.com/codenlp/6-things-about-sagemaker-i-wish-i-had-known-earlier-revision-2-e90511d58ca5#beed</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"ML 엔지니어를 위한 저장 공간 부족 문제 피하는 방법 가이드라인","description":"","date":"2024-06-22 19:50","slug":"2024-06-22-HowtoAvoidtheOut-of-SpaceProblemAGuidelineforanMLEngineer","content":"\n\n체크포인트, 도커 이미지, Python 환경, HF 모델 및 pip 캐시는 귀하가 완전한 인식 없이 시간이 지남에 따라 성장하여 디스크 공간을 더 많이 차지할 수 있습니다. 공간 부족 문제에 빠지지 않도록 주의하십시오.\n\n# 소개\n\n하드 드라이브가 얼마나 큰지 상관없이 언젠가는 공간 부족 문제에 직면하게 될 것입니다. 머신러닝 엔지니어 또는 데이터 과학자로서, 홈 폴더, 시스템 구조 또는 작업 공간 내 특정 위치가 시간이 지남에 따라 성장합니다. 이들은 주로 작업을 가속화하는 캐시이거나 특정 데이터의 전역 위치입니다. 이 글에서는 디스크의 일부 공간을 확보하기 위해 점검하고 조사해야 할 일반적인 위치 몇 군데를 모았습니다.\n\n아래는 여러 달 동안 큰 정기 청소 없이 작업한 후 공간 사용 현황을 이해하기 위해 위치별로 나눈 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n600G - 모델 체크포인트\n290G - Docker 이미지, 컨테이너 및 캐시\n231G - ~/miniconda3/envs\n 87G - ~/.cache/huggingface\n 41G - ~/miniconda3/pkgs\n 15G - ~/.cache/pip\n\n\n동일한 분할을 파이 차트로도 제시했습니다:\n\n데이터 1TB는 많지 않아 보일 수 있습니다. HDD 디스크는 비교적 저렴하며, 4-8TB 디스크를 가지는 것은 비싸지 않을 수 있습니다. 그러나 GPU를 사용한 컴퓨팅을 허용하는 Macbook M1/2/3/4 칩을 갖고 있는 노트북의 경우 비쌔 일 수 있습니다. 그러므로 주의와 정기적인 저장 공간 정리가 도움이 될 수 있습니다.\n\n# 모델 체크포인트\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ntransformers 라이브러리를 사용하여 ML 모델을 매일 훈련한다면, 알지 못할 수도 있는 많은 체크포인트를 얻게 될 수 있습니다. 체크포인트는 훈련 과정 중에 모델의 중간 복사본으로 생성되어, 훈련 중단의 경우 모델을 백업하는 역할을 합니다. 훈련이 완료되면 체크포인트를 제거해야 합니다. 하지만 이러한 체크포인트는 종종 무심코 하드 드라이브에 남아 있는 경우가 있습니다.\n\n사용 중인 체크포인트의 개수에 대해 궁금하다면, 다음을 실행해 보세요.\n\n```js\nfind . -name \"checkpoint-*\" | wc -l\n```\n\n제 경우에는 509개의 체크포인트가 있었습니다. 그들이 차지하는 용량을 확인해보겠습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sh\nfind . -name \"checkpoint-*\" | \\\n  xargs -I {} du --bytes {} | \\\n  awk '{ print; total += $1 }; END { print \"Total: \" total/1024/1024/1024 \" GB\" }'\n```\n\n오버 600GB이네요. 상당한 용량이에요!\n\n간단히 bash 스크립트를 설명하면:\n\n- find — 모델 체크포인트의 기본 이름인 \"checkpoint-\"로 시작하는 폴더 목록을 생성합니다.\n- xargs — 각 폴더를 du 명령어에 전달합니다. du 명령어는 find로 반환된 각 폴더에 대해 실행됩니다.\n- du — 바이트 단위로 폴더의 총 크기를 계산합니다.\n- awk — du에서 크기를 추출하여 합하여 단일 값으로 출력합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 큰 체크포인트부터 순서대로 나열하려면 다음 명령을 사용하면 됩니다:\n\n```js\nfind . -name \"checkpoint-*\" | \\\n  xargs -I {} du --bytes {} | \\\n  sort -n | \\\n  awk '{ print $1/1024/1024/1024 \" GB \" $2 }'\n```\n\n이 명령을 실행하면 다음과 같이 출력됩니다 (가독성을 위해 경로는 체크포인트 이름으로 줄였습니다):\n\n```js\n4.59175 GB (...)/checkpoint-19960-epoch-2\n4.59175 GB (...)/checkpoint-29940-epoch-3\n4.59175 GB (...)/checkpoint-39920-epoch-4\n4.59175 GB (...)/checkpoint-9980-epoch-1\n4.60686 GB (...)/checkpoint-20000\n4.60687 GB (...)/checkpoint-12000\n4.60687 GB (...)/checkpoint-13000\n4.60688 GB (...)/checkpoint-17000\n6.52057 GB (...)/checkpoint-6605\n6.52059 GB (...)/checkpoint-2310\n9.16658 GB (...)/checkpoint-21139\n9.16682 GB (...)/checkpoint-42278\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 목록을 사용하여 각 체크포인트를 검토하고 유지 또는 제거할지 결정할 수 있습니다.\n\n# Docker 이미지\n\n도커 컨테이너는 ML 모델을 포함한 다양한 응용 프로그램을 배포하는 편리한 방법입니다. 도커 이미지를 만들거나 외부 레지스트리에서 가져올 수 있습니다. 이미지를 빌드하거나 가져오면 작업 스테이션에 그대로 남아 있습니다. 시간이 지남에 따라 가지고 있는 이미지의 수와 차지하는 디스크 공간의 양에 놀라게 될 수 있습니다.\n\n도커가 사용한 공간을 확인하려면 다음 명령어를 실행하세요 [2]:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n도커 시스템 df\n```\n\n위 명령어를 실행하면 다음과 같은 결과가 출력됩니다:\n\n```js\nTYPE TOTAL ACTIVE SIZE RECLAIMABLE\nImages 133 69 264.4GB 180.6GB (68%)\nContainers 160 3 11.54GB 9.582GB (83%)\nLocal Volumes 6 4 256.9MB 5.419kB (0%)\nBuild Cache 473 0 14.56GB 14.56GB\n```\n\n여기서, 우리는 도커 이미지의 총 크기에만 초점을 맞출 것입니다. 제 경우에는 180GB가 넘습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n도커 정리를 처리하는 한 가지 방법은 프룬 명령어를 사용하는 것입니다 [3]. 문서에 따르면:\n\n이 명령은 직접적인 경우만 제거합니다. 이미지를 개별적으로 확인하고 남은 것이 여전히 필요한지 결정해야 할 것입니다. 한 번만 시도해본 이미지거나 더 이상 필요하지 않은 이미지가 있을 수도 있습니다. 제거할 수 있는 더 오래된 이미지 버전도 있을 수 있습니다. 다른 경우에는 더 오래된 버전을 남겨두어 더 최신 버전과 비교하고 싶을 수도 있습니다.\n\n이미지를 크기순으로 나열하기 위해 다음 명령어를 사용하세요:\n\n```js\ndocker image ls --format \"{.Size} {.ID} {.Repository}:{.Tag}\" | \\\n  LANG=en_US sort -h | \\\n  column -t\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같이 출력됩니다:\n\n```js\n(...)\n9.43GB  8ab26e6b7035  mczuk/poldeepner2:kpwr_timex_1.0\n9.58GB  8b50a5264fa1  mczuk/poldeepner2:nkjp_base_sq\n9.74GB  46d6ea3f8fea  nvidia/cuda:11.8.0-cudnn8-devel-ubuntu20.04\n10.5GB  9788da8da088  \u003cnone\u003e:\u003cnone\u003e\n10.8GB  484fc54f67e7  \u003cnone\u003e:\u003cnone\u003e\n10.8GB  b9bb30fe2458  \u003cnone\u003e:\u003cnone\u003e\n11.3GB  d37700724b89  \u003cnone\u003e:\u003cnone\u003e\n18.3GB  1d9a58a6fcf5  nvcr.io/nvidia/pytorch:22.12-py3\n```\n\n특정 도커 이미지를 제거하려면 docker image rm ID [4]를 사용합니다.\n\n# Miniconda 환경\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 프로젝트마다 별도의 Python 환경을 실행하는 것은 좋은 습관입니다. 이렇게 하면 라이브러리 의존성 간 충돌을 피하거나 두 개 이상의 프로젝트가 동일한 환경을 공유하는 상황을 방지할 수 있습니다. 한 프로젝트를 업데이트하면 다른 프로젝트가 작동을 중지하는 일도 없어집니다.\n\nPython 환경을 관리하는 인기 있는 솔루션 중 하나는 Miniconda입니다. Miniconda는 모든 환경을 한 곳에 유지함으로써, 보유한 환경 수와 사용 용량을 확인하기 쉽습니다. 환경은 ~/miniconda3/envs에 저장됩니다. 여러 환경을 보유하는 것은 문제가 되지 않을 수 있지만, GPU를 사용한 ML 모델 학습이나 추론을 할 때 NVidia 라이브러리(CUDA, cuDNN, cuBLAS 등)를 사용하는 경우가 많습니다. 이들은 상당히 많은 용량을 차지하고 있습니다. 기본 설정만 해도 약 10GB가 필요하며, 다른 의존성을 고려하지 않았습니다. Miniconda에서는 각 환경이 모듈의 복사본을 가지고 있기 때문에 공간 사용량이 더해지게 됩니다.\n\n저의 경우, miniconda3/envs 폴더는 230GB를 차지하고 있으며 100개 이상의 환경이 있습니다. 이미 일부 환경을 용량 부족으로 제거했었죠 ;-)\n\n오래된, 사용하지 않는 환경은 신중히 제거해야 합니다. 일부 오래된 프로젝트는 문제없이 함께 작동하는 라이브러리 조합을 가질 수 있습니다. 대부분의 프로젝트들은 환경을 생성할 수 있는 필수 라이브러리 목록(requirements.txt 또는 pyproject.toml)을 갖고 있어야 합니다. 그러나 몇 가지 모듈은 요구사항 목록이나 사용하는 라이브러리 중 하나에 특정 버전이 누락될 수 있습니다. 이러한 경우 정확한 라이브러리 조합을 다시 만드는 것이 어려울 수 있습니다. 이에 대한 해결책으로 pip freeze 명령을 사용하여 라이브러리의 정확한 버전을 덤프하고 나중에 검증할 수 있습니다. 기억해야 할 점은, 심지어 작은 변경이나 패치라도 라이브러리 간의 호환성에 일부 문제를 초래할 수 있는 일반적인 문제입니다. 해서서는 안 되지만 그렇게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Miniconda 패키지\n\nMiniconda는 conda install 명령어로 설치된 패키지를 캐시합니다. 캐시는 ~/miniconda3/pkgs 폴더에 위치해 있습니다. 제 경우엔 62GB입니다. 해당 폴더를 열어보면 여러 버전의 패키지가 몇 개만 있는 것을 볼 수 있습니다. 예전 버전은 종종 필요하지 않을 수 있어 쉽게 삭제할 수 있습니다.\n\n# Huggingface 모델 및 데이터셋\n\nHuggingface는 transformers 라이브러리를 통해 사용하는 모델 및 데이터셋을 모두 캐시합니다. 제 캐시의 분석을 통해 알 수 있는 정보가 여기에 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n허깅페이스 캐시에서 모델을 제거하는 것이 이전 파이썬 환경을 제거하는 것보다 안전합니다. 모델은 리포지토리에서 다시 다운로드할 수 있습니다. (단, 리포지토리에서 제거되지 않은 경우) 그럼에도 불구하고 캐시에는 기억하지 못하는 모델이 많이 있음을 알게 될 것입니다.\n\n# 파이썬 pip 캐시\n\n마지막 위치는 pip 캐시로, pip로 설치된 파이썬 모듈을 보관합니다. 캐시에 대한 정보를 표시하려면 pip cache info [6]를 사용할 수 있습니다. 아래와 같이 출력됩니다:\n\n```js\n패키지 인덱스 페이지 캐시 위치 (pip v23.3+): /home/czuk/.cache/pip/http-v2\n패키지 인덱스 페이지 캐시 위치 (이전 버전 pips): /home/czuk/.cache/pip/http\n패키지 인덱스 페이지 캐시 크기: 18297.6 MB\nHTTP 파일 수: 3025\n로컬 빌드된 휠 위치: /home/czuk/.cache/pip/wheels\n로컬 빌드된 휠 크기: 457 kB\n로컬 빌드된 휠 수: 5\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저의 경우에는 18 GB입니다. pip 캐시를 정리하기 위해 pip cache purge 명령을 사용할 수 있습니다.\n\n# 결론\n\n정기적인 디스크 사용량 관리는 공간 부족 오류로부터 자신을 보호하는 데 중요합니다. 급한 계산을 해야 할 때 메시지가 나타나면 정말 골치 아플 수 있습니다. 그런데 공간이 부족해서 계산 작업을 완료할 수 없는 경우가 발생할 수 있습니다. 로컬 워크스테이션이 아닌 워크스테이션에서 모델 훈련이나 다른 계산을 수행하고 있을 때 심지어 작업이 중단될 수도 있습니다.\n\n클라우드 서비스를 사용할 때는 디스크 사용량 관리가 특히 중요합니다. 원격 인스턴스나 SageMaker와 같은 ML 플랫폼을 사용할 때 공간을 사용하면 요금이 청구됩니다. 로컬 워크스테이션에서 공간이 부족한 메시지가 나타날 수 있습니다. 클라우드에서는 저장 용량이 거의 무한합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고 자료\n\n- [바 그래프 도구](https://www.rapidtables.com/tools/bar-graph.html)\n- [도커 CLI 시스템 리소스 확인](https://docs.docker.com/reference/cli/docker/system/df/)\n- [도커 자원 정리 설정](https://docs.docker.com/config/pruning/)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[4] https://docs.docker.com/reference/cli/docker/image/rm/\n\n[5] https://docs.anaconda.com/\n\n[6] https://pip.pypa.io/en/stable/cli/pip_cache/\n\n[7] https://aws.amazon.com/pm/sagemaker\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n[8] [https://medium.com/codenlp/6-things-about-sagemaker-i-wish-i-had-known-earlier-revision-2-e90511d58ca5#beed](https://medium.com/codenlp/6-things-about-sagemaker-i-wish-i-had-known-earlier-revision-2-e90511d58ca5#beed)","ogImage":{"url":"/assets/img/2024-06-22-HowtoAvoidtheOut-of-SpaceProblemAGuidelineforanMLEngineer_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoAvoidtheOut-of-SpaceProblemAGuidelineforanMLEngineer_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e체크포인트, 도커 이미지, Python 환경, HF 모델 및 pip 캐시는 귀하가 완전한 인식 없이 시간이 지남에 따라 성장하여 디스크 공간을 더 많이 차지할 수 있습니다. 공간 부족 문제에 빠지지 않도록 주의하십시오.\u003c/p\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e하드 드라이브가 얼마나 큰지 상관없이 언젠가는 공간 부족 문제에 직면하게 될 것입니다. 머신러닝 엔지니어 또는 데이터 과학자로서, 홈 폴더, 시스템 구조 또는 작업 공간 내 특정 위치가 시간이 지남에 따라 성장합니다. 이들은 주로 작업을 가속화하는 캐시이거나 특정 데이터의 전역 위치입니다. 이 글에서는 디스크의 일부 공간을 확보하기 위해 점검하고 조사해야 할 일반적인 위치 몇 군데를 모았습니다.\u003c/p\u003e\n\u003cp\u003e아래는 여러 달 동안 큰 정기 청소 없이 작업한 후 공간 사용 현황을 이해하기 위해 위치별로 나눈 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e600G - 모델 체크포인트\n290G - Docker 이미지, 컨테이너 및 캐시\n231G - ~/miniconda3/envs\n87G - ~/.cache/huggingface\n41G - ~/miniconda3/pkgs\n15G - ~/.cache/pip\u003c/p\u003e\n\u003cp\u003e동일한 분할을 파이 차트로도 제시했습니다:\u003c/p\u003e\n\u003cp\u003e데이터 1TB는 많지 않아 보일 수 있습니다. HDD 디스크는 비교적 저렴하며, 4-8TB 디스크를 가지는 것은 비싸지 않을 수 있습니다. 그러나 GPU를 사용한 컴퓨팅을 허용하는 Macbook M1/2/3/4 칩을 갖고 있는 노트북의 경우 비쌔 일 수 있습니다. 그러므로 주의와 정기적인 저장 공간 정리가 도움이 될 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e모델 체크포인트\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003etransformers 라이브러리를 사용하여 ML 모델을 매일 훈련한다면, 알지 못할 수도 있는 많은 체크포인트를 얻게 될 수 있습니다. 체크포인트는 훈련 과정 중에 모델의 중간 복사본으로 생성되어, 훈련 중단의 경우 모델을 백업하는 역할을 합니다. 훈련이 완료되면 체크포인트를 제거해야 합니다. 하지만 이러한 체크포인트는 종종 무심코 하드 드라이브에 남아 있는 경우가 있습니다.\u003c/p\u003e\n\u003cp\u003e사용 중인 체크포인트의 개수에 대해 궁금하다면, 다음을 실행해 보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efind . -name \u003cspan class=\"hljs-string\"\u003e\"checkpoint-*\"\u003c/span\u003e | wc -l\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제 경우에는 509개의 체크포인트가 있었습니다. 그들이 차지하는 용량을 확인해보겠습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sh\"\u003efind . -name \u003cspan class=\"hljs-string\"\u003e\"checkpoint-*\"\u003c/span\u003e | \\\n  xargs -I {} \u003cspan class=\"hljs-built_in\"\u003edu\u003c/span\u003e --bytes {} | \\\n  awk \u003cspan class=\"hljs-string\"\u003e'{ print; total += $1 }; END { print \"Total: \" total/1024/1024/1024 \" GB\" }'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e오버 600GB이네요. 상당한 용량이에요!\u003c/p\u003e\n\u003cp\u003e간단히 bash 스크립트를 설명하면:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efind — 모델 체크포인트의 기본 이름인 \"checkpoint-\"로 시작하는 폴더 목록을 생성합니다.\u003c/li\u003e\n\u003cli\u003exargs — 각 폴더를 du 명령어에 전달합니다. du 명령어는 find로 반환된 각 폴더에 대해 실행됩니다.\u003c/li\u003e\n\u003cli\u003edu — 바이트 단위로 폴더의 총 크기를 계산합니다.\u003c/li\u003e\n\u003cli\u003eawk — du에서 크기를 추출하여 합하여 단일 값으로 출력합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e가장 큰 체크포인트부터 순서대로 나열하려면 다음 명령을 사용하면 됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efind . -name \u003cspan class=\"hljs-string\"\u003e\"checkpoint-*\"\u003c/span\u003e | \\\n  xargs -I {} du --bytes {} | \\\n  sort -n | \\\n  awk \u003cspan class=\"hljs-string\"\u003e'{ print $1/1024/1024/1024 \" GB \" $2 }'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 명령을 실행하면 다음과 같이 출력됩니다 (가독성을 위해 경로는 체크포인트 이름으로 줄였습니다):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-number\"\u003e4.59175\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGB\u003c/span\u003e (...)/checkpoint-\u003cspan class=\"hljs-number\"\u003e19960\u003c/span\u003e-epoch-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e4.59175\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGB\u003c/span\u003e (...)/checkpoint-\u003cspan class=\"hljs-number\"\u003e29940\u003c/span\u003e-epoch-\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e4.59175\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGB\u003c/span\u003e (...)/checkpoint-\u003cspan class=\"hljs-number\"\u003e39920\u003c/span\u003e-epoch-\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e4.59175\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGB\u003c/span\u003e (...)/checkpoint-\u003cspan class=\"hljs-number\"\u003e9980\u003c/span\u003e-epoch-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e4.60686\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGB\u003c/span\u003e (...)/checkpoint-\u003cspan class=\"hljs-number\"\u003e20000\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e4.60687\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGB\u003c/span\u003e (...)/checkpoint-\u003cspan class=\"hljs-number\"\u003e12000\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e4.60687\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGB\u003c/span\u003e (...)/checkpoint-\u003cspan class=\"hljs-number\"\u003e13000\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e4.60688\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGB\u003c/span\u003e (...)/checkpoint-\u003cspan class=\"hljs-number\"\u003e17000\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e6.52057\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGB\u003c/span\u003e (...)/checkpoint-\u003cspan class=\"hljs-number\"\u003e6605\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e6.52059\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGB\u003c/span\u003e (...)/checkpoint-\u003cspan class=\"hljs-number\"\u003e2310\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e9.16658\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGB\u003c/span\u003e (...)/checkpoint-\u003cspan class=\"hljs-number\"\u003e21139\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e9.16682\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGB\u003c/span\u003e (...)/checkpoint-\u003cspan class=\"hljs-number\"\u003e42278\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 목록을 사용하여 각 체크포인트를 검토하고 유지 또는 제거할지 결정할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eDocker 이미지\u003c/h1\u003e\n\u003cp\u003e도커 컨테이너는 ML 모델을 포함한 다양한 응용 프로그램을 배포하는 편리한 방법입니다. 도커 이미지를 만들거나 외부 레지스트리에서 가져올 수 있습니다. 이미지를 빌드하거나 가져오면 작업 스테이션에 그대로 남아 있습니다. 시간이 지남에 따라 가지고 있는 이미지의 수와 차지하는 디스크 공간의 양에 놀라게 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e도커가 사용한 공간을 확인하려면 다음 명령어를 실행하세요 [2]:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e도커 시스템 df\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 명령어를 실행하면 다음과 같은 결과가 출력됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eTYPE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTOTAL\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eACTIVE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSIZE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eRECLAIMABLE\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eImages\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e133\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e69\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e264.\u003c/span\u003e4GB \u003cspan class=\"hljs-number\"\u003e180.\u003c/span\u003e6GB (\u003cspan class=\"hljs-number\"\u003e68\u003c/span\u003e%)\n\u003cspan class=\"hljs-title class_\"\u003eContainers\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e160\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e11.\u003c/span\u003e54GB \u003cspan class=\"hljs-number\"\u003e9.\u003c/span\u003e582GB (\u003cspan class=\"hljs-number\"\u003e83\u003c/span\u003e%)\n\u003cspan class=\"hljs-title class_\"\u003eLocal\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eVolumes\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e256.\u003c/span\u003e9MB \u003cspan class=\"hljs-number\"\u003e5.\u003c/span\u003e419kB (\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e%)\n\u003cspan class=\"hljs-title class_\"\u003eBuild\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCache\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e473\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e14.\u003c/span\u003e56GB \u003cspan class=\"hljs-number\"\u003e14.\u003c/span\u003e56GB\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서, 우리는 도커 이미지의 총 크기에만 초점을 맞출 것입니다. 제 경우에는 180GB가 넘습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e도커 정리를 처리하는 한 가지 방법은 프룬 명령어를 사용하는 것입니다 [3]. 문서에 따르면:\u003c/p\u003e\n\u003cp\u003e이 명령은 직접적인 경우만 제거합니다. 이미지를 개별적으로 확인하고 남은 것이 여전히 필요한지 결정해야 할 것입니다. 한 번만 시도해본 이미지거나 더 이상 필요하지 않은 이미지가 있을 수도 있습니다. 제거할 수 있는 더 오래된 이미지 버전도 있을 수 있습니다. 다른 경우에는 더 오래된 버전을 남겨두어 더 최신 버전과 비교하고 싶을 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e이미지를 크기순으로 나열하기 위해 다음 명령어를 사용하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker image ls --format \u003cspan class=\"hljs-string\"\u003e\"{.Size} {.ID} {.Repository}:{.Tag}\"\u003c/span\u003e | \\\n  \u003cspan class=\"hljs-variable constant_\"\u003eLANG\u003c/span\u003e=en_US sort -h | \\\n  column -t\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래와 같이 출력됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(...)\n\u003cspan class=\"hljs-number\"\u003e9.\u003c/span\u003e43GB  8ab26e6b7035  mczuk/\u003cspan class=\"hljs-attr\"\u003epoldeepner2\u003c/span\u003e:kpwr_timex_1\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e9.\u003c/span\u003e58GB  8b50a5264fa1  mczuk/\u003cspan class=\"hljs-attr\"\u003epoldeepner2\u003c/span\u003e:nkjp_base_sq\n\u003cspan class=\"hljs-number\"\u003e9.\u003c/span\u003e74GB  46d6ea3f8fea  nvidia/\u003cspan class=\"hljs-attr\"\u003ecuda\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e11.8\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e-cudnn8-devel-ubuntu20\u003cspan class=\"hljs-number\"\u003e.04\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e10.\u003c/span\u003e5GB  9788da8da088  \u0026#x3C;none\u003e:\u0026#x3C;none\u003e\n\u003cspan class=\"hljs-number\"\u003e10.\u003c/span\u003e8GB  484fc54f67e7  \u0026#x3C;none\u003e:\u0026#x3C;none\u003e\n\u003cspan class=\"hljs-number\"\u003e10.\u003c/span\u003e8GB  b9bb30fe2458  \u0026#x3C;none\u003e:\u0026#x3C;none\u003e\n\u003cspan class=\"hljs-number\"\u003e11.\u003c/span\u003e3GB  d37700724b89  \u0026#x3C;none\u003e:\u0026#x3C;none\u003e\n\u003cspan class=\"hljs-number\"\u003e18.\u003c/span\u003e3GB  1d9a58a6fcf5  nvcr.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/nvidia/\u003cspan class=\"hljs-attr\"\u003epytorch\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e22.12\u003c/span\u003e-py3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e특정 도커 이미지를 제거하려면 docker image rm ID [4]를 사용합니다.\u003c/p\u003e\n\u003ch1\u003eMiniconda 환경\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e각 프로젝트마다 별도의 Python 환경을 실행하는 것은 좋은 습관입니다. 이렇게 하면 라이브러리 의존성 간 충돌을 피하거나 두 개 이상의 프로젝트가 동일한 환경을 공유하는 상황을 방지할 수 있습니다. 한 프로젝트를 업데이트하면 다른 프로젝트가 작동을 중지하는 일도 없어집니다.\u003c/p\u003e\n\u003cp\u003ePython 환경을 관리하는 인기 있는 솔루션 중 하나는 Miniconda입니다. Miniconda는 모든 환경을 한 곳에 유지함으로써, 보유한 환경 수와 사용 용량을 확인하기 쉽습니다. 환경은 ~/miniconda3/envs에 저장됩니다. 여러 환경을 보유하는 것은 문제가 되지 않을 수 있지만, GPU를 사용한 ML 모델 학습이나 추론을 할 때 NVidia 라이브러리(CUDA, cuDNN, cuBLAS 등)를 사용하는 경우가 많습니다. 이들은 상당히 많은 용량을 차지하고 있습니다. 기본 설정만 해도 약 10GB가 필요하며, 다른 의존성을 고려하지 않았습니다. Miniconda에서는 각 환경이 모듈의 복사본을 가지고 있기 때문에 공간 사용량이 더해지게 됩니다.\u003c/p\u003e\n\u003cp\u003e저의 경우, miniconda3/envs 폴더는 230GB를 차지하고 있으며 100개 이상의 환경이 있습니다. 이미 일부 환경을 용량 부족으로 제거했었죠 ;-)\u003c/p\u003e\n\u003cp\u003e오래된, 사용하지 않는 환경은 신중히 제거해야 합니다. 일부 오래된 프로젝트는 문제없이 함께 작동하는 라이브러리 조합을 가질 수 있습니다. 대부분의 프로젝트들은 환경을 생성할 수 있는 필수 라이브러리 목록(requirements.txt 또는 pyproject.toml)을 갖고 있어야 합니다. 그러나 몇 가지 모듈은 요구사항 목록이나 사용하는 라이브러리 중 하나에 특정 버전이 누락될 수 있습니다. 이러한 경우 정확한 라이브러리 조합을 다시 만드는 것이 어려울 수 있습니다. 이에 대한 해결책으로 pip freeze 명령을 사용하여 라이브러리의 정확한 버전을 덤프하고 나중에 검증할 수 있습니다. 기억해야 할 점은, 심지어 작은 변경이나 패치라도 라이브러리 간의 호환성에 일부 문제를 초래할 수 있는 일반적인 문제입니다. 해서서는 안 되지만 그렇게 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eMiniconda 패키지\u003c/h1\u003e\n\u003cp\u003eMiniconda는 conda install 명령어로 설치된 패키지를 캐시합니다. 캐시는 ~/miniconda3/pkgs 폴더에 위치해 있습니다. 제 경우엔 62GB입니다. 해당 폴더를 열어보면 여러 버전의 패키지가 몇 개만 있는 것을 볼 수 있습니다. 예전 버전은 종종 필요하지 않을 수 있어 쉽게 삭제할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003eHuggingface 모델 및 데이터셋\u003c/h1\u003e\n\u003cp\u003eHuggingface는 transformers 라이브러리를 통해 사용하는 모델 및 데이터셋을 모두 캐시합니다. 제 캐시의 분석을 통해 알 수 있는 정보가 여기에 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e허깅페이스 캐시에서 모델을 제거하는 것이 이전 파이썬 환경을 제거하는 것보다 안전합니다. 모델은 리포지토리에서 다시 다운로드할 수 있습니다. (단, 리포지토리에서 제거되지 않은 경우) 그럼에도 불구하고 캐시에는 기억하지 못하는 모델이 많이 있음을 알게 될 것입니다.\u003c/p\u003e\n\u003ch1\u003e파이썬 pip 캐시\u003c/h1\u003e\n\u003cp\u003e마지막 위치는 pip 캐시로, pip로 설치된 파이썬 모듈을 보관합니다. 캐시에 대한 정보를 표시하려면 pip cache info [6]를 사용할 수 있습니다. 아래와 같이 출력됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e패키지 인덱스 페이지 캐시 위치 (pip v23\u003cspan class=\"hljs-number\"\u003e.3\u003c/span\u003e+): \u003cspan class=\"hljs-regexp\"\u003e/home/\u003c/span\u003eczuk/.\u003cspan class=\"hljs-property\"\u003ecache\u003c/span\u003e/pip/http-v2\n패키지 인덱스 페이지 캐시 위치 (이전 버전 pips): \u003cspan class=\"hljs-regexp\"\u003e/home/\u003c/span\u003eczuk/.\u003cspan class=\"hljs-property\"\u003ecache\u003c/span\u003e/pip/http\n패키지 인덱스 페이지 캐시 크기: \u003cspan class=\"hljs-number\"\u003e18297.6\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eMB\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eHTTP\u003c/span\u003e 파일 수: \u003cspan class=\"hljs-number\"\u003e3025\u003c/span\u003e\n로컬 빌드된 휠 위치: \u003cspan class=\"hljs-regexp\"\u003e/home/\u003c/span\u003eczuk/.\u003cspan class=\"hljs-property\"\u003ecache\u003c/span\u003e/pip/wheels\n로컬 빌드된 휠 크기: \u003cspan class=\"hljs-number\"\u003e457\u003c/span\u003e kB\n로컬 빌드된 휠 수: \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저의 경우에는 18 GB입니다. pip 캐시를 정리하기 위해 pip cache purge 명령을 사용할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e정기적인 디스크 사용량 관리는 공간 부족 오류로부터 자신을 보호하는 데 중요합니다. 급한 계산을 해야 할 때 메시지가 나타나면 정말 골치 아플 수 있습니다. 그런데 공간이 부족해서 계산 작업을 완료할 수 없는 경우가 발생할 수 있습니다. 로컬 워크스테이션이 아닌 워크스테이션에서 모델 훈련이나 다른 계산을 수행하고 있을 때 심지어 작업이 중단될 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e클라우드 서비스를 사용할 때는 디스크 사용량 관리가 특히 중요합니다. 원격 인스턴스나 SageMaker와 같은 ML 플랫폼을 사용할 때 공간을 사용하면 요금이 청구됩니다. 로컬 워크스테이션에서 공간이 부족한 메시지가 나타날 수 있습니다. 클라우드에서는 저장 용량이 거의 무한합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e참고 자료\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.rapidtables.com/tools/bar-graph.html\" rel=\"nofollow\" target=\"_blank\"\u003e바 그래프 도구\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.docker.com/reference/cli/docker/system/df/\" rel=\"nofollow\" target=\"_blank\"\u003e도커 CLI 시스템 리소스 확인\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.docker.com/config/pruning/\" rel=\"nofollow\" target=\"_blank\"\u003e도커 자원 정리 설정\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e[4] \u003ca href=\"https://docs.docker.com/reference/cli/docker/image/rm/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://docs.docker.com/reference/cli/docker/image/rm/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e[5] \u003ca href=\"https://docs.anaconda.com/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://docs.anaconda.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e[6] \u003ca href=\"https://pip.pypa.io/en/stable/cli/pip_cache/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://pip.pypa.io/en/stable/cli/pip_cache/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e[7] \u003ca href=\"https://aws.amazon.com/pm/sagemaker\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://aws.amazon.com/pm/sagemaker\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e[8] \u003ca href=\"https://medium.com/codenlp/6-things-about-sagemaker-i-wish-i-had-known-earlier-revision-2-e90511d58ca5#beed\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://medium.com/codenlp/6-things-about-sagemaker-i-wish-i-had-known-earlier-revision-2-e90511d58ca5#beed\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-HowtoAvoidtheOut-of-SpaceProblemAGuidelineforanMLEngineer"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>