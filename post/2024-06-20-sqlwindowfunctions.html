<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SQL 윈도우 함수 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-20-sqlwindowfunctions" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SQL 윈도우 함수 | itposting" data-gatsby-head="true"/><meta property="og:title" content="SQL 윈도우 함수 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-sqlwindowfunctions_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-20-sqlwindowfunctions" data-gatsby-head="true"/><meta name="twitter:title" content="SQL 윈도우 함수 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-sqlwindowfunctions_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 14:38" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SQL 윈도우 함수</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SQL 윈도우 함수" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-sqlwindowfunctions&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-20-sqlwindowfunctions_0.png">
<p>SQL 윈도우 함수는 현재 행과 관련된 일련의 테이블 행 전체에서 계산을 수행하는 강력한 도구입니다. 이러한 함수는 결과 집합을 단일 행으로 그룹화하지 않고, 순위, 러닝 합계, 이동 평균 등을 포함한 복잡한 쿼리를 실행하는 방법을 제공합니다. 여기에 일반적으로 사용되는 SQL 윈도우 함수 중 일부가 있습니다:</p>
<h1>1. ROW_NUMBER()</h1>
<p>결과 집합의 각 파티션 내에서 행에 고유한 연속 정수를 할당하며, 각 파티션의 첫 번째 행에 대해 1부터 시작합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
    column1,
    <span class="hljs-title function_">ROW_NUMBER</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> column2 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> column3) <span class="hljs-variable constant_">AS</span> row_num
<span class="hljs-variable constant_">FROM</span> 
    table_name;
</code></pre>
<h1>2. RANK()</h1>
<p>Assigns a rank to each row within a partition of a result set. The rank of a row is one plus the number of ranks that come before it. Ties receive the same rank, and the next rank(s) are skipped.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
    column1,
    <span class="hljs-title function_">RANK</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> column2 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> column3) <span class="hljs-variable constant_">AS</span> rank
<span class="hljs-variable constant_">FROM</span> 
    table_name;
</code></pre>
<div class="content-ad"></div>
<h1>3. DENSE_RANK()</h1>
<p>RANK()과 유사하지만 랭킹 시퀀스에 갭이 없습니다. 동점인 경우 동일한 순위를 받고, 다음 순위는 1씩 증가합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
    column1,
    <span class="hljs-title function_">DENSE_RANK</span>() <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> column2 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> column3) <span class="hljs-variable constant_">AS</span> dense_rank
<span class="hljs-variable constant_">FROM</span> 
    table_name;
</code></pre>
<h1>4. NTILE(n)</h1>
<div class="content-ad"></div>
<p>결과 집합을 대략적으로 n개의 동일한 부분으로 나누고 각 행에 1부터 n까지 버킷 번호를 할당합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
    column1,
    <span class="hljs-title function_">NTILE</span>(<span class="hljs-number">4</span>) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> column2) <span class="hljs-variable constant_">AS</span> quartile
<span class="hljs-variable constant_">FROM</span> 
    table_name;
</code></pre>
<p><strong>5. LAG()</strong></p>
<p>결과 집합 내 현재 행 이전에 있는 주어진 물리적 오프셋의 행에 액세스할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> 
    column1,
    <span class="hljs-built_in">LAG</span>(column2, <span class="hljs-number">1</span>) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column3) <span class="hljs-keyword">AS</span> prev_value
<span class="hljs-keyword">FROM</span> 
    table_name;
</code></pre>
<h2>6. LEAD()</h2>
<p>현재 행 다음에 나오는 주어진 물리적 오프셋 위치의 행에 대한 액세스를 제공합니다.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">SELECT</span> 
    column1,
    <span class="hljs-built_in">LEAD</span>(column2, <span class="hljs-number">1</span>) <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column3) <span class="hljs-keyword">AS</span> next_value
<span class="hljs-keyword">FROM</span> 
    table_name;
</code></pre>
<div class="content-ad"></div>
<h1>7. FIRST_VALUE()</h1>
<p>주어진 값들의 정렬된 세트에서 첫 번째 값을 반환합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
    column1,
    <span class="hljs-title function_">FIRST_VALUE</span>(column2) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> column3 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> column4) <span class="hljs-variable constant_">AS</span> first_val
<span class="hljs-variable constant_">FROM</span> 
    table_name;
</code></pre>
<h1>8. LAST_VALUE()</h1>
<div class="content-ad"></div>
<p>주어진 값들의 정렬된 세트에서 마지막 값을 반환합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
    column1,
    <span class="hljs-title function_">LAST_VALUE</span>(column2) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> column3 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> column4 <span class="hljs-variable constant_">ROWS</span> <span class="hljs-variable constant_">BETWEEN</span> <span class="hljs-variable constant_">UNBOUNDED</span> <span class="hljs-variable constant_">PRECEDING</span> <span class="hljs-variable constant_">AND</span> <span class="hljs-variable constant_">UNBOUNDED</span> <span class="hljs-variable constant_">FOLLOWING</span>) <span class="hljs-variable constant_">AS</span> last_val
<span class="hljs-variable constant_">FROM</span> 
    table_name;
</code></pre>
<h2>9. SUM()</h2>
<p>지정된 윈도우 프레임에서 값들의 합을 계산합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
    column1,
    <span class="hljs-title function_">SUM</span>(column2) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> column3 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> column4) <span class="hljs-variable constant_">AS</span> running_total
<span class="hljs-variable constant_">FROM</span> 
    table_name;
</code></pre>
<h1>10. AVG()</h1>
<p>Calculates the average of values in a specified window frame.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
    column1,
    <span class="hljs-title function_">AVG</span>(column2) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> column3 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> column4) <span class="hljs-variable constant_">AS</span> running_avg
<span class="hljs-variable constant_">FROM</span> 
    table_name;
</code></pre>
<div class="content-ad"></div>
<h1>11. MIN() 및 MAX()</h1>
<p>지정된 창 프레임 내에서 최소값 및 최대값을 반환합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
    column1,
    <span class="hljs-title function_">MIN</span>(column2) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> column3 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> column4) <span class="hljs-variable constant_">AS</span> min_val,
    <span class="hljs-title function_">MAX</span>(column2) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> column3 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> column4) <span class="hljs-variable constant_">AS</span> max_val
<span class="hljs-variable constant_">FROM</span> 
    table_name;
</code></pre>
<h1>창 명세화</h1>
<div class="content-ad"></div>
<p>OVER 절은 세 부분으로 구성될 수 있습니다:</p>
<ul>
<li>PARTITION BY: 윈도우 함수가 적용되는 파티션으로 결과 세트를 분할합니다.</li>
<li>ORDER BY: 각 파티션 내 행의 논리적 순서를 정의합니다.</li>
<li>Window Frame: 함수가 적용되는 파티션의 하위 집합을 지정합니다 (예: 1 PRECEDING부터 현재 행까지의 ROWS).</li>
</ul>
<p>완전한 윈도우 명세를 사용한 예시:</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
    column1,
    <span class="hljs-title function_">SUM</span>(column2) <span class="hljs-variable constant_">OVER</span> (<span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> column3 <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> column4 <span class="hljs-variable constant_">ROWS</span> <span class="hljs-variable constant_">BETWEEN</span> <span class="hljs-number">1</span> <span class="hljs-variable constant_">PRECEDING</span> <span class="hljs-variable constant_">AND</span> <span class="hljs-variable constant_">CURRENT</span> <span class="hljs-variable constant_">ROW</span>) <span class="hljs-variable constant_">AS</span> running_total
<span class="hljs-variable constant_">FROM</span> 
    table_name;
</code></pre>
<div class="content-ad"></div>
<p>이러한 함수들을 사용하면 복잡한 계산을 처리하는 더 효율적이고 가독성이 좋은 방법을 제공하여 SQL 내에서 고급 데이터 분석을 수행할 수 있습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SQL 윈도우 함수","description":"","date":"2024-06-20 14:38","slug":"2024-06-20-sqlwindowfunctions","content":"\n\n\n\u003cimg src=\"/assets/img/2024-06-20-sqlwindowfunctions_0.png\" /\u003e\n\nSQL 윈도우 함수는 현재 행과 관련된 일련의 테이블 행 전체에서 계산을 수행하는 강력한 도구입니다. 이러한 함수는 결과 집합을 단일 행으로 그룹화하지 않고, 순위, 러닝 합계, 이동 평균 등을 포함한 복잡한 쿼리를 실행하는 방법을 제공합니다. 여기에 일반적으로 사용되는 SQL 윈도우 함수 중 일부가 있습니다:\n\n# 1. ROW_NUMBER()\n\n결과 집합의 각 파티션 내에서 행에 고유한 연속 정수를 할당하며, 각 파티션의 첫 번째 행에 대해 1부터 시작합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n```js\nSELECT \n    column1,\n    ROW_NUMBER() OVER (PARTITION BY column2 ORDER BY column3) AS row_num\nFROM \n    table_name;\n```\n\n# 2. RANK()\n\nAssigns a rank to each row within a partition of a result set. The rank of a row is one plus the number of ranks that come before it. Ties receive the same rank, and the next rank(s) are skipped.\n\n```js\nSELECT \n    column1,\n    RANK() OVER (PARTITION BY column2 ORDER BY column3) AS rank\nFROM \n    table_name;\n``` \n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. DENSE_RANK()\n\nRANK()과 유사하지만 랭킹 시퀀스에 갭이 없습니다. 동점인 경우 동일한 순위를 받고, 다음 순위는 1씩 증가합니다.\n\n```js\nSELECT \n    column1,\n    DENSE_RANK() OVER (PARTITION BY column2 ORDER BY column3) AS dense_rank\nFROM \n    table_name;\n```\n\n# 4. NTILE(n)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n결과 집합을 대략적으로 n개의 동일한 부분으로 나누고 각 행에 1부터 n까지 버킷 번호를 할당합니다.\n\n```js\nSELECT \n    column1,\n    NTILE(4) OVER (ORDER BY column2) AS quartile\nFROM \n    table_name;\n```\n\n**5. LAG()**\n\n결과 집합 내 현재 행 이전에 있는 주어진 물리적 오프셋의 행에 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sql\nSELECT \n    column1,\n    LAG(column2, 1) OVER (ORDER BY column3) AS prev_value\nFROM \n    table_name;\n```\n\n## 6. LEAD()\n\n현재 행 다음에 나오는 주어진 물리적 오프셋 위치의 행에 대한 액세스를 제공합니다.\n\n```sql\nSELECT \n    column1,\n    LEAD(column2, 1) OVER (ORDER BY column3) AS next_value\nFROM \n    table_name;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7. FIRST_VALUE()\n\n주어진 값들의 정렬된 세트에서 첫 번째 값을 반환합니다.\n\n```js\nSELECT \n    column1,\n    FIRST_VALUE(column2) OVER (PARTITION BY column3 ORDER BY column4) AS first_val\nFROM \n    table_name;\n```\n\n# 8. LAST_VALUE()\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주어진 값들의 정렬된 세트에서 마지막 값을 반환합니다.\n\n```js\nSELECT \n    column1,\n    LAST_VALUE(column2) OVER (PARTITION BY column3 ORDER BY column4 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\nFROM \n    table_name;\n```\n\n## 9. SUM()\n\n지정된 윈도우 프레임에서 값들의 합을 계산합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nSELECT \n    column1,\n    SUM(column2) OVER (PARTITION BY column3 ORDER BY column4) AS running_total\nFROM \n    table_name;\n```\n\n# 10. AVG()\n\nCalculates the average of values in a specified window frame.\n\n```js\nSELECT \n    column1,\n    AVG(column2) OVER (PARTITION BY column3 ORDER BY column4) AS running_avg\nFROM \n    table_name;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 11. MIN() 및 MAX()\n\n지정된 창 프레임 내에서 최소값 및 최대값을 반환합니다.\n\n```js\nSELECT \n    column1,\n    MIN(column2) OVER (PARTITION BY column3 ORDER BY column4) AS min_val,\n    MAX(column2) OVER (PARTITION BY column3 ORDER BY column4) AS max_val\nFROM \n    table_name;\n```\n\n# 창 명세화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOVER 절은 세 부분으로 구성될 수 있습니다:\n\n- PARTITION BY: 윈도우 함수가 적용되는 파티션으로 결과 세트를 분할합니다.\n- ORDER BY: 각 파티션 내 행의 논리적 순서를 정의합니다.\n- Window Frame: 함수가 적용되는 파티션의 하위 집합을 지정합니다 (예: 1 PRECEDING부터 현재 행까지의 ROWS).\n\n완전한 윈도우 명세를 사용한 예시:\n\n```js\nSELECT \n    column1,\n    SUM(column2) OVER (PARTITION BY column3 ORDER BY column4 ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS running_total\nFROM \n    table_name;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 함수들을 사용하면 복잡한 계산을 처리하는 더 효율적이고 가독성이 좋은 방법을 제공하여 SQL 내에서 고급 데이터 분석을 수행할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-sqlwindowfunctions_0.png"},"coverImage":"/assets/img/2024-06-20-sqlwindowfunctions_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-20-sqlwindowfunctions_0.png\"\u003e\n\u003cp\u003eSQL 윈도우 함수는 현재 행과 관련된 일련의 테이블 행 전체에서 계산을 수행하는 강력한 도구입니다. 이러한 함수는 결과 집합을 단일 행으로 그룹화하지 않고, 순위, 러닝 합계, 이동 평균 등을 포함한 복잡한 쿼리를 실행하는 방법을 제공합니다. 여기에 일반적으로 사용되는 SQL 윈도우 함수 중 일부가 있습니다:\u003c/p\u003e\n\u003ch1\u003e1. ROW_NUMBER()\u003c/h1\u003e\n\u003cp\u003e결과 집합의 각 파티션 내에서 행에 고유한 연속 정수를 할당하며, 각 파티션의 첫 번째 행에 대해 1부터 시작합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    column1,\n    \u003cspan class=\"hljs-title function_\"\u003eROW_NUMBER\u003c/span\u003e() \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column2 \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column3) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e row_num\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \n    table_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e2. RANK()\u003c/h1\u003e\n\u003cp\u003eAssigns a rank to each row within a partition of a result set. The rank of a row is one plus the number of ranks that come before it. Ties receive the same rank, and the next rank(s) are skipped.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    column1,\n    \u003cspan class=\"hljs-title function_\"\u003eRANK\u003c/span\u003e() \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column2 \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column3) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e rank\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \n    table_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e3. DENSE_RANK()\u003c/h1\u003e\n\u003cp\u003eRANK()과 유사하지만 랭킹 시퀀스에 갭이 없습니다. 동점인 경우 동일한 순위를 받고, 다음 순위는 1씩 증가합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    column1,\n    \u003cspan class=\"hljs-title function_\"\u003eDENSE_RANK\u003c/span\u003e() \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column2 \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column3) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e dense_rank\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \n    table_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e4. NTILE(n)\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e결과 집합을 대략적으로 n개의 동일한 부분으로 나누고 각 행에 1부터 n까지 버킷 번호를 할당합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    column1,\n    \u003cspan class=\"hljs-title function_\"\u003eNTILE\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column2) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e quartile\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \n    table_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e5. LAG()\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e결과 집합 내 현재 행 이전에 있는 주어진 물리적 오프셋의 행에 액세스할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \n    column1,\n    \u003cspan class=\"hljs-built_in\"\u003eLAG\u003c/span\u003e(column2, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eBY\u003c/span\u003e column3) \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e prev_value\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e \n    table_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e6. LEAD()\u003c/h2\u003e\n\u003cp\u003e현재 행 다음에 나오는 주어진 물리적 오프셋 위치의 행에 대한 액세스를 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sql\"\u003e\u003cspan class=\"hljs-keyword\"\u003eSELECT\u003c/span\u003e \n    column1,\n    \u003cspan class=\"hljs-built_in\"\u003eLEAD\u003c/span\u003e(column2, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eBY\u003c/span\u003e column3) \u003cspan class=\"hljs-keyword\"\u003eAS\u003c/span\u003e next_value\n\u003cspan class=\"hljs-keyword\"\u003eFROM\u003c/span\u003e \n    table_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e7. FIRST_VALUE()\u003c/h1\u003e\n\u003cp\u003e주어진 값들의 정렬된 세트에서 첫 번째 값을 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    column1,\n    \u003cspan class=\"hljs-title function_\"\u003eFIRST_VALUE\u003c/span\u003e(column2) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column3 \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column4) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e first_val\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \n    table_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e8. LAST_VALUE()\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e주어진 값들의 정렬된 세트에서 마지막 값을 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    column1,\n    \u003cspan class=\"hljs-title function_\"\u003eLAST_VALUE\u003c/span\u003e(column2) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column3 \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column4 \u003cspan class=\"hljs-variable constant_\"\u003eROWS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eUNBOUNDED\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRECEDING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eUNBOUNDED\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eFOLLOWING\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e last_val\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \n    table_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e9. SUM()\u003c/h2\u003e\n\u003cp\u003e지정된 윈도우 프레임에서 값들의 합을 계산합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    column1,\n    \u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(column2) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column3 \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column4) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e running_total\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \n    table_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e10. AVG()\u003c/h1\u003e\n\u003cp\u003eCalculates the average of values in a specified window frame.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    column1,\n    \u003cspan class=\"hljs-title function_\"\u003eAVG\u003c/span\u003e(column2) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column3 \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column4) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e running_avg\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \n    table_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e11. MIN() 및 MAX()\u003c/h1\u003e\n\u003cp\u003e지정된 창 프레임 내에서 최소값 및 최대값을 반환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    column1,\n    \u003cspan class=\"hljs-title function_\"\u003eMIN\u003c/span\u003e(column2) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column3 \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column4) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e min_val,\n    \u003cspan class=\"hljs-title function_\"\u003eMAX\u003c/span\u003e(column2) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column3 \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column4) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e max_val\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \n    table_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e창 명세화\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eOVER 절은 세 부분으로 구성될 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePARTITION BY: 윈도우 함수가 적용되는 파티션으로 결과 세트를 분할합니다.\u003c/li\u003e\n\u003cli\u003eORDER BY: 각 파티션 내 행의 논리적 순서를 정의합니다.\u003c/li\u003e\n\u003cli\u003eWindow Frame: 함수가 적용되는 파티션의 하위 집합을 지정합니다 (예: 1 PRECEDING부터 현재 행까지의 ROWS).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e완전한 윈도우 명세를 사용한 예시:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    column1,\n    \u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(column2) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column3 \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e column4 \u003cspan class=\"hljs-variable constant_\"\u003eROWS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRECEDING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCURRENT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROW\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e running_total\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \n    table_name;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이러한 함수들을 사용하면 복잡한 계산을 처리하는 더 효율적이고 가독성이 좋은 방법을 제공하여 SQL 내에서 고급 데이터 분석을 수행할 수 있습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-sqlwindowfunctions"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>