<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>초보자를 위한 통합 가이드 Python을 사용한 LLM 로컬 배포 쉽게 하는 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="초보자를 위한 통합 가이드 Python을 사용한 LLM 로컬 배포 쉽게 하는 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="초보자를 위한 통합 가이드 Python을 사용한 LLM 로컬 배포 쉽게 하는 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython" data-gatsby-head="true"/><meta name="twitter:title" content="초보자를 위한 통합 가이드 Python을 사용한 LLM 로컬 배포 쉽게 하는 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 19:17" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">초보자를 위한 통합 가이드 Python을 사용한 LLM 로컬 배포 쉽게 하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="초보자를 위한 통합 가이드 Python을 사용한 LLM 로컬 배포 쉽게 하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">18<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython_0.png" alt="2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython_0.png"></p>
<p>인터넷에는 개인 컴퓨터에서 대형 언어 모델 (LLMs)을 실행하는 방법에 대한 가이드가 넘쳐나지만, 이 방대한 정보를 효율적으로 탐색하는 것은 특히 새로운 사용자에게는 어려운 일일 수 있습니다. 대부분의 가이드는 특정 접근 방식에 초점을 맞추기 때문에 초보자들이 포괄적인 길을 찾기 어려울 수 있습니다. 여기서 저의 기사가 등장하여, 몇 가지 유명한 방법들을 하나로 통합하고 초보자들을 위해 특별히 제작된 이를 제공합니다. 이 가이드의 독특한 접근 방식은 Python 기반 방법에 집중하고 있으며, Python의 간단함과 AI 커뮤니티 내에서의 광범위한 사용을 인정하고 있습니다. 이 가이드는 깔끔하고 단계별 지침서, 다양한 Python 라이브러리와 도구에 대한 통찰, 그리고 실용적인 팁을 제공하여 당신의 LLMs 세계로의 진입을 원활하게 만들어주려고 만들어졌습니다. 기술적인 세부 사항의 다양성이 혼란스럽게 느껴졌거나 선택지가 많았던 분들에게는 이 기사가 꼭 필요한 리소스로, 당신의 컴퓨터에서 LLMs를 직접 실행하기 위한 접근 가능하고 깨우침을 주는 여정을 보장합니다. 여러 프레임워크에서 모델을 작업하는 빠른 소개를 제공하는 이 기사는 CPU 또는 GPU를 사용하더라도 모든 측면을 깊이 다루지는 않습니다. 더 포괄적인 통찰을 위해서는 관련 문서를 참고하는 것이 좋습니다.</p>
<p>이 가이드는 다음을 사용하여 LLMs를 로컬로 실행하는 방법을 공유할 것입니다</p>
<ul>
<li>Huggingface: 방대한 모델 저장소와 직관적 인터페이스를 갖춘 포괄적인 라이브러리.</li>
<li>Llama.cpp Python: llama.cpp를 활용해 성능이 C++ 수준인 LLMs를 사용하는 Python 친화적 프론트 엔드.</li>
<li>llama.cpp 기반 GPT-3.5에 대한 API 드롭인 대체: 모델을 독립된 프로세스에서 실행하면, 동일한 기계 또는 서버에서 GPT 3.5 클라이언트들이 사용하는 API와 유사한 방식으로 추론이 가능해집니다.</li>
</ul>
<div class="content-ad"></div>
<p>상기한 방법들은 13세대 인텔 랩터 레이크 프로세서가 탑재된 Windows 11 시스템에서 WSL2을 사용하여 성공적으로 테스트되었으며, NVIDIA RTX 3060 카드와 16GB 메모리, CUDA 버전 12.1을 사용하고 있습니다.</p>
<h1>대형 언어 모델(LLM) 실행에 대한 고려 사항</h1>
<p>대형 언어 모델(LLM)의 세계로 진입하면 효율적인 배포와 운영을 위한 중요한 고려 사항이 드러납니다. 하드웨어 요구 사항부터 모델 액세스 프로토콜까지 각 요소가 LLM의 모든 잠재력을 활용하는 데 중요한 역할을 합니다.</p>
<p>LLM의 효율적인 운영을 위해서는 강력한 GPU가 필수적입니다. 퀀터제이션을 필요로 하는 모델들에게 특히 중요한데, GPT-2와 같은 작은 모델은 CPU에서 실행할 수 있지만 시스템 RAM에 제한을 받습니다. 예를 들어, GPT-2의 500MB 크기는 현대 CPU에서 관리가 가능하지만,  Llama 2 7B(13GB 크기)와 같은 큰 모델은 기술적으로 CPU에서 실행할 수 있지만, 충분한 RAM이 있어도 추론 속도가 느려집니다.</p>
<div class="content-ad"></div>
<p>HuggingFace 라이브러리는 자동 모델 다운로드를 용이하게 하고 다양한 모델에 액세스할 수 있도록 도와줍니다. Meta의 Llama2와 같은 일부 모델에 액세스하려면 Hugging Face를 통해 계정 설정, 애플리케이션 검토 및 Meta의 사용 정책 준수가 필요한 승인 프로세스가 필요합니다.</p>
<p>GPU 배포는 GPU RAM 용량에 따라 LLM에 가장 적합합니다. 일반적으로 모델은 float16 또는 float32 포맷이며, NVidia 4060 Ti와 같이 더 높은 용량을 갖는 GPU에서는 전체 모델 로딩이 가능합니다(16GB RAM). RAM이 적은 GPU의 경우 양자화는 원래 크기의 일부로 메모리 요구사항을 줄여 호환성 및 추론 속도를 향상시키지만, 정확도 손실은 최소화됩니다. GPU 기반 LLM 작업에는 전반적으로 양자화를 권장합니다. 양자화는 대규모 언어 모델(LLMs)이 로컬 기계에서 효율적으로 작동할 수 있도록 하는 데 중요한 역할을 합니다. 기본적으로 양자화는 모델의 가중치를 표현하는 데 사용되는 숫자의 정밀도를 줄이는 프로세스로, 성능을 크게 희생하지 않으면서 모델의 크기를 크게 줄입니다. GPU 추론에 대해, 이 가이드는 Nvidia GPU를 CUDA 프레임워크와 함께 사용하는 데 초점을 맞추고 있습니다.</p>
<p>Google Colab은 Nvidia GPU에 액세스하여 개인 하드웨어가 필요하지 않게 해주는 편리한 클라우드 기반 솔루션을 제공합니다. 주요 라이브러리와의 쉬운 통합을 지원하여 모델 실행이 간편해집니다. 그러나 무료 계정 사용자는 액세스 기간 제한 및 GPU 가용성과 같은 제한 사항을 직면할 수 있으며, 이는 긴 기간 또는 더 많은 리소스를 필요로 하는 프로젝트에 영향을 줄 수 있습니다.</p>
<div class="content-ad"></div>
<p>이제 이러한 구성 요소를 각각 설정하는 구체적인 내용을 살펴보겠습니다.</p>
<hr>
<h2>HuggingFace 사용하기</h2>
<p>Hugging Face는 자연 언어 처리(NLP) 분야에서 특히 열린 소스 라이브러리인 Transformers를 갖고 인공 지능 분야를 혁신시켰습니다. 이 라이브러리는 텍스트 분류 및 언어 생성과 같은 작업을 위한 다양한 사전 훈련된 모델을 제공하여 복잡한 NLP 작업의 구현을 간단하게 합니다. 그들의 작업은 다양한 분야에서 AI 응용 프로그램을 신속하게 개발할 수 있도록 하며 모델을 처음부터 훈련할 필요가 없게 합니다.</p>
<div class="content-ad"></div>
<h1>설정</h1>
<p>작동되는 구성:</p>
<ul>
<li>Python 3.8+ (3.10 버전에서 테스트됨)</li>
<li>Windows 11, Windows Subsystem for Linux (WSL) 및 Ubuntu 22.04에서 확인됨.</li>
<li>Transformer 버전 4.36.1에서 테스트됨 (이후 버전은 inference.py에 변경이 필요할 수 있음)</li>
<li>Intel 12세대 이상</li>
<li>(선택 사항) GPU (예: Nvidia RTX3060 12 GB) 및 CUDA 12.1이 장착되어 있음</li>
</ul>
<p>다음 섹션에서는 CPU 전용 및 GPU용으로 Linux 및 Windows에 대한 설치 지침을 나열할 것입니다. 해당 지침에 따라 설치하세요.</p>
<div class="content-ad"></div>
<p>Linux/WSL (CPU/GPU)</p>
<p>CPU만 설정하는 경우에 필요한 단계이며 GPU 설정을 구성하기 위한 예비 요구 사항으로도 사용됩니다.</p>
<pre><code class="hljs language-js">$ sudo apt install python3<span class="hljs-number">.10</span>-venv python3<span class="hljs-number">.10</span>-tk
$ pip install virtualenv 
$ python3<span class="hljs-number">.10</span> -m venv  venv
$ source ./venv/bin/activate
(venv)$ pip3 install tk numpy torch bertviz ipython transformers accelerate huggingface_hub hf_transfer
</code></pre>
<p>Linux/WSL (GPU)</p>
<div class="content-ad"></div>
<p>리눅스에서 GPU 지원을 위해 추가 패키지 설치하기</p>
<pre><code class="hljs language-js">(가상환경)$ pip3 install bitsandbytes accelerate autoawq optimum auto-gptq
</code></pre>
<p>Windows 설치 (CPU/GPU)</p>
<p>이 단계들은 CPU에서 설정하는 데 필수적이며, 윈도우에서 GPU 설정을 구성하는 데 기본 요구사항으로 작용합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">> pip install virtualenv
> python3<span class="hljs-number">.10</span> -m venv  venv
> venv\<span class="hljs-title class_">Scripts</span>\activate
(venv)> pip3 install tk numpy torch bertviz ipython transformers huggingface_hub hf_transfer
</code></pre>
<p>+Windows (GPU)</p>
<p>윈도우에서 GPU용 추가 패키지를 설치/업데이트 해주세요.</p>
<pre><code class="hljs language-js">(venv)> pip3 install accelerate autoawq optimum auto-gptq
(venv)> pip3 install torch torchvision torchaudio --index-url <span class="hljs-attr">https</span>:<span class="hljs-comment">//download.pytorch.org/whl/cu121</span>
(venv)> python -m pip install bitsandbytes==<span class="hljs-number">0.39</span><span class="hljs-number">.1</span> --prefer-binary --extra-index-url=<span class="hljs-attr">https</span>:<span class="hljs-comment">//jllllll.github.io/bitsandbytes-windows-webui</span>
</code></pre>
<div class="content-ad"></div>
<p>NVidia GPU에서 Large Language Models (LLMs)를 실행하기 위해 몇 가지 설치가 필요합니다:</p>
<ul>
<li>PyTorch 및 CUDA 설정: NVidia GPU 기능을 활용하기 위해 torch, torchvision 및 torchaudio를 CUDA 지원과 함께 설치해야 합니다. 일반적으로 Linux 사용자는 기본 PyTorch 설치에서 CUDA 지원을 받지만, Windows 사용자는 torch+cuda 설치를 위한 index-url을 지정해야 합니다. 최신 업데이트에 따르면 PyTorch는 CUDA toolkit 버전 12.1까지 호환됩니다. CUDA 호환성 및 설치 안내에 대한 최신 정보는 PyTorch 웹사이트 (PyTorch — 로컬에서 시작하기)에서 확인할 수 있습니다.</li>
<li>bitsandbytes 설치 변형: bitsandbytes의 표준 설치는 Linux에 최적화되어 있으며, 하나의 릴리스 빌드에서 여러 CUDA 버전을 수용합니다. 그러나 Windows 사용자는 소스에서 직접 빌드하거나 비공식 GitHub 저장소를 사용하여 설치해야 합니다. Windows용 구체적인 설치 지침은 이 기사의 이전 섹션에서 찾을 수 있습니다. Windows를 위한 추가 정보 및 안내는 bitsandbytes 비공식 Windows 저장소(<a href="https://github.com/jllllll/bitsandbytes-windows-webui)%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">https://github.com/jllllll/bitsandbytes-windows-webui)에서</a> 확인할 수 있습니다.</li>
<li>Cuda Toolkit 필요성: GPU 기반 작업을 용이하게 하기 위해 <a href="https://developer.nvidia.com/cuda-12-1-0-download-archive%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">https://developer.nvidia.com/cuda-12-1-0-download-archive에서</a> Cuda toolkit을 설치하세요. 사용 중인 torch+cuda 버전과 CUDA toolkit 버전을 일치시키는 것이 좋습니다. 현재 최신 torch는 CUDA 버전 12.1을 지원합니다.</li>
<li>Microsoft C++ 빌드 도구: Windows에서 GPU 프로세스를 실행하려면 Microsoft C++ 빌드 도구를 설치해야 합니다. 이는 accelarate 및 autoawq 패키지의 psutils 종속성으로 인한 것입니다.</li>
<li>autoawq 패키지는 GPU에서 AWQ 기반 양자화 모델을 실행해야 하는 경우에만 필요합니다.</li>
</ul>
<p>Windows 시스템의 특정 요구 사항을 고려하여 NVidia GPU에서 LLMs를 효과적으로 실행하기 위한 중요한 단계입니다. huggingface 설치 및 모델 다운로드에 대한 자세한 정보는 link1과 link2를 확인하세요.</p>
<p>Huggingface에 계정을 생성하면 토큰을 생성할 수 있는 능력이 생깁니다. 이 토큰은 export(예: HF_TOKEN)을 통해 환경에 구성하거나 Huggingface API와 함께 매개변수로 사용하여 모델 다운로드 및 다른 포턜 작업에 사용할 수 있습니다. 이 토큰은 서비스에 액세스하기 위한 패스로 생각할 수 있습니다. 또한 Llama와 같은 특정 모델을 다운로드하려면 승인이 필요할 수 있으며, 계정을 사용하여 Huggingface 포턜을 통해 요청할 수 있습니다. 부여된 모든 승인은 계정과 그 계정으로 생성된 모든 토큰과 연결됩니다.</p>
<div class="content-ad"></div>
<h1>추론</h1>
<p>이 스크립트는 추론 모드를 구체화하여 모델 실행에 적합한 하드웨어(CPU 또는 GPU)를 선택합니다. 만약 추론 모드가 'cpu'로 설정되어 있다면, GPT-2 모델이 로드되며, 작은 크기(~500MB)로 CPU 사용에 이상적이기 때문에 'cpu'로 설정된 device_map을 사용하여 타겟팅된 실행이 가능합니다. 반대로, GPU 사용 시에는 더 큰 Meta LLaMA 2 7B 모델(~13GB)을 선택하며, 'auto'로 설정된 device_map을 활용하여 유연한 장치 할당을 하고 load_in_4bit을 활성화하여 메모리 사용량을 최소화하여 한정된 메모리를 가진 GPU에서 큰 모델의 작동을 촉진합니다. pipeline 함수는 로드된 모델과 토크나이저를 사용하여 텍스트 생성 파이프라인을 생성하며, max_new_tokens와 같은 매개변수를 설정하여 생성된 텍스트의 길이를 제어합니다. 또한 streamer가 파이프라인에 전달되어, 스트리밍된 텍스트 생성이 사용될 것을 나타냅니다.</p>
<p>inference.py</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForCausalLM, TextStreamer, pipeline, BitsAndBytesConfig

inference_type = <span class="hljs-string">'cpu'</span>
<span class="hljs-keyword">if</span> inference_type == <span class="hljs-string">'cpu'</span>:
    <span class="hljs-comment"># CPU 추론</span>
    model_name = <span class="hljs-string">'gpt2'</span>  <span class="hljs-comment"># ~500MB 원본 크기</span>
    model = AutoModelForCausalLM.from_pretrained(
        model_name,
        device_map=<span class="hljs-string">'cpu'</span>
    )
<span class="hljs-keyword">else</span>:    
    <span class="hljs-comment"># GPU 추론; 'gpu'</span>
    model_name = <span class="hljs-string">'meta-llama/Llama-2-7b-hf'</span>  <span class="hljs-comment"># ~13GB 원본 크기</span>
    quantization_config = BitsAndBytesConfig(load_in_4bit=<span class="hljs-literal">True</span>, bnb_4bit_compute_dtype=torch.bfloat16)
    model = AutoModelForCausalLM.from_pretrained(
        model_name, 
        device_map=<span class="hljs-string">'auto'</span>,
        quantization_config=quantization_config)
tokenizer = AutoTokenizer.from_pretrained(model_name)
streamer = TextStreamer(
     tokenizer,
     skip_prompt=<span class="hljs-literal">False</span>,
     skip_special_tokens=<span class="hljs-literal">False</span>
)
text_pipeline = pipeline(
    <span class="hljs-string">"text-generation"</span>,
    model=model,
    tokenizer=tokenizer,
    max_new_tokens=<span class="hljs-number">100</span>,  <span class="hljs-comment"># 생성할 토큰의 최대 수</span>
    streamer=streamer,     
)
prompt=<span class="hljs-string">'I like apple pie'</span>
text_pipeline(prompt) 
</code></pre>
<div class="content-ad"></div>
<p>제공된 예제에서는 사전 학습된 모델을 사용하고 있습니다. 이 모델은 일련의 토큰과 같은 특정 키워드를 필요로 할 수도 있습니다. 모델이 이러한 토큰을 요구하는지 확인하려면 tokenizer_config.json 파일에서 add_bos_token 및 add_eos_token 설정을 확인할 수 있습니다. 이를 자동으로 처리하는 실용적인 방법은 text_pipeline 추론 호출에서 add_special_tokens=True (기본값 False)로 설정하는 것입니다. 이렇게 하면 프레임워크가 모델로 전송되기 전에 프롬프트에 특수 키워드를 삽입할지 여부를 결정할 수 있습니다. 위 예시에서는 해당 매개변수를 사용하지 않았습니다.</p>
<p>스크립트 실행</p>
<pre><code class="hljs language-js">(venv)$ python inference.<span class="hljs-property">py</span>
</code></pre>
<p>출력:</p>
<div class="content-ad"></div>
<p>BitsAndBytesConfig가 load_in_4bit=True로 전달되어 있습니다. 이는 변환 라이브러리에게 모델의 가중치를 4비트로 줄이라는 지시를하는 것이고, 이는 모델의 원래 크기의 25%에 해당합니다 (Llama 2는 float16 형식입니다). 이는 추론 속도를 향상시킵니다. bnb_4bit_compute_dtype는 torch.bfloat16으로 설정되어 있어 GPU에서 실제 계산이 여전히 float16로 수행되도록 합니다. 선택할 수 있는 대안 옵션은 load_in_8bit=True이며, load_in_4bit 옵션과 상호 배제됩니다. 8비트 모드는 약간 향상된 정확성을 제공하지만 모델 크기를 원래 크기의 50%로 줄이고 추론 속도를 낮춥니다. 양자화 옵션을 선택하지 않은 경우 변환 라이브러리는 가용한 VRAM에 따라 전체 모델을 GPU의 비디오 RAM에로드하는 것을 기본값으로 설정합니다.</p>
<h1>사전 양자화 모델 로드</h1>
<p>GPU 추론 시 모델을 로드할 때마다 양자화하는 대신, 디스크에서 사전 양자화 된 모델을로드할 수 있습니다. 인기있는 양자화 형식 중 두 가지는 GPTQ 및 AWQ입니다. Huggingface는 둘 다 지원합니다.</p>
<p>AWQ 유형 모델의 경우 아래 코드로 모델로드 라인을 대체하면 됩니다 (GPU 추론 경로에서). BitsAndBytesConfig 매개 변수가 생략됩니다. 왜냐하면 모델이 이미 양자화되어 있기 때문입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">model_name=<span class="hljs-string">'TheBloke/zephyr-7B-alpha-AWQ'</span> 
model = <span class="hljs-title class_">AutoModelForCausalLM</span>.<span class="hljs-title function_">from_pretrained</span>( 
    model_name, 
    device_map=<span class="hljs-string">'auto'</span>)
</code></pre>
<p>GPTQ 모델의 경우 아래 라인으로 모델 로드를 대체합니다.</p>
<pre><code class="hljs language-js">model_name=<span class="hljs-string">'TheBloke/zephyr-7B-beta-GPTQ'</span> 
model = <span class="hljs-title class_">AutoModelForCausalLM</span>.<span class="hljs-title function_">from_pretrained</span>( 
    model_name, 
    revision=<span class="hljs-string">'main'</span>, 
    device_map=<span class="hljs-string">'auto'</span>)
</code></pre>
<p>GitHub 브랜치에 해당하는 revision을 사용했습니다. zephyr-7B-beta-GPTQ 양자화 버전은 서로 다른 브랜치에 저장되어 있습니다. 자세한 내용은 <a href="https://huggingface.co/TheBloke/zephyr-7B-beta-GPTQ%EC%9D%98" rel="nofollow" target="_blank">https://huggingface.co/TheBloke/zephyr-7B-beta-GPTQ의</a> ‘Files and versions’ 탭을 참조해주세요.</p>
<div class="content-ad"></div>
<h1>GGUF 양자화</h1>
<p>GGUF는 llama.cpp에서 소개된 인기 있는 양자화 방법입니다. ctransformers는 GGML/GGUF 라이브러리를 사용하여 C/C++로 구현된 Transformer 모델용 Python 바인딩입니다. 또한 RAG Langchain과 통합되어 있습니다.</p>
<p>귀하의 구성에 따라 ctransformers 패키지를 설치하세요.</p>
<pre><code class="hljs language-js">(venv)$ pip install ctransformers
</code></pre>
<div class="content-ad"></div>
<p>huggingface-cli를 사용하여 GGUF 형식 모델을 다운로드하거나 from_pretrained() 호출을 통해 해당 모델의 첫 API 호출 시 자동으로 다운로드됩니다. 아래 코드 샘플은 GGUF 형식의 모델에 대해 ctransformers를 활용하는 방법을 보여줍니다. from_pretrained 메서드는 이전에 다운로드되지 않은 경우 Hugging Face에서 모델을 자동으로 가져옵니다. zephyr GGUF와 같은 일부 모델 유형은 동일한 리포지토리에 파일로 저장됩니다. 여기서 리포지토리 이름은 'TheBloke/zephyr-7B-beta-GGUF'이고 모델 파일은 zephyr-7b-beta.Q4_K_M.gguf입니다.</p>
<p>inference.py</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> ctransformers <span class="hljs-keyword">import</span> <span class="hljs-title class_">AutoModelForCausalLM</span>
# <span class="hljs-title class_">Set</span> gpu_layers to the number <span class="hljs-keyword">of</span> layers to offload to <span class="hljs-variable constant_">GPU</span>. <span class="hljs-title class_">Set</span> to <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> no <span class="hljs-variable constant_">GPU</span> acceleration is available on your system.
llm = <span class="hljs-title class_">AutoModelForCausalLM</span>.<span class="hljs-title function_">from_pretrained</span>(
    <span class="hljs-string">'TheBloke/zephyr-7B-beta-GGUF'</span>,
    model_file=<span class="hljs-string">'zephyr-7b-beta.Q4_K_M.gguf'</span>,
    model_type=<span class="hljs-string">'llama'</span>,
    gpu_layers=<span class="hljs-number">32</span>
)
prompt=<span class="hljs-string">'&#x3C;s>I like apple pie'</span>
# <span class="hljs-title class_">Do</span> inference <span class="hljs-keyword">with</span> streaming
stream=<span class="hljs-title function_">llm</span>(prompt, stream=<span class="hljs-title class_">True</span>)
<span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> <span class="hljs-attr">stream</span>:
    <span class="hljs-title function_">print</span>(chunk, end=<span class="hljs-string">""</span>, flush=<span class="hljs-title class_">True</span>)
</code></pre>
<p>사용 중인 특정 모델에 따라 gpu_layers 설정을 조정하세요. 이 경우, GPU에 32개 레이어를 할당하도록 설정합니다. 추론에 stream=True을 설정하면 모델이 생성하는 토큰을 실시간으로 표시할 수 있습니다. zephyr용 다양한 양자화된 모델 버전은 <a href="https://huggingface.co/TheBloke/zephyr-7B-beta-GGUF%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">https://huggingface.co/TheBloke/zephyr-7B-beta-GGUF에서</a> 확인할 수 있습니다.</p>
<div class="content-ad"></div>
<hr>
<h1>LLama.cpp python</h1>
<p>LLama.cpp은 다양한 백엔드(CUDA, Metal, OpenCL, SYCL)를 지원하여 적응성을 높인 유연한 C/C++ 라이브러리로, Meta의 LLaMA 모델과 같은 대규모 언어 모델에서 추론을 실행할 수 있는 능력으로 AI 분야에서 인식을 얻고 있습니다. llama-cpp-python 패키지를 통한 Python 통합은 사용자가 C/C++의 성능을 누리면서도 Python의 간편함을 누릴 수 있도록 합니다.</p>
<p>llama-cpp-python을 설치하는 선호하는 방법은 소스에서 컴파일하는 것입니다. 이 방법을 권장하는 이유는 기밀된 C/C++ 라이브러리인 llama.cpp이 특정 시스템에 맞춘 컴파일러 최적화를 활용하기 때문입니다. 미리 빌드된 이진 파일을 선택하면 이러한 최적화를 포기하거나 다양한 플랫폼용 이진 파일을 관리해야 할 수도 있습니다. llama-cpp-python을 컴파일하면 llama.cpp 라이브러리를 자동으로 라이브러리 파일(lib)로 빌드합니다. 이 라이브러리 파일은 특정 바인딩을 통해 Python에서 활용되어, Python 스크립트가 llama.cpp의 기능에 액세스하고 사용할 수 있도록 합니다. 컴파일 세부 정보는 llama-cpp-python의 github 저장소를 참조하세요.</p>
<div class="content-ad"></div>
<p>시스템에는 해당 버전의 BLAS 라이브러리가 설치되어 있어야 합니다. llama.cpp README의 ‘BLAS 빌드’ 섹션을 확인해보세요.</p>
<p>Intel ARC GPU는 SYCL을 통해 지원되며, 이를 위해서는 Intel OneAPI가 설치되어 있어야 합니다. README의 SYCL 섹션을 확인해보세요.</p>
<p>llama-cpp-python의 자세한 빌드 지시사항은 <a href="https://github.com/abetlen/llama-cpp-python%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">https://github.com/abetlen/llama-cpp-python에서</a> 찾을 수 있습니다.</p>
<p>간단한 지시사항은 여기에 있습니다.</p>
<div class="content-ad"></div>
<p>CPU 또는 GPU용 llama-cpp-python 패키지를 설치해 보세요.</p>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">CPU</span> 빌드용
(venv)$ <span class="hljs-variable constant_">CMAKE_ARGS</span>=<span class="hljs-string">"-DLLAMA_BLAS=ON -DLLAMA_BLAS_VENDOR=OpenBLAS"</span> pip install llama-cpp-python --upgrade --force-reinstall --no-cache-dir

# <span class="hljs-title class_">Nvidia</span> <span class="hljs-variable constant_">GPU</span> 빌드용
(venv)$ <span class="hljs-variable constant_">CMAKE_ARGS</span>=<span class="hljs-string">"-DLLAMA_CUBLAS=on"</span> pip install llama-cpp-python --upgrade --force-reinstall --no-cache-dir

# <span class="hljs-title class_">Intel</span> <span class="hljs-variable constant_">ARC</span> <span class="hljs-variable constant_">GPUS</span>를 위한 <span class="hljs-variable constant_">SYCL</span>을 통한 빌드
source /opt/intel/oneapi/setvars.<span class="hljs-property">sh</span>   
<span class="hljs-variable constant_">CMAKE_ARGS</span>=<span class="hljs-string">"-DLLAMA_SYCL=on -DCMAKE_C_COMPILER=icx -DCMAKE_CXX_COMPILER=icpx"</span> pip install llama-cpp-python
</code></pre>
<p>llama-cpp-python은 Hugging Face에서 얻을 수 있는 GGUF 모델 형식을 요구합니다. 그러나 llama의 API 사양으로 인해, 모델을 수동으로 다운로드하여 다른 디렉토리에 저장한 다음 해당 디렉토리 경로를 llama-cpp-python에 지정해야 합니다. 이번에는 우리의 정규 절차에서 벗어나, 명시적 로컬 폴더로 직접 다운로드하는 방식으로 사용 설명서 tuning된 Llama 2 모델을 사용하겠습니다.</p>
<pre><code class="hljs language-js">(venv)$ huggingface-cli download <span class="hljs-title class_">TheBloke</span>/<span class="hljs-title class_">Llama</span>-<span class="hljs-number">2</span>-7b-<span class="hljs-title class_">Chat</span>-<span class="hljs-variable constant_">GGUF</span> llama-<span class="hljs-number">2</span>-7b-chat.<span class="hljs-property">Q4_K_M</span>.<span class="hljs-property">gguf</span> --local-dir . --local-dir-use-symlinks <span class="hljs-title class_">True</span>
</code></pre>
<div class="content-ad"></div>
<p>local-dir-use-symlinks를 True로 설정하여 활성화하면 현재 디렉토리에 모델을 캐시 디렉토리에 이미 다운로드된 모델을 가리키는 심볼릭 링크를 생성하려고 시도하므로 시간과 공간을 효율적으로 사용할 수 있습니다. 심볼릭 링크를 사용하지 않고 현재 디렉토리에 모델의 완전한 사본이 필요하다면 이 옵션을 생략하는 것이 가장 좋습니다.</p>
<p>현재 디렉토리에 모델을 다운로드한 경우 model_path는 절대 경로 또는 상대 경로로 지정해야 합니다.</p>
<p>inference.py</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> llama_cpp <span class="hljs-keyword">import</span> Llama
<span class="hljs-keyword">import</span> llama_cpp
llm = llama_cpp.Llama(model_path=<span class="hljs-string">"./llama-2-7b-chat.Q4_K_M.gguf"</span>,
                verbose=<span class="hljs-literal">True</span>, n_gpu_layers=-<span class="hljs-number">1</span>, chat_format=<span class="hljs-string">"llama-2"</span>)
prompt = <span class="hljs-string">'[INST] Hi there, write me 3 random quotes [/INST]'</span>
stream = llm(prompt, max_tokens=<span class="hljs-number">2048</span>, echo=<span class="hljs-literal">False</span>, temperature=<span class="hljs-number">0</span>, stream=<span class="hljs-literal">True</span>)
result = <span class="hljs-string">""</span>
<span class="hljs-keyword">for</span> output <span class="hljs-keyword">in</span> stream:
    result += output[<span class="hljs-string">'choices'</span>][<span class="hljs-number">0</span>][<span class="hljs-string">'text'</span>]
    <span class="hljs-built_in">print</span>(output[<span class="hljs-string">'choices'</span>][<span class="hljs-number">0</span>][<span class="hljs-string">'text'</span>], end=<span class="hljs-string">""</span>)
</code></pre>
<div class="content-ad"></div>
<p>위의 코드는 시스템이 Llama2 7B 모델의 모든 레이어(n_gpu_layers=-1)를 GPU에로드하도록 지시합니다. 사용 가능한 VRAM에 따라 n_gpu_layers 값을 수정하여 CPU와 GPU 사이의 작업 부하를 분산시킬 수 있으며, 예를 들어 대규모 모델을 효과적으로 관리하기 위해 작업을 균등하게 분할할 수 있습니다.</p>
<p>프롬프트 구문의 중요성</p>
<p>위에서 사용된 모델은 채팅용으로 조정된 모델이므로 프롬프트 형식은 매우 중요합니다([INST] 사용). 이는 모델의 이해와 작업 실행에 상당한 영향을 미치기 때문입니다. 지시에 따라 응답을 생성할 수 있도록 특별히 설계된 지시에 조정된 모델은 상세 명령을 따르고 프롬프트에서 제공된 지침에 따라 응답을 생성합니다. 올바른 구문은 모델이 지시의 의도를 정확하게 이해하고 결과가 정확하고 타당한 것을 보장하는 데 중요합니다. 또한 다양한 모델 아키텍처는 다른 프롬프트 구문에 최적으로 반응할 수 있도록 세밀하게 조정됩니다.</p>
<div class="content-ad"></div>
<h1>llama.cpp 기반의 GPT-3.5 대체품입니다.</h1>
<p>이 섹션은 llama.cpp를 OpenAI의 GPT 엔드포인트 대신 사용할 수 있는 방법을 탐구합니다. llama.cpp 모델을 활용하여 OpenAI의 서비스에 의존하지 않고 로컬 llama.cpp 모델을 사용하여 GPT 기반 애플리케이션을 운영할 수 있습니다. 로컬 API 서버를 실행함으로써 OpenAI의 GPT API 엔드포인트의 기능을 모방하면서도 llama 모델을 사용하여 요청을 처리할 수 있습니다. 이는 GPT-3.5 또는 GPT-4를 대상으로 한 애플리케이션이 llama.cpp를 사용하도록 원활하게 전환할 수 있음을 의미합니다. 최종 목표는 비용을 절감하는 것뿐만 아니라 데이터가 로컬 환경 내에서 개인 정보 보호 및 안전성을 유지하도록 하는 것입니다.</p>
<p><img src="/assets/img/2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython_2.png" alt="이미지"></p>
<p>먼저 llama-cpp-python과 서버 지원 및 필수 요소를 설치해야 합니다. 패키지가 처음에 CPU 사용을 위해 설정되어 있고 이제 GPU 사용으로 전환하고 싶은 경우(또는 그 반대인 경우) 새 대상을 위해 설치 명령을 다시 실행하여 다시 설치해야 합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># <span class="hljs-variable constant_">CPU</span> 빌드용
(venv)$ <span class="hljs-variable constant_">CMAKE_ARGS</span>=<span class="hljs-string">"-DLLAMA_BLAS=ON -DLLAMA_BLAS_VENDOR=OpenBLAS"</span> pip install llama-cpp-python[server] --upgrade --force-reinstall --no-cache-dir

# <span class="hljs-title class_">Nvidia</span> <span class="hljs-variable constant_">GPU</span> 빌드용
(venv)$ <span class="hljs-variable constant_">CMAKE_ARGS</span>=<span class="hljs-string">"-DLLAMA_CUBLAS=on"</span> pip install llama-cpp-python[server] --upgrade --force-reinstall --no-cache-dir
</code></pre>
<p>openai 패키지 설치</p>
<pre><code class="hljs language-js">(venv)$ pip install openai
</code></pre>
<p>huggingface-cli 도구를 사용하여 로컬 폴더에 모델 다운로드하기</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">(venv)$ huggingface-cli <span class="hljs-title class_">TheBloke</span>/<span class="hljs-title class_">Llama</span>-<span class="hljs-number">2</span>-7b-<span class="hljs-title class_">Chat</span>-<span class="hljs-variable constant_">GGUF</span> 다운로드 llama-<span class="hljs-number">2</span>-7b-chat.<span class="hljs-property">Q4_K_M</span>.<span class="hljs-property">gguf</span> --local-dir . --local-dir-use-symlinks <span class="hljs-title class_">True</span>
</code></pre>
<p>모델에 입력하기 전에 프롬프트를 Llama-2 형식으로 구조화하는 방법과 함께 서버를 실행합니다.</p>
<pre><code class="hljs language-js">(venv)$ python3 -m llama_cpp.<span class="hljs-property">server</span> --model ./llama-<span class="hljs-number">2</span>-7b-chat.<span class="hljs-property">Q4_K_M</span>.<span class="hljs-property">gguf</span> --n_gpu_layers <span class="hljs-number">35</span> --chat_format llama-<span class="hljs-number">2</span>
</code></pre>
<p>서버는 기본적으로 포트 8000을 사용하도록 구성되어 있습니다. 아래의 클라이언트 스크립트에서 서비스에 연결하도록 설계된 경우 사용자 정의 포트 실행에 필요한 포트 번호를 수정하세요. 모델 매개변수에는 더미 값(e.g. xxxxx)이 할당되어 있으며, 이는 서버에서 무시되며 본 예제에서는 간편함을 위해 인증 프로세스가 포함되어 있지 않습니다. 또한 서버가 올바르게 실행 중인지 확인하려면 브라우저에서 <a href="http://localhost:8000/docs#/%EC%9D%84" rel="nofollow" target="_blank">http://localhost:8000/docs#/을</a> 방문하세요.</p>
<div class="content-ad"></div>
<p>client.py</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI
client = OpenAI(base_url=<span class="hljs-string">"http://127.0.0.1:8000/v1"</span>) 
stream = client.chat.completions.create(
  model=<span class="hljs-string">"xxxxx"</span>,
  messages=[
    {<span class="hljs-string">"role"</span>: <span class="hljs-string">"system"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"You are a well-read scholar with a deep appreciation for literature, especially when it comes to the subject of artificial intelligence (AI)"</span>},
    {<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: <span class="hljs-string">"Give me 3 quotes on AI."</span>}
  ],
  temperature=<span class="hljs-number">0.01</span>,
  stream=<span class="hljs-literal">True</span>,  
)
<span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> stream:
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> chunk.choices <span class="hljs-keyword">or</span> chunk.choices[<span class="hljs-number">0</span>].delta.content <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">continue</span>
    <span class="hljs-built_in">print</span>(chunk.choices[<span class="hljs-number">0</span>].delta.content, end=<span class="hljs-string">""</span>)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n"</span>)
</code></pre>
<p>Run the client script in another terminal.</p>
<pre><code class="hljs language-bash">(venv)$ python client.py
</code></pre>
<div class="content-ad"></div>
<p>수신된 출력 스트림은 터미널 창에 표시됩니다.</p>
<p>출력 (모델에서 받은 대로):</p>
<hr>
<h1>참고 자료</h1>
<div class="content-ad"></div>
<ul>
<li>Hugging Face [<a href="https://huggingface.co/" rel="nofollow" target="_blank">https://huggingface.co/</a>]</li>
<li>llama.cpp에 대한 Python 바인딩 [<a href="https://github.com/abetlen/llama-cpp-python" rel="nofollow" target="_blank">https://github.com/abetlen/llama-cpp-python</a>]</li>
<li>양자화 [<a href="https://huggingface.co/docs/optimum/concept_guides/quantization" rel="nofollow" target="_blank">https://huggingface.co/docs/optimum/concept_guides/quantization</a>]</li>
<li>당신에게 적합한 양자화 방법은 무엇인가요? (GPTQ vs. GGUF vs. AWQ) [<a href="https://towardsdatascience.com/which-quantization-method-is-right-for-you-gptq-vs-gguf-vs-awq-c4cd9d77d5be" rel="nofollow" target="_blank">https://towardsdatascience.com/which-quantization-method-is-right-for-you-gptq-vs-gguf-vs-awq-c4cd9d77d5be</a>]</li>
<li>Nvidia CUDA [<a href="https://developer.nvidia.com/cuda-12-1-0-download-archive" rel="nofollow" target="_blank">https://developer.nvidia.com/cuda-12-1-0-download-archive</a>]</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"초보자를 위한 통합 가이드 Python을 사용한 LLM 로컬 배포 쉽게 하는 방법","description":"","date":"2024-06-23 19:17","slug":"2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython","content":"\n\n![2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython_0.png](/assets/img/2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython_0.png)\n\n인터넷에는 개인 컴퓨터에서 대형 언어 모델 (LLMs)을 실행하는 방법에 대한 가이드가 넘쳐나지만, 이 방대한 정보를 효율적으로 탐색하는 것은 특히 새로운 사용자에게는 어려운 일일 수 있습니다. 대부분의 가이드는 특정 접근 방식에 초점을 맞추기 때문에 초보자들이 포괄적인 길을 찾기 어려울 수 있습니다. 여기서 저의 기사가 등장하여, 몇 가지 유명한 방법들을 하나로 통합하고 초보자들을 위해 특별히 제작된 이를 제공합니다. 이 가이드의 독특한 접근 방식은 Python 기반 방법에 집중하고 있으며, Python의 간단함과 AI 커뮤니티 내에서의 광범위한 사용을 인정하고 있습니다. 이 가이드는 깔끔하고 단계별 지침서, 다양한 Python 라이브러리와 도구에 대한 통찰, 그리고 실용적인 팁을 제공하여 당신의 LLMs 세계로의 진입을 원활하게 만들어주려고 만들어졌습니다. 기술적인 세부 사항의 다양성이 혼란스럽게 느껴졌거나 선택지가 많았던 분들에게는 이 기사가 꼭 필요한 리소스로, 당신의 컴퓨터에서 LLMs를 직접 실행하기 위한 접근 가능하고 깨우침을 주는 여정을 보장합니다. 여러 프레임워크에서 모델을 작업하는 빠른 소개를 제공하는 이 기사는 CPU 또는 GPU를 사용하더라도 모든 측면을 깊이 다루지는 않습니다. 더 포괄적인 통찰을 위해서는 관련 문서를 참고하는 것이 좋습니다.\n\n이 가이드는 다음을 사용하여 LLMs를 로컬로 실행하는 방법을 공유할 것입니다\n- Huggingface: 방대한 모델 저장소와 직관적 인터페이스를 갖춘 포괄적인 라이브러리.\n- Llama.cpp Python: llama.cpp를 활용해 성능이 C++ 수준인 LLMs를 사용하는 Python 친화적 프론트 엔드.\n- llama.cpp 기반 GPT-3.5에 대한 API 드롭인 대체: 모델을 독립된 프로세스에서 실행하면, 동일한 기계 또는 서버에서 GPT 3.5 클라이언트들이 사용하는 API와 유사한 방식으로 추론이 가능해집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n상기한 방법들은 13세대 인텔 랩터 레이크 프로세서가 탑재된 Windows 11 시스템에서 WSL2을 사용하여 성공적으로 테스트되었으며, NVIDIA RTX 3060 카드와 16GB 메모리, CUDA 버전 12.1을 사용하고 있습니다.\n\n# 대형 언어 모델(LLM) 실행에 대한 고려 사항\n\n대형 언어 모델(LLM)의 세계로 진입하면 효율적인 배포와 운영을 위한 중요한 고려 사항이 드러납니다. 하드웨어 요구 사항부터 모델 액세스 프로토콜까지 각 요소가 LLM의 모든 잠재력을 활용하는 데 중요한 역할을 합니다.\n\nLLM의 효율적인 운영을 위해서는 강력한 GPU가 필수적입니다. 퀀터제이션을 필요로 하는 모델들에게 특히 중요한데, GPT-2와 같은 작은 모델은 CPU에서 실행할 수 있지만 시스템 RAM에 제한을 받습니다. 예를 들어, GPT-2의 500MB 크기는 현대 CPU에서 관리가 가능하지만,  Llama 2 7B(13GB 크기)와 같은 큰 모델은 기술적으로 CPU에서 실행할 수 있지만, 충분한 RAM이 있어도 추론 속도가 느려집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nHuggingFace 라이브러리는 자동 모델 다운로드를 용이하게 하고 다양한 모델에 액세스할 수 있도록 도와줍니다. Meta의 Llama2와 같은 일부 모델에 액세스하려면 Hugging Face를 통해 계정 설정, 애플리케이션 검토 및 Meta의 사용 정책 준수가 필요한 승인 프로세스가 필요합니다.\n\nGPU 배포는 GPU RAM 용량에 따라 LLM에 가장 적합합니다. 일반적으로 모델은 float16 또는 float32 포맷이며, NVidia 4060 Ti와 같이 더 높은 용량을 갖는 GPU에서는 전체 모델 로딩이 가능합니다(16GB RAM). RAM이 적은 GPU의 경우 양자화는 원래 크기의 일부로 메모리 요구사항을 줄여 호환성 및 추론 속도를 향상시키지만, 정확도 손실은 최소화됩니다. GPU 기반 LLM 작업에는 전반적으로 양자화를 권장합니다. 양자화는 대규모 언어 모델(LLMs)이 로컬 기계에서 효율적으로 작동할 수 있도록 하는 데 중요한 역할을 합니다. 기본적으로 양자화는 모델의 가중치를 표현하는 데 사용되는 숫자의 정밀도를 줄이는 프로세스로, 성능을 크게 희생하지 않으면서 모델의 크기를 크게 줄입니다. GPU 추론에 대해, 이 가이드는 Nvidia GPU를 CUDA 프레임워크와 함께 사용하는 데 초점을 맞추고 있습니다.\n\nGoogle Colab은 Nvidia GPU에 액세스하여 개인 하드웨어가 필요하지 않게 해주는 편리한 클라우드 기반 솔루션을 제공합니다. 주요 라이브러리와의 쉬운 통합을 지원하여 모델 실행이 간편해집니다. 그러나 무료 계정 사용자는 액세스 기간 제한 및 GPU 가용성과 같은 제한 사항을 직면할 수 있으며, 이는 긴 기간 또는 더 많은 리소스를 필요로 하는 프로젝트에 영향을 줄 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이러한 구성 요소를 각각 설정하는 구체적인 내용을 살펴보겠습니다.\n\n---\n\n## HuggingFace 사용하기\n\nHugging Face는 자연 언어 처리(NLP) 분야에서 특히 열린 소스 라이브러리인 Transformers를 갖고 인공 지능 분야를 혁신시켰습니다. 이 라이브러리는 텍스트 분류 및 언어 생성과 같은 작업을 위한 다양한 사전 훈련된 모델을 제공하여 복잡한 NLP 작업의 구현을 간단하게 합니다. 그들의 작업은 다양한 분야에서 AI 응용 프로그램을 신속하게 개발할 수 있도록 하며 모델을 처음부터 훈련할 필요가 없게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 설정\n\n작동되는 구성:\n\n- Python 3.8+ (3.10 버전에서 테스트됨)\n- Windows 11, Windows Subsystem for Linux (WSL) 및 Ubuntu 22.04에서 확인됨.\n- Transformer 버전 4.36.1에서 테스트됨 (이후 버전은 inference.py에 변경이 필요할 수 있음)\n- Intel 12세대 이상\n- (선택 사항) GPU (예: Nvidia RTX3060 12 GB) 및 CUDA 12.1이 장착되어 있음\n\n다음 섹션에서는 CPU 전용 및 GPU용으로 Linux 및 Windows에 대한 설치 지침을 나열할 것입니다. 해당 지침에 따라 설치하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLinux/WSL (CPU/GPU)\n\nCPU만 설정하는 경우에 필요한 단계이며 GPU 설정을 구성하기 위한 예비 요구 사항으로도 사용됩니다.\n\n```js\n$ sudo apt install python3.10-venv python3.10-tk\n$ pip install virtualenv \n$ python3.10 -m venv  venv\n$ source ./venv/bin/activate\n(venv)$ pip3 install tk numpy torch bertviz ipython transformers accelerate huggingface_hub hf_transfer\n```\n\nLinux/WSL (GPU)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리눅스에서 GPU 지원을 위해 추가 패키지 설치하기\n\n```js\n(가상환경)$ pip3 install bitsandbytes accelerate autoawq optimum auto-gptq\n```\n\nWindows 설치 (CPU/GPU)\n\n이 단계들은 CPU에서 설정하는 데 필수적이며, 윈도우에서 GPU 설정을 구성하는 데 기본 요구사항으로 작용합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n\u003e pip install virtualenv\n\u003e python3.10 -m venv  venv\n\u003e venv\\Scripts\\activate\n(venv)\u003e pip3 install tk numpy torch bertviz ipython transformers huggingface_hub hf_transfer\n```\n\n+Windows (GPU)\n\n윈도우에서 GPU용 추가 패키지를 설치/업데이트 해주세요.\n\n```js\n(venv)\u003e pip3 install accelerate autoawq optimum auto-gptq\n(venv)\u003e pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121\n(venv)\u003e python -m pip install bitsandbytes==0.39.1 --prefer-binary --extra-index-url=https://jllllll.github.io/bitsandbytes-windows-webui\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nNVidia GPU에서 Large Language Models (LLMs)를 실행하기 위해 몇 가지 설치가 필요합니다:\n\n- PyTorch 및 CUDA 설정: NVidia GPU 기능을 활용하기 위해 torch, torchvision 및 torchaudio를 CUDA 지원과 함께 설치해야 합니다. 일반적으로 Linux 사용자는 기본 PyTorch 설치에서 CUDA 지원을 받지만, Windows 사용자는 torch+cuda 설치를 위한 index-url을 지정해야 합니다. 최신 업데이트에 따르면 PyTorch는 CUDA toolkit 버전 12.1까지 호환됩니다. CUDA 호환성 및 설치 안내에 대한 최신 정보는 PyTorch 웹사이트 (PyTorch — 로컬에서 시작하기)에서 확인할 수 있습니다.\n- bitsandbytes 설치 변형: bitsandbytes의 표준 설치는 Linux에 최적화되어 있으며, 하나의 릴리스 빌드에서 여러 CUDA 버전을 수용합니다. 그러나 Windows 사용자는 소스에서 직접 빌드하거나 비공식 GitHub 저장소를 사용하여 설치해야 합니다. Windows용 구체적인 설치 지침은 이 기사의 이전 섹션에서 찾을 수 있습니다. Windows를 위한 추가 정보 및 안내는 bitsandbytes 비공식 Windows 저장소(https://github.com/jllllll/bitsandbytes-windows-webui)에서 확인할 수 있습니다.\n- Cuda Toolkit 필요성: GPU 기반 작업을 용이하게 하기 위해 https://developer.nvidia.com/cuda-12-1-0-download-archive에서 Cuda toolkit을 설치하세요. 사용 중인 torch+cuda 버전과 CUDA toolkit 버전을 일치시키는 것이 좋습니다. 현재 최신 torch는 CUDA 버전 12.1을 지원합니다.\n- Microsoft C++ 빌드 도구: Windows에서 GPU 프로세스를 실행하려면 Microsoft C++ 빌드 도구를 설치해야 합니다. 이는 accelarate 및 autoawq 패키지의 psutils 종속성으로 인한 것입니다.\n- autoawq 패키지는 GPU에서 AWQ 기반 양자화 모델을 실행해야 하는 경우에만 필요합니다.\n\nWindows 시스템의 특정 요구 사항을 고려하여 NVidia GPU에서 LLMs를 효과적으로 실행하기 위한 중요한 단계입니다. huggingface 설치 및 모델 다운로드에 대한 자세한 정보는 link1과 link2를 확인하세요.\n\nHuggingface에 계정을 생성하면 토큰을 생성할 수 있는 능력이 생깁니다. 이 토큰은 export(예: HF_TOKEN)을 통해 환경에 구성하거나 Huggingface API와 함께 매개변수로 사용하여 모델 다운로드 및 다른 포턜 작업에 사용할 수 있습니다. 이 토큰은 서비스에 액세스하기 위한 패스로 생각할 수 있습니다. 또한 Llama와 같은 특정 모델을 다운로드하려면 승인이 필요할 수 있으며, 계정을 사용하여 Huggingface 포턜을 통해 요청할 수 있습니다. 부여된 모든 승인은 계정과 그 계정으로 생성된 모든 토큰과 연결됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 추론\n\n이 스크립트는 추론 모드를 구체화하여 모델 실행에 적합한 하드웨어(CPU 또는 GPU)를 선택합니다. 만약 추론 모드가 'cpu'로 설정되어 있다면, GPT-2 모델이 로드되며, 작은 크기(~500MB)로 CPU 사용에 이상적이기 때문에 'cpu'로 설정된 device_map을 사용하여 타겟팅된 실행이 가능합니다. 반대로, GPU 사용 시에는 더 큰 Meta LLaMA 2 7B 모델(~13GB)을 선택하며, 'auto'로 설정된 device_map을 활용하여 유연한 장치 할당을 하고 load_in_4bit을 활성화하여 메모리 사용량을 최소화하여 한정된 메모리를 가진 GPU에서 큰 모델의 작동을 촉진합니다. pipeline 함수는 로드된 모델과 토크나이저를 사용하여 텍스트 생성 파이프라인을 생성하며, max_new_tokens와 같은 매개변수를 설정하여 생성된 텍스트의 길이를 제어합니다. 또한 streamer가 파이프라인에 전달되어, 스트리밍된 텍스트 생성이 사용될 것을 나타냅니다.\n\ninference.py\n```python\nimport torch\nfrom transformers import AutoTokenizer, AutoModelForCausalLM, TextStreamer, pipeline, BitsAndBytesConfig\n\ninference_type = 'cpu'\nif inference_type == 'cpu':\n    # CPU 추론\n    model_name = 'gpt2'  # ~500MB 원본 크기\n    model = AutoModelForCausalLM.from_pretrained(\n        model_name,\n        device_map='cpu'\n    )\nelse:    \n    # GPU 추론; 'gpu'\n    model_name = 'meta-llama/Llama-2-7b-hf'  # ~13GB 원본 크기\n    quantization_config = BitsAndBytesConfig(load_in_4bit=True, bnb_4bit_compute_dtype=torch.bfloat16)\n    model = AutoModelForCausalLM.from_pretrained(\n        model_name, \n        device_map='auto',\n        quantization_config=quantization_config)\ntokenizer = AutoTokenizer.from_pretrained(model_name)\nstreamer = TextStreamer(\n     tokenizer,\n     skip_prompt=False,\n     skip_special_tokens=False\n)\ntext_pipeline = pipeline(\n    \"text-generation\",\n    model=model,\n    tokenizer=tokenizer,\n    max_new_tokens=100,  # 생성할 토큰의 최대 수\n    streamer=streamer,     \n)\nprompt='I like apple pie'\ntext_pipeline(prompt) \n``` \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제공된 예제에서는 사전 학습된 모델을 사용하고 있습니다. 이 모델은 일련의 토큰과 같은 특정 키워드를 필요로 할 수도 있습니다. 모델이 이러한 토큰을 요구하는지 확인하려면 tokenizer_config.json 파일에서 add_bos_token 및 add_eos_token 설정을 확인할 수 있습니다. 이를 자동으로 처리하는 실용적인 방법은 text_pipeline 추론 호출에서 add_special_tokens=True (기본값 False)로 설정하는 것입니다. 이렇게 하면 프레임워크가 모델로 전송되기 전에 프롬프트에 특수 키워드를 삽입할지 여부를 결정할 수 있습니다. 위 예시에서는 해당 매개변수를 사용하지 않았습니다.\n\n스크립트 실행\n\n```js\n(venv)$ python inference.py\n```\n\n출력:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBitsAndBytesConfig가 load_in_4bit=True로 전달되어 있습니다. 이는 변환 라이브러리에게 모델의 가중치를 4비트로 줄이라는 지시를하는 것이고, 이는 모델의 원래 크기의 25%에 해당합니다 (Llama 2는 float16 형식입니다). 이는 추론 속도를 향상시킵니다. bnb_4bit_compute_dtype는 torch.bfloat16으로 설정되어 있어 GPU에서 실제 계산이 여전히 float16로 수행되도록 합니다. 선택할 수 있는 대안 옵션은 load_in_8bit=True이며, load_in_4bit 옵션과 상호 배제됩니다. 8비트 모드는 약간 향상된 정확성을 제공하지만 모델 크기를 원래 크기의 50%로 줄이고 추론 속도를 낮춥니다. 양자화 옵션을 선택하지 않은 경우 변환 라이브러리는 가용한 VRAM에 따라 전체 모델을 GPU의 비디오 RAM에로드하는 것을 기본값으로 설정합니다.\n\n# 사전 양자화 모델 로드\n\nGPU 추론 시 모델을 로드할 때마다 양자화하는 대신, 디스크에서 사전 양자화 된 모델을로드할 수 있습니다. 인기있는 양자화 형식 중 두 가지는 GPTQ 및 AWQ입니다. Huggingface는 둘 다 지원합니다.\n\nAWQ 유형 모델의 경우 아래 코드로 모델로드 라인을 대체하면 됩니다 (GPU 추론 경로에서). BitsAndBytesConfig 매개 변수가 생략됩니다. 왜냐하면 모델이 이미 양자화되어 있기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nmodel_name='TheBloke/zephyr-7B-alpha-AWQ' \nmodel = AutoModelForCausalLM.from_pretrained( \n    model_name, \n    device_map='auto')\n```\n\nGPTQ 모델의 경우 아래 라인으로 모델 로드를 대체합니다.\n\n```js\nmodel_name='TheBloke/zephyr-7B-beta-GPTQ' \nmodel = AutoModelForCausalLM.from_pretrained( \n    model_name, \n    revision='main', \n    device_map='auto')\n```\n\nGitHub 브랜치에 해당하는 revision을 사용했습니다. zephyr-7B-beta-GPTQ 양자화 버전은 서로 다른 브랜치에 저장되어 있습니다. 자세한 내용은 https://huggingface.co/TheBloke/zephyr-7B-beta-GPTQ의 ‘Files and versions’ 탭을 참조해주세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# GGUF 양자화\n\nGGUF는 llama.cpp에서 소개된 인기 있는 양자화 방법입니다. ctransformers는 GGML/GGUF 라이브러리를 사용하여 C/C++로 구현된 Transformer 모델용 Python 바인딩입니다. 또한 RAG Langchain과 통합되어 있습니다.\n\n귀하의 구성에 따라 ctransformers 패키지를 설치하세요.\n\n```js\n(venv)$ pip install ctransformers\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhuggingface-cli를 사용하여 GGUF 형식 모델을 다운로드하거나 from_pretrained() 호출을 통해 해당 모델의 첫 API 호출 시 자동으로 다운로드됩니다. 아래 코드 샘플은 GGUF 형식의 모델에 대해 ctransformers를 활용하는 방법을 보여줍니다. from_pretrained 메서드는 이전에 다운로드되지 않은 경우 Hugging Face에서 모델을 자동으로 가져옵니다. zephyr GGUF와 같은 일부 모델 유형은 동일한 리포지토리에 파일로 저장됩니다. 여기서 리포지토리 이름은 'TheBloke/zephyr-7B-beta-GGUF'이고 모델 파일은 zephyr-7b-beta.Q4_K_M.gguf입니다.\n\ninference.py\n\n```js\nfrom ctransformers import AutoModelForCausalLM\n# Set gpu_layers to the number of layers to offload to GPU. Set to 0 if no GPU acceleration is available on your system.\nllm = AutoModelForCausalLM.from_pretrained(\n    'TheBloke/zephyr-7B-beta-GGUF',\n    model_file='zephyr-7b-beta.Q4_K_M.gguf',\n    model_type='llama',\n    gpu_layers=32\n)\nprompt='\u003cs\u003eI like apple pie'\n# Do inference with streaming\nstream=llm(prompt, stream=True)\nfor chunk in stream:\n    print(chunk, end=\"\", flush=True)\n```\n\n사용 중인 특정 모델에 따라 gpu_layers 설정을 조정하세요. 이 경우, GPU에 32개 레이어를 할당하도록 설정합니다. 추론에 stream=True을 설정하면 모델이 생성하는 토큰을 실시간으로 표시할 수 있습니다. zephyr용 다양한 양자화된 모델 버전은 https://huggingface.co/TheBloke/zephyr-7B-beta-GGUF에서 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n--- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---\n\n# LLama.cpp python\n\nLLama.cpp은 다양한 백엔드(CUDA, Metal, OpenCL, SYCL)를 지원하여 적응성을 높인 유연한 C/C++ 라이브러리로, Meta의 LLaMA 모델과 같은 대규모 언어 모델에서 추론을 실행할 수 있는 능력으로 AI 분야에서 인식을 얻고 있습니다. llama-cpp-python 패키지를 통한 Python 통합은 사용자가 C/C++의 성능을 누리면서도 Python의 간편함을 누릴 수 있도록 합니다.\n\nllama-cpp-python을 설치하는 선호하는 방법은 소스에서 컴파일하는 것입니다. 이 방법을 권장하는 이유는 기밀된 C/C++ 라이브러리인 llama.cpp이 특정 시스템에 맞춘 컴파일러 최적화를 활용하기 때문입니다. 미리 빌드된 이진 파일을 선택하면 이러한 최적화를 포기하거나 다양한 플랫폼용 이진 파일을 관리해야 할 수도 있습니다. llama-cpp-python을 컴파일하면 llama.cpp 라이브러리를 자동으로 라이브러리 파일(lib)로 빌드합니다. 이 라이브러리 파일은 특정 바인딩을 통해 Python에서 활용되어, Python 스크립트가 llama.cpp의 기능에 액세스하고 사용할 수 있도록 합니다. 컴파일 세부 정보는 llama-cpp-python의 github 저장소를 참조하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n시스템에는 해당 버전의 BLAS 라이브러리가 설치되어 있어야 합니다. llama.cpp README의 ‘BLAS 빌드’ 섹션을 확인해보세요.\n\nIntel ARC GPU는 SYCL을 통해 지원되며, 이를 위해서는 Intel OneAPI가 설치되어 있어야 합니다. README의 SYCL 섹션을 확인해보세요.\n\nllama-cpp-python의 자세한 빌드 지시사항은 https://github.com/abetlen/llama-cpp-python에서 찾을 수 있습니다.\n\n간단한 지시사항은 여기에 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nCPU 또는 GPU용 llama-cpp-python 패키지를 설치해 보세요.\n\n```js\n# CPU 빌드용\n(venv)$ CMAKE_ARGS=\"-DLLAMA_BLAS=ON -DLLAMA_BLAS_VENDOR=OpenBLAS\" pip install llama-cpp-python --upgrade --force-reinstall --no-cache-dir\n\n# Nvidia GPU 빌드용\n(venv)$ CMAKE_ARGS=\"-DLLAMA_CUBLAS=on\" pip install llama-cpp-python --upgrade --force-reinstall --no-cache-dir\n\n# Intel ARC GPUS를 위한 SYCL을 통한 빌드\nsource /opt/intel/oneapi/setvars.sh   \nCMAKE_ARGS=\"-DLLAMA_SYCL=on -DCMAKE_C_COMPILER=icx -DCMAKE_CXX_COMPILER=icpx\" pip install llama-cpp-python\n```\n\nllama-cpp-python은 Hugging Face에서 얻을 수 있는 GGUF 모델 형식을 요구합니다. 그러나 llama의 API 사양으로 인해, 모델을 수동으로 다운로드하여 다른 디렉토리에 저장한 다음 해당 디렉토리 경로를 llama-cpp-python에 지정해야 합니다. 이번에는 우리의 정규 절차에서 벗어나, 명시적 로컬 폴더로 직접 다운로드하는 방식으로 사용 설명서 tuning된 Llama 2 모델을 사용하겠습니다.\n\n```js\n(venv)$ huggingface-cli download TheBloke/Llama-2-7b-Chat-GGUF llama-2-7b-chat.Q4_K_M.gguf --local-dir . --local-dir-use-symlinks True\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nlocal-dir-use-symlinks를 True로 설정하여 활성화하면 현재 디렉토리에 모델을 캐시 디렉토리에 이미 다운로드된 모델을 가리키는 심볼릭 링크를 생성하려고 시도하므로 시간과 공간을 효율적으로 사용할 수 있습니다. 심볼릭 링크를 사용하지 않고 현재 디렉토리에 모델의 완전한 사본이 필요하다면 이 옵션을 생략하는 것이 가장 좋습니다.\n\n현재 디렉토리에 모델을 다운로드한 경우 model_path는 절대 경로 또는 상대 경로로 지정해야 합니다.\n\ninference.py\n\n```python\nfrom llama_cpp import Llama\nimport llama_cpp\nllm = llama_cpp.Llama(model_path=\"./llama-2-7b-chat.Q4_K_M.gguf\",\n                verbose=True, n_gpu_layers=-1, chat_format=\"llama-2\")\nprompt = '[INST] Hi there, write me 3 random quotes [/INST]'\nstream = llm(prompt, max_tokens=2048, echo=False, temperature=0, stream=True)\nresult = \"\"\nfor output in stream:\n    result += output['choices'][0]['text']\n    print(output['choices'][0]['text'], end=\"\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 코드는 시스템이 Llama2 7B 모델의 모든 레이어(n_gpu_layers=-1)를 GPU에로드하도록 지시합니다. 사용 가능한 VRAM에 따라 n_gpu_layers 값을 수정하여 CPU와 GPU 사이의 작업 부하를 분산시킬 수 있으며, 예를 들어 대규모 모델을 효과적으로 관리하기 위해 작업을 균등하게 분할할 수 있습니다.\n\n프롬프트 구문의 중요성\n\n위에서 사용된 모델은 채팅용으로 조정된 모델이므로 프롬프트 형식은 매우 중요합니다([INST] 사용). 이는 모델의 이해와 작업 실행에 상당한 영향을 미치기 때문입니다. 지시에 따라 응답을 생성할 수 있도록 특별히 설계된 지시에 조정된 모델은 상세 명령을 따르고 프롬프트에서 제공된 지침에 따라 응답을 생성합니다. 올바른 구문은 모델이 지시의 의도를 정확하게 이해하고 결과가 정확하고 타당한 것을 보장하는 데 중요합니다. 또한 다양한 모델 아키텍처는 다른 프롬프트 구문에 최적으로 반응할 수 있도록 세밀하게 조정됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# llama.cpp 기반의 GPT-3.5 대체품입니다.\n\n이 섹션은 llama.cpp를 OpenAI의 GPT 엔드포인트 대신 사용할 수 있는 방법을 탐구합니다. llama.cpp 모델을 활용하여 OpenAI의 서비스에 의존하지 않고 로컬 llama.cpp 모델을 사용하여 GPT 기반 애플리케이션을 운영할 수 있습니다. 로컬 API 서버를 실행함으로써 OpenAI의 GPT API 엔드포인트의 기능을 모방하면서도 llama 모델을 사용하여 요청을 처리할 수 있습니다. 이는 GPT-3.5 또는 GPT-4를 대상으로 한 애플리케이션이 llama.cpp를 사용하도록 원활하게 전환할 수 있음을 의미합니다. 최종 목표는 비용을 절감하는 것뿐만 아니라 데이터가 로컬 환경 내에서 개인 정보 보호 및 안전성을 유지하도록 하는 것입니다.\n\n![이미지](/assets/img/2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython_2.png)\n\n먼저 llama-cpp-python과 서버 지원 및 필수 요소를 설치해야 합니다. 패키지가 처음에 CPU 사용을 위해 설정되어 있고 이제 GPU 사용으로 전환하고 싶은 경우(또는 그 반대인 경우) 새 대상을 위해 설치 명령을 다시 실행하여 다시 설치해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# CPU 빌드용\n(venv)$ CMAKE_ARGS=\"-DLLAMA_BLAS=ON -DLLAMA_BLAS_VENDOR=OpenBLAS\" pip install llama-cpp-python[server] --upgrade --force-reinstall --no-cache-dir\n\n# Nvidia GPU 빌드용\n(venv)$ CMAKE_ARGS=\"-DLLAMA_CUBLAS=on\" pip install llama-cpp-python[server] --upgrade --force-reinstall --no-cache-dir\n```\n\nopenai 패키지 설치\n\n```js\n(venv)$ pip install openai\n```\n\nhuggingface-cli 도구를 사용하여 로컬 폴더에 모델 다운로드하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n(venv)$ huggingface-cli TheBloke/Llama-2-7b-Chat-GGUF 다운로드 llama-2-7b-chat.Q4_K_M.gguf --local-dir . --local-dir-use-symlinks True\n```\n\n모델에 입력하기 전에 프롬프트를 Llama-2 형식으로 구조화하는 방법과 함께 서버를 실행합니다.\n\n```js\n(venv)$ python3 -m llama_cpp.server --model ./llama-2-7b-chat.Q4_K_M.gguf --n_gpu_layers 35 --chat_format llama-2\n```\n\n서버는 기본적으로 포트 8000을 사용하도록 구성되어 있습니다. 아래의 클라이언트 스크립트에서 서비스에 연결하도록 설계된 경우 사용자 정의 포트 실행에 필요한 포트 번호를 수정하세요. 모델 매개변수에는 더미 값(e.g. xxxxx)이 할당되어 있으며, 이는 서버에서 무시되며 본 예제에서는 간편함을 위해 인증 프로세스가 포함되어 있지 않습니다. 또한 서버가 올바르게 실행 중인지 확인하려면 브라우저에서 http://localhost:8000/docs#/을 방문하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nclient.py\n\n```python\nfrom openai import OpenAI\nclient = OpenAI(base_url=\"http://127.0.0.1:8000/v1\") \nstream = client.chat.completions.create(\n  model=\"xxxxx\",\n  messages=[\n    {\"role\": \"system\", \"content\": \"You are a well-read scholar with a deep appreciation for literature, especially when it comes to the subject of artificial intelligence (AI)\"},\n    {\"role\": \"user\", \"content\": \"Give me 3 quotes on AI.\"}\n  ],\n  temperature=0.01,\n  stream=True,  \n)\nfor chunk in stream:\n    if not chunk.choices or chunk.choices[0].delta.content is None:\n        continue\n    print(chunk.choices[0].delta.content, end=\"\")\nprint(\"\\n\")\n```\n\nRun the client script in another terminal.\n\n```bash\n(venv)$ python client.py\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n수신된 출력 스트림은 터미널 창에 표시됩니다.\n\n출력 (모델에서 받은 대로):\n\n\n---\n# 참고 자료\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Hugging Face [https://huggingface.co/]\n- llama.cpp에 대한 Python 바인딩 [https://github.com/abetlen/llama-cpp-python]\n- 양자화 [https://huggingface.co/docs/optimum/concept_guides/quantization]\n- 당신에게 적합한 양자화 방법은 무엇인가요? (GPTQ vs. GGUF vs. AWQ) [https://towardsdatascience.com/which-quantization-method-is-right-for-you-gptq-vs-gguf-vs-awq-c4cd9d77d5be]\n- Nvidia CUDA [https://developer.nvidia.com/cuda-12-1-0-download-archive]","ogImage":{"url":"/assets/img/2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython_0.png"},"coverImage":"/assets/img/2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython_0.png","tag":["Tech"],"readingTime":18},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython_0.png\" alt=\"2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython_0.png\"\u003e\u003c/p\u003e\n\u003cp\u003e인터넷에는 개인 컴퓨터에서 대형 언어 모델 (LLMs)을 실행하는 방법에 대한 가이드가 넘쳐나지만, 이 방대한 정보를 효율적으로 탐색하는 것은 특히 새로운 사용자에게는 어려운 일일 수 있습니다. 대부분의 가이드는 특정 접근 방식에 초점을 맞추기 때문에 초보자들이 포괄적인 길을 찾기 어려울 수 있습니다. 여기서 저의 기사가 등장하여, 몇 가지 유명한 방법들을 하나로 통합하고 초보자들을 위해 특별히 제작된 이를 제공합니다. 이 가이드의 독특한 접근 방식은 Python 기반 방법에 집중하고 있으며, Python의 간단함과 AI 커뮤니티 내에서의 광범위한 사용을 인정하고 있습니다. 이 가이드는 깔끔하고 단계별 지침서, 다양한 Python 라이브러리와 도구에 대한 통찰, 그리고 실용적인 팁을 제공하여 당신의 LLMs 세계로의 진입을 원활하게 만들어주려고 만들어졌습니다. 기술적인 세부 사항의 다양성이 혼란스럽게 느껴졌거나 선택지가 많았던 분들에게는 이 기사가 꼭 필요한 리소스로, 당신의 컴퓨터에서 LLMs를 직접 실행하기 위한 접근 가능하고 깨우침을 주는 여정을 보장합니다. 여러 프레임워크에서 모델을 작업하는 빠른 소개를 제공하는 이 기사는 CPU 또는 GPU를 사용하더라도 모든 측면을 깊이 다루지는 않습니다. 더 포괄적인 통찰을 위해서는 관련 문서를 참고하는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003e이 가이드는 다음을 사용하여 LLMs를 로컬로 실행하는 방법을 공유할 것입니다\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHuggingface: 방대한 모델 저장소와 직관적 인터페이스를 갖춘 포괄적인 라이브러리.\u003c/li\u003e\n\u003cli\u003eLlama.cpp Python: llama.cpp를 활용해 성능이 C++ 수준인 LLMs를 사용하는 Python 친화적 프론트 엔드.\u003c/li\u003e\n\u003cli\u003ellama.cpp 기반 GPT-3.5에 대한 API 드롭인 대체: 모델을 독립된 프로세스에서 실행하면, 동일한 기계 또는 서버에서 GPT 3.5 클라이언트들이 사용하는 API와 유사한 방식으로 추론이 가능해집니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e상기한 방법들은 13세대 인텔 랩터 레이크 프로세서가 탑재된 Windows 11 시스템에서 WSL2을 사용하여 성공적으로 테스트되었으며, NVIDIA RTX 3060 카드와 16GB 메모리, CUDA 버전 12.1을 사용하고 있습니다.\u003c/p\u003e\n\u003ch1\u003e대형 언어 모델(LLM) 실행에 대한 고려 사항\u003c/h1\u003e\n\u003cp\u003e대형 언어 모델(LLM)의 세계로 진입하면 효율적인 배포와 운영을 위한 중요한 고려 사항이 드러납니다. 하드웨어 요구 사항부터 모델 액세스 프로토콜까지 각 요소가 LLM의 모든 잠재력을 활용하는 데 중요한 역할을 합니다.\u003c/p\u003e\n\u003cp\u003eLLM의 효율적인 운영을 위해서는 강력한 GPU가 필수적입니다. 퀀터제이션을 필요로 하는 모델들에게 특히 중요한데, GPT-2와 같은 작은 모델은 CPU에서 실행할 수 있지만 시스템 RAM에 제한을 받습니다. 예를 들어, GPT-2의 500MB 크기는 현대 CPU에서 관리가 가능하지만,  Llama 2 7B(13GB 크기)와 같은 큰 모델은 기술적으로 CPU에서 실행할 수 있지만, 충분한 RAM이 있어도 추론 속도가 느려집니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eHuggingFace 라이브러리는 자동 모델 다운로드를 용이하게 하고 다양한 모델에 액세스할 수 있도록 도와줍니다. Meta의 Llama2와 같은 일부 모델에 액세스하려면 Hugging Face를 통해 계정 설정, 애플리케이션 검토 및 Meta의 사용 정책 준수가 필요한 승인 프로세스가 필요합니다.\u003c/p\u003e\n\u003cp\u003eGPU 배포는 GPU RAM 용량에 따라 LLM에 가장 적합합니다. 일반적으로 모델은 float16 또는 float32 포맷이며, NVidia 4060 Ti와 같이 더 높은 용량을 갖는 GPU에서는 전체 모델 로딩이 가능합니다(16GB RAM). RAM이 적은 GPU의 경우 양자화는 원래 크기의 일부로 메모리 요구사항을 줄여 호환성 및 추론 속도를 향상시키지만, 정확도 손실은 최소화됩니다. GPU 기반 LLM 작업에는 전반적으로 양자화를 권장합니다. 양자화는 대규모 언어 모델(LLMs)이 로컬 기계에서 효율적으로 작동할 수 있도록 하는 데 중요한 역할을 합니다. 기본적으로 양자화는 모델의 가중치를 표현하는 데 사용되는 숫자의 정밀도를 줄이는 프로세스로, 성능을 크게 희생하지 않으면서 모델의 크기를 크게 줄입니다. GPU 추론에 대해, 이 가이드는 Nvidia GPU를 CUDA 프레임워크와 함께 사용하는 데 초점을 맞추고 있습니다.\u003c/p\u003e\n\u003cp\u003eGoogle Colab은 Nvidia GPU에 액세스하여 개인 하드웨어가 필요하지 않게 해주는 편리한 클라우드 기반 솔루션을 제공합니다. 주요 라이브러리와의 쉬운 통합을 지원하여 모델 실행이 간편해집니다. 그러나 무료 계정 사용자는 액세스 기간 제한 및 GPU 가용성과 같은 제한 사항을 직면할 수 있으며, 이는 긴 기간 또는 더 많은 리소스를 필요로 하는 프로젝트에 영향을 줄 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 이러한 구성 요소를 각각 설정하는 구체적인 내용을 살펴보겠습니다.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eHuggingFace 사용하기\u003c/h2\u003e\n\u003cp\u003eHugging Face는 자연 언어 처리(NLP) 분야에서 특히 열린 소스 라이브러리인 Transformers를 갖고 인공 지능 분야를 혁신시켰습니다. 이 라이브러리는 텍스트 분류 및 언어 생성과 같은 작업을 위한 다양한 사전 훈련된 모델을 제공하여 복잡한 NLP 작업의 구현을 간단하게 합니다. 그들의 작업은 다양한 분야에서 AI 응용 프로그램을 신속하게 개발할 수 있도록 하며 모델을 처음부터 훈련할 필요가 없게 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e설정\u003c/h1\u003e\n\u003cp\u003e작동되는 구성:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePython 3.8+ (3.10 버전에서 테스트됨)\u003c/li\u003e\n\u003cli\u003eWindows 11, Windows Subsystem for Linux (WSL) 및 Ubuntu 22.04에서 확인됨.\u003c/li\u003e\n\u003cli\u003eTransformer 버전 4.36.1에서 테스트됨 (이후 버전은 inference.py에 변경이 필요할 수 있음)\u003c/li\u003e\n\u003cli\u003eIntel 12세대 이상\u003c/li\u003e\n\u003cli\u003e(선택 사항) GPU (예: Nvidia RTX3060 12 GB) 및 CUDA 12.1이 장착되어 있음\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 섹션에서는 CPU 전용 및 GPU용으로 Linux 및 Windows에 대한 설치 지침을 나열할 것입니다. 해당 지침에 따라 설치하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eLinux/WSL (CPU/GPU)\u003c/p\u003e\n\u003cp\u003eCPU만 설정하는 경우에 필요한 단계이며 GPU 설정을 구성하기 위한 예비 요구 사항으로도 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e$ sudo apt install python3\u003cspan class=\"hljs-number\"\u003e.10\u003c/span\u003e-venv python3\u003cspan class=\"hljs-number\"\u003e.10\u003c/span\u003e-tk\n$ pip install virtualenv \n$ python3\u003cspan class=\"hljs-number\"\u003e.10\u003c/span\u003e -m venv  venv\n$ source ./venv/bin/activate\n(venv)$ pip3 install tk numpy torch bertviz ipython transformers accelerate huggingface_hub hf_transfer\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLinux/WSL (GPU)\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e리눅스에서 GPU 지원을 위해 추가 패키지 설치하기\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(가상환경)$ pip3 install bitsandbytes accelerate autoawq optimum auto-gptq\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWindows 설치 (CPU/GPU)\u003c/p\u003e\n\u003cp\u003e이 단계들은 CPU에서 설정하는 데 필수적이며, 윈도우에서 GPU 설정을 구성하는 데 기본 요구사항으로 작용합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003e pip install virtualenv\n\u003e python3\u003cspan class=\"hljs-number\"\u003e.10\u003c/span\u003e -m venv  venv\n\u003e venv\\\u003cspan class=\"hljs-title class_\"\u003eScripts\u003c/span\u003e\\activate\n(venv)\u003e pip3 install tk numpy torch bertviz ipython transformers huggingface_hub hf_transfer\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e+Windows (GPU)\u003c/p\u003e\n\u003cp\u003e윈도우에서 GPU용 추가 패키지를 설치/업데이트 해주세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(venv)\u003e pip3 install accelerate autoawq optimum auto-gptq\n(venv)\u003e pip3 install torch torchvision torchaudio --index-url \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//download.pytorch.org/whl/cu121\u003c/span\u003e\n(venv)\u003e python -m pip install bitsandbytes==\u003cspan class=\"hljs-number\"\u003e0.39\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.1\u003c/span\u003e --prefer-binary --extra-index-url=\u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//jllllll.github.io/bitsandbytes-windows-webui\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eNVidia GPU에서 Large Language Models (LLMs)를 실행하기 위해 몇 가지 설치가 필요합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePyTorch 및 CUDA 설정: NVidia GPU 기능을 활용하기 위해 torch, torchvision 및 torchaudio를 CUDA 지원과 함께 설치해야 합니다. 일반적으로 Linux 사용자는 기본 PyTorch 설치에서 CUDA 지원을 받지만, Windows 사용자는 torch+cuda 설치를 위한 index-url을 지정해야 합니다. 최신 업데이트에 따르면 PyTorch는 CUDA toolkit 버전 12.1까지 호환됩니다. CUDA 호환성 및 설치 안내에 대한 최신 정보는 PyTorch 웹사이트 (PyTorch — 로컬에서 시작하기)에서 확인할 수 있습니다.\u003c/li\u003e\n\u003cli\u003ebitsandbytes 설치 변형: bitsandbytes의 표준 설치는 Linux에 최적화되어 있으며, 하나의 릴리스 빌드에서 여러 CUDA 버전을 수용합니다. 그러나 Windows 사용자는 소스에서 직접 빌드하거나 비공식 GitHub 저장소를 사용하여 설치해야 합니다. Windows용 구체적인 설치 지침은 이 기사의 이전 섹션에서 찾을 수 있습니다. Windows를 위한 추가 정보 및 안내는 bitsandbytes 비공식 Windows 저장소(\u003ca href=\"https://github.com/jllllll/bitsandbytes-windows-webui)%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/jllllll/bitsandbytes-windows-webui)에서\u003c/a\u003e 확인할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eCuda Toolkit 필요성: GPU 기반 작업을 용이하게 하기 위해 \u003ca href=\"https://developer.nvidia.com/cuda-12-1-0-download-archive%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://developer.nvidia.com/cuda-12-1-0-download-archive에서\u003c/a\u003e Cuda toolkit을 설치하세요. 사용 중인 torch+cuda 버전과 CUDA toolkit 버전을 일치시키는 것이 좋습니다. 현재 최신 torch는 CUDA 버전 12.1을 지원합니다.\u003c/li\u003e\n\u003cli\u003eMicrosoft C++ 빌드 도구: Windows에서 GPU 프로세스를 실행하려면 Microsoft C++ 빌드 도구를 설치해야 합니다. 이는 accelarate 및 autoawq 패키지의 psutils 종속성으로 인한 것입니다.\u003c/li\u003e\n\u003cli\u003eautoawq 패키지는 GPU에서 AWQ 기반 양자화 모델을 실행해야 하는 경우에만 필요합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWindows 시스템의 특정 요구 사항을 고려하여 NVidia GPU에서 LLMs를 효과적으로 실행하기 위한 중요한 단계입니다. huggingface 설치 및 모델 다운로드에 대한 자세한 정보는 link1과 link2를 확인하세요.\u003c/p\u003e\n\u003cp\u003eHuggingface에 계정을 생성하면 토큰을 생성할 수 있는 능력이 생깁니다. 이 토큰은 export(예: HF_TOKEN)을 통해 환경에 구성하거나 Huggingface API와 함께 매개변수로 사용하여 모델 다운로드 및 다른 포턜 작업에 사용할 수 있습니다. 이 토큰은 서비스에 액세스하기 위한 패스로 생각할 수 있습니다. 또한 Llama와 같은 특정 모델을 다운로드하려면 승인이 필요할 수 있으며, 계정을 사용하여 Huggingface 포턜을 통해 요청할 수 있습니다. 부여된 모든 승인은 계정과 그 계정으로 생성된 모든 토큰과 연결됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e추론\u003c/h1\u003e\n\u003cp\u003e이 스크립트는 추론 모드를 구체화하여 모델 실행에 적합한 하드웨어(CPU 또는 GPU)를 선택합니다. 만약 추론 모드가 'cpu'로 설정되어 있다면, GPT-2 모델이 로드되며, 작은 크기(~500MB)로 CPU 사용에 이상적이기 때문에 'cpu'로 설정된 device_map을 사용하여 타겟팅된 실행이 가능합니다. 반대로, GPU 사용 시에는 더 큰 Meta LLaMA 2 7B 모델(~13GB)을 선택하며, 'auto'로 설정된 device_map을 활용하여 유연한 장치 할당을 하고 load_in_4bit을 활성화하여 메모리 사용량을 최소화하여 한정된 메모리를 가진 GPU에서 큰 모델의 작동을 촉진합니다. pipeline 함수는 로드된 모델과 토크나이저를 사용하여 텍스트 생성 파이프라인을 생성하며, max_new_tokens와 같은 매개변수를 설정하여 생성된 텍스트의 길이를 제어합니다. 또한 streamer가 파이프라인에 전달되어, 스트리밍된 텍스트 생성이 사용될 것을 나타냅니다.\u003c/p\u003e\n\u003cp\u003einference.py\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e torch\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e transformers \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e AutoTokenizer, AutoModelForCausalLM, TextStreamer, pipeline, BitsAndBytesConfig\n\ninference_type = \u003cspan class=\"hljs-string\"\u003e'cpu'\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e inference_type == \u003cspan class=\"hljs-string\"\u003e'cpu'\u003c/span\u003e:\n    \u003cspan class=\"hljs-comment\"\u003e# CPU 추론\u003c/span\u003e\n    model_name = \u003cspan class=\"hljs-string\"\u003e'gpt2'\u003c/span\u003e  \u003cspan class=\"hljs-comment\"\u003e# ~500MB 원본 크기\u003c/span\u003e\n    model = AutoModelForCausalLM.from_pretrained(\n        model_name,\n        device_map=\u003cspan class=\"hljs-string\"\u003e'cpu'\u003c/span\u003e\n    )\n\u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e:    \n    \u003cspan class=\"hljs-comment\"\u003e# GPU 추론; 'gpu'\u003c/span\u003e\n    model_name = \u003cspan class=\"hljs-string\"\u003e'meta-llama/Llama-2-7b-hf'\u003c/span\u003e  \u003cspan class=\"hljs-comment\"\u003e# ~13GB 원본 크기\u003c/span\u003e\n    quantization_config = BitsAndBytesConfig(load_in_4bit=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e, bnb_4bit_compute_dtype=torch.bfloat16)\n    model = AutoModelForCausalLM.from_pretrained(\n        model_name, \n        device_map=\u003cspan class=\"hljs-string\"\u003e'auto'\u003c/span\u003e,\n        quantization_config=quantization_config)\ntokenizer = AutoTokenizer.from_pretrained(model_name)\nstreamer = TextStreamer(\n     tokenizer,\n     skip_prompt=\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e,\n     skip_special_tokens=\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e\n)\ntext_pipeline = pipeline(\n    \u003cspan class=\"hljs-string\"\u003e\"text-generation\"\u003c/span\u003e,\n    model=model,\n    tokenizer=tokenizer,\n    max_new_tokens=\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,  \u003cspan class=\"hljs-comment\"\u003e# 생성할 토큰의 최대 수\u003c/span\u003e\n    streamer=streamer,     \n)\nprompt=\u003cspan class=\"hljs-string\"\u003e'I like apple pie'\u003c/span\u003e\ntext_pipeline(prompt) \n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e제공된 예제에서는 사전 학습된 모델을 사용하고 있습니다. 이 모델은 일련의 토큰과 같은 특정 키워드를 필요로 할 수도 있습니다. 모델이 이러한 토큰을 요구하는지 확인하려면 tokenizer_config.json 파일에서 add_bos_token 및 add_eos_token 설정을 확인할 수 있습니다. 이를 자동으로 처리하는 실용적인 방법은 text_pipeline 추론 호출에서 add_special_tokens=True (기본값 False)로 설정하는 것입니다. 이렇게 하면 프레임워크가 모델로 전송되기 전에 프롬프트에 특수 키워드를 삽입할지 여부를 결정할 수 있습니다. 위 예시에서는 해당 매개변수를 사용하지 않았습니다.\u003c/p\u003e\n\u003cp\u003e스크립트 실행\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(venv)$ python inference.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e출력:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eBitsAndBytesConfig가 load_in_4bit=True로 전달되어 있습니다. 이는 변환 라이브러리에게 모델의 가중치를 4비트로 줄이라는 지시를하는 것이고, 이는 모델의 원래 크기의 25%에 해당합니다 (Llama 2는 float16 형식입니다). 이는 추론 속도를 향상시킵니다. bnb_4bit_compute_dtype는 torch.bfloat16으로 설정되어 있어 GPU에서 실제 계산이 여전히 float16로 수행되도록 합니다. 선택할 수 있는 대안 옵션은 load_in_8bit=True이며, load_in_4bit 옵션과 상호 배제됩니다. 8비트 모드는 약간 향상된 정확성을 제공하지만 모델 크기를 원래 크기의 50%로 줄이고 추론 속도를 낮춥니다. 양자화 옵션을 선택하지 않은 경우 변환 라이브러리는 가용한 VRAM에 따라 전체 모델을 GPU의 비디오 RAM에로드하는 것을 기본값으로 설정합니다.\u003c/p\u003e\n\u003ch1\u003e사전 양자화 모델 로드\u003c/h1\u003e\n\u003cp\u003eGPU 추론 시 모델을 로드할 때마다 양자화하는 대신, 디스크에서 사전 양자화 된 모델을로드할 수 있습니다. 인기있는 양자화 형식 중 두 가지는 GPTQ 및 AWQ입니다. Huggingface는 둘 다 지원합니다.\u003c/p\u003e\n\u003cp\u003eAWQ 유형 모델의 경우 아래 코드로 모델로드 라인을 대체하면 됩니다 (GPU 추론 경로에서). BitsAndBytesConfig 매개 변수가 생략됩니다. 왜냐하면 모델이 이미 양자화되어 있기 때문입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emodel_name=\u003cspan class=\"hljs-string\"\u003e'TheBloke/zephyr-7B-alpha-AWQ'\u003c/span\u003e \nmodel = \u003cspan class=\"hljs-title class_\"\u003eAutoModelForCausalLM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_pretrained\u003c/span\u003e( \n    model_name, \n    device_map=\u003cspan class=\"hljs-string\"\u003e'auto'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGPTQ 모델의 경우 아래 라인으로 모델 로드를 대체합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003emodel_name=\u003cspan class=\"hljs-string\"\u003e'TheBloke/zephyr-7B-beta-GPTQ'\u003c/span\u003e \nmodel = \u003cspan class=\"hljs-title class_\"\u003eAutoModelForCausalLM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_pretrained\u003c/span\u003e( \n    model_name, \n    revision=\u003cspan class=\"hljs-string\"\u003e'main'\u003c/span\u003e, \n    device_map=\u003cspan class=\"hljs-string\"\u003e'auto'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGitHub 브랜치에 해당하는 revision을 사용했습니다. zephyr-7B-beta-GPTQ 양자화 버전은 서로 다른 브랜치에 저장되어 있습니다. 자세한 내용은 \u003ca href=\"https://huggingface.co/TheBloke/zephyr-7B-beta-GPTQ%EC%9D%98\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://huggingface.co/TheBloke/zephyr-7B-beta-GPTQ의\u003c/a\u003e ‘Files and versions’ 탭을 참조해주세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eGGUF 양자화\u003c/h1\u003e\n\u003cp\u003eGGUF는 llama.cpp에서 소개된 인기 있는 양자화 방법입니다. ctransformers는 GGML/GGUF 라이브러리를 사용하여 C/C++로 구현된 Transformer 모델용 Python 바인딩입니다. 또한 RAG Langchain과 통합되어 있습니다.\u003c/p\u003e\n\u003cp\u003e귀하의 구성에 따라 ctransformers 패키지를 설치하세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(venv)$ pip install ctransformers\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003ehuggingface-cli를 사용하여 GGUF 형식 모델을 다운로드하거나 from_pretrained() 호출을 통해 해당 모델의 첫 API 호출 시 자동으로 다운로드됩니다. 아래 코드 샘플은 GGUF 형식의 모델에 대해 ctransformers를 활용하는 방법을 보여줍니다. from_pretrained 메서드는 이전에 다운로드되지 않은 경우 Hugging Face에서 모델을 자동으로 가져옵니다. zephyr GGUF와 같은 일부 모델 유형은 동일한 리포지토리에 파일로 저장됩니다. 여기서 리포지토리 이름은 'TheBloke/zephyr-7B-beta-GGUF'이고 모델 파일은 zephyr-7b-beta.Q4_K_M.gguf입니다.\u003c/p\u003e\n\u003cp\u003einference.py\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e ctransformers \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAutoModelForCausalLM\u003c/span\u003e\n# \u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e gpu_layers to the number \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e layers to offload to \u003cspan class=\"hljs-variable constant_\"\u003eGPU\u003c/span\u003e. \u003cspan class=\"hljs-title class_\"\u003eSet\u003c/span\u003e to \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e no \u003cspan class=\"hljs-variable constant_\"\u003eGPU\u003c/span\u003e acceleration is available on your system.\nllm = \u003cspan class=\"hljs-title class_\"\u003eAutoModelForCausalLM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_pretrained\u003c/span\u003e(\n    \u003cspan class=\"hljs-string\"\u003e'TheBloke/zephyr-7B-beta-GGUF'\u003c/span\u003e,\n    model_file=\u003cspan class=\"hljs-string\"\u003e'zephyr-7b-beta.Q4_K_M.gguf'\u003c/span\u003e,\n    model_type=\u003cspan class=\"hljs-string\"\u003e'llama'\u003c/span\u003e,\n    gpu_layers=\u003cspan class=\"hljs-number\"\u003e32\u003c/span\u003e\n)\nprompt=\u003cspan class=\"hljs-string\"\u003e'\u0026#x3C;s\u003eI like apple pie'\u003c/span\u003e\n# \u003cspan class=\"hljs-title class_\"\u003eDo\u003c/span\u003e inference \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e streaming\nstream=\u003cspan class=\"hljs-title function_\"\u003ellm\u003c/span\u003e(prompt, stream=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e chunk \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estream\u003c/span\u003e:\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(chunk, end=\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e, flush=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사용 중인 특정 모델에 따라 gpu_layers 설정을 조정하세요. 이 경우, GPU에 32개 레이어를 할당하도록 설정합니다. 추론에 stream=True을 설정하면 모델이 생성하는 토큰을 실시간으로 표시할 수 있습니다. zephyr용 다양한 양자화된 모델 버전은 \u003ca href=\"https://huggingface.co/TheBloke/zephyr-7B-beta-GGUF%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://huggingface.co/TheBloke/zephyr-7B-beta-GGUF에서\u003c/a\u003e 확인할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003chr\u003e\n\u003ch1\u003eLLama.cpp python\u003c/h1\u003e\n\u003cp\u003eLLama.cpp은 다양한 백엔드(CUDA, Metal, OpenCL, SYCL)를 지원하여 적응성을 높인 유연한 C/C++ 라이브러리로, Meta의 LLaMA 모델과 같은 대규모 언어 모델에서 추론을 실행할 수 있는 능력으로 AI 분야에서 인식을 얻고 있습니다. llama-cpp-python 패키지를 통한 Python 통합은 사용자가 C/C++의 성능을 누리면서도 Python의 간편함을 누릴 수 있도록 합니다.\u003c/p\u003e\n\u003cp\u003ellama-cpp-python을 설치하는 선호하는 방법은 소스에서 컴파일하는 것입니다. 이 방법을 권장하는 이유는 기밀된 C/C++ 라이브러리인 llama.cpp이 특정 시스템에 맞춘 컴파일러 최적화를 활용하기 때문입니다. 미리 빌드된 이진 파일을 선택하면 이러한 최적화를 포기하거나 다양한 플랫폼용 이진 파일을 관리해야 할 수도 있습니다. llama-cpp-python을 컴파일하면 llama.cpp 라이브러리를 자동으로 라이브러리 파일(lib)로 빌드합니다. 이 라이브러리 파일은 특정 바인딩을 통해 Python에서 활용되어, Python 스크립트가 llama.cpp의 기능에 액세스하고 사용할 수 있도록 합니다. 컴파일 세부 정보는 llama-cpp-python의 github 저장소를 참조하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e시스템에는 해당 버전의 BLAS 라이브러리가 설치되어 있어야 합니다. llama.cpp README의 ‘BLAS 빌드’ 섹션을 확인해보세요.\u003c/p\u003e\n\u003cp\u003eIntel ARC GPU는 SYCL을 통해 지원되며, 이를 위해서는 Intel OneAPI가 설치되어 있어야 합니다. README의 SYCL 섹션을 확인해보세요.\u003c/p\u003e\n\u003cp\u003ellama-cpp-python의 자세한 빌드 지시사항은 \u003ca href=\"https://github.com/abetlen/llama-cpp-python%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/abetlen/llama-cpp-python에서\u003c/a\u003e 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e간단한 지시사항은 여기에 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eCPU 또는 GPU용 llama-cpp-python 패키지를 설치해 보세요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e 빌드용\n(venv)$ \u003cspan class=\"hljs-variable constant_\"\u003eCMAKE_ARGS\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"-DLLAMA_BLAS=ON -DLLAMA_BLAS_VENDOR=OpenBLAS\"\u003c/span\u003e pip install llama-cpp-python --upgrade --force-reinstall --no-cache-dir\n\n# \u003cspan class=\"hljs-title class_\"\u003eNvidia\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGPU\u003c/span\u003e 빌드용\n(venv)$ \u003cspan class=\"hljs-variable constant_\"\u003eCMAKE_ARGS\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"-DLLAMA_CUBLAS=on\"\u003c/span\u003e pip install llama-cpp-python --upgrade --force-reinstall --no-cache-dir\n\n# \u003cspan class=\"hljs-title class_\"\u003eIntel\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eARC\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGPUS\u003c/span\u003e를 위한 \u003cspan class=\"hljs-variable constant_\"\u003eSYCL\u003c/span\u003e을 통한 빌드\nsource /opt/intel/oneapi/setvars.\u003cspan class=\"hljs-property\"\u003esh\u003c/span\u003e   \n\u003cspan class=\"hljs-variable constant_\"\u003eCMAKE_ARGS\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"-DLLAMA_SYCL=on -DCMAKE_C_COMPILER=icx -DCMAKE_CXX_COMPILER=icpx\"\u003c/span\u003e pip install llama-cpp-python\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ellama-cpp-python은 Hugging Face에서 얻을 수 있는 GGUF 모델 형식을 요구합니다. 그러나 llama의 API 사양으로 인해, 모델을 수동으로 다운로드하여 다른 디렉토리에 저장한 다음 해당 디렉토리 경로를 llama-cpp-python에 지정해야 합니다. 이번에는 우리의 정규 절차에서 벗어나, 명시적 로컬 폴더로 직접 다운로드하는 방식으로 사용 설명서 tuning된 Llama 2 모델을 사용하겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(venv)$ huggingface-cli download \u003cspan class=\"hljs-title class_\"\u003eTheBloke\u003c/span\u003e/\u003cspan class=\"hljs-title class_\"\u003eLlama\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e-7b-\u003cspan class=\"hljs-title class_\"\u003eChat\u003c/span\u003e-\u003cspan class=\"hljs-variable constant_\"\u003eGGUF\u003c/span\u003e llama-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e-7b-chat.\u003cspan class=\"hljs-property\"\u003eQ4_K_M\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egguf\u003c/span\u003e --local-dir . --local-dir-use-symlinks \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003elocal-dir-use-symlinks를 True로 설정하여 활성화하면 현재 디렉토리에 모델을 캐시 디렉토리에 이미 다운로드된 모델을 가리키는 심볼릭 링크를 생성하려고 시도하므로 시간과 공간을 효율적으로 사용할 수 있습니다. 심볼릭 링크를 사용하지 않고 현재 디렉토리에 모델의 완전한 사본이 필요하다면 이 옵션을 생략하는 것이 가장 좋습니다.\u003c/p\u003e\n\u003cp\u003e현재 디렉토리에 모델을 다운로드한 경우 model_path는 절대 경로 또는 상대 경로로 지정해야 합니다.\u003c/p\u003e\n\u003cp\u003einference.py\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e llama_cpp \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Llama\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e llama_cpp\nllm = llama_cpp.Llama(model_path=\u003cspan class=\"hljs-string\"\u003e\"./llama-2-7b-chat.Q4_K_M.gguf\"\u003c/span\u003e,\n                verbose=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e, n_gpu_layers=-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, chat_format=\u003cspan class=\"hljs-string\"\u003e\"llama-2\"\u003c/span\u003e)\nprompt = \u003cspan class=\"hljs-string\"\u003e'[INST] Hi there, write me 3 random quotes [/INST]'\u003c/span\u003e\nstream = llm(prompt, max_tokens=\u003cspan class=\"hljs-number\"\u003e2048\u003c/span\u003e, echo=\u003cspan class=\"hljs-literal\"\u003eFalse\u003c/span\u003e, temperature=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, stream=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\nresult = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e output \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e stream:\n    result += output[\u003cspan class=\"hljs-string\"\u003e'choices'\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e'text'\u003c/span\u003e]\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(output[\u003cspan class=\"hljs-string\"\u003e'choices'\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e'text'\u003c/span\u003e], end=\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 코드는 시스템이 Llama2 7B 모델의 모든 레이어(n_gpu_layers=-1)를 GPU에로드하도록 지시합니다. 사용 가능한 VRAM에 따라 n_gpu_layers 값을 수정하여 CPU와 GPU 사이의 작업 부하를 분산시킬 수 있으며, 예를 들어 대규모 모델을 효과적으로 관리하기 위해 작업을 균등하게 분할할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e프롬프트 구문의 중요성\u003c/p\u003e\n\u003cp\u003e위에서 사용된 모델은 채팅용으로 조정된 모델이므로 프롬프트 형식은 매우 중요합니다([INST] 사용). 이는 모델의 이해와 작업 실행에 상당한 영향을 미치기 때문입니다. 지시에 따라 응답을 생성할 수 있도록 특별히 설계된 지시에 조정된 모델은 상세 명령을 따르고 프롬프트에서 제공된 지침에 따라 응답을 생성합니다. 올바른 구문은 모델이 지시의 의도를 정확하게 이해하고 결과가 정확하고 타당한 것을 보장하는 데 중요합니다. 또한 다양한 모델 아키텍처는 다른 프롬프트 구문에 최적으로 반응할 수 있도록 세밀하게 조정됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003ellama.cpp 기반의 GPT-3.5 대체품입니다.\u003c/h1\u003e\n\u003cp\u003e이 섹션은 llama.cpp를 OpenAI의 GPT 엔드포인트 대신 사용할 수 있는 방법을 탐구합니다. llama.cpp 모델을 활용하여 OpenAI의 서비스에 의존하지 않고 로컬 llama.cpp 모델을 사용하여 GPT 기반 애플리케이션을 운영할 수 있습니다. 로컬 API 서버를 실행함으로써 OpenAI의 GPT API 엔드포인트의 기능을 모방하면서도 llama 모델을 사용하여 요청을 처리할 수 있습니다. 이는 GPT-3.5 또는 GPT-4를 대상으로 한 애플리케이션이 llama.cpp를 사용하도록 원활하게 전환할 수 있음을 의미합니다. 최종 목표는 비용을 절감하는 것뿐만 아니라 데이터가 로컬 환경 내에서 개인 정보 보호 및 안전성을 유지하도록 하는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e먼저 llama-cpp-python과 서버 지원 및 필수 요소를 설치해야 합니다. 패키지가 처음에 CPU 사용을 위해 설정되어 있고 이제 GPU 사용으로 전환하고 싶은 경우(또는 그 반대인 경우) 새 대상을 위해 설치 명령을 다시 실행하여 다시 설치해야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e 빌드용\n(venv)$ \u003cspan class=\"hljs-variable constant_\"\u003eCMAKE_ARGS\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"-DLLAMA_BLAS=ON -DLLAMA_BLAS_VENDOR=OpenBLAS\"\u003c/span\u003e pip install llama-cpp-python[server] --upgrade --force-reinstall --no-cache-dir\n\n# \u003cspan class=\"hljs-title class_\"\u003eNvidia\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGPU\u003c/span\u003e 빌드용\n(venv)$ \u003cspan class=\"hljs-variable constant_\"\u003eCMAKE_ARGS\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"-DLLAMA_CUBLAS=on\"\u003c/span\u003e pip install llama-cpp-python[server] --upgrade --force-reinstall --no-cache-dir\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eopenai 패키지 설치\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(venv)$ pip install openai\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ehuggingface-cli 도구를 사용하여 로컬 폴더에 모델 다운로드하기\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(venv)$ huggingface-cli \u003cspan class=\"hljs-title class_\"\u003eTheBloke\u003c/span\u003e/\u003cspan class=\"hljs-title class_\"\u003eLlama\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e-7b-\u003cspan class=\"hljs-title class_\"\u003eChat\u003c/span\u003e-\u003cspan class=\"hljs-variable constant_\"\u003eGGUF\u003c/span\u003e 다운로드 llama-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e-7b-chat.\u003cspan class=\"hljs-property\"\u003eQ4_K_M\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egguf\u003c/span\u003e --local-dir . --local-dir-use-symlinks \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e모델에 입력하기 전에 프롬프트를 Llama-2 형식으로 구조화하는 방법과 함께 서버를 실행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e(venv)$ python3 -m llama_cpp.\u003cspan class=\"hljs-property\"\u003eserver\u003c/span\u003e --model ./llama-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e-7b-chat.\u003cspan class=\"hljs-property\"\u003eQ4_K_M\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003egguf\u003c/span\u003e --n_gpu_layers \u003cspan class=\"hljs-number\"\u003e35\u003c/span\u003e --chat_format llama-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서버는 기본적으로 포트 8000을 사용하도록 구성되어 있습니다. 아래의 클라이언트 스크립트에서 서비스에 연결하도록 설계된 경우 사용자 정의 포트 실행에 필요한 포트 번호를 수정하세요. 모델 매개변수에는 더미 값(e.g. xxxxx)이 할당되어 있으며, 이는 서버에서 무시되며 본 예제에서는 간편함을 위해 인증 프로세스가 포함되어 있지 않습니다. 또한 서버가 올바르게 실행 중인지 확인하려면 브라우저에서 \u003ca href=\"http://localhost:8000/docs#/%EC%9D%84\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://localhost:8000/docs#/을\u003c/a\u003e 방문하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eclient.py\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e openai \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e OpenAI\nclient = OpenAI(base_url=\u003cspan class=\"hljs-string\"\u003e\"http://127.0.0.1:8000/v1\"\u003c/span\u003e) \nstream = client.chat.completions.create(\n  model=\u003cspan class=\"hljs-string\"\u003e\"xxxxx\"\u003c/span\u003e,\n  messages=[\n    {\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"You are a well-read scholar with a deep appreciation for literature, especially when it comes to the subject of artificial intelligence (AI)\"\u003c/span\u003e},\n    {\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Give me 3 quotes on AI.\"\u003c/span\u003e}\n  ],\n  temperature=\u003cspan class=\"hljs-number\"\u003e0.01\u003c/span\u003e,\n  stream=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e,  \n)\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e chunk \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e stream:\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enot\u003c/span\u003e chunk.choices \u003cspan class=\"hljs-keyword\"\u003eor\u003c/span\u003e chunk.choices[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].delta.content \u003cspan class=\"hljs-keyword\"\u003eis\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eNone\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e\n    \u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(chunk.choices[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].delta.content, end=\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e)\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRun the client script in another terminal.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-bash\"\u003e(venv)$ python client.py\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e수신된 출력 스트림은 터미널 창에 표시됩니다.\u003c/p\u003e\n\u003cp\u003e출력 (모델에서 받은 대로):\u003c/p\u003e\n\u003chr\u003e\n\u003ch1\u003e참고 자료\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eHugging Face [\u003ca href=\"https://huggingface.co/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://huggingface.co/\u003c/a\u003e]\u003c/li\u003e\n\u003cli\u003ellama.cpp에 대한 Python 바인딩 [\u003ca href=\"https://github.com/abetlen/llama-cpp-python\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/abetlen/llama-cpp-python\u003c/a\u003e]\u003c/li\u003e\n\u003cli\u003e양자화 [\u003ca href=\"https://huggingface.co/docs/optimum/concept_guides/quantization\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://huggingface.co/docs/optimum/concept_guides/quantization\u003c/a\u003e]\u003c/li\u003e\n\u003cli\u003e당신에게 적합한 양자화 방법은 무엇인가요? (GPTQ vs. GGUF vs. AWQ) [\u003ca href=\"https://towardsdatascience.com/which-quantization-method-is-right-for-you-gptq-vs-gguf-vs-awq-c4cd9d77d5be\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://towardsdatascience.com/which-quantization-method-is-right-for-you-gptq-vs-gguf-vs-awq-c4cd9d77d5be\u003c/a\u003e]\u003c/li\u003e\n\u003cli\u003eNvidia CUDA [\u003ca href=\"https://developer.nvidia.com/cuda-12-1-0-download-archive\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://developer.nvidia.com/cuda-12-1-0-download-archive\u003c/a\u003e]\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-LLMsMadeAccessibleABeginnersUnifiedGuidetoLocalDeploymentviaPython"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>