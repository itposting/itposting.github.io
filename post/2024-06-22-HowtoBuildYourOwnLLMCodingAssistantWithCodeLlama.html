<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Code Llama로 나만의 LLM 코딩 어시스턴트 만드는 방법  | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Code Llama로 나만의 LLM 코딩 어시스턴트 만드는 방법  | itposting" data-gatsby-head="true"/><meta property="og:title" content="Code Llama로 나만의 LLM 코딩 어시스턴트 만드는 방법  | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama" data-gatsby-head="true"/><meta name="twitter:title" content="Code Llama로 나만의 LLM 코딩 어시스턴트 만드는 방법  | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 21:36" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Code Llama로 나만의 LLM 코딩 어시스턴트 만드는 방법 </h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Code Llama로 나만의 LLM 코딩 어시스턴트 만드는 방법 " loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이 실습에서는 무료로 사용할 수 있고 로컬 GPU에서 실행되는 AI 코드 어시스턴트를 구현할 예정입니다.</p>
<p>챗봇에 질문을 하면 자연어로 답변하며 여러 프로그래밍 언어로 코드도 제공합니다.</p>
<p>우리는 Hugging Face transformer 라이브러리를 사용하여 LLM을 구현하고 Chatbot 프론트 엔드에는 Streamlit을 사용할 것입니다.</p>
<h1>LLM이 텍스트를 생성하는 방법은 무엇인가요?</h1>
<div class="content-ad"></div>
<p>디코더 전용 트랜스포머 모델인 GPT 계열은 주어진 입력 프롬프트에 대한 다음 단어를 예측하도록 훈련되었습니다. 이로 인해 텍스트 생성에 아주 능숙합니다.</p>
<p><img src="/assets/img/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama_0.png" alt="이미지"></p>
<p>충분한 훈련 데이터가 제공된다면, 코드를 생성하는 것도 배울 수 있습니다. IDE에서 코드를 채우는 방식이나 챗봇으로 질문에 답변하는 방식으로 가능합니다.</p>
<p>GitHub Copilot은 상용 예시로서 AI 페어 프로그래머의 한 예입니다. Meta AI의 Code Llama 모델은 유사한 능력을 갖추고 있지만 무료로 사용할 수 있습니다.</p>
<div class="content-ad"></div>
<h1>코드 람마란 무엇인가요?</h1>
<p>코드 람마는 Meta AI가 만들고 2023년 8월에 처음으로 출시한 코드 전용 LLM 계열의 특별한 제품입니다.</p>
<p><img src="/assets/img/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama_1.png" alt="이미지"></p>
<p>Meta AI는 기본 모델 Llama 2(디코더 전용 Transformer 모델로 GPT-4와 유사함)을 시작으로, 대부분 코드로 이루어진 500B 토큰의 교육 데이터를 활용하여 추가 교육을 진행했습니다.</p>
<div class="content-ad"></div>
<p>그 이후로 Code Llama에 대한 세 가지 버전이 네 가지 다른 크기로 제공됩니다.</p>
<p>Code Llama 모델은 연구 및 상업적 사용을 위해 무료입니다.</p>
<p><img src="/assets/img/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama_2.png" alt="이미지"></p>
<h2>Code Llama</h2>
<div class="content-ad"></div>
<p>코드 Llama는 코드 생성을 위한 기반 모델입니다. 코드 Llama 모델은 infill 목적으로 훈련되어 IDE 내에서 코드 완성을 위해 설계되었습니다.</p>
<h2>코드 Llama — Instruct</h2>
<p>Instruct 버전은 인간의 질문에 답변하기 위해 지시 데이터셋에 맞춰 세밀하게 조정되었습니다. 이는 ChatGPT와 유사합니다.</p>
<h2>코드 Llama — Python</h2>
<div class="content-ad"></div>
<p>파이썬 버전은 추가 데이터셋인 100B 토큰의 파이썬 코드로 훈련되었습니다. 이 모델들은 코드 생성을 위해 의도되었습니다.</p>
<h1>LLM 챗봇 코딩</h1>
<p>본 튜토리얼에서는 Instruct 버전 중 가장 작은 모델인 CodeLlama-7b-Instruct — hf를 사용할 것입니다. 이 모델은 자연어 질문에 답변하도록 세밀하게 튜닝되어 있기 때문에 챗봇으로 사용할 수 있습니다.</p>
<p>가장 작은 모델조차도 여전히 7B 매개변수로 상당히 큽니다. 매개변수의 16비트 반정밀도를 사용하면, 모델은 약 14 GB의 GPU 메모리가 필요합니다. 4비트 양자화를 사용하면, 메모리 요구 사항을 약 3.5 GB 정도로 줄일 수 있습니다.</p>
<div class="content-ad"></div>
<h2>모델 구현하기</h2>
<p>우리는 먼저 Hugging Face에서 Code Llama 모델을 불러오고 주어진 프롬프트에 기반하여 텍스트를 생성할 ChatModel 클래스를 생성하는 것으로 시작하겠습니다.</p>
<p>우리는 4비트 양자화를 위해 BitsAndBytesConfig를 사용하며, 모델을 로드하기 위해 AutoModelForCausalLM을 사용하고 입력 프롬프트로부터 토큰 임베딩을 생성하기 위해 AutoTokenizer를 사용합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> torch
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> <span class="hljs-title class_">AutoTokenizer</span>, <span class="hljs-title class_">AutoModelForCausalLM</span>, <span class="hljs-title class_">BitsAndBytesConfig</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatModel</span>:
    def <span class="hljs-title function_">__init__</span>(self, model=<span class="hljs-string">"codellama/CodeLlama-7b-Instruct-hf"</span>):
        quantization_config = <span class="hljs-title class_">BitsAndBytesConfig</span>(
            load_in_4bit=<span class="hljs-title class_">True</span>, # <span class="hljs-number">4</span>비트 양자화 사용
            bnb_4bit_compute_dtype=torch.<span class="hljs-property">float16</span>,
            bnb_4bit_use_double_quant=<span class="hljs-title class_">True</span>,
        )
        self.<span class="hljs-property">model</span> = <span class="hljs-title class_">AutoModelForCausalLM</span>.<span class="hljs-title function_">from_pretrained</span>(
            model,
            quantization_config=quantization_config,
            device_map=<span class="hljs-string">"cuda"</span>,
            cache_dir=<span class="hljs-string">"./models"</span>, # 모델을 models 폴더에 다운로드
        )
        self.<span class="hljs-property">tokenizer</span> = <span class="hljs-title class_">AutoTokenizer</span>.<span class="hljs-title function_">from_pretrained</span>(
            model, use_fast=<span class="hljs-title class_">True</span>, padding_side=<span class="hljs-string">"left"</span>
        )
</code></pre>
<div class="content-ad"></div>
<p>또한, 사용자의 이전 입력 프롬프트와 AI가 생성한 응답을 저장하는 고정 길이의 히스토리 목록을 만듭니다. 이는 대화의 기억을 제공하여 LLM에게 대화의 기억을 부여하는 데 유용합니다.</p>
<pre><code class="hljs language-js">self.<span class="hljs-property">history</span> = []
self.<span class="hljs-property">history_length</span> = <span class="hljs-number">1</span>
</code></pre>
<p>Code Llama은 사용자 프롬프트 앞에 시스템 프롬프트를 사용합니다.</p>
<p>기본적으로, codellama-13b-chat 예제에서 시스템 프롬프트를 사용할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">self.<span class="hljs-property">DEFAULT_SYSTEM_PROMPT</span> = <span class="hljs-string">""</span><span class="hljs-string">"\
당신은 코드와 소프트웨어 디자인에 대한 깊은 지식을 가진, 도움이 되는, 예의 바르고 정직한 도우미입니다. 항상 도움이 될 수 있는 답변을 해야 하며, 안전하고 신중해야 합니다. 답변에 해로운, 부정한, 인종 차별적, 성 차별적, 유해한, 위험한, 또는 불법적인 내용을 포함해서는 안 됩니다. 답변이 사회적으로 편향되거나 부정적이여선 안됩니다.\n\n만약 질문이 이해할 수 없거나 사실적으로 일관성이 없다면, 올바른 대답 대신 왜 잘못된 것인지 설명하세요. 만약 질문에 대한 대답을 모르면, 가짜 정보를 공유하지 말고 대신 말해주세요.\
        "</span><span class="hljs-string">""</span>
</code></pre>
<p>이제 self.history에 현재 대화를 추가하는 함수를 구현해봅시다.</p>
<p>LLM(어라운드  모델)은 한정된 문맥 길이를 가지고 있기 때문에 메모리에 정보를 한정적으로 보관할 수밖에 없습니다. 여기서는 self.history_length = 1 개의 질문과 대답만 최대한 보관합니다.</p>
<pre><code class="hljs language-js">    def <span class="hljs-title function_">append_to_history</span>(self, user_prompt, response):
        self.<span class="hljs-property">history</span>.<span class="hljs-title function_">append</span>((user_prompt, response))
        <span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span>(self.<span class="hljs-property">history</span>) > self.<span class="hljs-property">history_length</span>:
            self.<span class="hljs-property">history</span>.<span class="hljs-title function_">pop</span>(<span class="hljs-number">0</span>)
</code></pre>
<div class="content-ad"></div>
<p>마침내 우리는 입력 프롬프트에 기반한 텍스트를 생성하는 generate 함수를 구현합니다.</p>
<p>각 LLM에는 훈련에 사용된 특정 프롬프트 템플릿이 있습니다. Code Llama의 경우 codellama-13b-chat의 프롬프트 템플릿을 참조로 사용했습니다.</p>
<pre><code class="hljs language-js">    def <span class="hljs-title function_">generate</span>(
        self, user_prompt, system_prompt, top_p=<span class="hljs-number">0.9</span>, temperature=<span class="hljs-number">0.1</span>, max_new_tokens=<span class="hljs-number">512</span>
    ):

        texts = [f<span class="hljs-string">"&#x3C;s>[INST] &#x3C;&#x3C;SYS>>\n{system_prompt}\n&#x3C;&#x3C;/SYS>>\n\n"</span>]
        do_strip = <span class="hljs-title class_">False</span>
        <span class="hljs-keyword">for</span> old_prompt, old_response <span class="hljs-keyword">in</span> self.<span class="hljs-property">history</span>:
            old_prompt = old_prompt.<span class="hljs-title function_">strip</span>() <span class="hljs-keyword">if</span> do_strip <span class="hljs-keyword">else</span> old_prompt
            do_strip = <span class="hljs-title class_">True</span>
            texts.<span class="hljs-title function_">append</span>(f<span class="hljs-string">"{old_prompt} [/INST] {old_response.strip()} &#x3C;/s>&#x3C;s>[INST] "</span>)
        user_prompt = user_prompt.<span class="hljs-title function_">strip</span>() <span class="hljs-keyword">if</span> do_strip <span class="hljs-keyword">else</span> user_prompt
        texts.<span class="hljs-title function_">append</span>(f<span class="hljs-string">"{user_prompt} [/INST]"</span>)
        prompt = <span class="hljs-string">""</span>.<span class="hljs-title function_">join</span>(texts)

        inputs = self.<span class="hljs-title function_">tokenizer</span>(
            prompt, return_tensors=<span class="hljs-string">"pt"</span>, add_special_tokens=<span class="hljs-title class_">False</span>
        ).<span class="hljs-title function_">to</span>(<span class="hljs-string">"cuda"</span>)

        output = self.<span class="hljs-property">model</span>.<span class="hljs-title function_">generate</span>(
            inputs[<span class="hljs-string">"input_ids"</span>],
            attention_mask=inputs[<span class="hljs-string">"attention_mask"</span>],
            pad_token_id=self.<span class="hljs-property">tokenizer</span>.<span class="hljs-property">eos_token_id</span>,
            max_new_tokens=max_new_tokens,
            do_sample=<span class="hljs-title class_">True</span>,
            top_p=top_p,
            top_k=<span class="hljs-number">50</span>,
            temperature=temperature,
        )
        output = output[<span class="hljs-number">0</span>].<span class="hljs-title function_">to</span>(<span class="hljs-string">"cpu"</span>)
        response = self.<span class="hljs-property">tokenizer</span>.<span class="hljs-title function_">decode</span>(output[inputs[<span class="hljs-string">"input_ids"</span>].<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>] : -<span class="hljs-number">1</span>])
        self.<span class="hljs-title function_">append_to_history</span>(user_prompt, response)
        <span class="hljs-keyword">return</span> response
</code></pre>
<p>응답은 시스템 프롬프트와 사용자 프롬프트를 기반으로 합니다. 답변의 창의성은 top_p 및 temperature와 같은 매개변수에 따라 달라집니다.</p>
<div class="content-ad"></div>
<p>top_p를 사용하면 출력 토큰의 확률 값을 제한하여 너무 드물게 발생하는 토큰을 생성하는 것을 피할 수 있어요:</p>
<p>temperature를 사용하면 출력 토큰의 확률 분포를 평평하게 하거나 날카롭게 할 수 있어요:</p>
<p>프론트엔드 애플리케이션을 진행하기 전에 ChatModel을 테스트해보죠.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> <span class="hljs-title class_">ChatModel</span> <span class="hljs-keyword">import</span> *

model = <span class="hljs-title class_">ChatModel</span>()
response = model.<span class="hljs-title function_">generate</span>(
    user_prompt=<span class="hljs-string">"C++에서 hello world 프로그램을 작성해봐"</span>, 
    system_prompt=model.<span class="hljs-property">DEFAULT_SYSTEM_PROMPT</span>
)
<span class="hljs-title function_">print</span>(response)
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-js">당신이 요청한 작업은 완료되었습니다. 이제 테이블 태그가 <span class="hljs-title class_">Markdown</span> 형식으로 변경되었습니다.
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> streamlit <span class="hljs-keyword">as</span> st
<span class="hljs-keyword">from</span> <span class="hljs-title class_">ChatModel</span> <span class="hljs-keyword">import</span> *

st.<span class="hljs-title function_">title</span>(<span class="hljs-string">"Code Llama Assistant"</span>)


@st.<span class="hljs-property">cache_resource</span>
def <span class="hljs-title function_">load_model</span>():
    model = <span class="hljs-title class_">ChatModel</span>()
    <span class="hljs-keyword">return</span> model


model = <span class="hljs-title function_">load_model</span>()  # load our <span class="hljs-title class_">ChatModel</span> once and then cache it
</code></pre>
<p>다음으로 generate 함수를 위한 모델 매개변수를 입력 제어하는 사이드바를 생성합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">with</span> st.<span class="hljs-property">sidebar</span>:
    temperature = st.<span class="hljs-title function_">slider</span>(<span class="hljs-string">"온도"</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">0.1</span>)
    top_p = st.<span class="hljs-title function_">slider</span>(<span class="hljs-string">"top_p"</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.9</span>)
    max_new_tokens = st.<span class="hljs-title function_">number_input</span>(<span class="hljs-string">"max_new_tokens"</span>, <span class="hljs-number">128</span>, <span class="hljs-number">4096</span>, <span class="hljs-number">256</span>)
    system_prompt = st.<span class="hljs-title function_">text_area</span>(
        <span class="hljs-string">"시스템 프롬프트"</span>, value=model.<span class="hljs-property">DEFAULT_SYSTEM_PROMPT</span>, height=<span class="hljs-number">500</span>
    )
</code></pre>
<p>그리고 챗봇 메시지 인터페이스를 생성합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 채팅 기록 초기화
<span class="hljs-keyword">if</span> <span class="hljs-string">"messages"</span> not <span class="hljs-keyword">in</span> st.<span class="hljs-property">session_state</span>:
    st.<span class="hljs-property">session_state</span>.<span class="hljs-property">messages</span> = []

# 앱 재실행시 기록된 채팅 메시지 표시
<span class="hljs-keyword">for</span> message <span class="hljs-keyword">in</span> st.<span class="hljs-property">session_state</span>.<span class="hljs-property">messages</span>:
    <span class="hljs-keyword">with</span> st.<span class="hljs-title function_">chat_message</span>(message[<span class="hljs-string">"role"</span>]):
        st.<span class="hljs-title function_">markdown</span>(message[<span class="hljs-string">"content"</span>])

# 사용자 입력 받기
<span class="hljs-keyword">if</span> prompt := st.<span class="hljs-title function_">chat_input</span>(<span class="hljs-string">"무엇이든 물어보세요!"</span>):
    # 사용자 메시지를 채팅 기록에 추가
    st.<span class="hljs-property">session_state</span>.<span class="hljs-property">messages</span>.<span class="hljs-title function_">append</span>({<span class="hljs-string">"role"</span>: <span class="hljs-string">"user"</span>, <span class="hljs-string">"content"</span>: prompt})
    # 사용자 메시지를 채팅 메시지 컨테이너에 표시
    <span class="hljs-keyword">with</span> st.<span class="hljs-title function_">chat_message</span>(<span class="hljs-string">"user"</span>):
        st.<span class="hljs-title function_">markdown</span>(prompt)

    # 챗봇 응답을 채팅 메시지 컨테이너에 표시
    <span class="hljs-keyword">with</span> st.<span class="hljs-title function_">chat_message</span>(<span class="hljs-string">"assistant"</span>):
        user_prompt = st.<span class="hljs-property">session_state</span>.<span class="hljs-property">messages</span>[-<span class="hljs-number">1</span>][<span class="hljs-string">"content"</span>]
        answer = model.<span class="hljs-title function_">generate</span>(
            user_prompt,
            top_p=top_p,
            temperature=temperature,
            max_new_tokens=max_new_tokens,
            system_prompt=system_prompt,
        )
        response = st.<span class="hljs-title function_">write</span>(answer)
    st.<span class="hljs-property">session_state</span>.<span class="hljs-property">messages</span>.<span class="hljs-title function_">append</span>({<span class="hljs-string">"role"</span>: <span class="hljs-string">"assistant"</span>, <span class="hljs-string">"content"</span>: answer})
</code></pre>
<p>스트림릿 앱을 streamlit run app.py로 실행하여 브라우저가 열립니다.</p>
<p>이제 챗봇에 코딩 관련 질문을 할 수 있습니다.</p>
<h1>결론</h1>
<div class="content-ad"></div>
<p>저희는 Meta AI의 Code Llama LLM을 활용하여 AI 코딩 어시스턴트를 구현했어요. 그리고 Hugging Face의 transformer 라이브러리와 Streamlit을 사용해서 프론트엔드 애플리케이션을 만들었어요.</p>
<p>6GB의 GPU 메모리를 갖춘 노트북으로는 4비트 양자화된 Code Llama 모델을 7B 매개변수와 함께 사용할 수밖에 없었어요. 더 큰 GPU를 사용하면 16비트 버전이나 더 큰 모델이 더 잘 작동할 것입니다.</p>
<p>P.S. Code Llama로부터 제가 받은 농담보다 더 재미있는 농담들을 기대해봅니다 🤡.</p>
<p>더 많은 LLM에 관심이 있으시다면, 최근에 공개된 오픈소스 모델에 대한 개요를 확인해보세요:</p>
<div class="content-ad"></div>
<h1>참고 자료</h1>
<p>[1] B. Rozière 외: Code Llama: 코드를 위한 오픈 기반 모델 (2023), arXiv:2308.12950</p>
<h1>자원</h1>
<ul>
<li>Streamlit 채팅 앱 예제: 기본 LLM 채팅 앱 구축</li>
<li>Hugging Face Code Llama gradio 구현: codellama-13b-chat</li>
<li>이 문서의 전체 작업 코드: <a href="https://github.com/leoneversberg/codellama-chatbot" rel="nofollow" target="_blank">https://github.com/leoneversberg/codellama-chatbot</a></li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Code Llama로 나만의 LLM 코딩 어시스턴트 만드는 방법 ","description":"","date":"2024-06-22 21:36","slug":"2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama","content":"\n\n이 실습에서는 무료로 사용할 수 있고 로컬 GPU에서 실행되는 AI 코드 어시스턴트를 구현할 예정입니다.\n\n챗봇에 질문을 하면 자연어로 답변하며 여러 프로그래밍 언어로 코드도 제공합니다.\n\n우리는 Hugging Face transformer 라이브러리를 사용하여 LLM을 구현하고 Chatbot 프론트 엔드에는 Streamlit을 사용할 것입니다.\n\n# LLM이 텍스트를 생성하는 방법은 무엇인가요?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n디코더 전용 트랜스포머 모델인 GPT 계열은 주어진 입력 프롬프트에 대한 다음 단어를 예측하도록 훈련되었습니다. 이로 인해 텍스트 생성에 아주 능숙합니다.\n\n![이미지](/assets/img/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama_0.png)\n\n충분한 훈련 데이터가 제공된다면, 코드를 생성하는 것도 배울 수 있습니다. IDE에서 코드를 채우는 방식이나 챗봇으로 질문에 답변하는 방식으로 가능합니다.\n\nGitHub Copilot은 상용 예시로서 AI 페어 프로그래머의 한 예입니다. Meta AI의 Code Llama 모델은 유사한 능력을 갖추고 있지만 무료로 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 코드 람마란 무엇인가요?\n\n코드 람마는 Meta AI가 만들고 2023년 8월에 처음으로 출시한 코드 전용 LLM 계열의 특별한 제품입니다.\n\n![이미지](/assets/img/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama_1.png)\n\nMeta AI는 기본 모델 Llama 2(디코더 전용 Transformer 모델로 GPT-4와 유사함)을 시작으로, 대부분 코드로 이루어진 500B 토큰의 교육 데이터를 활용하여 추가 교육을 진행했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그 이후로 Code Llama에 대한 세 가지 버전이 네 가지 다른 크기로 제공됩니다.\n\nCode Llama 모델은 연구 및 상업적 사용을 위해 무료입니다.\n\n![이미지](/assets/img/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama_2.png)\n\n## Code Llama\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 Llama는 코드 생성을 위한 기반 모델입니다. 코드 Llama 모델은 infill 목적으로 훈련되어 IDE 내에서 코드 완성을 위해 설계되었습니다.\n\n## 코드 Llama — Instruct\n\nInstruct 버전은 인간의 질문에 답변하기 위해 지시 데이터셋에 맞춰 세밀하게 조정되었습니다. 이는 ChatGPT와 유사합니다.\n\n## 코드 Llama — Python\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n파이썬 버전은 추가 데이터셋인 100B 토큰의 파이썬 코드로 훈련되었습니다. 이 모델들은 코드 생성을 위해 의도되었습니다.\n\n# LLM 챗봇 코딩\n\n본 튜토리얼에서는 Instruct 버전 중 가장 작은 모델인 CodeLlama-7b-Instruct — hf를 사용할 것입니다. 이 모델은 자연어 질문에 답변하도록 세밀하게 튜닝되어 있기 때문에 챗봇으로 사용할 수 있습니다.\n\n가장 작은 모델조차도 여전히 7B 매개변수로 상당히 큽니다. 매개변수의 16비트 반정밀도를 사용하면, 모델은 약 14 GB의 GPU 메모리가 필요합니다. 4비트 양자화를 사용하면, 메모리 요구 사항을 약 3.5 GB 정도로 줄일 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 모델 구현하기\n\n우리는 먼저 Hugging Face에서 Code Llama 모델을 불러오고 주어진 프롬프트에 기반하여 텍스트를 생성할 ChatModel 클래스를 생성하는 것으로 시작하겠습니다.\n\n우리는 4비트 양자화를 위해 BitsAndBytesConfig를 사용하며, 모델을 로드하기 위해 AutoModelForCausalLM을 사용하고 입력 프롬프트로부터 토큰 임베딩을 생성하기 위해 AutoTokenizer를 사용합니다.\n\n```js\nimport torch\nfrom transformers import AutoTokenizer, AutoModelForCausalLM, BitsAndBytesConfig\n\nclass ChatModel:\n    def __init__(self, model=\"codellama/CodeLlama-7b-Instruct-hf\"):\n        quantization_config = BitsAndBytesConfig(\n            load_in_4bit=True, # 4비트 양자화 사용\n            bnb_4bit_compute_dtype=torch.float16,\n            bnb_4bit_use_double_quant=True,\n        )\n        self.model = AutoModelForCausalLM.from_pretrained(\n            model,\n            quantization_config=quantization_config,\n            device_map=\"cuda\",\n            cache_dir=\"./models\", # 모델을 models 폴더에 다운로드\n        )\n        self.tokenizer = AutoTokenizer.from_pretrained(\n            model, use_fast=True, padding_side=\"left\"\n        )\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n또한, 사용자의 이전 입력 프롬프트와 AI가 생성한 응답을 저장하는 고정 길이의 히스토리 목록을 만듭니다. 이는 대화의 기억을 제공하여 LLM에게 대화의 기억을 부여하는 데 유용합니다.\n\n```js\nself.history = []\nself.history_length = 1\n```\n\nCode Llama은 사용자 프롬프트 앞에 시스템 프롬프트를 사용합니다.\n\n기본적으로, codellama-13b-chat 예제에서 시스템 프롬프트를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nself.DEFAULT_SYSTEM_PROMPT = \"\"\"\\\n당신은 코드와 소프트웨어 디자인에 대한 깊은 지식을 가진, 도움이 되는, 예의 바르고 정직한 도우미입니다. 항상 도움이 될 수 있는 답변을 해야 하며, 안전하고 신중해야 합니다. 답변에 해로운, 부정한, 인종 차별적, 성 차별적, 유해한, 위험한, 또는 불법적인 내용을 포함해서는 안 됩니다. 답변이 사회적으로 편향되거나 부정적이여선 안됩니다.\\n\\n만약 질문이 이해할 수 없거나 사실적으로 일관성이 없다면, 올바른 대답 대신 왜 잘못된 것인지 설명하세요. 만약 질문에 대한 대답을 모르면, 가짜 정보를 공유하지 말고 대신 말해주세요.\\\n        \"\"\"\n```\n\n이제 self.history에 현재 대화를 추가하는 함수를 구현해봅시다.\n\nLLM(어라운드  모델)은 한정된 문맥 길이를 가지고 있기 때문에 메모리에 정보를 한정적으로 보관할 수밖에 없습니다. 여기서는 self.history_length = 1 개의 질문과 대답만 최대한 보관합니다.\n\n```js\n    def append_to_history(self, user_prompt, response):\n        self.history.append((user_prompt, response))\n        if len(self.history) \u003e self.history_length:\n            self.history.pop(0)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마침내 우리는 입력 프롬프트에 기반한 텍스트를 생성하는 generate 함수를 구현합니다.\n\n각 LLM에는 훈련에 사용된 특정 프롬프트 템플릿이 있습니다. Code Llama의 경우 codellama-13b-chat의 프롬프트 템플릿을 참조로 사용했습니다.\n\n```js\n    def generate(\n        self, user_prompt, system_prompt, top_p=0.9, temperature=0.1, max_new_tokens=512\n    ):\n\n        texts = [f\"\u003cs\u003e[INST] \u003c\u003cSYS\u003e\u003e\\n{system_prompt}\\n\u003c\u003c/SYS\u003e\u003e\\n\\n\"]\n        do_strip = False\n        for old_prompt, old_response in self.history:\n            old_prompt = old_prompt.strip() if do_strip else old_prompt\n            do_strip = True\n            texts.append(f\"{old_prompt} [/INST] {old_response.strip()} \u003c/s\u003e\u003cs\u003e[INST] \")\n        user_prompt = user_prompt.strip() if do_strip else user_prompt\n        texts.append(f\"{user_prompt} [/INST]\")\n        prompt = \"\".join(texts)\n\n        inputs = self.tokenizer(\n            prompt, return_tensors=\"pt\", add_special_tokens=False\n        ).to(\"cuda\")\n\n        output = self.model.generate(\n            inputs[\"input_ids\"],\n            attention_mask=inputs[\"attention_mask\"],\n            pad_token_id=self.tokenizer.eos_token_id,\n            max_new_tokens=max_new_tokens,\n            do_sample=True,\n            top_p=top_p,\n            top_k=50,\n            temperature=temperature,\n        )\n        output = output[0].to(\"cpu\")\n        response = self.tokenizer.decode(output[inputs[\"input_ids\"].shape[1] : -1])\n        self.append_to_history(user_prompt, response)\n        return response\n```\n\n응답은 시스템 프롬프트와 사용자 프롬프트를 기반으로 합니다. 답변의 창의성은 top_p 및 temperature와 같은 매개변수에 따라 달라집니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ntop_p를 사용하면 출력 토큰의 확률 값을 제한하여 너무 드물게 발생하는 토큰을 생성하는 것을 피할 수 있어요:\n\ntemperature를 사용하면 출력 토큰의 확률 분포를 평평하게 하거나 날카롭게 할 수 있어요:\n\n프론트엔드 애플리케이션을 진행하기 전에 ChatModel을 테스트해보죠.\n\n```js\nfrom ChatModel import *\n\nmodel = ChatModel()\nresponse = model.generate(\n    user_prompt=\"C++에서 hello world 프로그램을 작성해봐\", \n    system_prompt=model.DEFAULT_SYSTEM_PROMPT\n)\nprint(response)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n당신이 요청한 작업은 완료되었습니다. 이제 테이블 태그가 Markdown 형식으로 변경되었습니다.\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nimport streamlit as st\nfrom ChatModel import *\n\nst.title(\"Code Llama Assistant\")\n\n\n@st.cache_resource\ndef load_model():\n    model = ChatModel()\n    return model\n\n\nmodel = load_model()  # load our ChatModel once and then cache it\r\n```\n\n다음으로 generate 함수를 위한 모델 매개변수를 입력 제어하는 사이드바를 생성합니다.\n\n```js\r\nwith st.sidebar:\n    temperature = st.slider(\"온도\", 0.0, 2.0, 0.1)\n    top_p = st.slider(\"top_p\", 0.0, 1.0, 0.9)\n    max_new_tokens = st.number_input(\"max_new_tokens\", 128, 4096, 256)\n    system_prompt = st.text_area(\n        \"시스템 프롬프트\", value=model.DEFAULT_SYSTEM_PROMPT, height=500\n    )\r\n```\n\n그리고 챗봇 메시지 인터페이스를 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 채팅 기록 초기화\nif \"messages\" not in st.session_state:\n    st.session_state.messages = []\n\n# 앱 재실행시 기록된 채팅 메시지 표시\nfor message in st.session_state.messages:\n    with st.chat_message(message[\"role\"]):\n        st.markdown(message[\"content\"])\n\n# 사용자 입력 받기\nif prompt := st.chat_input(\"무엇이든 물어보세요!\"):\n    # 사용자 메시지를 채팅 기록에 추가\n    st.session_state.messages.append({\"role\": \"user\", \"content\": prompt})\n    # 사용자 메시지를 채팅 메시지 컨테이너에 표시\n    with st.chat_message(\"user\"):\n        st.markdown(prompt)\n\n    # 챗봇 응답을 채팅 메시지 컨테이너에 표시\n    with st.chat_message(\"assistant\"):\n        user_prompt = st.session_state.messages[-1][\"content\"]\n        answer = model.generate(\n            user_prompt,\n            top_p=top_p,\n            temperature=temperature,\n            max_new_tokens=max_new_tokens,\n            system_prompt=system_prompt,\n        )\n        response = st.write(answer)\n    st.session_state.messages.append({\"role\": \"assistant\", \"content\": answer})\r\n```\n\n스트림릿 앱을 streamlit run app.py로 실행하여 브라우저가 열립니다.\n\n이제 챗봇에 코딩 관련 질문을 할 수 있습니다.\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저희는 Meta AI의 Code Llama LLM을 활용하여 AI 코딩 어시스턴트를 구현했어요. 그리고 Hugging Face의 transformer 라이브러리와 Streamlit을 사용해서 프론트엔드 애플리케이션을 만들었어요.\n\n6GB의 GPU 메모리를 갖춘 노트북으로는 4비트 양자화된 Code Llama 모델을 7B 매개변수와 함께 사용할 수밖에 없었어요. 더 큰 GPU를 사용하면 16비트 버전이나 더 큰 모델이 더 잘 작동할 것입니다.\n\nP.S. Code Llama로부터 제가 받은 농담보다 더 재미있는 농담들을 기대해봅니다 🤡.\n\n더 많은 LLM에 관심이 있으시다면, 최근에 공개된 오픈소스 모델에 대한 개요를 확인해보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 참고 자료\n\n[1] B. Rozière 외: Code Llama: 코드를 위한 오픈 기반 모델 (2023), arXiv:2308.12950\n\n# 자원\n\n- Streamlit 채팅 앱 예제: 기본 LLM 채팅 앱 구축\n- Hugging Face Code Llama gradio 구현: codellama-13b-chat\n- 이 문서의 전체 작업 코드: [https://github.com/leoneversberg/codellama-chatbot](https://github.com/leoneversberg/codellama-chatbot)","ogImage":{"url":"/assets/img/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이 실습에서는 무료로 사용할 수 있고 로컬 GPU에서 실행되는 AI 코드 어시스턴트를 구현할 예정입니다.\u003c/p\u003e\n\u003cp\u003e챗봇에 질문을 하면 자연어로 답변하며 여러 프로그래밍 언어로 코드도 제공합니다.\u003c/p\u003e\n\u003cp\u003e우리는 Hugging Face transformer 라이브러리를 사용하여 LLM을 구현하고 Chatbot 프론트 엔드에는 Streamlit을 사용할 것입니다.\u003c/p\u003e\n\u003ch1\u003eLLM이 텍스트를 생성하는 방법은 무엇인가요?\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e디코더 전용 트랜스포머 모델인 GPT 계열은 주어진 입력 프롬프트에 대한 다음 단어를 예측하도록 훈련되었습니다. 이로 인해 텍스트 생성에 아주 능숙합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e충분한 훈련 데이터가 제공된다면, 코드를 생성하는 것도 배울 수 있습니다. IDE에서 코드를 채우는 방식이나 챗봇으로 질문에 답변하는 방식으로 가능합니다.\u003c/p\u003e\n\u003cp\u003eGitHub Copilot은 상용 예시로서 AI 페어 프로그래머의 한 예입니다. Meta AI의 Code Llama 모델은 유사한 능력을 갖추고 있지만 무료로 사용할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e코드 람마란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003e코드 람마는 Meta AI가 만들고 2023년 8월에 처음으로 출시한 코드 전용 LLM 계열의 특별한 제품입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eMeta AI는 기본 모델 Llama 2(디코더 전용 Transformer 모델로 GPT-4와 유사함)을 시작으로, 대부분 코드로 이루어진 500B 토큰의 교육 데이터를 활용하여 추가 교육을 진행했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그 이후로 Code Llama에 대한 세 가지 버전이 네 가지 다른 크기로 제공됩니다.\u003c/p\u003e\n\u003cp\u003eCode Llama 모델은 연구 및 상업적 사용을 위해 무료입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003eCode Llama\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e코드 Llama는 코드 생성을 위한 기반 모델입니다. 코드 Llama 모델은 infill 목적으로 훈련되어 IDE 내에서 코드 완성을 위해 설계되었습니다.\u003c/p\u003e\n\u003ch2\u003e코드 Llama — Instruct\u003c/h2\u003e\n\u003cp\u003eInstruct 버전은 인간의 질문에 답변하기 위해 지시 데이터셋에 맞춰 세밀하게 조정되었습니다. 이는 ChatGPT와 유사합니다.\u003c/p\u003e\n\u003ch2\u003e코드 Llama — Python\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e파이썬 버전은 추가 데이터셋인 100B 토큰의 파이썬 코드로 훈련되었습니다. 이 모델들은 코드 생성을 위해 의도되었습니다.\u003c/p\u003e\n\u003ch1\u003eLLM 챗봇 코딩\u003c/h1\u003e\n\u003cp\u003e본 튜토리얼에서는 Instruct 버전 중 가장 작은 모델인 CodeLlama-7b-Instruct — hf를 사용할 것입니다. 이 모델은 자연어 질문에 답변하도록 세밀하게 튜닝되어 있기 때문에 챗봇으로 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e가장 작은 모델조차도 여전히 7B 매개변수로 상당히 큽니다. 매개변수의 16비트 반정밀도를 사용하면, 모델은 약 14 GB의 GPU 메모리가 필요합니다. 4비트 양자화를 사용하면, 메모리 요구 사항을 약 3.5 GB 정도로 줄일 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e모델 구현하기\u003c/h2\u003e\n\u003cp\u003e우리는 먼저 Hugging Face에서 Code Llama 모델을 불러오고 주어진 프롬프트에 기반하여 텍스트를 생성할 ChatModel 클래스를 생성하는 것으로 시작하겠습니다.\u003c/p\u003e\n\u003cp\u003e우리는 4비트 양자화를 위해 BitsAndBytesConfig를 사용하며, 모델을 로드하기 위해 AutoModelForCausalLM을 사용하고 입력 프롬프트로부터 토큰 임베딩을 생성하기 위해 AutoTokenizer를 사용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e torch\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e transformers \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAutoTokenizer\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eAutoModelForCausalLM\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eBitsAndBytesConfig\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatModel\u003c/span\u003e:\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self, model=\u003cspan class=\"hljs-string\"\u003e\"codellama/CodeLlama-7b-Instruct-hf\"\u003c/span\u003e):\n        quantization_config = \u003cspan class=\"hljs-title class_\"\u003eBitsAndBytesConfig\u003c/span\u003e(\n            load_in_4bit=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, # \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e비트 양자화 사용\n            bnb_4bit_compute_dtype=torch.\u003cspan class=\"hljs-property\"\u003efloat16\u003c/span\u003e,\n            bnb_4bit_use_double_quant=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e,\n        )\n        self.\u003cspan class=\"hljs-property\"\u003emodel\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eAutoModelForCausalLM\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_pretrained\u003c/span\u003e(\n            model,\n            quantization_config=quantization_config,\n            device_map=\u003cspan class=\"hljs-string\"\u003e\"cuda\"\u003c/span\u003e,\n            cache_dir=\u003cspan class=\"hljs-string\"\u003e\"./models\"\u003c/span\u003e, # 모델을 models 폴더에 다운로드\n        )\n        self.\u003cspan class=\"hljs-property\"\u003etokenizer\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eAutoTokenizer\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_pretrained\u003c/span\u003e(\n            model, use_fast=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, padding_side=\u003cspan class=\"hljs-string\"\u003e\"left\"\u003c/span\u003e\n        )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e또한, 사용자의 이전 입력 프롬프트와 AI가 생성한 응답을 저장하는 고정 길이의 히스토리 목록을 만듭니다. 이는 대화의 기억을 제공하여 LLM에게 대화의 기억을 부여하는 데 유용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eself.\u003cspan class=\"hljs-property\"\u003ehistory\u003c/span\u003e = []\nself.\u003cspan class=\"hljs-property\"\u003ehistory_length\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCode Llama은 사용자 프롬프트 앞에 시스템 프롬프트를 사용합니다.\u003c/p\u003e\n\u003cp\u003e기본적으로, codellama-13b-chat 예제에서 시스템 프롬프트를 사용할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eself.\u003cspan class=\"hljs-property\"\u003eDEFAULT_SYSTEM_PROMPT\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\\\n당신은 코드와 소프트웨어 디자인에 대한 깊은 지식을 가진, 도움이 되는, 예의 바르고 정직한 도우미입니다. 항상 도움이 될 수 있는 답변을 해야 하며, 안전하고 신중해야 합니다. 답변에 해로운, 부정한, 인종 차별적, 성 차별적, 유해한, 위험한, 또는 불법적인 내용을 포함해서는 안 됩니다. 답변이 사회적으로 편향되거나 부정적이여선 안됩니다.\\n\\n만약 질문이 이해할 수 없거나 사실적으로 일관성이 없다면, 올바른 대답 대신 왜 잘못된 것인지 설명하세요. 만약 질문에 대한 대답을 모르면, 가짜 정보를 공유하지 말고 대신 말해주세요.\\\n        \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 self.history에 현재 대화를 추가하는 함수를 구현해봅시다.\u003c/p\u003e\n\u003cp\u003eLLM(어라운드  모델)은 한정된 문맥 길이를 가지고 있기 때문에 메모리에 정보를 한정적으로 보관할 수밖에 없습니다. 여기서는 self.history_length = 1 개의 질문과 대답만 최대한 보관합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    def \u003cspan class=\"hljs-title function_\"\u003eappend_to_history\u003c/span\u003e(self, user_prompt, response):\n        self.\u003cspan class=\"hljs-property\"\u003ehistory\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e((user_prompt, response))\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(self.\u003cspan class=\"hljs-property\"\u003ehistory\u003c/span\u003e) \u003e self.\u003cspan class=\"hljs-property\"\u003ehistory_length\u003c/span\u003e:\n            self.\u003cspan class=\"hljs-property\"\u003ehistory\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003epop\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e마침내 우리는 입력 프롬프트에 기반한 텍스트를 생성하는 generate 함수를 구현합니다.\u003c/p\u003e\n\u003cp\u003e각 LLM에는 훈련에 사용된 특정 프롬프트 템플릿이 있습니다. Code Llama의 경우 codellama-13b-chat의 프롬프트 템플릿을 참조로 사용했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    def \u003cspan class=\"hljs-title function_\"\u003egenerate\u003c/span\u003e(\n        self, user_prompt, system_prompt, top_p=\u003cspan class=\"hljs-number\"\u003e0.9\u003c/span\u003e, temperature=\u003cspan class=\"hljs-number\"\u003e0.1\u003c/span\u003e, max_new_tokens=\u003cspan class=\"hljs-number\"\u003e512\u003c/span\u003e\n    ):\n\n        texts = [f\u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;s\u003e[INST] \u0026#x3C;\u0026#x3C;SYS\u003e\u003e\\n{system_prompt}\\n\u0026#x3C;\u0026#x3C;/SYS\u003e\u003e\\n\\n\"\u003c/span\u003e]\n        do_strip = \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e old_prompt, old_response \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e self.\u003cspan class=\"hljs-property\"\u003ehistory\u003c/span\u003e:\n            old_prompt = old_prompt.\u003cspan class=\"hljs-title function_\"\u003estrip\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e do_strip \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e old_prompt\n            do_strip = \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n            texts.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{old_prompt} [/INST] {old_response.strip()} \u0026#x3C;/s\u003e\u0026#x3C;s\u003e[INST] \"\u003c/span\u003e)\n        user_prompt = user_prompt.\u003cspan class=\"hljs-title function_\"\u003estrip\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e do_strip \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e user_prompt\n        texts.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{user_prompt} [/INST]\"\u003c/span\u003e)\n        prompt = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(texts)\n\n        inputs = self.\u003cspan class=\"hljs-title function_\"\u003etokenizer\u003c/span\u003e(\n            prompt, return_tensors=\u003cspan class=\"hljs-string\"\u003e\"pt\"\u003c/span\u003e, add_special_tokens=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n        ).\u003cspan class=\"hljs-title function_\"\u003eto\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"cuda\"\u003c/span\u003e)\n\n        output = self.\u003cspan class=\"hljs-property\"\u003emodel\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egenerate\u003c/span\u003e(\n            inputs[\u003cspan class=\"hljs-string\"\u003e\"input_ids\"\u003c/span\u003e],\n            attention_mask=inputs[\u003cspan class=\"hljs-string\"\u003e\"attention_mask\"\u003c/span\u003e],\n            pad_token_id=self.\u003cspan class=\"hljs-property\"\u003etokenizer\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eeos_token_id\u003c/span\u003e,\n            max_new_tokens=max_new_tokens,\n            do_sample=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e,\n            top_p=top_p,\n            top_k=\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e,\n            temperature=temperature,\n        )\n        output = output[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eto\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"cpu\"\u003c/span\u003e)\n        response = self.\u003cspan class=\"hljs-property\"\u003etokenizer\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003edecode\u003c/span\u003e(output[inputs[\u003cspan class=\"hljs-string\"\u003e\"input_ids\"\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] : -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\n        self.\u003cspan class=\"hljs-title function_\"\u003eappend_to_history\u003c/span\u003e(user_prompt, response)\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e응답은 시스템 프롬프트와 사용자 프롬프트를 기반으로 합니다. 답변의 창의성은 top_p 및 temperature와 같은 매개변수에 따라 달라집니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003etop_p를 사용하면 출력 토큰의 확률 값을 제한하여 너무 드물게 발생하는 토큰을 생성하는 것을 피할 수 있어요:\u003c/p\u003e\n\u003cp\u003etemperature를 사용하면 출력 토큰의 확률 분포를 평평하게 하거나 날카롭게 할 수 있어요:\u003c/p\u003e\n\u003cp\u003e프론트엔드 애플리케이션을 진행하기 전에 ChatModel을 테스트해보죠.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatModel\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e *\n\nmodel = \u003cspan class=\"hljs-title class_\"\u003eChatModel\u003c/span\u003e()\nresponse = model.\u003cspan class=\"hljs-title function_\"\u003egenerate\u003c/span\u003e(\n    user_prompt=\u003cspan class=\"hljs-string\"\u003e\"C++에서 hello world 프로그램을 작성해봐\"\u003c/span\u003e, \n    system_prompt=model.\u003cspan class=\"hljs-property\"\u003eDEFAULT_SYSTEM_PROMPT\u003c/span\u003e\n)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(response)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e당신이 요청한 작업은 완료되었습니다. 이제 테이블 태그가 \u003cspan class=\"hljs-title class_\"\u003eMarkdown\u003c/span\u003e 형식으로 변경되었습니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e streamlit \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e st\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eChatModel\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e *\n\nst.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Code Llama Assistant\"\u003c/span\u003e)\n\n\n@st.\u003cspan class=\"hljs-property\"\u003ecache_resource\u003c/span\u003e\ndef \u003cspan class=\"hljs-title function_\"\u003eload_model\u003c/span\u003e():\n    model = \u003cspan class=\"hljs-title class_\"\u003eChatModel\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e model\n\n\nmodel = \u003cspan class=\"hljs-title function_\"\u003eload_model\u003c/span\u003e()  # load our \u003cspan class=\"hljs-title class_\"\u003eChatModel\u003c/span\u003e once and then cache it\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 generate 함수를 위한 모델 매개변수를 입력 제어하는 사이드바를 생성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e st.\u003cspan class=\"hljs-property\"\u003esidebar\u003c/span\u003e:\n    temperature = st.\u003cspan class=\"hljs-title function_\"\u003eslider\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"온도\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.1\u003c/span\u003e)\n    top_p = st.\u003cspan class=\"hljs-title function_\"\u003eslider\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"top_p\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.9\u003c/span\u003e)\n    max_new_tokens = st.\u003cspan class=\"hljs-title function_\"\u003enumber_input\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"max_new_tokens\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e128\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4096\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e256\u003c/span\u003e)\n    system_prompt = st.\u003cspan class=\"hljs-title function_\"\u003etext_area\u003c/span\u003e(\n        \u003cspan class=\"hljs-string\"\u003e\"시스템 프롬프트\"\u003c/span\u003e, value=model.\u003cspan class=\"hljs-property\"\u003eDEFAULT_SYSTEM_PROMPT\u003c/span\u003e, height=\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e\n    )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그리고 챗봇 메시지 인터페이스를 생성합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 채팅 기록 초기화\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"messages\"\u003c/span\u003e not \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e:\n    st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessages\u003c/span\u003e = []\n\n# 앱 재실행시 기록된 채팅 메시지 표시\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e message \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessages\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e st.\u003cspan class=\"hljs-title function_\"\u003echat_message\u003c/span\u003e(message[\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e]):\n        st.\u003cspan class=\"hljs-title function_\"\u003emarkdown\u003c/span\u003e(message[\u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e])\n\n# 사용자 입력 받기\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e prompt := st.\u003cspan class=\"hljs-title function_\"\u003echat_input\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"무엇이든 물어보세요!\"\u003c/span\u003e):\n    # 사용자 메시지를 채팅 기록에 추가\n    st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessages\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: prompt})\n    # 사용자 메시지를 채팅 메시지 컨테이너에 표시\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e st.\u003cspan class=\"hljs-title function_\"\u003echat_message\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"user\"\u003c/span\u003e):\n        st.\u003cspan class=\"hljs-title function_\"\u003emarkdown\u003c/span\u003e(prompt)\n\n    # 챗봇 응답을 채팅 메시지 컨테이너에 표시\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e st.\u003cspan class=\"hljs-title function_\"\u003echat_message\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"assistant\"\u003c/span\u003e):\n        user_prompt = st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessages\u003c/span\u003e[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e]\n        answer = model.\u003cspan class=\"hljs-title function_\"\u003egenerate\u003c/span\u003e(\n            user_prompt,\n            top_p=top_p,\n            temperature=temperature,\n            max_new_tokens=max_new_tokens,\n            system_prompt=system_prompt,\n        )\n        response = st.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(answer)\n    st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessages\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"role\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"assistant\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"content\"\u003c/span\u003e: answer})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e스트림릿 앱을 streamlit run app.py로 실행하여 브라우저가 열립니다.\u003c/p\u003e\n\u003cp\u003e이제 챗봇에 코딩 관련 질문을 할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저희는 Meta AI의 Code Llama LLM을 활용하여 AI 코딩 어시스턴트를 구현했어요. 그리고 Hugging Face의 transformer 라이브러리와 Streamlit을 사용해서 프론트엔드 애플리케이션을 만들었어요.\u003c/p\u003e\n\u003cp\u003e6GB의 GPU 메모리를 갖춘 노트북으로는 4비트 양자화된 Code Llama 모델을 7B 매개변수와 함께 사용할 수밖에 없었어요. 더 큰 GPU를 사용하면 16비트 버전이나 더 큰 모델이 더 잘 작동할 것입니다.\u003c/p\u003e\n\u003cp\u003eP.S. Code Llama로부터 제가 받은 농담보다 더 재미있는 농담들을 기대해봅니다 🤡.\u003c/p\u003e\n\u003cp\u003e더 많은 LLM에 관심이 있으시다면, 최근에 공개된 오픈소스 모델에 대한 개요를 확인해보세요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e참고 자료\u003c/h1\u003e\n\u003cp\u003e[1] B. Rozière 외: Code Llama: 코드를 위한 오픈 기반 모델 (2023), arXiv:2308.12950\u003c/p\u003e\n\u003ch1\u003e자원\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eStreamlit 채팅 앱 예제: 기본 LLM 채팅 앱 구축\u003c/li\u003e\n\u003cli\u003eHugging Face Code Llama gradio 구현: codellama-13b-chat\u003c/li\u003e\n\u003cli\u003e이 문서의 전체 작업 코드: \u003ca href=\"https://github.com/leoneversberg/codellama-chatbot\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/leoneversberg/codellama-chatbot\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-HowtoBuildYourOwnLLMCodingAssistantWithCodeLlama"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>