<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>확장된 SQL 쿼리들, 꼭 알아야 할 사항들 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-AdvancedSQLQueriesyoumustknow" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="확장된 SQL 쿼리들, 꼭 알아야 할 사항들 | itposting" data-gatsby-head="true"/><meta property="og:title" content="확장된 SQL 쿼리들, 꼭 알아야 할 사항들 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-AdvancedSQLQueriesyoumustknow_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-AdvancedSQLQueriesyoumustknow" data-gatsby-head="true"/><meta name="twitter:title" content="확장된 SQL 쿼리들, 꼭 알아야 할 사항들 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-AdvancedSQLQueriesyoumustknow_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 01:50" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_buildManifest.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">확장된 SQL 쿼리들, 꼭 알아야 할 사항들</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="확장된 SQL 쿼리들, 꼭 알아야 할 사항들" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">9<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-AdvancedSQLQueriesyoumustknow&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>데이터 분석 및 데이터 엔지니어링을 위한 최고의 15가지 고급 SQL 명령어!</p>
<p><img src="/assets/img/2024-06-19-AdvancedSQLQueriesyoumustknow_0.png" alt="이미지"></p>
<p>이미 데이터 분석에 익숙한 분이라면 SELECT, INSERT, UPDATE, DELETE 등과 같은 기본 명령어를 이미 알고 있을 것입니다. 가장 많이 사용되는 명령어라면서도 데이터를 깊이 파고들기 위해 아래 쿼리도 알아두는 것이 좋습니다.</p>
<h1>1. 윈도우 함수</h1>
<div class="content-ad"></div>
<p>윈도우 함수는 현재 행과 관련된 일련의 행을 대상으로 계산에 사용됩니다. 예를 들어, SUM() 함수와 OVER() 절을 사용하여 매출의 누적 합계를 계산하는 예제를 살펴보겠습니다. 'Sales_Data'라는 매출 데이터 테이블을 가정해보겠습니다. 이 테이블은 여러 날짜에 걸친 매출 금액을 기록합니다. 각 날짜별 매출의 누적 합계를 계산하고자 합니다. 즉, 각 날짜까지의 총 매출액을 나타냅니다.</p>
<p>이 쿼리는 시간이 지남에 따른 매출의 누적 합계를 제공하여 누적 매출 성장을 추적하기 쉽게 합니다.</p>
<p>결과:</p>
<p>date | sales | running_total
2023-01-01 | 100 | 100
2023-01-02 | 150 | 250
2023-01-03 | 200 | 450
2023-01-04 | 250 | 700</p>
<div class="content-ad"></div>
<p>윈도우 함수는 단일 행 그룹으로 결과 집합을 축소시키지 않고 실행 합계, 이동 평균, 순위 등 다양한 작업에 사용할 수 있어요.</p>
<h1>2. 공통 테이블 표현식 (CTE)</h1>
<p>공통 테이블 표현식은 쿼리 내에서 참조할 수 있는 임시 결과 집합을 만드는 방법을 제공해요. 이것은 가독성을 향상시키고 복잡한 쿼리를 간단하게 만들어줘요. 다음은 각 제품 카테고리별 총 매출을 계산하기 위해 CTE를 사용하는 방법이에요.</p>
<p>이 쿼리는 'category_revenue'라는 CTE를 정의해요. 이는 매출 테이블에서 수익을 합산하고 카테고리 열을 기준으로 결과를 그룹화하여 각 카테고리별 총 수익을 계산해요. 메인 쿼리는 'category_revenue' CTE에서 모든 열을 선택하여 각 카테고리의 계산된 총 수익을 효과적으로 표시해요.</p>
<div class="content-ad"></div>
<p>출력:</p>
<p>category | total_revenue</p>
<p>A | 5000</p>
<p>B | 7000</p>
<div class="content-ad"></div>
<p>C|4500</p>
<h1>3. Recursive Queries</h1>
<p>Recursive queries enable travel of hierarchical data structures like organisational charts or bill of materials. Suppose we have a table representing employee relationships, and we want to find all the subordinates of a given manager.</p>
<p>This recursive CTE finds all employees who report directly or indirectly to a specific manager ‘manager_id_of_interest’. It starts with employees directly reporting to the manager and then recursively finds their subordinates, building the hierarchy.</p>
<div class="content-ad"></div>




















<table><thead><tr><th align="left">employee_id</th><th align="left">name</th><th align="left">manager_id</th></tr></thead><tbody><tr><td align="left">2</td><td align="left">Alice</td><td align="left">manager_id_of_interest</td></tr><tr><td align="left">3</td><td align="left">Bob</td><td align="left">2</td></tr></tbody></table>
<div class="content-ad"></div>
<p>4|Charlie |3</p>
<h1>4. Pivot Tables</h1>
<p>피벗 테이블은 행을 열로 변환하여 데이터를 요약해 주는 표 형식을 제공합니다. 예를 들어, 판매 데이터가 포함된 테이블이 있고, 각 제품의 월별 총 판매액을 표시하기 위해 데이터를 피벗하려고 한다고 가정해 봅시다.</p>
<p>이 쿼리는 조건부 집계를 사용하여 각 제품의 월별 판매 데이터를 집계합니다. 각 제품의 1월, 2월, 3월 판매액을 따로 합산하여, 이러한 월에 대한 각 제품의 총 판매액을 보여주는 테이블을 만듭니다.</p>
<div class="content-ad"></div>
<p>다음은 Markdown 형식으로 테이블을 나타낸 내용입니다:</p>





























<table><thead><tr><th>product</th><th>Jan</th><th>Feb</th><th>Mar</th></tr></thead><tbody><tr><td>Product A</td><td>100</td><td>200</td><td>150</td></tr><tr><td>Product B</td><td>80</td><td>190</td><td>220</td></tr><tr><td>Product C</td><td>60</td><td>140</td><td>130</td></tr></tbody></table>
<h1>5. 분석 함수</h1>
<p>분석 함수는 행 그룹을 기반으로 집계 값을 계산합니다. 예를 들어, ROW_NUMBER( ) 함수를 사용하여 데이터셋의 각 레코드에 고유한 행 번호를 할당할 수 있습니다.</p>
<div class="content-ad"></div>
<p>이 쿼리는 ROW_NUMBER() 윈도우 함수를 사용하여 주문 날짜를 기준으로 각 고객당 주문에 고유한 순위를 할당합니다. 결과는 각 고객이 배치한 주문의 순서를 보여줍니다.</p>
<p>출력:</p>



































<table><thead><tr><th>customer_id</th><th>order_id</th><th>order_rank</th></tr></thead><tbody><tr><td>1</td><td>101</td><td>1</td></tr><tr><td>1</td><td>102</td><td>2</td></tr><tr><td>2</td><td>201</td><td>1</td></tr><tr><td>2</td><td>202</td><td>2</td></tr><tr><td>2</td><td>203</td><td>3</td></tr></tbody></table>
<h1>6. Unpivot</h1>
<div class="content-ad"></div>
<p>언피벗은 열을 행으로 변환하는 피벗의 반대 작업입니다. 월별로 집계된 매출 데이터가 있는 테이블이 있다고 가정해봅시다. 시간에 따른 트렌드를 분석하기 위해 이를 언피벗하려고 합니다.</p>
<p>다음 쿼리는 매출 열을 행으로 변환하여 제품별 시간에 따른 트렌드를 분석하기 쉽게 만듭니다. 각 행은 특정 월에 대한 제품의 매출을 나타냅니다.</p>
<p>결과:</p>
<p>product | month | sales
ProductA | Jan | 100
ProductA | Feb | 150
ProductA | Mar | 200
ProductB | Jan | 200
ProductB | Feb | 250
ProductB | Mar | 300</p>
<div class="content-ad"></div>
<h1>7. 조건부 집계</h1>
<p>조건부 집계는 지정된 기준에 따라 조건부로 집계 함수를 적용하는 것을 말합니다. 예를 들어, 반복 고객이 주문한 주문에 대해서만 평균 판매 금액을 계산하고 싶을 수 있습니다.</p>
<p>다음 쿼리는 두 개 이상의 주문을 한 고객들의 평균 주문 총액을 계산합니다. 각 고객에 대해 주문 수와 총 주문 금액을 집계한 후, 반복 고객들에 대한 평균을 계산합니다.</p>
<p>출력:</p>
<div class="content-ad"></div>
<p>customer_id | avg_sales_repeat_customers
1 | 250
2 | 150
3 | 300</p>
<h2>8. 날짜 함수</h2>
<p>SQL에서의 날짜 함수는 날짜와 관련된 정보를 조작하고 추출할 수 있게 해줍니다. 예를 들어 DATE_TRUNC() 함수를 사용하여 매출 데이터를 월별로 그룹화할 수 있습니다.</p>
<p>이 출력은 매출이 total_sales로 집계된 각 월을 month으로 나타내며, 각 월은 해당 월의 첫 번째 날로 표시됩니다 (예: 1월의 경우 2023-01-01). 각 해당 월의 총 매출액이 합산되어 표시됩니다.</p>
<div class="content-ad"></div>
<p>출력:</p>

























<table><thead><tr><th>month</th><th>total_sales</th></tr></thead><tbody><tr><td>2023-01-01</td><td>15000</td></tr><tr><td>2023-02-01</td><td>20000</td></tr><tr><td>2023-03-01</td><td>17500</td></tr><tr><td>2023-04-01</td><td>22000</td></tr></tbody></table>
<h2>9. 병합문</h2>
<p>병합문(UPSERT 또는 ON DUPLICATE KEY UPDATE로도 알려져 있음)은 소스 테이블과의 조인 결과를 기반으로 대상 테이블에 레코드를 삽입, 업데이트 또는 삭제할 수 있게 합니다. 고객 데이터를 포함하는 두 테이블을 동기화하고 싶다고 가정해 봅시다.</p>
<div class="content-ad"></div>
<p>customers_target (before merge):</p>




















<table><thead><tr><th>customer_id</th><th>name</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>John Doe</td><td><a href="mailto:john@example.com">john@example.com</a></td></tr><tr><td>2</td><td>Jane Smith</td><td><a href="mailto:jane@example.com">jane@example.com</a></td></tr></tbody></table>
<div class="content-ad"></div>
<p>테이블 태그를 Markdown 형식으로 변경해보면 다음과 같습니다.</p>

























<table><thead><tr><th>customer_id</th><th>name</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>John Doe</td><td><a href="mailto:john@example.com">john@example.com</a></td></tr><tr><td>2</td><td>Jane Johnson</td><td><a href="mailto:jane.j@example.com">jane.j@example.com</a></td></tr><tr><td>3</td><td>Alice Brown</td><td><a href="mailto:alice@example.com">alice@example.com</a></td></tr></tbody></table>
<div class="content-ad"></div>
<p>MERGE 문은 customers_source 테이블을 기반으로 customers_target 테이블을 업데이트합니다. customers_source의 customer_id가 customers_target에서와 일치하는 경우, 이름과 이메일이 업데이트됩니다. 일치하는 항목이 없는 경우 새로운 행이 삽입됩니다.</p>
<h2>10. Case 문</h2>
<p>Case 문을 사용하면 SQL 쿼리 내에서 조건부 논리를 구현할 수 있습니다. 예를 들어, 총 구매 금액에 기초하여 고객을 분류하는 Case 문을 사용할 수 있습니다.</p>
<p>예제 데이터 세트를 고려하고 출력을 설명해보겠습니다.</p>
<div class="content-ad"></div>
<p>orders 테이블에서의 예시 데이터:</p>
<p>customer_id | order_total
1 | 200
1 | 300
2 | 800
3 | 150
3 | 400
4 | 1200</p>
<p>결과:</p>
<p>customer_id | customer_category
1 | Gold
2 | Gold
3 | Silver
4 | Platinum</p>
<div class="content-ad"></div>
<p>쿼리는 고객의 총 구매 금액을 기준으로 고객을 카테고리로 분류합니다. 총 구매 금액이 $1000 이상인 경우 '플래티넘'으로 레이블을 지정하고, $500에서 $999 사이인 경우 '골드'로 레이블을 지정하며, $500 미만인 경우 '실버'로 레이블을 지정합니다.</p>
<h1>11. 문자열 함수</h1>
<p>SQL에서의 문자열 함수는 텍스트 데이터를 조작하는 데 사용됩니다. 예를 들어 CONCAT( ) 함수를 사용하면 이름과 성을 연결할 수 있습니다.</p>
<p>예시 데이터 세트를 고려하고 출력을 설명해 보겠습니다.</p>
<div class="content-ad"></div>
<p>예시 데이터인 직원 테이블:</p>

























<table><thead><tr><th>이름</th><th>성</th></tr></thead><tbody><tr><td>John</td><td>Doe</td></tr><tr><td>Jane</td><td>Smith</td></tr><tr><td>Alice</td><td>Johnson</td></tr><tr><td>Bob</td><td>Brown</td></tr></tbody></table>
<p>결과:</p>




















<table><thead><tr><th>전체 이름</th></tr></thead><tbody><tr><td>John Doe</td></tr><tr><td>Jane Smith</td></tr><tr><td>Alice Johnson</td></tr><tr><td>Bob Brown</td></tr></tbody></table>
<div class="content-ad"></div>
<p>질문은 employees 테이블에서 first_name 및 last_name 열을 연결하여 각 직원의 full_name을 만드는 것입니다.</p>
<h2>12. 그룹 세트</h2>
<p>그룹 세트를 사용하면 하나의 쿼리에서 여러 수준의 세분화 데이터를 집계할 수 있습니다. 우리가 매월 그리고 연도별로 총 판매 수익을 계산하고 싶다고 가정해 봅시다.</p>
<p>예시 데이터는 sales 테이블에 있습니다:</p>
<div class="content-ad"></div>
<p>주문 날짜 | 매출액
2023–01–15 | 1000
2023–01–20 | 1500
2023–02–10 | 2000
2023–03–05 | 2500
2024–01–10 | 3000
2024–01–20 | 3500
2024–02–25 | 4000</p>
<p>결과:</p>
<p>년도 | 월 | 총 매출
2023 | 1 | 2500
2023 | 2 | 2000
2023 | 3 | 2500
2024 | 1 | 6500
2024 | 2 | 4000
2023 | NULL | 7000
2024 | NULL | 10500
NULL | 1 | 9000
NULL | 2 | 6000
NULL | 3 | 2500</p>
<p>그 쿼리는 GROUPING SETS를 사용하여 매출 데이터를 연도별 및 월별, 연도만, 월만으로 그룹화합니다. 결과적으로 각 연도의 각 월별 소계, 각 연도의 총합, 모든 연도를 통틀어 각 월의 총합이 나타납니다.</p>
<div class="content-ad"></div>
<h1>13. Cross Joins</h1>
<p>Cross joins은 두 개의 테이블의 데카르트 곱을 생성하여 각 테이블의 모든 행을 결합한 조합을 생성합니다. 예를 들어, 교차 조인을 사용하여 제품과 고객의 모든 가능한 조합을 생성할 수 있습니다.</p>
<p>제품 및 고객 테이블을 위한 예제 데이터 세트를 살펴봅시다.</p>
<p>제품 테이블:</p>
<div class="content-ad"></div>

















<table><thead><tr><th>product_id</th><th>product_name</th></tr></thead><tbody><tr><td>1</td><td>Product A</td></tr><tr><td>2</td><td>Product B</td></tr></tbody></table>
<p>customers table:</p>

















<table><thead><tr><th>customer_id</th><th>customer_name</th></tr></thead><tbody><tr><td>101</td><td>Customer X</td></tr><tr><td>102</td><td>Customer Y</td></tr></tbody></table>
<p>Output:</p>
<div class="content-ad"></div>
<p>product_id | product_name | customer_id | customer_name
1 | Product A | 101 | Customer X
1 | Product A | 102 | Customer Y
2 | Product B | 101 | Customer X
2 | Product B | 102 | Customer Y</p>
<p>해당 쿼리는 PRODUCTS와 CUSTOMERS 테이블 사이에 CROSS JOIN을 수행하여 카테시안 곱을 생성합니다. 이는 모든 제품이 모든 고객과 쌍을 이루어 모든 제품과 고객의 가능한 조합을 생성하는 것을 의미합니다.</p>
<h2>14. 인라인 뷰</h2>
<p>인라인 뷰(파생 테이블로도 알려짐)는 SQL 쿼리 내에서 임시 결과 집합을 만드는 데 사용됩니다. 예를 들어, 우리가 주문 평균 가치를 초과하는 구매를 한 고객을 찾고 싶다면 인라인 뷰를 사용할 수 있습니다.</p>
<div class="content-ad"></div>
<p>주문 테이블:</p>
<p>customer_id | order_total
1 | 100
1 | 200
2 | 500
3 | 300
3 | 200
4 | 700</p>
<p>각 고객별 총 주문을 계산합니다:</p>
<p>customer_id | order_total
1 | 300
2 | 500
3 | 500
4 | 700</p>
<div class="content-ad"></div>
<p>표를 마크다운 형식으로 변경하세요.</p>





















<table><thead><tr><th>customer_id</th><th>order_total</th></tr></thead><tbody><tr><td>2</td><td>500</td></tr><tr><td>3</td><td>500</td></tr><tr><td>4</td><td>700</td></tr></tbody></table>
<div class="content-ad"></div>
<h1>15. 집합 연산자</h1>
<p>UNION, INTERSECT 및 EXCEPT와 같은 집합 연산자를 사용하여 두 개 이상의 쿼리 결과를 결합할 수 있습니다. 예를 들어, 우리는 UNION 연산자를 사용하여 두 개의 쿼리 결과를 하나의 결과 세트로 병합할 수 있습니다.</p>
<p>이 쿼리는 제품 및 보관된 제품 테이블에서 결과를 결합하여 중복 항목을 제거하여 제품 ID 및 이름의 통합 목록을 만듭니다. UNION 연산자는 각 제품이 최종 출력에서 한 번만 나타나도록 합니다.</p>
<p>결과:</p>
<div class="content-ad"></div>
<p>product_id | product_name
1 | Chocolate Bar
2 | Dark Chocolate
3 | Milk Chocolate
4 | White Chocolate
5 | Almond Chocolate</p>
<p>이 15가지의 고급 SQL 기술을 사용하여 복잡한 데이터 문제를 쉽고 정확하게 해결할 수 있습니다. 데이터 분석가, 엔지니어, 혹은 과학자라면 SQL 기술을 향상시킴으로써 데이터 처리 역량을 크게 향상시킬 수 있습니다.</p>
<p>이 게시물이 유용했다면, 반드시 클랩(clap), 댓글(comment), 구독(subscribe) 및 팔로우(follow)하여 미디엄(medium.com)에서 더 많은 데이터 관련 콘텐츠를 접해보세요.</p>
<p>즐거운 데이터 분석 되세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"확장된 SQL 쿼리들, 꼭 알아야 할 사항들","description":"","date":"2024-06-19 01:50","slug":"2024-06-19-AdvancedSQLQueriesyoumustknow","content":"\n\n데이터 분석 및 데이터 엔지니어링을 위한 최고의 15가지 고급 SQL 명령어!\n\n![이미지](/assets/img/2024-06-19-AdvancedSQLQueriesyoumustknow_0.png)\n\n이미 데이터 분석에 익숙한 분이라면 SELECT, INSERT, UPDATE, DELETE 등과 같은 기본 명령어를 이미 알고 있을 것입니다. 가장 많이 사용되는 명령어라면서도 데이터를 깊이 파고들기 위해 아래 쿼리도 알아두는 것이 좋습니다.\n\n# 1. 윈도우 함수\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n윈도우 함수는 현재 행과 관련된 일련의 행을 대상으로 계산에 사용됩니다. 예를 들어, SUM() 함수와 OVER() 절을 사용하여 매출의 누적 합계를 계산하는 예제를 살펴보겠습니다. 'Sales_Data'라는 매출 데이터 테이블을 가정해보겠습니다. 이 테이블은 여러 날짜에 걸친 매출 금액을 기록합니다. 각 날짜별 매출의 누적 합계를 계산하고자 합니다. 즉, 각 날짜까지의 총 매출액을 나타냅니다.\n\n이 쿼리는 시간이 지남에 따른 매출의 누적 합계를 제공하여 누적 매출 성장을 추적하기 쉽게 합니다.\n\n결과:\n\ndate | sales | running_total\n2023-01-01 | 100 | 100\n2023-01-02 | 150 | 250\n2023-01-03 | 200 | 450\n2023-01-04 | 250 | 700\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n윈도우 함수는 단일 행 그룹으로 결과 집합을 축소시키지 않고 실행 합계, 이동 평균, 순위 등 다양한 작업에 사용할 수 있어요.\n\n# 2. 공통 테이블 표현식 (CTE)\n\n공통 테이블 표현식은 쿼리 내에서 참조할 수 있는 임시 결과 집합을 만드는 방법을 제공해요. 이것은 가독성을 향상시키고 복잡한 쿼리를 간단하게 만들어줘요. 다음은 각 제품 카테고리별 총 매출을 계산하기 위해 CTE를 사용하는 방법이에요.\n\n이 쿼리는 'category_revenue'라는 CTE를 정의해요. 이는 매출 테이블에서 수익을 합산하고 카테고리 열을 기준으로 결과를 그룹화하여 각 카테고리별 총 수익을 계산해요. 메인 쿼리는 'category_revenue' CTE에서 모든 열을 선택하여 각 카테고리의 계산된 총 수익을 효과적으로 표시해요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n출력:\n\ncategory | total_revenue\n\nA | 5000\n\nB | 7000\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\nC|4500\n\n# 3. Recursive Queries\n\nRecursive queries enable travel of hierarchical data structures like organisational charts or bill of materials. Suppose we have a table representing employee relationships, and we want to find all the subordinates of a given manager.\n\nThis recursive CTE finds all employees who report directly or indirectly to a specific manager ‘manager_id_of_interest’. It starts with employees directly reporting to the manager and then recursively finds their subordinates, building the hierarchy.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n| employee_id | name  | manager_id           |\n|:------------|:------|:---------------------|\n| 2           | Alice | manager_id_of_interest |\n| 3           | Bob   | 2                    |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n4|Charlie |3\n\n# 4. Pivot Tables\n\n피벗 테이블은 행을 열로 변환하여 데이터를 요약해 주는 표 형식을 제공합니다. 예를 들어, 판매 데이터가 포함된 테이블이 있고, 각 제품의 월별 총 판매액을 표시하기 위해 데이터를 피벗하려고 한다고 가정해 봅시다.\n\n이 쿼리는 조건부 집계를 사용하여 각 제품의 월별 판매 데이터를 집계합니다. 각 제품의 1월, 2월, 3월 판매액을 따로 합산하여, 이러한 월에 대한 각 제품의 총 판매액을 보여주는 테이블을 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 Markdown 형식으로 테이블을 나타낸 내용입니다:\n\n| product | Jan | Feb | Mar |\n|---------|-----|-----|-----|\n| Product A | 100 | 200 | 150 |\n| Product B | 80 | 190 | 220 |\n| Product C | 60 | 140 | 130 |\n\n# 5. 분석 함수\n\n분석 함수는 행 그룹을 기반으로 집계 값을 계산합니다. 예를 들어, ROW_NUMBER( ) 함수를 사용하여 데이터셋의 각 레코드에 고유한 행 번호를 할당할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 쿼리는 ROW_NUMBER() 윈도우 함수를 사용하여 주문 날짜를 기준으로 각 고객당 주문에 고유한 순위를 할당합니다. 결과는 각 고객이 배치한 주문의 순서를 보여줍니다.\n\n 출력:\n\n| customer_id | order_id | order_rank |\n|------------|-----------|--------------|\n| 1              | 101          | 1                    |\n| 1              | 102          | 2                    |\n| 2              | 201          | 1                    |\n| 2              | 202          | 2                    |\n| 2              | 203          | 3                    |\n\n# 6. Unpivot\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n언피벗은 열을 행으로 변환하는 피벗의 반대 작업입니다. 월별로 집계된 매출 데이터가 있는 테이블이 있다고 가정해봅시다. 시간에 따른 트렌드를 분석하기 위해 이를 언피벗하려고 합니다.\n\n다음 쿼리는 매출 열을 행으로 변환하여 제품별 시간에 따른 트렌드를 분석하기 쉽게 만듭니다. 각 행은 특정 월에 대한 제품의 매출을 나타냅니다.\n\n결과:\n\nproduct | month | sales\nProductA | Jan | 100\nProductA | Feb | 150\nProductA | Mar | 200\nProductB | Jan | 200\nProductB | Feb | 250\nProductB | Mar | 300\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 7. 조건부 집계\n\n조건부 집계는 지정된 기준에 따라 조건부로 집계 함수를 적용하는 것을 말합니다. 예를 들어, 반복 고객이 주문한 주문에 대해서만 평균 판매 금액을 계산하고 싶을 수 있습니다.\n\n다음 쿼리는 두 개 이상의 주문을 한 고객들의 평균 주문 총액을 계산합니다. 각 고객에 대해 주문 수와 총 주문 금액을 집계한 후, 반복 고객들에 대한 평균을 계산합니다.\n\n출력:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\ncustomer_id | avg_sales_repeat_customers \n1 | 250 \n2 | 150 \n3 | 300\n\n## 8. 날짜 함수\n\nSQL에서의 날짜 함수는 날짜와 관련된 정보를 조작하고 추출할 수 있게 해줍니다. 예를 들어 DATE_TRUNC() 함수를 사용하여 매출 데이터를 월별로 그룹화할 수 있습니다.\n\n이 출력은 매출이 total_sales로 집계된 각 월을 month으로 나타내며, 각 월은 해당 월의 첫 번째 날로 표시됩니다 (예: 1월의 경우 2023-01-01). 각 해당 월의 총 매출액이 합산되어 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n출력:\n\n| month      | total_sales |\n|------------|-------------|\n| 2023-01-01 | 15000       |\n| 2023-02-01 | 20000       |\n| 2023-03-01 | 17500       |\n| 2023-04-01 | 22000       |\n\n## 9. 병합문\n\n병합문(UPSERT 또는 ON DUPLICATE KEY UPDATE로도 알려져 있음)은 소스 테이블과의 조인 결과를 기반으로 대상 테이블에 레코드를 삽입, 업데이트 또는 삭제할 수 있게 합니다. 고객 데이터를 포함하는 두 테이블을 동기화하고 싶다고 가정해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\ncustomers_target (before merge):\n\n| customer_id | name       | email           |\n|-------------|------------|-----------------|\n| 1           | John Doe   | john@example.com|\n| 2           | Jane Smith | jane@example.com|\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n테이블 태그를 Markdown 형식으로 변경해보면 다음과 같습니다.\n\n\n| customer_id | name         | email            |\n|------------ | ------------ | -----------------|\n| 1           | John Doe     | john@example.com |\n| 2           | Jane Johnson | jane.j@example.com |\n| 3           | Alice Brown  | alice@example.com |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nMERGE 문은 customers_source 테이블을 기반으로 customers_target 테이블을 업데이트합니다. customers_source의 customer_id가 customers_target에서와 일치하는 경우, 이름과 이메일이 업데이트됩니다. 일치하는 항목이 없는 경우 새로운 행이 삽입됩니다.\n\n## 10. Case 문\n\nCase 문을 사용하면 SQL 쿼리 내에서 조건부 논리를 구현할 수 있습니다. 예를 들어, 총 구매 금액에 기초하여 고객을 분류하는 Case 문을 사용할 수 있습니다.\n\n예제 데이터 세트를 고려하고 출력을 설명해보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\norders 테이블에서의 예시 데이터:\n\ncustomer_id | order_total\n1 | 200\n1 | 300\n2 | 800\n3 | 150\n3 | 400\n4 | 1200\n\n결과:\n\ncustomer_id | customer_category\n1 | Gold\n2 | Gold\n3 | Silver\n4 | Platinum\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n쿼리는 고객의 총 구매 금액을 기준으로 고객을 카테고리로 분류합니다. 총 구매 금액이 $1000 이상인 경우 '플래티넘'으로 레이블을 지정하고, $500에서 $999 사이인 경우 '골드'로 레이블을 지정하며, $500 미만인 경우 '실버'로 레이블을 지정합니다.\n\n# 11. 문자열 함수\n\nSQL에서의 문자열 함수는 텍스트 데이터를 조작하는 데 사용됩니다. 예를 들어 CONCAT( ) 함수를 사용하면 이름과 성을 연결할 수 있습니다.\n\n예시 데이터 세트를 고려하고 출력을 설명해 보겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예시 데이터인 직원 테이블:\n\n| 이름 | 성 |\n|--------|--------|\n| John | Doe |\n| Jane | Smith |\n| Alice | Johnson |\n| Bob | Brown |\n\n결과:\n\n| 전체 이름 |\n|--------------|\n| John Doe |\n| Jane Smith |\n| Alice Johnson |\n| Bob Brown |\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n질문은 employees 테이블에서 first_name 및 last_name 열을 연결하여 각 직원의 full_name을 만드는 것입니다.\n\n## 12. 그룹 세트\n\n그룹 세트를 사용하면 하나의 쿼리에서 여러 수준의 세분화 데이터를 집계할 수 있습니다. 우리가 매월 그리고 연도별로 총 판매 수익을 계산하고 싶다고 가정해 봅시다.\n\n예시 데이터는 sales 테이블에 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주문 날짜 | 매출액\n2023–01–15 | 1000\n2023–01–20 | 1500\n2023–02–10 | 2000\n2023–03–05 | 2500\n2024–01–10 | 3000\n2024–01–20 | 3500\n2024–02–25 | 4000\n\n결과:\n\n년도 | 월 | 총 매출\n2023 | 1 | 2500\n2023 | 2 | 2000\n2023 | 3 | 2500\n2024 | 1 | 6500\n2024 | 2 | 4000\n2023 | NULL | 7000\n2024 | NULL | 10500\nNULL | 1 | 9000\nNULL | 2 | 6000\nNULL | 3 | 2500\n\n그 쿼리는 GROUPING SETS를 사용하여 매출 데이터를 연도별 및 월별, 연도만, 월만으로 그룹화합니다. 결과적으로 각 연도의 각 월별 소계, 각 연도의 총합, 모든 연도를 통틀어 각 월의 총합이 나타납니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 13. Cross Joins\n\nCross joins은 두 개의 테이블의 데카르트 곱을 생성하여 각 테이블의 모든 행을 결합한 조합을 생성합니다. 예를 들어, 교차 조인을 사용하여 제품과 고객의 모든 가능한 조합을 생성할 수 있습니다.\n\n제품 및 고객 테이블을 위한 예제 데이터 세트를 살펴봅시다.\n\n제품 테이블:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nproduct_id | product_name\n--- | ---\n1 | Product A\n2 | Product B\n\ncustomers table:\n\ncustomer_id | customer_name\n--- | ---\n101 | Customer X\n102 | Customer Y\n\nOutput:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nproduct_id | product_name | customer_id | customer_name\n1 | Product A | 101 | Customer X\n1 | Product A | 102 | Customer Y\n2 | Product B | 101 | Customer X\n2 | Product B | 102 | Customer Y\n\n해당 쿼리는 PRODUCTS와 CUSTOMERS 테이블 사이에 CROSS JOIN을 수행하여 카테시안 곱을 생성합니다. 이는 모든 제품이 모든 고객과 쌍을 이루어 모든 제품과 고객의 가능한 조합을 생성하는 것을 의미합니다.\n\n## 14. 인라인 뷰\n\n인라인 뷰(파생 테이블로도 알려짐)는 SQL 쿼리 내에서 임시 결과 집합을 만드는 데 사용됩니다. 예를 들어, 우리가 주문 평균 가치를 초과하는 구매를 한 고객을 찾고 싶다면 인라인 뷰를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주문 테이블:\n\ncustomer_id | order_total\n1 | 100\n1 | 200\n2 | 500\n3 | 300\n3 | 200\n4 | 700\n\n각 고객별 총 주문을 계산합니다:\n\ncustomer_id | order_total\n1 | 300\n2 | 500\n3 | 500\n4 | 700\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n표를 마크다운 형식으로 변경하세요.\n\n\n| customer_id | order_total |\n| --- | --- |\n| 2 | 500 |\n| 3 | 500 |\n| 4 | 700 |\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 15. 집합 연산자\n\nUNION, INTERSECT 및 EXCEPT와 같은 집합 연산자를 사용하여 두 개 이상의 쿼리 결과를 결합할 수 있습니다. 예를 들어, 우리는 UNION 연산자를 사용하여 두 개의 쿼리 결과를 하나의 결과 세트로 병합할 수 있습니다.\n\n이 쿼리는 제품 및 보관된 제품 테이블에서 결과를 결합하여 중복 항목을 제거하여 제품 ID 및 이름의 통합 목록을 만듭니다. UNION 연산자는 각 제품이 최종 출력에서 한 번만 나타나도록 합니다.\n\n결과:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nproduct_id | product_name\n1 | Chocolate Bar\n2 | Dark Chocolate\n3 | Milk Chocolate\n4 | White Chocolate\n5 | Almond Chocolate\n\n이 15가지의 고급 SQL 기술을 사용하여 복잡한 데이터 문제를 쉽고 정확하게 해결할 수 있습니다. 데이터 분석가, 엔지니어, 혹은 과학자라면 SQL 기술을 향상시킴으로써 데이터 처리 역량을 크게 향상시킬 수 있습니다.\n\n이 게시물이 유용했다면, 반드시 클랩(clap), 댓글(comment), 구독(subscribe) 및 팔로우(follow)하여 미디엄(medium.com)에서 더 많은 데이터 관련 콘텐츠를 접해보세요.\n\n즐거운 데이터 분석 되세요!","ogImage":{"url":"/assets/img/2024-06-19-AdvancedSQLQueriesyoumustknow_0.png"},"coverImage":"/assets/img/2024-06-19-AdvancedSQLQueriesyoumustknow_0.png","tag":["Tech"],"readingTime":9},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e데이터 분석 및 데이터 엔지니어링을 위한 최고의 15가지 고급 SQL 명령어!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-AdvancedSQLQueriesyoumustknow_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이미 데이터 분석에 익숙한 분이라면 SELECT, INSERT, UPDATE, DELETE 등과 같은 기본 명령어를 이미 알고 있을 것입니다. 가장 많이 사용되는 명령어라면서도 데이터를 깊이 파고들기 위해 아래 쿼리도 알아두는 것이 좋습니다.\u003c/p\u003e\n\u003ch1\u003e1. 윈도우 함수\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e윈도우 함수는 현재 행과 관련된 일련의 행을 대상으로 계산에 사용됩니다. 예를 들어, SUM() 함수와 OVER() 절을 사용하여 매출의 누적 합계를 계산하는 예제를 살펴보겠습니다. 'Sales_Data'라는 매출 데이터 테이블을 가정해보겠습니다. 이 테이블은 여러 날짜에 걸친 매출 금액을 기록합니다. 각 날짜별 매출의 누적 합계를 계산하고자 합니다. 즉, 각 날짜까지의 총 매출액을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e이 쿼리는 시간이 지남에 따른 매출의 누적 합계를 제공하여 누적 매출 성장을 추적하기 쉽게 합니다.\u003c/p\u003e\n\u003cp\u003e결과:\u003c/p\u003e\n\u003cp\u003edate | sales | running_total\n2023-01-01 | 100 | 100\n2023-01-02 | 150 | 250\n2023-01-03 | 200 | 450\n2023-01-04 | 250 | 700\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e윈도우 함수는 단일 행 그룹으로 결과 집합을 축소시키지 않고 실행 합계, 이동 평균, 순위 등 다양한 작업에 사용할 수 있어요.\u003c/p\u003e\n\u003ch1\u003e2. 공통 테이블 표현식 (CTE)\u003c/h1\u003e\n\u003cp\u003e공통 테이블 표현식은 쿼리 내에서 참조할 수 있는 임시 결과 집합을 만드는 방법을 제공해요. 이것은 가독성을 향상시키고 복잡한 쿼리를 간단하게 만들어줘요. 다음은 각 제품 카테고리별 총 매출을 계산하기 위해 CTE를 사용하는 방법이에요.\u003c/p\u003e\n\u003cp\u003e이 쿼리는 'category_revenue'라는 CTE를 정의해요. 이는 매출 테이블에서 수익을 합산하고 카테고리 열을 기준으로 결과를 그룹화하여 각 카테고리별 총 수익을 계산해요. 메인 쿼리는 'category_revenue' CTE에서 모든 열을 선택하여 각 카테고리의 계산된 총 수익을 효과적으로 표시해요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e출력:\u003c/p\u003e\n\u003cp\u003ecategory | total_revenue\u003c/p\u003e\n\u003cp\u003eA | 5000\u003c/p\u003e\n\u003cp\u003eB | 7000\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eC|4500\u003c/p\u003e\n\u003ch1\u003e3. Recursive Queries\u003c/h1\u003e\n\u003cp\u003eRecursive queries enable travel of hierarchical data structures like organisational charts or bill of materials. Suppose we have a table representing employee relationships, and we want to find all the subordinates of a given manager.\u003c/p\u003e\n\u003cp\u003eThis recursive CTE finds all employees who report directly or indirectly to a specific manager ‘manager_id_of_interest’. It starts with employees directly reporting to the manager and then recursively finds their subordinates, building the hierarchy.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth align=\"left\"\u003eemployee_id\u003c/th\u003e\u003cth align=\"left\"\u003ename\u003c/th\u003e\u003cth align=\"left\"\u003emanager_id\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003e2\u003c/td\u003e\u003ctd align=\"left\"\u003eAlice\u003c/td\u003e\u003ctd align=\"left\"\u003emanager_id_of_interest\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003e3\u003c/td\u003e\u003ctd align=\"left\"\u003eBob\u003c/td\u003e\u003ctd align=\"left\"\u003e2\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e4|Charlie |3\u003c/p\u003e\n\u003ch1\u003e4. Pivot Tables\u003c/h1\u003e\n\u003cp\u003e피벗 테이블은 행을 열로 변환하여 데이터를 요약해 주는 표 형식을 제공합니다. 예를 들어, 판매 데이터가 포함된 테이블이 있고, 각 제품의 월별 총 판매액을 표시하기 위해 데이터를 피벗하려고 한다고 가정해 봅시다.\u003c/p\u003e\n\u003cp\u003e이 쿼리는 조건부 집계를 사용하여 각 제품의 월별 판매 데이터를 집계합니다. 각 제품의 1월, 2월, 3월 판매액을 따로 합산하여, 이러한 월에 대한 각 제품의 총 판매액을 보여주는 테이블을 만듭니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음은 Markdown 형식으로 테이블을 나타낸 내용입니다:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eproduct\u003c/th\u003e\u003cth\u003eJan\u003c/th\u003e\u003cth\u003eFeb\u003c/th\u003e\u003cth\u003eMar\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eProduct A\u003c/td\u003e\u003ctd\u003e100\u003c/td\u003e\u003ctd\u003e200\u003c/td\u003e\u003ctd\u003e150\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eProduct B\u003c/td\u003e\u003ctd\u003e80\u003c/td\u003e\u003ctd\u003e190\u003c/td\u003e\u003ctd\u003e220\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eProduct C\u003c/td\u003e\u003ctd\u003e60\u003c/td\u003e\u003ctd\u003e140\u003c/td\u003e\u003ctd\u003e130\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003ch1\u003e5. 분석 함수\u003c/h1\u003e\n\u003cp\u003e분석 함수는 행 그룹을 기반으로 집계 값을 계산합니다. 예를 들어, ROW_NUMBER( ) 함수를 사용하여 데이터셋의 각 레코드에 고유한 행 번호를 할당할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 쿼리는 ROW_NUMBER() 윈도우 함수를 사용하여 주문 날짜를 기준으로 각 고객당 주문에 고유한 순위를 할당합니다. 결과는 각 고객이 배치한 주문의 순서를 보여줍니다.\u003c/p\u003e\n\u003cp\u003e출력:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003ecustomer_id\u003c/th\u003e\u003cth\u003eorder_id\u003c/th\u003e\u003cth\u003eorder_rank\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003e101\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003e102\u003c/td\u003e\u003ctd\u003e2\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2\u003c/td\u003e\u003ctd\u003e201\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2\u003c/td\u003e\u003ctd\u003e202\u003c/td\u003e\u003ctd\u003e2\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2\u003c/td\u003e\u003ctd\u003e203\u003c/td\u003e\u003ctd\u003e3\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003ch1\u003e6. Unpivot\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e언피벗은 열을 행으로 변환하는 피벗의 반대 작업입니다. 월별로 집계된 매출 데이터가 있는 테이블이 있다고 가정해봅시다. 시간에 따른 트렌드를 분석하기 위해 이를 언피벗하려고 합니다.\u003c/p\u003e\n\u003cp\u003e다음 쿼리는 매출 열을 행으로 변환하여 제품별 시간에 따른 트렌드를 분석하기 쉽게 만듭니다. 각 행은 특정 월에 대한 제품의 매출을 나타냅니다.\u003c/p\u003e\n\u003cp\u003e결과:\u003c/p\u003e\n\u003cp\u003eproduct | month | sales\nProductA | Jan | 100\nProductA | Feb | 150\nProductA | Mar | 200\nProductB | Jan | 200\nProductB | Feb | 250\nProductB | Mar | 300\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e7. 조건부 집계\u003c/h1\u003e\n\u003cp\u003e조건부 집계는 지정된 기준에 따라 조건부로 집계 함수를 적용하는 것을 말합니다. 예를 들어, 반복 고객이 주문한 주문에 대해서만 평균 판매 금액을 계산하고 싶을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음 쿼리는 두 개 이상의 주문을 한 고객들의 평균 주문 총액을 계산합니다. 각 고객에 대해 주문 수와 총 주문 금액을 집계한 후, 반복 고객들에 대한 평균을 계산합니다.\u003c/p\u003e\n\u003cp\u003e출력:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003ecustomer_id | avg_sales_repeat_customers\n1 | 250\n2 | 150\n3 | 300\u003c/p\u003e\n\u003ch2\u003e8. 날짜 함수\u003c/h2\u003e\n\u003cp\u003eSQL에서의 날짜 함수는 날짜와 관련된 정보를 조작하고 추출할 수 있게 해줍니다. 예를 들어 DATE_TRUNC() 함수를 사용하여 매출 데이터를 월별로 그룹화할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 출력은 매출이 total_sales로 집계된 각 월을 month으로 나타내며, 각 월은 해당 월의 첫 번째 날로 표시됩니다 (예: 1월의 경우 2023-01-01). 각 해당 월의 총 매출액이 합산되어 표시됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e출력:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003emonth\u003c/th\u003e\u003cth\u003etotal_sales\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e2023-01-01\u003c/td\u003e\u003ctd\u003e15000\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2023-02-01\u003c/td\u003e\u003ctd\u003e20000\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2023-03-01\u003c/td\u003e\u003ctd\u003e17500\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2023-04-01\u003c/td\u003e\u003ctd\u003e22000\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2\u003e9. 병합문\u003c/h2\u003e\n\u003cp\u003e병합문(UPSERT 또는 ON DUPLICATE KEY UPDATE로도 알려져 있음)은 소스 테이블과의 조인 결과를 기반으로 대상 테이블에 레코드를 삽입, 업데이트 또는 삭제할 수 있게 합니다. 고객 데이터를 포함하는 두 테이블을 동기화하고 싶다고 가정해 봅시다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003ecustomers_target (before merge):\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003ecustomer_id\u003c/th\u003e\u003cth\u003ename\u003c/th\u003e\u003cth\u003eemail\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003eJohn Doe\u003c/td\u003e\u003ctd\u003e\u003ca href=\"mailto:john@example.com\"\u003ejohn@example.com\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2\u003c/td\u003e\u003ctd\u003eJane Smith\u003c/td\u003e\u003ctd\u003e\u003ca href=\"mailto:jane@example.com\"\u003ejane@example.com\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e테이블 태그를 Markdown 형식으로 변경해보면 다음과 같습니다.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003ecustomer_id\u003c/th\u003e\u003cth\u003ename\u003c/th\u003e\u003cth\u003eemail\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003eJohn Doe\u003c/td\u003e\u003ctd\u003e\u003ca href=\"mailto:john@example.com\"\u003ejohn@example.com\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2\u003c/td\u003e\u003ctd\u003eJane Johnson\u003c/td\u003e\u003ctd\u003e\u003ca href=\"mailto:jane.j@example.com\"\u003ejane.j@example.com\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e3\u003c/td\u003e\u003ctd\u003eAlice Brown\u003c/td\u003e\u003ctd\u003e\u003ca href=\"mailto:alice@example.com\"\u003ealice@example.com\u003c/a\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eMERGE 문은 customers_source 테이블을 기반으로 customers_target 테이블을 업데이트합니다. customers_source의 customer_id가 customers_target에서와 일치하는 경우, 이름과 이메일이 업데이트됩니다. 일치하는 항목이 없는 경우 새로운 행이 삽입됩니다.\u003c/p\u003e\n\u003ch2\u003e10. Case 문\u003c/h2\u003e\n\u003cp\u003eCase 문을 사용하면 SQL 쿼리 내에서 조건부 논리를 구현할 수 있습니다. 예를 들어, 총 구매 금액에 기초하여 고객을 분류하는 Case 문을 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예제 데이터 세트를 고려하고 출력을 설명해보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eorders 테이블에서의 예시 데이터:\u003c/p\u003e\n\u003cp\u003ecustomer_id | order_total\n1 | 200\n1 | 300\n2 | 800\n3 | 150\n3 | 400\n4 | 1200\u003c/p\u003e\n\u003cp\u003e결과:\u003c/p\u003e\n\u003cp\u003ecustomer_id | customer_category\n1 | Gold\n2 | Gold\n3 | Silver\n4 | Platinum\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e쿼리는 고객의 총 구매 금액을 기준으로 고객을 카테고리로 분류합니다. 총 구매 금액이 $1000 이상인 경우 '플래티넘'으로 레이블을 지정하고, $500에서 $999 사이인 경우 '골드'로 레이블을 지정하며, $500 미만인 경우 '실버'로 레이블을 지정합니다.\u003c/p\u003e\n\u003ch1\u003e11. 문자열 함수\u003c/h1\u003e\n\u003cp\u003eSQL에서의 문자열 함수는 텍스트 데이터를 조작하는 데 사용됩니다. 예를 들어 CONCAT( ) 함수를 사용하면 이름과 성을 연결할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e예시 데이터 세트를 고려하고 출력을 설명해 보겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예시 데이터인 직원 테이블:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e이름\u003c/th\u003e\u003cth\u003e성\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eJohn\u003c/td\u003e\u003ctd\u003eDoe\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eJane\u003c/td\u003e\u003ctd\u003eSmith\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eAlice\u003c/td\u003e\u003ctd\u003eJohnson\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eBob\u003c/td\u003e\u003ctd\u003eBrown\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e결과:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e전체 이름\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eJohn Doe\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eJane Smith\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eAlice Johnson\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eBob Brown\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e질문은 employees 테이블에서 first_name 및 last_name 열을 연결하여 각 직원의 full_name을 만드는 것입니다.\u003c/p\u003e\n\u003ch2\u003e12. 그룹 세트\u003c/h2\u003e\n\u003cp\u003e그룹 세트를 사용하면 하나의 쿼리에서 여러 수준의 세분화 데이터를 집계할 수 있습니다. 우리가 매월 그리고 연도별로 총 판매 수익을 계산하고 싶다고 가정해 봅시다.\u003c/p\u003e\n\u003cp\u003e예시 데이터는 sales 테이블에 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e주문 날짜 | 매출액\n2023–01–15 | 1000\n2023–01–20 | 1500\n2023–02–10 | 2000\n2023–03–05 | 2500\n2024–01–10 | 3000\n2024–01–20 | 3500\n2024–02–25 | 4000\u003c/p\u003e\n\u003cp\u003e결과:\u003c/p\u003e\n\u003cp\u003e년도 | 월 | 총 매출\n2023 | 1 | 2500\n2023 | 2 | 2000\n2023 | 3 | 2500\n2024 | 1 | 6500\n2024 | 2 | 4000\n2023 | NULL | 7000\n2024 | NULL | 10500\nNULL | 1 | 9000\nNULL | 2 | 6000\nNULL | 3 | 2500\u003c/p\u003e\n\u003cp\u003e그 쿼리는 GROUPING SETS를 사용하여 매출 데이터를 연도별 및 월별, 연도만, 월만으로 그룹화합니다. 결과적으로 각 연도의 각 월별 소계, 각 연도의 총합, 모든 연도를 통틀어 각 월의 총합이 나타납니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e13. Cross Joins\u003c/h1\u003e\n\u003cp\u003eCross joins은 두 개의 테이블의 데카르트 곱을 생성하여 각 테이블의 모든 행을 결합한 조합을 생성합니다. 예를 들어, 교차 조인을 사용하여 제품과 고객의 모든 가능한 조합을 생성할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e제품 및 고객 테이블을 위한 예제 데이터 세트를 살펴봅시다.\u003c/p\u003e\n\u003cp\u003e제품 테이블:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eproduct_id\u003c/th\u003e\u003cth\u003eproduct_name\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003eProduct A\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2\u003c/td\u003e\u003ctd\u003eProduct B\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003ecustomers table:\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003ecustomer_id\u003c/th\u003e\u003cth\u003ecustomer_name\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e101\u003c/td\u003e\u003ctd\u003eCustomer X\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e102\u003c/td\u003e\u003ctd\u003eCustomer Y\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003eOutput:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eproduct_id | product_name | customer_id | customer_name\n1 | Product A | 101 | Customer X\n1 | Product A | 102 | Customer Y\n2 | Product B | 101 | Customer X\n2 | Product B | 102 | Customer Y\u003c/p\u003e\n\u003cp\u003e해당 쿼리는 PRODUCTS와 CUSTOMERS 테이블 사이에 CROSS JOIN을 수행하여 카테시안 곱을 생성합니다. 이는 모든 제품이 모든 고객과 쌍을 이루어 모든 제품과 고객의 가능한 조합을 생성하는 것을 의미합니다.\u003c/p\u003e\n\u003ch2\u003e14. 인라인 뷰\u003c/h2\u003e\n\u003cp\u003e인라인 뷰(파생 테이블로도 알려짐)는 SQL 쿼리 내에서 임시 결과 집합을 만드는 데 사용됩니다. 예를 들어, 우리가 주문 평균 가치를 초과하는 구매를 한 고객을 찾고 싶다면 인라인 뷰를 사용할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e주문 테이블:\u003c/p\u003e\n\u003cp\u003ecustomer_id | order_total\n1 | 100\n1 | 200\n2 | 500\n3 | 300\n3 | 200\n4 | 700\u003c/p\u003e\n\u003cp\u003e각 고객별 총 주문을 계산합니다:\u003c/p\u003e\n\u003cp\u003ecustomer_id | order_total\n1 | 300\n2 | 500\n3 | 500\n4 | 700\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e표를 마크다운 형식으로 변경하세요.\u003c/p\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003ecustomer_id\u003c/th\u003e\u003cth\u003eorder_total\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e2\u003c/td\u003e\u003ctd\u003e500\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e3\u003c/td\u003e\u003ctd\u003e500\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e4\u003c/td\u003e\u003ctd\u003e700\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e15. 집합 연산자\u003c/h1\u003e\n\u003cp\u003eUNION, INTERSECT 및 EXCEPT와 같은 집합 연산자를 사용하여 두 개 이상의 쿼리 결과를 결합할 수 있습니다. 예를 들어, 우리는 UNION 연산자를 사용하여 두 개의 쿼리 결과를 하나의 결과 세트로 병합할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 쿼리는 제품 및 보관된 제품 테이블에서 결과를 결합하여 중복 항목을 제거하여 제품 ID 및 이름의 통합 목록을 만듭니다. UNION 연산자는 각 제품이 최종 출력에서 한 번만 나타나도록 합니다.\u003c/p\u003e\n\u003cp\u003e결과:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eproduct_id | product_name\n1 | Chocolate Bar\n2 | Dark Chocolate\n3 | Milk Chocolate\n4 | White Chocolate\n5 | Almond Chocolate\u003c/p\u003e\n\u003cp\u003e이 15가지의 고급 SQL 기술을 사용하여 복잡한 데이터 문제를 쉽고 정확하게 해결할 수 있습니다. 데이터 분석가, 엔지니어, 혹은 과학자라면 SQL 기술을 향상시킴으로써 데이터 처리 역량을 크게 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 게시물이 유용했다면, 반드시 클랩(clap), 댓글(comment), 구독(subscribe) 및 팔로우(follow)하여 미디엄(medium.com)에서 더 많은 데이터 관련 콘텐츠를 접해보세요.\u003c/p\u003e\n\u003cp\u003e즐거운 데이터 분석 되세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-AdvancedSQLQueriesyoumustknow"},"buildId":"kkckKPyxcjJp_o8wb2unW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>