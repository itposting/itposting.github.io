<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>RAG 시스템을 위한 새로운 청킹 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-NewChunkingMethodforRAG-Systems" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="RAG 시스템을 위한 새로운 청킹 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="RAG 시스템을 위한 새로운 청킹 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-NewChunkingMethodforRAG-Systems" data-gatsby-head="true"/><meta name="twitter:title" content="RAG 시스템을 위한 새로운 청킹 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 03:33" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_buildManifest.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">RAG 시스템을 위한 새로운 청킹 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="RAG 시스템을 위한 새로운 청킹 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-NewChunkingMethodforRAG-Systems&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>문서 분할 개선</h2>
<p><img src="/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_0.png" alt="image"></p>
<p>대형 문서를 작은 부분으로 나누는 것은 검색 증강 생성 (RAG) 시스템의 성능에 영향을 미치는 필수적이면서도 중요한 요소입니다. RAG 시스템을 개발하는 프레임워크들은 일반적으로 여러 가지 옵션을 제공합니다. 본문에서는 새로운 옵션을 소개하여 문서를 세분화할 때 문장 임베딩의 도움을 받아 주제 변경을 인식하려고 시도한 이와 같은 방법을 소개하고자 합니다. 이것은 RAG 시스템의 임베딩 단계에서 주제를 인코딩하는 텍스트 부분의 벡터를 찾을 수 있으며 여러 가지 주제의 혼합이 아닙니다. 우리는 주제 모델링의 맥락에서 본 방법을 제안했지만, RAG 시스템에서도 사용할 수 있는 것입니다.</p>
<h1>RAG 시스템</h1>
<div class="content-ad"></div>
<p>검색 보완 생성 (Retrieval-Augmented Generation, RAG) 시스템은 검색 기반 및 생성 기반 방법을 결합하여 출력물의 품질과 관련성을 향상시키는 기계 학습 모델입니다. 먼저 입력 쿼리에 기반하여 대규모 데이터셋에서 관련 문서나 정보를 검색합니다. 그런 다음, 검색된 정보를 활용하여 일관된 컨텍스트에 적합한 응답이나 내용을 생성하기 위해 변환기 기반 언어 모델과 같은 생성 모델을 사용합니다. 이 하이브리드 방식은 모델이 정확하고 유익한 응답을 제공하는 능력을 향상시킵니다, 특히 복잡하거나 지식 집약적인 작업에서 더욱 유용합니다.</p>
<h1>다른 분할 옵션</h1>
<p>자세한 절차를 살펴보기 전에, 문서 분할에 대한 몇 가지 표준 옵션을 소개하겠습니다. 널리 사용되는 Langchain 프레임워크를 활용하여 예시를 보여드리겠습니다.</p>
<p>LangChain은 주로 대규모 언어 모델을 적용하기 위해 설계된 견고한 프레임워크로, 다양한 자연어 처리(NLP) 작업을 지원합니다. 그 중 하나인 문서 분할은 사용자가 대형 문서를 작은 관리 가능한 청크로 쪼개는 기능입니다. 아래는 LangChain의 문서 분할의 주요 기능 및 예시를 소개한 것입니다.</p>
<div class="content-ad"></div>
<h1>LangChain의 문서 분할 핵심 기능</h1>
<ul>
<li>재귀적 문자 텍스트 분할기: 이 방법은 문자 기반으로 텍스트를 재귀적으로 분할하여 각 청크가 지정된 길이보다 작도록 보장합니다. 이는 자연 단락 또는 문장 구분이 있는 문서에 특히 유용합니다.</li>
<li>토큰 분할기: 이 방법은 토큰을 사용하여 문서를 분할합니다. 언어 모델의 토큰 제한이 있는 경우에 유용하며, 각 청크가 모델의 제약에 맞도록 보장합니다.</li>
<li>문장 분할기: 이 방법은 문장 경계에서 문서를 분할합니다. 문장이 일반적으로 완전한 생각을 나타내므로 텍스트의 맥락적 무결성을 유지하는 데 이상적입니다.</li>
<li>Regex 분할기: 이 방법은 사용자 정의 분할 지점을 정의하기 위해 정규 표현식을 사용합니다. 이 방법은 사용 사례에 특정한 패턴을 기준으로 문서를 분할할 수 있는 가장 큰 유연성을 제공합니다.</li>
<li>마크다운 분할기: 이 방법은 마크다운 문서에 맞춰져 있습니다. 제목, 목록, 코드 블록과 같은 마크다운 특정 요소를 기준으로 텍스트를 분할합니다.</li>
</ul>
<h1>LangChain에서 문서 분할의 예시</h1>
<h2>1. 재귀적 문자 텍스트 분할기</h2>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> langchain.<span class="hljs-property">text_splitter</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">RecursiveCharacterTextSplitter</span>

text = <span class="hljs-string">"여러분의 긴 문서 텍스트를 여기에 넣어주세요..."</span>
splitter = <span class="hljs-title class_">RecursiveCharacterTextSplitter</span>(chunk_size=<span class="hljs-number">1000</span>, chunk_overlap=<span class="hljs-number">50</span>)
chunks = splitter.<span class="hljs-title function_">split_text</span>(text)
<span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> <span class="hljs-attr">chunks</span>:
    <span class="hljs-title function_">print</span>(chunk)
</code></pre>
<h2>2. 토큰 분할기</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> langchain.<span class="hljs-property">text_splitter</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">TokenSplitter</span>

text = <span class="hljs-string">"여러분의 긴 문서 텍스트를 여기에 넣어주세요..."</span>
splitter = <span class="hljs-title class_">TokenSplitter</span>(max_tokens=<span class="hljs-number">512</span>)
chunks = splitter.<span class="hljs-title function_">split_text</span>(text)
<span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> <span class="hljs-attr">chunks</span>:
    <span class="hljs-title function_">print</span>(chunk)
</code></pre>
<h2>3. 문장 분할기</h2>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> langchain.<span class="hljs-property">text_splitter</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">SentenceSplitter</span>

text = <span class="hljs-string">"문서의 긴 텍스트를 여기에 입력하세요..."</span>
splitter = <span class="hljs-title class_">SentenceSplitter</span>(max_length=<span class="hljs-number">5</span>)
chunks = splitter.<span class="hljs-title function_">split_text</span>(text)
<span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> <span class="hljs-attr">chunks</span>:
    <span class="hljs-title function_">print</span>(chunk)
</code></pre>
<h2>4. Regex Splitter</h2>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> langchain.<span class="hljs-property">text_splitter</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">RegexSplitter</span>

text = <span class="hljs-string">"문서의 긴 텍스트를 여기에 입력하세요..."</span>
splitter = <span class="hljs-title class_">RegexSplitter</span>(pattern=r<span class="hljs-string">'\n\n+'</span>)
chunks = splitter.<span class="hljs-title function_">split_text</span>(text)
<span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> <span class="hljs-attr">chunks</span>:
    <span class="hljs-title function_">print</span>(chunk)
</code></pre>
<h2>5. Markdown Splitter</h2>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> langchain.<span class="hljs-property">text_splitter</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">MarkdownSplitter</span>

text = <span class="hljs-string">"여기에 긴 마크다운 문서를 넣어주세요..."</span>
splitter = <span class="hljs-title class_">MarkdownSplitter</span>()
chunks = splitter.<span class="hljs-title function_">split_text</span>(text)
<span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> <span class="hljs-attr">chunks</span>:
    <span class="hljs-title function_">print</span>(chunk)
</code></pre>
<h1>새로운 접근 방식 소개</h1>
<p>대량의 문서를 디지털 콘텐츠 분석에서 일관된 주제별 섹션으로 분리하는 것은 상당한 어려움을 겪을 수 있습니다. 위에서 설명한 전통적인 방법들은 종종 주제가 변화하는 미묘한 부분을 정확하게 감지하지 못할 수 있습니다. 우리는 인공지능, 컴퓨터, 데이터 과학 및 응용국제 학회(ACDSA 2024)에서 발표된 논문에서 이 문제를 해결하기 위한 혁신적인 접근 방식을 제안합니다.</p>
<h2>핵심 도전 과제</h2>
<div class="content-ad"></div>
<p>대규모 문서, 예를 들어 학술 논문, 긴 보고서 및 상세한 기사는 복잡하며 여러 주제를 포함하고 있습니다. 간단한 규칙 기반 방법부터 고급 기계 학습 알고리즘까지 다양한 전통적인 분할 기술들은 주제 전환의 정확한 지점을 식별하는 것에 어려움을 겪습니다. 이러한 방법들은 종종 섬세한 전환점을 놓치거나 잘못 식별하여 단편화된 또는 겹치는 섹션을 야기할 수 있습니다.</p>
<p>저희 방법은 문장 임베딩의 힘을 활용하여 분할 과정을 개선합니다. 이 접근 방식은 개별 문장에 대한 임베딩을 생성하기 위해 Sentence-BERT (SBERT)를 활용하여 그들의 유사성을 양적으로 측정합니다. 주제가 변경됨에 따라 이러한 임베딩은 벡터 공간에서 변화를 반영하여 잠재적인 주제 전환을 나타냅니다.</p>
<h2>접근 방식의 각 단계를 살펴보세요:</h2>
<h2>1. 문장 임베딩 사용</h2>
<div class="content-ad"></div>
<p>임베딩 생성:</p>
<ul>
<li>이 방법은 개별 문장에 임베딩을 생성하기 위해 Sentence-BERT (SBERT)를 사용합니다. SBERT는 문장의 의미적 내용을 담고 있는 밀집 벡터 표현을 만듭니다.</li>
<li>이러한 임베딩을 비교하여 연이은 문장 간의 일관성을 파악합니다.</li>
</ul>
<p>유사도 계산:</p>
<ul>
<li>문장 간의 유사도는 코사인 유사도 또는 맨해튼 또는 유클리드 거리와 같은 다른 거리 측정을 사용하여 측정됩니다.</li>
<li>동일한 주제 내의 문장은 유사한 임베딩을 갖게 되며, 서로 다른 주제의 문장은 유사도가 감소하는 것을 보여줍니다.</li>
</ul>
<div class="content-ad"></div>
<h2>2. 갭 점수 계산</h2>
<p>매개 변수 n 정의:</p>
<ul>
<li>매개 변수 n을 설정하여 비교할 문장의 수를 지정합니다. 예를 들어, n=2이면 두 연속 문장이 다음 쌍과 비교됩니다.</li>
<li>n의 선택은 비교에서 고려되는 문맥 길이에 영향을 미치며, 세밀한 전환을 포착하는 필요와 계산 효율성을 균형있게 유지합니다.</li>
</ul>
<p>코사인 유사도 계산:</p>
<div class="content-ad"></div>
<ul>
<li>문서의 각 위치에 대해, 알고리즘은 현재 위치 앞 뒤 n개의 문장을 추출합니다.</li>
<li>그런 다음 이러한 시퀀스의 임베딩 간 코사인 유사도, 즉 '간격 점수'를 계산합니다.</li>
<li>이러한 간격 점수는 나중에 처리를 위해 목록에 저장됩니다.</li>
</ul>
<p><img src="/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_1.png" alt="이미지"></p>
<h2>3. 부드러운 처리</h2>
<p>노이즈 처리:</p>
<div class="content-ad"></div>
<ul>
<li>텍스트의 미세한 변동으로 인해 기존 갭 점수는 소음이 발생할 수 있습니다. 이를 보정하기 위해 평활화 알고리즘을 적용합니다.</li>
<li>평활화에는 매개변수 k로 정의된 창을 통해 갭 점수를 평균화하는 과정이 포함됩니다.</li>
</ul>
<p>창 크기 k 선택:</p>
<ul>
<li>창 크기 k는 평활화의 범위를 결정합니다. 큰 k 값은 더 많은 평활화를 유발하며 소음을 줄이지만 섬세한 변환을 놓칠 수 있습니다. 작은 k 값은 더 많은 세부 정보를 유지하지만 소음을 도입할 수 있습니다.</li>
<li>평활화된 갭 점수는 주제 전환 지점이 명확히 나타납니다.</li>
</ul>
<p><img src="/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_2.png" alt="이미지"></p>
<div class="content-ad"></div>
<h2>4. 경계 감지</h2>
<p>지역 최솟값 식별:</p>
<ul>
<li>부드러운 갭 점수를 분석하여 지역 최솟값과 주제 전환 지점을 식별합니다.</li>
<li>각 지역 최솟값에 대해 깊이 점수를 계산하여 지역 최솟값과 이전 값과 이후 값 사이의 차이를 합산합니다.</li>
</ul>
<p>임계값 c 설정하기:</p>
<div class="content-ad"></div>
<ul>
<li>유의미한 경계를 결정하는 임계값 c를 사용합니다. 높은 c 값은 더 적고 더 의미 있는 세그먼트를 만들어내며, 낮은 c 값은 더 많고 더 작은 세그먼트를 만들어냅니다.</li>
<li>평균 깊이 점수보다 표준 편차의 c 배 이상을 초과하는 경계는 유효한 분할 지점으로 간주됩니다.</li>
</ul>
<p><img src="/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_3.png" alt="그림"></p>
<h2>5. 클러스터링 세그먼트</h2>
<p>반복된 주제 다루기:</p>
<div class="content-ad"></div>
<ul>
<li>긴 문서는 서로 다른 지점에서 유사한 주제를 재방문할 수 있습니다. 이를 해결하기 위해 알고리즘은 유사한 콘텐츠를 가진 세그먼트를 클러스터링합니다.</li>
<li>이 과정은 세그먼트를 임베딩으로 변환하고 클러스터링 기술을 사용하여 유사한 세그먼트를 병합하는 것을 포함합니다.</li>
</ul>
<p>중복 감소:</p>
<ul>
<li>클러스터링은 각 주제가 고유하게 표현되어 중복을 줄이는 데 도움이 되며, 세분화의 전반적인 일관성과 정확도를 향상시킵니다.</li>
</ul>
<h1>알고리즘 의사 코드</h1>
<div class="content-ad"></div>
<p>갭 스코어 계산:</p>
<p><img src="/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_4.png" alt="이미지"></p>
<p>갭 스코어 부드럽게 표현:</p>
<p><img src="/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_5.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>경계 감지:</p>
<ul>
<li>각 지역 최솟값에 대한 깊이 점수가 계산됩니다.</li>
<li>중요한 분할 지점을 결정하기 위해 매개변수 c를 사용하여 임계값을 적용합니다.</li>
</ul>
<h1>향후 방향</h1>
<p>이 연구는 이 방법을 향상시키기 위해 추가 연구를 위한 여러 영역을 개요로 설명합니다:</p>
<div class="content-ad"></div>
<ul>
<li>자동 매개변수 최적화: 기계 학습 기술을 사용하여 매개변수를 동적으로 조정합니다.</li>
<li>보다 광범위한 데이터 집합 실험: 다양하고 대규모 데이터셋에서의 방법을 테스트합니다.</li>
<li>실시간 분할: 동적 문서에 대한 실시간 응용 프로그램을 탐색합니다.</li>
<li>모델 개선: 최신 변형 모델을 통합합니다.</li>
<li>다국어 분할: 멀티링귀얼 SBERT를 사용하여 다른 언어에 해당 방법을 적용합니다.</li>
<li>계층적 분할: 상세한 문서 분석을 위해 여러 수준에서의 분할을 조사합니다.</li>
<li>사용자 인터페이스 개발: 분할 결과를 더 간편하게 조정할 수 있는 대화형 도구를 만듭니다.</li>
<li>NLP 작업과의 통합: 알고리즘을 다른 자연어 처리 작업과 결합합니다.</li>
</ul>
<h1>결론</h1>
<p>우리의 방법은 문서 분할에 정교한 접근법을 제시하며 전통적인 원칙과 첨단 문장 임베딩을 결합합니다. SBERT와 고급 스무딩 및 클러스터링 기술을 활용하여 이 프로세스는 대규모 문서에서 정확한 주제 모델링을 위한 강력하고 효율적인 솔루션을 제공합니다.</p>
<p>논문: <a href="https://ieeexplore.ieee.org/document/10467643" rel="nofollow" target="_blank">https://ieeexplore.ieee.org/document/10467643</a></p>
<div class="content-ad"></div>
<p>DataDrivenInvestor.com에서 저희를 방문해주세요.</p>
<p>DDIntel을 여기서 구독해보세요.</p>
<p>주요 기사:</p>
<p>저희 창작자 생태계에 참여해보세요.</p>
<div class="content-ad"></div>
<p>DDI 공식 텔레그램 채널: <a href="https://t.me/+tafUp6ecEys4YjQ1" rel="nofollow" target="_blank">https://t.me/+tafUp6ecEys4YjQ1</a></p>
<p>LinkedIn, Twitter, YouTube, 그리고 Facebook에서도 팔로우해주세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"RAG 시스템을 위한 새로운 청킹 방법","description":"","date":"2024-06-19 03:33","slug":"2024-06-19-NewChunkingMethodforRAG-Systems","content":"\n\n## 문서 분할 개선\n\n![image](/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_0.png)\n\n대형 문서를 작은 부분으로 나누는 것은 검색 증강 생성 (RAG) 시스템의 성능에 영향을 미치는 필수적이면서도 중요한 요소입니다. RAG 시스템을 개발하는 프레임워크들은 일반적으로 여러 가지 옵션을 제공합니다. 본문에서는 새로운 옵션을 소개하여 문서를 세분화할 때 문장 임베딩의 도움을 받아 주제 변경을 인식하려고 시도한 이와 같은 방법을 소개하고자 합니다. 이것은 RAG 시스템의 임베딩 단계에서 주제를 인코딩하는 텍스트 부분의 벡터를 찾을 수 있으며 여러 가지 주제의 혼합이 아닙니다. 우리는 주제 모델링의 맥락에서 본 방법을 제안했지만, RAG 시스템에서도 사용할 수 있는 것입니다.\n\n# RAG 시스템\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n검색 보완 생성 (Retrieval-Augmented Generation, RAG) 시스템은 검색 기반 및 생성 기반 방법을 결합하여 출력물의 품질과 관련성을 향상시키는 기계 학습 모델입니다. 먼저 입력 쿼리에 기반하여 대규모 데이터셋에서 관련 문서나 정보를 검색합니다. 그런 다음, 검색된 정보를 활용하여 일관된 컨텍스트에 적합한 응답이나 내용을 생성하기 위해 변환기 기반 언어 모델과 같은 생성 모델을 사용합니다. 이 하이브리드 방식은 모델이 정확하고 유익한 응답을 제공하는 능력을 향상시킵니다, 특히 복잡하거나 지식 집약적인 작업에서 더욱 유용합니다.\n\n# 다른 분할 옵션\n\n자세한 절차를 살펴보기 전에, 문서 분할에 대한 몇 가지 표준 옵션을 소개하겠습니다. 널리 사용되는 Langchain 프레임워크를 활용하여 예시를 보여드리겠습니다.\n\nLangChain은 주로 대규모 언어 모델을 적용하기 위해 설계된 견고한 프레임워크로, 다양한 자연어 처리(NLP) 작업을 지원합니다. 그 중 하나인 문서 분할은 사용자가 대형 문서를 작은 관리 가능한 청크로 쪼개는 기능입니다. 아래는 LangChain의 문서 분할의 주요 기능 및 예시를 소개한 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# LangChain의 문서 분할 핵심 기능\n\n- 재귀적 문자 텍스트 분할기: 이 방법은 문자 기반으로 텍스트를 재귀적으로 분할하여 각 청크가 지정된 길이보다 작도록 보장합니다. 이는 자연 단락 또는 문장 구분이 있는 문서에 특히 유용합니다.\n- 토큰 분할기: 이 방법은 토큰을 사용하여 문서를 분할합니다. 언어 모델의 토큰 제한이 있는 경우에 유용하며, 각 청크가 모델의 제약에 맞도록 보장합니다.\n- 문장 분할기: 이 방법은 문장 경계에서 문서를 분할합니다. 문장이 일반적으로 완전한 생각을 나타내므로 텍스트의 맥락적 무결성을 유지하는 데 이상적입니다.\n- Regex 분할기: 이 방법은 사용자 정의 분할 지점을 정의하기 위해 정규 표현식을 사용합니다. 이 방법은 사용 사례에 특정한 패턴을 기준으로 문서를 분할할 수 있는 가장 큰 유연성을 제공합니다.\n- 마크다운 분할기: 이 방법은 마크다운 문서에 맞춰져 있습니다. 제목, 목록, 코드 블록과 같은 마크다운 특정 요소를 기준으로 텍스트를 분할합니다.\n\n# LangChain에서 문서 분할의 예시\n\n## 1. 재귀적 문자 텍스트 분할기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\ntext = \"여러분의 긴 문서 텍스트를 여기에 넣어주세요...\"\nsplitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=50)\nchunks = splitter.split_text(text)\nfor chunk in chunks:\n    print(chunk)\n```\n\n## 2. 토큰 분할기\n\n```js\nfrom langchain.text_splitter import TokenSplitter\n\ntext = \"여러분의 긴 문서 텍스트를 여기에 넣어주세요...\"\nsplitter = TokenSplitter(max_tokens=512)\nchunks = splitter.split_text(text)\nfor chunk in chunks:\n    print(chunk)\n```\n\n## 3. 문장 분할기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfrom langchain.text_splitter import SentenceSplitter\n\ntext = \"문서의 긴 텍스트를 여기에 입력하세요...\"\nsplitter = SentenceSplitter(max_length=5)\nchunks = splitter.split_text(text)\nfor chunk in chunks:\n    print(chunk)\n```\n\n## 4. Regex Splitter\n\n```js\nfrom langchain.text_splitter import RegexSplitter\n\ntext = \"문서의 긴 텍스트를 여기에 입력하세요...\"\nsplitter = RegexSplitter(pattern=r'\\n\\n+')\nchunks = splitter.split_text(text)\nfor chunk in chunks:\n    print(chunk)\n```\n\n## 5. Markdown Splitter\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfrom langchain.text_splitter import MarkdownSplitter\n\ntext = \"여기에 긴 마크다운 문서를 넣어주세요...\"\nsplitter = MarkdownSplitter()\nchunks = splitter.split_text(text)\nfor chunk in chunks:\n    print(chunk)\n```\n\n# 새로운 접근 방식 소개\n\n대량의 문서를 디지털 콘텐츠 분석에서 일관된 주제별 섹션으로 분리하는 것은 상당한 어려움을 겪을 수 있습니다. 위에서 설명한 전통적인 방법들은 종종 주제가 변화하는 미묘한 부분을 정확하게 감지하지 못할 수 있습니다. 우리는 인공지능, 컴퓨터, 데이터 과학 및 응용국제 학회(ACDSA 2024)에서 발표된 논문에서 이 문제를 해결하기 위한 혁신적인 접근 방식을 제안합니다.\n\n## 핵심 도전 과제\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n대규모 문서, 예를 들어 학술 논문, 긴 보고서 및 상세한 기사는 복잡하며 여러 주제를 포함하고 있습니다. 간단한 규칙 기반 방법부터 고급 기계 학습 알고리즘까지 다양한 전통적인 분할 기술들은 주제 전환의 정확한 지점을 식별하는 것에 어려움을 겪습니다. 이러한 방법들은 종종 섬세한 전환점을 놓치거나 잘못 식별하여 단편화된 또는 겹치는 섹션을 야기할 수 있습니다.\n\n저희 방법은 문장 임베딩의 힘을 활용하여 분할 과정을 개선합니다. 이 접근 방식은 개별 문장에 대한 임베딩을 생성하기 위해 Sentence-BERT (SBERT)를 활용하여 그들의 유사성을 양적으로 측정합니다. 주제가 변경됨에 따라 이러한 임베딩은 벡터 공간에서 변화를 반영하여 잠재적인 주제 전환을 나타냅니다.\n\n## 접근 방식의 각 단계를 살펴보세요:\n\n## 1. 문장 임베딩 사용\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n임베딩 생성:\n\n- 이 방법은 개별 문장에 임베딩을 생성하기 위해 Sentence-BERT (SBERT)를 사용합니다. SBERT는 문장의 의미적 내용을 담고 있는 밀집 벡터 표현을 만듭니다.\n- 이러한 임베딩을 비교하여 연이은 문장 간의 일관성을 파악합니다.\n\n유사도 계산:\n\n- 문장 간의 유사도는 코사인 유사도 또는 맨해튼 또는 유클리드 거리와 같은 다른 거리 측정을 사용하여 측정됩니다.\n- 동일한 주제 내의 문장은 유사한 임베딩을 갖게 되며, 서로 다른 주제의 문장은 유사도가 감소하는 것을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. 갭 점수 계산\n\n매개 변수 n 정의:\n\n- 매개 변수 n을 설정하여 비교할 문장의 수를 지정합니다. 예를 들어, n=2이면 두 연속 문장이 다음 쌍과 비교됩니다.\n- n의 선택은 비교에서 고려되는 문맥 길이에 영향을 미치며, 세밀한 전환을 포착하는 필요와 계산 효율성을 균형있게 유지합니다.\n\n코사인 유사도 계산:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 문서의 각 위치에 대해, 알고리즘은 현재 위치 앞 뒤 n개의 문장을 추출합니다.\n- 그런 다음 이러한 시퀀스의 임베딩 간 코사인 유사도, 즉 '간격 점수'를 계산합니다.\n- 이러한 간격 점수는 나중에 처리를 위해 목록에 저장됩니다.\n\n![이미지](/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_1.png)\n\n## 3. 부드러운 처리\n\n노이즈 처리:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 텍스트의 미세한 변동으로 인해 기존 갭 점수는 소음이 발생할 수 있습니다. 이를 보정하기 위해 평활화 알고리즘을 적용합니다.\n- 평활화에는 매개변수 k로 정의된 창을 통해 갭 점수를 평균화하는 과정이 포함됩니다.\n\n창 크기 k 선택:\n\n- 창 크기 k는 평활화의 범위를 결정합니다. 큰 k 값은 더 많은 평활화를 유발하며 소음을 줄이지만 섬세한 변환을 놓칠 수 있습니다. 작은 k 값은 더 많은 세부 정보를 유지하지만 소음을 도입할 수 있습니다.\n- 평활화된 갭 점수는 주제 전환 지점이 명확히 나타납니다.\n\n![이미지](/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 4. 경계 감지\n\n지역 최솟값 식별:\n\n- 부드러운 갭 점수를 분석하여 지역 최솟값과 주제 전환 지점을 식별합니다.\n- 각 지역 최솟값에 대해 깊이 점수를 계산하여 지역 최솟값과 이전 값과 이후 값 사이의 차이를 합산합니다.\n\n임계값 c 설정하기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 유의미한 경계를 결정하는 임계값 c를 사용합니다. 높은 c 값은 더 적고 더 의미 있는 세그먼트를 만들어내며, 낮은 c 값은 더 많고 더 작은 세그먼트를 만들어냅니다.\n- 평균 깊이 점수보다 표준 편차의 c 배 이상을 초과하는 경계는 유효한 분할 지점으로 간주됩니다.\n\n![그림](/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_3.png)\n\n## 5. 클러스터링 세그먼트\n\n반복된 주제 다루기:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 긴 문서는 서로 다른 지점에서 유사한 주제를 재방문할 수 있습니다. 이를 해결하기 위해 알고리즘은 유사한 콘텐츠를 가진 세그먼트를 클러스터링합니다.\n- 이 과정은 세그먼트를 임베딩으로 변환하고 클러스터링 기술을 사용하여 유사한 세그먼트를 병합하는 것을 포함합니다.\n\n중복 감소:\n\n- 클러스터링은 각 주제가 고유하게 표현되어 중복을 줄이는 데 도움이 되며, 세분화의 전반적인 일관성과 정확도를 향상시킵니다.\n\n# 알고리즘 의사 코드\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n갭 스코어 계산:\n\n![이미지](/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_4.png)\n\n갭 스코어 부드럽게 표현:\n\n![이미지](/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_5.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n경계 감지:\n\n- 각 지역 최솟값에 대한 깊이 점수가 계산됩니다.\n- 중요한 분할 지점을 결정하기 위해 매개변수 c를 사용하여 임계값을 적용합니다.\n\n# 향후 방향\n\n이 연구는 이 방법을 향상시키기 위해 추가 연구를 위한 여러 영역을 개요로 설명합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 자동 매개변수 최적화: 기계 학습 기술을 사용하여 매개변수를 동적으로 조정합니다.\n- 보다 광범위한 데이터 집합 실험: 다양하고 대규모 데이터셋에서의 방법을 테스트합니다.\n- 실시간 분할: 동적 문서에 대한 실시간 응용 프로그램을 탐색합니다.\n- 모델 개선: 최신 변형 모델을 통합합니다.\n- 다국어 분할: 멀티링귀얼 SBERT를 사용하여 다른 언어에 해당 방법을 적용합니다.\n- 계층적 분할: 상세한 문서 분석을 위해 여러 수준에서의 분할을 조사합니다.\n- 사용자 인터페이스 개발: 분할 결과를 더 간편하게 조정할 수 있는 대화형 도구를 만듭니다.\n- NLP 작업과의 통합: 알고리즘을 다른 자연어 처리 작업과 결합합니다.\n\n# 결론\n\n우리의 방법은 문서 분할에 정교한 접근법을 제시하며 전통적인 원칙과 첨단 문장 임베딩을 결합합니다. SBERT와 고급 스무딩 및 클러스터링 기술을 활용하여 이 프로세스는 대규모 문서에서 정확한 주제 모델링을 위한 강력하고 효율적인 솔루션을 제공합니다.\n\n논문: https://ieeexplore.ieee.org/document/10467643\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDataDrivenInvestor.com에서 저희를 방문해주세요.\n\nDDIntel을 여기서 구독해보세요.\n\n주요 기사:\n\n저희 창작자 생태계에 참여해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDDI 공식 텔레그램 채널: [https://t.me/+tafUp6ecEys4YjQ1](https://t.me/+tafUp6ecEys4YjQ1)\n\nLinkedIn, Twitter, YouTube, 그리고 Facebook에서도 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_0.png"},"coverImage":"/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e문서 분할 개선\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e대형 문서를 작은 부분으로 나누는 것은 검색 증강 생성 (RAG) 시스템의 성능에 영향을 미치는 필수적이면서도 중요한 요소입니다. RAG 시스템을 개발하는 프레임워크들은 일반적으로 여러 가지 옵션을 제공합니다. 본문에서는 새로운 옵션을 소개하여 문서를 세분화할 때 문장 임베딩의 도움을 받아 주제 변경을 인식하려고 시도한 이와 같은 방법을 소개하고자 합니다. 이것은 RAG 시스템의 임베딩 단계에서 주제를 인코딩하는 텍스트 부분의 벡터를 찾을 수 있으며 여러 가지 주제의 혼합이 아닙니다. 우리는 주제 모델링의 맥락에서 본 방법을 제안했지만, RAG 시스템에서도 사용할 수 있는 것입니다.\u003c/p\u003e\n\u003ch1\u003eRAG 시스템\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e검색 보완 생성 (Retrieval-Augmented Generation, RAG) 시스템은 검색 기반 및 생성 기반 방법을 결합하여 출력물의 품질과 관련성을 향상시키는 기계 학습 모델입니다. 먼저 입력 쿼리에 기반하여 대규모 데이터셋에서 관련 문서나 정보를 검색합니다. 그런 다음, 검색된 정보를 활용하여 일관된 컨텍스트에 적합한 응답이나 내용을 생성하기 위해 변환기 기반 언어 모델과 같은 생성 모델을 사용합니다. 이 하이브리드 방식은 모델이 정확하고 유익한 응답을 제공하는 능력을 향상시킵니다, 특히 복잡하거나 지식 집약적인 작업에서 더욱 유용합니다.\u003c/p\u003e\n\u003ch1\u003e다른 분할 옵션\u003c/h1\u003e\n\u003cp\u003e자세한 절차를 살펴보기 전에, 문서 분할에 대한 몇 가지 표준 옵션을 소개하겠습니다. 널리 사용되는 Langchain 프레임워크를 활용하여 예시를 보여드리겠습니다.\u003c/p\u003e\n\u003cp\u003eLangChain은 주로 대규모 언어 모델을 적용하기 위해 설계된 견고한 프레임워크로, 다양한 자연어 처리(NLP) 작업을 지원합니다. 그 중 하나인 문서 분할은 사용자가 대형 문서를 작은 관리 가능한 청크로 쪼개는 기능입니다. 아래는 LangChain의 문서 분할의 주요 기능 및 예시를 소개한 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eLangChain의 문서 분할 핵심 기능\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e재귀적 문자 텍스트 분할기: 이 방법은 문자 기반으로 텍스트를 재귀적으로 분할하여 각 청크가 지정된 길이보다 작도록 보장합니다. 이는 자연 단락 또는 문장 구분이 있는 문서에 특히 유용합니다.\u003c/li\u003e\n\u003cli\u003e토큰 분할기: 이 방법은 토큰을 사용하여 문서를 분할합니다. 언어 모델의 토큰 제한이 있는 경우에 유용하며, 각 청크가 모델의 제약에 맞도록 보장합니다.\u003c/li\u003e\n\u003cli\u003e문장 분할기: 이 방법은 문장 경계에서 문서를 분할합니다. 문장이 일반적으로 완전한 생각을 나타내므로 텍스트의 맥락적 무결성을 유지하는 데 이상적입니다.\u003c/li\u003e\n\u003cli\u003eRegex 분할기: 이 방법은 사용자 정의 분할 지점을 정의하기 위해 정규 표현식을 사용합니다. 이 방법은 사용 사례에 특정한 패턴을 기준으로 문서를 분할할 수 있는 가장 큰 유연성을 제공합니다.\u003c/li\u003e\n\u003cli\u003e마크다운 분할기: 이 방법은 마크다운 문서에 맞춰져 있습니다. 제목, 목록, 코드 블록과 같은 마크다운 특정 요소를 기준으로 텍스트를 분할합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003eLangChain에서 문서 분할의 예시\u003c/h1\u003e\n\u003ch2\u003e1. 재귀적 문자 텍스트 분할기\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain.\u003cspan class=\"hljs-property\"\u003etext_splitter\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRecursiveCharacterTextSplitter\u003c/span\u003e\n\ntext = \u003cspan class=\"hljs-string\"\u003e\"여러분의 긴 문서 텍스트를 여기에 넣어주세요...\"\u003c/span\u003e\nsplitter = \u003cspan class=\"hljs-title class_\"\u003eRecursiveCharacterTextSplitter\u003c/span\u003e(chunk_size=\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, chunk_overlap=\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e)\nchunks = splitter.\u003cspan class=\"hljs-title function_\"\u003esplit_text\u003c/span\u003e(text)\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e chunk \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003echunks\u003c/span\u003e:\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(chunk)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e2. 토큰 분할기\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain.\u003cspan class=\"hljs-property\"\u003etext_splitter\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTokenSplitter\u003c/span\u003e\n\ntext = \u003cspan class=\"hljs-string\"\u003e\"여러분의 긴 문서 텍스트를 여기에 넣어주세요...\"\u003c/span\u003e\nsplitter = \u003cspan class=\"hljs-title class_\"\u003eTokenSplitter\u003c/span\u003e(max_tokens=\u003cspan class=\"hljs-number\"\u003e512\u003c/span\u003e)\nchunks = splitter.\u003cspan class=\"hljs-title function_\"\u003esplit_text\u003c/span\u003e(text)\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e chunk \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003echunks\u003c/span\u003e:\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(chunk)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e3. 문장 분할기\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain.\u003cspan class=\"hljs-property\"\u003etext_splitter\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSentenceSplitter\u003c/span\u003e\n\ntext = \u003cspan class=\"hljs-string\"\u003e\"문서의 긴 텍스트를 여기에 입력하세요...\"\u003c/span\u003e\nsplitter = \u003cspan class=\"hljs-title class_\"\u003eSentenceSplitter\u003c/span\u003e(max_length=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)\nchunks = splitter.\u003cspan class=\"hljs-title function_\"\u003esplit_text\u003c/span\u003e(text)\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e chunk \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003echunks\u003c/span\u003e:\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(chunk)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e4. Regex Splitter\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain.\u003cspan class=\"hljs-property\"\u003etext_splitter\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRegexSplitter\u003c/span\u003e\n\ntext = \u003cspan class=\"hljs-string\"\u003e\"문서의 긴 텍스트를 여기에 입력하세요...\"\u003c/span\u003e\nsplitter = \u003cspan class=\"hljs-title class_\"\u003eRegexSplitter\u003c/span\u003e(pattern=r\u003cspan class=\"hljs-string\"\u003e'\\n\\n+'\u003c/span\u003e)\nchunks = splitter.\u003cspan class=\"hljs-title function_\"\u003esplit_text\u003c/span\u003e(text)\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e chunk \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003echunks\u003c/span\u003e:\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(chunk)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e5. Markdown Splitter\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e langchain.\u003cspan class=\"hljs-property\"\u003etext_splitter\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMarkdownSplitter\u003c/span\u003e\n\ntext = \u003cspan class=\"hljs-string\"\u003e\"여기에 긴 마크다운 문서를 넣어주세요...\"\u003c/span\u003e\nsplitter = \u003cspan class=\"hljs-title class_\"\u003eMarkdownSplitter\u003c/span\u003e()\nchunks = splitter.\u003cspan class=\"hljs-title function_\"\u003esplit_text\u003c/span\u003e(text)\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e chunk \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003echunks\u003c/span\u003e:\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(chunk)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e새로운 접근 방식 소개\u003c/h1\u003e\n\u003cp\u003e대량의 문서를 디지털 콘텐츠 분석에서 일관된 주제별 섹션으로 분리하는 것은 상당한 어려움을 겪을 수 있습니다. 위에서 설명한 전통적인 방법들은 종종 주제가 변화하는 미묘한 부분을 정확하게 감지하지 못할 수 있습니다. 우리는 인공지능, 컴퓨터, 데이터 과학 및 응용국제 학회(ACDSA 2024)에서 발표된 논문에서 이 문제를 해결하기 위한 혁신적인 접근 방식을 제안합니다.\u003c/p\u003e\n\u003ch2\u003e핵심 도전 과제\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e대규모 문서, 예를 들어 학술 논문, 긴 보고서 및 상세한 기사는 복잡하며 여러 주제를 포함하고 있습니다. 간단한 규칙 기반 방법부터 고급 기계 학습 알고리즘까지 다양한 전통적인 분할 기술들은 주제 전환의 정확한 지점을 식별하는 것에 어려움을 겪습니다. 이러한 방법들은 종종 섬세한 전환점을 놓치거나 잘못 식별하여 단편화된 또는 겹치는 섹션을 야기할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e저희 방법은 문장 임베딩의 힘을 활용하여 분할 과정을 개선합니다. 이 접근 방식은 개별 문장에 대한 임베딩을 생성하기 위해 Sentence-BERT (SBERT)를 활용하여 그들의 유사성을 양적으로 측정합니다. 주제가 변경됨에 따라 이러한 임베딩은 벡터 공간에서 변화를 반영하여 잠재적인 주제 전환을 나타냅니다.\u003c/p\u003e\n\u003ch2\u003e접근 방식의 각 단계를 살펴보세요:\u003c/h2\u003e\n\u003ch2\u003e1. 문장 임베딩 사용\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e임베딩 생성:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 방법은 개별 문장에 임베딩을 생성하기 위해 Sentence-BERT (SBERT)를 사용합니다. SBERT는 문장의 의미적 내용을 담고 있는 밀집 벡터 표현을 만듭니다.\u003c/li\u003e\n\u003cli\u003e이러한 임베딩을 비교하여 연이은 문장 간의 일관성을 파악합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e유사도 계산:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e문장 간의 유사도는 코사인 유사도 또는 맨해튼 또는 유클리드 거리와 같은 다른 거리 측정을 사용하여 측정됩니다.\u003c/li\u003e\n\u003cli\u003e동일한 주제 내의 문장은 유사한 임베딩을 갖게 되며, 서로 다른 주제의 문장은 유사도가 감소하는 것을 보여줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e2. 갭 점수 계산\u003c/h2\u003e\n\u003cp\u003e매개 변수 n 정의:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e매개 변수 n을 설정하여 비교할 문장의 수를 지정합니다. 예를 들어, n=2이면 두 연속 문장이 다음 쌍과 비교됩니다.\u003c/li\u003e\n\u003cli\u003en의 선택은 비교에서 고려되는 문맥 길이에 영향을 미치며, 세밀한 전환을 포착하는 필요와 계산 효율성을 균형있게 유지합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e코사인 유사도 계산:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e문서의 각 위치에 대해, 알고리즘은 현재 위치 앞 뒤 n개의 문장을 추출합니다.\u003c/li\u003e\n\u003cli\u003e그런 다음 이러한 시퀀스의 임베딩 간 코사인 유사도, 즉 '간격 점수'를 계산합니다.\u003c/li\u003e\n\u003cli\u003e이러한 간격 점수는 나중에 처리를 위해 목록에 저장됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003e3. 부드러운 처리\u003c/h2\u003e\n\u003cp\u003e노이즈 처리:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e텍스트의 미세한 변동으로 인해 기존 갭 점수는 소음이 발생할 수 있습니다. 이를 보정하기 위해 평활화 알고리즘을 적용합니다.\u003c/li\u003e\n\u003cli\u003e평활화에는 매개변수 k로 정의된 창을 통해 갭 점수를 평균화하는 과정이 포함됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e창 크기 k 선택:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e창 크기 k는 평활화의 범위를 결정합니다. 큰 k 값은 더 많은 평활화를 유발하며 소음을 줄이지만 섬세한 변환을 놓칠 수 있습니다. 작은 k 값은 더 많은 세부 정보를 유지하지만 소음을 도입할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e평활화된 갭 점수는 주제 전환 지점이 명확히 나타납니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e4. 경계 감지\u003c/h2\u003e\n\u003cp\u003e지역 최솟값 식별:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e부드러운 갭 점수를 분석하여 지역 최솟값과 주제 전환 지점을 식별합니다.\u003c/li\u003e\n\u003cli\u003e각 지역 최솟값에 대해 깊이 점수를 계산하여 지역 최솟값과 이전 값과 이후 값 사이의 차이를 합산합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e임계값 c 설정하기:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e유의미한 경계를 결정하는 임계값 c를 사용합니다. 높은 c 값은 더 적고 더 의미 있는 세그먼트를 만들어내며, 낮은 c 값은 더 많고 더 작은 세그먼트를 만들어냅니다.\u003c/li\u003e\n\u003cli\u003e평균 깊이 점수보다 표준 편차의 c 배 이상을 초과하는 경계는 유효한 분할 지점으로 간주됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_3.png\" alt=\"그림\"\u003e\u003c/p\u003e\n\u003ch2\u003e5. 클러스터링 세그먼트\u003c/h2\u003e\n\u003cp\u003e반복된 주제 다루기:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e긴 문서는 서로 다른 지점에서 유사한 주제를 재방문할 수 있습니다. 이를 해결하기 위해 알고리즘은 유사한 콘텐츠를 가진 세그먼트를 클러스터링합니다.\u003c/li\u003e\n\u003cli\u003e이 과정은 세그먼트를 임베딩으로 변환하고 클러스터링 기술을 사용하여 유사한 세그먼트를 병합하는 것을 포함합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e중복 감소:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e클러스터링은 각 주제가 고유하게 표현되어 중복을 줄이는 데 도움이 되며, 세분화의 전반적인 일관성과 정확도를 향상시킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e알고리즘 의사 코드\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e갭 스코어 계산:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e갭 스코어 부드럽게 표현:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-NewChunkingMethodforRAG-Systems_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e경계 감지:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e각 지역 최솟값에 대한 깊이 점수가 계산됩니다.\u003c/li\u003e\n\u003cli\u003e중요한 분할 지점을 결정하기 위해 매개변수 c를 사용하여 임계값을 적용합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e향후 방향\u003c/h1\u003e\n\u003cp\u003e이 연구는 이 방법을 향상시키기 위해 추가 연구를 위한 여러 영역을 개요로 설명합니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e자동 매개변수 최적화: 기계 학습 기술을 사용하여 매개변수를 동적으로 조정합니다.\u003c/li\u003e\n\u003cli\u003e보다 광범위한 데이터 집합 실험: 다양하고 대규모 데이터셋에서의 방법을 테스트합니다.\u003c/li\u003e\n\u003cli\u003e실시간 분할: 동적 문서에 대한 실시간 응용 프로그램을 탐색합니다.\u003c/li\u003e\n\u003cli\u003e모델 개선: 최신 변형 모델을 통합합니다.\u003c/li\u003e\n\u003cli\u003e다국어 분할: 멀티링귀얼 SBERT를 사용하여 다른 언어에 해당 방법을 적용합니다.\u003c/li\u003e\n\u003cli\u003e계층적 분할: 상세한 문서 분석을 위해 여러 수준에서의 분할을 조사합니다.\u003c/li\u003e\n\u003cli\u003e사용자 인터페이스 개발: 분할 결과를 더 간편하게 조정할 수 있는 대화형 도구를 만듭니다.\u003c/li\u003e\n\u003cli\u003eNLP 작업과의 통합: 알고리즘을 다른 자연어 처리 작업과 결합합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e우리의 방법은 문서 분할에 정교한 접근법을 제시하며 전통적인 원칙과 첨단 문장 임베딩을 결합합니다. SBERT와 고급 스무딩 및 클러스터링 기술을 활용하여 이 프로세스는 대규모 문서에서 정확한 주제 모델링을 위한 강력하고 효율적인 솔루션을 제공합니다.\u003c/p\u003e\n\u003cp\u003e논문: \u003ca href=\"https://ieeexplore.ieee.org/document/10467643\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://ieeexplore.ieee.org/document/10467643\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eDataDrivenInvestor.com에서 저희를 방문해주세요.\u003c/p\u003e\n\u003cp\u003eDDIntel을 여기서 구독해보세요.\u003c/p\u003e\n\u003cp\u003e주요 기사:\u003c/p\u003e\n\u003cp\u003e저희 창작자 생태계에 참여해보세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eDDI 공식 텔레그램 채널: \u003ca href=\"https://t.me/+tafUp6ecEys4YjQ1\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://t.me/+tafUp6ecEys4YjQ1\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eLinkedIn, Twitter, YouTube, 그리고 Facebook에서도 팔로우해주세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-NewChunkingMethodforRAG-Systems"},"buildId":"8coAiP0lmiEK5aH6nkQkj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>