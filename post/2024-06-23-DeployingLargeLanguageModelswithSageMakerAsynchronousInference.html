<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SageMaker 비동기 추론으로 대형 언어 모델 배포하는 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SageMaker 비동기 추론으로 대형 언어 모델 배포하는 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="SageMaker 비동기 추론으로 대형 언어 모델 배포하는 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference" data-gatsby-head="true"/><meta name="twitter:title" content="SageMaker 비동기 추론으로 대형 언어 모델 배포하는 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 19:59" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SageMaker 비동기 추론으로 대형 언어 모델 배포하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SageMaker 비동기 추론으로 대형 언어 모델 배포하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<img src="/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_0.png">
<p>LLM(대규모 언어 모델)은 인기를 얻고 있으며 이를 추측하는 방법도 늘어가고 있습니다. LLM 호스팅에는 모델의 크기와 배포된 하드웨어의 최적 사용을 보장해야 한다는 어려움이 잘 알려져 있습니다. LLM 사용 사례도 다양합니다. 어떤 것은 실시간 응답 시간이 필요할 수 있고, 다른 것은 거의 실시간 기반의 지연 시간 요구 사항일 수 있습니다.</p>
<p>후자와 더 많은 오프라인 추측 사용 사례를 위해, SageMaker 비동기 추론이 좋은 옵션으로 제공됩니다. 비동기 추론에서는 이름에서 알 수 있듯이 지연 시간이 굉장히 엄격하지 않지만 필요에 따라 호출하고 확장할 수 있는 활성화된 엔드포인트가 필요합니다. 특히 LLM에서 이러한 유형의 작업 부하는 내용 편집/생성, 요약 등과 같은 사용 사례로 인해 점점 인기를 얻고 있습니다. 이러한 작업 부하들은 하위 초 단위 응답이 필요하지는 않지만 필요에 따라 호출할 수 있는 적시의 추론을 필요로 하며, SageMaker Batch Transform과 같은 완전히 오프라인적인 성격과는 대조적입니다.</p>
<p>이 예시에서는 HuggingFace 텍스트 생성 추론 서버를 SageMaker 비동기 엔드포인트와 함께 사용하여 Flan-T-5-XXL 모델을 호스팅하는 방법을 살펴볼 것입니다.</p>
<div class="content-ad"></div>
<p>참고: 본 글은 Python, LLMs 및 Amazon SageMaker에 대한 기본적인 이해를 전제로 합니다. Amazon SageMaker 추론을 시작하려면 다음 가이드를 참조해주세요. SageMaker 비동기 추론의 기초를 다룰 것이지만 더 깊은 소개를 원하시면 다음에 나오는 스타터 예제를 참조해주세요.</p>
<p>공지: 저는 AWS의 머신 러닝 아키텍트이며, 이견은 제 개인적인 의견입니다.</p>
<h1>목차</h1>
<ul>
<li>SageMaker 비동기 추론을 사용하는 시점</li>
<li>TGI 비동기 추론 구현
a. 설정 및 엔드포인트 배포
b. 비동기 추론 호출
c. 자동 스케일링 설정</li>
<li>추가 자료 및 결론</li>
</ul>
<div class="content-ad"></div>
<h1>1. SageMaker 비동기 추론 사용 시점</h1>
<p>SageMaker 추론은 현재 사용 사례에 따라 활용할 수 있는 네 가지 옵션이 있습니다. 세 가지 엔드포인트 기반 옵션이 있고 완전 오프라인 추론을 위한 한 가지 옵션이 있습니다:</p>
<ul>
<li>
<p>엔드포인트 기반 옵션:</p>
<ul>
<li>SageMaker 실시간 추론: 서브초/밀리초 응답 시간과 고 처리량 워크로드를 위한 옵션입니다. 이 엔드포인트는 CPU, GPU 또는 Inferentia 칩을 활용하며 하드웨어 단계에서 AutoScaling을 적용하여 인프라를 확장할 수 있습니다. 일반적인 사용 사례로는 Ad-Tech 기반 예측, 실시간 챗봇 등이 있습니다.</li>
<li>SageMaker 서버리스 추론: 갑작스럽고 간헐적인 워크로드에 최적화되어 있으며 cold-start를 허용할 수 있는 옵션입니다 (Provisioned Concurrency를 통해 완화할 수 있음). 여기서는 엔드포인트 뒤에 있는 모든 인프라를 관리하지 않으며 확장은 자동으로 처리됩니다.</li>
<li>SageMaker 비동기 추론: 오늘 다룰 옵션으로, 비동기 추론을 통해 거의 실시간 기반의 응답 시간 요구 사항을 충족하고 여전히 엔드포인트를 위해 정의한 전용 하드웨어를 사용합니다. 그러나 비동기 추론의 경우 실시간 추론과 달리 0 개의 인스턴스로 축소할 수 있는 옵션이 있습니다. 비동기 추론을 통해 내장 큐를 사용하여 요청을 관리하고이 큐의 가득 찬 정도에 따라 확장할 수 있습니다.</li>
</ul>
</li>
<li>
<p>오프라인 추론:</p>
<ul>
<li>SageMaker 배치 변환: 데이터셋이 있고 데이터셋으로 반환된 출력만 필요할 때 최적입니다. 영구적인 엔드포인트는 없으며 완전히 오프라인 추론입니다. 일반적인 사용 사례로는 특정 주기에 추론이 필요한 데이터셋이 있는 경우 일정 시간에 배치 변환 작업을 실행하는 것이 있습니다.</li>
</ul>
</li>
</ul>
<p>이 사용 사례에서는 특히 비동기 추론에 초점을 맞추고 있습니다. 이 옵션은 거의 실시간 능력과 0 인스턴스로 축소할 수 있는 능력 때문에 Batch Transform과 Real-Time Inference 사이에서 결혼 생각할 수 있는 옵션입니다. 즉시 생성이 필요하지 않은 사용 사례를 위한 LLM을 호스팅하는 데 효율적인 방법으로 기능을 제공할 수 있습니다.</p>
<div class="content-ad"></div>
<p>이러한 사용 사례의 예시로는 요약, 콘텐츠 생성, 편집 등이 있습니다. 이러한 사용 사례는 모두 가변 시간에 activation이 필요할 수 있으므로 지속적인 엔드포인트가 필요하지만 실시간 추론의 응답 시간은 필요로 하지 않을 수도 있습니다. 비동기 추론을 통해 성능과 비용 측면에서 이러한 종류의 사용 사례들을 다룰 수 있습니다.</p>
<p>오늘의 예시로, 우리는 인기 있는 Flan 모델을 SageMaker 비동기 추론에 적용해 보겠습니다. SageMaker 비동기 추론 엔드포인트를 생성하는 것은 실시간 엔드포인트 생성과 매우 유사합니다. 주요 차이점은 실시간 추론처럼 페이로드를 직접 전달하는 대신 입력 데이터에 대한 S3 경로가 필요하다는 점입니다.</p>
<p><img src="/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_1.png" alt="이미지"></p>
<p>비동기 엔드포인트 내에는 내부 대기열도 있음을 유의해야 합니다. 모든 추론마다 SageMaker는 요청을 대기열에 넣고 결과 위치를 S3에 반환합니다. 비동기 엔드포인트에 대해 AutoScaling을 구성할 때 이 대기열 내의 요청 수에 따라 스케일을 조정할 수 있습니다. 또한 출력 S3 경로에서 직접 폴링하는 대신 성공 또는 오류 있는 추론 알림을 수신하기 위해 선택적으로 SNS 토픽을 통합할 수도 있습니다.</p>
<div class="content-ad"></div>
<p>이제 비동기 추론에 대한 이해가 조금 더 깊어졌으니 구현부로 넘어가 봅시다!</p>
<h1>2. TGI 비동기 추론 구현</h1>
<p>우리는 새로운 SageMaker Studio 환경에서 Base Python3 커널과 ml.c5.xlarge 인스턴스로 작업할 것입니다. 비동기 추론을 위해 익숙한 Boto3 AWS Python SDK 및 상위 레벨 SageMaker Python SDK를 사용할 것입니다.</p>
<h2>a. 설정 및 엔드포인트 배포</h2>
<div class="content-ad"></div>
<p>비동기 추론을 사용하려면 먼저 데이터가 저장될 출력 S3 경로를 정의해야 합니다.</p>
<pre><code class="hljs language-js">sagemaker_session = sagemaker.<span class="hljs-title class_">Session</span>()
default_bucket = sagemaker_session.<span class="hljs-title function_">default_bucket</span>()
bucket_prefix = <span class="hljs-string">"async-llm-output"</span>
async_output_path = f<span class="hljs-string">"s3://{default_bucket}/{bucket_prefix}/output"</span>
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"내 모델 추론 결과는 다음 S3 경로에 저장될 것입니다: {async_output_path}"</span>)
</code></pre>
<p>그런 다음 이 S3 경로를 사용하여 비동기 추론 구성을 지정할 수 있습니다. 이 경우 SNS 주제를 지정하지 않지만, 성공적이거나 오류가 발생했을 때 서비스를 통해 알림을받기를 원하는 경우 선택적으로 포함할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">from</span> sagemaker.<span class="hljs-property">async_inference</span>.<span class="hljs-property">async_inference_config</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">AsyncInferenceConfig</span>

async_config = <span class="hljs-title class_">AsyncInferenceConfig</span>(
    output_path=async_output_path,
    max_concurrent_invocations_per_instance=<span class="hljs-number">10</span>,
    # 선택적으로 <span class="hljs-title class_">Amazon</span> <span class="hljs-variable constant_">SNS</span> 주제 지정
    # notification_config = {
    # <span class="hljs-string">"SuccessTopic"</span>: <span class="hljs-string">"arn:aws:sns:&#x3C;aws-region>:&#x3C;account-id>:&#x3C;topic-name>"</span>,
    # <span class="hljs-string">"ErrorTopic"</span>: <span class="hljs-string">"arn:aws:sns:&#x3C;aws-region>:&#x3C;account-id>:&#x3C;topic-name>"</span>,
    # }
)
</code></pre>
<div class="content-ad"></div>
<p>이 정의된 후에는 Flan T-5-XXL 모델을 위한 HuggingFace Hub 링크에서 SageMaker 코드를 직접 가져올 수 있습니다. 이 코드는 Text Generation Inference 모델 서버를 활용하며, Tensor Parallelism과 같은 내장 최적화가 포함되어 있습니다.</p>
<pre><code class="hljs language-js"># huggingface hub에서 배포 코드 직접 가져와서 비동기 구성 추가
hub = {
   <span class="hljs-string">'HF_MODEL_ID'</span>:<span class="hljs-string">'google/flan-t5-xxl'</span>,
   <span class="hljs-string">'SM_NUM_GPUS'</span>: json.<span class="hljs-title function_">dumps</span>(<span class="hljs-number">4</span>)
}

huggingface_model = <span class="hljs-title class_">HuggingFaceModel</span>(
   image_uri=<span class="hljs-title function_">get_huggingface_llm_image_uri</span>(<span class="hljs-string">"huggingface"</span>,version=<span class="hljs-string">"1.1.0"</span>),
   env=hub,
   role=role, 
)
</code></pre>
<p>그런 다음 SageMaker 모델 객체와 비동기 구성을 함께 사용하여 엔드포인트를 생성할 수 있습니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">SageMaker</span> 추론을 위해 모델 배포
predictor = huggingface_model.<span class="hljs-title function_">deploy</span>(
 initial_instance_count=<span class="hljs-number">1</span>,
 instance_type=<span class="hljs-string">"ml.g5.12xlarge"</span>,
 container_startup_health_check_timeout=<span class="hljs-number">300</span>,
 async_inference_config=async_config
)
</code></pre>
<div class="content-ad"></div>
<p>콘솔 또는 UI에서 엔드포인트가 비동기 타입으로 지정되었음을 확인할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_2.png" alt="image"></p>
<h2>b. 비동기 추론 호출</h2>
<p>단일 페이로드로 엔드포인트를 호출하려면 실시간 추론과 같이 "predict" 내장 메소드를 사용할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 단일 호출

payload = <span class="hljs-string">"미국의 수도는 어디인가요?"</span>
input_data = {
    <span class="hljs-string">"inputs"</span>: payload,
    <span class="hljs-string">"parameters"</span>: {
        <span class="hljs-string">"early_stopping"</span>: <span class="hljs-title class_">True</span>,
        <span class="hljs-string">"length_penalty"</span>: <span class="hljs-number">2.0</span>,
        <span class="hljs-string">"max_new_tokens"</span>: <span class="hljs-number">50</span>,
        <span class="hljs-string">"temperature"</span>: <span class="hljs-number">1</span>,
        <span class="hljs-string">"min_length"</span>: <span class="hljs-number">10</span>,
        <span class="hljs-string">"no_repeat_ngram_size"</span>: <span class="hljs-number">3</span>,
        },
}
predictor.<span class="hljs-title function_">predict</span>(input_data)
</code></pre>
<p>그러나 현실적인 사용 사례에 대한 비동기 추론을 확장하려면 S3에서 데이터로 엔드포인트를 호출할 수 있습니다. 비동기 추론의 아이디어는 여러 요청이 입력 S3 버킷에 저장되어 있고 호출은 각 데이터 포인트에 대한 결과와 해당하는 S3 출력 파일을 반환한다는 것입니다. 여기서 한 가지 더 강조하고 싶은 것은 전체 데이터 집합이 처리되고 요청에 의해 호출할 엔드포인트가 없는 Batch Transform과 다르다는 점입니다.</p>
<p>이제 우리는 이 데모를 위해 동일한 데이터포인트를 가진 가짜 데이터 집합을 만들어 S3로 옮기겠습니다. 다음 코드는 입력 파일을 포함하는 로컬 디렉터리를 생성합니다:</p>
<pre><code class="hljs language-py"><span class="hljs-keyword">import</span> json
<span class="hljs-keyword">import</span> os

output_directory = <span class="hljs-string">'inputs'</span>
os.makedirs(output_directory, exist_ok=<span class="hljs-literal">True</span>)

<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>):
    json_data = [input_data.copy()]

    file_path = os.path.join(output_directory, <span class="hljs-string">f'input_<span class="hljs-subst">{i}</span>.jsonl'</span>)
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> input_file:
        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> json_data:
            json.dump(line, input_file)
            input_file.write(<span class="hljs-string">'\n'</span>)
</code></pre>
<div class="content-ad"></div>
<p>이미 제공된 유틸리티 함수를 사용하여 로컬 파일을 S3에 업로드하여 추론할 수 있습니다.</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">upload_file</span>(input_location):
    prefix = f<span class="hljs-string">"{bucket_prefix}/input"</span>
    <span class="hljs-keyword">return</span> sagemaker_session.<span class="hljs-title function_">upload_data</span>(
        input_location,
        bucket=default_bucket,
        key_prefix=prefix,
        extra_args={<span class="hljs-string">"ContentType"</span>: <span class="hljs-string">"application/json"</span>} # 꼭 지정해야함
    )

sample_data_point = <span class="hljs-title function_">upload_file</span>(<span class="hljs-string">"inputs/input_1.jsonl"</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"샘플 데이터 포인트가 업로드되었습니다: {sample_data_point}"</span>)
</code></pre>
<p>그런 다음 Boto3 SDK를 통해 "invoke_endpoint_async" API 호출로이 S3 경로에서 샘플 추론을 실행할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> boto3
runtime = boto3.<span class="hljs-title function_">client</span>(<span class="hljs-string">"sagemaker-runtime"</span>)

response = runtime.<span class="hljs-title function_">invoke_endpoint_async</span>(
    <span class="hljs-title class_">EndpointName</span>=predictor.<span class="hljs-property">endpoint_name</span>,
    <span class="hljs-title class_">InputLocation</span>=sample_data_point,
    <span class="hljs-title class_">Accept</span>=<span class="hljs-string">'application/json'</span>,
    <span class="hljs-title class_">ContentType</span>=<span class="hljs-string">"application/json"</span>
)

output_location = response[<span class="hljs-string">"OutputLocation"</span>]
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"출력 위치: {output_location}"</span>)
</code></pre>
<div class="content-ad"></div>
<p>한 번 더 제공된 유틸리티 함수를 사용하여 출력 파일의 출력을 관찰합니다. LLM을 사용하여 실제 추론을 수행하고 S3 파일을 생성하는 데 시간이 걸릴 수 있습니다. 따라서 제공된 함수에서는 화면에 표시할 내용이 포함된 데이터 파일이 나타날 때까지 데이터 파일을 확인합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> urllib, time
<span class="hljs-keyword">from</span> botocore.<span class="hljs-property">exceptions</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">ClientError</span>

# 함수 참조/크레딧: <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/aws/amazon-sagemaker-examples/blob/main/async-inference/Async-Inference-Walkthrough-SageMaker-Python-SDK.ipynb</span>
def <span class="hljs-title function_">get_output</span>(output_location):
    output_url = urllib.<span class="hljs-property">parse</span>.<span class="hljs-title function_">urlparse</span>(output_location)
    bucket = output_url.<span class="hljs-property">netloc</span>
    key = output_url.<span class="hljs-property">path</span>[<span class="hljs-number">1</span>:]
    <span class="hljs-keyword">while</span> <span class="hljs-title class_">True</span>:
        <span class="hljs-attr">try</span>:
            <span class="hljs-keyword">return</span> sagemaker_session.<span class="hljs-title function_">read_s3_file</span>(bucket=output_url.<span class="hljs-property">netloc</span>, key_prefix=output_url.<span class="hljs-property">path</span>[<span class="hljs-number">1</span>:])
        except <span class="hljs-title class_">ClientError</span> <span class="hljs-keyword">as</span> <span class="hljs-attr">e</span>:
            <span class="hljs-keyword">if</span> e.<span class="hljs-property">response</span>[<span class="hljs-string">"Error"</span>][<span class="hljs-string">"Code"</span>] == <span class="hljs-string">"NoSuchKey"</span>:
                <span class="hljs-title function_">print</span>(<span class="hljs-string">"output을 기다리는 중..."</span>)
                time.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">60</span>)
                <span class="hljs-keyword">continue</span>
            raise

output = <span class="hljs-title function_">get_output</span>(output_location)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"Output: {output}"</span>)
</code></pre>
<p>그런 다음 모든 샘플 데이터 포인트를 실행하여 모든 입력 파일에서 추론을 수행할 수 있습니다:</p>
<pre><code class="hljs language-js">inferences = []
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>):
    input_file = f<span class="hljs-string">"inputs/input_{i}.jsonl"</span>
    input_file_s3_location = <span class="hljs-title function_">upload_file</span>(input_file)
    <span class="hljs-title function_">print</span>(f<span class="hljs-string">"{input_file}을 사용하여 Endpoint를 호출 중"</span>)
    async_response = predictor.<span class="hljs-title function_">predict_async</span>(input_path=input_file_s3_location)
    output_location = async_response.<span class="hljs-property">output_path</span>
    <span class="hljs-title function_">print</span>(output_location)
    inferences += [(input_file, output_location)]
    time.<span class="hljs-title function_">sleep</span>(<span class="hljs-number">0.5</span>)

<span class="hljs-keyword">for</span> input_file, output_location <span class="hljs-keyword">in</span> <span class="hljs-attr">inferences</span>:
    output = <span class="hljs-title function_">get_output</span>(output_location)
    <span class="hljs-title function_">print</span>(f<span class="hljs-string">"입력 파일: {input_file}, 출력: {output}"</span>)
</code></pre>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_3.png">
<h2>c. AutoScaling 설정</h2>
<p>비동기 추론에서 자동 스케일링은 실시간 추론과 마찬가지로 Application AutoScaling을 통해 설정됩니다. 이곳에서의 차이점은 스케일링할 수 있는 새로운 메트릭이 있다는 점입니다.</p>
<p>비동기 추론 내에서 이미 구현된 내부 대기열이 있음을 이해했듯이, 자동 스케일링은 이 대기열에 있는 항목의 수에 따라 확장하거나 축소할 수 있습니다. 이는 CloudWatch 메트릭 "ApproximateBackLogSize"로 캡처됩니다. 이 요청은 이미 처리 중인 것이거나 아직 처리되지 않은 것입니다.</p>
<div class="content-ad"></div>
<p>Real-Time Inference와 비슷한 방식으로 Boto3 SDK를 사용하여 정책을 설정했습니다. 최소 인스턴스 수를 0으로 정의했는데, 이 기능은 Asynchronous Inference에서만 지원됩니다.</p>
<pre><code class="hljs language-js">client = boto3.<span class="hljs-title function_">client</span>(
    <span class="hljs-string">"application-autoscaling"</span>
)  # <span class="hljs-title class_">SageMaker</span>를 포함한 다른 서비스의 <span class="hljs-title class_">Application</span> <span class="hljs-title class_">Auto</span> <span class="hljs-title class_">Scaling</span>을 나타내는 일반 클래스

resource_id = (
    <span class="hljs-string">"endpoint/"</span> + predictor.<span class="hljs-property">endpoint_name</span> + <span class="hljs-string">"/variant/"</span> + <span class="hljs-string">"AllTraffic"</span>
)  # application autoscaling이 엔드포인트를 참조하는 형식

# 비동기 엔드포인트에서 인스턴스 수를 <span class="hljs-number">0</span>으로 설정하여 <span class="hljs-title class_">Autoscaling</span> 구성
response = client.<span class="hljs-title function_">register_scalable_target</span>(
    <span class="hljs-title class_">ServiceNamespace</span>=<span class="hljs-string">"sagemaker"</span>,
    <span class="hljs-title class_">ResourceId</span>=resource_id,
    <span class="hljs-title class_">ScalableDimension</span>=<span class="hljs-string">"sagemaker:variant:DesiredInstanceCount"</span>,
    <span class="hljs-title class_">MinCapacity</span>=<span class="hljs-number">0</span>,
    <span class="hljs-title class_">MaxCapacity</span>=<span class="hljs-number">5</span>,
)
</code></pre>
<p>최소 및 최대 인스턴스 수를 지정한 후, 확장 및 축소에 대한 쿨다운 기간을 정의할 수 있습니다. 여기에서 "MetricName"을 "ApproximateBackLogSize" 메트릭으로 지정하였음을 알려드립니다.</p>
<pre><code class="hljs language-js">response = client.<span class="hljs-title function_">put_scaling_policy</span>(
    <span class="hljs-title class_">PolicyName</span>=<span class="hljs-string">"Invocations-ScalingPolicy"</span>,
    <span class="hljs-title class_">ServiceNamespace</span>=<span class="hljs-string">"sagemaker"</span>,  # 리소스를 제공하는 <span class="hljs-variable constant_">AWS</span> 서비스의 이름 공간
    <span class="hljs-title class_">ResourceId</span>=resource_id,  # 엔드포인트 이름
    <span class="hljs-title class_">ScalableDimension</span>=<span class="hljs-string">"sagemaker:variant:DesiredInstanceCount"</span>,  # <span class="hljs-title class_">SageMaker</span>는 인스턴스 수만 지원
    <span class="hljs-title class_">PolicyType</span>=<span class="hljs-string">"TargetTrackingScaling"</span>,  # <span class="hljs-string">'StepScaling'</span>|<span class="hljs-string">'TargetTrackingScaling'</span>
    <span class="hljs-title class_">TargetTrackingScalingPolicyConfiguration</span>={
        <span class="hljs-string">"TargetValue"</span>: <span class="hljs-number">5.0</span>,  # 메트릭의 목표 값 - 여기서 메트릭은 <span class="hljs-title class_">SageMakerVariantInvocationsPerInstance</span>입니다.
        <span class="hljs-string">"CustomizedMetricSpecification"</span>: {
            <span class="hljs-string">"MetricName"</span>: <span class="hljs-string">"ApproximateBacklogSizePerInstance"</span>,
            <span class="hljs-string">"Namespace"</span>: <span class="hljs-string">"AWS/SageMaker"</span>,
            <span class="hljs-string">"Dimensions"</span>: [{<span class="hljs-string">"Name"</span>: <span class="hljs-string">"EndpointName"</span>, <span class="hljs-string">"Value"</span>: predictor.<span class="hljs-property">endpoint_name</span>}],
            <span class="hljs-string">"Statistic"</span>: <span class="hljs-string">"Average"</span>,
        },
        <span class="hljs-string">"ScaleInCooldown"</span>: <span class="hljs-number">600</span>,  # 쿨다운 기간은 이전 작업의 영향이 나타나기 전에 추가 인스턴스를 시작하거나 종료하는 것을 방지합니다.
        <span class="hljs-string">"ScaleOutCooldown"</span>: <span class="hljs-number">100</span>,  # <span class="hljs-title class_">ScaleOutCooldown</span> - 확장 작업 완료 후 다른 확장 작업을 시작하기 전의 시간 간격.
    },
)
</code></pre>
<div class="content-ad"></div>
<p>AutoScaling을 테스트하려면 일정 기간 동안 요청을 보낼 수 있습니다. 스케일링 정책에 따르면 대상 값은 엔드포인트 뒤에 있는 큐에서 아직 처리 중이거나 처리되지 않은 요청 또는 호출을 5회로 설정됩니다.</p>
<pre><code class="hljs language-js">request_duration = <span class="hljs-number">60</span> * <span class="hljs-number">15</span> # <span class="hljs-number">15</span>분
end_time = time.<span class="hljs-title function_">time</span>() + request_duration
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"{request_duration}초 동안 테스트가 실행됩니다."</span>)
<span class="hljs-keyword">while</span> time.<span class="hljs-title function_">time</span>() &#x3C; <span class="hljs-attr">end_time</span>:
    predictor.<span class="hljs-title function_">predict</span>(input_data)
</code></pre>
<p>일정 시간 동안 요청을 보내지 않은 후에는 인스턴스 수가 제로로 축소되고, 큐가 완전히 비어 있는 것을 주의하세요:</p>
<p><img src="/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_4.png" alt="이미지"></p>
<div class="content-ad"></div>
<h1>3. 추가 자료 및 결론</h1>
<p>전체 예제 코드는 위 링크에서 찾을 수 있습니다. SageMaker 비동기 추론은 전적으로 실시간이나 일괄 처리가 아닌 특정 LLM 사용 사례에 사용할 수 있는 기능입니다. 이 기사가 귀하에게 LLM을 규모 확장하여 인퍼런스를 제공하는 다른 방법에 대한 유용한 소개였기를 바랍니다. 이 분야에서 더 많은 콘텐츠를 기대해 주세요!</p>
<p>항상 읽어 주셔서 감사합니다. 읽은 후 의견을 자유롭게 남겨 주세요.</p>
<p>이 기사를 즐겁게 보셨다면 LinkedIn에서 저와 연락하고 Medium 뉴스레터를 구독해 주시기 바랍니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SageMaker 비동기 추론으로 대형 언어 모델 배포하는 방법","description":"","date":"2024-06-23 19:59","slug":"2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference","content":"\n\n\u003cimg src=\"/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_0.png\" /\u003e\n\nLLM(대규모 언어 모델)은 인기를 얻고 있으며 이를 추측하는 방법도 늘어가고 있습니다. LLM 호스팅에는 모델의 크기와 배포된 하드웨어의 최적 사용을 보장해야 한다는 어려움이 잘 알려져 있습니다. LLM 사용 사례도 다양합니다. 어떤 것은 실시간 응답 시간이 필요할 수 있고, 다른 것은 거의 실시간 기반의 지연 시간 요구 사항일 수 있습니다.\n\n후자와 더 많은 오프라인 추측 사용 사례를 위해, SageMaker 비동기 추론이 좋은 옵션으로 제공됩니다. 비동기 추론에서는 이름에서 알 수 있듯이 지연 시간이 굉장히 엄격하지 않지만 필요에 따라 호출하고 확장할 수 있는 활성화된 엔드포인트가 필요합니다. 특히 LLM에서 이러한 유형의 작업 부하는 내용 편집/생성, 요약 등과 같은 사용 사례로 인해 점점 인기를 얻고 있습니다. 이러한 작업 부하들은 하위 초 단위 응답이 필요하지는 않지만 필요에 따라 호출할 수 있는 적시의 추론을 필요로 하며, SageMaker Batch Transform과 같은 완전히 오프라인적인 성격과는 대조적입니다.\n\n이 예시에서는 HuggingFace 텍스트 생성 추론 서버를 SageMaker 비동기 엔드포인트와 함께 사용하여 Flan-T-5-XXL 모델을 호스팅하는 방법을 살펴볼 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n참고: 본 글은 Python, LLMs 및 Amazon SageMaker에 대한 기본적인 이해를 전제로 합니다. Amazon SageMaker 추론을 시작하려면 다음 가이드를 참조해주세요. SageMaker 비동기 추론의 기초를 다룰 것이지만 더 깊은 소개를 원하시면 다음에 나오는 스타터 예제를 참조해주세요.\n\n공지: 저는 AWS의 머신 러닝 아키텍트이며, 이견은 제 개인적인 의견입니다.\n\n# 목차\n\n- SageMaker 비동기 추론을 사용하는 시점\n- TGI 비동기 추론 구현\n   a. 설정 및 엔드포인트 배포\n   b. 비동기 추론 호출\n   c. 자동 스케일링 설정\n- 추가 자료 및 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 1. SageMaker 비동기 추론 사용 시점\n\nSageMaker 추론은 현재 사용 사례에 따라 활용할 수 있는 네 가지 옵션이 있습니다. 세 가지 엔드포인트 기반 옵션이 있고 완전 오프라인 추론을 위한 한 가지 옵션이 있습니다:\n\n- 엔드포인트 기반 옵션:\n    - SageMaker 실시간 추론: 서브초/밀리초 응답 시간과 고 처리량 워크로드를 위한 옵션입니다. 이 엔드포인트는 CPU, GPU 또는 Inferentia 칩을 활용하며 하드웨어 단계에서 AutoScaling을 적용하여 인프라를 확장할 수 있습니다. 일반적인 사용 사례로는 Ad-Tech 기반 예측, 실시간 챗봇 등이 있습니다.\n    - SageMaker 서버리스 추론: 갑작스럽고 간헐적인 워크로드에 최적화되어 있으며 cold-start를 허용할 수 있는 옵션입니다 (Provisioned Concurrency를 통해 완화할 수 있음). 여기서는 엔드포인트 뒤에 있는 모든 인프라를 관리하지 않으며 확장은 자동으로 처리됩니다.\n    - SageMaker 비동기 추론: 오늘 다룰 옵션으로, 비동기 추론을 통해 거의 실시간 기반의 응답 시간 요구 사항을 충족하고 여전히 엔드포인트를 위해 정의한 전용 하드웨어를 사용합니다. 그러나 비동기 추론의 경우 실시간 추론과 달리 0 개의 인스턴스로 축소할 수 있는 옵션이 있습니다. 비동기 추론을 통해 내장 큐를 사용하여 요청을 관리하고이 큐의 가득 찬 정도에 따라 확장할 수 있습니다.\n\n- 오프라인 추론:\n    - SageMaker 배치 변환: 데이터셋이 있고 데이터셋으로 반환된 출력만 필요할 때 최적입니다. 영구적인 엔드포인트는 없으며 완전히 오프라인 추론입니다. 일반적인 사용 사례로는 특정 주기에 추론이 필요한 데이터셋이 있는 경우 일정 시간에 배치 변환 작업을 실행하는 것이 있습니다.\n\n이 사용 사례에서는 특히 비동기 추론에 초점을 맞추고 있습니다. 이 옵션은 거의 실시간 능력과 0 인스턴스로 축소할 수 있는 능력 때문에 Batch Transform과 Real-Time Inference 사이에서 결혼 생각할 수 있는 옵션입니다. 즉시 생성이 필요하지 않은 사용 사례를 위한 LLM을 호스팅하는 데 효율적인 방법으로 기능을 제공할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 사용 사례의 예시로는 요약, 콘텐츠 생성, 편집 등이 있습니다. 이러한 사용 사례는 모두 가변 시간에 activation이 필요할 수 있으므로 지속적인 엔드포인트가 필요하지만 실시간 추론의 응답 시간은 필요로 하지 않을 수도 있습니다. 비동기 추론을 통해 성능과 비용 측면에서 이러한 종류의 사용 사례들을 다룰 수 있습니다.\n\n오늘의 예시로, 우리는 인기 있는 Flan 모델을 SageMaker 비동기 추론에 적용해 보겠습니다. SageMaker 비동기 추론 엔드포인트를 생성하는 것은 실시간 엔드포인트 생성과 매우 유사합니다. 주요 차이점은 실시간 추론처럼 페이로드를 직접 전달하는 대신 입력 데이터에 대한 S3 경로가 필요하다는 점입니다.\n\n![이미지](/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_1.png)\n\n비동기 엔드포인트 내에는 내부 대기열도 있음을 유의해야 합니다. 모든 추론마다 SageMaker는 요청을 대기열에 넣고 결과 위치를 S3에 반환합니다. 비동기 엔드포인트에 대해 AutoScaling을 구성할 때 이 대기열 내의 요청 수에 따라 스케일을 조정할 수 있습니다. 또한 출력 S3 경로에서 직접 폴링하는 대신 성공 또는 오류 있는 추론 알림을 수신하기 위해 선택적으로 SNS 토픽을 통합할 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 비동기 추론에 대한 이해가 조금 더 깊어졌으니 구현부로 넘어가 봅시다!\n\n# 2. TGI 비동기 추론 구현\n\n우리는 새로운 SageMaker Studio 환경에서 Base Python3 커널과 ml.c5.xlarge 인스턴스로 작업할 것입니다. 비동기 추론을 위해 익숙한 Boto3 AWS Python SDK 및 상위 레벨 SageMaker Python SDK를 사용할 것입니다.\n\n## a. 설정 및 엔드포인트 배포\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n비동기 추론을 사용하려면 먼저 데이터가 저장될 출력 S3 경로를 정의해야 합니다.\n\n```js\nsagemaker_session = sagemaker.Session()\ndefault_bucket = sagemaker_session.default_bucket()\nbucket_prefix = \"async-llm-output\"\nasync_output_path = f\"s3://{default_bucket}/{bucket_prefix}/output\"\nprint(f\"내 모델 추론 결과는 다음 S3 경로에 저장될 것입니다: {async_output_path}\")\n```\n\n그런 다음 이 S3 경로를 사용하여 비동기 추론 구성을 지정할 수 있습니다. 이 경우 SNS 주제를 지정하지 않지만, 성공적이거나 오류가 발생했을 때 서비스를 통해 알림을받기를 원하는 경우 선택적으로 포함할 수 있습니다.\n\n```js\nfrom sagemaker.async_inference.async_inference_config import AsyncInferenceConfig\n\nasync_config = AsyncInferenceConfig(\n    output_path=async_output_path,\n    max_concurrent_invocations_per_instance=10,\n    # 선택적으로 Amazon SNS 주제 지정\n    # notification_config = {\n    # \"SuccessTopic\": \"arn:aws:sns:\u003caws-region\u003e:\u003caccount-id\u003e:\u003ctopic-name\u003e\",\n    # \"ErrorTopic\": \"arn:aws:sns:\u003caws-region\u003e:\u003caccount-id\u003e:\u003ctopic-name\u003e\",\n    # }\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 정의된 후에는 Flan T-5-XXL 모델을 위한 HuggingFace Hub 링크에서 SageMaker 코드를 직접 가져올 수 있습니다. 이 코드는 Text Generation Inference 모델 서버를 활용하며, Tensor Parallelism과 같은 내장 최적화가 포함되어 있습니다.\n\n```js\n# huggingface hub에서 배포 코드 직접 가져와서 비동기 구성 추가\nhub = {\n   'HF_MODEL_ID':'google/flan-t5-xxl',\n   'SM_NUM_GPUS': json.dumps(4)\n}\n\nhuggingface_model = HuggingFaceModel(\n   image_uri=get_huggingface_llm_image_uri(\"huggingface\",version=\"1.1.0\"),\n   env=hub,\n   role=role, \n)\r\n```\n\n그런 다음 SageMaker 모델 객체와 비동기 구성을 함께 사용하여 엔드포인트를 생성할 수 있습니다.\n\n```js\n# SageMaker 추론을 위해 모델 배포\npredictor = huggingface_model.deploy(\n initial_instance_count=1,\n instance_type=\"ml.g5.12xlarge\",\n container_startup_health_check_timeout=300,\n async_inference_config=async_config\n)\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n콘솔 또는 UI에서 엔드포인트가 비동기 타입으로 지정되었음을 확인할 수 있습니다.\n\n![image](/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_2.png)\n\n## b. 비동기 추론 호출\n\n단일 페이로드로 엔드포인트를 호출하려면 실시간 추론과 같이 \"predict\" 내장 메소드를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n# 단일 호출\n\npayload = \"미국의 수도는 어디인가요?\"\ninput_data = {\n    \"inputs\": payload,\n    \"parameters\": {\n        \"early_stopping\": True,\n        \"length_penalty\": 2.0,\n        \"max_new_tokens\": 50,\n        \"temperature\": 1,\n        \"min_length\": 10,\n        \"no_repeat_ngram_size\": 3,\n        },\n}\npredictor.predict(input_data)\r\n```\n\n그러나 현실적인 사용 사례에 대한 비동기 추론을 확장하려면 S3에서 데이터로 엔드포인트를 호출할 수 있습니다. 비동기 추론의 아이디어는 여러 요청이 입력 S3 버킷에 저장되어 있고 호출은 각 데이터 포인트에 대한 결과와 해당하는 S3 출력 파일을 반환한다는 것입니다. 여기서 한 가지 더 강조하고 싶은 것은 전체 데이터 집합이 처리되고 요청에 의해 호출할 엔드포인트가 없는 Batch Transform과 다르다는 점입니다.\n\n이제 우리는 이 데모를 위해 동일한 데이터포인트를 가진 가짜 데이터 집합을 만들어 S3로 옮기겠습니다. 다음 코드는 입력 파일을 포함하는 로컬 디렉터리를 생성합니다:\n\n```py\nimport json\nimport os\n\noutput_directory = 'inputs'\nos.makedirs(output_directory, exist_ok=True)\n\nfor i in range(1, 20):\n    json_data = [input_data.copy()]\n\n    file_path = os.path.join(output_directory, f'input_{i}.jsonl')\n    with open(file_path, 'w') as input_file:\n        for line in json_data:\n            json.dump(line, input_file)\n            input_file.write('\\n')\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이미 제공된 유틸리티 함수를 사용하여 로컬 파일을 S3에 업로드하여 추론할 수 있습니다.\n\n```js\ndef upload_file(input_location):\n    prefix = f\"{bucket_prefix}/input\"\n    return sagemaker_session.upload_data(\n        input_location,\n        bucket=default_bucket,\n        key_prefix=prefix,\n        extra_args={\"ContentType\": \"application/json\"} # 꼭 지정해야함\n    )\n\nsample_data_point = upload_file(\"inputs/input_1.jsonl\")\nprint(f\"샘플 데이터 포인트가 업로드되었습니다: {sample_data_point}\")\n```\n\n그런 다음 Boto3 SDK를 통해 \"invoke_endpoint_async\" API 호출로이 S3 경로에서 샘플 추론을 실행할 수 있습니다.\n\n```js\nimport boto3\nruntime = boto3.client(\"sagemaker-runtime\")\n\nresponse = runtime.invoke_endpoint_async(\n    EndpointName=predictor.endpoint_name,\n    InputLocation=sample_data_point,\n    Accept='application/json',\n    ContentType=\"application/json\"\n)\n\noutput_location = response[\"OutputLocation\"]\nprint(f\"출력 위치: {output_location}\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 번 더 제공된 유틸리티 함수를 사용하여 출력 파일의 출력을 관찰합니다. LLM을 사용하여 실제 추론을 수행하고 S3 파일을 생성하는 데 시간이 걸릴 수 있습니다. 따라서 제공된 함수에서는 화면에 표시할 내용이 포함된 데이터 파일이 나타날 때까지 데이터 파일을 확인합니다.\n\n```js\nimport urllib, time\nfrom botocore.exceptions import ClientError\n\n# 함수 참조/크레딧: https://github.com/aws/amazon-sagemaker-examples/blob/main/async-inference/Async-Inference-Walkthrough-SageMaker-Python-SDK.ipynb\ndef get_output(output_location):\n    output_url = urllib.parse.urlparse(output_location)\n    bucket = output_url.netloc\n    key = output_url.path[1:]\n    while True:\n        try:\n            return sagemaker_session.read_s3_file(bucket=output_url.netloc, key_prefix=output_url.path[1:])\n        except ClientError as e:\n            if e.response[\"Error\"][\"Code\"] == \"NoSuchKey\":\n                print(\"output을 기다리는 중...\")\n                time.sleep(60)\n                continue\n            raise\n\noutput = get_output(output_location)\nprint(f\"Output: {output}\")\n```\n\n그런 다음 모든 샘플 데이터 포인트를 실행하여 모든 입력 파일에서 추론을 수행할 수 있습니다:\n\n```js\ninferences = []\nfor i in range(1, 20):\n    input_file = f\"inputs/input_{i}.jsonl\"\n    input_file_s3_location = upload_file(input_file)\n    print(f\"{input_file}을 사용하여 Endpoint를 호출 중\")\n    async_response = predictor.predict_async(input_path=input_file_s3_location)\n    output_location = async_response.output_path\n    print(output_location)\n    inferences += [(input_file, output_location)]\n    time.sleep(0.5)\n\nfor input_file, output_location in inferences:\n    output = get_output(output_location)\n    print(f\"입력 파일: {input_file}, 출력: {output}\")\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_3.png\" /\u003e\n\n## c. AutoScaling 설정\n\n비동기 추론에서 자동 스케일링은 실시간 추론과 마찬가지로 Application AutoScaling을 통해 설정됩니다. 이곳에서의 차이점은 스케일링할 수 있는 새로운 메트릭이 있다는 점입니다.\n\n비동기 추론 내에서 이미 구현된 내부 대기열이 있음을 이해했듯이, 자동 스케일링은 이 대기열에 있는 항목의 수에 따라 확장하거나 축소할 수 있습니다. 이는 CloudWatch 메트릭 \"ApproximateBackLogSize\"로 캡처됩니다. 이 요청은 이미 처리 중인 것이거나 아직 처리되지 않은 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nReal-Time Inference와 비슷한 방식으로 Boto3 SDK를 사용하여 정책을 설정했습니다. 최소 인스턴스 수를 0으로 정의했는데, 이 기능은 Asynchronous Inference에서만 지원됩니다.\n\n```js\nclient = boto3.client(\n    \"application-autoscaling\"\n)  # SageMaker를 포함한 다른 서비스의 Application Auto Scaling을 나타내는 일반 클래스\n\nresource_id = (\n    \"endpoint/\" + predictor.endpoint_name + \"/variant/\" + \"AllTraffic\"\n)  # application autoscaling이 엔드포인트를 참조하는 형식\n\n# 비동기 엔드포인트에서 인스턴스 수를 0으로 설정하여 Autoscaling 구성\nresponse = client.register_scalable_target(\n    ServiceNamespace=\"sagemaker\",\n    ResourceId=resource_id,\n    ScalableDimension=\"sagemaker:variant:DesiredInstanceCount\",\n    MinCapacity=0,\n    MaxCapacity=5,\n)\n```\n\n최소 및 최대 인스턴스 수를 지정한 후, 확장 및 축소에 대한 쿨다운 기간을 정의할 수 있습니다. 여기에서 \"MetricName\"을 \"ApproximateBackLogSize\" 메트릭으로 지정하였음을 알려드립니다.\n\n```js\nresponse = client.put_scaling_policy(\n    PolicyName=\"Invocations-ScalingPolicy\",\n    ServiceNamespace=\"sagemaker\",  # 리소스를 제공하는 AWS 서비스의 이름 공간\n    ResourceId=resource_id,  # 엔드포인트 이름\n    ScalableDimension=\"sagemaker:variant:DesiredInstanceCount\",  # SageMaker는 인스턴스 수만 지원\n    PolicyType=\"TargetTrackingScaling\",  # 'StepScaling'|'TargetTrackingScaling'\n    TargetTrackingScalingPolicyConfiguration={\n        \"TargetValue\": 5.0,  # 메트릭의 목표 값 - 여기서 메트릭은 SageMakerVariantInvocationsPerInstance입니다.\n        \"CustomizedMetricSpecification\": {\n            \"MetricName\": \"ApproximateBacklogSizePerInstance\",\n            \"Namespace\": \"AWS/SageMaker\",\n            \"Dimensions\": [{\"Name\": \"EndpointName\", \"Value\": predictor.endpoint_name}],\n            \"Statistic\": \"Average\",\n        },\n        \"ScaleInCooldown\": 600,  # 쿨다운 기간은 이전 작업의 영향이 나타나기 전에 추가 인스턴스를 시작하거나 종료하는 것을 방지합니다.\n        \"ScaleOutCooldown\": 100,  # ScaleOutCooldown - 확장 작업 완료 후 다른 확장 작업을 시작하기 전의 시간 간격.\n    },\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nAutoScaling을 테스트하려면 일정 기간 동안 요청을 보낼 수 있습니다. 스케일링 정책에 따르면 대상 값은 엔드포인트 뒤에 있는 큐에서 아직 처리 중이거나 처리되지 않은 요청 또는 호출을 5회로 설정됩니다.\n\n```js\nrequest_duration = 60 * 15 # 15분\nend_time = time.time() + request_duration\nprint(f\"{request_duration}초 동안 테스트가 실행됩니다.\")\nwhile time.time() \u003c end_time:\n    predictor.predict(input_data)\n```\n\n일정 시간 동안 요청을 보내지 않은 후에는 인스턴스 수가 제로로 축소되고, 큐가 완전히 비어 있는 것을 주의하세요:\n\n![이미지](/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_4.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 3. 추가 자료 및 결론\n\n전체 예제 코드는 위 링크에서 찾을 수 있습니다. SageMaker 비동기 추론은 전적으로 실시간이나 일괄 처리가 아닌 특정 LLM 사용 사례에 사용할 수 있는 기능입니다. 이 기사가 귀하에게 LLM을 규모 확장하여 인퍼런스를 제공하는 다른 방법에 대한 유용한 소개였기를 바랍니다. 이 분야에서 더 많은 콘텐츠를 기대해 주세요!\n\n항상 읽어 주셔서 감사합니다. 읽은 후 의견을 자유롭게 남겨 주세요.\n\n이 기사를 즐겁게 보셨다면 LinkedIn에서 저와 연락하고 Medium 뉴스레터를 구독해 주시기 바랍니다.","ogImage":{"url":"/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_0.png"},"coverImage":"/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cimg src=\"/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_0.png\"\u003e\n\u003cp\u003eLLM(대규모 언어 모델)은 인기를 얻고 있으며 이를 추측하는 방법도 늘어가고 있습니다. LLM 호스팅에는 모델의 크기와 배포된 하드웨어의 최적 사용을 보장해야 한다는 어려움이 잘 알려져 있습니다. LLM 사용 사례도 다양합니다. 어떤 것은 실시간 응답 시간이 필요할 수 있고, 다른 것은 거의 실시간 기반의 지연 시간 요구 사항일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e후자와 더 많은 오프라인 추측 사용 사례를 위해, SageMaker 비동기 추론이 좋은 옵션으로 제공됩니다. 비동기 추론에서는 이름에서 알 수 있듯이 지연 시간이 굉장히 엄격하지 않지만 필요에 따라 호출하고 확장할 수 있는 활성화된 엔드포인트가 필요합니다. 특히 LLM에서 이러한 유형의 작업 부하는 내용 편집/생성, 요약 등과 같은 사용 사례로 인해 점점 인기를 얻고 있습니다. 이러한 작업 부하들은 하위 초 단위 응답이 필요하지는 않지만 필요에 따라 호출할 수 있는 적시의 추론을 필요로 하며, SageMaker Batch Transform과 같은 완전히 오프라인적인 성격과는 대조적입니다.\u003c/p\u003e\n\u003cp\u003e이 예시에서는 HuggingFace 텍스트 생성 추론 서버를 SageMaker 비동기 엔드포인트와 함께 사용하여 Flan-T-5-XXL 모델을 호스팅하는 방법을 살펴볼 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e참고: 본 글은 Python, LLMs 및 Amazon SageMaker에 대한 기본적인 이해를 전제로 합니다. Amazon SageMaker 추론을 시작하려면 다음 가이드를 참조해주세요. SageMaker 비동기 추론의 기초를 다룰 것이지만 더 깊은 소개를 원하시면 다음에 나오는 스타터 예제를 참조해주세요.\u003c/p\u003e\n\u003cp\u003e공지: 저는 AWS의 머신 러닝 아키텍트이며, 이견은 제 개인적인 의견입니다.\u003c/p\u003e\n\u003ch1\u003e목차\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eSageMaker 비동기 추론을 사용하는 시점\u003c/li\u003e\n\u003cli\u003eTGI 비동기 추론 구현\na. 설정 및 엔드포인트 배포\nb. 비동기 추론 호출\nc. 자동 스케일링 설정\u003c/li\u003e\n\u003cli\u003e추가 자료 및 결론\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e1. SageMaker 비동기 추론 사용 시점\u003c/h1\u003e\n\u003cp\u003eSageMaker 추론은 현재 사용 사례에 따라 활용할 수 있는 네 가지 옵션이 있습니다. 세 가지 엔드포인트 기반 옵션이 있고 완전 오프라인 추론을 위한 한 가지 옵션이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e엔드포인트 기반 옵션:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSageMaker 실시간 추론: 서브초/밀리초 응답 시간과 고 처리량 워크로드를 위한 옵션입니다. 이 엔드포인트는 CPU, GPU 또는 Inferentia 칩을 활용하며 하드웨어 단계에서 AutoScaling을 적용하여 인프라를 확장할 수 있습니다. 일반적인 사용 사례로는 Ad-Tech 기반 예측, 실시간 챗봇 등이 있습니다.\u003c/li\u003e\n\u003cli\u003eSageMaker 서버리스 추론: 갑작스럽고 간헐적인 워크로드에 최적화되어 있으며 cold-start를 허용할 수 있는 옵션입니다 (Provisioned Concurrency를 통해 완화할 수 있음). 여기서는 엔드포인트 뒤에 있는 모든 인프라를 관리하지 않으며 확장은 자동으로 처리됩니다.\u003c/li\u003e\n\u003cli\u003eSageMaker 비동기 추론: 오늘 다룰 옵션으로, 비동기 추론을 통해 거의 실시간 기반의 응답 시간 요구 사항을 충족하고 여전히 엔드포인트를 위해 정의한 전용 하드웨어를 사용합니다. 그러나 비동기 추론의 경우 실시간 추론과 달리 0 개의 인스턴스로 축소할 수 있는 옵션이 있습니다. 비동기 추론을 통해 내장 큐를 사용하여 요청을 관리하고이 큐의 가득 찬 정도에 따라 확장할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e오프라인 추론:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSageMaker 배치 변환: 데이터셋이 있고 데이터셋으로 반환된 출력만 필요할 때 최적입니다. 영구적인 엔드포인트는 없으며 완전히 오프라인 추론입니다. 일반적인 사용 사례로는 특정 주기에 추론이 필요한 데이터셋이 있는 경우 일정 시간에 배치 변환 작업을 실행하는 것이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 사용 사례에서는 특히 비동기 추론에 초점을 맞추고 있습니다. 이 옵션은 거의 실시간 능력과 0 인스턴스로 축소할 수 있는 능력 때문에 Batch Transform과 Real-Time Inference 사이에서 결혼 생각할 수 있는 옵션입니다. 즉시 생성이 필요하지 않은 사용 사례를 위한 LLM을 호스팅하는 데 효율적인 방법으로 기능을 제공할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이러한 사용 사례의 예시로는 요약, 콘텐츠 생성, 편집 등이 있습니다. 이러한 사용 사례는 모두 가변 시간에 activation이 필요할 수 있으므로 지속적인 엔드포인트가 필요하지만 실시간 추론의 응답 시간은 필요로 하지 않을 수도 있습니다. 비동기 추론을 통해 성능과 비용 측면에서 이러한 종류의 사용 사례들을 다룰 수 있습니다.\u003c/p\u003e\n\u003cp\u003e오늘의 예시로, 우리는 인기 있는 Flan 모델을 SageMaker 비동기 추론에 적용해 보겠습니다. SageMaker 비동기 추론 엔드포인트를 생성하는 것은 실시간 엔드포인트 생성과 매우 유사합니다. 주요 차이점은 실시간 추론처럼 페이로드를 직접 전달하는 대신 입력 데이터에 대한 S3 경로가 필요하다는 점입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e비동기 엔드포인트 내에는 내부 대기열도 있음을 유의해야 합니다. 모든 추론마다 SageMaker는 요청을 대기열에 넣고 결과 위치를 S3에 반환합니다. 비동기 엔드포인트에 대해 AutoScaling을 구성할 때 이 대기열 내의 요청 수에 따라 스케일을 조정할 수 있습니다. 또한 출력 S3 경로에서 직접 폴링하는 대신 성공 또는 오류 있는 추론 알림을 수신하기 위해 선택적으로 SNS 토픽을 통합할 수도 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 비동기 추론에 대한 이해가 조금 더 깊어졌으니 구현부로 넘어가 봅시다!\u003c/p\u003e\n\u003ch1\u003e2. TGI 비동기 추론 구현\u003c/h1\u003e\n\u003cp\u003e우리는 새로운 SageMaker Studio 환경에서 Base Python3 커널과 ml.c5.xlarge 인스턴스로 작업할 것입니다. 비동기 추론을 위해 익숙한 Boto3 AWS Python SDK 및 상위 레벨 SageMaker Python SDK를 사용할 것입니다.\u003c/p\u003e\n\u003ch2\u003ea. 설정 및 엔드포인트 배포\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e비동기 추론을 사용하려면 먼저 데이터가 저장될 출력 S3 경로를 정의해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esagemaker_session = sagemaker.\u003cspan class=\"hljs-title class_\"\u003eSession\u003c/span\u003e()\ndefault_bucket = sagemaker_session.\u003cspan class=\"hljs-title function_\"\u003edefault_bucket\u003c/span\u003e()\nbucket_prefix = \u003cspan class=\"hljs-string\"\u003e\"async-llm-output\"\u003c/span\u003e\nasync_output_path = f\u003cspan class=\"hljs-string\"\u003e\"s3://{default_bucket}/{bucket_prefix}/output\"\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"내 모델 추론 결과는 다음 S3 경로에 저장될 것입니다: {async_output_path}\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 이 S3 경로를 사용하여 비동기 추론 구성을 지정할 수 있습니다. 이 경우 SNS 주제를 지정하지 않지만, 성공적이거나 오류가 발생했을 때 서비스를 통해 알림을받기를 원하는 경우 선택적으로 포함할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sagemaker.\u003cspan class=\"hljs-property\"\u003easync_inference\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003easync_inference_config\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAsyncInferenceConfig\u003c/span\u003e\n\nasync_config = \u003cspan class=\"hljs-title class_\"\u003eAsyncInferenceConfig\u003c/span\u003e(\n    output_path=async_output_path,\n    max_concurrent_invocations_per_instance=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\n    # 선택적으로 \u003cspan class=\"hljs-title class_\"\u003eAmazon\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSNS\u003c/span\u003e 주제 지정\n    # notification_config = {\n    # \u003cspan class=\"hljs-string\"\u003e\"SuccessTopic\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"arn:aws:sns:\u0026#x3C;aws-region\u003e:\u0026#x3C;account-id\u003e:\u0026#x3C;topic-name\u003e\"\u003c/span\u003e,\n    # \u003cspan class=\"hljs-string\"\u003e\"ErrorTopic\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"arn:aws:sns:\u0026#x3C;aws-region\u003e:\u0026#x3C;account-id\u003e:\u0026#x3C;topic-name\u003e\"\u003c/span\u003e,\n    # }\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 정의된 후에는 Flan T-5-XXL 모델을 위한 HuggingFace Hub 링크에서 SageMaker 코드를 직접 가져올 수 있습니다. 이 코드는 Text Generation Inference 모델 서버를 활용하며, Tensor Parallelism과 같은 내장 최적화가 포함되어 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# huggingface hub에서 배포 코드 직접 가져와서 비동기 구성 추가\nhub = {\n   \u003cspan class=\"hljs-string\"\u003e'HF_MODEL_ID'\u003c/span\u003e:\u003cspan class=\"hljs-string\"\u003e'google/flan-t5-xxl'\u003c/span\u003e,\n   \u003cspan class=\"hljs-string\"\u003e'SM_NUM_GPUS'\u003c/span\u003e: json.\u003cspan class=\"hljs-title function_\"\u003edumps\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)\n}\n\nhuggingface_model = \u003cspan class=\"hljs-title class_\"\u003eHuggingFaceModel\u003c/span\u003e(\n   image_uri=\u003cspan class=\"hljs-title function_\"\u003eget_huggingface_llm_image_uri\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"huggingface\"\u003c/span\u003e,version=\u003cspan class=\"hljs-string\"\u003e\"1.1.0\"\u003c/span\u003e),\n   env=hub,\n   role=role, \n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 SageMaker 모델 객체와 비동기 구성을 함께 사용하여 엔드포인트를 생성할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eSageMaker\u003c/span\u003e 추론을 위해 모델 배포\npredictor = huggingface_model.\u003cspan class=\"hljs-title function_\"\u003edeploy\u003c/span\u003e(\n initial_instance_count=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n instance_type=\u003cspan class=\"hljs-string\"\u003e\"ml.g5.12xlarge\"\u003c/span\u003e,\n container_startup_health_check_timeout=\u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e,\n async_inference_config=async_config\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e콘솔 또는 UI에서 엔드포인트가 비동기 타입으로 지정되었음을 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003eb. 비동기 추론 호출\u003c/h2\u003e\n\u003cp\u003e단일 페이로드로 엔드포인트를 호출하려면 실시간 추론과 같이 \"predict\" 내장 메소드를 사용할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 단일 호출\n\npayload = \u003cspan class=\"hljs-string\"\u003e\"미국의 수도는 어디인가요?\"\u003c/span\u003e\ninput_data = {\n    \u003cspan class=\"hljs-string\"\u003e\"inputs\"\u003c/span\u003e: payload,\n    \u003cspan class=\"hljs-string\"\u003e\"parameters\"\u003c/span\u003e: {\n        \u003cspan class=\"hljs-string\"\u003e\"early_stopping\"\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"length_penalty\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"max_new_tokens\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"temperature\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"min_length\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"no_repeat_ngram_size\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\n        },\n}\npredictor.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(input_data)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 현실적인 사용 사례에 대한 비동기 추론을 확장하려면 S3에서 데이터로 엔드포인트를 호출할 수 있습니다. 비동기 추론의 아이디어는 여러 요청이 입력 S3 버킷에 저장되어 있고 호출은 각 데이터 포인트에 대한 결과와 해당하는 S3 출력 파일을 반환한다는 것입니다. 여기서 한 가지 더 강조하고 싶은 것은 전체 데이터 집합이 처리되고 요청에 의해 호출할 엔드포인트가 없는 Batch Transform과 다르다는 점입니다.\u003c/p\u003e\n\u003cp\u003e이제 우리는 이 데모를 위해 동일한 데이터포인트를 가진 가짜 데이터 집합을 만들어 S3로 옮기겠습니다. 다음 코드는 입력 파일을 포함하는 로컬 디렉터리를 생성합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-py\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e json\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e os\n\noutput_directory = \u003cspan class=\"hljs-string\"\u003e'inputs'\u003c/span\u003e\nos.makedirs(output_directory, exist_ok=\u003cspan class=\"hljs-literal\"\u003eTrue\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e):\n    json_data = [input_data.copy()]\n\n    file_path = os.path.join(output_directory, \u003cspan class=\"hljs-string\"\u003ef'input_\u003cspan class=\"hljs-subst\"\u003e{i}\u003c/span\u003e.jsonl'\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eopen\u003c/span\u003e(file_path, \u003cspan class=\"hljs-string\"\u003e'w'\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e input_file:\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e line \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e json_data:\n            json.dump(line, input_file)\n            input_file.write(\u003cspan class=\"hljs-string\"\u003e'\\n'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이미 제공된 유틸리티 함수를 사용하여 로컬 파일을 S3에 업로드하여 추론할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eupload_file\u003c/span\u003e(input_location):\n    prefix = f\u003cspan class=\"hljs-string\"\u003e\"{bucket_prefix}/input\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e sagemaker_session.\u003cspan class=\"hljs-title function_\"\u003eupload_data\u003c/span\u003e(\n        input_location,\n        bucket=default_bucket,\n        key_prefix=prefix,\n        extra_args={\u003cspan class=\"hljs-string\"\u003e\"ContentType\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e} # 꼭 지정해야함\n    )\n\nsample_data_point = \u003cspan class=\"hljs-title function_\"\u003eupload_file\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"inputs/input_1.jsonl\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"샘플 데이터 포인트가 업로드되었습니다: {sample_data_point}\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 Boto3 SDK를 통해 \"invoke_endpoint_async\" API 호출로이 S3 경로에서 샘플 추론을 실행할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e boto3\nruntime = boto3.\u003cspan class=\"hljs-title function_\"\u003eclient\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"sagemaker-runtime\"\u003c/span\u003e)\n\nresponse = runtime.\u003cspan class=\"hljs-title function_\"\u003einvoke_endpoint_async\u003c/span\u003e(\n    \u003cspan class=\"hljs-title class_\"\u003eEndpointName\u003c/span\u003e=predictor.\u003cspan class=\"hljs-property\"\u003eendpoint_name\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eInputLocation\u003c/span\u003e=sample_data_point,\n    \u003cspan class=\"hljs-title class_\"\u003eAccept\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e'application/json'\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eContentType\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"application/json\"\u003c/span\u003e\n)\n\noutput_location = response[\u003cspan class=\"hljs-string\"\u003e\"OutputLocation\"\u003c/span\u003e]\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"출력 위치: {output_location}\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e한 번 더 제공된 유틸리티 함수를 사용하여 출력 파일의 출력을 관찰합니다. LLM을 사용하여 실제 추론을 수행하고 S3 파일을 생성하는 데 시간이 걸릴 수 있습니다. 따라서 제공된 함수에서는 화면에 표시할 내용이 포함된 데이터 파일이 나타날 때까지 데이터 파일을 확인합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e urllib, time\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e botocore.\u003cspan class=\"hljs-property\"\u003eexceptions\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eClientError\u003c/span\u003e\n\n# 함수 참조/크레딧: \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//github.com/aws/amazon-sagemaker-examples/blob/main/async-inference/Async-Inference-Walkthrough-SageMaker-Python-SDK.ipynb\u003c/span\u003e\ndef \u003cspan class=\"hljs-title function_\"\u003eget_output\u003c/span\u003e(output_location):\n    output_url = urllib.\u003cspan class=\"hljs-property\"\u003eparse\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eurlparse\u003c/span\u003e(output_location)\n    bucket = output_url.\u003cspan class=\"hljs-property\"\u003enetloc\u003c/span\u003e\n    key = output_url.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:]\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e:\n        \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e sagemaker_session.\u003cspan class=\"hljs-title function_\"\u003eread_s3_file\u003c/span\u003e(bucket=output_url.\u003cspan class=\"hljs-property\"\u003enetloc\u003c/span\u003e, key_prefix=output_url.\u003cspan class=\"hljs-property\"\u003epath\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e:])\n        except \u003cspan class=\"hljs-title class_\"\u003eClientError\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ee\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e e.\u003cspan class=\"hljs-property\"\u003eresponse\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"Error\"\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e\"Code\"\u003c/span\u003e] == \u003cspan class=\"hljs-string\"\u003e\"NoSuchKey\"\u003c/span\u003e:\n                \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"output을 기다리는 중...\"\u003c/span\u003e)\n                time.\u003cspan class=\"hljs-title function_\"\u003esleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e)\n                \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e\n            raise\n\noutput = \u003cspan class=\"hljs-title function_\"\u003eget_output\u003c/span\u003e(output_location)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"Output: {output}\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 모든 샘플 데이터 포인트를 실행하여 모든 입력 파일에서 추론을 수행할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einferences = []\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e):\n    input_file = f\u003cspan class=\"hljs-string\"\u003e\"inputs/input_{i}.jsonl\"\u003c/span\u003e\n    input_file_s3_location = \u003cspan class=\"hljs-title function_\"\u003eupload_file\u003c/span\u003e(input_file)\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{input_file}을 사용하여 Endpoint를 호출 중\"\u003c/span\u003e)\n    async_response = predictor.\u003cspan class=\"hljs-title function_\"\u003epredict_async\u003c/span\u003e(input_path=input_file_s3_location)\n    output_location = async_response.\u003cspan class=\"hljs-property\"\u003eoutput_path\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(output_location)\n    inferences += [(input_file, output_location)]\n    time.\u003cspan class=\"hljs-title function_\"\u003esleep\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e input_file, output_location \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003einferences\u003c/span\u003e:\n    output = \u003cspan class=\"hljs-title function_\"\u003eget_output\u003c/span\u003e(output_location)\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"입력 파일: {input_file}, 출력: {output}\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_3.png\"\u003e\n\u003ch2\u003ec. AutoScaling 설정\u003c/h2\u003e\n\u003cp\u003e비동기 추론에서 자동 스케일링은 실시간 추론과 마찬가지로 Application AutoScaling을 통해 설정됩니다. 이곳에서의 차이점은 스케일링할 수 있는 새로운 메트릭이 있다는 점입니다.\u003c/p\u003e\n\u003cp\u003e비동기 추론 내에서 이미 구현된 내부 대기열이 있음을 이해했듯이, 자동 스케일링은 이 대기열에 있는 항목의 수에 따라 확장하거나 축소할 수 있습니다. 이는 CloudWatch 메트릭 \"ApproximateBackLogSize\"로 캡처됩니다. 이 요청은 이미 처리 중인 것이거나 아직 처리되지 않은 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eReal-Time Inference와 비슷한 방식으로 Boto3 SDK를 사용하여 정책을 설정했습니다. 최소 인스턴스 수를 0으로 정의했는데, 이 기능은 Asynchronous Inference에서만 지원됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eclient = boto3.\u003cspan class=\"hljs-title function_\"\u003eclient\u003c/span\u003e(\n    \u003cspan class=\"hljs-string\"\u003e\"application-autoscaling\"\u003c/span\u003e\n)  # \u003cspan class=\"hljs-title class_\"\u003eSageMaker\u003c/span\u003e를 포함한 다른 서비스의 \u003cspan class=\"hljs-title class_\"\u003eApplication\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAuto\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScaling\u003c/span\u003e을 나타내는 일반 클래스\n\nresource_id = (\n    \u003cspan class=\"hljs-string\"\u003e\"endpoint/\"\u003c/span\u003e + predictor.\u003cspan class=\"hljs-property\"\u003eendpoint_name\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e\"/variant/\"\u003c/span\u003e + \u003cspan class=\"hljs-string\"\u003e\"AllTraffic\"\u003c/span\u003e\n)  # application autoscaling이 엔드포인트를 참조하는 형식\n\n# 비동기 엔드포인트에서 인스턴스 수를 \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e으로 설정하여 \u003cspan class=\"hljs-title class_\"\u003eAutoscaling\u003c/span\u003e 구성\nresponse = client.\u003cspan class=\"hljs-title function_\"\u003eregister_scalable_target\u003c/span\u003e(\n    \u003cspan class=\"hljs-title class_\"\u003eServiceNamespace\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"sagemaker\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eResourceId\u003c/span\u003e=resource_id,\n    \u003cspan class=\"hljs-title class_\"\u003eScalableDimension\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"sagemaker:variant:DesiredInstanceCount\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eMinCapacity\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eMaxCapacity\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e최소 및 최대 인스턴스 수를 지정한 후, 확장 및 축소에 대한 쿨다운 기간을 정의할 수 있습니다. 여기에서 \"MetricName\"을 \"ApproximateBackLogSize\" 메트릭으로 지정하였음을 알려드립니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresponse = client.\u003cspan class=\"hljs-title function_\"\u003eput_scaling_policy\u003c/span\u003e(\n    \u003cspan class=\"hljs-title class_\"\u003ePolicyName\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"Invocations-ScalingPolicy\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-title class_\"\u003eServiceNamespace\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"sagemaker\"\u003c/span\u003e,  # 리소스를 제공하는 \u003cspan class=\"hljs-variable constant_\"\u003eAWS\u003c/span\u003e 서비스의 이름 공간\n    \u003cspan class=\"hljs-title class_\"\u003eResourceId\u003c/span\u003e=resource_id,  # 엔드포인트 이름\n    \u003cspan class=\"hljs-title class_\"\u003eScalableDimension\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"sagemaker:variant:DesiredInstanceCount\"\u003c/span\u003e,  # \u003cspan class=\"hljs-title class_\"\u003eSageMaker\u003c/span\u003e는 인스턴스 수만 지원\n    \u003cspan class=\"hljs-title class_\"\u003ePolicyType\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\"TargetTrackingScaling\"\u003c/span\u003e,  # \u003cspan class=\"hljs-string\"\u003e'StepScaling'\u003c/span\u003e|\u003cspan class=\"hljs-string\"\u003e'TargetTrackingScaling'\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eTargetTrackingScalingPolicyConfiguration\u003c/span\u003e={\n        \u003cspan class=\"hljs-string\"\u003e\"TargetValue\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5.0\u003c/span\u003e,  # 메트릭의 목표 값 - 여기서 메트릭은 \u003cspan class=\"hljs-title class_\"\u003eSageMakerVariantInvocationsPerInstance\u003c/span\u003e입니다.\n        \u003cspan class=\"hljs-string\"\u003e\"CustomizedMetricSpecification\"\u003c/span\u003e: {\n            \u003cspan class=\"hljs-string\"\u003e\"MetricName\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"ApproximateBacklogSizePerInstance\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"Namespace\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"AWS/SageMaker\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"Dimensions\"\u003c/span\u003e: [{\u003cspan class=\"hljs-string\"\u003e\"Name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"EndpointName\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Value\"\u003c/span\u003e: predictor.\u003cspan class=\"hljs-property\"\u003eendpoint_name\u003c/span\u003e}],\n            \u003cspan class=\"hljs-string\"\u003e\"Statistic\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"Average\"\u003c/span\u003e,\n        },\n        \u003cspan class=\"hljs-string\"\u003e\"ScaleInCooldown\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e600\u003c/span\u003e,  # 쿨다운 기간은 이전 작업의 영향이 나타나기 전에 추가 인스턴스를 시작하거나 종료하는 것을 방지합니다.\n        \u003cspan class=\"hljs-string\"\u003e\"ScaleOutCooldown\"\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e,  # \u003cspan class=\"hljs-title class_\"\u003eScaleOutCooldown\u003c/span\u003e - 확장 작업 완료 후 다른 확장 작업을 시작하기 전의 시간 간격.\n    },\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eAutoScaling을 테스트하려면 일정 기간 동안 요청을 보낼 수 있습니다. 스케일링 정책에 따르면 대상 값은 엔드포인트 뒤에 있는 큐에서 아직 처리 중이거나 처리되지 않은 요청 또는 호출을 5회로 설정됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003erequest_duration = \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e # \u003cspan class=\"hljs-number\"\u003e15\u003c/span\u003e분\nend_time = time.\u003cspan class=\"hljs-title function_\"\u003etime\u003c/span\u003e() + request_duration\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{request_duration}초 동안 테스트가 실행됩니다.\"\u003c/span\u003e)\n\u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e time.\u003cspan class=\"hljs-title function_\"\u003etime\u003c/span\u003e() \u0026#x3C; \u003cspan class=\"hljs-attr\"\u003eend_time\u003c/span\u003e:\n    predictor.\u003cspan class=\"hljs-title function_\"\u003epredict\u003c/span\u003e(input_data)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e일정 시간 동안 요청을 보내지 않은 후에는 인스턴스 수가 제로로 축소되고, 큐가 완전히 비어 있는 것을 주의하세요:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e3. 추가 자료 및 결론\u003c/h1\u003e\n\u003cp\u003e전체 예제 코드는 위 링크에서 찾을 수 있습니다. SageMaker 비동기 추론은 전적으로 실시간이나 일괄 처리가 아닌 특정 LLM 사용 사례에 사용할 수 있는 기능입니다. 이 기사가 귀하에게 LLM을 규모 확장하여 인퍼런스를 제공하는 다른 방법에 대한 유용한 소개였기를 바랍니다. 이 분야에서 더 많은 콘텐츠를 기대해 주세요!\u003c/p\u003e\n\u003cp\u003e항상 읽어 주셔서 감사합니다. 읽은 후 의견을 자유롭게 남겨 주세요.\u003c/p\u003e\n\u003cp\u003e이 기사를 즐겁게 보셨다면 LinkedIn에서 저와 연락하고 Medium 뉴스레터를 구독해 주시기 바랍니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-DeployingLargeLanguageModelswithSageMakerAsynchronousInference"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>