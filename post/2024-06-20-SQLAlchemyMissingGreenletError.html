<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SQLAlchemy MissingGreenletError | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-20-SQLAlchemyMissingGreenletError" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SQLAlchemy MissingGreenletError | itposting" data-gatsby-head="true"/><meta property="og:title" content="SQLAlchemy MissingGreenletError | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-SQLAlchemyMissingGreenletError_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-20-SQLAlchemyMissingGreenletError" data-gatsby-head="true"/><meta name="twitter:title" content="SQLAlchemy MissingGreenletError | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-SQLAlchemyMissingGreenletError_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 15:44" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_buildManifest.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SQLAlchemy MissingGreenletError</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SQLAlchemy MissingGreenletError" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-SQLAlchemyMissingGreenletError&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>SQLAlchemy은 Python을 위한 강력한 라이브러리로, Python 프로그램과 데이터베이스 간의 통신을 용이하게 해줍니다. 이는 고수준 ORM (객체-관계 매핑)과 저수준 SQL 표현 언어를 제공합니다. asyncio의 등장으로 SQLAlchemy는 비동기 작업을 지원하도록 도입되었는데, 이는 비동기 IO가 성능을 향상시킬 수 있는 웹 애플리케이션에 특히 유용합니다. SQLAlchemy에서의 MissingGreenletError는 SQLAlchemy가 asyncio나 다른 비동기 프레임워크와 함께 사용될 때 발생하는 일반적인 문제입니다. 이 오류는 SQLAlchemy의 기본 동작이 동기적이기 때문에 발생하며, 이는 데이터베이스 작업이 결과를 기다리는 동안 이벤트 루프를 차단한다는 것을 의미합니다.</p>
<p>이 오류의 근본 원인을 이해하기 위해서는 SQLAlchemy와 asyncio가 어떻게 함께 작동하는지 이해해야 합니다.</p>
<p>MissingGreenletError: 이 오류는 보통 비동기 컨텍스트 (예: async 함수 또는 코루틴 내부)에서 동기 작업(데이터베이스 작업)을 실행하려고 할 때 발생합니다. async 함수 내에서 동기 SQLAlchemy 함수나 메서드를 호출하면, 데이터베이스 작업이 완료될 때까지 이벤트 루프가 다른 작업으로 전환할 수 없습니다. 이는 이벤트 루프가 차단되어 응용 프로그램이 응답하지 않거나 성능 문제가 발생한다는 것을 의미합니다.</p>
<p>다음은 MissingGreenletError를 설명하는 예시입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">엔진: <span class="hljs-title class_">AsyncEngine</span> = <span class="hljs-title function_">create_async_engine</span>(<span class="hljs-variable constant_">DB_ENGINE</span>, echo=<span class="hljs-title class_">True</span>)

<span class="hljs-attr">async_session</span>: <span class="hljs-title class_">AsyncSession</span> = <span class="hljs-title function_">async_sessionmaker</span>(engine, expire_on_commit=<span class="hljs-title class_">False</span>)


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>(<span class="hljs-title class_">DeclarativeBase</span>):
    <span class="hljs-string">""</span><span class="hljs-string">"모든 ORM 모델을 위한 기본 클래스."</span><span class="hljs-string">""</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">PirateCrew</span>(<span class="hljs-title class_">Base</span>):
    <span class="hljs-string">""</span><span class="hljs-string">"해적 승무원의 세부 정보를 포함합니다."</span><span class="hljs-string">""</span>

    __tablename__ = <span class="hljs-string">"pirate_crew"</span>

    <span class="hljs-attr">id</span>: <span class="hljs-title class_">Mapped</span>[int] = <span class="hljs-title function_">mapped_column</span>(primary_key=<span class="hljs-title class_">True</span>)
    <span class="hljs-attr">name</span>: <span class="hljs-title class_">Mapped</span>[str]
    <span class="hljs-attr">ship_name</span>: <span class="hljs-title class_">Mapped</span>[str]
    <span class="hljs-attr">members</span>: <span class="hljs-title class_">Mapped</span>[<span class="hljs-title class_">List</span>[<span class="hljs-string">"Pirate"</span>]] = <span class="hljs-title function_">relationship</span>(back_populates=<span class="hljs-string">"pirate_crew"</span>)

    def <span class="hljs-title function_">__repr__</span>(self) -> <span class="hljs-attr">str</span>:
        <span class="hljs-string">""</span><span class="hljs-string">"객체의 표현을 반환합니다."</span><span class="hljs-string">""</span>
        <span class="hljs-keyword">return</span> f<span class="hljs-string">"{self.__class__.name}({self.name})"</span>


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Pirate</span>(<span class="hljs-title class_">Base</span>):
    <span class="hljs-string">""</span><span class="hljs-string">"해적의 세부 정보를 포함합니다."</span><span class="hljs-string">""</span>

    __tablename__ = <span class="hljs-string">"pirates"</span>

    <span class="hljs-attr">id</span>: <span class="hljs-title class_">Mapped</span>[int] = <span class="hljs-title function_">mapped_column</span>(primary_key=<span class="hljs-title class_">True</span>)
    <span class="hljs-attr">name</span>: <span class="hljs-title class_">Mapped</span>[str]
    <span class="hljs-attr">role</span>: <span class="hljs-title class_">Mapped</span>[str]
    <span class="hljs-attr">devil_fruit_user</span>: <span class="hljs-title class_">Mapped</span>[bool]
    pirate_crew_id = <span class="hljs-title function_">mapped_column</span>(<span class="hljs-title class_">ForeignKey</span>(<span class="hljs-string">"pirate_crew.id"</span>))
    <span class="hljs-attr">pirate_crew</span>: <span class="hljs-title class_">Mapped</span>[<span class="hljs-string">"PirateCrew"</span>] = <span class="hljs-title function_">relationship</span>(back_populates=<span class="hljs-string">"members"</span>)

    def <span class="hljs-title function_">__repr__</span>(self) -> <span class="hljs-attr">str</span>:
        <span class="hljs-string">""</span><span class="hljs-string">"객체의 표현을 반환합니다."</span><span class="hljs-string">""</span>
        <span class="hljs-keyword">return</span> f<span class="hljs-string">"{self.__class__.name}({self.name})"</span>


<span class="hljs-keyword">async</span> def <span class="hljs-title function_">create_tables</span>():
    <span class="hljs-string">""</span><span class="hljs-string">"모든 테이블을 생성하는 메서드입니다."</span><span class="hljs-string">""</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> engine.<span class="hljs-title function_">begin</span>() <span class="hljs-keyword">as</span> <span class="hljs-attr">connection</span>:
        <span class="hljs-keyword">await</span> connection.<span class="hljs-title function_">run_sync</span>(<span class="hljs-title class_">Base</span>.<span class="hljs-property">metadata</span>.<span class="hljs-property">create_all</span>)


<span class="hljs-keyword">async</span> def <span class="hljs-title function_">db_seeder</span>():
    <span class="hljs-string">""</span><span class="hljs-string">"PirateCrew 및 Pirate 테이블에 데이터를 시드하는 시더입니다."</span><span class="hljs-string">""</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> <span class="hljs-title function_">async_session</span>() <span class="hljs-keyword">as</span> <span class="hljs-attr">session</span>:
        mugiwara = <span class="hljs-title class_">PirateCrew</span>(name=<span class="hljs-string">"Straw Hats"</span>, ship_name=<span class="hljs-string">"Thousand Sunny"</span>)
        mugiwara_members = [
            <span class="hljs-title class_">Pirate</span>(
                name=<span class="hljs-string">"Monkey D Luffy"</span>,
                role=<span class="hljs-string">"Captain"</span>,
                devil_fruit_user=<span class="hljs-title class_">True</span>,
                pirate_crew=mugiwara,
            ),
            <span class="hljs-title class_">Pirate</span>(
                name=<span class="hljs-string">"Roronoa Zoro"</span>,
                role=<span class="hljs-string">"First Mate"</span>,
                devil_fruit_user=<span class="hljs-title class_">False</span>,
                pirate_crew=mugiwara,
            ),
            <span class="hljs-title class_">Pirate</span>(
                name=<span class="hljs-string">"Nami"</span>,
                role=<span class="hljs-string">"Navigator"</span>,
                devil_fruit_user=<span class="hljs-title class_">False</span>,
                pirate_crew=mugiwara,
            ),
        ]
        session.<span class="hljs-title function_">add</span>(mugiwara)
        session.<span class="hljs-title function_">add_all</span>(mugiwara_members)
        <span class="hljs-keyword">await</span> session.<span class="hljs-title function_">commit</span>()
</code></pre>
<p>따라서 여기에서 우리는 PirateCrew와 Pirate 두 개의 테이블을 만들었습니다. Pirate와 PirateCrew 테이블 사이에 일대다 관계가 있음을 알 수 있습니다. 또한 데이터베이스에 테이블을 생성하고 일부 데이터로 씨드하는 두 개의 비동기 함수가 있습니다.</p>
<p>이제 MissingGreenletError를 살펴보겠습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> def <span class="hljs-title function_">missing_greenlet_error</span>():
    <span class="hljs-string">""</span><span class="hljs-string">"MissingGreenletError 예제입니다."</span><span class="hljs-string">""</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> <span class="hljs-title function_">async_session</span>() <span class="hljs-keyword">as</span> <span class="hljs-attr">session</span>:
        pirate_crew = (<span class="hljs-keyword">await</span> session.<span class="hljs-title function_">execute</span>(<span class="hljs-title function_">select</span>(<span class="hljs-title class_">PirateCrew</span>))).<span class="hljs-title function_">all</span>()[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
        # 이제 해적 승무원의 멤버에 액세스하려고 시도해 보겠습니다 (members는 관련된 객체입니다).
        members = pirate_crew.<span class="hljs-property">members</span>
        <span class="hljs-title function_">print</span>(members)
</code></pre>
<div class="content-ad"></div>
<p>이 함수를 실행하면 콘솔에서 다음과 같은 오류가 발생합니다.</p>
<pre><code class="hljs language-js">sqlalchemy.<span class="hljs-property">exc</span>.<span class="hljs-property">MissingGreenlet</span>: greenlet_spawn has not been called; can<span class="hljs-string">'t call await_only() here. Was IO attempted in an unexpected place? (Background on this error at: https://sqlalche.me/e/20/xd2s)
</span></code></pre>
<p>이 오류는 members 속성이 관계 속성이기 때문에 발생합니다. SQLAlchemy의 기본 동작은 관련된 객체를 동기적으로 게으르게 로드하는 것입니다. members 속성에 액세스할 때 SQLAlchemy가 관련 Pirate 객체를 동기적으로 로드하려고 하면, 이는 비동기 함수와 호환되지 않습니다. 동기적으로 작동하는 SQLAlchemy가 기대하는 것은 동기 작업에 대해 사용 가능한 greenlet이 있기 때문에 MissingGreenletError가 발생하게 되는 것입니다. 그러나 비동기적인 컨텍스트에서는 greenlet은 사용할 수 없습니다.</p>
<p>이와 같은 상황에서 MissingGreenletError를 피하려면 두 가지 옵션이 있습니다.</p>
<div class="content-ad"></div>
<ul>
<li>관련 객체를 초기 쿼리에서 함께 로드하려면</li>
<li>AsyncAttrs</li>
</ul>
<p>Eager load 접근 방식: Eager loading은 SQLAlchemy와 같은 객체-관계 매핑(ORM) 라이브러리에서 사용되는 기술로, 부모 객체와 관련된 객체를 동일한 쿼리에서 로드하여 필요할 때 게으르게로 로드하는 것이 아니라 한 번에 로드합니다. 이 방식은 관련 객체를 비동기적으로 처리할 때 MissingGreenletError를 피하는 데 도움이 될 수 있습니다.</p>
<p>다음은 Eager load 방식으로 MissingGreenletError를 해결하는 예시입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">async</span> def loading_techniques로 수정해주세요():
    <span class="hljs-string">""</span><span class="hljs-string">"로딩 기술을 사용하여 MissingGreenletError를 해결하는 예시."</span><span class="hljs-string">""</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> <span class="hljs-title function_">async_session</span>() <span class="hljs-keyword">as</span> <span class="hljs-attr">session</span>:
        pirate_crew = (
            <span class="hljs-keyword">await</span> session.<span class="hljs-title function_">execute</span>(
                <span class="hljs-title function_">select</span>(<span class="hljs-title class_">PirateCrew</span>).<span class="hljs-title function_">options</span>(<span class="hljs-title function_">selectinload</span>(<span class="hljs-title class_">PirateCrew</span>.<span class="hljs-property">members</span>))
            )
        ).<span class="hljs-title function_">all</span>()[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
        # 이곳에서 <span class="hljs-title function_">selectinload</span>()를 사용하여 <span class="hljs-title class_">Pirate</span> <span class="hljs-title class_">Table</span>을 조인했습니다
        members = pirate_crew.<span class="hljs-property">members</span>
        <span class="hljs-title function_">print</span>(members)
</code></pre>
<div class="content-ad"></div>
<p>여기서 selectinload() 로더 전략을 사용하여 관련된 객체를 즉시 로드했습니다. 더 자세한 설명은 이전 게시물을 참고해주세요,</p>
<p>AsyncAttrs: AsyncAttrs은 SQLAlchemy에서 제공하는 내장 mixin으로, awaitable_attrs 엑세서를 소개하여 어떤 속성도 awaitable로 취급할 수 있게 하며, 관련된 객체 또는 다른 속성에 대한 비동기 로딩 및 액세스를 용이하게 합니다.</p>
<p>다음은 AsyncAttrs를 사용하여 MissingGreenletError를 해결하는 예시입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>(<span class="hljs-title class_">DeclarativeBase</span>, <span class="hljs-title class_">AsyncAttrs</span>):
    <span class="hljs-string">""</span><span class="hljs-string">"모든 ORM 모델의 기본 클래스"</span><span class="hljs-string">""</span>

<span class="hljs-keyword">async</span> def <span class="hljs-title function_">fix_with_async_attrs</span>():
    <span class="hljs-string">""</span><span class="hljs-string">"AsyncAttrs로 MissingGreenletError를 해결하는 예시"</span><span class="hljs-string">""</span>
    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> <span class="hljs-title function_">async_session</span>() <span class="hljs-keyword">as</span> <span class="hljs-attr">session</span>:
        pirate_crew = (<span class="hljs-keyword">await</span> session.<span class="hljs-title function_">execute</span>(<span class="hljs-title function_">select</span>(<span class="hljs-title class_">PirateCrew</span>))).<span class="hljs-title function_">all</span>()[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]
        members = <span class="hljs-keyword">await</span> pirate_crew.<span class="hljs-property">awaitable_attrs</span>.<span class="hljs-property">members</span>
        <span class="hljs-title function_">print</span>(members)
</code></pre>
<div class="content-ad"></div>
<p>여기서 우리는 AsyncAttrs를 Base 클래스에 추가했습니다. 이제 awaitable_attrs 액세서를 사용하여 관련 객체에 액세스할 수 있습니다. AsyncAttrs를 추가함으로써 이제 pirate_crew.members에 직접 액세스하는 대신 pirate_crew.awaitable_attrs.members를 사용할 수 있습니다. awaitable_attrs 부분은 SQLAlchemy에게 관련 Pirate 객체를 블로킹하지 않고 비동기적으로 로드하도록 지시합니다.</p>
<p>참고: AsyncAttrs은 MissingGreenletError를 피하는 데 도움이 되지만 N+1 쿼리 문제나 불필요한 데이터 로딩과 같은 다른 잠재적인 문제를 반드시 예방하는 것은 아닙니다. 여전히 적절한 로딩 전략(예: joinedload 또는 selectinload)을 사용하고 데이터 액세스 패턴을 신중히 고려하여 성능을 최적화하고 불필요한 부하를 피하는 것이 좋습니다.</p>
<p>참고 자료:</p>
<p>코드 참조:</p>
<div class="content-ad"></div>
<p><a href="https://github.com/vickypalani/sqlalchemy_missing_greenlet_error" rel="nofollow" target="_blank">https://github.com/vickypalani/sqlalchemy_missing_greenlet_error</a></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SQLAlchemy MissingGreenletError","description":"","date":"2024-06-20 15:44","slug":"2024-06-20-SQLAlchemyMissingGreenletError","content":"\n\nSQLAlchemy은 Python을 위한 강력한 라이브러리로, Python 프로그램과 데이터베이스 간의 통신을 용이하게 해줍니다. 이는 고수준 ORM (객체-관계 매핑)과 저수준 SQL 표현 언어를 제공합니다. asyncio의 등장으로 SQLAlchemy는 비동기 작업을 지원하도록 도입되었는데, 이는 비동기 IO가 성능을 향상시킬 수 있는 웹 애플리케이션에 특히 유용합니다. SQLAlchemy에서의 MissingGreenletError는 SQLAlchemy가 asyncio나 다른 비동기 프레임워크와 함께 사용될 때 발생하는 일반적인 문제입니다. 이 오류는 SQLAlchemy의 기본 동작이 동기적이기 때문에 발생하며, 이는 데이터베이스 작업이 결과를 기다리는 동안 이벤트 루프를 차단한다는 것을 의미합니다.\n\n이 오류의 근본 원인을 이해하기 위해서는 SQLAlchemy와 asyncio가 어떻게 함께 작동하는지 이해해야 합니다.\n\nMissingGreenletError: 이 오류는 보통 비동기 컨텍스트 (예: async 함수 또는 코루틴 내부)에서 동기 작업(데이터베이스 작업)을 실행하려고 할 때 발생합니다. async 함수 내에서 동기 SQLAlchemy 함수나 메서드를 호출하면, 데이터베이스 작업이 완료될 때까지 이벤트 루프가 다른 작업으로 전환할 수 없습니다. 이는 이벤트 루프가 차단되어 응용 프로그램이 응답하지 않거나 성능 문제가 발생한다는 것을 의미합니다.\n\n다음은 MissingGreenletError를 설명하는 예시입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n엔진: AsyncEngine = create_async_engine(DB_ENGINE, echo=True)\n\nasync_session: AsyncSession = async_sessionmaker(engine, expire_on_commit=False)\n\n\nclass Base(DeclarativeBase):\n    \"\"\"모든 ORM 모델을 위한 기본 클래스.\"\"\"\n\n\nclass PirateCrew(Base):\n    \"\"\"해적 승무원의 세부 정보를 포함합니다.\"\"\"\n\n    __tablename__ = \"pirate_crew\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    ship_name: Mapped[str]\n    members: Mapped[List[\"Pirate\"]] = relationship(back_populates=\"pirate_crew\")\n\n    def __repr__(self) -\u003e str:\n        \"\"\"객체의 표현을 반환합니다.\"\"\"\n        return f\"{self.__class__.name}({self.name})\"\n\n\nclass Pirate(Base):\n    \"\"\"해적의 세부 정보를 포함합니다.\"\"\"\n\n    __tablename__ = \"pirates\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    role: Mapped[str]\n    devil_fruit_user: Mapped[bool]\n    pirate_crew_id = mapped_column(ForeignKey(\"pirate_crew.id\"))\n    pirate_crew: Mapped[\"PirateCrew\"] = relationship(back_populates=\"members\")\n\n    def __repr__(self) -\u003e str:\n        \"\"\"객체의 표현을 반환합니다.\"\"\"\n        return f\"{self.__class__.name}({self.name})\"\n\n\nasync def create_tables():\n    \"\"\"모든 테이블을 생성하는 메서드입니다.\"\"\"\n    async with engine.begin() as connection:\n        await connection.run_sync(Base.metadata.create_all)\n\n\nasync def db_seeder():\n    \"\"\"PirateCrew 및 Pirate 테이블에 데이터를 시드하는 시더입니다.\"\"\"\n    async with async_session() as session:\n        mugiwara = PirateCrew(name=\"Straw Hats\", ship_name=\"Thousand Sunny\")\n        mugiwara_members = [\n            Pirate(\n                name=\"Monkey D Luffy\",\n                role=\"Captain\",\n                devil_fruit_user=True,\n                pirate_crew=mugiwara,\n            ),\n            Pirate(\n                name=\"Roronoa Zoro\",\n                role=\"First Mate\",\n                devil_fruit_user=False,\n                pirate_crew=mugiwara,\n            ),\n            Pirate(\n                name=\"Nami\",\n                role=\"Navigator\",\n                devil_fruit_user=False,\n                pirate_crew=mugiwara,\n            ),\n        ]\n        session.add(mugiwara)\n        session.add_all(mugiwara_members)\n        await session.commit()\r\n```\n\n따라서 여기에서 우리는 PirateCrew와 Pirate 두 개의 테이블을 만들었습니다. Pirate와 PirateCrew 테이블 사이에 일대다 관계가 있음을 알 수 있습니다. 또한 데이터베이스에 테이블을 생성하고 일부 데이터로 씨드하는 두 개의 비동기 함수가 있습니다.\n\n이제 MissingGreenletError를 살펴보겠습니다.\n\n```js\nasync def missing_greenlet_error():\n    \"\"\"MissingGreenletError 예제입니다.\"\"\"\n    async with async_session() as session:\n        pirate_crew = (await session.execute(select(PirateCrew))).all()[0][0]\n        # 이제 해적 승무원의 멤버에 액세스하려고 시도해 보겠습니다 (members는 관련된 객체입니다).\n        members = pirate_crew.members\n        print(members)\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 함수를 실행하면 콘솔에서 다음과 같은 오류가 발생합니다.\n\n```js\nsqlalchemy.exc.MissingGreenlet: greenlet_spawn has not been called; can't call await_only() here. Was IO attempted in an unexpected place? (Background on this error at: https://sqlalche.me/e/20/xd2s)\n```\n\n이 오류는 members 속성이 관계 속성이기 때문에 발생합니다. SQLAlchemy의 기본 동작은 관련된 객체를 동기적으로 게으르게 로드하는 것입니다. members 속성에 액세스할 때 SQLAlchemy가 관련 Pirate 객체를 동기적으로 로드하려고 하면, 이는 비동기 함수와 호환되지 않습니다. 동기적으로 작동하는 SQLAlchemy가 기대하는 것은 동기 작업에 대해 사용 가능한 greenlet이 있기 때문에 MissingGreenletError가 발생하게 되는 것입니다. 그러나 비동기적인 컨텍스트에서는 greenlet은 사용할 수 없습니다.\n\n이와 같은 상황에서 MissingGreenletError를 피하려면 두 가지 옵션이 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 관련 객체를 초기 쿼리에서 함께 로드하려면\n- AsyncAttrs\n\nEager load 접근 방식: Eager loading은 SQLAlchemy와 같은 객체-관계 매핑(ORM) 라이브러리에서 사용되는 기술로, 부모 객체와 관련된 객체를 동일한 쿼리에서 로드하여 필요할 때 게으르게로 로드하는 것이 아니라 한 번에 로드합니다. 이 방식은 관련 객체를 비동기적으로 처리할 때 MissingGreenletError를 피하는 데 도움이 될 수 있습니다.\n\n다음은 Eager load 방식으로 MissingGreenletError를 해결하는 예시입니다.\n\n```js\nasync def loading_techniques로 수정해주세요():\n    \"\"\"로딩 기술을 사용하여 MissingGreenletError를 해결하는 예시.\"\"\"\n    async with async_session() as session:\n        pirate_crew = (\n            await session.execute(\n                select(PirateCrew).options(selectinload(PirateCrew.members))\n            )\n        ).all()[0][0]\n        # 이곳에서 selectinload()를 사용하여 Pirate Table을 조인했습니다\n        members = pirate_crew.members\n        print(members)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 selectinload() 로더 전략을 사용하여 관련된 객체를 즉시 로드했습니다. 더 자세한 설명은 이전 게시물을 참고해주세요,\n\nAsyncAttrs: AsyncAttrs은 SQLAlchemy에서 제공하는 내장 mixin으로, awaitable_attrs 엑세서를 소개하여 어떤 속성도 awaitable로 취급할 수 있게 하며, 관련된 객체 또는 다른 속성에 대한 비동기 로딩 및 액세스를 용이하게 합니다.\n\n다음은 AsyncAttrs를 사용하여 MissingGreenletError를 해결하는 예시입니다.\n\n```js\nclass Base(DeclarativeBase, AsyncAttrs):\n    \"\"\"모든 ORM 모델의 기본 클래스\"\"\"\n\nasync def fix_with_async_attrs():\n    \"\"\"AsyncAttrs로 MissingGreenletError를 해결하는 예시\"\"\"\n    async with async_session() as session:\n        pirate_crew = (await session.execute(select(PirateCrew))).all()[0][0]\n        members = await pirate_crew.awaitable_attrs.members\n        print(members)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n여기서 우리는 AsyncAttrs를 Base 클래스에 추가했습니다. 이제 awaitable_attrs 액세서를 사용하여 관련 객체에 액세스할 수 있습니다. AsyncAttrs를 추가함으로써 이제 pirate_crew.members에 직접 액세스하는 대신 pirate_crew.awaitable_attrs.members를 사용할 수 있습니다. awaitable_attrs 부분은 SQLAlchemy에게 관련 Pirate 객체를 블로킹하지 않고 비동기적으로 로드하도록 지시합니다.\n\n참고: AsyncAttrs은 MissingGreenletError를 피하는 데 도움이 되지만 N+1 쿼리 문제나 불필요한 데이터 로딩과 같은 다른 잠재적인 문제를 반드시 예방하는 것은 아닙니다. 여전히 적절한 로딩 전략(예: joinedload 또는 selectinload)을 사용하고 데이터 액세스 패턴을 신중히 고려하여 성능을 최적화하고 불필요한 부하를 피하는 것이 좋습니다.\n\n참고 자료:\n\n코드 참조:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nhttps://github.com/vickypalani/sqlalchemy_missing_greenlet_error","ogImage":{"url":"/assets/img/2024-06-20-SQLAlchemyMissingGreenletError_0.png"},"coverImage":"/assets/img/2024-06-20-SQLAlchemyMissingGreenletError_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003eSQLAlchemy은 Python을 위한 강력한 라이브러리로, Python 프로그램과 데이터베이스 간의 통신을 용이하게 해줍니다. 이는 고수준 ORM (객체-관계 매핑)과 저수준 SQL 표현 언어를 제공합니다. asyncio의 등장으로 SQLAlchemy는 비동기 작업을 지원하도록 도입되었는데, 이는 비동기 IO가 성능을 향상시킬 수 있는 웹 애플리케이션에 특히 유용합니다. SQLAlchemy에서의 MissingGreenletError는 SQLAlchemy가 asyncio나 다른 비동기 프레임워크와 함께 사용될 때 발생하는 일반적인 문제입니다. 이 오류는 SQLAlchemy의 기본 동작이 동기적이기 때문에 발생하며, 이는 데이터베이스 작업이 결과를 기다리는 동안 이벤트 루프를 차단한다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e이 오류의 근본 원인을 이해하기 위해서는 SQLAlchemy와 asyncio가 어떻게 함께 작동하는지 이해해야 합니다.\u003c/p\u003e\n\u003cp\u003eMissingGreenletError: 이 오류는 보통 비동기 컨텍스트 (예: async 함수 또는 코루틴 내부)에서 동기 작업(데이터베이스 작업)을 실행하려고 할 때 발생합니다. async 함수 내에서 동기 SQLAlchemy 함수나 메서드를 호출하면, 데이터베이스 작업이 완료될 때까지 이벤트 루프가 다른 작업으로 전환할 수 없습니다. 이는 이벤트 루프가 차단되어 응용 프로그램이 응답하지 않거나 성능 문제가 발생한다는 것을 의미합니다.\u003c/p\u003e\n\u003cp\u003e다음은 MissingGreenletError를 설명하는 예시입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e엔진: \u003cspan class=\"hljs-title class_\"\u003eAsyncEngine\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ecreate_async_engine\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eDB_ENGINE\u003c/span\u003e, echo=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\n\u003cspan class=\"hljs-attr\"\u003easync_session\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eAsyncSession\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003easync_sessionmaker\u003c/span\u003e(engine, expire_on_commit=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDeclarativeBase\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"모든 ORM 모델을 위한 기본 클래스.\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePirateCrew\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"해적 승무원의 세부 정보를 포함합니다.\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n    __tablename__ = \u003cspan class=\"hljs-string\"\u003e\"pirate_crew\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMapped\u003c/span\u003e[int] = \u003cspan class=\"hljs-title function_\"\u003emapped_column\u003c/span\u003e(primary_key=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMapped\u003c/span\u003e[str]\n    \u003cspan class=\"hljs-attr\"\u003eship_name\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMapped\u003c/span\u003e[str]\n    \u003cspan class=\"hljs-attr\"\u003emembers\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMapped\u003c/span\u003e[\u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"Pirate\"\u003c/span\u003e]] = \u003cspan class=\"hljs-title function_\"\u003erelationship\u003c/span\u003e(back_populates=\u003cspan class=\"hljs-string\"\u003e\"pirate_crew\"\u003c/span\u003e)\n\n    def \u003cspan class=\"hljs-title function_\"\u003e__repr__\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-attr\"\u003estr\u003c/span\u003e:\n        \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"객체의 표현을 반환합니다.\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e f\u003cspan class=\"hljs-string\"\u003e\"{self.__class__.name}({self.name})\"\u003c/span\u003e\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePirate\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"해적의 세부 정보를 포함합니다.\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n    __tablename__ = \u003cspan class=\"hljs-string\"\u003e\"pirates\"\u003c/span\u003e\n\n    \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMapped\u003c/span\u003e[int] = \u003cspan class=\"hljs-title function_\"\u003emapped_column\u003c/span\u003e(primary_key=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n    \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMapped\u003c/span\u003e[str]\n    \u003cspan class=\"hljs-attr\"\u003erole\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMapped\u003c/span\u003e[str]\n    \u003cspan class=\"hljs-attr\"\u003edevil_fruit_user\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMapped\u003c/span\u003e[bool]\n    pirate_crew_id = \u003cspan class=\"hljs-title function_\"\u003emapped_column\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eForeignKey\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"pirate_crew.id\"\u003c/span\u003e))\n    \u003cspan class=\"hljs-attr\"\u003epirate_crew\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eMapped\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\"PirateCrew\"\u003c/span\u003e] = \u003cspan class=\"hljs-title function_\"\u003erelationship\u003c/span\u003e(back_populates=\u003cspan class=\"hljs-string\"\u003e\"members\"\u003c/span\u003e)\n\n    def \u003cspan class=\"hljs-title function_\"\u003e__repr__\u003c/span\u003e(self) -\u003e \u003cspan class=\"hljs-attr\"\u003estr\u003c/span\u003e:\n        \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"객체의 표현을 반환합니다.\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e f\u003cspan class=\"hljs-string\"\u003e\"{self.__class__.name}({self.name})\"\u003c/span\u003e\n\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003ecreate_tables\u003c/span\u003e():\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"모든 테이블을 생성하는 메서드입니다.\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e engine.\u003cspan class=\"hljs-title function_\"\u003ebegin\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econnection\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e connection.\u003cspan class=\"hljs-title function_\"\u003erun_sync\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emetadata\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecreate_all\u003c/span\u003e)\n\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003edb_seeder\u003c/span\u003e():\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"PirateCrew 및 Pirate 테이블에 데이터를 시드하는 시더입니다.\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easync_session\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esession\u003c/span\u003e:\n        mugiwara = \u003cspan class=\"hljs-title class_\"\u003ePirateCrew\u003c/span\u003e(name=\u003cspan class=\"hljs-string\"\u003e\"Straw Hats\"\u003c/span\u003e, ship_name=\u003cspan class=\"hljs-string\"\u003e\"Thousand Sunny\"\u003c/span\u003e)\n        mugiwara_members = [\n            \u003cspan class=\"hljs-title class_\"\u003ePirate\u003c/span\u003e(\n                name=\u003cspan class=\"hljs-string\"\u003e\"Monkey D Luffy\"\u003c/span\u003e,\n                role=\u003cspan class=\"hljs-string\"\u003e\"Captain\"\u003c/span\u003e,\n                devil_fruit_user=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e,\n                pirate_crew=mugiwara,\n            ),\n            \u003cspan class=\"hljs-title class_\"\u003ePirate\u003c/span\u003e(\n                name=\u003cspan class=\"hljs-string\"\u003e\"Roronoa Zoro\"\u003c/span\u003e,\n                role=\u003cspan class=\"hljs-string\"\u003e\"First Mate\"\u003c/span\u003e,\n                devil_fruit_user=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e,\n                pirate_crew=mugiwara,\n            ),\n            \u003cspan class=\"hljs-title class_\"\u003ePirate\u003c/span\u003e(\n                name=\u003cspan class=\"hljs-string\"\u003e\"Nami\"\u003c/span\u003e,\n                role=\u003cspan class=\"hljs-string\"\u003e\"Navigator\"\u003c/span\u003e,\n                devil_fruit_user=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e,\n                pirate_crew=mugiwara,\n            ),\n        ]\n        session.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(mugiwara)\n        session.\u003cspan class=\"hljs-title function_\"\u003eadd_all\u003c/span\u003e(mugiwara_members)\n        \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e session.\u003cspan class=\"hljs-title function_\"\u003ecommit\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e따라서 여기에서 우리는 PirateCrew와 Pirate 두 개의 테이블을 만들었습니다. Pirate와 PirateCrew 테이블 사이에 일대다 관계가 있음을 알 수 있습니다. 또한 데이터베이스에 테이블을 생성하고 일부 데이터로 씨드하는 두 개의 비동기 함수가 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 MissingGreenletError를 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003emissing_greenlet_error\u003c/span\u003e():\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"MissingGreenletError 예제입니다.\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easync_session\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esession\u003c/span\u003e:\n        pirate_crew = (\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e session.\u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eselect\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePirateCrew\u003c/span\u003e))).\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e()[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n        # 이제 해적 승무원의 멤버에 액세스하려고 시도해 보겠습니다 (members는 관련된 객체입니다).\n        members = pirate_crew.\u003cspan class=\"hljs-property\"\u003emembers\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(members)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 함수를 실행하면 콘솔에서 다음과 같은 오류가 발생합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esqlalchemy.\u003cspan class=\"hljs-property\"\u003eexc\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eMissingGreenlet\u003c/span\u003e: greenlet_spawn has not been called; can\u003cspan class=\"hljs-string\"\u003e't call await_only() here. Was IO attempted in an unexpected place? (Background on this error at: https://sqlalche.me/e/20/xd2s)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 오류는 members 속성이 관계 속성이기 때문에 발생합니다. SQLAlchemy의 기본 동작은 관련된 객체를 동기적으로 게으르게 로드하는 것입니다. members 속성에 액세스할 때 SQLAlchemy가 관련 Pirate 객체를 동기적으로 로드하려고 하면, 이는 비동기 함수와 호환되지 않습니다. 동기적으로 작동하는 SQLAlchemy가 기대하는 것은 동기 작업에 대해 사용 가능한 greenlet이 있기 때문에 MissingGreenletError가 발생하게 되는 것입니다. 그러나 비동기적인 컨텍스트에서는 greenlet은 사용할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e이와 같은 상황에서 MissingGreenletError를 피하려면 두 가지 옵션이 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e관련 객체를 초기 쿼리에서 함께 로드하려면\u003c/li\u003e\n\u003cli\u003eAsyncAttrs\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEager load 접근 방식: Eager loading은 SQLAlchemy와 같은 객체-관계 매핑(ORM) 라이브러리에서 사용되는 기술로, 부모 객체와 관련된 객체를 동일한 쿼리에서 로드하여 필요할 때 게으르게로 로드하는 것이 아니라 한 번에 로드합니다. 이 방식은 관련 객체를 비동기적으로 처리할 때 MissingGreenletError를 피하는 데 도움이 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 Eager load 방식으로 MissingGreenletError를 해결하는 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def loading_techniques로 수정해주세요():\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"로딩 기술을 사용하여 MissingGreenletError를 해결하는 예시.\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easync_session\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esession\u003c/span\u003e:\n        pirate_crew = (\n            \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e session.\u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e(\n                \u003cspan class=\"hljs-title function_\"\u003eselect\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePirateCrew\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eoptions\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eselectinload\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePirateCrew\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emembers\u003c/span\u003e))\n            )\n        ).\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e()[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n        # 이곳에서 \u003cspan class=\"hljs-title function_\"\u003eselectinload\u003c/span\u003e()를 사용하여 \u003cspan class=\"hljs-title class_\"\u003ePirate\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTable\u003c/span\u003e을 조인했습니다\n        members = pirate_crew.\u003cspan class=\"hljs-property\"\u003emembers\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(members)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기서 selectinload() 로더 전략을 사용하여 관련된 객체를 즉시 로드했습니다. 더 자세한 설명은 이전 게시물을 참고해주세요,\u003c/p\u003e\n\u003cp\u003eAsyncAttrs: AsyncAttrs은 SQLAlchemy에서 제공하는 내장 mixin으로, awaitable_attrs 엑세서를 소개하여 어떤 속성도 awaitable로 취급할 수 있게 하며, 관련된 객체 또는 다른 속성에 대한 비동기 로딩 및 액세스를 용이하게 합니다.\u003c/p\u003e\n\u003cp\u003e다음은 AsyncAttrs를 사용하여 MissingGreenletError를 해결하는 예시입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eBase\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDeclarativeBase\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eAsyncAttrs\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"모든 ORM 모델의 기본 클래스\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e def \u003cspan class=\"hljs-title function_\"\u003efix_with_async_attrs\u003c/span\u003e():\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"AsyncAttrs로 MissingGreenletError를 해결하는 예시\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003easync_session\u003c/span\u003e() \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esession\u003c/span\u003e:\n        pirate_crew = (\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e session.\u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eselect\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003ePirateCrew\u003c/span\u003e))).\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e()[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n        members = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e pirate_crew.\u003cspan class=\"hljs-property\"\u003eawaitable_attrs\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emembers\u003c/span\u003e\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(members)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e여기서 우리는 AsyncAttrs를 Base 클래스에 추가했습니다. 이제 awaitable_attrs 액세서를 사용하여 관련 객체에 액세스할 수 있습니다. AsyncAttrs를 추가함으로써 이제 pirate_crew.members에 직접 액세스하는 대신 pirate_crew.awaitable_attrs.members를 사용할 수 있습니다. awaitable_attrs 부분은 SQLAlchemy에게 관련 Pirate 객체를 블로킹하지 않고 비동기적으로 로드하도록 지시합니다.\u003c/p\u003e\n\u003cp\u003e참고: AsyncAttrs은 MissingGreenletError를 피하는 데 도움이 되지만 N+1 쿼리 문제나 불필요한 데이터 로딩과 같은 다른 잠재적인 문제를 반드시 예방하는 것은 아닙니다. 여전히 적절한 로딩 전략(예: joinedload 또는 selectinload)을 사용하고 데이터 액세스 패턴을 신중히 고려하여 성능을 최적화하고 불필요한 부하를 피하는 것이 좋습니다.\u003c/p\u003e\n\u003cp\u003e참고 자료:\u003c/p\u003e\n\u003cp\u003e코드 참조:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/vickypalani/sqlalchemy_missing_greenlet_error\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/vickypalani/sqlalchemy_missing_greenlet_error\u003c/a\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-SQLAlchemyMissingGreenletError"},"buildId":"kkckKPyxcjJp_o8wb2unW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>