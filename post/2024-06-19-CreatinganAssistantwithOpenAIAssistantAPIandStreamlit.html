<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>OpenAI Assistant API와 Streamlit을 사용하여 도우미 만들기 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-CreatinganAssistantwithOpenAIAssistantAPIandStreamlit" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="OpenAI Assistant API와 Streamlit을 사용하여 도우미 만들기 | itposting" data-gatsby-head="true"/><meta property="og:title" content="OpenAI Assistant API와 Streamlit을 사용하여 도우미 만들기 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-CreatinganAssistantwithOpenAIAssistantAPIandStreamlit_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-CreatinganAssistantwithOpenAIAssistantAPIandStreamlit" data-gatsby-head="true"/><meta name="twitter:title" content="OpenAI Assistant API와 Streamlit을 사용하여 도우미 만들기 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-CreatinganAssistantwithOpenAIAssistantAPIandStreamlit_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 19:58" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">OpenAI Assistant API와 Streamlit을 사용하여 도우미 만들기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="OpenAI Assistant API와 Streamlit을 사용하여 도우미 만들기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">8<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-CreatinganAssistantwithOpenAIAssistantAPIandStreamlit&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>단계별 가이드</h2>
<p><img src="https://miro.medium.com/v2/resize:fit:1200/1*bX5eqE7EUmnwxWuqjZDzIQ.gif" alt="이미지"></p>
<h1>OpenAI Assistant API</h1>
<p>최근 OpenAI가 새로운 기능을 소개했습니다. 이들은 Assistant API와 같이 에이전트와 같은 아키텍처를 보여줍니다. OpenAI에 따르면:</p>
<div class="content-ad"></div>
<p>이러한 발전은 희망적이지만, 아직 LangChain을 따라가지 못합니다. LangChain은 자연어 입력을 처리하고 문맥 기반 액션을 실행하는 더 유연한 LLM을 활용하여 에이전트 형태의 시스템을 만들 수 있습니다.</p>
<p>하지만, 이것은 시작에 불과합니다.</p>
<p>높은 수준에서 Assistant API와 상호 작용하는 것은 루프로 상상할 수 있습니다:</p>
<ul>
<li>사용자 입력을 받으면 LLM이 호출되어 응답을 제공할지 또는 특정 조치를 취할지를 결정합니다.</li>
<li>LLM의 결정이 쿼리에 대한 답변으로 충분하다면 루프가 종료됩니다.</li>
<li>만약 행동이 새로운 관찰로 이어진다면, 이 관찰은 프롬프트에 포함되고 LLM이 다시 호출됩니다.</li>
<li>그런 다음 루프가 다시 시작됩니다.</li>
</ul>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-19-CreatinganAssistantwithOpenAIAssistantAPIandStreamlit_0.png" alt="이미지"></p>
<p>안타깝게도 발표된 장점에도 불구하고, API에 대한 문서는 특히 사용자 정의 함수 호출 및 Streamlit와 같은 프레임워크를 사용한 앱 구축과 관련하여 제대로 작성되지 않았다고 생각했습니다.</p>
<p>이 블로그 포스트에서는 OpenAI Assistant API 및 사용자 정의 함수 호출을 사용하여 Streamlit 인터페이스와 함께 AI 어시스턴트를 구축하는 방법을 안내해드리겠습니다. 이를 통해 Assistant API를 효과적으로 사용하고자 하는 분들께 도움이 될 것입니다.</p>
<h1>사용 사례: 세금 계산 어시스턴트</h1>
<div class="content-ad"></div>
<p>이 블로그 포스트에서는 간단한 예제를 보여드리겠습니다: 주어진 수익에 기반한 세금을 계산할 수 있는 AI 어시스턴트입니다. Langchain 사용자들은 "세금 계산" 도구를 가진 에이전트를 생성함으로써 이를 쉽게 이해할 수 있습니다.</p>
<p>이 도구에는 필요한 계산 단계와 LLM이 수익 또는 세금과 관련된 질문이 있을 때 도구를 호출해야 하는지를 알려주는 잘 설계된 프롬프트가 포함될 것입니다.</p>
<p>그러나 이 프로세스는 OpenAI 어시스턴트 API와 정확히 동일하지는 않습니다. OpenAI의 문서에 따르면 코드 해석기와 파일 검색 도구는 직접적으로 간단한 방식으로 사용할 수 있지만, 사용자 정의 도구는 약간 다른 방식으로 접근해야 합니다.</p>
<pre><code class="hljs language-js">assistant = client.<span class="hljs-property">beta</span>.<span class="hljs-property">assistants</span>.<span class="hljs-title function_">create</span>(
  name=<span class="hljs-string">"데이터 시각화자"</span>,
  description=<span class="hljs-string">"당신은 아름다운 데이터 시각화를 만드는 데 뛰어나십니다. .csv 파일에 있는 데이터를 분석하며 트렌드를 이해하고 해당 트렌드에 관련된 데이터 시각화를 제시합니다. 또한 관찰된 트렌드에 대한 간단한 텍스트 요약을 공유합니다."</span>,
  model=<span class="hljs-string">"gpt-4o"</span>,
  tools=[{<span class="hljs-string">"type"</span>: <span class="hljs-string">"code_interpreter"</span>}],
)
</code></pre>
<div class="content-ad"></div>
<p>한 단계씩 세부 내용을 살펴보겠습니다. 다음을 목표로 합니다:</p>
<ul>
<li>주어진 수익에 기반한 세금을 계산하는 함수 정의하기.</li>
<li>이 함수를 사용하는 도구 개발하기.</li>
<li>이 도구에 액세스하고 세금 계산이 필요할 때 호출할 수 있는 어시스턴트 만들기.</li>
</ul>
<h1>어시스턴트 통합을 위한 세금 계산 함수</h1>
<p>다음 단락에서 설명하는 세금 계산 도구는 이 글에서 논의된 API를 사용하는 방법을 보여주기 위한 예시로 설계되었음을 유념해 주세요. 실제 세금 계산에 사용해서는 안 됩니다.</p>
<div class="content-ad"></div>
<p>다음과 같이 조각별 함수를 고려해 보세요. 이 함수는 주어진 매출에 대한 세금 값을 반환합니다. 입력이 간단한 구문 분석을 위해 문자열로 설정되어 있음을 유의하세요:</p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">calculate_tax</span>(<span class="hljs-attr">revenue</span>: str):
    <span class="hljs-attr">try</span>:
        revenue = <span class="hljs-title function_">float</span>(revenue)
    except <span class="hljs-title class_">ValueError</span>:
        raise <span class="hljs-title class_">ValueError</span>(<span class="hljs-string">"매출은 숫자의 문자열 표현이어야 합니다."</span>)

    <span class="hljs-keyword">if</span> revenue &#x3C;= <span class="hljs-number">10000</span>:
        tax = <span class="hljs-number">0</span>
    elif revenue &#x3C;= <span class="hljs-number">30000</span>:
        tax = <span class="hljs-number">0.10</span> * (revenue - <span class="hljs-number">10000</span>)
    elif revenue &#x3C;= <span class="hljs-number">70000</span>:
        tax = <span class="hljs-number">2000</span> + <span class="hljs-number">0.20</span> * (revenue - <span class="hljs-number">30000</span>)
    elif revenue &#x3C;= <span class="hljs-number">150000</span>:
        tax = <span class="hljs-number">10000</span> + <span class="hljs-number">0.30</span> * (revenue - <span class="hljs-number">70000</span>)
    <span class="hljs-attr">else</span>:
        tax = <span class="hljs-number">34000</span> + <span class="hljs-number">0.40</span> * (revenue - <span class="hljs-number">150000</span>)

    <span class="hljs-keyword">return</span> tax
</code></pre>
<p>다음으로, 비서(assistant)를 정의합니다:</p>
<pre><code class="hljs language-js">function_tools = [
    {
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"function"</span>,
        <span class="hljs-string">"function"</span>: {
            <span class="hljs-string">"name"</span>: <span class="hljs-string">"calculate_tax"</span>,
            <span class="hljs-string">"description"</span>: <span class="hljs-string">"유로로 주어진 매출에 대한 세금을 가져옵니다."</span>,
            <span class="hljs-string">"parameters"</span>: {
                <span class="hljs-string">"type"</span>: <span class="hljs-string">"object"</span>,
                <span class="hljs-string">"properties"</span>: {
                    <span class="hljs-string">"revenue"</span>: {
                        <span class="hljs-string">"type"</span>: <span class="hljs-string">"string"</span>,
                        <span class="hljs-string">"description"</span>: <span class="hljs-string">"유로로 연간 매출"</span>
                    }
                },
                <span class="hljs-string">"required"</span>: [<span class="hljs-string">"revenue"</span>]
            }
        }
    }
]

# 비서(assistant) 정의
assistant = client.<span class="hljs-property">beta</span>.<span class="hljs-property">assistants</span>.<span class="hljs-title function_">create</span>(
    name=<span class="hljs-string">"Assistant"</span>,
    instructions=<span class="hljs-string">""</span>,
    tools=function_tools,
    model=<span class="hljs-string">"gpt-4o"</span>,
)
</code></pre>
<div class="content-ad"></div>
<p>이제, 주요한 포인트에 대해서 얘기해볼게요:</p>
<p>어시스턴트가 "calculate_tax"가 호출될 때 어떻게 함수를 사용하는지 알고 계신가요? 이 부분은 OpenAI 어시스턴트에서 문서화가 잘 되어 있지 않아, 많은 사용자들이 처음 사용할 때 혼동을 겪을 수 있어요. 이를 해결하기 위해, 응담 스트림(response stream)에서 다양한 이벤트를 관리하기 위한 EventHandler를 정의해야 합니다. 특히 "calculate_tax" 도구가 호출될 때의 이벤트를 어떻게 처리하는지에 대해 명확히 알아둬야 해요.</p>
<pre><code class="hljs language-js">    def <span class="hljs-title function_">handle_requires_action</span>(self, data, run_id):
        tool_outputs = []

        <span class="hljs-keyword">for</span> tool <span class="hljs-keyword">in</span> data.<span class="hljs-property">required_action</span>.<span class="hljs-property">submit_tool_outputs</span>.<span class="hljs-property">tool_calls</span>:
            <span class="hljs-keyword">if</span> tool.<span class="hljs-property">function</span>.<span class="hljs-property">name</span> == <span class="hljs-string">"calculate_tax"</span>:
                <span class="hljs-attr">try</span>:
                    # 도구 매개변수에서 수익 추출
                    revenue = ast.<span class="hljs-title function_">literal_eval</span>(tool.<span class="hljs-property">function</span>.<span class="hljs-property">arguments</span>)[<span class="hljs-string">"revenue"</span>]
                    # 세금을 계산하는 calculate_tax 함수 호출
                    tax_result = <span class="hljs-title function_">calculate_tax</span>(revenue)
                    # 필요한 형식에 맞게 도구 출력을 추가
                    tool_outputs.<span class="hljs-title function_">append</span>({<span class="hljs-string">"tool_call_id"</span>: tool.<span class="hljs-property">id</span>, <span class="hljs-string">"output"</span>: f<span class="hljs-string">"{tax_result}"</span>})
                except <span class="hljs-title class_">ValueError</span> <span class="hljs-keyword">as</span> <span class="hljs-attr">e</span>:
                    # 세금 계산 시 발생하는 모든 오류 처리
                    tool_outputs.<span class="hljs-title function_">append</span>({<span class="hljs-string">"tool_call_id"</span>: tool.<span class="hljs-property">id</span>, <span class="hljs-string">"error"</span>: <span class="hljs-title function_">str</span>(e)})
        # 모든 도구 출력을 동시에 제출
        self.<span class="hljs-title function_">submit_tool_outputs</span>(tool_outputs)
</code></pre>
<p>위 코드는 다음과 같이 동작해요: 동작이 필요한 각 도구 호출에 대해:</p>
<div class="content-ad"></div>
<ul>
<li>"calculate_tax" 함수 이름을 확인합니다.</li>
<li>툴 매개변수에서 수익 값을 추출합니다.</li>
<li>수익을 이용하여 calculate_tax 함수를 호출하여 세금을 계산합니다. (여기서 실제 상호작용이 이루어집니다.)</li>
<li>모든 툴 호출을 처리한 후, 수집된 결과를 제출합니다.</li>
</ul>
<h1>보조 인공지능과 대화하기</h1>
<p>다음은 OpenAI가 문서화한 표준 단계를 따라 보조 인공지능과 상호작용할 수 있습니다. 따라서 이 섹션에서는 많은 세부 정보를 제공하지 않겠습니다:</p>
<ul>
<li>스레드 생성: 이는 사용자와 보조 인공지능 간의 대화를 나타냅니다.</li>
<li>사용자 메시지 추가: 이는 스레드에 추가되는 텍스트 및 파일을 포함할 수 있습니다.</li>
<li>실행 생성: 보조 인공지능과 연관된 모델 및 도구를 활용하여 응답 생성합니다. 이 응답은 다시 스레드에 추가됩니다.</li>
</ul>
<div class="content-ad"></div>
<p>아래 코드 조각은 특정 사용 사례에서 어시스턴트를 실행하는 방법을 보여줍니다: 코드는 스레드 ID 및 어시스턴트 ID를 사용하는 특정 매개변수를 설정하여 어시스턴트와의 스트리밍 상호작용을 설정합니다. EventHandler 인스턴스는 스트림 중 이벤트를 관리합니다. stream.until_done() 메서드는 모든 상호작용이 완료될 때까지 스트림을 유지합니다. with 문은 스트림이 적절히 닫히도록 보장합니다.</p>
<pre><code class="hljs language-js">  <span class="hljs-keyword">with</span> client.<span class="hljs-property">beta</span>.<span class="hljs-property">threads</span>.<span class="hljs-property">runs</span>.<span class="hljs-title function_">stream</span>(thread_id=st.<span class="hljs-property">session_state</span>.<span class="hljs-property">thread_id</span>,
                                         assistant_id=assistant.<span class="hljs-property">id</span>,
                                         event_handler=<span class="hljs-title class_">EventHandler</span>(),
                                         temperature=<span class="hljs-number">0</span>) <span class="hljs-keyword">as</span> <span class="hljs-attr">stream</span>:
        stream.<span class="hljs-title function_">until_done</span>()
</code></pre>
<h1>Streamlit 인터페이스</h1>
<p>여기서 내 게시물을 마칠 수 있지만, Streamlit 포럼(예: 이 포스트)에서 사용자들이 터미널에서는 정상 작동하지만 인터페이스에서 스트리밍이 작동하지 않는다는 수많은 문의를 발견했습니다. 이것이 나로 하여금 더 깊이 파고들도록 유도했습니다.</p>
<div class="content-ad"></div>
<p>스트리밍을 앱에 성공적으로 통합하려면, 앞서 언급한 EventHandler 클래스의 기능을 확장해야 합니다. 특히 텍스트 생성, 텍스트 델타 처리 및 텍스트 완료를 중점적으로 다루어야 합니다. 채팅 히스토리를 관리하면서 Streamlit 인터페이스에 텍스트를 표시하기 위해 필요한 세 가지 주요 단계는 다음과 같습니다:</p>
<ul>
<li>텍스트 생성 처리 (on_text_created): 어시스턴트의 각 응답마다 새로운 텍스트 상자를 초기화하고 표시하여 이전 작업의 상태를 반영하도록 UI를 업데이트합니다.</li>
<li>텍스트 델타 처리 (on_text_delta): 어시스턴트가 텍스트를 생성할 때 현재 텍스트 상자를 동적으로 업데이트하여 전체 UI를 새로 고치지 않고도 점진적으로 변경할 수 있도록 합니다.</li>
<li>텍스트 완료 처리 (on_text_done): 새로운 빈 텍스트 상자를 추가하여 각 상호작용 세그먼트를 완료하고, 다음 상호작용을 준비합니다. 또한, 대화 세그먼트를 chat_history에 기록합니다.</li>
</ul>
<p>예를 들어, 텍스트 델타를 관리하는 다음 코드 조각을 살펴봅시다:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">on_text_delta</span>(<span class="hljs-params">self, delta: TextDelta, snapshot: Text</span>):
    <span class="hljs-string">"""
    텍스트 델타가 생성될 때의 핸들러
    """</span>
    <span class="hljs-comment"># 최신 텍스트 상자를 지웁니다.</span>
    st.session_state.text_boxes[-<span class="hljs-number">1</span>].empty()
    
    <span class="hljs-comment"># 새로운 텍스트가 있으면, 어시스턴트 텍스트 목록의 마지막 요소에 추가합니다.</span>
    <span class="hljs-keyword">if</span> delta.value:
        st.session_state.assistant_text[-<span class="hljs-number">1</span>] += delta.value
    
    <span class="hljs-comment"># 업데이트된 어시스턴트 텍스트를 최신 텍스트 상자에 다시 표시합니다.</span>
    st.session_state.text_boxes[-<span class="hljs-number">1</span>].info(<span class="hljs-string">""</span>.join(st.session_state[<span class="hljs-string">"assistant_text"</span>][-<span class="hljs-number">1</span>]))
</code></pre>
<div class="content-ad"></div>
<p>이 코드는 세 가지 주요 작업을 수행합니다:</p>
<ul>
<li>최신 텍스트 상자 지우기: 최신 텍스트 상자의 내용을 지워 새 입력을 준비합니다 (st.session_state.text_boxes[-1]).</li>
<li>델타 값을 도우미 텍스트에 추가: 새 텍스트 (delta.value)가 있는 경우, 이를 st.session_state.assistant_text[-1]에 저장된 지속적인 도우미 텍스트에 추가합니다.</li>
<li>업데이트된 도우미 텍스트 다시 표시: 지금까지 축적된 모든 도우미 텍스트의 내용을 반영하기 위해 최신 텍스트 상자의 내용을 업데이트합니다 (st.session_state["assistant_text"][-1]).</li>
</ul>
<h1>결론</h1>
<p>이 블로그 포스트에서는 OpenAI Assistant API와 Streamlit을 사용하여 세금을 계산할 수 있는 AI 도우미를 만드는 방법을 보여주었습니다.</p>
<div class="content-ad"></div>
<p>저는 Assistant API의 능력을 강조하기 위해 이 간단한 프로젝트를 수행했어요. 문서가 다소 불명확하더라도, 목표는 모호한 부분을 명확하게 하고 Assistant API를 사용하고자 하는 분들에게 일부 지침을 제공하는 것이었습니다. 이 게시물이 도움이 되었으면 좋겠고, 이 강력한 도구로 더 많은 가능성을 탐험하도록 격려하길 바랍니다.</p>
<p>공간 제약으로 인해 불필요한 코드 조각을 포함하지 않으려고 노력했어요. 그러나 필요한 경우, 제 Github 저장소를 방문하여 전체 구현 내용을 확인해주세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"OpenAI Assistant API와 Streamlit을 사용하여 도우미 만들기","description":"","date":"2024-06-19 19:58","slug":"2024-06-19-CreatinganAssistantwithOpenAIAssistantAPIandStreamlit","content":"\n\n## 단계별 가이드\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*bX5eqE7EUmnwxWuqjZDzIQ.gif)\n\n# OpenAI Assistant API\n\n최근 OpenAI가 새로운 기능을 소개했습니다. 이들은 Assistant API와 같이 에이전트와 같은 아키텍처를 보여줍니다. OpenAI에 따르면:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이러한 발전은 희망적이지만, 아직 LangChain을 따라가지 못합니다. LangChain은 자연어 입력을 처리하고 문맥 기반 액션을 실행하는 더 유연한 LLM을 활용하여 에이전트 형태의 시스템을 만들 수 있습니다.\n\n하지만, 이것은 시작에 불과합니다.\n\n높은 수준에서 Assistant API와 상호 작용하는 것은 루프로 상상할 수 있습니다:\n\n- 사용자 입력을 받으면 LLM이 호출되어 응답을 제공할지 또는 특정 조치를 취할지를 결정합니다.\n- LLM의 결정이 쿼리에 대한 답변으로 충분하다면 루프가 종료됩니다.\n- 만약 행동이 새로운 관찰로 이어진다면, 이 관찰은 프롬프트에 포함되고 LLM이 다시 호출됩니다.\n- 그런 다음 루프가 다시 시작됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-CreatinganAssistantwithOpenAIAssistantAPIandStreamlit_0.png)\n\n안타깝게도 발표된 장점에도 불구하고, API에 대한 문서는 특히 사용자 정의 함수 호출 및 Streamlit와 같은 프레임워크를 사용한 앱 구축과 관련하여 제대로 작성되지 않았다고 생각했습니다.\n\n이 블로그 포스트에서는 OpenAI Assistant API 및 사용자 정의 함수 호출을 사용하여 Streamlit 인터페이스와 함께 AI 어시스턴트를 구축하는 방법을 안내해드리겠습니다. 이를 통해 Assistant API를 효과적으로 사용하고자 하는 분들께 도움이 될 것입니다.\n\n# 사용 사례: 세금 계산 어시스턴트\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 블로그 포스트에서는 간단한 예제를 보여드리겠습니다: 주어진 수익에 기반한 세금을 계산할 수 있는 AI 어시스턴트입니다. Langchain 사용자들은 \"세금 계산\" 도구를 가진 에이전트를 생성함으로써 이를 쉽게 이해할 수 있습니다.\n\n이 도구에는 필요한 계산 단계와 LLM이 수익 또는 세금과 관련된 질문이 있을 때 도구를 호출해야 하는지를 알려주는 잘 설계된 프롬프트가 포함될 것입니다.\n\n그러나 이 프로세스는 OpenAI 어시스턴트 API와 정확히 동일하지는 않습니다. OpenAI의 문서에 따르면 코드 해석기와 파일 검색 도구는 직접적으로 간단한 방식으로 사용할 수 있지만, 사용자 정의 도구는 약간 다른 방식으로 접근해야 합니다.\n\n```js\nassistant = client.beta.assistants.create(\n  name=\"데이터 시각화자\",\n  description=\"당신은 아름다운 데이터 시각화를 만드는 데 뛰어나십니다. .csv 파일에 있는 데이터를 분석하며 트렌드를 이해하고 해당 트렌드에 관련된 데이터 시각화를 제시합니다. 또한 관찰된 트렌드에 대한 간단한 텍스트 요약을 공유합니다.\",\n  model=\"gpt-4o\",\n  tools=[{\"type\": \"code_interpreter\"}],\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n한 단계씩 세부 내용을 살펴보겠습니다. 다음을 목표로 합니다:\n\n- 주어진 수익에 기반한 세금을 계산하는 함수 정의하기.\n- 이 함수를 사용하는 도구 개발하기.\n- 이 도구에 액세스하고 세금 계산이 필요할 때 호출할 수 있는 어시스턴트 만들기.\n\n# 어시스턴트 통합을 위한 세금 계산 함수\n\n다음 단락에서 설명하는 세금 계산 도구는 이 글에서 논의된 API를 사용하는 방법을 보여주기 위한 예시로 설계되었음을 유념해 주세요. 실제 세금 계산에 사용해서는 안 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음과 같이 조각별 함수를 고려해 보세요. 이 함수는 주어진 매출에 대한 세금 값을 반환합니다. 입력이 간단한 구문 분석을 위해 문자열로 설정되어 있음을 유의하세요:\n\n```js\ndef calculate_tax(revenue: str):\n    try:\n        revenue = float(revenue)\n    except ValueError:\n        raise ValueError(\"매출은 숫자의 문자열 표현이어야 합니다.\")\n\n    if revenue \u003c= 10000:\n        tax = 0\n    elif revenue \u003c= 30000:\n        tax = 0.10 * (revenue - 10000)\n    elif revenue \u003c= 70000:\n        tax = 2000 + 0.20 * (revenue - 30000)\n    elif revenue \u003c= 150000:\n        tax = 10000 + 0.30 * (revenue - 70000)\n    else:\n        tax = 34000 + 0.40 * (revenue - 150000)\n\n    return tax\n```\n\n다음으로, 비서(assistant)를 정의합니다:\n\n```js\nfunction_tools = [\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"calculate_tax\",\n            \"description\": \"유로로 주어진 매출에 대한 세금을 가져옵니다.\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"revenue\": {\n                        \"type\": \"string\",\n                        \"description\": \"유로로 연간 매출\"\n                    }\n                },\n                \"required\": [\"revenue\"]\n            }\n        }\n    }\n]\n\n# 비서(assistant) 정의\nassistant = client.beta.assistants.create(\n    name=\"Assistant\",\n    instructions=\"\",\n    tools=function_tools,\n    model=\"gpt-4o\",\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제, 주요한 포인트에 대해서 얘기해볼게요:\n\n어시스턴트가 \"calculate_tax\"가 호출될 때 어떻게 함수를 사용하는지 알고 계신가요? 이 부분은 OpenAI 어시스턴트에서 문서화가 잘 되어 있지 않아, 많은 사용자들이 처음 사용할 때 혼동을 겪을 수 있어요. 이를 해결하기 위해, 응담 스트림(response stream)에서 다양한 이벤트를 관리하기 위한 EventHandler를 정의해야 합니다. 특히 \"calculate_tax\" 도구가 호출될 때의 이벤트를 어떻게 처리하는지에 대해 명확히 알아둬야 해요.\n\n```js\n    def handle_requires_action(self, data, run_id):\n        tool_outputs = []\n\n        for tool in data.required_action.submit_tool_outputs.tool_calls:\n            if tool.function.name == \"calculate_tax\":\n                try:\n                    # 도구 매개변수에서 수익 추출\n                    revenue = ast.literal_eval(tool.function.arguments)[\"revenue\"]\n                    # 세금을 계산하는 calculate_tax 함수 호출\n                    tax_result = calculate_tax(revenue)\n                    # 필요한 형식에 맞게 도구 출력을 추가\n                    tool_outputs.append({\"tool_call_id\": tool.id, \"output\": f\"{tax_result}\"})\n                except ValueError as e:\n                    # 세금 계산 시 발생하는 모든 오류 처리\n                    tool_outputs.append({\"tool_call_id\": tool.id, \"error\": str(e)})\n        # 모든 도구 출력을 동시에 제출\n        self.submit_tool_outputs(tool_outputs)\n```\n\n위 코드는 다음과 같이 동작해요: 동작이 필요한 각 도구 호출에 대해:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- \"calculate_tax\" 함수 이름을 확인합니다.\n- 툴 매개변수에서 수익 값을 추출합니다.\n- 수익을 이용하여 calculate_tax 함수를 호출하여 세금을 계산합니다. (여기서 실제 상호작용이 이루어집니다.)\n- 모든 툴 호출을 처리한 후, 수집된 결과를 제출합니다.\n\n# 보조 인공지능과 대화하기\n\n다음은 OpenAI가 문서화한 표준 단계를 따라 보조 인공지능과 상호작용할 수 있습니다. 따라서 이 섹션에서는 많은 세부 정보를 제공하지 않겠습니다:\n\n- 스레드 생성: 이는 사용자와 보조 인공지능 간의 대화를 나타냅니다.\n- 사용자 메시지 추가: 이는 스레드에 추가되는 텍스트 및 파일을 포함할 수 있습니다.\n- 실행 생성: 보조 인공지능과 연관된 모델 및 도구를 활용하여 응답 생성합니다. 이 응답은 다시 스레드에 추가됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래 코드 조각은 특정 사용 사례에서 어시스턴트를 실행하는 방법을 보여줍니다: 코드는 스레드 ID 및 어시스턴트 ID를 사용하는 특정 매개변수를 설정하여 어시스턴트와의 스트리밍 상호작용을 설정합니다. EventHandler 인스턴스는 스트림 중 이벤트를 관리합니다. stream.until_done() 메서드는 모든 상호작용이 완료될 때까지 스트림을 유지합니다. with 문은 스트림이 적절히 닫히도록 보장합니다.\n\n```js\n  with client.beta.threads.runs.stream(thread_id=st.session_state.thread_id,\n                                         assistant_id=assistant.id,\n                                         event_handler=EventHandler(),\n                                         temperature=0) as stream:\n        stream.until_done()\n```\n\n# Streamlit 인터페이스\n\n여기서 내 게시물을 마칠 수 있지만, Streamlit 포럼(예: 이 포스트)에서 사용자들이 터미널에서는 정상 작동하지만 인터페이스에서 스트리밍이 작동하지 않는다는 수많은 문의를 발견했습니다. 이것이 나로 하여금 더 깊이 파고들도록 유도했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n스트리밍을 앱에 성공적으로 통합하려면, 앞서 언급한 EventHandler 클래스의 기능을 확장해야 합니다. 특히 텍스트 생성, 텍스트 델타 처리 및 텍스트 완료를 중점적으로 다루어야 합니다. 채팅 히스토리를 관리하면서 Streamlit 인터페이스에 텍스트를 표시하기 위해 필요한 세 가지 주요 단계는 다음과 같습니다:\n\n- 텍스트 생성 처리 (on_text_created): 어시스턴트의 각 응답마다 새로운 텍스트 상자를 초기화하고 표시하여 이전 작업의 상태를 반영하도록 UI를 업데이트합니다.\n- 텍스트 델타 처리 (on_text_delta): 어시스턴트가 텍스트를 생성할 때 현재 텍스트 상자를 동적으로 업데이트하여 전체 UI를 새로 고치지 않고도 점진적으로 변경할 수 있도록 합니다.\n- 텍스트 완료 처리 (on_text_done): 새로운 빈 텍스트 상자를 추가하여 각 상호작용 세그먼트를 완료하고, 다음 상호작용을 준비합니다. 또한, 대화 세그먼트를 chat_history에 기록합니다.\n\n예를 들어, 텍스트 델타를 관리하는 다음 코드 조각을 살펴봅시다:\n\n```python\ndef on_text_delta(self, delta: TextDelta, snapshot: Text):\n    \"\"\"\n    텍스트 델타가 생성될 때의 핸들러\n    \"\"\"\n    # 최신 텍스트 상자를 지웁니다.\n    st.session_state.text_boxes[-1].empty()\n    \n    # 새로운 텍스트가 있으면, 어시스턴트 텍스트 목록의 마지막 요소에 추가합니다.\n    if delta.value:\n        st.session_state.assistant_text[-1] += delta.value\n    \n    # 업데이트된 어시스턴트 텍스트를 최신 텍스트 상자에 다시 표시합니다.\n    st.session_state.text_boxes[-1].info(\"\".join(st.session_state[\"assistant_text\"][-1]))\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드는 세 가지 주요 작업을 수행합니다:\n\n- 최신 텍스트 상자 지우기: 최신 텍스트 상자의 내용을 지워 새 입력을 준비합니다 (st.session_state.text_boxes[-1]).\n- 델타 값을 도우미 텍스트에 추가: 새 텍스트 (delta.value)가 있는 경우, 이를 st.session_state.assistant_text[-1]에 저장된 지속적인 도우미 텍스트에 추가합니다.\n- 업데이트된 도우미 텍스트 다시 표시: 지금까지 축적된 모든 도우미 텍스트의 내용을 반영하기 위해 최신 텍스트 상자의 내용을 업데이트합니다 (st.session_state[\"assistant_text\"][-1]).\n\n# 결론\n\n이 블로그 포스트에서는 OpenAI Assistant API와 Streamlit을 사용하여 세금을 계산할 수 있는 AI 도우미를 만드는 방법을 보여주었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저는 Assistant API의 능력을 강조하기 위해 이 간단한 프로젝트를 수행했어요. 문서가 다소 불명확하더라도, 목표는 모호한 부분을 명확하게 하고 Assistant API를 사용하고자 하는 분들에게 일부 지침을 제공하는 것이었습니다. 이 게시물이 도움이 되었으면 좋겠고, 이 강력한 도구로 더 많은 가능성을 탐험하도록 격려하길 바랍니다.\n\n공간 제약으로 인해 불필요한 코드 조각을 포함하지 않으려고 노력했어요. 그러나 필요한 경우, 제 Github 저장소를 방문하여 전체 구현 내용을 확인해주세요.","ogImage":{"url":"/assets/img/2024-06-19-CreatinganAssistantwithOpenAIAssistantAPIandStreamlit_0.png"},"coverImage":"/assets/img/2024-06-19-CreatinganAssistantwithOpenAIAssistantAPIandStreamlit_0.png","tag":["Tech"],"readingTime":8},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e단계별 가이드\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*bX5eqE7EUmnwxWuqjZDzIQ.gif\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003eOpenAI Assistant API\u003c/h1\u003e\n\u003cp\u003e최근 OpenAI가 새로운 기능을 소개했습니다. 이들은 Assistant API와 같이 에이전트와 같은 아키텍처를 보여줍니다. OpenAI에 따르면:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이러한 발전은 희망적이지만, 아직 LangChain을 따라가지 못합니다. LangChain은 자연어 입력을 처리하고 문맥 기반 액션을 실행하는 더 유연한 LLM을 활용하여 에이전트 형태의 시스템을 만들 수 있습니다.\u003c/p\u003e\n\u003cp\u003e하지만, 이것은 시작에 불과합니다.\u003c/p\u003e\n\u003cp\u003e높은 수준에서 Assistant API와 상호 작용하는 것은 루프로 상상할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e사용자 입력을 받으면 LLM이 호출되어 응답을 제공할지 또는 특정 조치를 취할지를 결정합니다.\u003c/li\u003e\n\u003cli\u003eLLM의 결정이 쿼리에 대한 답변으로 충분하다면 루프가 종료됩니다.\u003c/li\u003e\n\u003cli\u003e만약 행동이 새로운 관찰로 이어진다면, 이 관찰은 프롬프트에 포함되고 LLM이 다시 호출됩니다.\u003c/li\u003e\n\u003cli\u003e그런 다음 루프가 다시 시작됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-CreatinganAssistantwithOpenAIAssistantAPIandStreamlit_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e안타깝게도 발표된 장점에도 불구하고, API에 대한 문서는 특히 사용자 정의 함수 호출 및 Streamlit와 같은 프레임워크를 사용한 앱 구축과 관련하여 제대로 작성되지 않았다고 생각했습니다.\u003c/p\u003e\n\u003cp\u003e이 블로그 포스트에서는 OpenAI Assistant API 및 사용자 정의 함수 호출을 사용하여 Streamlit 인터페이스와 함께 AI 어시스턴트를 구축하는 방법을 안내해드리겠습니다. 이를 통해 Assistant API를 효과적으로 사용하고자 하는 분들께 도움이 될 것입니다.\u003c/p\u003e\n\u003ch1\u003e사용 사례: 세금 계산 어시스턴트\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 블로그 포스트에서는 간단한 예제를 보여드리겠습니다: 주어진 수익에 기반한 세금을 계산할 수 있는 AI 어시스턴트입니다. Langchain 사용자들은 \"세금 계산\" 도구를 가진 에이전트를 생성함으로써 이를 쉽게 이해할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이 도구에는 필요한 계산 단계와 LLM이 수익 또는 세금과 관련된 질문이 있을 때 도구를 호출해야 하는지를 알려주는 잘 설계된 프롬프트가 포함될 것입니다.\u003c/p\u003e\n\u003cp\u003e그러나 이 프로세스는 OpenAI 어시스턴트 API와 정확히 동일하지는 않습니다. OpenAI의 문서에 따르면 코드 해석기와 파일 검색 도구는 직접적으로 간단한 방식으로 사용할 수 있지만, 사용자 정의 도구는 약간 다른 방식으로 접근해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eassistant = client.\u003cspan class=\"hljs-property\"\u003ebeta\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eassistants\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\n  name=\u003cspan class=\"hljs-string\"\u003e\"데이터 시각화자\"\u003c/span\u003e,\n  description=\u003cspan class=\"hljs-string\"\u003e\"당신은 아름다운 데이터 시각화를 만드는 데 뛰어나십니다. .csv 파일에 있는 데이터를 분석하며 트렌드를 이해하고 해당 트렌드에 관련된 데이터 시각화를 제시합니다. 또한 관찰된 트렌드에 대한 간단한 텍스트 요약을 공유합니다.\"\u003c/span\u003e,\n  model=\u003cspan class=\"hljs-string\"\u003e\"gpt-4o\"\u003c/span\u003e,\n  tools=[{\u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"code_interpreter\"\u003c/span\u003e}],\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e한 단계씩 세부 내용을 살펴보겠습니다. 다음을 목표로 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e주어진 수익에 기반한 세금을 계산하는 함수 정의하기.\u003c/li\u003e\n\u003cli\u003e이 함수를 사용하는 도구 개발하기.\u003c/li\u003e\n\u003cli\u003e이 도구에 액세스하고 세금 계산이 필요할 때 호출할 수 있는 어시스턴트 만들기.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e어시스턴트 통합을 위한 세금 계산 함수\u003c/h1\u003e\n\u003cp\u003e다음 단락에서 설명하는 세금 계산 도구는 이 글에서 논의된 API를 사용하는 방법을 보여주기 위한 예시로 설계되었음을 유념해 주세요. 실제 세금 계산에 사용해서는 안 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음과 같이 조각별 함수를 고려해 보세요. 이 함수는 주어진 매출에 대한 세금 값을 반환합니다. 입력이 간단한 구문 분석을 위해 문자열로 설정되어 있음을 유의하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003ecalculate_tax\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003erevenue\u003c/span\u003e: str):\n    \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        revenue = \u003cspan class=\"hljs-title function_\"\u003efloat\u003c/span\u003e(revenue)\n    except \u003cspan class=\"hljs-title class_\"\u003eValueError\u003c/span\u003e:\n        raise \u003cspan class=\"hljs-title class_\"\u003eValueError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"매출은 숫자의 문자열 표현이어야 합니다.\"\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e revenue \u0026#x3C;= \u003cspan class=\"hljs-number\"\u003e10000\u003c/span\u003e:\n        tax = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n    elif revenue \u0026#x3C;= \u003cspan class=\"hljs-number\"\u003e30000\u003c/span\u003e:\n        tax = \u003cspan class=\"hljs-number\"\u003e0.10\u003c/span\u003e * (revenue - \u003cspan class=\"hljs-number\"\u003e10000\u003c/span\u003e)\n    elif revenue \u0026#x3C;= \u003cspan class=\"hljs-number\"\u003e70000\u003c/span\u003e:\n        tax = \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e0.20\u003c/span\u003e * (revenue - \u003cspan class=\"hljs-number\"\u003e30000\u003c/span\u003e)\n    elif revenue \u0026#x3C;= \u003cspan class=\"hljs-number\"\u003e150000\u003c/span\u003e:\n        tax = \u003cspan class=\"hljs-number\"\u003e10000\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e0.30\u003c/span\u003e * (revenue - \u003cspan class=\"hljs-number\"\u003e70000\u003c/span\u003e)\n    \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n        tax = \u003cspan class=\"hljs-number\"\u003e34000\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e0.40\u003c/span\u003e * (revenue - \u003cspan class=\"hljs-number\"\u003e150000\u003c/span\u003e)\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e tax\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로, 비서(assistant)를 정의합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efunction_tools = [\n    {\n        \u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"function\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-string\"\u003e\"function\"\u003c/span\u003e: {\n            \u003cspan class=\"hljs-string\"\u003e\"name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"calculate_tax\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"description\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"유로로 주어진 매출에 대한 세금을 가져옵니다.\"\u003c/span\u003e,\n            \u003cspan class=\"hljs-string\"\u003e\"parameters\"\u003c/span\u003e: {\n                \u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"object\"\u003c/span\u003e,\n                \u003cspan class=\"hljs-string\"\u003e\"properties\"\u003c/span\u003e: {\n                    \u003cspan class=\"hljs-string\"\u003e\"revenue\"\u003c/span\u003e: {\n                        \u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"string\"\u003c/span\u003e,\n                        \u003cspan class=\"hljs-string\"\u003e\"description\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"유로로 연간 매출\"\u003c/span\u003e\n                    }\n                },\n                \u003cspan class=\"hljs-string\"\u003e\"required\"\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\"revenue\"\u003c/span\u003e]\n            }\n        }\n    }\n]\n\n# 비서(assistant) 정의\nassistant = client.\u003cspan class=\"hljs-property\"\u003ebeta\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eassistants\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(\n    name=\u003cspan class=\"hljs-string\"\u003e\"Assistant\"\u003c/span\u003e,\n    instructions=\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e,\n    tools=function_tools,\n    model=\u003cspan class=\"hljs-string\"\u003e\"gpt-4o\"\u003c/span\u003e,\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제, 주요한 포인트에 대해서 얘기해볼게요:\u003c/p\u003e\n\u003cp\u003e어시스턴트가 \"calculate_tax\"가 호출될 때 어떻게 함수를 사용하는지 알고 계신가요? 이 부분은 OpenAI 어시스턴트에서 문서화가 잘 되어 있지 않아, 많은 사용자들이 처음 사용할 때 혼동을 겪을 수 있어요. 이를 해결하기 위해, 응담 스트림(response stream)에서 다양한 이벤트를 관리하기 위한 EventHandler를 정의해야 합니다. 특히 \"calculate_tax\" 도구가 호출될 때의 이벤트를 어떻게 처리하는지에 대해 명확히 알아둬야 해요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e    def \u003cspan class=\"hljs-title function_\"\u003ehandle_requires_action\u003c/span\u003e(self, data, run_id):\n        tool_outputs = []\n\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e tool \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e data.\u003cspan class=\"hljs-property\"\u003erequired_action\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esubmit_tool_outputs\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etool_calls\u003c/span\u003e:\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e tool.\u003cspan class=\"hljs-property\"\u003efunction\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e == \u003cspan class=\"hljs-string\"\u003e\"calculate_tax\"\u003c/span\u003e:\n                \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n                    # 도구 매개변수에서 수익 추출\n                    revenue = ast.\u003cspan class=\"hljs-title function_\"\u003eliteral_eval\u003c/span\u003e(tool.\u003cspan class=\"hljs-property\"\u003efunction\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003earguments\u003c/span\u003e)[\u003cspan class=\"hljs-string\"\u003e\"revenue\"\u003c/span\u003e]\n                    # 세금을 계산하는 calculate_tax 함수 호출\n                    tax_result = \u003cspan class=\"hljs-title function_\"\u003ecalculate_tax\u003c/span\u003e(revenue)\n                    # 필요한 형식에 맞게 도구 출력을 추가\n                    tool_outputs.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"tool_call_id\"\u003c/span\u003e: tool.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"output\"\u003c/span\u003e: f\u003cspan class=\"hljs-string\"\u003e\"{tax_result}\"\u003c/span\u003e})\n                except \u003cspan class=\"hljs-title class_\"\u003eValueError\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ee\u003c/span\u003e:\n                    # 세금 계산 시 발생하는 모든 오류 처리\n                    tool_outputs.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"tool_call_id\"\u003c/span\u003e: tool.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"error\"\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(e)})\n        # 모든 도구 출력을 동시에 제출\n        self.\u003cspan class=\"hljs-title function_\"\u003esubmit_tool_outputs\u003c/span\u003e(tool_outputs)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 다음과 같이 동작해요: 동작이 필요한 각 도구 호출에 대해:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\"calculate_tax\" 함수 이름을 확인합니다.\u003c/li\u003e\n\u003cli\u003e툴 매개변수에서 수익 값을 추출합니다.\u003c/li\u003e\n\u003cli\u003e수익을 이용하여 calculate_tax 함수를 호출하여 세금을 계산합니다. (여기서 실제 상호작용이 이루어집니다.)\u003c/li\u003e\n\u003cli\u003e모든 툴 호출을 처리한 후, 수집된 결과를 제출합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e보조 인공지능과 대화하기\u003c/h1\u003e\n\u003cp\u003e다음은 OpenAI가 문서화한 표준 단계를 따라 보조 인공지능과 상호작용할 수 있습니다. 따라서 이 섹션에서는 많은 세부 정보를 제공하지 않겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e스레드 생성: 이는 사용자와 보조 인공지능 간의 대화를 나타냅니다.\u003c/li\u003e\n\u003cli\u003e사용자 메시지 추가: 이는 스레드에 추가되는 텍스트 및 파일을 포함할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e실행 생성: 보조 인공지능과 연관된 모델 및 도구를 활용하여 응답 생성합니다. 이 응답은 다시 스레드에 추가됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래 코드 조각은 특정 사용 사례에서 어시스턴트를 실행하는 방법을 보여줍니다: 코드는 스레드 ID 및 어시스턴트 ID를 사용하는 특정 매개변수를 설정하여 어시스턴트와의 스트리밍 상호작용을 설정합니다. EventHandler 인스턴스는 스트림 중 이벤트를 관리합니다. stream.until_done() 메서드는 모든 상호작용이 완료될 때까지 스트림을 유지합니다. with 문은 스트림이 적절히 닫히도록 보장합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e  \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e client.\u003cspan class=\"hljs-property\"\u003ebeta\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ethreads\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eruns\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estream\u003c/span\u003e(thread_id=st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ethread_id\u003c/span\u003e,\n                                         assistant_id=assistant.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e,\n                                         event_handler=\u003cspan class=\"hljs-title class_\"\u003eEventHandler\u003c/span\u003e(),\n                                         temperature=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estream\u003c/span\u003e:\n        stream.\u003cspan class=\"hljs-title function_\"\u003euntil_done\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eStreamlit 인터페이스\u003c/h1\u003e\n\u003cp\u003e여기서 내 게시물을 마칠 수 있지만, Streamlit 포럼(예: 이 포스트)에서 사용자들이 터미널에서는 정상 작동하지만 인터페이스에서 스트리밍이 작동하지 않는다는 수많은 문의를 발견했습니다. 이것이 나로 하여금 더 깊이 파고들도록 유도했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e스트리밍을 앱에 성공적으로 통합하려면, 앞서 언급한 EventHandler 클래스의 기능을 확장해야 합니다. 특히 텍스트 생성, 텍스트 델타 처리 및 텍스트 완료를 중점적으로 다루어야 합니다. 채팅 히스토리를 관리하면서 Streamlit 인터페이스에 텍스트를 표시하기 위해 필요한 세 가지 주요 단계는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e텍스트 생성 처리 (on_text_created): 어시스턴트의 각 응답마다 새로운 텍스트 상자를 초기화하고 표시하여 이전 작업의 상태를 반영하도록 UI를 업데이트합니다.\u003c/li\u003e\n\u003cli\u003e텍스트 델타 처리 (on_text_delta): 어시스턴트가 텍스트를 생성할 때 현재 텍스트 상자를 동적으로 업데이트하여 전체 UI를 새로 고치지 않고도 점진적으로 변경할 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003e텍스트 완료 처리 (on_text_done): 새로운 빈 텍스트 상자를 추가하여 각 상호작용 세그먼트를 완료하고, 다음 상호작용을 준비합니다. 또한, 대화 세그먼트를 chat_history에 기록합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e예를 들어, 텍스트 델타를 관리하는 다음 코드 조각을 살펴봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eon_text_delta\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eself, delta: TextDelta, snapshot: Text\u003c/span\u003e):\n    \u003cspan class=\"hljs-string\"\u003e\"\"\"\n    텍스트 델타가 생성될 때의 핸들러\n    \"\"\"\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e# 최신 텍스트 상자를 지웁니다.\u003c/span\u003e\n    st.session_state.text_boxes[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].empty()\n    \n    \u003cspan class=\"hljs-comment\"\u003e# 새로운 텍스트가 있으면, 어시스턴트 텍스트 목록의 마지막 요소에 추가합니다.\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e delta.value:\n        st.session_state.assistant_text[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] += delta.value\n    \n    \u003cspan class=\"hljs-comment\"\u003e# 업데이트된 어시스턴트 텍스트를 최신 텍스트 상자에 다시 표시합니다.\u003c/span\u003e\n    st.session_state.text_boxes[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].info(\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e.join(st.session_state[\u003cspan class=\"hljs-string\"\u003e\"assistant_text\"\u003c/span\u003e][-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 코드는 세 가지 주요 작업을 수행합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e최신 텍스트 상자 지우기: 최신 텍스트 상자의 내용을 지워 새 입력을 준비합니다 (st.session_state.text_boxes[-1]).\u003c/li\u003e\n\u003cli\u003e델타 값을 도우미 텍스트에 추가: 새 텍스트 (delta.value)가 있는 경우, 이를 st.session_state.assistant_text[-1]에 저장된 지속적인 도우미 텍스트에 추가합니다.\u003c/li\u003e\n\u003cli\u003e업데이트된 도우미 텍스트 다시 표시: 지금까지 축적된 모든 도우미 텍스트의 내용을 반영하기 위해 최신 텍스트 상자의 내용을 업데이트합니다 (st.session_state[\"assistant_text\"][-1]).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 블로그 포스트에서는 OpenAI Assistant API와 Streamlit을 사용하여 세금을 계산할 수 있는 AI 도우미를 만드는 방법을 보여주었습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저는 Assistant API의 능력을 강조하기 위해 이 간단한 프로젝트를 수행했어요. 문서가 다소 불명확하더라도, 목표는 모호한 부분을 명확하게 하고 Assistant API를 사용하고자 하는 분들에게 일부 지침을 제공하는 것이었습니다. 이 게시물이 도움이 되었으면 좋겠고, 이 강력한 도구로 더 많은 가능성을 탐험하도록 격려하길 바랍니다.\u003c/p\u003e\n\u003cp\u003e공간 제약으로 인해 불필요한 코드 조각을 포함하지 않으려고 노력했어요. 그러나 필요한 경우, 제 Github 저장소를 방문하여 전체 구현 내용을 확인해주세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-CreatinganAssistantwithOpenAIAssistantAPIandStreamlit"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>