<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>시계열 회귀 및 교차 검증 깔끔한 접근 방식 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="시계열 회귀 및 교차 검증 깔끔한 접근 방식 | itposting" data-gatsby-head="true"/><meta property="og:title" content="시계열 회귀 및 교차 검증 깔끔한 접근 방식 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach" data-gatsby-head="true"/><meta name="twitter:title" content="시계열 회귀 및 교차 검증 깔끔한 접근 방식 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 20:22" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-0fd008072af5a644.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_buildManifest.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">시계열 회귀 및 교차 검증 깔끔한 접근 방식</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="시계열 회귀 및 교차 검증 깔끔한 접근 방식" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_0.png" alt="Image"></p>
<p>시계열 예측 방법은 항상 발전하고 있습니다. ARIMA가 오랫동안 기초를 이루어 왔지만, 머신러닝 모델도 큰 약속을 보여줍니다. 다양한 산업 분야에서 자료를 시간에 따라 더 정확하게 모델링할 수 있는 경우가 있습니다. 이 글에서는 그 중 하나인 매출 예측을 다루어 보겠습니다. 소중한 시간을 아끼기 위해, 바로 본문으로 넘어가겠습니다.</p>
<h1>코드</h1>
<p>이 글에서 모든 것을 재현하는 코드는 제 GitHub 저장소에서 찾을 수 있습니다.</p>
<h1>데이터 세트</h1>
<p>이 연습에서는 Kaggle에서 Samuel Cortinhas가 공개한 CC0: Public 도메인으로 제공되는 시계열 데이터 연습 데이터 세트를 사용합니다. 이 데이터 세트는 10년(2010년부터 2019년) 동안의 모의 시계열 데이터를 포함하며 날짜, 상점 ID, 제품 ID 및 매출 기능이 포함되어 있습니다. 이 분석에서는 회귀 구성 요소에 초점을 맞추기 위해 단일 상점과 제품을 선택했습니다.</p>
<p><img src="/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_1.png" alt=""></p>
<h1>시계열 분석</h1>
<h2>단계 0: 설정하기</h2>
<p>나는 데이터 탐색과 회귀를 위해 다음 패키지들을 사용할 것입니다. 로딩하기 전에 아래 명령어를 사용하여 설치할 수 있습니다: install.packages("package_name").</p>
<pre><code class="hljs language-js"># 필요한 라이브러리 로딩하기
<span class="hljs-title function_">library</span>(tidyverse)
<span class="hljs-title function_">library</span>(lubridate)
<span class="hljs-title function_">library</span>(tidymodels)
<span class="hljs-title function_">library</span>(modeltime)
<span class="hljs-title function_">library</span>(timetk)
<span class="hljs-title function_">library</span>(viridis)
</code></pre>
<h2>Step 1: 날짜 및 해당할 수 있는 모든 것들!!</h2>
<p>날짜는 제가 가장 좋아하는 변수입니다. 하나의 날짜 열은 많은 정보를 담고 있어요. 이 시나리오에서는 판매와의 관계를 탐색하기 위해 날짜 열에서 새로운 특징들을 만들 거에요. 하지만 먼저, 날짜 열을 문자열로만 사용하는 것보다는 as.Date()를 사용하여 정리할 거에요.</p>
<pre><code class="hljs language-r">data <span class="hljs-operator">&#x3C;-</span> data <span class="hljs-operator">%>%</span>
  mutate<span class="hljs-punctuation">(</span>date <span class="hljs-operator">=</span> as.Date<span class="hljs-punctuation">(</span>date<span class="hljs-punctuation">,</span> format <span class="hljs-operator">=</span> <span class="hljs-string">"%m/%d/%Y"</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>
</code></pre>
<p>다음으로 회귀 분석을 위해 이 날짜 열에서 새로운 특징들을 만들 거에요. Lubridate 패키지는 이 작업을 간단하게 만들어 주는 편리한 함수들로 구성돼 있어요.</p>
<pre><code class="hljs language-r"><span class="hljs-comment"># 시간과 관련된 요소를 포함하기 위해 데이터 전처리</span>
df <span class="hljs-operator">&#x3C;-</span> data <span class="hljs-operator">%>%</span>
  mutate<span class="hljs-punctuation">(</span>
    year <span class="hljs-operator">=</span> year<span class="hljs-punctuation">(</span>date<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>
    semester <span class="hljs-operator">=</span> factor<span class="hljs-punctuation">(</span>semester<span class="hljs-punctuation">(</span>date<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>
    quarter <span class="hljs-operator">=</span> factor<span class="hljs-punctuation">(</span>quarter<span class="hljs-punctuation">(</span>date<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>
    day_in_week <span class="hljs-operator">=</span> factor<span class="hljs-punctuation">(</span>wday<span class="hljs-punctuation">(</span>date<span class="hljs-punctuation">,</span> label <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>
    week_in_year <span class="hljs-operator">=</span> factor<span class="hljs-punctuation">(</span>week<span class="hljs-punctuation">(</span>date<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>
    day_in_year <span class="hljs-operator">=</span> factor<span class="hljs-punctuation">(</span>yday<span class="hljs-punctuation">(</span>date<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>
    month <span class="hljs-operator">=</span> factor<span class="hljs-punctuation">(</span>month<span class="hljs-punctuation">(</span>date<span class="hljs-punctuation">,</span> label <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span>
  <span class="hljs-punctuation">)</span>
</code></pre>
<p>이제 데이터가 다음과 같이 보입니다:</p>
<p><img src="/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_2.png" alt="image"></p>
<h2>단계 2: 탐색적 데이터 분석</h2>
<p>단일 날짜 열에서 생성된 모든 이러한 새로운 흥미로운 기능들과 매출과의 관골을 탐색해 볼 것입니다. 연간 계절성부터 시작하겠습니다.</p>
<pre><code class="hljs language-js">df %>%
  <span class="hljs-title function_">ggplot</span>(<span class="hljs-title function_">aes</span>(date, sales)) +
  <span class="hljs-title function_">geom_line</span>(alpha = <span class="hljs-number">1</span>, size = <span class="hljs-number">1</span>, color = <span class="hljs-string">"darkblue"</span>) +  
  <span class="hljs-title function_">theme_bw</span>() +
  <span class="hljs-title function_">labs</span>(title = <span class="hljs-string">"일별 매출 분포 변화"</span>, x = <span class="hljs-string">"날짜"</span>, y = <span class="hljs-string">"매출"</span>) +
  <span class="hljs-title function_">scale_x_date</span>(date_labels = <span class="hljs-string">"%Y"</span>, date_breaks = <span class="hljs-string">"2 years"</span>) +  
  <span class="hljs-title function_">scale_y_continuous</span>(labels = <span class="hljs-attr">scales</span>::comma) 
</code></pre>
<p>매출 데이터에는 명확한 계절성과 특정한 추세가 있습니다. 이제 요일과의 관계를 살펴보겠습니다.</p>
<pre><code class="hljs language-js">df %>%
  <span class="hljs-title function_">ggplot</span>(<span class="hljs-title function_">aes</span>(day_in_week, sales, color = day_in_week)) +
  <span class="hljs-title function_">geom_boxplot</span>() +
  <span class="hljs-title function_">geom_jitter</span>(alpha = <span class="hljs-number">0.1</span>) +
  <span class="hljs-title function_">theme_bw</span>() +
  <span class="hljs-title function_">scale_colour_viridis_d</span>() +
  <span class="hljs-title function_">labs</span>(title = <span class="hljs-string">"요일별 일일 매출 분포"</span>, x = <span class="hljs-string">"요일"</span>, y = <span class="hljs-string">"매출"</span>) +
  <span class="hljs-title function_">scale_x_discrete</span>() +
  <span class="hljs-title function_">scale_y_continuous</span>(labels = <span class="hljs-attr">scales</span>::comma)
</code></pre>
<p><img src="/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_4.png" alt="Image"></p>
<p>이제 월별 분포를 살펴보겠습니다.</p>
<pre><code class="hljs language-js">df |> 
  <span class="hljs-title function_">ggplot</span>(<span class="hljs-title function_">aes</span>(month, sales)) +
  <span class="hljs-title function_">geom_violin</span>(color = <span class="hljs-string">"darkgreen"</span>) +  
  <span class="hljs-title function_">geom_jitter</span>(alpha = <span class="hljs-number">0.2</span>, <span class="hljs-title function_">aes</span>(color = sales)) +  
  <span class="hljs-title function_">theme_light</span>() +
  <span class="hljs-title function_">geom_smooth</span>(method = <span class="hljs-string">"loess"</span>, se = <span class="hljs-variable constant_">FALSE</span>) +  
  <span class="hljs-title function_">scale_colour_viridis_c</span>() +
  <span class="hljs-title function_">labs</span>(title = <span class="hljs-string">"Daily Sales Distribution by Month"</span>, x = <span class="hljs-string">""</span>, y = <span class="hljs-string">"Sales"</span>, color= <span class="hljs-string">"Sales"</span>)
</code></pre>
<p><img src="/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_5.png" alt="Image"></p>
<p>이제 모델링으로 넘어가겠습니다.</p>
<h2>단계 3: 데이터 분할 및 교차 검증 설정</h2>
<p>tidymodels에서 제공하는 initial_time_split() 함수를 사용하여 데이터를 학습 및 테스트 세트로 나누겠습니다.</p>
<pre><code class="hljs language-R">df_split <span class="hljs-operator">&#x3C;-</span> df <span class="hljs-operator">|></span> 
  initial_time_split<span class="hljs-punctuation">(</span>prop<span class="hljs-operator">=</span><span class="hljs-number">0.9</span><span class="hljs-punctuation">)</span>  <span class="hljs-comment"># 90% 데이터를 학습에, 10%를 테스트에 할당</span>

df_train <span class="hljs-operator">&#x3C;-</span> training<span class="hljs-punctuation">(</span>df_split<span class="hljs-punctuation">)</span>
df_test <span class="hljs-operator">&#x3C;-</span> testing<span class="hljs-punctuation">(</span>df_split<span class="hljs-punctuation">)</span>
</code></pre>
<p>이것이 분할의 모습입니다:</p>
<p>교차 검증은 입력 데이터의 하위 집합에서 모델을 학습시키고 나머지 데이터에서 평가하여 모델을 평가하는 데 사용할 수 있습니다. 일반적인 교차 검증 방법은 데이터 포인트를 무작위로 선택하여 학습 데이터 집합에 할당합니다. 그러나 이 방법은 데이터가 순차적이어야하기 때문에 시계열에 적합하지 않습니다. Timetk 패키지에는 시계열 데이터 세트에 대한 교차 검증 폴드를 특별히 생성하고 해당 분할을 시각화하는 데 사용할 수있는 멋진 함수인 time_series_cv()가 있습니다.</p>
<pre><code class="hljs language-R"><span class="hljs-comment"># 교차 검증 분할 생성</span>
df_folds <span class="hljs-operator">&#x3C;-</span> 
  time_series_cv<span class="hljs-punctuation">(</span>
    df_train<span class="hljs-punctuation">,</span> 
    initial <span class="hljs-operator">=</span> <span class="hljs-string">"3 years"</span><span class="hljs-punctuation">,</span> 
    assess <span class="hljs-operator">=</span> <span class="hljs-string">"1 year"</span><span class="hljs-punctuation">,</span> 
    skip <span class="hljs-operator">=</span> <span class="hljs-string">"6 months"</span><span class="hljs-punctuation">,</span>
    slice_limit <span class="hljs-operator">=</span> <span class="hljs-number">5</span><span class="hljs-punctuation">)</span>  

<span class="hljs-comment"># 분할 시각화</span>
plot_time_series_cv_plan<span class="hljs-punctuation">(</span>df_folds<span class="hljs-punctuation">,</span> date<span class="hljs-punctuation">,</span> sales<span class="hljs-punctuation">)</span>
</code></pre>
<h2>단계 4: 모델링을 위한 데이터 준비</h2>
<p>레시피는 새로운 예측 변수를 만들고 모델에서 필요한 몇 가지 전처리를 수행할 수 있는 객체입니다. 저는 auto ARIMA 및 랜덤 포레스트 두 모델을 시도하고 싶기 때문에 두 레시피 객체를 만들 것입니다. 레시피()의 첫 번째 단계는 회귀 분석을 위한 공식입니다.</p>
<pre><code class="hljs language-js">recipe_autoarima &#x3C;- 
  <span class="hljs-title function_">recipe</span>(sales ~ date,
         data = df_train)
</code></pre>
<p>두 번째 랜덤 포레스트 레시피에는 step_holiday()를 사용하여 date 데이터를 공휴일에 대한 하나 이상의 이진 지표 변수로 변환하는 기능을 추가할 것입니다. 또한 step_rm()을 사용하여 date 열을 제거하고 step_dummy()를 사용하여 모든 명목 예측 변수를 더미 변수로 변환할 것입니다.</p>
<pre><code class="hljs language-js">recipe_rf &#x3C;- 
  <span class="hljs-title function_">recipe</span>(sales ~ ., data = df_train) |>
  <span class="hljs-title function_">step_holiday</span>(date, holidays = <span class="hljs-attr">timeDate</span>::<span class="hljs-title function_">listHolidays</span>(<span class="hljs-string">"US"</span>)) |>  
  <span class="hljs-title function_">step_rm</span>(date) |>  
  <span class="hljs-title function_">step_dummy</span>(<span class="hljs-title function_">all_nominal_predictors</span>())
</code></pre>
<p>다음은 recipe 객체가 보이는 모습입니다:</p>
<p><img src="/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_8.png" alt="Recipe Object"></p>
<p>레시피 객체는 학습 및 테스트 데이터셋에서 반복 가능한 단계 시퀀스를 만들어주어 긴 피처 엔지니어링 코드를 작성하지 않고도 사용할 수 있습니다. 저는 이를 피처 엔지니어링의 단축키로 생각해요!</p>
<p>아래 명령은 레시피 객체가 데이터셋을 업데이트하고 새로 생성된 열을 이해하는 데 사용될 수 있습니다.</p>
<pre><code class="hljs language-js">recipe_rf |> <span class="hljs-title function_">prep</span>() |> <span class="hljs-title function_">bake</span>(new_data = <span class="hljs-variable constant_">NULL</span>)
</code></pre>
<h2>단계 5: 모델 사양 및 재표본화</h2>
<p>레시피를 만들면, 각각의 두 모델에 대한 명세서를 작성할 것입니다. ARIMA에 Modeltime을 사용하고 랜덤 포레스트에는 Tidymodels를 사용할 예정이에요. 이것들은 일관된 단계적 흐름으로 여러 모델에 대한 명세를 만드는 훌륭한 방법을 제공합니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Auto</span> <span class="hljs-variable constant_">ARIMA</span> 모델 명세
auto_arima_spec &#x3C;- <span class="hljs-title function_">arima_boost</span>() |> 
  <span class="hljs-title function_">set_mode</span>(<span class="hljs-string">"regression"</span>) |> 
  <span class="hljs-title function_">set_engine</span>(<span class="hljs-string">'auto_arima_xgboost'</span>)

# <span class="hljs-title class_">Random</span> <span class="hljs-title class_">Forest</span> 모델 명세
rf_spec &#x3C;- 
  <span class="hljs-title function_">rand_forest</span>(trees = <span class="hljs-number">500</span>) |>  
  <span class="hljs-title function_">set_mode</span>(<span class="hljs-string">"regression"</span>) |> 
  <span class="hljs-title function_">set_engine</span>(<span class="hljs-string">"ranger"</span>)
</code></pre>
<h2>단계 6: Workflow 세트</h2>
<p>workflow()는 전처리, 모델링, 후처리 요청을 함께 묶을 수 있는 객체입니다. 여러 모델과 리샘플링을 사용할 때, workflow 세트를 사용하는 것이 더 편리하다고 발견했어요.</p>
<p>이제 recipe 객체와 해당하는 모델 사양을 workflow_set()을 사용하여 결합할 것입니다. 기본적으로 cross 파라미터는 TRUE로 설정되어 있어서 각 recipe 객체가 각 모델 사양과 일치하도록 합니다. 이 경우에는 각 recipe 객체가 해당하는 모델 사양과 일치하도록 FALSE로 설정할 것입니다.</p>
<pre><code class="hljs language-js">workflowset_df &#x3C;- 
  <span class="hljs-title function_">workflow_set</span>(
    <span class="hljs-title function_">list</span>(recipe_autoarima, recipe_rf),
    <span class="hljs-title function_">list</span>(auto_arima_spec, rf_spec),
    cross=<span class="hljs-variable constant_">FALSE</span>
  )
</code></pre>
<p>이것이 workflow 객체입니다. 현재 결과가 없지만, 교차 검증이 완료되면 결과를 저장하기 위한 자리 표시자가 있습니다.</p>
<p><img src="/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_9.png" alt="그림"></p>
<h2>단계 7: 모델 학습 시간입니다</h2>
<p>지금까지 새로운 특성을 만들고 데이터를 전처리하고 모델 사양을 만들고 워크플로 세트를 구축했습니다. 이제 훈련 세트 및 리샘플링 폴드를 사용하여 모델을 적합시키겠습니다. 결과를 나중에 분석할 df_results에 결과를 저장할 것입니다.</p>
<pre><code class="hljs language-js">df_results &#x3C;-
  <span class="hljs-title function_">workflow_map</span>(
    workflowset_df,
    <span class="hljs-string">"fit_resamples"</span>,
    resamples = df_folds
  )
</code></pre>
<p>이렇게 하면 workflowset_df의 모든 워크플로에 대해 루프를 반복하고 각각에 fit_resamples 함수를 적용하여 df_folds 교차 검증 객체를 사용합니다. 각 실행의 결과는 df_results의 해당 모델 행 아래에 저장됩니다. 결과 열이 이제 교차 검증 결과로 채워졌음을 유의하십시오. 이러한 결과는 필요한 경우 unnest()를 사용하여 추출할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_10.png" alt="image"></p>
<p>결과는 tidymodels의 정말 멋진 기능인 autoplot() 명령을 사용하여 신속하게 시각화할 수도 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title function_">autoplot</span>(df_results)
</code></pre>
<p><img src="/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_11.png" alt="image"></p>
<p>모든 리샘플에서 랜덤 포레스트가 ARIMA와 비교했을 때 더 낮은 RMSE(평균 제곱근 오차)와 R-제곱을 보여주고 있습니다.</p>
<h2>단계 8: 테스트 데이터 적합</h2>
<p>이제 df_results의 결과를 순위 매겨 가장 낮은 RMSE를 기준으로 가장 성능이 좋은 모델을 식별하겠습니다. 해당 모델의 ID 및 매개변수를 검색하고 이 최적화된 모델을 훈련 데이터에 맞출 것입니다. 그런 다음, 이 모델을 사용하여 테스트 데이터셋에서 판단하고 새로운 지표를 확인하겠습니다.</p>
<pre><code class="hljs language-r"><span class="hljs-comment"># 최고의 rmse를 가진 workflow의 ID 가져오기</span>
best_workflow_id <span class="hljs-operator">&#x3C;-</span> df_results <span class="hljs-operator">%>%</span>
  rank_results<span class="hljs-punctuation">(</span>rank_metric <span class="hljs-operator">=</span> <span class="hljs-string">"rmse"</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">%>%</span>
  head<span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">%>%</span>
  pull<span class="hljs-punctuation">(</span>wflow_id<span class="hljs-punctuation">)</span>  

<span class="hljs-comment">## best_workflow_id와 관련된 매개변수 가져오기</span>
best_params <span class="hljs-operator">&#x3C;-</span> df_results <span class="hljs-operator">%>%</span>
  extract_workflow_set_result<span class="hljs-punctuation">(</span>id <span class="hljs-operator">=</span> best_workflow_id<span class="hljs-punctuation">)</span> <span class="hljs-operator">%>%</span>
  select_best<span class="hljs-punctuation">(</span>metric <span class="hljs-operator">=</span> <span class="hljs-string">"rmse"</span><span class="hljs-punctuation">)</span>  

<span class="hljs-comment">## best_workflow_id와 관련된 workflow 가져오기</span>
best_workflow <span class="hljs-operator">&#x3C;-</span> df_results <span class="hljs-operator">%>%</span>
  extract_workflow<span class="hljs-punctuation">(</span>id <span class="hljs-operator">=</span> best_workflow_id<span class="hljs-punctuation">)</span>  

<span class="hljs-comment"># 최적화된 매개변수로 workflow 완성</span>
finalized_workflow <span class="hljs-operator">&#x3C;-</span> finalize_workflow<span class="hljs-punctuation">(</span>best_workflow<span class="hljs-punctuation">,</span> best_params<span class="hljs-punctuation">)</span> 

finalized_workflow
</code></pre>
<p>다음은 최종 워크플로우의 모습입니다:</p>
<p><img src="/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_12.png" alt="image"></p>
<p>이제 이 워크플로우를 사용하여 fit() 및 augment()를 사용하여 테스트 데이터 세트에서 예측하겠습니다. 이 예측을 기반으로 지표를 측정할 것입니다.</p>
<pre><code class="hljs language-R">predictions <span class="hljs-operator">&#x3C;-</span> finalized_workflow <span class="hljs-operator">%>%</span>
  fit<span class="hljs-punctuation">(</span>df_train<span class="hljs-punctuation">)</span> <span class="hljs-operator">%>%</span>
  augment<span class="hljs-punctuation">(</span>df_test<span class="hljs-punctuation">)</span>  

<span class="hljs-comment">## 평가 지표 계산</span>
evaluation_metrics <span class="hljs-operator">&#x3C;-</span> metric_set<span class="hljs-punctuation">(</span>rmse<span class="hljs-punctuation">,</span> mae<span class="hljs-punctuation">,</span> rsq<span class="hljs-punctuation">)</span>
results <span class="hljs-operator">&#x3C;-</span> evaluation_metrics<span class="hljs-punctuation">(</span>predictions<span class="hljs-punctuation">,</span> truth <span class="hljs-operator">=</span> sales<span class="hljs-punctuation">,</span> estimate <span class="hljs-operator">=</span> .pred<span class="hljs-punctuation">)</span> 
print<span class="hljs-punctuation">(</span>results<span class="hljs-punctuation">)</span>  
</code></pre>
<p>다음은 최종 지표가 표시되는 모습입니다:</p>
<p><img src="/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_13.png" alt="Final Metrics"></p>
<p>정말 잘 했어요!</p>
<h1>성공했어요!</h1>
<p>이 기사를 통해 tidymodels, modeltime 및 timetk가 시계열 회귀 모델을 구축하는 강력한 프레임워크를 제공하는 방법에 대해 명확해졌으면 좋겠고, 여러분이 한 번 시도해볼 것으로 바랍니다! 이 기사는 한 가게와 제품 ID를 위해 만들어 졌지만, 이것은 어떤 가게와 제품 조합에 대해 이를 복제할 수 있는 Shiny 웹 애플리케이션을 구축하기 위한 좋은 사례가 될 수 있습니다. 즐거운 코딩하세요!</p>
<h1>코드</h1>
<p>이 기사의 모든 내용을 다시 만들기 위한 코드는 제 GitHub 저장소에서 찾을 수 있습니다.</p>
<p>마음껏 찾아주세요. LinkedIn에서 저를 찾아보세요.</p>
<p>글에서 언급되지 않는 한, 모든 이미지는 저자가 찍은 것입니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"시계열 회귀 및 교차 검증 깔끔한 접근 방식","description":"","date":"2024-06-19 20:22","slug":"2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach","content":"\n\n![Image](/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_0.png)\n\n시계열 예측 방법은 항상 발전하고 있습니다. ARIMA가 오랫동안 기초를 이루어 왔지만, 머신러닝 모델도 큰 약속을 보여줍니다. 다양한 산업 분야에서 자료를 시간에 따라 더 정확하게 모델링할 수 있는 경우가 있습니다. 이 글에서는 그 중 하나인 매출 예측을 다루어 보겠습니다. 소중한 시간을 아끼기 위해, 바로 본문으로 넘어가겠습니다.\n\n# 코드\n\n이 글에서 모든 것을 재현하는 코드는 제 GitHub 저장소에서 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터 세트\n\n이 연습에서는 Kaggle에서 Samuel Cortinhas가 공개한 CC0: Public 도메인으로 제공되는 시계열 데이터 연습 데이터 세트를 사용합니다. 이 데이터 세트는 10년(2010년부터 2019년) 동안의 모의 시계열 데이터를 포함하며 날짜, 상점 ID, 제품 ID 및 매출 기능이 포함되어 있습니다. 이 분석에서는 회귀 구성 요소에 초점을 맞추기 위해 단일 상점과 제품을 선택했습니다.\n\n![](/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_1.png)\n\n# 시계열 분석\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 0: 설정하기\n\n나는 데이터 탐색과 회귀를 위해 다음 패키지들을 사용할 것입니다. 로딩하기 전에 아래 명령어를 사용하여 설치할 수 있습니다: install.packages(\"package_name\").\n\n```js\n# 필요한 라이브러리 로딩하기\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(tidymodels)\nlibrary(modeltime)\nlibrary(timetk)\nlibrary(viridis)\n``` \n\n## Step 1: 날짜 및 해당할 수 있는 모든 것들!!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n날짜는 제가 가장 좋아하는 변수입니다. 하나의 날짜 열은 많은 정보를 담고 있어요. 이 시나리오에서는 판매와의 관계를 탐색하기 위해 날짜 열에서 새로운 특징들을 만들 거에요. 하지만 먼저, 날짜 열을 문자열로만 사용하는 것보다는 as.Date()를 사용하여 정리할 거에요.\n\n```r\ndata \u003c- data %\u003e%\n  mutate(date = as.Date(date, format = \"%m/%d/%Y\"))\n```\n\n다음으로 회귀 분석을 위해 이 날짜 열에서 새로운 특징들을 만들 거에요. Lubridate 패키지는 이 작업을 간단하게 만들어 주는 편리한 함수들로 구성돼 있어요.\n\n```r\n# 시간과 관련된 요소를 포함하기 위해 데이터 전처리\ndf \u003c- data %\u003e%\n  mutate(\n    year = year(date),\n    semester = factor(semester(date)),\n    quarter = factor(quarter(date)),\n    day_in_week = factor(wday(date, label = TRUE)),\n    week_in_year = factor(week(date)),\n    day_in_year = factor(yday(date)),\n    month = factor(month(date, label = TRUE))\n  )\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 데이터가 다음과 같이 보입니다:\n\n![image](/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_2.png)\n\n## 단계 2: 탐색적 데이터 분석\n\n단일 날짜 열에서 생성된 모든 이러한 새로운 흥미로운 기능들과 매출과의 관골을 탐색해 볼 것입니다. 연간 계절성부터 시작하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\ndf %\u003e%\n  ggplot(aes(date, sales)) +\n  geom_line(alpha = 1, size = 1, color = \"darkblue\") +  \n  theme_bw() +\n  labs(title = \"일별 매출 분포 변화\", x = \"날짜\", y = \"매출\") +\n  scale_x_date(date_labels = \"%Y\", date_breaks = \"2 years\") +  \n  scale_y_continuous(labels = scales::comma) \n```\n\n\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_3.png\" /\u003e\n\n매출 데이터에는 명확한 계절성과 특정한 추세가 있습니다. 이제 요일과의 관계를 살펴보겠습니다.\n\n```js\ndf %\u003e%\n  ggplot(aes(day_in_week, sales, color = day_in_week)) +\n  geom_boxplot() +\n  geom_jitter(alpha = 0.1) +\n  theme_bw() +\n  scale_colour_viridis_d() +\n  labs(title = \"요일별 일일 매출 분포\", x = \"요일\", y = \"매출\") +\n  scale_x_discrete() +\n  scale_y_continuous(labels = scales::comma)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Image](/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_4.png)\n\n이제 월별 분포를 살펴보겠습니다.\n\n```js\ndf |\u003e \n  ggplot(aes(month, sales)) +\n  geom_violin(color = \"darkgreen\") +  \n  geom_jitter(alpha = 0.2, aes(color = sales)) +  \n  theme_light() +\n  geom_smooth(method = \"loess\", se = FALSE) +  \n  scale_colour_viridis_c() +\n  labs(title = \"Daily Sales Distribution by Month\", x = \"\", y = \"Sales\", color= \"Sales\")\n```\n\n![Image](/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_5.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 모델링으로 넘어가겠습니다.\n\n## 단계 3: 데이터 분할 및 교차 검증 설정\n\ntidymodels에서 제공하는 initial_time_split() 함수를 사용하여 데이터를 학습 및 테스트 세트로 나누겠습니다.\n\n```R\ndf_split \u003c- df |\u003e \n  initial_time_split(prop=0.9)  # 90% 데이터를 학습에, 10%를 테스트에 할당\n\ndf_train \u003c- training(df_split)\ndf_test \u003c- testing(df_split)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것이 분할의 모습입니다:\n\n\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_6.png\" /\u003e\n\n교차 검증은 입력 데이터의 하위 집합에서 모델을 학습시키고 나머지 데이터에서 평가하여 모델을 평가하는 데 사용할 수 있습니다. 일반적인 교차 검증 방법은 데이터 포인트를 무작위로 선택하여 학습 데이터 집합에 할당합니다. 그러나 이 방법은 데이터가 순차적이어야하기 때문에 시계열에 적합하지 않습니다. Timetk 패키지에는 시계열 데이터 세트에 대한 교차 검증 폴드를 특별히 생성하고 해당 분할을 시각화하는 데 사용할 수있는 멋진 함수인 time_series_cv()가 있습니다.\n\n```R\n# 교차 검증 분할 생성\ndf_folds \u003c- \n  time_series_cv(\n    df_train, \n    initial = \"3 years\", \n    assess = \"1 year\", \n    skip = \"6 months\",\n    slice_limit = 5)  \n\n# 분할 시각화\nplot_time_series_cv_plan(df_folds, date, sales)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_7.png\" /\u003e\n\n## 단계 4: 모델링을 위한 데이터 준비\n\n레시피는 새로운 예측 변수를 만들고 모델에서 필요한 몇 가지 전처리를 수행할 수 있는 객체입니다. 저는 auto ARIMA 및 랜덤 포레스트 두 모델을 시도하고 싶기 때문에 두 레시피 객체를 만들 것입니다. 레시피()의 첫 번째 단계는 회귀 분석을 위한 공식입니다.\n\n```js\nrecipe_autoarima \u003c- \n  recipe(sales ~ date,\n         data = df_train)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 번째 랜덤 포레스트 레시피에는 step_holiday()를 사용하여 date 데이터를 공휴일에 대한 하나 이상의 이진 지표 변수로 변환하는 기능을 추가할 것입니다. 또한 step_rm()을 사용하여 date 열을 제거하고 step_dummy()를 사용하여 모든 명목 예측 변수를 더미 변수로 변환할 것입니다.\n\n```js\nrecipe_rf \u003c- \n  recipe(sales ~ ., data = df_train) |\u003e\n  step_holiday(date, holidays = timeDate::listHolidays(\"US\")) |\u003e  \n  step_rm(date) |\u003e  \n  step_dummy(all_nominal_predictors())\n```\n\n다음은 recipe 객체가 보이는 모습입니다:\n\n![Recipe Object](/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_8.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n레시피 객체는 학습 및 테스트 데이터셋에서 반복 가능한 단계 시퀀스를 만들어주어 긴 피처 엔지니어링 코드를 작성하지 않고도 사용할 수 있습니다. 저는 이를 피처 엔지니어링의 단축키로 생각해요!\n\n아래 명령은 레시피 객체가 데이터셋을 업데이트하고 새로 생성된 열을 이해하는 데 사용될 수 있습니다.\n\n```js\nrecipe_rf |\u003e prep() |\u003e bake(new_data = NULL)\n```\n\n## 단계 5: 모델 사양 및 재표본화\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n레시피를 만들면, 각각의 두 모델에 대한 명세서를 작성할 것입니다. ARIMA에 Modeltime을 사용하고 랜덤 포레스트에는 Tidymodels를 사용할 예정이에요. 이것들은 일관된 단계적 흐름으로 여러 모델에 대한 명세를 만드는 훌륭한 방법을 제공합니다.\n\n```js\n# Auto ARIMA 모델 명세\nauto_arima_spec \u003c- arima_boost() |\u003e \n  set_mode(\"regression\") |\u003e \n  set_engine('auto_arima_xgboost')\n\n# Random Forest 모델 명세\nrf_spec \u003c- \n  rand_forest(trees = 500) |\u003e  \n  set_mode(\"regression\") |\u003e \n  set_engine(\"ranger\")\n```\n\n## 단계 6: Workflow 세트\n\nworkflow()는 전처리, 모델링, 후처리 요청을 함께 묶을 수 있는 객체입니다. 여러 모델과 리샘플링을 사용할 때, workflow 세트를 사용하는 것이 더 편리하다고 발견했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 recipe 객체와 해당하는 모델 사양을 workflow_set()을 사용하여 결합할 것입니다. 기본적으로 cross 파라미터는 TRUE로 설정되어 있어서 각 recipe 객체가 각 모델 사양과 일치하도록 합니다. 이 경우에는 각 recipe 객체가 해당하는 모델 사양과 일치하도록 FALSE로 설정할 것입니다.\n\n```js\nworkflowset_df \u003c- \n  workflow_set(\n    list(recipe_autoarima, recipe_rf),\n    list(auto_arima_spec, rf_spec),\n    cross=FALSE\n  )\n```\n\n이것이 workflow 객체입니다. 현재 결과가 없지만, 교차 검증이 완료되면 결과를 저장하기 위한 자리 표시자가 있습니다.\n\n![그림](/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_9.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 단계 7: 모델 학습 시간입니다\n\n지금까지 새로운 특성을 만들고 데이터를 전처리하고 모델 사양을 만들고 워크플로 세트를 구축했습니다. 이제 훈련 세트 및 리샘플링 폴드를 사용하여 모델을 적합시키겠습니다. 결과를 나중에 분석할 df_results에 결과를 저장할 것입니다.\n\n```js\ndf_results \u003c-\n  workflow_map(\n    workflowset_df,\n    \"fit_resamples\",\n    resamples = df_folds\n  )\n```\n\n이렇게 하면 workflowset_df의 모든 워크플로에 대해 루프를 반복하고 각각에 fit_resamples 함수를 적용하여 df_folds 교차 검증 객체를 사용합니다. 각 실행의 결과는 df_results의 해당 모델 행 아래에 저장됩니다. 결과 열이 이제 교차 검증 결과로 채워졌음을 유의하십시오. 이러한 결과는 필요한 경우 unnest()를 사용하여 추출할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![image](/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_10.png)\n\n결과는 tidymodels의 정말 멋진 기능인 autoplot() 명령을 사용하여 신속하게 시각화할 수도 있습니다.\n\n```js\nautoplot(df_results)\n```\n\n![image](/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_11.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n모든 리샘플에서 랜덤 포레스트가 ARIMA와 비교했을 때 더 낮은 RMSE(평균 제곱근 오차)와 R-제곱을 보여주고 있습니다.\n\n## 단계 8: 테스트 데이터 적합\n\n이제 df_results의 결과를 순위 매겨 가장 낮은 RMSE를 기준으로 가장 성능이 좋은 모델을 식별하겠습니다. 해당 모델의 ID 및 매개변수를 검색하고 이 최적화된 모델을 훈련 데이터에 맞출 것입니다. 그런 다음, 이 모델을 사용하여 테스트 데이터셋에서 판단하고 새로운 지표를 확인하겠습니다.\n\n```r\n# 최고의 rmse를 가진 workflow의 ID 가져오기\nbest_workflow_id \u003c- df_results %\u003e%\n  rank_results(rank_metric = \"rmse\") %\u003e%\n  head(1) %\u003e%\n  pull(wflow_id)  \n\n## best_workflow_id와 관련된 매개변수 가져오기\nbest_params \u003c- df_results %\u003e%\n  extract_workflow_set_result(id = best_workflow_id) %\u003e%\n  select_best(metric = \"rmse\")  \n\n## best_workflow_id와 관련된 workflow 가져오기\nbest_workflow \u003c- df_results %\u003e%\n  extract_workflow(id = best_workflow_id)  \n\n# 최적화된 매개변수로 workflow 완성\nfinalized_workflow \u003c- finalize_workflow(best_workflow, best_params) \n\nfinalized_workflow\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 최종 워크플로우의 모습입니다:\n\n![image](/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_12.png)\n\n이제 이 워크플로우를 사용하여 fit() 및 augment()를 사용하여 테스트 데이터 세트에서 예측하겠습니다. 이 예측을 기반으로 지표를 측정할 것입니다.\n\n```R\npredictions \u003c- finalized_workflow %\u003e%\n  fit(df_train) %\u003e%\n  augment(df_test)  \n\n## 평가 지표 계산\nevaluation_metrics \u003c- metric_set(rmse, mae, rsq)\nresults \u003c- evaluation_metrics(predictions, truth = sales, estimate = .pred) \nprint(results)  \n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 최종 지표가 표시되는 모습입니다:\n\n![Final Metrics](/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_13.png)\n\n정말 잘 했어요!\n\n# 성공했어요!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사를 통해 tidymodels, modeltime 및 timetk가 시계열 회귀 모델을 구축하는 강력한 프레임워크를 제공하는 방법에 대해 명확해졌으면 좋겠고, 여러분이 한 번 시도해볼 것으로 바랍니다! 이 기사는 한 가게와 제품 ID를 위해 만들어 졌지만, 이것은 어떤 가게와 제품 조합에 대해 이를 복제할 수 있는 Shiny 웹 애플리케이션을 구축하기 위한 좋은 사례가 될 수 있습니다. 즐거운 코딩하세요!\n\n# 코드\n\n이 기사의 모든 내용을 다시 만들기 위한 코드는 제 GitHub 저장소에서 찾을 수 있습니다.\n\n마음껏 찾아주세요. LinkedIn에서 저를 찾아보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n글에서 언급되지 않는 한, 모든 이미지는 저자가 찍은 것입니다.","ogImage":{"url":"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_0.png"},"coverImage":"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_0.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e시계열 예측 방법은 항상 발전하고 있습니다. ARIMA가 오랫동안 기초를 이루어 왔지만, 머신러닝 모델도 큰 약속을 보여줍니다. 다양한 산업 분야에서 자료를 시간에 따라 더 정확하게 모델링할 수 있는 경우가 있습니다. 이 글에서는 그 중 하나인 매출 예측을 다루어 보겠습니다. 소중한 시간을 아끼기 위해, 바로 본문으로 넘어가겠습니다.\u003c/p\u003e\n\u003ch1\u003e코드\u003c/h1\u003e\n\u003cp\u003e이 글에서 모든 것을 재현하는 코드는 제 GitHub 저장소에서 찾을 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e데이터 세트\u003c/h1\u003e\n\u003cp\u003e이 연습에서는 Kaggle에서 Samuel Cortinhas가 공개한 CC0: Public 도메인으로 제공되는 시계열 데이터 연습 데이터 세트를 사용합니다. 이 데이터 세트는 10년(2010년부터 2019년) 동안의 모의 시계열 데이터를 포함하며 날짜, 상점 ID, 제품 ID 및 매출 기능이 포함되어 있습니다. 이 분석에서는 회귀 구성 요소에 초점을 맞추기 위해 단일 상점과 제품을 선택했습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_1.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch1\u003e시계열 분석\u003c/h1\u003e\n\u003ch2\u003e단계 0: 설정하기\u003c/h2\u003e\n\u003cp\u003e나는 데이터 탐색과 회귀를 위해 다음 패키지들을 사용할 것입니다. 로딩하기 전에 아래 명령어를 사용하여 설치할 수 있습니다: install.packages(\"package_name\").\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 필요한 라이브러리 로딩하기\n\u003cspan class=\"hljs-title function_\"\u003elibrary\u003c/span\u003e(tidyverse)\n\u003cspan class=\"hljs-title function_\"\u003elibrary\u003c/span\u003e(lubridate)\n\u003cspan class=\"hljs-title function_\"\u003elibrary\u003c/span\u003e(tidymodels)\n\u003cspan class=\"hljs-title function_\"\u003elibrary\u003c/span\u003e(modeltime)\n\u003cspan class=\"hljs-title function_\"\u003elibrary\u003c/span\u003e(timetk)\n\u003cspan class=\"hljs-title function_\"\u003elibrary\u003c/span\u003e(viridis)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eStep 1: 날짜 및 해당할 수 있는 모든 것들!!\u003c/h2\u003e\n\u003cp\u003e날짜는 제가 가장 좋아하는 변수입니다. 하나의 날짜 열은 많은 정보를 담고 있어요. 이 시나리오에서는 판매와의 관계를 탐색하기 위해 날짜 열에서 새로운 특징들을 만들 거에요. 하지만 먼저, 날짜 열을 문자열로만 사용하는 것보다는 as.Date()를 사용하여 정리할 거에요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-r\"\u003edata \u003cspan class=\"hljs-operator\"\u003e\u0026#x3C;-\u003c/span\u003e data \u003cspan class=\"hljs-operator\"\u003e%\u003e%\u003c/span\u003e\n  mutate\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edate \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e as.Date\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edate\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e format \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"%m/%d/%Y\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음으로 회귀 분석을 위해 이 날짜 열에서 새로운 특징들을 만들 거에요. Lubridate 패키지는 이 작업을 간단하게 만들어 주는 편리한 함수들로 구성돼 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-r\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 시간과 관련된 요소를 포함하기 위해 데이터 전처리\u003c/span\u003e\ndf \u003cspan class=\"hljs-operator\"\u003e\u0026#x3C;-\u003c/span\u003e data \u003cspan class=\"hljs-operator\"\u003e%\u003e%\u003c/span\u003e\n  mutate\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003e\n    year \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e year\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edate\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    semester \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e factor\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003esemester\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edate\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    quarter \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e factor\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003equarter\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edate\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    day_in_week \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e factor\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003ewday\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edate\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e label \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eTRUE\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    week_in_year \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e factor\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003eweek\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edate\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    day_in_year \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e factor\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003eyday\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edate\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    month \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e factor\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003emonth\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edate\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e label \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eTRUE\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 데이터가 다음과 같이 보입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_2.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ch2\u003e단계 2: 탐색적 데이터 분석\u003c/h2\u003e\n\u003cp\u003e단일 날짜 열에서 생성된 모든 이러한 새로운 흥미로운 기능들과 매출과의 관골을 탐색해 볼 것입니다. 연간 계절성부터 시작하겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edf %\u003e%\n  \u003cspan class=\"hljs-title function_\"\u003eggplot\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eaes\u003c/span\u003e(date, sales)) +\n  \u003cspan class=\"hljs-title function_\"\u003egeom_line\u003c/span\u003e(alpha = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, size = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, color = \u003cspan class=\"hljs-string\"\u003e\"darkblue\"\u003c/span\u003e) +  \n  \u003cspan class=\"hljs-title function_\"\u003etheme_bw\u003c/span\u003e() +\n  \u003cspan class=\"hljs-title function_\"\u003elabs\u003c/span\u003e(title = \u003cspan class=\"hljs-string\"\u003e\"일별 매출 분포 변화\"\u003c/span\u003e, x = \u003cspan class=\"hljs-string\"\u003e\"날짜\"\u003c/span\u003e, y = \u003cspan class=\"hljs-string\"\u003e\"매출\"\u003c/span\u003e) +\n  \u003cspan class=\"hljs-title function_\"\u003escale_x_date\u003c/span\u003e(date_labels = \u003cspan class=\"hljs-string\"\u003e\"%Y\"\u003c/span\u003e, date_breaks = \u003cspan class=\"hljs-string\"\u003e\"2 years\"\u003c/span\u003e) +  \n  \u003cspan class=\"hljs-title function_\"\u003escale_y_continuous\u003c/span\u003e(labels = \u003cspan class=\"hljs-attr\"\u003escales\u003c/span\u003e::comma) \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e매출 데이터에는 명확한 계절성과 특정한 추세가 있습니다. 이제 요일과의 관계를 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edf %\u003e%\n  \u003cspan class=\"hljs-title function_\"\u003eggplot\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eaes\u003c/span\u003e(day_in_week, sales, color = day_in_week)) +\n  \u003cspan class=\"hljs-title function_\"\u003egeom_boxplot\u003c/span\u003e() +\n  \u003cspan class=\"hljs-title function_\"\u003egeom_jitter\u003c/span\u003e(alpha = \u003cspan class=\"hljs-number\"\u003e0.1\u003c/span\u003e) +\n  \u003cspan class=\"hljs-title function_\"\u003etheme_bw\u003c/span\u003e() +\n  \u003cspan class=\"hljs-title function_\"\u003escale_colour_viridis_d\u003c/span\u003e() +\n  \u003cspan class=\"hljs-title function_\"\u003elabs\u003c/span\u003e(title = \u003cspan class=\"hljs-string\"\u003e\"요일별 일일 매출 분포\"\u003c/span\u003e, x = \u003cspan class=\"hljs-string\"\u003e\"요일\"\u003c/span\u003e, y = \u003cspan class=\"hljs-string\"\u003e\"매출\"\u003c/span\u003e) +\n  \u003cspan class=\"hljs-title function_\"\u003escale_x_discrete\u003c/span\u003e() +\n  \u003cspan class=\"hljs-title function_\"\u003escale_y_continuous\u003c/span\u003e(labels = \u003cspan class=\"hljs-attr\"\u003escales\u003c/span\u003e::comma)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_4.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 월별 분포를 살펴보겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edf |\u003e \n  \u003cspan class=\"hljs-title function_\"\u003eggplot\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eaes\u003c/span\u003e(month, sales)) +\n  \u003cspan class=\"hljs-title function_\"\u003egeom_violin\u003c/span\u003e(color = \u003cspan class=\"hljs-string\"\u003e\"darkgreen\"\u003c/span\u003e) +  \n  \u003cspan class=\"hljs-title function_\"\u003egeom_jitter\u003c/span\u003e(alpha = \u003cspan class=\"hljs-number\"\u003e0.2\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003eaes\u003c/span\u003e(color = sales)) +  \n  \u003cspan class=\"hljs-title function_\"\u003etheme_light\u003c/span\u003e() +\n  \u003cspan class=\"hljs-title function_\"\u003egeom_smooth\u003c/span\u003e(method = \u003cspan class=\"hljs-string\"\u003e\"loess\"\u003c/span\u003e, se = \u003cspan class=\"hljs-variable constant_\"\u003eFALSE\u003c/span\u003e) +  \n  \u003cspan class=\"hljs-title function_\"\u003escale_colour_viridis_c\u003c/span\u003e() +\n  \u003cspan class=\"hljs-title function_\"\u003elabs\u003c/span\u003e(title = \u003cspan class=\"hljs-string\"\u003e\"Daily Sales Distribution by Month\"\u003c/span\u003e, x = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e, y = \u003cspan class=\"hljs-string\"\u003e\"Sales\"\u003c/span\u003e, color= \u003cspan class=\"hljs-string\"\u003e\"Sales\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_5.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 모델링으로 넘어가겠습니다.\u003c/p\u003e\n\u003ch2\u003e단계 3: 데이터 분할 및 교차 검증 설정\u003c/h2\u003e\n\u003cp\u003etidymodels에서 제공하는 initial_time_split() 함수를 사용하여 데이터를 학습 및 테스트 세트로 나누겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-R\"\u003edf_split \u003cspan class=\"hljs-operator\"\u003e\u0026#x3C;-\u003c/span\u003e df \u003cspan class=\"hljs-operator\"\u003e|\u003e\u003c/span\u003e \n  initial_time_split\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003eprop\u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e0.9\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e  \u003cspan class=\"hljs-comment\"\u003e# 90% 데이터를 학습에, 10%를 테스트에 할당\u003c/span\u003e\n\ndf_train \u003cspan class=\"hljs-operator\"\u003e\u0026#x3C;-\u003c/span\u003e training\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edf_split\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\ndf_test \u003cspan class=\"hljs-operator\"\u003e\u0026#x3C;-\u003c/span\u003e testing\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edf_split\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것이 분할의 모습입니다:\u003c/p\u003e\n\u003cp\u003e교차 검증은 입력 데이터의 하위 집합에서 모델을 학습시키고 나머지 데이터에서 평가하여 모델을 평가하는 데 사용할 수 있습니다. 일반적인 교차 검증 방법은 데이터 포인트를 무작위로 선택하여 학습 데이터 집합에 할당합니다. 그러나 이 방법은 데이터가 순차적이어야하기 때문에 시계열에 적합하지 않습니다. Timetk 패키지에는 시계열 데이터 세트에 대한 교차 검증 폴드를 특별히 생성하고 해당 분할을 시각화하는 데 사용할 수있는 멋진 함수인 time_series_cv()가 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-R\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 교차 검증 분할 생성\u003c/span\u003e\ndf_folds \u003cspan class=\"hljs-operator\"\u003e\u0026#x3C;-\u003c/span\u003e \n  time_series_cv\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003e\n    df_train\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e \n    initial \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"3 years\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e \n    assess \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"1 year\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e \n    skip \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"6 months\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e\n    slice_limit \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e  \n\n\u003cspan class=\"hljs-comment\"\u003e# 분할 시각화\u003c/span\u003e\nplot_time_series_cv_plan\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edf_folds\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e date\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e sales\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e단계 4: 모델링을 위한 데이터 준비\u003c/h2\u003e\n\u003cp\u003e레시피는 새로운 예측 변수를 만들고 모델에서 필요한 몇 가지 전처리를 수행할 수 있는 객체입니다. 저는 auto ARIMA 및 랜덤 포레스트 두 모델을 시도하고 싶기 때문에 두 레시피 객체를 만들 것입니다. 레시피()의 첫 번째 단계는 회귀 분석을 위한 공식입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003erecipe_autoarima \u0026#x3C;- \n  \u003cspan class=\"hljs-title function_\"\u003erecipe\u003c/span\u003e(sales ~ date,\n         data = df_train)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 번째 랜덤 포레스트 레시피에는 step_holiday()를 사용하여 date 데이터를 공휴일에 대한 하나 이상의 이진 지표 변수로 변환하는 기능을 추가할 것입니다. 또한 step_rm()을 사용하여 date 열을 제거하고 step_dummy()를 사용하여 모든 명목 예측 변수를 더미 변수로 변환할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003erecipe_rf \u0026#x3C;- \n  \u003cspan class=\"hljs-title function_\"\u003erecipe\u003c/span\u003e(sales ~ ., data = df_train) |\u003e\n  \u003cspan class=\"hljs-title function_\"\u003estep_holiday\u003c/span\u003e(date, holidays = \u003cspan class=\"hljs-attr\"\u003etimeDate\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003elistHolidays\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"US\"\u003c/span\u003e)) |\u003e  \n  \u003cspan class=\"hljs-title function_\"\u003estep_rm\u003c/span\u003e(date) |\u003e  \n  \u003cspan class=\"hljs-title function_\"\u003estep_dummy\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eall_nominal_predictors\u003c/span\u003e())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음은 recipe 객체가 보이는 모습입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_8.png\" alt=\"Recipe Object\"\u003e\u003c/p\u003e\n\u003cp\u003e레시피 객체는 학습 및 테스트 데이터셋에서 반복 가능한 단계 시퀀스를 만들어주어 긴 피처 엔지니어링 코드를 작성하지 않고도 사용할 수 있습니다. 저는 이를 피처 엔지니어링의 단축키로 생각해요!\u003c/p\u003e\n\u003cp\u003e아래 명령은 레시피 객체가 데이터셋을 업데이트하고 새로 생성된 열을 이해하는 데 사용될 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003erecipe_rf |\u003e \u003cspan class=\"hljs-title function_\"\u003eprep\u003c/span\u003e() |\u003e \u003cspan class=\"hljs-title function_\"\u003ebake\u003c/span\u003e(new_data = \u003cspan class=\"hljs-variable constant_\"\u003eNULL\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e단계 5: 모델 사양 및 재표본화\u003c/h2\u003e\n\u003cp\u003e레시피를 만들면, 각각의 두 모델에 대한 명세서를 작성할 것입니다. ARIMA에 Modeltime을 사용하고 랜덤 포레스트에는 Tidymodels를 사용할 예정이에요. 이것들은 일관된 단계적 흐름으로 여러 모델에 대한 명세를 만드는 훌륭한 방법을 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003eAuto\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eARIMA\u003c/span\u003e 모델 명세\nauto_arima_spec \u0026#x3C;- \u003cspan class=\"hljs-title function_\"\u003earima_boost\u003c/span\u003e() |\u003e \n  \u003cspan class=\"hljs-title function_\"\u003eset_mode\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"regression\"\u003c/span\u003e) |\u003e \n  \u003cspan class=\"hljs-title function_\"\u003eset_engine\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'auto_arima_xgboost'\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-title class_\"\u003eRandom\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eForest\u003c/span\u003e 모델 명세\nrf_spec \u0026#x3C;- \n  \u003cspan class=\"hljs-title function_\"\u003erand_forest\u003c/span\u003e(trees = \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e) |\u003e  \n  \u003cspan class=\"hljs-title function_\"\u003eset_mode\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"regression\"\u003c/span\u003e) |\u003e \n  \u003cspan class=\"hljs-title function_\"\u003eset_engine\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ranger\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e단계 6: Workflow 세트\u003c/h2\u003e\n\u003cp\u003eworkflow()는 전처리, 모델링, 후처리 요청을 함께 묶을 수 있는 객체입니다. 여러 모델과 리샘플링을 사용할 때, workflow 세트를 사용하는 것이 더 편리하다고 발견했어요.\u003c/p\u003e\n\u003cp\u003e이제 recipe 객체와 해당하는 모델 사양을 workflow_set()을 사용하여 결합할 것입니다. 기본적으로 cross 파라미터는 TRUE로 설정되어 있어서 각 recipe 객체가 각 모델 사양과 일치하도록 합니다. 이 경우에는 각 recipe 객체가 해당하는 모델 사양과 일치하도록 FALSE로 설정할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eworkflowset_df \u0026#x3C;- \n  \u003cspan class=\"hljs-title function_\"\u003eworkflow_set\u003c/span\u003e(\n    \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e(recipe_autoarima, recipe_rf),\n    \u003cspan class=\"hljs-title function_\"\u003elist\u003c/span\u003e(auto_arima_spec, rf_spec),\n    cross=\u003cspan class=\"hljs-variable constant_\"\u003eFALSE\u003c/span\u003e\n  )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이것이 workflow 객체입니다. 현재 결과가 없지만, 교차 검증이 완료되면 결과를 저장하기 위한 자리 표시자가 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_9.png\" alt=\"그림\"\u003e\u003c/p\u003e\n\u003ch2\u003e단계 7: 모델 학습 시간입니다\u003c/h2\u003e\n\u003cp\u003e지금까지 새로운 특성을 만들고 데이터를 전처리하고 모델 사양을 만들고 워크플로 세트를 구축했습니다. 이제 훈련 세트 및 리샘플링 폴드를 사용하여 모델을 적합시키겠습니다. 결과를 나중에 분석할 df_results에 결과를 저장할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edf_results \u0026#x3C;-\n  \u003cspan class=\"hljs-title function_\"\u003eworkflow_map\u003c/span\u003e(\n    workflowset_df,\n    \u003cspan class=\"hljs-string\"\u003e\"fit_resamples\"\u003c/span\u003e,\n    resamples = df_folds\n  )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이렇게 하면 workflowset_df의 모든 워크플로에 대해 루프를 반복하고 각각에 fit_resamples 함수를 적용하여 df_folds 교차 검증 객체를 사용합니다. 각 실행의 결과는 df_results의 해당 모델 행 아래에 저장됩니다. 결과 열이 이제 교차 검증 결과로 채워졌음을 유의하십시오. 이러한 결과는 필요한 경우 unnest()를 사용하여 추출할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_10.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e결과는 tidymodels의 정말 멋진 기능인 autoplot() 명령을 사용하여 신속하게 시각화할 수도 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eautoplot\u003c/span\u003e(df_results)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_11.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e모든 리샘플에서 랜덤 포레스트가 ARIMA와 비교했을 때 더 낮은 RMSE(평균 제곱근 오차)와 R-제곱을 보여주고 있습니다.\u003c/p\u003e\n\u003ch2\u003e단계 8: 테스트 데이터 적합\u003c/h2\u003e\n\u003cp\u003e이제 df_results의 결과를 순위 매겨 가장 낮은 RMSE를 기준으로 가장 성능이 좋은 모델을 식별하겠습니다. 해당 모델의 ID 및 매개변수를 검색하고 이 최적화된 모델을 훈련 데이터에 맞출 것입니다. 그런 다음, 이 모델을 사용하여 테스트 데이터셋에서 판단하고 새로운 지표를 확인하겠습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-r\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 최고의 rmse를 가진 workflow의 ID 가져오기\u003c/span\u003e\nbest_workflow_id \u003cspan class=\"hljs-operator\"\u003e\u0026#x3C;-\u003c/span\u003e df_results \u003cspan class=\"hljs-operator\"\u003e%\u003e%\u003c/span\u003e\n  rank_results\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003erank_metric \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"rmse\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e%\u003e%\u003c/span\u003e\n  head\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e%\u003e%\u003c/span\u003e\n  pull\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003ewflow_id\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e  \n\n\u003cspan class=\"hljs-comment\"\u003e## best_workflow_id와 관련된 매개변수 가져오기\u003c/span\u003e\nbest_params \u003cspan class=\"hljs-operator\"\u003e\u0026#x3C;-\u003c/span\u003e df_results \u003cspan class=\"hljs-operator\"\u003e%\u003e%\u003c/span\u003e\n  extract_workflow_set_result\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003eid \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e best_workflow_id\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e%\u003e%\u003c/span\u003e\n  select_best\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003emetric \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"rmse\"\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e  \n\n\u003cspan class=\"hljs-comment\"\u003e## best_workflow_id와 관련된 workflow 가져오기\u003c/span\u003e\nbest_workflow \u003cspan class=\"hljs-operator\"\u003e\u0026#x3C;-\u003c/span\u003e df_results \u003cspan class=\"hljs-operator\"\u003e%\u003e%\u003c/span\u003e\n  extract_workflow\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003eid \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e best_workflow_id\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e  \n\n\u003cspan class=\"hljs-comment\"\u003e# 최적화된 매개변수로 workflow 완성\u003c/span\u003e\nfinalized_workflow \u003cspan class=\"hljs-operator\"\u003e\u0026#x3C;-\u003c/span\u003e finalize_workflow\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003ebest_workflow\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e best_params\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e \n\nfinalized_workflow\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음은 최종 워크플로우의 모습입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_12.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 이 워크플로우를 사용하여 fit() 및 augment()를 사용하여 테스트 데이터 세트에서 예측하겠습니다. 이 예측을 기반으로 지표를 측정할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-R\"\u003epredictions \u003cspan class=\"hljs-operator\"\u003e\u0026#x3C;-\u003c/span\u003e finalized_workflow \u003cspan class=\"hljs-operator\"\u003e%\u003e%\u003c/span\u003e\n  fit\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edf_train\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e%\u003e%\u003c/span\u003e\n  augment\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003edf_test\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e  \n\n\u003cspan class=\"hljs-comment\"\u003e## 평가 지표 계산\u003c/span\u003e\nevaluation_metrics \u003cspan class=\"hljs-operator\"\u003e\u0026#x3C;-\u003c/span\u003e metric_set\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003ermse\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e mae\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e rsq\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e\nresults \u003cspan class=\"hljs-operator\"\u003e\u0026#x3C;-\u003c/span\u003e evaluation_metrics\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003epredictions\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e truth \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e sales\u003cspan class=\"hljs-punctuation\"\u003e,\u003c/span\u003e estimate \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e .pred\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e \nprint\u003cspan class=\"hljs-punctuation\"\u003e(\u003c/span\u003eresults\u003cspan class=\"hljs-punctuation\"\u003e)\u003c/span\u003e  \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음은 최종 지표가 표시되는 모습입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach_13.png\" alt=\"Final Metrics\"\u003e\u003c/p\u003e\n\u003cp\u003e정말 잘 했어요!\u003c/p\u003e\n\u003ch1\u003e성공했어요!\u003c/h1\u003e\n\u003cp\u003e이 기사를 통해 tidymodels, modeltime 및 timetk가 시계열 회귀 모델을 구축하는 강력한 프레임워크를 제공하는 방법에 대해 명확해졌으면 좋겠고, 여러분이 한 번 시도해볼 것으로 바랍니다! 이 기사는 한 가게와 제품 ID를 위해 만들어 졌지만, 이것은 어떤 가게와 제품 조합에 대해 이를 복제할 수 있는 Shiny 웹 애플리케이션을 구축하기 위한 좋은 사례가 될 수 있습니다. 즐거운 코딩하세요!\u003c/p\u003e\n\u003ch1\u003e코드\u003c/h1\u003e\n\u003cp\u003e이 기사의 모든 내용을 다시 만들기 위한 코드는 제 GitHub 저장소에서 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e마음껏 찾아주세요. LinkedIn에서 저를 찾아보세요.\u003c/p\u003e\n\u003cp\u003e글에서 언급되지 않는 한, 모든 이미지는 저자가 찍은 것입니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-TimeSeriesRegressionandCross-ValidationATidyApproach"},"buildId":"FH3Qr-mLAesqA0X5IFRQr","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>