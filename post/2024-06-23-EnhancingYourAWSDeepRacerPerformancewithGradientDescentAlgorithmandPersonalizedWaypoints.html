<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Gradient Descent 알고리즘과 맞춤형 웨이포인트로 AWS DeepRacer 성능 향상시키는 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Gradient Descent 알고리즘과 맞춤형 웨이포인트로 AWS DeepRacer 성능 향상시키는 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="Gradient Descent 알고리즘과 맞춤형 웨이포인트로 AWS DeepRacer 성능 향상시키는 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints" data-gatsby-head="true"/><meta name="twitter:title" content="Gradient Descent 알고리즘과 맞춤형 웨이포인트로 AWS DeepRacer 성능 향상시키는 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 18:29" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_buildManifest.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Gradient Descent 알고리즘과 맞춤형 웨이포인트로 AWS DeepRacer 성능 향상시키는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Gradient Descent 알고리즘과 맞춤형 웨이포인트로 AWS DeepRacer 성능 향상시키는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>AWS DeepRacer에 대해</h1>
<p>AWS DeepRacer는 Amazon Web Services (AWS)의 흥미로운 프로젝트로, 자율 주행 레이싱의 즐거움과 강화 학습 (RL)의 힘을 시원하게 결합한 것이죠. DeepRacer의 핵심은 RL 분야를 분석하고 민주화하는 데 중점을 둔 포괄적이고 인터랙티브한 플랫폼입니다. 이를 통해 숙련된 개발자부터 초보자까지 RL 분야에 대한 접근성을 높일 수 있습니다.</p>
<h1>커뮤니티 레이스</h1>
<p>DeepRacer 커뮤니티 레이스는 AWS DeepRacer 생태계 내에서 참여자들 간의 커뮤니티와 경쟁 의식을 촉진하기 위해 디자인된 매력적이고 협업적인 프로그램입니다. 이 흥미진진한 프로젝트는 모든 수준의 참가자들을 초대하여 그들의 AI 레이싱 스킬을 겨룰 수 있게 합니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_0.png" alt="DeepRacer Performance"></p>
<p>우리 회사의 DeepRacer 경주에 참여한 기회를 가졌는데, 이 경험은 즐겁고 교육적이었습니다. 이 여정을 통해 강화 학습의 세계에 심취하며 자율 주행 레이싱 카를 훈련하는 데 중추적인 역할을 하는 보상 함수(RF)에 대한 깊은 이해를 얻을 수 있었습니다.</p>
<p>저는 경사하강 알고리즘과 코딩을 통해 3바퀴를 24.58초로 완주한 경험을 공유할 예정입니다.</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1200/1*7vcRCVvk4TG3Hy_9AzB9KQ.gif" alt="DeepRacer GIF"></p>
<div class="content-ad"></div>
<h1>최적 경로 계획</h1>
<p>AWS Invent:2018 트랙 레이스를 위한 나의 모델 훈련은 핵심 작업인 최적 레이싱 경로 계획으로 시작되었습니다. 이 노력에서는 GitHub Repository에서 제시된 방법론에서 영감을 받았습니다. 이 방법론은 경사 하강 알고리즘의 힘을 이용하고 있습니다. 먼저, 저는 아래와 같이 빨간색으로 표시된 상한선과 하한선을 설정하는 데 집중했습니다:</p>
<p><img src="/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_1.png" alt="그림"></p>
<p>그 후 알고리즘의 목표는 자동차의 최적 경로를 계산하는 것이었습니다. 이때의 주요 목표는 트랙의 직선 구간을 최대화하는 것이었습니다. 이 전략적인 접근 방식은 급한 회전을 줄여주어 자동차가 장기간 최대 속도를 유지할 수 있게 합니다.</p>
<div class="content-ad"></div>
<p>다음으로, AWS에서 제공한 미리 정의된 웨이포인트를 계획된 경로 위에 겹쳤습니다.</p>
<p>그로 인해 차량이 가속해야 하는 최적 구간과 회전을 준비하기 위해 감속해야 하는 지역을 명확히 식별할 수 있었습니다. 이 포괄적인 이해는 내 보상 함수 개발의 기초가 되었습니다:</p>
<div class="content-ad"></div>
<p>아래는 경로 계획에 이어 트랙상의 각 인덱스에 적합한 속도를 결정하는 과정이 집중적으로 다루어졌습니다. 최적의 성능을 보장하기 위해 속도 범위는 1.5에서 4.0 사이로 제한했습니다. 특히, U턴 및 중요 지점 근처에서 계산된 속도가 낮아지는 것을 관찰할 수 있는데, 이는 차량이 정밀하게 이 도전적인 섹션을 운행할 수 있도록 도와줍니다.</p>
<p>이 방식을 활용하여 차량의 속도를 다양한 트랙 구간에 맞게 섬세하게 조절할 수 있는 폭넓은 속도 값 범위를 포착했습니다.</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_6.png">
<p>이 속도 범위는 모델 훈련 과정을 가속화하고 향상시키는 데 중요한 역할을 합니다. 당연히 이러한 범위를 조정하여 여러분의 구체적인 트랙과 목표에 맞출 수 있는 유연성이 있습니다. 이렇게 하면 성능을 더욱 향상시킬 수 있습니다.</p>
<p>앞으로 계획된 작업 공간에 대해 자세히 살펴볼 수 있습니다. 각 행은 예상 작업을 나타내며 각 인덱스에 해당합니다 (웨이포인트와 동일함). 이 작업 공간은 [x, y, speed, time]로 표시됩니다. 훈련 중에 "시간" 구성 요소는 안정성이 다소 일관되지 않았기 때문에 크게 사용하지 않았습니다.</p>
<p>이 트랙에 118개의 인덱스가 존재하지만 할당할 수 있는 작업은 단 30개뿐이므로, 속도와 작업 가능성을 더 관리할 수 있는 집합으로 압축하기 위해 클러스터링 접근 방법이 필요했습니다. 이를 위해 K-means 클러스터링 방법을 선택하여 작업을 13개의 구분된 클러스터로 효과적으로 줄였습니다. 이 접근 방법을 통해 모델이 학습하고 레이싱 결정 중에 적용할 수 있는 보다 간결하고 실용적인 작업 집합이 보장되었습니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_7.png" alt="이미지"></p>
<p>그리고 이것이 이산적인 액션들입니다:</p>
<p><img src="/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_8.png" alt="이미지"></p>
<h1>모델 훈련</h1>
<div class="content-ad"></div>
<p>강화 학습을 탐험하면서, 상대적으로 새로운 개념인데도 불구하고, 그 근본적인 원리에 대해 파고들어 내 나름대로의 이해로 정리했습니다:</p>
<p>모델 훈련 측면에서, 제 개인적인 경험은 큰 학습 속도 및 작은 배치 크기로 시작하는 것이 효과적이라는 것을 알려 주었습니다. 이 전략은 모델이 일반적인 경로와 속도 경향을 빠르게 파악하는 데 도움이 됩니다. 점진적으로, 모델이 진행됨에 따라 이러한 초매개변수를 점차 감소시키는 것을 권장하며, 더 구체적이고 정교한 훈련 요구에 적응하도록 합니다. 대부분의 훈련에 사용된 하이퍼파라미터는 다음과 같습니다:</p>
<p><a href="/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_9.png">하이퍼파라미터 테이블</a></p>
<p>총 30시간 정도의 시간을 들여, 모델을 복제하고 훈련하여 비교적 안정된 상태에 이르렀습니다:</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_10.png">
<p>열정적이고 철저한 훈련 노력 끝에, 나는 리더보드에서 선두를 차지했습니다.</p>
<p>이 보상 함수가 효과적인 면에서 이점을 제공하지만, 간단한 보상 함수보다 수렴하는 데 더 많은 시간이 걸릴 수 있다는 점을 인지하는 것이 중요합니다. 이 요소로 인해 마지막 제출이 레이스 마감 시간을 넘어섰고 두 번째 위치를 확보한 타이밍이었습니다. 이것은 강화 학습과 레이싱의 동적 세계에서 복잡성과 수렴 속도 사이의 적절한 균형을 찾는 것이 중요한 도전임을 상기시켜줍니다. 그러나 이는 DeepRacer 여정을 풍부하게 하는 귀중한 학습 경험이기도 합니다.</p>
<img src="/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_11.png">
<div class="content-ad"></div>
<h1>데이터 분석으로 보상 기능 향상하기</h1>
<p>매 훈련 세션 이후, 훈련 로그를 다운로드하고 분석하는 과정은 여정 중 중추적인 단계가 됩니다. 저는 주로 세 가지 필수 플롯을 분석하여 가치 있는 통찰을 얻습니다:</p>
<ul>
<li>에피소드 진행 플롯 (왼쪽): 이 플롯은 각 에피소드에서 이루어진 진행을 시각적으로 나타내며 학습 곡선을 명확하게 보여줍니다.</li>
<li>완주 당 총 단계 플롯 (가운데): 여기서 나는 자동차가 각 랩을 완주하기 위해 필요한 총 단계 수를 평가합니다. 이 통찰은 효율성과 전반적인 성능을 평가하는 데 중요합니다.</li>
<li>보상 플롯 (오른쪽): 보상 그래프는 매우 중요한데, 보상 함수의 효과적인지를 시험하는 역할을 합니다. 이 그래프는 함수가 자동차가 더 짧은 걸음으로 최적의 경로를 따르도록 적절하게 장려하는지를 강조합니다.</li>
</ul>
<p>이러한 플롯들은 훈련 진행 상황에 대한 종합적인 시각을 제공하며 최적의 결과를 위해 모델 수정을 도와줍니다.</p>
<div class="content-ad"></div>
<p>아래와 같이 Markdown 형식으로 수정하세요.</p>
<p><img src="/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_12.png" alt="이미지"></p>
<p>실제로 리워드 대 웨이포인트 그래프는 특정 웨이포인트를 찾아내는 데 매우 유용한 도구입니다. 이 그래프를 면밀히 살펴보면, 리워드가 낮은 웨이포인트를 식별하여 자동차가 코스를 이탈하게 하는 요인을 찾아낼 수 있습니다. 이러한 특정 통찰력은 리워드 기능을 정밀하게 조정하여 자동차의 전반적인 성능을 향상시키고, 더 일관되게 코스를 유지할 수 있도록 하는 데 도움이 됩니다.</p>
<p><img src="/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_13.png" alt="이미지"></p>
<p>당연히, 훈련 트랙을 시각화할 수 있는 능력은 최적 경로를 설계하는 데만 있는 것이 아니라, 훈련 과정에 대한 보다 깊은 통찰력을 얻을 수 있는 귀중한 자원입니다. "Training_analysis.ipynb"를 탐험하는 것을 강력히 권장합니다. 이 파일은 이러한 유용한 플롯 생성을 자동화하여 분석을 단순화하고, 모델을 더욱 개선하기 위한 데이터 기반 의사결정을 도와줍니다. DeepRacer 여정에서 귀하의 성공에 크게 기여할 수 있는 강력한 도구입니다.</p>
<div class="content-ad"></div>
<h1>코드 세부 정보</h1>
<p>보상 함수는 다음과 같습니다:</p>
<pre><code class="hljs language-js"># 속도 범위: <span class="hljs-number">1.5</span> - <span class="hljs-number">4</span>
<span class="hljs-keyword">import</span> math


<span class="hljs-keyword">class</span> <span class="hljs-title class_">Reward</span>:
    def <span class="hljs-title function_">__init__</span>(self):
        self.<span class="hljs-property">first_racingpoint_index</span> = <span class="hljs-number">0</span>

    def <span class="hljs-title function_">reward_function</span>(self, params):

        ################## 도우미 함수 ###################

        def <span class="hljs-title function_">dist_2_points</span>(x1, x2, y1, y2):
            <span class="hljs-keyword">return</span> <span class="hljs-title function_">abs</span>(<span class="hljs-title function_">abs</span>(x1-x2)**<span class="hljs-number">2</span> + <span class="hljs-title function_">abs</span>(y1-y2)**<span class="hljs-number">2</span>)**<span class="hljs-number">0.5</span>

        def <span class="hljs-title function_">closest_2_racing_points_index</span>(racing_coords, car_coords):

            # 모든 레이싱 포인트까지의 거리 계산
            distances = []
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(racing_coords)):
                distance = <span class="hljs-title function_">dist_2_points</span>(x1=racing_coords[i][<span class="hljs-number">0</span>], x2=car_coords[<span class="hljs-number">0</span>],
                                         y1=racing_coords[i][<span class="hljs-number">1</span>], y2=car_coords[<span class="hljs-number">1</span>])
                distances.<span class="hljs-title function_">append</span>(distance)

            # 가장 가까운 레이싱 포인트의 인덱스 가져오기
            closest_index = distances.<span class="hljs-title function_">index</span>(<span class="hljs-title function_">min</span>(distances))

            # 두 번째로 가까운 레이싱 포인트의 인덱스 가져오기
            distances_no_closest = distances.<span class="hljs-title function_">copy</span>()
            distances_no_closest[closest_index] = <span class="hljs-number">999</span>
            second_closest_index = distances_no_closest.<span class="hljs-title function_">index</span>(
                <span class="hljs-title function_">min</span>(distances_no_closest))

            <span class="hljs-keyword">return</span> [closest_index, second_closest_index]

        def <span class="hljs-title function_">dist_to_racing_line</span>(closest_coords, second_closest_coords, car_coords):

            # 가장 가까운 <span class="hljs-number">2</span>개 레이싱 포인트 사이의 거리 계산
            a = <span class="hljs-title function_">abs</span>(<span class="hljs-title function_">dist_2_points</span>(x1=closest_coords[<span class="hljs-number">0</span>],
                                  x2=second_closest_coords[<span class="hljs-number">0</span>],
                                  y1=closest_coords[<span class="hljs-number">1</span>],
                                  y2=second_closest_coords[<span class="hljs-number">1</span>]))

            # 차와 가장 가까운 레이싱 포인트 사이의 거리와 두 번째로 가까운 레이싱 포인트 사이의 거리
            b = <span class="hljs-title function_">abs</span>(<span class="hljs-title function_">dist_2_points</span>(x1=car_coords[<span class="hljs-number">0</span>],
                                  x2=closest_coords[<span class="hljs-number">0</span>],
                                  y1=car_coords[<span class="hljs-number">1</span>],
                                  y2=closest_coords[<span class="hljs-number">1</span>]))
            c = <span class="hljs-title function_">abs</span>(<span class="hljs-title function_">dist_2_points</span>(x1=car_coords[<span class="hljs-number">0</span>],
                                  x2=second_closest_coords[<span class="hljs-number">0</span>],
                                  y1=car_coords[<span class="hljs-number">1</span>],
                                  y2=second_closest_coords[<span class="hljs-number">1</span>]))

            # 차와 레이싱 라인 사이의 거리 계산 (가장 가까운 <span class="hljs-number">2</span>개의 레이싱 포인트를 통과)
            # <span class="hljs-title class_">DeepRacer</span>에서 드문 버그인 경우를 위해 <span class="hljs-keyword">try</span>-except 사용
            <span class="hljs-attr">try</span>:
                distance = <span class="hljs-title function_">abs</span>(-(a**<span class="hljs-number">4</span>) + <span class="hljs-number">2</span>*(a**<span class="hljs-number">2</span>)*(b**<span class="hljs-number">2</span>) + <span class="hljs-number">2</span>*(a**<span class="hljs-number">2</span>)*(c**<span class="hljs-number">2</span>) -
                               (b**<span class="hljs-number">4</span>) + <span class="hljs-number">2</span>*(b**<span class="hljs-number">2</span>)*(c**<span class="hljs-number">2</span>) - (c**<span class="hljs-number">4</span>))**<span class="hljs-number">0.5</span> / (<span class="hljs-number">2</span>*a)
            <span class="hljs-attr">except</span>:
                distance = b

            <span class="hljs-keyword">return</span> distance

        # 다음인 레이싱 포인트 및 이전 레이싱 포인트 계산
        def <span class="hljs-title function_">next_prev_racing_point</span>(closest_coords, second_closest_coords, car_coords, heading):

            # 차를 더 많이 향하도록 설정
            heading_vector = [math.<span class="hljs-title function_">cos</span>(math.<span class="hljs-title function_">radians</span>(
                heading)), math.<span class="hljs-title function_">sin</span>(math.<span class="hljs-title function_">radians</span>(heading))]
            new_car_coords = [car_coords[<span class="hljs-number">0</span>]+heading_vector[<span class="hljs-number">0</span>],
                              car_coords[<span class="hljs-number">1</span>]+heading_vector[<span class="hljs-number">1</span>]]

            # 새로운 차 좌표와 두 가장 가까운 레이싱 포인트까지의 거리 계산
            distance_closest_coords_new = <span class="hljs-title function_">dist_2_points</span>(x1=new_car_coords[<span class="hljs-number">0</span>],
                                                        x2=closest_coords[<span class="hljs-number">0</span>],
                                                        y1=new_car_coords[<span class="hljs-number">1</span>],
                                                        y2=closest_coords[<span class="hljs-number">1</span>])
            distance_second_closest_coords_new = <span class="hljs-title function_">dist_2_points</span>(x1=new_car_coords[<span class="hljs-number">0</span>],
                                                               x2=second_closest_coords[<span class="hljs-number">0</span>],
                                                               y1=new_car_coords[<span class="hljs-number">1</span>],
                                                               y2=second_closest_coords[<span class="hljs-number">1</span>])

            <span class="hljs-keyword">if</span> distance_closest_coords_new &#x3C;= <span class="hljs-attr">distance_second_closest_coords_new</span>:
                next_point_coords = closest_coords
                prev_point_coords = second_closest_coords
            <span class="hljs-attr">else</span>:
                next_point_coords = second_closest_coords
                prev_point_coords = closest_coords

            <span class="hljs-keyword">return</span> [next_point_coords, prev_point_coords]

        def <span class="hljs-title function_">racing_direction_diff</span>(closest_coords, second_closest_coords, car_coords, heading):

            # 가장 가까운 웨이포인트를 기반으로 센터 라인의 방향 계산
            next_point, prev_point = <span class="hljs-title function_">next_prev_racing_point</span>(closest_coords,
                                                            second_closest_coords,
                                                            car_coords,
                                                            heading)

            # 방향 계산(radian 값, <span class="hljs-title function_">arctan2</span>(dy, dx), 결과는 라디안 단위로 (-pi, pi))
            track_direction = math.<span class="hljs-title function_">atan2</span>(
                next_point[<span class="hljs-number">1</span>] - prev_point[<span class="hljs-number">1</span>], next_point[<span class="hljs-number">0</span>] - prev_point[<span class="hljs-number">0</span>])

            # 도수로 변환
            track_direction = math.<span class="hljs-title function_">degrees</span>(track_direction)

            # 트랙 방향과 차량의 진행 방향 간의 차이 계산
            direction_diff = <span class="hljs-title function_">abs</span>(track_direction - heading)
            <span class="hljs-keyword">if</span> direction_diff > <span class="hljs-number">180</span>:
                direction_diff = <span class="hljs-number">360</span> - direction_diff

            <span class="hljs-keyword">return</span> direction_diff

        #################### 레이싱 라인 ######################

        # <span class="hljs-title class_">Spain</span> 트랙을 위한 최적의 레이싱 라인
        # 각 행: [x,y,speed,timeFromPreviousPoint]
        racing_track = [
            [<span class="hljs-number">3.06664</span>, <span class="hljs-number">0.69989</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">0.03654</span>],
            ...
            [<span class="hljs-number">2.77639</span>, <span class="hljs-number">0.72086</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">0.03581</span>],
            [<span class="hljs-number">2.92074</span>, <span class="hljs-number">0.70874</span>, <span class="hljs-number">4.0</span>, <span class="hljs-number">0.03621</span>]]

        ...

reward_object = <span class="hljs-title class_">Reward</span>()


def <span class="hljs-title function_">reward_function</span>(params):
    <span class="hljs-keyword">return</span> reward_object.<span class="hljs-title function_">reward_function</span>(params)
</code></pre>
<div class="content-ad"></div>
<p>코드 구현의 세부 사항에 관심이 있는 분들을 위해, 제 GitHub 저장소를 살펴보실 것을 초대합니다:</p>
<h1>감사의 말</h1>
<p>이 모델을 교육하는 경험은 절대적으로 즐거웠으며 가치 있는 학습 여정이었습니다. 강화 학습에 대한 실용적인 통찰을 얻을 뿐만 아니라, 즐거운 레이싱 게임 측면 때문에 이를 수행하는 데 즐거움을 느꼈습니다. 이 경험을 가능하게 해 준 주최자들께 감사의 말씀을 전하고 싶습니다 (교육 시간은 싸지 않습니다)!</p>
<p>이 GitHub 저장소를 완성하는 데 중요한 참고 자료로 사용된 두 명의 저자 dgnzlz 및 GitHub 사용자 oscarYCL의 역할에 감사의 의미를 표합니다. Capstone_AWS_DeepRacer 및 deepracer-waypoints-workshop이라는 저장소는 그들의 창의성과 기여가 귀중했습니다.</p>
<div class="content-ad"></div>
<p>마지막으로, 이겪은 것은 팀워크입니다. 제 동료들과 함께 이 모델을 개발하는 과정을 즐겼습니다.</p>
<h1>참고</h1>
<ul>
<li><a href="https://github.com/dgnzlz/Capstone_AWS_DeepRacer" rel="nofollow" target="_blank">https://github.com/dgnzlz/Capstone_AWS_DeepRacer</a></li>
<li><a href="https://github.com/oscarYCL/deepracer-waypoints-workshop" rel="nofollow" target="_blank">https://github.com/oscarYCL/deepracer-waypoints-workshop</a></li>
<li><a href="https://docs.aws.amazon.com/deepracer/latest/developerguide/deepracer-reward-function-input.html" rel="nofollow" target="_blank">https://docs.aws.amazon.com/deepracer/latest/developerguide/deepracer-reward-function-input.html</a></li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Gradient Descent 알고리즘과 맞춤형 웨이포인트로 AWS DeepRacer 성능 향상시키는 방법","description":"","date":"2024-06-23 18:29","slug":"2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints","content":"\n\n# AWS DeepRacer에 대해\n\nAWS DeepRacer는 Amazon Web Services (AWS)의 흥미로운 프로젝트로, 자율 주행 레이싱의 즐거움과 강화 학습 (RL)의 힘을 시원하게 결합한 것이죠. DeepRacer의 핵심은 RL 분야를 분석하고 민주화하는 데 중점을 둔 포괄적이고 인터랙티브한 플랫폼입니다. 이를 통해 숙련된 개발자부터 초보자까지 RL 분야에 대한 접근성을 높일 수 있습니다.\n\n# 커뮤니티 레이스\n\nDeepRacer 커뮤니티 레이스는 AWS DeepRacer 생태계 내에서 참여자들 간의 커뮤니티와 경쟁 의식을 촉진하기 위해 디자인된 매력적이고 협업적인 프로그램입니다. 이 흥미진진한 프로젝트는 모든 수준의 참가자들을 초대하여 그들의 AI 레이싱 스킬을 겨룰 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![DeepRacer Performance](/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_0.png)\n\n우리 회사의 DeepRacer 경주에 참여한 기회를 가졌는데, 이 경험은 즐겁고 교육적이었습니다. 이 여정을 통해 강화 학습의 세계에 심취하며 자율 주행 레이싱 카를 훈련하는 데 중추적인 역할을 하는 보상 함수(RF)에 대한 깊은 이해를 얻을 수 있었습니다.\n\n저는 경사하강 알고리즘과 코딩을 통해 3바퀴를 24.58초로 완주한 경험을 공유할 예정입니다.\n\n![DeepRacer GIF](https://miro.medium.com/v2/resize:fit:1200/1*7vcRCVvk4TG3Hy_9AzB9KQ.gif)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 최적 경로 계획\n\nAWS Invent:2018 트랙 레이스를 위한 나의 모델 훈련은 핵심 작업인 최적 레이싱 경로 계획으로 시작되었습니다. 이 노력에서는 GitHub Repository에서 제시된 방법론에서 영감을 받았습니다. 이 방법론은 경사 하강 알고리즘의 힘을 이용하고 있습니다. 먼저, 저는 아래와 같이 빨간색으로 표시된 상한선과 하한선을 설정하는 데 집중했습니다:\n\n![그림](/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_1.png)\n\n그 후 알고리즘의 목표는 자동차의 최적 경로를 계산하는 것이었습니다. 이때의 주요 목표는 트랙의 직선 구간을 최대화하는 것이었습니다. 이 전략적인 접근 방식은 급한 회전을 줄여주어 자동차가 장기간 최대 속도를 유지할 수 있게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음으로, AWS에서 제공한 미리 정의된 웨이포인트를 계획된 경로 위에 겹쳤습니다.\n\n그로 인해 차량이 가속해야 하는 최적 구간과 회전을 준비하기 위해 감속해야 하는 지역을 명확히 식별할 수 있었습니다. 이 포괄적인 이해는 내 보상 함수 개발의 기초가 되었습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래는 경로 계획에 이어 트랙상의 각 인덱스에 적합한 속도를 결정하는 과정이 집중적으로 다루어졌습니다. 최적의 성능을 보장하기 위해 속도 범위는 1.5에서 4.0 사이로 제한했습니다. 특히, U턴 및 중요 지점 근처에서 계산된 속도가 낮아지는 것을 관찰할 수 있는데, 이는 차량이 정밀하게 이 도전적인 섹션을 운행할 수 있도록 도와줍니다.\n\n이 방식을 활용하여 차량의 속도를 다양한 트랙 구간에 맞게 섬세하게 조절할 수 있는 폭넓은 속도 값 범위를 포착했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_6.png\" /\u003e\n\n이 속도 범위는 모델 훈련 과정을 가속화하고 향상시키는 데 중요한 역할을 합니다. 당연히 이러한 범위를 조정하여 여러분의 구체적인 트랙과 목표에 맞출 수 있는 유연성이 있습니다. 이렇게 하면 성능을 더욱 향상시킬 수 있습니다.\n\n앞으로 계획된 작업 공간에 대해 자세히 살펴볼 수 있습니다. 각 행은 예상 작업을 나타내며 각 인덱스에 해당합니다 (웨이포인트와 동일함). 이 작업 공간은 [x, y, speed, time]로 표시됩니다. 훈련 중에 \"시간\" 구성 요소는 안정성이 다소 일관되지 않았기 때문에 크게 사용하지 않았습니다.\n\n이 트랙에 118개의 인덱스가 존재하지만 할당할 수 있는 작업은 단 30개뿐이므로, 속도와 작업 가능성을 더 관리할 수 있는 집합으로 압축하기 위해 클러스터링 접근 방법이 필요했습니다. 이를 위해 K-means 클러스터링 방법을 선택하여 작업을 13개의 구분된 클러스터로 효과적으로 줄였습니다. 이 접근 방법을 통해 모델이 학습하고 레이싱 결정 중에 적용할 수 있는 보다 간결하고 실용적인 작업 집합이 보장되었습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_7.png)\n\n그리고 이것이 이산적인 액션들입니다:\n\n![이미지](/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_8.png)\n\n# 모델 훈련\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n강화 학습을 탐험하면서, 상대적으로 새로운 개념인데도 불구하고, 그 근본적인 원리에 대해 파고들어 내 나름대로의 이해로 정리했습니다:\n\n모델 훈련 측면에서, 제 개인적인 경험은 큰 학습 속도 및 작은 배치 크기로 시작하는 것이 효과적이라는 것을 알려 주었습니다. 이 전략은 모델이 일반적인 경로와 속도 경향을 빠르게 파악하는 데 도움이 됩니다. 점진적으로, 모델이 진행됨에 따라 이러한 초매개변수를 점차 감소시키는 것을 권장하며, 더 구체적이고 정교한 훈련 요구에 적응하도록 합니다. 대부분의 훈련에 사용된 하이퍼파라미터는 다음과 같습니다:\n\n[하이퍼파라미터 테이블](/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_9.png)\n\n총 30시간 정도의 시간을 들여, 모델을 복제하고 훈련하여 비교적 안정된 상태에 이르렀습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_10.png\" /\u003e\n\n열정적이고 철저한 훈련 노력 끝에, 나는 리더보드에서 선두를 차지했습니다.\n\n이 보상 함수가 효과적인 면에서 이점을 제공하지만, 간단한 보상 함수보다 수렴하는 데 더 많은 시간이 걸릴 수 있다는 점을 인지하는 것이 중요합니다. 이 요소로 인해 마지막 제출이 레이스 마감 시간을 넘어섰고 두 번째 위치를 확보한 타이밍이었습니다. 이것은 강화 학습과 레이싱의 동적 세계에서 복잡성과 수렴 속도 사이의 적절한 균형을 찾는 것이 중요한 도전임을 상기시켜줍니다. 그러나 이는 DeepRacer 여정을 풍부하게 하는 귀중한 학습 경험이기도 합니다.\n\n\u003cimg src=\"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_11.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터 분석으로 보상 기능 향상하기\n\n매 훈련 세션 이후, 훈련 로그를 다운로드하고 분석하는 과정은 여정 중 중추적인 단계가 됩니다. 저는 주로 세 가지 필수 플롯을 분석하여 가치 있는 통찰을 얻습니다:\n\n- 에피소드 진행 플롯 (왼쪽): 이 플롯은 각 에피소드에서 이루어진 진행을 시각적으로 나타내며 학습 곡선을 명확하게 보여줍니다.\n- 완주 당 총 단계 플롯 (가운데): 여기서 나는 자동차가 각 랩을 완주하기 위해 필요한 총 단계 수를 평가합니다. 이 통찰은 효율성과 전반적인 성능을 평가하는 데 중요합니다.\n- 보상 플롯 (오른쪽): 보상 그래프는 매우 중요한데, 보상 함수의 효과적인지를 시험하는 역할을 합니다. 이 그래프는 함수가 자동차가 더 짧은 걸음으로 최적의 경로를 따르도록 적절하게 장려하는지를 강조합니다.\n\n이러한 플롯들은 훈련 진행 상황에 대한 종합적인 시각을 제공하며 최적의 결과를 위해 모델 수정을 도와줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아래와 같이 Markdown 형식으로 수정하세요.\n\n\n![이미지](/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_12.png)\n\n실제로 리워드 대 웨이포인트 그래프는 특정 웨이포인트를 찾아내는 데 매우 유용한 도구입니다. 이 그래프를 면밀히 살펴보면, 리워드가 낮은 웨이포인트를 식별하여 자동차가 코스를 이탈하게 하는 요인을 찾아낼 수 있습니다. 이러한 특정 통찰력은 리워드 기능을 정밀하게 조정하여 자동차의 전반적인 성능을 향상시키고, 더 일관되게 코스를 유지할 수 있도록 하는 데 도움이 됩니다.\n\n![이미지](/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_13.png)\n\n당연히, 훈련 트랙을 시각화할 수 있는 능력은 최적 경로를 설계하는 데만 있는 것이 아니라, 훈련 과정에 대한 보다 깊은 통찰력을 얻을 수 있는 귀중한 자원입니다. \"Training_analysis.ipynb\"를 탐험하는 것을 강력히 권장합니다. 이 파일은 이러한 유용한 플롯 생성을 자동화하여 분석을 단순화하고, 모델을 더욱 개선하기 위한 데이터 기반 의사결정을 도와줍니다. DeepRacer 여정에서 귀하의 성공에 크게 기여할 수 있는 강력한 도구입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 코드 세부 정보\n\n보상 함수는 다음과 같습니다:\n\n```js\n# 속도 범위: 1.5 - 4\nimport math\n\n\nclass Reward:\n    def __init__(self):\n        self.first_racingpoint_index = 0\n\n    def reward_function(self, params):\n\n        ################## 도우미 함수 ###################\n\n        def dist_2_points(x1, x2, y1, y2):\n            return abs(abs(x1-x2)**2 + abs(y1-y2)**2)**0.5\n\n        def closest_2_racing_points_index(racing_coords, car_coords):\n\n            # 모든 레이싱 포인트까지의 거리 계산\n            distances = []\n            for i in range(len(racing_coords)):\n                distance = dist_2_points(x1=racing_coords[i][0], x2=car_coords[0],\n                                         y1=racing_coords[i][1], y2=car_coords[1])\n                distances.append(distance)\n\n            # 가장 가까운 레이싱 포인트의 인덱스 가져오기\n            closest_index = distances.index(min(distances))\n\n            # 두 번째로 가까운 레이싱 포인트의 인덱스 가져오기\n            distances_no_closest = distances.copy()\n            distances_no_closest[closest_index] = 999\n            second_closest_index = distances_no_closest.index(\n                min(distances_no_closest))\n\n            return [closest_index, second_closest_index]\n\n        def dist_to_racing_line(closest_coords, second_closest_coords, car_coords):\n\n            # 가장 가까운 2개 레이싱 포인트 사이의 거리 계산\n            a = abs(dist_2_points(x1=closest_coords[0],\n                                  x2=second_closest_coords[0],\n                                  y1=closest_coords[1],\n                                  y2=second_closest_coords[1]))\n\n            # 차와 가장 가까운 레이싱 포인트 사이의 거리와 두 번째로 가까운 레이싱 포인트 사이의 거리\n            b = abs(dist_2_points(x1=car_coords[0],\n                                  x2=closest_coords[0],\n                                  y1=car_coords[1],\n                                  y2=closest_coords[1]))\n            c = abs(dist_2_points(x1=car_coords[0],\n                                  x2=second_closest_coords[0],\n                                  y1=car_coords[1],\n                                  y2=second_closest_coords[1]))\n\n            # 차와 레이싱 라인 사이의 거리 계산 (가장 가까운 2개의 레이싱 포인트를 통과)\n            # DeepRacer에서 드문 버그인 경우를 위해 try-except 사용\n            try:\n                distance = abs(-(a**4) + 2*(a**2)*(b**2) + 2*(a**2)*(c**2) -\n                               (b**4) + 2*(b**2)*(c**2) - (c**4))**0.5 / (2*a)\n            except:\n                distance = b\n\n            return distance\n\n        # 다음인 레이싱 포인트 및 이전 레이싱 포인트 계산\n        def next_prev_racing_point(closest_coords, second_closest_coords, car_coords, heading):\n\n            # 차를 더 많이 향하도록 설정\n            heading_vector = [math.cos(math.radians(\n                heading)), math.sin(math.radians(heading))]\n            new_car_coords = [car_coords[0]+heading_vector[0],\n                              car_coords[1]+heading_vector[1]]\n\n            # 새로운 차 좌표와 두 가장 가까운 레이싱 포인트까지의 거리 계산\n            distance_closest_coords_new = dist_2_points(x1=new_car_coords[0],\n                                                        x2=closest_coords[0],\n                                                        y1=new_car_coords[1],\n                                                        y2=closest_coords[1])\n            distance_second_closest_coords_new = dist_2_points(x1=new_car_coords[0],\n                                                               x2=second_closest_coords[0],\n                                                               y1=new_car_coords[1],\n                                                               y2=second_closest_coords[1])\n\n            if distance_closest_coords_new \u003c= distance_second_closest_coords_new:\n                next_point_coords = closest_coords\n                prev_point_coords = second_closest_coords\n            else:\n                next_point_coords = second_closest_coords\n                prev_point_coords = closest_coords\n\n            return [next_point_coords, prev_point_coords]\n\n        def racing_direction_diff(closest_coords, second_closest_coords, car_coords, heading):\n\n            # 가장 가까운 웨이포인트를 기반으로 센터 라인의 방향 계산\n            next_point, prev_point = next_prev_racing_point(closest_coords,\n                                                            second_closest_coords,\n                                                            car_coords,\n                                                            heading)\n\n            # 방향 계산(radian 값, arctan2(dy, dx), 결과는 라디안 단위로 (-pi, pi))\n            track_direction = math.atan2(\n                next_point[1] - prev_point[1], next_point[0] - prev_point[0])\n\n            # 도수로 변환\n            track_direction = math.degrees(track_direction)\n\n            # 트랙 방향과 차량의 진행 방향 간의 차이 계산\n            direction_diff = abs(track_direction - heading)\n            if direction_diff \u003e 180:\n                direction_diff = 360 - direction_diff\n\n            return direction_diff\n\n        #################### 레이싱 라인 ######################\n\n        # Spain 트랙을 위한 최적의 레이싱 라인\n        # 각 행: [x,y,speed,timeFromPreviousPoint]\n        racing_track = [\n            [3.06664, 0.69989, 4.0, 0.03654],\n            ...\n            [2.77639, 0.72086, 4.0, 0.03581],\n            [2.92074, 0.70874, 4.0, 0.03621]]\n\n        ...\n\nreward_object = Reward()\n\n\ndef reward_function(params):\n    return reward_object.reward_function(params)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n코드 구현의 세부 사항에 관심이 있는 분들을 위해, 제 GitHub 저장소를 살펴보실 것을 초대합니다:\n\n# 감사의 말\n\n이 모델을 교육하는 경험은 절대적으로 즐거웠으며 가치 있는 학습 여정이었습니다. 강화 학습에 대한 실용적인 통찰을 얻을 뿐만 아니라, 즐거운 레이싱 게임 측면 때문에 이를 수행하는 데 즐거움을 느꼈습니다. 이 경험을 가능하게 해 준 주최자들께 감사의 말씀을 전하고 싶습니다 (교육 시간은 싸지 않습니다)!\n\n이 GitHub 저장소를 완성하는 데 중요한 참고 자료로 사용된 두 명의 저자 dgnzlz 및 GitHub 사용자 oscarYCL의 역할에 감사의 의미를 표합니다. Capstone_AWS_DeepRacer 및 deepracer-waypoints-workshop이라는 저장소는 그들의 창의성과 기여가 귀중했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 이겪은 것은 팀워크입니다. 제 동료들과 함께 이 모델을 개발하는 과정을 즐겼습니다.\n\n# 참고\n\n- https://github.com/dgnzlz/Capstone_AWS_DeepRacer\n- https://github.com/oscarYCL/deepracer-waypoints-workshop\n- https://docs.aws.amazon.com/deepracer/latest/developerguide/deepracer-reward-function-input.html","ogImage":{"url":"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_0.png"},"coverImage":"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003eAWS DeepRacer에 대해\u003c/h1\u003e\n\u003cp\u003eAWS DeepRacer는 Amazon Web Services (AWS)의 흥미로운 프로젝트로, 자율 주행 레이싱의 즐거움과 강화 학습 (RL)의 힘을 시원하게 결합한 것이죠. DeepRacer의 핵심은 RL 분야를 분석하고 민주화하는 데 중점을 둔 포괄적이고 인터랙티브한 플랫폼입니다. 이를 통해 숙련된 개발자부터 초보자까지 RL 분야에 대한 접근성을 높일 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e커뮤니티 레이스\u003c/h1\u003e\n\u003cp\u003eDeepRacer 커뮤니티 레이스는 AWS DeepRacer 생태계 내에서 참여자들 간의 커뮤니티와 경쟁 의식을 촉진하기 위해 디자인된 매력적이고 협업적인 프로그램입니다. 이 흥미진진한 프로젝트는 모든 수준의 참가자들을 초대하여 그들의 AI 레이싱 스킬을 겨룰 수 있게 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_0.png\" alt=\"DeepRacer Performance\"\u003e\u003c/p\u003e\n\u003cp\u003e우리 회사의 DeepRacer 경주에 참여한 기회를 가졌는데, 이 경험은 즐겁고 교육적이었습니다. 이 여정을 통해 강화 학습의 세계에 심취하며 자율 주행 레이싱 카를 훈련하는 데 중추적인 역할을 하는 보상 함수(RF)에 대한 깊은 이해를 얻을 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e저는 경사하강 알고리즘과 코딩을 통해 3바퀴를 24.58초로 완주한 경험을 공유할 예정입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1200/1*7vcRCVvk4TG3Hy_9AzB9KQ.gif\" alt=\"DeepRacer GIF\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e최적 경로 계획\u003c/h1\u003e\n\u003cp\u003eAWS Invent:2018 트랙 레이스를 위한 나의 모델 훈련은 핵심 작업인 최적 레이싱 경로 계획으로 시작되었습니다. 이 노력에서는 GitHub Repository에서 제시된 방법론에서 영감을 받았습니다. 이 방법론은 경사 하강 알고리즘의 힘을 이용하고 있습니다. 먼저, 저는 아래와 같이 빨간색으로 표시된 상한선과 하한선을 설정하는 데 집중했습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_1.png\" alt=\"그림\"\u003e\u003c/p\u003e\n\u003cp\u003e그 후 알고리즘의 목표는 자동차의 최적 경로를 계산하는 것이었습니다. 이때의 주요 목표는 트랙의 직선 구간을 최대화하는 것이었습니다. 이 전략적인 접근 방식은 급한 회전을 줄여주어 자동차가 장기간 최대 속도를 유지할 수 있게 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음으로, AWS에서 제공한 미리 정의된 웨이포인트를 계획된 경로 위에 겹쳤습니다.\u003c/p\u003e\n\u003cp\u003e그로 인해 차량이 가속해야 하는 최적 구간과 회전을 준비하기 위해 감속해야 하는 지역을 명확히 식별할 수 있었습니다. 이 포괄적인 이해는 내 보상 함수 개발의 기초가 되었습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래는 경로 계획에 이어 트랙상의 각 인덱스에 적합한 속도를 결정하는 과정이 집중적으로 다루어졌습니다. 최적의 성능을 보장하기 위해 속도 범위는 1.5에서 4.0 사이로 제한했습니다. 특히, U턴 및 중요 지점 근처에서 계산된 속도가 낮아지는 것을 관찰할 수 있는데, 이는 차량이 정밀하게 이 도전적인 섹션을 운행할 수 있도록 도와줍니다.\u003c/p\u003e\n\u003cp\u003e이 방식을 활용하여 차량의 속도를 다양한 트랙 구간에 맞게 섬세하게 조절할 수 있는 폭넓은 속도 값 범위를 포착했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_6.png\"\u003e\n\u003cp\u003e이 속도 범위는 모델 훈련 과정을 가속화하고 향상시키는 데 중요한 역할을 합니다. 당연히 이러한 범위를 조정하여 여러분의 구체적인 트랙과 목표에 맞출 수 있는 유연성이 있습니다. 이렇게 하면 성능을 더욱 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003e앞으로 계획된 작업 공간에 대해 자세히 살펴볼 수 있습니다. 각 행은 예상 작업을 나타내며 각 인덱스에 해당합니다 (웨이포인트와 동일함). 이 작업 공간은 [x, y, speed, time]로 표시됩니다. 훈련 중에 \"시간\" 구성 요소는 안정성이 다소 일관되지 않았기 때문에 크게 사용하지 않았습니다.\u003c/p\u003e\n\u003cp\u003e이 트랙에 118개의 인덱스가 존재하지만 할당할 수 있는 작업은 단 30개뿐이므로, 속도와 작업 가능성을 더 관리할 수 있는 집합으로 압축하기 위해 클러스터링 접근 방법이 필요했습니다. 이를 위해 K-means 클러스터링 방법을 선택하여 작업을 13개의 구분된 클러스터로 효과적으로 줄였습니다. 이 접근 방법을 통해 모델이 학습하고 레이싱 결정 중에 적용할 수 있는 보다 간결하고 실용적인 작업 집합이 보장되었습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_7.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e그리고 이것이 이산적인 액션들입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_8.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e모델 훈련\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e강화 학습을 탐험하면서, 상대적으로 새로운 개념인데도 불구하고, 그 근본적인 원리에 대해 파고들어 내 나름대로의 이해로 정리했습니다:\u003c/p\u003e\n\u003cp\u003e모델 훈련 측면에서, 제 개인적인 경험은 큰 학습 속도 및 작은 배치 크기로 시작하는 것이 효과적이라는 것을 알려 주었습니다. 이 전략은 모델이 일반적인 경로와 속도 경향을 빠르게 파악하는 데 도움이 됩니다. 점진적으로, 모델이 진행됨에 따라 이러한 초매개변수를 점차 감소시키는 것을 권장하며, 더 구체적이고 정교한 훈련 요구에 적응하도록 합니다. 대부분의 훈련에 사용된 하이퍼파라미터는 다음과 같습니다:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_9.png\"\u003e하이퍼파라미터 테이블\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e총 30시간 정도의 시간을 들여, 모델을 복제하고 훈련하여 비교적 안정된 상태에 이르렀습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_10.png\"\u003e\n\u003cp\u003e열정적이고 철저한 훈련 노력 끝에, 나는 리더보드에서 선두를 차지했습니다.\u003c/p\u003e\n\u003cp\u003e이 보상 함수가 효과적인 면에서 이점을 제공하지만, 간단한 보상 함수보다 수렴하는 데 더 많은 시간이 걸릴 수 있다는 점을 인지하는 것이 중요합니다. 이 요소로 인해 마지막 제출이 레이스 마감 시간을 넘어섰고 두 번째 위치를 확보한 타이밍이었습니다. 이것은 강화 학습과 레이싱의 동적 세계에서 복잡성과 수렴 속도 사이의 적절한 균형을 찾는 것이 중요한 도전임을 상기시켜줍니다. 그러나 이는 DeepRacer 여정을 풍부하게 하는 귀중한 학습 경험이기도 합니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_11.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e데이터 분석으로 보상 기능 향상하기\u003c/h1\u003e\n\u003cp\u003e매 훈련 세션 이후, 훈련 로그를 다운로드하고 분석하는 과정은 여정 중 중추적인 단계가 됩니다. 저는 주로 세 가지 필수 플롯을 분석하여 가치 있는 통찰을 얻습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e에피소드 진행 플롯 (왼쪽): 이 플롯은 각 에피소드에서 이루어진 진행을 시각적으로 나타내며 학습 곡선을 명확하게 보여줍니다.\u003c/li\u003e\n\u003cli\u003e완주 당 총 단계 플롯 (가운데): 여기서 나는 자동차가 각 랩을 완주하기 위해 필요한 총 단계 수를 평가합니다. 이 통찰은 효율성과 전반적인 성능을 평가하는 데 중요합니다.\u003c/li\u003e\n\u003cli\u003e보상 플롯 (오른쪽): 보상 그래프는 매우 중요한데, 보상 함수의 효과적인지를 시험하는 역할을 합니다. 이 그래프는 함수가 자동차가 더 짧은 걸음으로 최적의 경로를 따르도록 적절하게 장려하는지를 강조합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 플롯들은 훈련 진행 상황에 대한 종합적인 시각을 제공하며 최적의 결과를 위해 모델 수정을 도와줍니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아래와 같이 Markdown 형식으로 수정하세요.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_12.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e실제로 리워드 대 웨이포인트 그래프는 특정 웨이포인트를 찾아내는 데 매우 유용한 도구입니다. 이 그래프를 면밀히 살펴보면, 리워드가 낮은 웨이포인트를 식별하여 자동차가 코스를 이탈하게 하는 요인을 찾아낼 수 있습니다. 이러한 특정 통찰력은 리워드 기능을 정밀하게 조정하여 자동차의 전반적인 성능을 향상시키고, 더 일관되게 코스를 유지할 수 있도록 하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints_13.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e당연히, 훈련 트랙을 시각화할 수 있는 능력은 최적 경로를 설계하는 데만 있는 것이 아니라, 훈련 과정에 대한 보다 깊은 통찰력을 얻을 수 있는 귀중한 자원입니다. \"Training_analysis.ipynb\"를 탐험하는 것을 강력히 권장합니다. 이 파일은 이러한 유용한 플롯 생성을 자동화하여 분석을 단순화하고, 모델을 더욱 개선하기 위한 데이터 기반 의사결정을 도와줍니다. DeepRacer 여정에서 귀하의 성공에 크게 기여할 수 있는 강력한 도구입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e코드 세부 정보\u003c/h1\u003e\n\u003cp\u003e보상 함수는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 속도 범위: \u003cspan class=\"hljs-number\"\u003e1.5\u003c/span\u003e - \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e math\n\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReward\u003c/span\u003e:\n    def \u003cspan class=\"hljs-title function_\"\u003e__init__\u003c/span\u003e(self):\n        self.\u003cspan class=\"hljs-property\"\u003efirst_racingpoint_index\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\n    def \u003cspan class=\"hljs-title function_\"\u003ereward_function\u003c/span\u003e(self, params):\n\n        ################## 도우미 함수 ###################\n\n        def \u003cspan class=\"hljs-title function_\"\u003edist_2_points\u003c/span\u003e(x1, x2, y1, y2):\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(x1-x2)**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e + \u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(y1-y2)**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)**\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e\n\n        def \u003cspan class=\"hljs-title function_\"\u003eclosest_2_racing_points_index\u003c/span\u003e(racing_coords, car_coords):\n\n            # 모든 레이싱 포인트까지의 거리 계산\n            distances = []\n            \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(racing_coords)):\n                distance = \u003cspan class=\"hljs-title function_\"\u003edist_2_points\u003c/span\u003e(x1=racing_coords[i][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], x2=car_coords[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                                         y1=racing_coords[i][\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], y2=car_coords[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\n                distances.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(distance)\n\n            # 가장 가까운 레이싱 포인트의 인덱스 가져오기\n            closest_index = distances.\u003cspan class=\"hljs-title function_\"\u003eindex\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(distances))\n\n            # 두 번째로 가까운 레이싱 포인트의 인덱스 가져오기\n            distances_no_closest = distances.\u003cspan class=\"hljs-title function_\"\u003ecopy\u003c/span\u003e()\n            distances_no_closest[closest_index] = \u003cspan class=\"hljs-number\"\u003e999\u003c/span\u003e\n            second_closest_index = distances_no_closest.\u003cspan class=\"hljs-title function_\"\u003eindex\u003c/span\u003e(\n                \u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e(distances_no_closest))\n\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [closest_index, second_closest_index]\n\n        def \u003cspan class=\"hljs-title function_\"\u003edist_to_racing_line\u003c/span\u003e(closest_coords, second_closest_coords, car_coords):\n\n            # 가장 가까운 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e개 레이싱 포인트 사이의 거리 계산\n            a = \u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003edist_2_points\u003c/span\u003e(x1=closest_coords[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                                  x2=second_closest_coords[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                                  y1=closest_coords[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e],\n                                  y2=second_closest_coords[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]))\n\n            # 차와 가장 가까운 레이싱 포인트 사이의 거리와 두 번째로 가까운 레이싱 포인트 사이의 거리\n            b = \u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003edist_2_points\u003c/span\u003e(x1=car_coords[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                                  x2=closest_coords[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                                  y1=car_coords[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e],\n                                  y2=closest_coords[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]))\n            c = \u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003edist_2_points\u003c/span\u003e(x1=car_coords[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                                  x2=second_closest_coords[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                                  y1=car_coords[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e],\n                                  y2=second_closest_coords[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]))\n\n            # 차와 레이싱 라인 사이의 거리 계산 (가장 가까운 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e개의 레이싱 포인트를 통과)\n            # \u003cspan class=\"hljs-title class_\"\u003eDeepRacer\u003c/span\u003e에서 드문 버그인 경우를 위해 \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e-except 사용\n            \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n                distance = \u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(-(a**\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e) + \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e*(a**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)*(b**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) + \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e*(a**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)*(c**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) -\n                               (b**\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e) + \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e*(b**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)*(c**\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) - (c**\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e))**\u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e / (\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e*a)\n            \u003cspan class=\"hljs-attr\"\u003eexcept\u003c/span\u003e:\n                distance = b\n\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e distance\n\n        # 다음인 레이싱 포인트 및 이전 레이싱 포인트 계산\n        def \u003cspan class=\"hljs-title function_\"\u003enext_prev_racing_point\u003c/span\u003e(closest_coords, second_closest_coords, car_coords, heading):\n\n            # 차를 더 많이 향하도록 설정\n            heading_vector = [math.\u003cspan class=\"hljs-title function_\"\u003ecos\u003c/span\u003e(math.\u003cspan class=\"hljs-title function_\"\u003eradians\u003c/span\u003e(\n                heading)), math.\u003cspan class=\"hljs-title function_\"\u003esin\u003c/span\u003e(math.\u003cspan class=\"hljs-title function_\"\u003eradians\u003c/span\u003e(heading))]\n            new_car_coords = [car_coords[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]+heading_vector[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                              car_coords[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]+heading_vector[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]]\n\n            # 새로운 차 좌표와 두 가장 가까운 레이싱 포인트까지의 거리 계산\n            distance_closest_coords_new = \u003cspan class=\"hljs-title function_\"\u003edist_2_points\u003c/span\u003e(x1=new_car_coords[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                                                        x2=closest_coords[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                                                        y1=new_car_coords[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e],\n                                                        y2=closest_coords[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\n            distance_second_closest_coords_new = \u003cspan class=\"hljs-title function_\"\u003edist_2_points\u003c/span\u003e(x1=new_car_coords[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                                                               x2=second_closest_coords[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e],\n                                                               y1=new_car_coords[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e],\n                                                               y2=second_closest_coords[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e])\n\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e distance_closest_coords_new \u0026#x3C;= \u003cspan class=\"hljs-attr\"\u003edistance_second_closest_coords_new\u003c/span\u003e:\n                next_point_coords = closest_coords\n                prev_point_coords = second_closest_coords\n            \u003cspan class=\"hljs-attr\"\u003eelse\u003c/span\u003e:\n                next_point_coords = second_closest_coords\n                prev_point_coords = closest_coords\n\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [next_point_coords, prev_point_coords]\n\n        def \u003cspan class=\"hljs-title function_\"\u003eracing_direction_diff\u003c/span\u003e(closest_coords, second_closest_coords, car_coords, heading):\n\n            # 가장 가까운 웨이포인트를 기반으로 센터 라인의 방향 계산\n            next_point, prev_point = \u003cspan class=\"hljs-title function_\"\u003enext_prev_racing_point\u003c/span\u003e(closest_coords,\n                                                            second_closest_coords,\n                                                            car_coords,\n                                                            heading)\n\n            # 방향 계산(radian 값, \u003cspan class=\"hljs-title function_\"\u003earctan2\u003c/span\u003e(dy, dx), 결과는 라디안 단위로 (-pi, pi))\n            track_direction = math.\u003cspan class=\"hljs-title function_\"\u003eatan2\u003c/span\u003e(\n                next_point[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e] - prev_point[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], next_point[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] - prev_point[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e])\n\n            # 도수로 변환\n            track_direction = math.\u003cspan class=\"hljs-title function_\"\u003edegrees\u003c/span\u003e(track_direction)\n\n            # 트랙 방향과 차량의 진행 방향 간의 차이 계산\n            direction_diff = \u003cspan class=\"hljs-title function_\"\u003eabs\u003c/span\u003e(track_direction - heading)\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e direction_diff \u003e \u003cspan class=\"hljs-number\"\u003e180\u003c/span\u003e:\n                direction_diff = \u003cspan class=\"hljs-number\"\u003e360\u003c/span\u003e - direction_diff\n\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e direction_diff\n\n        #################### 레이싱 라인 ######################\n\n        # \u003cspan class=\"hljs-title class_\"\u003eSpain\u003c/span\u003e 트랙을 위한 최적의 레이싱 라인\n        # 각 행: [x,y,speed,timeFromPreviousPoint]\n        racing_track = [\n            [\u003cspan class=\"hljs-number\"\u003e3.06664\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.69989\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.03654\u003c/span\u003e],\n            ...\n            [\u003cspan class=\"hljs-number\"\u003e2.77639\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.72086\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.03581\u003c/span\u003e],\n            [\u003cspan class=\"hljs-number\"\u003e2.92074\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.70874\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4.0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0.03621\u003c/span\u003e]]\n\n        ...\n\nreward_object = \u003cspan class=\"hljs-title class_\"\u003eReward\u003c/span\u003e()\n\n\ndef \u003cspan class=\"hljs-title function_\"\u003ereward_function\u003c/span\u003e(params):\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e reward_object.\u003cspan class=\"hljs-title function_\"\u003ereward_function\u003c/span\u003e(params)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e코드 구현의 세부 사항에 관심이 있는 분들을 위해, 제 GitHub 저장소를 살펴보실 것을 초대합니다:\u003c/p\u003e\n\u003ch1\u003e감사의 말\u003c/h1\u003e\n\u003cp\u003e이 모델을 교육하는 경험은 절대적으로 즐거웠으며 가치 있는 학습 여정이었습니다. 강화 학습에 대한 실용적인 통찰을 얻을 뿐만 아니라, 즐거운 레이싱 게임 측면 때문에 이를 수행하는 데 즐거움을 느꼈습니다. 이 경험을 가능하게 해 준 주최자들께 감사의 말씀을 전하고 싶습니다 (교육 시간은 싸지 않습니다)!\u003c/p\u003e\n\u003cp\u003e이 GitHub 저장소를 완성하는 데 중요한 참고 자료로 사용된 두 명의 저자 dgnzlz 및 GitHub 사용자 oscarYCL의 역할에 감사의 의미를 표합니다. Capstone_AWS_DeepRacer 및 deepracer-waypoints-workshop이라는 저장소는 그들의 창의성과 기여가 귀중했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e마지막으로, 이겪은 것은 팀워크입니다. 제 동료들과 함께 이 모델을 개발하는 과정을 즐겼습니다.\u003c/p\u003e\n\u003ch1\u003e참고\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/dgnzlz/Capstone_AWS_DeepRacer\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/dgnzlz/Capstone_AWS_DeepRacer\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/oscarYCL/deepracer-waypoints-workshop\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://github.com/oscarYCL/deepracer-waypoints-workshop\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.aws.amazon.com/deepracer/latest/developerguide/deepracer-reward-function-input.html\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://docs.aws.amazon.com/deepracer/latest/developerguide/deepracer-reward-function-input.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-EnhancingYourAWSDeepRacerPerformancewithGradientDescentAlgorithmandPersonalizedWaypoints"},"buildId":"kkckKPyxcjJp_o8wb2unW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>