<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>LangFlow와 Ollama로 코딩 없이 로컬 RAG 챗봇 만들기 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="LangFlow와 Ollama로 코딩 없이 로컬 RAG 챗봇 만들기 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="LangFlow와 Ollama로 코딩 없이 로컬 RAG 챗봇 만들기 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama" data-gatsby-head="true"/><meta name="twitter:title" content="LangFlow와 Ollama로 코딩 없이 로컬 RAG 챗봇 만들기 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 20:49" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">LangFlow와 Ollama로 코딩 없이 로컬 RAG 챗봇 만들기 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="LangFlow와 Ollama로 코딩 없이 로컬 RAG 챗봇 만들기 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">11<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>⁤스마트 챗봇을 만드는 데 수개월의 코딩이 필요했던 시절을 기억하나요?</p>
<p>LangChain과 같은 프레임워크는 개발을 간소화했지만, 수백 줄의 코드는 프로그래머가 아닌 사람들에게 여전히 장벽일 수 있습니다. ⁤</p>
<p>더 간단한 방법은 없을까요? (풀 스토리를 읽기 위해 친구 링크를 찾으려면 이미 Medium 회원이 아닌 경우 Medium 회원 가입을 고려해 주세요)</p>
<p><img src="/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_0.png" alt="image"></p>
<div class="content-ad"></div>
<p>그때 "Lang Flow"를 발견했어요. 이 오픈 소스 패키지는 Python 버전의 LangChain을 기반으로 구축되었습니다. 코드를 한 줄도 쓰지 않고 AI 애플리케이션을 만들 수 있게 해줘요. 챗봇을 만들기 위해 컴포넌트들을 끌어다가 캔버스에서 연결하기만 하면 돼요.</p>
<p>이 게시물에서는 LangFlow를 사용해서 몇 분 안에 스마트 AI 챗봇 프로토타입을 만들 거에요. 백엔드로는 Ollama를 사용하여 임베딩 모델과 대형 언어 모델을 사용할 거에요. 이렇게 하면 응용프로그램을 로컬에서 무료로 실행할 수 있어요! 마지막으로 이 흐름을 최소한의 코딩으로 Streamlit 애플리케이션으로 변환할 거에요.</p>
<h1>RAG Pipeline, LangChain, LangFlow, Ollama 소개</h1>
<p>이 프로젝트에서는 AI 챗봇을 만들어보려고 해요. "Dinnerly - 당신의 건강한 요리 플래너" 라고 이름 붙여보죠. 이 챗봇은 건강한 요리 레시피를 추천하는 것을 목표로 합니다. 이를 위해 RAG(Retrieval Augmented Generation)를 사용하여 레시피 PDF 파일에서 추출할 거에요.</p>
<div class="content-ad"></div>
<p>어떻게 이를 실현할 것인지에 대해 들어가기 전에 프로젝트에서 사용할 핵심 재료를 빠르게 살펴보겠습니다.</p>
<h2>검색 증강 생성 (RAG)</h2>
<p>RAG(검색 증강 생성)은 대형 언어 모델 (LLMs)이 외부 소스에서 관련 정보를 제공받아 돕는 기술입니다. 이를 통해 LLM은 응답을 생성할 때 이 문맥을 고려하여 보다 정확하고 최신의 결과를 만들어냅니다.</p>
<p>RAG 파이프라인에는 일반적으로 '검색 증강 생성 안내서'에 설명된대로 다음 단계가 포함됩니다.</p>
<div class="content-ad"></div>
<p>“</p>
<ul>
<li>문서 로드: 문서 또는 데이터 원본을 먼저로드하십시오.</li>
<li>청크로 분할: 문서를 관리하기 쉬운 부분으로 나누십시오.</li>
<li>임베딩 생성: 임베딩을 사용하여 이러한 청크를 벡터 표현으로 변환하십시오.</li>
<li>벡터 데이터베이스에 저장: 이러한 벡터를 데이터베이스에 저장하여 효율적으로 검색하십시오.</li>
<li>사용자 상호 작용: 사용자로부터 쿼리 또는 입력을받고 그것을 임베딩으로 변환하십시오.</li>
<li>벡터 데이터베이스에서 의미 검색: 사용자 쿼리를 기반으로 의미 검색을 수행하기 위해 벡터 데이터베이스에 연결하십시오.</li>
<li>응답 검색 및 처리: 관련 응답을 가져와 LLM을 통과시키고 답변을 생성하십시오.</li>
<li>사용자에게 답변 전달: LLM에 의해 생성된 최종 출력물을 사용자에게 제공하십시오.
”</li>
</ul>
<h2>Langchain</h2>
<div class="content-ad"></div>
<p>LLMs을 중심으로 만들어진 오픈 소스 프레임워크인 LangChain은 챗봇, 요약 등 다양한 GenAI 응용 프로그램의 설계와 개발을 용이하게 합니다.</p>
<p>이 라이브러리의 핵심 아이디어는 다른 구성 요소를 "체인"으로 연결하여 복잡한 AI 작업을 단순화하고 LLMs 주변에서 더 많은 고급 사용 사례를 만드는 것입니다.</p>
<p><img src="/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_1.png" alt="이미지"></p>
<h2>LangFlow</h2>
<div class="content-ad"></div>
<p>LangFlow은 LangChain을 위해 특별히 설계된 웹 도구입니다. 사용자가 코딩없이 LangChain 애플리케이션을 구축하고 테스트할 수 있는 사용자 인터페이스를 제공합니다. 간단히 구성 요소를 끌어다 놓기만 하면 됩니다.</p>
<p>하지만 LangFlow를 사용하려면 LangChain의 작동 방식과 다양한 구성 요소에 대한 기본적인 이해가 필요합니다. 그러면 AI 애플리케이션의 흐름을 설계하는 데 LangFlow를 사용할 수 있습니다.</p>
<p>Ollama</p>
<p>Ollama은 오픈 소스 LLM을 사용하기 위한 최고이자 가장 쉬운 방법입니다. Llama 2 및 Mistral과 같은 가장 강력한 LLM을 지원하며, ollama.ai/library에서 사용 가능한 모델 목록을 찾을 수 있습니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_2.png" alt="Ollama setup"></p>
<h1>Ollama 설정하기</h1>
<h2>Ollama 설치</h2>
<p>먼저 Ollama 다운로드 페이지로 이동하여 사용 중인 운영 체제와 일치하는 버전을 선택한 후 다운로드하고 설치하세요.</p>
<div class="content-ad"></div>
<p>Ollama를 설치한 후에 명령 터미널을 열고 다음 명령을 입력하세요. 이 명령들은 모델을 다운로드하고 로컬 머신에서 실행할 것입니다.</p>
<p>이 프로젝트에서는 우리가 Large Language Model (LLM)으로 Llama2를 사용하고, 임베딩 모델로 "nomic-embed-text"를 사용할 것입니다. "Nomic-embed-text"는 큰 컨텍스트 윈도우를 가진 강력한 오픈 소스 임베딩 모델입니다. 이를 통해 전체 애플리케이션을 클라우드 서비스 없이 로컬에서 실행할 수 있습니다!</p>
<pre><code class="hljs language-js">ollama serve
ollama pull llama2
ollama pull nomic-embed-text
ollama run llama2
</code></pre>
<h1>LangFlow 설정하기</h1>
<div class="content-ad"></div>
<h2>준비 사항</h2>
<p>LangFlow을 시작하기 전에 컴퓨터에 Python이 설치되어 있는지 확인하는 것이 중요합니다. Python 버전은 3.9보다 높아야 하지만 3.12보다 낮아야 합니다.</p>
<p>LangFlow 설치</p>
<p>이제 LangFlow를 설치해 봅시다. 가상 환경 내에서 설치하는 것을 권장합니다. 이 방법을 사용하면 종속성을 깔끔하게 자체 공간 내에서 관리할 수 있습니다. 저는 Mac에서 Conda를 사용하여 설정합니다. 명령 줄 터미널에 다음 명령을 입력하여 "langflow"라는 가상 환경을 만들고 Python 3.11을 설정하세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">conda create -n langflow python=<span class="hljs-number">3.11</span>
conda activate langflow
pip install langflow
</code></pre>
<p>콘다를 사용하지 않는 경우에도 다음 명령어를 사용하여 Python으로 직접 가상 환경을 설정할 수 있어요.</p>
<pre><code class="hljs language-js">python -m venv langflow
source langflow/bin/activate
pip install langflow
</code></pre>
<p>설치를 마치면 LangFlow를 시작하는 것은 매우 간단합니다. 터미널에 "langflow run"을 입력하기만 하면 돼요.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_3.png" alt=""></p>
<p>그런 다음, 제공된 URL을 복사하세요 (위의 예에서는 <a href="http://127.0.0.1:7860" rel="nofollow" target="_blank">http://127.0.0.1:7860</a>), 웹 브라우저에 붙여넣기하고, 와! 이런 식으로 보이는 인터페이스를 볼 수 있어야 합니다. 이 페이지에는 모든 프로젝트가 표시됩니다.</p>
<p><img src="/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_4.png" alt=""></p>
<h1>챗봇 플로우 디자인하기</h1>
<div class="content-ad"></div>
<p>첫 번째 플로우를 만드는 시간이군요!</p>
<p>"새 프로젝트"를 클릭하여 빈 캔버스를 열어보세요. 왼쪽 창에는 드래그하여 작업 영역에 놓을 수 있는 다양한 구성 요소가 준비되어 있습니다.</p>
<p>우리 프로젝트를 위해 PDF 파일에서 질문에 답변할 수 있는 챗봇을 만들고 있습니다. 이전에 언급한 RAG 파이프라인을 기억하시나요? 이를 구성할 때 필요한 몇 가지 요소가 있습니다:</p>
<ul>
<li>PDF 로더: 여기서 "PyPDFLoader"를 사용할 것입니다. PDF 문서의 파일 경로를 입력해야 합니다.</li>
<li>텍스트 분할기: "RecursiveCharacterTextSplitter"를 선택하고 기본 설정을 사용하시면 됩니다.</li>
<li>텍스트 임베딩 모델: 무료 오픈소스 임베딩을 사용하려면 "OllamaEmbeddings"를 선택하세요.</li>
<li>벡터 데이터베이스: 임베딩을 저장하고 벡터 검색을 용이하게 하기 위해 "FAISS"를 선택합니다.</li>
<li>응답 생성을 위한 LLM: "ChatOllama"를 선택하고 모델을 "llama2"로 지정하세요.</li>
<li>대화 기억: 챗봇이 채팅 기록을 유지하도록 하는 기능으로 "ConversationBufferMemory"를 사용할 것입니다.</li>
<li>대화 검색 체인: LLM, 메모리, 검색된 텍스트 등과 같은 다양한 구성 요소를 연결하여 응답을 생성하는 기능입니다. "ConversationRetrievalChain"이 우리의 선택입니다.</li>
</ul>
<div class="content-ad"></div>
<p>캔버스로 모든 구성 요소를 끌어다 놓고 PDF 파일 경로 및 LLM 모델 이름과 같은 필수 필드를 설정하세요. 나머지 설정은 기본값으로 두어도 괜찮습니다.</p>
<p>그 다음, 이러한 구성 요소를 연결하여 흐름을 만들어보세요.</p>
<p>모든 것이 연결되었다면, 우측 하단에 있는 "번개" 버튼을 눌러 흐름을 컴파일하세요. 모든 것이 순조롭게 진행된다면 버튼이 녹색으로 바뀌어 성공을 알리게 됩니다.</p>
<p>흐름을 성공적으로 컴파일한 후, "챗봇" 아이콘을 클릭하여 생성물을 테스트해보세요.</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_5.png">
<p>여러 가지 팁:</p>
<ul>
<li>플로우를 완료하면 JSON 파일로 저장하거나 나중에 액세스하거나 편집할 수 있도록 "내 컬렉션"에서 찾을 수 있습니다.</li>
<li>사전 빌트 예제로 LangFlow에 뛰어들면 훌륭한 영감을 얻고 시작하는 데 도움이 될 수 있습니다. 여기에 팁이 있습니다:</li>
<li>"LangFlow Store"는 예제를 보유하고 있지만 액세스를 위해 API 키가 필요합니다.</li>
<li>LangFlow GitHub 페이지를 통해 예제를 다운로드하여 "업로드" 버튼을 사용하여 LangFlow UI로 업로드할 수 있습니다.</li>
<li>로컬로 설정하는 것이 꺼려지면, OpenAI를 선택하여 RAG 파이프라인을 구축할 수도 있습니다. 설정을 위해 OpenAI API 키를 가지고 있는지 확인하세요.</li>
</ul>
<h1>플로우를 스트림릿 챗봇으로 변환하기</h1>
<div class="content-ad"></div>
<p>이제 플로우가 완벽하게 설정되었다면, 애플리케이션에 통합할 시간입니다. 플로우를 구축한 후에는 LangFlow가 필요한 코드 조각을 제공하여 쉽게 만들어줍니다. 사이드바에서 "코드" 버튼을 누르기만 하면 됩니다.</p>
<p><img src="/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_6.png" alt="image"></p>
<p>이제 이 플로우를 Streamlit 챗봇에 통합해 보겠습니다.</p>
<ul>
<li>종속성 설정: 시작하기 전에 종속성을 설치해야 합니다.</li>
</ul>
<div class="content-ad"></div>
<pre><code class="hljs language-js">pip install streamlit
pip install langflow
pip install langchain-community 
</code></pre>
<ol start="2">
<li>Lang Flow 코드 스니펫 가져오기: "app.py"라는 새로운 Python 파일을 만듭니다. LangFlow UI로 돌아가 "Code" 버튼을 다시 찾습니다. "Python API" 탭으로 이동하여 코드 스니펫을 복사하고 "app.py"에 붙여넣습니다.</li>
</ol>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> requests
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-title class_">Optional</span>

<span class="hljs-variable constant_">BASE_API_URL</span> = <span class="hljs-string">"http://127.0.0.1:7860/api/v1/process"</span>
<span class="hljs-variable constant_">FLOW_ID</span> = <span class="hljs-string">"d9392262-a912-42b4-8582-cc9e48894a00"</span>

# 원하는대로 플로우를 조정할 수 있습니다.
# 예시: {<span class="hljs-string">"OpenAI-XXXXX"</span>: {<span class="hljs-string">"model_name"</span>: <span class="hljs-string">"gpt-4"</span>}
<span class="hljs-variable constant_">TWEAKS</span> = {
  <span class="hljs-string">"VectorStoreAgent-brRPx"</span>: {},
  <span class="hljs-string">"VectorStoreInfo-BS24v"</span>: {},
  <span class="hljs-string">"OpenAIEmbeddings-lnfRZ"</span>: {},
  <span class="hljs-string">"RecursiveCharacterTextSplitter-bErPe"</span>: {},
  <span class="hljs-string">"WebBaseLoader-HLOqm"</span>: {},
  <span class="hljs-string">"ChatOpenAI-aQOv0"</span>: {},
  <span class="hljs-string">"FAISS-o0WIf"</span>: {}
}

def <span class="hljs-title function_">run_flow</span>(<span class="hljs-attr">inputs</span>: dict, <span class="hljs-attr">flow_id</span>: str, <span class="hljs-attr">tweaks</span>: <span class="hljs-title class_">Optional</span>[dict] = <span class="hljs-title class_">None</span>) -> <span class="hljs-attr">dict</span>:
    <span class="hljs-string">""</span><span class="hljs-string">"
    주어진 메시지와 선택적 조정으로 플로우를 실행합니다.

    :param message: 플로우에 보낼 메시지
    :param flow_id: 실행할 플로우의 ID
    :param tweaks: 플로우를 사용자 정의하는 선택적 조정
    :return: 플로우의 JSON 응답
    "</span><span class="hljs-string">""</span>
    api_url = f<span class="hljs-string">"{BASE_API_URL}/{flow_id}"</span>

    payload = {<span class="hljs-string">"inputs"</span>: inputs}
    headers = <span class="hljs-title class_">None</span>
    <span class="hljs-keyword">if</span> <span class="hljs-attr">tweaks</span>:
        payload[<span class="hljs-string">"tweaks"</span>] = tweaks
    response = requests.<span class="hljs-title function_">post</span>(api_url, json=payload, headers=headers)
    <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>()
</code></pre>
<ol start="3">
<li>채팅 기능 구현: 같은 Python 파일에서 사용자의 새로운 쿼리마다 응답을 가져오기 위해 플로우를 실행하는 함수를 정의합니다. 그런 다음 이 응답을 인터페이스에 스트리밍합니다.</li>
</ol>
<div class="content-ad"></div>
<pre><code class="hljs language-js">def <span class="hljs-title function_">chat</span>(<span class="hljs-attr">prompt</span>: str):
  <span class="hljs-keyword">with</span> <span class="hljs-attr">current_chat_message</span>:
    # <span class="hljs-variable constant_">AI</span>가 응답할 때 메시지를 보내지 못하도록 입력을 차단합니다
    st.<span class="hljs-property">session_state</span>.<span class="hljs-property">disabled</span> = <span class="hljs-title class_">True</span>

    # 사용자 메시지를 채팅 기록에 추가합니다
    st.<span class="hljs-property">session_state</span>.<span class="hljs-property">messages</span>.<span class="hljs-title function_">append</span>((<span class="hljs-string">"human"</span>, prompt))

    # 채팅 메시지 컨테이너에 사용자 메시지를 표시합니다
    <span class="hljs-keyword">with</span> st.<span class="hljs-title function_">chat_message</span>(<span class="hljs-string">"human"</span>):
      st.<span class="hljs-title function_">markdown</span>(prompt)

    # 채팅 메시지 컨테이너에 어시스턴트 응답을 표시합니다
    <span class="hljs-keyword">with</span> st.<span class="hljs-title function_">chat_message</span>(<span class="hljs-string">"ai"</span>):
      # 최신 질문을 마지막 메시지로 포함한 전체 채팅 기록을 가져옵니다
      history = <span class="hljs-string">"\n"</span>.<span class="hljs-title function_">join</span>(
        [f<span class="hljs-string">"{role}: {msg}"</span> <span class="hljs-keyword">for</span> role, msg <span class="hljs-keyword">in</span> st.<span class="hljs-property">session_state</span>.<span class="hljs-property">messages</span>]
      )

      query = f<span class="hljs-string">"{history}\nAI:"</span>

      # 흐름에 적용할 수정 사항을 설정합니다
      inputs = {<span class="hljs-string">"input"</span>: query}

      output = <span class="hljs-title function_">run_flow</span>(inputs, flow_id=<span class="hljs-variable constant_">FLOW_ID</span>, tweaks=<span class="hljs-variable constant_">TWEAKS</span>)
      <span class="hljs-title function_">print</span>(output)
      <span class="hljs-attr">try</span>:
        output = output[<span class="hljs-string">'result'</span>][<span class="hljs-string">'output'</span>]
      except <span class="hljs-title class_">Exception</span> :
        output = f<span class="hljs-string">"애플리케이션 오류 : {output}"</span>

      placeholder = st.<span class="hljs-title function_">empty</span>()
      response = <span class="hljs-string">""</span>

      <span class="hljs-keyword">for</span> tokens <span class="hljs-keyword">in</span> <span class="hljs-attr">output</span>:
        response += tokens
        # <span class="hljs-string">"▌"</span>으로 스트리밍을 표시하여 응답을 작성합니다
        <span class="hljs-keyword">with</span> <span class="hljs-attr">placeholder</span>:
          st.<span class="hljs-title function_">markdown</span>(response + <span class="hljs-string">"▌"</span>)

      # <span class="hljs-string">"▌"</span> 없이 완료된 메시지를 표시합니다
      <span class="hljs-keyword">with</span> <span class="hljs-attr">placeholder</span>:
        st.<span class="hljs-title function_">markdown</span>(response)

    # <span class="hljs-variable constant_">AI</span> 응답을 채팅 기록에 기록합니다
    st.<span class="hljs-property">session_state</span>.<span class="hljs-property">messages</span>.<span class="hljs-title function_">append</span>((<span class="hljs-string">"ai"</span>, response))
    # 채팅 입력 해제
    st.<span class="hljs-property">session_state</span>.<span class="hljs-property">disabled</span> = <span class="hljs-title class_">False</span>

    st.<span class="hljs-title function_">rerun</span>()
</code></pre>
<ol start="4">
<li>인터페이스 만들기: 이제 동일한 Python 파일에서 다음 코드를 사용하여 간단한 Streamlit 사용자 인터페이스를 만들어보겠습니다.</li>
</ol>
<pre><code class="hljs language-js">st.<span class="hljs-title function_">set_page_config</span>(page_title=<span class="hljs-string">"Dinnerly"</span>)
st.<span class="hljs-title function_">title</span>(<span class="hljs-string">"Dinnerly에 오신 것을 환영합니다: 건강한 요리 플래너"</span>)

system_prompt = <span class="hljs-string">"사용자에게 건강한 요리 레시피를 제안하고 제공하는 유용한 도우미입니다"</span>
<span class="hljs-keyword">if</span> <span class="hljs-string">"messages"</span> not <span class="hljs-keyword">in</span> st.<span class="hljs-property">session_state</span>:
    st.<span class="hljs-property">session_state</span>.<span class="hljs-property">messages</span> = [(<span class="hljs-string">"system"</span>, system_prompt)]
<span class="hljs-keyword">if</span> <span class="hljs-string">"disabled"</span> not <span class="hljs-keyword">in</span> st.<span class="hljs-property">session_state</span>:
    # <span class="hljs-variable constant_">AI</span>가 응답 중일 때 사용자가 메시지를 보내지 못하도록하는 <span class="hljs-string">'disabled'</span> 플래그
    st.<span class="hljs-property">session_state</span>.<span class="hljs-property">disabled</span> = <span class="hljs-title class_">False</span>


<span class="hljs-keyword">with</span> st.<span class="hljs-title function_">chat_message</span>(<span class="hljs-string">"ai"</span>):
  st.<span class="hljs-title function_">markdown</span>(
    f<span class="hljs-string">"안녕하세요! 건강한 요리 플래너입니다. 건강하고 맛있는 요리를 준비하는 데 도움을 드리겠습니다!"</span>
  )

# 앱 재실행 시 기록된 채팅 메시지 표시
<span class="hljs-keyword">for</span> role, message <span class="hljs-keyword">in</span> st.<span class="hljs-property">session_state</span>.<span class="hljs-property">messages</span>:
    <span class="hljs-keyword">if</span> role == <span class="hljs-string">"system"</span>:
        <span class="hljs-keyword">continue</span>
    <span class="hljs-keyword">with</span> st.<span class="hljs-title function_">chat_message</span>(role):
        st.<span class="hljs-title function_">markdown</span>(message)

current_chat_message = st.<span class="hljs-title function_">container</span>()
prompt = st.<span class="hljs-title function_">chat_input</span>(<span class="hljs-string">"질문을 여기에 입력하세요..."</span>, disabled=st.<span class="hljs-property">session_state</span>.<span class="hljs-property">disabled</span>)

<span class="hljs-keyword">if</span> <span class="hljs-attr">prompt</span>:
    <span class="hljs-title function_">chat</span>(prompt)
</code></pre>
<p>Streamlit 앱을 실행하면 자체 요리 플래너와 채팅할 수 있습니다! 맛있고 건강한 요리를 만드는 데 도움이 됩니다.</p>
<div class="content-ad"></div>
<p>마크다운 형식으로 표 태그를 변경하십시오.</p>
<p>Tips:</p>
<p>다른 플로우에 대해 동일한 코드와 인터페이스를 사용할 수 있습니다. FLOW_ID를 변경하여 새로운 플로우를 앱에 테스트 및 통합하세요.</p>
<img src="/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_8.png">
<div class="content-ad"></div>
<h1>마무리 생각</h1>
<p>이 글에서 우리는 스마트한 RAG 기반 챗봇을 만들었습니다. 우리는 코드를 작성할 필요 없이 LangFlow를 활용하여 RAG 파이프라인을 설정했고, 임베딩 및 LLM 처리를 위해 오픈 소스 모델을 활용하여 응용 프로그램을 로컬에서 실행하고 추론 비용 없이 유지했습니다. 마지막으로,이 설정을 Streamlit 애플리케이션으로 변환했습니다.</p>
<p>특히 LangFlow의 노코드 방식을 감사히 여기고, AI 응용 프로그램을 구축하고 프로토타입화하는 방식을 바꿀 수 있다고 믿습니다.</p>
<p>그러나 아직 개발 중인 구성 요소가 있으며 때로는 예상대로 작동하지 않을 수 있음을 언급할 가치가 있습니다. 이러한 순간이 발생할 때 문제에 대한 가시성이나 문제 해결에 대한 안내가 부족할 수 있습니다. 또 다른 개선 사항으로는 Python 코드를 직접 제공하여 더 많은 사용자 정의를 제공하는 것이 있을 수 있습니다.</p>
<div class="content-ad"></div>
<p>LangFlow은 빠른 프로토타이핑 필요에 유용한 도구라고 생각해요.</p>
<h2>떠나시기 전에! 🦸🏻‍♀️</h2>
<p>만약 제 이야기가 마음에 드셨고 저를 지원하고 싶으시다면:</p>
<ul>
<li>약간의 Medium 사랑을 보내주세요 💕(박수, 댓글 및 하이라이트), 여러분의 지원은 저에게 큰 힘이 됩니다.👏</li>
<li>Medium에서 저를 팔로우하고 최신 기사를 받아보세요🫶</li>
</ul>
<div class="content-ad"></div>
<h2>참고</h2>
<ul>
<li>LangFlow 문서</li>
<li>Ollama 문서</li>
<li>Deliciously Healthy Dinners (데모에서 사용된 pdf 파일): <a href="https://healthyeating.nhlbi.nih.gov/pdfs/dinners_cookbook_508-compliant.pdf" rel="nofollow" target="_blank">링크</a></li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"LangFlow와 Ollama로 코딩 없이 로컬 RAG 챗봇 만들기 방법","description":"","date":"2024-06-22 20:49","slug":"2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama","content":"\n\n⁤스마트 챗봇을 만드는 데 수개월의 코딩이 필요했던 시절을 기억하나요?\n\nLangChain과 같은 프레임워크는 개발을 간소화했지만, 수백 줄의 코드는 프로그래머가 아닌 사람들에게 여전히 장벽일 수 있습니다. ⁤\n\n더 간단한 방법은 없을까요? (풀 스토리를 읽기 위해 친구 링크를 찾으려면 이미 Medium 회원이 아닌 경우 Medium 회원 가입을 고려해 주세요)\n\n![image](/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_0.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그때 \"Lang Flow\"를 발견했어요. 이 오픈 소스 패키지는 Python 버전의 LangChain을 기반으로 구축되었습니다. 코드를 한 줄도 쓰지 않고 AI 애플리케이션을 만들 수 있게 해줘요. 챗봇을 만들기 위해 컴포넌트들을 끌어다가 캔버스에서 연결하기만 하면 돼요. \n\n이 게시물에서는 LangFlow를 사용해서 몇 분 안에 스마트 AI 챗봇 프로토타입을 만들 거에요. 백엔드로는 Ollama를 사용하여 임베딩 모델과 대형 언어 모델을 사용할 거에요. 이렇게 하면 응용프로그램을 로컬에서 무료로 실행할 수 있어요! 마지막으로 이 흐름을 최소한의 코딩으로 Streamlit 애플리케이션으로 변환할 거에요.\n\n# RAG Pipeline, LangChain, LangFlow, Ollama 소개\n\n이 프로젝트에서는 AI 챗봇을 만들어보려고 해요. \"Dinnerly - 당신의 건강한 요리 플래너\" 라고 이름 붙여보죠. 이 챗봇은 건강한 요리 레시피를 추천하는 것을 목표로 합니다. 이를 위해 RAG(Retrieval Augmented Generation)를 사용하여 레시피 PDF 파일에서 추출할 거에요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떻게 이를 실현할 것인지에 대해 들어가기 전에 프로젝트에서 사용할 핵심 재료를 빠르게 살펴보겠습니다.\n\n## 검색 증강 생성 (RAG)\n\nRAG(검색 증강 생성)은 대형 언어 모델 (LLMs)이 외부 소스에서 관련 정보를 제공받아 돕는 기술입니다. 이를 통해 LLM은 응답을 생성할 때 이 문맥을 고려하여 보다 정확하고 최신의 결과를 만들어냅니다.\n\nRAG 파이프라인에는 일반적으로 '검색 증강 생성 안내서'에 설명된대로 다음 단계가 포함됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n“\n- 문서 로드: 문서 또는 데이터 원본을 먼저로드하십시오.\n- 청크로 분할: 문서를 관리하기 쉬운 부분으로 나누십시오.\n- 임베딩 생성: 임베딩을 사용하여 이러한 청크를 벡터 표현으로 변환하십시오.\n- 벡터 데이터베이스에 저장: 이러한 벡터를 데이터베이스에 저장하여 효율적으로 검색하십시오.\n- 사용자 상호 작용: 사용자로부터 쿼리 또는 입력을받고 그것을 임베딩으로 변환하십시오.\n- 벡터 데이터베이스에서 의미 검색: 사용자 쿼리를 기반으로 의미 검색을 수행하기 위해 벡터 데이터베이스에 연결하십시오.\n- 응답 검색 및 처리: 관련 응답을 가져와 LLM을 통과시키고 답변을 생성하십시오.\n- 사용자에게 답변 전달: LLM에 의해 생성된 최종 출력물을 사용자에게 제공하십시오.\n”\n\n## Langchain\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLLMs을 중심으로 만들어진 오픈 소스 프레임워크인 LangChain은 챗봇, 요약 등 다양한 GenAI 응용 프로그램의 설계와 개발을 용이하게 합니다.\n\n이 라이브러리의 핵심 아이디어는 다른 구성 요소를 \"체인\"으로 연결하여 복잡한 AI 작업을 단순화하고 LLMs 주변에서 더 많은 고급 사용 사례를 만드는 것입니다.\n\n![이미지](/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_1.png)\n\n## LangFlow\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLangFlow은 LangChain을 위해 특별히 설계된 웹 도구입니다. 사용자가 코딩없이 LangChain 애플리케이션을 구축하고 테스트할 수 있는 사용자 인터페이스를 제공합니다. 간단히 구성 요소를 끌어다 놓기만 하면 됩니다.\n\n하지만 LangFlow를 사용하려면 LangChain의 작동 방식과 다양한 구성 요소에 대한 기본적인 이해가 필요합니다. 그러면 AI 애플리케이션의 흐름을 설계하는 데 LangFlow를 사용할 수 있습니다.\n\nOllama\n\nOllama은 오픈 소스 LLM을 사용하기 위한 최고이자 가장 쉬운 방법입니다. Llama 2 및 Mistral과 같은 가장 강력한 LLM을 지원하며, ollama.ai/library에서 사용 가능한 모델 목록을 찾을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![Ollama setup](/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_2.png)\n\n# Ollama 설정하기\n\n## Ollama 설치\n\n먼저 Ollama 다운로드 페이지로 이동하여 사용 중인 운영 체제와 일치하는 버전을 선택한 후 다운로드하고 설치하세요.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOllama를 설치한 후에 명령 터미널을 열고 다음 명령을 입력하세요. 이 명령들은 모델을 다운로드하고 로컬 머신에서 실행할 것입니다.\n\n이 프로젝트에서는 우리가 Large Language Model (LLM)으로 Llama2를 사용하고, 임베딩 모델로 \"nomic-embed-text\"를 사용할 것입니다. \"Nomic-embed-text\"는 큰 컨텍스트 윈도우를 가진 강력한 오픈 소스 임베딩 모델입니다. 이를 통해 전체 애플리케이션을 클라우드 서비스 없이 로컬에서 실행할 수 있습니다!\n\n```js\nollama serve\nollama pull llama2\nollama pull nomic-embed-text\nollama run llama2\n```\n\n# LangFlow 설정하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 준비 사항\n\nLangFlow을 시작하기 전에 컴퓨터에 Python이 설치되어 있는지 확인하는 것이 중요합니다. Python 버전은 3.9보다 높아야 하지만 3.12보다 낮아야 합니다.\n\nLangFlow 설치\n\n이제 LangFlow를 설치해 봅시다. 가상 환경 내에서 설치하는 것을 권장합니다. 이 방법을 사용하면 종속성을 깔끔하게 자체 공간 내에서 관리할 수 있습니다. 저는 Mac에서 Conda를 사용하여 설정합니다. 명령 줄 터미널에 다음 명령을 입력하여 \"langflow\"라는 가상 환경을 만들고 Python 3.11을 설정하세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconda create -n langflow python=3.11\nconda activate langflow\npip install langflow\n```\n\n콘다를 사용하지 않는 경우에도 다음 명령어를 사용하여 Python으로 직접 가상 환경을 설정할 수 있어요.\n\n```js\npython -m venv langflow\nsource langflow/bin/activate\npip install langflow\n```\n\n설치를 마치면 LangFlow를 시작하는 것은 매우 간단합니다. 터미널에 \"langflow run\"을 입력하기만 하면 돼요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![](/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_3.png)\n\n그런 다음, 제공된 URL을 복사하세요 (위의 예에서는 http://127.0.0.1:7860), 웹 브라우저에 붙여넣기하고, 와! 이런 식으로 보이는 인터페이스를 볼 수 있어야 합니다. 이 페이지에는 모든 프로젝트가 표시됩니다.\n\n![](/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_4.png)\n\n# 챗봇 플로우 디자인하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n첫 번째 플로우를 만드는 시간이군요!\n\n\"새 프로젝트\"를 클릭하여 빈 캔버스를 열어보세요. 왼쪽 창에는 드래그하여 작업 영역에 놓을 수 있는 다양한 구성 요소가 준비되어 있습니다.\n\n우리 프로젝트를 위해 PDF 파일에서 질문에 답변할 수 있는 챗봇을 만들고 있습니다. 이전에 언급한 RAG 파이프라인을 기억하시나요? 이를 구성할 때 필요한 몇 가지 요소가 있습니다:\n\n- PDF 로더: 여기서 \"PyPDFLoader\"를 사용할 것입니다. PDF 문서의 파일 경로를 입력해야 합니다.\n- 텍스트 분할기: \"RecursiveCharacterTextSplitter\"를 선택하고 기본 설정을 사용하시면 됩니다.\n- 텍스트 임베딩 모델: 무료 오픈소스 임베딩을 사용하려면 \"OllamaEmbeddings\"를 선택하세요.\n- 벡터 데이터베이스: 임베딩을 저장하고 벡터 검색을 용이하게 하기 위해 \"FAISS\"를 선택합니다.\n- 응답 생성을 위한 LLM: \"ChatOllama\"를 선택하고 모델을 \"llama2\"로 지정하세요.\n- 대화 기억: 챗봇이 채팅 기록을 유지하도록 하는 기능으로 \"ConversationBufferMemory\"를 사용할 것입니다.\n- 대화 검색 체인: LLM, 메모리, 검색된 텍스트 등과 같은 다양한 구성 요소를 연결하여 응답을 생성하는 기능입니다. \"ConversationRetrievalChain\"이 우리의 선택입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n캔버스로 모든 구성 요소를 끌어다 놓고 PDF 파일 경로 및 LLM 모델 이름과 같은 필수 필드를 설정하세요. 나머지 설정은 기본값으로 두어도 괜찮습니다.\n\n그 다음, 이러한 구성 요소를 연결하여 흐름을 만들어보세요.\n\n모든 것이 연결되었다면, 우측 하단에 있는 \"번개\" 버튼을 눌러 흐름을 컴파일하세요. 모든 것이 순조롭게 진행된다면 버튼이 녹색으로 바뀌어 성공을 알리게 됩니다.\n\n흐름을 성공적으로 컴파일한 후, \"챗봇\" 아이콘을 클릭하여 생성물을 테스트해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_5.png\" /\u003e\n\n여러 가지 팁:\n\n- 플로우를 완료하면 JSON 파일로 저장하거나 나중에 액세스하거나 편집할 수 있도록 \"내 컬렉션\"에서 찾을 수 있습니다.\n- 사전 빌트 예제로 LangFlow에 뛰어들면 훌륭한 영감을 얻고 시작하는 데 도움이 될 수 있습니다. 여기에 팁이 있습니다:\n- \"LangFlow Store\"는 예제를 보유하고 있지만 액세스를 위해 API 키가 필요합니다.\n- LangFlow GitHub 페이지를 통해 예제를 다운로드하여 \"업로드\" 버튼을 사용하여 LangFlow UI로 업로드할 수 있습니다.\n- 로컬로 설정하는 것이 꺼려지면, OpenAI를 선택하여 RAG 파이프라인을 구축할 수도 있습니다. 설정을 위해 OpenAI API 키를 가지고 있는지 확인하세요.\n\n# 플로우를 스트림릿 챗봇으로 변환하기\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 플로우가 완벽하게 설정되었다면, 애플리케이션에 통합할 시간입니다. 플로우를 구축한 후에는 LangFlow가 필요한 코드 조각을 제공하여 쉽게 만들어줍니다. 사이드바에서 \"코드\" 버튼을 누르기만 하면 됩니다.\n\n![image](/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_6.png)\n\n이제 이 플로우를 Streamlit 챗봇에 통합해 보겠습니다.\n\n- 종속성 설정: 시작하기 전에 종속성을 설치해야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\npip install streamlit\npip install langflow\npip install langchain-community \n```\n\n2. Lang Flow 코드 스니펫 가져오기: \"app.py\"라는 새로운 Python 파일을 만듭니다. LangFlow UI로 돌아가 \"Code\" 버튼을 다시 찾습니다. \"Python API\" 탭으로 이동하여 코드 스니펫을 복사하고 \"app.py\"에 붙여넣습니다.\n\n```js\nimport requests\nfrom typing import Optional\n\nBASE_API_URL = \"http://127.0.0.1:7860/api/v1/process\"\nFLOW_ID = \"d9392262-a912-42b4-8582-cc9e48894a00\"\n\n# 원하는대로 플로우를 조정할 수 있습니다.\n# 예시: {\"OpenAI-XXXXX\": {\"model_name\": \"gpt-4\"}\nTWEAKS = {\n  \"VectorStoreAgent-brRPx\": {},\n  \"VectorStoreInfo-BS24v\": {},\n  \"OpenAIEmbeddings-lnfRZ\": {},\n  \"RecursiveCharacterTextSplitter-bErPe\": {},\n  \"WebBaseLoader-HLOqm\": {},\n  \"ChatOpenAI-aQOv0\": {},\n  \"FAISS-o0WIf\": {}\n}\n\ndef run_flow(inputs: dict, flow_id: str, tweaks: Optional[dict] = None) -\u003e dict:\n    \"\"\"\n    주어진 메시지와 선택적 조정으로 플로우를 실행합니다.\n\n    :param message: 플로우에 보낼 메시지\n    :param flow_id: 실행할 플로우의 ID\n    :param tweaks: 플로우를 사용자 정의하는 선택적 조정\n    :return: 플로우의 JSON 응답\n    \"\"\"\n    api_url = f\"{BASE_API_URL}/{flow_id}\"\n\n    payload = {\"inputs\": inputs}\n    headers = None\n    if tweaks:\n        payload[\"tweaks\"] = tweaks\n    response = requests.post(api_url, json=payload, headers=headers)\n    return response.json()\n```\n\n3. 채팅 기능 구현: 같은 Python 파일에서 사용자의 새로운 쿼리마다 응답을 가져오기 위해 플로우를 실행하는 함수를 정의합니다. 그런 다음 이 응답을 인터페이스에 스트리밍합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\ndef chat(prompt: str):\n  with current_chat_message:\n    # AI가 응답할 때 메시지를 보내지 못하도록 입력을 차단합니다\n    st.session_state.disabled = True\n\n    # 사용자 메시지를 채팅 기록에 추가합니다\n    st.session_state.messages.append((\"human\", prompt))\n\n    # 채팅 메시지 컨테이너에 사용자 메시지를 표시합니다\n    with st.chat_message(\"human\"):\n      st.markdown(prompt)\n\n    # 채팅 메시지 컨테이너에 어시스턴트 응답을 표시합니다\n    with st.chat_message(\"ai\"):\n      # 최신 질문을 마지막 메시지로 포함한 전체 채팅 기록을 가져옵니다\n      history = \"\\n\".join(\n        [f\"{role}: {msg}\" for role, msg in st.session_state.messages]\n      )\n\n      query = f\"{history}\\nAI:\"\n\n      # 흐름에 적용할 수정 사항을 설정합니다\n      inputs = {\"input\": query}\n\n      output = run_flow(inputs, flow_id=FLOW_ID, tweaks=TWEAKS)\n      print(output)\n      try:\n        output = output['result']['output']\n      except Exception :\n        output = f\"애플리케이션 오류 : {output}\"\n\n      placeholder = st.empty()\n      response = \"\"\n\n      for tokens in output:\n        response += tokens\n        # \"▌\"으로 스트리밍을 표시하여 응답을 작성합니다\n        with placeholder:\n          st.markdown(response + \"▌\")\n\n      # \"▌\" 없이 완료된 메시지를 표시합니다\n      with placeholder:\n        st.markdown(response)\n\n    # AI 응답을 채팅 기록에 기록합니다\n    st.session_state.messages.append((\"ai\", response))\n    # 채팅 입력 해제\n    st.session_state.disabled = False\n\n    st.rerun()\r\n```\n\n4. 인터페이스 만들기: 이제 동일한 Python 파일에서 다음 코드를 사용하여 간단한 Streamlit 사용자 인터페이스를 만들어보겠습니다.\n\n```js\r\nst.set_page_config(page_title=\"Dinnerly\")\nst.title(\"Dinnerly에 오신 것을 환영합니다: 건강한 요리 플래너\")\n\nsystem_prompt = \"사용자에게 건강한 요리 레시피를 제안하고 제공하는 유용한 도우미입니다\"\nif \"messages\" not in st.session_state:\n    st.session_state.messages = [(\"system\", system_prompt)]\nif \"disabled\" not in st.session_state:\n    # AI가 응답 중일 때 사용자가 메시지를 보내지 못하도록하는 'disabled' 플래그\n    st.session_state.disabled = False\n\n\nwith st.chat_message(\"ai\"):\n  st.markdown(\n    f\"안녕하세요! 건강한 요리 플래너입니다. 건강하고 맛있는 요리를 준비하는 데 도움을 드리겠습니다!\"\n  )\n\n# 앱 재실행 시 기록된 채팅 메시지 표시\nfor role, message in st.session_state.messages:\n    if role == \"system\":\n        continue\n    with st.chat_message(role):\n        st.markdown(message)\n\ncurrent_chat_message = st.container()\nprompt = st.chat_input(\"질문을 여기에 입력하세요...\", disabled=st.session_state.disabled)\n\nif prompt:\n    chat(prompt)\r\n```\n\nStreamlit 앱을 실행하면 자체 요리 플래너와 채팅할 수 있습니다! 맛있고 건강한 요리를 만드는 데 도움이 됩니다.\r\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마크다운 형식으로 표 태그를 변경하십시오.\n\nTips:\n\n다른 플로우에 대해 동일한 코드와 인터페이스를 사용할 수 있습니다. FLOW_ID를 변경하여 새로운 플로우를 앱에 테스트 및 통합하세요.\n\n\u003cimg src=\"/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_8.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 마무리 생각\n\n이 글에서 우리는 스마트한 RAG 기반 챗봇을 만들었습니다. 우리는 코드를 작성할 필요 없이 LangFlow를 활용하여 RAG 파이프라인을 설정했고, 임베딩 및 LLM 처리를 위해 오픈 소스 모델을 활용하여 응용 프로그램을 로컬에서 실행하고 추론 비용 없이 유지했습니다. 마지막으로,이 설정을 Streamlit 애플리케이션으로 변환했습니다.\n\n특히 LangFlow의 노코드 방식을 감사히 여기고, AI 응용 프로그램을 구축하고 프로토타입화하는 방식을 바꿀 수 있다고 믿습니다.\n\n그러나 아직 개발 중인 구성 요소가 있으며 때로는 예상대로 작동하지 않을 수 있음을 언급할 가치가 있습니다. 이러한 순간이 발생할 때 문제에 대한 가시성이나 문제 해결에 대한 안내가 부족할 수 있습니다. 또 다른 개선 사항으로는 Python 코드를 직접 제공하여 더 많은 사용자 정의를 제공하는 것이 있을 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLangFlow은 빠른 프로토타이핑 필요에 유용한 도구라고 생각해요.\n\n## 떠나시기 전에! 🦸🏻‍♀️\n\n만약 제 이야기가 마음에 드셨고 저를 지원하고 싶으시다면:\n\n- 약간의 Medium 사랑을 보내주세요 💕(박수, 댓글 및 하이라이트), 여러분의 지원은 저에게 큰 힘이 됩니다.👏\n- Medium에서 저를 팔로우하고 최신 기사를 받아보세요🫶\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 참고\n\n- LangFlow 문서\n- Ollama 문서\n- Deliciously Healthy Dinners (데모에서 사용된 pdf 파일): [링크](https://healthyeating.nhlbi.nih.gov/pdfs/dinners_cookbook_508-compliant.pdf)","ogImage":{"url":"/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_0.png"},"coverImage":"/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_0.png","tag":["Tech"],"readingTime":11},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e⁤스마트 챗봇을 만드는 데 수개월의 코딩이 필요했던 시절을 기억하나요?\u003c/p\u003e\n\u003cp\u003eLangChain과 같은 프레임워크는 개발을 간소화했지만, 수백 줄의 코드는 프로그래머가 아닌 사람들에게 여전히 장벽일 수 있습니다. ⁤\u003c/p\u003e\n\u003cp\u003e더 간단한 방법은 없을까요? (풀 스토리를 읽기 위해 친구 링크를 찾으려면 이미 Medium 회원이 아닌 경우 Medium 회원 가입을 고려해 주세요)\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_0.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그때 \"Lang Flow\"를 발견했어요. 이 오픈 소스 패키지는 Python 버전의 LangChain을 기반으로 구축되었습니다. 코드를 한 줄도 쓰지 않고 AI 애플리케이션을 만들 수 있게 해줘요. 챗봇을 만들기 위해 컴포넌트들을 끌어다가 캔버스에서 연결하기만 하면 돼요.\u003c/p\u003e\n\u003cp\u003e이 게시물에서는 LangFlow를 사용해서 몇 분 안에 스마트 AI 챗봇 프로토타입을 만들 거에요. 백엔드로는 Ollama를 사용하여 임베딩 모델과 대형 언어 모델을 사용할 거에요. 이렇게 하면 응용프로그램을 로컬에서 무료로 실행할 수 있어요! 마지막으로 이 흐름을 최소한의 코딩으로 Streamlit 애플리케이션으로 변환할 거에요.\u003c/p\u003e\n\u003ch1\u003eRAG Pipeline, LangChain, LangFlow, Ollama 소개\u003c/h1\u003e\n\u003cp\u003e이 프로젝트에서는 AI 챗봇을 만들어보려고 해요. \"Dinnerly - 당신의 건강한 요리 플래너\" 라고 이름 붙여보죠. 이 챗봇은 건강한 요리 레시피를 추천하는 것을 목표로 합니다. 이를 위해 RAG(Retrieval Augmented Generation)를 사용하여 레시피 PDF 파일에서 추출할 거에요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e어떻게 이를 실현할 것인지에 대해 들어가기 전에 프로젝트에서 사용할 핵심 재료를 빠르게 살펴보겠습니다.\u003c/p\u003e\n\u003ch2\u003e검색 증강 생성 (RAG)\u003c/h2\u003e\n\u003cp\u003eRAG(검색 증강 생성)은 대형 언어 모델 (LLMs)이 외부 소스에서 관련 정보를 제공받아 돕는 기술입니다. 이를 통해 LLM은 응답을 생성할 때 이 문맥을 고려하여 보다 정확하고 최신의 결과를 만들어냅니다.\u003c/p\u003e\n\u003cp\u003eRAG 파이프라인에는 일반적으로 '검색 증강 생성 안내서'에 설명된대로 다음 단계가 포함됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e“\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e문서 로드: 문서 또는 데이터 원본을 먼저로드하십시오.\u003c/li\u003e\n\u003cli\u003e청크로 분할: 문서를 관리하기 쉬운 부분으로 나누십시오.\u003c/li\u003e\n\u003cli\u003e임베딩 생성: 임베딩을 사용하여 이러한 청크를 벡터 표현으로 변환하십시오.\u003c/li\u003e\n\u003cli\u003e벡터 데이터베이스에 저장: 이러한 벡터를 데이터베이스에 저장하여 효율적으로 검색하십시오.\u003c/li\u003e\n\u003cli\u003e사용자 상호 작용: 사용자로부터 쿼리 또는 입력을받고 그것을 임베딩으로 변환하십시오.\u003c/li\u003e\n\u003cli\u003e벡터 데이터베이스에서 의미 검색: 사용자 쿼리를 기반으로 의미 검색을 수행하기 위해 벡터 데이터베이스에 연결하십시오.\u003c/li\u003e\n\u003cli\u003e응답 검색 및 처리: 관련 응답을 가져와 LLM을 통과시키고 답변을 생성하십시오.\u003c/li\u003e\n\u003cli\u003e사용자에게 답변 전달: LLM에 의해 생성된 최종 출력물을 사용자에게 제공하십시오.\n”\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eLangchain\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eLLMs을 중심으로 만들어진 오픈 소스 프레임워크인 LangChain은 챗봇, 요약 등 다양한 GenAI 응용 프로그램의 설계와 개발을 용이하게 합니다.\u003c/p\u003e\n\u003cp\u003e이 라이브러리의 핵심 아이디어는 다른 구성 요소를 \"체인\"으로 연결하여 복잡한 AI 작업을 단순화하고 LLMs 주변에서 더 많은 고급 사용 사례를 만드는 것입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch2\u003eLangFlow\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eLangFlow은 LangChain을 위해 특별히 설계된 웹 도구입니다. 사용자가 코딩없이 LangChain 애플리케이션을 구축하고 테스트할 수 있는 사용자 인터페이스를 제공합니다. 간단히 구성 요소를 끌어다 놓기만 하면 됩니다.\u003c/p\u003e\n\u003cp\u003e하지만 LangFlow를 사용하려면 LangChain의 작동 방식과 다양한 구성 요소에 대한 기본적인 이해가 필요합니다. 그러면 AI 애플리케이션의 흐름을 설계하는 데 LangFlow를 사용할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eOllama\u003c/p\u003e\n\u003cp\u003eOllama은 오픈 소스 LLM을 사용하기 위한 최고이자 가장 쉬운 방법입니다. Llama 2 및 Mistral과 같은 가장 강력한 LLM을 지원하며, ollama.ai/library에서 사용 가능한 모델 목록을 찾을 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_2.png\" alt=\"Ollama setup\"\u003e\u003c/p\u003e\n\u003ch1\u003eOllama 설정하기\u003c/h1\u003e\n\u003ch2\u003eOllama 설치\u003c/h2\u003e\n\u003cp\u003e먼저 Ollama 다운로드 페이지로 이동하여 사용 중인 운영 체제와 일치하는 버전을 선택한 후 다운로드하고 설치하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eOllama를 설치한 후에 명령 터미널을 열고 다음 명령을 입력하세요. 이 명령들은 모델을 다운로드하고 로컬 머신에서 실행할 것입니다.\u003c/p\u003e\n\u003cp\u003e이 프로젝트에서는 우리가 Large Language Model (LLM)으로 Llama2를 사용하고, 임베딩 모델로 \"nomic-embed-text\"를 사용할 것입니다. \"Nomic-embed-text\"는 큰 컨텍스트 윈도우를 가진 강력한 오픈 소스 임베딩 모델입니다. 이를 통해 전체 애플리케이션을 클라우드 서비스 없이 로컬에서 실행할 수 있습니다!\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eollama serve\nollama pull llama2\nollama pull nomic-embed-text\nollama run llama2\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eLangFlow 설정하기\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e준비 사항\u003c/h2\u003e\n\u003cp\u003eLangFlow을 시작하기 전에 컴퓨터에 Python이 설치되어 있는지 확인하는 것이 중요합니다. Python 버전은 3.9보다 높아야 하지만 3.12보다 낮아야 합니다.\u003c/p\u003e\n\u003cp\u003eLangFlow 설치\u003c/p\u003e\n\u003cp\u003e이제 LangFlow를 설치해 봅시다. 가상 환경 내에서 설치하는 것을 권장합니다. 이 방법을 사용하면 종속성을 깔끔하게 자체 공간 내에서 관리할 수 있습니다. 저는 Mac에서 Conda를 사용하여 설정합니다. 명령 줄 터미널에 다음 명령을 입력하여 \"langflow\"라는 가상 환경을 만들고 Python 3.11을 설정하세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003econda create -n langflow python=\u003cspan class=\"hljs-number\"\u003e3.11\u003c/span\u003e\nconda activate langflow\npip install langflow\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e콘다를 사용하지 않는 경우에도 다음 명령어를 사용하여 Python으로 직접 가상 환경을 설정할 수 있어요.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epython -m venv langflow\nsource langflow/bin/activate\npip install langflow\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e설치를 마치면 LangFlow를 시작하는 것은 매우 간단합니다. 터미널에 \"langflow run\"을 입력하기만 하면 돼요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_3.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e그런 다음, 제공된 URL을 복사하세요 (위의 예에서는 \u003ca href=\"http://127.0.0.1:7860\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://127.0.0.1:7860\u003c/a\u003e), 웹 브라우저에 붙여넣기하고, 와! 이런 식으로 보이는 인터페이스를 볼 수 있어야 합니다. 이 페이지에는 모든 프로젝트가 표시됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_4.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003ch1\u003e챗봇 플로우 디자인하기\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e첫 번째 플로우를 만드는 시간이군요!\u003c/p\u003e\n\u003cp\u003e\"새 프로젝트\"를 클릭하여 빈 캔버스를 열어보세요. 왼쪽 창에는 드래그하여 작업 영역에 놓을 수 있는 다양한 구성 요소가 준비되어 있습니다.\u003c/p\u003e\n\u003cp\u003e우리 프로젝트를 위해 PDF 파일에서 질문에 답변할 수 있는 챗봇을 만들고 있습니다. 이전에 언급한 RAG 파이프라인을 기억하시나요? 이를 구성할 때 필요한 몇 가지 요소가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePDF 로더: 여기서 \"PyPDFLoader\"를 사용할 것입니다. PDF 문서의 파일 경로를 입력해야 합니다.\u003c/li\u003e\n\u003cli\u003e텍스트 분할기: \"RecursiveCharacterTextSplitter\"를 선택하고 기본 설정을 사용하시면 됩니다.\u003c/li\u003e\n\u003cli\u003e텍스트 임베딩 모델: 무료 오픈소스 임베딩을 사용하려면 \"OllamaEmbeddings\"를 선택하세요.\u003c/li\u003e\n\u003cli\u003e벡터 데이터베이스: 임베딩을 저장하고 벡터 검색을 용이하게 하기 위해 \"FAISS\"를 선택합니다.\u003c/li\u003e\n\u003cli\u003e응답 생성을 위한 LLM: \"ChatOllama\"를 선택하고 모델을 \"llama2\"로 지정하세요.\u003c/li\u003e\n\u003cli\u003e대화 기억: 챗봇이 채팅 기록을 유지하도록 하는 기능으로 \"ConversationBufferMemory\"를 사용할 것입니다.\u003c/li\u003e\n\u003cli\u003e대화 검색 체인: LLM, 메모리, 검색된 텍스트 등과 같은 다양한 구성 요소를 연결하여 응답을 생성하는 기능입니다. \"ConversationRetrievalChain\"이 우리의 선택입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e캔버스로 모든 구성 요소를 끌어다 놓고 PDF 파일 경로 및 LLM 모델 이름과 같은 필수 필드를 설정하세요. 나머지 설정은 기본값으로 두어도 괜찮습니다.\u003c/p\u003e\n\u003cp\u003e그 다음, 이러한 구성 요소를 연결하여 흐름을 만들어보세요.\u003c/p\u003e\n\u003cp\u003e모든 것이 연결되었다면, 우측 하단에 있는 \"번개\" 버튼을 눌러 흐름을 컴파일하세요. 모든 것이 순조롭게 진행된다면 버튼이 녹색으로 바뀌어 성공을 알리게 됩니다.\u003c/p\u003e\n\u003cp\u003e흐름을 성공적으로 컴파일한 후, \"챗봇\" 아이콘을 클릭하여 생성물을 테스트해보세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_5.png\"\u003e\n\u003cp\u003e여러 가지 팁:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e플로우를 완료하면 JSON 파일로 저장하거나 나중에 액세스하거나 편집할 수 있도록 \"내 컬렉션\"에서 찾을 수 있습니다.\u003c/li\u003e\n\u003cli\u003e사전 빌트 예제로 LangFlow에 뛰어들면 훌륭한 영감을 얻고 시작하는 데 도움이 될 수 있습니다. 여기에 팁이 있습니다:\u003c/li\u003e\n\u003cli\u003e\"LangFlow Store\"는 예제를 보유하고 있지만 액세스를 위해 API 키가 필요합니다.\u003c/li\u003e\n\u003cli\u003eLangFlow GitHub 페이지를 통해 예제를 다운로드하여 \"업로드\" 버튼을 사용하여 LangFlow UI로 업로드할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e로컬로 설정하는 것이 꺼려지면, OpenAI를 선택하여 RAG 파이프라인을 구축할 수도 있습니다. 설정을 위해 OpenAI API 키를 가지고 있는지 확인하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e플로우를 스트림릿 챗봇으로 변환하기\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 플로우가 완벽하게 설정되었다면, 애플리케이션에 통합할 시간입니다. 플로우를 구축한 후에는 LangFlow가 필요한 코드 조각을 제공하여 쉽게 만들어줍니다. 사이드바에서 \"코드\" 버튼을 누르기만 하면 됩니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_6.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e이제 이 플로우를 Streamlit 챗봇에 통합해 보겠습니다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e종속성 설정: 시작하기 전에 종속성을 설치해야 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epip install streamlit\npip install langflow\npip install langchain-community \n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003eLang Flow 코드 스니펫 가져오기: \"app.py\"라는 새로운 Python 파일을 만듭니다. LangFlow UI로 돌아가 \"Code\" 버튼을 다시 찾습니다. \"Python API\" 탭으로 이동하여 코드 스니펫을 복사하고 \"app.py\"에 붙여넣습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e requests\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e typing \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOptional\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable constant_\"\u003eBASE_API_URL\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"http://127.0.0.1:7860/api/v1/process\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eFLOW_ID\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\"d9392262-a912-42b4-8582-cc9e48894a00\"\u003c/span\u003e\n\n# 원하는대로 플로우를 조정할 수 있습니다.\n# 예시: {\u003cspan class=\"hljs-string\"\u003e\"OpenAI-XXXXX\"\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e\"model_name\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"gpt-4\"\u003c/span\u003e}\n\u003cspan class=\"hljs-variable constant_\"\u003eTWEAKS\u003c/span\u003e = {\n  \u003cspan class=\"hljs-string\"\u003e\"VectorStoreAgent-brRPx\"\u003c/span\u003e: {},\n  \u003cspan class=\"hljs-string\"\u003e\"VectorStoreInfo-BS24v\"\u003c/span\u003e: {},\n  \u003cspan class=\"hljs-string\"\u003e\"OpenAIEmbeddings-lnfRZ\"\u003c/span\u003e: {},\n  \u003cspan class=\"hljs-string\"\u003e\"RecursiveCharacterTextSplitter-bErPe\"\u003c/span\u003e: {},\n  \u003cspan class=\"hljs-string\"\u003e\"WebBaseLoader-HLOqm\"\u003c/span\u003e: {},\n  \u003cspan class=\"hljs-string\"\u003e\"ChatOpenAI-aQOv0\"\u003c/span\u003e: {},\n  \u003cspan class=\"hljs-string\"\u003e\"FAISS-o0WIf\"\u003c/span\u003e: {}\n}\n\ndef \u003cspan class=\"hljs-title function_\"\u003erun_flow\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003einputs\u003c/span\u003e: dict, \u003cspan class=\"hljs-attr\"\u003eflow_id\u003c/span\u003e: str, \u003cspan class=\"hljs-attr\"\u003etweaks\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eOptional\u003c/span\u003e[dict] = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e) -\u003e \u003cspan class=\"hljs-attr\"\u003edict\u003c/span\u003e:\n    \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\n    주어진 메시지와 선택적 조정으로 플로우를 실행합니다.\n\n    :param message: 플로우에 보낼 메시지\n    :param flow_id: 실행할 플로우의 ID\n    :param tweaks: 플로우를 사용자 정의하는 선택적 조정\n    :return: 플로우의 JSON 응답\n    \"\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n    api_url = f\u003cspan class=\"hljs-string\"\u003e\"{BASE_API_URL}/{flow_id}\"\u003c/span\u003e\n\n    payload = {\u003cspan class=\"hljs-string\"\u003e\"inputs\"\u003c/span\u003e: inputs}\n    headers = \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etweaks\u003c/span\u003e:\n        payload[\u003cspan class=\"hljs-string\"\u003e\"tweaks\"\u003c/span\u003e] = tweaks\n    response = requests.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(api_url, json=payload, headers=headers)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response.\u003cspan class=\"hljs-title function_\"\u003ejson\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e채팅 기능 구현: 같은 Python 파일에서 사용자의 새로운 쿼리마다 응답을 가져오기 위해 플로우를 실행하는 함수를 정의합니다. 그런 다음 이 응답을 인터페이스에 스트리밍합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003echat\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eprompt\u003c/span\u003e: str):\n  \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecurrent_chat_message\u003c/span\u003e:\n    # \u003cspan class=\"hljs-variable constant_\"\u003eAI\u003c/span\u003e가 응답할 때 메시지를 보내지 못하도록 입력을 차단합니다\n    st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edisabled\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n\n    # 사용자 메시지를 채팅 기록에 추가합니다\n    st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessages\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e((\u003cspan class=\"hljs-string\"\u003e\"human\"\u003c/span\u003e, prompt))\n\n    # 채팅 메시지 컨테이너에 사용자 메시지를 표시합니다\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e st.\u003cspan class=\"hljs-title function_\"\u003echat_message\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"human\"\u003c/span\u003e):\n      st.\u003cspan class=\"hljs-title function_\"\u003emarkdown\u003c/span\u003e(prompt)\n\n    # 채팅 메시지 컨테이너에 어시스턴트 응답을 표시합니다\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e st.\u003cspan class=\"hljs-title function_\"\u003echat_message\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ai\"\u003c/span\u003e):\n      # 최신 질문을 마지막 메시지로 포함한 전체 채팅 기록을 가져옵니다\n      history = \u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\n        [f\u003cspan class=\"hljs-string\"\u003e\"{role}: {msg}\"\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e role, msg \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessages\u003c/span\u003e]\n      )\n\n      query = f\u003cspan class=\"hljs-string\"\u003e\"{history}\\nAI:\"\u003c/span\u003e\n\n      # 흐름에 적용할 수정 사항을 설정합니다\n      inputs = {\u003cspan class=\"hljs-string\"\u003e\"input\"\u003c/span\u003e: query}\n\n      output = \u003cspan class=\"hljs-title function_\"\u003erun_flow\u003c/span\u003e(inputs, flow_id=\u003cspan class=\"hljs-variable constant_\"\u003eFLOW_ID\u003c/span\u003e, tweaks=\u003cspan class=\"hljs-variable constant_\"\u003eTWEAKS\u003c/span\u003e)\n      \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(output)\n      \u003cspan class=\"hljs-attr\"\u003etry\u003c/span\u003e:\n        output = output[\u003cspan class=\"hljs-string\"\u003e'result'\u003c/span\u003e][\u003cspan class=\"hljs-string\"\u003e'output'\u003c/span\u003e]\n      except \u003cspan class=\"hljs-title class_\"\u003eException\u003c/span\u003e :\n        output = f\u003cspan class=\"hljs-string\"\u003e\"애플리케이션 오류 : {output}\"\u003c/span\u003e\n\n      placeholder = st.\u003cspan class=\"hljs-title function_\"\u003eempty\u003c/span\u003e()\n      response = \u003cspan class=\"hljs-string\"\u003e\"\"\u003c/span\u003e\n\n      \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e tokens \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eoutput\u003c/span\u003e:\n        response += tokens\n        # \u003cspan class=\"hljs-string\"\u003e\"▌\"\u003c/span\u003e으로 스트리밍을 표시하여 응답을 작성합니다\n        \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eplaceholder\u003c/span\u003e:\n          st.\u003cspan class=\"hljs-title function_\"\u003emarkdown\u003c/span\u003e(response + \u003cspan class=\"hljs-string\"\u003e\"▌\"\u003c/span\u003e)\n\n      # \u003cspan class=\"hljs-string\"\u003e\"▌\"\u003c/span\u003e 없이 완료된 메시지를 표시합니다\n      \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eplaceholder\u003c/span\u003e:\n        st.\u003cspan class=\"hljs-title function_\"\u003emarkdown\u003c/span\u003e(response)\n\n    # \u003cspan class=\"hljs-variable constant_\"\u003eAI\u003c/span\u003e 응답을 채팅 기록에 기록합니다\n    st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessages\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e((\u003cspan class=\"hljs-string\"\u003e\"ai\"\u003c/span\u003e, response))\n    # 채팅 입력 해제\n    st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edisabled\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n\n    st.\u003cspan class=\"hljs-title function_\"\u003ererun\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"4\"\u003e\n\u003cli\u003e인터페이스 만들기: 이제 동일한 Python 파일에서 다음 코드를 사용하여 간단한 Streamlit 사용자 인터페이스를 만들어보겠습니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003est.\u003cspan class=\"hljs-title function_\"\u003eset_page_config\u003c/span\u003e(page_title=\u003cspan class=\"hljs-string\"\u003e\"Dinnerly\"\u003c/span\u003e)\nst.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Dinnerly에 오신 것을 환영합니다: 건강한 요리 플래너\"\u003c/span\u003e)\n\nsystem_prompt = \u003cspan class=\"hljs-string\"\u003e\"사용자에게 건강한 요리 레시피를 제안하고 제공하는 유용한 도우미입니다\"\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"messages\"\u003c/span\u003e not \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e:\n    st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessages\u003c/span\u003e = [(\u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, system_prompt)]\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"disabled\"\u003c/span\u003e not \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e:\n    # \u003cspan class=\"hljs-variable constant_\"\u003eAI\u003c/span\u003e가 응답 중일 때 사용자가 메시지를 보내지 못하도록하는 \u003cspan class=\"hljs-string\"\u003e'disabled'\u003c/span\u003e 플래그\n    st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edisabled\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n\n\n\u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e st.\u003cspan class=\"hljs-title function_\"\u003echat_message\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ai\"\u003c/span\u003e):\n  st.\u003cspan class=\"hljs-title function_\"\u003emarkdown\u003c/span\u003e(\n    f\u003cspan class=\"hljs-string\"\u003e\"안녕하세요! 건강한 요리 플래너입니다. 건강하고 맛있는 요리를 준비하는 데 도움을 드리겠습니다!\"\u003c/span\u003e\n  )\n\n# 앱 재실행 시 기록된 채팅 메시지 표시\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e role, message \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emessages\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e role == \u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e:\n        \u003cspan class=\"hljs-keyword\"\u003econtinue\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e st.\u003cspan class=\"hljs-title function_\"\u003echat_message\u003c/span\u003e(role):\n        st.\u003cspan class=\"hljs-title function_\"\u003emarkdown\u003c/span\u003e(message)\n\ncurrent_chat_message = st.\u003cspan class=\"hljs-title function_\"\u003econtainer\u003c/span\u003e()\nprompt = st.\u003cspan class=\"hljs-title function_\"\u003echat_input\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"질문을 여기에 입력하세요...\"\u003c/span\u003e, disabled=st.\u003cspan class=\"hljs-property\"\u003esession_state\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edisabled\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eprompt\u003c/span\u003e:\n    \u003cspan class=\"hljs-title function_\"\u003echat\u003c/span\u003e(prompt)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eStreamlit 앱을 실행하면 자체 요리 플래너와 채팅할 수 있습니다! 맛있고 건강한 요리를 만드는 데 도움이 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e마크다운 형식으로 표 태그를 변경하십시오.\u003c/p\u003e\n\u003cp\u003eTips:\u003c/p\u003e\n\u003cp\u003e다른 플로우에 대해 동일한 코드와 인터페이스를 사용할 수 있습니다. FLOW_ID를 변경하여 새로운 플로우를 앱에 테스트 및 통합하세요.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama_8.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e마무리 생각\u003c/h1\u003e\n\u003cp\u003e이 글에서 우리는 스마트한 RAG 기반 챗봇을 만들었습니다. 우리는 코드를 작성할 필요 없이 LangFlow를 활용하여 RAG 파이프라인을 설정했고, 임베딩 및 LLM 처리를 위해 오픈 소스 모델을 활용하여 응용 프로그램을 로컬에서 실행하고 추론 비용 없이 유지했습니다. 마지막으로,이 설정을 Streamlit 애플리케이션으로 변환했습니다.\u003c/p\u003e\n\u003cp\u003e특히 LangFlow의 노코드 방식을 감사히 여기고, AI 응용 프로그램을 구축하고 프로토타입화하는 방식을 바꿀 수 있다고 믿습니다.\u003c/p\u003e\n\u003cp\u003e그러나 아직 개발 중인 구성 요소가 있으며 때로는 예상대로 작동하지 않을 수 있음을 언급할 가치가 있습니다. 이러한 순간이 발생할 때 문제에 대한 가시성이나 문제 해결에 대한 안내가 부족할 수 있습니다. 또 다른 개선 사항으로는 Python 코드를 직접 제공하여 더 많은 사용자 정의를 제공하는 것이 있을 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eLangFlow은 빠른 프로토타이핑 필요에 유용한 도구라고 생각해요.\u003c/p\u003e\n\u003ch2\u003e떠나시기 전에! 🦸🏻‍♀️\u003c/h2\u003e\n\u003cp\u003e만약 제 이야기가 마음에 드셨고 저를 지원하고 싶으시다면:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e약간의 Medium 사랑을 보내주세요 💕(박수, 댓글 및 하이라이트), 여러분의 지원은 저에게 큰 힘이 됩니다.👏\u003c/li\u003e\n\u003cli\u003eMedium에서 저를 팔로우하고 최신 기사를 받아보세요🫶\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e참고\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eLangFlow 문서\u003c/li\u003e\n\u003cli\u003eOllama 문서\u003c/li\u003e\n\u003cli\u003eDeliciously Healthy Dinners (데모에서 사용된 pdf 파일): \u003ca href=\"https://healthyeating.nhlbi.nih.gov/pdfs/dinners_cookbook_508-compliant.pdf\" rel=\"nofollow\" target=\"_blank\"\u003e링크\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-BuildingLocalRAGChatbotsWithoutCodingUsingLangFlowandOllama"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>