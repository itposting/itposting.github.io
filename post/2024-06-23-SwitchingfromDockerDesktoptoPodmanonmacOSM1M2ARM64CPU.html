<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>macOS M1 M2 ARM64 CPU에서 Docker Desktop을 Podman으로 바꾸는 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="macOS M1 M2 ARM64 CPU에서 Docker Desktop을 Podman으로 바꾸는 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="macOS M1 M2 ARM64 CPU에서 Docker Desktop을 Podman으로 바꾸는 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU" data-gatsby-head="true"/><meta name="twitter:title" content="macOS M1 M2 ARM64 CPU에서 Docker Desktop을 Podman으로 바꾸는 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 15:31" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">macOS M1 M2 ARM64 CPU에서 Docker Desktop을 Podman으로 바꾸는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="macOS M1 M2 ARM64 CPU에서 Docker Desktop을 Podman으로 바꾸는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">23<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>친절한 쿠버네티스 클러스터와 함께</h2>
<p><img src="/assets/img/2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU_0.png" alt="이미지"></p>
<h1>배경</h1>
<p>이전 글에서는 macOS에서 이전 AMD64 아키텍처 기반 머신에 Minikube와 Hyperkit을 사용하여 Docker Desktop을 대체하는 방법에 대해 논의했습니다. 그러나 ARM64 아키텍처 CPU를 사용하는 새로운 M1/M2 머신이 등장하면서 Hyperkit은 이러한 새로운 머신과 호환되지 않습니다. 이 문제를 해결하기 위해 macOS M1/M2 머신에서 Docker Desktop을 Podman으로 대체하고 Kind를 사용하여 쿠버네티스 로컬 클러스터를 생성했습니다.</p>
<div class="content-ad"></div>
<h1>macOS M1/M2 ARM64 아키텍처</h1>
<p>macOS M1/M2는 최신 Apple 맥인토시 컴퓨터 라인으로, ARM64 아키텍처를 기반으로 합니다. ARM64 아키텍처는 컴퓨팅 세계에서 점차 인기를 끌고 있는 새로운 유형의 프로세서 아키텍처입니다. 대부분의 데스크톱 및 랩톱 컴퓨터에서 사용되는 전통적인 x86 아키텍처와 비교하면, ARM64 아키텍처는 저전력을 위해 설계되었으며 모바일 기기용으로 최적화되어 있습니다.</p>
<p>ARM64 아키텍처의 주요 장점 중 하나는 와트 당 성능 향상입니다. 이는 ARM64 아키텍처를 기반으로 한 컴퓨터가 더 적은 전력을 사용하면서도 유사하거나 더 나은 성능을 제공할 수 있음을 의미합니다. 이는 노트북의 배터리 수명 연장 및 데스크탑의 에너지 소비 감소로 이어질 수 있습니다. 또한, ARM64 아키텍처는 머신러닝과 같은 특정 작업을 위한 하드웨어 가속화와 같은 기능을 포함하고 있어, 이러한 작업 부하의 성능을 향상시킬 수 있습니다.</p>
<p>AMD64/x86 인텔 아키텍처와 비교하면, ARM64 아키텍처는 더 새롭고 확립되지 않은 아키텍처입니다. AMD64/x86은 많은 해 동안 주도적인 아키텍처이지만, ARM64는 특히 모바일 기기와 서버에서 더 많은 인기를 얻고 있습니다. 그러나 ARM64 아키텍처에 대한 더 많은 응용 프로그램과 소프트웨어의 최적화가 이루어지면, 앞으로 더 많은 ARM64 기반 컴퓨터를 볼 수 있을 것입니다. 성능 측면에서, ARM64 아키텍처는 특정 작업 부하에 대해 AMD64/x86 아키텍처와 비교 가능하거나 더 빠를 수 있지만, 이는 구체적인 사용 사례 및 소프트웨어 최적화에 따라 다를 수 있습니다. 최종적으로 두 아키텍처 모두 강점과 약점을 가지고 있으며, 그것들 사이의 선택은 사용자나 조직의 구체적인 요구 사항에 달려 있습니다.</p>
<div class="content-ad"></div>
<p>맥OS M1/M2 기기는 ARM64 아키텍처에서 실행되도록 특별히 설계되었으며, 이 아키텍처에 최적화된 소프트웨어와 도구가 필요하여 효율적으로 실행할 수 있습니다. x86 아키텍처에서 실행되도록 설계된 일부 소프트웨어는 macOS M1/M2 기기에서 제대로 작동하지 않을 수 있으므로, 개발자와 사용자는 호환성과 최적 성능을 보장하기 위해 ARM64 아키텍처용 도구와 소프트웨어를 사용해야 합니다.</p>
<h1>Docker Desktop</h1>
<p>macOS에서 Docker Desktop은 Docker 컨테이너를 사용하여 애플리케이션을 쉽게 빌드, 테스트 및 배포할 수 있도록 합니다. 컨테이너, 이미지 및 네트워크를 관리하기 위한 간단하고 사용자 친화적인 인터페이스를 제공하며, 다양한 플랫폼 및 운영 체제에서 사용할 수 있습니다. ARM64 아키텍처 기반의 최신 macOS M1/M2 기기가 출시된 가운데, Docker는 ARM64 아키텍처에 최적화된 새로운 Docker Desktop 버전을 출시했습니다. 이 버전은 Apple의 Hypervisor.framework를 활용하여 가상화 환경에서 컨테이너를 실행하며, 이를 통해 Docker Desktop을 사용하는 개발자와 IT 전문가에게 매끄러운 경험을 제공합니다.</p>
<p>Docker Desktop은 컨테이너화에 강력한 도구를 제공하지만, 단점도 있습니다. Docker Desktop 사용의 주요 단점 중 하나는 백그라운드에서 실행되는 별도의 데몬 프로세스를 필요로 한다는 점인데, 이는 상당한 시스템 리소스를 소비할 수 있습니다. 또한, Docker Desktop은 일부 애플리케이션 및 운영 체제와 가끔 호환성 문제가 있어 사용자들에게 다운타임과 귀찮음을 초래할 수 있습니다. 게다가, 최근 Docker Desktop의 라이선스 요구사항 변경으로 많은 사용자가 대안을 찾고 있습니다. 결과적으로, Podman과 같은 대체 솔루션들이 이 기기에서 컨테이너화 요구를 충족하는 데 더 인기를 얻고 있습니다.</p>
<div class="content-ad"></div>
<h1>Podman</h1>
<p>Podman은 빌드, 관리 및 실행을 위한 Docker의 대체제로 제공되는 인기 있는 컨테이너 관리 도구입니다. ARM64 아키텍처 기반의 새로운 macOS M1/M2 기계가 출시되면서, Podman은 컨테이너화 요구 사항에 대한 Docker Desktop의 대안으로 나타나고 있습니다.</p>
<p>Podman은 ARM64 아키텍처에 최적화되어 개발자와 IT 전문가들에게 뛰어난 경험을 제공합니다. Docker와 달리, Podman은 Linux 커널의 컨테이너화 기능을 사용하므로 별도의 백그라운드 데몬 프로세스가 실행되어야 하는 필요가 없습니다. 이는 성능 향상과 리소스 소비의 감소로 이어질 수 있습니다.</p>
<p>macOS M1/M2 기계에서 Podman을 사용하는 주요 이점 중 하나는 가상 머신을 사용하지 않아도 된다는 점입니다. 대신, Podman은 ARM64 아키텍처의 네이티브 컨테이너화 기능을 활용하여 더 효율적이고 간소화된 경험을 제공합니다. Podman은 ARM64 아키텍처를 기반으로 하는 macOS M1/M2 기계에서 Docker Desktop에 대한 유망한 대안입니다. 최적화된 성능과 간소화된 컨테이너화 기능을 갖춘 Podman은 이러한 기계에서 컨테이너를 빌드, 관리 및 실행해야 하는 개발자와 IT 전문가들에게 강력한 도구를 제공합니다.</p>
<div class="content-ad"></div>
<p>새로운 macOS M1/M2 기기에서 ARM64 아키텍처를 사용하는 Podman을 설정하는 가이드입니다. 이를 통해 더 가벼우면서도 효율적인 컨테이너화 도구로 Docker 및 Docker Desktop을 대체할 수 있습니다.</p>
<h2>1. Podman 설치 및 구성</h2>
<p>macOS에는 Homebrew 패키지 관리자를 사용하여 Podman을 설치할 수 있습니다. 설치한 후, Podman을 루트 없는 컨테이너와 함께 사용할 수 있도록 구성할 수 있습니다. 이때 주의해야 할 점은 Linux 시스템과는 달리 macOS(그리고 Windows)에서는 Podman 사용 시 가상 머신을 사용해야 한다는 것입니다. 가상 머신은 QEMU 에뮬레이터를 사용하여 Linux 런타임 환경을 제공합니다. MacOS와 Windows는 Podman이 의존하는 Linux 네임스페이스 및 cgroups를 네이티브로 지원하지 않기 때문입니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-title class_">Podman</span> 설치
❯❯ brew install podman

# 새로운 <span class="hljs-title class_">Linux</span> 런타임 환경 초기화 (이를 <span class="hljs-string">'podman machine'</span>이라고 합니다)
# <span class="hljs-title class_">Podman</span>은 quem 에뮬레이터를 사용하여 <span class="hljs-title class_">Linux</span> 런타임 환경을 제공합니다
# --cpus <span class="hljs-number">4</span> (<span class="hljs-variable constant_">CPU</span> 코어 수 지정)
# --memory=<span class="hljs-number">6144</span> (메모리 용량 지정)
❯❯ podman machine init --cpus <span class="hljs-number">4</span> --memory=<span class="hljs-number">6144</span>

# <span class="hljs-title class_">Podman</span> 머신 목록 표시
# 기본 <span class="hljs-title class_">Podman</span> 머신은 <span class="hljs-string">`podman-machine-default*`</span>입니다
❯❯ podman machine ls
<span class="hljs-variable constant_">NAME</span>                     <span class="hljs-variable constant_">VM</span> <span class="hljs-variable constant_">TYPE</span>     <span class="hljs-variable constant_">CREATED</span>     <span class="hljs-variable constant_">LAST</span> <span class="hljs-variable constant_">UP</span>     <span class="hljs-variable constant_">CPUS</span>        <span class="hljs-variable constant_">MEMORY</span>      <span class="hljs-variable constant_">DISK</span> <span class="hljs-variable constant_">SIZE</span>
podman-machine-<span class="hljs-keyword">default</span>*  qemu        <span class="hljs-number">4</span> days ago  <span class="hljs-number">4</span> days ago  <span class="hljs-number">2</span>           <span class="hljs-number">2.</span>147GB     <span class="hljs-number">107.</span>4GB

# 런타임 시작
# <span class="hljs-title class_">Podman</span>은 /<span class="hljs-title class_">Users</span>, <span class="hljs-regexp">/private, /</span><span class="hljs-keyword">var</span>/folders 디렉터리에 볼륨 매핑을 사용합니다
❯❯ podman machine start
<span class="hljs-string">"podman-machine-default"</span> 머신 시작 중
<span class="hljs-variable constant_">VM</span> 대기 중...
볼륨 마운트... /<span class="hljs-title class_">Users</span>:/<span class="hljs-title class_">Users</span>
볼륨 마운트... /<span class="hljs-attr">private</span>:/private
볼륨 마운트... /<span class="hljs-keyword">var</span>/<span class="hljs-attr">folders</span>:<span class="hljs-regexp">/var/</span>folders

현재 이 머신은 루트 없는 모드로 구성되어 있습니다. 컨테이너에 루트 권한이 필요한 경우(예: 포트 &#x3C; <span class="hljs-number">1024</span>) 또는 비-<span class="hljs-title class_">Podman</span> 클라이언트와의 호환성 문제가 발생한 경우, 다음 명령을 사용하여 전환할 수 있습니다:

 podman machine set --rootful

<span class="hljs-variable constant_">API</span> 전달 <span class="hljs-title class_">Listening</span>: <span class="hljs-regexp">/Users/</span>lambda.<span class="hljs-property">eranga</span>/.<span class="hljs-property">local</span>/share/containers/podman/machine/podman-machine-<span class="hljs-keyword">default</span>/podman.<span class="hljs-property">sock</span>

시스템 도우미 서비스가 설치되어 있지 않습니다; podman에서는 기본 <span class="hljs-title class_">Docker</span> <span class="hljs-variable constant_">API</span> 소켓 주소를 사용할 수 없습니다. 설치하려면 다음 명령을 실행하세요:

 sudo /opt/homebrew/<span class="hljs-title class_">Cellar</span>/podman/<span class="hljs-number">4.4</span><span class="hljs-number">.2</span>/bin/podman-mac-helper install
 podman machine stop; podman machine start

터미널 세션에서 다음 몤령을 사용하여 여전히 <span class="hljs-title class_">Docker</span> <span class="hljs-variable constant_">API</span> 클라이언트에 연결할 수 있습니다:

 <span class="hljs-keyword">export</span> <span class="hljs-variable constant_">DOCKER_HOST</span>=<span class="hljs-string">'unix:///Users/lambda.eranga/.local/share/containers/podman/machine/podman-machine-default/podman.sock'</span>

<span class="hljs-string">"podman-machine-default"</span> 머신이 성공적으로 시작되었습니다
podman machine start

# <span class="hljs-title class_">Podman</span> 머신이 실행 중
❯❯ podman machine ls
<span class="hljs-variable constant_">NAME</span>                     <span class="hljs-variable constant_">VM</span> <span class="hljs-variable constant_">TYPE</span>     <span class="hljs-variable constant_">CREATED</span>     <span class="hljs-variable constant_">LAST</span> <span class="hljs-variable constant_">UP</span>            <span class="hljs-variable constant_">CPUS</span>        <span class="hljs-variable constant_">MEMORY</span>      <span class="hljs-variable constant_">DISK</span> <span class="hljs-variable constant_">SIZE</span>
podman-machine-<span class="hljs-keyword">default</span>*  qemu        <span class="hljs-number">4</span> days ago  <span class="hljs-title class_">Currently</span> running  <span class="hljs-number">2</span>           <span class="hljs-number">2.</span>147GB     <span class="hljs-number">107.</span>4GB

# 정보 확인
❯❯ podman info

# <span class="hljs-title class_">Podman</span> 연결
❯❯ podman system connection ls
<span class="hljs-title class_">Name</span>                         <span class="hljs-variable constant_">URI</span>                                                         <span class="hljs-title class_">Identity</span>                                          <span class="hljs-title class_">Default</span>
podman-machine-<span class="hljs-keyword">default</span>       <span class="hljs-attr">ssh</span>:<span class="hljs-comment">//core@localhost:50985/run/user/501/podman/podman.sock  /Users/lambda.eranga/.ssh/podman-machine-default  true</span>
podman-machine-<span class="hljs-keyword">default</span>-root  <span class="hljs-attr">ssh</span>:<span class="hljs-comment">//root@localhost:50985/run/podman/podman.sock           /Users/lambda.eranga/.ssh/podman-machine-default  false</span>

# 머신 정지
❯❯ podman machine stop

# 머신 재시작
❯❯ podman machine stop; podman machine start

# <span class="hljs-title class_">Podman</span> 머신에 <span class="hljs-variable constant_">SSH</span> 접속
❯❯ podman machine ssh

# 머신 제거
❯❯ podman machine rm -f podman-machine-<span class="hljs-keyword">default</span>
</code></pre>
<div class="content-ad"></div>
<h2>2. Podman Commands</h2>
<p>Podman은 Docker와 유사한 명령줄 인터페이스를 제공합니다. 사실, Podman에서 사용하는 많은 명령어는 Docker에서 사용하는 것과 동일하여 Docker에 익숙한 사용자가 Podman으로 쉽게 전환할 수 있습니다. Podman에서 다양한 명령어를 실행하려면 원하는 특정 명령어 뒤에 podman 명령어를 사용할 수 있습니다. 예를 들어, 모든 실행 중인 컨테이너를 나열하려면 podman ps 명령어를 사용할 수 있습니다. 마찬가지로 Dockerfile에서 이미지를 빌드하려면 podman build -t image_name -f Dockerfile_path와 같은 명령어를 사용할 수 있습니다. Podman은 컨테이너 시작 및 중지, 실행 중인 컨테이너에 연결 및 이미지 및 볼륨 관리와 같은 일반적인 컨테이너화 작업을 지원합니다.</p>
<pre><code class="hljs language-js"># 이미지 목록
❯❯ podman images
<span class="hljs-variable constant_">REPOSITORY</span>                           <span class="hljs-variable constant_">TAG</span>             <span class="hljs-variable constant_">IMAGE</span> <span class="hljs-variable constant_">ID</span>      <span class="hljs-variable constant_">CREATED</span>       <span class="hljs-variable constant_">SIZE</span>
docker.<span class="hljs-property">io</span>/hashicorp/envconsul        <span class="hljs-number">0.13</span><span class="hljs-number">.0</span>          42307d16e023  <span class="hljs-number">8</span> months ago  <span class="hljs-number">18.7</span> <span class="hljs-variable constant_">MB</span>
docker.<span class="hljs-property">io</span>/library/vault              &#x3C;none>          aac433bb6835  <span class="hljs-number">2</span> years ago   147MB

# <span class="hljs-title class_">PostgreSQL</span> 이미지 다운로드
❯❯ podman pull <span class="hljs-attr">postgres</span>:latest
...

# <span class="hljs-title class_">PostgreSQL</span> 실행
❯❯ podman run --name postgres -e <span class="hljs-variable constant_">POSTGRES_PASSWORD</span>=admin -p <span class="hljs-number">5432</span>:<span class="hljs-number">5432</span> -d postgres
6ee93adb00d1f1a468308b50a044002e2f7da116614ebb8d092d8236ae6542d6

# 실행 중인 컨테이너 목록
❯❯ podman ps
<span class="hljs-variable constant_">CONTAINER</span> <span class="hljs-variable constant_">ID</span>  <span class="hljs-variable constant_">IMAGE</span>                              <span class="hljs-variable constant_">COMMAND</span>     <span class="hljs-variable constant_">CREATED</span>        <span class="hljs-variable constant_">STATUS</span>        <span class="hljs-variable constant_">PORTS</span>                   <span class="hljs-variable constant_">NAMES</span>
6ee93adb00d1  docker.<span class="hljs-property">io</span>/library/<span class="hljs-attr">postgres</span>:latest  postgres    <span class="hljs-number">4</span> seconds ago  <span class="hljs-title class_">Up</span> <span class="hljs-number">4</span> seconds  <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">5432</span>-><span class="hljs-number">5432</span>/tcp  postgres

# 명령어 실행 시 디버그 로그 보기
❯❯ podman --log-level=debug ps
...

## <span class="hljs-number">3.</span> <span class="hljs-title class_">Create</span> <span class="hljs-title class_">Docker</span> <span class="hljs-title class_">Alias</span>
</code></pre>
<div class="content-ad"></div>
<p>Podman은 Docker와 매우 유사한 명령줄 인터페이스를 제공하여 Docker에서 Podman으로 쉽게 전환할 수 있습니다. 실제로 Podman과 Docker를 동일하게 사용할 수 있도록 Docker에 대한 별칭을 Podman으로 만들 수 있습니다. 예를 들어, 다음 Alias를 ~/.zshrc 파일에 추가하여 Podman의 docker alias를 만들 수 있습니다.</p>
<pre><code class="hljs language-js"># alias to docker, run podman commands <span class="hljs-keyword">as</span> docker
alias docker=podman
</code></pre>
<p>별칭을 설정한 후에는 docker 명령을 podman 명령처럼 사용할 수 있으며, docker 명령을 사용하여 Podman 명령을 실행할 수 있습니다. Docker에서 작업하는 데 익숙하고 새로운 명령어를 배우지 않고 Podman으로 전환하려는 경우 도움이 될 수 있습니다. 그러나 Docker와 Podman 사이에 동작에 차이가 있을 수 있으므로 docker alias를 Podman과 함께 사용할 때 작업 흐름을 충분히 테스트해야 합니다.</p>
<pre><code class="hljs language-js"># list images <span class="hljs-keyword">with</span> docker alias
❯❯ docker images
<span class="hljs-variable constant_">REPOSITORY</span>                           <span class="hljs-variable constant_">TAG</span>             <span class="hljs-variable constant_">IMAGE</span> <span class="hljs-variable constant_">ID</span>      <span class="hljs-variable constant_">CREATED</span>       <span class="hljs-variable constant_">SIZE</span>
docker.<span class="hljs-property">io</span>/library/postgres           latest          61d0571c2f7b  <span class="hljs-number">2</span> weeks ago   <span class="hljs-number">368</span> <span class="hljs-variable constant_">MB</span>
docker.<span class="hljs-property">io</span>/hashicorp/envconsul        <span class="hljs-number">0.13</span><span class="hljs-number">.0</span>          42307d16e023  <span class="hljs-number">8</span> months ago  <span class="hljs-number">18.7</span> <span class="hljs-variable constant_">MB</span>
docker.<span class="hljs-property">io</span>/library/vault              &#x3C;none>          aac433bb6835  <span class="hljs-number">2</span> years ago   <span class="hljs-number">147</span> <span class="hljs-variable constant_">MB</span>

# list containers
❯❯ docker ps
<span class="hljs-variable constant_">CONTAINER</span> <span class="hljs-variable constant_">ID</span>  <span class="hljs-variable constant_">IMAGE</span>                              <span class="hljs-variable constant_">COMMAND</span>     <span class="hljs-variable constant_">CREATED</span>        <span class="hljs-variable constant_">STATUS</span>        <span class="hljs-variable constant_">PORTS</span>                   <span class="hljs-variable constant_">NAMES</span>
6ee93adb00d1  docker.<span class="hljs-property">io</span>/library/<span class="hljs-attr">postgres</span>:latest  postgres    <span class="hljs-number">4</span> minutes ago  <span class="hljs-title class_">Up</span> <span class="hljs-number">4</span> minutes  <span class="hljs-number">0.0</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span>:<span class="hljs-number">5432</span>-><span class="hljs-number">5432</span>/tcp  postgres
</code></pre>
<div class="content-ad"></div>
<h2>4. Podman REST API에 액세스하기</h2>
<p>podman.sock은 Podman 데몬이 Podman 클라이언트로부터 요청을 수신하기 위해 사용하는 유닉스 도메인 소켓입니다. Podman 명령을 실행할 때 Podman 클라이언트는 podman.sock 소켓을 통해 Podman 데몬에 요청을 보내고, 데몬은 요청을 처리하고 클라이언트에 응답을 보냅니다. 기본적으로 podman.sock 소켓은 Podman이 실행 중인 기기에서 로컬로만 액세스할 수 있습니다. 그러나 socat을 사용하여 podman.sock 소켓을 TCP 소켓에 바인딩하여 HTTP REST API를 통해 Podman에 원격 액세스할 수 있도록 설정할 수 있습니다.</p>
<p>다음 예제에서는 podman.sock 유닉스 소켓을 socat을 사용하여 TCP 포트 2375에 바인딩하는 방법을 보여줍니다. 이를 통해 호스트 기기에서 이 포트에 연결하고 podman REST API를 외부에 노출시킬 수 있습니다. 설정이 완료되면 REST 클라이언트가 포트 2375에 연결하여 Podman REST API에 액세스할 수 있습니다.</p>
<div class="content-ad"></div>
<h2>5. ARM64 CPU 아키텍처 이미지 실행하기</h2>
<p>Podman을 사용하여 컨테이너 이미지를 실행할 때, 컨테이너는 호스트 머신과 동일한 CPU 아키텍처에서 실행됩니다. 즉, 호스트 머신이 ARM64 CPU 아키텍처를 가지고 있다면, Podman은 ARM64 아키텍처를 사용하여 컨테이너를 실행합니다. 만약 호스트 머신이 AMD64 또는 x86 아키텍처를 가지고 있다면, 컨테이너는 해당 아키텍처로 실행됩니다.</p>
<p>주의할 점은 호스트 머신의 아키텍처와 다른 아키텍처의 컨테이너 이미지를 실행하려고 한다면, Podman이 해당 컨테이너를 실행할 수 없다는 것입니다. 예를 들어, AMD64 또는 x86 아키텍처를 가진 호스트 머신에서 ARM64 컨테이너 이미지를 실행하려고 하면, Podman은 해당 컨테이너를 실행할 수 없습니다.</p>
<p>이 제한을 극복하기 위해, multi-architecture 컨테이너 이미지를 사용할 수 있습니다. 이러한 이미지에는 여러 CPU 아키텍처의 이진 파일과 라이브러리가 포함되어 있어, 동일한 이미지가 다른 아키텍처의 머신에서 실행될 수 있습니다. Docker와 Podman은 모두 multi-architecture 이미지를 지원합니다. multi-architecture 이미지를 가져올 때, Podman은 자동으로 호스트 머신에 맞는 올바른 아키텍처를 선택하고 해당 아키텍처로 컨테이너를 실행합니다.</p>
<div class="content-ad"></div>
<p>mquery 도구를 사용하면 공개 컨테이너 저장소의 모든 공개 이미지를 쿼리하여 미디어 유형, 다이제스트 및 플랫폼 지원을 확인할 수 있습니다. 또한 도커 이미지의 사용 가능한 CPU 아키텍처를 확인하는 데 사용할 수 있습니다. 이 도구는 estesp/mquery라는 이름의 Docker 이미지로 제공됩니다. 해당 이미지를 실행하여 어떤 도커 이미지의 CPU 아키텍처를 확인할 수 있습니다. 결과에는 이미지를 지원하는 플랫폼이 표시되며, 해당 아키텍처, 운영 체제 및 버전이 포함됩니다. 시스템의 CPU 아키텍처와 호환되는지 확인하는 데 유용할 수 있습니다.</p>
<pre><code class="hljs language-js"># <span class="hljs-attr">postgres</span>:latest 이미지의 사용 가능한 <span class="hljs-variable constant_">CPU</span> 아키텍처 보기
# <span class="hljs-attr">postgres</span>:latest 이미지는 arm64를 포함한 모든 <span class="hljs-variable constant_">CPU</span> 아키텍처로 제공됩니다
# macOS <span class="hljs-variable constant_">M1</span>에서 <span class="hljs-attr">postgres</span>:latest를 실행하는 경우 arm64 이미지가 선택됩니다
❯❯ docker run --rm mplatform/mquery <span class="hljs-attr">postgres</span>:latest
<span class="hljs-title class_">Image</span>: <span class="hljs-attr">postgres</span>:latest (<span class="hljs-attr">digest</span>: <span class="hljs-attr">sha256</span>:50a96a21f2992518c2cb4601467cf27c7ac852542d8913c1872fe45cd6449947)
 * <span class="hljs-title class_">Manifest</span> <span class="hljs-title class_">List</span>: <span class="hljs-title class_">Yes</span> (<span class="hljs-title class_">Image</span> <span class="hljs-attr">type</span>: application/vnd.<span class="hljs-property">docker</span>.<span class="hljs-property">distribution</span>.<span class="hljs-property">manifest</span>.<span class="hljs-property">list</span>.<span class="hljs-property">v2</span>+json)
 * <span class="hljs-title class_">Supported</span> <span class="hljs-attr">platforms</span>:
   - linux/amd64
   - linux/arm/v5
   - linux/arm/v7
   - linux/arm64/v8
   - linux/<span class="hljs-number">386</span>
   - linux/mips64le
   - linux/ppc64le
   - linux/s390x

# 실행 중인 <span class="hljs-attr">postgres</span>:latest 이미지의 <span class="hljs-variable constant_">CPU</span> 아키텍처 보기
# macOS <span class="hljs-variable constant_">M1</span>에서 <span class="hljs-attr">postgres</span>:latest를 실행하는 경우 arm64 이미지가 선택됩니다
❯❯ docker image inspect <span class="hljs-attr">postgres</span>:latest | grep <span class="hljs-title class_">Architecture</span>
          <span class="hljs-string">"Architecture"</span>: <span class="hljs-string">"arm64"</span>,
</code></pre>
<h2>6. AMD64 CPU 아키텍처 이미지 실행</h2>
<p>Podman에서 AMD64와 같은 다른 CPU 아키텍처용으로 빌드된 도커 이미지를 macOS M1/M2 ARM64 CPU에 실행하려고 하면 에러가 발생하여 실패할 것입니다. 이는 이미지가 호스트 머신의 CPU 아키텍처와 호환되지 않기 때문입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># <span class="hljs-attr">mysql</span>:<span class="hljs-number">8.0</span><span class="hljs-number">.23</span>은 amd64 아키텍처 이미지만 사용 가능합니다
❯❯ docker run --rm mplatform/mquery <span class="hljs-attr">mysql</span>:<span class="hljs-number">8.0</span><span class="hljs-number">.23</span>
이미지: <span class="hljs-attr">mysql</span>:<span class="hljs-number">8.0</span><span class="hljs-number">.23</span> (다이제스트: <span class="hljs-attr">sha256</span>:6e0014cdd88092545557dee5e9eb7e1a3c84c9a14ad2418d5f2231e930967a38)
 * <span class="hljs-title class_">Manifest</span> <span class="hljs-title class_">List</span>: <span class="hljs-title class_">Yes</span> (이미지 유형: application/vnd.<span class="hljs-property">docker</span>.<span class="hljs-property">distribution</span>.<span class="hljs-property">manifest</span>.<span class="hljs-property">list</span>.<span class="hljs-property">v2</span>+json)
 * 지원하는 플랫폼:
   - linux/amd64

# mac m1 arm64 머신에서 <span class="hljs-attr">mysql</span>:<span class="hljs-number">8.0</span><span class="hljs-number">.23</span> 실행 시 발생하는 오류입니다
❯❯ docker run <span class="hljs-attr">mysql</span>:<span class="hljs-number">8.0</span><span class="hljs-number">.23</span>
<span class="hljs-string">"mysql"</span>을 미지정 검색 레지스트리를 사용하여 해석 중 (<span class="hljs-regexp">/etc/</span>containers/registries.<span class="hljs-property">conf</span>.<span class="hljs-property">d</span>/<span class="hljs-number">999</span>-podman-machine.<span class="hljs-property">conf</span>)
docker.<span class="hljs-property">io</span>/library/<span class="hljs-attr">mysql</span>:<span class="hljs-number">8.0</span><span class="hljs-number">.23</span>에서 가져오려고 시도 중...
오류: 아키텍처 arm64, 변형 <span class="hljs-string">"v8"</span>, <span class="hljs-variable constant_">OS</span> linux에 대한 매니페스트 목록에서 이미지를 찾을 수 없음

그러나 <span class="hljs-title class_">Podman</span>은 이 문제에 대한 다중 아키텍처 지원으로 해결책을 제공합니다. --arch 옵션을 사용하여 실행하려는 플랫폼을 지정할 수 있고, 해당 플랫폼에 대해 사용 가능한 경우 <span class="hljs-title class_">Podman</span>은 자동으로 이미지의 올바른 버전을 가져옵니다. 이를 통해 macOS <span class="hljs-variable constant_">M1</span>/<span class="hljs-variable constant_">M2</span> <span class="hljs-title class_">ARM64</span> <span class="hljs-variable constant_">CPU</span>에서 다른 <span class="hljs-variable constant_">CPU</span> 아키텍처용 이미지를 문제 없이 실행할 수 있습니다.

# amd64 아키텍처를 지정하여 mysql 이미지 실행
# 그럼 podman은 amd64 아키텍처로 docker 이미지를 가져와 실행합니다
❯❯ docker run --arch=amd64 <span class="hljs-attr">mysql</span>:<span class="hljs-number">8.0</span><span class="hljs-number">.23</span>
<span class="hljs-string">"mysql"</span>을 미지정 검색 레지스트리를 사용하여 해석 중 (<span class="hljs-regexp">/etc/</span>containers/registries.<span class="hljs-property">conf</span>.<span class="hljs-property">d</span>/<span class="hljs-number">999</span>-podman-machine.<span class="hljs-property">conf</span>)
docker.<span class="hljs-property">io</span>/library/<span class="hljs-attr">mysql</span>:<span class="hljs-number">8.0</span><span class="hljs-number">.23</span>에서 가져오려고 시도 중...
이미지 소스 서명 가져옴
blob <span class="hljs-attr">sha256</span>:15f235e0d7eefe6c5153946a57daebaf2d0744fb1d0676642f269554fc68ba2a 복사 중
(중략)
config <span class="hljs-attr">sha256</span>:cbe8815cbea8fb86ce7d3169a82d05301e7dfe1a8d4228941f23f4f115a887f2 복사 중
이미지 목적지에 매니페스트 쓰는 중
서명 저장 중
<span class="hljs-number">2023</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span> <span class="hljs-number">01</span>:<span class="hljs-number">58</span>:<span class="hljs-number">56</span>+<span class="hljs-number">00</span>:<span class="hljs-number">00</span> [<span class="hljs-title class_">Note</span>] [<span class="hljs-title class_">Entrypoint</span>]: <span class="hljs-title class_">MySQL</span> <span class="hljs-title class_">Server</span> <span class="hljs-number">8.0</span><span class="hljs-number">.23</span>-1debian10용 입구점 스크립트 시작됨.
(중략)
<span class="hljs-number">2023</span>-<span class="hljs-number">03</span>-<span class="hljs-number">18</span> <span class="hljs-number">01</span>:<span class="hljs-number">58</span>:<span class="hljs-number">57</span>+<span class="hljs-number">00</span>:<span class="hljs-number">00</span> [<span class="hljs-variable constant_">ERROR</span>] [<span class="hljs-title class_">Entrypoint</span>]: 데이터베이스가 초기화되지 않았으며 암호 옵션이 지정되지 않았습니다
    다음 중 하나를 지정해야 합니다:
    - <span class="hljs-variable constant_">MYSQL_ROOT_PASSWORD</span>
    - <span class="hljs-variable constant_">MYSQL_ALLOW_EMPTY_PASSWORD</span>
    - <span class="hljs-variable constant_">MYSQL_RANDOM_ROOT_PASSWORD</span>

--arch 옵션이 작동하지 않는 경우, multiarch/qemu-user-<span class="hljs-keyword">static</span>을 사용한 해결책이 있습니다. 이 글에서 그 해결책에 대해 자세히 설명합니다.
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-js">podman machine ssh
sudo -i
rpm-ostree install qemu-user-<span class="hljs-keyword">static</span>
systemctl reboot
</code></pre>
<h2>7. 다른 CPU 아키텍처로 이미지 빌드하기</h2>
<p>Podman으로 이미지를 빌드할 때 --arch 플래그를 사용하여 이미지에 원하는 CPU 아키텍처를 선택할 수 있습니다. 기본적으로 Podman은 실행 중인 기기의 CPU 아키텍처를 사용합니다. 이를 통해 Podman을 사용하여 멀티 아키텍처 이미지를 빌드할 수 있으며, 동일한 응용 프로그램을 다양한 CPU 아키텍처에서 실행하는 데 유용할 수 있습니다. 아래는 다른 아키텍처 이미지를 빌드하는 데 사용되는 예시 golang 응용프로그램(main.go)과 Dockerfile입니다.</p>
<pre><code class="hljs language-js">package main

<span class="hljs-keyword">import</span> <span class="hljs-string">"fmt"</span>

func <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
 fmt.<span class="hljs-title class_">Println</span>(<span class="hljs-string">"vim-go"</span>)
}
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">golang</span>:<span class="hljs-number">1.16</span>-alpine <span class="hljs-keyword">as</span> builder
<span class="hljs-variable constant_">WORKDIR</span> /app
<span class="hljs-variable constant_">COPY</span> . .

<span class="hljs-variable constant_">RUN</span> go build -o main *.<span class="hljs-property">go</span>

<span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">alpine</span>:latest
<span class="hljs-variable constant_">WORKDIR</span> /root/
<span class="hljs-variable constant_">COPY</span> --<span class="hljs-keyword">from</span>=builder /app/main .
<span class="hljs-variable constant_">CMD</span> [ <span class="hljs-string">"./main"</span> ]
</code></pre>
<p>AMD64 아키텍처를 사용하여 이미지를 빌드하려면 Podman을 사용하여 다음 명령을 --arch=amd64 매개변수와 함께 사용할 수 있습니다. 이는 AMD64 아키텍처 기본 이미지를 사용하고 그 위에 새 이미지를 빌드합니다.</p>
<pre><code class="hljs language-js"># amd64 cpu 아키텍처로 도커 이미지 빌드
# 빌드할 때 주어진 cpu 아키텍처의 기반 이미지 및 라이브러리를 가져옵니다
❯❯ docker build --arch=amd64 --rm -t erangaeb/hello .
[<span class="hljs-number">1</span>/<span class="hljs-number">2</span>] 단계 <span class="hljs-number">1</span>/<span class="hljs-number">4</span>: <span class="hljs-variable constant_">FROM</span> <span class="hljs-attr">golang</span>:<span class="hljs-number">1.16</span>-alpine <span class="hljs-variable constant_">AS</span> builder
<span class="hljs-string">"golang"</span>를 unqualified-search 레지스트리(../../containers/registries.<span class="hljs-property">conf</span>.<span class="hljs-property">d</span>/<span class="hljs-number">999</span>-podman-machine.<span class="hljs-property">conf</span>)를 사용하여 해석 중
docker.<span class="hljs-property">io</span>/library/<span class="hljs-attr">golang</span>:<span class="hljs-number">1.16</span>-alpine를 가져오려는 중...
이미지 소스 서명 가져오는 중
blob <span class="hljs-attr">sha256</span>:0435e09637941e35cccdf9cf9171571811d2fdfe72c27e39543a718d38d28668 복사 중
blob <span class="hljs-attr">sha256</span>:59bf1c3509f33515622619af21ed55bbe26d24913cedbca106468a5fb37a50c3 복사 중
blob <span class="hljs-attr">sha256</span>:666ba61612fd7c93393f9a5bc1751d8a9929e32d51501dba691da9e8232bc87b 복사 중
blob <span class="hljs-attr">sha256</span>:8ed8ca4862056a130f714accb3538decfa0663fec84e635d8b5a0a3305353dee 복사 중
blob <span class="hljs-attr">sha256</span>:ca4bf87e467a8cacf62c9b01c7d6d43f6ca4bb9b0fc9146fbb906b05aee56cc1 복사 중
config <span class="hljs-attr">sha256</span>:7642119cd16177d874dcbfe1c550affd336dbe4cabb3339ef685ac1d6ec71ccc 복사 중
이미지 목적지에 매니페스트 작성 중
서명 저장 중
[<span class="hljs-number">1</span>/<span class="hljs-number">2</span>] 단계 <span class="hljs-number">2</span>/<span class="hljs-number">4</span>: <span class="hljs-variable constant_">WORKDIR</span> /app
--> 캐시 푸시 []:220abc07870fcc2e449b7b03384b2e4c219f7c32b28546f90067c1488ea63ba0
--> 663c9d6f7ea
[<span class="hljs-number">1</span>/<span class="hljs-number">2</span>] 단계 <span class="hljs-number">3</span>/<span class="hljs-number">4</span>: <span class="hljs-variable constant_">COPY</span> . .
--> 캐시 푸시 []:e7db7815e4762b218ab81c3f93cdf789c4961c783825470c3c2edb55000b1844
--> ce3d882f4c8
[<span class="hljs-number">1</span>/<span class="hljs-number">2</span>] 단계 <span class="hljs-number">4</span>/<span class="hljs-number">4</span>: <span class="hljs-variable constant_">RUN</span> go build -o main *.<span class="hljs-property">go</span>
--> 캐시 푸시 []:95b5a69b661a646895b2a2bc6b313e0f5fd2cc83a4d7dcd1e5f2594be34c3d4d
--> 54d84331cf2
사용자 정의 erangaeb/hello 이미지가 성공적으로 빌드되었습니다
c1329ead22a2cf66cd4a47b06aa0d406aba34798d26e79d666e1d855cd920028

# 이미지 실행
# 이미지를 arm64 cpu로 빌드한 후 --arch=amd64를 명시해야 함
# 그렇지 않으면 amd64 cpu 아키텍처 이미지를 가져와 실패할 것입니다
❯❯ docker run --arch=amd64 localhost/erangaeb/hello
경고: 이미지 플랫폼(리눅스/amd64)이 예상 플랫폼(리눅스/arm64)과 일치하지 않습니다
vim-go
</code></pre>
<p>다음은 Podman을 사용하여 arm64 아키텍처로 이미지를 빌드하는 예제 명령입니다. 이 명령은 --arch 플래그를 사용하여 ARM64 아키텍처를 지정합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># arm64 <span class="hljs-variable constant_">CPU</span> 아키텍처로 도커 이미지 빌드
❯❯ docker build --arch=arm64 --rm -t erangaeb/<span class="hljs-attr">hello</span>:arm64 .
[<span class="hljs-number">1</span>/<span class="hljs-number">2</span>] 단계 <span class="hljs-number">1</span>/<span class="hljs-number">4</span>: <span class="hljs-attr">golang</span>:<span class="hljs-number">1.16</span>-alpine을 빌드 중
... (중략) ...
[<span class="hljs-number">2</span>/<span class="hljs-number">2</span>] 단계 <span class="hljs-number">1</span>/<span class="hljs-number">4</span>: <span class="hljs-attr">alpine</span>:latest으로 빌드 중
... (중략) ...
erangaeb/<span class="hljs-attr">hello</span>:arm64 이미지 구축 완료
4d98d25ec13db2b9c25c149a0c3f5996829029026a6fd295e55c78acc9cef89e

# arm64 이미지 실행
# <span class="hljs-variable constant_">CPU</span> 아키텍처와 일치하여 경고 없이 실행됩니다.
❯❯ docker run localhost/erangaeb/<span class="hljs-attr">hello</span>:arm64
vim-go
</code></pre>
<h2>8. 쿠버네티스 클러스터 실행</h2>
<p>로컬 쿠버네티스 클러스터를 생성하기 위해 Kind와 Podman을 함께 사용했습니다. Kind는 로컬 머신에서 도커 컨테이너로 작동하는 클러스터 노드로서 쿠버네티스 클러스터를 운영할 수 있게 해주는 오픈소스 도구입니다. 아래는 Podman을 활용하여 Kind 클러스터를 설정하는 단계입니다.</p>
<pre><code class="hljs language-js"># asdf를 사용하여 kind 설치
❯❯ asdf plugin add kind
❯❯ asdf install kind <span class="hljs-number">0.17</span><span class="hljs-number">.0</span>
❯❯ asdf <span class="hljs-variable language_">global</span> kind <span class="hljs-number">0.17</span><span class="hljs-number">.0</span>

# ~/.<span class="hljs-property">zshrc</span> 파일에 아래 구성 추가하여 rootless podman으로 kind 실행
<span class="hljs-variable constant_">KIND_EXPERIMENTAL_PROVIDER</span>=podman

# 클러스터 생성
# 클러스터 이름은 <span class="hljs-string">'kind'</span>로 지정됩니다.
❯❯ kind create cluster 

# kubectl 컨텍스트인 kind-kind가 추가됩니다.
❯❯ kubectl config get-contexts
... (중략) ...

# kind 클러스터 조회
❯❯ kind get clusters
... (중략) ...

# 클러스터 노드에 이미지 로드
# 비공개 도커 레지스트리(예: <span class="hljs-title class_">Google</span> <span class="hljs-title class_">Container</span> <span class="hljs-title class_">Registry</span>/<span class="hljs-variable constant_">GCR</span>)에 있는 이미지 실행에 도움이 됩니다.
❯❯ kind load docker-image eu.<span class="hljs-property">gcr</span>.<span class="hljs-property">io</span>/rahasak-build/<span class="hljs-attr">lambdaops</span>:<span class="hljs-number">1.0</span>

# kind-kind 컨텍스트로 kind 클러스터 사용
❯❯ kubectl --context=kind-kind get pods

# 클러스터 삭제
❯❯ kind <span class="hljs-keyword">delete</span> cluster
</code></pre>
<div class="content-ad"></div>
<h2>9. Google Container Registry 인증</h2>
<p>Google Container Registry(GCR)와 통합하고 싶을 수 있습니다. 이는 Google Cloud가 제공하는 Docker 이미지를 저장하고 관리하는 호스팅 서비스입니다. GCR 문서에는 Docker와의 인증에 대한 훌륭한 안내가 제공됩니다. 첫 번째 인증 방법은 gcloud 자격 증명 도우미를 사용하는 것인데, 이는 gcloud CLI를 사용하여 Cloud Shell 또는 Google Cloud CLI가 설치된 모든 환경에서 인증을 구성합니다. Docker의 gcloud 자격 증명 도우미 방법을 통해 한 번 인증을 받으면 같은 인증 방법을 Podman에서도 사용할 수 있습니다. 먼저 Google Cloud 계정으로 gcloud auth login 명령을 실행하여 인증하십시오. 다음으로, gcloud auth configure-docker <code>registry host</code> 명령을 사용하여 Docker가 GCR과 인증하도록 구성하십시오. 이 작업이 완료되면 Podman은 Docker 자격 증명을 재사용할 수 있습니다.</p>
<pre><code class="hljs language-js"># 웹 플로우를 통해 gcloud 서비스에 로그인
❯❯ gcloud auth login

# 자격 증명을 ~<span class="hljs-regexp">/.config/g</span>cloud/credentials.<span class="hljs-property">db</span> <span class="hljs-title class_">SQLite</span> 데이터베이스에 저장합니다
❯❯ sqlite3 credentials.<span class="hljs-property">db</span> <span class="hljs-string">"SELECT value FROM credentials"</span>
{
  <span class="hljs-string">"client_id"</span>: <span class="hljs-string">"&#x3C;id>.apps.googleusercontent.com"</span>,
  <span class="hljs-string">"client_secret"</span>: <span class="hljs-string">"&#x3C;secret>"</span>,
  <span class="hljs-string">"refresh_token"</span>: <span class="hljs-string">"&#x3C;token>"</span>,
  <span class="hljs-string">"revoke_uri"</span>: <span class="hljs-string">"https://accounts.google.com/o/oauth2/revoke"</span>,
  <span class="hljs-string">"scopes"</span>: [
    <span class="hljs-string">"openid"</span>,
    <span class="hljs-string">"https://www.googleapis.com/auth/userinfo.email"</span>,
    <span class="hljs-string">"https://www.googleapis.com/auth/cloud-platform"</span>,
    <span class="hljs-string">"https://www.googleapis.com/auth/appengine.admin"</span>,
    <span class="hljs-string">"https://www.googleapis.com/auth/sqlservice.login"</span>,
    <span class="hljs-string">"https://www.googleapis.com/auth/compute"</span>,
    <span class="hljs-string">"https://www.googleapis.com/auth/accounts.reauth"</span>
  ],
  <span class="hljs-string">"token_uri"</span>: <span class="hljs-string">"https://oauth2.googleapis.com/token"</span>,
  <span class="hljs-string">"type"</span>: <span class="hljs-string">"authorized_user"</span>
}

# <span class="hljs-title class_">Docker</span>가 <span class="hljs-variable constant_">GCR</span>과 인증하도록 구성
# 그럼 <span class="hljs-title class_">Podman</span>이 해당 자격 증명을 재사용할 수 있습니다
# 명령어
❯❯ gcloud auth configure-docker &#x3C;registry host>

# 예시
❯❯ gcloud auth configure-docker eu.<span class="hljs-property">gcr</span>.<span class="hljs-property">io</span>
<span class="hljs-title class_">Adding</span> credentials <span class="hljs-attr">for</span>: eu.<span class="hljs-property">gcr</span>.<span class="hljs-property">io</span>
업데이트 후 다음이 <span class="hljs-title class_">Docker</span> 구성 파일에 작성될 것입니다
[<span class="hljs-regexp">/Users/</span>lambda.<span class="hljs-property">eranga</span>/.<span class="hljs-property">docker</span>/config.<span class="hljs-property">json</span>]:
 {
  <span class="hljs-string">"credHelpers"</span>: {
    <span class="hljs-string">"eu.gcr.io"</span>: <span class="hljs-string">"gcloud"</span>
  }
}
계속하시겠습니까 (Y/n)?  Y

# 원하는 경우 더 많은 레지스트리 호스트를 추가할 수 있습니다
❯❯ gcloud auth configure-docker europe-docker.<span class="hljs-property">pkg</span>.<span class="hljs-property">dev</span>
❯❯ gcloud auth configure-docker europe-north1-docker.<span class="hljs-property">pkg</span>.<span class="hljs-property">dev</span>

# 생성된 구성은 홈 디렉토리 ~<span class="hljs-regexp">/.docker/</span>config.<span class="hljs-property">json</span>에 저장됩니다
❯❯ cat ~<span class="hljs-regexp">/.docker/</span>config.<span class="hljs-property">json</span>
{
  <span class="hljs-string">"credHelpers"</span>: {
    <span class="hljs-string">"eu.gcr.io"</span>: <span class="hljs-string">"gcloud"</span>,
    <span class="hljs-string">"europe-docker.pkg.dev"</span>: <span class="hljs-string">"gcloud"</span>,
    <span class="hljs-string">"europe-north1-docker.pkg.dev"</span>: <span class="hljs-string">"gcloud"</span>
  }
}

# 이제 <span class="hljs-title class_">Podman</span>은 <span class="hljs-title class_">Docker</span> 자격 증명을 사용하여 credential helper gcloud를 통해 <span class="hljs-variable constant_">GCR</span>에 접근할 수 있습니다
❯❯ docker pull eu.<span class="hljs-property">gcr</span>.<span class="hljs-property">io</span>/rahasak-build/<span class="hljs-attr">aplos</span>:<span class="hljs-number">0.1</span> --log-level=debug
<span class="hljs-variable constant_">INFO</span>[<span class="hljs-number">0000</span>] podman filtering at log level debug
⋮
</code></pre>
<p>이전 방법은 Podman이 Docker GCR 인증 구성을 사용하여 Google Container Registry와 인증하는 방법을 설명했습니다. 그러나 Podman은 직접 컨테이너 레지스트리에 로그인하기 위한 podman login이라는 명령도 제공합니다. 이 명령은 Container Registry와 함께 사용할 수 있는 단기간의 OAuth 액세스 토큰을 사용하여 인증합니다. 이 토큰은 60분 동안만 유효하므로 Container Registry에 연결하기 전 1시간 이전에 요청해야 합니다. 토큰이 만료되면 다시 로그인해야 하며, 그렇지 않으면 권한 없음: 인증 실패 오류가 발생할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-yaml"><span class="hljs-comment"># 웹 플로우를 통해 gcloud 서비스에 로그인해주세요</span>
<span class="hljs-string">❯❯</span> <span class="hljs-string">gcloud</span> <span class="hljs-string">auth</span> <span class="hljs-string">login</span>

<span class="hljs-comment"># 이전에 생성된 도커 자격 증명을 제거해주세요</span>
<span class="hljs-string">❯❯</span> <span class="hljs-string">rm</span> <span class="hljs-string">-rf</span> <span class="hljs-string">~/.docker</span>

<span class="hljs-comment"># 짧게 유지되는 액세스 토큰을 생성하고 sqlite db ~/.config/gcloud/access_tokens.db에 저장됩니다</span>
<span class="hljs-string">❯❯</span> <span class="hljs-string">sqlite3</span> <span class="hljs-string">access_tokens.db</span> <span class="hljs-string">"select * from access_tokens"</span>

<span class="hljs-comment"># 액세스 토큰 확인</span>
<span class="hljs-string">❯❯</span> <span class="hljs-string">gcloud</span> <span class="hljs-string">auth</span> <span class="hljs-string">print-access-token</span>

<span class="hljs-comment"># 액세스 토큰으로 gcr에 로그인</span>
<span class="hljs-comment"># 이렇게 짧게 유지되는 OAuth 액세스 토큰을 사용하여 Container Registry와 인증합니다. </span>
<span class="hljs-comment"># 토큰은 60분 동안 유효하며, Container Registry에 연결하기 전에 한 시간 이내에 요청해야 합니다.</span>
<span class="hljs-comment"># 토큰 만료 시, 아래 명령어를 다시 실행하고 다시 로그인해야 합니다. 그렇지 않으면 권한이 없음: 인증 실패 오류가 발생합니다.</span>
<span class="hljs-string">❯❯</span> <span class="hljs-string">gcloud</span> <span class="hljs-string">auth</span> <span class="hljs-string">print-access-token</span> <span class="hljs-string">|</span> <span class="hljs-string">podman</span> <span class="hljs-string">login</span> <span class="hljs-string">-u</span> <span class="hljs-string">oauth2accesstoken</span> <span class="hljs-string">--password-stdin</span> <span class="hljs-string">eu.gcr.io</span>

<span class="hljs-comment"># ~/.config/containers/auth.json에 인증 파일이 생성됩니다</span>
<span class="hljs-string">❯❯</span> <span class="hljs-string">cat</span> <span class="hljs-string">.config/containers/auth.json</span>
</code></pre>
<p>{
"auths": {
"eu.gcr.io": {
"auth": "&#x3C;액세스 토큰>"
}
}
}</p>
<h1>이제 podman은 docker 자격 증명을 사용하여 gcr에 액세스할 수 있습니다(자격 증명 도우미 gcloud 사용)</h1>
<p>❯❯ docker pull eu.gcr.io/rahasak-build/aplos:0.1 --log-level=debug
INFO[0000] log level debug에서 podman 필터링
DEBU[0000] pull.PersistentPreRunE(podman pull eu.gcr.io/rahasak-build/aplos:0.1 --log-level=debug) 호출
DEBU[0000] DoRequest 메서드: GET URI: <a href="http://d/v4.4.2/libpod/_ping" rel="nofollow" target="_blank">http://d/v4.4.2/libpod/_ping</a>
DEBU[0000] "/etc/containers/registries.conf"에서 레지스트리 구성로드
DEBU[0000] 자격 증명 도우미 containers-auth.json에서 /Users/lambda.eranga/.config/containers/auth.json 파일의 eu.gcr.io 자격 증명 찾음
DEBU[0000] DoRequest 메서드: POST URI: <a href="http://d/v4.4.2/libpod/images/pull" rel="nofollow" target="_blank">http://d/v4.4.2/libpod/images/pull</a>
eu.gcr.io/rahasak-build/aplos:0.1 끌어오기 시도 중...
이미지 소스 서명 가져오는 중
blob sha256:9fa0fafc404b18044192115d295424237056a9296da9fe07f3f493f714d7c6fb 복사 중
blob sha256:b9fd7cb1ff8f489cf082781b0e1fe0c13b840e20147e8fc8204b4592da7c2f70 복사 중
blob sha256:f25ad21146dc80e14a651d9f59707ccab21bd3749aee1177faf72329661f19eb 복사 중
blob sha256:e92ed755c008afc1863a616a5ba743b670c09c1698f7328f05591932452a425f 복사 중
blob sha256:53e3366ec435596bed2563cc882ba47ec25df6be2b1027e3243e83589c667c1e 복사 중
blob sha256:ee690f2d57a128744cf4c5b52646ad0ba7a5af113d9d7e0e02b62c06d35fd14c 복사 중
blob sha256:e83609f677899ddd7e01f03fd3f797d98fb18e3307a236b55b218a59f5cf7b9b 복사 중
blob sha256:88c7c603b3faedd122305543eb17d6968a16399c7a93f67b3486196b2440c846 복사 중</p>
<h1>로그인 취소</h1>
<p>❯❯ podman logout eu.gcr.io</p>
<h1>참고</h1>
<ul>
<li><a href="https://medium.com/rahasak/replace-docker-desktop-with-minikube-and-hyperkit-on-macos-783ce4fb39e3" rel="nofollow" target="_blank">https://medium.com/rahasak/replace-docker-desktop-with-minikube-and-hyperkit-on-macos-783ce4fb39e3</a></li>
<li><a href="https://dev.to/docker/choosing-the-right-docker-image-for-your-apple-m1-pro-440l" rel="nofollow" target="_blank">https://dev.to/docker/choosing-the-right-docker-image-for-your-apple-m1-pro-440l</a></li>
<li><a href="https://zenn.dev/sbk0716/articles/d9235b78b97615" rel="nofollow" target="_blank">https://zenn.dev/sbk0716/articles/d9235b78b97615</a></li>
<li><a href="https://itnext.io/using-minikube-on-m1-macs-416da593ba0c" rel="nofollow" target="_blank">https://itnext.io/using-minikube-on-m1-macs-416da593ba0c</a></li>
<li><a href="https://itnext.io/goodbye-docker-desktop-hello-minikube-3649f2a1c469" rel="nofollow" target="_blank">https://itnext.io/goodbye-docker-desktop-hello-minikube-3649f2a1c469</a></li>
<li><a href="https://0to1.nl/post/minikube-m1-pro-issues/" rel="nofollow" target="_blank">https://0to1.nl/post/minikube-m1-pro-issues/</a></li>
<li><a href="https://www.redhat.com/sysadmin/podman-python-bash" rel="nofollow" target="_blank">https://www.redhat.com/sysadmin/podman-python-bash</a></li>
<li><a href="https://edofic.com/posts/2021-09-12-podman-m1-amd64/" rel="nofollow" target="_blank">https://edofic.com/posts/2021-09-12-podman-m1-amd64/</a></li>
<li><a href="https://xphyr.net/post/podman_on_osx/" rel="nofollow" target="_blank">https://xphyr.net/post/podman_on_osx/</a></li>
<li><a href="https://www.redhat.com/sysadmin/specify-architecture-pulling-podman-images" rel="nofollow" target="_blank">https://www.redhat.com/sysadmin/specify-architecture-pulling-podman-images</a></li>
<li><a href="https://itnext.io/kubernetes-kind-cheat-shee-2605da77984" rel="nofollow" target="_blank">https://itnext.io/kubernetes-kind-cheat-shee-2605da77984</a></li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"macOS M1 M2 ARM64 CPU에서 Docker Desktop을 Podman으로 바꾸는 방법","description":"","date":"2024-06-23 15:31","slug":"2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU","content":"\n\n## 친절한 쿠버네티스 클러스터와 함께\n\n![이미지](/assets/img/2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU_0.png)\n\n# 배경\n\n이전 글에서는 macOS에서 이전 AMD64 아키텍처 기반 머신에 Minikube와 Hyperkit을 사용하여 Docker Desktop을 대체하는 방법에 대해 논의했습니다. 그러나 ARM64 아키텍처 CPU를 사용하는 새로운 M1/M2 머신이 등장하면서 Hyperkit은 이러한 새로운 머신과 호환되지 않습니다. 이 문제를 해결하기 위해 macOS M1/M2 머신에서 Docker Desktop을 Podman으로 대체하고 Kind를 사용하여 쿠버네티스 로컬 클러스터를 생성했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# macOS M1/M2 ARM64 아키텍처\n\nmacOS M1/M2는 최신 Apple 맥인토시 컴퓨터 라인으로, ARM64 아키텍처를 기반으로 합니다. ARM64 아키텍처는 컴퓨팅 세계에서 점차 인기를 끌고 있는 새로운 유형의 프로세서 아키텍처입니다. 대부분의 데스크톱 및 랩톱 컴퓨터에서 사용되는 전통적인 x86 아키텍처와 비교하면, ARM64 아키텍처는 저전력을 위해 설계되었으며 모바일 기기용으로 최적화되어 있습니다.\n\nARM64 아키텍처의 주요 장점 중 하나는 와트 당 성능 향상입니다. 이는 ARM64 아키텍처를 기반으로 한 컴퓨터가 더 적은 전력을 사용하면서도 유사하거나 더 나은 성능을 제공할 수 있음을 의미합니다. 이는 노트북의 배터리 수명 연장 및 데스크탑의 에너지 소비 감소로 이어질 수 있습니다. 또한, ARM64 아키텍처는 머신러닝과 같은 특정 작업을 위한 하드웨어 가속화와 같은 기능을 포함하고 있어, 이러한 작업 부하의 성능을 향상시킬 수 있습니다.\n\nAMD64/x86 인텔 아키텍처와 비교하면, ARM64 아키텍처는 더 새롭고 확립되지 않은 아키텍처입니다. AMD64/x86은 많은 해 동안 주도적인 아키텍처이지만, ARM64는 특히 모바일 기기와 서버에서 더 많은 인기를 얻고 있습니다. 그러나 ARM64 아키텍처에 대한 더 많은 응용 프로그램과 소프트웨어의 최적화가 이루어지면, 앞으로 더 많은 ARM64 기반 컴퓨터를 볼 수 있을 것입니다. 성능 측면에서, ARM64 아키텍처는 특정 작업 부하에 대해 AMD64/x86 아키텍처와 비교 가능하거나 더 빠를 수 있지만, 이는 구체적인 사용 사례 및 소프트웨어 최적화에 따라 다를 수 있습니다. 최종적으로 두 아키텍처 모두 강점과 약점을 가지고 있으며, 그것들 사이의 선택은 사용자나 조직의 구체적인 요구 사항에 달려 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n맥OS M1/M2 기기는 ARM64 아키텍처에서 실행되도록 특별히 설계되었으며, 이 아키텍처에 최적화된 소프트웨어와 도구가 필요하여 효율적으로 실행할 수 있습니다. x86 아키텍처에서 실행되도록 설계된 일부 소프트웨어는 macOS M1/M2 기기에서 제대로 작동하지 않을 수 있으므로, 개발자와 사용자는 호환성과 최적 성능을 보장하기 위해 ARM64 아키텍처용 도구와 소프트웨어를 사용해야 합니다.\n\n# Docker Desktop\n\nmacOS에서 Docker Desktop은 Docker 컨테이너를 사용하여 애플리케이션을 쉽게 빌드, 테스트 및 배포할 수 있도록 합니다. 컨테이너, 이미지 및 네트워크를 관리하기 위한 간단하고 사용자 친화적인 인터페이스를 제공하며, 다양한 플랫폼 및 운영 체제에서 사용할 수 있습니다. ARM64 아키텍처 기반의 최신 macOS M1/M2 기기가 출시된 가운데, Docker는 ARM64 아키텍처에 최적화된 새로운 Docker Desktop 버전을 출시했습니다. 이 버전은 Apple의 Hypervisor.framework를 활용하여 가상화 환경에서 컨테이너를 실행하며, 이를 통해 Docker Desktop을 사용하는 개발자와 IT 전문가에게 매끄러운 경험을 제공합니다.\n\nDocker Desktop은 컨테이너화에 강력한 도구를 제공하지만, 단점도 있습니다. Docker Desktop 사용의 주요 단점 중 하나는 백그라운드에서 실행되는 별도의 데몬 프로세스를 필요로 한다는 점인데, 이는 상당한 시스템 리소스를 소비할 수 있습니다. 또한, Docker Desktop은 일부 애플리케이션 및 운영 체제와 가끔 호환성 문제가 있어 사용자들에게 다운타임과 귀찮음을 초래할 수 있습니다. 게다가, 최근 Docker Desktop의 라이선스 요구사항 변경으로 많은 사용자가 대안을 찾고 있습니다. 결과적으로, Podman과 같은 대체 솔루션들이 이 기기에서 컨테이너화 요구를 충족하는 데 더 인기를 얻고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Podman\n\nPodman은 빌드, 관리 및 실행을 위한 Docker의 대체제로 제공되는 인기 있는 컨테이너 관리 도구입니다. ARM64 아키텍처 기반의 새로운 macOS M1/M2 기계가 출시되면서, Podman은 컨테이너화 요구 사항에 대한 Docker Desktop의 대안으로 나타나고 있습니다.\n\nPodman은 ARM64 아키텍처에 최적화되어 개발자와 IT 전문가들에게 뛰어난 경험을 제공합니다. Docker와 달리, Podman은 Linux 커널의 컨테이너화 기능을 사용하므로 별도의 백그라운드 데몬 프로세스가 실행되어야 하는 필요가 없습니다. 이는 성능 향상과 리소스 소비의 감소로 이어질 수 있습니다.\n\nmacOS M1/M2 기계에서 Podman을 사용하는 주요 이점 중 하나는 가상 머신을 사용하지 않아도 된다는 점입니다. 대신, Podman은 ARM64 아키텍처의 네이티브 컨테이너화 기능을 활용하여 더 효율적이고 간소화된 경험을 제공합니다. Podman은 ARM64 아키텍처를 기반으로 하는 macOS M1/M2 기계에서 Docker Desktop에 대한 유망한 대안입니다. 최적화된 성능과 간소화된 컨테이너화 기능을 갖춘 Podman은 이러한 기계에서 컨테이너를 빌드, 관리 및 실행해야 하는 개발자와 IT 전문가들에게 강력한 도구를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 macOS M1/M2 기기에서 ARM64 아키텍처를 사용하는 Podman을 설정하는 가이드입니다. 이를 통해 더 가벼우면서도 효율적인 컨테이너화 도구로 Docker 및 Docker Desktop을 대체할 수 있습니다.\n\n## 1. Podman 설치 및 구성\n\nmacOS에는 Homebrew 패키지 관리자를 사용하여 Podman을 설치할 수 있습니다. 설치한 후, Podman을 루트 없는 컨테이너와 함께 사용할 수 있도록 구성할 수 있습니다. 이때 주의해야 할 점은 Linux 시스템과는 달리 macOS(그리고 Windows)에서는 Podman 사용 시 가상 머신을 사용해야 한다는 것입니다. 가상 머신은 QEMU 에뮬레이터를 사용하여 Linux 런타임 환경을 제공합니다. MacOS와 Windows는 Podman이 의존하는 Linux 네임스페이스 및 cgroups를 네이티브로 지원하지 않기 때문입니다.\n\n```js\n# Podman 설치\n❯❯ brew install podman\n\n# 새로운 Linux 런타임 환경 초기화 (이를 'podman machine'이라고 합니다)\n# Podman은 quem 에뮬레이터를 사용하여 Linux 런타임 환경을 제공합니다\n# --cpus 4 (CPU 코어 수 지정)\n# --memory=6144 (메모리 용량 지정)\n❯❯ podman machine init --cpus 4 --memory=6144\n\n# Podman 머신 목록 표시\n# 기본 Podman 머신은 `podman-machine-default*`입니다\n❯❯ podman machine ls\nNAME                     VM TYPE     CREATED     LAST UP     CPUS        MEMORY      DISK SIZE\npodman-machine-default*  qemu        4 days ago  4 days ago  2           2.147GB     107.4GB\n\n# 런타임 시작\n# Podman은 /Users, /private, /var/folders 디렉터리에 볼륨 매핑을 사용합니다\n❯❯ podman machine start\n\"podman-machine-default\" 머신 시작 중\nVM 대기 중...\n볼륨 마운트... /Users:/Users\n볼륨 마운트... /private:/private\n볼륨 마운트... /var/folders:/var/folders\n\n현재 이 머신은 루트 없는 모드로 구성되어 있습니다. 컨테이너에 루트 권한이 필요한 경우(예: 포트 \u003c 1024) 또는 비-Podman 클라이언트와의 호환성 문제가 발생한 경우, 다음 명령을 사용하여 전환할 수 있습니다:\n\n podman machine set --rootful\n\nAPI 전달 Listening: /Users/lambda.eranga/.local/share/containers/podman/machine/podman-machine-default/podman.sock\n\n시스템 도우미 서비스가 설치되어 있지 않습니다; podman에서는 기본 Docker API 소켓 주소를 사용할 수 없습니다. 설치하려면 다음 명령을 실행하세요:\n\n sudo /opt/homebrew/Cellar/podman/4.4.2/bin/podman-mac-helper install\n podman machine stop; podman machine start\n\n터미널 세션에서 다음 몤령을 사용하여 여전히 Docker API 클라이언트에 연결할 수 있습니다:\n\n export DOCKER_HOST='unix:///Users/lambda.eranga/.local/share/containers/podman/machine/podman-machine-default/podman.sock'\n\n\"podman-machine-default\" 머신이 성공적으로 시작되었습니다\npodman machine start\n\n# Podman 머신이 실행 중\n❯❯ podman machine ls\nNAME                     VM TYPE     CREATED     LAST UP            CPUS        MEMORY      DISK SIZE\npodman-machine-default*  qemu        4 days ago  Currently running  2           2.147GB     107.4GB\n\n# 정보 확인\n❯❯ podman info\n\n# Podman 연결\n❯❯ podman system connection ls\nName                         URI                                                         Identity                                          Default\npodman-machine-default       ssh://core@localhost:50985/run/user/501/podman/podman.sock  /Users/lambda.eranga/.ssh/podman-machine-default  true\npodman-machine-default-root  ssh://root@localhost:50985/run/podman/podman.sock           /Users/lambda.eranga/.ssh/podman-machine-default  false\n\n# 머신 정지\n❯❯ podman machine stop\n\n# 머신 재시작\n❯❯ podman machine stop; podman machine start\n\n# Podman 머신에 SSH 접속\n❯❯ podman machine ssh\n\n# 머신 제거\n❯❯ podman machine rm -f podman-machine-default\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 2. Podman Commands\n\nPodman은 Docker와 유사한 명령줄 인터페이스를 제공합니다. 사실, Podman에서 사용하는 많은 명령어는 Docker에서 사용하는 것과 동일하여 Docker에 익숙한 사용자가 Podman으로 쉽게 전환할 수 있습니다. Podman에서 다양한 명령어를 실행하려면 원하는 특정 명령어 뒤에 podman 명령어를 사용할 수 있습니다. 예를 들어, 모든 실행 중인 컨테이너를 나열하려면 podman ps 명령어를 사용할 수 있습니다. 마찬가지로 Dockerfile에서 이미지를 빌드하려면 podman build -t image_name -f Dockerfile_path와 같은 명령어를 사용할 수 있습니다. Podman은 컨테이너 시작 및 중지, 실행 중인 컨테이너에 연결 및 이미지 및 볼륨 관리와 같은 일반적인 컨테이너화 작업을 지원합니다.\n\n```js\n# 이미지 목록\n❯❯ podman images\nREPOSITORY                           TAG             IMAGE ID      CREATED       SIZE\ndocker.io/hashicorp/envconsul        0.13.0          42307d16e023  8 months ago  18.7 MB\ndocker.io/library/vault              \u003cnone\u003e          aac433bb6835  2 years ago   147MB\n\n# PostgreSQL 이미지 다운로드\n❯❯ podman pull postgres:latest\n...\n\n# PostgreSQL 실행\n❯❯ podman run --name postgres -e POSTGRES_PASSWORD=admin -p 5432:5432 -d postgres\n6ee93adb00d1f1a468308b50a044002e2f7da116614ebb8d092d8236ae6542d6\n\n# 실행 중인 컨테이너 목록\n❯❯ podman ps\nCONTAINER ID  IMAGE                              COMMAND     CREATED        STATUS        PORTS                   NAMES\n6ee93adb00d1  docker.io/library/postgres:latest  postgres    4 seconds ago  Up 4 seconds  0.0.0.0:5432-\u003e5432/tcp  postgres\n\n# 명령어 실행 시 디버그 로그 보기\n❯❯ podman --log-level=debug ps\n...\n\n## 3. Create Docker Alias\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nPodman은 Docker와 매우 유사한 명령줄 인터페이스를 제공하여 Docker에서 Podman으로 쉽게 전환할 수 있습니다. 실제로 Podman과 Docker를 동일하게 사용할 수 있도록 Docker에 대한 별칭을 Podman으로 만들 수 있습니다. 예를 들어, 다음 Alias를 ~/.zshrc 파일에 추가하여 Podman의 docker alias를 만들 수 있습니다.\n\n```js\n# alias to docker, run podman commands as docker\nalias docker=podman\n```\n\n별칭을 설정한 후에는 docker 명령을 podman 명령처럼 사용할 수 있으며, docker 명령을 사용하여 Podman 명령을 실행할 수 있습니다. Docker에서 작업하는 데 익숙하고 새로운 명령어를 배우지 않고 Podman으로 전환하려는 경우 도움이 될 수 있습니다. 그러나 Docker와 Podman 사이에 동작에 차이가 있을 수 있으므로 docker alias를 Podman과 함께 사용할 때 작업 흐름을 충분히 테스트해야 합니다.\n\n```js\n# list images with docker alias\n❯❯ docker images\nREPOSITORY                           TAG             IMAGE ID      CREATED       SIZE\ndocker.io/library/postgres           latest          61d0571c2f7b  2 weeks ago   368 MB\ndocker.io/hashicorp/envconsul        0.13.0          42307d16e023  8 months ago  18.7 MB\ndocker.io/library/vault              \u003cnone\u003e          aac433bb6835  2 years ago   147 MB\n\n# list containers\n❯❯ docker ps\nCONTAINER ID  IMAGE                              COMMAND     CREATED        STATUS        PORTS                   NAMES\n6ee93adb00d1  docker.io/library/postgres:latest  postgres    4 minutes ago  Up 4 minutes  0.0.0.0:5432-\u003e5432/tcp  postgres\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 4. Podman REST API에 액세스하기\n\npodman.sock은 Podman 데몬이 Podman 클라이언트로부터 요청을 수신하기 위해 사용하는 유닉스 도메인 소켓입니다. Podman 명령을 실행할 때 Podman 클라이언트는 podman.sock 소켓을 통해 Podman 데몬에 요청을 보내고, 데몬은 요청을 처리하고 클라이언트에 응답을 보냅니다. 기본적으로 podman.sock 소켓은 Podman이 실행 중인 기기에서 로컬로만 액세스할 수 있습니다. 그러나 socat을 사용하여 podman.sock 소켓을 TCP 소켓에 바인딩하여 HTTP REST API를 통해 Podman에 원격 액세스할 수 있도록 설정할 수 있습니다.\n\n다음 예제에서는 podman.sock 유닉스 소켓을 socat을 사용하여 TCP 포트 2375에 바인딩하는 방법을 보여줍니다. 이를 통해 호스트 기기에서 이 포트에 연결하고 podman REST API를 외부에 노출시킬 수 있습니다. 설정이 완료되면 REST 클라이언트가 포트 2375에 연결하여 Podman REST API에 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 5. ARM64 CPU 아키텍처 이미지 실행하기\n\nPodman을 사용하여 컨테이너 이미지를 실행할 때, 컨테이너는 호스트 머신과 동일한 CPU 아키텍처에서 실행됩니다. 즉, 호스트 머신이 ARM64 CPU 아키텍처를 가지고 있다면, Podman은 ARM64 아키텍처를 사용하여 컨테이너를 실행합니다. 만약 호스트 머신이 AMD64 또는 x86 아키텍처를 가지고 있다면, 컨테이너는 해당 아키텍처로 실행됩니다.\n\n주의할 점은 호스트 머신의 아키텍처와 다른 아키텍처의 컨테이너 이미지를 실행하려고 한다면, Podman이 해당 컨테이너를 실행할 수 없다는 것입니다. 예를 들어, AMD64 또는 x86 아키텍처를 가진 호스트 머신에서 ARM64 컨테이너 이미지를 실행하려고 하면, Podman은 해당 컨테이너를 실행할 수 없습니다.\n\n이 제한을 극복하기 위해, multi-architecture 컨테이너 이미지를 사용할 수 있습니다. 이러한 이미지에는 여러 CPU 아키텍처의 이진 파일과 라이브러리가 포함되어 있어, 동일한 이미지가 다른 아키텍처의 머신에서 실행될 수 있습니다. Docker와 Podman은 모두 multi-architecture 이미지를 지원합니다. multi-architecture 이미지를 가져올 때, Podman은 자동으로 호스트 머신에 맞는 올바른 아키텍처를 선택하고 해당 아키텍처로 컨테이너를 실행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nmquery 도구를 사용하면 공개 컨테이너 저장소의 모든 공개 이미지를 쿼리하여 미디어 유형, 다이제스트 및 플랫폼 지원을 확인할 수 있습니다. 또한 도커 이미지의 사용 가능한 CPU 아키텍처를 확인하는 데 사용할 수 있습니다. 이 도구는 estesp/mquery라는 이름의 Docker 이미지로 제공됩니다. 해당 이미지를 실행하여 어떤 도커 이미지의 CPU 아키텍처를 확인할 수 있습니다. 결과에는 이미지를 지원하는 플랫폼이 표시되며, 해당 아키텍처, 운영 체제 및 버전이 포함됩니다. 시스템의 CPU 아키텍처와 호환되는지 확인하는 데 유용할 수 있습니다.\n\n```js\n# postgres:latest 이미지의 사용 가능한 CPU 아키텍처 보기\n# postgres:latest 이미지는 arm64를 포함한 모든 CPU 아키텍처로 제공됩니다\n# macOS M1에서 postgres:latest를 실행하는 경우 arm64 이미지가 선택됩니다\n❯❯ docker run --rm mplatform/mquery postgres:latest\nImage: postgres:latest (digest: sha256:50a96a21f2992518c2cb4601467cf27c7ac852542d8913c1872fe45cd6449947)\n * Manifest List: Yes (Image type: application/vnd.docker.distribution.manifest.list.v2+json)\n * Supported platforms:\n   - linux/amd64\n   - linux/arm/v5\n   - linux/arm/v7\n   - linux/arm64/v8\n   - linux/386\n   - linux/mips64le\n   - linux/ppc64le\n   - linux/s390x\n\n# 실행 중인 postgres:latest 이미지의 CPU 아키텍처 보기\n# macOS M1에서 postgres:latest를 실행하는 경우 arm64 이미지가 선택됩니다\n❯❯ docker image inspect postgres:latest | grep Architecture\n          \"Architecture\": \"arm64\",\n```\n\n## 6. AMD64 CPU 아키텍처 이미지 실행\n\nPodman에서 AMD64와 같은 다른 CPU 아키텍처용으로 빌드된 도커 이미지를 macOS M1/M2 ARM64 CPU에 실행하려고 하면 에러가 발생하여 실패할 것입니다. 이는 이미지가 호스트 머신의 CPU 아키텍처와 호환되지 않기 때문입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# mysql:8.0.23은 amd64 아키텍처 이미지만 사용 가능합니다\n❯❯ docker run --rm mplatform/mquery mysql:8.0.23\n이미지: mysql:8.0.23 (다이제스트: sha256:6e0014cdd88092545557dee5e9eb7e1a3c84c9a14ad2418d5f2231e930967a38)\n * Manifest List: Yes (이미지 유형: application/vnd.docker.distribution.manifest.list.v2+json)\n * 지원하는 플랫폼:\n   - linux/amd64\n\n# mac m1 arm64 머신에서 mysql:8.0.23 실행 시 발생하는 오류입니다\n❯❯ docker run mysql:8.0.23\n\"mysql\"을 미지정 검색 레지스트리를 사용하여 해석 중 (/etc/containers/registries.conf.d/999-podman-machine.conf)\ndocker.io/library/mysql:8.0.23에서 가져오려고 시도 중...\n오류: 아키텍처 arm64, 변형 \"v8\", OS linux에 대한 매니페스트 목록에서 이미지를 찾을 수 없음\n\n그러나 Podman은 이 문제에 대한 다중 아키텍처 지원으로 해결책을 제공합니다. --arch 옵션을 사용하여 실행하려는 플랫폼을 지정할 수 있고, 해당 플랫폼에 대해 사용 가능한 경우 Podman은 자동으로 이미지의 올바른 버전을 가져옵니다. 이를 통해 macOS M1/M2 ARM64 CPU에서 다른 CPU 아키텍처용 이미지를 문제 없이 실행할 수 있습니다.\n\n# amd64 아키텍처를 지정하여 mysql 이미지 실행\n# 그럼 podman은 amd64 아키텍처로 docker 이미지를 가져와 실행합니다\n❯❯ docker run --arch=amd64 mysql:8.0.23\n\"mysql\"을 미지정 검색 레지스트리를 사용하여 해석 중 (/etc/containers/registries.conf.d/999-podman-machine.conf)\ndocker.io/library/mysql:8.0.23에서 가져오려고 시도 중...\n이미지 소스 서명 가져옴\nblob sha256:15f235e0d7eefe6c5153946a57daebaf2d0744fb1d0676642f269554fc68ba2a 복사 중\n(중략)\nconfig sha256:cbe8815cbea8fb86ce7d3169a82d05301e7dfe1a8d4228941f23f4f115a887f2 복사 중\n이미지 목적지에 매니페스트 쓰는 중\n서명 저장 중\n2023-03-18 01:58:56+00:00 [Note] [Entrypoint]: MySQL Server 8.0.23-1debian10용 입구점 스크립트 시작됨.\n(중략)\n2023-03-18 01:58:57+00:00 [ERROR] [Entrypoint]: 데이터베이스가 초기화되지 않았으며 암호 옵션이 지정되지 않았습니다\n    다음 중 하나를 지정해야 합니다:\n    - MYSQL_ROOT_PASSWORD\n    - MYSQL_ALLOW_EMPTY_PASSWORD\n    - MYSQL_RANDOM_ROOT_PASSWORD\n\n--arch 옵션이 작동하지 않는 경우, multiarch/qemu-user-static을 사용한 해결책이 있습니다. 이 글에서 그 해결책에 대해 자세히 설명합니다.\n``` \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\npodman machine ssh\nsudo -i\nrpm-ostree install qemu-user-static\nsystemctl reboot\r\n```\n\n## 7. 다른 CPU 아키텍처로 이미지 빌드하기\n\nPodman으로 이미지를 빌드할 때 --arch 플래그를 사용하여 이미지에 원하는 CPU 아키텍처를 선택할 수 있습니다. 기본적으로 Podman은 실행 중인 기기의 CPU 아키텍처를 사용합니다. 이를 통해 Podman을 사용하여 멀티 아키텍처 이미지를 빌드할 수 있으며, 동일한 응용 프로그램을 다양한 CPU 아키텍처에서 실행하는 데 유용할 수 있습니다. 아래는 다른 아키텍처 이미지를 빌드하는 데 사용되는 예시 golang 응용프로그램(main.go)과 Dockerfile입니다.\n\n```js\r\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n fmt.Println(\"vim-go\")\n}\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\nFROM golang:1.16-alpine as builder\nWORKDIR /app\nCOPY . .\n\nRUN go build -o main *.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [ \"./main\" ]\r\n```\n\nAMD64 아키텍처를 사용하여 이미지를 빌드하려면 Podman을 사용하여 다음 명령을 --arch=amd64 매개변수와 함께 사용할 수 있습니다. 이는 AMD64 아키텍처 기본 이미지를 사용하고 그 위에 새 이미지를 빌드합니다.\n\n```js\r\n# amd64 cpu 아키텍처로 도커 이미지 빌드\n# 빌드할 때 주어진 cpu 아키텍처의 기반 이미지 및 라이브러리를 가져옵니다\n❯❯ docker build --arch=amd64 --rm -t erangaeb/hello .\n[1/2] 단계 1/4: FROM golang:1.16-alpine AS builder\n\"golang\"를 unqualified-search 레지스트리(../../containers/registries.conf.d/999-podman-machine.conf)를 사용하여 해석 중\ndocker.io/library/golang:1.16-alpine를 가져오려는 중...\n이미지 소스 서명 가져오는 중\nblob sha256:0435e09637941e35cccdf9cf9171571811d2fdfe72c27e39543a718d38d28668 복사 중\nblob sha256:59bf1c3509f33515622619af21ed55bbe26d24913cedbca106468a5fb37a50c3 복사 중\nblob sha256:666ba61612fd7c93393f9a5bc1751d8a9929e32d51501dba691da9e8232bc87b 복사 중\nblob sha256:8ed8ca4862056a130f714accb3538decfa0663fec84e635d8b5a0a3305353dee 복사 중\nblob sha256:ca4bf87e467a8cacf62c9b01c7d6d43f6ca4bb9b0fc9146fbb906b05aee56cc1 복사 중\nconfig sha256:7642119cd16177d874dcbfe1c550affd336dbe4cabb3339ef685ac1d6ec71ccc 복사 중\n이미지 목적지에 매니페스트 작성 중\n서명 저장 중\n[1/2] 단계 2/4: WORKDIR /app\n--\u003e 캐시 푸시 []:220abc07870fcc2e449b7b03384b2e4c219f7c32b28546f90067c1488ea63ba0\n--\u003e 663c9d6f7ea\n[1/2] 단계 3/4: COPY . .\n--\u003e 캐시 푸시 []:e7db7815e4762b218ab81c3f93cdf789c4961c783825470c3c2edb55000b1844\n--\u003e ce3d882f4c8\n[1/2] 단계 4/4: RUN go build -o main *.go\n--\u003e 캐시 푸시 []:95b5a69b661a646895b2a2bc6b313e0f5fd2cc83a4d7dcd1e5f2594be34c3d4d\n--\u003e 54d84331cf2\n사용자 정의 erangaeb/hello 이미지가 성공적으로 빌드되었습니다\nc1329ead22a2cf66cd4a47b06aa0d406aba34798d26e79d666e1d855cd920028\n\n# 이미지 실행\n# 이미지를 arm64 cpu로 빌드한 후 --arch=amd64를 명시해야 함\n# 그렇지 않으면 amd64 cpu 아키텍처 이미지를 가져와 실패할 것입니다\n❯❯ docker run --arch=amd64 localhost/erangaeb/hello\n경고: 이미지 플랫폼(리눅스/amd64)이 예상 플랫폼(리눅스/arm64)과 일치하지 않습니다\nvim-go\r\n```\n\n다음은 Podman을 사용하여 arm64 아키텍처로 이미지를 빌드하는 예제 명령입니다. 이 명령은 --arch 플래그를 사용하여 ARM64 아키텍처를 지정합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# arm64 CPU 아키텍처로 도커 이미지 빌드\n❯❯ docker build --arch=arm64 --rm -t erangaeb/hello:arm64 .\n[1/2] 단계 1/4: golang:1.16-alpine을 빌드 중\n... (중략) ...\n[2/2] 단계 1/4: alpine:latest으로 빌드 중\n... (중략) ...\nerangaeb/hello:arm64 이미지 구축 완료\n4d98d25ec13db2b9c25c149a0c3f5996829029026a6fd295e55c78acc9cef89e\n\n# arm64 이미지 실행\n# CPU 아키텍처와 일치하여 경고 없이 실행됩니다.\n❯❯ docker run localhost/erangaeb/hello:arm64\nvim-go\n```\n\n## 8. 쿠버네티스 클러스터 실행\n\n로컬 쿠버네티스 클러스터를 생성하기 위해 Kind와 Podman을 함께 사용했습니다. Kind는 로컬 머신에서 도커 컨테이너로 작동하는 클러스터 노드로서 쿠버네티스 클러스터를 운영할 수 있게 해주는 오픈소스 도구입니다. 아래는 Podman을 활용하여 Kind 클러스터를 설정하는 단계입니다.\n\n```js\n# asdf를 사용하여 kind 설치\n❯❯ asdf plugin add kind\n❯❯ asdf install kind 0.17.0\n❯❯ asdf global kind 0.17.0\n\n# ~/.zshrc 파일에 아래 구성 추가하여 rootless podman으로 kind 실행\nKIND_EXPERIMENTAL_PROVIDER=podman\n\n# 클러스터 생성\n# 클러스터 이름은 'kind'로 지정됩니다.\n❯❯ kind create cluster \n\n# kubectl 컨텍스트인 kind-kind가 추가됩니다.\n❯❯ kubectl config get-contexts\n... (중략) ...\n\n# kind 클러스터 조회\n❯❯ kind get clusters\n... (중략) ...\n\n# 클러스터 노드에 이미지 로드\n# 비공개 도커 레지스트리(예: Google Container Registry/GCR)에 있는 이미지 실행에 도움이 됩니다.\n❯❯ kind load docker-image eu.gcr.io/rahasak-build/lambdaops:1.0\n\n# kind-kind 컨텍스트로 kind 클러스터 사용\n❯❯ kubectl --context=kind-kind get pods\n\n# 클러스터 삭제\n❯❯ kind delete cluster\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 9. Google Container Registry 인증\n\nGoogle Container Registry(GCR)와 통합하고 싶을 수 있습니다. 이는 Google Cloud가 제공하는 Docker 이미지를 저장하고 관리하는 호스팅 서비스입니다. GCR 문서에는 Docker와의 인증에 대한 훌륭한 안내가 제공됩니다. 첫 번째 인증 방법은 gcloud 자격 증명 도우미를 사용하는 것인데, 이는 gcloud CLI를 사용하여 Cloud Shell 또는 Google Cloud CLI가 설치된 모든 환경에서 인증을 구성합니다. Docker의 gcloud 자격 증명 도우미 방법을 통해 한 번 인증을 받으면 같은 인증 방법을 Podman에서도 사용할 수 있습니다. 먼저 Google Cloud 계정으로 gcloud auth login 명령을 실행하여 인증하십시오. 다음으로, gcloud auth configure-docker `registry host` 명령을 사용하여 Docker가 GCR과 인증하도록 구성하십시오. 이 작업이 완료되면 Podman은 Docker 자격 증명을 재사용할 수 있습니다.\n\n```js\n# 웹 플로우를 통해 gcloud 서비스에 로그인\n❯❯ gcloud auth login\n\n# 자격 증명을 ~/.config/gcloud/credentials.db SQLite 데이터베이스에 저장합니다\n❯❯ sqlite3 credentials.db \"SELECT value FROM credentials\"\n{\n  \"client_id\": \"\u003cid\u003e.apps.googleusercontent.com\",\n  \"client_secret\": \"\u003csecret\u003e\",\n  \"refresh_token\": \"\u003ctoken\u003e\",\n  \"revoke_uri\": \"https://accounts.google.com/o/oauth2/revoke\",\n  \"scopes\": [\n    \"openid\",\n    \"https://www.googleapis.com/auth/userinfo.email\",\n    \"https://www.googleapis.com/auth/cloud-platform\",\n    \"https://www.googleapis.com/auth/appengine.admin\",\n    \"https://www.googleapis.com/auth/sqlservice.login\",\n    \"https://www.googleapis.com/auth/compute\",\n    \"https://www.googleapis.com/auth/accounts.reauth\"\n  ],\n  \"token_uri\": \"https://oauth2.googleapis.com/token\",\n  \"type\": \"authorized_user\"\n}\n\n# Docker가 GCR과 인증하도록 구성\n# 그럼 Podman이 해당 자격 증명을 재사용할 수 있습니다\n# 명령어\n❯❯ gcloud auth configure-docker \u003cregistry host\u003e\n\n# 예시\n❯❯ gcloud auth configure-docker eu.gcr.io\nAdding credentials for: eu.gcr.io\n업데이트 후 다음이 Docker 구성 파일에 작성될 것입니다\n[/Users/lambda.eranga/.docker/config.json]:\n {\n  \"credHelpers\": {\n    \"eu.gcr.io\": \"gcloud\"\n  }\n}\n계속하시겠습니까 (Y/n)?  Y\n\n# 원하는 경우 더 많은 레지스트리 호스트를 추가할 수 있습니다\n❯❯ gcloud auth configure-docker europe-docker.pkg.dev\n❯❯ gcloud auth configure-docker europe-north1-docker.pkg.dev\n\n# 생성된 구성은 홈 디렉토리 ~/.docker/config.json에 저장됩니다\n❯❯ cat ~/.docker/config.json\n{\n  \"credHelpers\": {\n    \"eu.gcr.io\": \"gcloud\",\n    \"europe-docker.pkg.dev\": \"gcloud\",\n    \"europe-north1-docker.pkg.dev\": \"gcloud\"\n  }\n}\n\n# 이제 Podman은 Docker 자격 증명을 사용하여 credential helper gcloud를 통해 GCR에 접근할 수 있습니다\n❯❯ docker pull eu.gcr.io/rahasak-build/aplos:0.1 --log-level=debug\nINFO[0000] podman filtering at log level debug\n⋮\n```\n\n이전 방법은 Podman이 Docker GCR 인증 구성을 사용하여 Google Container Registry와 인증하는 방법을 설명했습니다. 그러나 Podman은 직접 컨테이너 레지스트리에 로그인하기 위한 podman login이라는 명령도 제공합니다. 이 명령은 Container Registry와 함께 사용할 수 있는 단기간의 OAuth 액세스 토큰을 사용하여 인증합니다. 이 토큰은 60분 동안만 유효하므로 Container Registry에 연결하기 전 1시간 이전에 요청해야 합니다. 토큰이 만료되면 다시 로그인해야 하며, 그렇지 않으면 권한 없음: 인증 실패 오류가 발생할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\n# 웹 플로우를 통해 gcloud 서비스에 로그인해주세요\n❯❯ gcloud auth login\n\n# 이전에 생성된 도커 자격 증명을 제거해주세요\n❯❯ rm -rf ~/.docker\n\n# 짧게 유지되는 액세스 토큰을 생성하고 sqlite db ~/.config/gcloud/access_tokens.db에 저장됩니다\n❯❯ sqlite3 access_tokens.db \"select * from access_tokens\"\n\n# 액세스 토큰 확인\n❯❯ gcloud auth print-access-token\n\n# 액세스 토큰으로 gcr에 로그인\n# 이렇게 짧게 유지되는 OAuth 액세스 토큰을 사용하여 Container Registry와 인증합니다. \n# 토큰은 60분 동안 유효하며, Container Registry에 연결하기 전에 한 시간 이내에 요청해야 합니다.\n# 토큰 만료 시, 아래 명령어를 다시 실행하고 다시 로그인해야 합니다. 그렇지 않으면 권한이 없음: 인증 실패 오류가 발생합니다.\n❯❯ gcloud auth print-access-token | podman login -u oauth2accesstoken --password-stdin eu.gcr.io\n\n# ~/.config/containers/auth.json에 인증 파일이 생성됩니다\n❯❯ cat .config/containers/auth.json\n```\n{\n \"auths\": {\n  \"eu.gcr.io\": {\n   \"auth\": \"\u003c액세스 토큰\u003e\"\n  }\n }\n}\n\n# 이제 podman은 docker 자격 증명을 사용하여 gcr에 액세스할 수 있습니다(자격 증명 도우미 gcloud 사용)\n❯❯ docker pull eu.gcr.io/rahasak-build/aplos:0.1 --log-level=debug\nINFO[0000] log level debug에서 podman 필터링\nDEBU[0000] pull.PersistentPreRunE(podman pull eu.gcr.io/rahasak-build/aplos:0.1 --log-level=debug) 호출\nDEBU[0000] DoRequest 메서드: GET URI: http://d/v4.4.2/libpod/_ping\nDEBU[0000] \"/etc/containers/registries.conf\"에서 레지스트리 구성로드\nDEBU[0000] 자격 증명 도우미 containers-auth.json에서 /Users/lambda.eranga/.config/containers/auth.json 파일의 eu.gcr.io 자격 증명 찾음\nDEBU[0000] DoRequest 메서드: POST URI: http://d/v4.4.2/libpod/images/pull\neu.gcr.io/rahasak-build/aplos:0.1 끌어오기 시도 중...\n이미지 소스 서명 가져오는 중\nblob sha256:9fa0fafc404b18044192115d295424237056a9296da9fe07f3f493f714d7c6fb 복사 중\nblob sha256:b9fd7cb1ff8f489cf082781b0e1fe0c13b840e20147e8fc8204b4592da7c2f70 복사 중\nblob sha256:f25ad21146dc80e14a651d9f59707ccab21bd3749aee1177faf72329661f19eb 복사 중\nblob sha256:e92ed755c008afc1863a616a5ba743b670c09c1698f7328f05591932452a425f 복사 중\nblob sha256:53e3366ec435596bed2563cc882ba47ec25df6be2b1027e3243e83589c667c1e 복사 중\nblob sha256:ee690f2d57a128744cf4c5b52646ad0ba7a5af113d9d7e0e02b62c06d35fd14c 복사 중\nblob sha256:e83609f677899ddd7e01f03fd3f797d98fb18e3307a236b55b218a59f5cf7b9b 복사 중\nblob sha256:88c7c603b3faedd122305543eb17d6968a16399c7a93f67b3486196b2440c846 복사 중\n\n# 로그인 취소\n❯❯ podman logout eu.gcr.io\r\n\n\n# 참고\n\n- https://medium.com/rahasak/replace-docker-desktop-with-minikube-and-hyperkit-on-macos-783ce4fb39e3\r\n- https://dev.to/docker/choosing-the-right-docker-image-for-your-apple-m1-pro-440l\r\n- https://zenn.dev/sbk0716/articles/d9235b78b97615\r\n- https://itnext.io/using-minikube-on-m1-macs-416da593ba0c\r\n- https://itnext.io/goodbye-docker-desktop-hello-minikube-3649f2a1c469\r\n- https://0to1.nl/post/minikube-m1-pro-issues/\r\n- https://www.redhat.com/sysadmin/podman-python-bash\r\n- https://edofic.com/posts/2021-09-12-podman-m1-amd64/\r\n- https://xphyr.net/post/podman_on_osx/\r\n- https://www.redhat.com/sysadmin/specify-architecture-pulling-podman-images\r\n- https://itnext.io/kubernetes-kind-cheat-shee-2605da77984\r\n","ogImage":{"url":"/assets/img/2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU_0.png"},"coverImage":"/assets/img/2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU_0.png","tag":["Tech"],"readingTime":23},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e친절한 쿠버네티스 클러스터와 함께\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e배경\u003c/h1\u003e\n\u003cp\u003e이전 글에서는 macOS에서 이전 AMD64 아키텍처 기반 머신에 Minikube와 Hyperkit을 사용하여 Docker Desktop을 대체하는 방법에 대해 논의했습니다. 그러나 ARM64 아키텍처 CPU를 사용하는 새로운 M1/M2 머신이 등장하면서 Hyperkit은 이러한 새로운 머신과 호환되지 않습니다. 이 문제를 해결하기 위해 macOS M1/M2 머신에서 Docker Desktop을 Podman으로 대체하고 Kind를 사용하여 쿠버네티스 로컬 클러스터를 생성했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003emacOS M1/M2 ARM64 아키텍처\u003c/h1\u003e\n\u003cp\u003emacOS M1/M2는 최신 Apple 맥인토시 컴퓨터 라인으로, ARM64 아키텍처를 기반으로 합니다. ARM64 아키텍처는 컴퓨팅 세계에서 점차 인기를 끌고 있는 새로운 유형의 프로세서 아키텍처입니다. 대부분의 데스크톱 및 랩톱 컴퓨터에서 사용되는 전통적인 x86 아키텍처와 비교하면, ARM64 아키텍처는 저전력을 위해 설계되었으며 모바일 기기용으로 최적화되어 있습니다.\u003c/p\u003e\n\u003cp\u003eARM64 아키텍처의 주요 장점 중 하나는 와트 당 성능 향상입니다. 이는 ARM64 아키텍처를 기반으로 한 컴퓨터가 더 적은 전력을 사용하면서도 유사하거나 더 나은 성능을 제공할 수 있음을 의미합니다. 이는 노트북의 배터리 수명 연장 및 데스크탑의 에너지 소비 감소로 이어질 수 있습니다. 또한, ARM64 아키텍처는 머신러닝과 같은 특정 작업을 위한 하드웨어 가속화와 같은 기능을 포함하고 있어, 이러한 작업 부하의 성능을 향상시킬 수 있습니다.\u003c/p\u003e\n\u003cp\u003eAMD64/x86 인텔 아키텍처와 비교하면, ARM64 아키텍처는 더 새롭고 확립되지 않은 아키텍처입니다. AMD64/x86은 많은 해 동안 주도적인 아키텍처이지만, ARM64는 특히 모바일 기기와 서버에서 더 많은 인기를 얻고 있습니다. 그러나 ARM64 아키텍처에 대한 더 많은 응용 프로그램과 소프트웨어의 최적화가 이루어지면, 앞으로 더 많은 ARM64 기반 컴퓨터를 볼 수 있을 것입니다. 성능 측면에서, ARM64 아키텍처는 특정 작업 부하에 대해 AMD64/x86 아키텍처와 비교 가능하거나 더 빠를 수 있지만, 이는 구체적인 사용 사례 및 소프트웨어 최적화에 따라 다를 수 있습니다. 최종적으로 두 아키텍처 모두 강점과 약점을 가지고 있으며, 그것들 사이의 선택은 사용자나 조직의 구체적인 요구 사항에 달려 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e맥OS M1/M2 기기는 ARM64 아키텍처에서 실행되도록 특별히 설계되었으며, 이 아키텍처에 최적화된 소프트웨어와 도구가 필요하여 효율적으로 실행할 수 있습니다. x86 아키텍처에서 실행되도록 설계된 일부 소프트웨어는 macOS M1/M2 기기에서 제대로 작동하지 않을 수 있으므로, 개발자와 사용자는 호환성과 최적 성능을 보장하기 위해 ARM64 아키텍처용 도구와 소프트웨어를 사용해야 합니다.\u003c/p\u003e\n\u003ch1\u003eDocker Desktop\u003c/h1\u003e\n\u003cp\u003emacOS에서 Docker Desktop은 Docker 컨테이너를 사용하여 애플리케이션을 쉽게 빌드, 테스트 및 배포할 수 있도록 합니다. 컨테이너, 이미지 및 네트워크를 관리하기 위한 간단하고 사용자 친화적인 인터페이스를 제공하며, 다양한 플랫폼 및 운영 체제에서 사용할 수 있습니다. ARM64 아키텍처 기반의 최신 macOS M1/M2 기기가 출시된 가운데, Docker는 ARM64 아키텍처에 최적화된 새로운 Docker Desktop 버전을 출시했습니다. 이 버전은 Apple의 Hypervisor.framework를 활용하여 가상화 환경에서 컨테이너를 실행하며, 이를 통해 Docker Desktop을 사용하는 개발자와 IT 전문가에게 매끄러운 경험을 제공합니다.\u003c/p\u003e\n\u003cp\u003eDocker Desktop은 컨테이너화에 강력한 도구를 제공하지만, 단점도 있습니다. Docker Desktop 사용의 주요 단점 중 하나는 백그라운드에서 실행되는 별도의 데몬 프로세스를 필요로 한다는 점인데, 이는 상당한 시스템 리소스를 소비할 수 있습니다. 또한, Docker Desktop은 일부 애플리케이션 및 운영 체제와 가끔 호환성 문제가 있어 사용자들에게 다운타임과 귀찮음을 초래할 수 있습니다. 게다가, 최근 Docker Desktop의 라이선스 요구사항 변경으로 많은 사용자가 대안을 찾고 있습니다. 결과적으로, Podman과 같은 대체 솔루션들이 이 기기에서 컨테이너화 요구를 충족하는 데 더 인기를 얻고 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003ePodman\u003c/h1\u003e\n\u003cp\u003ePodman은 빌드, 관리 및 실행을 위한 Docker의 대체제로 제공되는 인기 있는 컨테이너 관리 도구입니다. ARM64 아키텍처 기반의 새로운 macOS M1/M2 기계가 출시되면서, Podman은 컨테이너화 요구 사항에 대한 Docker Desktop의 대안으로 나타나고 있습니다.\u003c/p\u003e\n\u003cp\u003ePodman은 ARM64 아키텍처에 최적화되어 개발자와 IT 전문가들에게 뛰어난 경험을 제공합니다. Docker와 달리, Podman은 Linux 커널의 컨테이너화 기능을 사용하므로 별도의 백그라운드 데몬 프로세스가 실행되어야 하는 필요가 없습니다. 이는 성능 향상과 리소스 소비의 감소로 이어질 수 있습니다.\u003c/p\u003e\n\u003cp\u003emacOS M1/M2 기계에서 Podman을 사용하는 주요 이점 중 하나는 가상 머신을 사용하지 않아도 된다는 점입니다. 대신, Podman은 ARM64 아키텍처의 네이티브 컨테이너화 기능을 활용하여 더 효율적이고 간소화된 경험을 제공합니다. Podman은 ARM64 아키텍처를 기반으로 하는 macOS M1/M2 기계에서 Docker Desktop에 대한 유망한 대안입니다. 최적화된 성능과 간소화된 컨테이너화 기능을 갖춘 Podman은 이러한 기계에서 컨테이너를 빌드, 관리 및 실행해야 하는 개발자와 IT 전문가들에게 강력한 도구를 제공합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e새로운 macOS M1/M2 기기에서 ARM64 아키텍처를 사용하는 Podman을 설정하는 가이드입니다. 이를 통해 더 가벼우면서도 효율적인 컨테이너화 도구로 Docker 및 Docker Desktop을 대체할 수 있습니다.\u003c/p\u003e\n\u003ch2\u003e1. Podman 설치 및 구성\u003c/h2\u003e\n\u003cp\u003emacOS에는 Homebrew 패키지 관리자를 사용하여 Podman을 설치할 수 있습니다. 설치한 후, Podman을 루트 없는 컨테이너와 함께 사용할 수 있도록 구성할 수 있습니다. 이때 주의해야 할 점은 Linux 시스템과는 달리 macOS(그리고 Windows)에서는 Podman 사용 시 가상 머신을 사용해야 한다는 것입니다. 가상 머신은 QEMU 에뮬레이터를 사용하여 Linux 런타임 환경을 제공합니다. MacOS와 Windows는 Podman이 의존하는 Linux 네임스페이스 및 cgroups를 네이티브로 지원하지 않기 때문입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-title class_\"\u003ePodman\u003c/span\u003e 설치\n❯❯ brew install podman\n\n# 새로운 \u003cspan class=\"hljs-title class_\"\u003eLinux\u003c/span\u003e 런타임 환경 초기화 (이를 \u003cspan class=\"hljs-string\"\u003e'podman machine'\u003c/span\u003e이라고 합니다)\n# \u003cspan class=\"hljs-title class_\"\u003ePodman\u003c/span\u003e은 quem 에뮬레이터를 사용하여 \u003cspan class=\"hljs-title class_\"\u003eLinux\u003c/span\u003e 런타임 환경을 제공합니다\n# --cpus \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e 코어 수 지정)\n# --memory=\u003cspan class=\"hljs-number\"\u003e6144\u003c/span\u003e (메모리 용량 지정)\n❯❯ podman machine init --cpus \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e --memory=\u003cspan class=\"hljs-number\"\u003e6144\u003c/span\u003e\n\n# \u003cspan class=\"hljs-title class_\"\u003ePodman\u003c/span\u003e 머신 목록 표시\n# 기본 \u003cspan class=\"hljs-title class_\"\u003ePodman\u003c/span\u003e 머신은 \u003cspan class=\"hljs-string\"\u003e`podman-machine-default*`\u003c/span\u003e입니다\n❯❯ podman machine ls\n\u003cspan class=\"hljs-variable constant_\"\u003eNAME\u003c/span\u003e                     \u003cspan class=\"hljs-variable constant_\"\u003eVM\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTYPE\u003c/span\u003e     \u003cspan class=\"hljs-variable constant_\"\u003eCREATED\u003c/span\u003e     \u003cspan class=\"hljs-variable constant_\"\u003eLAST\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eUP\u003c/span\u003e     \u003cspan class=\"hljs-variable constant_\"\u003eCPUS\u003c/span\u003e        \u003cspan class=\"hljs-variable constant_\"\u003eMEMORY\u003c/span\u003e      \u003cspan class=\"hljs-variable constant_\"\u003eDISK\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSIZE\u003c/span\u003e\npodman-machine-\u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e*  qemu        \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e days ago  \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e days ago  \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e           \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e147GB     \u003cspan class=\"hljs-number\"\u003e107.\u003c/span\u003e4GB\n\n# 런타임 시작\n# \u003cspan class=\"hljs-title class_\"\u003ePodman\u003c/span\u003e은 /\u003cspan class=\"hljs-title class_\"\u003eUsers\u003c/span\u003e, \u003cspan class=\"hljs-regexp\"\u003e/private, /\u003c/span\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e/folders 디렉터리에 볼륨 매핑을 사용합니다\n❯❯ podman machine start\n\u003cspan class=\"hljs-string\"\u003e\"podman-machine-default\"\u003c/span\u003e 머신 시작 중\n\u003cspan class=\"hljs-variable constant_\"\u003eVM\u003c/span\u003e 대기 중...\n볼륨 마운트... /\u003cspan class=\"hljs-title class_\"\u003eUsers\u003c/span\u003e:/\u003cspan class=\"hljs-title class_\"\u003eUsers\u003c/span\u003e\n볼륨 마운트... /\u003cspan class=\"hljs-attr\"\u003eprivate\u003c/span\u003e:/private\n볼륨 마운트... /\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e/\u003cspan class=\"hljs-attr\"\u003efolders\u003c/span\u003e:\u003cspan class=\"hljs-regexp\"\u003e/var/\u003c/span\u003efolders\n\n현재 이 머신은 루트 없는 모드로 구성되어 있습니다. 컨테이너에 루트 권한이 필요한 경우(예: 포트 \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e) 또는 비-\u003cspan class=\"hljs-title class_\"\u003ePodman\u003c/span\u003e 클라이언트와의 호환성 문제가 발생한 경우, 다음 명령을 사용하여 전환할 수 있습니다:\n\n podman machine set --rootful\n\n\u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e 전달 \u003cspan class=\"hljs-title class_\"\u003eListening\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/Users/\u003c/span\u003elambda.\u003cspan class=\"hljs-property\"\u003eeranga\u003c/span\u003e/.\u003cspan class=\"hljs-property\"\u003elocal\u003c/span\u003e/share/containers/podman/machine/podman-machine-\u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e/podman.\u003cspan class=\"hljs-property\"\u003esock\u003c/span\u003e\n\n시스템 도우미 서비스가 설치되어 있지 않습니다; podman에서는 기본 \u003cspan class=\"hljs-title class_\"\u003eDocker\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e 소켓 주소를 사용할 수 없습니다. 설치하려면 다음 명령을 실행하세요:\n\n sudo /opt/homebrew/\u003cspan class=\"hljs-title class_\"\u003eCellar\u003c/span\u003e/podman/\u003cspan class=\"hljs-number\"\u003e4.4\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.2\u003c/span\u003e/bin/podman-mac-helper install\n podman machine stop; podman machine start\n\n터미널 세션에서 다음 몤령을 사용하여 여전히 \u003cspan class=\"hljs-title class_\"\u003eDocker\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAPI\u003c/span\u003e 클라이언트에 연결할 수 있습니다:\n\n \u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDOCKER_HOST\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e'unix:///Users/lambda.eranga/.local/share/containers/podman/machine/podman-machine-default/podman.sock'\u003c/span\u003e\n\n\u003cspan class=\"hljs-string\"\u003e\"podman-machine-default\"\u003c/span\u003e 머신이 성공적으로 시작되었습니다\npodman machine start\n\n# \u003cspan class=\"hljs-title class_\"\u003ePodman\u003c/span\u003e 머신이 실행 중\n❯❯ podman machine ls\n\u003cspan class=\"hljs-variable constant_\"\u003eNAME\u003c/span\u003e                     \u003cspan class=\"hljs-variable constant_\"\u003eVM\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTYPE\u003c/span\u003e     \u003cspan class=\"hljs-variable constant_\"\u003eCREATED\u003c/span\u003e     \u003cspan class=\"hljs-variable constant_\"\u003eLAST\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eUP\u003c/span\u003e            \u003cspan class=\"hljs-variable constant_\"\u003eCPUS\u003c/span\u003e        \u003cspan class=\"hljs-variable constant_\"\u003eMEMORY\u003c/span\u003e      \u003cspan class=\"hljs-variable constant_\"\u003eDISK\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSIZE\u003c/span\u003e\npodman-machine-\u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e*  qemu        \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e days ago  \u003cspan class=\"hljs-title class_\"\u003eCurrently\u003c/span\u003e running  \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e           \u003cspan class=\"hljs-number\"\u003e2.\u003c/span\u003e147GB     \u003cspan class=\"hljs-number\"\u003e107.\u003c/span\u003e4GB\n\n# 정보 확인\n❯❯ podman info\n\n# \u003cspan class=\"hljs-title class_\"\u003ePodman\u003c/span\u003e 연결\n❯❯ podman system connection ls\n\u003cspan class=\"hljs-title class_\"\u003eName\u003c/span\u003e                         \u003cspan class=\"hljs-variable constant_\"\u003eURI\u003c/span\u003e                                                         \u003cspan class=\"hljs-title class_\"\u003eIdentity\u003c/span\u003e                                          \u003cspan class=\"hljs-title class_\"\u003eDefault\u003c/span\u003e\npodman-machine-\u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e       \u003cspan class=\"hljs-attr\"\u003essh\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//core@localhost:50985/run/user/501/podman/podman.sock  /Users/lambda.eranga/.ssh/podman-machine-default  true\u003c/span\u003e\npodman-machine-\u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e-root  \u003cspan class=\"hljs-attr\"\u003essh\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//root@localhost:50985/run/podman/podman.sock           /Users/lambda.eranga/.ssh/podman-machine-default  false\u003c/span\u003e\n\n# 머신 정지\n❯❯ podman machine stop\n\n# 머신 재시작\n❯❯ podman machine stop; podman machine start\n\n# \u003cspan class=\"hljs-title class_\"\u003ePodman\u003c/span\u003e 머신에 \u003cspan class=\"hljs-variable constant_\"\u003eSSH\u003c/span\u003e 접속\n❯❯ podman machine ssh\n\n# 머신 제거\n❯❯ podman machine rm -f podman-machine-\u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e2. Podman Commands\u003c/h2\u003e\n\u003cp\u003ePodman은 Docker와 유사한 명령줄 인터페이스를 제공합니다. 사실, Podman에서 사용하는 많은 명령어는 Docker에서 사용하는 것과 동일하여 Docker에 익숙한 사용자가 Podman으로 쉽게 전환할 수 있습니다. Podman에서 다양한 명령어를 실행하려면 원하는 특정 명령어 뒤에 podman 명령어를 사용할 수 있습니다. 예를 들어, 모든 실행 중인 컨테이너를 나열하려면 podman ps 명령어를 사용할 수 있습니다. 마찬가지로 Dockerfile에서 이미지를 빌드하려면 podman build -t image_name -f Dockerfile_path와 같은 명령어를 사용할 수 있습니다. Podman은 컨테이너 시작 및 중지, 실행 중인 컨테이너에 연결 및 이미지 및 볼륨 관리와 같은 일반적인 컨테이너화 작업을 지원합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 이미지 목록\n❯❯ podman images\n\u003cspan class=\"hljs-variable constant_\"\u003eREPOSITORY\u003c/span\u003e                           \u003cspan class=\"hljs-variable constant_\"\u003eTAG\u003c/span\u003e             \u003cspan class=\"hljs-variable constant_\"\u003eIMAGE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e      \u003cspan class=\"hljs-variable constant_\"\u003eCREATED\u003c/span\u003e       \u003cspan class=\"hljs-variable constant_\"\u003eSIZE\u003c/span\u003e\ndocker.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/hashicorp/envconsul        \u003cspan class=\"hljs-number\"\u003e0.13\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e          42307d16e023  \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e months ago  \u003cspan class=\"hljs-number\"\u003e18.7\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eMB\u003c/span\u003e\ndocker.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/library/vault              \u0026#x3C;none\u003e          aac433bb6835  \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e years ago   147MB\n\n# \u003cspan class=\"hljs-title class_\"\u003ePostgreSQL\u003c/span\u003e 이미지 다운로드\n❯❯ podman pull \u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:latest\n...\n\n# \u003cspan class=\"hljs-title class_\"\u003ePostgreSQL\u003c/span\u003e 실행\n❯❯ podman run --name postgres -e \u003cspan class=\"hljs-variable constant_\"\u003ePOSTGRES_PASSWORD\u003c/span\u003e=admin -p \u003cspan class=\"hljs-number\"\u003e5432\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e5432\u003c/span\u003e -d postgres\n6ee93adb00d1f1a468308b50a044002e2f7da116614ebb8d092d8236ae6542d6\n\n# 실행 중인 컨테이너 목록\n❯❯ podman ps\n\u003cspan class=\"hljs-variable constant_\"\u003eCONTAINER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e  \u003cspan class=\"hljs-variable constant_\"\u003eIMAGE\u003c/span\u003e                              \u003cspan class=\"hljs-variable constant_\"\u003eCOMMAND\u003c/span\u003e     \u003cspan class=\"hljs-variable constant_\"\u003eCREATED\u003c/span\u003e        \u003cspan class=\"hljs-variable constant_\"\u003eSTATUS\u003c/span\u003e        \u003cspan class=\"hljs-variable constant_\"\u003ePORTS\u003c/span\u003e                   \u003cspan class=\"hljs-variable constant_\"\u003eNAMES\u003c/span\u003e\n6ee93adb00d1  docker.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/library/\u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:latest  postgres    \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e seconds ago  \u003cspan class=\"hljs-title class_\"\u003eUp\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e seconds  \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e5432\u003c/span\u003e-\u003e\u003cspan class=\"hljs-number\"\u003e5432\u003c/span\u003e/tcp  postgres\n\n# 명령어 실행 시 디버그 로그 보기\n❯❯ podman --log-level=debug ps\n...\n\n## \u003cspan class=\"hljs-number\"\u003e3.\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCreate\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDocker\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAlias\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003ePodman은 Docker와 매우 유사한 명령줄 인터페이스를 제공하여 Docker에서 Podman으로 쉽게 전환할 수 있습니다. 실제로 Podman과 Docker를 동일하게 사용할 수 있도록 Docker에 대한 별칭을 Podman으로 만들 수 있습니다. 예를 들어, 다음 Alias를 ~/.zshrc 파일에 추가하여 Podman의 docker alias를 만들 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# alias to docker, run podman commands \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e docker\nalias docker=podman\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e별칭을 설정한 후에는 docker 명령을 podman 명령처럼 사용할 수 있으며, docker 명령을 사용하여 Podman 명령을 실행할 수 있습니다. Docker에서 작업하는 데 익숙하고 새로운 명령어를 배우지 않고 Podman으로 전환하려는 경우 도움이 될 수 있습니다. 그러나 Docker와 Podman 사이에 동작에 차이가 있을 수 있으므로 docker alias를 Podman과 함께 사용할 때 작업 흐름을 충분히 테스트해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# list images \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e docker alias\n❯❯ docker images\n\u003cspan class=\"hljs-variable constant_\"\u003eREPOSITORY\u003c/span\u003e                           \u003cspan class=\"hljs-variable constant_\"\u003eTAG\u003c/span\u003e             \u003cspan class=\"hljs-variable constant_\"\u003eIMAGE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e      \u003cspan class=\"hljs-variable constant_\"\u003eCREATED\u003c/span\u003e       \u003cspan class=\"hljs-variable constant_\"\u003eSIZE\u003c/span\u003e\ndocker.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/library/postgres           latest          61d0571c2f7b  \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e weeks ago   \u003cspan class=\"hljs-number\"\u003e368\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eMB\u003c/span\u003e\ndocker.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/hashicorp/envconsul        \u003cspan class=\"hljs-number\"\u003e0.13\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e          42307d16e023  \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e months ago  \u003cspan class=\"hljs-number\"\u003e18.7\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eMB\u003c/span\u003e\ndocker.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/library/vault              \u0026#x3C;none\u003e          aac433bb6835  \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e years ago   \u003cspan class=\"hljs-number\"\u003e147\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eMB\u003c/span\u003e\n\n# list containers\n❯❯ docker ps\n\u003cspan class=\"hljs-variable constant_\"\u003eCONTAINER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e  \u003cspan class=\"hljs-variable constant_\"\u003eIMAGE\u003c/span\u003e                              \u003cspan class=\"hljs-variable constant_\"\u003eCOMMAND\u003c/span\u003e     \u003cspan class=\"hljs-variable constant_\"\u003eCREATED\u003c/span\u003e        \u003cspan class=\"hljs-variable constant_\"\u003eSTATUS\u003c/span\u003e        \u003cspan class=\"hljs-variable constant_\"\u003ePORTS\u003c/span\u003e                   \u003cspan class=\"hljs-variable constant_\"\u003eNAMES\u003c/span\u003e\n6ee93adb00d1  docker.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/library/\u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:latest  postgres    \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e minutes ago  \u003cspan class=\"hljs-title class_\"\u003eUp\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e minutes  \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e5432\u003c/span\u003e-\u003e\u003cspan class=\"hljs-number\"\u003e5432\u003c/span\u003e/tcp  postgres\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e4. Podman REST API에 액세스하기\u003c/h2\u003e\n\u003cp\u003epodman.sock은 Podman 데몬이 Podman 클라이언트로부터 요청을 수신하기 위해 사용하는 유닉스 도메인 소켓입니다. Podman 명령을 실행할 때 Podman 클라이언트는 podman.sock 소켓을 통해 Podman 데몬에 요청을 보내고, 데몬은 요청을 처리하고 클라이언트에 응답을 보냅니다. 기본적으로 podman.sock 소켓은 Podman이 실행 중인 기기에서 로컬로만 액세스할 수 있습니다. 그러나 socat을 사용하여 podman.sock 소켓을 TCP 소켓에 바인딩하여 HTTP REST API를 통해 Podman에 원격 액세스할 수 있도록 설정할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다음 예제에서는 podman.sock 유닉스 소켓을 socat을 사용하여 TCP 포트 2375에 바인딩하는 방법을 보여줍니다. 이를 통해 호스트 기기에서 이 포트에 연결하고 podman REST API를 외부에 노출시킬 수 있습니다. 설정이 완료되면 REST 클라이언트가 포트 2375에 연결하여 Podman REST API에 액세스할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e5. ARM64 CPU 아키텍처 이미지 실행하기\u003c/h2\u003e\n\u003cp\u003ePodman을 사용하여 컨테이너 이미지를 실행할 때, 컨테이너는 호스트 머신과 동일한 CPU 아키텍처에서 실행됩니다. 즉, 호스트 머신이 ARM64 CPU 아키텍처를 가지고 있다면, Podman은 ARM64 아키텍처를 사용하여 컨테이너를 실행합니다. 만약 호스트 머신이 AMD64 또는 x86 아키텍처를 가지고 있다면, 컨테이너는 해당 아키텍처로 실행됩니다.\u003c/p\u003e\n\u003cp\u003e주의할 점은 호스트 머신의 아키텍처와 다른 아키텍처의 컨테이너 이미지를 실행하려고 한다면, Podman이 해당 컨테이너를 실행할 수 없다는 것입니다. 예를 들어, AMD64 또는 x86 아키텍처를 가진 호스트 머신에서 ARM64 컨테이너 이미지를 실행하려고 하면, Podman은 해당 컨테이너를 실행할 수 없습니다.\u003c/p\u003e\n\u003cp\u003e이 제한을 극복하기 위해, multi-architecture 컨테이너 이미지를 사용할 수 있습니다. 이러한 이미지에는 여러 CPU 아키텍처의 이진 파일과 라이브러리가 포함되어 있어, 동일한 이미지가 다른 아키텍처의 머신에서 실행될 수 있습니다. Docker와 Podman은 모두 multi-architecture 이미지를 지원합니다. multi-architecture 이미지를 가져올 때, Podman은 자동으로 호스트 머신에 맞는 올바른 아키텍처를 선택하고 해당 아키텍처로 컨테이너를 실행합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003emquery 도구를 사용하면 공개 컨테이너 저장소의 모든 공개 이미지를 쿼리하여 미디어 유형, 다이제스트 및 플랫폼 지원을 확인할 수 있습니다. 또한 도커 이미지의 사용 가능한 CPU 아키텍처를 확인하는 데 사용할 수 있습니다. 이 도구는 estesp/mquery라는 이름의 Docker 이미지로 제공됩니다. 해당 이미지를 실행하여 어떤 도커 이미지의 CPU 아키텍처를 확인할 수 있습니다. 결과에는 이미지를 지원하는 플랫폼이 표시되며, 해당 아키텍처, 운영 체제 및 버전이 포함됩니다. 시스템의 CPU 아키텍처와 호환되는지 확인하는 데 유용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:latest 이미지의 사용 가능한 \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e 아키텍처 보기\n# \u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:latest 이미지는 arm64를 포함한 모든 \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e 아키텍처로 제공됩니다\n# macOS \u003cspan class=\"hljs-variable constant_\"\u003eM1\u003c/span\u003e에서 \u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:latest를 실행하는 경우 arm64 이미지가 선택됩니다\n❯❯ docker run --rm mplatform/mquery \u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:latest\n\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:latest (\u003cspan class=\"hljs-attr\"\u003edigest\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003esha256\u003c/span\u003e:50a96a21f2992518c2cb4601467cf27c7ac852542d8913c1872fe45cd6449947)\n * \u003cspan class=\"hljs-title class_\"\u003eManifest\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eYes\u003c/span\u003e (\u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: application/vnd.\u003cspan class=\"hljs-property\"\u003edocker\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edistribution\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emanifest\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elist\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ev2\u003c/span\u003e+json)\n * \u003cspan class=\"hljs-title class_\"\u003eSupported\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eplatforms\u003c/span\u003e:\n   - linux/amd64\n   - linux/arm/v5\n   - linux/arm/v7\n   - linux/arm64/v8\n   - linux/\u003cspan class=\"hljs-number\"\u003e386\u003c/span\u003e\n   - linux/mips64le\n   - linux/ppc64le\n   - linux/s390x\n\n# 실행 중인 \u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:latest 이미지의 \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e 아키텍처 보기\n# macOS \u003cspan class=\"hljs-variable constant_\"\u003eM1\u003c/span\u003e에서 \u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:latest를 실행하는 경우 arm64 이미지가 선택됩니다\n❯❯ docker image inspect \u003cspan class=\"hljs-attr\"\u003epostgres\u003c/span\u003e:latest | grep \u003cspan class=\"hljs-title class_\"\u003eArchitecture\u003c/span\u003e\n          \u003cspan class=\"hljs-string\"\u003e\"Architecture\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"arm64\"\u003c/span\u003e,\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e6. AMD64 CPU 아키텍처 이미지 실행\u003c/h2\u003e\n\u003cp\u003ePodman에서 AMD64와 같은 다른 CPU 아키텍처용으로 빌드된 도커 이미지를 macOS M1/M2 ARM64 CPU에 실행하려고 하면 에러가 발생하여 실패할 것입니다. 이는 이미지가 호스트 머신의 CPU 아키텍처와 호환되지 않기 때문입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# \u003cspan class=\"hljs-attr\"\u003emysql\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.23\u003c/span\u003e은 amd64 아키텍처 이미지만 사용 가능합니다\n❯❯ docker run --rm mplatform/mquery \u003cspan class=\"hljs-attr\"\u003emysql\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.23\u003c/span\u003e\n이미지: \u003cspan class=\"hljs-attr\"\u003emysql\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.23\u003c/span\u003e (다이제스트: \u003cspan class=\"hljs-attr\"\u003esha256\u003c/span\u003e:6e0014cdd88092545557dee5e9eb7e1a3c84c9a14ad2418d5f2231e930967a38)\n * \u003cspan class=\"hljs-title class_\"\u003eManifest\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eYes\u003c/span\u003e (이미지 유형: application/vnd.\u003cspan class=\"hljs-property\"\u003edocker\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edistribution\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emanifest\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elist\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ev2\u003c/span\u003e+json)\n * 지원하는 플랫폼:\n   - linux/amd64\n\n# mac m1 arm64 머신에서 \u003cspan class=\"hljs-attr\"\u003emysql\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.23\u003c/span\u003e 실행 시 발생하는 오류입니다\n❯❯ docker run \u003cspan class=\"hljs-attr\"\u003emysql\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.23\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"mysql\"\u003c/span\u003e을 미지정 검색 레지스트리를 사용하여 해석 중 (\u003cspan class=\"hljs-regexp\"\u003e/etc/\u003c/span\u003econtainers/registries.\u003cspan class=\"hljs-property\"\u003econf\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ed\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e999\u003c/span\u003e-podman-machine.\u003cspan class=\"hljs-property\"\u003econf\u003c/span\u003e)\ndocker.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/library/\u003cspan class=\"hljs-attr\"\u003emysql\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.23\u003c/span\u003e에서 가져오려고 시도 중...\n오류: 아키텍처 arm64, 변형 \u003cspan class=\"hljs-string\"\u003e\"v8\"\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eOS\u003c/span\u003e linux에 대한 매니페스트 목록에서 이미지를 찾을 수 없음\n\n그러나 \u003cspan class=\"hljs-title class_\"\u003ePodman\u003c/span\u003e은 이 문제에 대한 다중 아키텍처 지원으로 해결책을 제공합니다. --arch 옵션을 사용하여 실행하려는 플랫폼을 지정할 수 있고, 해당 플랫폼에 대해 사용 가능한 경우 \u003cspan class=\"hljs-title class_\"\u003ePodman\u003c/span\u003e은 자동으로 이미지의 올바른 버전을 가져옵니다. 이를 통해 macOS \u003cspan class=\"hljs-variable constant_\"\u003eM1\u003c/span\u003e/\u003cspan class=\"hljs-variable constant_\"\u003eM2\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eARM64\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e에서 다른 \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e 아키텍처용 이미지를 문제 없이 실행할 수 있습니다.\n\n# amd64 아키텍처를 지정하여 mysql 이미지 실행\n# 그럼 podman은 amd64 아키텍처로 docker 이미지를 가져와 실행합니다\n❯❯ docker run --arch=amd64 \u003cspan class=\"hljs-attr\"\u003emysql\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.23\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e\"mysql\"\u003c/span\u003e을 미지정 검색 레지스트리를 사용하여 해석 중 (\u003cspan class=\"hljs-regexp\"\u003e/etc/\u003c/span\u003econtainers/registries.\u003cspan class=\"hljs-property\"\u003econf\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ed\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e999\u003c/span\u003e-podman-machine.\u003cspan class=\"hljs-property\"\u003econf\u003c/span\u003e)\ndocker.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/library/\u003cspan class=\"hljs-attr\"\u003emysql\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e8.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.23\u003c/span\u003e에서 가져오려고 시도 중...\n이미지 소스 서명 가져옴\nblob \u003cspan class=\"hljs-attr\"\u003esha256\u003c/span\u003e:15f235e0d7eefe6c5153946a57daebaf2d0744fb1d0676642f269554fc68ba2a 복사 중\n(중략)\nconfig \u003cspan class=\"hljs-attr\"\u003esha256\u003c/span\u003e:cbe8815cbea8fb86ce7d3169a82d05301e7dfe1a8d4228941f23f4f115a887f2 복사 중\n이미지 목적지에 매니페스트 쓰는 중\n서명 저장 중\n\u003cspan class=\"hljs-number\"\u003e2023\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e03\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e58\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e56\u003c/span\u003e+\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e [\u003cspan class=\"hljs-title class_\"\u003eNote\u003c/span\u003e] [\u003cspan class=\"hljs-title class_\"\u003eEntrypoint\u003c/span\u003e]: \u003cspan class=\"hljs-title class_\"\u003eMySQL\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eServer\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e8.0\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.23\u003c/span\u003e-1debian10용 입구점 스크립트 시작됨.\n(중략)\n\u003cspan class=\"hljs-number\"\u003e2023\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e03\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e18\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e58\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e57\u003c/span\u003e+\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e [\u003cspan class=\"hljs-variable constant_\"\u003eERROR\u003c/span\u003e] [\u003cspan class=\"hljs-title class_\"\u003eEntrypoint\u003c/span\u003e]: 데이터베이스가 초기화되지 않았으며 암호 옵션이 지정되지 않았습니다\n    다음 중 하나를 지정해야 합니다:\n    - \u003cspan class=\"hljs-variable constant_\"\u003eMYSQL_ROOT_PASSWORD\u003c/span\u003e\n    - \u003cspan class=\"hljs-variable constant_\"\u003eMYSQL_ALLOW_EMPTY_PASSWORD\u003c/span\u003e\n    - \u003cspan class=\"hljs-variable constant_\"\u003eMYSQL_RANDOM_ROOT_PASSWORD\u003c/span\u003e\n\n--arch 옵션이 작동하지 않는 경우, multiarch/qemu-user-\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e을 사용한 해결책이 있습니다. 이 글에서 그 해결책에 대해 자세히 설명합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epodman machine ssh\nsudo -i\nrpm-ostree install qemu-user-\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e\nsystemctl reboot\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e7. 다른 CPU 아키텍처로 이미지 빌드하기\u003c/h2\u003e\n\u003cp\u003ePodman으로 이미지를 빌드할 때 --arch 플래그를 사용하여 이미지에 원하는 CPU 아키텍처를 선택할 수 있습니다. 기본적으로 Podman은 실행 중인 기기의 CPU 아키텍처를 사용합니다. 이를 통해 Podman을 사용하여 멀티 아키텍처 이미지를 빌드할 수 있으며, 동일한 응용 프로그램을 다양한 CPU 아키텍처에서 실행하는 데 유용할 수 있습니다. 아래는 다른 아키텍처 이미지를 빌드하는 데 사용되는 예시 golang 응용프로그램(main.go)과 Dockerfile입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epackage main\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"fmt\"\u003c/span\u003e\n\nfunc \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n fmt.\u003cspan class=\"hljs-title class_\"\u003ePrintln\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"vim-go\"\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003egolang\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.16\u003c/span\u003e-alpine \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e builder\n\u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /app\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e . .\n\n\u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e go build -o main *.\u003cspan class=\"hljs-property\"\u003ego\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealpine\u003c/span\u003e:latest\n\u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /root/\n\u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e --\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e=builder /app/main .\n\u003cspan class=\"hljs-variable constant_\"\u003eCMD\u003c/span\u003e [ \u003cspan class=\"hljs-string\"\u003e\"./main\"\u003c/span\u003e ]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAMD64 아키텍처를 사용하여 이미지를 빌드하려면 Podman을 사용하여 다음 명령을 --arch=amd64 매개변수와 함께 사용할 수 있습니다. 이는 AMD64 아키텍처 기본 이미지를 사용하고 그 위에 새 이미지를 빌드합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# amd64 cpu 아키텍처로 도커 이미지 빌드\n# 빌드할 때 주어진 cpu 아키텍처의 기반 이미지 및 라이브러리를 가져옵니다\n❯❯ docker build --arch=amd64 --rm -t erangaeb/hello .\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] 단계 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003egolang\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.16\u003c/span\u003e-alpine \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e builder\n\u003cspan class=\"hljs-string\"\u003e\"golang\"\u003c/span\u003e를 unqualified-search 레지스트리(../../containers/registries.\u003cspan class=\"hljs-property\"\u003econf\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ed\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e999\u003c/span\u003e-podman-machine.\u003cspan class=\"hljs-property\"\u003econf\u003c/span\u003e)를 사용하여 해석 중\ndocker.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/library/\u003cspan class=\"hljs-attr\"\u003egolang\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.16\u003c/span\u003e-alpine를 가져오려는 중...\n이미지 소스 서명 가져오는 중\nblob \u003cspan class=\"hljs-attr\"\u003esha256\u003c/span\u003e:0435e09637941e35cccdf9cf9171571811d2fdfe72c27e39543a718d38d28668 복사 중\nblob \u003cspan class=\"hljs-attr\"\u003esha256\u003c/span\u003e:59bf1c3509f33515622619af21ed55bbe26d24913cedbca106468a5fb37a50c3 복사 중\nblob \u003cspan class=\"hljs-attr\"\u003esha256\u003c/span\u003e:666ba61612fd7c93393f9a5bc1751d8a9929e32d51501dba691da9e8232bc87b 복사 중\nblob \u003cspan class=\"hljs-attr\"\u003esha256\u003c/span\u003e:8ed8ca4862056a130f714accb3538decfa0663fec84e635d8b5a0a3305353dee 복사 중\nblob \u003cspan class=\"hljs-attr\"\u003esha256\u003c/span\u003e:ca4bf87e467a8cacf62c9b01c7d6d43f6ca4bb9b0fc9146fbb906b05aee56cc1 복사 중\nconfig \u003cspan class=\"hljs-attr\"\u003esha256\u003c/span\u003e:7642119cd16177d874dcbfe1c550affd336dbe4cabb3339ef685ac1d6ec71ccc 복사 중\n이미지 목적지에 매니페스트 작성 중\n서명 저장 중\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] 단계 \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eWORKDIR\u003c/span\u003e /app\n--\u003e 캐시 푸시 []:220abc07870fcc2e449b7b03384b2e4c219f7c32b28546f90067c1488ea63ba0\n--\u003e 663c9d6f7ea\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] 단계 \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eCOPY\u003c/span\u003e . .\n--\u003e 캐시 푸시 []:e7db7815e4762b218ab81c3f93cdf789c4961c783825470c3c2edb55000b1844\n--\u003e ce3d882f4c8\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] 단계 \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eRUN\u003c/span\u003e go build -o main *.\u003cspan class=\"hljs-property\"\u003ego\u003c/span\u003e\n--\u003e 캐시 푸시 []:95b5a69b661a646895b2a2bc6b313e0f5fd2cc83a4d7dcd1e5f2594be34c3d4d\n--\u003e 54d84331cf2\n사용자 정의 erangaeb/hello 이미지가 성공적으로 빌드되었습니다\nc1329ead22a2cf66cd4a47b06aa0d406aba34798d26e79d666e1d855cd920028\n\n# 이미지 실행\n# 이미지를 arm64 cpu로 빌드한 후 --arch=amd64를 명시해야 함\n# 그렇지 않으면 amd64 cpu 아키텍처 이미지를 가져와 실패할 것입니다\n❯❯ docker run --arch=amd64 localhost/erangaeb/hello\n경고: 이미지 플랫폼(리눅스/amd64)이 예상 플랫폼(리눅스/arm64)과 일치하지 않습니다\nvim-go\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음은 Podman을 사용하여 arm64 아키텍처로 이미지를 빌드하는 예제 명령입니다. 이 명령은 --arch 플래그를 사용하여 ARM64 아키텍처를 지정합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# arm64 \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e 아키텍처로 도커 이미지 빌드\n❯❯ docker build --arch=arm64 --rm -t erangaeb/\u003cspan class=\"hljs-attr\"\u003ehello\u003c/span\u003e:arm64 .\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] 단계 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003egolang\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.16\u003c/span\u003e-alpine을 빌드 중\n... (중략) ...\n[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e] 단계 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e: \u003cspan class=\"hljs-attr\"\u003ealpine\u003c/span\u003e:latest으로 빌드 중\n... (중략) ...\nerangaeb/\u003cspan class=\"hljs-attr\"\u003ehello\u003c/span\u003e:arm64 이미지 구축 완료\n4d98d25ec13db2b9c25c149a0c3f5996829029026a6fd295e55c78acc9cef89e\n\n# arm64 이미지 실행\n# \u003cspan class=\"hljs-variable constant_\"\u003eCPU\u003c/span\u003e 아키텍처와 일치하여 경고 없이 실행됩니다.\n❯❯ docker run localhost/erangaeb/\u003cspan class=\"hljs-attr\"\u003ehello\u003c/span\u003e:arm64\nvim-go\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e8. 쿠버네티스 클러스터 실행\u003c/h2\u003e\n\u003cp\u003e로컬 쿠버네티스 클러스터를 생성하기 위해 Kind와 Podman을 함께 사용했습니다. Kind는 로컬 머신에서 도커 컨테이너로 작동하는 클러스터 노드로서 쿠버네티스 클러스터를 운영할 수 있게 해주는 오픈소스 도구입니다. 아래는 Podman을 활용하여 Kind 클러스터를 설정하는 단계입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# asdf를 사용하여 kind 설치\n❯❯ asdf plugin add kind\n❯❯ asdf install kind \u003cspan class=\"hljs-number\"\u003e0.17\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\n❯❯ asdf \u003cspan class=\"hljs-variable language_\"\u003eglobal\u003c/span\u003e kind \u003cspan class=\"hljs-number\"\u003e0.17\u003c/span\u003e\u003cspan class=\"hljs-number\"\u003e.0\u003c/span\u003e\n\n# ~/.\u003cspan class=\"hljs-property\"\u003ezshrc\u003c/span\u003e 파일에 아래 구성 추가하여 rootless podman으로 kind 실행\n\u003cspan class=\"hljs-variable constant_\"\u003eKIND_EXPERIMENTAL_PROVIDER\u003c/span\u003e=podman\n\n# 클러스터 생성\n# 클러스터 이름은 \u003cspan class=\"hljs-string\"\u003e'kind'\u003c/span\u003e로 지정됩니다.\n❯❯ kind create cluster \n\n# kubectl 컨텍스트인 kind-kind가 추가됩니다.\n❯❯ kubectl config get-contexts\n... (중략) ...\n\n# kind 클러스터 조회\n❯❯ kind get clusters\n... (중략) ...\n\n# 클러스터 노드에 이미지 로드\n# 비공개 도커 레지스트리(예: \u003cspan class=\"hljs-title class_\"\u003eGoogle\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eContainer\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRegistry\u003c/span\u003e/\u003cspan class=\"hljs-variable constant_\"\u003eGCR\u003c/span\u003e)에 있는 이미지 실행에 도움이 됩니다.\n❯❯ kind load docker-image eu.\u003cspan class=\"hljs-property\"\u003egcr\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/rahasak-build/\u003cspan class=\"hljs-attr\"\u003elambdaops\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1.0\u003c/span\u003e\n\n# kind-kind 컨텍스트로 kind 클러스터 사용\n❯❯ kubectl --context=kind-kind get pods\n\n# 클러스터 삭제\n❯❯ kind \u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e cluster\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e9. Google Container Registry 인증\u003c/h2\u003e\n\u003cp\u003eGoogle Container Registry(GCR)와 통합하고 싶을 수 있습니다. 이는 Google Cloud가 제공하는 Docker 이미지를 저장하고 관리하는 호스팅 서비스입니다. GCR 문서에는 Docker와의 인증에 대한 훌륭한 안내가 제공됩니다. 첫 번째 인증 방법은 gcloud 자격 증명 도우미를 사용하는 것인데, 이는 gcloud CLI를 사용하여 Cloud Shell 또는 Google Cloud CLI가 설치된 모든 환경에서 인증을 구성합니다. Docker의 gcloud 자격 증명 도우미 방법을 통해 한 번 인증을 받으면 같은 인증 방법을 Podman에서도 사용할 수 있습니다. 먼저 Google Cloud 계정으로 gcloud auth login 명령을 실행하여 인증하십시오. 다음으로, gcloud auth configure-docker \u003ccode\u003eregistry host\u003c/code\u003e 명령을 사용하여 Docker가 GCR과 인증하도록 구성하십시오. 이 작업이 완료되면 Podman은 Docker 자격 증명을 재사용할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 웹 플로우를 통해 gcloud 서비스에 로그인\n❯❯ gcloud auth login\n\n# 자격 증명을 ~\u003cspan class=\"hljs-regexp\"\u003e/.config/g\u003c/span\u003ecloud/credentials.\u003cspan class=\"hljs-property\"\u003edb\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSQLite\u003c/span\u003e 데이터베이스에 저장합니다\n❯❯ sqlite3 credentials.\u003cspan class=\"hljs-property\"\u003edb\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"SELECT value FROM credentials\"\u003c/span\u003e\n{\n  \u003cspan class=\"hljs-string\"\u003e\"client_id\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;id\u003e.apps.googleusercontent.com\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"client_secret\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;secret\u003e\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"refresh_token\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"\u0026#x3C;token\u003e\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"revoke_uri\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"https://accounts.google.com/o/oauth2/revoke\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"scopes\"\u003c/span\u003e: [\n    \u003cspan class=\"hljs-string\"\u003e\"openid\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"https://www.googleapis.com/auth/userinfo.email\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"https://www.googleapis.com/auth/cloud-platform\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"https://www.googleapis.com/auth/appengine.admin\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"https://www.googleapis.com/auth/sqlservice.login\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"https://www.googleapis.com/auth/compute\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"https://www.googleapis.com/auth/accounts.reauth\"\u003c/span\u003e\n  ],\n  \u003cspan class=\"hljs-string\"\u003e\"token_uri\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"https://oauth2.googleapis.com/token\"\u003c/span\u003e,\n  \u003cspan class=\"hljs-string\"\u003e\"type\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"authorized_user\"\u003c/span\u003e\n}\n\n# \u003cspan class=\"hljs-title class_\"\u003eDocker\u003c/span\u003e가 \u003cspan class=\"hljs-variable constant_\"\u003eGCR\u003c/span\u003e과 인증하도록 구성\n# 그럼 \u003cspan class=\"hljs-title class_\"\u003ePodman\u003c/span\u003e이 해당 자격 증명을 재사용할 수 있습니다\n# 명령어\n❯❯ gcloud auth configure-docker \u0026#x3C;registry host\u003e\n\n# 예시\n❯❯ gcloud auth configure-docker eu.\u003cspan class=\"hljs-property\"\u003egcr\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eAdding\u003c/span\u003e credentials \u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: eu.\u003cspan class=\"hljs-property\"\u003egcr\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e\n업데이트 후 다음이 \u003cspan class=\"hljs-title class_\"\u003eDocker\u003c/span\u003e 구성 파일에 작성될 것입니다\n[\u003cspan class=\"hljs-regexp\"\u003e/Users/\u003c/span\u003elambda.\u003cspan class=\"hljs-property\"\u003eeranga\u003c/span\u003e/.\u003cspan class=\"hljs-property\"\u003edocker\u003c/span\u003e/config.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e]:\n {\n  \u003cspan class=\"hljs-string\"\u003e\"credHelpers\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"eu.gcr.io\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"gcloud\"\u003c/span\u003e\n  }\n}\n계속하시겠습니까 (Y/n)?  Y\n\n# 원하는 경우 더 많은 레지스트리 호스트를 추가할 수 있습니다\n❯❯ gcloud auth configure-docker europe-docker.\u003cspan class=\"hljs-property\"\u003epkg\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edev\u003c/span\u003e\n❯❯ gcloud auth configure-docker europe-north1-docker.\u003cspan class=\"hljs-property\"\u003epkg\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edev\u003c/span\u003e\n\n# 생성된 구성은 홈 디렉토리 ~\u003cspan class=\"hljs-regexp\"\u003e/.docker/\u003c/span\u003econfig.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e에 저장됩니다\n❯❯ cat ~\u003cspan class=\"hljs-regexp\"\u003e/.docker/\u003c/span\u003econfig.\u003cspan class=\"hljs-property\"\u003ejson\u003c/span\u003e\n{\n  \u003cspan class=\"hljs-string\"\u003e\"credHelpers\"\u003c/span\u003e: {\n    \u003cspan class=\"hljs-string\"\u003e\"eu.gcr.io\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"gcloud\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"europe-docker.pkg.dev\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"gcloud\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-string\"\u003e\"europe-north1-docker.pkg.dev\"\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\"gcloud\"\u003c/span\u003e\n  }\n}\n\n# 이제 \u003cspan class=\"hljs-title class_\"\u003ePodman\u003c/span\u003e은 \u003cspan class=\"hljs-title class_\"\u003eDocker\u003c/span\u003e 자격 증명을 사용하여 credential helper gcloud를 통해 \u003cspan class=\"hljs-variable constant_\"\u003eGCR\u003c/span\u003e에 접근할 수 있습니다\n❯❯ docker pull eu.\u003cspan class=\"hljs-property\"\u003egcr\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eio\u003c/span\u003e/rahasak-build/\u003cspan class=\"hljs-attr\"\u003eaplos\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e0.1\u003c/span\u003e --log-level=debug\n\u003cspan class=\"hljs-variable constant_\"\u003eINFO\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0000\u003c/span\u003e] podman filtering at log level debug\n⋮\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이전 방법은 Podman이 Docker GCR 인증 구성을 사용하여 Google Container Registry와 인증하는 방법을 설명했습니다. 그러나 Podman은 직접 컨테이너 레지스트리에 로그인하기 위한 podman login이라는 명령도 제공합니다. 이 명령은 Container Registry와 함께 사용할 수 있는 단기간의 OAuth 액세스 토큰을 사용하여 인증합니다. 이 토큰은 60분 동안만 유효하므로 Container Registry에 연결하기 전 1시간 이전에 요청해야 합니다. 토큰이 만료되면 다시 로그인해야 하며, 그렇지 않으면 권한 없음: 인증 실패 오류가 발생할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-comment\"\u003e# 웹 플로우를 통해 gcloud 서비스에 로그인해주세요\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e❯❯\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003egcloud\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eauth\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003elogin\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 이전에 생성된 도커 자격 증명을 제거해주세요\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e❯❯\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003erm\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e-rf\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e~/.docker\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 짧게 유지되는 액세스 토큰을 생성하고 sqlite db ~/.config/gcloud/access_tokens.db에 저장됩니다\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e❯❯\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003esqlite3\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eaccess_tokens.db\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"select * from access_tokens\"\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 액세스 토큰 확인\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e❯❯\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003egcloud\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eauth\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eprint-access-token\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# 액세스 토큰으로 gcr에 로그인\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e# 이렇게 짧게 유지되는 OAuth 액세스 토큰을 사용하여 Container Registry와 인증합니다. \u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e# 토큰은 60분 동안 유효하며, Container Registry에 연결하기 전에 한 시간 이내에 요청해야 합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e# 토큰 만료 시, 아래 명령어를 다시 실행하고 다시 로그인해야 합니다. 그렇지 않으면 권한이 없음: 인증 실패 오류가 발생합니다.\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e❯❯\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003egcloud\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eauth\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eprint-access-token\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e|\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epodman\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003elogin\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e-u\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eoauth2accesstoken\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e--password-stdin\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eeu.gcr.io\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e# ~/.config/containers/auth.json에 인증 파일이 생성됩니다\u003c/span\u003e\n\u003cspan class=\"hljs-string\"\u003e❯❯\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecat\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e.config/containers/auth.json\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e{\n\"auths\": {\n\"eu.gcr.io\": {\n\"auth\": \"\u0026#x3C;액세스 토큰\u003e\"\n}\n}\n}\u003c/p\u003e\n\u003ch1\u003e이제 podman은 docker 자격 증명을 사용하여 gcr에 액세스할 수 있습니다(자격 증명 도우미 gcloud 사용)\u003c/h1\u003e\n\u003cp\u003e❯❯ docker pull eu.gcr.io/rahasak-build/aplos:0.1 --log-level=debug\nINFO[0000] log level debug에서 podman 필터링\nDEBU[0000] pull.PersistentPreRunE(podman pull eu.gcr.io/rahasak-build/aplos:0.1 --log-level=debug) 호출\nDEBU[0000] DoRequest 메서드: GET URI: \u003ca href=\"http://d/v4.4.2/libpod/_ping\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://d/v4.4.2/libpod/_ping\u003c/a\u003e\nDEBU[0000] \"/etc/containers/registries.conf\"에서 레지스트리 구성로드\nDEBU[0000] 자격 증명 도우미 containers-auth.json에서 /Users/lambda.eranga/.config/containers/auth.json 파일의 eu.gcr.io 자격 증명 찾음\nDEBU[0000] DoRequest 메서드: POST URI: \u003ca href=\"http://d/v4.4.2/libpod/images/pull\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://d/v4.4.2/libpod/images/pull\u003c/a\u003e\neu.gcr.io/rahasak-build/aplos:0.1 끌어오기 시도 중...\n이미지 소스 서명 가져오는 중\nblob sha256:9fa0fafc404b18044192115d295424237056a9296da9fe07f3f493f714d7c6fb 복사 중\nblob sha256:b9fd7cb1ff8f489cf082781b0e1fe0c13b840e20147e8fc8204b4592da7c2f70 복사 중\nblob sha256:f25ad21146dc80e14a651d9f59707ccab21bd3749aee1177faf72329661f19eb 복사 중\nblob sha256:e92ed755c008afc1863a616a5ba743b670c09c1698f7328f05591932452a425f 복사 중\nblob sha256:53e3366ec435596bed2563cc882ba47ec25df6be2b1027e3243e83589c667c1e 복사 중\nblob sha256:ee690f2d57a128744cf4c5b52646ad0ba7a5af113d9d7e0e02b62c06d35fd14c 복사 중\nblob sha256:e83609f677899ddd7e01f03fd3f797d98fb18e3307a236b55b218a59f5cf7b9b 복사 중\nblob sha256:88c7c603b3faedd122305543eb17d6968a16399c7a93f67b3486196b2440c846 복사 중\u003c/p\u003e\n\u003ch1\u003e로그인 취소\u003c/h1\u003e\n\u003cp\u003e❯❯ podman logout eu.gcr.io\u003c/p\u003e\n\u003ch1\u003e참고\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://medium.com/rahasak/replace-docker-desktop-with-minikube-and-hyperkit-on-macos-783ce4fb39e3\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://medium.com/rahasak/replace-docker-desktop-with-minikube-and-hyperkit-on-macos-783ce4fb39e3\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://dev.to/docker/choosing-the-right-docker-image-for-your-apple-m1-pro-440l\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://dev.to/docker/choosing-the-right-docker-image-for-your-apple-m1-pro-440l\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zenn.dev/sbk0716/articles/d9235b78b97615\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://zenn.dev/sbk0716/articles/d9235b78b97615\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://itnext.io/using-minikube-on-m1-macs-416da593ba0c\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://itnext.io/using-minikube-on-m1-macs-416da593ba0c\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://itnext.io/goodbye-docker-desktop-hello-minikube-3649f2a1c469\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://itnext.io/goodbye-docker-desktop-hello-minikube-3649f2a1c469\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://0to1.nl/post/minikube-m1-pro-issues/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://0to1.nl/post/minikube-m1-pro-issues/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.redhat.com/sysadmin/podman-python-bash\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.redhat.com/sysadmin/podman-python-bash\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://edofic.com/posts/2021-09-12-podman-m1-amd64/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://edofic.com/posts/2021-09-12-podman-m1-amd64/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://xphyr.net/post/podman_on_osx/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://xphyr.net/post/podman_on_osx/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.redhat.com/sysadmin/specify-architecture-pulling-podman-images\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://www.redhat.com/sysadmin/specify-architecture-pulling-podman-images\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://itnext.io/kubernetes-kind-cheat-shee-2605da77984\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://itnext.io/kubernetes-kind-cheat-shee-2605da77984\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>