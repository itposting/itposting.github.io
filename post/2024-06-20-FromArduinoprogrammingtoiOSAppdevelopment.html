<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>아두이노 프로그래밍에서 iOS 앱 개발로 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="아두이노 프로그래밍에서 iOS 앱 개발로 | itposting" data-gatsby-head="true"/><meta property="og:title" content="아두이노 프로그래밍에서 iOS 앱 개발로 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment" data-gatsby-head="true"/><meta name="twitter:title" content="아두이노 프로그래밍에서 iOS 앱 개발로 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 16:48" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-0fd008072af5a644.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_buildManifest.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">아두이노 프로그래밍에서 iOS 앱 개발로</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="아두이노 프로그래밍에서 iOS 앱 개발로" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">18<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>BLE 연결을 통한 IoT 프로젝트 구축 실습 가이드</h2>
<p>이 튜토리얼에서는 iOS 앱 개발과 Arduino 프로그래밍의 세계를 탐험하면서 전자 보드를 무선으로 제어할 수 있는 간단한 시스템을 생성하는 방법을 살펴보겠습니다. Bluetooth Low Energy (BLE) 연결 기능을 활용하여 Arduino Nano 33 BLE Sense 보드와 상호작용하고 LED 상태를 제어하며 센서에서 온도 데이터를 읽는 모바일 애플리케이션을 개발할 것입니다. 이 실습 가이드를 통해 iOS 앱과 Arduino 스케치를 개발하는 단계별 프로세스를 경험하면서 자체 IoT 프로젝트를 만들 수 있는 귀중한 기술을 습득할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_0.png" alt="이미지"></p>
<p>Nano 33 BLE Sense는 BLE 연결 및 센싱 기능이 필요한 프로젝트에 적합한 소형 Arduino 보드입니다. 다양한 센서를 갖추고 있어 IoT 응용 프로그램, 웨어러블 기기 및 데이터 획득 프로젝트에 적합합니다.</p>
<h1>BLE 통신 이해하기</h1>
<p>BLE는 저전력 기기를 위해 설계된 무선 통신 기술입니다. 이는 클라이언트-서버 아키텍처를 사용하며 다음과 같이 기기가 작동할 수 있습니다:</p>
<ul>
<li>중앙 (클라이언트): 통신을 시작하고 제어합니다.</li>
<li>주변 (서버): 액세스할 데이터 또는 작업을 제공합니다.</li>
</ul>
<p>서비스와 특성은 BLE 통신의 구성 요소입니다:</p>
<ul>
<li>서비스는 관련 기능이나 데이터 모음을 나타냅니다.</li>
<li>특징은 서비스 내에서 특정한 데이터 값을 가리킵니다.</li>
</ul>
<p>연결을 설정하려면 주변 기기가 광고 패킷이라는 작은 메시지를 방송하여 가용성을 알립니다. 중심 기기는 스캔 과정을 통해 이러한 패킷을 수신하고 주변 기기를 발견할 수 있습니다.</p>
<p>중심 기기가 관심 있는 주변 기기를 식별하면 연결을 설정하고 사용 가능한 서비스와 특징과 상호 작용을 시작할 수 있습니다.</p>
<p>우리 프로젝트에서 iOS 앱은 중심의 역할을 하고, Arduino 보드는 주변으로 동작합니다. 보드는 두 개의 별도 서비스 내에서 두 개의 특징을 통해 데이터를 노출할 것입니다:</p>
<ul>
<li>Led Status Characteristic (in Led Service): 이 특성은 쓰기 속성을 가진 특성으로, 앱이 0 (끄기) 또는 1 (켜기) 값을 쓰면 LED의 상태를 변경할 수 있습니다.</li>
<li>Temperature Characteristic (in Sensor Service): 이 특성은 읽기 및 알림 속성을 가진 특성으로, 보드에서 측정된 온도 값을 검색하고 온도 업데이트에 대한 알림을 받을 수 있도록 합니다.</li>
</ul>
<p><img src="/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_1.png" alt="이미지"></p>
<h1>Arduino 프로그램 빌드</h1>
<p>Arduino 프로그램은 ArduinoBLE 및 Arduino_HTS221 라이브러리를 활용하여 BLE 통신 및 온도 감지 기능을 가능하게 합니다.</p>
<pre><code class="hljs language-js">#include &#x3C;<span class="hljs-title class_">ArduinoBLE</span>.<span class="hljs-property">h</span>>
#include &#x3C;<span class="hljs-title class_">Arduino</span>_HTS221.<span class="hljs-property">h</span>>
</code></pre>
<p>먼저, 스케치는 UUID를 사용하여 필요한 BLE 서비스 및 특성을 설정하고 각 특성에 대한 속성을 정의합니다. UUID(Universally Unique Identifiers)는 BLE 통신 프로토콜에서 서비스 및 특성을 식별하는 데 사용되는 고유 식별자입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">BLEService</span> <span class="hljs-title function_">ledService</span>(<span class="hljs-string">"cd48409a-f3cc-11ed-a05b-0242ac120003"</span>);
<span class="hljs-title class_">BLEByteCharacteristic</span> <span class="hljs-title function_">ledstatusCharacteristic</span>(<span class="hljs-string">"cd48409b-f3cc-11ed-a05b-0242ac120003"</span>, <span class="hljs-title class_">BLEWrite</span>);

<span class="hljs-title class_">BLEService</span> <span class="hljs-title function_">sensorService</span>(<span class="hljs-string">"d888a9c2-f3cc-11ed-a05b-0242ac120003"</span>);
<span class="hljs-title class_">BLEByteCharacteristic</span> <span class="hljs-title function_">temperatureCharacteristic</span>(<span class="hljs-string">"d888a9c3-f3cc-11ed-a05b-0242ac120003"</span>, <span class="hljs-title class_">BLERead</span> | <span class="hljs-title class_">BLENotify</span>);
</code></pre>
<p>그런 다음, 프로그램은 BLE 모듈을 초기화하고 로컬 이름 및 광고 서비스를 설정합니다. 사용자가 정의한 로컬 이름은 Arduino에 의해 방송되며 페리퍼럴을 식별하는 사람이 읽을 수 있는 식별자 역할을 합니다. 광고 서비스를 Led 서비스로 설정함으로써, Arduino는 iOS 앱이나 다른 중앙 장치에게 제공하는 특정 서비스에 대해 알립니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ...</span>

    <span class="hljs-comment">// BLE 초기화</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable constant_">BLE</span>.<span class="hljs-title function_">begin</span>()) {
        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);
    }

    <span class="hljs-comment">// 광고할 로컬 이름과 서비스 UUID 설정</span>
    <span class="hljs-variable constant_">BLE</span>.<span class="hljs-title function_">setLocalName</span>(<span class="hljs-string">"iOSArduinoBoard"</span>);
    <span class="hljs-variable constant_">BLE</span>.<span class="hljs-title function_">setAdvertisedService</span>(ledService);
}
</code></pre>
<p>BLE 스택에 서비스와 특성이 추가되며, 온도 특성에 대한 읽기 요청 핸들러가 설정됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// 서비스에 특성 추가</span>
ledService.<span class="hljs-title function_">addCharacteristic</span>(ledstatusCharacteristic);
sensorService.<span class="hljs-title function_">addCharacteristic</span>(temperatureCharacteristic);

<span class="hljs-comment">// BLE 스택에 서비스 추가</span>
<span class="hljs-variable constant_">BLE</span>.<span class="hljs-title function_">addService</span>(ledService);
<span class="hljs-variable constant_">BLE</span>.<span class="hljs-title function_">addService</span>(sensorService);

<span class="hljs-comment">// 온도 특성에 대한 읽기 요청 핸들러 설정</span>
temperatureCharacteristic.<span class="hljs-title function_">setEventHandler</span>(<span class="hljs-title class_">BLERead</span>, temperatureCharacteristicRead);
</code></pre>
<p>프로그램은 광고를 시작하고 메인 루프에 진입합니다.</p>
<pre><code class="hljs language-js"> <span class="hljs-comment">// 광고 시작</span>
 <span class="hljs-variable constant_">BLE</span>.<span class="hljs-title function_">advertise</span>();
}
</code></pre>
<p>메인 루프에서는 중앙 기기가 연결하도록 대기하며, 연결되면 통신을 처리하는 루프를 시작합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">loop</span>(<span class="hljs-params"></span>) {  
  <span class="hljs-comment">// BLE 센트럴 기기가 연결될 때까지 대기</span>
  <span class="hljs-title class_">BLEDevice</span> central = <span class="hljs-variable constant_">BLE</span>.<span class="hljs-title function_">central</span>();

  <span class="hljs-comment">// 센트럴 기기가 페리페럴에 연결된 경우</span>
  <span class="hljs-keyword">if</span> (central) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">while</span> (central.<span class="hljs-title function_">connected</span>()) {
      <span class="hljs-comment">// ...</span>
    }
  }
}
</code></pre>
<p>이 루프 내에서 프로그램은 주기적으로 센서에서 온도를 읽어 올바른 온도 값을 업데이트합니다. 또한, 센트럴 기기가 LedStatus 특성에 새 값을 쓰지 않았는지 확인합니다. 새 값을 감지하면 LED를 켜거나 끕니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">while</span> (central.<span class="hljs-title function_">connected</span>()) {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// 온도 값을 읽어옴</span>
    temperature = (int) <span class="hljs-variable constant_">HTS</span>.<span class="hljs-title function_">readTemperature</span>();
    temperatureCharacteristic.<span class="hljs-title function_">writeValue</span>(temperature);
    
    <span class="hljs-comment">// ...</span>
    <span class="hljs-comment">// LedStatus characteristic의 쓰기 여부 확인</span>
    <span class="hljs-keyword">if</span> (ledstatusCharacteristic.<span class="hljs-title function_">written</span>()) {
        <span class="hljs-keyword">if</span> (ledstatusCharacteristic.<span class="hljs-title function_">value</span>()) {
            <span class="hljs-title function_">digitalWrite</span>(<span class="hljs-variable constant_">LED_BUILTIN</span>, <span class="hljs-variable constant_">HIGH</span>);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-title function_">digitalWrite</span>(<span class="hljs-variable constant_">LED_BUILTIN</span>, <span class="hljs-variable constant_">LOW</span>);
        }
    }
}
</code></pre>
<p>마지막으로, 온도 characteristic의 읽기 요청에 응답하기 위해 read 이벤트 핸들러 함수를 구현했습니다. 이 함수는 현재 온도 값을 characteristic에 작성합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">void</span> <span class="hljs-title function_">temperatureCharacteristicRead</span>(<span class="hljs-params">BLEDevice central, BLECharacteristic characteristic</span>) {
    temperatureCharacteristic.<span class="hljs-title function_">writeValue</span>(temperature);
}
</code></pre>
<h1>iOS 앱 설계</h1>
<p>iOS 앱은 사용자 친화적인 인터페이스로 설계되었으며 두 가지 주요 화면으로 구성되어 있습니다:</p>
<ul>
<li>스캔 화면: 앱을 실행할 때 초기화면으로 작동하여 사용자가 주변 기기를 스캔할 수 있게 합니다. 발견된 기기의 목록을 표시하며 사용자는 특정 기기의 이름을 탭하여 연결을 시작할 수 있습니다. 연결에 성공하면 앱은 연결 화면으로 전환됩니다.</li>
<li>연결 화면: 연결된 아두이노와 상호 작용할 수 있는 인터페이스를 제공합니다. 사용자는 LED의 상태를 수정하여 켜거나 끌 수 있습니다. 또한 사용자는 온도를 두 가지 모드로 읽을 수 있습니다: 단일 읽기(Read) 또는 변화의 지속적 모니터링(Notify).</li>
</ul>
<p><img src="/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_2.png" alt="이미지"></p>
<p>이 앱은 MVVM (Model-View-ViewModel) 디자인 패턴을 사용한 Clean Architecture에 영감을 받은 아키텍처로 구축되었으며 몇 가지 조정을 통해 단숨함과 이해하기 쉬운 요소를 향상시켰습니다. 이 접근 방식은 앱을 3개의 구분된 계층으로 구성하여 컴포넌트 독립성과 테스트 가능성을 촉진합니다:</p>
<ul>
<li>프리젠테이션 계층은 사용자 인터페이스와 상호 작용을 처리합니다. 이 계층은 View(사용자 인터페이스 렌더링 담당)와 ViewModel(View의 상태를 관리하는)으로 구성됩니다.</li>
<li>도메인 계층은 응용 프로그램의 핵심 비즈니스 로직을 나타냅니다. 이 계층은 사용 사례를 캡슐화하고 데이터와 상호 작용합니다. 사용 사례는 응용 프로그램에서 수행할 수 있는 특정 비즈니스 작업을 나타냅니다.</li>
<li>데이터 계층은 데이터 접근 및 지속성을 담당합니다. 데이터 작업을 추상화하는 엔티티를 포함합니다.</li>
</ul>
<p><img src="/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_3.png" alt="image"></p>
<p>앱은 CoreBluetooth를 활용하여 Bluetooth 관련 작업을 처리할 것입니다. CoreBluetooth는 Apple이 제공하는 프레임워크로, iOS 플랫폼에서 Bluetooth 기기와의 원활한 통신을 가능하게 합니다. Bluetooth 기능 구현을 간소화하는 포괄적인 기능 세트를 제공합니다.</p>
<p>CoreBluetooth를 활용하여, 앱은 주변의 Bluetooth 주변 기기를 탐지하고 연결을 설정하며 기기 간 데이터를 교환할 수 있을 것입니다.</p>
<p>자 이제 iOS 프로그래밍에 직접 참여해 봅시다!
시작하기 전에 필요한 필수 도구 몇 가지가 있습니다: 맥 컴퓨터와 Apple 플랫폼을 위한 공식 통합 개발 환경(Integrated Development Environment, IDE) 인 Xcode입니다. Xcode는 iOS 애플리케이션을 디자인, 코딩 및 디버깅할 수 있는 종합적인 도구 및 자원 세트를 제공합니다.</p>
<p>Xcode를 열고, 환영 화면에서 "새 Xcode 프로젝트 생성"을 선택하고 iOS 섹션에서 App 템플릿을 선택하세요. 고유한 제품명(iOSArduinoBLE)을 제공하고, 팀 식별자(귀하의 Apple ID 이름)를 선택하고, 언어(Swift)와 프로젝트를 저장할 위치를 선택하세요.</p>
<p>...여기까지입니다! 시작해 봅시다.</p>
<h1>iOS 앱: Arduino 보드를 스캔하고 연결하기</h1>
<p>스캔 화면에서 사용자는 깔끔하고 직관적인 UI로 BLE 장치를 발견하고 연결할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_5.png" alt="이미지"></p>
<p>이 화면의 기본 아키텍처는 다음과 같습니다:</p>
<ul>
<li>ScanView: 화면의 UI를 렌더링하는 데 책임이 있습니다. SwiftUI를 사용하여 디자인되었습니다.</li>
<li>ScanViewModel: "Start Scan" 버튼을 탭하거나 장치 이름을 선택하는 이벤트를 처리합니다. 스캔 및 연결 작업을 실행하기 위해 ScanViewModel은 CentralUseCase에 의존합니다.</li>
<li>CentralUseCase: CoreBluetooth 프레임워크와 상호 작용하기 위한 필수 로직을 캡슐화하며, CBCentralManager 객체를 활용합니다. 이 객체는 프레임워크 내에서 스캔을 시작하고 연결을 설정하며 주변기기를 관리합니다.</li>
</ul>
<p><img src="/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_6.png" alt="이미지"></p>
<p>데이터 레이어에는 Peripheral 및 UUIDs 두 가지 엔티티가 포함되어 있습니다. Peripheral 객체는 BLE 장치를 나타내며, 장치 이름, 식별자 및 기타 관련 속성과 같은 세부 정보를 보유합니다. UUIDs는 응용 프로그램에서 사용할 서비스 및 특성 목록을 보유하는 컬렉션입니다.</p>
<h1>스캐닝</h1>
<p>"Start Scan" 버튼을 누르면 ScanView가 사용자 상호작용을 캡처하고 요청을 처리하기 위해 ScanViewModel로 전달합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//  ScanView.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-title class_">Button</span> {
    viewModel.<span class="hljs-title function_">scan</span>()
} <span class="hljs-attr">label</span>: {
    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"Start Scan"</span>)
    .<span class="hljs-title function_">frame</span>(<span class="hljs-attr">maxWidth</span>: .<span class="hljs-property">infinity</span>)
}
<span class="hljs-comment">// ...</span>
</code></pre>
<p>ScanViewModel은 상호작용을 받으면 해당 사용 사례에서 스캔 기능을 트리거합니다. 사용 사례는 LedService를 광고하는 디바이스만 찾도록 지시 받습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//  ScanViewModel.swift</span>
<span class="hljs-comment">// ...</span>
func <span class="hljs-title function_">scan</span>(<span class="hljs-params"></span>) {
    useCase.<span class="hljs-title function_">scan</span>(<span class="hljs-attr">for</span>: [<span class="hljs-title class_">UUIDs</span>.<span class="hljs-property">ledService</span>])
}
</code></pre>
<p>최종적으로 사용 사례는 CoreBluetooth 프레임워크와 상호 작용하여 스캔 프로시저를 시작합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// CentralUseCase.swift</span>
<span class="hljs-comment">// ...</span>
lazy <span class="hljs-keyword">var</span> <span class="hljs-attr">central</span>: <span class="hljs-title class_">CBCentralManager</span> = {
 <span class="hljs-title class_">CBCentralManager</span>(<span class="hljs-attr">delegate</span>: self, <span class="hljs-attr">queue</span>: <span class="hljs-title class_">DispatchQueue</span>.<span class="hljs-property">main</span>)
}()

func <span class="hljs-title function_">scan</span>(<span class="hljs-params"><span class="hljs-keyword">for</span> services: [CBUUID]</span>) {
 guard central.<span class="hljs-property">isScanning</span> == <span class="hljs-literal">false</span> <span class="hljs-keyword">else</span> {
     <span class="hljs-keyword">return</span>
 }
 central.<span class="hljs-title function_">scanForPeripherals</span>(<span class="hljs-attr">withServices</span>: services, <span class="hljs-attr">options</span>: [:])
}
</code></pre>
<p>CoreBluetooth에서 scanForPeripherals 함수를 사용할 때, CBCentralManagerDelegate 메소드를 통해 응답을 처리할 수 있습니다. 발견된 페리페럴을 처리하는 델리게이트 메소드는 didDiscover이며, 스캔 과정 중에 페리페랄이 발견될 때마다 호출됩니다.</p>
<p>기기가 발견되면 CentralUseCase는 onPeripheralDiscovery 클로저(즉, 자체 포함된 코드 블록)를 호출하여 새로 발견된 페리페럴의 세부 정보를 제공합니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// CentralUseCase.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">extension</span> <span class="hljs-title class_">CentralUseCase</span>: <span class="hljs-title class_">CBCentralManagerDelegate</span> {
  <span class="hljs-keyword">func</span> <span class="hljs-title function_">centralManager</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">central</span>: <span class="hljs-type">CBCentralManager</span>, <span class="hljs-params">didDiscover</span> <span class="hljs-params">peripheral</span>: <span class="hljs-type">CBPeripheral</span>,
                       <span class="hljs-params">advertisementData</span>: [<span class="hljs-params">String</span> : <span class="hljs-keyword">Any</span>], <span class="hljs-params">rssi</span> <span class="hljs-params">RSSI</span>: <span class="hljs-type">NSNumber</span>) {
      onPeripheralDiscovery<span class="hljs-operator">?</span>(.<span class="hljs-keyword">init</span>(cbPeripheral: peripheral))
  }
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>ScanViewModel은 내부 상태를 업데이트하고 ScanView에 새로운 장치가 주변 장치 목록에 표시될 준비가 되었음을 알립니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// ScanViewModel.swift</span>
<span class="hljs-comment">// ...</span>
useCase.onPeripheralDiscovery <span class="hljs-operator">=</span> { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] peripheral <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> <span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span> <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span>
    }
    <span class="hljs-keyword">self</span>.foundPeripherals.insert(peripheral)
    <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> .scan(<span class="hljs-type">Array</span>(<span class="hljs-keyword">self</span>.foundPeripherals))
}
</code></pre>
<pre><code class="hljs language-swift"><span class="hljs-comment">// ScanView.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-type">VStack</span> {
    <span class="hljs-type">List</span>(peripheralList, id: \.id) { peripheral <span class="hljs-keyword">in</span>
        <span class="hljs-type">Text</span>(<span class="hljs-string">"<span class="hljs-subst">\(peripheral.name <span class="hljs-operator">??</span> <span class="hljs-string">"N/A"</span>)</span>"</span>)
        <span class="hljs-comment">// ...</span>
    }
}
<span class="hljs-comment">// ...</span>
}
.onReceive(viewModel.<span class="hljs-variable">$state</span>) { state <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">switch</span> state {
        <span class="hljs-comment">// ...</span>
        <span class="hljs-keyword">case</span> .scan(<span class="hljs-keyword">let</span> list):
            peripheralList <span class="hljs-operator">=</span> list
        <span class="hljs-comment">// ...</span>
    }
}
</code></pre>
<h1>연결하기</h1>
<p>목록 중 한 장치를 누르면 ScanView가 사용자 상호 작용을 캡처하고 해당 페리페럴에 연결하기 위해 ScanViewModel에 요청을 전달합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// ScanView.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-title class_">List</span>(peripheralList, <span class="hljs-attr">id</span>: \.<span class="hljs-property">id</span>) { peripheral <span class="hljs-keyword">in</span>
    <span class="hljs-title class_">Text</span>(<span class="hljs-string">"\(peripheral.name ?? "</span>N/A<span class="hljs-string">")"</span>)
        <span class="hljs-comment">// ...</span>
        .<span class="hljs-property">onTapGesture</span> {
            viewModel.<span class="hljs-title function_">connect</span>(<span class="hljs-attr">to</span>: peripheral)
        }
}
</code></pre>
<p>이 작업은 ScanViewModel이 연결 작업을 해당 사용 사례에 전달하도록 유도합니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">//  ScanViewModel.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">to</span> <span class="hljs-params">peripheral</span>: <span class="hljs-type">Peripheral</span>) {
    useCase.connect(to: peripheral)
}
</code></pre>
<p>마침내 사용 사례는 선택한 장치와 연결 프로세스를 시작하는 동안 스캐닝 프로세스를 중단하여 CoreBluetooth 프레임워크와 상호 작용합니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">//  CentralUseCase.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">connect</span>(<span class="hljs-params">to</span> <span class="hljs-params">peripheral</span>: <span class="hljs-type">Peripheral</span>) {
    central.stopScan()
    central.connect(peripheral.cbPeripheral<span class="hljs-operator">!</span>)
}
</code></pre>
<p>연결이 성공하면 didConnect 대리자 메서드가 호출됩니다. CentralUseCase는 이 정보를 ScanViewModel에게 onConnection 클로저를 호출하여 전달합니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">//  CentralUseCase.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">centralManager</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">central</span>: <span class="hljs-type">CBCentralManager</span>, <span class="hljs-params">didConnect</span> <span class="hljs-params">peripheral</span>: <span class="hljs-type">CBPeripheral</span>) {
    onConnection<span class="hljs-operator">?</span>(.<span class="hljs-keyword">init</span>(cbPeripheral: peripheral))
}
</code></pre>
<p>ScanViewModel은 내부 상태를 업데이트하고 선택한 장치와의 연결이 설정되었음을 ScanView에 알립니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">//  ScanViewModel.swift</span>
<span class="hljs-comment">// ...</span>
useCase.onConnection <span class="hljs-operator">=</span> { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] peripheral <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.state <span class="hljs-operator">=</span> .connected(peripheral)
}
</code></pre>
<p>그에 따라 ScanView는 ConnectView로 전환합니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">// ScanView.swift</span>
<span class="hljs-comment">// ...</span>
.onReceive(viewModel.<span class="hljs-variable">$state</span>) { state <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">switch</span> state {
    <span class="hljs-keyword">case</span> .connected:
        shouldShowDetail <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>
    <span class="hljs-comment">// ...</span>
    }
}
.navigationDestination(isPresented: <span class="hljs-variable">$shouldShowDetail</span>) {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .connected(peripheral) <span class="hljs-operator">=</span> viewModel.state  {
        <span class="hljs-keyword">let</span> viewModel <span class="hljs-operator">=</span> <span class="hljs-type">ConnectViewModel</span>(useCase: <span class="hljs-type">PeripheralUseCase</span>(),
            connectedPeripheral: peripheral)
        <span class="hljs-type">ConnectView</span>(viewModel: viewModel)
    }
}
</code></pre>
<h1>iOS 앱: 데이터 쓰기 및 읽기</h1>
<p>Connect 화면에서 사용자는 Arduino와 상호 작용하여 LED 및 온도와 관련된 정보를 교환할 수 있습니다.</p>
<p>아키텍처는 이전 화면과 일관성을 유지하며 다음 구성 요소를 포함합니다:</p>
<ul>
<li>ConnectView: LED 상태를 제어하는 UI 요소, 온도 정보를 읽는 UI 요소, 및 장치와의 연결을 해제하는 UI 요소를 표현합니다. SwiftUI를 사용하여 구현되었습니다.</li>
<li>ConnectViewModel: LED 제어를 위한 온/오프 버튼을 탭하거나 온도 알림 활성화를 전환하거나 즉시 온도를 읽는 버튼을 누르는 등 사용자 상호작용을 캡처합니다. 또한 연산을 처리하기 위해 PeripheralUseCase와 통신합니다.</li>
<li>PeripheralUseCase: CentralUseCase와 유사하게 CoreBluetooth와 관련된 로직을 담당합니다. CBPeripheral 객체와 상호작용하여 특성과 서비스를 통해 데이터를 관리하고 교환합니다.</li>
</ul>
<p><img src="/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_8.png" alt="아무 이미지"></p>
<p>서비스와 특성과의 데이터 교환을 시작하기 전에 발견 단계를 수행해야 합니다. 이 단계에서 CoreBluetooth 프레임워크는 연결된 주변 장치에 의해 제공되는 사용 가능한 서비스와 특성에 대한 정보를 스캔하고 검색합니다.</p>
<h1>발견</h1>
<p>ConnectViewModel 및 해당 PeripheralUseCase를 생성한 후에는 발견 서비스 프로시저가 시작됩니다. 발견된 각 서비스에는 해당하는 특성도 발견됩니다.</p>
<p>CoreBluetooth 프레임워크에서의 응답은 각각의 대리자 메서드인 didDiscoverServices 및 didDiscoverCharacteristicsFor로 전달됩니다. 이러한 메서드는 장치에서 발견된 서비스 및 특성에 대한 정보를 앱에 제공합니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">//  PeripheralUseCase.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">discoverServices</span>() {
 cbPeripheral<span class="hljs-operator">?</span>.discoverServices([<span class="hljs-type">UUIDs</span>.ledService, <span class="hljs-type">UUIDs</span>.sensorService])
}
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">peripheral</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">peripheral</span>: <span class="hljs-type">CBPeripheral</span>, <span class="hljs-params">didDiscoverServices</span> <span class="hljs-params">error</span>: <span class="hljs-type">Error</span>?) {
 <span class="hljs-comment">// ...</span>
  <span class="hljs-keyword">for</span> service <span class="hljs-keyword">in</span> services {
      <span class="hljs-comment">// ...</span>
      peripheral.discoverCharacteristics(uuids, for: service)
  }
}
</code></pre>
<p>Once the discovery process is completed, the <code>ConnectViewModel</code> is notified with <code>onPeripheralReady</code>, and the UI is prepared to handle operations on the discovered characteristics.</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// PeripheralUseCase.swift</span>
<span class="hljs-comment">// ...</span>
func <span class="hljs-title function_">peripheral</span>(<span class="hljs-params">_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: <span class="hljs-built_in">Error</span>?</span>) {
  <span class="hljs-keyword">for</span> characteristic <span class="hljs-keyword">in</span> characteristics {
      discoveredCharacteristics[characteristic.<span class="hljs-property">uuid</span>] = characteristic
  }

  <span class="hljs-keyword">if</span> discoveredCharacteristics[<span class="hljs-title class_">UUIDs</span>.<span class="hljs-property">temperatureCharacteristic</span>] != nil &#x26;&#x26;
      discoveredCharacteristics[<span class="hljs-title class_">UUIDs</span>.<span class="hljs-property">ledStatusCharacteristic</span>] != nil {
      onPeripheralReady?()
  }
}
</code></pre>
<h1>Controlling LED</h1>
<p>When the user presses the on/off buttons, it triggers a write operation to the LedStatus characteristic with a numerical value (1 for “On” and 0 for “Off”). This action, in turn, controls the integrated LED on the board, either turning it on or off accordingly.</p>
<p>일반적인 흐름을 따라 전체 프로세스가 관리됩니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// ConnectView.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-title class_">Button</span>(<span class="hljs-string">"On"</span>) {
    viewModel.<span class="hljs-title function_">turnOnLed</span>()
}
<span class="hljs-comment">// ...</span>
<span class="hljs-title class_">Button</span>(<span class="hljs-string">"Off"</span>) {
    viewModel.<span class="hljs-title function_">turnOffLed</span>()
}

<span class="hljs-comment">// ConnectViewModel.swift</span>
<span class="hljs-comment">// ...</span>
func <span class="hljs-title function_">turnOnLed</span>(<span class="hljs-params"></span>) {
    useCase.<span class="hljs-title function_">writeLedState</span>(<span class="hljs-attr">isOn</span>: <span class="hljs-literal">true</span>)
}

func <span class="hljs-title function_">turnOffLed</span>(<span class="hljs-params"></span>) {
    useCase.<span class="hljs-title function_">writeLedState</span>(<span class="hljs-attr">isOn</span>: <span class="hljs-literal">false</span>)
}

<span class="hljs-comment">// PeripheralUseCase.swift</span>
<span class="hljs-comment">// ...</span>
func <span class="hljs-title function_">writeLedState</span>(<span class="hljs-params">isOn: Bool</span>) {
    cbPeripheral?.<span class="hljs-title function_">writeValue</span>(<span class="hljs-title class_">Data</span>(isOn ? [<span class="hljs-number">0x01</span>] : [<span class="hljs-number">0x00</span>]), <span class="hljs-attr">for</span>: ledCharacteristic, <span class="hljs-attr">type</span>: .<span class="hljs-property">withResponse</span>)
}
</code></pre>
<h1>온도 읽기</h1>
<p>온도 측정은 두 가지 방법으로 수행할 수 있습니다: 한 번의 값을 얻기 위해 트리거되는 읽기 작업을 사용하는 싱글 샷 모드 또는 실시간 업데이트를 받기 위해 알림 작업을 사용하는 연속 모드입니다.</p>
<p>다음은 읽기 작업 요청의 흐름입니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//  ConnectView.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-title class_">Button</span>(<span class="hljs-string">"READ"</span>) {
  viewModel.<span class="hljs-title function_">readTemperature</span>()
}

<span class="hljs-comment">//  ConnectViewModel.swift</span>
<span class="hljs-comment">// ...</span>
func <span class="hljs-title function_">readTemperature</span>(<span class="hljs-params"></span>) {
  useCase.<span class="hljs-title function_">readTemperature</span>()
}

<span class="hljs-comment">//  PeripheralUseCase.swift</span>
<span class="hljs-comment">// ...</span>
func <span class="hljs-title function_">readTemperature</span>(<span class="hljs-params"></span>) {
 cbPeripheral?.<span class="hljs-title function_">readValue</span>(<span class="hljs-attr">for</span>: tempCharacteristic)
}
</code></pre>
<p>알림 작업 흐름의 활성화/비활성화는 동일한 패턴을 따릅니다:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">//  ConnectView.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-title class_">Toggle</span>(<span class="hljs-string">"Notify"</span>, <span class="hljs-attr">isOn</span>: $isToggleOn)
<span class="hljs-comment">// ...</span>
.<span class="hljs-title function_">onChange</span>(<span class="hljs-params"><span class="hljs-keyword">of</span>: isToggleOn</span>) { newValue <span class="hljs-keyword">in</span>
 <span class="hljs-keyword">if</span> newValue == <span class="hljs-literal">true</span> {
  viewModel.<span class="hljs-title function_">startNotifyTemperature</span>()
 } <span class="hljs-keyword">else</span> {
  viewModel.<span class="hljs-title function_">stopNotifyTemperature</span>()
 }
}

<span class="hljs-comment">//  ConnectViewModel.swift</span>
<span class="hljs-comment">// ...</span>
func <span class="hljs-title function_">startNotifyTemperature</span>(<span class="hljs-params"></span>) {
  useCase.<span class="hljs-title function_">notifyTemperature</span>(<span class="hljs-literal">true</span>)
}

func <span class="hljs-title function_">stopNotifyTemperature</span>(<span class="hljs-params"></span>) {
  useCase.<span class="hljs-title function_">notifyTemperature</span>(<span class="hljs-literal">false</span>)
}

<span class="hljs-comment">//  PeripheralUseCase.swift</span>
<span class="hljs-comment">// ...</span>
func <span class="hljs-title function_">notifyTemperature</span>(<span class="hljs-params">_ isOn: Bool</span>) {
 cbPeripheral?.<span class="hljs-title function_">setNotifyValue</span>(isOn, <span class="hljs-attr">for</span>: tempCharacteristic)
}
</code></pre>
<p>두 작업은 모두 CoreBluetooth의 동일한 대리자에 응답을 생성합니다. 구체적으로 didUpdateValueFor 메서드입니다. 읽기 작업의 경우 요청한 데이터와 함께 단일 응답이 있을 것입니다. 알림의 경우, 알림이 비활성화될 때까지 응답이 계속 전송됩니다. 각 응답은 UI 상태를 업데이트하기 위해 ConnectViewModel의 onReadTemperature 클로저를 트리거합니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">//  PeripheralUseCase.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">peripheral</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">peripheral</span>: <span class="hljs-type">CBPeripheral</span>, <span class="hljs-params">didUpdateValueFor</span> <span class="hljs-params">characteristic</span>: <span class="hljs-type">CBCharacteristic</span>, <span class="hljs-params">error</span>: <span class="hljs-type">Error</span>?) {
  <span class="hljs-keyword">switch</span> characteristic.uuid {
   <span class="hljs-keyword">case</span> <span class="hljs-type">UUIDs</span>.temperatureCharacteristic:
     <span class="hljs-keyword">let</span> value: <span class="hljs-type">UInt8</span> <span class="hljs-operator">=</span> {
       <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> value <span class="hljs-operator">=</span> characteristic.value<span class="hljs-operator">?</span>.first <span class="hljs-keyword">else</span> {
         <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
       }
       <span class="hljs-keyword">return</span> value
     }()
     onReadTemperature<span class="hljs-operator">?</span>(<span class="hljs-type">Int</span>(value))
  }
}

<span class="hljs-comment">//  ConnectViewModel.swift</span>
<span class="hljs-comment">// ...</span>
useCase.onReadTemperature <span class="hljs-operator">=</span> { [<span class="hljs-keyword">weak</span> <span class="hljs-keyword">self</span>] value <span class="hljs-keyword">in</span>
 <span class="hljs-keyword">self</span><span class="hljs-operator">?</span>.state <span class="hljs-operator">=</span> .temperature(value)
}

<span class="hljs-comment">//  ConnectView.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-meta">@State</span> <span class="hljs-keyword">var</span> lastTemperature: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-type">Text</span>(<span class="hljs-string">"<span class="hljs-subst">\(lastTemperature)</span> °C"</span>)
<span class="hljs-comment">// ...</span>
.onReceive(viewModel.<span class="hljs-variable">$state</span>) { state <span class="hljs-keyword">in</span>
  <span class="hljs-keyword">switch</span> state {
   <span class="hljs-comment">// ...</span>
   <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .temperature(temp):
       lastTemperature <span class="hljs-operator">=</span> temp
  }
}
</code></pre>
<h1>연결 해제</h1>
<p>연결 해제 버튼을 누르면 흐름이 약간 다른 방향으로 진행됩니다. 연결 해제 작업은 CBCentralManager 객체에 속하므로 CentralUseCase에서 수행되어야 합니다. 이를 가능하게 하기 위해 사용자가 버튼을 누르면 현재 화면이 해제되고 사용자는 스캔 화면으로 돌아갑니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">//  ConnectView.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-type">Button</span> {
  dismiss()
} label: {
  <span class="hljs-type">Text</span>(<span class="hljs-string">"연결 해제"</span>)
  .frame(maxWidth: .infinity)
}
</code></pre>
<p>ScanView가 나타날 때, 수행하는 첫 번째 작업은 이미 연결된 장치가 있는지 확인하고 있다면 연결을 해제하는 것입니다. 이 작업은 해당 ScanViewModel에서 처리되며, 그런 다음 CentralUseCase에 해당 요청을 전달하여 CoreBluetooth 프레임워크에서 연결 해제 작업을 수행합니다.</p>
<pre><code class="hljs language-swift"><span class="hljs-comment">//  ScanView.swift</span>
<span class="hljs-comment">// ...</span>
.onAppear {
  viewModel.disconnectIfConnected()
}

<span class="hljs-comment">//  ScanViewModel.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">disconnectIfConnected</span>() {
  <span class="hljs-keyword">guard</span> <span class="hljs-keyword">case</span> <span class="hljs-keyword">let</span> .connected(peripheral) <span class="hljs-operator">=</span> state,
  peripheral.cbPeripheral <span class="hljs-operator">!=</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">return</span>
  }
  useCase.disconnect(from: peripheral)
}

<span class="hljs-comment">//  CentralUseCase.swift</span>
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">func</span> <span class="hljs-title function_">disconnect</span>(<span class="hljs-params">from</span> <span class="hljs-params">peripheral</span>: <span class="hljs-type">Peripheral</span>) {
  central.cancelPeripheralConnection(peripheral.cbPeripheral<span class="hljs-operator">!</span>)
}
</code></pre>
<h1>결론</h1>
<p>이 글에서는 Arduino 프로그래밍부터 iOS 앱 개발로 이동하는 여정을 살펴보았는데, 이 과정에서 BLE 연결을 통해 IoT 프로젝트를 구축하는 데 초점을 맞추었습니다.</p>
<p>우리는 Xcode와 CoreBluetooth 프레임워크를 사용하여 iOS 앱을 만드는 방법을 배웠습니다. BLE의 기본 지식을 습득하고, 청결한 아키텍처 원칙을 공부하며, 확장 가능하고 유지보수 가능한 코드베이스를 보장하기 위해 MVVM 디자인 패턴을 구현해 보았습니다.</p>
<p>이 프로젝트는 여러분의 IoT 프로젝트를 시작하는 좋은 지점이 될 수 있습니다. 그러나 CoreBluetooth를 직접 사용하는 것은 백그라운드 작업 처리의 복잡도와 상위 수준의 기능(메쉬, 펌웨어 업데이트 등) 부족과 같은 몇 가지 제한 사항이 있을 수 있습니다. 이러한 제한 사항을 극복하기 위해, 추가적인 추상화 계층과 고급 기능을 지원하는 서드파티 라이브러리를 활용하는 것이 좋습니다.
일부 인기 있는 옵션은 다음과 같습니다:</p>
<ul>
<li>RxBluetoothKit: 강력한 ReactiveX 기반 BLE 라이브러리.</li>
<li>Bluejay: 간편하고 사용하기 쉬운 BLE 라이브러리를 강조하는 현대적인 라이브러리.</li>
<li>LittleBlueTooth: 가벼우면서 간편한 BLE 라이브러리.</li>
</ul>
<h1>코드</h1>
<ul>
<li>iOSArduinoBLE_ArduinoSketch</li>
<li>iOSArduinoBLE_iOSApp</li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"아두이노 프로그래밍에서 iOS 앱 개발로","description":"","date":"2024-06-20 16:48","slug":"2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment","content":"\n\n## BLE 연결을 통한 IoT 프로젝트 구축 실습 가이드\n\n이 튜토리얼에서는 iOS 앱 개발과 Arduino 프로그래밍의 세계를 탐험하면서 전자 보드를 무선으로 제어할 수 있는 간단한 시스템을 생성하는 방법을 살펴보겠습니다. Bluetooth Low Energy (BLE) 연결 기능을 활용하여 Arduino Nano 33 BLE Sense 보드와 상호작용하고 LED 상태를 제어하며 센서에서 온도 데이터를 읽는 모바일 애플리케이션을 개발할 것입니다. 이 실습 가이드를 통해 iOS 앱과 Arduino 스케치를 개발하는 단계별 프로세스를 경험하면서 자체 IoT 프로젝트를 만들 수 있는 귀중한 기술을 습득할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_0.png)\n\nNano 33 BLE Sense는 BLE 연결 및 센싱 기능이 필요한 프로젝트에 적합한 소형 Arduino 보드입니다. 다양한 센서를 갖추고 있어 IoT 응용 프로그램, 웨어러블 기기 및 데이터 획득 프로젝트에 적합합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# BLE 통신 이해하기\n\nBLE는 저전력 기기를 위해 설계된 무선 통신 기술입니다. 이는 클라이언트-서버 아키텍처를 사용하며 다음과 같이 기기가 작동할 수 있습니다:\n\n- 중앙 (클라이언트): 통신을 시작하고 제어합니다.\n- 주변 (서버): 액세스할 데이터 또는 작업을 제공합니다.\n\n서비스와 특성은 BLE 통신의 구성 요소입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 서비스는 관련 기능이나 데이터 모음을 나타냅니다.\n- 특징은 서비스 내에서 특정한 데이터 값을 가리킵니다.\n\n연결을 설정하려면 주변 기기가 광고 패킷이라는 작은 메시지를 방송하여 가용성을 알립니다. 중심 기기는 스캔 과정을 통해 이러한 패킷을 수신하고 주변 기기를 발견할 수 있습니다.\n\n중심 기기가 관심 있는 주변 기기를 식별하면 연결을 설정하고 사용 가능한 서비스와 특징과 상호 작용을 시작할 수 있습니다.\n\n우리 프로젝트에서 iOS 앱은 중심의 역할을 하고, Arduino 보드는 주변으로 동작합니다. 보드는 두 개의 별도 서비스 내에서 두 개의 특징을 통해 데이터를 노출할 것입니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- Led Status Characteristic (in Led Service): 이 특성은 쓰기 속성을 가진 특성으로, 앱이 0 (끄기) 또는 1 (켜기) 값을 쓰면 LED의 상태를 변경할 수 있습니다.\n- Temperature Characteristic (in Sensor Service): 이 특성은 읽기 및 알림 속성을 가진 특성으로, 보드에서 측정된 온도 값을 검색하고 온도 업데이트에 대한 알림을 받을 수 있도록 합니다.\n\n![이미지](/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_1.png)\n\n# Arduino 프로그램 빌드\n\nArduino 프로그램은 ArduinoBLE 및 Arduino_HTS221 라이브러리를 활용하여 BLE 통신 및 온도 감지 기능을 가능하게 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\r\n#include \u003cArduinoBLE.h\u003e\n#include \u003cArduino_HTS221.h\u003e\r\n```\n\n먼저, 스케치는 UUID를 사용하여 필요한 BLE 서비스 및 특성을 설정하고 각 특성에 대한 속성을 정의합니다. UUID(Universally Unique Identifiers)는 BLE 통신 프로토콜에서 서비스 및 특성을 식별하는 데 사용되는 고유 식별자입니다.\n\n```js\r\nBLEService ledService(\"cd48409a-f3cc-11ed-a05b-0242ac120003\");\nBLEByteCharacteristic ledstatusCharacteristic(\"cd48409b-f3cc-11ed-a05b-0242ac120003\", BLEWrite);\n\nBLEService sensorService(\"d888a9c2-f3cc-11ed-a05b-0242ac120003\");\nBLEByteCharacteristic temperatureCharacteristic(\"d888a9c3-f3cc-11ed-a05b-0242ac120003\", BLERead | BLENotify);\r\n```\n\n그런 다음, 프로그램은 BLE 모듈을 초기화하고 로컬 이름 및 광고 서비스를 설정합니다. 사용자가 정의한 로컬 이름은 Arduino에 의해 방송되며 페리퍼럴을 식별하는 사람이 읽을 수 있는 식별자 역할을 합니다. 광고 서비스를 Led 서비스로 설정함으로써, Arduino는 iOS 앱이나 다른 중앙 장치에게 제공하는 특정 서비스에 대해 알립니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nvoid setup() {\n    // ...\n\n    // BLE 초기화\n    if (!BLE.begin()) {\n        while (1);\n    }\n\n    // 광고할 로컬 이름과 서비스 UUID 설정\n    BLE.setLocalName(\"iOSArduinoBoard\");\n    BLE.setAdvertisedService(ledService);\n}\n```\n\nBLE 스택에 서비스와 특성이 추가되며, 온도 특성에 대한 읽기 요청 핸들러가 설정됩니다.\n\n```js\n// 서비스에 특성 추가\nledService.addCharacteristic(ledstatusCharacteristic);\nsensorService.addCharacteristic(temperatureCharacteristic);\n\n// BLE 스택에 서비스 추가\nBLE.addService(ledService);\nBLE.addService(sensorService);\n\n// 온도 특성에 대한 읽기 요청 핸들러 설정\ntemperatureCharacteristic.setEventHandler(BLERead, temperatureCharacteristicRead);\n```\n\n프로그램은 광고를 시작하고 메인 루프에 진입합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n // 광고 시작\n BLE.advertise();\n}\n```\n\n메인 루프에서는 중앙 기기가 연결하도록 대기하며, 연결되면 통신을 처리하는 루프를 시작합니다.\n\n```js\nvoid loop() {  \n  // BLE 센트럴 기기가 연결될 때까지 대기\n  BLEDevice central = BLE.central();\n\n  // 센트럴 기기가 페리페럴에 연결된 경우\n  if (central) {\n    // ...\n    while (central.connected()) {\n      // ...\n    }\n  }\n}\n```\n\n이 루프 내에서 프로그램은 주기적으로 센서에서 온도를 읽어 올바른 온도 값을 업데이트합니다. 또한, 센트럴 기기가 LedStatus 특성에 새 값을 쓰지 않았는지 확인합니다. 새 값을 감지하면 LED를 켜거나 끕니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nwhile (central.connected()) {\n    // ...\n    // 온도 값을 읽어옴\n    temperature = (int) HTS.readTemperature();\n    temperatureCharacteristic.writeValue(temperature);\n    \n    // ...\n    // LedStatus characteristic의 쓰기 여부 확인\n    if (ledstatusCharacteristic.written()) {\n        if (ledstatusCharacteristic.value()) {\n            digitalWrite(LED_BUILTIN, HIGH);\n        } else {\n            digitalWrite(LED_BUILTIN, LOW);\n        }\n    }\n}\n```\n\n마지막으로, 온도 characteristic의 읽기 요청에 응답하기 위해 read 이벤트 핸들러 함수를 구현했습니다. 이 함수는 현재 온도 값을 characteristic에 작성합니다.\n\n```js\nvoid temperatureCharacteristicRead(BLEDevice central, BLECharacteristic characteristic) {\n    temperatureCharacteristic.writeValue(temperature);\n}\n```\n\n# iOS 앱 설계\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\niOS 앱은 사용자 친화적인 인터페이스로 설계되었으며 두 가지 주요 화면으로 구성되어 있습니다:\n\n- 스캔 화면: 앱을 실행할 때 초기화면으로 작동하여 사용자가 주변 기기를 스캔할 수 있게 합니다. 발견된 기기의 목록을 표시하며 사용자는 특정 기기의 이름을 탭하여 연결을 시작할 수 있습니다. 연결에 성공하면 앱은 연결 화면으로 전환됩니다.\n- 연결 화면: 연결된 아두이노와 상호 작용할 수 있는 인터페이스를 제공합니다. 사용자는 LED의 상태를 수정하여 켜거나 끌 수 있습니다. 또한 사용자는 온도를 두 가지 모드로 읽을 수 있습니다: 단일 읽기(Read) 또는 변화의 지속적 모니터링(Notify).\n\n![이미지](/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_2.png)\n\n이 앱은 MVVM (Model-View-ViewModel) 디자인 패턴을 사용한 Clean Architecture에 영감을 받은 아키텍처로 구축되었으며 몇 가지 조정을 통해 단숨함과 이해하기 쉬운 요소를 향상시켰습니다. 이 접근 방식은 앱을 3개의 구분된 계층으로 구성하여 컴포넌트 독립성과 테스트 가능성을 촉진합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 프리젠테이션 계층은 사용자 인터페이스와 상호 작용을 처리합니다. 이 계층은 View(사용자 인터페이스 렌더링 담당)와 ViewModel(View의 상태를 관리하는)으로 구성됩니다.\n- 도메인 계층은 응용 프로그램의 핵심 비즈니스 로직을 나타냅니다. 이 계층은 사용 사례를 캡슐화하고 데이터와 상호 작용합니다. 사용 사례는 응용 프로그램에서 수행할 수 있는 특정 비즈니스 작업을 나타냅니다.\n- 데이터 계층은 데이터 접근 및 지속성을 담당합니다. 데이터 작업을 추상화하는 엔티티를 포함합니다.\n\n![image](/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_3.png)\n\n앱은 CoreBluetooth를 활용하여 Bluetooth 관련 작업을 처리할 것입니다. CoreBluetooth는 Apple이 제공하는 프레임워크로, iOS 플랫폼에서 Bluetooth 기기와의 원활한 통신을 가능하게 합니다. Bluetooth 기능 구현을 간소화하는 포괄적인 기능 세트를 제공합니다.\n\nCoreBluetooth를 활용하여, 앱은 주변의 Bluetooth 주변 기기를 탐지하고 연결을 설정하며 기기 간 데이터를 교환할 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n자 이제 iOS 프로그래밍에 직접 참여해 봅시다!\n시작하기 전에 필요한 필수 도구 몇 가지가 있습니다: 맥 컴퓨터와 Apple 플랫폼을 위한 공식 통합 개발 환경(Integrated Development Environment, IDE) 인 Xcode입니다. Xcode는 iOS 애플리케이션을 디자인, 코딩 및 디버깅할 수 있는 종합적인 도구 및 자원 세트를 제공합니다.\n\nXcode를 열고, 환영 화면에서 \"새 Xcode 프로젝트 생성\"을 선택하고 iOS 섹션에서 App 템플릿을 선택하세요. 고유한 제품명(iOSArduinoBLE)을 제공하고, 팀 식별자(귀하의 Apple ID 이름)를 선택하고, 언어(Swift)와 프로젝트를 저장할 위치를 선택하세요.\n\n...여기까지입니다! 시작해 봅시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# iOS 앱: Arduino 보드를 스캔하고 연결하기\n\n스캔 화면에서 사용자는 깔끔하고 직관적인 UI로 BLE 장치를 발견하고 연결할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_5.png)\n\n이 화면의 기본 아키텍처는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- ScanView: 화면의 UI를 렌더링하는 데 책임이 있습니다. SwiftUI를 사용하여 디자인되었습니다.\n- ScanViewModel: \"Start Scan\" 버튼을 탭하거나 장치 이름을 선택하는 이벤트를 처리합니다. 스캔 및 연결 작업을 실행하기 위해 ScanViewModel은 CentralUseCase에 의존합니다.\n- CentralUseCase: CoreBluetooth 프레임워크와 상호 작용하기 위한 필수 로직을 캡슐화하며, CBCentralManager 객체를 활용합니다. 이 객체는 프레임워크 내에서 스캔을 시작하고 연결을 설정하며 주변기기를 관리합니다.\n\n![이미지](/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_6.png)\n\n데이터 레이어에는 Peripheral 및 UUIDs 두 가지 엔티티가 포함되어 있습니다. Peripheral 객체는 BLE 장치를 나타내며, 장치 이름, 식별자 및 기타 관련 속성과 같은 세부 정보를 보유합니다. UUIDs는 응용 프로그램에서 사용할 서비스 및 특성 목록을 보유하는 컬렉션입니다.\n\n# 스캐닝\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\"Start Scan\" 버튼을 누르면 ScanView가 사용자 상호작용을 캡처하고 요청을 처리하기 위해 ScanViewModel로 전달합니다.\n\n```js\n//  ScanView.swift\n// ...\nButton {\n    viewModel.scan()\n} label: {\n    Text(\"Start Scan\")\n    .frame(maxWidth: .infinity)\n}\n// ...\n```\n\nScanViewModel은 상호작용을 받으면 해당 사용 사례에서 스캔 기능을 트리거합니다. 사용 사례는 LedService를 광고하는 디바이스만 찾도록 지시 받습니다.\n\n```js\n//  ScanViewModel.swift\n// ...\nfunc scan() {\n    useCase.scan(for: [UUIDs.ledService])\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n최종적으로 사용 사례는 CoreBluetooth 프레임워크와 상호 작용하여 스캔 프로시저를 시작합니다.\n\n```js\n// CentralUseCase.swift\n// ...\nlazy var central: CBCentralManager = {\n CBCentralManager(delegate: self, queue: DispatchQueue.main)\n}()\n\nfunc scan(for services: [CBUUID]) {\n guard central.isScanning == false else {\n     return\n }\n central.scanForPeripherals(withServices: services, options: [:])\n}\n```\n\nCoreBluetooth에서 scanForPeripherals 함수를 사용할 때, CBCentralManagerDelegate 메소드를 통해 응답을 처리할 수 있습니다. 발견된 페리페럴을 처리하는 델리게이트 메소드는 didDiscover이며, 스캔 과정 중에 페리페랄이 발견될 때마다 호출됩니다.\n\n기기가 발견되면 CentralUseCase는 onPeripheralDiscovery 클로저(즉, 자체 포함된 코드 블록)를 호출하여 새로 발견된 페리페럴의 세부 정보를 제공합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\n// CentralUseCase.swift\n// ...\nextension CentralUseCase: CBCentralManagerDelegate {\n  func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral,\n                       advertisementData: [String : Any], rssi RSSI: NSNumber) {\n      onPeripheralDiscovery?(.init(cbPeripheral: peripheral))\n  }\n  // ...\n}\n```\n\nScanViewModel은 내부 상태를 업데이트하고 ScanView에 새로운 장치가 주변 장치 목록에 표시될 준비가 되었음을 알립니다.\n\n```swift\n// ScanViewModel.swift\n// ...\nuseCase.onPeripheralDiscovery = { [weak self] peripheral in\n    guard let self = self else {\n        return\n    }\n    self.foundPeripherals.insert(peripheral)\n    self.state = .scan(Array(self.foundPeripherals))\n}\n```\n\n```swift\n// ScanView.swift\n// ...\nVStack {\n    List(peripheralList, id: \\.id) { peripheral in\n        Text(\"\\(peripheral.name ?? \"N/A\")\")\n        // ...\n    }\n}\n// ...\n}\n.onReceive(viewModel.$state) { state in\n    switch state {\n        // ...\n        case .scan(let list):\n            peripheralList = list\n        // ...\n    }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 연결하기\n\n목록 중 한 장치를 누르면 ScanView가 사용자 상호 작용을 캡처하고 해당 페리페럴에 연결하기 위해 ScanViewModel에 요청을 전달합니다.\n\n```js\n// ScanView.swift\n// ...\nList(peripheralList, id: \\.id) { peripheral in\n    Text(\"\\(peripheral.name ?? \"N/A\")\")\n        // ...\n        .onTapGesture {\n            viewModel.connect(to: peripheral)\n        }\n}\n```\n\n이 작업은 ScanViewModel이 연결 작업을 해당 사용 사례에 전달하도록 유도합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\n//  ScanViewModel.swift\n// ...\nfunc connect(to peripheral: Peripheral) {\n    useCase.connect(to: peripheral)\n}\n```\n\n마침내 사용 사례는 선택한 장치와 연결 프로세스를 시작하는 동안 스캐닝 프로세스를 중단하여 CoreBluetooth 프레임워크와 상호 작용합니다.\n\n```swift\n//  CentralUseCase.swift\n// ...\nfunc connect(to peripheral: Peripheral) {\n    central.stopScan()\n    central.connect(peripheral.cbPeripheral!)\n}\n```\n\n연결이 성공하면 didConnect 대리자 메서드가 호출됩니다. CentralUseCase는 이 정보를 ScanViewModel에게 onConnection 클로저를 호출하여 전달합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\n//  CentralUseCase.swift\n// ...\nfunc centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {\n    onConnection?(.init(cbPeripheral: peripheral))\n}\n```\n\nScanViewModel은 내부 상태를 업데이트하고 선택한 장치와의 연결이 설정되었음을 ScanView에 알립니다.\n\n```swift\n//  ScanViewModel.swift\n// ...\nuseCase.onConnection = { [weak self] peripheral in\n    self?.state = .connected(peripheral)\n}\n```\n\n그에 따라 ScanView는 ConnectView로 전환합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\n// ScanView.swift\n// ...\n.onReceive(viewModel.$state) { state in\n    switch state {\n    case .connected:\n        shouldShowDetail = true\n    // ...\n    }\n}\n.navigationDestination(isPresented: $shouldShowDetail) {\n    if case let .connected(peripheral) = viewModel.state  {\n        let viewModel = ConnectViewModel(useCase: PeripheralUseCase(),\n            connectedPeripheral: peripheral)\n        ConnectView(viewModel: viewModel)\n    }\n}\n```\n\n# iOS 앱: 데이터 쓰기 및 읽기\n\nConnect 화면에서 사용자는 Arduino와 상호 작용하여 LED 및 온도와 관련된 정보를 교환할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_7.png\" /\u003e\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아키텍처는 이전 화면과 일관성을 유지하며 다음 구성 요소를 포함합니다:\n\n- ConnectView: LED 상태를 제어하는 UI 요소, 온도 정보를 읽는 UI 요소, 및 장치와의 연결을 해제하는 UI 요소를 표현합니다. SwiftUI를 사용하여 구현되었습니다.\n- ConnectViewModel: LED 제어를 위한 온/오프 버튼을 탭하거나 온도 알림 활성화를 전환하거나 즉시 온도를 읽는 버튼을 누르는 등 사용자 상호작용을 캡처합니다. 또한 연산을 처리하기 위해 PeripheralUseCase와 통신합니다.\n- PeripheralUseCase: CentralUseCase와 유사하게 CoreBluetooth와 관련된 로직을 담당합니다. CBPeripheral 객체와 상호작용하여 특성과 서비스를 통해 데이터를 관리하고 교환합니다.\n\n![아무 이미지](/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_8.png)\n\n서비스와 특성과의 데이터 교환을 시작하기 전에 발견 단계를 수행해야 합니다. 이 단계에서 CoreBluetooth 프레임워크는 연결된 주변 장치에 의해 제공되는 사용 가능한 서비스와 특성에 대한 정보를 스캔하고 검색합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 발견\n\nConnectViewModel 및 해당 PeripheralUseCase를 생성한 후에는 발견 서비스 프로시저가 시작됩니다. 발견된 각 서비스에는 해당하는 특성도 발견됩니다.\n\nCoreBluetooth 프레임워크에서의 응답은 각각의 대리자 메서드인 didDiscoverServices 및 didDiscoverCharacteristicsFor로 전달됩니다. 이러한 메서드는 장치에서 발견된 서비스 및 특성에 대한 정보를 앱에 제공합니다.\n\n```swift\n//  PeripheralUseCase.swift\n// ...\nfunc discoverServices() {\n cbPeripheral?.discoverServices([UUIDs.ledService, UUIDs.sensorService])\n}\n// ...\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?) {\n // ...\n  for service in services {\n      // ...\n      peripheral.discoverCharacteristics(uuids, for: service)\n  }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nOnce the discovery process is completed, the `ConnectViewModel` is notified with `onPeripheralReady`, and the UI is prepared to handle operations on the discovered characteristics.\n\n```js\n// PeripheralUseCase.swift\n// ...\nfunc peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {\n  for characteristic in characteristics {\n      discoveredCharacteristics[characteristic.uuid] = characteristic\n  }\n\n  if discoveredCharacteristics[UUIDs.temperatureCharacteristic] != nil \u0026\u0026\n      discoveredCharacteristics[UUIDs.ledStatusCharacteristic] != nil {\n      onPeripheralReady?()\n  }\n}\n```\n\n# Controlling LED\n\nWhen the user presses the on/off buttons, it triggers a write operation to the LedStatus characteristic with a numerical value (1 for “On” and 0 for “Off”). This action, in turn, controls the integrated LED on the board, either turning it on or off accordingly.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적인 흐름을 따라 전체 프로세스가 관리됩니다:\n\n```js\n// ConnectView.swift\n// ...\nButton(\"On\") {\n    viewModel.turnOnLed()\n}\n// ...\nButton(\"Off\") {\n    viewModel.turnOffLed()\n}\n\n// ConnectViewModel.swift\n// ...\nfunc turnOnLed() {\n    useCase.writeLedState(isOn: true)\n}\n\nfunc turnOffLed() {\n    useCase.writeLedState(isOn: false)\n}\n\n// PeripheralUseCase.swift\n// ...\nfunc writeLedState(isOn: Bool) {\n    cbPeripheral?.writeValue(Data(isOn ? [0x01] : [0x00]), for: ledCharacteristic, type: .withResponse)\n}\n```\n\n# 온도 읽기\n\n온도 측정은 두 가지 방법으로 수행할 수 있습니다: 한 번의 값을 얻기 위해 트리거되는 읽기 작업을 사용하는 싱글 샷 모드 또는 실시간 업데이트를 받기 위해 알림 작업을 사용하는 연속 모드입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음은 읽기 작업 요청의 흐름입니다:\n\n```js\n//  ConnectView.swift\n// ...\nButton(\"READ\") {\n  viewModel.readTemperature()\n}\n\n//  ConnectViewModel.swift\n// ...\nfunc readTemperature() {\n  useCase.readTemperature()\n}\n\n//  PeripheralUseCase.swift\n// ...\nfunc readTemperature() {\n cbPeripheral?.readValue(for: tempCharacteristic)\n}\n```\n\n알림 작업 흐름의 활성화/비활성화는 동일한 패턴을 따릅니다:\n\n```js\n//  ConnectView.swift\n// ...\nToggle(\"Notify\", isOn: $isToggleOn)\n// ...\n.onChange(of: isToggleOn) { newValue in\n if newValue == true {\n  viewModel.startNotifyTemperature()\n } else {\n  viewModel.stopNotifyTemperature()\n }\n}\n\n//  ConnectViewModel.swift\n// ...\nfunc startNotifyTemperature() {\n  useCase.notifyTemperature(true)\n}\n\nfunc stopNotifyTemperature() {\n  useCase.notifyTemperature(false)\n}\n\n//  PeripheralUseCase.swift\n// ...\nfunc notifyTemperature(_ isOn: Bool) {\n cbPeripheral?.setNotifyValue(isOn, for: tempCharacteristic)\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n두 작업은 모두 CoreBluetooth의 동일한 대리자에 응답을 생성합니다. 구체적으로 didUpdateValueFor 메서드입니다. 읽기 작업의 경우 요청한 데이터와 함께 단일 응답이 있을 것입니다. 알림의 경우, 알림이 비활성화될 때까지 응답이 계속 전송됩니다. 각 응답은 UI 상태를 업데이트하기 위해 ConnectViewModel의 onReadTemperature 클로저를 트리거합니다.\n\n```swift\n//  PeripheralUseCase.swift\n// ...\nfunc peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {\n  switch characteristic.uuid {\n   case UUIDs.temperatureCharacteristic:\n     let value: UInt8 = {\n       guard let value = characteristic.value?.first else {\n         return 0\n       }\n       return value\n     }()\n     onReadTemperature?(Int(value))\n  }\n}\n\n//  ConnectViewModel.swift\n// ...\nuseCase.onReadTemperature = { [weak self] value in\n self?.state = .temperature(value)\n}\n\n//  ConnectView.swift\n// ...\n@State var lastTemperature: Int = 0\n// ...\nText(\"\\(lastTemperature) °C\")\n// ...\n.onReceive(viewModel.$state) { state in\n  switch state {\n   // ...\n   case let .temperature(temp):\n       lastTemperature = temp\n  }\n}\n```\n\n# 연결 해제\n\n연결 해제 버튼을 누르면 흐름이 약간 다른 방향으로 진행됩니다. 연결 해제 작업은 CBCentralManager 객체에 속하므로 CentralUseCase에서 수행되어야 합니다. 이를 가능하게 하기 위해 사용자가 버튼을 누르면 현재 화면이 해제되고 사용자는 스캔 화면으로 돌아갑니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```swift\n//  ConnectView.swift\n// ...\nButton {\n  dismiss()\n} label: {\n  Text(\"연결 해제\")\n  .frame(maxWidth: .infinity)\n}\n```\n\nScanView가 나타날 때, 수행하는 첫 번째 작업은 이미 연결된 장치가 있는지 확인하고 있다면 연결을 해제하는 것입니다. 이 작업은 해당 ScanViewModel에서 처리되며, 그런 다음 CentralUseCase에 해당 요청을 전달하여 CoreBluetooth 프레임워크에서 연결 해제 작업을 수행합니다.\n\n```swift\n//  ScanView.swift\n// ...\n.onAppear {\n  viewModel.disconnectIfConnected()\n}\n\n//  ScanViewModel.swift\n// ...\nfunc disconnectIfConnected() {\n  guard case let .connected(peripheral) = state,\n  peripheral.cbPeripheral != nil else {\n      return\n  }\n  useCase.disconnect(from: peripheral)\n}\n\n//  CentralUseCase.swift\n// ...\nfunc disconnect(from peripheral: Peripheral) {\n  central.cancelPeripheralConnection(peripheral.cbPeripheral!)\n}\n```\n\n# 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 글에서는 Arduino 프로그래밍부터 iOS 앱 개발로 이동하는 여정을 살펴보았는데, 이 과정에서 BLE 연결을 통해 IoT 프로젝트를 구축하는 데 초점을 맞추었습니다.\n\n우리는 Xcode와 CoreBluetooth 프레임워크를 사용하여 iOS 앱을 만드는 방법을 배웠습니다. BLE의 기본 지식을 습득하고, 청결한 아키텍처 원칙을 공부하며, 확장 가능하고 유지보수 가능한 코드베이스를 보장하기 위해 MVVM 디자인 패턴을 구현해 보았습니다.\n\n이 프로젝트는 여러분의 IoT 프로젝트를 시작하는 좋은 지점이 될 수 있습니다. 그러나 CoreBluetooth를 직접 사용하는 것은 백그라운드 작업 처리의 복잡도와 상위 수준의 기능(메쉬, 펌웨어 업데이트 등) 부족과 같은 몇 가지 제한 사항이 있을 수 있습니다. 이러한 제한 사항을 극복하기 위해, 추가적인 추상화 계층과 고급 기능을 지원하는 서드파티 라이브러리를 활용하는 것이 좋습니다.\n일부 인기 있는 옵션은 다음과 같습니다:\n\n- RxBluetoothKit: 강력한 ReactiveX 기반 BLE 라이브러리.\n- Bluejay: 간편하고 사용하기 쉬운 BLE 라이브러리를 강조하는 현대적인 라이브러리.\n- LittleBlueTooth: 가벼우면서 간편한 BLE 라이브러리.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 코드\n\n- iOSArduinoBLE_ArduinoSketch\n- iOSArduinoBLE_iOSApp","ogImage":{"url":"/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_0.png"},"coverImage":"/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_0.png","tag":["Tech"],"readingTime":18},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003eBLE 연결을 통한 IoT 프로젝트 구축 실습 가이드\u003c/h2\u003e\n\u003cp\u003e이 튜토리얼에서는 iOS 앱 개발과 Arduino 프로그래밍의 세계를 탐험하면서 전자 보드를 무선으로 제어할 수 있는 간단한 시스템을 생성하는 방법을 살펴보겠습니다. Bluetooth Low Energy (BLE) 연결 기능을 활용하여 Arduino Nano 33 BLE Sense 보드와 상호작용하고 LED 상태를 제어하며 센서에서 온도 데이터를 읽는 모바일 애플리케이션을 개발할 것입니다. 이 실습 가이드를 통해 iOS 앱과 Arduino 스케치를 개발하는 단계별 프로세스를 경험하면서 자체 IoT 프로젝트를 만들 수 있는 귀중한 기술을 습득할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003eNano 33 BLE Sense는 BLE 연결 및 센싱 기능이 필요한 프로젝트에 적합한 소형 Arduino 보드입니다. 다양한 센서를 갖추고 있어 IoT 응용 프로그램, 웨어러블 기기 및 데이터 획득 프로젝트에 적합합니다.\u003c/p\u003e\n\u003ch1\u003eBLE 통신 이해하기\u003c/h1\u003e\n\u003cp\u003eBLE는 저전력 기기를 위해 설계된 무선 통신 기술입니다. 이는 클라이언트-서버 아키텍처를 사용하며 다음과 같이 기기가 작동할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e중앙 (클라이언트): 통신을 시작하고 제어합니다.\u003c/li\u003e\n\u003cli\u003e주변 (서버): 액세스할 데이터 또는 작업을 제공합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e서비스와 특성은 BLE 통신의 구성 요소입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e서비스는 관련 기능이나 데이터 모음을 나타냅니다.\u003c/li\u003e\n\u003cli\u003e특징은 서비스 내에서 특정한 데이터 값을 가리킵니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e연결을 설정하려면 주변 기기가 광고 패킷이라는 작은 메시지를 방송하여 가용성을 알립니다. 중심 기기는 스캔 과정을 통해 이러한 패킷을 수신하고 주변 기기를 발견할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e중심 기기가 관심 있는 주변 기기를 식별하면 연결을 설정하고 사용 가능한 서비스와 특징과 상호 작용을 시작할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e우리 프로젝트에서 iOS 앱은 중심의 역할을 하고, Arduino 보드는 주변으로 동작합니다. 보드는 두 개의 별도 서비스 내에서 두 개의 특징을 통해 데이터를 노출할 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLed Status Characteristic (in Led Service): 이 특성은 쓰기 속성을 가진 특성으로, 앱이 0 (끄기) 또는 1 (켜기) 값을 쓰면 LED의 상태를 변경할 수 있습니다.\u003c/li\u003e\n\u003cli\u003eTemperature Characteristic (in Sensor Service): 이 특성은 읽기 및 알림 속성을 가진 특성으로, 보드에서 측정된 온도 값을 검색하고 온도 업데이트에 대한 알림을 받을 수 있도록 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003eArduino 프로그램 빌드\u003c/h1\u003e\n\u003cp\u003eArduino 프로그램은 ArduinoBLE 및 Arduino_HTS221 라이브러리를 활용하여 BLE 통신 및 온도 감지 기능을 가능하게 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#include \u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eArduinoBLE\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n#include \u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eArduino\u003c/span\u003e_HTS221.\u003cspan class=\"hljs-property\"\u003eh\u003c/span\u003e\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e먼저, 스케치는 UUID를 사용하여 필요한 BLE 서비스 및 특성을 설정하고 각 특성에 대한 속성을 정의합니다. UUID(Universally Unique Identifiers)는 BLE 통신 프로토콜에서 서비스 및 특성을 식별하는 데 사용되는 고유 식별자입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eBLEService\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eledService\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"cd48409a-f3cc-11ed-a05b-0242ac120003\"\u003c/span\u003e);\n\u003cspan class=\"hljs-title class_\"\u003eBLEByteCharacteristic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eledstatusCharacteristic\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"cd48409b-f3cc-11ed-a05b-0242ac120003\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eBLEWrite\u003c/span\u003e);\n\n\u003cspan class=\"hljs-title class_\"\u003eBLEService\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esensorService\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"d888a9c2-f3cc-11ed-a05b-0242ac120003\"\u003c/span\u003e);\n\u003cspan class=\"hljs-title class_\"\u003eBLEByteCharacteristic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etemperatureCharacteristic\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"d888a9c3-f3cc-11ed-a05b-0242ac120003\"\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eBLERead\u003c/span\u003e | \u003cspan class=\"hljs-title class_\"\u003eBLENotify\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음, 프로그램은 BLE 모듈을 초기화하고 로컬 이름 및 광고 서비스를 설정합니다. 사용자가 정의한 로컬 이름은 Arduino에 의해 방송되며 페리퍼럴을 식별하는 사람이 읽을 수 있는 식별자 역할을 합니다. 광고 서비스를 Led 서비스로 설정함으로써, Arduino는 iOS 앱이나 다른 중앙 장치에게 제공하는 특정 서비스에 대해 알립니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetup\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\n    \u003cspan class=\"hljs-comment\"\u003e// BLE 초기화\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!\u003cspan class=\"hljs-variable constant_\"\u003eBLE\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebegin\u003c/span\u003e()) {\n        \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// 광고할 로컬 이름과 서비스 UUID 설정\u003c/span\u003e\n    \u003cspan class=\"hljs-variable constant_\"\u003eBLE\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esetLocalName\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"iOSArduinoBoard\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-variable constant_\"\u003eBLE\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003esetAdvertisedService\u003c/span\u003e(ledService);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBLE 스택에 서비스와 특성이 추가되며, 온도 특성에 대한 읽기 요청 핸들러가 설정됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 서비스에 특성 추가\u003c/span\u003e\nledService.\u003cspan class=\"hljs-title function_\"\u003eaddCharacteristic\u003c/span\u003e(ledstatusCharacteristic);\nsensorService.\u003cspan class=\"hljs-title function_\"\u003eaddCharacteristic\u003c/span\u003e(temperatureCharacteristic);\n\n\u003cspan class=\"hljs-comment\"\u003e// BLE 스택에 서비스 추가\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eBLE\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddService\u003c/span\u003e(ledService);\n\u003cspan class=\"hljs-variable constant_\"\u003eBLE\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddService\u003c/span\u003e(sensorService);\n\n\u003cspan class=\"hljs-comment\"\u003e// 온도 특성에 대한 읽기 요청 핸들러 설정\u003c/span\u003e\ntemperatureCharacteristic.\u003cspan class=\"hljs-title function_\"\u003esetEventHandler\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eBLERead\u003c/span\u003e, temperatureCharacteristicRead);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e프로그램은 광고를 시작하고 메인 루프에 진입합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e \u003cspan class=\"hljs-comment\"\u003e// 광고 시작\u003c/span\u003e\n \u003cspan class=\"hljs-variable constant_\"\u003eBLE\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eadvertise\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e메인 루프에서는 중앙 기기가 연결하도록 대기하며, 연결되면 통신을 처리하는 루프를 시작합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloop\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {  \n  \u003cspan class=\"hljs-comment\"\u003e// BLE 센트럴 기기가 연결될 때까지 대기\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003eBLEDevice\u003c/span\u003e central = \u003cspan class=\"hljs-variable constant_\"\u003eBLE\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecentral\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 센트럴 기기가 페리페럴에 연결된 경우\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (central) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (central.\u003cspan class=\"hljs-title function_\"\u003econnected\u003c/span\u003e()) {\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 루프 내에서 프로그램은 주기적으로 센서에서 온도를 읽어 올바른 온도 값을 업데이트합니다. 또한, 센트럴 기기가 LedStatus 특성에 새 값을 쓰지 않았는지 확인합니다. 새 값을 감지하면 LED를 켜거나 끕니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (central.\u003cspan class=\"hljs-title function_\"\u003econnected\u003c/span\u003e()) {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 온도 값을 읽어옴\u003c/span\u003e\n    temperature = (int) \u003cspan class=\"hljs-variable constant_\"\u003eHTS\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereadTemperature\u003c/span\u003e();\n    temperatureCharacteristic.\u003cspan class=\"hljs-title function_\"\u003ewriteValue\u003c/span\u003e(temperature);\n    \n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// LedStatus characteristic의 쓰기 여부 확인\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ledstatusCharacteristic.\u003cspan class=\"hljs-title function_\"\u003ewritten\u003c/span\u003e()) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ledstatusCharacteristic.\u003cspan class=\"hljs-title function_\"\u003evalue\u003c/span\u003e()) {\n            \u003cspan class=\"hljs-title function_\"\u003edigitalWrite\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eLED_BUILTIN\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eHIGH\u003c/span\u003e);\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-title function_\"\u003edigitalWrite\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eLED_BUILTIN\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eLOW\u003c/span\u003e);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, 온도 characteristic의 읽기 요청에 응답하기 위해 read 이벤트 핸들러 함수를 구현했습니다. 이 함수는 현재 온도 값을 characteristic에 작성합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etemperatureCharacteristicRead\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eBLEDevice central, BLECharacteristic characteristic\u003c/span\u003e) {\n    temperatureCharacteristic.\u003cspan class=\"hljs-title function_\"\u003ewriteValue\u003c/span\u003e(temperature);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eiOS 앱 설계\u003c/h1\u003e\n\u003cp\u003eiOS 앱은 사용자 친화적인 인터페이스로 설계되었으며 두 가지 주요 화면으로 구성되어 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e스캔 화면: 앱을 실행할 때 초기화면으로 작동하여 사용자가 주변 기기를 스캔할 수 있게 합니다. 발견된 기기의 목록을 표시하며 사용자는 특정 기기의 이름을 탭하여 연결을 시작할 수 있습니다. 연결에 성공하면 앱은 연결 화면으로 전환됩니다.\u003c/li\u003e\n\u003cli\u003e연결 화면: 연결된 아두이노와 상호 작용할 수 있는 인터페이스를 제공합니다. 사용자는 LED의 상태를 수정하여 켜거나 끌 수 있습니다. 또한 사용자는 온도를 두 가지 모드로 읽을 수 있습니다: 단일 읽기(Read) 또는 변화의 지속적 모니터링(Notify).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 앱은 MVVM (Model-View-ViewModel) 디자인 패턴을 사용한 Clean Architecture에 영감을 받은 아키텍처로 구축되었으며 몇 가지 조정을 통해 단숨함과 이해하기 쉬운 요소를 향상시켰습니다. 이 접근 방식은 앱을 3개의 구분된 계층으로 구성하여 컴포넌트 독립성과 테스트 가능성을 촉진합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e프리젠테이션 계층은 사용자 인터페이스와 상호 작용을 처리합니다. 이 계층은 View(사용자 인터페이스 렌더링 담당)와 ViewModel(View의 상태를 관리하는)으로 구성됩니다.\u003c/li\u003e\n\u003cli\u003e도메인 계층은 응용 프로그램의 핵심 비즈니스 로직을 나타냅니다. 이 계층은 사용 사례를 캡슐화하고 데이터와 상호 작용합니다. 사용 사례는 응용 프로그램에서 수행할 수 있는 특정 비즈니스 작업을 나타냅니다.\u003c/li\u003e\n\u003cli\u003e데이터 계층은 데이터 접근 및 지속성을 담당합니다. 데이터 작업을 추상화하는 엔티티를 포함합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_3.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e앱은 CoreBluetooth를 활용하여 Bluetooth 관련 작업을 처리할 것입니다. CoreBluetooth는 Apple이 제공하는 프레임워크로, iOS 플랫폼에서 Bluetooth 기기와의 원활한 통신을 가능하게 합니다. Bluetooth 기능 구현을 간소화하는 포괄적인 기능 세트를 제공합니다.\u003c/p\u003e\n\u003cp\u003eCoreBluetooth를 활용하여, 앱은 주변의 Bluetooth 주변 기기를 탐지하고 연결을 설정하며 기기 간 데이터를 교환할 수 있을 것입니다.\u003c/p\u003e\n\u003cp\u003e자 이제 iOS 프로그래밍에 직접 참여해 봅시다!\n시작하기 전에 필요한 필수 도구 몇 가지가 있습니다: 맥 컴퓨터와 Apple 플랫폼을 위한 공식 통합 개발 환경(Integrated Development Environment, IDE) 인 Xcode입니다. Xcode는 iOS 애플리케이션을 디자인, 코딩 및 디버깅할 수 있는 종합적인 도구 및 자원 세트를 제공합니다.\u003c/p\u003e\n\u003cp\u003eXcode를 열고, 환영 화면에서 \"새 Xcode 프로젝트 생성\"을 선택하고 iOS 섹션에서 App 템플릿을 선택하세요. 고유한 제품명(iOSArduinoBLE)을 제공하고, 팀 식별자(귀하의 Apple ID 이름)를 선택하고, 언어(Swift)와 프로젝트를 저장할 위치를 선택하세요.\u003c/p\u003e\n\u003cp\u003e...여기까지입니다! 시작해 봅시다.\u003c/p\u003e\n\u003ch1\u003eiOS 앱: Arduino 보드를 스캔하고 연결하기\u003c/h1\u003e\n\u003cp\u003e스캔 화면에서 사용자는 깔끔하고 직관적인 UI로 BLE 장치를 발견하고 연결할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 화면의 기본 아키텍처는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eScanView: 화면의 UI를 렌더링하는 데 책임이 있습니다. SwiftUI를 사용하여 디자인되었습니다.\u003c/li\u003e\n\u003cli\u003eScanViewModel: \"Start Scan\" 버튼을 탭하거나 장치 이름을 선택하는 이벤트를 처리합니다. 스캔 및 연결 작업을 실행하기 위해 ScanViewModel은 CentralUseCase에 의존합니다.\u003c/li\u003e\n\u003cli\u003eCentralUseCase: CoreBluetooth 프레임워크와 상호 작용하기 위한 필수 로직을 캡슐화하며, CBCentralManager 객체를 활용합니다. 이 객체는 프레임워크 내에서 스캔을 시작하고 연결을 설정하며 주변기기를 관리합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_6.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e데이터 레이어에는 Peripheral 및 UUIDs 두 가지 엔티티가 포함되어 있습니다. Peripheral 객체는 BLE 장치를 나타내며, 장치 이름, 식별자 및 기타 관련 속성과 같은 세부 정보를 보유합니다. UUIDs는 응용 프로그램에서 사용할 서비스 및 특성 목록을 보유하는 컬렉션입니다.\u003c/p\u003e\n\u003ch1\u003e스캐닝\u003c/h1\u003e\n\u003cp\u003e\"Start Scan\" 버튼을 누르면 ScanView가 사용자 상호작용을 캡처하고 요청을 처리하기 위해 ScanViewModel로 전달합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//  ScanView.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e {\n    viewModel.\u003cspan class=\"hljs-title function_\"\u003escan\u003c/span\u003e()\n} \u003cspan class=\"hljs-attr\"\u003elabel\u003c/span\u003e: {\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Start Scan\"\u003c/span\u003e)\n    .\u003cspan class=\"hljs-title function_\"\u003eframe\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003emaxWidth\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003einfinity\u003c/span\u003e)\n}\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eScanViewModel은 상호작용을 받으면 해당 사용 사례에서 스캔 기능을 트리거합니다. 사용 사례는 LedService를 광고하는 디바이스만 찾도록 지시 받습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//  ScanViewModel.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\nfunc \u003cspan class=\"hljs-title function_\"\u003escan\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    useCase.\u003cspan class=\"hljs-title function_\"\u003escan\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: [\u003cspan class=\"hljs-title class_\"\u003eUUIDs\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eledService\u003c/span\u003e])\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e최종적으로 사용 사례는 CoreBluetooth 프레임워크와 상호 작용하여 스캔 프로시저를 시작합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// CentralUseCase.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\nlazy \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ecentral\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCBCentralManager\u003c/span\u003e = {\n \u003cspan class=\"hljs-title class_\"\u003eCBCentralManager\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003edelegate\u003c/span\u003e: self, \u003cspan class=\"hljs-attr\"\u003equeue\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDispatchQueue\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emain\u003c/span\u003e)\n}()\n\nfunc \u003cspan class=\"hljs-title function_\"\u003escan\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e services: [CBUUID]\u003c/span\u003e) {\n guard central.\u003cspan class=\"hljs-property\"\u003eisScanning\u003c/span\u003e == \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n     \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n }\n central.\u003cspan class=\"hljs-title function_\"\u003escanForPeripherals\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003ewithServices\u003c/span\u003e: services, \u003cspan class=\"hljs-attr\"\u003eoptions\u003c/span\u003e: [:])\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCoreBluetooth에서 scanForPeripherals 함수를 사용할 때, CBCentralManagerDelegate 메소드를 통해 응답을 처리할 수 있습니다. 발견된 페리페럴을 처리하는 델리게이트 메소드는 didDiscover이며, 스캔 과정 중에 페리페랄이 발견될 때마다 호출됩니다.\u003c/p\u003e\n\u003cp\u003e기기가 발견되면 CentralUseCase는 onPeripheralDiscovery 클로저(즉, 자체 포함된 코드 블록)를 호출하여 새로 발견된 페리페럴의 세부 정보를 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e// CentralUseCase.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eextension\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCentralUseCase\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCBCentralManagerDelegate\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecentralManager\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003ecentral\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eCBCentralManager\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003edidDiscover\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eperipheral\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eCBPeripheral\u003c/span\u003e,\n                       \u003cspan class=\"hljs-params\"\u003eadvertisementData\u003c/span\u003e: [\u003cspan class=\"hljs-params\"\u003eString\u003c/span\u003e : \u003cspan class=\"hljs-keyword\"\u003eAny\u003c/span\u003e], \u003cspan class=\"hljs-params\"\u003erssi\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eRSSI\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eNSNumber\u003c/span\u003e) {\n      onPeripheralDiscovery\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e(.\u003cspan class=\"hljs-keyword\"\u003einit\u003c/span\u003e(cbPeripheral: peripheral))\n  }\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eScanViewModel은 내부 상태를 업데이트하고 ScanView에 새로운 장치가 주변 장치 목록에 표시될 준비가 되었음을 알립니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ScanViewModel.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\nuseCase.onPeripheralDiscovery \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e { [\u003cspan class=\"hljs-keyword\"\u003eweak\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e] peripheral \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eguard\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n    }\n    \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.foundPeripherals.insert(peripheral)\n    \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.state \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e .scan(\u003cspan class=\"hljs-type\"\u003eArray\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e.foundPeripherals))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ScanView.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003eVStack\u003c/span\u003e {\n    \u003cspan class=\"hljs-type\"\u003eList\u003c/span\u003e(peripheralList, id: \\.id) { peripheral \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-subst\"\u003e\\(peripheral.name \u003cspan class=\"hljs-operator\"\u003e??\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"N/A\"\u003c/span\u003e)\u003c/span\u003e\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    }\n}\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n.onReceive(viewModel.\u003cspan class=\"hljs-variable\"\u003e$state\u003c/span\u003e) { state \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e state {\n        \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .scan(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e list):\n            peripheralList \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e list\n        \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e연결하기\u003c/h1\u003e\n\u003cp\u003e목록 중 한 장치를 누르면 ScanView가 사용자 상호 작용을 캡처하고 해당 페리페럴에 연결하기 위해 ScanViewModel에 요청을 전달합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ScanView.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eList\u003c/span\u003e(peripheralList, \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \\.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e) { peripheral \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\(peripheral.name ?? \"\u003c/span\u003eN/A\u003cspan class=\"hljs-string\"\u003e\")\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n        .\u003cspan class=\"hljs-property\"\u003eonTapGesture\u003c/span\u003e {\n            viewModel.\u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eto\u003c/span\u003e: peripheral)\n        }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 작업은 ScanViewModel이 연결 작업을 해당 사용 사례에 전달하도록 유도합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e//  ScanViewModel.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eto\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eperipheral\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003ePeripheral\u003c/span\u003e) {\n    useCase.connect(to: peripheral)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마침내 사용 사례는 선택한 장치와 연결 프로세스를 시작하는 동안 스캐닝 프로세스를 중단하여 CoreBluetooth 프레임워크와 상호 작용합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e//  CentralUseCase.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eto\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eperipheral\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003ePeripheral\u003c/span\u003e) {\n    central.stopScan()\n    central.connect(peripheral.cbPeripheral\u003cspan class=\"hljs-operator\"\u003e!\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e연결이 성공하면 didConnect 대리자 메서드가 호출됩니다. CentralUseCase는 이 정보를 ScanViewModel에게 onConnection 클로저를 호출하여 전달합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e//  CentralUseCase.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecentralManager\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003ecentral\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eCBCentralManager\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003edidConnect\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eperipheral\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eCBPeripheral\u003c/span\u003e) {\n    onConnection\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e(.\u003cspan class=\"hljs-keyword\"\u003einit\u003c/span\u003e(cbPeripheral: peripheral))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eScanViewModel은 내부 상태를 업데이트하고 선택한 장치와의 연결이 설정되었음을 ScanView에 알립니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e//  ScanViewModel.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\nuseCase.onConnection \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e { [\u003cspan class=\"hljs-keyword\"\u003eweak\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e] peripheral \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.state \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e .connected(peripheral)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그에 따라 ScanView는 ConnectView로 전환합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ScanView.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n.onReceive(viewModel.\u003cspan class=\"hljs-variable\"\u003e$state\u003c/span\u003e) { state \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e state {\n    \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e .connected:\n        shouldShowDetail \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    }\n}\n.navigationDestination(isPresented: \u003cspan class=\"hljs-variable\"\u003e$shouldShowDetail\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e .connected(peripheral) \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e viewModel.state  {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e viewModel \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eConnectViewModel\u003c/span\u003e(useCase: \u003cspan class=\"hljs-type\"\u003ePeripheralUseCase\u003c/span\u003e(),\n            connectedPeripheral: peripheral)\n        \u003cspan class=\"hljs-type\"\u003eConnectView\u003c/span\u003e(viewModel: viewModel)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eiOS 앱: 데이터 쓰기 및 읽기\u003c/h1\u003e\n\u003cp\u003eConnect 화면에서 사용자는 Arduino와 상호 작용하여 LED 및 온도와 관련된 정보를 교환할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e아키텍처는 이전 화면과 일관성을 유지하며 다음 구성 요소를 포함합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eConnectView: LED 상태를 제어하는 UI 요소, 온도 정보를 읽는 UI 요소, 및 장치와의 연결을 해제하는 UI 요소를 표현합니다. SwiftUI를 사용하여 구현되었습니다.\u003c/li\u003e\n\u003cli\u003eConnectViewModel: LED 제어를 위한 온/오프 버튼을 탭하거나 온도 알림 활성화를 전환하거나 즉시 온도를 읽는 버튼을 누르는 등 사용자 상호작용을 캡처합니다. 또한 연산을 처리하기 위해 PeripheralUseCase와 통신합니다.\u003c/li\u003e\n\u003cli\u003ePeripheralUseCase: CentralUseCase와 유사하게 CoreBluetooth와 관련된 로직을 담당합니다. CBPeripheral 객체와 상호작용하여 특성과 서비스를 통해 데이터를 관리하고 교환합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment_8.png\" alt=\"아무 이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e서비스와 특성과의 데이터 교환을 시작하기 전에 발견 단계를 수행해야 합니다. 이 단계에서 CoreBluetooth 프레임워크는 연결된 주변 장치에 의해 제공되는 사용 가능한 서비스와 특성에 대한 정보를 스캔하고 검색합니다.\u003c/p\u003e\n\u003ch1\u003e발견\u003c/h1\u003e\n\u003cp\u003eConnectViewModel 및 해당 PeripheralUseCase를 생성한 후에는 발견 서비스 프로시저가 시작됩니다. 발견된 각 서비스에는 해당하는 특성도 발견됩니다.\u003c/p\u003e\n\u003cp\u003eCoreBluetooth 프레임워크에서의 응답은 각각의 대리자 메서드인 didDiscoverServices 및 didDiscoverCharacteristicsFor로 전달됩니다. 이러한 메서드는 장치에서 발견된 서비스 및 특성에 대한 정보를 앱에 제공합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e//  PeripheralUseCase.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ediscoverServices\u003c/span\u003e() {\n cbPeripheral\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.discoverServices([\u003cspan class=\"hljs-type\"\u003eUUIDs\u003c/span\u003e.ledService, \u003cspan class=\"hljs-type\"\u003eUUIDs\u003c/span\u003e.sensorService])\n}\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eperipheral\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eperipheral\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eCBPeripheral\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003edidDiscoverServices\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eError\u003c/span\u003e?) {\n \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e service \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e services {\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n      peripheral.discoverCharacteristics(uuids, for: service)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnce the discovery process is completed, the \u003ccode\u003eConnectViewModel\u003c/code\u003e is notified with \u003ccode\u003eonPeripheralReady\u003c/code\u003e, and the UI is prepared to handle operations on the discovered characteristics.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// PeripheralUseCase.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\nfunc \u003cspan class=\"hljs-title function_\"\u003eperipheral\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: \u003cspan class=\"hljs-built_in\"\u003eError\u003c/span\u003e?\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e characteristic \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e characteristics {\n      discoveredCharacteristics[characteristic.\u003cspan class=\"hljs-property\"\u003euuid\u003c/span\u003e] = characteristic\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e discoveredCharacteristics[\u003cspan class=\"hljs-title class_\"\u003eUUIDs\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etemperatureCharacteristic\u003c/span\u003e] != nil \u0026#x26;\u0026#x26;\n      discoveredCharacteristics[\u003cspan class=\"hljs-title class_\"\u003eUUIDs\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eledStatusCharacteristic\u003c/span\u003e] != nil {\n      onPeripheralReady?()\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003eControlling LED\u003c/h1\u003e\n\u003cp\u003eWhen the user presses the on/off buttons, it triggers a write operation to the LedStatus characteristic with a numerical value (1 for “On” and 0 for “Off”). This action, in turn, controls the integrated LED on the board, either turning it on or off accordingly.\u003c/p\u003e\n\u003cp\u003e일반적인 흐름을 따라 전체 프로세스가 관리됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ConnectView.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"On\"\u003c/span\u003e) {\n    viewModel.\u003cspan class=\"hljs-title function_\"\u003eturnOnLed\u003c/span\u003e()\n}\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Off\"\u003c/span\u003e) {\n    viewModel.\u003cspan class=\"hljs-title function_\"\u003eturnOffLed\u003c/span\u003e()\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// ConnectViewModel.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\nfunc \u003cspan class=\"hljs-title function_\"\u003eturnOnLed\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    useCase.\u003cspan class=\"hljs-title function_\"\u003ewriteLedState\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eisOn\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n}\n\nfunc \u003cspan class=\"hljs-title function_\"\u003eturnOffLed\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    useCase.\u003cspan class=\"hljs-title function_\"\u003ewriteLedState\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003eisOn\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// PeripheralUseCase.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\nfunc \u003cspan class=\"hljs-title function_\"\u003ewriteLedState\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eisOn: Bool\u003c/span\u003e) {\n    cbPeripheral?.\u003cspan class=\"hljs-title function_\"\u003ewriteValue\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eData\u003c/span\u003e(isOn ? [\u003cspan class=\"hljs-number\"\u003e0x01\u003c/span\u003e] : [\u003cspan class=\"hljs-number\"\u003e0x00\u003c/span\u003e]), \u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: ledCharacteristic, \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: .\u003cspan class=\"hljs-property\"\u003ewithResponse\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e온도 읽기\u003c/h1\u003e\n\u003cp\u003e온도 측정은 두 가지 방법으로 수행할 수 있습니다: 한 번의 값을 얻기 위해 트리거되는 읽기 작업을 사용하는 싱글 샷 모드 또는 실시간 업데이트를 받기 위해 알림 작업을 사용하는 연속 모드입니다.\u003c/p\u003e\n\u003cp\u003e다음은 읽기 작업 요청의 흐름입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//  ConnectView.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"READ\"\u003c/span\u003e) {\n  viewModel.\u003cspan class=\"hljs-title function_\"\u003ereadTemperature\u003c/span\u003e()\n}\n\n\u003cspan class=\"hljs-comment\"\u003e//  ConnectViewModel.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\nfunc \u003cspan class=\"hljs-title function_\"\u003ereadTemperature\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  useCase.\u003cspan class=\"hljs-title function_\"\u003ereadTemperature\u003c/span\u003e()\n}\n\n\u003cspan class=\"hljs-comment\"\u003e//  PeripheralUseCase.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\nfunc \u003cspan class=\"hljs-title function_\"\u003ereadTemperature\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n cbPeripheral?.\u003cspan class=\"hljs-title function_\"\u003ereadValue\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: tempCharacteristic)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e알림 작업 흐름의 활성화/비활성화는 동일한 패턴을 따릅니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//  ConnectView.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eToggle\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Notify\"\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003eisOn\u003c/span\u003e: $isToggleOn)\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n.\u003cspan class=\"hljs-title function_\"\u003eonChange\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e: isToggleOn\u003c/span\u003e) { newValue \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e newValue == \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e {\n  viewModel.\u003cspan class=\"hljs-title function_\"\u003estartNotifyTemperature\u003c/span\u003e()\n } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n  viewModel.\u003cspan class=\"hljs-title function_\"\u003estopNotifyTemperature\u003c/span\u003e()\n }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e//  ConnectViewModel.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\nfunc \u003cspan class=\"hljs-title function_\"\u003estartNotifyTemperature\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  useCase.\u003cspan class=\"hljs-title function_\"\u003enotifyTemperature\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e)\n}\n\nfunc \u003cspan class=\"hljs-title function_\"\u003estopNotifyTemperature\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  useCase.\u003cspan class=\"hljs-title function_\"\u003enotifyTemperature\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e)\n}\n\n\u003cspan class=\"hljs-comment\"\u003e//  PeripheralUseCase.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\nfunc \u003cspan class=\"hljs-title function_\"\u003enotifyTemperature\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e_ isOn: Bool\u003c/span\u003e) {\n cbPeripheral?.\u003cspan class=\"hljs-title function_\"\u003esetNotifyValue\u003c/span\u003e(isOn, \u003cspan class=\"hljs-attr\"\u003efor\u003c/span\u003e: tempCharacteristic)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 작업은 모두 CoreBluetooth의 동일한 대리자에 응답을 생성합니다. 구체적으로 didUpdateValueFor 메서드입니다. 읽기 작업의 경우 요청한 데이터와 함께 단일 응답이 있을 것입니다. 알림의 경우, 알림이 비활성화될 때까지 응답이 계속 전송됩니다. 각 응답은 UI 상태를 업데이트하기 위해 ConnectViewModel의 onReadTemperature 클로저를 트리거합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e//  PeripheralUseCase.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eperipheral\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eperipheral\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eCBPeripheral\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003edidUpdateValueFor\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003echaracteristic\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eCBCharacteristic\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003eerror\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eError\u003c/span\u003e?) {\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e characteristic.uuid {\n   \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eUUIDs\u003c/span\u003e.temperatureCharacteristic:\n     \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e value: \u003cspan class=\"hljs-type\"\u003eUInt8\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e {\n       \u003cspan class=\"hljs-keyword\"\u003eguard\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e value \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e characteristic.value\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.first \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n         \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n       }\n       \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e value\n     }()\n     onReadTemperature\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e(\u003cspan class=\"hljs-type\"\u003eInt\u003c/span\u003e(value))\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e//  ConnectViewModel.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\nuseCase.onReadTemperature \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e { [\u003cspan class=\"hljs-keyword\"\u003eweak\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e] value \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.state \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e .temperature(value)\n}\n\n\u003cspan class=\"hljs-comment\"\u003e//  ConnectView.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-meta\"\u003e@State\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e lastTemperature: \u003cspan class=\"hljs-type\"\u003eInt\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\u003cspan class=\"hljs-subst\"\u003e\\(lastTemperature)\u003c/span\u003e °C\"\u003c/span\u003e)\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n.onReceive(viewModel.\u003cspan class=\"hljs-variable\"\u003e$state\u003c/span\u003e) { state \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e state {\n   \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n   \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e .temperature(temp):\n       lastTemperature \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e temp\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e연결 해제\u003c/h1\u003e\n\u003cp\u003e연결 해제 버튼을 누르면 흐름이 약간 다른 방향으로 진행됩니다. 연결 해제 작업은 CBCentralManager 객체에 속하므로 CentralUseCase에서 수행되어야 합니다. 이를 가능하게 하기 위해 사용자가 버튼을 누르면 현재 화면이 해제되고 사용자는 스캔 화면으로 돌아갑니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e//  ConnectView.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003eButton\u003c/span\u003e {\n  dismiss()\n} label: {\n  \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"연결 해제\"\u003c/span\u003e)\n  .frame(maxWidth: .infinity)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eScanView가 나타날 때, 수행하는 첫 번째 작업은 이미 연결된 장치가 있는지 확인하고 있다면 연결을 해제하는 것입니다. 이 작업은 해당 ScanViewModel에서 처리되며, 그런 다음 CentralUseCase에 해당 요청을 전달하여 CoreBluetooth 프레임워크에서 연결 해제 작업을 수행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-swift\"\u003e\u003cspan class=\"hljs-comment\"\u003e//  ScanView.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n.onAppear {\n  viewModel.disconnectIfConnected()\n}\n\n\u003cspan class=\"hljs-comment\"\u003e//  ScanViewModel.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edisconnectIfConnected\u003c/span\u003e() {\n  \u003cspan class=\"hljs-keyword\"\u003eguard\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e .connected(peripheral) \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e state,\n  peripheral.cbPeripheral \u003cspan class=\"hljs-operator\"\u003e!=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e\n  }\n  useCase.disconnect(from: peripheral)\n}\n\n\u003cspan class=\"hljs-comment\"\u003e//  CentralUseCase.swift\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edisconnect\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eperipheral\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003ePeripheral\u003c/span\u003e) {\n  central.cancelPeripheralConnection(peripheral.cbPeripheral\u003cspan class=\"hljs-operator\"\u003e!\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 글에서는 Arduino 프로그래밍부터 iOS 앱 개발로 이동하는 여정을 살펴보았는데, 이 과정에서 BLE 연결을 통해 IoT 프로젝트를 구축하는 데 초점을 맞추었습니다.\u003c/p\u003e\n\u003cp\u003e우리는 Xcode와 CoreBluetooth 프레임워크를 사용하여 iOS 앱을 만드는 방법을 배웠습니다. BLE의 기본 지식을 습득하고, 청결한 아키텍처 원칙을 공부하며, 확장 가능하고 유지보수 가능한 코드베이스를 보장하기 위해 MVVM 디자인 패턴을 구현해 보았습니다.\u003c/p\u003e\n\u003cp\u003e이 프로젝트는 여러분의 IoT 프로젝트를 시작하는 좋은 지점이 될 수 있습니다. 그러나 CoreBluetooth를 직접 사용하는 것은 백그라운드 작업 처리의 복잡도와 상위 수준의 기능(메쉬, 펌웨어 업데이트 등) 부족과 같은 몇 가지 제한 사항이 있을 수 있습니다. 이러한 제한 사항을 극복하기 위해, 추가적인 추상화 계층과 고급 기능을 지원하는 서드파티 라이브러리를 활용하는 것이 좋습니다.\n일부 인기 있는 옵션은 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRxBluetoothKit: 강력한 ReactiveX 기반 BLE 라이브러리.\u003c/li\u003e\n\u003cli\u003eBluejay: 간편하고 사용하기 쉬운 BLE 라이브러리를 강조하는 현대적인 라이브러리.\u003c/li\u003e\n\u003cli\u003eLittleBlueTooth: 가벼우면서 간편한 BLE 라이브러리.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e코드\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eiOSArduinoBLE_ArduinoSketch\u003c/li\u003e\n\u003cli\u003eiOSArduinoBLE_iOSApp\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-FromArduinoprogrammingtoiOSAppdevelopment"},"buildId":"FH3Qr-mLAesqA0X5IFRQr","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>