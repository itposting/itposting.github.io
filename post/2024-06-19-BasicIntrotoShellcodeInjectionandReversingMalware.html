<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>쉘코드 삽입 및 악성 코드 역분류에 대한 기본 소개 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="쉘코드 삽입 및 악성 코드 역분류에 대한 기본 소개 | itposting" data-gatsby-head="true"/><meta property="og:title" content="쉘코드 삽입 및 악성 코드 역분류에 대한 기본 소개 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware" data-gatsby-head="true"/><meta name="twitter:title" content="쉘코드 삽입 및 악성 코드 역분류에 대한 기본 소개 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 09:00" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">쉘코드 삽입 및 악성 코드 역분류에 대한 기본 소개</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="쉘코드 삽입 및 악성 코드 역분류에 대한 기본 소개" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>안녕하세요! 이 게시물의 목적은 제가 배우고 있는 연구 및 개발 방법 중 일부를 공유하는 것입니다!</p>
<p>오늘은 Windows 앱, 드라이버, 심지어 커널 자체에 대한 강력한 디버깅 솔루션인 WinDbg의 사용에 대해 이야기하고 싶었습니다. WinDbg를 좋아하는 한 가지 이유는 도구가 매우 유연하며 체계적인 시스템 분석을 위한 놀라운 기능이 포함되어 있다는 것입니다.</p>
<p>몇 가지 예시를 제공하기 위해, 'AAAA'를 notepad.exe의 주소 공간에 간단히 주입하는 간단한 셸코드 주입 프로그램을 만들어 보았습니다. 선택한 프로그램이 시스템에서 실행 중이고 보호받는 프로세스가 아닌 한 사용할 수 있습니다!</p>
<p>참고: 이러한 기술을 배우는 데 도움을 준 MalDev Academy 및 멋진 YT 채널을 운영하는 cr0w에게 감사드립니다!</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png" alt="이미지"></p>
<p>프로그램 실행 후에 보이는 것처럼, 이 프로그램은 PID를 매개변수로 사용하고 핸들을 획득한 다음 할당된 메모리에 쉘코드를 주입하여 코드 실행을 달성합니다!</p>
<p>더 나아가기 전에 현대 시스템에서는 어떤 종류의 합법적인 쉘 코드도 대부분의 보안 제품을 우회하기 위해 강력하게 난독화되어야 하거나, 디스크나 메모리의 별도 위치에 저장되어야 할 것으로 강조하고 싶습니다. 이것은 단순한 개념 증명일 뿐입니다.</p>
<p>프로그램의 기본 개요는 아마도 쉘 코드를 주입하는 가장 일반적인 방법을 따릅니다:</p>
<div class="content-ad"></div>
<ul>
<li>해당 PID로 프로세스를 식별하고 핸들을 획득합니다.</li>
<li>그 프로세스의 가상 주소 공간 내에서 RWX 권한으로 메모리를 할당합니다.</li>
<li>쉘 코드의 내용을 버퍼에 쓰고 그것을 할당된 메모리 공간에 전달합니다.</li>
<li>생성 및 호출하여 페이로드가 실행될 스레드를 만들어 실행을 트리거합니다.</li>
</ul>
<p><img src="/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_1.png" alt="이미지"></p>
<p>위는 우리 프로그램의 "Main"이라는 단어를 포함하는 여러 기능들의 분해입니다. 여기서 "x <code>프로그램이름</code>!<code>함수이름</code>" 명령을 사용하여 이를 달성합니다.</p>
<p>주소가 a5f00으로 끝나는 곳에서 우리 main 함수의 진입점을 볼 수 있습니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_2.png" alt="이미지"></p>
<p>메인 함수에 중단점을 설정하고 실행을 계속한 후, 프로그램을 분해하여 현재 레지스터 값들을 검사할 수 있습니다. 여기서 소스 코드 왼쪽에 할당된 변수를 NULL로 설정했다고 알 수 있습니다. 오른쪽에는 스택에 반영된 할당이 보이며, 값 0이 스택의 기본 위치로부터 다양한 오프셋에 저장되는 것을 확인할 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_3.png" alt="이미지"></p>
<p>여기서 "cmp" 명령어를 볼 수 있는데, 이는 결국 인수 개수 함수입니다. 인수 개수가 2와 일치하면 함수가 실행되고, 그렇지 않으면 사용법 라인에 정의된 문자열을 출력합니다.</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_4.png">
<p>위 캡처에서는 특정 메모리 주소에 포함된 값들을 표시할 수 있습니다. 여기서는 db 명령어 뒤에 주소를 넣어 해당 내용을 바이트로 표시합니다. 하지만 "display as ascii"를 위해 da를 활용할 수도 있습니다.</p>
<p>이 메모리 주소로부터 함수가 계속 실행되는 동안 어떤 문자열이 출력되는지 확인할 수 있습니다.</p>
<img src="/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_5.png">
<div class="content-ad"></div>
<p>이제 페이로드 저장에 대해 이야기하겠습니다. 한 발 물러서서 rep movs 명령어를 강조하고 싶어요. 우리가 인자 수를 비교하기 전에 우리의 ECX 또는 카운터 레지스터에 값 5를 할당했다는 것을 주목하세요. 그리고 나서 우리는 반복적으로 스택으로 한 번에 한 바이트씩 복사합니다.</p>
<p>우리의 페이로드는 AAAA로만 구성되어 있으므로, 왜 5라는 값이 우리의 페이로드에서 몇 바이트를 복사할지 결정하는 데 사용되는 걸까요? 이 5번째 바이트는 아마도 우리의 페이로드가 NULL 종료된 문자열이라는 사실을 고려하기 때문에, 마지막으로 복사해야 하는 바이트는 NULL 바이트일 것입니다.</p>
<p>이와 마지막으로, 페이로드 식별에 대해서 이야기할게요. "dd/db" 명령을 활용하여 특정 레지스터의 내용을 표시할 수 있어요! 이렇게 멋진 걸요! 그래서 프로그램 실행을 따라가면서 레지스터가 어떻게 변하는지, 어떤 값이 저장되는지를 살펴볼 수 있고, 아마도 프로그램이 무엇을 하는지 추측할 수도 있어요.</p>
<div class="content-ad"></div>
<p>RAX 레지스터에 저장된 페이로드의 바이트 및 ASCII 내용을 공개함으로써 거기에 4개의 A가 있다는 것을 확인할 수 있습니다.</p>
<p>마지막으로: 이 WinDbg 프로그램에서 할 수 있는 작업은 스택 추적을 검토하거나 레지스터를 조작하거나 API 호출 및 그 매개변수를 찾는 등 훨씬 더 많습니다. 저는 기본적인 분석 기술을 강조하고 앞으로 더 복잡한 주제를 탐구할 것을 희망합니다. 또한, ProcessHacker2나 일부 Sysinternals 도구와 같은 도구를 사용하여 프로그램을 실행하는 동안 메모장 메모리 내용을 검토하거나 페이로드가 삽입되는 방식 및 스레드가 호출되거나 호출되는 방식을 파악할 수도 있습니다.</p>
<p>읽어 주셔서 감사합니다!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"쉘코드 삽입 및 악성 코드 역분류에 대한 기본 소개","description":"","date":"2024-06-19 09:00","slug":"2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware","content":"\n\n안녕하세요! 이 게시물의 목적은 제가 배우고 있는 연구 및 개발 방법 중 일부를 공유하는 것입니다!\n\n오늘은 Windows 앱, 드라이버, 심지어 커널 자체에 대한 강력한 디버깅 솔루션인 WinDbg의 사용에 대해 이야기하고 싶었습니다. WinDbg를 좋아하는 한 가지 이유는 도구가 매우 유연하며 체계적인 시스템 분석을 위한 놀라운 기능이 포함되어 있다는 것입니다.\n\n몇 가지 예시를 제공하기 위해, 'AAAA'를 notepad.exe의 주소 공간에 간단히 주입하는 간단한 셸코드 주입 프로그램을 만들어 보았습니다. 선택한 프로그램이 시스템에서 실행 중이고 보호받는 프로세스가 아닌 한 사용할 수 있습니다!\n\n참고: 이러한 기술을 배우는 데 도움을 준 MalDev Academy 및 멋진 YT 채널을 운영하는 cr0w에게 감사드립니다!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png)\n\n프로그램 실행 후에 보이는 것처럼, 이 프로그램은 PID를 매개변수로 사용하고 핸들을 획득한 다음 할당된 메모리에 쉘코드를 주입하여 코드 실행을 달성합니다!\n\n더 나아가기 전에 현대 시스템에서는 어떤 종류의 합법적인 쉘 코드도 대부분의 보안 제품을 우회하기 위해 강력하게 난독화되어야 하거나, 디스크나 메모리의 별도 위치에 저장되어야 할 것으로 강조하고 싶습니다. 이것은 단순한 개념 증명일 뿐입니다.\n\n프로그램의 기본 개요는 아마도 쉘 코드를 주입하는 가장 일반적인 방법을 따릅니다:\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 해당 PID로 프로세스를 식별하고 핸들을 획득합니다.\n- 그 프로세스의 가상 주소 공간 내에서 RWX 권한으로 메모리를 할당합니다.\n- 쉘 코드의 내용을 버퍼에 쓰고 그것을 할당된 메모리 공간에 전달합니다.\n- 생성 및 호출하여 페이로드가 실행될 스레드를 만들어 실행을 트리거합니다.\n\n![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_1.png)\n\n위는 우리 프로그램의 \"Main\"이라는 단어를 포함하는 여러 기능들의 분해입니다. 여기서 \"x `프로그램이름`!`함수이름`\" 명령을 사용하여 이를 달성합니다. \n\n주소가 a5f00으로 끝나는 곳에서 우리 main 함수의 진입점을 볼 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_2.png)\n\n메인 함수에 중단점을 설정하고 실행을 계속한 후, 프로그램을 분해하여 현재 레지스터 값들을 검사할 수 있습니다. 여기서 소스 코드 왼쪽에 할당된 변수를 NULL로 설정했다고 알 수 있습니다. 오른쪽에는 스택에 반영된 할당이 보이며, 값 0이 스택의 기본 위치로부터 다양한 오프셋에 저장되는 것을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_3.png)\n\n여기서 \"cmp\" 명령어를 볼 수 있는데, 이는 결국 인수 개수 함수입니다. 인수 개수가 2와 일치하면 함수가 실행되고, 그렇지 않으면 사용법 라인에 정의된 문자열을 출력합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_4.png\" /\u003e\n\n위 캡처에서는 특정 메모리 주소에 포함된 값들을 표시할 수 있습니다. 여기서는 db 명령어 뒤에 주소를 넣어 해당 내용을 바이트로 표시합니다. 하지만 \"display as ascii\"를 위해 da를 활용할 수도 있습니다.\n\n이 메모리 주소로부터 함수가 계속 실행되는 동안 어떤 문자열이 출력되는지 확인할 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_5.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 페이로드 저장에 대해 이야기하겠습니다. 한 발 물러서서 rep movs 명령어를 강조하고 싶어요. 우리가 인자 수를 비교하기 전에 우리의 ECX 또는 카운터 레지스터에 값 5를 할당했다는 것을 주목하세요. 그리고 나서 우리는 반복적으로 스택으로 한 번에 한 바이트씩 복사합니다.\n\n우리의 페이로드는 AAAA로만 구성되어 있으므로, 왜 5라는 값이 우리의 페이로드에서 몇 바이트를 복사할지 결정하는 데 사용되는 걸까요? 이 5번째 바이트는 아마도 우리의 페이로드가 NULL 종료된 문자열이라는 사실을 고려하기 때문에, 마지막으로 복사해야 하는 바이트는 NULL 바이트일 것입니다.\n\n이와 마지막으로, 페이로드 식별에 대해서 이야기할게요. \"dd/db\" 명령을 활용하여 특정 레지스터의 내용을 표시할 수 있어요! 이렇게 멋진 걸요! 그래서 프로그램 실행을 따라가면서 레지스터가 어떻게 변하는지, 어떤 값이 저장되는지를 살펴볼 수 있고, 아마도 프로그램이 무엇을 하는지 추측할 수도 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRAX 레지스터에 저장된 페이로드의 바이트 및 ASCII 내용을 공개함으로써 거기에 4개의 A가 있다는 것을 확인할 수 있습니다.\n\n마지막으로: 이 WinDbg 프로그램에서 할 수 있는 작업은 스택 추적을 검토하거나 레지스터를 조작하거나 API 호출 및 그 매개변수를 찾는 등 훨씬 더 많습니다. 저는 기본적인 분석 기술을 강조하고 앞으로 더 복잡한 주제를 탐구할 것을 희망합니다. 또한, ProcessHacker2나 일부 Sysinternals 도구와 같은 도구를 사용하여 프로그램을 실행하는 동안 메모장 메모리 내용을 검토하거나 페이로드가 삽입되는 방식 및 스레드가 호출되거나 호출되는 방식을 파악할 수도 있습니다.\n\n읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png"},"coverImage":"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e안녕하세요! 이 게시물의 목적은 제가 배우고 있는 연구 및 개발 방법 중 일부를 공유하는 것입니다!\u003c/p\u003e\n\u003cp\u003e오늘은 Windows 앱, 드라이버, 심지어 커널 자체에 대한 강력한 디버깅 솔루션인 WinDbg의 사용에 대해 이야기하고 싶었습니다. WinDbg를 좋아하는 한 가지 이유는 도구가 매우 유연하며 체계적인 시스템 분석을 위한 놀라운 기능이 포함되어 있다는 것입니다.\u003c/p\u003e\n\u003cp\u003e몇 가지 예시를 제공하기 위해, 'AAAA'를 notepad.exe의 주소 공간에 간단히 주입하는 간단한 셸코드 주입 프로그램을 만들어 보았습니다. 선택한 프로그램이 시스템에서 실행 중이고 보호받는 프로세스가 아닌 한 사용할 수 있습니다!\u003c/p\u003e\n\u003cp\u003e참고: 이러한 기술을 배우는 데 도움을 준 MalDev Academy 및 멋진 YT 채널을 운영하는 cr0w에게 감사드립니다!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e프로그램 실행 후에 보이는 것처럼, 이 프로그램은 PID를 매개변수로 사용하고 핸들을 획득한 다음 할당된 메모리에 쉘코드를 주입하여 코드 실행을 달성합니다!\u003c/p\u003e\n\u003cp\u003e더 나아가기 전에 현대 시스템에서는 어떤 종류의 합법적인 쉘 코드도 대부분의 보안 제품을 우회하기 위해 강력하게 난독화되어야 하거나, 디스크나 메모리의 별도 위치에 저장되어야 할 것으로 강조하고 싶습니다. 이것은 단순한 개념 증명일 뿐입니다.\u003c/p\u003e\n\u003cp\u003e프로그램의 기본 개요는 아마도 쉘 코드를 주입하는 가장 일반적인 방법을 따릅니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e해당 PID로 프로세스를 식별하고 핸들을 획득합니다.\u003c/li\u003e\n\u003cli\u003e그 프로세스의 가상 주소 공간 내에서 RWX 권한으로 메모리를 할당합니다.\u003c/li\u003e\n\u003cli\u003e쉘 코드의 내용을 버퍼에 쓰고 그것을 할당된 메모리 공간에 전달합니다.\u003c/li\u003e\n\u003cli\u003e생성 및 호출하여 페이로드가 실행될 스레드를 만들어 실행을 트리거합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e위는 우리 프로그램의 \"Main\"이라는 단어를 포함하는 여러 기능들의 분해입니다. 여기서 \"x \u003ccode\u003e프로그램이름\u003c/code\u003e!\u003ccode\u003e함수이름\u003c/code\u003e\" 명령을 사용하여 이를 달성합니다.\u003c/p\u003e\n\u003cp\u003e주소가 a5f00으로 끝나는 곳에서 우리 main 함수의 진입점을 볼 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e메인 함수에 중단점을 설정하고 실행을 계속한 후, 프로그램을 분해하여 현재 레지스터 값들을 검사할 수 있습니다. 여기서 소스 코드 왼쪽에 할당된 변수를 NULL로 설정했다고 알 수 있습니다. 오른쪽에는 스택에 반영된 할당이 보이며, 값 0이 스택의 기본 위치로부터 다양한 오프셋에 저장되는 것을 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e여기서 \"cmp\" 명령어를 볼 수 있는데, 이는 결국 인수 개수 함수입니다. 인수 개수가 2와 일치하면 함수가 실행되고, 그렇지 않으면 사용법 라인에 정의된 문자열을 출력합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_4.png\"\u003e\n\u003cp\u003e위 캡처에서는 특정 메모리 주소에 포함된 값들을 표시할 수 있습니다. 여기서는 db 명령어 뒤에 주소를 넣어 해당 내용을 바이트로 표시합니다. 하지만 \"display as ascii\"를 위해 da를 활용할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e이 메모리 주소로부터 함수가 계속 실행되는 동안 어떤 문자열이 출력되는지 확인할 수 있습니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_5.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 페이로드 저장에 대해 이야기하겠습니다. 한 발 물러서서 rep movs 명령어를 강조하고 싶어요. 우리가 인자 수를 비교하기 전에 우리의 ECX 또는 카운터 레지스터에 값 5를 할당했다는 것을 주목하세요. 그리고 나서 우리는 반복적으로 스택으로 한 번에 한 바이트씩 복사합니다.\u003c/p\u003e\n\u003cp\u003e우리의 페이로드는 AAAA로만 구성되어 있으므로, 왜 5라는 값이 우리의 페이로드에서 몇 바이트를 복사할지 결정하는 데 사용되는 걸까요? 이 5번째 바이트는 아마도 우리의 페이로드가 NULL 종료된 문자열이라는 사실을 고려하기 때문에, 마지막으로 복사해야 하는 바이트는 NULL 바이트일 것입니다.\u003c/p\u003e\n\u003cp\u003e이와 마지막으로, 페이로드 식별에 대해서 이야기할게요. \"dd/db\" 명령을 활용하여 특정 레지스터의 내용을 표시할 수 있어요! 이렇게 멋진 걸요! 그래서 프로그램 실행을 따라가면서 레지스터가 어떻게 변하는지, 어떤 값이 저장되는지를 살펴볼 수 있고, 아마도 프로그램이 무엇을 하는지 추측할 수도 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eRAX 레지스터에 저장된 페이로드의 바이트 및 ASCII 내용을 공개함으로써 거기에 4개의 A가 있다는 것을 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e마지막으로: 이 WinDbg 프로그램에서 할 수 있는 작업은 스택 추적을 검토하거나 레지스터를 조작하거나 API 호출 및 그 매개변수를 찾는 등 훨씬 더 많습니다. 저는 기본적인 분석 기술을 강조하고 앞으로 더 복잡한 주제를 탐구할 것을 희망합니다. 또한, ProcessHacker2나 일부 Sysinternals 도구와 같은 도구를 사용하여 프로그램을 실행하는 동안 메모장 메모리 내용을 검토하거나 페이로드가 삽입되는 방식 및 스레드가 호출되거나 호출되는 방식을 파악할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e읽어 주셔서 감사합니다!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>