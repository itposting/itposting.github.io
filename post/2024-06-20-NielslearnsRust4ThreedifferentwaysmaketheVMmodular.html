<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>Niels, 러스트를 배우다 4 - VM을 모듈화하는 세 가지 다른 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="Niels, 러스트를 배우다 4 - VM을 모듈화하는 세 가지 다른 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="Niels, 러스트를 배우다 4 - VM을 모듈화하는 세 가지 다른 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular" data-gatsby-head="true"/><meta name="twitter:title" content="Niels, 러스트를 배우다 4 - VM을 모듈화하는 세 가지 다른 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 17:07" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">Niels, 러스트를 배우다 4 - VM을 모듈화하는 세 가지 다른 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="Niels, 러스트를 배우다 4 - VM을 모듈화하는 세 가지 다른 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">10<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이 문서는 '루스트(Rust)'를 배우면서 내장형 자바 가상 머신을 이식하는 과정의 네 번째 단골입니다. 전체 시리즈를 보려면 여기를 클릭하세요.</p>
<p>이전 VM 버전은 Darjeeling 가상 머신의 변경 버전이었습니다. 모듈식으로 설정되어 다양한 구성 요소 세트로 쉽게 컴파일할 수 있었습니다.</p>
<p>이러한 구성 요소는 무선 프로그래밍, 장치 UART 액세스, Java 기본 라이브러리 등과 같은 다양한 기능을 제공했습니다. 이를 사용한 연구 프로젝트는 이종적인 사물 인터넷(IoT) 장치 네트워크를 조정하는 데 사용되었습니다. 이 프로젝트에서는 심지어 자바 가상 머신 자체를 선택적 구성 요소로 만들어 가장 작은 장치용 버전을 작성할 수 있었으므로 자바 코드를 실행할 수 없어도 네트워크에 참여할 수 있었습니다.</p>
<h1>프로젝트 레이아웃</h1>
<div class="content-ad"></div>
<p>VM을 빌드하기 전에 프로젝트 레이아웃을 먼저 설정해 봅시다. 목표는 VM을 구축할 때 설정 옵션에 따라 선택적으로 포함될 수 있는 구성 요소를 갖는 것입니다. 각 구성 요소는 코어 VM에서 노출된 여러 훅에 대한 콜백을 등록할 수 있어야 합니다. 이를 통해 구성 요소를 초기화하고 가비지 컬렉터와 상호 작용하게 하며 네트워크 메시지를 수신할 수 있어야 합니다. 이 단계에서 우리는 init()라는 훅을 정의할 것입니다. 이 훅은 시작할 때 호출됩니다.</p>
<p>다양한 옵션을 설명하기 위해 두 개의 구성 요소로 시작해 봅시다.</p>
<ul>
<li>jvm : 실제 Java 가상 머신을 포함할 것입니다.</li>
<li>uart : CPU의 UART(유니버설 비동기 수신기/발신기)를 제어하는 코드를 포함할 것입니다.</li>
</ul>
<p>프로젝트 레이아웃은 이렇게 보일 것입니다:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-rust">.
├── avrora.rs
├── main.rs
└── components
    ├── <span class="hljs-keyword">mod</span>.rs
    ├── jvm
    │   └── <span class="hljs-keyword">mod</span>.rs
    └── uart
        └── <span class="hljs-keyword">mod</span>.rs

<span class="hljs-number">4</span> directories, <span class="hljs-number">5</span> files
</code></pre>
<p>러스트는 세 가지 방법으로 모듈을 정의하여 계층적으로 범위를 지정합니다:</p>
<ul>
<li>mod modname ' ... ' 블록,</li>
<li>modname.rs 파일로, 이 프로젝트에는 avrora라는 모듈이 있습니다,</li>
<li>그리고 mod.rs가 포함된 하위 디렉토리로, 해당 하위 디렉토리의 이름을 따르는 모듈이 정의됩니다. 여기에서는 components, components::jvm, 그리고 components::uart 모듈이 있습니다.</li>
</ul>
<p>컴파일은 main.rs 또는 라이브러리의 경우 lib.rs에서 시작됩니다. 다른 파일이나 디렉토리의 모듈은 명시적으로 프로젝트에 포함되어야 합니다. 그렇지 않을 경우 무시됩니다. 이 경우 mod avrora;와 mod components; 라인은 avrora 및 components 모듈을 가져와서 전체 크레이트에서 사용할 수 있도록 만듭니다.</p>
<div class="content-ad"></div>
<p>목표는 구성 설정에 따라 components::uart 및 components::vm을 선택적으로 포함하고, 활성화되어 있는 경우 init() 함수를 호출하는 것입니다.</p>
<p>이를 수행하는 세 가지 방법을 고려해 보았는데, 각각이 저에게 몇 가지 흥미로운 Rust 기능을 가르쳐 주었습니다. 따라서 모두 살펴보도록 하겠습니다:</p>
<h1>옵션 A: build.rs</h1>
<p>Cargo에는 코드를 빌드하기 전에 Rust 스크립트를 실행할 수 있는 옵션이 있습니다. 스크립트는 build.rs로 불리며 프로젝트의 루트 디렉토리에 배치되어야 합니다.</p>
<div class="content-ad"></div>
<p>선택한 구성 요소를 가져오는 데 필요한 코드를 생성하는 데 사용할 수 있습니다. 구성 요소가 활성화되는 설정을 따로 저장할 것이며, 이는 프로젝트 루트에 있는 vm-config.toml 파일에 저장됩니다:</p>
<pre><code class="hljs language-js">[capevm]
components = [<span class="hljs-string">"jvm"</span>]
</code></pre>
<p>이 예에서는 jvm이 활성화되었지만 uart 구성 요소는 비활성화되었습니다. 그럼 우리의 빌드 스크립트는 다음 코드를 포함한 파일을 생성해야 합니다:</p>
<pre><code class="hljs language-js">#[path = <span class="hljs-string">"/home/niels/git/capevm-rust/capevm/src/components/jvm/mod.rs"</span>]
mod jvm;

pub fn <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
    <span class="hljs-attr">jvm</span>::<span class="hljs-title function_">init</span>();
}
</code></pre>
<div class="content-ad"></div>
<p>러스트는 프로젝트에 명시적으로 임포트되지 않는 코드를 무시하므로 최종 빌드에는 jvm 모듈만 포함되고 uart 모듈은 건너뛰게 됩니다.</p>
<p>생성된 코드는 일시적인 파일이며 소스 제어에 포함되지 않아야 합니다. 따라서 Cargo의 출력 디렉토리에 생성하고 components/mod.rs에서 포함시키겠습니다. 이 파일은 이제 다음과 같이 한 줄만 포함하고 있습니다:</p>
<pre><code class="hljs language-js">include!(concat!(env!(<span class="hljs-string">"OUT_DIR"</span>), <span class="hljs-string">"/enabled_components.rs"</span>));
</code></pre>
<p>생성된 코드의 #[path] 속성이 필요한 이유는 모듈 임포트가 가져오는 파일의 위치를 기준으로 상대적이기 때문입니다. 그러나 Rust의 include! 매크로는 C의 #include 전처리기 지시문과 다르게 작동합니다. 포함된 코드는 단순히 파일에 붙여넣는 것이 아니라 해당 소스 위치에 따라 구문 분석되는데, 이 경우에는 Cargo 출력 디렉토리입니다. 만약 #[path] 속성을 사용하지 않고 Rust에게 해당 컴포넌트가 다른 위치에 있다고 알리지 않으면 아래와 같은 오류가 발생할 것입니다:</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular_0.png">
<p>다음은 완전한 빌드 스크립트입니다:</p>
<pre><code class="hljs language-js">extern crate toml;

use <span class="hljs-attr">std</span>::fs;
use <span class="hljs-attr">std</span>::<span class="hljs-attr">path</span>::<span class="hljs-title class_">Path</span>;
use <span class="hljs-attr">toml</span>::<span class="hljs-title class_">Value</span>;

fn <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) {
    println!(<span class="hljs-string">"cargo:rerun-if-changed=build.rs"</span>);
    println!(<span class="hljs-string">"cargo:rerun-if-changed=vm-config.toml"</span>);

    <span class="hljs-keyword">let</span> manifest_dir = <span class="hljs-attr">std</span>::<span class="hljs-attr">env</span>::<span class="hljs-title function_">var</span>(<span class="hljs-string">"CARGO_MANIFEST_DIR"</span>).<span class="hljs-title function_">unwrap</span>();
    <span class="hljs-keyword">let</span> out_dir = <span class="hljs-attr">std</span>::<span class="hljs-attr">env</span>::<span class="hljs-title function_">var</span>(<span class="hljs-string">"OUT_DIR"</span>).<span class="hljs-title function_">unwrap</span>();
    <span class="hljs-keyword">let</span> dest_path = <span class="hljs-title class_">Path</span>::<span class="hljs-title function_">new</span>(&#x26;out_dir).<span class="hljs-title function_">join</span>(<span class="hljs-string">"enabled_components.rs"</span>);

    <span class="hljs-keyword">let</span> <span class="hljs-attr">contents</span>: <span class="hljs-title class_">String</span> = <span class="hljs-attr">fs</span>::<span class="hljs-title function_">read_to_string</span>(<span class="hljs-string">"vm-config.toml"</span>).<span class="hljs-title function_">unwrap</span>();
    <span class="hljs-keyword">let</span> cargo_toml = contents.<span class="hljs-property">parse</span>::&#x3C;<span class="hljs-title class_">Value</span>>().<span class="hljs-title function_">unwrap</span>();

    <span class="hljs-keyword">let</span> vm_components =
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-title class_">Some</span>(capevm_components) = cargo_toml.<span class="hljs-title function_">get</span>(<span class="hljs-string">"capevm"</span>)
                                        .<span class="hljs-title function_">and_then</span>(<span class="hljs-title class_">Value</span>::as_table)
                                        .<span class="hljs-title function_">and_then</span>(|table| table.<span class="hljs-title function_">get</span>(<span class="hljs-string">"components"</span>))
                                        .<span class="hljs-title function_">and_then</span>(<span class="hljs-params">Value::as_array</span>) {
            capevm_components.<span class="hljs-title function_">iter</span>().<span class="hljs-title function_">filter_map</span>(|v| v.<span class="hljs-title function_">as_str</span>()).<span class="hljs-property">collect</span>::&#x3C;<span class="hljs-title class_">Vec</span>&#x3C;&#x26;str>>()
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-title class_">Vec</span>::&#x3C;&#x26;str>::<span class="hljs-title function_">default</span>()
        };

    <span class="hljs-keyword">let</span> mod_imports =
        vm_components.<span class="hljs-title function_">iter</span>()
            .<span class="hljs-title function_">map</span>(|name| format!(r#<span class="hljs-string">"
                #[path = "</span>{manifest_dir}/src/components/{name}/mod.<span class="hljs-property">rs</span><span class="hljs-string">"]
                mod {name};"</span>#, manifest_dir=manifest_dir, name=name))
            .<span class="hljs-property">collect</span>::&#x3C;<span class="hljs-title class_">Vec</span>&#x3C;_>>().<span class="hljs-title function_">join</span>(<span class="hljs-string">"\n"</span>);
    <span class="hljs-keyword">let</span> mod_inits =
        vm_components.<span class="hljs-title function_">iter</span>()
            .<span class="hljs-title function_">map</span>(|name| format!(<span class="hljs-string">"
                {}::init();"</span>, name))
            .<span class="hljs-property">collect</span>::&#x3C;<span class="hljs-title class_">Vec</span>&#x3C;_>>().<span class="hljs-title function_">join</span>(<span class="hljs-string">"\n"</span>);

    <span class="hljs-keyword">let</span> generated_code =
        format!(<span class="hljs-string">"{}
            
            pub fn init() {
                {}
            }"</span>, mod_imports, mod_inits);

    <span class="hljs-attr">fs</span>::<span class="hljs-title function_">write</span>(dest_path, generated_code.<span class="hljs-title function_">as_bytes</span>()).<span class="hljs-title function_">unwrap</span>();
}
</code></pre>
<p>조금 주목해야 할 사항이 있습니다:</p>
<div class="content-ad"></div>
<ul>
<li>extern crate toml; 메인 애플리케이션과 마찬가지로 build.rs 스크립트는 외부 크레이트를 사용할 수 있습니다. 다른 크레이트와 마찬가지로 Cargo.toml에 선언해야 하지만, [dependencies] 대신 [build-dependencies] 섹션에 선언해야 합니다.</li>
<li>println!("cargo:rerun-if-changed=..."); 표준 출력에 쓰는 것으로 Cargo가 빌드 스크립트를 실행하는 시점(그리고 다른 여러 가지 것들)을 제어할 수 있습니다. 여기서 두 줄은 Cargo에게 build.rs 또는 vm-config.toml이 변경되면 빌드 스크립트를 다시 실행하도록 지시합니다.</li>
<li>std::env::var("CARGO_MANIFEST_DIR"): Cargo는 환경 변수를 통해 빌드 프로세스의 여러 매개변수를 스크립트에 노출시킵니다. 이 경우 OUT_DIR을 사용하여 생성된 파일이 위치해야 하는 곳을 결정하고, CARGO_MANIFEST_DIR을 사용하여 구성 요소의 위치를 파악합니다.</li>
<li>unwrap(): Rust의 주요 오류 처리 방식은 Result&#x3C;T, E>를 반환하는 것입니다. 이는 T 값이나 E 오류 중 하나를 포함할 수 있습니다. 일반적으로 오류를 처리하거나 전달해야 하지만, 오류가 발생할 가능성이 없거나 코드가 패닉 상황이라고 생각하면 unwrap을 사용하여 Result에서 값을 가져올 수 있습니다.</li>
<li>.and_then(): toml 크레이트는 toml 파일의 내용을 나타내는 Value 객체를 제공합니다. 이는 이름으로 검색할 수 있습니다. 이는 Option&#x3C;&#x26;Value>를 반환하며, 이름을 찾지 못하면 None일 수 있습니다. .and_then() 호출을 사용하면 값을 포함하는 경우에는 Option에서 작업을 연결하고, 그렇지 않은 경우에는 None을 유지할 수 있습니다. 다른 언어에서는 이를 flatmap 또는 bind라고도 부르기도 합니다.</li>
</ul>
<h1>옵션 B: Cargo 피쳐</h1>
<p>두 번째 옵션은 Rust 피쳐를 사용하는 것입니다. 이 방법은 훨씬 간단하지만 한계가 있습니다. 먼저 다음과 같이 Cargo.toml에 [features] 섹션을 선언합니다:</p>
<pre><code class="hljs language-js">[features]
<span class="hljs-keyword">default</span> = [<span class="hljs-string">"jvm"</span>]
jvm = []
uart = []
</code></pre>
<div class="content-ad"></div>
<p>각 기능은 종속성 목록이 포함된 이름에 해당합니다. 기본 기능은 기본적으로 포함됩니다. 예를 들어 이 예시에서 기본 기능은 jvm에 의존하므로 해당 기능은 활성화되지만 uart는 활성화되지 않습니다.</p>
<p>그런 다음 조건부 컴파일에 사용할 수 있는 이름이 지정된 기능이 있습니다. #[cfg(feature = "...")] 속성을 사용하여 구성요소/mod.rs를 다음과 같이 구현할 수 있습니다:</p>
<pre><code class="hljs language-js">#[<span class="hljs-title function_">cfg</span>(feature = <span class="hljs-string">"jvm"</span>)]
mod jvm;
#[<span class="hljs-title function_">cfg</span>(feature = <span class="hljs-string">"uart"</span>)]
mod uart;

pub fn <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
    #[<span class="hljs-title function_">cfg</span>(feature = <span class="hljs-string">"jvm"</span>)]
    <span class="hljs-attr">jvm</span>::<span class="hljs-title function_">init</span>();
    #[<span class="hljs-title function_">cfg</span>(feature = <span class="hljs-string">"uart"</span>)]
    <span class="hljs-attr">uart</span>::<span class="hljs-title function_">init</span>();
}
</code></pre>
<p>이 접근 방식의 장점은 빌드 스크립트보다 훨씬 간단하다는 것입니다. 또한 명령줄에서 선택된 기능을 제어할 수 있습니다. 예를 들어, --features="uart"은 uart 기능을 활성화하며, --no-default-features는 기본 기능을 무시합니다.</p>
<div class="content-ad"></div>
<p>단점 중 하나는 해당 기능이 활성화되어 있는 경우 그 모든 컴포넌트를 가져오기 위해 components/mod.rs에 수동으로 목록을 작성해야 한다는 것입니다. 게다가, 현재 init() 함수만 있어야 하는데 이 함수는 모든 활성화된 기능을 위해 호출되어야 합니다. 그러나 쓰레기 수집 및 네트워킹과 같은 항목을 추가할 때 가능한 후크 목록이 늘어나게 됩니다. 그래서 일부 컴포넌트는 수신 메시지를 듣거나 힙에 자체 객체를 등록하려는 것일 수 있습니다.</p>
<p>이것은 꽤 강한 결합이며, 모듈 및/또는 후크의 수가 계속해서 늘어난다면 이 접근법은 유지하기 어려워질 수 있습니다.</p>
<h1>옵션 C: 기능 + 인벤토리 크레이트</h1>
<p>이제 옵션 C로 넘어가봅시다: 인벤토리 크레이트입니다. 이를 통해 컴포넌트와 코어 VM 간의 강한 결합을 줄일 수 있습니다. 안타깝게도 AVR에서는 작동하지 않지만, 학습할 가치가 있는 내용입니다.</p>
<div class="content-ad"></div>
<p>크레이트를 사용하면 데이터 형식을 정의하고 해당 데이터 형식의 인스턴스를 코드의 한 부분에서 등록하고 다른 곳에서 수집할 수 있습니다. 저희 경우에는 데이터 형식이 init() 함수 포인터를 포함하는 구조체일 수 있습니다:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Component</span> {
    init: <span class="hljs-title function_ invoke__">fn</span>()
}
</code></pre>
<p>이제 컴포넌트의 구현은 아래와 같습니다:</p>
<pre><code class="hljs language-rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">init</span>() {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"jvm 초기화 중..."</span>);
}

inventory::submit! {
    crate::components::Component { init }
}
</code></pre>
<div class="content-ad"></div>
<p>구성 요소/components/mod.rs의 구현부는 다음과 같습니다:</p>
<pre><code class="hljs language-js">#[<span class="hljs-title function_">cfg</span>(feature = <span class="hljs-string">"jvm"</span>)]
mod jvm;
#[<span class="hljs-title function_">cfg</span>(feature = <span class="hljs-string">"uart"</span>)]
mod uart;

pub struct <span class="hljs-title class_">Component</span> {
    <span class="hljs-attr">init</span>: <span class="hljs-title function_">fn</span>()
}

<span class="hljs-attr">inventory</span>::collect!(<span class="hljs-title class_">Component</span>);

pub fn <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">for</span> component <span class="hljs-keyword">in</span> <span class="hljs-attr">inventory</span>::<span class="hljs-attr">iter</span>::&#x3C;<span class="hljs-title class_">Component</span>> {
        (component.<span class="hljs-property">init</span>)();
    }
}
</code></pre>
<p>collect! 매크로는 submit!()를 통해 등록된 모든 Component 객체를 순회할 수 있는 반복자를 생성합니다. 이 반복자는 main() 함수에 진입하기 전에 초기화되며, 우리가 수동으로 초기화 코드를 실행할 필요가 없습니다.</p>
<p>이 동작이 가능하게 하는 핵심은 submit! 매크로에 있습니다. 매크로가 어떻게 확장되는지 볼 수 있다는 점은 종종 유용하거나 그냥 재미있을 수 있습니다. cargo-expand라는 Cargo 확장 프로그램을 사용하여 확장된 소스를 표시할 수 있습니다. 설치한 후(cargo install cargo-expand), cargo expand components::jvm: 명령을 통해 확장된 소스를 확인할 수 있습니다.</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular_1.png" alt="이미지"></p>
<p>특정 링크된 섹션에 코드를 배치하여 마법이 일어납니다. 인벤토리 크레이트의 소스를 살펴보면(조밀하지만 500줄 미만이고 그 중 절반은 주석입니다), 생성될 링커 섹션이 운영 체제에 따라 다르다는 것을 알 수 있습니다. 리눅스의 경우 .init_array가 되고, 윈도우의 경우 .CRT$XCU가 되며 macOS의 경우 __DATA,__mod_init_func가 됩니다. 각각은 main() 함수에 진입하기 전에 실행될 코드를 포함하고 있습니다.</p>
<p>AVR의 경우 이러한 종류의 코드가 .initN 섹션으로 들어가지만, 안타깝게도 인벤토리 크레이트는 AVR에서 작동하지 않습니다:</p>
<p><img src="/assets/img/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular_2.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>에러 메시지가 약간 암호화되어 있어서 이 문제는 조금 어렵게 느껴질 수도 있어요. 특히 <code>ptr</code> 피처 부분이 숨겨져 있는 것이요. 이 크레이트는 core::sync::atomic::AtomicPtr라는 유형을 사용하는데, 어떤 이유 때문에 사용할 수 없네요. 이 유형의 구현을 살펴보면 플랫폼이 원자 포인터 작업을 지원하는 경우에만 설정되는 #[cfg(target_has_atomic_load_store = "ptr")]라는 조건부 컴파일 속성이 있다는 것을 알게 됩니다.</p>
<p>AVR은 그 작업을 지원하지 않아요. 이는 8비트 CPU이며 포인터는 16비트이기 때문에 포인터 조작은 항상 여러 번의 읽기 또는 쓰기가 필요해요.</p>
<h1>비교와 결정</h1>
<p>우리는 아마도 인벤토리 크레이트가 하는 것을 AtomicPtr이 없이도 일부 코드를 복사하고 수정하여 재생산할 수 있을 거예요. 그러나 여기서 최종적으로 가장 좋은 선택이 아닌 이유가 하나 더 있어요.</p>
<div class="content-ad"></div>
<p>이 방식은 iterator가 루프를 돌 수 있는 정적 inventory::Node 객체의 링크드 리스트를 만들어 작동합니다. 이것은 RAM을 사용하므로, 객체당 4바이트가 필요한 경우에도 RAM이 단 4KB만 있는 장치에서 정적 목록에 낭비하고 싶지 않습니다.</p>
<p>그러므로 옵션 A와 B 중에서 선택해야 합니다. 옵션 A는 핵심 vm 코드가 구성 요소에 대해 알 필요가 없어 보이지만, 옵션 B는 각 구성 요소를 해당 기능 플래그와 등록해야 한다는 점이 필요합니다.</p>
<p>옵션 A의 단점은 각 구성 요소가 초기화할 것이 없더라도 init()에 대한 구현을 정의해야 한다는 것입니다. 빌드 스크립트는 항상 호출을 생성하므로 말입니다. 러스트 컴파일러는 죽은 코드를 제거하는 데 매우 뛰어나기 때문에, 컴파일 시간에 이 코드들이 제거될 가능성이 높지만, 나중에 사용할 쓰레기 수집기를 위해 비슷한 후크를 추가할 때마다, 적어도 빈 구현을 제공해야 하는데 이는 추가 작업이 필요합니다.</p>
<p>구성 요소와 후크의 수가 제한될 것이므로, 두 옵션 모두 잘 작동할 것으로 보입니다. 옵션 A는 더 많은 요소가 움직이며, 마법이 적으면 항상 좋은 것이므로, 일단 옵션 B를 선택하겠습니다.</p>
<div class="content-ad"></div>
<p>보통 이번 단계의 코드 상태는 Github에서 확인하실 수 있어요. 세 가지 옵션을 업로드했어요:</p>
<ul>
<li>옵션 A: build.rs</li>
<li>옵션 B: features</li>
<li>옵션 C: features + inventory (AVR에서 컴파일되지 않아요)</li>
<li>데스크탑에서 작동하는 옵션 C의 최소 예제.</li>
</ul>
<p>2024년 5월 23일에 <a href="https://nielsreijers.com%EC%97%90%EC%84%9C" rel="nofollow" target="_blank">https://nielsreijers.com에서</a> 최초로 게시되었어요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Niels, 러스트를 배우다 4 - VM을 모듈화하는 세 가지 다른 방법","description":"","date":"2024-06-20 17:07","slug":"2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular","content":"\n\n이 문서는 '루스트(Rust)'를 배우면서 내장형 자바 가상 머신을 이식하는 과정의 네 번째 단골입니다. 전체 시리즈를 보려면 여기를 클릭하세요.\n\n이전 VM 버전은 Darjeeling 가상 머신의 변경 버전이었습니다. 모듈식으로 설정되어 다양한 구성 요소 세트로 쉽게 컴파일할 수 있었습니다.\n\n이러한 구성 요소는 무선 프로그래밍, 장치 UART 액세스, Java 기본 라이브러리 등과 같은 다양한 기능을 제공했습니다. 이를 사용한 연구 프로젝트는 이종적인 사물 인터넷(IoT) 장치 네트워크를 조정하는 데 사용되었습니다. 이 프로젝트에서는 심지어 자바 가상 머신 자체를 선택적 구성 요소로 만들어 가장 작은 장치용 버전을 작성할 수 있었으므로 자바 코드를 실행할 수 없어도 네트워크에 참여할 수 있었습니다.\n\n# 프로젝트 레이아웃\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nVM을 빌드하기 전에 프로젝트 레이아웃을 먼저 설정해 봅시다. 목표는 VM을 구축할 때 설정 옵션에 따라 선택적으로 포함될 수 있는 구성 요소를 갖는 것입니다. 각 구성 요소는 코어 VM에서 노출된 여러 훅에 대한 콜백을 등록할 수 있어야 합니다. 이를 통해 구성 요소를 초기화하고 가비지 컬렉터와 상호 작용하게 하며 네트워크 메시지를 수신할 수 있어야 합니다. 이 단계에서 우리는 init()라는 훅을 정의할 것입니다. 이 훅은 시작할 때 호출됩니다.\n\n다양한 옵션을 설명하기 위해 두 개의 구성 요소로 시작해 봅시다.\n\n- jvm : 실제 Java 가상 머신을 포함할 것입니다.\n- uart : CPU의 UART(유니버설 비동기 수신기/발신기)를 제어하는 코드를 포함할 것입니다.\n\n프로젝트 레이아웃은 이렇게 보일 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```rust\n.\n├── avrora.rs\n├── main.rs\n└── components\n    ├── mod.rs\n    ├── jvm\n    │   └── mod.rs\n    └── uart\n        └── mod.rs\n\n4 directories, 5 files\n```\n\n러스트는 세 가지 방법으로 모듈을 정의하여 계층적으로 범위를 지정합니다:\n\n- mod modname ' ... ' 블록,\n- modname.rs 파일로, 이 프로젝트에는 avrora라는 모듈이 있습니다,\n- 그리고 mod.rs가 포함된 하위 디렉토리로, 해당 하위 디렉토리의 이름을 따르는 모듈이 정의됩니다. 여기에서는 components, components::jvm, 그리고 components::uart 모듈이 있습니다.\n\n컴파일은 main.rs 또는 라이브러리의 경우 lib.rs에서 시작됩니다. 다른 파일이나 디렉토리의 모듈은 명시적으로 프로젝트에 포함되어야 합니다. 그렇지 않을 경우 무시됩니다. 이 경우 mod avrora;와 mod components; 라인은 avrora 및 components 모듈을 가져와서 전체 크레이트에서 사용할 수 있도록 만듭니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n목표는 구성 설정에 따라 components::uart 및 components::vm을 선택적으로 포함하고, 활성화되어 있는 경우 init() 함수를 호출하는 것입니다.\n\n이를 수행하는 세 가지 방법을 고려해 보았는데, 각각이 저에게 몇 가지 흥미로운 Rust 기능을 가르쳐 주었습니다. 따라서 모두 살펴보도록 하겠습니다:\n\n# 옵션 A: build.rs\n\nCargo에는 코드를 빌드하기 전에 Rust 스크립트를 실행할 수 있는 옵션이 있습니다. 스크립트는 build.rs로 불리며 프로젝트의 루트 디렉토리에 배치되어야 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n선택한 구성 요소를 가져오는 데 필요한 코드를 생성하는 데 사용할 수 있습니다. 구성 요소가 활성화되는 설정을 따로 저장할 것이며, 이는 프로젝트 루트에 있는 vm-config.toml 파일에 저장됩니다:\n\n```js\n[capevm]\ncomponents = [\"jvm\"]\n```\n\n이 예에서는 jvm이 활성화되었지만 uart 구성 요소는 비활성화되었습니다. 그럼 우리의 빌드 스크립트는 다음 코드를 포함한 파일을 생성해야 합니다:\n\n```js\n#[path = \"/home/niels/git/capevm-rust/capevm/src/components/jvm/mod.rs\"]\nmod jvm;\n\npub fn init() {\n    jvm::init();\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n러스트는 프로젝트에 명시적으로 임포트되지 않는 코드를 무시하므로 최종 빌드에는 jvm 모듈만 포함되고 uart 모듈은 건너뛰게 됩니다.\n\n생성된 코드는 일시적인 파일이며 소스 제어에 포함되지 않아야 합니다. 따라서 Cargo의 출력 디렉토리에 생성하고 components/mod.rs에서 포함시키겠습니다. 이 파일은 이제 다음과 같이 한 줄만 포함하고 있습니다:\n\n```js\ninclude!(concat!(env!(\"OUT_DIR\"), \"/enabled_components.rs\"));\n```\n\n생성된 코드의 #[path] 속성이 필요한 이유는 모듈 임포트가 가져오는 파일의 위치를 기준으로 상대적이기 때문입니다. 그러나 Rust의 include! 매크로는 C의 #include 전처리기 지시문과 다르게 작동합니다. 포함된 코드는 단순히 파일에 붙여넣는 것이 아니라 해당 소스 위치에 따라 구문 분석되는데, 이 경우에는 Cargo 출력 디렉토리입니다. 만약 #[path] 속성을 사용하지 않고 Rust에게 해당 컴포넌트가 다른 위치에 있다고 알리지 않으면 아래와 같은 오류가 발생할 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular_0.png\" /\u003e\n\n다음은 완전한 빌드 스크립트입니다:\n\n```js\nextern crate toml;\n\nuse std::fs;\nuse std::path::Path;\nuse toml::Value;\n\nfn main() {\n    println!(\"cargo:rerun-if-changed=build.rs\");\n    println!(\"cargo:rerun-if-changed=vm-config.toml\");\n\n    let manifest_dir = std::env::var(\"CARGO_MANIFEST_DIR\").unwrap();\n    let out_dir = std::env::var(\"OUT_DIR\").unwrap();\n    let dest_path = Path::new(\u0026out_dir).join(\"enabled_components.rs\");\n\n    let contents: String = fs::read_to_string(\"vm-config.toml\").unwrap();\n    let cargo_toml = contents.parse::\u003cValue\u003e().unwrap();\n\n    let vm_components =\n        if let Some(capevm_components) = cargo_toml.get(\"capevm\")\n                                        .and_then(Value::as_table)\n                                        .and_then(|table| table.get(\"components\"))\n                                        .and_then(Value::as_array) {\n            capevm_components.iter().filter_map(|v| v.as_str()).collect::\u003cVec\u003c\u0026str\u003e\u003e()\n        } else {\n            Vec::\u003c\u0026str\u003e::default()\n        };\n\n    let mod_imports =\n        vm_components.iter()\n            .map(|name| format!(r#\"\n                #[path = \"{manifest_dir}/src/components/{name}/mod.rs\"]\n                mod {name};\"#, manifest_dir=manifest_dir, name=name))\n            .collect::\u003cVec\u003c_\u003e\u003e().join(\"\\n\");\n    let mod_inits =\n        vm_components.iter()\n            .map(|name| format!(\"\n                {}::init();\", name))\n            .collect::\u003cVec\u003c_\u003e\u003e().join(\"\\n\");\n\n    let generated_code =\n        format!(\"{}\n            \n            pub fn init() {\n                {}\n            }\", mod_imports, mod_inits);\n\n    fs::write(dest_path, generated_code.as_bytes()).unwrap();\n}\n```\n\n조금 주목해야 할 사항이 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- extern crate toml; 메인 애플리케이션과 마찬가지로 build.rs 스크립트는 외부 크레이트를 사용할 수 있습니다. 다른 크레이트와 마찬가지로 Cargo.toml에 선언해야 하지만, [dependencies] 대신 [build-dependencies] 섹션에 선언해야 합니다.\n- println!(\"cargo:rerun-if-changed=...\"); 표준 출력에 쓰는 것으로 Cargo가 빌드 스크립트를 실행하는 시점(그리고 다른 여러 가지 것들)을 제어할 수 있습니다. 여기서 두 줄은 Cargo에게 build.rs 또는 vm-config.toml이 변경되면 빌드 스크립트를 다시 실행하도록 지시합니다.\n- std::env::var(\"CARGO_MANIFEST_DIR\"): Cargo는 환경 변수를 통해 빌드 프로세스의 여러 매개변수를 스크립트에 노출시킵니다. 이 경우 OUT_DIR을 사용하여 생성된 파일이 위치해야 하는 곳을 결정하고, CARGO_MANIFEST_DIR을 사용하여 구성 요소의 위치를 파악합니다.\n- unwrap(): Rust의 주요 오류 처리 방식은 Result\u003cT, E\u003e를 반환하는 것입니다. 이는 T 값이나 E 오류 중 하나를 포함할 수 있습니다. 일반적으로 오류를 처리하거나 전달해야 하지만, 오류가 발생할 가능성이 없거나 코드가 패닉 상황이라고 생각하면 unwrap을 사용하여 Result에서 값을 가져올 수 있습니다.\n- .and_then(): toml 크레이트는 toml 파일의 내용을 나타내는 Value 객체를 제공합니다. 이는 이름으로 검색할 수 있습니다. 이는 Option\u003c\u0026Value\u003e를 반환하며, 이름을 찾지 못하면 None일 수 있습니다. .and_then() 호출을 사용하면 값을 포함하는 경우에는 Option에서 작업을 연결하고, 그렇지 않은 경우에는 None을 유지할 수 있습니다. 다른 언어에서는 이를 flatmap 또는 bind라고도 부르기도 합니다.\n\n# 옵션 B: Cargo 피쳐\n\n두 번째 옵션은 Rust 피쳐를 사용하는 것입니다. 이 방법은 훨씬 간단하지만 한계가 있습니다. 먼저 다음과 같이 Cargo.toml에 [features] 섹션을 선언합니다:\n\n```js\n[features]\ndefault = [\"jvm\"]\njvm = []\nuart = []\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 기능은 종속성 목록이 포함된 이름에 해당합니다. 기본 기능은 기본적으로 포함됩니다. 예를 들어 이 예시에서 기본 기능은 jvm에 의존하므로 해당 기능은 활성화되지만 uart는 활성화되지 않습니다.\n\n그런 다음 조건부 컴파일에 사용할 수 있는 이름이 지정된 기능이 있습니다. #[cfg(feature = \"...\")] 속성을 사용하여 구성요소/mod.rs를 다음과 같이 구현할 수 있습니다:\n\n```js\n#[cfg(feature = \"jvm\")]\nmod jvm;\n#[cfg(feature = \"uart\")]\nmod uart;\n\npub fn init() {\n    #[cfg(feature = \"jvm\")]\n    jvm::init();\n    #[cfg(feature = \"uart\")]\n    uart::init();\n}\n```\n\n이 접근 방식의 장점은 빌드 스크립트보다 훨씬 간단하다는 것입니다. 또한 명령줄에서 선택된 기능을 제어할 수 있습니다. 예를 들어, --features=\"uart\"은 uart 기능을 활성화하며, --no-default-features는 기본 기능을 무시합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단점 중 하나는 해당 기능이 활성화되어 있는 경우 그 모든 컴포넌트를 가져오기 위해 components/mod.rs에 수동으로 목록을 작성해야 한다는 것입니다. 게다가, 현재 init() 함수만 있어야 하는데 이 함수는 모든 활성화된 기능을 위해 호출되어야 합니다. 그러나 쓰레기 수집 및 네트워킹과 같은 항목을 추가할 때 가능한 후크 목록이 늘어나게 됩니다. 그래서 일부 컴포넌트는 수신 메시지를 듣거나 힙에 자체 객체를 등록하려는 것일 수 있습니다.\n\n이것은 꽤 강한 결합이며, 모듈 및/또는 후크의 수가 계속해서 늘어난다면 이 접근법은 유지하기 어려워질 수 있습니다.\n\n# 옵션 C: 기능 + 인벤토리 크레이트\n\n이제 옵션 C로 넘어가봅시다: 인벤토리 크레이트입니다. 이를 통해 컴포넌트와 코어 VM 간의 강한 결합을 줄일 수 있습니다. 안타깝게도 AVR에서는 작동하지 않지만, 학습할 가치가 있는 내용입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n크레이트를 사용하면 데이터 형식을 정의하고 해당 데이터 형식의 인스턴스를 코드의 한 부분에서 등록하고 다른 곳에서 수집할 수 있습니다. 저희 경우에는 데이터 형식이 init() 함수 포인터를 포함하는 구조체일 수 있습니다:\n\n```rust\npub struct Component {\n    init: fn()\n}\n```\n\n이제 컴포넌트의 구현은 아래와 같습니다:\n\n```rust\npub fn init() {\n    println!(\"jvm 초기화 중...\");\n}\n\ninventory::submit! {\n    crate::components::Component { init }\n}\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n구성 요소/components/mod.rs의 구현부는 다음과 같습니다:\n\n```js\n#[cfg(feature = \"jvm\")]\nmod jvm;\n#[cfg(feature = \"uart\")]\nmod uart;\n\npub struct Component {\n    init: fn()\n}\n\ninventory::collect!(Component);\n\npub fn init() {\n    for component in inventory::iter::\u003cComponent\u003e {\n        (component.init)();\n    }\n}\n```\n\ncollect! 매크로는 submit!()를 통해 등록된 모든 Component 객체를 순회할 수 있는 반복자를 생성합니다. 이 반복자는 main() 함수에 진입하기 전에 초기화되며, 우리가 수동으로 초기화 코드를 실행할 필요가 없습니다.\n\n이 동작이 가능하게 하는 핵심은 submit! 매크로에 있습니다. 매크로가 어떻게 확장되는지 볼 수 있다는 점은 종종 유용하거나 그냥 재미있을 수 있습니다. cargo-expand라는 Cargo 확장 프로그램을 사용하여 확장된 소스를 표시할 수 있습니다. 설치한 후(cargo install cargo-expand), cargo expand components::jvm: 명령을 통해 확장된 소스를 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n![이미지](/assets/img/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular_1.png)\n\n특정 링크된 섹션에 코드를 배치하여 마법이 일어납니다. 인벤토리 크레이트의 소스를 살펴보면(조밀하지만 500줄 미만이고 그 중 절반은 주석입니다), 생성될 링커 섹션이 운영 체제에 따라 다르다는 것을 알 수 있습니다. 리눅스의 경우 .init_array가 되고, 윈도우의 경우 .CRT$XCU가 되며 macOS의 경우 __DATA,__mod_init_func가 됩니다. 각각은 main() 함수에 진입하기 전에 실행될 코드를 포함하고 있습니다.\n\nAVR의 경우 이러한 종류의 코드가 .initN 섹션으로 들어가지만, 안타깝게도 인벤토리 크레이트는 AVR에서 작동하지 않습니다:\n\n![이미지](/assets/img/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular_2.png)\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n에러 메시지가 약간 암호화되어 있어서 이 문제는 조금 어렵게 느껴질 수도 있어요. 특히 `ptr` 피처 부분이 숨겨져 있는 것이요. 이 크레이트는 core::sync::atomic::AtomicPtr라는 유형을 사용하는데, 어떤 이유 때문에 사용할 수 없네요. 이 유형의 구현을 살펴보면 플랫폼이 원자 포인터 작업을 지원하는 경우에만 설정되는 #[cfg(target_has_atomic_load_store = \"ptr\")]라는 조건부 컴파일 속성이 있다는 것을 알게 됩니다.\n\nAVR은 그 작업을 지원하지 않아요. 이는 8비트 CPU이며 포인터는 16비트이기 때문에 포인터 조작은 항상 여러 번의 읽기 또는 쓰기가 필요해요.\n\n# 비교와 결정\n\n우리는 아마도 인벤토리 크레이트가 하는 것을 AtomicPtr이 없이도 일부 코드를 복사하고 수정하여 재생산할 수 있을 거예요. 그러나 여기서 최종적으로 가장 좋은 선택이 아닌 이유가 하나 더 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방식은 iterator가 루프를 돌 수 있는 정적 inventory::Node 객체의 링크드 리스트를 만들어 작동합니다. 이것은 RAM을 사용하므로, 객체당 4바이트가 필요한 경우에도 RAM이 단 4KB만 있는 장치에서 정적 목록에 낭비하고 싶지 않습니다.\n\n그러므로 옵션 A와 B 중에서 선택해야 합니다. 옵션 A는 핵심 vm 코드가 구성 요소에 대해 알 필요가 없어 보이지만, 옵션 B는 각 구성 요소를 해당 기능 플래그와 등록해야 한다는 점이 필요합니다.\n\n옵션 A의 단점은 각 구성 요소가 초기화할 것이 없더라도 init()에 대한 구현을 정의해야 한다는 것입니다. 빌드 스크립트는 항상 호출을 생성하므로 말입니다. 러스트 컴파일러는 죽은 코드를 제거하는 데 매우 뛰어나기 때문에, 컴파일 시간에 이 코드들이 제거될 가능성이 높지만, 나중에 사용할 쓰레기 수집기를 위해 비슷한 후크를 추가할 때마다, 적어도 빈 구현을 제공해야 하는데 이는 추가 작업이 필요합니다.\n\n구성 요소와 후크의 수가 제한될 것이므로, 두 옵션 모두 잘 작동할 것으로 보입니다. 옵션 A는 더 많은 요소가 움직이며, 마법이 적으면 항상 좋은 것이므로, 일단 옵션 B를 선택하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n보통 이번 단계의 코드 상태는 Github에서 확인하실 수 있어요. 세 가지 옵션을 업로드했어요:\n\n- 옵션 A: build.rs\n- 옵션 B: features\n- 옵션 C: features + inventory (AVR에서 컴파일되지 않아요)\n- 데스크탑에서 작동하는 옵션 C의 최소 예제.\n\n2024년 5월 23일에 https://nielsreijers.com에서 최초로 게시되었어요.","ogImage":{"url":"/assets/img/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular_0.png"},"coverImage":"/assets/img/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular_0.png","tag":["Tech"],"readingTime":10},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이 문서는 '루스트(Rust)'를 배우면서 내장형 자바 가상 머신을 이식하는 과정의 네 번째 단골입니다. 전체 시리즈를 보려면 여기를 클릭하세요.\u003c/p\u003e\n\u003cp\u003e이전 VM 버전은 Darjeeling 가상 머신의 변경 버전이었습니다. 모듈식으로 설정되어 다양한 구성 요소 세트로 쉽게 컴파일할 수 있었습니다.\u003c/p\u003e\n\u003cp\u003e이러한 구성 요소는 무선 프로그래밍, 장치 UART 액세스, Java 기본 라이브러리 등과 같은 다양한 기능을 제공했습니다. 이를 사용한 연구 프로젝트는 이종적인 사물 인터넷(IoT) 장치 네트워크를 조정하는 데 사용되었습니다. 이 프로젝트에서는 심지어 자바 가상 머신 자체를 선택적 구성 요소로 만들어 가장 작은 장치용 버전을 작성할 수 있었으므로 자바 코드를 실행할 수 없어도 네트워크에 참여할 수 있었습니다.\u003c/p\u003e\n\u003ch1\u003e프로젝트 레이아웃\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eVM을 빌드하기 전에 프로젝트 레이아웃을 먼저 설정해 봅시다. 목표는 VM을 구축할 때 설정 옵션에 따라 선택적으로 포함될 수 있는 구성 요소를 갖는 것입니다. 각 구성 요소는 코어 VM에서 노출된 여러 훅에 대한 콜백을 등록할 수 있어야 합니다. 이를 통해 구성 요소를 초기화하고 가비지 컬렉터와 상호 작용하게 하며 네트워크 메시지를 수신할 수 있어야 합니다. 이 단계에서 우리는 init()라는 훅을 정의할 것입니다. 이 훅은 시작할 때 호출됩니다.\u003c/p\u003e\n\u003cp\u003e다양한 옵션을 설명하기 위해 두 개의 구성 요소로 시작해 봅시다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ejvm : 실제 Java 가상 머신을 포함할 것입니다.\u003c/li\u003e\n\u003cli\u003euart : CPU의 UART(유니버설 비동기 수신기/발신기)를 제어하는 코드를 포함할 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e프로젝트 레이아웃은 이렇게 보일 것입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e.\n├── avrora.rs\n├── main.rs\n└── components\n    ├── \u003cspan class=\"hljs-keyword\"\u003emod\u003c/span\u003e.rs\n    ├── jvm\n    │   └── \u003cspan class=\"hljs-keyword\"\u003emod\u003c/span\u003e.rs\n    └── uart\n        └── \u003cspan class=\"hljs-keyword\"\u003emod\u003c/span\u003e.rs\n\n\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e directories, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e files\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e러스트는 세 가지 방법으로 모듈을 정의하여 계층적으로 범위를 지정합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emod modname ' ... ' 블록,\u003c/li\u003e\n\u003cli\u003emodname.rs 파일로, 이 프로젝트에는 avrora라는 모듈이 있습니다,\u003c/li\u003e\n\u003cli\u003e그리고 mod.rs가 포함된 하위 디렉토리로, 해당 하위 디렉토리의 이름을 따르는 모듈이 정의됩니다. 여기에서는 components, components::jvm, 그리고 components::uart 모듈이 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e컴파일은 main.rs 또는 라이브러리의 경우 lib.rs에서 시작됩니다. 다른 파일이나 디렉토리의 모듈은 명시적으로 프로젝트에 포함되어야 합니다. 그렇지 않을 경우 무시됩니다. 이 경우 mod avrora;와 mod components; 라인은 avrora 및 components 모듈을 가져와서 전체 크레이트에서 사용할 수 있도록 만듭니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e목표는 구성 설정에 따라 components::uart 및 components::vm을 선택적으로 포함하고, 활성화되어 있는 경우 init() 함수를 호출하는 것입니다.\u003c/p\u003e\n\u003cp\u003e이를 수행하는 세 가지 방법을 고려해 보았는데, 각각이 저에게 몇 가지 흥미로운 Rust 기능을 가르쳐 주었습니다. 따라서 모두 살펴보도록 하겠습니다:\u003c/p\u003e\n\u003ch1\u003e옵션 A: build.rs\u003c/h1\u003e\n\u003cp\u003eCargo에는 코드를 빌드하기 전에 Rust 스크립트를 실행할 수 있는 옵션이 있습니다. 스크립트는 build.rs로 불리며 프로젝트의 루트 디렉토리에 배치되어야 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e선택한 구성 요소를 가져오는 데 필요한 코드를 생성하는 데 사용할 수 있습니다. 구성 요소가 활성화되는 설정을 따로 저장할 것이며, 이는 프로젝트 루트에 있는 vm-config.toml 파일에 저장됩니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[capevm]\ncomponents = [\u003cspan class=\"hljs-string\"\u003e\"jvm\"\u003c/span\u003e]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 예에서는 jvm이 활성화되었지만 uart 구성 요소는 비활성화되었습니다. 그럼 우리의 빌드 스크립트는 다음 코드를 포함한 파일을 생성해야 합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#[path = \u003cspan class=\"hljs-string\"\u003e\"/home/niels/git/capevm-rust/capevm/src/components/jvm/mod.rs\"\u003c/span\u003e]\nmod jvm;\n\npub fn \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-attr\"\u003ejvm\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e러스트는 프로젝트에 명시적으로 임포트되지 않는 코드를 무시하므로 최종 빌드에는 jvm 모듈만 포함되고 uart 모듈은 건너뛰게 됩니다.\u003c/p\u003e\n\u003cp\u003e생성된 코드는 일시적인 파일이며 소스 제어에 포함되지 않아야 합니다. 따라서 Cargo의 출력 디렉토리에 생성하고 components/mod.rs에서 포함시키겠습니다. 이 파일은 이제 다음과 같이 한 줄만 포함하고 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003einclude!(concat!(env!(\u003cspan class=\"hljs-string\"\u003e\"OUT_DIR\"\u003c/span\u003e), \u003cspan class=\"hljs-string\"\u003e\"/enabled_components.rs\"\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e생성된 코드의 #[path] 속성이 필요한 이유는 모듈 임포트가 가져오는 파일의 위치를 기준으로 상대적이기 때문입니다. 그러나 Rust의 include! 매크로는 C의 #include 전처리기 지시문과 다르게 작동합니다. 포함된 코드는 단순히 파일에 붙여넣는 것이 아니라 해당 소스 위치에 따라 구문 분석되는데, 이 경우에는 Cargo 출력 디렉토리입니다. 만약 #[path] 속성을 사용하지 않고 Rust에게 해당 컴포넌트가 다른 위치에 있다고 알리지 않으면 아래와 같은 오류가 발생할 것입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular_0.png\"\u003e\n\u003cp\u003e다음은 완전한 빌드 스크립트입니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eextern crate toml;\n\nuse \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::fs;\nuse \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e;\nuse \u003cspan class=\"hljs-attr\"\u003etoml\u003c/span\u003e::\u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e;\n\nfn \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    println!(\u003cspan class=\"hljs-string\"\u003e\"cargo:rerun-if-changed=build.rs\"\u003c/span\u003e);\n    println!(\u003cspan class=\"hljs-string\"\u003e\"cargo:rerun-if-changed=vm-config.toml\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e manifest_dir = \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003evar\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"CARGO_MANIFEST_DIR\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eunwrap\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e out_dir = \u003cspan class=\"hljs-attr\"\u003estd\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003eenv\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003evar\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"OUT_DIR\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eunwrap\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e dest_path = \u003cspan class=\"hljs-title class_\"\u003ePath\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003enew\u003c/span\u003e(\u0026#x26;out_dir).\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"enabled_components.rs\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtents\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eString\u003c/span\u003e = \u003cspan class=\"hljs-attr\"\u003efs\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003eread_to_string\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"vm-config.toml\"\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eunwrap\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e cargo_toml = contents.\u003cspan class=\"hljs-property\"\u003eparse\u003c/span\u003e::\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e\u003e().\u003cspan class=\"hljs-title function_\"\u003eunwrap\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e vm_components =\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSome\u003c/span\u003e(capevm_components) = cargo_toml.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"capevm\"\u003c/span\u003e)\n                                        .\u003cspan class=\"hljs-title function_\"\u003eand_then\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eValue\u003c/span\u003e::as_table)\n                                        .\u003cspan class=\"hljs-title function_\"\u003eand_then\u003c/span\u003e(|table| table.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"components\"\u003c/span\u003e))\n                                        .\u003cspan class=\"hljs-title function_\"\u003eand_then\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eValue::as_array\u003c/span\u003e) {\n            capevm_components.\u003cspan class=\"hljs-title function_\"\u003eiter\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003efilter_map\u003c/span\u003e(|v| v.\u003cspan class=\"hljs-title function_\"\u003eas_str\u003c/span\u003e()).\u003cspan class=\"hljs-property\"\u003ecollect\u003c/span\u003e::\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eVec\u003c/span\u003e\u0026#x3C;\u0026#x26;str\u003e\u003e()\n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n            \u003cspan class=\"hljs-title class_\"\u003eVec\u003c/span\u003e::\u0026#x3C;\u0026#x26;str\u003e::\u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e()\n        };\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mod_imports =\n        vm_components.\u003cspan class=\"hljs-title function_\"\u003eiter\u003c/span\u003e()\n            .\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(|name| format!(r#\u003cspan class=\"hljs-string\"\u003e\"\n                #[path = \"\u003c/span\u003e{manifest_dir}/src/components/{name}/mod.\u003cspan class=\"hljs-property\"\u003ers\u003c/span\u003e\u003cspan class=\"hljs-string\"\u003e\"]\n                mod {name};\"\u003c/span\u003e#, manifest_dir=manifest_dir, name=name))\n            .\u003cspan class=\"hljs-property\"\u003ecollect\u003c/span\u003e::\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eVec\u003c/span\u003e\u0026#x3C;_\u003e\u003e().\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e mod_inits =\n        vm_components.\u003cspan class=\"hljs-title function_\"\u003eiter\u003c/span\u003e()\n            .\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(|name| format!(\u003cspan class=\"hljs-string\"\u003e\"\n                {}::init();\"\u003c/span\u003e, name))\n            .\u003cspan class=\"hljs-property\"\u003ecollect\u003c/span\u003e::\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eVec\u003c/span\u003e\u0026#x3C;_\u003e\u003e().\u003cspan class=\"hljs-title function_\"\u003ejoin\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n\"\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e generated_code =\n        format!(\u003cspan class=\"hljs-string\"\u003e\"{}\n            \n            pub fn init() {\n                {}\n            }\"\u003c/span\u003e, mod_imports, mod_inits);\n\n    \u003cspan class=\"hljs-attr\"\u003efs\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(dest_path, generated_code.\u003cspan class=\"hljs-title function_\"\u003eas_bytes\u003c/span\u003e()).\u003cspan class=\"hljs-title function_\"\u003eunwrap\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e조금 주목해야 할 사항이 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eextern crate toml; 메인 애플리케이션과 마찬가지로 build.rs 스크립트는 외부 크레이트를 사용할 수 있습니다. 다른 크레이트와 마찬가지로 Cargo.toml에 선언해야 하지만, [dependencies] 대신 [build-dependencies] 섹션에 선언해야 합니다.\u003c/li\u003e\n\u003cli\u003eprintln!(\"cargo:rerun-if-changed=...\"); 표준 출력에 쓰는 것으로 Cargo가 빌드 스크립트를 실행하는 시점(그리고 다른 여러 가지 것들)을 제어할 수 있습니다. 여기서 두 줄은 Cargo에게 build.rs 또는 vm-config.toml이 변경되면 빌드 스크립트를 다시 실행하도록 지시합니다.\u003c/li\u003e\n\u003cli\u003estd::env::var(\"CARGO_MANIFEST_DIR\"): Cargo는 환경 변수를 통해 빌드 프로세스의 여러 매개변수를 스크립트에 노출시킵니다. 이 경우 OUT_DIR을 사용하여 생성된 파일이 위치해야 하는 곳을 결정하고, CARGO_MANIFEST_DIR을 사용하여 구성 요소의 위치를 파악합니다.\u003c/li\u003e\n\u003cli\u003eunwrap(): Rust의 주요 오류 처리 방식은 Result\u0026#x3C;T, E\u003e를 반환하는 것입니다. 이는 T 값이나 E 오류 중 하나를 포함할 수 있습니다. 일반적으로 오류를 처리하거나 전달해야 하지만, 오류가 발생할 가능성이 없거나 코드가 패닉 상황이라고 생각하면 unwrap을 사용하여 Result에서 값을 가져올 수 있습니다.\u003c/li\u003e\n\u003cli\u003e.and_then(): toml 크레이트는 toml 파일의 내용을 나타내는 Value 객체를 제공합니다. 이는 이름으로 검색할 수 있습니다. 이는 Option\u0026#x3C;\u0026#x26;Value\u003e를 반환하며, 이름을 찾지 못하면 None일 수 있습니다. .and_then() 호출을 사용하면 값을 포함하는 경우에는 Option에서 작업을 연결하고, 그렇지 않은 경우에는 None을 유지할 수 있습니다. 다른 언어에서는 이를 flatmap 또는 bind라고도 부르기도 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e옵션 B: Cargo 피쳐\u003c/h1\u003e\n\u003cp\u003e두 번째 옵션은 Rust 피쳐를 사용하는 것입니다. 이 방법은 훨씬 간단하지만 한계가 있습니다. 먼저 다음과 같이 Cargo.toml에 [features] 섹션을 선언합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e[features]\n\u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e = [\u003cspan class=\"hljs-string\"\u003e\"jvm\"\u003c/span\u003e]\njvm = []\nuart = []\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e각 기능은 종속성 목록이 포함된 이름에 해당합니다. 기본 기능은 기본적으로 포함됩니다. 예를 들어 이 예시에서 기본 기능은 jvm에 의존하므로 해당 기능은 활성화되지만 uart는 활성화되지 않습니다.\u003c/p\u003e\n\u003cp\u003e그런 다음 조건부 컴파일에 사용할 수 있는 이름이 지정된 기능이 있습니다. #[cfg(feature = \"...\")] 속성을 사용하여 구성요소/mod.rs를 다음과 같이 구현할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#[\u003cspan class=\"hljs-title function_\"\u003ecfg\u003c/span\u003e(feature = \u003cspan class=\"hljs-string\"\u003e\"jvm\"\u003c/span\u003e)]\nmod jvm;\n#[\u003cspan class=\"hljs-title function_\"\u003ecfg\u003c/span\u003e(feature = \u003cspan class=\"hljs-string\"\u003e\"uart\"\u003c/span\u003e)]\nmod uart;\n\npub fn \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    #[\u003cspan class=\"hljs-title function_\"\u003ecfg\u003c/span\u003e(feature = \u003cspan class=\"hljs-string\"\u003e\"jvm\"\u003c/span\u003e)]\n    \u003cspan class=\"hljs-attr\"\u003ejvm\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e();\n    #[\u003cspan class=\"hljs-title function_\"\u003ecfg\u003c/span\u003e(feature = \u003cspan class=\"hljs-string\"\u003e\"uart\"\u003c/span\u003e)]\n    \u003cspan class=\"hljs-attr\"\u003euart\u003c/span\u003e::\u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 접근 방식의 장점은 빌드 스크립트보다 훨씬 간단하다는 것입니다. 또한 명령줄에서 선택된 기능을 제어할 수 있습니다. 예를 들어, --features=\"uart\"은 uart 기능을 활성화하며, --no-default-features는 기본 기능을 무시합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e단점 중 하나는 해당 기능이 활성화되어 있는 경우 그 모든 컴포넌트를 가져오기 위해 components/mod.rs에 수동으로 목록을 작성해야 한다는 것입니다. 게다가, 현재 init() 함수만 있어야 하는데 이 함수는 모든 활성화된 기능을 위해 호출되어야 합니다. 그러나 쓰레기 수집 및 네트워킹과 같은 항목을 추가할 때 가능한 후크 목록이 늘어나게 됩니다. 그래서 일부 컴포넌트는 수신 메시지를 듣거나 힙에 자체 객체를 등록하려는 것일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이것은 꽤 강한 결합이며, 모듈 및/또는 후크의 수가 계속해서 늘어난다면 이 접근법은 유지하기 어려워질 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e옵션 C: 기능 + 인벤토리 크레이트\u003c/h1\u003e\n\u003cp\u003e이제 옵션 C로 넘어가봅시다: 인벤토리 크레이트입니다. 이를 통해 컴포넌트와 코어 VM 간의 강한 결합을 줄일 수 있습니다. 안타깝게도 AVR에서는 작동하지 않지만, 학습할 가치가 있는 내용입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e크레이트를 사용하면 데이터 형식을 정의하고 해당 데이터 형식의 인스턴스를 코드의 한 부분에서 등록하고 다른 곳에서 수집할 수 있습니다. 저희 경우에는 데이터 형식이 init() 함수 포인터를 포함하는 구조체일 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e {\n    init: \u003cspan class=\"hljs-title function_ invoke__\"\u003efn\u003c/span\u003e()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 컴포넌트의 구현은 아래와 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-keyword\"\u003epub\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e() {\n    \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"jvm 초기화 중...\"\u003c/span\u003e);\n}\n\ninventory::submit! {\n    crate::components::Component { init }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e구성 요소/components/mod.rs의 구현부는 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e#[\u003cspan class=\"hljs-title function_\"\u003ecfg\u003c/span\u003e(feature = \u003cspan class=\"hljs-string\"\u003e\"jvm\"\u003c/span\u003e)]\nmod jvm;\n#[\u003cspan class=\"hljs-title function_\"\u003ecfg\u003c/span\u003e(feature = \u003cspan class=\"hljs-string\"\u003e\"uart\"\u003c/span\u003e)]\nmod uart;\n\npub struct \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003einit\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e()\n}\n\n\u003cspan class=\"hljs-attr\"\u003einventory\u003c/span\u003e::collect!(\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e);\n\npub fn \u003cspan class=\"hljs-title function_\"\u003einit\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e component \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003einventory\u003c/span\u003e::\u003cspan class=\"hljs-attr\"\u003eiter\u003c/span\u003e::\u0026#x3C;\u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e\u003e {\n        (component.\u003cspan class=\"hljs-property\"\u003einit\u003c/span\u003e)();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecollect! 매크로는 submit!()를 통해 등록된 모든 Component 객체를 순회할 수 있는 반복자를 생성합니다. 이 반복자는 main() 함수에 진입하기 전에 초기화되며, 우리가 수동으로 초기화 코드를 실행할 필요가 없습니다.\u003c/p\u003e\n\u003cp\u003e이 동작이 가능하게 하는 핵심은 submit! 매크로에 있습니다. 매크로가 어떻게 확장되는지 볼 수 있다는 점은 종종 유용하거나 그냥 재미있을 수 있습니다. cargo-expand라는 Cargo 확장 프로그램을 사용하여 확장된 소스를 표시할 수 있습니다. 설치한 후(cargo install cargo-expand), cargo expand components::jvm: 명령을 통해 확장된 소스를 확인할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e특정 링크된 섹션에 코드를 배치하여 마법이 일어납니다. 인벤토리 크레이트의 소스를 살펴보면(조밀하지만 500줄 미만이고 그 중 절반은 주석입니다), 생성될 링커 섹션이 운영 체제에 따라 다르다는 것을 알 수 있습니다. 리눅스의 경우 .init_array가 되고, 윈도우의 경우 .CRT$XCU가 되며 macOS의 경우 __DATA,__mod_init_func가 됩니다. 각각은 main() 함수에 진입하기 전에 실행될 코드를 포함하고 있습니다.\u003c/p\u003e\n\u003cp\u003eAVR의 경우 이러한 종류의 코드가 .initN 섹션으로 들어가지만, 안타깝게도 인벤토리 크레이트는 AVR에서 작동하지 않습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e에러 메시지가 약간 암호화되어 있어서 이 문제는 조금 어렵게 느껴질 수도 있어요. 특히 \u003ccode\u003eptr\u003c/code\u003e 피처 부분이 숨겨져 있는 것이요. 이 크레이트는 core::sync::atomic::AtomicPtr라는 유형을 사용하는데, 어떤 이유 때문에 사용할 수 없네요. 이 유형의 구현을 살펴보면 플랫폼이 원자 포인터 작업을 지원하는 경우에만 설정되는 #[cfg(target_has_atomic_load_store = \"ptr\")]라는 조건부 컴파일 속성이 있다는 것을 알게 됩니다.\u003c/p\u003e\n\u003cp\u003eAVR은 그 작업을 지원하지 않아요. 이는 8비트 CPU이며 포인터는 16비트이기 때문에 포인터 조작은 항상 여러 번의 읽기 또는 쓰기가 필요해요.\u003c/p\u003e\n\u003ch1\u003e비교와 결정\u003c/h1\u003e\n\u003cp\u003e우리는 아마도 인벤토리 크레이트가 하는 것을 AtomicPtr이 없이도 일부 코드를 복사하고 수정하여 재생산할 수 있을 거예요. 그러나 여기서 최종적으로 가장 좋은 선택이 아닌 이유가 하나 더 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 방식은 iterator가 루프를 돌 수 있는 정적 inventory::Node 객체의 링크드 리스트를 만들어 작동합니다. 이것은 RAM을 사용하므로, 객체당 4바이트가 필요한 경우에도 RAM이 단 4KB만 있는 장치에서 정적 목록에 낭비하고 싶지 않습니다.\u003c/p\u003e\n\u003cp\u003e그러므로 옵션 A와 B 중에서 선택해야 합니다. 옵션 A는 핵심 vm 코드가 구성 요소에 대해 알 필요가 없어 보이지만, 옵션 B는 각 구성 요소를 해당 기능 플래그와 등록해야 한다는 점이 필요합니다.\u003c/p\u003e\n\u003cp\u003e옵션 A의 단점은 각 구성 요소가 초기화할 것이 없더라도 init()에 대한 구현을 정의해야 한다는 것입니다. 빌드 스크립트는 항상 호출을 생성하므로 말입니다. 러스트 컴파일러는 죽은 코드를 제거하는 데 매우 뛰어나기 때문에, 컴파일 시간에 이 코드들이 제거될 가능성이 높지만, 나중에 사용할 쓰레기 수집기를 위해 비슷한 후크를 추가할 때마다, 적어도 빈 구현을 제공해야 하는데 이는 추가 작업이 필요합니다.\u003c/p\u003e\n\u003cp\u003e구성 요소와 후크의 수가 제한될 것이므로, 두 옵션 모두 잘 작동할 것으로 보입니다. 옵션 A는 더 많은 요소가 움직이며, 마법이 적으면 항상 좋은 것이므로, 일단 옵션 B를 선택하겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e보통 이번 단계의 코드 상태는 Github에서 확인하실 수 있어요. 세 가지 옵션을 업로드했어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e옵션 A: build.rs\u003c/li\u003e\n\u003cli\u003e옵션 B: features\u003c/li\u003e\n\u003cli\u003e옵션 C: features + inventory (AVR에서 컴파일되지 않아요)\u003c/li\u003e\n\u003cli\u003e데스크탑에서 작동하는 옵션 C의 최소 예제.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e2024년 5월 23일에 \u003ca href=\"https://nielsreijers.com%EC%97%90%EC%84%9C\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://nielsreijers.com에서\u003c/a\u003e 최초로 게시되었어요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-NielslearnsRust4ThreedifferentwaysmaketheVMmodular"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>