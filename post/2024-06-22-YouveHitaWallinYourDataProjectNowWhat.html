<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>데이터 프로젝트에서 벽에 부딪혔다면 이제 어떻게 해야 할까요 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-22-YouveHitaWallinYourDataProjectNowWhat" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="데이터 프로젝트에서 벽에 부딪혔다면 이제 어떻게 해야 할까요 | itposting" data-gatsby-head="true"/><meta property="og:title" content="데이터 프로젝트에서 벽에 부딪혔다면 이제 어떻게 해야 할까요 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-YouveHitaWallinYourDataProjectNowWhat_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-22-YouveHitaWallinYourDataProjectNowWhat" data-gatsby-head="true"/><meta name="twitter:title" content="데이터 프로젝트에서 벽에 부딪혔다면 이제 어떻게 해야 할까요 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-YouveHitaWallinYourDataProjectNowWhat_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 17:53" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">데이터 프로젝트에서 벽에 부딪혔다면 이제 어떻게 해야 할까요</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="데이터 프로젝트에서 벽에 부딪혔다면 이제 어떻게 해야 할까요" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-YouveHitaWallinYourDataProjectNowWhat&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><img src="/assets/img/2024-06-22-YouveHitaWallinYourDataProjectNowWhat_0.png" alt="img"></p>
<p>우리 모두가 익숙한 시나리오를 경험했을 것입니다: SQL 쿼리를 개발하거나 데이터 파이프라인을 구축하거나 예측 모델을 작성 중이면서 최종 출력 데이터 집합이라고 생각되는 지점에서 코드를 실행하면 의도하지 않은 결과가 나오는 것이다. 레코드 수가 이상하게 반환된다거나, 필드가 올바르게 채워지지 않는다거나, 모델이 예상치 못한 결과를 생성할 수도 있습니다.</p>
<p>어떤 문제가 발생했음을 알지만 코드에는 문제가 발생한 원인에 대한 오류 메시지나 명확한 표시가 없을 때 어떻게 문제 해결에 접근해야 할까요?</p>
<p>지난 6년 이상의 다양한 분석 업무에서 얻은 경험으로 말씀드리면, 새로운 개발 문제를 해결하며 자주 벽에 부딪힐 것이라고 확신합니다. 그러나 이러한 장애물을 극복하고 더 강인한 전문가로 나아가기 위해 채택한 효과적인 전략이 있습니다. 다음 섹션에서는 내게 가장 성공적으로 입증된 몇 가지 기술을 공유하겠습니다.</p>
<div class="content-ad"></div>
<h2>"재부팅을 시도해 보셨나요?"</h2>
<p>저는 컴퓨터를 껐다 켜는 것을 의미하는 게 아니라, 오히려 뇌를 재설정하는 것을 말하고 있어요. 다시 말해, 몇 분 동안 책상에서 멀어지는 걸 시도해 보세요.</p>
<p>이게 얼마나 효과가 좋은지 믿을 수 없을 정도로 도움이 됐던 적이 많아요. 때로는 간단한 산책만으로도 문제에 대한 해결책이나 새로운 접근 방법이 스스로 떠오르곤 해요. 너무 오래 동안 같은 문제를 바라보고 있으면, 문제의 한 부분에만 집중하다가 더 큰 그림을 잊고 만다는 점이 쉽게 발생할 수 있어요.</p>
<p>예를 들어, 파이썬 함수를 사용해서 데이터 포인트를 올바르게 출력하려는 문제를 겪고 있을 수도 있어요. 하지만 더 중요한 것은, 함수가 왜 필요한지, 어떤 종속성이 있는지, 그리고 함께 상호작용해야 하는 다른 데이터들이 무엇인지에 대한 초점을 잃었을 수 있다는 거죠. 때때로 이러한 방법이 문제를 해결하는 길로 다시 돌아가는 가장 좋은 방법일 수 있어요.</p>
<div class="content-ad"></div>
<h2>가정을 다시 바라보기</h2>
<p>제 개인적인 경험으로 보면, 제 경력에서 부딪힌 대부분의 장애물은 데이터나 코드에 대해 잘못된 가정을 한 것에서 비롯되었습니다.</p>
<p>어느 한 역할에서, 퇴사한 다른 데이터 분석가가 만든 대시보드 지표를 복제하는 업무를 맡았습니다. 이전 SQL과 해당 지표를 생성하는 데 사용된 Power BI 워크북에 접근할 수 있었습니다. 나는 비슷한 방식으로 비즈니스 로직을 복제했지만, 결과물을 출력했을 때 약 5% 정도 다르게 나타났습니다. 문법의 정확성, 필드 호출, 및 조인에서 의도하지 않은 데이터 필터링을 철저히 검토하기 위해 상당한 시간을 보냈지만, 이러한 접근 방식들 중 어느 것도 작동하지 않았습니다. 더 철저한 검토를 거친 후, 우리 둘 다 다른 원본 테이블에서 필드명이 customer_active로 필터링하는 것으로 밝혀졌으며, 이 두 필드는 백엔드에서 서로 다르게 계산되었습니다.</p>
<p>위의 장애물의 근본 원인은 내가 호출한 필드에 대해 가정을 한 점이었습니다. 내가 생각했던 대로 데이터를 쿼리했지만, 잘못된 데이터에 대한 내 가정이 결국 우리 둘 간의 지표와의 5% 차이의 원인이었습니다. 되돌아보면, 차이가 발생하는 곳을 이해하기 위해 소스 테이블로 역추적하는 것이 더 나은 방법이었을 것입니다.</p>
<div class="content-ad"></div>
<p>일반적으로 이 단계에 있을 때 다음을 고려해보세요:</p>
<ul>
<li>작업 중인 데이터의 기본 정보는 무엇인가요? 즉, 각 행이 나타내는 내용은 무엇인가요? 예를 들어 매일 스냅샷되는 고객 테이블과 작업 중이라면 — 테이블의 기본 정보는 고객과 날짜입니다. 의도한 테이블의 기본 정보가 실제로 출력되는 것인지 확인하세요.</li>
<li>검토 중인 코드가 전체 그림을 나타내는가요? 데이터가 상류 어딘가에 잘못된 부분이 있는지 이해해야 할 필요가 있나요? 파이프라인 또는 데이터 수집 문제가 있을 수 있나요?</li>
<li>비즈니스와 관련된 x 테이블의 문맥을 정확히 이해하고 있나요? 관련 데이터가 시스템과 프로세스 관점에서 어떻게 유래되는지 이해하는 것이 중요합니다. 명확하지 않다면 전문가와 협업하세요.</li>
</ul>
<h2>코드의 개별 세그먼트를 분리하세요</h2>
<p>SQL 작업 시, 나의 즐겨찾는 방법은 코드 세그먼트를 공통 테이블 표현으로 분리하고 각각을 개별적으로 쿼리하는 것입니다. 이 형식은 처음에 DBT를 사용할 때 발견했고, 그들의 문서에서 더 많은 정보를 확인할 수 있습니다. 다음과 같은 예시를 살펴보세요:</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">WITH</span> customer_acq <span class="hljs-variable constant_">AS</span> (
  <span class="hljs-variable constant_">SELECT</span>
  *
  , <span class="hljs-variable constant_">CASE</span>
      <span class="hljs-variable constant_">WHEN</span> first_order_date <span class="hljs-variable constant_">IS</span> <span class="hljs-variable constant_">NOT</span> <span class="hljs-variable constant_">NULL</span>
        <span class="hljs-variable constant_">THEN</span> first_order_date
      <span class="hljs-variable constant_">ELSE</span> salesforce_date_created
    <span class="hljs-variable constant_">END</span> <span class="hljs-variable constant_">AS</span> acquisition_date
  <span class="hljs-variable constant_">FROM</span> customers
)

, main <span class="hljs-variable constant_">AS</span> (
  <span class="hljs-variable constant_">SELECT</span>
  *
  <span class="hljs-variable constant_">FROM</span> customer_acq
  <span class="hljs-variable constant_">WHERE</span> acquisition_date >= <span class="hljs-title function_">DATE_SUB</span>(<span class="hljs-title function_">CURRENT_DATE</span>(), <span class="hljs-variable constant_">INTERVAL</span> <span class="hljs-number">30</span> <span class="hljs-variable constant_">DAY</span>)
)

<span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">FROM</span> main
</code></pre>
<p>마지막 줄에 있는 SELECT * FROM main 부분이 불필요해 보일 수 있지만, 이 구조를 통해 코드 세그먼트의 문제 해결을 쉽게 할 수 있음을 보증할 수 있어요. 여기서 마지막 줄에서 우리는 각 CTE의 출력을 쿼리하여 각각에서 무엇이 잘못되고 있는지 확인할 수 있어요. 이 기술은 특히 쿼리의 출력이 의도치 않게 0개의 레코드를 반환할 때 매우 효과적으로 증명되었어요. 여기서 "main"이라는 마지막 단어를 다른 CTE 이름으로 변경함으로써 모든 레코드를 필터링하는 원인 CTE를 결정할 수 있어요.</p>
<p>CTE가 쿼리 최적화에 부담을 준다는 것은 일반적인 오해입니다. 실제로 (적어도 눈에 띄는 차이를 만들 만큼만이라도) 현대 클라우드 데이터 웨어하우스 공급업체와 함께 작업하는 경우 CTE가 쿼리 최적화에 미칠 영향은 상당하지 않아요.</p>
<h2>하나의 예시 레코드 격리하기</h2>
<div class="content-ad"></div>
<p>이 기술을 사용하여 원본 시스템의 한 예제 레코드, 원본 데이터베이스 테이블 및 코드의 출력에서 하나의 예제 레코드를 살펴보고자 합니다. 이를 통해 A.) 원본 시스템에서 데이터베이스로 데이터가 이동하는 과정에 어떤 문제가 있는지와 B.) 적용한 로직이 이 한 레코드에 어떤 영향을 미치는지를 결정할 수 있습니다. 하나를 분리함으로써 우리는 개별 입력이 개발한 코드를 통해 어떻게 흐르는지 더 명확하게 이해할 수 있습니다. 이 단계에서 다음 사항을 평가할 수 있습니다:</p>
<ul>
<li>이 레코드가 의도한 대로 코드를 통해 흐르고 있는가?</li>
<li>그렇지 않다면, 이 레코드가 제대로 작동하는 다른 레코드와 어떤 점이 다른가요?</li>
</ul>
<p>위에서 언급한 기술과 결합하여, 코드의 개별 부분에서 개별 레코드를 분리할 수도 있습니다. 예를 들어, 위에서 정의한 CTE를 사용하여 코드의 각 세그먼트를 통해 특정 레코드가 어떻게 출력되는지 확인해보세요. 여기에서는 코드 중 어떤 섹션이 레코드를 잘못 조작하고 있는지를 정확히 식별할 수 있어야 합니다.</p>
<h2>더 이상 추측하지 마세요</h2>
<div class="content-ad"></div>
<p>문제 명세서에 대해 포괄적인 시각을 가져야 합니다. 대시보드가 올바르게 채워지지 않는 상황에 처해 있을 때, 소규모 수정(필터 조건 변경 등)을 하고 대시보드를 새로고침하여 최선을 바라는 습관에 빠지기 쉬울 수 있습니다. 이것은 마치 주사위를 던지는 것과 다를바 없으며, 여러 계층의 문제를 효과적으로 해결하는 방법이 아닙니다.</p>
<p>문제 명세서를 해체하고 다시 구성해보세요. 다음과 같은 질문을 스스로에게 던져보세요:</p>
<ul>
<li>어떤 비즈니스 질문에 답하려고 하는가요?</li>
<li>이에 대한 답변을 위해 어떤 데이터가 사용 가능한가요? 각 관련 데이터 테이블이 무엇을 나타내는지 알아야 합니다. 최소 가치 제품을 제공하기 위해 필요한 데이터와 사용 가능한 데이터에 대한 명확한 가이드라인을 가져야 합니다.</li>
<li>소스 데이터 위에 BI 레이어를 구축하기 위해 필요한 변확 필요한 변환은 무엇인가요?</li>
<li>사용 중인 데이터 소스 또는 데이터 파이프라인의 미묘한 점은 무엇인가요?</li>
<li>데이터 품질 — 널 값이 어디에 존재하나요? 데이터의 지연에 대한 우려사항은 없나요?</li>
</ul>
<p>이러한 질문에 대답할 수 없다면, 도움을 요청하거나 데이터에 대한 팀원 또는 전문가와 소통하는 것도 괜찮습니다. 데이터에 대한 친숙함은 가치 있는 해결책을 제공하는 데 중요하므로 필요하다면 비즈니스 컨텍스트를 더 잘 이해하기 위해 필요한 시간을 투자하는 것이 중요합니다.</p>
<div class="content-ad"></div>
<h1>결론</h1>
<p>시니어리티 레벨에 관계없이, 발전하는 과정에서 어려움을 겪게 될 것입니다. 때때로 이미 알고 있는 지식을 잊고 문제에 새로운 시각으로 접근해야 합니다. 예상치 못한 결과나 어려움에 부딪힐 때는 체계적인 방법을 채택하고 차분한 마음가짐을 유지하는 것이 중요합니다.</p>
<p>어떤 데이터 프로젝트에서도 어려움에 부딪히는 것은 실패의 징후가 아니라 성장의 기회입니다. 이러한 전략을 적용하고 프로젝트에 대해 종합적인 시각을 유지함으로써 문제 해결 능력을 향상시키고 더욱 신뢰할 수 있고 효율적인 결과를 이룰 수 있습니다. 그러니 다음 번 데이터 프로젝트에서 어려움을 겪을 때는 이 기술들을 포용하고 시각을 재설정하며, 각 어려움이 더 강력한 데이터 전문가로 발전하는 한 걸음 다가가는 과정임을 기억해주세요.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"데이터 프로젝트에서 벽에 부딪혔다면 이제 어떻게 해야 할까요","description":"","date":"2024-06-22 17:53","slug":"2024-06-22-YouveHitaWallinYourDataProjectNowWhat","content":"\n\n![img](/assets/img/2024-06-22-YouveHitaWallinYourDataProjectNowWhat_0.png)\n\n우리 모두가 익숙한 시나리오를 경험했을 것입니다: SQL 쿼리를 개발하거나 데이터 파이프라인을 구축하거나 예측 모델을 작성 중이면서 최종 출력 데이터 집합이라고 생각되는 지점에서 코드를 실행하면 의도하지 않은 결과가 나오는 것이다. 레코드 수가 이상하게 반환된다거나, 필드가 올바르게 채워지지 않는다거나, 모델이 예상치 못한 결과를 생성할 수도 있습니다.\n\n어떤 문제가 발생했음을 알지만 코드에는 문제가 발생한 원인에 대한 오류 메시지나 명확한 표시가 없을 때 어떻게 문제 해결에 접근해야 할까요? \n\n지난 6년 이상의 다양한 분석 업무에서 얻은 경험으로 말씀드리면, 새로운 개발 문제를 해결하며 자주 벽에 부딪힐 것이라고 확신합니다. 그러나 이러한 장애물을 극복하고 더 강인한 전문가로 나아가기 위해 채택한 효과적인 전략이 있습니다. 다음 섹션에서는 내게 가장 성공적으로 입증된 몇 가지 기술을 공유하겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## \"재부팅을 시도해 보셨나요?\"\n\n저는 컴퓨터를 껐다 켜는 것을 의미하는 게 아니라, 오히려 뇌를 재설정하는 것을 말하고 있어요. 다시 말해, 몇 분 동안 책상에서 멀어지는 걸 시도해 보세요.\n\n이게 얼마나 효과가 좋은지 믿을 수 없을 정도로 도움이 됐던 적이 많아요. 때로는 간단한 산책만으로도 문제에 대한 해결책이나 새로운 접근 방법이 스스로 떠오르곤 해요. 너무 오래 동안 같은 문제를 바라보고 있으면, 문제의 한 부분에만 집중하다가 더 큰 그림을 잊고 만다는 점이 쉽게 발생할 수 있어요.\n\n예를 들어, 파이썬 함수를 사용해서 데이터 포인트를 올바르게 출력하려는 문제를 겪고 있을 수도 있어요. 하지만 더 중요한 것은, 함수가 왜 필요한지, 어떤 종속성이 있는지, 그리고 함께 상호작용해야 하는 다른 데이터들이 무엇인지에 대한 초점을 잃었을 수 있다는 거죠. 때때로 이러한 방법이 문제를 해결하는 길로 다시 돌아가는 가장 좋은 방법일 수 있어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 가정을 다시 바라보기\n\n제 개인적인 경험으로 보면, 제 경력에서 부딪힌 대부분의 장애물은 데이터나 코드에 대해 잘못된 가정을 한 것에서 비롯되었습니다.\n\n어느 한 역할에서, 퇴사한 다른 데이터 분석가가 만든 대시보드 지표를 복제하는 업무를 맡았습니다. 이전 SQL과 해당 지표를 생성하는 데 사용된 Power BI 워크북에 접근할 수 있었습니다. 나는 비슷한 방식으로 비즈니스 로직을 복제했지만, 결과물을 출력했을 때 약 5% 정도 다르게 나타났습니다. 문법의 정확성, 필드 호출, 및 조인에서 의도하지 않은 데이터 필터링을 철저히 검토하기 위해 상당한 시간을 보냈지만, 이러한 접근 방식들 중 어느 것도 작동하지 않았습니다. 더 철저한 검토를 거친 후, 우리 둘 다 다른 원본 테이블에서 필드명이 customer_active로 필터링하는 것으로 밝혀졌으며, 이 두 필드는 백엔드에서 서로 다르게 계산되었습니다.\n\n위의 장애물의 근본 원인은 내가 호출한 필드에 대해 가정을 한 점이었습니다. 내가 생각했던 대로 데이터를 쿼리했지만, 잘못된 데이터에 대한 내 가정이 결국 우리 둘 간의 지표와의 5% 차이의 원인이었습니다. 되돌아보면, 차이가 발생하는 곳을 이해하기 위해 소스 테이블로 역추적하는 것이 더 나은 방법이었을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일반적으로 이 단계에 있을 때 다음을 고려해보세요:\n\n- 작업 중인 데이터의 기본 정보는 무엇인가요? 즉, 각 행이 나타내는 내용은 무엇인가요? 예를 들어 매일 스냅샷되는 고객 테이블과 작업 중이라면 — 테이블의 기본 정보는 고객과 날짜입니다. 의도한 테이블의 기본 정보가 실제로 출력되는 것인지 확인하세요.\n- 검토 중인 코드가 전체 그림을 나타내는가요? 데이터가 상류 어딘가에 잘못된 부분이 있는지 이해해야 할 필요가 있나요? 파이프라인 또는 데이터 수집 문제가 있을 수 있나요?\n- 비즈니스와 관련된 x 테이블의 문맥을 정확히 이해하고 있나요? 관련 데이터가 시스템과 프로세스 관점에서 어떻게 유래되는지 이해하는 것이 중요합니다. 명확하지 않다면 전문가와 협업하세요.\n\n## 코드의 개별 세그먼트를 분리하세요\n\nSQL 작업 시, 나의 즐겨찾는 방법은 코드 세그먼트를 공통 테이블 표현으로 분리하고 각각을 개별적으로 쿼리하는 것입니다. 이 형식은 처음에 DBT를 사용할 때 발견했고, 그들의 문서에서 더 많은 정보를 확인할 수 있습니다. 다음과 같은 예시를 살펴보세요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nWITH customer_acq AS (\n  SELECT\n  *\n  , CASE\n      WHEN first_order_date IS NOT NULL\n        THEN first_order_date\n      ELSE salesforce_date_created\n    END AS acquisition_date\n  FROM customers\n)\n\n, main AS (\n  SELECT\n  *\n  FROM customer_acq\n  WHERE acquisition_date \u003e= DATE_SUB(CURRENT_DATE(), INTERVAL 30 DAY)\n)\n\nSELECT * FROM main\n```\n\n마지막 줄에 있는 SELECT * FROM main 부분이 불필요해 보일 수 있지만, 이 구조를 통해 코드 세그먼트의 문제 해결을 쉽게 할 수 있음을 보증할 수 있어요. 여기서 마지막 줄에서 우리는 각 CTE의 출력을 쿼리하여 각각에서 무엇이 잘못되고 있는지 확인할 수 있어요. 이 기술은 특히 쿼리의 출력이 의도치 않게 0개의 레코드를 반환할 때 매우 효과적으로 증명되었어요. 여기서 \"main\"이라는 마지막 단어를 다른 CTE 이름으로 변경함으로써 모든 레코드를 필터링하는 원인 CTE를 결정할 수 있어요.\n\nCTE가 쿼리 최적화에 부담을 준다는 것은 일반적인 오해입니다. 실제로 (적어도 눈에 띄는 차이를 만들 만큼만이라도) 현대 클라우드 데이터 웨어하우스 공급업체와 함께 작업하는 경우 CTE가 쿼리 최적화에 미칠 영향은 상당하지 않아요.\n\n## 하나의 예시 레코드 격리하기\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기술을 사용하여 원본 시스템의 한 예제 레코드, 원본 데이터베이스 테이블 및 코드의 출력에서 하나의 예제 레코드를 살펴보고자 합니다. 이를 통해 A.) 원본 시스템에서 데이터베이스로 데이터가 이동하는 과정에 어떤 문제가 있는지와 B.) 적용한 로직이 이 한 레코드에 어떤 영향을 미치는지를 결정할 수 있습니다. 하나를 분리함으로써 우리는 개별 입력이 개발한 코드를 통해 어떻게 흐르는지 더 명확하게 이해할 수 있습니다. 이 단계에서 다음 사항을 평가할 수 있습니다:\n\n- 이 레코드가 의도한 대로 코드를 통해 흐르고 있는가?\n- 그렇지 않다면, 이 레코드가 제대로 작동하는 다른 레코드와 어떤 점이 다른가요?\n\n위에서 언급한 기술과 결합하여, 코드의 개별 부분에서 개별 레코드를 분리할 수도 있습니다. 예를 들어, 위에서 정의한 CTE를 사용하여 코드의 각 세그먼트를 통해 특정 레코드가 어떻게 출력되는지 확인해보세요. 여기에서는 코드 중 어떤 섹션이 레코드를 잘못 조작하고 있는지를 정확히 식별할 수 있어야 합니다.\n\n## 더 이상 추측하지 마세요\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n문제 명세서에 대해 포괄적인 시각을 가져야 합니다. 대시보드가 올바르게 채워지지 않는 상황에 처해 있을 때, 소규모 수정(필터 조건 변경 등)을 하고 대시보드를 새로고침하여 최선을 바라는 습관에 빠지기 쉬울 수 있습니다. 이것은 마치 주사위를 던지는 것과 다를바 없으며, 여러 계층의 문제를 효과적으로 해결하는 방법이 아닙니다.\n\n문제 명세서를 해체하고 다시 구성해보세요. 다음과 같은 질문을 스스로에게 던져보세요:\n\n- 어떤 비즈니스 질문에 답하려고 하는가요?\n- 이에 대한 답변을 위해 어떤 데이터가 사용 가능한가요? 각 관련 데이터 테이블이 무엇을 나타내는지 알아야 합니다. 최소 가치 제품을 제공하기 위해 필요한 데이터와 사용 가능한 데이터에 대한 명확한 가이드라인을 가져야 합니다.\n- 소스 데이터 위에 BI 레이어를 구축하기 위해 필요한 변확 필요한 변환은 무엇인가요?\n- 사용 중인 데이터 소스 또는 데이터 파이프라인의 미묘한 점은 무엇인가요?\n- 데이터 품질 — 널 값이 어디에 존재하나요? 데이터의 지연에 대한 우려사항은 없나요?\n\n이러한 질문에 대답할 수 없다면, 도움을 요청하거나 데이터에 대한 팀원 또는 전문가와 소통하는 것도 괜찮습니다. 데이터에 대한 친숙함은 가치 있는 해결책을 제공하는 데 중요하므로 필요하다면 비즈니스 컨텍스트를 더 잘 이해하기 위해 필요한 시간을 투자하는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 결론\n\n시니어리티 레벨에 관계없이, 발전하는 과정에서 어려움을 겪게 될 것입니다. 때때로 이미 알고 있는 지식을 잊고 문제에 새로운 시각으로 접근해야 합니다. 예상치 못한 결과나 어려움에 부딪힐 때는 체계적인 방법을 채택하고 차분한 마음가짐을 유지하는 것이 중요합니다.\n\n어떤 데이터 프로젝트에서도 어려움에 부딪히는 것은 실패의 징후가 아니라 성장의 기회입니다. 이러한 전략을 적용하고 프로젝트에 대해 종합적인 시각을 유지함으로써 문제 해결 능력을 향상시키고 더욱 신뢰할 수 있고 효율적인 결과를 이룰 수 있습니다. 그러니 다음 번 데이터 프로젝트에서 어려움을 겪을 때는 이 기술들을 포용하고 시각을 재설정하며, 각 어려움이 더 강력한 데이터 전문가로 발전하는 한 걸음 다가가는 과정임을 기억해주세요.","ogImage":{"url":"/assets/img/2024-06-22-YouveHitaWallinYourDataProjectNowWhat_0.png"},"coverImage":"/assets/img/2024-06-22-YouveHitaWallinYourDataProjectNowWhat_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-22-YouveHitaWallinYourDataProjectNowWhat_0.png\" alt=\"img\"\u003e\u003c/p\u003e\n\u003cp\u003e우리 모두가 익숙한 시나리오를 경험했을 것입니다: SQL 쿼리를 개발하거나 데이터 파이프라인을 구축하거나 예측 모델을 작성 중이면서 최종 출력 데이터 집합이라고 생각되는 지점에서 코드를 실행하면 의도하지 않은 결과가 나오는 것이다. 레코드 수가 이상하게 반환된다거나, 필드가 올바르게 채워지지 않는다거나, 모델이 예상치 못한 결과를 생성할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e어떤 문제가 발생했음을 알지만 코드에는 문제가 발생한 원인에 대한 오류 메시지나 명확한 표시가 없을 때 어떻게 문제 해결에 접근해야 할까요?\u003c/p\u003e\n\u003cp\u003e지난 6년 이상의 다양한 분석 업무에서 얻은 경험으로 말씀드리면, 새로운 개발 문제를 해결하며 자주 벽에 부딪힐 것이라고 확신합니다. 그러나 이러한 장애물을 극복하고 더 강인한 전문가로 나아가기 위해 채택한 효과적인 전략이 있습니다. 다음 섹션에서는 내게 가장 성공적으로 입증된 몇 가지 기술을 공유하겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e\"재부팅을 시도해 보셨나요?\"\u003c/h2\u003e\n\u003cp\u003e저는 컴퓨터를 껐다 켜는 것을 의미하는 게 아니라, 오히려 뇌를 재설정하는 것을 말하고 있어요. 다시 말해, 몇 분 동안 책상에서 멀어지는 걸 시도해 보세요.\u003c/p\u003e\n\u003cp\u003e이게 얼마나 효과가 좋은지 믿을 수 없을 정도로 도움이 됐던 적이 많아요. 때로는 간단한 산책만으로도 문제에 대한 해결책이나 새로운 접근 방법이 스스로 떠오르곤 해요. 너무 오래 동안 같은 문제를 바라보고 있으면, 문제의 한 부분에만 집중하다가 더 큰 그림을 잊고 만다는 점이 쉽게 발생할 수 있어요.\u003c/p\u003e\n\u003cp\u003e예를 들어, 파이썬 함수를 사용해서 데이터 포인트를 올바르게 출력하려는 문제를 겪고 있을 수도 있어요. 하지만 더 중요한 것은, 함수가 왜 필요한지, 어떤 종속성이 있는지, 그리고 함께 상호작용해야 하는 다른 데이터들이 무엇인지에 대한 초점을 잃었을 수 있다는 거죠. 때때로 이러한 방법이 문제를 해결하는 길로 다시 돌아가는 가장 좋은 방법일 수 있어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e가정을 다시 바라보기\u003c/h2\u003e\n\u003cp\u003e제 개인적인 경험으로 보면, 제 경력에서 부딪힌 대부분의 장애물은 데이터나 코드에 대해 잘못된 가정을 한 것에서 비롯되었습니다.\u003c/p\u003e\n\u003cp\u003e어느 한 역할에서, 퇴사한 다른 데이터 분석가가 만든 대시보드 지표를 복제하는 업무를 맡았습니다. 이전 SQL과 해당 지표를 생성하는 데 사용된 Power BI 워크북에 접근할 수 있었습니다. 나는 비슷한 방식으로 비즈니스 로직을 복제했지만, 결과물을 출력했을 때 약 5% 정도 다르게 나타났습니다. 문법의 정확성, 필드 호출, 및 조인에서 의도하지 않은 데이터 필터링을 철저히 검토하기 위해 상당한 시간을 보냈지만, 이러한 접근 방식들 중 어느 것도 작동하지 않았습니다. 더 철저한 검토를 거친 후, 우리 둘 다 다른 원본 테이블에서 필드명이 customer_active로 필터링하는 것으로 밝혀졌으며, 이 두 필드는 백엔드에서 서로 다르게 계산되었습니다.\u003c/p\u003e\n\u003cp\u003e위의 장애물의 근본 원인은 내가 호출한 필드에 대해 가정을 한 점이었습니다. 내가 생각했던 대로 데이터를 쿼리했지만, 잘못된 데이터에 대한 내 가정이 결국 우리 둘 간의 지표와의 5% 차이의 원인이었습니다. 되돌아보면, 차이가 발생하는 곳을 이해하기 위해 소스 테이블로 역추적하는 것이 더 나은 방법이었을 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e일반적으로 이 단계에 있을 때 다음을 고려해보세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e작업 중인 데이터의 기본 정보는 무엇인가요? 즉, 각 행이 나타내는 내용은 무엇인가요? 예를 들어 매일 스냅샷되는 고객 테이블과 작업 중이라면 — 테이블의 기본 정보는 고객과 날짜입니다. 의도한 테이블의 기본 정보가 실제로 출력되는 것인지 확인하세요.\u003c/li\u003e\n\u003cli\u003e검토 중인 코드가 전체 그림을 나타내는가요? 데이터가 상류 어딘가에 잘못된 부분이 있는지 이해해야 할 필요가 있나요? 파이프라인 또는 데이터 수집 문제가 있을 수 있나요?\u003c/li\u003e\n\u003cli\u003e비즈니스와 관련된 x 테이블의 문맥을 정확히 이해하고 있나요? 관련 데이터가 시스템과 프로세스 관점에서 어떻게 유래되는지 이해하는 것이 중요합니다. 명확하지 않다면 전문가와 협업하세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e코드의 개별 세그먼트를 분리하세요\u003c/h2\u003e\n\u003cp\u003eSQL 작업 시, 나의 즐겨찾는 방법은 코드 세그먼트를 공통 테이블 표현으로 분리하고 각각을 개별적으로 쿼리하는 것입니다. 이 형식은 처음에 DBT를 사용할 때 발견했고, 그들의 문서에서 더 많은 정보를 확인할 수 있습니다. 다음과 같은 예시를 살펴보세요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eWITH\u003c/span\u003e customer_acq \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n  \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n  *\n  , \u003cspan class=\"hljs-variable constant_\"\u003eCASE\u003c/span\u003e\n      \u003cspan class=\"hljs-variable constant_\"\u003eWHEN\u003c/span\u003e first_order_date \u003cspan class=\"hljs-variable constant_\"\u003eIS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eNOT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eNULL\u003c/span\u003e\n        \u003cspan class=\"hljs-variable constant_\"\u003eTHEN\u003c/span\u003e first_order_date\n      \u003cspan class=\"hljs-variable constant_\"\u003eELSE\u003c/span\u003e salesforce_date_created\n    \u003cspan class=\"hljs-variable constant_\"\u003eEND\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e acquisition_date\n  \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e customers\n)\n\n, main \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n  \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n  *\n  \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e customer_acq\n  \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e acquisition_date \u003e= \u003cspan class=\"hljs-title function_\"\u003eDATE_SUB\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eCURRENT_DATE\u003c/span\u003e(), \u003cspan class=\"hljs-variable constant_\"\u003eINTERVAL\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDAY\u003c/span\u003e)\n)\n\n\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e * \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e main\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막 줄에 있는 SELECT * FROM main 부분이 불필요해 보일 수 있지만, 이 구조를 통해 코드 세그먼트의 문제 해결을 쉽게 할 수 있음을 보증할 수 있어요. 여기서 마지막 줄에서 우리는 각 CTE의 출력을 쿼리하여 각각에서 무엇이 잘못되고 있는지 확인할 수 있어요. 이 기술은 특히 쿼리의 출력이 의도치 않게 0개의 레코드를 반환할 때 매우 효과적으로 증명되었어요. 여기서 \"main\"이라는 마지막 단어를 다른 CTE 이름으로 변경함으로써 모든 레코드를 필터링하는 원인 CTE를 결정할 수 있어요.\u003c/p\u003e\n\u003cp\u003eCTE가 쿼리 최적화에 부담을 준다는 것은 일반적인 오해입니다. 실제로 (적어도 눈에 띄는 차이를 만들 만큼만이라도) 현대 클라우드 데이터 웨어하우스 공급업체와 함께 작업하는 경우 CTE가 쿼리 최적화에 미칠 영향은 상당하지 않아요.\u003c/p\u003e\n\u003ch2\u003e하나의 예시 레코드 격리하기\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 기술을 사용하여 원본 시스템의 한 예제 레코드, 원본 데이터베이스 테이블 및 코드의 출력에서 하나의 예제 레코드를 살펴보고자 합니다. 이를 통해 A.) 원본 시스템에서 데이터베이스로 데이터가 이동하는 과정에 어떤 문제가 있는지와 B.) 적용한 로직이 이 한 레코드에 어떤 영향을 미치는지를 결정할 수 있습니다. 하나를 분리함으로써 우리는 개별 입력이 개발한 코드를 통해 어떻게 흐르는지 더 명확하게 이해할 수 있습니다. 이 단계에서 다음 사항을 평가할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e이 레코드가 의도한 대로 코드를 통해 흐르고 있는가?\u003c/li\u003e\n\u003cli\u003e그렇지 않다면, 이 레코드가 제대로 작동하는 다른 레코드와 어떤 점이 다른가요?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e위에서 언급한 기술과 결합하여, 코드의 개별 부분에서 개별 레코드를 분리할 수도 있습니다. 예를 들어, 위에서 정의한 CTE를 사용하여 코드의 각 세그먼트를 통해 특정 레코드가 어떻게 출력되는지 확인해보세요. 여기에서는 코드 중 어떤 섹션이 레코드를 잘못 조작하고 있는지를 정확히 식별할 수 있어야 합니다.\u003c/p\u003e\n\u003ch2\u003e더 이상 추측하지 마세요\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e문제 명세서에 대해 포괄적인 시각을 가져야 합니다. 대시보드가 올바르게 채워지지 않는 상황에 처해 있을 때, 소규모 수정(필터 조건 변경 등)을 하고 대시보드를 새로고침하여 최선을 바라는 습관에 빠지기 쉬울 수 있습니다. 이것은 마치 주사위를 던지는 것과 다를바 없으며, 여러 계층의 문제를 효과적으로 해결하는 방법이 아닙니다.\u003c/p\u003e\n\u003cp\u003e문제 명세서를 해체하고 다시 구성해보세요. 다음과 같은 질문을 스스로에게 던져보세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e어떤 비즈니스 질문에 답하려고 하는가요?\u003c/li\u003e\n\u003cli\u003e이에 대한 답변을 위해 어떤 데이터가 사용 가능한가요? 각 관련 데이터 테이블이 무엇을 나타내는지 알아야 합니다. 최소 가치 제품을 제공하기 위해 필요한 데이터와 사용 가능한 데이터에 대한 명확한 가이드라인을 가져야 합니다.\u003c/li\u003e\n\u003cli\u003e소스 데이터 위에 BI 레이어를 구축하기 위해 필요한 변확 필요한 변환은 무엇인가요?\u003c/li\u003e\n\u003cli\u003e사용 중인 데이터 소스 또는 데이터 파이프라인의 미묘한 점은 무엇인가요?\u003c/li\u003e\n\u003cli\u003e데이터 품질 — 널 값이 어디에 존재하나요? 데이터의 지연에 대한 우려사항은 없나요?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 질문에 대답할 수 없다면, 도움을 요청하거나 데이터에 대한 팀원 또는 전문가와 소통하는 것도 괜찮습니다. 데이터에 대한 친숙함은 가치 있는 해결책을 제공하는 데 중요하므로 필요하다면 비즈니스 컨텍스트를 더 잘 이해하기 위해 필요한 시간을 투자하는 것이 중요합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e시니어리티 레벨에 관계없이, 발전하는 과정에서 어려움을 겪게 될 것입니다. 때때로 이미 알고 있는 지식을 잊고 문제에 새로운 시각으로 접근해야 합니다. 예상치 못한 결과나 어려움에 부딪힐 때는 체계적인 방법을 채택하고 차분한 마음가짐을 유지하는 것이 중요합니다.\u003c/p\u003e\n\u003cp\u003e어떤 데이터 프로젝트에서도 어려움에 부딪히는 것은 실패의 징후가 아니라 성장의 기회입니다. 이러한 전략을 적용하고 프로젝트에 대해 종합적인 시각을 유지함으로써 문제 해결 능력을 향상시키고 더욱 신뢰할 수 있고 효율적인 결과를 이룰 수 있습니다. 그러니 다음 번 데이터 프로젝트에서 어려움을 겪을 때는 이 기술들을 포용하고 시각을 재설정하며, 각 어려움이 더 강력한 데이터 전문가로 발전하는 한 걸음 다가가는 과정임을 기억해주세요.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-YouveHitaWallinYourDataProjectNowWhat"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>