<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>암호화폐 백테스팅 간단한 딥 러닝 전략의 놀라운 결과 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="암호화폐 백테스팅 간단한 딥 러닝 전략의 놀라운 결과 | itposting" data-gatsby-head="true"/><meta property="og:title" content="암호화폐 백테스팅 간단한 딥 러닝 전략의 놀라운 결과 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy" data-gatsby-head="true"/><meta name="twitter:title" content="암호화폐 백테스팅 간단한 딥 러닝 전략의 놀라운 결과 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 18:11" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">암호화폐 백테스팅 간단한 딥 러닝 전략의 놀라운 결과</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="암호화폐 백테스팅 간단한 딥 러닝 전략의 놀라운 결과" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>암호화폐 시장의 급격한 변동 속에서 백테스팅은 투자 전략을 검증하는 데 중요한 역할을 합니다. 본 연구는 비트코인, 이더리움, 바이낸스 코인, 솔라나 및 엑스알피와 같은 주요 암호화폐를 간단한 딥 러닝 모델을 활용해 평가하는 데 초점을 맞췄습니다. 놀랍게도, 이 방법은 다음과 같이 매우 뛰어난 성과 지표를 제시합니다:</p>
<ul>
<li>샤프 비율: 19.898, 비법적인 위험 조정 수익을 나타냅니다.</li>
<li>소티노 비율: 114.442, 무시할 만한 하락 위험을 나타냅니다.</li>
<li>베타: -0.131, 역시장 상관 관계를 보여줍니다.</li>
<li>알파: 0.021, 주목할 만한 추세를 강조합니다.</li>
</ul>
<p>이 간단하고 효과적인 딥 러닝 모델에 의해 높은 성과를 이룬 이러한 결과는 전략적인 투자에 대한 깊은 통찰을 제공합니다.</p>
<p>따라서, 우리는 바이낸스의 다섯 가지 암호화폐 쌍에 대해 (새 전략으로 불리는) 간단한 전략을 사용하여 백테스팅을 진행했습니다. 결과는 다음과 같습니다:</p>
<div class="content-ad"></div>
<p>BTCUSDT</p>
<p><img src="/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_0.png" alt="image1"></p>
<p><img src="/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_1.png" alt="image2"></p>
<p>ETHUSDT</p>
<div class="content-ad"></div>
<p>BNBUSDT</p>
<p>SOLUSDT</p>
<p>XRPUSDT</p>
<h1>ETH/USDT 백테스팅 성능 지표 분석</h1>
<div class="content-ad"></div>
<p>간단한 딥 러닝 전략을 사용하여 ETH/USDT의 백 테스팅 결과는 다음과 같은 성능 지표를 보여줍니다:</p>
<ul>
<li>평균 절대 오차 (MAE): 19.994, 예측 오차의 평균 크기를 나타냅니다.</li>
<li>제곱근 평균 제곱 오차 (RMSE): 25.152, 예측 값과 실제 값 사이의 평균 제곱 차이의 제곱근을 나타냅니다.</li>
<li>R-제곱 (R²): 0.997, 예측 값과 실제 가격 사이에 매우 높은 상관 관계를 보여줍니다. 이는 모델이 변동성 거의 모두를 설명한다는 것을 의미합니다.</li>
<li>평균 절대 백분율 오차 (MAPE): 0.0007, 예측 값과 실제 값 사이의 평균 퍼센트 오차를 나타냅니다.</li>
<li>샤프 비율 (신 전략): 15.967, 새 전략의 우수한 리스크 조정 수익을 보여줍니다.</li>
<li>소티노 비율 (신 전략): 116.496, 최소한의 하향 리스크를 강조합니다.</li>
<li>베타 (신 전략): 0.048, 시장과의 낮은 양의 상관 관계를 보여줍니다.</li>
<li>알파 (신 전략): 0.022, 전략이 시장 기준에 비해 우수한 성과를 보여주는 것을 나타냅니다.</li>
<li>교차 검증 MAE: 661.709 ± 499.095, 모델의 예측 오차를 데이터의 다양한 하위 집합에 걸쳐 추정합니다.</li>
</ul>
<p>이러한 지표들은 이 백 테스트에서 적용된 딥 러닝 전략의 높은 성능과 견고성을 강조합니다.</p>
<p>이것은 단지 예시일 뿐이며, 충분한 데이터가 있다면 바이낸스나 다른 거래소의 모든 심볼에서도 좋은 결과를 얻을 수 있을 것이라고 생각합니다.</p>
<div class="content-ad"></div>
<p>리플레이 결과</p>
<p>이 결과를 다시 확인하거나 새로 시도하려면 다음 코드를 사용할 수 있습니다:</p>
<ul>
<li>모델 만들기</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> ccxt
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta
<span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">preprocessing</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">MinMaxScaler</span>
<span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf
<span class="hljs-keyword">from</span> tensorflow.<span class="hljs-property">keras</span>.<span class="hljs-property">models</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Sequential</span>
<span class="hljs-keyword">from</span> tensorflow.<span class="hljs-property">keras</span>.<span class="hljs-property">layers</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Dense</span>, <span class="hljs-variable constant_">LSTM</span>, <span class="hljs-title class_">Conv1D</span>, <span class="hljs-title class_">MaxPooling1D</span>, <span class="hljs-title class_">Dropout</span>, <span class="hljs-title class_">Flatten</span>
<span class="hljs-keyword">import</span> tf2onnx
<span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">from</span> tensorflow.<span class="hljs-property">keras</span> <span class="hljs-keyword">import</span> callbacks
<span class="hljs-keyword">from</span> tensorflow.<span class="hljs-property">keras</span>.<span class="hljs-property">callbacks</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">ModelCheckpoint</span>

# 바이낸스에서 데이터 다운로드하는 함수
def <span class="hljs-title function_">descargar_datos</span>(symbol, timeframe=<span class="hljs-string">'1d'</span>, start_date=<span class="hljs-string">'2004-01-01T00:00:00Z'</span>, end_date=<span class="hljs-string">'2024-01-01T00:00:00Z'</span>):
    exchange = ccxt.<span class="hljs-title function_">binance</span>({<span class="hljs-string">'enableRateLimit'</span>: <span class="hljs-title class_">False</span>})
    since = exchange.<span class="hljs-title function_">parse8601</span>(start_date)
    end_date_timestamp = pd.<span class="hljs-title function_">to_datetime</span>(end_date, utc=<span class="hljs-title class_">True</span>)
    all_data = []

    <span class="hljs-keyword">while</span> since &#x3C; end_date_timestamp.<span class="hljs-title function_">timestamp</span>() * <span class="hljs-number">1000</span>:
        ohlc = exchange.<span class="hljs-title function_">fetch_ohlcv</span>(symbol, timeframe=timeframe, since=since)
        all_data.<span class="hljs-title function_">extend</span>(ohlc)
        since = ohlc[-<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>  # <span class="hljs-string">'since'</span> 매개변수 <span class="hljs-number">1</span>밀리초 증가

    df = pd.<span class="hljs-title class_">DataFrame</span>(all_data, columns=[<span class="hljs-string">'timestamp'</span>, <span class="hljs-string">'open'</span>, <span class="hljs-string">'high'</span>, <span class="hljs-string">'low'</span>, <span class="hljs-string">'close'</span>, <span class="hljs-string">'volume'</span>])
    df[<span class="hljs-string">'timestamp'</span>] = pd.<span class="hljs-title function_">to_datetime</span>(df[<span class="hljs-string">'timestamp'</span>], unit=<span class="hljs-string">'ms'</span>)
    df.<span class="hljs-title function_">set_index</span>(<span class="hljs-string">'timestamp'</span>, inplace=<span class="hljs-title class_">True</span>)

    # 두 데이터 모두 타임존이 설정되어 있는지 확인하거나 필요한 경우 변환
    <span class="hljs-keyword">if</span> df.<span class="hljs-property">index</span>.<span class="hljs-property">tz</span> is <span class="hljs-title class_">None</span>:
        df.<span class="hljs-property">index</span> = df.<span class="hljs-property">index</span>.<span class="hljs-title function_">tz_localize</span>(<span class="hljs-string">'utc'</span>)
    
    df = df[df.<span class="hljs-property">index</span> &#x3C;= end_date_timestamp]
    <span class="hljs-title function_">print</span>(df)
    <span class="hljs-keyword">return</span> df[<span class="hljs-string">'close'</span>].<span class="hljs-property">values</span>

# 데이터 불러오기
data = <span class="hljs-title function_">descargar_datos</span>(<span class="hljs-string">'ETH/USDT'</span>)

# 데이터 정규화
scaler = <span class="hljs-title class_">MinMaxScaler</span>(feature_range=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))
data = scaler.<span class="hljs-title function_">fit_transform</span>(data.<span class="hljs-title function_">reshape</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))

# 시퀀스에서 샘플 생성하는 함수
def <span class="hljs-title function_">crear_muestras</span>(dataset, pasos_de_tiempo=<span class="hljs-number">120</span>):
    X, y = [], []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(pasos_de_tiempo, <span class="hljs-title function_">len</span>(dataset)):
        X.<span class="hljs-title function_">append</span>(dataset[i-<span class="hljs-attr">pasos_de_tiempo</span>:i, <span class="hljs-number">0</span>])
        y.<span class="hljs-title function_">append</span>(dataset[i, <span class="hljs-number">0</span>])
    <span class="hljs-keyword">return</span> np.<span class="hljs-title function_">array</span>(X), np.<span class="hljs-title function_">array</span>(y)

# 훈련 및 테스트 데이터 준비
pasos_de_tiempo = <span class="hljs-number">120</span>
X, y = <span class="hljs-title function_">crear_muestras</span>(data, pasos_de_tiempo)
X = X.<span class="hljs-title function_">reshape</span>(X.<span class="hljs-property">shape</span>[<span class="hljs-number">0</span>], X.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)  # <span class="hljs-variable constant_">LSTM</span>용 변경

# 데이터 분할 (훈련에 <span class="hljs-number">80</span>% 할당)
split = <span class="hljs-title function_">int</span>(<span class="hljs-number">0.8</span> * <span class="hljs-title function_">len</span>(X))
X_train, X_test = X[:split], X[<span class="hljs-attr">split</span>:]
y_train, y_test = y[:split], y[<span class="hljs-attr">split</span>:]

# 모델 훈련

model = <span class="hljs-title class_">Sequential</span>()
model.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Conv1D</span>(filters=<span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">2</span>, activation=<span class="hljs-string">'relu'</span>,padding = <span class="hljs-string">'same'</span>,input_shape=(X_train.<span class="hljs-property">shape</span>[<span class="hljs-number">1</span>],<span class="hljs-number">1</span>)))
model.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">MaxPooling1D</span>(pool_size=<span class="hljs-number">2</span>))
model.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">LSTM</span>(<span class="hljs-number">100</span>, return_sequences = <span class="hljs-title class_">True</span>))
model.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Dropout</span>(<span class="hljs-number">0.3</span>))
model.<span class="hljs-title function_">add</span>(<span class="hljs-title function_">LSTM</span>(<span class="hljs-number">100</span>, return_sequences = <span class="hljs-title class_">False</span>))
model.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Dropout</span>(<span class="hljs-number">0.3</span>))
model.<span class="hljs-title function_">add</span>(<span class="hljs-title class_">Dense</span>(units=<span class="hljs-number">1</span>, activation = <span class="hljs-string">'sigmoid'</span>))
model.<span class="hljs-title function_">compile</span>(optimizer=<span class="hljs-string">'adam'</span>, loss= <span class="hljs-string">'mse'</span> , metrics = [tf.<span class="hljs-property">keras</span>.<span class="hljs-property">metrics</span>.<span class="hljs-title class_">RootMeanSquaredError</span>(name=<span class="hljs-string">'rmse'</span>)])

# 조기 종료 설정
early_stopping = callbacks.<span class="hljs-title class_">EarlyStopping</span>(
    monitor=<span class="hljs-string">'val_loss'</span>,
    patience=<span class="hljs-number">10</span>,
    restore_best_weights=<span class="hljs-title class_">True</span>,
)
# 최적의 모델 저장할 체크포인트 설정
checkpoint = <span class="hljs-title class_">ModelCheckpoint</span>(
    <span class="hljs-string">'best_model.h5'</span>, 
    monitor=<span class="hljs-string">'val_loss'</span>, 
    save_best_only=<span class="hljs-title class_">True</span>, 
    save_weights_only=<span class="hljs-title class_">False</span>
)

# <span class="hljs-number">300</span> 에폭 학습
history = model.<span class="hljs-title function_">fit</span>(X_train, y_train, epochs = <span class="hljs-number">300</span> , validation_data = (X_test,y_test), batch_size=<span class="hljs-number">32</span>, callbacks=[early_stopping, checkpoint], verbose=<span class="hljs-number">2</span>)

# 훈련 이력 그래프
plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>))
plt.<span class="hljs-title function_">plot</span>(history.<span class="hljs-property">history</span>[<span class="hljs-string">'loss'</span>], label=<span class="hljs-string">'Train Loss'</span>)
plt.<span class="hljs-title function_">plot</span>(history.<span class="hljs-property">history</span>[<span class="hljs-string">'val_loss'</span>], label=<span class="hljs-string">'Validation Loss'</span>)
plt.<span class="hljs-title function_">plot</span>(history.<span class="hljs-property">history</span>[<span class="hljs-string">'rmse'</span>], label=<span class="hljs-string">'Train RMSE'</span>)
plt.<span class="hljs-title function_">plot</span>(history.<span class="hljs-property">history</span>[<span class="hljs-string">'val_rmse'</span>], label=<span class="hljs-string">'Validation RMSE'</span>)
plt.<span class="hljs-title function_">title</span>(<span class="hljs-string">'Model Training History'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'Epochs'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'Loss/RMSE'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">savefig</span>(<span class="hljs-string">'ETHUSDT.png'</span>)  # 그래프 이미지 파일로 저장

# 모델을 <span class="hljs-variable constant_">ONNX</span>로 변환
onnx_model, _ = tf2onnx.<span class="hljs-property">convert</span>.<span class="hljs-title function_">from_keras</span>(model, opset=<span class="hljs-number">13</span>, output_path=<span class="hljs-string">"model_ethusdt.onnx"</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">"ONNX 모델을 'model_ethusdt.onnx'로 저장했습니다."</span>)

# 모델 평가
train_loss, train_rmse = model.evaluate(X_train, y_train, verbose=<span class="hljs-number">0</span>)
test_loss, test_rmse = model.evaluate(X_test, y_test, verbose=<span class="hljs-number">0</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"train_loss={train_loss:.3f}, train_rmse={train_rmse:.3f}"</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"test_loss={test_loss:.3f}, test_rmse={test_rmse:.3f}"</span>)
</code></pre>
<div class="content-ad"></div>
<ul>
<li>백테스팅</li>
</ul>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> ccxt
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> onnx
<span class="hljs-keyword">import</span> onnxruntime <span class="hljs-keyword">as</span> ort
<span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt
<span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">metrics</span> <span class="hljs-keyword">import</span> mean_absolute_error, mean_squared_error, r2_score, mean_absolute_percentage_error
<span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">model_selection</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">TimeSeriesSplit</span>

# 바이낸스 거래소 인스턴스 생성
binance = ccxt.<span class="hljs-title function_">binance</span>()

# 시장 심볼 및 시간 간격 정의
symbol = <span class="hljs-string">'ETH/USDT'</span>
timeframe = <span class="hljs-string">'1d'</span>
limit = <span class="hljs-number">1000</span>  # <span class="hljs-number">120</span>일 신뢰 구간 보장을 위한 충분한 데이터 다운로드

# 역사적 데이터 다운로드
ohlcv = binance.<span class="hljs-title function_">fetch_ohlcv</span>(symbol, timeframe, limit=limit)

# 데이터를 판다스 <span class="hljs-title class_">DataFrame</span>으로 변환
df = pd.<span class="hljs-title class_">DataFrame</span>(ohlcv, columns=[<span class="hljs-string">'timestamp'</span>, <span class="hljs-string">'open'</span>, <span class="hljs-string">'high'</span>, <span class="hljs-string">'low'</span>, <span class="hljs-string">'close'</span>, <span class="hljs-string">'volume'</span>])
df[<span class="hljs-string">'timestamp'</span>] = pd.<span class="hljs-title function_">to_datetime</span>(df[<span class="hljs-string">'timestamp'</span>], unit=<span class="hljs-string">'ms'</span>)

# 데이터를 <span class="hljs-variable constant_">CSV</span> 파일로 저장
df.<span class="hljs-title function_">to_csv</span>(<span class="hljs-string">'binance_data.csv'</span>, index=<span class="hljs-title class_">False</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">"'binance_data.csv'에 다운로드 및 저장된 데이터"</span>)

# 다운로드한 데이터 로드
data = pd.<span class="hljs-title function_">read_csv</span>(<span class="hljs-string">'binance_data.csv'</span>)

# <span class="hljs-string">'timestamp'</span> 열을 datetime 형식으로 변환
data[<span class="hljs-string">'timestamp'</span>] = pd.<span class="hljs-title function_">to_datetime</span>(data[<span class="hljs-string">'timestamp'</span>])

# 정규화 값(정규화에 사용한 값에 맞게 조정)
min_close = data[<span class="hljs-string">'close'</span>].<span class="hljs-title function_">min</span>()
max_close = data[<span class="hljs-string">'close'</span>].<span class="hljs-title function_">max</span>()

# 종가 데이터 정규화
data[<span class="hljs-string">'close_normalized'</span>] = (data[<span class="hljs-string">'close'</span>] - min_close) / (max_close - min_close)

# <span class="hljs-variable constant_">ONNX</span> 모델 로드
model = onnx.<span class="hljs-title function_">load</span>(<span class="hljs-string">'model_ethusdt.onnx'</span>)
onnx.<span class="hljs-property">checker</span>.<span class="hljs-title function_">check_model</span>(model)

# 런타임 세션 생성
ort_session = ort.<span class="hljs-title class_">InferenceSession</span>(<span class="hljs-string">'model_ethusdt.onnx'</span>)

# 모델에 주입할 데이터를 슬라이딩 윈도우로 준비
input_name = ort_session.<span class="hljs-title function_">get_inputs</span>()[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>
sequence_length = <span class="hljs-number">120</span>  # 모델에 따라 조정

# 예측값을 저장할 리스트 생성
predictions_list = []

# 예측 시작 날짜 설정
start_date = pd.<span class="hljs-title class_">Timestamp</span>(<span class="hljs-string">'2024-01-01'</span>)
end_date = pd.<span class="hljs-property">Timestamp</span>.<span class="hljs-title function_">today</span>()

# 날짜별 추론 실행
current_date = start_date
<span class="hljs-keyword">while</span> current_date &#x3C;= <span class="hljs-attr">end_date</span>:
    # 현재 날짜 이전 <span class="hljs-number">120</span>일 데이터 선택
    end_idx = data[data[<span class="hljs-string">'timestamp'</span>] &#x3C;= current_date].<span class="hljs-property">index</span>[-<span class="hljs-number">1</span>]
    start_idx = end_idx - sequence_length + <span class="hljs-number">1</span>

    <span class="hljs-keyword">if</span> start_idx &#x3C; <span class="hljs-number">0</span>:
        <span class="hljs-title function_">print</span>(f<span class="hljs-string">"{current_date} 날짜에 대한 데이터 부족"</span>)
        <span class="hljs-keyword">break</span>

    # 정규화된 데이터 윈도우 추출
    <span class="hljs-variable language_">window</span> = data[<span class="hljs-string">'close_normalized'</span>].<span class="hljs-property">values</span>[<span class="hljs-attr">start_idx</span>:end_idx+<span class="hljs-number">1</span>]

    <span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span>(<span class="hljs-variable language_">window</span>) &#x3C; <span class="hljs-attr">sequence_length</span>:
        <span class="hljs-title function_">print</span>(f<span class="hljs-string">"{current_date} 날짜에 대한 데이터 부족"</span>)
        <span class="hljs-keyword">break</span>

    # 모델에 입력할 데이터 준비
    input_window = np.<span class="hljs-title function_">array</span>(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">astype</span>(np.<span class="hljs-property">float32</span>)
    input_window = np.<span class="hljs-title function_">expand_dims</span>(input_window, axis=<span class="hljs-number">0</span>)  # 배치 크기 차원 추가
    input_window = np.<span class="hljs-title function_">expand_dims</span>(input_window, axis=<span class="hljs-number">2</span>)  # 특성 차원 추가

    # 추론 실행
    output = ort_session.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">None</span>, {<span class="hljs-attr">input_name</span>: input_window})
    prediction = output[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]

    # 예측값 역정규화
    prediction = prediction * (max_close - min_close) + min_close

    # 예측값 저장
    predictions_list.<span class="hljs-title function_">append</span>({<span class="hljs-string">'date'</span>: current_date, <span class="hljs-string">'prediction'</span>: prediction})

    # 날짜 증가
    current_date += pd.<span class="hljs-title class_">Timedelta</span>(days=<span class="hljs-number">1</span>)

# 예측값 리스트를 <span class="hljs-title class_">DataFrame</span>으로 변환
predictions_df = pd.<span class="hljs-title class_">DataFrame</span>(predictions_list)

# 예측값을 <span class="hljs-variable constant_">CSV</span> 파일로 저장
predictions_df.<span class="hljs-title function_">to_csv</span>(<span class="hljs-string">'predicted_data.csv'</span>, index=<span class="hljs-title class_">False</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">"'predicted_data.csv'에 저장된 예측값"</span>)

# 예측값과 실제 값 비교
comparison_df = pd.<span class="hljs-title function_">merge</span>(predictions_df, data[[<span class="hljs-string">'timestamp'</span>, <span class="hljs-string">'close'</span>]], left_on=<span class="hljs-string">'date'</span>, right_on=<span class="hljs-string">'timestamp'</span>)
comparison_df = comparison_df.<span class="hljs-title function_">drop</span>(columns=[<span class="hljs-string">'timestamp'</span>])
comparison_df = comparison_df.<span class="hljs-title function_">rename</span>(columns={<span class="hljs-string">'close'</span>: <span class="hljs-string">'actual'</span>})

# 오차 메트릭 계산
mae = <span class="hljs-title function_">mean_absolute_error</span>(comparison_df[<span class="hljs-string">'actual'</span>], comparison_df[<span class="hljs-string">'prediction'</span>])
rmse = np.<span class="hljs-title function_">sqrt</span>(<span class="hljs-title function_">mean_squared_error</span>(comparison_df[<span class="hljs-string">'actual'</span>], comparison_df[<span class="hljs-string">'prediction'</span>]))
r2 = <span class="hljs-title function_">r2_score</span>(comparison_df[<span class="hljs-string">'actual'</span>], comparison_df[<span class="hljs-string">'prediction'</span>])
mape = <span class="hljs-title function_">mean_absolute_percentage_error</span>(comparison_df[<span class="hljs-string">'actual'</span>], comparison_df[<span class="hljs-string">'prediction'</span>])
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'평균 절대 오차(MAE): {mae}'</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'제곱근 평균 제곱 오차(RMSE): {rmse}'</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'R^2 점수 (R2): {r2}'</span>)
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'평균 절대 백분율 오차(MAPE): {mape}'</span>)

# 오차 밴드가 있는 그래프 그리기
plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">7</span>))
plt.<span class="hljs-title function_">plot</span>(comparison_df[<span class="hljs-string">'date'</span>], comparison_df[<span class="hljs-string">'actual'</span>], label=<span class="hljs-string">'실제 가격'</span>, color=<span class="hljs-string">'blue'</span>)
plt.<span class="hljs-title function_">plot</span>(comparison_df[<span class="hljs-string">'date'</span>], comparison_df[<span class="hljs-string">'prediction'</span>], label=<span class="hljs-string">'예측 가격'</span>, color=<span class="hljs-string">'red'</span>)
plt.<span class="hljs-title function_">fill_between</span>(comparison_df[<span class="hljs-string">'date'</span>], comparison_df[<span class="hljs-string">'prediction'</span>] - mae, comparison_df[<span class="hljs-string">'prediction'</span>] + mae, color=<span class="hljs-string">'gray'</span>, alpha=<span class="hljs-number">0.2</span>, label=<span class="hljs-string">'오차 밴드 (MAE)'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'날짜'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'가격'</span>)
plt.<span class="hljs-title function_">title</span>(f<span class="hljs-string">'{symbol} 가격 예측 대 비교'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">savefig</span>(f<span class="hljs-string">"{symbol.replace('/', '_')}_price_prediction.png"</span>)
plt.<span class="hljs-title function_">show</span>()
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"'{symbol.replace('/', '_')}_price_prediction.png'로 그래프 저장됨"</span>)

# 잔차 분석
residuals = comparison_df[<span class="hljs-string">'actual'</span>] - comparison_df[<span class="hljs-string">'prediction'</span>]
plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">7</span>))
plt.<span class="hljs-title function_">plot</span>(comparison_df[<span class="hljs-string">'date'</span>], residuals, label=<span class="hljs-string">'잔차'</span>, color=<span class="hljs-string">'purple'</span>)
plt.<span class="hljs-title function_">axhline</span>(<span class="hljs-number">0</span>, color=<span class="hljs-string">'black'</span>, linestyle=<span class="hljs-string">'--'</span>, linewidth=<span class="hljs-number">0.8</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'날짜'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'잔차'</span>)
plt.<span class="hljs-title function_">title</span>(f<span class="hljs-string">'{symbol} 예측 잔차'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">savefig</span>(f<span class="hljs-string">"{symbol.replace('/', '_')}_residuals.png"</span>)
plt.<span class="hljs-title function_">show</span>()
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"'{symbol.replace('/', '_')}_residuals.png'로 잔차 그래프 저장됨"</span>)

# 상관관계 분석
correlation = comparison_df[<span class="hljs-string">'actual'</span>].<span class="hljs-title function_">corr</span>(comparison_df[<span class="hljs-string">'prediction'</span>])
<span class="hljs-title function_">print</span>(f<span class="hljs-string">'실제 및 예측 가격 간 상관관계: {correlation}'</span>)

# 예측 기반 투자 전략 시뮬레이션 (원본 전략)
investment_df = comparison_df.<span class="hljs-title function_">copy</span>()
investment_df[<span class="hljs-string">'strategy_returns'</span>] = (investment_df[<span class="hljs-string">'prediction'</span>].<span class="hljs-title function_">shift</span>(-<span class="hljs-number">1</span>) - investment_df[<span class="hljs-string">'actual'</span>]) / investment_df[<span class="hljs-string">'actual'</span>]
investment_df[<span class="hljs-string">'buy_and_hold_returns'</span>] = (investment_df[<span class="hljs-string">'actual'</span>].<span class="hljs-title function_">shift</span>(-<span class="hljs-number">1</span>) - investment_df[<span class="hljs-string">'actual'</span>]) / investment_df[<span class="hljs-string">'actual'</span>]

strategy_cumulative_returns = (investment_df[<span class="hljs-string">'strategy_returns'</span>] + <span class="hljs-number">1</span>).<span class="hljs-title function_">cumprod</span>() - <span class="hljs-number">1</span>
buy_and_hold_cumulative_returns = (investment_df[<span class="hljs-string">'buy_and_hold_returns'</span>] + <span class="hljs-number">1</span>).<span class="hljs-title function_">cumprod</span>() - <span class="hljs-number">1</span>

plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">7</span>))
plt.<span class="hljs-title function_">plot</span>(investment_df[<span class="hljs-string">'date'</span>], strategy_cumulative_returns, label=<span class="hljs-string">'전략 누적 수익'</span>, color=<span class="hljs-string">'green'</span>)
plt.<span class="hljs-title function_">plot</span>(investment_df[<span class="hljs-string">'date'</span>], buy_and_hold_cumulative_returns, label=<span class="hljs-string">'매수 및 보유 누적 수익'</span>, color=<span class="hljs-string">'orange'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'날짜'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'누적 수익률'</span>)
plt.<span class="hljs-title function_">title</span>(f<span class="hljs-string">'{symbol} 투자 전략 대 매수 및 보유'</span>)
plt.<span class="hljs-title function_">legend</span>()
plt.<span class="hljs-title function_">savefig</span>(f<span class="hljs-string">"{symbol.replace('/', '_')}_investment_strategy.png"</span>)
plt.<span class="hljs-title function_">show</span>()
<span class="hljs-title function_">print</span>(f<span class="hljs-string">"'{symbol.replace('/', '_')}_investment_strategy.png'로 투자 전략 그래프 저장됨"</span>)

# 손실 전망
investment_df[<span class="hljs-string">'drawdown'</span>] = strategy_cumulative_returns.<span class="hljs-title function_">cummax</span>() - strategy_cumulative_returns
investment_df[<span class="hljs-string">'max_drawdown'</span>] = investment_df[<span class="hljs-string">'drawdown'</span>].<span class="hljs-title function_">max</span>()

plt.<span class="hljs-title function_">figure</span>(figsize=(<span class="hljs-number">14</span>, <span class="hljs-number">7</span>))
plt.<span class="hljs-title function_">plot</span>(investment_df[<span class="hljs-string">'date'</span>], investment_df[<span class="hljs-string">'drawdown'</span>], label=<span class="hljs-string">'Drawdown'</span>, color=<span class="hljs-string">'red'</span>)
plt.<span class="hljs-title function_">xlabel</span>(<span class="hljs-string">'날짜'</span>)
plt.<span class="hljs-title function_">ylabel</span>(<span class="hljs-string">'Drawdown'</span>)
plt.<span class="hljs-title function_">title</span>(f<span class="hljs-string">'{symbol} 전략 Drawdown'</span>)
plt
</code></pre>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"암호화폐 백테스팅 간단한 딥 러닝 전략의 놀라운 결과","description":"","date":"2024-06-20 18:11","slug":"2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy","content":"\n\n암호화폐 시장의 급격한 변동 속에서 백테스팅은 투자 전략을 검증하는 데 중요한 역할을 합니다. 본 연구는 비트코인, 이더리움, 바이낸스 코인, 솔라나 및 엑스알피와 같은 주요 암호화폐를 간단한 딥 러닝 모델을 활용해 평가하는 데 초점을 맞췄습니다. 놀랍게도, 이 방법은 다음과 같이 매우 뛰어난 성과 지표를 제시합니다:\n\n- 샤프 비율: 19.898, 비법적인 위험 조정 수익을 나타냅니다.\n- 소티노 비율: 114.442, 무시할 만한 하락 위험을 나타냅니다.\n- 베타: -0.131, 역시장 상관 관계를 보여줍니다.\n- 알파: 0.021, 주목할 만한 추세를 강조합니다.\n\n이 간단하고 효과적인 딥 러닝 모델에 의해 높은 성과를 이룬 이러한 결과는 전략적인 투자에 대한 깊은 통찰을 제공합니다.\n\n따라서, 우리는 바이낸스의 다섯 가지 암호화폐 쌍에 대해 (새 전략으로 불리는) 간단한 전략을 사용하여 백테스팅을 진행했습니다. 결과는 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBTCUSDT\n\n![image1](/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_0.png)\n\n![image2](/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_1.png)\n\nETHUSDT\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nBNBUSDT\n\nSOLUSDT\n\nXRPUSDT\n\n# ETH/USDT 백테스팅 성능 지표 분석\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n간단한 딥 러닝 전략을 사용하여 ETH/USDT의 백 테스팅 결과는 다음과 같은 성능 지표를 보여줍니다:\n\n- 평균 절대 오차 (MAE): 19.994, 예측 오차의 평균 크기를 나타냅니다.\n- 제곱근 평균 제곱 오차 (RMSE): 25.152, 예측 값과 실제 값 사이의 평균 제곱 차이의 제곱근을 나타냅니다.\n- R-제곱 (R²): 0.997, 예측 값과 실제 가격 사이에 매우 높은 상관 관계를 보여줍니다. 이는 모델이 변동성 거의 모두를 설명한다는 것을 의미합니다.\n- 평균 절대 백분율 오차 (MAPE): 0.0007, 예측 값과 실제 값 사이의 평균 퍼센트 오차를 나타냅니다.\n- 샤프 비율 (신 전략): 15.967, 새 전략의 우수한 리스크 조정 수익을 보여줍니다.\n- 소티노 비율 (신 전략): 116.496, 최소한의 하향 리스크를 강조합니다.\n- 베타 (신 전략): 0.048, 시장과의 낮은 양의 상관 관계를 보여줍니다.\n- 알파 (신 전략): 0.022, 전략이 시장 기준에 비해 우수한 성과를 보여주는 것을 나타냅니다.\n- 교차 검증 MAE: 661.709 ± 499.095, 모델의 예측 오차를 데이터의 다양한 하위 집합에 걸쳐 추정합니다.\n\n이러한 지표들은 이 백 테스트에서 적용된 딥 러닝 전략의 높은 성능과 견고성을 강조합니다.\n\n이것은 단지 예시일 뿐이며, 충분한 데이터가 있다면 바이낸스나 다른 거래소의 모든 심볼에서도 좋은 결과를 얻을 수 있을 것이라고 생각합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n리플레이 결과\n\n이 결과를 다시 확인하거나 새로 시도하려면 다음 코드를 사용할 수 있습니다:\n\n- 모델 만들기\n\n```js\nimport ccxt\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom sklearn.preprocessing import MinMaxScaler\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Conv1D, MaxPooling1D, Dropout, Flatten\nimport tf2onnx\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom tensorflow.keras import callbacks\nfrom tensorflow.keras.callbacks import ModelCheckpoint\n\n# 바이낸스에서 데이터 다운로드하는 함수\ndef descargar_datos(symbol, timeframe='1d', start_date='2004-01-01T00:00:00Z', end_date='2024-01-01T00:00:00Z'):\n    exchange = ccxt.binance({'enableRateLimit': False})\n    since = exchange.parse8601(start_date)\n    end_date_timestamp = pd.to_datetime(end_date, utc=True)\n    all_data = []\n\n    while since \u003c end_date_timestamp.timestamp() * 1000:\n        ohlc = exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=since)\n        all_data.extend(ohlc)\n        since = ohlc[-1][0] + 1  # 'since' 매개변수 1밀리초 증가\n\n    df = pd.DataFrame(all_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\n    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')\n    df.set_index('timestamp', inplace=True)\n\n    # 두 데이터 모두 타임존이 설정되어 있는지 확인하거나 필요한 경우 변환\n    if df.index.tz is None:\n        df.index = df.index.tz_localize('utc')\n    \n    df = df[df.index \u003c= end_date_timestamp]\n    print(df)\n    return df['close'].values\n\n# 데이터 불러오기\ndata = descargar_datos('ETH/USDT')\n\n# 데이터 정규화\nscaler = MinMaxScaler(feature_range=(0, 1))\ndata = scaler.fit_transform(data.reshape(-1, 1))\n\n# 시퀀스에서 샘플 생성하는 함수\ndef crear_muestras(dataset, pasos_de_tiempo=120):\n    X, y = [], []\n    for i in range(pasos_de_tiempo, len(dataset)):\n        X.append(dataset[i-pasos_de_tiempo:i, 0])\n        y.append(dataset[i, 0])\n    return np.array(X), np.array(y)\n\n# 훈련 및 테스트 데이터 준비\npasos_de_tiempo = 120\nX, y = crear_muestras(data, pasos_de_tiempo)\nX = X.reshape(X.shape[0], X.shape[1], 1)  # LSTM용 변경\n\n# 데이터 분할 (훈련에 80% 할당)\nsplit = int(0.8 * len(X))\nX_train, X_test = X[:split], X[split:]\ny_train, y_test = y[:split], y[split:]\n\n# 모델 훈련\n\nmodel = Sequential()\nmodel.add(Conv1D(filters=256, kernel_size=2, activation='relu',padding = 'same',input_shape=(X_train.shape[1],1)))\nmodel.add(MaxPooling1D(pool_size=2))\nmodel.add(LSTM(100, return_sequences = True))\nmodel.add(Dropout(0.3))\nmodel.add(LSTM(100, return_sequences = False))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(units=1, activation = 'sigmoid'))\nmodel.compile(optimizer='adam', loss= 'mse' , metrics = [tf.keras.metrics.RootMeanSquaredError(name='rmse')])\n\n# 조기 종료 설정\nearly_stopping = callbacks.EarlyStopping(\n    monitor='val_loss',\n    patience=10,\n    restore_best_weights=True,\n)\n# 최적의 모델 저장할 체크포인트 설정\ncheckpoint = ModelCheckpoint(\n    'best_model.h5', \n    monitor='val_loss', \n    save_best_only=True, \n    save_weights_only=False\n)\n\n# 300 에폭 학습\nhistory = model.fit(X_train, y_train, epochs = 300 , validation_data = (X_test,y_test), batch_size=32, callbacks=[early_stopping, checkpoint], verbose=2)\n\n# 훈련 이력 그래프\nplt.figure(figsize=(10, 5))\nplt.plot(history.history['loss'], label='Train Loss')\nplt.plot(history.history['val_loss'], label='Validation Loss')\nplt.plot(history.history['rmse'], label='Train RMSE')\nplt.plot(history.history['val_rmse'], label='Validation RMSE')\nplt.title('Model Training History')\nplt.xlabel('Epochs')\nplt.ylabel('Loss/RMSE')\nplt.legend()\nplt.savefig('ETHUSDT.png')  # 그래프 이미지 파일로 저장\n\n# 모델을 ONNX로 변환\nonnx_model, _ = tf2onnx.convert.from_keras(model, opset=13, output_path=\"model_ethusdt.onnx\")\nprint(\"ONNX 모델을 'model_ethusdt.onnx'로 저장했습니다.\")\n\n# 모델 평가\ntrain_loss, train_rmse = model.evaluate(X_train, y_train, verbose=0)\ntest_loss, test_rmse = model.evaluate(X_test, y_test, verbose=0)\nprint(f\"train_loss={train_loss:.3f}, train_rmse={train_rmse:.3f}\")\nprint(f\"test_loss={test_loss:.3f}, test_rmse={test_rmse:.3f}\")\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 백테스팅\n\n```js\nimport ccxt\nimport pandas as pd\nimport numpy as np\nimport onnx\nimport onnxruntime as ort\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score, mean_absolute_percentage_error\nfrom sklearn.model_selection import TimeSeriesSplit\n\n# 바이낸스 거래소 인스턴스 생성\nbinance = ccxt.binance()\n\n# 시장 심볼 및 시간 간격 정의\nsymbol = 'ETH/USDT'\ntimeframe = '1d'\nlimit = 1000  # 120일 신뢰 구간 보장을 위한 충분한 데이터 다운로드\n\n# 역사적 데이터 다운로드\nohlcv = binance.fetch_ohlcv(symbol, timeframe, limit=limit)\n\n# 데이터를 판다스 DataFrame으로 변환\ndf = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\ndf['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')\n\n# 데이터를 CSV 파일로 저장\ndf.to_csv('binance_data.csv', index=False)\nprint(\"'binance_data.csv'에 다운로드 및 저장된 데이터\")\n\n# 다운로드한 데이터 로드\ndata = pd.read_csv('binance_data.csv')\n\n# 'timestamp' 열을 datetime 형식으로 변환\ndata['timestamp'] = pd.to_datetime(data['timestamp'])\n\n# 정규화 값(정규화에 사용한 값에 맞게 조정)\nmin_close = data['close'].min()\nmax_close = data['close'].max()\n\n# 종가 데이터 정규화\ndata['close_normalized'] = (data['close'] - min_close) / (max_close - min_close)\n\n# ONNX 모델 로드\nmodel = onnx.load('model_ethusdt.onnx')\nonnx.checker.check_model(model)\n\n# 런타임 세션 생성\nort_session = ort.InferenceSession('model_ethusdt.onnx')\n\n# 모델에 주입할 데이터를 슬라이딩 윈도우로 준비\ninput_name = ort_session.get_inputs()[0].name\nsequence_length = 120  # 모델에 따라 조정\n\n# 예측값을 저장할 리스트 생성\npredictions_list = []\n\n# 예측 시작 날짜 설정\nstart_date = pd.Timestamp('2024-01-01')\nend_date = pd.Timestamp.today()\n\n# 날짜별 추론 실행\ncurrent_date = start_date\nwhile current_date \u003c= end_date:\n    # 현재 날짜 이전 120일 데이터 선택\n    end_idx = data[data['timestamp'] \u003c= current_date].index[-1]\n    start_idx = end_idx - sequence_length + 1\n\n    if start_idx \u003c 0:\n        print(f\"{current_date} 날짜에 대한 데이터 부족\")\n        break\n\n    # 정규화된 데이터 윈도우 추출\n    window = data['close_normalized'].values[start_idx:end_idx+1]\n\n    if len(window) \u003c sequence_length:\n        print(f\"{current_date} 날짜에 대한 데이터 부족\")\n        break\n\n    # 모델에 입력할 데이터 준비\n    input_window = np.array(window).astype(np.float32)\n    input_window = np.expand_dims(input_window, axis=0)  # 배치 크기 차원 추가\n    input_window = np.expand_dims(input_window, axis=2)  # 특성 차원 추가\n\n    # 추론 실행\n    output = ort_session.run(None, {input_name: input_window})\n    prediction = output[0][0][0]\n\n    # 예측값 역정규화\n    prediction = prediction * (max_close - min_close) + min_close\n\n    # 예측값 저장\n    predictions_list.append({'date': current_date, 'prediction': prediction})\n\n    # 날짜 증가\n    current_date += pd.Timedelta(days=1)\n\n# 예측값 리스트를 DataFrame으로 변환\npredictions_df = pd.DataFrame(predictions_list)\n\n# 예측값을 CSV 파일로 저장\npredictions_df.to_csv('predicted_data.csv', index=False)\nprint(\"'predicted_data.csv'에 저장된 예측값\")\n\n# 예측값과 실제 값 비교\ncomparison_df = pd.merge(predictions_df, data[['timestamp', 'close']], left_on='date', right_on='timestamp')\ncomparison_df = comparison_df.drop(columns=['timestamp'])\ncomparison_df = comparison_df.rename(columns={'close': 'actual'})\n\n# 오차 메트릭 계산\nmae = mean_absolute_error(comparison_df['actual'], comparison_df['prediction'])\nrmse = np.sqrt(mean_squared_error(comparison_df['actual'], comparison_df['prediction']))\nr2 = r2_score(comparison_df['actual'], comparison_df['prediction'])\nmape = mean_absolute_percentage_error(comparison_df['actual'], comparison_df['prediction'])\nprint(f'평균 절대 오차(MAE): {mae}')\nprint(f'제곱근 평균 제곱 오차(RMSE): {rmse}')\nprint(f'R^2 점수 (R2): {r2}')\nprint(f'평균 절대 백분율 오차(MAPE): {mape}')\n\n# 오차 밴드가 있는 그래프 그리기\nplt.figure(figsize=(14, 7))\nplt.plot(comparison_df['date'], comparison_df['actual'], label='실제 가격', color='blue')\nplt.plot(comparison_df['date'], comparison_df['prediction'], label='예측 가격', color='red')\nplt.fill_between(comparison_df['date'], comparison_df['prediction'] - mae, comparison_df['prediction'] + mae, color='gray', alpha=0.2, label='오차 밴드 (MAE)')\nplt.xlabel('날짜')\nplt.ylabel('가격')\nplt.title(f'{symbol} 가격 예측 대 비교')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_price_prediction.png\")\nplt.show()\nprint(f\"'{symbol.replace('/', '_')}_price_prediction.png'로 그래프 저장됨\")\n\n# 잔차 분석\nresiduals = comparison_df['actual'] - comparison_df['prediction']\nplt.figure(figsize=(14, 7))\nplt.plot(comparison_df['date'], residuals, label='잔차', color='purple')\nplt.axhline(0, color='black', linestyle='--', linewidth=0.8)\nplt.xlabel('날짜')\nplt.ylabel('잔차')\nplt.title(f'{symbol} 예측 잔차')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_residuals.png\")\nplt.show()\nprint(f\"'{symbol.replace('/', '_')}_residuals.png'로 잔차 그래프 저장됨\")\n\n# 상관관계 분석\ncorrelation = comparison_df['actual'].corr(comparison_df['prediction'])\nprint(f'실제 및 예측 가격 간 상관관계: {correlation}')\n\n# 예측 기반 투자 전략 시뮬레이션 (원본 전략)\ninvestment_df = comparison_df.copy()\ninvestment_df['strategy_returns'] = (investment_df['prediction'].shift(-1) - investment_df['actual']) / investment_df['actual']\ninvestment_df['buy_and_hold_returns'] = (investment_df['actual'].shift(-1) - investment_df['actual']) / investment_df['actual']\n\nstrategy_cumulative_returns = (investment_df['strategy_returns'] + 1).cumprod() - 1\nbuy_and_hold_cumulative_returns = (investment_df['buy_and_hold_returns'] + 1).cumprod() - 1\n\nplt.figure(figsize=(14, 7))\nplt.plot(investment_df['date'], strategy_cumulative_returns, label='전략 누적 수익', color='green')\nplt.plot(investment_df['date'], buy_and_hold_cumulative_returns, label='매수 및 보유 누적 수익', color='orange')\nplt.xlabel('날짜')\nplt.ylabel('누적 수익률')\nplt.title(f'{symbol} 투자 전략 대 매수 및 보유')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_investment_strategy.png\")\nplt.show()\nprint(f\"'{symbol.replace('/', '_')}_investment_strategy.png'로 투자 전략 그래프 저장됨\")\n\n# 손실 전망\ninvestment_df['drawdown'] = strategy_cumulative_returns.cummax() - strategy_cumulative_returns\ninvestment_df['max_drawdown'] = investment_df['drawdown'].max()\n\nplt.figure(figsize=(14, 7))\nplt.plot(investment_df['date'], investment_df['drawdown'], label='Drawdown', color='red')\nplt.xlabel('날짜')\nplt.ylabel('Drawdown')\nplt.title(f'{symbol} 전략 Drawdown')\nplt","ogImage":{"url":"/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_0.png"},"coverImage":"/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e암호화폐 시장의 급격한 변동 속에서 백테스팅은 투자 전략을 검증하는 데 중요한 역할을 합니다. 본 연구는 비트코인, 이더리움, 바이낸스 코인, 솔라나 및 엑스알피와 같은 주요 암호화폐를 간단한 딥 러닝 모델을 활용해 평가하는 데 초점을 맞췄습니다. 놀랍게도, 이 방법은 다음과 같이 매우 뛰어난 성과 지표를 제시합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e샤프 비율: 19.898, 비법적인 위험 조정 수익을 나타냅니다.\u003c/li\u003e\n\u003cli\u003e소티노 비율: 114.442, 무시할 만한 하락 위험을 나타냅니다.\u003c/li\u003e\n\u003cli\u003e베타: -0.131, 역시장 상관 관계를 보여줍니다.\u003c/li\u003e\n\u003cli\u003e알파: 0.021, 주목할 만한 추세를 강조합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이 간단하고 효과적인 딥 러닝 모델에 의해 높은 성과를 이룬 이러한 결과는 전략적인 투자에 대한 깊은 통찰을 제공합니다.\u003c/p\u003e\n\u003cp\u003e따라서, 우리는 바이낸스의 다섯 가지 암호화폐 쌍에 대해 (새 전략으로 불리는) 간단한 전략을 사용하여 백테스팅을 진행했습니다. 결과는 다음과 같습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eBTCUSDT\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_0.png\" alt=\"image1\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_1.png\" alt=\"image2\"\u003e\u003c/p\u003e\n\u003cp\u003eETHUSDT\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eBNBUSDT\u003c/p\u003e\n\u003cp\u003eSOLUSDT\u003c/p\u003e\n\u003cp\u003eXRPUSDT\u003c/p\u003e\n\u003ch1\u003eETH/USDT 백테스팅 성능 지표 분석\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e간단한 딥 러닝 전략을 사용하여 ETH/USDT의 백 테스팅 결과는 다음과 같은 성능 지표를 보여줍니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e평균 절대 오차 (MAE): 19.994, 예측 오차의 평균 크기를 나타냅니다.\u003c/li\u003e\n\u003cli\u003e제곱근 평균 제곱 오차 (RMSE): 25.152, 예측 값과 실제 값 사이의 평균 제곱 차이의 제곱근을 나타냅니다.\u003c/li\u003e\n\u003cli\u003eR-제곱 (R²): 0.997, 예측 값과 실제 가격 사이에 매우 높은 상관 관계를 보여줍니다. 이는 모델이 변동성 거의 모두를 설명한다는 것을 의미합니다.\u003c/li\u003e\n\u003cli\u003e평균 절대 백분율 오차 (MAPE): 0.0007, 예측 값과 실제 값 사이의 평균 퍼센트 오차를 나타냅니다.\u003c/li\u003e\n\u003cli\u003e샤프 비율 (신 전략): 15.967, 새 전략의 우수한 리스크 조정 수익을 보여줍니다.\u003c/li\u003e\n\u003cli\u003e소티노 비율 (신 전략): 116.496, 최소한의 하향 리스크를 강조합니다.\u003c/li\u003e\n\u003cli\u003e베타 (신 전략): 0.048, 시장과의 낮은 양의 상관 관계를 보여줍니다.\u003c/li\u003e\n\u003cli\u003e알파 (신 전략): 0.022, 전략이 시장 기준에 비해 우수한 성과를 보여주는 것을 나타냅니다.\u003c/li\u003e\n\u003cli\u003e교차 검증 MAE: 661.709 ± 499.095, 모델의 예측 오차를 데이터의 다양한 하위 집합에 걸쳐 추정합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 지표들은 이 백 테스트에서 적용된 딥 러닝 전략의 높은 성능과 견고성을 강조합니다.\u003c/p\u003e\n\u003cp\u003e이것은 단지 예시일 뿐이며, 충분한 데이터가 있다면 바이낸스나 다른 거래소의 모든 심볼에서도 좋은 결과를 얻을 수 있을 것이라고 생각합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e리플레이 결과\u003c/p\u003e\n\u003cp\u003e이 결과를 다시 확인하거나 새로 시도하려면 다음 코드를 사용할 수 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e모델 만들기\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ccxt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e datetime \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e datetime, timedelta\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.\u003cspan class=\"hljs-property\"\u003epreprocessing\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMinMaxScaler\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e tensorflow \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e tf\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e tensorflow.\u003cspan class=\"hljs-property\"\u003ekeras\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emodels\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSequential\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e tensorflow.\u003cspan class=\"hljs-property\"\u003ekeras\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elayers\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDense\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eLSTM\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eConv1D\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eMaxPooling1D\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eDropout\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eFlatten\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e tf2onnx\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e tensorflow.\u003cspan class=\"hljs-property\"\u003ekeras\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e callbacks\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e tensorflow.\u003cspan class=\"hljs-property\"\u003ekeras\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecallbacks\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eModelCheckpoint\u003c/span\u003e\n\n# 바이낸스에서 데이터 다운로드하는 함수\ndef \u003cspan class=\"hljs-title function_\"\u003edescargar_datos\u003c/span\u003e(symbol, timeframe=\u003cspan class=\"hljs-string\"\u003e'1d'\u003c/span\u003e, start_date=\u003cspan class=\"hljs-string\"\u003e'2004-01-01T00:00:00Z'\u003c/span\u003e, end_date=\u003cspan class=\"hljs-string\"\u003e'2024-01-01T00:00:00Z'\u003c/span\u003e):\n    exchange = ccxt.\u003cspan class=\"hljs-title function_\"\u003ebinance\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e'enableRateLimit'\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e})\n    since = exchange.\u003cspan class=\"hljs-title function_\"\u003eparse8601\u003c/span\u003e(start_date)\n    end_date_timestamp = pd.\u003cspan class=\"hljs-title function_\"\u003eto_datetime\u003c/span\u003e(end_date, utc=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n    all_data = []\n\n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e since \u0026#x3C; end_date_timestamp.\u003cspan class=\"hljs-title function_\"\u003etimestamp\u003c/span\u003e() * \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e:\n        ohlc = exchange.\u003cspan class=\"hljs-title function_\"\u003efetch_ohlcv\u003c/span\u003e(symbol, timeframe=timeframe, since=since)\n        all_data.\u003cspan class=\"hljs-title function_\"\u003eextend\u003c/span\u003e(ohlc)\n        since = ohlc[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e  # \u003cspan class=\"hljs-string\"\u003e'since'\u003c/span\u003e 매개변수 \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e밀리초 증가\n\n    df = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(all_data, columns=[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'open'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'high'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'low'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'volume'\u003c/span\u003e])\n    df[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e] = pd.\u003cspan class=\"hljs-title function_\"\u003eto_datetime\u003c/span\u003e(df[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e], unit=\u003cspan class=\"hljs-string\"\u003e'ms'\u003c/span\u003e)\n    df.\u003cspan class=\"hljs-title function_\"\u003eset_index\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e, inplace=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e)\n\n    # 두 데이터 모두 타임존이 설정되어 있는지 확인하거나 필요한 경우 변환\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e df.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etz\u003c/span\u003e is \u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e:\n        df.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e = df.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etz_localize\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'utc'\u003c/span\u003e)\n    \n    df = df[df.\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e \u0026#x3C;= end_date_timestamp]\n    \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(df)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e df[\u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003evalues\u003c/span\u003e\n\n# 데이터 불러오기\ndata = \u003cspan class=\"hljs-title function_\"\u003edescargar_datos\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'ETH/USDT'\u003c/span\u003e)\n\n# 데이터 정규화\nscaler = \u003cspan class=\"hljs-title class_\"\u003eMinMaxScaler\u003c/span\u003e(feature_range=(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e))\ndata = scaler.\u003cspan class=\"hljs-title function_\"\u003efit_transform\u003c/span\u003e(data.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e))\n\n# 시퀀스에서 샘플 생성하는 함수\ndef \u003cspan class=\"hljs-title function_\"\u003ecrear_muestras\u003c/span\u003e(dataset, pasos_de_tiempo=\u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e):\n    X, y = [], []\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(pasos_de_tiempo, \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(dataset)):\n        X.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(dataset[i-\u003cspan class=\"hljs-attr\"\u003epasos_de_tiempo\u003c/span\u003e:i, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e])\n        y.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(dataset[i, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e])\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(X), np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(y)\n\n# 훈련 및 테스트 데이터 준비\npasos_de_tiempo = \u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e\nX, y = \u003cspan class=\"hljs-title function_\"\u003ecrear_muestras\u003c/span\u003e(data, pasos_de_tiempo)\nX = X.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(X.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], X.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)  # \u003cspan class=\"hljs-variable constant_\"\u003eLSTM\u003c/span\u003e용 변경\n\n# 데이터 분할 (훈련에 \u003cspan class=\"hljs-number\"\u003e80\u003c/span\u003e% 할당)\nsplit = \u003cspan class=\"hljs-title function_\"\u003eint\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.8\u003c/span\u003e * \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(X))\nX_train, X_test = X[:split], X[\u003cspan class=\"hljs-attr\"\u003esplit\u003c/span\u003e:]\ny_train, y_test = y[:split], y[\u003cspan class=\"hljs-attr\"\u003esplit\u003c/span\u003e:]\n\n# 모델 훈련\n\nmodel = \u003cspan class=\"hljs-title class_\"\u003eSequential\u003c/span\u003e()\nmodel.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eConv1D\u003c/span\u003e(filters=\u003cspan class=\"hljs-number\"\u003e256\u003c/span\u003e, kernel_size=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, activation=\u003cspan class=\"hljs-string\"\u003e'relu'\u003c/span\u003e,padding = \u003cspan class=\"hljs-string\"\u003e'same'\u003c/span\u003e,input_shape=(X_train.\u003cspan class=\"hljs-property\"\u003eshape\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e],\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)))\nmodel.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eMaxPooling1D\u003c/span\u003e(pool_size=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e))\nmodel.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eLSTM\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, return_sequences = \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e))\nmodel.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDropout\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.3\u003c/span\u003e))\nmodel.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eLSTM\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, return_sequences = \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e))\nmodel.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDropout\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.3\u003c/span\u003e))\nmodel.\u003cspan class=\"hljs-title function_\"\u003eadd\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eDense\u003c/span\u003e(units=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, activation = \u003cspan class=\"hljs-string\"\u003e'sigmoid'\u003c/span\u003e))\nmodel.\u003cspan class=\"hljs-title function_\"\u003ecompile\u003c/span\u003e(optimizer=\u003cspan class=\"hljs-string\"\u003e'adam'\u003c/span\u003e, loss= \u003cspan class=\"hljs-string\"\u003e'mse'\u003c/span\u003e , metrics = [tf.\u003cspan class=\"hljs-property\"\u003ekeras\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emetrics\u003c/span\u003e.\u003cspan class=\"hljs-title class_\"\u003eRootMeanSquaredError\u003c/span\u003e(name=\u003cspan class=\"hljs-string\"\u003e'rmse'\u003c/span\u003e)])\n\n# 조기 종료 설정\nearly_stopping = callbacks.\u003cspan class=\"hljs-title class_\"\u003eEarlyStopping\u003c/span\u003e(\n    monitor=\u003cspan class=\"hljs-string\"\u003e'val_loss'\u003c/span\u003e,\n    patience=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e,\n    restore_best_weights=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e,\n)\n# 최적의 모델 저장할 체크포인트 설정\ncheckpoint = \u003cspan class=\"hljs-title class_\"\u003eModelCheckpoint\u003c/span\u003e(\n    \u003cspan class=\"hljs-string\"\u003e'best_model.h5'\u003c/span\u003e, \n    monitor=\u003cspan class=\"hljs-string\"\u003e'val_loss'\u003c/span\u003e, \n    save_best_only=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e, \n    save_weights_only=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n)\n\n# \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e 에폭 학습\nhistory = model.\u003cspan class=\"hljs-title function_\"\u003efit\u003c/span\u003e(X_train, y_train, epochs = \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e , validation_data = (X_test,y_test), batch_size=\u003cspan class=\"hljs-number\"\u003e32\u003c/span\u003e, callbacks=[early_stopping, checkpoint], verbose=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n\n# 훈련 이력 그래프\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e))\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(history.\u003cspan class=\"hljs-property\"\u003ehistory\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'loss'\u003c/span\u003e], label=\u003cspan class=\"hljs-string\"\u003e'Train Loss'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(history.\u003cspan class=\"hljs-property\"\u003ehistory\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'val_loss'\u003c/span\u003e], label=\u003cspan class=\"hljs-string\"\u003e'Validation Loss'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(history.\u003cspan class=\"hljs-property\"\u003ehistory\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'rmse'\u003c/span\u003e], label=\u003cspan class=\"hljs-string\"\u003e'Train RMSE'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(history.\u003cspan class=\"hljs-property\"\u003ehistory\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'val_rmse'\u003c/span\u003e], label=\u003cspan class=\"hljs-string\"\u003e'Validation RMSE'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Model Training History'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Epochs'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Loss/RMSE'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\nplt.\u003cspan class=\"hljs-title function_\"\u003esavefig\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'ETHUSDT.png'\u003c/span\u003e)  # 그래프 이미지 파일로 저장\n\n# 모델을 \u003cspan class=\"hljs-variable constant_\"\u003eONNX\u003c/span\u003e로 변환\nonnx_model, _ = tf2onnx.\u003cspan class=\"hljs-property\"\u003econvert\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_keras\u003c/span\u003e(model, opset=\u003cspan class=\"hljs-number\"\u003e13\u003c/span\u003e, output_path=\u003cspan class=\"hljs-string\"\u003e\"model_ethusdt.onnx\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ONNX 모델을 'model_ethusdt.onnx'로 저장했습니다.\"\u003c/span\u003e)\n\n# 모델 평가\ntrain_loss, train_rmse = model.evaluate(X_train, y_train, verbose=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\ntest_loss, test_rmse = model.evaluate(X_test, y_test, verbose=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"train_loss={train_loss:.3f}, train_rmse={train_rmse:.3f}\"\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"test_loss={test_loss:.3f}, test_rmse={test_rmse:.3f}\"\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e백테스팅\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e ccxt\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e onnx\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e onnxruntime \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e ort\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.\u003cspan class=\"hljs-property\"\u003emetrics\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e mean_absolute_error, mean_squared_error, r2_score, mean_absolute_percentage_error\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.\u003cspan class=\"hljs-property\"\u003emodel_selection\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTimeSeriesSplit\u003c/span\u003e\n\n# 바이낸스 거래소 인스턴스 생성\nbinance = ccxt.\u003cspan class=\"hljs-title function_\"\u003ebinance\u003c/span\u003e()\n\n# 시장 심볼 및 시간 간격 정의\nsymbol = \u003cspan class=\"hljs-string\"\u003e'ETH/USDT'\u003c/span\u003e\ntimeframe = \u003cspan class=\"hljs-string\"\u003e'1d'\u003c/span\u003e\nlimit = \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e  # \u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e일 신뢰 구간 보장을 위한 충분한 데이터 다운로드\n\n# 역사적 데이터 다운로드\nohlcv = binance.\u003cspan class=\"hljs-title function_\"\u003efetch_ohlcv\u003c/span\u003e(symbol, timeframe, limit=limit)\n\n# 데이터를 판다스 \u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e으로 변환\ndf = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(ohlcv, columns=[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'open'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'high'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'low'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'volume'\u003c/span\u003e])\ndf[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e] = pd.\u003cspan class=\"hljs-title function_\"\u003eto_datetime\u003c/span\u003e(df[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e], unit=\u003cspan class=\"hljs-string\"\u003e'ms'\u003c/span\u003e)\n\n# 데이터를 \u003cspan class=\"hljs-variable constant_\"\u003eCSV\u003c/span\u003e 파일로 저장\ndf.\u003cspan class=\"hljs-title function_\"\u003eto_csv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'binance_data.csv'\u003c/span\u003e, index=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"'binance_data.csv'에 다운로드 및 저장된 데이터\"\u003c/span\u003e)\n\n# 다운로드한 데이터 로드\ndata = pd.\u003cspan class=\"hljs-title function_\"\u003eread_csv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'binance_data.csv'\u003c/span\u003e)\n\n# \u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e 열을 datetime 형식으로 변환\ndata[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e] = pd.\u003cspan class=\"hljs-title function_\"\u003eto_datetime\u003c/span\u003e(data[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e])\n\n# 정규화 값(정규화에 사용한 값에 맞게 조정)\nmin_close = data[\u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003emin\u003c/span\u003e()\nmax_close = data[\u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e()\n\n# 종가 데이터 정규화\ndata[\u003cspan class=\"hljs-string\"\u003e'close_normalized'\u003c/span\u003e] = (data[\u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e] - min_close) / (max_close - min_close)\n\n# \u003cspan class=\"hljs-variable constant_\"\u003eONNX\u003c/span\u003e 모델 로드\nmodel = onnx.\u003cspan class=\"hljs-title function_\"\u003eload\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'model_ethusdt.onnx'\u003c/span\u003e)\nonnx.\u003cspan class=\"hljs-property\"\u003echecker\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003echeck_model\u003c/span\u003e(model)\n\n# 런타임 세션 생성\nort_session = ort.\u003cspan class=\"hljs-title class_\"\u003eInferenceSession\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'model_ethusdt.onnx'\u003c/span\u003e)\n\n# 모델에 주입할 데이터를 슬라이딩 윈도우로 준비\ninput_name = ort_session.\u003cspan class=\"hljs-title function_\"\u003eget_inputs\u003c/span\u003e()[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e\nsequence_length = \u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e  # 모델에 따라 조정\n\n# 예측값을 저장할 리스트 생성\npredictions_list = []\n\n# 예측 시작 날짜 설정\nstart_date = pd.\u003cspan class=\"hljs-title class_\"\u003eTimestamp\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'2024-01-01'\u003c/span\u003e)\nend_date = pd.\u003cspan class=\"hljs-property\"\u003eTimestamp\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etoday\u003c/span\u003e()\n\n# 날짜별 추론 실행\ncurrent_date = start_date\n\u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e current_date \u0026#x3C;= \u003cspan class=\"hljs-attr\"\u003eend_date\u003c/span\u003e:\n    # 현재 날짜 이전 \u003cspan class=\"hljs-number\"\u003e120\u003c/span\u003e일 데이터 선택\n    end_idx = data[data[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e] \u0026#x3C;= current_date].\u003cspan class=\"hljs-property\"\u003eindex\u003c/span\u003e[-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n    start_idx = end_idx - sequence_length + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e start_idx \u0026#x3C; \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{current_date} 날짜에 대한 데이터 부족\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n\n    # 정규화된 데이터 윈도우 추출\n    \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e = data[\u003cspan class=\"hljs-string\"\u003e'close_normalized'\u003c/span\u003e].\u003cspan class=\"hljs-property\"\u003evalues\u003c/span\u003e[\u003cspan class=\"hljs-attr\"\u003estart_idx\u003c/span\u003e:end_idx+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e) \u0026#x3C; \u003cspan class=\"hljs-attr\"\u003esequence_length\u003c/span\u003e:\n        \u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{current_date} 날짜에 대한 데이터 부족\"\u003c/span\u003e)\n        \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e\n\n    # 모델에 입력할 데이터 준비\n    input_window = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eastype\u003c/span\u003e(np.\u003cspan class=\"hljs-property\"\u003efloat32\u003c/span\u003e)\n    input_window = np.\u003cspan class=\"hljs-title function_\"\u003eexpand_dims\u003c/span\u003e(input_window, axis=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)  # 배치 크기 차원 추가\n    input_window = np.\u003cspan class=\"hljs-title function_\"\u003eexpand_dims\u003c/span\u003e(input_window, axis=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)  # 특성 차원 추가\n\n    # 추론 실행\n    output = ort_session.\u003cspan class=\"hljs-title function_\"\u003erun\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eNone\u003c/span\u003e, {\u003cspan class=\"hljs-attr\"\u003einput_name\u003c/span\u003e: input_window})\n    prediction = output[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]\n\n    # 예측값 역정규화\n    prediction = prediction * (max_close - min_close) + min_close\n\n    # 예측값 저장\n    predictions_list.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e: current_date, \u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e: prediction})\n\n    # 날짜 증가\n    current_date += pd.\u003cspan class=\"hljs-title class_\"\u003eTimedelta\u003c/span\u003e(days=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)\n\n# 예측값 리스트를 \u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e으로 변환\npredictions_df = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e(predictions_list)\n\n# 예측값을 \u003cspan class=\"hljs-variable constant_\"\u003eCSV\u003c/span\u003e 파일로 저장\npredictions_df.\u003cspan class=\"hljs-title function_\"\u003eto_csv\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'predicted_data.csv'\u003c/span\u003e, index=\u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"'predicted_data.csv'에 저장된 예측값\"\u003c/span\u003e)\n\n# 예측값과 실제 값 비교\ncomparison_df = pd.\u003cspan class=\"hljs-title function_\"\u003emerge\u003c/span\u003e(predictions_df, data[[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e]], left_on=\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e, right_on=\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e)\ncomparison_df = comparison_df.\u003cspan class=\"hljs-title function_\"\u003edrop\u003c/span\u003e(columns=[\u003cspan class=\"hljs-string\"\u003e'timestamp'\u003c/span\u003e])\ncomparison_df = comparison_df.\u003cspan class=\"hljs-title function_\"\u003erename\u003c/span\u003e(columns={\u003cspan class=\"hljs-string\"\u003e'close'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e})\n\n# 오차 메트릭 계산\nmae = \u003cspan class=\"hljs-title function_\"\u003emean_absolute_error\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e])\nrmse = np.\u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003emean_squared_error\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e]))\nr2 = \u003cspan class=\"hljs-title function_\"\u003er2_score\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e])\nmape = \u003cspan class=\"hljs-title function_\"\u003emean_absolute_percentage_error\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e])\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'평균 절대 오차(MAE): {mae}'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'제곱근 평균 제곱 오차(RMSE): {rmse}'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'R^2 점수 (R2): {r2}'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'평균 절대 백분율 오차(MAPE): {mape}'\u003c/span\u003e)\n\n# 오차 밴드가 있는 그래프 그리기\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e))\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e], label=\u003cspan class=\"hljs-string\"\u003e'실제 가격'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'blue'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e], label=\u003cspan class=\"hljs-string\"\u003e'예측 가격'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'red'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003efill_between\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e] - mae, comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e] + mae, color=\u003cspan class=\"hljs-string\"\u003e'gray'\u003c/span\u003e, alpha=\u003cspan class=\"hljs-number\"\u003e0.2\u003c/span\u003e, label=\u003cspan class=\"hljs-string\"\u003e'오차 밴드 (MAE)'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'날짜'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'가격'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'{symbol} 가격 예측 대 비교'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\nplt.\u003cspan class=\"hljs-title function_\"\u003esavefig\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{symbol.replace('/', '_')}_price_prediction.png\"\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"'{symbol.replace('/', '_')}_price_prediction.png'로 그래프 저장됨\"\u003c/span\u003e)\n\n# 잔차 분석\nresiduals = comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e] - comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e]\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e))\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], residuals, label=\u003cspan class=\"hljs-string\"\u003e'잔차'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'purple'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eaxhline\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'black'\u003c/span\u003e, linestyle=\u003cspan class=\"hljs-string\"\u003e'--'\u003c/span\u003e, linewidth=\u003cspan class=\"hljs-number\"\u003e0.8\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'날짜'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'잔차'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'{symbol} 예측 잔차'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\nplt.\u003cspan class=\"hljs-title function_\"\u003esavefig\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{symbol.replace('/', '_')}_residuals.png\"\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"'{symbol.replace('/', '_')}_residuals.png'로 잔차 그래프 저장됨\"\u003c/span\u003e)\n\n# 상관관계 분석\ncorrelation = comparison_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003ecorr\u003c/span\u003e(comparison_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e])\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'실제 및 예측 가격 간 상관관계: {correlation}'\u003c/span\u003e)\n\n# 예측 기반 투자 전략 시뮬레이션 (원본 전략)\ninvestment_df = comparison_df.\u003cspan class=\"hljs-title function_\"\u003ecopy\u003c/span\u003e()\ninvestment_df[\u003cspan class=\"hljs-string\"\u003e'strategy_returns'\u003c/span\u003e] = (investment_df[\u003cspan class=\"hljs-string\"\u003e'prediction'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eshift\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) - investment_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e]) / investment_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e]\ninvestment_df[\u003cspan class=\"hljs-string\"\u003e'buy_and_hold_returns'\u003c/span\u003e] = (investment_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eshift\u003c/span\u003e(-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) - investment_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e]) / investment_df[\u003cspan class=\"hljs-string\"\u003e'actual'\u003c/span\u003e]\n\nstrategy_cumulative_returns = (investment_df[\u003cspan class=\"hljs-string\"\u003e'strategy_returns'\u003c/span\u003e] + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ecumprod\u003c/span\u003e() - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\nbuy_and_hold_cumulative_returns = (investment_df[\u003cspan class=\"hljs-string\"\u003e'buy_and_hold_returns'\u003c/span\u003e] + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ecumprod\u003c/span\u003e() - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e))\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(investment_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], strategy_cumulative_returns, label=\u003cspan class=\"hljs-string\"\u003e'전략 누적 수익'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'green'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(investment_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], buy_and_hold_cumulative_returns, label=\u003cspan class=\"hljs-string\"\u003e'매수 및 보유 누적 수익'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'orange'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'날짜'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'누적 수익률'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'{symbol} 투자 전략 대 매수 및 보유'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003elegend\u003c/span\u003e()\nplt.\u003cspan class=\"hljs-title function_\"\u003esavefig\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"{symbol.replace('/', '_')}_investment_strategy.png\"\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e\"'{symbol.replace('/', '_')}_investment_strategy.png'로 투자 전략 그래프 저장됨\"\u003c/span\u003e)\n\n# 손실 전망\ninvestment_df[\u003cspan class=\"hljs-string\"\u003e'drawdown'\u003c/span\u003e] = strategy_cumulative_returns.\u003cspan class=\"hljs-title function_\"\u003ecummax\u003c/span\u003e() - strategy_cumulative_returns\ninvestment_df[\u003cspan class=\"hljs-string\"\u003e'max_drawdown'\u003c/span\u003e] = investment_df[\u003cspan class=\"hljs-string\"\u003e'drawdown'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003emax\u003c/span\u003e()\n\nplt.\u003cspan class=\"hljs-title function_\"\u003efigure\u003c/span\u003e(figsize=(\u003cspan class=\"hljs-number\"\u003e14\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e))\nplt.\u003cspan class=\"hljs-title function_\"\u003eplot\u003c/span\u003e(investment_df[\u003cspan class=\"hljs-string\"\u003e'date'\u003c/span\u003e], investment_df[\u003cspan class=\"hljs-string\"\u003e'drawdown'\u003c/span\u003e], label=\u003cspan class=\"hljs-string\"\u003e'Drawdown'\u003c/span\u003e, color=\u003cspan class=\"hljs-string\"\u003e'red'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003exlabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'날짜'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003eylabel\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'Drawdown'\u003c/span\u003e)\nplt.\u003cspan class=\"hljs-title function_\"\u003etitle\u003c/span\u003e(f\u003cspan class=\"hljs-string\"\u003e'{symbol} 전략 Drawdown'\u003c/span\u003e)\nplt\n\u003c/code\u003e\u003c/pre\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>