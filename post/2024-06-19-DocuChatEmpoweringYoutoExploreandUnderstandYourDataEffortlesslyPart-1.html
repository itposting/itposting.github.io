<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>문서챗 데이터를 손쉽게 탐색하고 이해하는 데 도움이 되는 방법  파트 1 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="문서챗 데이터를 손쉽게 탐색하고 이해하는 데 도움이 되는 방법  파트 1 | itposting" data-gatsby-head="true"/><meta property="og:title" content="문서챗 데이터를 손쉽게 탐색하고 이해하는 데 도움이 되는 방법  파트 1 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1" data-gatsby-head="true"/><meta name="twitter:title" content="문서챗 데이터를 손쉽게 탐색하고 이해하는 데 도움이 되는 방법  파트 1 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 19:14" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">문서챗 데이터를 손쉽게 탐색하고 이해하는 데 도움이 되는 방법  파트 1</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="문서챗 데이터를 손쉽게 탐색하고 이해하는 데 도움이 되는 방법  파트 1" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>소개:</h1>
<p>대형 언어 모델(LLMs)의 가장 혁신적인 사용 사례 중 하나는 정교한 질의응답(Q&#x26;A) 챗봇을 개발하는 데 있습니다. 이러한 지능적인 시스템은 "검색 증강 생성"이라는 기술 덕분에 특정 데이터셋을 이용하여 질문에 대답하고 해석할 수 있습니다.</p>
<p>본 기사는 기업용 챗봇을 구축하는 시리즈의 일환입니다. 우리는 기초적인 개념부터 시작하여 점차적으로 더 복잡한 주제로 나아갈 것입니다. 이 시리즈를 통해 다음과 같은 내용을 배우게 될 것입니다:</p>
<ul>
<li>메모리 인식 챗봇 구축을 위한 기초적인 개념: RAG, LangChain, LlamaIndex 등의 기초 개념부터 시작하여 챗봇이 맥락을 유지하고 일관된 장기적 상호작용을 제공할 수 있도록 합니다.</li>
<li>고급 데이터 전처리 및 멀티모달 검색: 이미지나 테이블이 포함된 문서를 처리하여 챗봇이 이러한 데이터를 효과적으로 해석하고 활용할 수 있도록 합니다.</li>
<li>기업용 데이터 수집: 기업 환경에 맞게 데이터 수집, 저장 및 조정을 위한 강력한 전략입니다.</li>
<li>에이전트 전략: 기존 RAG 파이프라인 상에 에이전트를 구축하여 자동화된 의사결정 능력을 부여합니다.</li>
<li>보안 및 거버넌스: 챗봇을 안전하게 보호하고 데이터 거버넌스 정책을 준수하는 데 필요한 모범 사례입니다.</li>
<li>가시성: 챗봇의 건강과 성능을 유지하기 위해 모니터링 및 가시성을 구현합니다.</li>
</ul>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1_0.png">
<p>이 시리즈가 끝나면, 데이터 탐색과 이해를 쉽게 능력을 향상시킬 수 있는 강력한 기업급 챗봇을 구축하는 데 필요한 지식과 도구를 갖게 될 것입니다.</p>
<h2>RAG란 무엇인가요?</h2>
<p>RAG는 LLM의 기능을 확장하여 추가 데이터를 통합하는 강력한 방법입니다. LLM은 다양한 주제를 토론할 수 있지만, 그들의 지식은 일정한 시점까지 공개 정보로 제한됩니다. 개인 정보나 보다 최근 데이터를 처리할 수 있는 AI 애플리케이션을 만들기 위해서는 모델의 지식을 관련 정보로 보충하는 것이 중요합니다.</p>
<div class="content-ad"></div>
<p>RAG은 필요한 데이터를 검색하여 모델의 프롬프트에 삽입함으로써 이를 달성합니다. LangChain, LlamaIndex와 같은 프레임워크는 Q&#x26;A 애플리케이션 및 RAG 구현을 용이하게 하는 컴포넌트 스위트를 제공합니다. 전형적인 RAG 애플리케이션은 두 가지 주요 컴포넌트로 구성됩니다:</p>
<ul>
<li>
<p>색인화: 이는 여러 소스에서 데이터를 수집하고 색인화하는 파이프라인을 설정하는 과정입니다.</p>
</li>
<li>
<p>데이터 로딩: 첫 번째 단계는 데이터를 로드하는 것인데, 여기서는 LangChain의 <code>PyPDFLoader</code>, <code>WebBaseLoader</code> 또는 LLamaIndex의 <code>SimpleDirectoryReader</code>와 같은 DocumentLoader를 사용합니다.</p>
</li>
<li>
<p>텍스트 분할: 텍스트 분할기는 큰 문서를 작은 청크로 분할하여 검색이 쉽고 모델의 컨텍스트 창에 맞는 데이터로 만듭니다.</p>
</li>
<li>
<p>데이터 저장: 분할된 데이터 청크는 추후 검색을 위해 저장되고 색인화됩니다. 이때 ChromaDB, Azure Search, AWS ElasticSearch와 같은 VectorStores(벡터 스토어)를 Embeddings 모델과 결합하여 종종 사용합니다.</p>
</li>
</ul>
<ol start="2">
<li>검색 및 생성: 이 컴포넌트는 사용자 쿼리를 실시간으로 처리하고 색인에서 중요한 데이터를 검색하여 모델을 사용하여 응답을 생성합니다.</li>
</ol>
<div class="content-ad"></div>
<ul>
<li>데이터 검색: 사용자가 쿼리를 입력하면, 관련 청크는 리트리버를 사용하여 저장소에서 검색됩니다.</li>
<li>답변 생성: ChatModel 또는 LLM은 사용자의 질문과 검색된 데이터를 포함하여 답변을 생성합니다.</li>
</ul>
<h2>RAG 아키텍처</h2>
<p><img src="/assets/img/2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1_1.png" alt="RAG 아키텍처"></p>
<pre><code class="hljs language-js">def <span class="hljs-title function_">process_pdf_simple</span>(self, file_content):
    # 문서 로드
    loader = <span class="hljs-title class_">PyPDFLoader</span>(file_content)
    docs = loader.<span class="hljs-title function_">load</span>()
    
    # 문서 분할
    text_splitter = <span class="hljs-title class_">RecursiveCharacterTextSplitter</span>(
        chunk_size=<span class="hljs-number">1000</span>, 
        chunk_overlap=<span class="hljs-number">200</span>
    )
    splits = text_splitter.<span class="hljs-title function_">split_documents</span>(docs)
    
    # 문서 색인화
    vectorstore = <span class="hljs-title class_">Chroma</span>.<span class="hljs-title function_">from_documents</span>(splits, self.<span class="hljs-property">embeddings</span>)
    
    # 리트리버 정의
    retriever = vectorstore.<span class="hljs-title function_">as_retriever</span>()
</code></pre>
<div class="content-ad"></div>
<p>이 스니펫에서는 PyPDFLoader를 사용하여 PDF 콘텐츠를 초기화하고 문서를 로드합니다. 그런 다음 Chroma 클래스를 사용하여 문서 청크에서 벡터 저장소를 생성합니다. Chroma의 <code>from_documents</code> 메서드는 임베딩 모델을 사용하여 문서 분할에서 인덱스를 생성합니다. <code>as_retriever</code> 메서드는 벡터 저장소를 검색기 객체로 변환하여 챗봇이 인덱싱된 문서 청크를 검색하고 가장 관련성 높은 정보를 빠르게 찾을 수 있도록 합니다.</p>
<h1>Q&#x26;A 챗봇의 주요 구성 요소:</h1>
<ol>
<li>
<p>챗 모델: 텍스트 기반 LLM과 달리 메시지 기반 상호작용에 최적화되어 더 자연스러운 대화 응답을 제공합니다.</p>
</li>
<li>
<p>프롬프트 템플릿: 이러한 템플릿은 기본 메시지, 사용자 입력, 채팅 기록 및 선택적으로 다른 소스에서 검색한 추가 컨텍스트를 결합하여 프롬프트를 만드는 데 도움이 됩니다. 이는 예를 들어, 금융 자문가로 챗봇을 가정하는 특정 페르소나를 만들어낼 수도 있습니다.</p>
</li>
</ol>
<div class="content-ad"></div>
<ol start="3">
<li>채팅 기록: 이 기능을 통해 챗봇은 과거 상호작용을 기억할 수 있어 후속 질문에 맥락을 제공하여 응답할 수 있습니다. Q&#x26;A 애플리케이션에서는 과거 질문과 답변을 기억하는 것이 일관된 대화를 위해 중요합니다.</li>
</ol>
<h2>기록 인식 검색 구현:</h2>
<p>우리는 역사적 메시지와 최신 사용자 질문을 가져와 질문을 재정렬하여 이전 맥락없이도 이해할 수 있도록 할 서브-체인을 정의할 것입니다. 이를 위해 우리의 프롬프트에서 "chat_history"라는 <code>MessagesPlaceholder</code> 변수를 사용합니다. <code>create_history_aware_retriever</code>라는 도우미 함수를 사용하여 채팅 기록을 포함하고 시퀀스를 적용할 것입니다: <code>prompt | lIm | StrOutputParser | retriever</code>.</p>
<pre><code class="hljs language-js">####
# 질문 맥락화
####
contextualize_q_system_prompt = (
    <span class="hljs-string">"과거 채팅 기록과 최신 사용자 질문이 주어졌을 때, 채팅 기록에서 맥락을 참조할 수 있는 문제를 독립적으로 이해할 수 있는 혼자서도 이해할 수 있는 질문으로 재평가하세요. 질문에 대답하지 말고, 필요하다면 다시 정리하고 그렇지 않으면 그대로 반환하세요."</span>
)

contextualize_q_prompt = <span class="hljs-title class_">ChatPromptTemplate</span>.<span class="hljs-title function_">from_messages</span>(
    (<span class="hljs-string">"system"</span>, contextualize_q_system_prompt),
    <span class="hljs-title class_">MessagesPlaceholder</span>(<span class="hljs-string">"chat_history"</span>),
    (<span class="hljs-string">"human"</span>, <span class="hljs-string">"{input}"</span>)
)

history_aware_retriever = <span class="hljs-title function_">create_history_aware_retriever</span>(
    self.<span class="hljs-property">llm</span>, retriever, contextualize_q_prompt
)
</code></pre>
<div class="content-ad"></div>
<h2>전체 QA 체인 구축하기:</h2>
<p>마침내, 우리는 리트리버를 히스토리 인식 리트리버로 업데이트하고 <code>create_stuff_documents_chain</code>을 사용하여 질문-답변 체인을 구축할 것입니다. 이 체인은 검색된 컨텍스트, 채팅 기록 및 사용자 쿼리를 받아 답변을 생성합니다. 그런 다음 <code>create_retrieval_chain</code>을 사용하여 최종 RAG 체인을 구성합니다. 이 체인은 히스토리 인식 리트리버와 질문-답변 체인을 순차적으로 적용하여 검색된 컨텍스트와 같은 중간 출력을 유지합니다. 이러한 단계를 통해 과거 상호작용을 인식하고 기억하는 강력한 챗봇을 구축했습니다. 이는 사용자와의 원활하고 일관된 대화를 보장합니다.</p>
<pre><code class="hljs language-js">### 채팅 기록 상태 관리하기 ###
store = {}

# 채팅 기록을 영속적으로 저장하고 있지 않지만, redis에 저장할 수도 있습니다
def <span class="hljs-title function_">get_session_history</span>(<span class="hljs-attr">session_id</span>: str) -> <span class="hljs-title class_">BaseChatMessageHistory</span>:
    <span class="hljs-keyword">if</span> session_id not <span class="hljs-keyword">in</span> <span class="hljs-attr">store</span>:
        store[session_id] = <span class="hljs-title class_">ChatMessageHistory</span>()
    <span class="hljs-keyword">return</span> store[session_id]

conversational_rag_chain = <span class="hljs-title class_">RunnableWithMessageHistory</span>(
    rag_chain,
    get_session_history,
    input_messages_key=<span class="hljs-string">"input"</span>,
    history_messages_key=<span class="hljs-string">"chat_history"</span>,
    output_messages_key=<span class="hljs-string">"answer"</span>
)

<span class="hljs-keyword">return</span> conversational_rag_chain
</code></pre>
<p>마지막으로, 입력 쿼리를 처리하고 색인된 문서 청크에서 관련 정보를 검색하는 conversational_rag_chain inbuilt 메서드 invoke를 호출할 수 있습니다. 결합된 질문, 컨텍스트 및 프롬프트는 LLM에 전송되어 응답을 생성합니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">file_path = <span class="hljs-string">'amazon_2024_10q.pdf'</span>
user_query = <span class="hljs-string">"Amazon의 2024년 Q1 10-Q SEC 보고서에서 보고된 주요 재무 하이라이트 및 중요한 변화는 무엇입니까?"</span>
obj = <span class="hljs-title class_">ConversationRetrieverAgent</span>()
chain = obj.<span class="hljs-title function_">process_pdf_simple</span>(file_path)
result = chain.<span class="hljs-title function_">invoke</span>({<span class="hljs-string">"input"</span>: user_query})
<span class="hljs-title function_">print</span>(result[<span class="hljs-string">"answer"</span>])
</code></pre>
<h1>결론</h1>
<p>DocuChat 앱은 LangChain 및 검색 확장 생성 (RAG)과 같은 고급 기술을 활용하여 사용자가 데이터를 탐색하고 이해하는 데 편리하게 도와줍니다. 문서를 효율적으로 로드, 분리 및 색인화하고 정교한 검색 및 생성 기술을 활용하여, DocuChat은 사용자 쿼리에 정확하고 컨텍스트에 민감한 답변을 제공할 수 있습니다. 채팅 모델, 프롬프트 템플릿 및 채팅 기록을 통합함으로써 자연스럽고 일관된 대화를 보장합니다. 히스토리 인식 검색 및 견고한 세션 관리를 구현함으로써, DocuChat은 데이터를 더 접근 가능하고 실행 가능하게 만들어 스마트하고 원활한 상호 작용 경험을 제공합니다.</p>
<h1>다음 단계?</h1>
<div class="content-ad"></div>
<p>이번 시리즈의 다음 부분을 기대해주세요. 다음에는 고급 데이터 전처리와 멀티모달 검색에 대해 자세히 알아볼 것입니다. 이미지와 테이블을 포함한 문서를 어떻게 처리하는지, 이 데이터를 챗봇이 효과적으로 해석하고 활용하는 방법을 다룰 예정입니다. 이는 금융 서비스용 봇을 만들 때 특히 유용하며, SEC와 Bloomberg과 같은 출처에서 받은 금융 시장 데이터를 분석할 수 있게 해줍니다. 이 데이터는 종종 그래프, 지표, 테이블을 포함하고 있습니다. 이러한 통찰력을 놓치지 마시고 챗봇 역량을 향상시키세요!</p>
<h1>저자 정보</h1>
<p>이 기사를 읽어주셔서 감사합니다! 만약 여기서 논의된 전체 코드베이스를 보거나 완전히 기능하는 챗 앱을 사용해보고 싶다면, 아래 링크를 방문해 주세요:</p>
<ul>
<li>LinkedIn: LinkedIn 프로필</li>
<li>GitHub: 이 기사의 전체 코드를 제 GitHub 프로필에서 확인하세요.</li>
<li>Streamlit: Streamlit 앱에서 완전히 기능하는 앱과 상호 작용해보세요. 기능을 탐색하고, 질문을 하며, DocuChat이 실시간으로 쿼리에 응답하는 방식을 확인해보세요.</li>
</ul>
<div class="content-ad"></div>
<p>LinkedIn에서 업데이트, 토론 및 지적 응용 프로그램 구축에 대한 자세한 통찰력을 얻으세요. 피드백 및 기여는 언제나 환영합니다!</p>
<p>참고 자료:</p>
<ul>
<li><a href="https://platform.openai.com/docs/quickstart" rel="nofollow" target="_blank">https://platform.openai.com/docs/quickstart</a></li>
<li><a href="https://python.langchain.com/v0.2/docs/tutorials/chatbot/" rel="nofollow" target="_blank">https://python.langchain.com/v0.2/docs/tutorials/chatbot/</a></li>
<li><a href="https://blog.langchain.dev/semi-structured-multi-modal-rag/" rel="nofollow" target="_blank">https://blog.langchain.dev/semi-structured-multi-modal-rag/</a></li>
<li><a href="https://docs.llamaindex.ai/en/stable/getting_started/concepts/" rel="nofollow" target="_blank">https://docs.llamaindex.ai/en/stable/getting_started/concepts/</a></li>
</ul>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"문서챗 데이터를 손쉽게 탐색하고 이해하는 데 도움이 되는 방법  파트 1","description":"","date":"2024-06-19 19:14","slug":"2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1","content":"\n\n# 소개:\n\n대형 언어 모델(LLMs)의 가장 혁신적인 사용 사례 중 하나는 정교한 질의응답(Q\u0026A) 챗봇을 개발하는 데 있습니다. 이러한 지능적인 시스템은 \"검색 증강 생성\"이라는 기술 덕분에 특정 데이터셋을 이용하여 질문에 대답하고 해석할 수 있습니다.\n\n본 기사는 기업용 챗봇을 구축하는 시리즈의 일환입니다. 우리는 기초적인 개념부터 시작하여 점차적으로 더 복잡한 주제로 나아갈 것입니다. 이 시리즈를 통해 다음과 같은 내용을 배우게 될 것입니다:\n\n- 메모리 인식 챗봇 구축을 위한 기초적인 개념: RAG, LangChain, LlamaIndex 등의 기초 개념부터 시작하여 챗봇이 맥락을 유지하고 일관된 장기적 상호작용을 제공할 수 있도록 합니다.\n- 고급 데이터 전처리 및 멀티모달 검색: 이미지나 테이블이 포함된 문서를 처리하여 챗봇이 이러한 데이터를 효과적으로 해석하고 활용할 수 있도록 합니다.\n- 기업용 데이터 수집: 기업 환경에 맞게 데이터 수집, 저장 및 조정을 위한 강력한 전략입니다.\n- 에이전트 전략: 기존 RAG 파이프라인 상에 에이전트를 구축하여 자동화된 의사결정 능력을 부여합니다.\n- 보안 및 거버넌스: 챗봇을 안전하게 보호하고 데이터 거버넌스 정책을 준수하는 데 필요한 모범 사례입니다.\n- 가시성: 챗봇의 건강과 성능을 유지하기 위해 모니터링 및 가시성을 구현합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1_0.png\" /\u003e\n\n이 시리즈가 끝나면, 데이터 탐색과 이해를 쉽게 능력을 향상시킬 수 있는 강력한 기업급 챗봇을 구축하는 데 필요한 지식과 도구를 갖게 될 것입니다.\n\n## RAG란 무엇인가요?\n\nRAG는 LLM의 기능을 확장하여 추가 데이터를 통합하는 강력한 방법입니다. LLM은 다양한 주제를 토론할 수 있지만, 그들의 지식은 일정한 시점까지 공개 정보로 제한됩니다. 개인 정보나 보다 최근 데이터를 처리할 수 있는 AI 애플리케이션을 만들기 위해서는 모델의 지식을 관련 정보로 보충하는 것이 중요합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nRAG은 필요한 데이터를 검색하여 모델의 프롬프트에 삽입함으로써 이를 달성합니다. LangChain, LlamaIndex와 같은 프레임워크는 Q\u0026A 애플리케이션 및 RAG 구현을 용이하게 하는 컴포넌트 스위트를 제공합니다. 전형적인 RAG 애플리케이션은 두 가지 주요 컴포넌트로 구성됩니다:\n\n- 색인화: 이는 여러 소스에서 데이터를 수집하고 색인화하는 파이프라인을 설정하는 과정입니다.\n\n- 데이터 로딩: 첫 번째 단계는 데이터를 로드하는 것인데, 여기서는 LangChain의 `PyPDFLoader`, `WebBaseLoader` 또는 LLamaIndex의 `SimpleDirectoryReader`와 같은 DocumentLoader를 사용합니다.\n- 텍스트 분할: 텍스트 분할기는 큰 문서를 작은 청크로 분할하여 검색이 쉽고 모델의 컨텍스트 창에 맞는 데이터로 만듭니다.\n- 데이터 저장: 분할된 데이터 청크는 추후 검색을 위해 저장되고 색인화됩니다. 이때 ChromaDB, Azure Search, AWS ElasticSearch와 같은 VectorStores(벡터 스토어)를 Embeddings 모델과 결합하여 종종 사용합니다.\n\n2. 검색 및 생성: 이 컴포넌트는 사용자 쿼리를 실시간으로 처리하고 색인에서 중요한 데이터를 검색하여 모델을 사용하여 응답을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 데이터 검색: 사용자가 쿼리를 입력하면, 관련 청크는 리트리버를 사용하여 저장소에서 검색됩니다.\n- 답변 생성: ChatModel 또는 LLM은 사용자의 질문과 검색된 데이터를 포함하여 답변을 생성합니다.\n\n## RAG 아키텍처\n\n![RAG 아키텍처](/assets/img/2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1_1.png)\n\n```js\ndef process_pdf_simple(self, file_content):\n    # 문서 로드\n    loader = PyPDFLoader(file_content)\n    docs = loader.load()\n    \n    # 문서 분할\n    text_splitter = RecursiveCharacterTextSplitter(\n        chunk_size=1000, \n        chunk_overlap=200\n    )\n    splits = text_splitter.split_documents(docs)\n    \n    # 문서 색인화\n    vectorstore = Chroma.from_documents(splits, self.embeddings)\n    \n    # 리트리버 정의\n    retriever = vectorstore.as_retriever()\r\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 스니펫에서는 PyPDFLoader를 사용하여 PDF 콘텐츠를 초기화하고 문서를 로드합니다. 그런 다음 Chroma 클래스를 사용하여 문서 청크에서 벡터 저장소를 생성합니다. Chroma의 `from_documents` 메서드는 임베딩 모델을 사용하여 문서 분할에서 인덱스를 생성합니다. `as_retriever` 메서드는 벡터 저장소를 검색기 객체로 변환하여 챗봇이 인덱싱된 문서 청크를 검색하고 가장 관련성 높은 정보를 빠르게 찾을 수 있도록 합니다.\n\n# Q\u0026A 챗봇의 주요 구성 요소:\n\n1. 챗 모델: 텍스트 기반 LLM과 달리 메시지 기반 상호작용에 최적화되어 더 자연스러운 대화 응답을 제공합니다.\n\n2. 프롬프트 템플릿: 이러한 템플릿은 기본 메시지, 사용자 입력, 채팅 기록 및 선택적으로 다른 소스에서 검색한 추가 컨텍스트를 결합하여 프롬프트를 만드는 데 도움이 됩니다. 이는 예를 들어, 금융 자문가로 챗봇을 가정하는 특정 페르소나를 만들어낼 수도 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 채팅 기록: 이 기능을 통해 챗봇은 과거 상호작용을 기억할 수 있어 후속 질문에 맥락을 제공하여 응답할 수 있습니다. Q\u0026A 애플리케이션에서는 과거 질문과 답변을 기억하는 것이 일관된 대화를 위해 중요합니다.\n\n## 기록 인식 검색 구현:\n\n우리는 역사적 메시지와 최신 사용자 질문을 가져와 질문을 재정렬하여 이전 맥락없이도 이해할 수 있도록 할 서브-체인을 정의할 것입니다. 이를 위해 우리의 프롬프트에서 \"chat_history\"라는 `MessagesPlaceholder` 변수를 사용합니다. `create_history_aware_retriever`라는 도우미 함수를 사용하여 채팅 기록을 포함하고 시퀀스를 적용할 것입니다: `prompt | lIm | StrOutputParser | retriever`.\n\n```js\n####\n# 질문 맥락화\n####\ncontextualize_q_system_prompt = (\n    \"과거 채팅 기록과 최신 사용자 질문이 주어졌을 때, 채팅 기록에서 맥락을 참조할 수 있는 문제를 독립적으로 이해할 수 있는 혼자서도 이해할 수 있는 질문으로 재평가하세요. 질문에 대답하지 말고, 필요하다면 다시 정리하고 그렇지 않으면 그대로 반환하세요.\"\n)\n\ncontextualize_q_prompt = ChatPromptTemplate.from_messages(\n    (\"system\", contextualize_q_system_prompt),\n    MessagesPlaceholder(\"chat_history\"),\n    (\"human\", \"{input}\")\n)\n\nhistory_aware_retriever = create_history_aware_retriever(\n    self.llm, retriever, contextualize_q_prompt\n)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n## 전체 QA 체인 구축하기:\n\n마침내, 우리는 리트리버를 히스토리 인식 리트리버로 업데이트하고 `create_stuff_documents_chain`을 사용하여 질문-답변 체인을 구축할 것입니다. 이 체인은 검색된 컨텍스트, 채팅 기록 및 사용자 쿼리를 받아 답변을 생성합니다. 그런 다음 `create_retrieval_chain`을 사용하여 최종 RAG 체인을 구성합니다. 이 체인은 히스토리 인식 리트리버와 질문-답변 체인을 순차적으로 적용하여 검색된 컨텍스트와 같은 중간 출력을 유지합니다. 이러한 단계를 통해 과거 상호작용을 인식하고 기억하는 강력한 챗봇을 구축했습니다. 이는 사용자와의 원활하고 일관된 대화를 보장합니다.\n\n```js\n### 채팅 기록 상태 관리하기 ###\nstore = {}\n\n# 채팅 기록을 영속적으로 저장하고 있지 않지만, redis에 저장할 수도 있습니다\ndef get_session_history(session_id: str) -\u003e BaseChatMessageHistory:\n    if session_id not in store:\n        store[session_id] = ChatMessageHistory()\n    return store[session_id]\n\nconversational_rag_chain = RunnableWithMessageHistory(\n    rag_chain,\n    get_session_history,\n    input_messages_key=\"input\",\n    history_messages_key=\"chat_history\",\n    output_messages_key=\"answer\"\n)\n\nreturn conversational_rag_chain\n```\n\n마지막으로, 입력 쿼리를 처리하고 색인된 문서 청크에서 관련 정보를 검색하는 conversational_rag_chain inbuilt 메서드 invoke를 호출할 수 있습니다. 결합된 질문, 컨텍스트 및 프롬프트는 LLM에 전송되어 응답을 생성합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfile_path = 'amazon_2024_10q.pdf'\nuser_query = \"Amazon의 2024년 Q1 10-Q SEC 보고서에서 보고된 주요 재무 하이라이트 및 중요한 변화는 무엇입니까?\"\nobj = ConversationRetrieverAgent()\nchain = obj.process_pdf_simple(file_path)\nresult = chain.invoke({\"input\": user_query})\nprint(result[\"answer\"])\n```\n\n# 결론\n\nDocuChat 앱은 LangChain 및 검색 확장 생성 (RAG)과 같은 고급 기술을 활용하여 사용자가 데이터를 탐색하고 이해하는 데 편리하게 도와줍니다. 문서를 효율적으로 로드, 분리 및 색인화하고 정교한 검색 및 생성 기술을 활용하여, DocuChat은 사용자 쿼리에 정확하고 컨텍스트에 민감한 답변을 제공할 수 있습니다. 채팅 모델, 프롬프트 템플릿 및 채팅 기록을 통합함으로써 자연스럽고 일관된 대화를 보장합니다. 히스토리 인식 검색 및 견고한 세션 관리를 구현함으로써, DocuChat은 데이터를 더 접근 가능하고 실행 가능하게 만들어 스마트하고 원활한 상호 작용 경험을 제공합니다.\n\n# 다음 단계?\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이번 시리즈의 다음 부분을 기대해주세요. 다음에는 고급 데이터 전처리와 멀티모달 검색에 대해 자세히 알아볼 것입니다. 이미지와 테이블을 포함한 문서를 어떻게 처리하는지, 이 데이터를 챗봇이 효과적으로 해석하고 활용하는 방법을 다룰 예정입니다. 이는 금융 서비스용 봇을 만들 때 특히 유용하며, SEC와 Bloomberg과 같은 출처에서 받은 금융 시장 데이터를 분석할 수 있게 해줍니다. 이 데이터는 종종 그래프, 지표, 테이블을 포함하고 있습니다. 이러한 통찰력을 놓치지 마시고 챗봇 역량을 향상시키세요!\n\n# 저자 정보\n\n이 기사를 읽어주셔서 감사합니다! 만약 여기서 논의된 전체 코드베이스를 보거나 완전히 기능하는 챗 앱을 사용해보고 싶다면, 아래 링크를 방문해 주세요:\n\n- LinkedIn: LinkedIn 프로필\n- GitHub: 이 기사의 전체 코드를 제 GitHub 프로필에서 확인하세요.\n- Streamlit: Streamlit 앱에서 완전히 기능하는 앱과 상호 작용해보세요. 기능을 탐색하고, 질문을 하며, DocuChat이 실시간으로 쿼리에 응답하는 방식을 확인해보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nLinkedIn에서 업데이트, 토론 및 지적 응용 프로그램 구축에 대한 자세한 통찰력을 얻으세요. 피드백 및 기여는 언제나 환영합니다!\n\n참고 자료:\n\n- https://platform.openai.com/docs/quickstart\n- https://python.langchain.com/v0.2/docs/tutorials/chatbot/\n- https://blog.langchain.dev/semi-structured-multi-modal-rag/\n- https://docs.llamaindex.ai/en/stable/getting_started/concepts/","ogImage":{"url":"/assets/img/2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1_0.png"},"coverImage":"/assets/img/2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e소개:\u003c/h1\u003e\n\u003cp\u003e대형 언어 모델(LLMs)의 가장 혁신적인 사용 사례 중 하나는 정교한 질의응답(Q\u0026#x26;A) 챗봇을 개발하는 데 있습니다. 이러한 지능적인 시스템은 \"검색 증강 생성\"이라는 기술 덕분에 특정 데이터셋을 이용하여 질문에 대답하고 해석할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e본 기사는 기업용 챗봇을 구축하는 시리즈의 일환입니다. 우리는 기초적인 개념부터 시작하여 점차적으로 더 복잡한 주제로 나아갈 것입니다. 이 시리즈를 통해 다음과 같은 내용을 배우게 될 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e메모리 인식 챗봇 구축을 위한 기초적인 개념: RAG, LangChain, LlamaIndex 등의 기초 개념부터 시작하여 챗봇이 맥락을 유지하고 일관된 장기적 상호작용을 제공할 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003e고급 데이터 전처리 및 멀티모달 검색: 이미지나 테이블이 포함된 문서를 처리하여 챗봇이 이러한 데이터를 효과적으로 해석하고 활용할 수 있도록 합니다.\u003c/li\u003e\n\u003cli\u003e기업용 데이터 수집: 기업 환경에 맞게 데이터 수집, 저장 및 조정을 위한 강력한 전략입니다.\u003c/li\u003e\n\u003cli\u003e에이전트 전략: 기존 RAG 파이프라인 상에 에이전트를 구축하여 자동화된 의사결정 능력을 부여합니다.\u003c/li\u003e\n\u003cli\u003e보안 및 거버넌스: 챗봇을 안전하게 보호하고 데이터 거버넌스 정책을 준수하는 데 필요한 모범 사례입니다.\u003c/li\u003e\n\u003cli\u003e가시성: 챗봇의 건강과 성능을 유지하기 위해 모니터링 및 가시성을 구현합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1_0.png\"\u003e\n\u003cp\u003e이 시리즈가 끝나면, 데이터 탐색과 이해를 쉽게 능력을 향상시킬 수 있는 강력한 기업급 챗봇을 구축하는 데 필요한 지식과 도구를 갖게 될 것입니다.\u003c/p\u003e\n\u003ch2\u003eRAG란 무엇인가요?\u003c/h2\u003e\n\u003cp\u003eRAG는 LLM의 기능을 확장하여 추가 데이터를 통합하는 강력한 방법입니다. LLM은 다양한 주제를 토론할 수 있지만, 그들의 지식은 일정한 시점까지 공개 정보로 제한됩니다. 개인 정보나 보다 최근 데이터를 처리할 수 있는 AI 애플리케이션을 만들기 위해서는 모델의 지식을 관련 정보로 보충하는 것이 중요합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eRAG은 필요한 데이터를 검색하여 모델의 프롬프트에 삽입함으로써 이를 달성합니다. LangChain, LlamaIndex와 같은 프레임워크는 Q\u0026#x26;A 애플리케이션 및 RAG 구현을 용이하게 하는 컴포넌트 스위트를 제공합니다. 전형적인 RAG 애플리케이션은 두 가지 주요 컴포넌트로 구성됩니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e색인화: 이는 여러 소스에서 데이터를 수집하고 색인화하는 파이프라인을 설정하는 과정입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e데이터 로딩: 첫 번째 단계는 데이터를 로드하는 것인데, 여기서는 LangChain의 \u003ccode\u003ePyPDFLoader\u003c/code\u003e, \u003ccode\u003eWebBaseLoader\u003c/code\u003e 또는 LLamaIndex의 \u003ccode\u003eSimpleDirectoryReader\u003c/code\u003e와 같은 DocumentLoader를 사용합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e텍스트 분할: 텍스트 분할기는 큰 문서를 작은 청크로 분할하여 검색이 쉽고 모델의 컨텍스트 창에 맞는 데이터로 만듭니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e데이터 저장: 분할된 데이터 청크는 추후 검색을 위해 저장되고 색인화됩니다. 이때 ChromaDB, Azure Search, AWS ElasticSearch와 같은 VectorStores(벡터 스토어)를 Embeddings 모델과 결합하여 종종 사용합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e검색 및 생성: 이 컴포넌트는 사용자 쿼리를 실시간으로 처리하고 색인에서 중요한 데이터를 검색하여 모델을 사용하여 응답을 생성합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e데이터 검색: 사용자가 쿼리를 입력하면, 관련 청크는 리트리버를 사용하여 저장소에서 검색됩니다.\u003c/li\u003e\n\u003cli\u003e답변 생성: ChatModel 또는 LLM은 사용자의 질문과 검색된 데이터를 포함하여 답변을 생성합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eRAG 아키텍처\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1_1.png\" alt=\"RAG 아키텍처\"\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edef \u003cspan class=\"hljs-title function_\"\u003eprocess_pdf_simple\u003c/span\u003e(self, file_content):\n    # 문서 로드\n    loader = \u003cspan class=\"hljs-title class_\"\u003ePyPDFLoader\u003c/span\u003e(file_content)\n    docs = loader.\u003cspan class=\"hljs-title function_\"\u003eload\u003c/span\u003e()\n    \n    # 문서 분할\n    text_splitter = \u003cspan class=\"hljs-title class_\"\u003eRecursiveCharacterTextSplitter\u003c/span\u003e(\n        chunk_size=\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e, \n        chunk_overlap=\u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e\n    )\n    splits = text_splitter.\u003cspan class=\"hljs-title function_\"\u003esplit_documents\u003c/span\u003e(docs)\n    \n    # 문서 색인화\n    vectorstore = \u003cspan class=\"hljs-title class_\"\u003eChroma\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_documents\u003c/span\u003e(splits, self.\u003cspan class=\"hljs-property\"\u003eembeddings\u003c/span\u003e)\n    \n    # 리트리버 정의\n    retriever = vectorstore.\u003cspan class=\"hljs-title function_\"\u003eas_retriever\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 스니펫에서는 PyPDFLoader를 사용하여 PDF 콘텐츠를 초기화하고 문서를 로드합니다. 그런 다음 Chroma 클래스를 사용하여 문서 청크에서 벡터 저장소를 생성합니다. Chroma의 \u003ccode\u003efrom_documents\u003c/code\u003e 메서드는 임베딩 모델을 사용하여 문서 분할에서 인덱스를 생성합니다. \u003ccode\u003eas_retriever\u003c/code\u003e 메서드는 벡터 저장소를 검색기 객체로 변환하여 챗봇이 인덱싱된 문서 청크를 검색하고 가장 관련성 높은 정보를 빠르게 찾을 수 있도록 합니다.\u003c/p\u003e\n\u003ch1\u003eQ\u0026#x26;A 챗봇의 주요 구성 요소:\u003c/h1\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e챗 모델: 텍스트 기반 LLM과 달리 메시지 기반 상호작용에 최적화되어 더 자연스러운 대화 응답을 제공합니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e프롬프트 템플릿: 이러한 템플릿은 기본 메시지, 사용자 입력, 채팅 기록 및 선택적으로 다른 소스에서 검색한 추가 컨텍스트를 결합하여 프롬프트를 만드는 데 도움이 됩니다. 이는 예를 들어, 금융 자문가로 챗봇을 가정하는 특정 페르소나를 만들어낼 수도 있습니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e채팅 기록: 이 기능을 통해 챗봇은 과거 상호작용을 기억할 수 있어 후속 질문에 맥락을 제공하여 응답할 수 있습니다. Q\u0026#x26;A 애플리케이션에서는 과거 질문과 답변을 기억하는 것이 일관된 대화를 위해 중요합니다.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e기록 인식 검색 구현:\u003c/h2\u003e\n\u003cp\u003e우리는 역사적 메시지와 최신 사용자 질문을 가져와 질문을 재정렬하여 이전 맥락없이도 이해할 수 있도록 할 서브-체인을 정의할 것입니다. 이를 위해 우리의 프롬프트에서 \"chat_history\"라는 \u003ccode\u003eMessagesPlaceholder\u003c/code\u003e 변수를 사용합니다. \u003ccode\u003ecreate_history_aware_retriever\u003c/code\u003e라는 도우미 함수를 사용하여 채팅 기록을 포함하고 시퀀스를 적용할 것입니다: \u003ccode\u003eprompt | lIm | StrOutputParser | retriever\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e####\n# 질문 맥락화\n####\ncontextualize_q_system_prompt = (\n    \u003cspan class=\"hljs-string\"\u003e\"과거 채팅 기록과 최신 사용자 질문이 주어졌을 때, 채팅 기록에서 맥락을 참조할 수 있는 문제를 독립적으로 이해할 수 있는 혼자서도 이해할 수 있는 질문으로 재평가하세요. 질문에 대답하지 말고, 필요하다면 다시 정리하고 그렇지 않으면 그대로 반환하세요.\"\u003c/span\u003e\n)\n\ncontextualize_q_prompt = \u003cspan class=\"hljs-title class_\"\u003eChatPromptTemplate\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efrom_messages\u003c/span\u003e(\n    (\u003cspan class=\"hljs-string\"\u003e\"system\"\u003c/span\u003e, contextualize_q_system_prompt),\n    \u003cspan class=\"hljs-title class_\"\u003eMessagesPlaceholder\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"chat_history\"\u003c/span\u003e),\n    (\u003cspan class=\"hljs-string\"\u003e\"human\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"{input}\"\u003c/span\u003e)\n)\n\nhistory_aware_retriever = \u003cspan class=\"hljs-title function_\"\u003ecreate_history_aware_retriever\u003c/span\u003e(\n    self.\u003cspan class=\"hljs-property\"\u003ellm\u003c/span\u003e, retriever, contextualize_q_prompt\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch2\u003e전체 QA 체인 구축하기:\u003c/h2\u003e\n\u003cp\u003e마침내, 우리는 리트리버를 히스토리 인식 리트리버로 업데이트하고 \u003ccode\u003ecreate_stuff_documents_chain\u003c/code\u003e을 사용하여 질문-답변 체인을 구축할 것입니다. 이 체인은 검색된 컨텍스트, 채팅 기록 및 사용자 쿼리를 받아 답변을 생성합니다. 그런 다음 \u003ccode\u003ecreate_retrieval_chain\u003c/code\u003e을 사용하여 최종 RAG 체인을 구성합니다. 이 체인은 히스토리 인식 리트리버와 질문-답변 체인을 순차적으로 적용하여 검색된 컨텍스트와 같은 중간 출력을 유지합니다. 이러한 단계를 통해 과거 상호작용을 인식하고 기억하는 강력한 챗봇을 구축했습니다. 이는 사용자와의 원활하고 일관된 대화를 보장합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e### 채팅 기록 상태 관리하기 ###\nstore = {}\n\n# 채팅 기록을 영속적으로 저장하고 있지 않지만, redis에 저장할 수도 있습니다\ndef \u003cspan class=\"hljs-title function_\"\u003eget_session_history\u003c/span\u003e(\u003cspan class=\"hljs-attr\"\u003esession_id\u003c/span\u003e: str) -\u003e \u003cspan class=\"hljs-title class_\"\u003eBaseChatMessageHistory\u003c/span\u003e:\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e session_id not \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estore\u003c/span\u003e:\n        store[session_id] = \u003cspan class=\"hljs-title class_\"\u003eChatMessageHistory\u003c/span\u003e()\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e store[session_id]\n\nconversational_rag_chain = \u003cspan class=\"hljs-title class_\"\u003eRunnableWithMessageHistory\u003c/span\u003e(\n    rag_chain,\n    get_session_history,\n    input_messages_key=\u003cspan class=\"hljs-string\"\u003e\"input\"\u003c/span\u003e,\n    history_messages_key=\u003cspan class=\"hljs-string\"\u003e\"chat_history\"\u003c/span\u003e,\n    output_messages_key=\u003cspan class=\"hljs-string\"\u003e\"answer\"\u003c/span\u003e\n)\n\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e conversational_rag_chain\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e마지막으로, 입력 쿼리를 처리하고 색인된 문서 청크에서 관련 정보를 검색하는 conversational_rag_chain inbuilt 메서드 invoke를 호출할 수 있습니다. 결합된 질문, 컨텍스트 및 프롬프트는 LLM에 전송되어 응답을 생성합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003efile_path = \u003cspan class=\"hljs-string\"\u003e'amazon_2024_10q.pdf'\u003c/span\u003e\nuser_query = \u003cspan class=\"hljs-string\"\u003e\"Amazon의 2024년 Q1 10-Q SEC 보고서에서 보고된 주요 재무 하이라이트 및 중요한 변화는 무엇입니까?\"\u003c/span\u003e\nobj = \u003cspan class=\"hljs-title class_\"\u003eConversationRetrieverAgent\u003c/span\u003e()\nchain = obj.\u003cspan class=\"hljs-title function_\"\u003eprocess_pdf_simple\u003c/span\u003e(file_path)\nresult = chain.\u003cspan class=\"hljs-title function_\"\u003einvoke\u003c/span\u003e({\u003cspan class=\"hljs-string\"\u003e\"input\"\u003c/span\u003e: user_query})\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(result[\u003cspan class=\"hljs-string\"\u003e\"answer\"\u003c/span\u003e])\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eDocuChat 앱은 LangChain 및 검색 확장 생성 (RAG)과 같은 고급 기술을 활용하여 사용자가 데이터를 탐색하고 이해하는 데 편리하게 도와줍니다. 문서를 효율적으로 로드, 분리 및 색인화하고 정교한 검색 및 생성 기술을 활용하여, DocuChat은 사용자 쿼리에 정확하고 컨텍스트에 민감한 답변을 제공할 수 있습니다. 채팅 모델, 프롬프트 템플릿 및 채팅 기록을 통합함으로써 자연스럽고 일관된 대화를 보장합니다. 히스토리 인식 검색 및 견고한 세션 관리를 구현함으로써, DocuChat은 데이터를 더 접근 가능하고 실행 가능하게 만들어 스마트하고 원활한 상호 작용 경험을 제공합니다.\u003c/p\u003e\n\u003ch1\u003e다음 단계?\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이번 시리즈의 다음 부분을 기대해주세요. 다음에는 고급 데이터 전처리와 멀티모달 검색에 대해 자세히 알아볼 것입니다. 이미지와 테이블을 포함한 문서를 어떻게 처리하는지, 이 데이터를 챗봇이 효과적으로 해석하고 활용하는 방법을 다룰 예정입니다. 이는 금융 서비스용 봇을 만들 때 특히 유용하며, SEC와 Bloomberg과 같은 출처에서 받은 금융 시장 데이터를 분석할 수 있게 해줍니다. 이 데이터는 종종 그래프, 지표, 테이블을 포함하고 있습니다. 이러한 통찰력을 놓치지 마시고 챗봇 역량을 향상시키세요!\u003c/p\u003e\n\u003ch1\u003e저자 정보\u003c/h1\u003e\n\u003cp\u003e이 기사를 읽어주셔서 감사합니다! 만약 여기서 논의된 전체 코드베이스를 보거나 완전히 기능하는 챗 앱을 사용해보고 싶다면, 아래 링크를 방문해 주세요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLinkedIn: LinkedIn 프로필\u003c/li\u003e\n\u003cli\u003eGitHub: 이 기사의 전체 코드를 제 GitHub 프로필에서 확인하세요.\u003c/li\u003e\n\u003cli\u003eStreamlit: Streamlit 앱에서 완전히 기능하는 앱과 상호 작용해보세요. 기능을 탐색하고, 질문을 하며, DocuChat이 실시간으로 쿼리에 응답하는 방식을 확인해보세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eLinkedIn에서 업데이트, 토론 및 지적 응용 프로그램 구축에 대한 자세한 통찰력을 얻으세요. 피드백 및 기여는 언제나 환영합니다!\u003c/p\u003e\n\u003cp\u003e참고 자료:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://platform.openai.com/docs/quickstart\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://platform.openai.com/docs/quickstart\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://python.langchain.com/v0.2/docs/tutorials/chatbot/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://python.langchain.com/v0.2/docs/tutorials/chatbot/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.langchain.dev/semi-structured-multi-modal-rag/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://blog.langchain.dev/semi-structured-multi-modal-rag/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.llamaindex.ai/en/stable/getting_started/concepts/\" rel=\"nofollow\" target=\"_blank\"\u003ehttps://docs.llamaindex.ai/en/stable/getting_started/concepts/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-DocuChatEmpoweringYoutoExploreandUnderstandYourDataEffortlesslyPart-1"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>