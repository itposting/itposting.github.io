<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>인공지능의 마법 구슬 신경망이 인플레이션을 예측하는 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="인공지능의 마법 구슬 신경망이 인플레이션을 예측하는 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="인공지능의 마법 구슬 신경망이 인플레이션을 예측하는 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation" data-gatsby-head="true"/><meta name="twitter:title" content="인공지능의 마법 구슬 신경망이 인플레이션을 예측하는 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-20 18:18" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_buildManifest.js" defer=""></script><script src="/_next/static/kkckKPyxcjJp_o8wb2unW/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">인공지능의 마법 구슬 신경망이 인플레이션을 예측하는 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="인공지능의 마법 구슬 신경망이 인플레이션을 예측하는 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 20, 2024</span><span class="posts_reading_time__f7YPP">5<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p><code>&#x3C;img src="/assets/img/2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation_0.png" /></code></p>
<p>인플레이션 예측에 대한 전통적인 방법은 과거 데이터와 복잡한 계량 경제 모델에 크게 의존하지만, 종종 빠르게 변화하는 경제 상황의 세세한 점을 포착하지 못할 때가 있습니다. (일부 우수한 모델을 제외하고) 이제는 신경망, 특히 LSTM 신경망이 예측 분석에 접근하는 방식을 혁신하고 있습니다.</p>
<p>이 기사는 LSTM 모델을 핵심부터 만들고, 미국의 월별 인플레이션 지표 변화를 예측하는 데 사용하는 방법을 보여줍니다.</p>
<h1>LSTM 부트캠프</h1>
<div class="content-ad"></div>
<p>어떤 것을 이해하는 가장 좋은 방법은 단순하게 생각하는 것입니다. 수학이나 복잡한 그래프가 필요하지 않고 순수한 직관과 논리만 있으면 돼요. 책을 읽고 있다고 상상해봐요. 한 장을 넘겨 다음 장으로 넘어갈 때, 이전 장의 중요한 내용을 기억해야 현재 장을 이해할 수 있어요. 이전 장에서의 정보를 상기시킬 수 있는 능력은 이야기를 따라가는 데 도움을 줍니다. 이제 컴퓨터가 이 책을 어떻게 읽을 수 있을지 생각해봐요.</p>
<p>인간과 달리 컴퓨터는 새로운 정보를 처리할 때 이전 정보를 기억하는 데 어려움을 겪는 경향이 있어요 (미래에 우리를 지배하기 전에 컴퓨터들에게 우리의 이점을 남겨둘 수 있어 다행이죠). 여기서 장기 단기 기억망(LSTM) 네트워크가 등장합니다 — 이들은 당신이 책을 읽을 때와 같이 컴퓨터가 중요한 세부 정보를 시간을 초월하여 기억하는 데 도움을 줍니다. 그래서 LSTM 네트워크에서 중요한 키워드는 기억입니다. 하지만 LSTMs가 정말 무엇인가요?</p>
<p>이들은 데이터 시퀀스를 처리하기 위해 설계된 특별한 종류의 인공 신경망입니다. 이들은 오랜 기간동안 정보를 기억하는 문제를 해결하기 위해 만들어졌는데, 일반적인 신경망은 이를 다루기 어렵습니다.</p>
<p>LSTMs는 역사를 공부하면서 중요한 사건을 메모할 수 있는 노트북을 가지고 있는 것과 같아요. 언제든 필요할 때 이러한 노트를 다시 참고하여 이전 정보를 상기시킬 수 있습니다. 이 노트북이 바로 LSTM의 기억입니다.</p>
<div class="content-ad"></div>
<p><code>LSTM</code>의 기능에 대해 이해해야 할 내용이 대부분입니다. 재미있는 세부사항은 전문가들에게 맡기고, 우리의 목표인 기계 학습 알고리즘을 사용한 인플레이션 예측으로 넘어가 보겠습니다.</p>
<h1>LSTM을 이용한 인플레이션 예측</h1>
<p>우선, 분석하려는 데이터 유형을 이해해야 합니다. 미국 소비자 물가지수(CPI)는 도시 소비자가 일상적으로 소비하는 장바구니의 상품 및 서비스에 대한 가격 변동의 평균 변화를 측정하는 중요한 경제 지표입니다. 기본적으로 CPI는 음식, 의류, 주거, 연료, 교통, 의료 서비스 및 사람들이 일상적으로 구입하는 다른 상품 및 서비스에 대한 가격 변동을 모니터링하여 생활비 변동을 추적합니다.</p>
<p>작업 계획은 다음과 같습니다:</p>
<div class="content-ad"></div>
<ul>
<li>필요한 Python 라이브러리 및 미국 세인트루이스 연방준비은행에서 공개한 인플레이션(CPI) 데이터를 가져옵니다.</li>
<li>데이터를 정리하고 훈련 세트와 테스트 세트로 분할합니다.</li>
<li>설명 변수(예측 변수)를 선택합니다. 이 경우 미래 값을 예측하기 위해 과거 값을 사용하는 지연 변화가 사용됩니다. 이는 데이터에서 자기 상관성과 예측 가능성의 형태를 의미합니다.</li>
<li>데이터를 훈련하고 테스트 데이터에서 예측합니다.</li>
<li>정확도(적중률)와 평균 제곱근 오차(RMSE)를 사용하여 모델을 평가합니다.</li>
</ul>
<p>아래 코드를 사용하여 알고리즘을 구현하세요:</p>
<pre><code class="hljs language-js"># 필요한 라이브러리 가져오기
<span class="hljs-keyword">import</span> pandas_datareader <span class="hljs-keyword">as</span> pdr
<span class="hljs-keyword">import</span> matplotlib.<span class="hljs-property">pyplot</span> <span class="hljs-keyword">as</span> plt

# 히스토리컬 데이터의 시작 및 끝 날짜 설정
start_date = <span class="hljs-string">'1950-01-01'</span>
end_date = <span class="hljs-string">'2024-01-23'</span>

# 데이터프레임 생성 및 <span class="hljs-variable constant_">CPI</span> 데이터 다운로드
data = pdr.<span class="hljs-title class_">DataReader</span>(<span class="hljs-string">'CPIAUCSL'</span>, <span class="hljs-string">'fred'</span>, start_date, end_date)

# <span class="hljs-variable constant_">CPI</span> 데이터프레임에 nan 값이 있는지 확인
count_nan = data[<span class="hljs-string">'CPIAUCSL'</span>].<span class="hljs-title function_">isnull</span>().<span class="hljs-title function_">sum</span>()

# 결과 출력
<span class="hljs-title function_">print</span>(<span class="hljs-string">'CPI 데이터프레임에 있는 nan 값의 수: '</span> + <span class="hljs-title function_">str</span>(count_nan))

# <span class="hljs-variable constant_">CPI</span>를 연간 변화율로 변환
data = data.<span class="hljs-title function_">pct_change</span>(periods=<span class="hljs-number">12</span>, axis=<span class="hljs-number">0</span>) * <span class="hljs-number">100</span>

# 행에서 nan 값을 제거
data = data.<span class="hljs-title function_">dropna</span>()

# 라이브러리 가져오기
<span class="hljs-keyword">from</span> keras.<span class="hljs-property">models</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Sequential</span>
<span class="hljs-keyword">from</span> keras.<span class="hljs-property">layers</span> <span class="hljs-keyword">import</span> <span class="hljs-title class_">Dense</span>, <span class="hljs-variable constant_">LSTM</span>
<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np
<span class="hljs-keyword">import</span> pandas_datareader <span class="hljs-keyword">as</span> pdr
<span class="hljs-keyword">from</span> sklearn.<span class="hljs-property">metrics</span> <span class="hljs-keyword">import</span> mean_squared_error

# 데이터 전처리 함수 정의
def <span class="hljs-title function_">data_preprocessing</span>(data, num_lags, train_test_split):
    # 훈련을 위한 데이터 준비
    x = []
    y = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title function_">range</span>(<span class="hljs-title function_">len</span>(data) - num_lags):
        x.<span class="hljs-title function_">append</span>(data[<span class="hljs-attr">i</span>:i + num_lags])
        y.<span class="hljs-title function_">append</span>(data[i + num_lags])
    # 데이터를 넘파이 배열로 변환
    x = np.<span class="hljs-title function_">array</span>(x)
    y = np.<span class="hljs-title function_">array</span>(y)
    # 데이터를 훈련 및 테스트 세트로 분할
    split_index = <span class="hljs-title function_">int</span>(train_test_split * <span class="hljs-title function_">len</span>(x))
    x_train = x[:split_index]
    y_train = y[:split_index]
    x_test = x[<span class="hljs-attr">split_index</span>:]
    y_test = y[<span class="hljs-attr">split_index</span>:]

    <span class="hljs-keyword">return</span> x_train, y_train, x_test, y_test

# 훈련 및 테스트 값을 그래프로 그리는 함수 정의
# 나머지 코드는 생략합니다.
</code></pre>
<p>이 코드는 제가 최신 딥러닝 도서에서 가져온 것입니다.</p>
<div class="content-ad"></div>
<p>플로팅 함수는 다음 차트를 제공해야 합니다:</p>
<p><img src="/assets/img/2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation_1.png" alt="차트"></p>
<p>이전에 정의한 함수를 사용하여 알고리즘을 평가해 봅시다:</p>
<pre><code class="hljs language-js"># 성능 평가
<span class="hljs-title function_">print</span>(<span class="hljs-string">'---'</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">'정확도(학습) = '</span>, <span class="hljs-title function_">round</span>(<span class="hljs-title function_">calculate_accuracy</span>(y_predicted_train, y_train), <span class="hljs-number">2</span>), <span class="hljs-string">'%'</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">'정확도(테스트) = '</span>, <span class="hljs-title function_">round</span>(<span class="hljs-title function_">calculate_accuracy</span>(y_predicted, y_test), <span class="hljs-number">2</span>), <span class="hljs-string">'%'</span>)
<span class="hljs-title function_">print</span>(<span class="hljs-string">'RMSE(학습) = '</span>, <span class="hljs-title function_">round</span>(np.<span class="hljs-title function_">sqrt</span>(<span class="hljs-title function_">mean_squared_error</span>(y_predicted_train, y_train)), <span class="hljs-number">10</span>))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'RMSE(테스트) = '</span>, <span class="hljs-title function_">round</span>(np.<span class="hljs-title function_">sqrt</span>(<span class="hljs-title function_">mean_squared_error</span>(y_predicted, y_test)), <span class="hljs-number">10</span>))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'상관관계(시계열 예측/학습) = '</span>, <span class="hljs-title function_">round</span>(np.<span class="hljs-title function_">corrcoef</span>(np.<span class="hljs-title function_">reshape</span>(y_predicted_train, (-<span class="hljs-number">1</span>)), y_train)[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], <span class="hljs-number">3</span>))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'상관관게(예측/테스트) = '</span>, <span class="hljs-title function_">round</span>(np.<span class="hljs-title function_">corrcoef</span>(np.<span class="hljs-title function_">reshape</span>(y_predicted, (-<span class="hljs-number">1</span>)), np.<span class="hljs-title function_">reshape</span>(y_test, (-<span class="hljs-number">1</span>)))[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], <span class="hljs-number">3</span>))
<span class="hljs-title function_">print</span>(<span class="hljs-string">'---'</span>)
</code></pre>
<div class="content-ad"></div>
<p>이전 코드의 출력은 다음과 같습니다:</p>
<pre><code class="hljs language-js">---
<span class="hljs-title class_">Accuracy</span> <span class="hljs-title class_">Train</span> =  <span class="hljs-number">62.58</span> %
<span class="hljs-title class_">Accuracy</span> <span class="hljs-title class_">Test</span> =  <span class="hljs-number">70.51</span> %
<span class="hljs-variable constant_">RMSE</span> <span class="hljs-title class_">Train</span> =  <span class="hljs-number">0.3287812546</span>
<span class="hljs-variable constant_">RMSE</span> <span class="hljs-title class_">Test</span> =  <span class="hljs-number">0.3275757807</span>
<span class="hljs-title class_">Correlation</span> <span class="hljs-title class_">In</span>-<span class="hljs-title class_">Sample</span> <span class="hljs-title class_">Predicted</span>/<span class="hljs-title class_">Train</span> =  <span class="hljs-number">0.522</span>
<span class="hljs-title class_">Correlation</span> <span class="hljs-title class_">Out</span>-<span class="hljs-keyword">of</span>-<span class="hljs-title class_">Sample</span> <span class="hljs-title class_">Predicted</span>/<span class="hljs-title class_">Test</span> =  <span class="hljs-number">0.509</span>
---
</code></pre>
<p>예측 모델을 개발하고 배포할 때, 특히 금융과 같은 중요한 분야에서는 어떤 모델에 의존하기 전에 광범위한 연구를 수행하는 것이 중요합니다. 꼼꼼히 공부해보세요!</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"인공지능의 마법 구슬 신경망이 인플레이션을 예측하는 방법","description":"","date":"2024-06-20 18:18","slug":"2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation","content":"\n\n`\u003cimg src=\"/assets/img/2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation_0.png\" /\u003e`\n\n인플레이션 예측에 대한 전통적인 방법은 과거 데이터와 복잡한 계량 경제 모델에 크게 의존하지만, 종종 빠르게 변화하는 경제 상황의 세세한 점을 포착하지 못할 때가 있습니다. (일부 우수한 모델을 제외하고) 이제는 신경망, 특히 LSTM 신경망이 예측 분석에 접근하는 방식을 혁신하고 있습니다.\n\n이 기사는 LSTM 모델을 핵심부터 만들고, 미국의 월별 인플레이션 지표 변화를 예측하는 데 사용하는 방법을 보여줍니다.\n\n# LSTM 부트캠프\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n어떤 것을 이해하는 가장 좋은 방법은 단순하게 생각하는 것입니다. 수학이나 복잡한 그래프가 필요하지 않고 순수한 직관과 논리만 있으면 돼요. 책을 읽고 있다고 상상해봐요. 한 장을 넘겨 다음 장으로 넘어갈 때, 이전 장의 중요한 내용을 기억해야 현재 장을 이해할 수 있어요. 이전 장에서의 정보를 상기시킬 수 있는 능력은 이야기를 따라가는 데 도움을 줍니다. 이제 컴퓨터가 이 책을 어떻게 읽을 수 있을지 생각해봐요.\n\n인간과 달리 컴퓨터는 새로운 정보를 처리할 때 이전 정보를 기억하는 데 어려움을 겪는 경향이 있어요 (미래에 우리를 지배하기 전에 컴퓨터들에게 우리의 이점을 남겨둘 수 있어 다행이죠). 여기서 장기 단기 기억망(LSTM) 네트워크가 등장합니다 — 이들은 당신이 책을 읽을 때와 같이 컴퓨터가 중요한 세부 정보를 시간을 초월하여 기억하는 데 도움을 줍니다. 그래서 LSTM 네트워크에서 중요한 키워드는 기억입니다. 하지만 LSTMs가 정말 무엇인가요?\n\n이들은 데이터 시퀀스를 처리하기 위해 설계된 특별한 종류의 인공 신경망입니다. 이들은 오랜 기간동안 정보를 기억하는 문제를 해결하기 위해 만들어졌는데, 일반적인 신경망은 이를 다루기 어렵습니다.\n\nLSTMs는 역사를 공부하면서 중요한 사건을 메모할 수 있는 노트북을 가지고 있는 것과 같아요. 언제든 필요할 때 이러한 노트를 다시 참고하여 이전 정보를 상기시킬 수 있습니다. 이 노트북이 바로 LSTM의 기억입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n`LSTM`의 기능에 대해 이해해야 할 내용이 대부분입니다. 재미있는 세부사항은 전문가들에게 맡기고, 우리의 목표인 기계 학습 알고리즘을 사용한 인플레이션 예측으로 넘어가 보겠습니다.\n\n# LSTM을 이용한 인플레이션 예측\n\n우선, 분석하려는 데이터 유형을 이해해야 합니다. 미국 소비자 물가지수(CPI)는 도시 소비자가 일상적으로 소비하는 장바구니의 상품 및 서비스에 대한 가격 변동의 평균 변화를 측정하는 중요한 경제 지표입니다. 기본적으로 CPI는 음식, 의류, 주거, 연료, 교통, 의료 서비스 및 사람들이 일상적으로 구입하는 다른 상품 및 서비스에 대한 가격 변동을 모니터링하여 생활비 변동을 추적합니다.\n\n작업 계획은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 필요한 Python 라이브러리 및 미국 세인트루이스 연방준비은행에서 공개한 인플레이션(CPI) 데이터를 가져옵니다.\n- 데이터를 정리하고 훈련 세트와 테스트 세트로 분할합니다.\n- 설명 변수(예측 변수)를 선택합니다. 이 경우 미래 값을 예측하기 위해 과거 값을 사용하는 지연 변화가 사용됩니다. 이는 데이터에서 자기 상관성과 예측 가능성의 형태를 의미합니다.\n- 데이터를 훈련하고 테스트 데이터에서 예측합니다.\n- 정확도(적중률)와 평균 제곱근 오차(RMSE)를 사용하여 모델을 평가합니다.\n\n아래 코드를 사용하여 알고리즘을 구현하세요:\n\n```js\n# 필요한 라이브러리 가져오기\nimport pandas_datareader as pdr\nimport matplotlib.pyplot as plt\n\n# 히스토리컬 데이터의 시작 및 끝 날짜 설정\nstart_date = '1950-01-01'\nend_date = '2024-01-23'\n\n# 데이터프레임 생성 및 CPI 데이터 다운로드\ndata = pdr.DataReader('CPIAUCSL', 'fred', start_date, end_date)\n\n# CPI 데이터프레임에 nan 값이 있는지 확인\ncount_nan = data['CPIAUCSL'].isnull().sum()\n\n# 결과 출력\nprint('CPI 데이터프레임에 있는 nan 값의 수: ' + str(count_nan))\n\n# CPI를 연간 변화율로 변환\ndata = data.pct_change(periods=12, axis=0) * 100\n\n# 행에서 nan 값을 제거\ndata = data.dropna()\n\n# 라이브러리 가져오기\nfrom keras.models import Sequential\nfrom keras.layers import Dense, LSTM\nimport numpy as np\nimport pandas_datareader as pdr\nfrom sklearn.metrics import mean_squared_error\n\n# 데이터 전처리 함수 정의\ndef data_preprocessing(data, num_lags, train_test_split):\n    # 훈련을 위한 데이터 준비\n    x = []\n    y = []\n    for i in range(len(data) - num_lags):\n        x.append(data[i:i + num_lags])\n        y.append(data[i + num_lags])\n    # 데이터를 넘파이 배열로 변환\n    x = np.array(x)\n    y = np.array(y)\n    # 데이터를 훈련 및 테스트 세트로 분할\n    split_index = int(train_test_split * len(x))\n    x_train = x[:split_index]\n    y_train = y[:split_index]\n    x_test = x[split_index:]\n    y_test = y[split_index:]\n\n    return x_train, y_train, x_test, y_test\n\n# 훈련 및 테스트 값을 그래프로 그리는 함수 정의\n# 나머지 코드는 생략합니다.\n``` \n\n이 코드는 제가 최신 딥러닝 도서에서 가져온 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플로팅 함수는 다음 차트를 제공해야 합니다:\n\n![차트](/assets/img/2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation_1.png)\n\n이전에 정의한 함수를 사용하여 알고리즘을 평가해 봅시다:\n\n```js\n# 성능 평가\nprint('---')\nprint('정확도(학습) = ', round(calculate_accuracy(y_predicted_train, y_train), 2), '%')\nprint('정확도(테스트) = ', round(calculate_accuracy(y_predicted, y_test), 2), '%')\nprint('RMSE(학습) = ', round(np.sqrt(mean_squared_error(y_predicted_train, y_train)), 10))\nprint('RMSE(테스트) = ', round(np.sqrt(mean_squared_error(y_predicted, y_test)), 10))\nprint('상관관계(시계열 예측/학습) = ', round(np.corrcoef(np.reshape(y_predicted_train, (-1)), y_train)[0][1], 3))\nprint('상관관게(예측/테스트) = ', round(np.corrcoef(np.reshape(y_predicted, (-1)), np.reshape(y_test, (-1)))[0][1], 3))\nprint('---')\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이전 코드의 출력은 다음과 같습니다:\n\n```js\n---\nAccuracy Train =  62.58 %\nAccuracy Test =  70.51 %\nRMSE Train =  0.3287812546\nRMSE Test =  0.3275757807\nCorrelation In-Sample Predicted/Train =  0.522\nCorrelation Out-of-Sample Predicted/Test =  0.509\n---\n```\n\n예측 모델을 개발하고 배포할 때, 특히 금융과 같은 중요한 분야에서는 어떤 모델에 의존하기 전에 광범위한 연구를 수행하는 것이 중요합니다. 꼼꼼히 공부해보세요!","ogImage":{"url":"/assets/img/2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation_0.png"},"coverImage":"/assets/img/2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation_0.png","tag":["Tech"],"readingTime":5},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e\u003ccode\u003e\u0026#x3C;img src=\"/assets/img/2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation_0.png\" /\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e인플레이션 예측에 대한 전통적인 방법은 과거 데이터와 복잡한 계량 경제 모델에 크게 의존하지만, 종종 빠르게 변화하는 경제 상황의 세세한 점을 포착하지 못할 때가 있습니다. (일부 우수한 모델을 제외하고) 이제는 신경망, 특히 LSTM 신경망이 예측 분석에 접근하는 방식을 혁신하고 있습니다.\u003c/p\u003e\n\u003cp\u003e이 기사는 LSTM 모델을 핵심부터 만들고, 미국의 월별 인플레이션 지표 변화를 예측하는 데 사용하는 방법을 보여줍니다.\u003c/p\u003e\n\u003ch1\u003eLSTM 부트캠프\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e어떤 것을 이해하는 가장 좋은 방법은 단순하게 생각하는 것입니다. 수학이나 복잡한 그래프가 필요하지 않고 순수한 직관과 논리만 있으면 돼요. 책을 읽고 있다고 상상해봐요. 한 장을 넘겨 다음 장으로 넘어갈 때, 이전 장의 중요한 내용을 기억해야 현재 장을 이해할 수 있어요. 이전 장에서의 정보를 상기시킬 수 있는 능력은 이야기를 따라가는 데 도움을 줍니다. 이제 컴퓨터가 이 책을 어떻게 읽을 수 있을지 생각해봐요.\u003c/p\u003e\n\u003cp\u003e인간과 달리 컴퓨터는 새로운 정보를 처리할 때 이전 정보를 기억하는 데 어려움을 겪는 경향이 있어요 (미래에 우리를 지배하기 전에 컴퓨터들에게 우리의 이점을 남겨둘 수 있어 다행이죠). 여기서 장기 단기 기억망(LSTM) 네트워크가 등장합니다 — 이들은 당신이 책을 읽을 때와 같이 컴퓨터가 중요한 세부 정보를 시간을 초월하여 기억하는 데 도움을 줍니다. 그래서 LSTM 네트워크에서 중요한 키워드는 기억입니다. 하지만 LSTMs가 정말 무엇인가요?\u003c/p\u003e\n\u003cp\u003e이들은 데이터 시퀀스를 처리하기 위해 설계된 특별한 종류의 인공 신경망입니다. 이들은 오랜 기간동안 정보를 기억하는 문제를 해결하기 위해 만들어졌는데, 일반적인 신경망은 이를 다루기 어렵습니다.\u003c/p\u003e\n\u003cp\u003eLSTMs는 역사를 공부하면서 중요한 사건을 메모할 수 있는 노트북을 가지고 있는 것과 같아요. 언제든 필요할 때 이러한 노트를 다시 참고하여 이전 정보를 상기시킬 수 있습니다. 이 노트북이 바로 LSTM의 기억입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eLSTM\u003c/code\u003e의 기능에 대해 이해해야 할 내용이 대부분입니다. 재미있는 세부사항은 전문가들에게 맡기고, 우리의 목표인 기계 학습 알고리즘을 사용한 인플레이션 예측으로 넘어가 보겠습니다.\u003c/p\u003e\n\u003ch1\u003eLSTM을 이용한 인플레이션 예측\u003c/h1\u003e\n\u003cp\u003e우선, 분석하려는 데이터 유형을 이해해야 합니다. 미국 소비자 물가지수(CPI)는 도시 소비자가 일상적으로 소비하는 장바구니의 상품 및 서비스에 대한 가격 변동의 평균 변화를 측정하는 중요한 경제 지표입니다. 기본적으로 CPI는 음식, 의류, 주거, 연료, 교통, 의료 서비스 및 사람들이 일상적으로 구입하는 다른 상품 및 서비스에 대한 가격 변동을 모니터링하여 생활비 변동을 추적합니다.\u003c/p\u003e\n\u003cp\u003e작업 계획은 다음과 같습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e필요한 Python 라이브러리 및 미국 세인트루이스 연방준비은행에서 공개한 인플레이션(CPI) 데이터를 가져옵니다.\u003c/li\u003e\n\u003cli\u003e데이터를 정리하고 훈련 세트와 테스트 세트로 분할합니다.\u003c/li\u003e\n\u003cli\u003e설명 변수(예측 변수)를 선택합니다. 이 경우 미래 값을 예측하기 위해 과거 값을 사용하는 지연 변화가 사용됩니다. 이는 데이터에서 자기 상관성과 예측 가능성의 형태를 의미합니다.\u003c/li\u003e\n\u003cli\u003e데이터를 훈련하고 테스트 데이터에서 예측합니다.\u003c/li\u003e\n\u003cli\u003e정확도(적중률)와 평균 제곱근 오차(RMSE)를 사용하여 모델을 평가합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e아래 코드를 사용하여 알고리즘을 구현하세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 필요한 라이브러리 가져오기\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas_datareader \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pdr\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e matplotlib.\u003cspan class=\"hljs-property\"\u003epyplot\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e plt\n\n# 히스토리컬 데이터의 시작 및 끝 날짜 설정\nstart_date = \u003cspan class=\"hljs-string\"\u003e'1950-01-01'\u003c/span\u003e\nend_date = \u003cspan class=\"hljs-string\"\u003e'2024-01-23'\u003c/span\u003e\n\n# 데이터프레임 생성 및 \u003cspan class=\"hljs-variable constant_\"\u003eCPI\u003c/span\u003e 데이터 다운로드\ndata = pdr.\u003cspan class=\"hljs-title class_\"\u003eDataReader\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'CPIAUCSL'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'fred'\u003c/span\u003e, start_date, end_date)\n\n# \u003cspan class=\"hljs-variable constant_\"\u003eCPI\u003c/span\u003e 데이터프레임에 nan 값이 있는지 확인\ncount_nan = data[\u003cspan class=\"hljs-string\"\u003e'CPIAUCSL'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eisnull\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003esum\u003c/span\u003e()\n\n# 결과 출력\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'CPI 데이터프레임에 있는 nan 값의 수: '\u003c/span\u003e + \u003cspan class=\"hljs-title function_\"\u003estr\u003c/span\u003e(count_nan))\n\n# \u003cspan class=\"hljs-variable constant_\"\u003eCPI\u003c/span\u003e를 연간 변화율로 변환\ndata = data.\u003cspan class=\"hljs-title function_\"\u003epct_change\u003c/span\u003e(periods=\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e, axis=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) * \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e\n\n# 행에서 nan 값을 제거\ndata = data.\u003cspan class=\"hljs-title function_\"\u003edropna\u003c/span\u003e()\n\n# 라이브러리 가져오기\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e keras.\u003cspan class=\"hljs-property\"\u003emodels\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSequential\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e keras.\u003cspan class=\"hljs-property\"\u003elayers\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDense\u003c/span\u003e, \u003cspan class=\"hljs-variable constant_\"\u003eLSTM\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e numpy \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e np\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas_datareader \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pdr\n\u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e sklearn.\u003cspan class=\"hljs-property\"\u003emetrics\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e mean_squared_error\n\n# 데이터 전처리 함수 정의\ndef \u003cspan class=\"hljs-title function_\"\u003edata_preprocessing\u003c/span\u003e(data, num_lags, train_test_split):\n    # 훈련을 위한 데이터 준비\n    x = []\n    y = []\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e i \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erange\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(data) - num_lags):\n        x.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(data[\u003cspan class=\"hljs-attr\"\u003ei\u003c/span\u003e:i + num_lags])\n        y.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(data[i + num_lags])\n    # 데이터를 넘파이 배열로 변환\n    x = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(x)\n    y = np.\u003cspan class=\"hljs-title function_\"\u003earray\u003c/span\u003e(y)\n    # 데이터를 훈련 및 테스트 세트로 분할\n    split_index = \u003cspan class=\"hljs-title function_\"\u003eint\u003c/span\u003e(train_test_split * \u003cspan class=\"hljs-title function_\"\u003elen\u003c/span\u003e(x))\n    x_train = x[:split_index]\n    y_train = y[:split_index]\n    x_test = x[\u003cspan class=\"hljs-attr\"\u003esplit_index\u003c/span\u003e:]\n    y_test = y[\u003cspan class=\"hljs-attr\"\u003esplit_index\u003c/span\u003e:]\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e x_train, y_train, x_test, y_test\n\n# 훈련 및 테스트 값을 그래프로 그리는 함수 정의\n# 나머지 코드는 생략합니다.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 제가 최신 딥러닝 도서에서 가져온 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e플로팅 함수는 다음 차트를 제공해야 합니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation_1.png\" alt=\"차트\"\u003e\u003c/p\u003e\n\u003cp\u003e이전에 정의한 함수를 사용하여 알고리즘을 평가해 봅시다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 성능 평가\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'---'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'정확도(학습) = '\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003eround\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ecalculate_accuracy\u003c/span\u003e(y_predicted_train, y_train), \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e), \u003cspan class=\"hljs-string\"\u003e'%'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'정확도(테스트) = '\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003eround\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ecalculate_accuracy\u003c/span\u003e(y_predicted, y_test), \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e), \u003cspan class=\"hljs-string\"\u003e'%'\u003c/span\u003e)\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'RMSE(학습) = '\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003eround\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003emean_squared_error\u003c/span\u003e(y_predicted_train, y_train)), \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'RMSE(테스트) = '\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003eround\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003esqrt\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003emean_squared_error\u003c/span\u003e(y_predicted, y_test)), \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'상관관계(시계열 예측/학습) = '\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003eround\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003ecorrcoef\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(y_predicted_train, (-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)), y_train)[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'상관관게(예측/테스트) = '\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003eround\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003ecorrcoef\u003c/span\u003e(np.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(y_predicted, (-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)), np.\u003cspan class=\"hljs-title function_\"\u003ereshape\u003c/span\u003e(y_test, (-\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)))[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e][\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e))\n\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'---'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이전 코드의 출력은 다음과 같습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e---\n\u003cspan class=\"hljs-title class_\"\u003eAccuracy\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTrain\u003c/span\u003e =  \u003cspan class=\"hljs-number\"\u003e62.58\u003c/span\u003e %\n\u003cspan class=\"hljs-title class_\"\u003eAccuracy\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e =  \u003cspan class=\"hljs-number\"\u003e70.51\u003c/span\u003e %\n\u003cspan class=\"hljs-variable constant_\"\u003eRMSE\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTrain\u003c/span\u003e =  \u003cspan class=\"hljs-number\"\u003e0.3287812546\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eRMSE\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e =  \u003cspan class=\"hljs-number\"\u003e0.3275757807\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eCorrelation\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIn\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eSample\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePredicted\u003c/span\u003e/\u003cspan class=\"hljs-title class_\"\u003eTrain\u003c/span\u003e =  \u003cspan class=\"hljs-number\"\u003e0.522\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eCorrelation\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOut\u003c/span\u003e-\u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eSample\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePredicted\u003c/span\u003e/\u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e =  \u003cspan class=\"hljs-number\"\u003e0.509\u003c/span\u003e\n---\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e예측 모델을 개발하고 배포할 때, 특히 금융과 같은 중요한 분야에서는 어떤 모델에 의존하기 전에 광범위한 연구를 수행하는 것이 중요합니다. 꼼꼼히 공부해보세요!\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-20-AIsCrystalBallHowNeuralNetworksForecastInflation"},"buildId":"kkckKPyxcjJp_o8wb2unW","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>