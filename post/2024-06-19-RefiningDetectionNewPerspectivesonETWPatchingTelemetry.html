<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>탐지 개선 ETW 패치 텔레미트리에 대한 새로운 관점 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="탐지 개선 ETW 패치 텔레미트리에 대한 새로운 관점 | itposting" data-gatsby-head="true"/><meta property="og:title" content="탐지 개선 ETW 패치 텔레미트리에 대한 새로운 관점 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry" data-gatsby-head="true"/><meta name="twitter:title" content="탐지 개선 ETW 패치 텔레미트리에 대한 새로운 관점 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 09:11" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">탐지 개선 ETW 패치 텔레미트리에 대한 새로운 관점</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="탐지 개선 ETW 패치 텔레미트리에 대한 새로운 관점" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">7<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>소개</h1>
<p>얼마 전에 'ETW 패치 이해하기'라는 블로그를 썼는데, 그 글에서 ETW 패칭이 함수 패치의 초고도 버전이라는 내용을 설명했어. Defenders 부분에서는 프로세스 내에서 공급자 DLL이 로드되었지만 ETW 이벤트가 발생하지 않는 걸 볼 수 있는 방법에 대해 언급했어. 이 방법은 특정 공급자에 대해서만 작동해서 좋은 방법은 아니야. 이 초기 생각에 대해 더 알고 싶다면 <a href="%EB%A7%81%ED%81%AC">요 트윗</a>을 참조해봐. 그 이후로 좀 더 깊게 파보았고, 이번 글에서는 이 접근 방식에 대해 이야기할 거야.</p>
<h1>로컬 ETW 패칭</h1>
<p>이전 글에서 언급했듯이, 이벤트 발생을 막는 일반적인 방법 중 하나는 ntdll 함수인 특히 EtwEventWrite 또는 NtTraceEvent에 초점을 맞추는 것이야. 이를 수행하는 단계는 다음과 같아:</p>
<div class="content-ad"></div>
<ul>
<li>DLL 로딩: 이미 로드되지 않은 경우, 함수를 패치하고 싶은 DLL을 로드하세요.</li>
<li>함수 포인터 획득: 원하는 함수에 대한 함수 포인터를 가져오세요.</li>
<li>메모리 보호 변경: 쓰기 액세스를 허용하기 위해 메모리 영역의 보호 값을 변경하세요.</li>
<li>패치 적용: 패치를 작성하세요.</li>
<li>메모리 보호 복원: 선택적으로, 메모리 영역의 보호 값을 원래 설정으로 돌려놓으세요.</li>
</ul>
<p>원하는 함수에 대한 함수 포인터를 획들한 후, 이러한 바이트를 임의로 패치할 수 없다는 것을 알 수 있습니다. 각 함수의 메모리 주소의 보호 수준을 먼저 변경해야합니다. 이러한 함수가 메모리 영역에 대한 쓰기 권한이 있는 경우 가능할 것입니다. 하지만 곧 보게 될 것처럼, 그렇지 않습니다.</p>
<p>메모리 영역은 수행할 수 있는 작업을 제한하는 보호 상수를 가지고 있습니다. 이러한 함수들에 대해서는 해당 메모리 섹션에 쓰기가 지원되지 않음을 볼 수 있습니다. 아래에서 이러한 함수들의 메모리 영역 보호 값이 표시됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-number">0</span>:<span class="hljs-number">012</span>> !vprot ntdll!<span class="hljs-title class_">EtwEventWrite</span>
<span class="hljs-title class_">BaseAddress</span>: 00007ffaafbbf000
<span class="hljs-title class_">AllocationBase</span>: 00007ffaafb90000
<span class="hljs-title class_">AllocationProtect</span>: <span class="hljs-number">00000080</span> <span class="hljs-variable constant_">PAGE_EXECUTE_WRITECOPY</span>
<span class="hljs-title class_">RegionSize</span>: <span class="hljs-number">0000000000103000</span>
<span class="hljs-title class_">State</span>: <span class="hljs-number">00001000</span> <span class="hljs-variable constant_">MEM_COMMIT</span>
<span class="hljs-title class_">Protect</span>: <span class="hljs-number">00000020</span> <span class="hljs-variable constant_">PAGE_EXECUTE_READ</span>
<span class="hljs-title class_">Type</span>: <span class="hljs-number">01000000</span> <span class="hljs-variable constant_">MEM_IMAGE</span>

<span class="hljs-number">0</span>:<span class="hljs-number">012</span>> !vprot ntdll!<span class="hljs-title class_">NtTraceEvent</span>
<span class="hljs-title class_">BaseAddress</span>: 00007ffaafc30000
<span class="hljs-title class_">AllocationBase</span>: 00007ffaafb90000
<span class="hljs-title class_">AllocationProtect</span>: <span class="hljs-number">00000080</span> <span class="hljs-variable constant_">PAGE_EXECUTE_WRITECOPY</span>
<span class="hljs-title class_">RegionSize</span>: <span class="hljs-number">0000000000092000</span>
<span class="hljs-title class_">State</span>: <span class="hljs-number">00001000</span> <span class="hljs-variable constant_">MEM_COMMIT</span>
<span class="hljs-title class_">Protect</span>: <span class="hljs-number">00000020</span> <span class="hljs-variable constant_">PAGE_EXECUTE_READ</span>
<span class="hljs-title class_">Type</span>: <span class="hljs-number">01000000</span> <span class="hljs-variable constant_">MEM_IMAGE</span>
</code></pre>
<div class="content-ad"></div>
<p>위의 내용은 코드가 읽히고 실행되지만 작성되지는 않음을 의미합니다. 따라서 이러한 함수 중 하나를 수정할 때 보호 값이 변경되어야 합니다. 일반적으로 PAGE_EXECUTE_READWRITE (0x40/60)로 변경하여 VirtualProtect를 사용합니다. VirtualProtect 작업 이전에 수집된 텔레메트리는 함수 패치의 신뢰할 수 있는 지표가 아닐 수 있습니다. VirtualProtect 작업조차 직접적인 함수 패치를 나타내지는 않습니다. 그러나 VirtualProtect에 대한 텔레메트리 데이터가 있는 경우, 해당 메타데이터에서 함수 패치가 발생했는지 추측하는 데 충분한 맥락을 제공할 수 있습니다.</p>
<p>ETW 위협 인텔리전스 프로바이더 내에는 THREATINT_PROTECTVM_LOCAL (EID: 7)라는 이벤트가 있습니다. 이 이벤트는 VirtualProtect가 로컬에서 수행될 때 텔레메트리 정보를 제공하는 것으로 보입니다. TelemetrySource 프로젝트를 살펴보거나 EtwInspector를 실행하여 이를 확인할 수 있습니다:</p>
<p><img src="/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_0.png" alt="이미지"></p>
<p>더 깊이 조사한 결과로 메모리 영역의 보호 수준을 변경하는 경우에 대한 이벤트가 있음을 확인할 수 있습니다.</p>
<div class="content-ad"></div>
<p>사전 패치: 보호 값이 PAGE_EXECUTE_READ(0x20)에서 PAGE_EXECUTE_READWRITE(0x40)로 변경되었습니다.</p>
<p><img src="/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_1.png" alt="이미지"></p>
<p>이 이벤트에는 몇 가지 귀중한 정보가 있습니다:</p>
<ul>
<li>BaseAddress — 보호 값이 변경된 메모리 주소입니다.</li>
<li>RegionSize Value — 2. 여기서는 보호가 변경된 바이트가 2개임을 보여줍니다. 이것은 보통 4096 또는 그 이상인데, 이 값이 낮은 것이 불통입니다. 또 내용을 찾아보니 이 값이 (0xc3, 0x00)으로 변경되었을 때이며 이 값은 x64 시스템에서 반환값입니다.</li>
<li>ProtectionMask — 값이 PAGE_EXECUTE_READWRITE로 변경되었음을 나타냅니다.</li>
<li>Last ProtectionMask — 값이 PAGE_EXECUTE_READ에서 변경되었음을 나타냅니다.</li>
<li>Callstack — VirtualProtect가 호출된 것을 보여줍니다.</li>
</ul>
<div class="content-ad"></div>
<p>포스트 패치: 페이지 보호 값을 PAGE_EXECUTE_READWRITE(0x20)에서 PAGE_EXECUTE_READ(0x40)으로 변경합니다.</p>
<p><img src="/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_2.png" alt="이미지"></p>
<p>포스트 보호 값이 반드시 이루어질 필요는 없습니다. 그러나 보호 값이 한 값에서 다른 값으로 변경된 시기를 알고 싶어하는 사람이 있다면 좋은 신호입니다. 이는 누군가가 한 값으로 변경한 다음 다시 다른 값으로 바꾸는 것은 매우 이상하다는 것을 의미합니다. 실제로 변경된 바이트를 볼 수 없기 때문에 이것은 잘못된 양성 결과를 방지하는 데 도움이 될 수 있습니다.</p>
<p>이제 아마도 당신은 생각할 것입니다 — 실제 바이트 패치는 어떻게 할까요? 처음에는 WriteProcessMemory 함수가 작동할 것이라고 생각했지만, C 함수를 호출할 때 — memcpy/memmove 함수가 실제로 WriteProcessMemory를 호출하지 않는다는 사실을 깨달았습니다. 원격 패치에 대해 아래에서 계속 탐구할 것입니다.</p>
<div class="content-ad"></div>
<h1>탐지 아이디어:</h1>
<ul>
<li>
<p>이벤트 ID 7을 수집합니다: Local Virtual Protect — 초기 ProtectionMask 변경</p>
</li>
<li>
<p>관심 있는 함수들에서 패치된 바이트의 공통 숫자(RegionSize 값)를 찾아보세요. x64/x86의 경우 EtwEventWrite와 같은 함수에서 패치된 바이트의 수는 종종 2입니다. 이는 함수가 실행된 후 반환 값이 패치되기 때문입니다.</p>
</li>
<li>
<p>New ProtectionMask가 PAGE_READWRITE (0x04) 또는 PAGE_EXECUTE_READWRITE (0x40)로 열렸을 때를 확인해보세요.</p>
</li>
</ul>
<ol start="2">
<li>이벤트 ID 7을 수집합니다: Local Virtual Protect — ProtectionMask 복원</li>
</ol>
<div class="content-ad"></div>
<ul>
<li>누군가가 보호 값을 다시 원래 값으로 변경할 필요는 없지만, 일반적으로 그렇게 하는 것이 좋습니다. 보호 마스크를 더 엄격한 0x20에서 0x40로 변경한 다음 다시 0x20으로 변경되는 것을 보면 꽤 의심스럽습니다. 따라서 동일한 메모리 주소에서 보호 마스크가 계속 왔다갔다 하면 2 EID 7을 검사하는 것이 높은 결과를 얻을 수 있을 것입니다.</li>
</ul>
<h1>원격 ETW 패치</h1>
<p>원격 패치는 더 드물지만, 듣보잡은 아니며 이에 대한 좋은 프로젝트는 RemotePatcher입니다. 이는 원격 함수 패치를 수행하는 것이 더 위험하기 때문에 감지될 가능성이 높기 때문입니다. memcpy/memmove는 원격 프로세스 내에서 바이트를 쓰는 것을 지원하지 않기 때문에 WriteProcessMemory를 사용해야 하며, RemotePatcher는 patchAMSI 함수에서 이 작업을 수행합니다.</p>
<p><img src="/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_3.png" alt="이미지"></p>
<div class="content-ad"></div>
<p>지금, 우리는 NtProtectVirtualMemory가 두 번 호출된 것을 볼 수 있습니다. 한 번은 보호 값을 PAGE_READWRITE(0x04)로 변경하고 다시 원래 값으로 변경하기 위해 호출됩니다. 차이점은 NtWriteVirtualMemory가 호출된다는 것입니다. TelemetrySource 내부에서 event ID 14로 이어진다는 것을 알 수 있습니다. 이것을 살펴보겠습니다:</p>
<p><img src="/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_4.png" alt="이미지"></p>
<p>위에 표시된 이벤트들이 멋진 점은 원격 프로세스에 액세스한 프로세스가 있고, 메모리 영역의 보호 값을 변경하고 대상 프로세스에 데이터를 쓰고 다시 보호 값을 변경했다는 것이 명백하다는 것입니다. 이러한 연산 순서는 Windows에서 빈번하게 발생하지 않습니다.</p>
<h1>탐지 아이디어:</h1>
<div class="content-ad"></div>
<ul>
<li>
<p>이벤트 ID 2를 수집하세요: 원격 가상 보호 — 초기 ProtectionMask 변경</p>
</li>
<li>
<p>New ProtectionMask가 PAGE_READWRITE (0x04) 또는 PAGE_EXECUTE_READWRITE (0x40)로 열렸을 때를 찾아보세요.</p>
</li>
</ul>
<ol start="2">
<li>이벤트 ID 2를 수집하세요: 원격 가상 보호 — ProtectionMask 되돌리기</li>
</ol>
<ul>
<li>누군가는 보호 값을 원래 값으로 되돌릴 필요는 없지만, 이는 일반적인 관행입니다. 보호 마스크가 0x20처럼 더 많이 잠긴 마스크에서 0x40로 변경되고 다시 0x20으로 돌아가는 것을 보는 것은 상당히 수상합니다. 따라서 동일한 메모리 주소의 보호 마스크가 그렇게 왔다갔다하는 2개의 EID 2를 주시하면 높은 결과를 얻을 수 있을 겁니다.</li>
</ul>
<div class="content-ad"></div>
<ol start="3">
<li>이벤트 ID 14를 수집하세요: 프로세스 메모리 쓰기 - 패치용 바이트를 기록</li>
</ol>
<ul>
<li>이를 원격 VirtualProtect가 메모리 쓰기 전후에 수행되는 상황에서 관찰하는 것은 의심스러울 수 있습니다.</li>
<li>이것이 ETW 패칭인지에 대해 분간하기가 어려울 수 있지만, 이것은 어쨌든 프로세스 주입 가시성에 사용될 수 있습니다. 기술적으로 이것은 데이터가 대상 프로세스에 쓰여지기 때문에 프로세스 주입으로 간주될 수 있습니다.</li>
</ul>
<h1>결론</h1>
<p>이 포스트에서는 ETW 패칭 및 이 활동을 관찰하는 실용적인 접근 방식을 간단히 탐색하고자 했습니다. 로컬 패칭이 원격 패칭보다 훨씬 더 흔합니다. 유감스럽게도, memcpy와 memmove는 WriteProcessMemory를 호출하지 않기 때문에 로컬에서 실제 패치를 식별하는 것은 매우 어렵습니다. 그러나 패치가 발생할 메모리 영역의 보호 마스크에 대한 변경을 감지하는 것은 여전히 좋은 지표로 남아 있습니다.</p>
<div class="content-ad"></div>
<p>이 보호 마스크가 읽기/실행에서 읽기/쓰기/실행으로 변경되는 것은 흔하지 않습니다. 또한, 이러한 이벤트에서 바뀌는 바이트 수는 보통 다른 일반적인 VirtualProtect 이벤트보다 낮습니다. 일반적으로 4096바이트 이상이 관련된 것들이 대부분입니다. RemotePatcher에서 볼 수 있듯이, 누군가가 4096바이트 메모리 영역의 보호 값 변경을 위해 조용히 하는 경우가 있습니다.</p>
<p>만약 이 방식을 구현하고 싶다면, 데이터를 분석하여 연속적으로 여러 작업이 발생하는 패턴을 식별하는 것을 권장합니다. 또한, 공격자가 변경할 수 있는 모든 가능한 보호 값과 함께 쓰기 권한을 포함하는 것들을 모두 살펴보세요. 이 정보가 도움이 되었기를 바랍니다. 아이디어를 공유하거나 질문이 있으면 언제든지 연락 주세요.</p>
<p>Arash Parsa에게 연락해주고 다시 이 주제를 재방문하고 문서화하도록 하도록 도와준 것에 감사드립니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"탐지 개선 ETW 패치 텔레미트리에 대한 새로운 관점","description":"","date":"2024-06-19 09:11","slug":"2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry","content":"\n\n# 소개\n\n얼마 전에 'ETW 패치 이해하기'라는 블로그를 썼는데, 그 글에서 ETW 패칭이 함수 패치의 초고도 버전이라는 내용을 설명했어. Defenders 부분에서는 프로세스 내에서 공급자 DLL이 로드되었지만 ETW 이벤트가 발생하지 않는 걸 볼 수 있는 방법에 대해 언급했어. 이 방법은 특정 공급자에 대해서만 작동해서 좋은 방법은 아니야. 이 초기 생각에 대해 더 알고 싶다면 [요 트윗](링크)을 참조해봐. 그 이후로 좀 더 깊게 파보았고, 이번 글에서는 이 접근 방식에 대해 이야기할 거야.\n\n# 로컬 ETW 패칭\n\n이전 글에서 언급했듯이, 이벤트 발생을 막는 일반적인 방법 중 하나는 ntdll 함수인 특히 EtwEventWrite 또는 NtTraceEvent에 초점을 맞추는 것이야. 이를 수행하는 단계는 다음과 같아:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- DLL 로딩: 이미 로드되지 않은 경우, 함수를 패치하고 싶은 DLL을 로드하세요.\n- 함수 포인터 획득: 원하는 함수에 대한 함수 포인터를 가져오세요.\n- 메모리 보호 변경: 쓰기 액세스를 허용하기 위해 메모리 영역의 보호 값을 변경하세요.\n- 패치 적용: 패치를 작성하세요.\n- 메모리 보호 복원: 선택적으로, 메모리 영역의 보호 값을 원래 설정으로 돌려놓으세요.\n\n원하는 함수에 대한 함수 포인터를 획들한 후, 이러한 바이트를 임의로 패치할 수 없다는 것을 알 수 있습니다. 각 함수의 메모리 주소의 보호 수준을 먼저 변경해야합니다. 이러한 함수가 메모리 영역에 대한 쓰기 권한이 있는 경우 가능할 것입니다. 하지만 곧 보게 될 것처럼, 그렇지 않습니다.\n\n메모리 영역은 수행할 수 있는 작업을 제한하는 보호 상수를 가지고 있습니다. 이러한 함수들에 대해서는 해당 메모리 섹션에 쓰기가 지원되지 않음을 볼 수 있습니다. 아래에서 이러한 함수들의 메모리 영역 보호 값이 표시됩니다.\n\n```js\n0:012\u003e !vprot ntdll!EtwEventWrite\nBaseAddress: 00007ffaafbbf000\nAllocationBase: 00007ffaafb90000\nAllocationProtect: 00000080 PAGE_EXECUTE_WRITECOPY\nRegionSize: 0000000000103000\nState: 00001000 MEM_COMMIT\nProtect: 00000020 PAGE_EXECUTE_READ\nType: 01000000 MEM_IMAGE\n\n0:012\u003e !vprot ntdll!NtTraceEvent\nBaseAddress: 00007ffaafc30000\nAllocationBase: 00007ffaafb90000\nAllocationProtect: 00000080 PAGE_EXECUTE_WRITECOPY\nRegionSize: 0000000000092000\nState: 00001000 MEM_COMMIT\nProtect: 00000020 PAGE_EXECUTE_READ\nType: 01000000 MEM_IMAGE\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 내용은 코드가 읽히고 실행되지만 작성되지는 않음을 의미합니다. 따라서 이러한 함수 중 하나를 수정할 때 보호 값이 변경되어야 합니다. 일반적으로 PAGE_EXECUTE_READWRITE (0x40/60)로 변경하여 VirtualProtect를 사용합니다. VirtualProtect 작업 이전에 수집된 텔레메트리는 함수 패치의 신뢰할 수 있는 지표가 아닐 수 있습니다. VirtualProtect 작업조차 직접적인 함수 패치를 나타내지는 않습니다. 그러나 VirtualProtect에 대한 텔레메트리 데이터가 있는 경우, 해당 메타데이터에서 함수 패치가 발생했는지 추측하는 데 충분한 맥락을 제공할 수 있습니다.\n\nETW 위협 인텔리전스 프로바이더 내에는 THREATINT_PROTECTVM_LOCAL (EID: 7)라는 이벤트가 있습니다. 이 이벤트는 VirtualProtect가 로컬에서 수행될 때 텔레메트리 정보를 제공하는 것으로 보입니다. TelemetrySource 프로젝트를 살펴보거나 EtwInspector를 실행하여 이를 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_0.png)\n\n더 깊이 조사한 결과로 메모리 영역의 보호 수준을 변경하는 경우에 대한 이벤트가 있음을 확인할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n사전 패치: 보호 값이 PAGE_EXECUTE_READ(0x20)에서 PAGE_EXECUTE_READWRITE(0x40)로 변경되었습니다.\n\n![이미지](/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_1.png)\n\n이 이벤트에는 몇 가지 귀중한 정보가 있습니다:\n\n- BaseAddress — 보호 값이 변경된 메모리 주소입니다.\n- RegionSize Value — 2. 여기서는 보호가 변경된 바이트가 2개임을 보여줍니다. 이것은 보통 4096 또는 그 이상인데, 이 값이 낮은 것이 불통입니다. 또 내용을 찾아보니 이 값이 (0xc3, 0x00)으로 변경되었을 때이며 이 값은 x64 시스템에서 반환값입니다.\n- ProtectionMask — 값이 PAGE_EXECUTE_READWRITE로 변경되었음을 나타냅니다.\n- Last ProtectionMask — 값이 PAGE_EXECUTE_READ에서 변경되었음을 나타냅니다.\n- Callstack — VirtualProtect가 호출된 것을 보여줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n포스트 패치: 페이지 보호 값을 PAGE_EXECUTE_READWRITE(0x20)에서 PAGE_EXECUTE_READ(0x40)으로 변경합니다.\n\n![이미지](/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_2.png)\n\n포스트 보호 값이 반드시 이루어질 필요는 없습니다. 그러나 보호 값이 한 값에서 다른 값으로 변경된 시기를 알고 싶어하는 사람이 있다면 좋은 신호입니다. 이는 누군가가 한 값으로 변경한 다음 다시 다른 값으로 바꾸는 것은 매우 이상하다는 것을 의미합니다. 실제로 변경된 바이트를 볼 수 없기 때문에 이것은 잘못된 양성 결과를 방지하는 데 도움이 될 수 있습니다.\n\n이제 아마도 당신은 생각할 것입니다 — 실제 바이트 패치는 어떻게 할까요? 처음에는 WriteProcessMemory 함수가 작동할 것이라고 생각했지만, C 함수를 호출할 때 — memcpy/memmove 함수가 실제로 WriteProcessMemory를 호출하지 않는다는 사실을 깨달았습니다. 원격 패치에 대해 아래에서 계속 탐구할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 탐지 아이디어:\n\n- 이벤트 ID 7을 수집합니다: Local Virtual Protect — 초기 ProtectionMask 변경\n\n- 관심 있는 함수들에서 패치된 바이트의 공통 숫자(RegionSize 값)를 찾아보세요. x64/x86의 경우 EtwEventWrite와 같은 함수에서 패치된 바이트의 수는 종종 2입니다. 이는 함수가 실행된 후 반환 값이 패치되기 때문입니다.\n- New ProtectionMask가 PAGE_READWRITE (0x04) 또는 PAGE_EXECUTE_READWRITE (0x40)로 열렸을 때를 확인해보세요.\n\n2. 이벤트 ID 7을 수집합니다: Local Virtual Protect — ProtectionMask 복원\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 누군가가 보호 값을 다시 원래 값으로 변경할 필요는 없지만, 일반적으로 그렇게 하는 것이 좋습니다. 보호 마스크를 더 엄격한 0x20에서 0x40로 변경한 다음 다시 0x20으로 변경되는 것을 보면 꽤 의심스럽습니다. 따라서 동일한 메모리 주소에서 보호 마스크가 계속 왔다갔다 하면 2 EID 7을 검사하는 것이 높은 결과를 얻을 수 있을 것입니다.\n\n# 원격 ETW 패치\n\n원격 패치는 더 드물지만, 듣보잡은 아니며 이에 대한 좋은 프로젝트는 RemotePatcher입니다. 이는 원격 함수 패치를 수행하는 것이 더 위험하기 때문에 감지될 가능성이 높기 때문입니다. memcpy/memmove는 원격 프로세스 내에서 바이트를 쓰는 것을 지원하지 않기 때문에 WriteProcessMemory를 사용해야 하며, RemotePatcher는 patchAMSI 함수에서 이 작업을 수행합니다.\n\n![이미지](/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_3.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지금, 우리는 NtProtectVirtualMemory가 두 번 호출된 것을 볼 수 있습니다. 한 번은 보호 값을 PAGE_READWRITE(0x04)로 변경하고 다시 원래 값으로 변경하기 위해 호출됩니다. 차이점은 NtWriteVirtualMemory가 호출된다는 것입니다. TelemetrySource 내부에서 event ID 14로 이어진다는 것을 알 수 있습니다. 이것을 살펴보겠습니다:\n\n![이미지](/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_4.png)\n\n위에 표시된 이벤트들이 멋진 점은 원격 프로세스에 액세스한 프로세스가 있고, 메모리 영역의 보호 값을 변경하고 대상 프로세스에 데이터를 쓰고 다시 보호 값을 변경했다는 것이 명백하다는 것입니다. 이러한 연산 순서는 Windows에서 빈번하게 발생하지 않습니다.\n\n# 탐지 아이디어:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 이벤트 ID 2를 수집하세요: 원격 가상 보호 — 초기 ProtectionMask 변경\n\n- New ProtectionMask가 PAGE_READWRITE (0x04) 또는 PAGE_EXECUTE_READWRITE (0x40)로 열렸을 때를 찾아보세요.\n\n2. 이벤트 ID 2를 수집하세요: 원격 가상 보호 — ProtectionMask 되돌리기\n\n- 누군가는 보호 값을 원래 값으로 되돌릴 필요는 없지만, 이는 일반적인 관행입니다. 보호 마스크가 0x20처럼 더 많이 잠긴 마스크에서 0x40로 변경되고 다시 0x20으로 돌아가는 것을 보는 것은 상당히 수상합니다. 따라서 동일한 메모리 주소의 보호 마스크가 그렇게 왔다갔다하는 2개의 EID 2를 주시하면 높은 결과를 얻을 수 있을 겁니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3. 이벤트 ID 14를 수집하세요: 프로세스 메모리 쓰기 - 패치용 바이트를 기록\n\n- 이를 원격 VirtualProtect가 메모리 쓰기 전후에 수행되는 상황에서 관찰하는 것은 의심스러울 수 있습니다.\n- 이것이 ETW 패칭인지에 대해 분간하기가 어려울 수 있지만, 이것은 어쨌든 프로세스 주입 가시성에 사용될 수 있습니다. 기술적으로 이것은 데이터가 대상 프로세스에 쓰여지기 때문에 프로세스 주입으로 간주될 수 있습니다.\n\n# 결론\n\n이 포스트에서는 ETW 패칭 및 이 활동을 관찰하는 실용적인 접근 방식을 간단히 탐색하고자 했습니다. 로컬 패칭이 원격 패칭보다 훨씬 더 흔합니다. 유감스럽게도, memcpy와 memmove는 WriteProcessMemory를 호출하지 않기 때문에 로컬에서 실제 패치를 식별하는 것은 매우 어렵습니다. 그러나 패치가 발생할 메모리 영역의 보호 마스크에 대한 변경을 감지하는 것은 여전히 좋은 지표로 남아 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 보호 마스크가 읽기/실행에서 읽기/쓰기/실행으로 변경되는 것은 흔하지 않습니다. 또한, 이러한 이벤트에서 바뀌는 바이트 수는 보통 다른 일반적인 VirtualProtect 이벤트보다 낮습니다. 일반적으로 4096바이트 이상이 관련된 것들이 대부분입니다. RemotePatcher에서 볼 수 있듯이, 누군가가 4096바이트 메모리 영역의 보호 값 변경을 위해 조용히 하는 경우가 있습니다.\n\n만약 이 방식을 구현하고 싶다면, 데이터를 분석하여 연속적으로 여러 작업이 발생하는 패턴을 식별하는 것을 권장합니다. 또한, 공격자가 변경할 수 있는 모든 가능한 보호 값과 함께 쓰기 권한을 포함하는 것들을 모두 살펴보세요. 이 정보가 도움이 되었기를 바랍니다. 아이디어를 공유하거나 질문이 있으면 언제든지 연락 주세요.\n\nArash Parsa에게 연락해주고 다시 이 주제를 재방문하고 문서화하도록 하도록 도와준 것에 감사드립니다.","ogImage":{"url":"/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_0.png"},"coverImage":"/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_0.png","tag":["Tech"],"readingTime":7},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e얼마 전에 'ETW 패치 이해하기'라는 블로그를 썼는데, 그 글에서 ETW 패칭이 함수 패치의 초고도 버전이라는 내용을 설명했어. Defenders 부분에서는 프로세스 내에서 공급자 DLL이 로드되었지만 ETW 이벤트가 발생하지 않는 걸 볼 수 있는 방법에 대해 언급했어. 이 방법은 특정 공급자에 대해서만 작동해서 좋은 방법은 아니야. 이 초기 생각에 대해 더 알고 싶다면 \u003ca href=\"%EB%A7%81%ED%81%AC\"\u003e요 트윗\u003c/a\u003e을 참조해봐. 그 이후로 좀 더 깊게 파보았고, 이번 글에서는 이 접근 방식에 대해 이야기할 거야.\u003c/p\u003e\n\u003ch1\u003e로컬 ETW 패칭\u003c/h1\u003e\n\u003cp\u003e이전 글에서 언급했듯이, 이벤트 발생을 막는 일반적인 방법 중 하나는 ntdll 함수인 특히 EtwEventWrite 또는 NtTraceEvent에 초점을 맞추는 것이야. 이를 수행하는 단계는 다음과 같아:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003eDLL 로딩: 이미 로드되지 않은 경우, 함수를 패치하고 싶은 DLL을 로드하세요.\u003c/li\u003e\n\u003cli\u003e함수 포인터 획득: 원하는 함수에 대한 함수 포인터를 가져오세요.\u003c/li\u003e\n\u003cli\u003e메모리 보호 변경: 쓰기 액세스를 허용하기 위해 메모리 영역의 보호 값을 변경하세요.\u003c/li\u003e\n\u003cli\u003e패치 적용: 패치를 작성하세요.\u003c/li\u003e\n\u003cli\u003e메모리 보호 복원: 선택적으로, 메모리 영역의 보호 값을 원래 설정으로 돌려놓으세요.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e원하는 함수에 대한 함수 포인터를 획들한 후, 이러한 바이트를 임의로 패치할 수 없다는 것을 알 수 있습니다. 각 함수의 메모리 주소의 보호 수준을 먼저 변경해야합니다. 이러한 함수가 메모리 영역에 대한 쓰기 권한이 있는 경우 가능할 것입니다. 하지만 곧 보게 될 것처럼, 그렇지 않습니다.\u003c/p\u003e\n\u003cp\u003e메모리 영역은 수행할 수 있는 작업을 제한하는 보호 상수를 가지고 있습니다. 이러한 함수들에 대해서는 해당 메모리 섹션에 쓰기가 지원되지 않음을 볼 수 있습니다. 아래에서 이러한 함수들의 메모리 영역 보호 값이 표시됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e012\u003c/span\u003e\u003e !vprot ntdll!\u003cspan class=\"hljs-title class_\"\u003eEtwEventWrite\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eBaseAddress\u003c/span\u003e: 00007ffaafbbf000\n\u003cspan class=\"hljs-title class_\"\u003eAllocationBase\u003c/span\u003e: 00007ffaafb90000\n\u003cspan class=\"hljs-title class_\"\u003eAllocationProtect\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e00000080\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePAGE_EXECUTE_WRITECOPY\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eRegionSize\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0000000000103000\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e00001000\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eMEM_COMMIT\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eProtect\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e00000020\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePAGE_EXECUTE_READ\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e01000000\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eMEM_IMAGE\u003c/span\u003e\n\n\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e012\u003c/span\u003e\u003e !vprot ntdll!\u003cspan class=\"hljs-title class_\"\u003eNtTraceEvent\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eBaseAddress\u003c/span\u003e: 00007ffaafc30000\n\u003cspan class=\"hljs-title class_\"\u003eAllocationBase\u003c/span\u003e: 00007ffaafb90000\n\u003cspan class=\"hljs-title class_\"\u003eAllocationProtect\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e00000080\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePAGE_EXECUTE_WRITECOPY\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eRegionSize\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0000000000092000\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eState\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e00001000\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eMEM_COMMIT\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eProtect\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e00000020\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePAGE_EXECUTE_READ\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e01000000\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eMEM_IMAGE\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 내용은 코드가 읽히고 실행되지만 작성되지는 않음을 의미합니다. 따라서 이러한 함수 중 하나를 수정할 때 보호 값이 변경되어야 합니다. 일반적으로 PAGE_EXECUTE_READWRITE (0x40/60)로 변경하여 VirtualProtect를 사용합니다. VirtualProtect 작업 이전에 수집된 텔레메트리는 함수 패치의 신뢰할 수 있는 지표가 아닐 수 있습니다. VirtualProtect 작업조차 직접적인 함수 패치를 나타내지는 않습니다. 그러나 VirtualProtect에 대한 텔레메트리 데이터가 있는 경우, 해당 메타데이터에서 함수 패치가 발생했는지 추측하는 데 충분한 맥락을 제공할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eETW 위협 인텔리전스 프로바이더 내에는 THREATINT_PROTECTVM_LOCAL (EID: 7)라는 이벤트가 있습니다. 이 이벤트는 VirtualProtect가 로컬에서 수행될 때 텔레메트리 정보를 제공하는 것으로 보입니다. TelemetrySource 프로젝트를 살펴보거나 EtwInspector를 실행하여 이를 확인할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e더 깊이 조사한 결과로 메모리 영역의 보호 수준을 변경하는 경우에 대한 이벤트가 있음을 확인할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e사전 패치: 보호 값이 PAGE_EXECUTE_READ(0x20)에서 PAGE_EXECUTE_READWRITE(0x40)로 변경되었습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_1.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이 이벤트에는 몇 가지 귀중한 정보가 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBaseAddress — 보호 값이 변경된 메모리 주소입니다.\u003c/li\u003e\n\u003cli\u003eRegionSize Value — 2. 여기서는 보호가 변경된 바이트가 2개임을 보여줍니다. 이것은 보통 4096 또는 그 이상인데, 이 값이 낮은 것이 불통입니다. 또 내용을 찾아보니 이 값이 (0xc3, 0x00)으로 변경되었을 때이며 이 값은 x64 시스템에서 반환값입니다.\u003c/li\u003e\n\u003cli\u003eProtectionMask — 값이 PAGE_EXECUTE_READWRITE로 변경되었음을 나타냅니다.\u003c/li\u003e\n\u003cli\u003eLast ProtectionMask — 값이 PAGE_EXECUTE_READ에서 변경되었음을 나타냅니다.\u003c/li\u003e\n\u003cli\u003eCallstack — VirtualProtect가 호출된 것을 보여줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e포스트 패치: 페이지 보호 값을 PAGE_EXECUTE_READWRITE(0x20)에서 PAGE_EXECUTE_READ(0x40)으로 변경합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_2.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e포스트 보호 값이 반드시 이루어질 필요는 없습니다. 그러나 보호 값이 한 값에서 다른 값으로 변경된 시기를 알고 싶어하는 사람이 있다면 좋은 신호입니다. 이는 누군가가 한 값으로 변경한 다음 다시 다른 값으로 바꾸는 것은 매우 이상하다는 것을 의미합니다. 실제로 변경된 바이트를 볼 수 없기 때문에 이것은 잘못된 양성 결과를 방지하는 데 도움이 될 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이제 아마도 당신은 생각할 것입니다 — 실제 바이트 패치는 어떻게 할까요? 처음에는 WriteProcessMemory 함수가 작동할 것이라고 생각했지만, C 함수를 호출할 때 — memcpy/memmove 함수가 실제로 WriteProcessMemory를 호출하지 않는다는 사실을 깨달았습니다. 원격 패치에 대해 아래에서 계속 탐구할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e탐지 아이디어:\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e이벤트 ID 7을 수집합니다: Local Virtual Protect — 초기 ProtectionMask 변경\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e관심 있는 함수들에서 패치된 바이트의 공통 숫자(RegionSize 값)를 찾아보세요. x64/x86의 경우 EtwEventWrite와 같은 함수에서 패치된 바이트의 수는 종종 2입니다. 이는 함수가 실행된 후 반환 값이 패치되기 때문입니다.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNew ProtectionMask가 PAGE_READWRITE (0x04) 또는 PAGE_EXECUTE_READWRITE (0x40)로 열렸을 때를 확인해보세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e이벤트 ID 7을 수집합니다: Local Virtual Protect — ProtectionMask 복원\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e누군가가 보호 값을 다시 원래 값으로 변경할 필요는 없지만, 일반적으로 그렇게 하는 것이 좋습니다. 보호 마스크를 더 엄격한 0x20에서 0x40로 변경한 다음 다시 0x20으로 변경되는 것을 보면 꽤 의심스럽습니다. 따라서 동일한 메모리 주소에서 보호 마스크가 계속 왔다갔다 하면 2 EID 7을 검사하는 것이 높은 결과를 얻을 수 있을 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e원격 ETW 패치\u003c/h1\u003e\n\u003cp\u003e원격 패치는 더 드물지만, 듣보잡은 아니며 이에 대한 좋은 프로젝트는 RemotePatcher입니다. 이는 원격 함수 패치를 수행하는 것이 더 위험하기 때문에 감지될 가능성이 높기 때문입니다. memcpy/memmove는 원격 프로세스 내에서 바이트를 쓰는 것을 지원하지 않기 때문에 WriteProcessMemory를 사용해야 하며, RemotePatcher는 patchAMSI 함수에서 이 작업을 수행합니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e지금, 우리는 NtProtectVirtualMemory가 두 번 호출된 것을 볼 수 있습니다. 한 번은 보호 값을 PAGE_READWRITE(0x04)로 변경하고 다시 원래 값으로 변경하기 위해 호출됩니다. 차이점은 NtWriteVirtualMemory가 호출된다는 것입니다. TelemetrySource 내부에서 event ID 14로 이어진다는 것을 알 수 있습니다. 이것을 살펴보겠습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e위에 표시된 이벤트들이 멋진 점은 원격 프로세스에 액세스한 프로세스가 있고, 메모리 영역의 보호 값을 변경하고 대상 프로세스에 데이터를 쓰고 다시 보호 값을 변경했다는 것이 명백하다는 것입니다. 이러한 연산 순서는 Windows에서 빈번하게 발생하지 않습니다.\u003c/p\u003e\n\u003ch1\u003e탐지 아이디어:\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e이벤트 ID 2를 수집하세요: 원격 가상 보호 — 초기 ProtectionMask 변경\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eNew ProtectionMask가 PAGE_READWRITE (0x04) 또는 PAGE_EXECUTE_READWRITE (0x40)로 열렸을 때를 찾아보세요.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e이벤트 ID 2를 수집하세요: 원격 가상 보호 — ProtectionMask 되돌리기\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e누군가는 보호 값을 원래 값으로 되돌릴 필요는 없지만, 이는 일반적인 관행입니다. 보호 마스크가 0x20처럼 더 많이 잠긴 마스크에서 0x40로 변경되고 다시 0x20으로 돌아가는 것을 보는 것은 상당히 수상합니다. 따라서 동일한 메모리 주소의 보호 마스크가 그렇게 왔다갔다하는 2개의 EID 2를 주시하면 높은 결과를 얻을 수 있을 겁니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e이벤트 ID 14를 수집하세요: 프로세스 메모리 쓰기 - 패치용 바이트를 기록\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e이를 원격 VirtualProtect가 메모리 쓰기 전후에 수행되는 상황에서 관찰하는 것은 의심스러울 수 있습니다.\u003c/li\u003e\n\u003cli\u003e이것이 ETW 패칭인지에 대해 분간하기가 어려울 수 있지만, 이것은 어쨌든 프로세스 주입 가시성에 사용될 수 있습니다. 기술적으로 이것은 데이터가 대상 프로세스에 쓰여지기 때문에 프로세스 주입으로 간주될 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e이 포스트에서는 ETW 패칭 및 이 활동을 관찰하는 실용적인 접근 방식을 간단히 탐색하고자 했습니다. 로컬 패칭이 원격 패칭보다 훨씬 더 흔합니다. 유감스럽게도, memcpy와 memmove는 WriteProcessMemory를 호출하지 않기 때문에 로컬에서 실제 패치를 식별하는 것은 매우 어렵습니다. 그러나 패치가 발생할 메모리 영역의 보호 마스크에 대한 변경을 감지하는 것은 여전히 좋은 지표로 남아 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 보호 마스크가 읽기/실행에서 읽기/쓰기/실행으로 변경되는 것은 흔하지 않습니다. 또한, 이러한 이벤트에서 바뀌는 바이트 수는 보통 다른 일반적인 VirtualProtect 이벤트보다 낮습니다. 일반적으로 4096바이트 이상이 관련된 것들이 대부분입니다. RemotePatcher에서 볼 수 있듯이, 누군가가 4096바이트 메모리 영역의 보호 값 변경을 위해 조용히 하는 경우가 있습니다.\u003c/p\u003e\n\u003cp\u003e만약 이 방식을 구현하고 싶다면, 데이터를 분석하여 연속적으로 여러 작업이 발생하는 패턴을 식별하는 것을 권장합니다. 또한, 공격자가 변경할 수 있는 모든 가능한 보호 값과 함께 쓰기 권한을 포함하는 것들을 모두 살펴보세요. 이 정보가 도움이 되었기를 바랍니다. 아이디어를 공유하거나 질문이 있으면 언제든지 연락 주세요.\u003c/p\u003e\n\u003cp\u003eArash Parsa에게 연락해주고 다시 이 주제를 재방문하고 문서화하도록 하도록 도와준 것에 감사드립니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>