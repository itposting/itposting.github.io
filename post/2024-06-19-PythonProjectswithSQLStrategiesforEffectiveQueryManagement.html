<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략 | itposting" data-gatsby-head="true"/><meta property="og:title" content="파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement" data-gatsby-head="true"/><meta name="twitter:title" content="파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 16:29" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_buildManifest.js" defer=""></script><script src="/_next/static/8coAiP0lmiEK5aH6nkQkj/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">12<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>프로젝트에서 데이터베이스와 상호 작용하는 프로그래밍을 할 때, 쿼리를 어떻게 조직화하고 재사용할지 고민하는 일이 종종 있어요. 이럴 때 몇몇 개발자는 쿼리를 보다 동적으로 만들기 위해 문자열을 연결하는 함수를 만들기도 하고, 다른 사람들은 이 쿼리를 정의하는 변수를 만들기를 선호하기도 해요. 일부 더 고급 개발자들은 쿼리를 정의할 때 SQLAlchemy 객체 선언을 사용하기도 하는데, 이 방법은 배우는 곡선이 있어서 더 복잡한 쿼리를 다룰 때 개발 프로세스를 어렵게 만들 수 있어요.</p>
<p>어느 날, 저는 코드를 지나치게 복잡하게 만들지 않고도 조직적이고 재사용 가능한 방식으로 작업하기 위한 해결책을 찾던 중 흥미로운 라이브러리인 aiosql을 우연히 발견했어요.</p>
<div class="content-ad"></div>
<p>다음 기사에서는 aiosql 라이브러리를 어떻게 사용하는지를 검토하고 문서에서 설명되는 내용과 함께 다른 컨텍스트에서 구현하는 데 사용한 몇 가지 방법을 공유하겠습니다.</p>
<h1>⚙️ aiosql 라이브러리란 무엇인가요?</h1>
<p>Aiosql은 🐍파이썬 라이브러리로, SQL 쿼리를 주요 파이썬 프로젝트 코드와 분리된 파일에 쉽게 작성할 수 있도록 도와줍니다. 이러한 쿼리는 SQL 파일에 저장되며, 이후에는 🐍파이썬 객체 내의 메서드로 변환됩니다.</p>
<p>Aiosql의 또 다른 주목할 만한 기능은 매개변수를 받아들이는 동적 메서드를 생성할 수 있는 능력으로, 유연한 쿼리 실행과 기본 데이터베이스와의 효과적인 상호 작용을 가능케합니다.</p>
<div class="content-ad"></div>
<p>SQL 쿼리를 Python 코드에서 분리함으로써 코드를 더 깔끔하고 모듈식으로 유지하는 데 도움이 됩니다. 이는 프로젝트의 가독성과 유지보수성을 향상시킵니다.</p>
<h1>⚙️ aiosql의 작동 방식</h1>
<p>다이어그램에서 볼 수 있듯이 SQL 파일에서 모든 쿼리를 가져와서 Python 코드에서 쿼리 헤더에 정의된 이름으로 호출하여 사용할 수 있습니다. 이후에 Python 코드에서 필요한 매개변수를 직접 전달하여 쿼리를 실행할 수 있습니다. 이를 통해 쿼리를 재사용하고 유지보수하기 쉽게 만들 수 있습니다.</p>
<img src="/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_1.png">
<div class="content-ad"></div>
<h1>⚙️ Aiosql 라이브러리 핵심 기능</h1>
<p>아래에서는 이 라이브러리가 이미 갖고 있거나 사용에 기반한 기능을 가질 수 있는 일련의 기능을 공유하겠습니다:</p>
<ul>
<li>데이터베이스 작업을 위한 CRUD 기능 제공 (Create: Insert, Read: Select, Update, Delete).</li>
<li>Python 코드와 SQL 코드를 분리하여 여러 데이터베이스가 있는 프로젝트에서 쿼리를 찾기 쉽게 함.</li>
<li>각 쿼리에 설명적인 이름과 독스트링을 할당할 수 있어 Python 함수와 유사하게 쿼리를 문서화할 수 있음.</li>
<li>프로젝트 내에서 쿼리 카탈로그를 작성하도록 지원하여 엔터티, 데이터베이스 또는 기타 그룹별 식별을 용이하게 함.</li>
<li>동적 값 전달과 필요에 따라 수정할 수 있는 동적 쿼리를 쉽게 생성할 수 있음.</li>
</ul>
<p><img src="/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2.png" alt="PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2"></p>
<div class="content-ad"></div>
<h1>⚙️ Aiosql 튜토리얼</h1>
<h2>🔧 사전 준비 사항</h2>
<ul>
<li>🐳 도커</li>
<li>🐙 도커 컴포즈</li>
<li>🐍 Python 라이브러리 설치:</li>
</ul>
<pre><code class="hljs language-js">pip install aiosql pandas
</code></pre>
<div class="content-ad"></div>
<h1>🚀 빠른 시작</h1>
<h2>🛠️ 포스트그레스 데이터베이스 만들기</h2>
<ul>
<li>1️⃣ — 이 저장소를 복제합니다: aiosql-tutorial</li>
</ul>
<pre><code class="hljs language-js">git clone <span class="hljs-attr">https</span>:<span class="hljs-comment">//github.com/r0mymendez/aiosql-tutorial.git</span>
</code></pre>
<div class="content-ad"></div>
<ul>
<li>2️⃣ 'postgres' 폴더로 디렉토리 변경해주세요</li>
</ul>
<pre><code class="hljs language-js">cd aiosql-tutorial/postgres
</code></pre>
<ul>
<li>3️⃣ PostgreSQL 데이터베이스를 생성해주세요 → 터미널에서 실행하세요:</li>
</ul>
<pre><code class="hljs language-js">docker-compose -f docker-compose.<span class="hljs-property">yml</span> up --build
</code></pre>
<div class="content-ad"></div>
<ul>
<li>4️⃣ 이제 컨테이너가 실행 중인지 확인하세요 → 터미널에서 다음을 실행해보세요:</li>
</ul>
<pre><code class="hljs language-js">docker ps
</code></pre>
<ul>
<li>5️⃣ CSV 파일을 로드하세요 → 컨테이너 내에서 CSV 파일을 로드하려면 다음 명령어를 실행하세요:</li>
</ul>
<pre><code class="hljs language-js">cd src
python3 etl.<span class="hljs-property">py</span>
</code></pre>
<div class="content-ad"></div>
<h1>🏥 병원 데이터</h1>
<p>aiosql을 구현하기 위해 Synthea에서 제공하는 데이터셋을 사용할 것입니다. 이 데이터는 매사추세츠 지역 인구의 다양한 변수를 고려한 시뮬레이션에서 생성된 합성 데이터입니다. 이 데이터셋에서는 <code>conditions</code>, <code>encounters</code>, <code>patients</code> 테이블을 사용할 것입니다.</p>
<h1>👥 사용자 이야기</h1>
<p>실제 상황을 반영하기 위해 3가지 사용 사례를 만들어보겠습니다:</p>
<ul>
<li>1️⃣ — 데이터 분석가로서, 방문 횟수가 90번 백분위 이상인 환자 목록을 검색할 수 있기를 원합니다. 이를 통해 병원에서 가장 활발한 환자들을 식별할 수 있습니다. 또한 나중에 쉽게 조정할 수 있도록 이 백분위를 구성할 수 있기를 원합니다.</li>
<li>2️⃣ — <strong>연구원 또는 데이터 분석가</strong>로서, 일정 기간 동안 가장 빈도가 높은 10가지 진단을 받은 환자 데이터에 액세스하고, 추세를 분석하고 의료 서비스의 품질을 개선하기 위해 사용하고 싶습니다.</li>
<li>3️⃣ — <strong>마케팅 분석가</strong>로서, 환자 만족도 조사용 테이블을 작성하고, 의료 서비스의 품질에 대한 피드백을 수집하여 개선 조치를 취하고자 합니다.</li>
</ul>
<div class="content-ad"></div>
<h1>🚀 구현</h1>
<p>우리가 만들 것인 사용자 스토리에 기반하여, 실행해야 하는 쿼리와 스크립트를 로드할 두 개의 파일을 정의할 것입니다:</p>
<ul>
<li>patients.sql: 회복 중인 환자 데이터에 관련된 모든 쿼리가 있는 곳입니다.</li>
<li>visits.sql: 설문 조사와 같은 방문에 관련된 모든 쿼리가 있는 곳입니다.</li>
</ul>
<p>그러므로 우리 프로젝트에서는 이러한 폴더 및 파일 구조를 가지게 될 것입니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">📁 db

    - 📁 queries
        - 📄 patients.<span class="hljs-property">sql</span>
        - 📄 visits.<span class="hljs-property">sql</span>

📄 main.<span class="hljs-property">ipynb</span>
</code></pre>
<p>1️⃣ — Python 라이브러리를 가져옵시다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">import</span> aiosql
<span class="hljs-keyword">import</span> psycopg2
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd
</code></pre>
<p>2️⃣ — SQL 쿼리를 가져와 데이터베이스 드라이버를 설정합시다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">sql = aiosql.<span class="hljs-title function_">from_path</span>(<span class="hljs-string">'src/db/queries'</span>, <span class="hljs-string">'psycopg2'</span>)
</code></pre>
<p>3️⃣ — PostgreSQL 데이터베이스에 연결합니다.</p>
<pre><code class="hljs language-js">postgres_secrets = {<span class="hljs-string">'host'</span>: <span class="hljs-string">'localhost'</span>,<span class="hljs-string">'port'</span>: <span class="hljs-number">5432</span>, <span class="hljs-string">'user'</span>: <span class="hljs-string">'postgres'</span>, <span class="hljs-string">'password'</span>: <span class="hljs-string">'postgres'</span>, <span class="hljs-string">'dbname'</span>: <span class="hljs-string">'postgres'</span>}
conn = psycopg2.<span class="hljs-title function_">connect</span>(**postgres_secrets)
conn.<span class="hljs-property">autocommit</span> = <span class="hljs-title class_">True</span>
</code></pre>
<h2>👥 사용자 이야기 I: 정적 값들</h2>
<div class="content-ad"></div>
<p>위의 사용자 스토리를 기반으로, 먼저 90번째 백분위수 이상의 방문 빈도를 가진 환자 목록을 검색할 수 있는 쿼리를 생성할 것입니다.</p>
<p>1️⃣ — sql 파일에서 첫 번째 사용자 스토리에 대한 쿼리가 있습니다.</p>
<p>다음은 aiosq에서 SQL 문이 구성되는 세 가지 구성 요소입니다:</p>
<ul>
<li>📗 Name: 이는 Python 코드에서 쿼리를 호출하는 데 사용되는 서술적인 이름입니다. 다음 예제에서 이름은 “fn_get_patients_adove_90th_percentile" 입니다.</li>
<li>📗 Description: 이는 문서 문자열을 생성하는 데 사용되는 자세한 설명입니다. 쿼리의 목적과 맥락에 대해 더 포괄적으로 설명합니다. 다음 예제에서 설명은 “90번째 백분위수 이상의 방문보다 더 많은 환자를 가져옵니다…" 입니다.</li>
<li>📗 Query: 여기에는 데이터베이스에서 실행될 SQL 쿼리가 있습니다.</li>
</ul>
<div class="content-ad"></div>
<p>📄 sql: db/queries/patients.sql</p>
<pre><code class="hljs language-js">-- 이름: fn_get_patients_adove_90th_percentile
-- 모든 환자 중 방문이 <span class="hljs-number">90</span> 번째 백분위수보다 많은 환자들을 가져옵니다. 모든 데이터는 encounters 테이블에 저장되어 있습니다.
 <span class="hljs-variable constant_">WITH</span> patient_visits <span class="hljs-variable constant_">AS</span> (
     <span class="hljs-variable constant_">SELECT</span>
         patient,
         <span class="hljs-title function_">COUNT</span>(*) <span class="hljs-variable constant_">AS</span> visit_count
     <span class="hljs-variable constant_">FROM</span>
         hospital.<span class="hljs-property">encounters</span>
     <span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span>
         patient
 ),
 percentil_n <span class="hljs-variable constant_">AS</span> (
   <span class="hljs-variable constant_">SELECT</span>
     <span class="hljs-title function_">percentile_cont</span>(<span class="hljs-number">0.9</span>) <span class="hljs-variable constant_">WITHIN</span> <span class="hljs-variable constant_">GROUP</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> visit_count) <span class="hljs-variable constant_">AS</span> p_visits
   <span class="hljs-variable constant_">FROM</span>
   patient_visits
 )
 <span class="hljs-variable constant_">SELECT</span> 
     pv.<span class="hljs-property">patient</span>, 
     pv.<span class="hljs-property">visit_count</span>
 <span class="hljs-variable constant_">FROM</span> 
     patient_visits pv
 <span class="hljs-variable constant_">CROSS</span> <span class="hljs-variable constant_">JOIN</span> 
     percentil_n pn
 <span class="hljs-variable constant_">WHERE</span> 
     pv.<span class="hljs-property">visit_count</span> >= pn.<span class="hljs-property">p_visits</span>;
</code></pre>
<p>2️⃣ — 'fn_get_patients_above_90th_percentile' SQL 함수를 데이터베이스 연결 'conn'을 사용하여 실행합니다.</p>
<pre><code class="hljs language-js">response = sql.<span class="hljs-title function_">fn_get_patients_above_90th_percentile</span>(conn)
</code></pre>
<div class="content-ad"></div>
<p>3️⃣ — 이제 응답 객체를 판다스 데이터프레임으로 변환하여 데이터 조작을 더 쉽게 할 수 있습니다.</p>
<pre><code class="hljs language-python">data = pd.DataFrame([item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> response], columns=[<span class="hljs-string">'patient_id'</span>, <span class="hljs-string">'num_visit'</span>])
<span class="hljs-comment"># 데이터프레임 표시.</span>
data
</code></pre>
<p><img src="/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_3.png" alt="이미지"></p>
<p>쿼리를 확인하고 싶으면 다음 코드를 사용할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-title function_">print</span>(sql.<span class="hljs-property">fn_get_patients_adove_90th_percentile</span>.<span class="hljs-property">sql</span>)
</code></pre>
<h2>👥 사용자 스토리 I: 동적 값</h2>
<p>이제 우리는 다른 백분위 값들을 받아들일 수 있는 쿼리를 생성하여 전달된 값에 기반하여 동적으로 수정될 수 있도록 할 것입니다. 우리의 경우, 75번째 백분위 이상의 환자 목록을 얻는 예시를 제공할 것입니다.</p>
<pre><code class="hljs language-js">-- <span class="hljs-attr">name</span>: fn_get_patients_above_n_percentile
 <span class="hljs-variable constant_">WITH</span> patient_visits <span class="hljs-variable constant_">AS</span> (
     <span class="hljs-variable constant_">SELECT</span>
         patient,
         <span class="hljs-title function_">COUNT</span>(*) <span class="hljs-variable constant_">AS</span> visit_count
     <span class="hljs-variable constant_">FROM</span>
         hospital.<span class="hljs-property">encounters</span>
     <span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span>
         patient
 ),
 percentil_n <span class="hljs-variable constant_">AS</span> (
   <span class="hljs-variable constant_">SELECT</span>
     <span class="hljs-title function_">percentile_cont</span>(:percentil_value) <span class="hljs-variable constant_">WITHIN</span> <span class="hljs-variable constant_">GROUP</span> (<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> visit_count) <span class="hljs-variable constant_">AS</span> p_visits
   <span class="hljs-variable constant_">FROM</span>
   patient_visits
 )
 <span class="hljs-variable constant_">SELECT</span> 
     pv.<span class="hljs-property">patient</span>, 
     pv.<span class="hljs-property">visit_count</span>
 <span class="hljs-variable constant_">FROM</span> 
     patient_visits pv
 <span class="hljs-variable constant_">CROSS</span> <span class="hljs-variable constant_">JOIN</span> 
     percentil_n pn
 <span class="hljs-variable constant_">WHERE</span> 
     pv.<span class="hljs-property">visit_count</span> >= pn.<span class="hljs-property">p_visits</span>;
</code></pre>
<div class="content-ad"></div>
<p>1️⃣ - 다음 코드는 입력값으로 다른 백분위 값을 허용하는 동적 SQL 쿼리를 실행합니다.</p>
<pre><code class="hljs language-js"># 이 경우에는 <span class="hljs-number">75</span> 백분위 이상의 환자들을 얻습니다.
response = sql.<span class="hljs-title function_">fn_get_patients_above_n_percentile</span>(conn, percentil_value=<span class="hljs-number">0.75</span>)
data = pd.<span class="hljs-title class_">DataFrame</span>([item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> response], columns=[<span class="hljs-string">'patient_id'</span>, <span class="hljs-string">'num_visit'</span>])
</code></pre>
<h2>👥 사용자 스토리 II</h2>
<p>이 사용자 스토리를 해결하기 위해 지정된 기간 내에서 가장 일반적인 질환이 있는 환자들을 검색하는 쿼리를 생성할 것입니다. 이 쿼리는 동적이며, 향후 관심 있는 질환 수의 변화를 허용할 것입니다.
이 쿼리는 세 개의 매개변수를 받습니다:</p>
<div class="content-ad"></div>
<ul>
<li>num_condition: 우리가 관심 있는 조건의 수를 제한할 수 있게 해줄 것입니다 (예: 가장 일반적인 상위 10개 조건).</li>
<li>period_start_date와 period_start_end는 데이터를 검색하려는 시간 창을 정의할 것입니다.</li>
</ul>
<pre><code class="hljs language-js">--<span class="hljs-attr">name</span>: fn_get_patients_top_conditions
--주어진 기간 동안 최상위 조건을 가진 환자 가져오기, 환자는 조건을 가진 날 수와 데이터 소스가 병원 스키마인 기준으로 정렬됩니다.
<span class="hljs-keyword">with</span> top_n_conditions <span class="hljs-title function_">as</span>(
  <span class="hljs-variable constant_">SELECT</span> code, description, <span class="hljs-title function_">COUNT</span>(*) 
   <span class="hljs-variable constant_">FROM</span> hospital.<span class="hljs-property">CONDITIONS</span> 
  <span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> code,description 
  <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-title function_">COUNT</span>(*) <span class="hljs-variable constant_">DESC</span> 
  <span class="hljs-variable constant_">LIMIT</span> :num_condition
),
top_n_condition_patients <span class="hljs-keyword">as</span> (
  <span class="hljs-variable constant_">SELECT</span> 
     p.<span class="hljs-property">ID</span>, 
     p.<span class="hljs-property">FIRST</span>, 
     p.<span class="hljs-property">LAST</span>, 
     p.<span class="hljs-property">CITY</span>, 
     p.<span class="hljs-property">GENDER</span>, 
     <span class="hljs-title function_">EXTRACT</span>(<span class="hljs-variable constant_">YEAR</span> <span class="hljs-variable constant_">FROM</span> <span class="hljs-title function_">AGE</span>(p.<span class="hljs-property">BIRTHDATE</span>)) <span class="hljs-variable constant_">AS</span> age,
     c.<span class="hljs-property">start</span> condition_start_date,
     c.<span class="hljs-property">stop</span> condition_stop_date,
     <span class="hljs-title function_">EXTRACT</span>(<span class="hljs-variable constant_">DAY</span> <span class="hljs-variable constant_">FROM</span> (c.<span class="hljs-property">stop</span> - c.<span class="hljs-property">start</span> )) <span class="hljs-variable constant_">AS</span> condition_days, 
     c.<span class="hljs-property">encounter</span>,
     c.<span class="hljs-property">code</span>,
     c.<span class="hljs-property">description</span>
   <span class="hljs-keyword">from</span> hospital.<span class="hljs-property">patients</span> p 
   inner join hospital.<span class="hljs-property">conditions</span> c on c.<span class="hljs-property">patient</span> = p.<span class="hljs-property">id</span>
   inner join top_n_conditions t on t.<span class="hljs-property">code</span>=c.<span class="hljs-property">code</span>
)
select * 
 <span class="hljs-keyword">from</span> top_n_condition_patients
 where condition_start_date between :period_start_date and :period_start_end;
</code></pre>
<pre><code class="hljs language-js">response = sql.<span class="hljs-title function_">fn_get_patients_top_conditions</span>(conn, num_condition_days=<span class="hljs-number">10</span>, 
 period_start_date=<span class="hljs-string">'2022–01–01'</span>, 
 period_start_end=<span class="hljs-string">'2022–12–31'</span>)
column_name=[<span class="hljs-string">'id'</span>, <span class="hljs-string">'first'</span>,<span class="hljs-string">'last'</span>,<span class="hljs-string">'city'</span>,<span class="hljs-string">'gender'</span>,
<span class="hljs-string">'age'</span>,<span class="hljs-string">'condition_start_date'</span>,<span class="hljs-string">'condition_stop_date'</span>,<span class="hljs-string">'condition_days'</span>,<span class="hljs-string">'encounter'</span>,<span class="hljs-string">'code'</span>,<span class="hljs-string">'description'</span>]
data = pd.<span class="hljs-title class_">DataFrame</span>([item <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> response], columns=column_name)
data.<span class="hljs-title function_">head</span>()
</code></pre>
<h2>👥 사용자 이야기 III</h2>
<div class="content-ad"></div>
<p>이제 aiosql을 사용하여 테이블을 생성할 것입니다. 만약 SQL 코드를 살펴보시면 # 기호가 추가된 것을 보실 수 있습니다. 이러한 기호들은 aiosql이 다양한 작업을 식별하는 데 사용됩니다.</p>
<pre><code class="hljs language-js">--<span class="hljs-attr">name</span>: fn_create_survey_table#
<span class="hljs-variable constant_">CREATE</span> <span class="hljs-variable constant_">TABLE</span> <span class="hljs-variable constant_">HOSPITAL</span>.<span class="hljs-title function_">VISIT_SURVEY</span>(
 <span class="hljs-variable constant_">ID</span> <span class="hljs-variable constant_">SERIAL</span> <span class="hljs-variable constant_">PRIMARY</span> <span class="hljs-variable constant_">KEY</span>,
 <span class="hljs-variable constant_">PATIENT_ID</span> <span class="hljs-title function_">VARCHAR</span>(<span class="hljs-number">50</span>),
 <span class="hljs-variable constant_">SURVEY_DATE</span> <span class="hljs-variable constant_">TIMESTAMP</span>,
 <span class="hljs-variable constant_">RATING</span> <span class="hljs-variable constant_">INT</span>,
 <span class="hljs-variable constant_">COMMENTS</span> <span class="hljs-variable constant_">TEXT</span>,
 <span class="hljs-variable constant_">CREATED_AT</span> <span class="hljs-variable constant_">TIMESTAMP</span> <span class="hljs-variable constant_">DEFAULT</span> <span class="hljs-variable constant_">CURRENT_TIMESTAMP</span>
);
</code></pre>
<img src="/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_4.png">
<p>1️⃣ — 'fn_create_survey_table' SQL 함수를 실행하여 데이터베이스에 새 테이블을 만드세요.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">sql.<span class="hljs-title function_">fn_create_survey_table</span>(conn)
</code></pre>
<pre><code class="hljs language-js"># output
<span class="hljs-variable constant_">CREATE</span> <span class="hljs-variable constant_">TABLE</span>
</code></pre>
<p>2️⃣ — 테이블이 생성되면 아래 삽입문을 사용하여 환자의 리뷰를 삽입할 수 있습니다.</p>
<pre><code class="hljs language-js">-- <span class="hljs-attr">name</span>: fn_add_one_visit_survey&#x3C;!
insert into <span class="hljs-variable constant_">HOSPITAL</span>.<span class="hljs-title function_">VISIT_SURVEY</span>(<span class="hljs-variable constant_">PATIENT_ID</span>,<span class="hljs-variable constant_">SURVEY_DATE</span>,<span class="hljs-variable constant_">RATING</span>,<span class="hljs-variable constant_">COMMENTS</span>) 
 values (:patient_id, :survey_date, :rating,:comments) returning <span class="hljs-variable constant_">ID</span>;
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-js"># 새로운 방문 조사 레코드 추가
sql.<span class="hljs-title function_">fn_add_one_visit_survey</span>(conn, 
 patient_id=<span class="hljs-string">'8b9a93f6-3df3-203d-932f-f456e00d2c01'</span>, 
 survey_date=<span class="hljs-string">'2022-01-01'</span>, 
 rating=<span class="hljs-number">5</span>,
 comments=<span class="hljs-string">'이 병원 정말 좋아요!'</span> )
</code></pre>
<p>3️⃣ — 이제 여러 리뷰를 로드하기 위해 새로운 삽입문을 활용할 것입니다. 이 리뷰들은 딕셔너리 목록에 저장되어 있습니다 (파이썬의 각 딕셔너리는 리뷰에 해당합니다). 이를 수행하기 위해 비슷한 쿼리를 활용하겠지만 그 이름을 수정해야 합니다.</p>
<pre><code class="hljs language-js">-- <span class="hljs-attr">name</span>: fn_add_many_visit_survey*!
 insert into <span class="hljs-variable constant_">HOSPITAL</span>.<span class="hljs-title function_">VISIT_SURVEY</span>(<span class="hljs-variable constant_">PATIENT_ID</span>,<span class="hljs-variable constant_">SURVEY_DATE</span>,<span class="hljs-variable constant_">RATING</span>,<span class="hljs-variable constant_">COMMENTS</span>) 
 values (:patient_id, :survey_date, :rating ,:comments) returning <span class="hljs-variable constant_">ID</span>;
</code></pre>
<pre><code class="hljs language-js"># 여러 방문 조사 레코드 추가
response_survey = [
     {
       <span class="hljs-string">'patient_id'</span>: <span class="hljs-string">'8b9a93f6-3df3-203d-932f-f456e00d2c01'</span>,
       <span class="hljs-string">'survey_date'</span>: <span class="hljs-string">'2022-01-01'</span>,
       <span class="hljs-string">'rating'</span>: <span class="hljs-number">3</span>,
       <span class="hljs-string">'comments'</span>: <span class="hljs-string">'서비스는 좋았어요. 다만 대기 시간이 조금 길었습니다.'</span>
     },
     {
       <span class="hljs-string">'patient_id'</span>: <span class="hljs-string">'7c8a93f6-4df3-203d-932f-f456e00d2c02'</span>,
       <span class="hljs-string">'survey_date'</span>: <span class="hljs-string">'2022-02-01'</span>,
       <span class="hljs-string">'rating'</span>: <span class="hljs-number">4</span>,
       <span class="hljs-string">'comments'</span>: <span class="hljs-string">'직원들이 매우 친절했어요!'</span>
     },
     {
       <span class="hljs-string">'patient_id'</span>: <span class="hljs-string">'6b7a93f6-5ef3-203d-932f-f456e00d2c03'</span>,
       <span class="hljs-string">'survey_date'</span>: <span class="hljs-string">'2022-03-01'</span>,
       <span class="hljs-string">'rating'</span>: <span class="hljs-number">3</span>,
       <span class="hljs-string">'comments'</span>: <span class="hljs-string">'대기 시간이 조금 길었습니다.'</span>
     }
]
sql.<span class="hljs-title function_">fn_add_many_visit_survey</span>(conn, response_survey)
</code></pre>
<div class="content-ad"></div>
<h1>📚 프로젝트 쿼리 카탈로그</h1>
<p>튜토리얼 초반에는 프로젝트용 쿼리 카탈로그를 만들 수 있는 가능성을 언급했습니다. 이 라이브러리는 이 기능을 직접 제공하지는 않지만, 나의 GitHub 저장소에서 이 튜토리얼의 완전한 코드와 데이터에 액세스하여 이를 수행하는 방법을 확인할 수 있습니다.</p>
<p>유용하게 사용하시면, ⭐️ 스타를 남겨주시고 새로운 글 알림을 받기 위해 팔로우해주시면 저에게 큰 도움이 됩니다. 기술 커뮤니티에서 성장하고 더 많은 콘텐츠를 제작할 수 있게 될 것입니다.</p>
<h1>🔍 최종 결론</h1>
<div class="content-ad"></div>
<ul>
<li>다양성과 유틸리티: 저는 aiosql이 다른 프로젝트에서 쿼리를 효율적으로 구현할 수 있게 해주는 유용한 라이브러리라고 생각합니다. 이 라이브러리는 SQL 쿼리를 관리하고 실행하는 구조적인 방법을 제공하여 본 코드베이스와 별도로 처리할 수 있어 가독성과 유지 보수성을 향상시킵니다.</li>
<li>유연한 쿼리 처리: aiosql은 데이터베이스 연결을 통해 쿼리를 직접 실행할 수 있는 환경을 제공하지만, 저의 프로젝트에서는 주로 Python 코드로 이미 설정한 클래스를 사용하여 SQL 코드를 반환하고 실행합니다.</li>
<li>다른 데이터베이스: 쿼리를 저장하고 관리할 수 있는 기능은 SQL 데이터베이스를 넘어서기도 합니다. 예를 들어 이 접근 방식은 Neo4j와 같은 NoSQL 데이터베이스에도 적용할 수 있습니다. 구조적인 방식으로 쿼리를 구성하고 처리함으로써 다양한 유형의 데이터베이스와의 상호 작용을 최적화할 수 있습니다.</li>
</ul>
<h2>📚 참고 자료</h2>
<p>학습하고 싶다면...</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략","description":"","date":"2024-06-19 16:29","slug":"2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement","content":"\n\n프로젝트에서 데이터베이스와 상호 작용하는 프로그래밍을 할 때, 쿼리를 어떻게 조직화하고 재사용할지 고민하는 일이 종종 있어요. 이럴 때 몇몇 개발자는 쿼리를 보다 동적으로 만들기 위해 문자열을 연결하는 함수를 만들기도 하고, 다른 사람들은 이 쿼리를 정의하는 변수를 만들기를 선호하기도 해요. 일부 더 고급 개발자들은 쿼리를 정의할 때 SQLAlchemy 객체 선언을 사용하기도 하는데, 이 방법은 배우는 곡선이 있어서 더 복잡한 쿼리를 다룰 때 개발 프로세스를 어렵게 만들 수 있어요.\n\n어느 날, 저는 코드를 지나치게 복잡하게 만들지 않고도 조직적이고 재사용 가능한 방식으로 작업하기 위한 해결책을 찾던 중 흥미로운 라이브러리인 aiosql을 우연히 발견했어요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다음 기사에서는 aiosql 라이브러리를 어떻게 사용하는지를 검토하고 문서에서 설명되는 내용과 함께 다른 컨텍스트에서 구현하는 데 사용한 몇 가지 방법을 공유하겠습니다.\n\n# ⚙️ aiosql 라이브러리란 무엇인가요?\n\nAiosql은 🐍파이썬 라이브러리로, SQL 쿼리를 주요 파이썬 프로젝트 코드와 분리된 파일에 쉽게 작성할 수 있도록 도와줍니다. 이러한 쿼리는 SQL 파일에 저장되며, 이후에는 🐍파이썬 객체 내의 메서드로 변환됩니다.\n\nAiosql의 또 다른 주목할 만한 기능은 매개변수를 받아들이는 동적 메서드를 생성할 수 있는 능력으로, 유연한 쿼리 실행과 기본 데이터베이스와의 효과적인 상호 작용을 가능케합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSQL 쿼리를 Python 코드에서 분리함으로써 코드를 더 깔끔하고 모듈식으로 유지하는 데 도움이 됩니다. 이는 프로젝트의 가독성과 유지보수성을 향상시킵니다.\n\n# ⚙️ aiosql의 작동 방식\n\n다이어그램에서 볼 수 있듯이 SQL 파일에서 모든 쿼리를 가져와서 Python 코드에서 쿼리 헤더에 정의된 이름으로 호출하여 사용할 수 있습니다. 이후에 Python 코드에서 필요한 매개변수를 직접 전달하여 쿼리를 실행할 수 있습니다. 이를 통해 쿼리를 재사용하고 유지보수하기 쉽게 만들 수 있습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_1.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ⚙️ Aiosql 라이브러리 핵심 기능\n\n아래에서는 이 라이브러리가 이미 갖고 있거나 사용에 기반한 기능을 가질 수 있는 일련의 기능을 공유하겠습니다:\n\n- 데이터베이스 작업을 위한 CRUD 기능 제공 (Create: Insert, Read: Select, Update, Delete).\n- Python 코드와 SQL 코드를 분리하여 여러 데이터베이스가 있는 프로젝트에서 쿼리를 찾기 쉽게 함.\n- 각 쿼리에 설명적인 이름과 독스트링을 할당할 수 있어 Python 함수와 유사하게 쿼리를 문서화할 수 있음.\n- 프로젝트 내에서 쿼리 카탈로그를 작성하도록 지원하여 엔터티, 데이터베이스 또는 기타 그룹별 식별을 용이하게 함.\n- 동적 값 전달과 필요에 따라 수정할 수 있는 동적 쿼리를 쉽게 생성할 수 있음.\n\n![PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2](/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2.png)\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# ⚙️ Aiosql 튜토리얼\n\n## 🔧 사전 준비 사항\n\n- 🐳 도커\n- 🐙 도커 컴포즈\n- 🐍 Python 라이브러리 설치:\n\n```js\npip install aiosql pandas\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 🚀 빠른 시작\n\n## 🛠️ 포스트그레스 데이터베이스 만들기\n\n- 1️⃣ — 이 저장소를 복제합니다: aiosql-tutorial\n\n```js\ngit clone https://github.com/r0mymendez/aiosql-tutorial.git\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 2️⃣ 'postgres' 폴더로 디렉토리 변경해주세요\n\n```js\ncd aiosql-tutorial/postgres\n```\n\n- 3️⃣ PostgreSQL 데이터베이스를 생성해주세요 → 터미널에서 실행하세요:\n\n```js\ndocker-compose -f docker-compose.yml up --build\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 4️⃣ 이제 컨테이너가 실행 중인지 확인하세요 → 터미널에서 다음을 실행해보세요:\n\n```js\ndocker ps\n```\n\n- 5️⃣ CSV 파일을 로드하세요 → 컨테이너 내에서 CSV 파일을 로드하려면 다음 명령어를 실행하세요:\n\n```js\ncd src\npython3 etl.py\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 🏥 병원 데이터\n\naiosql을 구현하기 위해 Synthea에서 제공하는 데이터셋을 사용할 것입니다. 이 데이터는 매사추세츠 지역 인구의 다양한 변수를 고려한 시뮬레이션에서 생성된 합성 데이터입니다. 이 데이터셋에서는 `conditions`, `encounters`, `patients` 테이블을 사용할 것입니다.\n\n# 👥 사용자 이야기\n\n실제 상황을 반영하기 위해 3가지 사용 사례를 만들어보겠습니다:\n* 1️⃣ — 데이터 분석가로서, 방문 횟수가 90번 백분위 이상인 환자 목록을 검색할 수 있기를 원합니다. 이를 통해 병원에서 가장 활발한 환자들을 식별할 수 있습니다. 또한 나중에 쉽게 조정할 수 있도록 이 백분위를 구성할 수 있기를 원합니다.\n* 2️⃣ — **연구원 또는 데이터 분석가**로서, 일정 기간 동안 가장 빈도가 높은 10가지 진단을 받은 환자 데이터에 액세스하고, 추세를 분석하고 의료 서비스의 품질을 개선하기 위해 사용하고 싶습니다.\n* 3️⃣ — **마케팅 분석가**로서, 환자 만족도 조사용 테이블을 작성하고, 의료 서비스의 품질에 대한 피드백을 수집하여 개선 조치를 취하고자 합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 🚀 구현\n\n우리가 만들 것인 사용자 스토리에 기반하여, 실행해야 하는 쿼리와 스크립트를 로드할 두 개의 파일을 정의할 것입니다:\n\n- patients.sql: 회복 중인 환자 데이터에 관련된 모든 쿼리가 있는 곳입니다.\n- visits.sql: 설문 조사와 같은 방문에 관련된 모든 쿼리가 있는 곳입니다.\n\n그러므로 우리 프로젝트에서는 이러한 폴더 및 파일 구조를 가지게 될 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n📁 db\n\n    - 📁 queries\n        - 📄 patients.sql\n        - 📄 visits.sql\n\n📄 main.ipynb\n```\n\n1️⃣ — Python 라이브러리를 가져옵시다.\n\n```js\nimport aiosql\nimport psycopg2\nimport pandas as pd\n```\n\n2️⃣ — SQL 쿼리를 가져와 데이터베이스 드라이버를 설정합시다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsql = aiosql.from_path('src/db/queries', 'psycopg2')\n```\n\n3️⃣ — PostgreSQL 데이터베이스에 연결합니다.\n\n```js\npostgres_secrets = {'host': 'localhost','port': 5432, 'user': 'postgres', 'password': 'postgres', 'dbname': 'postgres'}\nconn = psycopg2.connect(**postgres_secrets)\nconn.autocommit = True\n```\n\n## 👥 사용자 이야기 I: 정적 값들\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n위의 사용자 스토리를 기반으로, 먼저 90번째 백분위수 이상의 방문 빈도를 가진 환자 목록을 검색할 수 있는 쿼리를 생성할 것입니다.\n\n1️⃣ — sql 파일에서 첫 번째 사용자 스토리에 대한 쿼리가 있습니다.\n\n다음은 aiosq에서 SQL 문이 구성되는 세 가지 구성 요소입니다:\n\n- 📗 Name: 이는 Python 코드에서 쿼리를 호출하는 데 사용되는 서술적인 이름입니다. 다음 예제에서 이름은 “fn_get_patients_adove_90th_percentile\" 입니다.\n- 📗 Description: 이는 문서 문자열을 생성하는 데 사용되는 자세한 설명입니다. 쿼리의 목적과 맥락에 대해 더 포괄적으로 설명합니다. 다음 예제에서 설명은 “90번째 백분위수 이상의 방문보다 더 많은 환자를 가져옵니다…\" 입니다.\n- 📗 Query: 여기에는 데이터베이스에서 실행될 SQL 쿼리가 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n📄 sql: db/queries/patients.sql\n\n```js\n-- 이름: fn_get_patients_adove_90th_percentile\n-- 모든 환자 중 방문이 90 번째 백분위수보다 많은 환자들을 가져옵니다. 모든 데이터는 encounters 테이블에 저장되어 있습니다.\n WITH patient_visits AS (\n     SELECT\n         patient,\n         COUNT(*) AS visit_count\n     FROM\n         hospital.encounters\n     GROUP BY\n         patient\n ),\n percentil_n AS (\n   SELECT\n     percentile_cont(0.9) WITHIN GROUP (ORDER BY visit_count) AS p_visits\n   FROM\n   patient_visits\n )\n SELECT \n     pv.patient, \n     pv.visit_count\n FROM \n     patient_visits pv\n CROSS JOIN \n     percentil_n pn\n WHERE \n     pv.visit_count \u003e= pn.p_visits;\n```\n\n2️⃣ — 'fn_get_patients_above_90th_percentile' SQL 함수를 데이터베이스 연결 'conn'을 사용하여 실행합니다.\n\n```js\nresponse = sql.fn_get_patients_above_90th_percentile(conn)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n3️⃣ — 이제 응답 객체를 판다스 데이터프레임으로 변환하여 데이터 조작을 더 쉽게 할 수 있습니다.\n\n```python\ndata = pd.DataFrame([item for item in response], columns=['patient_id', 'num_visit'])\n# 데이터프레임 표시.\ndata\n```\n\n![이미지](/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_3.png)\n\n쿼리를 확인하고 싶으면 다음 코드를 사용할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nprint(sql.fn_get_patients_adove_90th_percentile.sql)\n```\n\n## 👥 사용자 스토리 I: 동적 값\n\n이제 우리는 다른 백분위 값들을 받아들일 수 있는 쿼리를 생성하여 전달된 값에 기반하여 동적으로 수정될 수 있도록 할 것입니다. 우리의 경우, 75번째 백분위 이상의 환자 목록을 얻는 예시를 제공할 것입니다.\n\n```js\n-- name: fn_get_patients_above_n_percentile\n WITH patient_visits AS (\n     SELECT\n         patient,\n         COUNT(*) AS visit_count\n     FROM\n         hospital.encounters\n     GROUP BY\n         patient\n ),\n percentil_n AS (\n   SELECT\n     percentile_cont(:percentil_value) WITHIN GROUP (ORDER BY visit_count) AS p_visits\n   FROM\n   patient_visits\n )\n SELECT \n     pv.patient, \n     pv.visit_count\n FROM \n     patient_visits pv\n CROSS JOIN \n     percentil_n pn\n WHERE \n     pv.visit_count \u003e= pn.p_visits;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n1️⃣ - 다음 코드는 입력값으로 다른 백분위 값을 허용하는 동적 SQL 쿼리를 실행합니다.\n\n```js\n# 이 경우에는 75 백분위 이상의 환자들을 얻습니다.\nresponse = sql.fn_get_patients_above_n_percentile(conn, percentil_value=0.75)\ndata = pd.DataFrame([item for item in response], columns=['patient_id', 'num_visit'])\n```\n\n## 👥 사용자 스토리 II\n\n이 사용자 스토리를 해결하기 위해 지정된 기간 내에서 가장 일반적인 질환이 있는 환자들을 검색하는 쿼리를 생성할 것입니다. 이 쿼리는 동적이며, 향후 관심 있는 질환 수의 변화를 허용할 것입니다.\n이 쿼리는 세 개의 매개변수를 받습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- num_condition: 우리가 관심 있는 조건의 수를 제한할 수 있게 해줄 것입니다 (예: 가장 일반적인 상위 10개 조건).\n- period_start_date와 period_start_end는 데이터를 검색하려는 시간 창을 정의할 것입니다.\n\n```js\n--name: fn_get_patients_top_conditions\n--주어진 기간 동안 최상위 조건을 가진 환자 가져오기, 환자는 조건을 가진 날 수와 데이터 소스가 병원 스키마인 기준으로 정렬됩니다.\nwith top_n_conditions as(\n  SELECT code, description, COUNT(*) \n   FROM hospital.CONDITIONS \n  GROUP BY code,description \n  ORDER BY COUNT(*) DESC \n  LIMIT :num_condition\n),\ntop_n_condition_patients as (\n  SELECT \n     p.ID, \n     p.FIRST, \n     p.LAST, \n     p.CITY, \n     p.GENDER, \n     EXTRACT(YEAR FROM AGE(p.BIRTHDATE)) AS age,\n     c.start condition_start_date,\n     c.stop condition_stop_date,\n     EXTRACT(DAY FROM (c.stop - c.start )) AS condition_days, \n     c.encounter,\n     c.code,\n     c.description\n   from hospital.patients p \n   inner join hospital.conditions c on c.patient = p.id\n   inner join top_n_conditions t on t.code=c.code\n)\nselect * \n from top_n_condition_patients\n where condition_start_date between :period_start_date and :period_start_end;\n```\n\n```js\nresponse = sql.fn_get_patients_top_conditions(conn, num_condition_days=10, \n period_start_date='2022–01–01', \n period_start_end='2022–12–31')\ncolumn_name=['id', 'first','last','city','gender',\n'age','condition_start_date','condition_stop_date','condition_days','encounter','code','description']\ndata = pd.DataFrame([item for item in response], columns=column_name)\ndata.head()\n```\n\n## 👥 사용자 이야기 III\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 aiosql을 사용하여 테이블을 생성할 것입니다. 만약 SQL 코드를 살펴보시면 # 기호가 추가된 것을 보실 수 있습니다. 이러한 기호들은 aiosql이 다양한 작업을 식별하는 데 사용됩니다.\n\n```js\n--name: fn_create_survey_table#\nCREATE TABLE HOSPITAL.VISIT_SURVEY(\n ID SERIAL PRIMARY KEY,\n PATIENT_ID VARCHAR(50),\n SURVEY_DATE TIMESTAMP,\n RATING INT,\n COMMENTS TEXT,\n CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n\u003cimg src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_4.png\" /\u003e\n\n1️⃣ — 'fn_create_survey_table' SQL 함수를 실행하여 데이터베이스에 새 테이블을 만드세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nsql.fn_create_survey_table(conn)\n```\n\n```js\n# output\nCREATE TABLE\n```\n\n2️⃣ — 테이블이 생성되면 아래 삽입문을 사용하여 환자의 리뷰를 삽입할 수 있습니다.\n\n```js\n-- name: fn_add_one_visit_survey\u003c!\ninsert into HOSPITAL.VISIT_SURVEY(PATIENT_ID,SURVEY_DATE,RATING,COMMENTS) \n values (:patient_id, :survey_date, :rating,:comments) returning ID;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n# 새로운 방문 조사 레코드 추가\nsql.fn_add_one_visit_survey(conn, \n patient_id='8b9a93f6-3df3-203d-932f-f456e00d2c01', \n survey_date='2022-01-01', \n rating=5,\n comments='이 병원 정말 좋아요!' )\n```\n\n3️⃣ — 이제 여러 리뷰를 로드하기 위해 새로운 삽입문을 활용할 것입니다. 이 리뷰들은 딕셔너리 목록에 저장되어 있습니다 (파이썬의 각 딕셔너리는 리뷰에 해당합니다). 이를 수행하기 위해 비슷한 쿼리를 활용하겠지만 그 이름을 수정해야 합니다.\n\n```js\n-- name: fn_add_many_visit_survey*!\n insert into HOSPITAL.VISIT_SURVEY(PATIENT_ID,SURVEY_DATE,RATING,COMMENTS) \n values (:patient_id, :survey_date, :rating ,:comments) returning ID;\n```\n\n```js\n# 여러 방문 조사 레코드 추가\nresponse_survey = [\n     {\n       'patient_id': '8b9a93f6-3df3-203d-932f-f456e00d2c01',\n       'survey_date': '2022-01-01',\n       'rating': 3,\n       'comments': '서비스는 좋았어요. 다만 대기 시간이 조금 길었습니다.'\n     },\n     {\n       'patient_id': '7c8a93f6-4df3-203d-932f-f456e00d2c02',\n       'survey_date': '2022-02-01',\n       'rating': 4,\n       'comments': '직원들이 매우 친절했어요!'\n     },\n     {\n       'patient_id': '6b7a93f6-5ef3-203d-932f-f456e00d2c03',\n       'survey_date': '2022-03-01',\n       'rating': 3,\n       'comments': '대기 시간이 조금 길었습니다.'\n     }\n]\nsql.fn_add_many_visit_survey(conn, response_survey)\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 📚 프로젝트 쿼리 카탈로그\n\n튜토리얼 초반에는 프로젝트용 쿼리 카탈로그를 만들 수 있는 가능성을 언급했습니다. 이 라이브러리는 이 기능을 직접 제공하지는 않지만, 나의 GitHub 저장소에서 이 튜토리얼의 완전한 코드와 데이터에 액세스하여 이를 수행하는 방법을 확인할 수 있습니다.\n\n유용하게 사용하시면, ⭐️ 스타를 남겨주시고 새로운 글 알림을 받기 위해 팔로우해주시면 저에게 큰 도움이 됩니다. 기술 커뮤니티에서 성장하고 더 많은 콘텐츠를 제작할 수 있게 될 것입니다.\n\n# 🔍 최종 결론\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 다양성과 유틸리티: 저는 aiosql이 다른 프로젝트에서 쿼리를 효율적으로 구현할 수 있게 해주는 유용한 라이브러리라고 생각합니다. 이 라이브러리는 SQL 쿼리를 관리하고 실행하는 구조적인 방법을 제공하여 본 코드베이스와 별도로 처리할 수 있어 가독성과 유지 보수성을 향상시킵니다.\n- 유연한 쿼리 처리: aiosql은 데이터베이스 연결을 통해 쿼리를 직접 실행할 수 있는 환경을 제공하지만, 저의 프로젝트에서는 주로 Python 코드로 이미 설정한 클래스를 사용하여 SQL 코드를 반환하고 실행합니다.\n- 다른 데이터베이스: 쿼리를 저장하고 관리할 수 있는 기능은 SQL 데이터베이스를 넘어서기도 합니다. 예를 들어 이 접근 방식은 Neo4j와 같은 NoSQL 데이터베이스에도 적용할 수 있습니다. 구조적인 방식으로 쿼리를 구성하고 처리함으로써 다양한 유형의 데이터베이스와의 상호 작용을 최적화할 수 있습니다.\n\n## 📚 참고 자료\n\n학습하고 싶다면...","ogImage":{"url":"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_0.png"},"coverImage":"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_0.png","tag":["Tech"],"readingTime":12},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e프로젝트에서 데이터베이스와 상호 작용하는 프로그래밍을 할 때, 쿼리를 어떻게 조직화하고 재사용할지 고민하는 일이 종종 있어요. 이럴 때 몇몇 개발자는 쿼리를 보다 동적으로 만들기 위해 문자열을 연결하는 함수를 만들기도 하고, 다른 사람들은 이 쿼리를 정의하는 변수를 만들기를 선호하기도 해요. 일부 더 고급 개발자들은 쿼리를 정의할 때 SQLAlchemy 객체 선언을 사용하기도 하는데, 이 방법은 배우는 곡선이 있어서 더 복잡한 쿼리를 다룰 때 개발 프로세스를 어렵게 만들 수 있어요.\u003c/p\u003e\n\u003cp\u003e어느 날, 저는 코드를 지나치게 복잡하게 만들지 않고도 조직적이고 재사용 가능한 방식으로 작업하기 위한 해결책을 찾던 중 흥미로운 라이브러리인 aiosql을 우연히 발견했어요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다음 기사에서는 aiosql 라이브러리를 어떻게 사용하는지를 검토하고 문서에서 설명되는 내용과 함께 다른 컨텍스트에서 구현하는 데 사용한 몇 가지 방법을 공유하겠습니다.\u003c/p\u003e\n\u003ch1\u003e⚙️ aiosql 라이브러리란 무엇인가요?\u003c/h1\u003e\n\u003cp\u003eAiosql은 🐍파이썬 라이브러리로, SQL 쿼리를 주요 파이썬 프로젝트 코드와 분리된 파일에 쉽게 작성할 수 있도록 도와줍니다. 이러한 쿼리는 SQL 파일에 저장되며, 이후에는 🐍파이썬 객체 내의 메서드로 변환됩니다.\u003c/p\u003e\n\u003cp\u003eAiosql의 또 다른 주목할 만한 기능은 매개변수를 받아들이는 동적 메서드를 생성할 수 있는 능력으로, 유연한 쿼리 실행과 기본 데이터베이스와의 효과적인 상호 작용을 가능케합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eSQL 쿼리를 Python 코드에서 분리함으로써 코드를 더 깔끔하고 모듈식으로 유지하는 데 도움이 됩니다. 이는 프로젝트의 가독성과 유지보수성을 향상시킵니다.\u003c/p\u003e\n\u003ch1\u003e⚙️ aiosql의 작동 방식\u003c/h1\u003e\n\u003cp\u003e다이어그램에서 볼 수 있듯이 SQL 파일에서 모든 쿼리를 가져와서 Python 코드에서 쿼리 헤더에 정의된 이름으로 호출하여 사용할 수 있습니다. 이후에 Python 코드에서 필요한 매개변수를 직접 전달하여 쿼리를 실행할 수 있습니다. 이를 통해 쿼리를 재사용하고 유지보수하기 쉽게 만들 수 있습니다.\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_1.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e⚙️ Aiosql 라이브러리 핵심 기능\u003c/h1\u003e\n\u003cp\u003e아래에서는 이 라이브러리가 이미 갖고 있거나 사용에 기반한 기능을 가질 수 있는 일련의 기능을 공유하겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e데이터베이스 작업을 위한 CRUD 기능 제공 (Create: Insert, Read: Select, Update, Delete).\u003c/li\u003e\n\u003cli\u003ePython 코드와 SQL 코드를 분리하여 여러 데이터베이스가 있는 프로젝트에서 쿼리를 찾기 쉽게 함.\u003c/li\u003e\n\u003cli\u003e각 쿼리에 설명적인 이름과 독스트링을 할당할 수 있어 Python 함수와 유사하게 쿼리를 문서화할 수 있음.\u003c/li\u003e\n\u003cli\u003e프로젝트 내에서 쿼리 카탈로그를 작성하도록 지원하여 엔터티, 데이터베이스 또는 기타 그룹별 식별을 용이하게 함.\u003c/li\u003e\n\u003cli\u003e동적 값 전달과 필요에 따라 수정할 수 있는 동적 쿼리를 쉽게 생성할 수 있음.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2.png\" alt=\"PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2\"\u003e\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e⚙️ Aiosql 튜토리얼\u003c/h1\u003e\n\u003ch2\u003e🔧 사전 준비 사항\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e🐳 도커\u003c/li\u003e\n\u003cli\u003e🐙 도커 컴포즈\u003c/li\u003e\n\u003cli\u003e🐍 Python 라이브러리 설치:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epip install aiosql pandas\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e🚀 빠른 시작\u003c/h1\u003e\n\u003ch2\u003e🛠️ 포스트그레스 데이터베이스 만들기\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e1️⃣ — 이 저장소를 복제합니다: aiosql-tutorial\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003egit clone \u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//github.com/r0mymendez/aiosql-tutorial.git\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e2️⃣ 'postgres' 폴더로 디렉토리 변경해주세요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd aiosql-tutorial/postgres\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e3️⃣ PostgreSQL 데이터베이스를 생성해주세요 → 터미널에서 실행하세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker-compose -f docker-compose.\u003cspan class=\"hljs-property\"\u003eyml\u003c/span\u003e up --build\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e4️⃣ 이제 컨테이너가 실행 중인지 확인하세요 → 터미널에서 다음을 실행해보세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003edocker ps\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e5️⃣ CSV 파일을 로드하세요 → 컨테이너 내에서 CSV 파일을 로드하려면 다음 명령어를 실행하세요:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003ecd src\npython3 etl.\u003cspan class=\"hljs-property\"\u003epy\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e🏥 병원 데이터\u003c/h1\u003e\n\u003cp\u003eaiosql을 구현하기 위해 Synthea에서 제공하는 데이터셋을 사용할 것입니다. 이 데이터는 매사추세츠 지역 인구의 다양한 변수를 고려한 시뮬레이션에서 생성된 합성 데이터입니다. 이 데이터셋에서는 \u003ccode\u003econditions\u003c/code\u003e, \u003ccode\u003eencounters\u003c/code\u003e, \u003ccode\u003epatients\u003c/code\u003e 테이블을 사용할 것입니다.\u003c/p\u003e\n\u003ch1\u003e👥 사용자 이야기\u003c/h1\u003e\n\u003cp\u003e실제 상황을 반영하기 위해 3가지 사용 사례를 만들어보겠습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e1️⃣ — 데이터 분석가로서, 방문 횟수가 90번 백분위 이상인 환자 목록을 검색할 수 있기를 원합니다. 이를 통해 병원에서 가장 활발한 환자들을 식별할 수 있습니다. 또한 나중에 쉽게 조정할 수 있도록 이 백분위를 구성할 수 있기를 원합니다.\u003c/li\u003e\n\u003cli\u003e2️⃣ — \u003cstrong\u003e연구원 또는 데이터 분석가\u003c/strong\u003e로서, 일정 기간 동안 가장 빈도가 높은 10가지 진단을 받은 환자 데이터에 액세스하고, 추세를 분석하고 의료 서비스의 품질을 개선하기 위해 사용하고 싶습니다.\u003c/li\u003e\n\u003cli\u003e3️⃣ — \u003cstrong\u003e마케팅 분석가\u003c/strong\u003e로서, 환자 만족도 조사용 테이블을 작성하고, 의료 서비스의 품질에 대한 피드백을 수집하여 개선 조치를 취하고자 합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e🚀 구현\u003c/h1\u003e\n\u003cp\u003e우리가 만들 것인 사용자 스토리에 기반하여, 실행해야 하는 쿼리와 스크립트를 로드할 두 개의 파일을 정의할 것입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epatients.sql: 회복 중인 환자 데이터에 관련된 모든 쿼리가 있는 곳입니다.\u003c/li\u003e\n\u003cli\u003evisits.sql: 설문 조사와 같은 방문에 관련된 모든 쿼리가 있는 곳입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그러므로 우리 프로젝트에서는 이러한 폴더 및 파일 구조를 가지게 될 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e📁 db\n\n    - 📁 queries\n        - 📄 patients.\u003cspan class=\"hljs-property\"\u003esql\u003c/span\u003e\n        - 📄 visits.\u003cspan class=\"hljs-property\"\u003esql\u003c/span\u003e\n\n📄 main.\u003cspan class=\"hljs-property\"\u003eipynb\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e1️⃣ — Python 라이브러리를 가져옵시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e aiosql\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e psycopg2\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e2️⃣ — SQL 쿼리를 가져와 데이터베이스 드라이버를 설정합시다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esql = aiosql.\u003cspan class=\"hljs-title function_\"\u003efrom_path\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'src/db/queries'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'psycopg2'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e3️⃣ — PostgreSQL 데이터베이스에 연결합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003epostgres_secrets = {\u003cspan class=\"hljs-string\"\u003e'host'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'localhost'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'port'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5432\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'user'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'postgres'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'password'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'postgres'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'dbname'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'postgres'\u003c/span\u003e}\nconn = psycopg2.\u003cspan class=\"hljs-title function_\"\u003econnect\u003c/span\u003e(**postgres_secrets)\nconn.\u003cspan class=\"hljs-property\"\u003eautocommit\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e👥 사용자 이야기 I: 정적 값들\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e위의 사용자 스토리를 기반으로, 먼저 90번째 백분위수 이상의 방문 빈도를 가진 환자 목록을 검색할 수 있는 쿼리를 생성할 것입니다.\u003c/p\u003e\n\u003cp\u003e1️⃣ — sql 파일에서 첫 번째 사용자 스토리에 대한 쿼리가 있습니다.\u003c/p\u003e\n\u003cp\u003e다음은 aiosq에서 SQL 문이 구성되는 세 가지 구성 요소입니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e📗 Name: 이는 Python 코드에서 쿼리를 호출하는 데 사용되는 서술적인 이름입니다. 다음 예제에서 이름은 “fn_get_patients_adove_90th_percentile\" 입니다.\u003c/li\u003e\n\u003cli\u003e📗 Description: 이는 문서 문자열을 생성하는 데 사용되는 자세한 설명입니다. 쿼리의 목적과 맥락에 대해 더 포괄적으로 설명합니다. 다음 예제에서 설명은 “90번째 백분위수 이상의 방문보다 더 많은 환자를 가져옵니다…\" 입니다.\u003c/li\u003e\n\u003cli\u003e📗 Query: 여기에는 데이터베이스에서 실행될 SQL 쿼리가 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e📄 sql: db/queries/patients.sql\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e-- 이름: fn_get_patients_adove_90th_percentile\n-- 모든 환자 중 방문이 \u003cspan class=\"hljs-number\"\u003e90\u003c/span\u003e 번째 백분위수보다 많은 환자들을 가져옵니다. 모든 데이터는 encounters 테이블에 저장되어 있습니다.\n \u003cspan class=\"hljs-variable constant_\"\u003eWITH\u003c/span\u003e patient_visits \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n     \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n         patient,\n         \u003cspan class=\"hljs-title function_\"\u003eCOUNT\u003c/span\u003e(*) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e visit_count\n     \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e\n         hospital.\u003cspan class=\"hljs-property\"\u003eencounters\u003c/span\u003e\n     \u003cspan class=\"hljs-variable constant_\"\u003eGROUP\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e\n         patient\n ),\n percentil_n \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n   \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n     \u003cspan class=\"hljs-title function_\"\u003epercentile_cont\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0.9\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eWITHIN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGROUP\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e visit_count) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e p_visits\n   \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e\n   patient_visits\n )\n \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n     pv.\u003cspan class=\"hljs-property\"\u003epatient\u003c/span\u003e, \n     pv.\u003cspan class=\"hljs-property\"\u003evisit_count\u003c/span\u003e\n \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \n     patient_visits pv\n \u003cspan class=\"hljs-variable constant_\"\u003eCROSS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eJOIN\u003c/span\u003e \n     percentil_n pn\n \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e \n     pv.\u003cspan class=\"hljs-property\"\u003evisit_count\u003c/span\u003e \u003e= pn.\u003cspan class=\"hljs-property\"\u003ep_visits\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e2️⃣ — 'fn_get_patients_above_90th_percentile' SQL 함수를 데이터베이스 연결 'conn'을 사용하여 실행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresponse = sql.\u003cspan class=\"hljs-title function_\"\u003efn_get_patients_above_90th_percentile\u003c/span\u003e(conn)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e3️⃣ — 이제 응답 객체를 판다스 데이터프레임으로 변환하여 데이터 조작을 더 쉽게 할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003edata = pd.DataFrame([item \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e item \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e response], columns=[\u003cspan class=\"hljs-string\"\u003e'patient_id'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'num_visit'\u003c/span\u003e])\n\u003cspan class=\"hljs-comment\"\u003e# 데이터프레임 표시.\u003c/span\u003e\ndata\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_3.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e쿼리를 확인하고 싶으면 다음 코드를 사용할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003eprint\u003c/span\u003e(sql.\u003cspan class=\"hljs-property\"\u003efn_get_patients_adove_90th_percentile\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esql\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e👥 사용자 스토리 I: 동적 값\u003c/h2\u003e\n\u003cp\u003e이제 우리는 다른 백분위 값들을 받아들일 수 있는 쿼리를 생성하여 전달된 값에 기반하여 동적으로 수정될 수 있도록 할 것입니다. 우리의 경우, 75번째 백분위 이상의 환자 목록을 얻는 예시를 제공할 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e-- \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: fn_get_patients_above_n_percentile\n \u003cspan class=\"hljs-variable constant_\"\u003eWITH\u003c/span\u003e patient_visits \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n     \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n         patient,\n         \u003cspan class=\"hljs-title function_\"\u003eCOUNT\u003c/span\u003e(*) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e visit_count\n     \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e\n         hospital.\u003cspan class=\"hljs-property\"\u003eencounters\u003c/span\u003e\n     \u003cspan class=\"hljs-variable constant_\"\u003eGROUP\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e\n         patient\n ),\n percentil_n \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n   \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n     \u003cspan class=\"hljs-title function_\"\u003epercentile_cont\u003c/span\u003e(:percentil_value) \u003cspan class=\"hljs-variable constant_\"\u003eWITHIN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eGROUP\u003c/span\u003e (\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e visit_count) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e p_visits\n   \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e\n   patient_visits\n )\n \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n     pv.\u003cspan class=\"hljs-property\"\u003epatient\u003c/span\u003e, \n     pv.\u003cspan class=\"hljs-property\"\u003evisit_count\u003c/span\u003e\n \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \n     patient_visits pv\n \u003cspan class=\"hljs-variable constant_\"\u003eCROSS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eJOIN\u003c/span\u003e \n     percentil_n pn\n \u003cspan class=\"hljs-variable constant_\"\u003eWHERE\u003c/span\u003e \n     pv.\u003cspan class=\"hljs-property\"\u003evisit_count\u003c/span\u003e \u003e= pn.\u003cspan class=\"hljs-property\"\u003ep_visits\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e1️⃣ - 다음 코드는 입력값으로 다른 백분위 값을 허용하는 동적 SQL 쿼리를 실행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 이 경우에는 \u003cspan class=\"hljs-number\"\u003e75\u003c/span\u003e 백분위 이상의 환자들을 얻습니다.\nresponse = sql.\u003cspan class=\"hljs-title function_\"\u003efn_get_patients_above_n_percentile\u003c/span\u003e(conn, percentil_value=\u003cspan class=\"hljs-number\"\u003e0.75\u003c/span\u003e)\ndata = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e([item \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e item \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e response], columns=[\u003cspan class=\"hljs-string\"\u003e'patient_id'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'num_visit'\u003c/span\u003e])\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e👥 사용자 스토리 II\u003c/h2\u003e\n\u003cp\u003e이 사용자 스토리를 해결하기 위해 지정된 기간 내에서 가장 일반적인 질환이 있는 환자들을 검색하는 쿼리를 생성할 것입니다. 이 쿼리는 동적이며, 향후 관심 있는 질환 수의 변화를 허용할 것입니다.\n이 쿼리는 세 개의 매개변수를 받습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003enum_condition: 우리가 관심 있는 조건의 수를 제한할 수 있게 해줄 것입니다 (예: 가장 일반적인 상위 10개 조건).\u003c/li\u003e\n\u003cli\u003eperiod_start_date와 period_start_end는 데이터를 검색하려는 시간 창을 정의할 것입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e--\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: fn_get_patients_top_conditions\n--주어진 기간 동안 최상위 조건을 가진 환자 가져오기, 환자는 조건을 가진 날 수와 데이터 소스가 병원 스키마인 기준으로 정렬됩니다.\n\u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e top_n_conditions \u003cspan class=\"hljs-title function_\"\u003eas\u003c/span\u003e(\n  \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e code, description, \u003cspan class=\"hljs-title function_\"\u003eCOUNT\u003c/span\u003e(*) \n   \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e hospital.\u003cspan class=\"hljs-property\"\u003eCONDITIONS\u003c/span\u003e \n  \u003cspan class=\"hljs-variable constant_\"\u003eGROUP\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e code,description \n  \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eCOUNT\u003c/span\u003e(*) \u003cspan class=\"hljs-variable constant_\"\u003eDESC\u003c/span\u003e \n  \u003cspan class=\"hljs-variable constant_\"\u003eLIMIT\u003c/span\u003e :num_condition\n),\ntop_n_condition_patients \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e (\n  \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n     p.\u003cspan class=\"hljs-property\"\u003eID\u003c/span\u003e, \n     p.\u003cspan class=\"hljs-property\"\u003eFIRST\u003c/span\u003e, \n     p.\u003cspan class=\"hljs-property\"\u003eLAST\u003c/span\u003e, \n     p.\u003cspan class=\"hljs-property\"\u003eCITY\u003c/span\u003e, \n     p.\u003cspan class=\"hljs-property\"\u003eGENDER\u003c/span\u003e, \n     \u003cspan class=\"hljs-title function_\"\u003eEXTRACT\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eYEAR\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eAGE\u003c/span\u003e(p.\u003cspan class=\"hljs-property\"\u003eBIRTHDATE\u003c/span\u003e)) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e age,\n     c.\u003cspan class=\"hljs-property\"\u003estart\u003c/span\u003e condition_start_date,\n     c.\u003cspan class=\"hljs-property\"\u003estop\u003c/span\u003e condition_stop_date,\n     \u003cspan class=\"hljs-title function_\"\u003eEXTRACT\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eDAY\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e (c.\u003cspan class=\"hljs-property\"\u003estop\u003c/span\u003e - c.\u003cspan class=\"hljs-property\"\u003estart\u003c/span\u003e )) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e condition_days, \n     c.\u003cspan class=\"hljs-property\"\u003eencounter\u003c/span\u003e,\n     c.\u003cspan class=\"hljs-property\"\u003ecode\u003c/span\u003e,\n     c.\u003cspan class=\"hljs-property\"\u003edescription\u003c/span\u003e\n   \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e hospital.\u003cspan class=\"hljs-property\"\u003epatients\u003c/span\u003e p \n   inner join hospital.\u003cspan class=\"hljs-property\"\u003econditions\u003c/span\u003e c on c.\u003cspan class=\"hljs-property\"\u003epatient\u003c/span\u003e = p.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e\n   inner join top_n_conditions t on t.\u003cspan class=\"hljs-property\"\u003ecode\u003c/span\u003e=c.\u003cspan class=\"hljs-property\"\u003ecode\u003c/span\u003e\n)\nselect * \n \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e top_n_condition_patients\n where condition_start_date between :period_start_date and :period_start_end;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eresponse = sql.\u003cspan class=\"hljs-title function_\"\u003efn_get_patients_top_conditions\u003c/span\u003e(conn, num_condition_days=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e, \n period_start_date=\u003cspan class=\"hljs-string\"\u003e'2022–01–01'\u003c/span\u003e, \n period_start_end=\u003cspan class=\"hljs-string\"\u003e'2022–12–31'\u003c/span\u003e)\ncolumn_name=[\u003cspan class=\"hljs-string\"\u003e'id'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'first'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'last'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'city'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'gender'\u003c/span\u003e,\n\u003cspan class=\"hljs-string\"\u003e'age'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'condition_start_date'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'condition_stop_date'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'condition_days'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'encounter'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'code'\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e'description'\u003c/span\u003e]\ndata = pd.\u003cspan class=\"hljs-title class_\"\u003eDataFrame\u003c/span\u003e([item \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e item \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e response], columns=column_name)\ndata.\u003cspan class=\"hljs-title function_\"\u003ehead\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e👥 사용자 이야기 III\u003c/h2\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이제 aiosql을 사용하여 테이블을 생성할 것입니다. 만약 SQL 코드를 살펴보시면 # 기호가 추가된 것을 보실 수 있습니다. 이러한 기호들은 aiosql이 다양한 작업을 식별하는 데 사용됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e--\u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: fn_create_survey_table#\n\u003cspan class=\"hljs-variable constant_\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTABLE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eHOSPITAL\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eVISIT_SURVEY\u003c/span\u003e(\n \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSERIAL\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRIMARY\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eKEY\u003c/span\u003e,\n \u003cspan class=\"hljs-variable constant_\"\u003ePATIENT_ID\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eVARCHAR\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e),\n \u003cspan class=\"hljs-variable constant_\"\u003eSURVEY_DATE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTIMESTAMP\u003c/span\u003e,\n \u003cspan class=\"hljs-variable constant_\"\u003eRATING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINT\u003c/span\u003e,\n \u003cspan class=\"hljs-variable constant_\"\u003eCOMMENTS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTEXT\u003c/span\u003e,\n \u003cspan class=\"hljs-variable constant_\"\u003eCREATED_AT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTIMESTAMP\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDEFAULT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCURRENT_TIMESTAMP\u003c/span\u003e\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cimg src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_4.png\"\u003e\n\u003cp\u003e1️⃣ — 'fn_create_survey_table' SQL 함수를 실행하여 데이터베이스에 새 테이블을 만드세요.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esql.\u003cspan class=\"hljs-title function_\"\u003efn_create_survey_table\u003c/span\u003e(conn)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# output\n\u003cspan class=\"hljs-variable constant_\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTABLE\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e2️⃣ — 테이블이 생성되면 아래 삽입문을 사용하여 환자의 리뷰를 삽입할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e-- \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: fn_add_one_visit_survey\u0026#x3C;!\ninsert into \u003cspan class=\"hljs-variable constant_\"\u003eHOSPITAL\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eVISIT_SURVEY\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003ePATIENT_ID\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eSURVEY_DATE\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eRATING\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eCOMMENTS\u003c/span\u003e) \n values (:patient_id, :survey_date, :rating,:comments) returning \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 새로운 방문 조사 레코드 추가\nsql.\u003cspan class=\"hljs-title function_\"\u003efn_add_one_visit_survey\u003c/span\u003e(conn, \n patient_id=\u003cspan class=\"hljs-string\"\u003e'8b9a93f6-3df3-203d-932f-f456e00d2c01'\u003c/span\u003e, \n survey_date=\u003cspan class=\"hljs-string\"\u003e'2022-01-01'\u003c/span\u003e, \n rating=\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e,\n comments=\u003cspan class=\"hljs-string\"\u003e'이 병원 정말 좋아요!'\u003c/span\u003e )\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e3️⃣ — 이제 여러 리뷰를 로드하기 위해 새로운 삽입문을 활용할 것입니다. 이 리뷰들은 딕셔너리 목록에 저장되어 있습니다 (파이썬의 각 딕셔너리는 리뷰에 해당합니다). 이를 수행하기 위해 비슷한 쿼리를 활용하겠지만 그 이름을 수정해야 합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e-- \u003cspan class=\"hljs-attr\"\u003ename\u003c/span\u003e: fn_add_many_visit_survey*!\n insert into \u003cspan class=\"hljs-variable constant_\"\u003eHOSPITAL\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eVISIT_SURVEY\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003ePATIENT_ID\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eSURVEY_DATE\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eRATING\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eCOMMENTS\u003c/span\u003e) \n values (:patient_id, :survey_date, :rating ,:comments) returning \u003cspan class=\"hljs-variable constant_\"\u003eID\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 여러 방문 조사 레코드 추가\nresponse_survey = [\n     {\n       \u003cspan class=\"hljs-string\"\u003e'patient_id'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'8b9a93f6-3df3-203d-932f-f456e00d2c01'\u003c/span\u003e,\n       \u003cspan class=\"hljs-string\"\u003e'survey_date'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'2022-01-01'\u003c/span\u003e,\n       \u003cspan class=\"hljs-string\"\u003e'rating'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\n       \u003cspan class=\"hljs-string\"\u003e'comments'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'서비스는 좋았어요. 다만 대기 시간이 조금 길었습니다.'\u003c/span\u003e\n     },\n     {\n       \u003cspan class=\"hljs-string\"\u003e'patient_id'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'7c8a93f6-4df3-203d-932f-f456e00d2c02'\u003c/span\u003e,\n       \u003cspan class=\"hljs-string\"\u003e'survey_date'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'2022-02-01'\u003c/span\u003e,\n       \u003cspan class=\"hljs-string\"\u003e'rating'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e,\n       \u003cspan class=\"hljs-string\"\u003e'comments'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'직원들이 매우 친절했어요!'\u003c/span\u003e\n     },\n     {\n       \u003cspan class=\"hljs-string\"\u003e'patient_id'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'6b7a93f6-5ef3-203d-932f-f456e00d2c03'\u003c/span\u003e,\n       \u003cspan class=\"hljs-string\"\u003e'survey_date'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'2022-03-01'\u003c/span\u003e,\n       \u003cspan class=\"hljs-string\"\u003e'rating'\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e,\n       \u003cspan class=\"hljs-string\"\u003e'comments'\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'대기 시간이 조금 길었습니다.'\u003c/span\u003e\n     }\n]\nsql.\u003cspan class=\"hljs-title function_\"\u003efn_add_many_visit_survey\u003c/span\u003e(conn, response_survey)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e📚 프로젝트 쿼리 카탈로그\u003c/h1\u003e\n\u003cp\u003e튜토리얼 초반에는 프로젝트용 쿼리 카탈로그를 만들 수 있는 가능성을 언급했습니다. 이 라이브러리는 이 기능을 직접 제공하지는 않지만, 나의 GitHub 저장소에서 이 튜토리얼의 완전한 코드와 데이터에 액세스하여 이를 수행하는 방법을 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e유용하게 사용하시면, ⭐️ 스타를 남겨주시고 새로운 글 알림을 받기 위해 팔로우해주시면 저에게 큰 도움이 됩니다. 기술 커뮤니티에서 성장하고 더 많은 콘텐츠를 제작할 수 있게 될 것입니다.\u003c/p\u003e\n\u003ch1\u003e🔍 최종 결론\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e다양성과 유틸리티: 저는 aiosql이 다른 프로젝트에서 쿼리를 효율적으로 구현할 수 있게 해주는 유용한 라이브러리라고 생각합니다. 이 라이브러리는 SQL 쿼리를 관리하고 실행하는 구조적인 방법을 제공하여 본 코드베이스와 별도로 처리할 수 있어 가독성과 유지 보수성을 향상시킵니다.\u003c/li\u003e\n\u003cli\u003e유연한 쿼리 처리: aiosql은 데이터베이스 연결을 통해 쿼리를 직접 실행할 수 있는 환경을 제공하지만, 저의 프로젝트에서는 주로 Python 코드로 이미 설정한 클래스를 사용하여 SQL 코드를 반환하고 실행합니다.\u003c/li\u003e\n\u003cli\u003e다른 데이터베이스: 쿼리를 저장하고 관리할 수 있는 기능은 SQL 데이터베이스를 넘어서기도 합니다. 예를 들어 이 접근 방식은 Neo4j와 같은 NoSQL 데이터베이스에도 적용할 수 있습니다. 구조적인 방식으로 쿼리를 구성하고 처리함으로써 다양한 유형의 데이터베이스와의 상호 작용을 최적화할 수 있습니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e📚 참고 자료\u003c/h2\u003e\n\u003cp\u003e학습하고 싶다면...\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement"},"buildId":"8coAiP0lmiEK5aH6nkQkj","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>