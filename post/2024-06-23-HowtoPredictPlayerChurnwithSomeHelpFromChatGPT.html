<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>ChatGPT를 이용한 플레이어 이탈 예측 방법 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="ChatGPT를 이용한 플레이어 이탈 예측 방법 | itposting" data-gatsby-head="true"/><meta property="og:title" content="ChatGPT를 이용한 플레이어 이탈 예측 방법 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT" data-gatsby-head="true"/><meta name="twitter:title" content="ChatGPT를 이용한 플레이어 이탈 예측 방법 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-23 16:39" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_buildManifest.js" defer=""></script><script src="/_next/static/CYQjEY3HhSkRTiL0gewc0/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">ChatGPT를 이용한 플레이어 이탈 예측 방법</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="ChatGPT를 이용한 플레이어 이탈 예측 방법" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 23, 2024</span><span class="posts_reading_time__f7YPP">21<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h2>저 코드 머신 러닝 플랫폼을 활용한 데이터 과학 | ACTABLE AI</h2>
<p><img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_0.png" alt="이미지"></p>
<h1>소개</h1>
<p>게임 산업에서 기업들은 플레이어를 유치하는 것 뿐만 아니라 특히 인게임 마이크로 트랜잭션에 의존하는 프리투플레이 게임에서 가능한 한 오랫동안 유지시키려고 노력합니다. 이러한 마이크로 트랜잭션은 종종 인게임 화폐 구매를 포함하며, 플레이어가 진행 또는 사용자 정의를 위한 아이템을 획득하고 게임 개발을 지원합니다. 중단하는 플레이어 수를 나타내는 이탈률을 모니터링하는 것이 중요합니다. 이는 높은 이탈율은 수입 손실을 의미하며, 이는 개발자와 관리자의 스트레스 수준이 증가하게 됩니다.</p>
<div class="content-ad"></div>
<p>이 기사는 특정 모바일 앱에서 획득한 데이터를 기반으로 한 실제 데이터셋의 사용을 탐색하며, 사용자들이 플레이한 레벨에 중점을 둡니다. 기계 학습을 활용하여 기술 현장에서 중요한 역할을 하며 인공 지능(AI)의 기초를 형성한 이후, 기업들은 자신들의 데이터에서 가치 있는 통찰을 얻을 수 있습니다.</p>
<p>하지만, 기계 학습 모델을 구축하는 것은 일반적으로 코딩과 데이터 과학 전문 지식이 필요하므로, 많은 사람들 및 자원이 부족한 소규모 기업들에게는 접근하기 어렵습니다. 이러한 도전에 대처하기 위해, 로우코드와 노코드 기계 학습 플랫폼이 나타나기 시작했으며, 기계 학습과 데이터 과학 과정을 간소화하여 방대한 코딩 지식이 필요하지 않도록 하는 것을 목표로 합니다. Einblick, KNIME, Dataiku, Alteryx, Akkio와 같은 플랫폼의 예시가 있습니다.</p>
<p>이 기사에서는 하나의 로우코드 기계 학습 플랫폼을 사용하여 사용자가 게임을 중단할지 예측할 수 있는 모델을 훈련하는 방법을 다룹니다. 뿐만 아니라 결과 해석 및 모델 성능을 향상시키는 데 사용할 수 있는 기술에 대해 탐구합니다.</p>
<div class="content-ad"></div>
<p>이 기사의 나머지 부분은 다음과 같이 구성되어 있습니다:</p>
<ul>
<li>플랫폼</li>
<li>데이터셋</li>
<li>탐색적 데이터 분석</li>
<li>분류 모델 훈련</li>
<li>모델 성능 향상</li>
<li>새로운 특징 생성</li>
<li>새로운 (개선된) 분류 모델 훈련</li>
<li>생산 환경에 모델 배포</li>
<li>결론</li>
</ul>
<h1>플랫폼</h1>
<p>전체 공개 - 이 기사 작성 시점에 제가 Actable AI의 데이터 과학자인 사실을 알려드립니다. 따라서 이 기사에서는 해당 플랫폼을 사용할 예정입니다. 또한, 저는 ML 라이브러리에 새로운 기능을 구현하고 유지보수하는 일에 관여하고 있어서, 이 플랫폼이 실제 문제에 대해 어떻게 대응하는지 궁금했습니다.</p>
<div class="content-ad"></div>
<p>플랫폼은 전통적인 분류, 회귀 및 세분화 애플리케이션을 위한 여러 인기있는 머신 러닝 방법을 제공합니다. 시계열 예측, 감성 분석 및 인과 추론과 같은 일부 일반적이지 않은 도구도 이용할 수 있습니다. 또한, 결측 데이터를 보완할 수 있으며 데이터 세트의 통계를 계산하고(특성 간 상관 관계, 분산 분석(ANOVA) 등), 막대 차트, 히스토그램, 워드 클라우드와 같은 도구를 사용하여 데이터를 시각화할 수 있습니다.</p>
<p>Google Sheets 애드온도 제공되어 스프레드시트 내에서 직접 분석과 모델 훈련을 할 수 있습니다. 다만, 이 애드온에서는 최신 기능이 지원되지 않을 수 있으니 참고 바랍니다.</p>
<p><img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_1.png" alt="image"></p>
<p>핵심 라이브러리는 GitHub에서 오픈 소스로 제공되며 AutoGluon 및 scikit-learn과 같은 잘 알려진 신뢰할 수 있는 프레임워크로 구성되어 있습니다. 이는 기존의 오픈 소스 솔루션을 활용하는 다른 관련 플랫폼과 유사합니다.</p>
<div class="content-ad"></div>
<p>그러나, 이에 대한 질문이 생깁니다: 대부분의 도구들이 이미 사용 가능하고 무료로 제공되는데, 왜 이러한 플랫폼을 사용해야 하는지요?</p>
<p>가장 중요한 이유는 이러한 도구들이 Python과 같은 프로그래밍 언어에 대한 지식이 필요하다는 것입니다. 일반적으로 코딩에 익숙하지 않은 사람은 사용하기 어렵거나 불가능할 수 있습니다. 따라서 이러한 플랫폼은 프로그래밍 명령어의 형태로가 아닌 GUI(그래픽 사용자 인터페이스) 형식으로 모든 기능을 제공하려고 합니다.</p>
<p>더 경험이 많은 전문가들은 또한 시간을 절약할 수 있을 뿐만 아니라 쉽게 사용할 수 있는 그래픽 인터페이스를 통해 지원 도구와 기법의 정보를 제공할 수도 있습니다. 일부 플랫폼은 익숙하지 않았던 도구들을 제공하거나 데이터 작업 시 유용한 경고(예: 데이터 누출의 존재 - 모델이 볼 수 없는 데이터의 생산 환경에 배포될 때 사용할 수 없는 특징에 액세스할 수 있는 경우)를 제공할 수도 있습니다.</p>
<p>이러한 종류의 플랫폼을 사용하는 또 다른 이유는 모델을 실행할 하드웨어도 제공하기 때문입니다. 따라서 자신의 컴퓨터나 GPU(Graphical Processing Units)와 같은 구성 요소를 구매하고 유지 관리할 필요가 없습니다.</p>
<div class="content-ad"></div>
<h1>데이터셋</h1>
<p>게임 회사가 제공한 데이터셋은 이곳에서 확인할 수 있으며 CC BY-SA-4 라이센스가 적용되어있어 적절한 크레딧이 제공된다면 공유 및 수정이 허용됩니다. 이 데이터셋은 789,879개의 행(샘플)을 가지고 있어 과적합과 같은 영향을 줄여줄 것으로 예상됩니다.</p>
<p>이 데이터셋은 개인이 모바일 앱에서 플레이한 각 레벨에 관한 정보를 포함하고 있습니다. 예를 들어, 플레이한 시간, 플레이어가 레벨에서 승리했는지 패배했는지, 레벨 번호 등에 대한 정보가 있습니다.</p>
<p>사용자 ID도 포함되어 있지만 원래 플레이어의 신원을 드러내지 않도록 익명화되었습니다. 일부 필드도 제거되었지만, 이 데이터셋은 이 기사에서 고려된 ML 플랫폼에서 제공된 도구가 플레이어의 이탈을 예측하는 데 유용할 수 있는지 확인하는 견고한 기초를 제공할 것으로 예상됩니다.</p>
<div class="content-ad"></div>
<p>각 기능의 의미는 다음과 같습니다:</p>
<ul>
<li>Churn: 플레이어가 게임을 2주 이상 플레이하지 않았을 경우 '1', 그렇지 않으면 '0'</li>
<li>ServerTime: 레벨이 플레이된 서버의 타임스탬프</li>
<li>EndType: 레벨이 종료된 이유 ('승리'일 경우 주로 게임에서 이겼을 때, '패배'일 경우 게임에서 졌을 때)</li>
<li>LevelType: 레벨의 유형</li>
<li>Level: 레벨 번호</li>
<li>SubLevel: 하위 레벨 번호</li>
<li>Variant: 레벨 변형</li>
<li>Levelversion: 레벨 버전</li>
<li>NextCar: 사용되지 않음 (플랫폼이 한 라벨만 포함하는 기능을 처리하는 방법 확인용으로 포함됨)</li>
<li>AddMoves: 추가 이동 횟수</li>
<li>DoubleMana: 사용되지 않음 (플랫폼이 한 라벨만 포함하는 기능을 처리하는 방법 확인용으로 포함됨)</li>
<li>StartMoves: 레벨 시작 시 사용 가능한 이동횟수</li>
<li>ExtraMoves: 구매한 추가 이동 횟수</li>
<li>UsedMoves: 플레이어가 사용한 이동 횟수</li>
<li>UsedChangeCar: 사용되지 않음 (플랫폼이 한 라벨만 포함하는 기능을 처리하는 방법 확인용으로 포함됨)</li>
<li>WatchedVideo: 비디오를 시청했는지 여부, 추가 이동 제공</li>
<li>BuyMoreMoves: 플레이어가 추가 이동을 구매한 횟수</li>
<li>PlayTime: 레벨 플레이에 소요된 시간</li>
<li>Scores: 플레이어가 달성한 점수</li>
<li>UsedCoins: 레벨에서 사용된 총 코인 수</li>
<li>MaxLevel: 플레이어가 도달한 최대 레벨</li>
<li>Platform: 장치 유형</li>
<li>UserID: 플레이어의 ID</li>
<li>RollingLosses: 플레이어의 연속적인 패배 횟수</li>
</ul>
<h1>탐색적 데이터 분석</h1>
<p>학습 전 첫 번째 단계는 탐색적 데이터 분석(EDA)을 통해 데이터를 이해하는 것입니다. EDA는 데이터를 요약, 시각화하고 주요 특성을 이해하는 데이터 분석 방법론입니다. 목표는 데이터로부터 통찰력을 얻고, 어떠한 패턴, 추세, 이상 현상 또는 존재할 수 있는 이슈(예: 결측값)를 식별하여 사용될 특성 및 모델을 확인하는 데 도움이 되는 것입니다.</p>
<div class="content-ad"></div>
<p>주요 이유들을 확인해 보면서 레벨이 종료된 이유에 대해 살펴보겠습니다:</p>
<p><img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_2.png" alt="Image"></p>
<p>위 이미지를 보면 레벨 종료의 주된 이유(EndType으로 표시됨)는 플레이어가 게임에서 패배한 경우(63.6%)가 승리한 경우의 35.2%에 비해 더 많다는 것을 알 수 있습니다. 또한 UsedChangeCar 열은 모든 행에 동일한 값을 포함하고 있어 쓸모없어 보입니다.</p>
<p>매우 중요한 점은 우리의 대상값이 매우 불균형하다는 것입니다. 처음 10,000행 중에서 63개의 샘플만이 (데이터의 0.6%) Churn 값이 1(즉, 플레이어가 이탈함)을 가지고 있다는 것입니다. 이것은 염두에 둘 필요가 있습니다. 왜냐하면 우리의 모델이 Churn에 대해 0의 값을 예측하는 데 매우 편향될 수 있기 때문입니다. 모델이 정확도와 같은 몇 가지 지표에 대해 매우 좋은 값을 얻을 수 있기 때문에, 이 경우에는 가장 일반적인 클래스를 선택하는 더미 모델이 99.4%의 정확도로 정답을 맞출 것입니다! 이에 대해 Baptiste Rocca와 Jason Brownlee의 두 훌륭한 기사에서 더 읽어보시기를 권합니다.</p>
<div class="content-ad"></div>
<p>아쉽게도 Actable AI는 SMOTE(합성 소수 샘플링 기법)를 통해 불균형 데이터를 처리하거나 클래스 가중치 또는 다른 샘플링 전략을 사용하는 방법을 아직 제공하지 않습니다. 이는 최적화를 위해 선택된 지표에 주의를 기울여야 한다는 것을 의미합니다. 위에서 언급한 대로, 정확도는 한 클래스의 샘플이 올바르게 레이블링되지 않아도 높은 비율을 달성할 수 있는 경우라면 최선의 선택이 아닐 것입니다.</p>
<p>또 다른 유용한 분석 유형은 특징들 간의 상관 관계, 특히 예측자 특징과 대상 특징 간의 상관 관계입니다. 이를 수행하기 위해 '상관 분석' 도구를 사용할 수 있으며, 해당 결과는 Actable AI 플랫폼에서 직접 확인할 수 있습니다:</p>
<p><img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_3.png" alt="HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_3"></p>
<p>위 차트에서 파란 막대는 특징이 Churn과 양의 상관 관계가 있는 경우를 나타내며 값이 1인 경우이고, 주황색 막대는 음의 특징 상관 관계를 나타냅니다. 상관 관계는 -1에서 1 사이에 있음을 주의해야 합니다. 양의 값은 두 특징이 함께 변화하는 경향이 있다는 것을 나타내며(예: 둘 다 증가하거나 감소), 음의 상관 관계는 한 특징이 증가하거나 감소할 때 다른 특징이 반대로 변화한다는 것을 나타냅니다. 따라서 상관 관계의 크기(음의 부호를 무시한)가 아마도 가장 중요한 사항일 것입니다.</p>
<div class="content-ad"></div>
<p>특정 수준을 잃은 플레이어들이 (가장 위쪽의 파란 막대) 막적회전에 민감하다는 것이나, 반대로 특정 수준을 이긴 플레이어들은 계속해서 플레이하는 경향이 있다는 등 여러 가지 교훈이 있습니다 (세 번째 오렌지 막대). 그러나 값이 상당히 낮다는 것도 주목해야 합니다. 이는 이러한 특징이 목표와 상관 관계가 약한 것을 의미합니다. 이는 모델이 더 정확한 예측을 수행하기 위해 더 중요한 정보를 포착하는 새로운 기능을 만들어 사용하는 특성 엔지니어링을 수행해야 할 것으로 예상됩니다. 특성 엔지니어링은 이 글의 뒷부분에서 자세히 다룰 것입니다.</p>
<p>하지만 새로운 특성을 생성하기 전에 데이터셋의 원래 특성만 사용하여 어떤 성능을 달성할 수 있는지 살펴보는 것도 좋은 방법입니다. 따라서 다음 단계는 더 흥미로운 것으로, 모델을 훈련시켜 어떤 성능을 달성할 수 있는지 알아보는 것이 될 것입니다.</p>
<h1>분류 모델 훈련</h1>
<p>사용자가 플레이를 중단할지 여부를 예측하고 싶기 때문에, 이는 여러 레이블 중 하나를 선택해야 하는 분류 문제입니다. 우리의 경우, 문제는 두 가지 레이블 중 하나('1'은 '이탈', '0'은 '이탈하지 않음'에 해당)를 할당하는 것을 포함하므로, 이는 이진 분류 문제로 만듭니다.</p>
<div class="content-ad"></div>
<p>이 프로세스는 주로 AutoGluon 라이브러리를 통해 수행되며, 이 라이브러리는 자동으로 여러 모델을 학습한 다음 가장 우수한 성능을 달성한 모델을 선택합니다. 이렇게 하면 각각의 모델을 수동으로 학습하고 그 성능을 비교할 필요가 없어집니다.</p>
<p>Actable AI 플랫폼에서 설정해야 할 여러 매개변수가 있으며, 제가 선택한 옵션은 아래에 나와 있습니다:</p>
<p><img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_4.png" alt="이미지"></p>
<p>모델의 최적화를 위해 사용할 메트릭도 선택할 수 있습니다. 저는 수신자 조작 특성 (ROC) 아래 영역 (AUC ROC) 곡선을 사용했습니다. 이는 이전에 논의된 클래스 불균형 문제에 대해 훨씬 민감하지 않기 때문입니다. 값은 0부터 1까지의 범위를 가지며 (1일수록 완벽한 점수입니다).</p>
<div class="content-ad"></div>
<p>일정 시간이 지난 후에는 결과가 생성되어 표시되며, 여기서도 볼 수 있습니다. 여러 가지 다른 측정 항목이 계산되며, 이는 좋은 실천 방식일 뿐만 아니라 각 측정 항목이 모델 성능의 특정 측면에 집중하기 때문에 우리가 모델을 실제로 이해하려면 거의 필수적입니다.</p>
<p>표시된 첫 번째 메트릭은 최적화 메트릭으로, 값이 0.675입니다:</p>
<p><img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_5.png" alt="이미지"></p>
<p>이것은 크게 좋지는 않지만, EDA 중에 특성이 대상과 상관성이 약한 것을 상기하면, 성능이 별로 두드러지지 않는 것은 놀라운 일이 아닙니다.</p>
<div class="content-ad"></div>
<p>이 결과는 결과를 이해하는 중요성을 강조합니다. 보통 0.997 (즉, 99.7%) 정확도에 대해 매우 만족스러워할 것입니다. 그러나 이는 앞서 언급한 것처럼 데이터 세트의 심각한 불균형 때문이 대부분이므로 그다지 중요하지 않습니다. 한편, 정밀도와 재현율과 같은 점수는 기본적으로 임계값 0.5를 기반으로 하며, 이는 우리의 응용 프로그램에 가장 적합하지 않을 수 있습니다.</p>
<p>ROC 및 정밀도-재현율 곡선도 표시되는데, 이것들 또한 성능이 약간 부족함을 명확히 보여줍니다:</p>
<p>이러한 곡선들은 최종 응용 프로그램에서 사용할 임계값을 결정하는 데도 유용합니다. 예를 들어, 거짓 양성의 수를 최소화하려면 모델이 더 높은 정밀도를 얻는 임계값을 선택하고 해당하는 재현을 확인할 수 있습니다.</p>
<p>얻은 최상의 모델에서 각 피처의 중요성을 확인할 수도 있습니다. 이는 AutoGluon을 통해 순열 중요성을 사용하여 계산됩니다. 결과의 신뢰성을 결정하기 위해 P-값도 표시됩니다:</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_6.png">
<p>아마도 놀랍지 않게도, 가장 중요한 기능은 EndType입니다(레벨이 종료된 이유를 보여주는데, 승리나 패배와 같은 요인), 그 다음은 MaxLevel(사용자가 플레이 한 가장 높은 레벨로, 숫자가 높을수록 플레이어가 게임에 매우 집중하고 활발하다는 것을 의미합니다).</p>
<p>반면에, UsedMoves(플레이어가 수행한 움직임의 수)는 사실상 쓸모없지만, StartMoves(플레이어가 사용할 수있는 움직임의 수)는 실제로 성능을 해칠 수 있습니다. 이것도 논리적입니다. 사용된 움직임 수와 플레이어가 사용할 수있는 움직임 수가 그 자체로는 높은 정보를 가지고 있지 않기 때문에, 두 값간의 비교가 훨씬 유용할 것입니다.</p>
<p>또한 각 클래스(이 경우 1 또는 0)의 추정 확률을 살펴볼 수 있습니다. 이 확률은 예측된 클래스를 도출하기 위해 사용되며(기본적으로 가장 높은 확률을 가진 클래스가 예측된 클래스로 할당됩니다):</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_7.png">
<p>AI의 설명 가능성은 모델 동작을 이해하는 데 더 중요해지고 있으며, 이로 인해 Shapley 값과 같은 도구가 인기를 끌고 있습니다. 이러한 값은 기능이 예측된 클래스의 확률에 미치는 기여를 나타냅니다. 예를 들어, 첫 번째 행에서 RollingLosses 값이 36인 경우, 해당 플레이어가 게임을 계속하는 클래스 (클래스 0)의 확률이 감소함을 볼 수 있습니다.</p>
<p>반대로, 이는 다른 클래스(즉, 플레이어가 이탈하는 클래스 1)의 확률이 증가함을 의미합니다. 이는 RollingLosses 값이 높을수록 플레이어가 연속해서 많은 레벨을 잃었고, 따라서 좌절하여 게임을 그만 둘 가능성이 높다는 것을 의미합니다. 반면, RollingLosses 값이 낮을수록 부정적인 클래스(즉, 플레이어가 게임을 그만 두지 않을 가능성)의 확률이 일반적으로 향상됩니다.</p>
<p>언급한 바와 같이 여러 모델이 훈련되고 평가된 후, 그 중에서 최적의 모델이 선택됩니다. 흥미로운 점은 이 경우 최고의 모델이 LightGBM임과 동시에 가장 빠른 모델 중 하나인 것입니다:</p>
<div class="content-ad"></div>
<p>마크다운 형식으로 테이블 태그를 변경해보세요.</p>
<h1>모델 성능 향상</h1>
<p>지금 이 시점에서는 모델의 성능을 향상시킬 수 있습니다. 아마도 가장 쉬운 방법 중 하나는 '품질 최적화' 옵션을 선택하고 얼마나 나아질 수 있는지 확인하는 것입니다. 이 옵션은 일반적으로 성능을 향상시키는 몇 가지 매개변수를 구성하며, 단단한 학습 시간의 비용으로 이루어집니다. 다음 결과를 얻었습니다 (여기에서도 확인할 수 있습니다):</p>
<img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_9.png">
<div class="content-ad"></div>
<p>다시 ROC AUC 지표에 초점을 맞추면, 성능이 0.675에서 0.709로 향상되었습니다. 이렇게 간단한 변경으로 성능이 상당히 향상된 것입니다. 하지만 여전히 이상적인 수준에서는 멀리 떨어져 있습니다. 더 나은 성능을 위해 우리가 할 수 있는 다른 방법이 있을까요?</p>
<h1>새로운 기능 만들기</h1>
<p>이전에 논의한 대로, 이것을 특성 공학을 사용하여 수행할 수 있습니다. 이것은 기존 기능에서 새로운 기능을 만드는 것을 의미하며, 이러한 새로운 기능은 더 강력한 패턴을 포착하고 예측할 변수와 더 높은 상관 관계를 갖도록 할 수 있습니다.</p>
<p>우리의 경우, 데이터 세트의 기능은 사용자가 플레이한 레벨에 관한 정보에 대한 값만을 갖기 때문에 범위가 상당히 좁습니다. 따라서, 시간을 거쳐 레코드를 요약함으로써 더 전반적인 전망을 얻는 것이 매우 유용할 수 있습니다. 이렇게 함으로써 모델은 사용자의 역사적인 추세에 대한 지식을 가질 수 있을 것입니다.</p>
<div class="content-ad"></div>
<p>예를 들어, 플레이어가 사용한 추가 움직임의 수를 확인하여 경험한 난이도를 측정할 수 있습니다. 추가 움직임이 거의 필요하지 않았다면, 레벨이 너무 쉬웠을 수도 있습니다. 반대로 많은 숫자는 레벨이 너무 어려웠을 수도 있습니다.</p>
<p>또한, 플레이어가 게임에 몰입하고 참여하고 있는지 확인하기 위해 이전 몇 날 동안 게임을 플레이한 시간을 확인하는 것도 좋은 아이디어일 것입니다. 게임을 별로 하지 않았다면, 그들이 흥미를 잃고 곧 그만둘 수도 있다는 의미일 수 있습니다.</p>
<p>유용한 특징들은 서로 다른 도메인에서 다양하기 때문에 현재 작업과 관련된 정보를 찾는 것이 중요합니다. 예를 들어, 연구 논문, 사례 연구 및 기사를 찾거나 해당 분야에서 일한 회사나 전문가들의 조언을 구하면 가장 일반적인 특징, 특징 간의 관계, 잠재적인 함정 및 유용할 것으로 예상되는 새로운 특징들에 대해 숙련된 지식이 있는 사람들로부터 도움을 받을 수 있습니다. 이러한 접근 방식은 시행착오를 줄이고 특징 엔지니어링 프로세스를 가속화하는 데 도움이 됩니다.</p>
<p>최근 대규모 언어 모델(LLMs)의 발전과 (예: ChatGPT를 들어본 적이 있을지도 모르죠...), 그리고 특징 엔지니어링 프로세스가 경험 부족한 사용자에게는 다소 어려울 수 있기 때문에, LLMs가 어떤 특징을 생성할 수 있는 아이디어를 제공하는 데 어떤 지원이 될 수 있는지 궁금했습니다. 저는 이를 테스트해보았고, 다음 결과가 나왔습니다:</p>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_10.png">
<p>차트 GPT의 답변은 실제로 아주 좋습니다. 또한 앞서 언급한 바와 같이 여러 시간 기반 특성을 가리키기도 합니다. 물론 필요한 정보가 없을 경우 모든 제안된 기능을 구현할 수 없을 수도 있음을 염두에 두세요. 게다가 이것은 망상에 빠지기 쉬우며, 따라서 완전히 정확한 답변을 제공하지 못할 수도 있습니다.</p>
<p>ChatGPT로부터 더 관련성 높은 응답을 받으려면 사용 중인 특성을 지정하거나 프롬프트를 활용하는 등의 방법을 사용할 수 있습니다. 그러나 이는 본 문서의 범위를 벗어나므로 독자들에게 연습 과제로 남겨두겠습니다. 그럼에도 불구하고, LLMs는 시작 단계로 고려할 수 있지만, 논문, 전문가 등보다 신뢰할 만한 정보를 얻기 위해 노력하는 것이 강력히 권장됩니다.</p>
<p>Actable AI 플랫폼에서는 상당히 잘 알려진 SQL 프로그래밍 언어를 사용하여 새로운 기능을 만들 수 있습니다. SQL에 익숙하지 않은 사용자를 위해 ChatGPT를 활용하여 쿼리를 자동으로 생성하는 방법이 유용할 수 있습니다. 그러나 내가 제한된 실험을 통해 이 방법의 신뢰성은 다소 일관되지 않을 수 있다는 것을 발견했습니다.</p>
<div class="content-ad"></div>
<p>원하는 결과를 정확하게 계산하기 위해 의도한 출력물을 수동으로 확인하여 검증하는 것이 좋습니다. SQL Lab에서 쿼리를 실행한 후에 나타나는 테이블을 확인하여 이를 확인할 수 있습니다. Actable AI는 SQL 코드를 작성하고 실행하는 인터페이스입니다.</p>
<p>다음은 새로운 열을 생성하는 데 사용한 SQL 코드입니다. 다른 기능을 만들고 싶다면 이것을 참고하여 시작할 수 있을 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">SELECT</span> 
    *,
    <span class="hljs-title function_">SUM</span>(<span class="hljs-string">"PlayTime"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">UserLevelWindow</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"time_spent_on_level"</span>,
    (a.<span class="hljs-string">"Max_Level"</span> - a.<span class="hljs-string">"Min_Level"</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"levels_completed_in_last_7_days"</span>,
    <span class="hljs-title function_">COALESCE</span>(<span class="hljs-title function_">CAST</span>(<span class="hljs-string">"total_wins_in_last_14_days"</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-variable constant_">DECIMAL</span>)/<span class="hljs-title function_">NULLIF</span>(<span class="hljs-string">"total_losses_in_last_14_days"</span>, <span class="hljs-number">0</span>), <span class="hljs-number">0.0</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"win_to_lose_ratio_in_last_14_days"</span>,
    <span class="hljs-title function_">COALESCE</span>(<span class="hljs-title function_">SUM</span>(<span class="hljs-string">"UsedCoins"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">User1DayWindow</span>, <span class="hljs-number">0</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"UsedCoins_in_last_1_days"</span>,
    <span class="hljs-title function_">COALESCE</span>(<span class="hljs-title function_">SUM</span>(<span class="hljs-string">"UsedCoins"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">User7DayWindow</span>, <span class="hljs-number">0</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"UsedCoins_in_last_7_days"</span>,
    <span class="hljs-title function_">COALESCE</span>(<span class="hljs-title function_">SUM</span>(<span class="hljs-string">"UsedCoins"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">User14DayWindow</span>, <span class="hljs-number">0</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"UsedCoins_in_last_14_days"</span>,
    <span class="hljs-title function_">COALESCE</span>(<span class="hljs-title function_">SUM</span>(<span class="hljs-string">"ExtraMoves"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">User1DayWindow</span>, <span class="hljs-number">0</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"ExtraMoves_in_last_1_days"</span>,
    <span class="hljs-title function_">COALESCE</span>(<span class="hljs-title function_">SUM</span>(<span class="hljs-string">"ExtraMoves"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">User7DayWindow</span>, <span class="hljs-number">0</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"ExtraMoves_in_last_7_days"</span>,
    <span class="hljs-title function_">COALESCE</span>(<span class="hljs-title function_">SUM</span>(<span class="hljs-string">"ExtraMoves"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">User14DayWindow</span>, <span class="hljs-number">0</span>) <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"ExtraMoves_in_last_14_days"</span>,
    <span class="hljs-title function_">AVG</span>(<span class="hljs-string">"RollingLosses"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">User7DayWindow</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"RollingLosses_mean_last_7_days"</span>,
    <span class="hljs-title function_">AVG</span>(<span class="hljs-string">"MaxLevel"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">PastWindow</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"MaxLevel_mean"</span>
<span class="hljs-variable constant_">FROM</span> (
    <span class="hljs-variable constant_">SELECT</span>
        *,
        <span class="hljs-title function_">MAX</span>(<span class="hljs-string">"Level"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">User7DayWindow</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"Max_Level"</span>,
        <span class="hljs-title function_">MIN</span>(<span class="hljs-string">"Level"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">User7DayWindow</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"Min_Level"</span>,
        <span class="hljs-title function_">SUM</span>(<span class="hljs-variable constant_">CASE</span> <span class="hljs-variable constant_">WHEN</span> <span class="hljs-string">"EndType"</span> = <span class="hljs-string">'Lose'</span> <span class="hljs-variable constant_">THEN</span> <span class="hljs-number">1</span> <span class="hljs-variable constant_">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-variable constant_">END</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">User14DayWindow</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"total_losses_in_last_14_days"</span>,
        <span class="hljs-title function_">SUM</span>(<span class="hljs-variable constant_">CASE</span> <span class="hljs-variable constant_">WHEN</span> <span class="hljs-string">"EndType"</span> = <span class="hljs-string">'Win'</span> <span class="hljs-variable constant_">THEN</span> <span class="hljs-number">1</span> <span class="hljs-variable constant_">ELSE</span> <span class="hljs-number">0</span> <span class="hljs-variable constant_">END</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">User14DayWindow</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"total_wins_in_last_14_days"</span>,
        <span class="hljs-title function_">SUM</span>(<span class="hljs-string">"PlayTime"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">User7DayWindow</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"PlayTime_cumul_7_days"</span>,
        <span class="hljs-title function_">SUM</span>(<span class="hljs-string">"RollingLosses"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">User7DayWindow</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"RollingLosses_cumul_7_days"</span>,
        <span class="hljs-title function_">SUM</span>(<span class="hljs-string">"PlayTime"</span>) <span class="hljs-variable constant_">OVER</span> <span class="hljs-title class_">UserPastWindow</span> <span class="hljs-variable constant_">AS</span> <span class="hljs-string">"PlayTime_cumul"</span>
    <span class="hljs-variable constant_">FROM</span> <span class="hljs-string">"game_data_levels"</span>
    <span class="hljs-variable constant_">WINDOW</span>
        <span class="hljs-title class_">User7DayWindow</span> <span class="hljs-variable constant_">AS</span> (
            <span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"UserID"</span>
            <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"ServerTime"</span>
            <span class="hljs-variable constant_">RANGE</span> <span class="hljs-variable constant_">BETWEEN</span> <span class="hljs-variable constant_">INTERVAL</span> <span class="hljs-string">'7'</span> <span class="hljs-variable constant_">DAY</span> <span class="hljs-variable constant_">PRECEDING</span> <span class="hljs-variable constant_">AND</span> <span class="hljs-variable constant_">CURRENT</span> <span class="hljs-variable constant_">ROW</span>
        ),
        <span class="hljs-title class_">User14DayWindow</span> <span class="hljs-variable constant_">AS</span> (
            <span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"UserID"</span>
            <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"ServerTime"</span>
            <span class="hljs-variable constant_">RANGE</span> <span class="hljs-variable constant_">BETWEEN</span> <span class="hljs-variable constant_">INTERVAL</span> <span class="hljs-string">'14'</span> <span class="hljs-variable constant_">DAY</span> <span class="hljs-variable constant_">PRECEDING</span> <span class="hljs-variable constant_">AND</span> <span class="hljs-variable constant_">CURRENT</span> <span class="hljs-variable constant_">ROW</span>
        ),
        <span class="hljs-title class_">UserPastWindow</span> <span class="hljs-variable constant_">AS</span> (
        <span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"UserID"</span>
        <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"ServerTime"</span>
        <span class="hljs-variable constant_">ROWS</span> <span class="hljs-variable constant_">BETWEEN</span> <span class="hljs-variable constant_">UNBOUNDED</span> <span class="hljs-variable constant_">PRECEDING</span> <span class="hljs-variable constant_">AND</span> <span class="hljs-variable constant_">CURRENT</span> <span class="hljs-variable constant_">ROW</span>
        )
) <span class="hljs-variable constant_">AS</span> a
<span class="hljs-variable constant_">WINDOW</span>
    <span class="hljs-title class_">UserLevelWindow</span> <span class="hljs-variable constant_">AS</span> (
        <span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"UserID"</span>, <span class="hljs-string">"Level"</span>
        <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"ServerTime"</span>
        <span class="hljs-variable constant_">ROWS</span> <span class="hljs-variable constant_">BETWEEN</span> <span class="hljs-variable constant_">UNBOUNDED</span> <span class="hljs-variable constant_">PRECEDING</span> <span class="hljs-variable constant_">AND</span> <span class="hljs-variable constant_">CURRENT</span> <span class="hljs-variable constant_">ROW</span>
    ),
    <span class="hljs-title class_">PastWindow</span> <span class="hljs-variable constant_">AS</span> (
        <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"ServerTime"</span>
        <span class="hljs-variable constant_">ROWS</span> <span class="hljs-variable constant_">BETWEEN</span> <span class="hljs-variable constant_">UNBOUNDED</span> <span class="hljs-variable constant_">PRECEDING</span> <span class="hljs-variable constant_">AND</span> <span class="hljs-variable constant_">CURRENT</span> <span class="hljs-variable constant_">ROW</span>
    ),
    <span class="hljs-title class_">User1DayWindow</span> <span class="hljs-variable constant_">AS</span> (
        <span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"UserID"</span> 
        <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"ServerTime"</span> 
        <span class="hljs-variable constant_">RANGE</span> <span class="hljs-variable constant_">BETWEEN</span> <span class="hljs-variable constant_">INTERVAL</span> <span class="hljs-string">'1'</span> <span class="hljs-variable constant_">DAY</span> <span class="hljs-variable constant_">PRECEDING</span> <span class="hljs-variable constant_">AND</span> <span class="hljs-variable constant_">CURRENT</span> <span class="hljs-variable constant_">ROW</span>
    ),
    <span class="hljs-title class_">User7DayWindow</span> <span class="hljs-variable constant_">AS</span> (
        <span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"UserID"</span>
        <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"ServerTime"</span>
        <span class="hljs-variable constant_">RANGE</span> <span class="hljs-variable constant_">BETWEEN</span> <span class="hljs-variable constant_">INTERVAL</span> <span class="hljs-string">'7'</span> <span class="hljs-variable constant_">DAY</span> <span class="hljs-variable constant_">PRECEDING</span> <span class="hljs-variable constant_">AND</span> <span class="hljs-variable constant_">CURRENT</span> <span class="hljs-variable constant_">ROW</span>
    ),
    <span class="hljs-title class_">User14DayWindow</span> <span class="hljs-variable constant_">AS</span> (
        <span class="hljs-variable constant_">PARTITION</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"UserID"</span>
        <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"ServerTime"</span>
        <span class="hljs-variable constant_">RANGE</span> <span class="hljs-variable constant_">BETWEEN</span> <span class="hljs-variable constant_">INTERVAL</span> <span class="hljs-string">'14'</span> <span class="hljs-variable constant_">DAY</span> <span class="hljs-variable constant_">PRECEDING</span> <span class="hljs-variable constant_">AND</span> <span class="hljs-variable constant_">CURRENT</span> <span class="hljs-variable constant_">ROW</span>
    )
<span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-string">"ServerTime"</span>;
</code></pre>
<p>이 코드에서 '윈도우'는 고려할 시간 범위를 정의하기 위해 생성되어 마지막 날, 지난 주 또는 지난 2주와 같은 것을 나타냅니다. 해당 범위 내에 속한 레코드가 기능 계산 중에 사용되며, 이는 주로 게임에서 플레이어의 여정에 대한 일부 역사적 맥락을 제공하기 위해 의도되었습니다. 전체 기능 목록은 다음과 같습니다:</p>
<div class="content-ad"></div>
<ul>
<li>level_time_spend: 사용자가 레벨을 플레이하는 데 소요된 시간을 나타냅니다. 레벨의 난이도를 나타냅니다.</li>
<li>levels_completed_last_7_days: 사용자가 지난 7일 동안(1주일) 완료한 레벨 수를 나타냅니다. 난이도, 인내력 및 게임에 대한 몰입도를 보여줍니다.</li>
<li>total_wins_last_14_days: 사용자가 레벨을 이긴 총 횟수</li>
<li>total_losses_last_14_days: 사용자가 레벨을 진 총 횟수</li>
<li>win_to_lose_ratio_last_14_days: 승리 횟수와 패배 횟수의 비율 (total_wins_last_14_days/total_losses_last_14_days)</li>
<li>used_coins_last_1_days: 이전 날 사용된 코인 수. 레벨 난이도 및 플레이어가 게임 내 통화를 사용할 의지를 보여줍니다.</li>
<li>used_coins_last_7_days: 지난 7일간 사용된 코인 수 (1주일)</li>
<li>used_coins_last_14_days: 지난 14일간 사용된 코인 수 (2주)</li>
<li>extra_moves_last_1_days: 사용자가 이전 날에 사용한 추가 움직임 수. 레벨 난이도를 나타냅니다.</li>
<li>extra_moves_last_7_days: 사용자가 지난 7일 동안 사용한 추가 움직임 수 (1주)</li>
<li>extra_moves_last_14_days: 사용자가 지난 14일 동안 사용한 추가 움직임 수 (2주)</li>
<li>rolling_losses_mean_last_7_days: 사용자가 지난 7일 동안 누적으로 경험한 평균 손실 횟수 (1주). 레벨 난이도를 보여줍니다.</li>
<li>max_level_mean: 모든 사용자가 달성한 최고 레벨의 평균.</li>
<li>max_level: 사용자가 지난 7일 동안(1주) 달성한 최고 레벨. max_level_mean과 결합하여 플레이어의 다른 플레이어들에 대한 진행 상황을 보여줍니다.</li>
<li>min_level: 사용자가 지난 7일 동안(1주) 플레이한 최소 레벨</li>
<li>play_time_cumul_7_days: 사용자가 지난 7일 동안(1주) 플레이한 총 시간. 플레이어의 게임 몰입도를 나타냅니다.</li>
<li>play_time_cumul: 사용자가 플레이한 총 시간(첫 번째 기록부터)</li>
<li>rolling_losses_cumul_7_days: 지난 7일 동안(1주) 누적된 롤링 손실 총 횟수. 레벨의 난이도를 나타냅니다.</li>
</ul>
<p>새로운 기능의 값을 계산할 때는 이전 레코드만 사용하는 것이 중요합니다. 다시 말해, 향후 관측치의 사용은 피해야 합니다. 왜냐하면 모델이 상용 환경에 배포될 때 미래 값에 액세스할 방법이 없기 때문입니다.</p>
<p>생성된 피처에 만족하셨다면 테이블을 새 데이터 세트로 저장하고 (희망적으로) 성능이 향상된 새 모델을 실행할 수 있습니다.</p>
<h1>새로운 (희망적으로 향상된) 분류 모델 훈련</h1>
<div class="content-ad"></div>
<p>새로운 열이 유용한지 확인할 시간이에요. 이전과 동일한 단계를 반복할 수 있어요. 유일한 차이점은 이제 추가 기능을 포함하는 새 데이터 세트를 사용한다는 것이에요. 기존 모델과 공정한 비교를 위해 동일한 설정을 사용하여 원본 모델과 다음 결과와 함께 최적화합니다(여기서도 확인할 수 있습니다):</p>
<p><img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_11.png" alt="image"></p>
<p>0.918의 ROC AUC 값은 원래 값인 0.675와 비교했을 때 크게 향상되었어요. 심지어 품질에 최적화된 모델(0.709)보다 더 나아요! 이는 데이터를 이해하고 더 풍부한 정보를 제공할 수 있는 새로운 기능을 만드는 중요성을 보여줍니다.</p>
<p>이제 어떤 새로운 기능이 실제로 가장 유용했는지 확인하는 것이 흥미롭겠죠. 다시 한번 특징 중요도 표를 확인할 수 있어요:</p>
<div class="content-ad"></div>
<p><img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_12.png" alt="그림"></p>
<p>최근 두 주간의 총 패배 횟수가 매우 중요한 것으로 보입니다. 이는 게임에서 더 자주 패배할수록 플레이어가 좌절하고 플레이를 그만둘 가능성이 더 높아진다는 논리적입니다.</p>
<p>모든 사용자의 평균 최대 레벨도 중요한 것으로 보입니다. 다시 한번, 플레이어가 다수의 다른 플레이어와 얼마나 멀리 떨어져 있는지를 결정하는 데 사용될 수 있습니다. 평균보다 훨씬 높은 level은 플레이어가 게임에 깊게 몰두해 있다는 것을 나타내고, 평균보다 훨씬 낮은 값은 플레이어가 여전히 충분히 동기 부여받지 못했을 수 있다는 것을 나타낼 수 있습니다.</p>
<p>이것들은 우리가 만들었을 수 있는 몇 가지 간단한 기능에 불과합니다. 성능을 더 향상시킬 수 있는 다른 기능들이 있을 수 있습니다. 독자에게 어떤 다른 기능들이 만들어질 수 있는지 확인해 보도록 남겨두겠습니다.</p>
<div class="content-ad"></div>
<p>지난과 동일한 시간 제한으로 품질에 최적화된 모델을 훈련시키는 것은 성능을 향상시키지 않았습니다. 그러나 더 많은 피처를 사용하고 있기 때문에 최적화에 더 많은 시간이 필요할 수 있기 때문에 이해할 만한 일입니다. 여기서 시간 제한을 6시간으로 늘리면 성능이 실제로 0.923(AUC 기준)로 향상된 것을 확인할 수 있습니다:</p>
<p><img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_13.png" alt="이미지"></p>
<p>또한 정밀도 및 재현율과 같은 몇 가지 메트릭이 여전히 상당히 낮다는 점에 유의해야 합니다. 그러나 이는 0.5의 분류 임계값을 가정했기 때문일 수 있습니다. 임계값을 곡선을 클릭하여 변경할 수 있지만 AUC는 임계값에 독립적이며 성능을 더 포괄적으로 나타낼 수 있습니다. 앞서 언급했듯이 AUC는 불균형 데이터셋을 기반으로 훈련하는 동안 최적화 메트릭으로 사용될 때 특히 유용합니다.</p>
<p>훈련된 모델의 AUC 성능은 다음과 같이 요약할 수 있습니다:</p>
<div class="content-ad"></div>

























<table><thead><tr><th>Model</th><th>AUC (ROC)</th></tr></thead><tbody><tr><td>Original features</td><td>0.675</td></tr><tr><td>Original features + optim. for quality</td><td>0.709</td></tr><tr><td>Engineered features</td><td>0.918</td></tr><tr><td>Engineered features + optim. for quality + longer time</td><td>0.923</td></tr></tbody></table>
<h1>프로덕션 환경에 모델 배포하기</h1>
<p>새로운 데이터에서 실제로 모델을 사용할 수 없다면 좋은 모델이 있어도 쓸모가 없습니다. 머신러닝 플랫폼은 훈련된 모델을 사용하여 미래의 보이지 않는 데이터에 대한 예측을 생성하는 기능을 제공할 수 있습니다. 예를 들어, Actable AI 플랫폼은 API를 통해 모델을 사용하여 플랫폼 외부 데이터에 사용할 수 있게 해주며, 모델을 내보내거나 원시 값을 삽입하여 즉시 예측을 얻을 수 있습니다.</p>
<p>그러나 모델을 주기적으로 미래 데이터에 테스트하는 것은 매우 중요합니다. 모델이 여전히 예상대로 작동하는지 확인하기 위해 필요합니다. 실제로 더 최신 데이터로 모델을 다시 훈련해야 할 수도 있습니다. 이는 특징(예: 피처 분포)이 시간이 지남에 따라 변경될 수 있어 모델의 정확도에 영향을 미칠 수 있기 때문입니다.</p>
<div class="content-ad"></div>
<p>예를 들어, 회사에서 새로운 정책을 도입할 수 있으며 이는 고객 행동에 영향을 미칠 수 있습니다(긍정적 또는 부정적). 그러나 새로운 변화를 반영하는 기능이 없는 경우 모델은 새로운 정책을 고려하지 못할 수 있습니다. 만일 그런 심각한 변화가 있지만 모델에 정보를 제공할 수 있는 기능이 없다면, 고려해볼 가치가 있는 것은 두 모델을 사용하는 것입니다: 하나는 이전 데이터를 훈련시키고 사용하는 데에 특화되고, 다른 하나는 최신 데이터를 훈련시키고 사용하는 데에 특화하는 것입니다. 이렇게 함으로써 모델이 단일 모델로 잡기 어려운 서로 다른 특성을 가진 데이터에서 작동할 수 있도록 보장할 수 있습니다.</p>
<h1>결론</h1>
<p>본 글에서는 사용자가 모바일 앱에서 각 레벨을 하면서 생성된 정보를 포함하는 실제 데이터 세트를 사용하여, 플레이어가 2주 후에 게임을 그만둘지를 예측할 수 있는 분류 모델을 훈련시켰습니다.</p>
<p>데이터 탐색부터 모델 훈련, 피처 엔지니어링까지 전반적인 처리 파이프라인을 고려했습니다. 결과의 해석에 대한 토론과 어떻게 향상시킬 수 있는지가 제공되었으며, 0.675에서 0.923으로 가치를 향상시키는 방법을 탐색했습니다(1.0이 최대값입니다).</p>
<div class="content-ad"></div>
<p>새로 만들어진 기능들은 비교적 간단합니다. 더 많은 기능들이 있을 수 있지만, Feature Normalisation과 Standardisation 같은 기술들 역시 고려해볼 만 합니다. 여기와 여기에서 유용한 자료들을 찾을 수 있습니다.</p>
<p>Actable AI 플랫폼에 관해서, 제가 조금 편협한 의견을 가지고 있을 수도 있지만, 이 플랫폼이 데이터 과학자와 머신 러닝 전문가에 의해 수행되어야 하는 좀 더 성가신 프로세스들을 간단화할 수 있다고 생각합니다. 다음과 같은 우수한 측면이 있습니다:</p>
<ul>
<li>Core ML 라이브러리는 오픈 소스이기 때문에 좋은 프로그래밍 지식을 가진 사람이라면 안전하게 사용할 수 있습니다. 또한 Python을 알고 있는 사람이라면 누구나 사용할 수 있습니다.</li>
<li>Python을 모르거나 코딩에 익숙하지 않은 사람들을 위해 GUI를 통해 쉽게 분석 및 시각화를 할 수 있는 방법을 제공합니다.</li>
<li>플랫폼을 사용하기 시작하는 것이 너무 어렵지 않습니다. 기술적인 정보가 너무 많아서 지식이 부족한 사람들이 사용을 꺼려할 정도로 사용자를 압도하지 않습니다.</li>
<li>무료 계층을 통해 공개적으로 사용 가능한 데이터셋에 대한 분석을 실행할 수 있습니다.</li>
<li>이 글에서 고려된 분류 이외에도 다양한 도구가 제공됩니다.</li>
</ul>
<p>그럼에도 불구하고, 개선할 부분들이 몇 가지 존재하며, 몇 가지 측면들이 개선되어야 할 것입니다.</p>
<div class="content-ad"></div>
<ul>
<li>무료 티어는 개인 데이터에서 ML 모델을 실행할 수 없습니다.</li>
<li>사용자 인터페이스가 다소 오래된 느낌이 있습니다.</li>
<li>일부 시각화 요소가 명확하지 않고 해석하기 어려울 수 있습니다.</li>
<li>어플리케이션이 가끔 반응이 느릴 수 있습니다.</li>
<li>불균형 데이터를 지원하지 않습니다.</li>
<li>이 플랫폼의 최대 잠재력을 발휘하려면 데이터 과학 및 기계 학습에 대한 일부 지식이 여전히 필요합니다 (다른 플랫폼에서도 마찬가지일 수 있습니다).</li>
</ul>
<p>다음 기사에서는 다른 플랫폼들을 사용하여 그들의 장단점을 파악하고, 각 플랫폼에 최적인 사용 사례를 확인할 것입니다.</p>
<p>그 때까지 이 기사가 흥미로운 내용이었길 바랍니다! 피드백이나 질문이 있으시면 언제든지 자유롭게 남겨주세요!</p>
<p>이 기사에 대한 생각이 있으신가요? LinkedIn에서 메시지를 보내거나 직접 연락 주십시오!</p>
<div class="content-ad"></div>
<p>저를 팔로우해주세요! 이렇게 하면 미래의 기사 발행 알림을 받을 수 있습니다.</p>
<p><img src="/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_14.png" alt="Image"></p>
<p>이 기사를 작성한 저자는 작성 시점에 Actable AI의 데이터 과학자였습니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"ChatGPT를 이용한 플레이어 이탈 예측 방법","description":"","date":"2024-06-23 16:39","slug":"2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT","content":"\n\n## 저 코드 머신 러닝 플랫폼을 활용한 데이터 과학 | ACTABLE AI\n\n![이미지](/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_0.png)\n\n# 소개\n\n게임 산업에서 기업들은 플레이어를 유치하는 것 뿐만 아니라 특히 인게임 마이크로 트랜잭션에 의존하는 프리투플레이 게임에서 가능한 한 오랫동안 유지시키려고 노력합니다. 이러한 마이크로 트랜잭션은 종종 인게임 화폐 구매를 포함하며, 플레이어가 진행 또는 사용자 정의를 위한 아이템을 획득하고 게임 개발을 지원합니다. 중단하는 플레이어 수를 나타내는 이탈률을 모니터링하는 것이 중요합니다. 이는 높은 이탈율은 수입 손실을 의미하며, 이는 개발자와 관리자의 스트레스 수준이 증가하게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사는 특정 모바일 앱에서 획득한 데이터를 기반으로 한 실제 데이터셋의 사용을 탐색하며, 사용자들이 플레이한 레벨에 중점을 둡니다. 기계 학습을 활용하여 기술 현장에서 중요한 역할을 하며 인공 지능(AI)의 기초를 형성한 이후, 기업들은 자신들의 데이터에서 가치 있는 통찰을 얻을 수 있습니다.\n\n하지만, 기계 학습 모델을 구축하는 것은 일반적으로 코딩과 데이터 과학 전문 지식이 필요하므로, 많은 사람들 및 자원이 부족한 소규모 기업들에게는 접근하기 어렵습니다. 이러한 도전에 대처하기 위해, 로우코드와 노코드 기계 학습 플랫폼이 나타나기 시작했으며, 기계 학습과 데이터 과학 과정을 간소화하여 방대한 코딩 지식이 필요하지 않도록 하는 것을 목표로 합니다. Einblick, KNIME, Dataiku, Alteryx, Akkio와 같은 플랫폼의 예시가 있습니다.\n\n이 기사에서는 하나의 로우코드 기계 학습 플랫폼을 사용하여 사용자가 게임을 중단할지 예측할 수 있는 모델을 훈련하는 방법을 다룹니다. 뿐만 아니라 결과 해석 및 모델 성능을 향상시키는 데 사용할 수 있는 기술에 대해 탐구합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 기사의 나머지 부분은 다음과 같이 구성되어 있습니다:\n\n- 플랫폼\n- 데이터셋\n- 탐색적 데이터 분석\n- 분류 모델 훈련\n- 모델 성능 향상\n- 새로운 특징 생성\n- 새로운 (개선된) 분류 모델 훈련\n- 생산 환경에 모델 배포\n- 결론\n\n# 플랫폼\n\n전체 공개 - 이 기사 작성 시점에 제가 Actable AI의 데이터 과학자인 사실을 알려드립니다. 따라서 이 기사에서는 해당 플랫폼을 사용할 예정입니다. 또한, 저는 ML 라이브러리에 새로운 기능을 구현하고 유지보수하는 일에 관여하고 있어서, 이 플랫폼이 실제 문제에 대해 어떻게 대응하는지 궁금했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n플랫폼은 전통적인 분류, 회귀 및 세분화 애플리케이션을 위한 여러 인기있는 머신 러닝 방법을 제공합니다. 시계열 예측, 감성 분석 및 인과 추론과 같은 일부 일반적이지 않은 도구도 이용할 수 있습니다. 또한, 결측 데이터를 보완할 수 있으며 데이터 세트의 통계를 계산하고(특성 간 상관 관계, 분산 분석(ANOVA) 등), 막대 차트, 히스토그램, 워드 클라우드와 같은 도구를 사용하여 데이터를 시각화할 수 있습니다.\n\nGoogle Sheets 애드온도 제공되어 스프레드시트 내에서 직접 분석과 모델 훈련을 할 수 있습니다. 다만, 이 애드온에서는 최신 기능이 지원되지 않을 수 있으니 참고 바랍니다.\n\n![image](/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_1.png)\n\n핵심 라이브러리는 GitHub에서 오픈 소스로 제공되며 AutoGluon 및 scikit-learn과 같은 잘 알려진 신뢰할 수 있는 프레임워크로 구성되어 있습니다. 이는 기존의 오픈 소스 솔루션을 활용하는 다른 관련 플랫폼과 유사합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그러나, 이에 대한 질문이 생깁니다: 대부분의 도구들이 이미 사용 가능하고 무료로 제공되는데, 왜 이러한 플랫폼을 사용해야 하는지요?\n\n가장 중요한 이유는 이러한 도구들이 Python과 같은 프로그래밍 언어에 대한 지식이 필요하다는 것입니다. 일반적으로 코딩에 익숙하지 않은 사람은 사용하기 어렵거나 불가능할 수 있습니다. 따라서 이러한 플랫폼은 프로그래밍 명령어의 형태로가 아닌 GUI(그래픽 사용자 인터페이스) 형식으로 모든 기능을 제공하려고 합니다.\n\n더 경험이 많은 전문가들은 또한 시간을 절약할 수 있을 뿐만 아니라 쉽게 사용할 수 있는 그래픽 인터페이스를 통해 지원 도구와 기법의 정보를 제공할 수도 있습니다. 일부 플랫폼은 익숙하지 않았던 도구들을 제공하거나 데이터 작업 시 유용한 경고(예: 데이터 누출의 존재 - 모델이 볼 수 없는 데이터의 생산 환경에 배포될 때 사용할 수 없는 특징에 액세스할 수 있는 경우)를 제공할 수도 있습니다.  \n\n이러한 종류의 플랫폼을 사용하는 또 다른 이유는 모델을 실행할 하드웨어도 제공하기 때문입니다. 따라서 자신의 컴퓨터나 GPU(Graphical Processing Units)와 같은 구성 요소를 구매하고 유지 관리할 필요가 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 데이터셋\n\n게임 회사가 제공한 데이터셋은 이곳에서 확인할 수 있으며 CC BY-SA-4 라이센스가 적용되어있어 적절한 크레딧이 제공된다면 공유 및 수정이 허용됩니다. 이 데이터셋은 789,879개의 행(샘플)을 가지고 있어 과적합과 같은 영향을 줄여줄 것으로 예상됩니다.\n\n이 데이터셋은 개인이 모바일 앱에서 플레이한 각 레벨에 관한 정보를 포함하고 있습니다. 예를 들어, 플레이한 시간, 플레이어가 레벨에서 승리했는지 패배했는지, 레벨 번호 등에 대한 정보가 있습니다.\n\n사용자 ID도 포함되어 있지만 원래 플레이어의 신원을 드러내지 않도록 익명화되었습니다. 일부 필드도 제거되었지만, 이 데이터셋은 이 기사에서 고려된 ML 플랫폼에서 제공된 도구가 플레이어의 이탈을 예측하는 데 유용할 수 있는지 확인하는 견고한 기초를 제공할 것으로 예상됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n각 기능의 의미는 다음과 같습니다:\n\n- Churn: 플레이어가 게임을 2주 이상 플레이하지 않았을 경우 '1', 그렇지 않으면 '0'\n- ServerTime: 레벨이 플레이된 서버의 타임스탬프\n- EndType: 레벨이 종료된 이유 ('승리'일 경우 주로 게임에서 이겼을 때, '패배'일 경우 게임에서 졌을 때)\n- LevelType: 레벨의 유형\n- Level: 레벨 번호\n- SubLevel: 하위 레벨 번호\n- Variant: 레벨 변형\n- Levelversion: 레벨 버전\n- NextCar: 사용되지 않음 (플랫폼이 한 라벨만 포함하는 기능을 처리하는 방법 확인용으로 포함됨)\n- AddMoves: 추가 이동 횟수\n- DoubleMana: 사용되지 않음 (플랫폼이 한 라벨만 포함하는 기능을 처리하는 방법 확인용으로 포함됨)\n- StartMoves: 레벨 시작 시 사용 가능한 이동횟수\n- ExtraMoves: 구매한 추가 이동 횟수\n- UsedMoves: 플레이어가 사용한 이동 횟수\n- UsedChangeCar: 사용되지 않음 (플랫폼이 한 라벨만 포함하는 기능을 처리하는 방법 확인용으로 포함됨)\n- WatchedVideo: 비디오를 시청했는지 여부, 추가 이동 제공\n- BuyMoreMoves: 플레이어가 추가 이동을 구매한 횟수\n- PlayTime: 레벨 플레이에 소요된 시간\n- Scores: 플레이어가 달성한 점수\n- UsedCoins: 레벨에서 사용된 총 코인 수\n- MaxLevel: 플레이어가 도달한 최대 레벨\n- Platform: 장치 유형\n- UserID: 플레이어의 ID\n- RollingLosses: 플레이어의 연속적인 패배 횟수\n\n# 탐색적 데이터 분석\n\n학습 전 첫 번째 단계는 탐색적 데이터 분석(EDA)을 통해 데이터를 이해하는 것입니다. EDA는 데이터를 요약, 시각화하고 주요 특성을 이해하는 데이터 분석 방법론입니다. 목표는 데이터로부터 통찰력을 얻고, 어떠한 패턴, 추세, 이상 현상 또는 존재할 수 있는 이슈(예: 결측값)를 식별하여 사용될 특성 및 모델을 확인하는 데 도움이 되는 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n주요 이유들을 확인해 보면서 레벨이 종료된 이유에 대해 살펴보겠습니다:\n\n![Image](/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_2.png)\n\n위 이미지를 보면 레벨 종료의 주된 이유(EndType으로 표시됨)는 플레이어가 게임에서 패배한 경우(63.6%)가 승리한 경우의 35.2%에 비해 더 많다는 것을 알 수 있습니다. 또한 UsedChangeCar 열은 모든 행에 동일한 값을 포함하고 있어 쓸모없어 보입니다.\n\n매우 중요한 점은 우리의 대상값이 매우 불균형하다는 것입니다. 처음 10,000행 중에서 63개의 샘플만이 (데이터의 0.6%) Churn 값이 1(즉, 플레이어가 이탈함)을 가지고 있다는 것입니다. 이것은 염두에 둘 필요가 있습니다. 왜냐하면 우리의 모델이 Churn에 대해 0의 값을 예측하는 데 매우 편향될 수 있기 때문입니다. 모델이 정확도와 같은 몇 가지 지표에 대해 매우 좋은 값을 얻을 수 있기 때문에, 이 경우에는 가장 일반적인 클래스를 선택하는 더미 모델이 99.4%의 정확도로 정답을 맞출 것입니다! 이에 대해 Baptiste Rocca와 Jason Brownlee의 두 훌륭한 기사에서 더 읽어보시기를 권합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n아쉽게도 Actable AI는 SMOTE(합성 소수 샘플링 기법)를 통해 불균형 데이터를 처리하거나 클래스 가중치 또는 다른 샘플링 전략을 사용하는 방법을 아직 제공하지 않습니다. 이는 최적화를 위해 선택된 지표에 주의를 기울여야 한다는 것을 의미합니다. 위에서 언급한 대로, 정확도는 한 클래스의 샘플이 올바르게 레이블링되지 않아도 높은 비율을 달성할 수 있는 경우라면 최선의 선택이 아닐 것입니다.\n\n또 다른 유용한 분석 유형은 특징들 간의 상관 관계, 특히 예측자 특징과 대상 특징 간의 상관 관계입니다. 이를 수행하기 위해 '상관 분석' 도구를 사용할 수 있으며, 해당 결과는 Actable AI 플랫폼에서 직접 확인할 수 있습니다:\n\n![HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_3](/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_3.png)\n\n위 차트에서 파란 막대는 특징이 Churn과 양의 상관 관계가 있는 경우를 나타내며 값이 1인 경우이고, 주황색 막대는 음의 특징 상관 관계를 나타냅니다. 상관 관계는 -1에서 1 사이에 있음을 주의해야 합니다. 양의 값은 두 특징이 함께 변화하는 경향이 있다는 것을 나타내며(예: 둘 다 증가하거나 감소), 음의 상관 관계는 한 특징이 증가하거나 감소할 때 다른 특징이 반대로 변화한다는 것을 나타냅니다. 따라서 상관 관계의 크기(음의 부호를 무시한)가 아마도 가장 중요한 사항일 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n특정 수준을 잃은 플레이어들이 (가장 위쪽의 파란 막대) 막적회전에 민감하다는 것이나, 반대로 특정 수준을 이긴 플레이어들은 계속해서 플레이하는 경향이 있다는 등 여러 가지 교훈이 있습니다 (세 번째 오렌지 막대). 그러나 값이 상당히 낮다는 것도 주목해야 합니다. 이는 이러한 특징이 목표와 상관 관계가 약한 것을 의미합니다. 이는 모델이 더 정확한 예측을 수행하기 위해 더 중요한 정보를 포착하는 새로운 기능을 만들어 사용하는 특성 엔지니어링을 수행해야 할 것으로 예상됩니다. 특성 엔지니어링은 이 글의 뒷부분에서 자세히 다룰 것입니다.\n\n하지만 새로운 특성을 생성하기 전에 데이터셋의 원래 특성만 사용하여 어떤 성능을 달성할 수 있는지 살펴보는 것도 좋은 방법입니다. 따라서 다음 단계는 더 흥미로운 것으로, 모델을 훈련시켜 어떤 성능을 달성할 수 있는지 알아보는 것이 될 것입니다.\n\n# 분류 모델 훈련\n\n사용자가 플레이를 중단할지 여부를 예측하고 싶기 때문에, 이는 여러 레이블 중 하나를 선택해야 하는 분류 문제입니다. 우리의 경우, 문제는 두 가지 레이블 중 하나('1'은 '이탈', '0'은 '이탈하지 않음'에 해당)를 할당하는 것을 포함하므로, 이는 이진 분류 문제로 만듭니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 프로세스는 주로 AutoGluon 라이브러리를 통해 수행되며, 이 라이브러리는 자동으로 여러 모델을 학습한 다음 가장 우수한 성능을 달성한 모델을 선택합니다. 이렇게 하면 각각의 모델을 수동으로 학습하고 그 성능을 비교할 필요가 없어집니다.\n\nActable AI 플랫폼에서 설정해야 할 여러 매개변수가 있으며, 제가 선택한 옵션은 아래에 나와 있습니다:\n\n![이미지](/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_4.png)\n\n모델의 최적화를 위해 사용할 메트릭도 선택할 수 있습니다. 저는 수신자 조작 특성 (ROC) 아래 영역 (AUC ROC) 곡선을 사용했습니다. 이는 이전에 논의된 클래스 불균형 문제에 대해 훨씬 민감하지 않기 때문입니다. 값은 0부터 1까지의 범위를 가지며 (1일수록 완벽한 점수입니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일정 시간이 지난 후에는 결과가 생성되어 표시되며, 여기서도 볼 수 있습니다. 여러 가지 다른 측정 항목이 계산되며, 이는 좋은 실천 방식일 뿐만 아니라 각 측정 항목이 모델 성능의 특정 측면에 집중하기 때문에 우리가 모델을 실제로 이해하려면 거의 필수적입니다.\n\n표시된 첫 번째 메트릭은 최적화 메트릭으로, 값이 0.675입니다:\n\n![이미지](/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_5.png)\n\n이것은 크게 좋지는 않지만, EDA 중에 특성이 대상과 상관성이 약한 것을 상기하면, 성능이 별로 두드러지지 않는 것은 놀라운 일이 아닙니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 결과는 결과를 이해하는 중요성을 강조합니다. 보통 0.997 (즉, 99.7%) 정확도에 대해 매우 만족스러워할 것입니다. 그러나 이는 앞서 언급한 것처럼 데이터 세트의 심각한 불균형 때문이 대부분이므로 그다지 중요하지 않습니다. 한편, 정밀도와 재현율과 같은 점수는 기본적으로 임계값 0.5를 기반으로 하며, 이는 우리의 응용 프로그램에 가장 적합하지 않을 수 있습니다.\n\nROC 및 정밀도-재현율 곡선도 표시되는데, 이것들 또한 성능이 약간 부족함을 명확히 보여줍니다:\n\n이러한 곡선들은 최종 응용 프로그램에서 사용할 임계값을 결정하는 데도 유용합니다. 예를 들어, 거짓 양성의 수를 최소화하려면 모델이 더 높은 정밀도를 얻는 임계값을 선택하고 해당하는 재현을 확인할 수 있습니다.\n\n얻은 최상의 모델에서 각 피처의 중요성을 확인할 수도 있습니다. 이는 AutoGluon을 통해 순열 중요성을 사용하여 계산됩니다. 결과의 신뢰성을 결정하기 위해 P-값도 표시됩니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_6.png\" /\u003e\n\n아마도 놀랍지 않게도, 가장 중요한 기능은 EndType입니다(레벨이 종료된 이유를 보여주는데, 승리나 패배와 같은 요인), 그 다음은 MaxLevel(사용자가 플레이 한 가장 높은 레벨로, 숫자가 높을수록 플레이어가 게임에 매우 집중하고 활발하다는 것을 의미합니다).\n\n반면에, UsedMoves(플레이어가 수행한 움직임의 수)는 사실상 쓸모없지만, StartMoves(플레이어가 사용할 수있는 움직임의 수)는 실제로 성능을 해칠 수 있습니다. 이것도 논리적입니다. 사용된 움직임 수와 플레이어가 사용할 수있는 움직임 수가 그 자체로는 높은 정보를 가지고 있지 않기 때문에, 두 값간의 비교가 훨씬 유용할 것입니다.\n\n또한 각 클래스(이 경우 1 또는 0)의 추정 확률을 살펴볼 수 있습니다. 이 확률은 예측된 클래스를 도출하기 위해 사용되며(기본적으로 가장 높은 확률을 가진 클래스가 예측된 클래스로 할당됩니다):\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_7.png\" /\u003e\n\nAI의 설명 가능성은 모델 동작을 이해하는 데 더 중요해지고 있으며, 이로 인해 Shapley 값과 같은 도구가 인기를 끌고 있습니다. 이러한 값은 기능이 예측된 클래스의 확률에 미치는 기여를 나타냅니다. 예를 들어, 첫 번째 행에서 RollingLosses 값이 36인 경우, 해당 플레이어가 게임을 계속하는 클래스 (클래스 0)의 확률이 감소함을 볼 수 있습니다.\n\n반대로, 이는 다른 클래스(즉, 플레이어가 이탈하는 클래스 1)의 확률이 증가함을 의미합니다. 이는 RollingLosses 값이 높을수록 플레이어가 연속해서 많은 레벨을 잃었고, 따라서 좌절하여 게임을 그만 둘 가능성이 높다는 것을 의미합니다. 반면, RollingLosses 값이 낮을수록 부정적인 클래스(즉, 플레이어가 게임을 그만 두지 않을 가능성)의 확률이 일반적으로 향상됩니다.\n\n언급한 바와 같이 여러 모델이 훈련되고 평가된 후, 그 중에서 최적의 모델이 선택됩니다. 흥미로운 점은 이 경우 최고의 모델이 LightGBM임과 동시에 가장 빠른 모델 중 하나인 것입니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마크다운 형식으로 테이블 태그를 변경해보세요.\n\n# 모델 성능 향상\n\n지금 이 시점에서는 모델의 성능을 향상시킬 수 있습니다. 아마도 가장 쉬운 방법 중 하나는 '품질 최적화' 옵션을 선택하고 얼마나 나아질 수 있는지 확인하는 것입니다. 이 옵션은 일반적으로 성능을 향상시키는 몇 가지 매개변수를 구성하며, 단단한 학습 시간의 비용으로 이루어집니다. 다음 결과를 얻었습니다 (여기에서도 확인할 수 있습니다):\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_9.png\" /\u003e\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다시 ROC AUC 지표에 초점을 맞추면, 성능이 0.675에서 0.709로 향상되었습니다. 이렇게 간단한 변경으로 성능이 상당히 향상된 것입니다. 하지만 여전히 이상적인 수준에서는 멀리 떨어져 있습니다. 더 나은 성능을 위해 우리가 할 수 있는 다른 방법이 있을까요?\n\n# 새로운 기능 만들기\n\n이전에 논의한 대로, 이것을 특성 공학을 사용하여 수행할 수 있습니다. 이것은 기존 기능에서 새로운 기능을 만드는 것을 의미하며, 이러한 새로운 기능은 더 강력한 패턴을 포착하고 예측할 변수와 더 높은 상관 관계를 갖도록 할 수 있습니다.\n\n우리의 경우, 데이터 세트의 기능은 사용자가 플레이한 레벨에 관한 정보에 대한 값만을 갖기 때문에 범위가 상당히 좁습니다. 따라서, 시간을 거쳐 레코드를 요약함으로써 더 전반적인 전망을 얻는 것이 매우 유용할 수 있습니다. 이렇게 함으로써 모델은 사용자의 역사적인 추세에 대한 지식을 가질 수 있을 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 플레이어가 사용한 추가 움직임의 수를 확인하여 경험한 난이도를 측정할 수 있습니다. 추가 움직임이 거의 필요하지 않았다면, 레벨이 너무 쉬웠을 수도 있습니다. 반대로 많은 숫자는 레벨이 너무 어려웠을 수도 있습니다.\n\n또한, 플레이어가 게임에 몰입하고 참여하고 있는지 확인하기 위해 이전 몇 날 동안 게임을 플레이한 시간을 확인하는 것도 좋은 아이디어일 것입니다. 게임을 별로 하지 않았다면, 그들이 흥미를 잃고 곧 그만둘 수도 있다는 의미일 수 있습니다.\n\n유용한 특징들은 서로 다른 도메인에서 다양하기 때문에 현재 작업과 관련된 정보를 찾는 것이 중요합니다. 예를 들어, 연구 논문, 사례 연구 및 기사를 찾거나 해당 분야에서 일한 회사나 전문가들의 조언을 구하면 가장 일반적인 특징, 특징 간의 관계, 잠재적인 함정 및 유용할 것으로 예상되는 새로운 특징들에 대해 숙련된 지식이 있는 사람들로부터 도움을 받을 수 있습니다. 이러한 접근 방식은 시행착오를 줄이고 특징 엔지니어링 프로세스를 가속화하는 데 도움이 됩니다.\n\n최근 대규모 언어 모델(LLMs)의 발전과 (예: ChatGPT를 들어본 적이 있을지도 모르죠...), 그리고 특징 엔지니어링 프로세스가 경험 부족한 사용자에게는 다소 어려울 수 있기 때문에, LLMs가 어떤 특징을 생성할 수 있는 아이디어를 제공하는 데 어떤 지원이 될 수 있는지 궁금했습니다. 저는 이를 테스트해보았고, 다음 결과가 나왔습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_10.png\" /\u003e\n\n차트 GPT의 답변은 실제로 아주 좋습니다. 또한 앞서 언급한 바와 같이 여러 시간 기반 특성을 가리키기도 합니다. 물론 필요한 정보가 없을 경우 모든 제안된 기능을 구현할 수 없을 수도 있음을 염두에 두세요. 게다가 이것은 망상에 빠지기 쉬우며, 따라서 완전히 정확한 답변을 제공하지 못할 수도 있습니다.\n\nChatGPT로부터 더 관련성 높은 응답을 받으려면 사용 중인 특성을 지정하거나 프롬프트를 활용하는 등의 방법을 사용할 수 있습니다. 그러나 이는 본 문서의 범위를 벗어나므로 독자들에게 연습 과제로 남겨두겠습니다. 그럼에도 불구하고, LLMs는 시작 단계로 고려할 수 있지만, 논문, 전문가 등보다 신뢰할 만한 정보를 얻기 위해 노력하는 것이 강력히 권장됩니다.\n\nActable AI 플랫폼에서는 상당히 잘 알려진 SQL 프로그래밍 언어를 사용하여 새로운 기능을 만들 수 있습니다. SQL에 익숙하지 않은 사용자를 위해 ChatGPT를 활용하여 쿼리를 자동으로 생성하는 방법이 유용할 수 있습니다. 그러나 내가 제한된 실험을 통해 이 방법의 신뢰성은 다소 일관되지 않을 수 있다는 것을 발견했습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n원하는 결과를 정확하게 계산하기 위해 의도한 출력물을 수동으로 확인하여 검증하는 것이 좋습니다. SQL Lab에서 쿼리를 실행한 후에 나타나는 테이블을 확인하여 이를 확인할 수 있습니다. Actable AI는 SQL 코드를 작성하고 실행하는 인터페이스입니다.\n\n다음은 새로운 열을 생성하는 데 사용한 SQL 코드입니다. 다른 기능을 만들고 싶다면 이것을 참고하여 시작할 수 있을 것입니다.\n\n```js\nSELECT \n    *,\n    SUM(\"PlayTime\") OVER UserLevelWindow AS \"time_spent_on_level\",\n    (a.\"Max_Level\" - a.\"Min_Level\") AS \"levels_completed_in_last_7_days\",\n    COALESCE(CAST(\"total_wins_in_last_14_days\" AS DECIMAL)/NULLIF(\"total_losses_in_last_14_days\", 0), 0.0) AS \"win_to_lose_ratio_in_last_14_days\",\n    COALESCE(SUM(\"UsedCoins\") OVER User1DayWindow, 0) AS \"UsedCoins_in_last_1_days\",\n    COALESCE(SUM(\"UsedCoins\") OVER User7DayWindow, 0) AS \"UsedCoins_in_last_7_days\",\n    COALESCE(SUM(\"UsedCoins\") OVER User14DayWindow, 0) AS \"UsedCoins_in_last_14_days\",\n    COALESCE(SUM(\"ExtraMoves\") OVER User1DayWindow, 0) AS \"ExtraMoves_in_last_1_days\",\n    COALESCE(SUM(\"ExtraMoves\") OVER User7DayWindow, 0) AS \"ExtraMoves_in_last_7_days\",\n    COALESCE(SUM(\"ExtraMoves\") OVER User14DayWindow, 0) AS \"ExtraMoves_in_last_14_days\",\n    AVG(\"RollingLosses\") OVER User7DayWindow AS \"RollingLosses_mean_last_7_days\",\n    AVG(\"MaxLevel\") OVER PastWindow AS \"MaxLevel_mean\"\nFROM (\n    SELECT\n        *,\n        MAX(\"Level\") OVER User7DayWindow AS \"Max_Level\",\n        MIN(\"Level\") OVER User7DayWindow AS \"Min_Level\",\n        SUM(CASE WHEN \"EndType\" = 'Lose' THEN 1 ELSE 0 END) OVER User14DayWindow AS \"total_losses_in_last_14_days\",\n        SUM(CASE WHEN \"EndType\" = 'Win' THEN 1 ELSE 0 END) OVER User14DayWindow AS \"total_wins_in_last_14_days\",\n        SUM(\"PlayTime\") OVER User7DayWindow AS \"PlayTime_cumul_7_days\",\n        SUM(\"RollingLosses\") OVER User7DayWindow AS \"RollingLosses_cumul_7_days\",\n        SUM(\"PlayTime\") OVER UserPastWindow AS \"PlayTime_cumul\"\n    FROM \"game_data_levels\"\n    WINDOW\n        User7DayWindow AS (\n            PARTITION BY \"UserID\"\n            ORDER BY \"ServerTime\"\n            RANGE BETWEEN INTERVAL '7' DAY PRECEDING AND CURRENT ROW\n        ),\n        User14DayWindow AS (\n            PARTITION BY \"UserID\"\n            ORDER BY \"ServerTime\"\n            RANGE BETWEEN INTERVAL '14' DAY PRECEDING AND CURRENT ROW\n        ),\n        UserPastWindow AS (\n        PARTITION BY \"UserID\"\n        ORDER BY \"ServerTime\"\n        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n        )\n) AS a\nWINDOW\n    UserLevelWindow AS (\n        PARTITION BY \"UserID\", \"Level\"\n        ORDER BY \"ServerTime\"\n        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ),\n    PastWindow AS (\n        ORDER BY \"ServerTime\"\n        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW\n    ),\n    User1DayWindow AS (\n        PARTITION BY \"UserID\" \n        ORDER BY \"ServerTime\" \n        RANGE BETWEEN INTERVAL '1' DAY PRECEDING AND CURRENT ROW\n    ),\n    User7DayWindow AS (\n        PARTITION BY \"UserID\"\n        ORDER BY \"ServerTime\"\n        RANGE BETWEEN INTERVAL '7' DAY PRECEDING AND CURRENT ROW\n    ),\n    User14DayWindow AS (\n        PARTITION BY \"UserID\"\n        ORDER BY \"ServerTime\"\n        RANGE BETWEEN INTERVAL '14' DAY PRECEDING AND CURRENT ROW\n    )\nORDER BY \"ServerTime\";\n```\n\n이 코드에서 '윈도우'는 고려할 시간 범위를 정의하기 위해 생성되어 마지막 날, 지난 주 또는 지난 2주와 같은 것을 나타냅니다. 해당 범위 내에 속한 레코드가 기능 계산 중에 사용되며, 이는 주로 게임에서 플레이어의 여정에 대한 일부 역사적 맥락을 제공하기 위해 의도되었습니다. 전체 기능 목록은 다음과 같습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- level_time_spend: 사용자가 레벨을 플레이하는 데 소요된 시간을 나타냅니다. 레벨의 난이도를 나타냅니다.\n- levels_completed_last_7_days: 사용자가 지난 7일 동안(1주일) 완료한 레벨 수를 나타냅니다. 난이도, 인내력 및 게임에 대한 몰입도를 보여줍니다.\n- total_wins_last_14_days: 사용자가 레벨을 이긴 총 횟수\n- total_losses_last_14_days: 사용자가 레벨을 진 총 횟수\n- win_to_lose_ratio_last_14_days: 승리 횟수와 패배 횟수의 비율 (total_wins_last_14_days/total_losses_last_14_days)\n- used_coins_last_1_days: 이전 날 사용된 코인 수. 레벨 난이도 및 플레이어가 게임 내 통화를 사용할 의지를 보여줍니다.\n- used_coins_last_7_days: 지난 7일간 사용된 코인 수 (1주일)\n- used_coins_last_14_days: 지난 14일간 사용된 코인 수 (2주)\n- extra_moves_last_1_days: 사용자가 이전 날에 사용한 추가 움직임 수. 레벨 난이도를 나타냅니다.\n- extra_moves_last_7_days: 사용자가 지난 7일 동안 사용한 추가 움직임 수 (1주)\n- extra_moves_last_14_days: 사용자가 지난 14일 동안 사용한 추가 움직임 수 (2주)\n- rolling_losses_mean_last_7_days: 사용자가 지난 7일 동안 누적으로 경험한 평균 손실 횟수 (1주). 레벨 난이도를 보여줍니다.\n- max_level_mean: 모든 사용자가 달성한 최고 레벨의 평균.\n- max_level: 사용자가 지난 7일 동안(1주) 달성한 최고 레벨. max_level_mean과 결합하여 플레이어의 다른 플레이어들에 대한 진행 상황을 보여줍니다.\n- min_level: 사용자가 지난 7일 동안(1주) 플레이한 최소 레벨\n- play_time_cumul_7_days: 사용자가 지난 7일 동안(1주) 플레이한 총 시간. 플레이어의 게임 몰입도를 나타냅니다.\n- play_time_cumul: 사용자가 플레이한 총 시간(첫 번째 기록부터)\n- rolling_losses_cumul_7_days: 지난 7일 동안(1주) 누적된 롤링 손실 총 횟수. 레벨의 난이도를 나타냅니다.\n\n새로운 기능의 값을 계산할 때는 이전 레코드만 사용하는 것이 중요합니다. 다시 말해, 향후 관측치의 사용은 피해야 합니다. 왜냐하면 모델이 상용 환경에 배포될 때 미래 값에 액세스할 방법이 없기 때문입니다.\n\n생성된 피처에 만족하셨다면 테이블을 새 데이터 세트로 저장하고 (희망적으로) 성능이 향상된 새 모델을 실행할 수 있습니다.\n\n# 새로운 (희망적으로 향상된) 분류 모델 훈련\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로운 열이 유용한지 확인할 시간이에요. 이전과 동일한 단계를 반복할 수 있어요. 유일한 차이점은 이제 추가 기능을 포함하는 새 데이터 세트를 사용한다는 것이에요. 기존 모델과 공정한 비교를 위해 동일한 설정을 사용하여 원본 모델과 다음 결과와 함께 최적화합니다(여기서도 확인할 수 있습니다):\n\n![image](/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_11.png)\n\n0.918의 ROC AUC 값은 원래 값인 0.675와 비교했을 때 크게 향상되었어요. 심지어 품질에 최적화된 모델(0.709)보다 더 나아요! 이는 데이터를 이해하고 더 풍부한 정보를 제공할 수 있는 새로운 기능을 만드는 중요성을 보여줍니다.\n\n이제 어떤 새로운 기능이 실제로 가장 유용했는지 확인하는 것이 흥미롭겠죠. 다시 한번 특징 중요도 표를 확인할 수 있어요:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n![그림](/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_12.png)\n\n최근 두 주간의 총 패배 횟수가 매우 중요한 것으로 보입니다. 이는 게임에서 더 자주 패배할수록 플레이어가 좌절하고 플레이를 그만둘 가능성이 더 높아진다는 논리적입니다.\n\n모든 사용자의 평균 최대 레벨도 중요한 것으로 보입니다. 다시 한번, 플레이어가 다수의 다른 플레이어와 얼마나 멀리 떨어져 있는지를 결정하는 데 사용될 수 있습니다. 평균보다 훨씬 높은 level은 플레이어가 게임에 깊게 몰두해 있다는 것을 나타내고, 평균보다 훨씬 낮은 값은 플레이어가 여전히 충분히 동기 부여받지 못했을 수 있다는 것을 나타낼 수 있습니다.\n\n이것들은 우리가 만들었을 수 있는 몇 가지 간단한 기능에 불과합니다. 성능을 더 향상시킬 수 있는 다른 기능들이 있을 수 있습니다. 독자에게 어떤 다른 기능들이 만들어질 수 있는지 확인해 보도록 남겨두겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n지난과 동일한 시간 제한으로 품질에 최적화된 모델을 훈련시키는 것은 성능을 향상시키지 않았습니다. 그러나 더 많은 피처를 사용하고 있기 때문에 최적화에 더 많은 시간이 필요할 수 있기 때문에 이해할 만한 일입니다. 여기서 시간 제한을 6시간으로 늘리면 성능이 실제로 0.923(AUC 기준)로 향상된 것을 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_13.png)\n\n또한 정밀도 및 재현율과 같은 몇 가지 메트릭이 여전히 상당히 낮다는 점에 유의해야 합니다. 그러나 이는 0.5의 분류 임계값을 가정했기 때문일 수 있습니다. 임계값을 곡선을 클릭하여 변경할 수 있지만 AUC는 임계값에 독립적이며 성능을 더 포괄적으로 나타낼 수 있습니다. 앞서 언급했듯이 AUC는 불균형 데이터셋을 기반으로 훈련하는 동안 최적화 메트릭으로 사용될 때 특히 유용합니다.\n\n훈련된 모델의 AUC 성능은 다음과 같이 요약할 수 있습니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n|                         Model                           | AUC (ROC) |\n|--------------------------------------------------------|-----------|\n| Original features                                      |     0.675 |\n| Original features + optim. for quality                 |     0.709 |\n| Engineered features                                    |     0.918 |\n| Engineered features + optim. for quality + longer time |     0.923 |\n\n\n# 프로덕션 환경에 모델 배포하기\n\n새로운 데이터에서 실제로 모델을 사용할 수 없다면 좋은 모델이 있어도 쓸모가 없습니다. 머신러닝 플랫폼은 훈련된 모델을 사용하여 미래의 보이지 않는 데이터에 대한 예측을 생성하는 기능을 제공할 수 있습니다. 예를 들어, Actable AI 플랫폼은 API를 통해 모델을 사용하여 플랫폼 외부 데이터에 사용할 수 있게 해주며, 모델을 내보내거나 원시 값을 삽입하여 즉시 예측을 얻을 수 있습니다.\n\n그러나 모델을 주기적으로 미래 데이터에 테스트하는 것은 매우 중요합니다. 모델이 여전히 예상대로 작동하는지 확인하기 위해 필요합니다. 실제로 더 최신 데이터로 모델을 다시 훈련해야 할 수도 있습니다. 이는 특징(예: 피처 분포)이 시간이 지남에 따라 변경될 수 있어 모델의 정확도에 영향을 미칠 수 있기 때문입니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, 회사에서 새로운 정책을 도입할 수 있으며 이는 고객 행동에 영향을 미칠 수 있습니다(긍정적 또는 부정적). 그러나 새로운 변화를 반영하는 기능이 없는 경우 모델은 새로운 정책을 고려하지 못할 수 있습니다. 만일 그런 심각한 변화가 있지만 모델에 정보를 제공할 수 있는 기능이 없다면, 고려해볼 가치가 있는 것은 두 모델을 사용하는 것입니다: 하나는 이전 데이터를 훈련시키고 사용하는 데에 특화되고, 다른 하나는 최신 데이터를 훈련시키고 사용하는 데에 특화하는 것입니다. 이렇게 함으로써 모델이 단일 모델로 잡기 어려운 서로 다른 특성을 가진 데이터에서 작동할 수 있도록 보장할 수 있습니다.\n\n# 결론\n\n본 글에서는 사용자가 모바일 앱에서 각 레벨을 하면서 생성된 정보를 포함하는 실제 데이터 세트를 사용하여, 플레이어가 2주 후에 게임을 그만둘지를 예측할 수 있는 분류 모델을 훈련시켰습니다.\n\n데이터 탐색부터 모델 훈련, 피처 엔지니어링까지 전반적인 처리 파이프라인을 고려했습니다. 결과의 해석에 대한 토론과 어떻게 향상시킬 수 있는지가 제공되었으며, 0.675에서 0.923으로 가치를 향상시키는 방법을 탐색했습니다(1.0이 최대값입니다).\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n새로 만들어진 기능들은 비교적 간단합니다. 더 많은 기능들이 있을 수 있지만, Feature Normalisation과 Standardisation 같은 기술들 역시 고려해볼 만 합니다. 여기와 여기에서 유용한 자료들을 찾을 수 있습니다.\n\nActable AI 플랫폼에 관해서, 제가 조금 편협한 의견을 가지고 있을 수도 있지만, 이 플랫폼이 데이터 과학자와 머신 러닝 전문가에 의해 수행되어야 하는 좀 더 성가신 프로세스들을 간단화할 수 있다고 생각합니다. 다음과 같은 우수한 측면이 있습니다:\n\n- Core ML 라이브러리는 오픈 소스이기 때문에 좋은 프로그래밍 지식을 가진 사람이라면 안전하게 사용할 수 있습니다. 또한 Python을 알고 있는 사람이라면 누구나 사용할 수 있습니다.\n- Python을 모르거나 코딩에 익숙하지 않은 사람들을 위해 GUI를 통해 쉽게 분석 및 시각화를 할 수 있는 방법을 제공합니다.\n- 플랫폼을 사용하기 시작하는 것이 너무 어렵지 않습니다. 기술적인 정보가 너무 많아서 지식이 부족한 사람들이 사용을 꺼려할 정도로 사용자를 압도하지 않습니다.\n- 무료 계층을 통해 공개적으로 사용 가능한 데이터셋에 대한 분석을 실행할 수 있습니다.\n- 이 글에서 고려된 분류 이외에도 다양한 도구가 제공됩니다.\n\n그럼에도 불구하고, 개선할 부분들이 몇 가지 존재하며, 몇 가지 측면들이 개선되어야 할 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 무료 티어는 개인 데이터에서 ML 모델을 실행할 수 없습니다.\n- 사용자 인터페이스가 다소 오래된 느낌이 있습니다.\n- 일부 시각화 요소가 명확하지 않고 해석하기 어려울 수 있습니다.\n- 어플리케이션이 가끔 반응이 느릴 수 있습니다.\n- 불균형 데이터를 지원하지 않습니다.\n- 이 플랫폼의 최대 잠재력을 발휘하려면 데이터 과학 및 기계 학습에 대한 일부 지식이 여전히 필요합니다 (다른 플랫폼에서도 마찬가지일 수 있습니다).\n\n다음 기사에서는 다른 플랫폼들을 사용하여 그들의 장단점을 파악하고, 각 플랫폼에 최적인 사용 사례를 확인할 것입니다.\n\n그 때까지 이 기사가 흥미로운 내용이었길 바랍니다! 피드백이나 질문이 있으시면 언제든지 자유롭게 남겨주세요!\n\n이 기사에 대한 생각이 있으신가요? LinkedIn에서 메시지를 보내거나 직접 연락 주십시오!\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n저를 팔로우해주세요! 이렇게 하면 미래의 기사 발행 알림을 받을 수 있습니다.\n\n![Image](/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_14.png)\n\n이 기사를 작성한 저자는 작성 시점에 Actable AI의 데이터 과학자였습니다.","ogImage":{"url":"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_0.png","tag":["Tech"],"readingTime":21},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch2\u003e저 코드 머신 러닝 플랫폼을 활용한 데이터 과학 | ACTABLE AI\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_0.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003ch1\u003e소개\u003c/h1\u003e\n\u003cp\u003e게임 산업에서 기업들은 플레이어를 유치하는 것 뿐만 아니라 특히 인게임 마이크로 트랜잭션에 의존하는 프리투플레이 게임에서 가능한 한 오랫동안 유지시키려고 노력합니다. 이러한 마이크로 트랜잭션은 종종 인게임 화폐 구매를 포함하며, 플레이어가 진행 또는 사용자 정의를 위한 아이템을 획득하고 게임 개발을 지원합니다. 중단하는 플레이어 수를 나타내는 이탈률을 모니터링하는 것이 중요합니다. 이는 높은 이탈율은 수입 손실을 의미하며, 이는 개발자와 관리자의 스트레스 수준이 증가하게 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 기사는 특정 모바일 앱에서 획득한 데이터를 기반으로 한 실제 데이터셋의 사용을 탐색하며, 사용자들이 플레이한 레벨에 중점을 둡니다. 기계 학습을 활용하여 기술 현장에서 중요한 역할을 하며 인공 지능(AI)의 기초를 형성한 이후, 기업들은 자신들의 데이터에서 가치 있는 통찰을 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e하지만, 기계 학습 모델을 구축하는 것은 일반적으로 코딩과 데이터 과학 전문 지식이 필요하므로, 많은 사람들 및 자원이 부족한 소규모 기업들에게는 접근하기 어렵습니다. 이러한 도전에 대처하기 위해, 로우코드와 노코드 기계 학습 플랫폼이 나타나기 시작했으며, 기계 학습과 데이터 과학 과정을 간소화하여 방대한 코딩 지식이 필요하지 않도록 하는 것을 목표로 합니다. Einblick, KNIME, Dataiku, Alteryx, Akkio와 같은 플랫폼의 예시가 있습니다.\u003c/p\u003e\n\u003cp\u003e이 기사에서는 하나의 로우코드 기계 학습 플랫폼을 사용하여 사용자가 게임을 중단할지 예측할 수 있는 모델을 훈련하는 방법을 다룹니다. 뿐만 아니라 결과 해석 및 모델 성능을 향상시키는 데 사용할 수 있는 기술에 대해 탐구합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 기사의 나머지 부분은 다음과 같이 구성되어 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e플랫폼\u003c/li\u003e\n\u003cli\u003e데이터셋\u003c/li\u003e\n\u003cli\u003e탐색적 데이터 분석\u003c/li\u003e\n\u003cli\u003e분류 모델 훈련\u003c/li\u003e\n\u003cli\u003e모델 성능 향상\u003c/li\u003e\n\u003cli\u003e새로운 특징 생성\u003c/li\u003e\n\u003cli\u003e새로운 (개선된) 분류 모델 훈련\u003c/li\u003e\n\u003cli\u003e생산 환경에 모델 배포\u003c/li\u003e\n\u003cli\u003e결론\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e플랫폼\u003c/h1\u003e\n\u003cp\u003e전체 공개 - 이 기사 작성 시점에 제가 Actable AI의 데이터 과학자인 사실을 알려드립니다. 따라서 이 기사에서는 해당 플랫폼을 사용할 예정입니다. 또한, 저는 ML 라이브러리에 새로운 기능을 구현하고 유지보수하는 일에 관여하고 있어서, 이 플랫폼이 실제 문제에 대해 어떻게 대응하는지 궁금했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e플랫폼은 전통적인 분류, 회귀 및 세분화 애플리케이션을 위한 여러 인기있는 머신 러닝 방법을 제공합니다. 시계열 예측, 감성 분석 및 인과 추론과 같은 일부 일반적이지 않은 도구도 이용할 수 있습니다. 또한, 결측 데이터를 보완할 수 있으며 데이터 세트의 통계를 계산하고(특성 간 상관 관계, 분산 분석(ANOVA) 등), 막대 차트, 히스토그램, 워드 클라우드와 같은 도구를 사용하여 데이터를 시각화할 수 있습니다.\u003c/p\u003e\n\u003cp\u003eGoogle Sheets 애드온도 제공되어 스프레드시트 내에서 직접 분석과 모델 훈련을 할 수 있습니다. 다만, 이 애드온에서는 최신 기능이 지원되지 않을 수 있으니 참고 바랍니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_1.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e핵심 라이브러리는 GitHub에서 오픈 소스로 제공되며 AutoGluon 및 scikit-learn과 같은 잘 알려진 신뢰할 수 있는 프레임워크로 구성되어 있습니다. 이는 기존의 오픈 소스 솔루션을 활용하는 다른 관련 플랫폼과 유사합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그러나, 이에 대한 질문이 생깁니다: 대부분의 도구들이 이미 사용 가능하고 무료로 제공되는데, 왜 이러한 플랫폼을 사용해야 하는지요?\u003c/p\u003e\n\u003cp\u003e가장 중요한 이유는 이러한 도구들이 Python과 같은 프로그래밍 언어에 대한 지식이 필요하다는 것입니다. 일반적으로 코딩에 익숙하지 않은 사람은 사용하기 어렵거나 불가능할 수 있습니다. 따라서 이러한 플랫폼은 프로그래밍 명령어의 형태로가 아닌 GUI(그래픽 사용자 인터페이스) 형식으로 모든 기능을 제공하려고 합니다.\u003c/p\u003e\n\u003cp\u003e더 경험이 많은 전문가들은 또한 시간을 절약할 수 있을 뿐만 아니라 쉽게 사용할 수 있는 그래픽 인터페이스를 통해 지원 도구와 기법의 정보를 제공할 수도 있습니다. 일부 플랫폼은 익숙하지 않았던 도구들을 제공하거나 데이터 작업 시 유용한 경고(예: 데이터 누출의 존재 - 모델이 볼 수 없는 데이터의 생산 환경에 배포될 때 사용할 수 없는 특징에 액세스할 수 있는 경우)를 제공할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e이러한 종류의 플랫폼을 사용하는 또 다른 이유는 모델을 실행할 하드웨어도 제공하기 때문입니다. 따라서 자신의 컴퓨터나 GPU(Graphical Processing Units)와 같은 구성 요소를 구매하고 유지 관리할 필요가 없습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003e데이터셋\u003c/h1\u003e\n\u003cp\u003e게임 회사가 제공한 데이터셋은 이곳에서 확인할 수 있으며 CC BY-SA-4 라이센스가 적용되어있어 적절한 크레딧이 제공된다면 공유 및 수정이 허용됩니다. 이 데이터셋은 789,879개의 행(샘플)을 가지고 있어 과적합과 같은 영향을 줄여줄 것으로 예상됩니다.\u003c/p\u003e\n\u003cp\u003e이 데이터셋은 개인이 모바일 앱에서 플레이한 각 레벨에 관한 정보를 포함하고 있습니다. 예를 들어, 플레이한 시간, 플레이어가 레벨에서 승리했는지 패배했는지, 레벨 번호 등에 대한 정보가 있습니다.\u003c/p\u003e\n\u003cp\u003e사용자 ID도 포함되어 있지만 원래 플레이어의 신원을 드러내지 않도록 익명화되었습니다. 일부 필드도 제거되었지만, 이 데이터셋은 이 기사에서 고려된 ML 플랫폼에서 제공된 도구가 플레이어의 이탈을 예측하는 데 유용할 수 있는지 확인하는 견고한 기초를 제공할 것으로 예상됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e각 기능의 의미는 다음과 같습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChurn: 플레이어가 게임을 2주 이상 플레이하지 않았을 경우 '1', 그렇지 않으면 '0'\u003c/li\u003e\n\u003cli\u003eServerTime: 레벨이 플레이된 서버의 타임스탬프\u003c/li\u003e\n\u003cli\u003eEndType: 레벨이 종료된 이유 ('승리'일 경우 주로 게임에서 이겼을 때, '패배'일 경우 게임에서 졌을 때)\u003c/li\u003e\n\u003cli\u003eLevelType: 레벨의 유형\u003c/li\u003e\n\u003cli\u003eLevel: 레벨 번호\u003c/li\u003e\n\u003cli\u003eSubLevel: 하위 레벨 번호\u003c/li\u003e\n\u003cli\u003eVariant: 레벨 변형\u003c/li\u003e\n\u003cli\u003eLevelversion: 레벨 버전\u003c/li\u003e\n\u003cli\u003eNextCar: 사용되지 않음 (플랫폼이 한 라벨만 포함하는 기능을 처리하는 방법 확인용으로 포함됨)\u003c/li\u003e\n\u003cli\u003eAddMoves: 추가 이동 횟수\u003c/li\u003e\n\u003cli\u003eDoubleMana: 사용되지 않음 (플랫폼이 한 라벨만 포함하는 기능을 처리하는 방법 확인용으로 포함됨)\u003c/li\u003e\n\u003cli\u003eStartMoves: 레벨 시작 시 사용 가능한 이동횟수\u003c/li\u003e\n\u003cli\u003eExtraMoves: 구매한 추가 이동 횟수\u003c/li\u003e\n\u003cli\u003eUsedMoves: 플레이어가 사용한 이동 횟수\u003c/li\u003e\n\u003cli\u003eUsedChangeCar: 사용되지 않음 (플랫폼이 한 라벨만 포함하는 기능을 처리하는 방법 확인용으로 포함됨)\u003c/li\u003e\n\u003cli\u003eWatchedVideo: 비디오를 시청했는지 여부, 추가 이동 제공\u003c/li\u003e\n\u003cli\u003eBuyMoreMoves: 플레이어가 추가 이동을 구매한 횟수\u003c/li\u003e\n\u003cli\u003ePlayTime: 레벨 플레이에 소요된 시간\u003c/li\u003e\n\u003cli\u003eScores: 플레이어가 달성한 점수\u003c/li\u003e\n\u003cli\u003eUsedCoins: 레벨에서 사용된 총 코인 수\u003c/li\u003e\n\u003cli\u003eMaxLevel: 플레이어가 도달한 최대 레벨\u003c/li\u003e\n\u003cli\u003ePlatform: 장치 유형\u003c/li\u003e\n\u003cli\u003eUserID: 플레이어의 ID\u003c/li\u003e\n\u003cli\u003eRollingLosses: 플레이어의 연속적인 패배 횟수\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e탐색적 데이터 분석\u003c/h1\u003e\n\u003cp\u003e학습 전 첫 번째 단계는 탐색적 데이터 분석(EDA)을 통해 데이터를 이해하는 것입니다. EDA는 데이터를 요약, 시각화하고 주요 특성을 이해하는 데이터 분석 방법론입니다. 목표는 데이터로부터 통찰력을 얻고, 어떠한 패턴, 추세, 이상 현상 또는 존재할 수 있는 이슈(예: 결측값)를 식별하여 사용될 특성 및 모델을 확인하는 데 도움이 되는 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e주요 이유들을 확인해 보면서 레벨이 종료된 이유에 대해 살펴보겠습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_2.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e위 이미지를 보면 레벨 종료의 주된 이유(EndType으로 표시됨)는 플레이어가 게임에서 패배한 경우(63.6%)가 승리한 경우의 35.2%에 비해 더 많다는 것을 알 수 있습니다. 또한 UsedChangeCar 열은 모든 행에 동일한 값을 포함하고 있어 쓸모없어 보입니다.\u003c/p\u003e\n\u003cp\u003e매우 중요한 점은 우리의 대상값이 매우 불균형하다는 것입니다. 처음 10,000행 중에서 63개의 샘플만이 (데이터의 0.6%) Churn 값이 1(즉, 플레이어가 이탈함)을 가지고 있다는 것입니다. 이것은 염두에 둘 필요가 있습니다. 왜냐하면 우리의 모델이 Churn에 대해 0의 값을 예측하는 데 매우 편향될 수 있기 때문입니다. 모델이 정확도와 같은 몇 가지 지표에 대해 매우 좋은 값을 얻을 수 있기 때문에, 이 경우에는 가장 일반적인 클래스를 선택하는 더미 모델이 99.4%의 정확도로 정답을 맞출 것입니다! 이에 대해 Baptiste Rocca와 Jason Brownlee의 두 훌륭한 기사에서 더 읽어보시기를 권합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e아쉽게도 Actable AI는 SMOTE(합성 소수 샘플링 기법)를 통해 불균형 데이터를 처리하거나 클래스 가중치 또는 다른 샘플링 전략을 사용하는 방법을 아직 제공하지 않습니다. 이는 최적화를 위해 선택된 지표에 주의를 기울여야 한다는 것을 의미합니다. 위에서 언급한 대로, 정확도는 한 클래스의 샘플이 올바르게 레이블링되지 않아도 높은 비율을 달성할 수 있는 경우라면 최선의 선택이 아닐 것입니다.\u003c/p\u003e\n\u003cp\u003e또 다른 유용한 분석 유형은 특징들 간의 상관 관계, 특히 예측자 특징과 대상 특징 간의 상관 관계입니다. 이를 수행하기 위해 '상관 분석' 도구를 사용할 수 있으며, 해당 결과는 Actable AI 플랫폼에서 직접 확인할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_3.png\" alt=\"HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_3\"\u003e\u003c/p\u003e\n\u003cp\u003e위 차트에서 파란 막대는 특징이 Churn과 양의 상관 관계가 있는 경우를 나타내며 값이 1인 경우이고, 주황색 막대는 음의 특징 상관 관계를 나타냅니다. 상관 관계는 -1에서 1 사이에 있음을 주의해야 합니다. 양의 값은 두 특징이 함께 변화하는 경향이 있다는 것을 나타내며(예: 둘 다 증가하거나 감소), 음의 상관 관계는 한 특징이 증가하거나 감소할 때 다른 특징이 반대로 변화한다는 것을 나타냅니다. 따라서 상관 관계의 크기(음의 부호를 무시한)가 아마도 가장 중요한 사항일 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e특정 수준을 잃은 플레이어들이 (가장 위쪽의 파란 막대) 막적회전에 민감하다는 것이나, 반대로 특정 수준을 이긴 플레이어들은 계속해서 플레이하는 경향이 있다는 등 여러 가지 교훈이 있습니다 (세 번째 오렌지 막대). 그러나 값이 상당히 낮다는 것도 주목해야 합니다. 이는 이러한 특징이 목표와 상관 관계가 약한 것을 의미합니다. 이는 모델이 더 정확한 예측을 수행하기 위해 더 중요한 정보를 포착하는 새로운 기능을 만들어 사용하는 특성 엔지니어링을 수행해야 할 것으로 예상됩니다. 특성 엔지니어링은 이 글의 뒷부분에서 자세히 다룰 것입니다.\u003c/p\u003e\n\u003cp\u003e하지만 새로운 특성을 생성하기 전에 데이터셋의 원래 특성만 사용하여 어떤 성능을 달성할 수 있는지 살펴보는 것도 좋은 방법입니다. 따라서 다음 단계는 더 흥미로운 것으로, 모델을 훈련시켜 어떤 성능을 달성할 수 있는지 알아보는 것이 될 것입니다.\u003c/p\u003e\n\u003ch1\u003e분류 모델 훈련\u003c/h1\u003e\n\u003cp\u003e사용자가 플레이를 중단할지 여부를 예측하고 싶기 때문에, 이는 여러 레이블 중 하나를 선택해야 하는 분류 문제입니다. 우리의 경우, 문제는 두 가지 레이블 중 하나('1'은 '이탈', '0'은 '이탈하지 않음'에 해당)를 할당하는 것을 포함하므로, 이는 이진 분류 문제로 만듭니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 프로세스는 주로 AutoGluon 라이브러리를 통해 수행되며, 이 라이브러리는 자동으로 여러 모델을 학습한 다음 가장 우수한 성능을 달성한 모델을 선택합니다. 이렇게 하면 각각의 모델을 수동으로 학습하고 그 성능을 비교할 필요가 없어집니다.\u003c/p\u003e\n\u003cp\u003eActable AI 플랫폼에서 설정해야 할 여러 매개변수가 있으며, 제가 선택한 옵션은 아래에 나와 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e모델의 최적화를 위해 사용할 메트릭도 선택할 수 있습니다. 저는 수신자 조작 특성 (ROC) 아래 영역 (AUC ROC) 곡선을 사용했습니다. 이는 이전에 논의된 클래스 불균형 문제에 대해 훨씬 민감하지 않기 때문입니다. 값은 0부터 1까지의 범위를 가지며 (1일수록 완벽한 점수입니다).\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e일정 시간이 지난 후에는 결과가 생성되어 표시되며, 여기서도 볼 수 있습니다. 여러 가지 다른 측정 항목이 계산되며, 이는 좋은 실천 방식일 뿐만 아니라 각 측정 항목이 모델 성능의 특정 측면에 집중하기 때문에 우리가 모델을 실제로 이해하려면 거의 필수적입니다.\u003c/p\u003e\n\u003cp\u003e표시된 첫 번째 메트릭은 최적화 메트릭으로, 값이 0.675입니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_5.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e이것은 크게 좋지는 않지만, EDA 중에 특성이 대상과 상관성이 약한 것을 상기하면, 성능이 별로 두드러지지 않는 것은 놀라운 일이 아닙니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 결과는 결과를 이해하는 중요성을 강조합니다. 보통 0.997 (즉, 99.7%) 정확도에 대해 매우 만족스러워할 것입니다. 그러나 이는 앞서 언급한 것처럼 데이터 세트의 심각한 불균형 때문이 대부분이므로 그다지 중요하지 않습니다. 한편, 정밀도와 재현율과 같은 점수는 기본적으로 임계값 0.5를 기반으로 하며, 이는 우리의 응용 프로그램에 가장 적합하지 않을 수 있습니다.\u003c/p\u003e\n\u003cp\u003eROC 및 정밀도-재현율 곡선도 표시되는데, 이것들 또한 성능이 약간 부족함을 명확히 보여줍니다:\u003c/p\u003e\n\u003cp\u003e이러한 곡선들은 최종 응용 프로그램에서 사용할 임계값을 결정하는 데도 유용합니다. 예를 들어, 거짓 양성의 수를 최소화하려면 모델이 더 높은 정밀도를 얻는 임계값을 선택하고 해당하는 재현을 확인할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e얻은 최상의 모델에서 각 피처의 중요성을 확인할 수도 있습니다. 이는 AutoGluon을 통해 순열 중요성을 사용하여 계산됩니다. 결과의 신뢰성을 결정하기 위해 P-값도 표시됩니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_6.png\"\u003e\n\u003cp\u003e아마도 놀랍지 않게도, 가장 중요한 기능은 EndType입니다(레벨이 종료된 이유를 보여주는데, 승리나 패배와 같은 요인), 그 다음은 MaxLevel(사용자가 플레이 한 가장 높은 레벨로, 숫자가 높을수록 플레이어가 게임에 매우 집중하고 활발하다는 것을 의미합니다).\u003c/p\u003e\n\u003cp\u003e반면에, UsedMoves(플레이어가 수행한 움직임의 수)는 사실상 쓸모없지만, StartMoves(플레이어가 사용할 수있는 움직임의 수)는 실제로 성능을 해칠 수 있습니다. 이것도 논리적입니다. 사용된 움직임 수와 플레이어가 사용할 수있는 움직임 수가 그 자체로는 높은 정보를 가지고 있지 않기 때문에, 두 값간의 비교가 훨씬 유용할 것입니다.\u003c/p\u003e\n\u003cp\u003e또한 각 클래스(이 경우 1 또는 0)의 추정 확률을 살펴볼 수 있습니다. 이 확률은 예측된 클래스를 도출하기 위해 사용되며(기본적으로 가장 높은 확률을 가진 클래스가 예측된 클래스로 할당됩니다):\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_7.png\"\u003e\n\u003cp\u003eAI의 설명 가능성은 모델 동작을 이해하는 데 더 중요해지고 있으며, 이로 인해 Shapley 값과 같은 도구가 인기를 끌고 있습니다. 이러한 값은 기능이 예측된 클래스의 확률에 미치는 기여를 나타냅니다. 예를 들어, 첫 번째 행에서 RollingLosses 값이 36인 경우, 해당 플레이어가 게임을 계속하는 클래스 (클래스 0)의 확률이 감소함을 볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e반대로, 이는 다른 클래스(즉, 플레이어가 이탈하는 클래스 1)의 확률이 증가함을 의미합니다. 이는 RollingLosses 값이 높을수록 플레이어가 연속해서 많은 레벨을 잃었고, 따라서 좌절하여 게임을 그만 둘 가능성이 높다는 것을 의미합니다. 반면, RollingLosses 값이 낮을수록 부정적인 클래스(즉, 플레이어가 게임을 그만 두지 않을 가능성)의 확률이 일반적으로 향상됩니다.\u003c/p\u003e\n\u003cp\u003e언급한 바와 같이 여러 모델이 훈련되고 평가된 후, 그 중에서 최적의 모델이 선택됩니다. 흥미로운 점은 이 경우 최고의 모델이 LightGBM임과 동시에 가장 빠른 모델 중 하나인 것입니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e마크다운 형식으로 테이블 태그를 변경해보세요.\u003c/p\u003e\n\u003ch1\u003e모델 성능 향상\u003c/h1\u003e\n\u003cp\u003e지금 이 시점에서는 모델의 성능을 향상시킬 수 있습니다. 아마도 가장 쉬운 방법 중 하나는 '품질 최적화' 옵션을 선택하고 얼마나 나아질 수 있는지 확인하는 것입니다. 이 옵션은 일반적으로 성능을 향상시키는 몇 가지 매개변수를 구성하며, 단단한 학습 시간의 비용으로 이루어집니다. 다음 결과를 얻었습니다 (여기에서도 확인할 수 있습니다):\u003c/p\u003e\n\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_9.png\"\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다시 ROC AUC 지표에 초점을 맞추면, 성능이 0.675에서 0.709로 향상되었습니다. 이렇게 간단한 변경으로 성능이 상당히 향상된 것입니다. 하지만 여전히 이상적인 수준에서는 멀리 떨어져 있습니다. 더 나은 성능을 위해 우리가 할 수 있는 다른 방법이 있을까요?\u003c/p\u003e\n\u003ch1\u003e새로운 기능 만들기\u003c/h1\u003e\n\u003cp\u003e이전에 논의한 대로, 이것을 특성 공학을 사용하여 수행할 수 있습니다. 이것은 기존 기능에서 새로운 기능을 만드는 것을 의미하며, 이러한 새로운 기능은 더 강력한 패턴을 포착하고 예측할 변수와 더 높은 상관 관계를 갖도록 할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e우리의 경우, 데이터 세트의 기능은 사용자가 플레이한 레벨에 관한 정보에 대한 값만을 갖기 때문에 범위가 상당히 좁습니다. 따라서, 시간을 거쳐 레코드를 요약함으로써 더 전반적인 전망을 얻는 것이 매우 유용할 수 있습니다. 이렇게 함으로써 모델은 사용자의 역사적인 추세에 대한 지식을 가질 수 있을 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예를 들어, 플레이어가 사용한 추가 움직임의 수를 확인하여 경험한 난이도를 측정할 수 있습니다. 추가 움직임이 거의 필요하지 않았다면, 레벨이 너무 쉬웠을 수도 있습니다. 반대로 많은 숫자는 레벨이 너무 어려웠을 수도 있습니다.\u003c/p\u003e\n\u003cp\u003e또한, 플레이어가 게임에 몰입하고 참여하고 있는지 확인하기 위해 이전 몇 날 동안 게임을 플레이한 시간을 확인하는 것도 좋은 아이디어일 것입니다. 게임을 별로 하지 않았다면, 그들이 흥미를 잃고 곧 그만둘 수도 있다는 의미일 수 있습니다.\u003c/p\u003e\n\u003cp\u003e유용한 특징들은 서로 다른 도메인에서 다양하기 때문에 현재 작업과 관련된 정보를 찾는 것이 중요합니다. 예를 들어, 연구 논문, 사례 연구 및 기사를 찾거나 해당 분야에서 일한 회사나 전문가들의 조언을 구하면 가장 일반적인 특징, 특징 간의 관계, 잠재적인 함정 및 유용할 것으로 예상되는 새로운 특징들에 대해 숙련된 지식이 있는 사람들로부터 도움을 받을 수 있습니다. 이러한 접근 방식은 시행착오를 줄이고 특징 엔지니어링 프로세스를 가속화하는 데 도움이 됩니다.\u003c/p\u003e\n\u003cp\u003e최근 대규모 언어 모델(LLMs)의 발전과 (예: ChatGPT를 들어본 적이 있을지도 모르죠...), 그리고 특징 엔지니어링 프로세스가 경험 부족한 사용자에게는 다소 어려울 수 있기 때문에, LLMs가 어떤 특징을 생성할 수 있는 아이디어를 제공하는 데 어떤 지원이 될 수 있는지 궁금했습니다. 저는 이를 테스트해보았고, 다음 결과가 나왔습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_10.png\"\u003e\n\u003cp\u003e차트 GPT의 답변은 실제로 아주 좋습니다. 또한 앞서 언급한 바와 같이 여러 시간 기반 특성을 가리키기도 합니다. 물론 필요한 정보가 없을 경우 모든 제안된 기능을 구현할 수 없을 수도 있음을 염두에 두세요. 게다가 이것은 망상에 빠지기 쉬우며, 따라서 완전히 정확한 답변을 제공하지 못할 수도 있습니다.\u003c/p\u003e\n\u003cp\u003eChatGPT로부터 더 관련성 높은 응답을 받으려면 사용 중인 특성을 지정하거나 프롬프트를 활용하는 등의 방법을 사용할 수 있습니다. 그러나 이는 본 문서의 범위를 벗어나므로 독자들에게 연습 과제로 남겨두겠습니다. 그럼에도 불구하고, LLMs는 시작 단계로 고려할 수 있지만, 논문, 전문가 등보다 신뢰할 만한 정보를 얻기 위해 노력하는 것이 강력히 권장됩니다.\u003c/p\u003e\n\u003cp\u003eActable AI 플랫폼에서는 상당히 잘 알려진 SQL 프로그래밍 언어를 사용하여 새로운 기능을 만들 수 있습니다. SQL에 익숙하지 않은 사용자를 위해 ChatGPT를 활용하여 쿼리를 자동으로 생성하는 방법이 유용할 수 있습니다. 그러나 내가 제한된 실험을 통해 이 방법의 신뢰성은 다소 일관되지 않을 수 있다는 것을 발견했습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e원하는 결과를 정확하게 계산하기 위해 의도한 출력물을 수동으로 확인하여 검증하는 것이 좋습니다. SQL Lab에서 쿼리를 실행한 후에 나타나는 테이블을 확인하여 이를 확인할 수 있습니다. Actable AI는 SQL 코드를 작성하고 실행하는 인터페이스입니다.\u003c/p\u003e\n\u003cp\u003e다음은 새로운 열을 생성하는 데 사용한 SQL 코드입니다. 다른 기능을 만들고 싶다면 이것을 참고하여 시작할 수 있을 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    *,\n    \u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"PlayTime\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserLevelWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"time_spent_on_level\"\u003c/span\u003e,\n    (a.\u003cspan class=\"hljs-string\"\u003e\"Max_Level\"\u003c/span\u003e - a.\u003cspan class=\"hljs-string\"\u003e\"Min_Level\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"levels_completed_in_last_7_days\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-title function_\"\u003eCOALESCE\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eCAST\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"total_wins_in_last_14_days\"\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDECIMAL\u003c/span\u003e)/\u003cspan class=\"hljs-title function_\"\u003eNULLIF\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"total_losses_in_last_14_days\"\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e), \u003cspan class=\"hljs-number\"\u003e0.0\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"win_to_lose_ratio_in_last_14_days\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-title function_\"\u003eCOALESCE\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"UsedCoins\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser1DayWindow\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"UsedCoins_in_last_1_days\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-title function_\"\u003eCOALESCE\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"UsedCoins\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser7DayWindow\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"UsedCoins_in_last_7_days\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-title function_\"\u003eCOALESCE\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"UsedCoins\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser14DayWindow\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"UsedCoins_in_last_14_days\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-title function_\"\u003eCOALESCE\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ExtraMoves\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser1DayWindow\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ExtraMoves_in_last_1_days\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-title function_\"\u003eCOALESCE\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ExtraMoves\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser7DayWindow\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ExtraMoves_in_last_7_days\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-title function_\"\u003eCOALESCE\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ExtraMoves\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser14DayWindow\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ExtraMoves_in_last_14_days\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-title function_\"\u003eAVG\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"RollingLosses\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser7DayWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"RollingLosses_mean_last_7_days\"\u003c/span\u003e,\n    \u003cspan class=\"hljs-title function_\"\u003eAVG\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"MaxLevel\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePastWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"MaxLevel_mean\"\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e (\n    \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e\n        *,\n        \u003cspan class=\"hljs-title function_\"\u003eMAX\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Level\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser7DayWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Max_Level\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-title function_\"\u003eMIN\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Level\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser7DayWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Min_Level\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eCASE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eWHEN\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"EndType\"\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'Lose'\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTHEN\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eELSE\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eEND\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser14DayWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"total_losses_in_last_14_days\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eCASE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eWHEN\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"EndType\"\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e'Win'\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eTHEN\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eELSE\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eEND\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser14DayWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"total_wins_in_last_14_days\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"PlayTime\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser7DayWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"PlayTime_cumul_7_days\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"RollingLosses\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser7DayWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"RollingLosses_cumul_7_days\"\u003c/span\u003e,\n        \u003cspan class=\"hljs-title function_\"\u003eSUM\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"PlayTime\"\u003c/span\u003e) \u003cspan class=\"hljs-variable constant_\"\u003eOVER\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUserPastWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"PlayTime_cumul\"\u003c/span\u003e\n    \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"game_data_levels\"\u003c/span\u003e\n    \u003cspan class=\"hljs-variable constant_\"\u003eWINDOW\u003c/span\u003e\n        \u003cspan class=\"hljs-title class_\"\u003eUser7DayWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n            \u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"UserID\"\u003c/span\u003e\n            \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ServerTime\"\u003c/span\u003e\n            \u003cspan class=\"hljs-variable constant_\"\u003eRANGE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINTERVAL\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'7'\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDAY\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRECEDING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCURRENT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROW\u003c/span\u003e\n        ),\n        \u003cspan class=\"hljs-title class_\"\u003eUser14DayWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n            \u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"UserID\"\u003c/span\u003e\n            \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ServerTime\"\u003c/span\u003e\n            \u003cspan class=\"hljs-variable constant_\"\u003eRANGE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINTERVAL\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'14'\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDAY\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRECEDING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCURRENT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROW\u003c/span\u003e\n        ),\n        \u003cspan class=\"hljs-title class_\"\u003eUserPastWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n        \u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"UserID\"\u003c/span\u003e\n        \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ServerTime\"\u003c/span\u003e\n        \u003cspan class=\"hljs-variable constant_\"\u003eROWS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eUNBOUNDED\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRECEDING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCURRENT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROW\u003c/span\u003e\n        )\n) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e a\n\u003cspan class=\"hljs-variable constant_\"\u003eWINDOW\u003c/span\u003e\n    \u003cspan class=\"hljs-title class_\"\u003eUserLevelWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n        \u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"UserID\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"Level\"\u003c/span\u003e\n        \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ServerTime\"\u003c/span\u003e\n        \u003cspan class=\"hljs-variable constant_\"\u003eROWS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eUNBOUNDED\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRECEDING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCURRENT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROW\u003c/span\u003e\n    ),\n    \u003cspan class=\"hljs-title class_\"\u003ePastWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n        \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ServerTime\"\u003c/span\u003e\n        \u003cspan class=\"hljs-variable constant_\"\u003eROWS\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eUNBOUNDED\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRECEDING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCURRENT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROW\u003c/span\u003e\n    ),\n    \u003cspan class=\"hljs-title class_\"\u003eUser1DayWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n        \u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"UserID\"\u003c/span\u003e \n        \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ServerTime\"\u003c/span\u003e \n        \u003cspan class=\"hljs-variable constant_\"\u003eRANGE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINTERVAL\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'1'\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDAY\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRECEDING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCURRENT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROW\u003c/span\u003e\n    ),\n    \u003cspan class=\"hljs-title class_\"\u003eUser7DayWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n        \u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"UserID\"\u003c/span\u003e\n        \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ServerTime\"\u003c/span\u003e\n        \u003cspan class=\"hljs-variable constant_\"\u003eRANGE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINTERVAL\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'7'\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDAY\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRECEDING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCURRENT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROW\u003c/span\u003e\n    ),\n    \u003cspan class=\"hljs-title class_\"\u003eUser14DayWindow\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e (\n        \u003cspan class=\"hljs-variable constant_\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"UserID\"\u003c/span\u003e\n        \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ServerTime\"\u003c/span\u003e\n        \u003cspan class=\"hljs-variable constant_\"\u003eRANGE\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eINTERVAL\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'14'\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDAY\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003ePRECEDING\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAND\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCURRENT\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eROW\u003c/span\u003e\n    )\n\u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"ServerTime\"\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드에서 '윈도우'는 고려할 시간 범위를 정의하기 위해 생성되어 마지막 날, 지난 주 또는 지난 2주와 같은 것을 나타냅니다. 해당 범위 내에 속한 레코드가 기능 계산 중에 사용되며, 이는 주로 게임에서 플레이어의 여정에 대한 일부 역사적 맥락을 제공하기 위해 의도되었습니다. 전체 기능 목록은 다음과 같습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003elevel_time_spend: 사용자가 레벨을 플레이하는 데 소요된 시간을 나타냅니다. 레벨의 난이도를 나타냅니다.\u003c/li\u003e\n\u003cli\u003elevels_completed_last_7_days: 사용자가 지난 7일 동안(1주일) 완료한 레벨 수를 나타냅니다. 난이도, 인내력 및 게임에 대한 몰입도를 보여줍니다.\u003c/li\u003e\n\u003cli\u003etotal_wins_last_14_days: 사용자가 레벨을 이긴 총 횟수\u003c/li\u003e\n\u003cli\u003etotal_losses_last_14_days: 사용자가 레벨을 진 총 횟수\u003c/li\u003e\n\u003cli\u003ewin_to_lose_ratio_last_14_days: 승리 횟수와 패배 횟수의 비율 (total_wins_last_14_days/total_losses_last_14_days)\u003c/li\u003e\n\u003cli\u003eused_coins_last_1_days: 이전 날 사용된 코인 수. 레벨 난이도 및 플레이어가 게임 내 통화를 사용할 의지를 보여줍니다.\u003c/li\u003e\n\u003cli\u003eused_coins_last_7_days: 지난 7일간 사용된 코인 수 (1주일)\u003c/li\u003e\n\u003cli\u003eused_coins_last_14_days: 지난 14일간 사용된 코인 수 (2주)\u003c/li\u003e\n\u003cli\u003eextra_moves_last_1_days: 사용자가 이전 날에 사용한 추가 움직임 수. 레벨 난이도를 나타냅니다.\u003c/li\u003e\n\u003cli\u003eextra_moves_last_7_days: 사용자가 지난 7일 동안 사용한 추가 움직임 수 (1주)\u003c/li\u003e\n\u003cli\u003eextra_moves_last_14_days: 사용자가 지난 14일 동안 사용한 추가 움직임 수 (2주)\u003c/li\u003e\n\u003cli\u003erolling_losses_mean_last_7_days: 사용자가 지난 7일 동안 누적으로 경험한 평균 손실 횟수 (1주). 레벨 난이도를 보여줍니다.\u003c/li\u003e\n\u003cli\u003emax_level_mean: 모든 사용자가 달성한 최고 레벨의 평균.\u003c/li\u003e\n\u003cli\u003emax_level: 사용자가 지난 7일 동안(1주) 달성한 최고 레벨. max_level_mean과 결합하여 플레이어의 다른 플레이어들에 대한 진행 상황을 보여줍니다.\u003c/li\u003e\n\u003cli\u003emin_level: 사용자가 지난 7일 동안(1주) 플레이한 최소 레벨\u003c/li\u003e\n\u003cli\u003eplay_time_cumul_7_days: 사용자가 지난 7일 동안(1주) 플레이한 총 시간. 플레이어의 게임 몰입도를 나타냅니다.\u003c/li\u003e\n\u003cli\u003eplay_time_cumul: 사용자가 플레이한 총 시간(첫 번째 기록부터)\u003c/li\u003e\n\u003cli\u003erolling_losses_cumul_7_days: 지난 7일 동안(1주) 누적된 롤링 손실 총 횟수. 레벨의 난이도를 나타냅니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e새로운 기능의 값을 계산할 때는 이전 레코드만 사용하는 것이 중요합니다. 다시 말해, 향후 관측치의 사용은 피해야 합니다. 왜냐하면 모델이 상용 환경에 배포될 때 미래 값에 액세스할 방법이 없기 때문입니다.\u003c/p\u003e\n\u003cp\u003e생성된 피처에 만족하셨다면 테이블을 새 데이터 세트로 저장하고 (희망적으로) 성능이 향상된 새 모델을 실행할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e새로운 (희망적으로 향상된) 분류 모델 훈련\u003c/h1\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e새로운 열이 유용한지 확인할 시간이에요. 이전과 동일한 단계를 반복할 수 있어요. 유일한 차이점은 이제 추가 기능을 포함하는 새 데이터 세트를 사용한다는 것이에요. 기존 모델과 공정한 비교를 위해 동일한 설정을 사용하여 원본 모델과 다음 결과와 함께 최적화합니다(여기서도 확인할 수 있습니다):\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_11.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003cp\u003e0.918의 ROC AUC 값은 원래 값인 0.675와 비교했을 때 크게 향상되었어요. 심지어 품질에 최적화된 모델(0.709)보다 더 나아요! 이는 데이터를 이해하고 더 풍부한 정보를 제공할 수 있는 새로운 기능을 만드는 중요성을 보여줍니다.\u003c/p\u003e\n\u003cp\u003e이제 어떤 새로운 기능이 실제로 가장 유용했는지 확인하는 것이 흥미롭겠죠. 다시 한번 특징 중요도 표를 확인할 수 있어요:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_12.png\" alt=\"그림\"\u003e\u003c/p\u003e\n\u003cp\u003e최근 두 주간의 총 패배 횟수가 매우 중요한 것으로 보입니다. 이는 게임에서 더 자주 패배할수록 플레이어가 좌절하고 플레이를 그만둘 가능성이 더 높아진다는 논리적입니다.\u003c/p\u003e\n\u003cp\u003e모든 사용자의 평균 최대 레벨도 중요한 것으로 보입니다. 다시 한번, 플레이어가 다수의 다른 플레이어와 얼마나 멀리 떨어져 있는지를 결정하는 데 사용될 수 있습니다. 평균보다 훨씬 높은 level은 플레이어가 게임에 깊게 몰두해 있다는 것을 나타내고, 평균보다 훨씬 낮은 값은 플레이어가 여전히 충분히 동기 부여받지 못했을 수 있다는 것을 나타낼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e이것들은 우리가 만들었을 수 있는 몇 가지 간단한 기능에 불과합니다. 성능을 더 향상시킬 수 있는 다른 기능들이 있을 수 있습니다. 독자에게 어떤 다른 기능들이 만들어질 수 있는지 확인해 보도록 남겨두겠습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e지난과 동일한 시간 제한으로 품질에 최적화된 모델을 훈련시키는 것은 성능을 향상시키지 않았습니다. 그러나 더 많은 피처를 사용하고 있기 때문에 최적화에 더 많은 시간이 필요할 수 있기 때문에 이해할 만한 일입니다. 여기서 시간 제한을 6시간으로 늘리면 성능이 실제로 0.923(AUC 기준)로 향상된 것을 확인할 수 있습니다:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_13.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e또한 정밀도 및 재현율과 같은 몇 가지 메트릭이 여전히 상당히 낮다는 점에 유의해야 합니다. 그러나 이는 0.5의 분류 임계값을 가정했기 때문일 수 있습니다. 임계값을 곡선을 클릭하여 변경할 수 있지만 AUC는 임계값에 독립적이며 성능을 더 포괄적으로 나타낼 수 있습니다. 앞서 언급했듯이 AUC는 불균형 데이터셋을 기반으로 훈련하는 동안 최적화 메트릭으로 사용될 때 특히 유용합니다.\u003c/p\u003e\n\u003cp\u003e훈련된 모델의 AUC 성능은 다음과 같이 요약할 수 있습니다:\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eModel\u003c/th\u003e\u003cth\u003eAUC (ROC)\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eOriginal features\u003c/td\u003e\u003ctd\u003e0.675\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eOriginal features + optim. for quality\u003c/td\u003e\u003ctd\u003e0.709\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eEngineered features\u003c/td\u003e\u003ctd\u003e0.918\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eEngineered features + optim. for quality + longer time\u003c/td\u003e\u003ctd\u003e0.923\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\u003ch1\u003e프로덕션 환경에 모델 배포하기\u003c/h1\u003e\n\u003cp\u003e새로운 데이터에서 실제로 모델을 사용할 수 없다면 좋은 모델이 있어도 쓸모가 없습니다. 머신러닝 플랫폼은 훈련된 모델을 사용하여 미래의 보이지 않는 데이터에 대한 예측을 생성하는 기능을 제공할 수 있습니다. 예를 들어, Actable AI 플랫폼은 API를 통해 모델을 사용하여 플랫폼 외부 데이터에 사용할 수 있게 해주며, 모델을 내보내거나 원시 값을 삽입하여 즉시 예측을 얻을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e그러나 모델을 주기적으로 미래 데이터에 테스트하는 것은 매우 중요합니다. 모델이 여전히 예상대로 작동하는지 확인하기 위해 필요합니다. 실제로 더 최신 데이터로 모델을 다시 훈련해야 할 수도 있습니다. 이는 특징(예: 피처 분포)이 시간이 지남에 따라 변경될 수 있어 모델의 정확도에 영향을 미칠 수 있기 때문입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예를 들어, 회사에서 새로운 정책을 도입할 수 있으며 이는 고객 행동에 영향을 미칠 수 있습니다(긍정적 또는 부정적). 그러나 새로운 변화를 반영하는 기능이 없는 경우 모델은 새로운 정책을 고려하지 못할 수 있습니다. 만일 그런 심각한 변화가 있지만 모델에 정보를 제공할 수 있는 기능이 없다면, 고려해볼 가치가 있는 것은 두 모델을 사용하는 것입니다: 하나는 이전 데이터를 훈련시키고 사용하는 데에 특화되고, 다른 하나는 최신 데이터를 훈련시키고 사용하는 데에 특화하는 것입니다. 이렇게 함으로써 모델이 단일 모델로 잡기 어려운 서로 다른 특성을 가진 데이터에서 작동할 수 있도록 보장할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003e본 글에서는 사용자가 모바일 앱에서 각 레벨을 하면서 생성된 정보를 포함하는 실제 데이터 세트를 사용하여, 플레이어가 2주 후에 게임을 그만둘지를 예측할 수 있는 분류 모델을 훈련시켰습니다.\u003c/p\u003e\n\u003cp\u003e데이터 탐색부터 모델 훈련, 피처 엔지니어링까지 전반적인 처리 파이프라인을 고려했습니다. 결과의 해석에 대한 토론과 어떻게 향상시킬 수 있는지가 제공되었으며, 0.675에서 0.923으로 가치를 향상시키는 방법을 탐색했습니다(1.0이 최대값입니다).\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e새로 만들어진 기능들은 비교적 간단합니다. 더 많은 기능들이 있을 수 있지만, Feature Normalisation과 Standardisation 같은 기술들 역시 고려해볼 만 합니다. 여기와 여기에서 유용한 자료들을 찾을 수 있습니다.\u003c/p\u003e\n\u003cp\u003eActable AI 플랫폼에 관해서, 제가 조금 편협한 의견을 가지고 있을 수도 있지만, 이 플랫폼이 데이터 과학자와 머신 러닝 전문가에 의해 수행되어야 하는 좀 더 성가신 프로세스들을 간단화할 수 있다고 생각합니다. 다음과 같은 우수한 측면이 있습니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCore ML 라이브러리는 오픈 소스이기 때문에 좋은 프로그래밍 지식을 가진 사람이라면 안전하게 사용할 수 있습니다. 또한 Python을 알고 있는 사람이라면 누구나 사용할 수 있습니다.\u003c/li\u003e\n\u003cli\u003ePython을 모르거나 코딩에 익숙하지 않은 사람들을 위해 GUI를 통해 쉽게 분석 및 시각화를 할 수 있는 방법을 제공합니다.\u003c/li\u003e\n\u003cli\u003e플랫폼을 사용하기 시작하는 것이 너무 어렵지 않습니다. 기술적인 정보가 너무 많아서 지식이 부족한 사람들이 사용을 꺼려할 정도로 사용자를 압도하지 않습니다.\u003c/li\u003e\n\u003cli\u003e무료 계층을 통해 공개적으로 사용 가능한 데이터셋에 대한 분석을 실행할 수 있습니다.\u003c/li\u003e\n\u003cli\u003e이 글에서 고려된 분류 이외에도 다양한 도구가 제공됩니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e그럼에도 불구하고, 개선할 부분들이 몇 가지 존재하며, 몇 가지 측면들이 개선되어야 할 것입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e무료 티어는 개인 데이터에서 ML 모델을 실행할 수 없습니다.\u003c/li\u003e\n\u003cli\u003e사용자 인터페이스가 다소 오래된 느낌이 있습니다.\u003c/li\u003e\n\u003cli\u003e일부 시각화 요소가 명확하지 않고 해석하기 어려울 수 있습니다.\u003c/li\u003e\n\u003cli\u003e어플리케이션이 가끔 반응이 느릴 수 있습니다.\u003c/li\u003e\n\u003cli\u003e불균형 데이터를 지원하지 않습니다.\u003c/li\u003e\n\u003cli\u003e이 플랫폼의 최대 잠재력을 발휘하려면 데이터 과학 및 기계 학습에 대한 일부 지식이 여전히 필요합니다 (다른 플랫폼에서도 마찬가지일 수 있습니다).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e다음 기사에서는 다른 플랫폼들을 사용하여 그들의 장단점을 파악하고, 각 플랫폼에 최적인 사용 사례를 확인할 것입니다.\u003c/p\u003e\n\u003cp\u003e그 때까지 이 기사가 흥미로운 내용이었길 바랍니다! 피드백이나 질문이 있으시면 언제든지 자유롭게 남겨주세요!\u003c/p\u003e\n\u003cp\u003e이 기사에 대한 생각이 있으신가요? LinkedIn에서 메시지를 보내거나 직접 연락 주십시오!\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e저를 팔로우해주세요! 이렇게 하면 미래의 기사 발행 알림을 받을 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT_14.png\" alt=\"Image\"\u003e\u003c/p\u003e\n\u003cp\u003e이 기사를 작성한 저자는 작성 시점에 Actable AI의 데이터 과학자였습니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-23-HowtoPredictPlayerChurnwithSomeHelpFromChatGPT"},"buildId":"CYQjEY3HhSkRTiL0gewc0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>