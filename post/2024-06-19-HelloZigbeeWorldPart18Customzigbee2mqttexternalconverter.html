<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>안녕하세요, 지그비 세계, 18부 - 사용자 정의 zigbee2mqtt 외부 변환기 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="안녕하세요, 지그비 세계, 18부 - 사용자 정의 zigbee2mqtt 외부 변환기 | itposting" data-gatsby-head="true"/><meta property="og:title" content="안녕하세요, 지그비 세계, 18부 - 사용자 정의 zigbee2mqtt 외부 변환기 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter" data-gatsby-head="true"/><meta name="twitter:title" content="안녕하세요, 지그비 세계, 18부 - 사용자 정의 zigbee2mqtt 외부 변환기 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 17:08" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-4a646156c659a948.js" defer=""></script><script src="/_next/static/chunks/348-d11c34b645b13f5b.js" defer=""></script><script src="/_next/static/chunks/162-4172e84c8e2aa747.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-0fd008072af5a644.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_buildManifest.js" defer=""></script><script src="/_next/static/FH3Qr-mLAesqA0X5IFRQr/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">안녕하세요, 지그비 세계, 18부 - 사용자 정의 zigbee2mqtt 외부 변환기</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="안녕하세요, 지그비 세계, 18부 - 사용자 정의 zigbee2mqtt 외부 변환기" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">18<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>이전 두 편의 글에서는 스마트 스위치에 여러 작업을 지원하는 기능을 구현하여, 멀티스테이트 입력 클러스터를 통해 단일/더블/트리플/롱 프레스를 처리하고 보고할 수 있게 되었습니다. 또한 On/Off 스위치 설정 클러스터의 사용자 정의 확장을 통해 장치의 설정을 제어하는 기능도 구현했습니다. 이러한 추가 기능으로 사용자들은 Zigbee 시설을 이용하여 런타임에서 장치를 구성할 수 있게 됩니다.</p>
<p>그러나 한 가지 문제가 있습니다: 우리는 장치 측면에서 이를 구현했지만, zigbee2mqtt와 같은 다른 시스템들은 이러한 추가 기능과 어떻게 작동해야 하는지 알지 못합니다. 이 글에서는 우리의 장치를 지원하기 위해 zigbee2mqtt용의 외부 컨버터 — 특별한 플러그인을 작성하는 방법을 상세히 설명하고 있습니다.</p>
<p>일반적으로, 나의 코드는 이전 글에서 만든 코드를 기반으로 합니다. 개발 보드로는 NXP JN5169 마이크로컨트롤러를 기반으로 한 EBYTE E75-2G4M10S 모듈을 사용할 것입니다. 이 글은 Hello Zigbee 시리즈에 훌륭한 추가 내용이 되며, 처음부터 Zigbee 장치 펌웨어를 구축하는 방법을 설명하고 있습니다.</p>
<h1>Zigbee2mqtt 외부 컨버터</h1>
<p>안타깝게도 외부 컨버터에 대한 문서화가 매우 미흡하며, 정확히 함수가 무엇을 해야 하는지에 대한 좋은 설명을 찾지 못했습니다. 조금 모호한 예제 몇 개가 있지만, 이에 대해 많은 의문이 듭니다.</p>
<p>우리의 사용자 정의 On/Off Switch Configuration Cluster를 지원하기로 시작합시다. 저는 직접 <code>poke</code> 메서드를 사용하여 내 컨버터를 작성해야 했고, 그들이 어떻게 동작해야 하는지 파악하기 위해 수십 개의 기존 컨버터를 살펴보았습니다. 제가 제작 중일 때 컨버터에 대해 공부한 내용은 다음과 같습니다.</p>
<p>모든 컨버터는 <code>imports</code>로 시작합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> fz = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zigbee-herdsman-converters/converters/fromZigbee'</span>);
<span class="hljs-keyword">const</span> tz = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zigbee-herdsman-converters/converters/toZigbee'</span>);
<span class="hljs-keyword">const</span> exposes = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zigbee-herdsman-converters/lib/exposes'</span>);
<span class="hljs-keyword">const</span> reporting = <span class="hljs-built_in">require</span>(<span class="hljs-string">'zigbee-herdsman-converters/lib/reporting'</span>);
<span class="hljs-keyword">const</span> e = exposes.<span class="hljs-property">presets</span>;
<span class="hljs-keyword">const</span> ea = exposes.<span class="hljs-property">access</span>;
</code></pre>
<p>우리가 맞춤 필드를 여러 개 추가했기 때문에, 그들과 관련된 유형 및 데이터 구조를 설명해야 합니다. Herdsman converters 프로젝트에서 정의된 모든 가능한 유형이 있습니다. 불행하게도, TypeScript에서 구조체를 JavaScript 코드로 가져오는 방법을 찾지 못해 필요한 유형의 값을 중복해서 작성해야 했습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">DataType</span> = {
    <span class="hljs-attr">uint16</span>: <span class="hljs-number">0x21</span>,
    <span class="hljs-attr">enum8</span>: <span class="hljs-number">0x30</span>,
}
</code></pre>
<p>새로운 속성에 대한 열거형 값들을 정의해봅시다. 값들의 순서는 펌웨어 코드에 설명된 것과 동일하며, 변환기 코드는 목록에서 위치 번호를 해당 값과 일치시키기만 하면 됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> switchTypeValues = [<span class="hljs-string">'toggle'</span>, <span class="hljs-string">'momentary'</span>, <span class="hljs-string">'multifunction'</span>];
<span class="hljs-keyword">const</span> switchActionValues = [<span class="hljs-string">'onOff'</span>, <span class="hljs-string">'offOn'</span>, <span class="hljs-string">'toggle'</span>];
<span class="hljs-keyword">const</span> relayModeValues = [<span class="hljs-string">'unlinked'</span>, <span class="hljs-string">'front'</span>, <span class="hljs-string">'single'</span>, <span class="hljs-string">'double'</span>, <span class="hljs-string">'tripple'</span>, <span class="hljs-string">'long'</span>];
</code></pre>
<p>제조업체별 속성을 참조할 때에는 속성 식별자 뿐만 아니라 제조업체 코드도 명시해야 합니다. 그렇지 않으면 ZCL 펌웨어 코드에서 요청을 거부합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> manufacturerOptions = {
    <span class="hljs-attr">jennic</span>: {<span class="hljs-attr">manufacturerCode</span>: <span class="hljs-number">0x1037</span>}
}
</code></pre>
<p>이제 z2m 웹 양식에 해당 필드를 등록해야 합니다. 이러한 필드는 디바이스의 Exposes 탭에 표시됩니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">genSwitchEndpoint</span>(<span class="hljs-params">epName</span>) {
   <span class="hljs-keyword">return</span> [
       e.<span class="hljs-title function_">switch</span>().<span class="hljs-title function_">withEndpoint</span>(epName),
       exposes.<span class="hljs-title function_">enum</span>(<span class="hljs-string">'switch_mode'</span>, ea.<span class="hljs-property">ALL</span>, switchModeValues).<span class="hljs-title function_">withEndpoint</span>(epName),
       exposes.<span class="hljs-title function_">enum</span>(<span class="hljs-string">'switch_actions'</span>, ea.<span class="hljs-property">ALL</span>, switchActionValues).<span class="hljs-title function_">withEndpoint</span>(epName),
       exposes.<span class="hljs-title function_">enum</span>(<span class="hljs-string">'relay_mode'</span>, ea.<span class="hljs-property">ALL</span>, relayModeValues).<span class="hljs-title function_">withEndpoint</span>(epName),
       exposes.<span class="hljs-title function_">numeric</span>(<span class="hljs-string">'max_pause'</span>, ea.<span class="hljs-property">ALL</span>).<span class="hljs-title function_">withEndpoint</span>(epName),
       exposes.<span class="hljs-title function_">numeric</span>(<span class="hljs-string">'min_long_press'</span>, ea.<span class="hljs-property">ALL</span>).<span class="hljs-title function_">withEndpoint</span>(epName),
   ]
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">genSwitchEndpoints</span>(<span class="hljs-params">endpoinsCount</span>) {
   <span class="hljs-keyword">let</span> features = [];

   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &#x3C;= endpoinsCount; i++) {
       <span class="hljs-keyword">const</span> epName = <span class="hljs-string">`button_<span class="hljs-subst">${i}</span>`</span>;
       features.<span class="hljs-title function_">push</span>(...<span class="hljs-title function_">genSwitchEndpoint</span>(epName));
   }

   <span class="hljs-keyword">return</span> features;
}
</code></pre>
<p>주어진 엔드포인트 수에 대해 첫 번째 함수는 스위치 위젯 (e.switch())과 구성 필드 시리즈를 생성합니다. 결과물은 다음과 같습니다.</p>
<p>2~3개 값으로 이루어진 열거형 필드는 버튼으로, 다른 필드(relay_mode)는 드롭다운 목록으로 변환되었습니다. 마지막 두 숫자 필드는 증가/감소 화살표가 있는 입력 필드입니다.</p>
<p>이제 이에 생명을 불어넣고, 3개의 변환 함수를 작성해야 합니다. 이 3개의 함수는 toZigbee 및 fromZigbee라는 코드명으로 구성되어야 합니다. 정확히 무슨 의미인지는 아래에서 설명하겠습니다.</p>
<p>양식을 변경할 때 zigbee2mqtt는 toZigbee 구조에서 convertSet() 함수를 호출합니다. key 필드는 또한 우리의 컨버터가 처리할 수있는 매개변수 목록을 지정합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> toZigbee_OnOffSwitchCfg = {
   <span class="hljs-attr">key</span>: [<span class="hljs-string">'switch_mode'</span>, <span class="hljs-string">'switch_actions'</span>, <span class="hljs-string">'relay_mode'</span>, <span class="hljs-string">'max_pause'</span>, <span class="hljs-string">'min_long_press'</span>],

   <span class="hljs-attr">convertSet</span>: <span class="hljs-keyword">async</span> (entity, key, value, meta) => {
       <span class="hljs-keyword">let</span> payload = {};
       <span class="hljs-keyword">let</span> newValue = value;

       <span class="hljs-keyword">switch</span>(key) {
           <span class="hljs-keyword">case</span> <span class="hljs-string">'switch_mode'</span>:
               newValue = switchModeValues.<span class="hljs-title function_">indexOf</span>(value);
               payload = {<span class="hljs-number">65280</span>: {<span class="hljs-string">'value'</span>: newValue, <span class="hljs-string">'type'</span>: <span class="hljs-title class_">DataType</span>.<span class="hljs-property">enum8</span>};
               <span class="hljs-keyword">await</span> entity.<span class="hljs-title function_">write</span>(<span class="hljs-string">'genOnOffSwitchCfg'</span>, payload, manufacturerOptions.<span class="hljs-property">jennic</span>);
               <span class="hljs-keyword">break</span>;

           <span class="hljs-keyword">case</span> <span class="hljs-string">'switch_actions'</span>:
               newValue = switchActionValues.<span class="hljs-title function_">indexOf</span>(value);
               payload = {<span class="hljs-attr">switchActions</span>: newValue};
               <span class="hljs-keyword">await</span> entity.<span class="hljs-title function_">write</span>(<span class="hljs-string">'genOnOffSwitchCfg'</span>, payload);
               <span class="hljs-keyword">break</span>;

           <span class="hljs-keyword">case</span> <span class="hljs-string">'relay_mode'</span>:
               newValue = relayModeValues.<span class="hljs-title function_">indexOf</span>(value);
               payload = {<span class="hljs-number">65281</span>: {<span class="hljs-string">'value'</span>: newValue, <span class="hljs-string">'type'</span>: <span class="hljs-title class_">DataType</span>.<span class="hljs-property">enum8</span>};
               <span class="hljs-keyword">await</span> entity.<span class="hljs-title function_">write</span>(<span class="hljs-string">'genOnOffSwitchCfg'</span>, payload, manufacturerOptions.<span class="hljs-property">jennic</span>);
               <span class="hljs-keyword">break</span>;

           <span class="hljs-keyword">case</span> <span class="hljs-string">'max_pause'</span>:
               payload = {<span class="hljs-number">65282</span>: {<span class="hljs-string">'value'</span>: value, <span class="hljs-string">'type'</span>: <span class="hljs-title class_">DataType</span>.<span class="hljs-property">uint16</span>};
               <span class="hljs-keyword">await</span> entity.<span class="hljs-title function_">write</span>(<span class="hljs-string">'genOnOffSwitchCfg'</span>, payload, manufacturerOptions.<span class="hljs-property">jennic</span>);
               <span class="hljs-keyword">break</span>;

           <span class="hljs-keyword">case</span> <span class="hljs-string">'min_long_press'</span>:
               payload = {<span class="hljs-number">65283</span>: {<span class="hljs-string">'value'</span>: value, <span class="hljs-string">'type'</span>: <span class="hljs-title class_">DataType</span>.<span class="hljs-property">uint16</span>};
               <span class="hljs-keyword">await</span> entity.<span class="hljs-title function_">write</span>(<span class="hljs-string">'genOnOffSwitchCfg'</span>, payload, manufacturerOptions.<span class="hljs-property">jennic</span>);
               <span class="hljs-keyword">break</span>;

           <span class="hljs-attr">default</span>:
               <span class="hljs-keyword">break</span>;
       }

       result = {<span class="hljs-attr">state</span>: {[key]: value}
       <span class="hljs-keyword">return</span> result;
   },
</code></pre>
<p>toZigbee_OnOffSwitchCfg::convertSet() 함수는 텍스트 속성 이름과 설정할 속성 값들을 받습니다. 이 함수의 목표는 이를 네트워크로 전송할 수 있는 구조로 변환하는 것입니다. 표준 속성 (예: switch_actions)의 경우, 단순히 속성 키-값 쌍이 될 것이지만, 값은 숫자로 변환됩니다. herdsman 변환기 코드는 표준 속성 및 이들의 형식, 네트워크로 전달하는 방법 등을 알고 있습니다. 비표준 속성 (예: relay_mode)의 경우, 세 개의 값으로 변환해야 합니다:</p>
<ul>
<li>숫자 속성 식별자 (10진 형식으로 설정해야 함 — 예: 65280)</li>
<li>속성 유형 (유형 식별자)</li>
<li>값 (열거형의 경우 값 색인)</li>
</ul>
<p>이러한 값들은 낮은 수준의 Zigbee 메시지로 묶여 네트워크를 통해 전송됩니다. 엔티티 객체는 읽기 및 쓰기 명령이 실행되는 엔드포인트입니다. 비표준 속성을 위해 제조사별 코드를 지정하는 것이 필수적입니다 (manufacturerOptions.jennic 사용).</p>
<p>함수는 속성의 새로운 상태를 반환해야 합니다. 그 결과는 꼼꼼한 종류의 구조로 구성되어야 하며, 그렇지 않으면 웹 양식의 버튼 값이 변경되지 않습니다.</p>
<p>새로운 속성 값을 보내는 스니퍼는 다음과 같이 보일 것입니다.</p>
<p>디바이스 측에서는 ZCL 구현이 들어오는 요청을 파싱하고, 자동으로 새 값을 해당 필드에 설정합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-attr">ZPS_EVENT_APS_DATA_INDICATION</span>: <span class="hljs-title class_">SrcEP</span>=<span class="hljs-number">1</span> <span class="hljs-title class_">DstEP</span>=<span class="hljs-number">2</span> <span class="hljs-title class_">SrcAddr</span>=<span class="hljs-number">0000</span> <span class="hljs-title class_">Cluster</span>=<span class="hljs-number">0007</span> () <span class="hljs-title class_">Status</span>=<span class="hljs-number">0</span>
<span class="hljs-variable constant_">ZCL</span> <span class="hljs-title class_">Write</span> <span class="hljs-title class_">Attribute</span>: <span class="hljs-title class_">Clustter</span> <span class="hljs-number">0007</span> <span class="hljs-title class_">Attrib</span> ff00
<span class="hljs-variable constant_">ZCL</span> <span class="hljs-title class_">Endpoint</span> <span class="hljs-title class_">Callback</span>: <span class="hljs-title class_">Write</span> attributes completed
<span class="hljs-attr">ZPS_EVENT_APS_DATA_CONFIRM</span>: <span class="hljs-title class_">SrcEP</span>=<span class="hljs-number">2</span> <span class="hljs-title class_">DstEP</span>=<span class="hljs-number">1</span> <span class="hljs-title class_">DstAddr</span>=<span class="hljs-number">0000</span> <span class="hljs-title class_">Status</span>=<span class="hljs-number">0</span>
<span class="hljs-attr">ZPS_EVENT_APS_DATA_ACK</span>: <span class="hljs-title class_">SrcEP</span>=<span class="hljs-number">1</span> <span class="hljs-title class_">DrcEP</span>=<span class="hljs-number">2</span> <span class="hljs-title class_">DstAddr</span>=<span class="hljs-number">0000</span> <span class="hljs-title class_">Profile</span>=<span class="hljs-number">0104</span> <span class="hljs-title class_">Cluster</span>=<span class="hljs-number">0007</span> ()
</code></pre>
<p>속성을 읽는 것이 더 어려워 보입니다. 기본적으로 zigbee2mqtt UI는 현재 속성 값을 표시하지 않습니다. 속성 중 하나 옆의 "업데이트" 버튼을 클릭하면 toZigbeeConverter::convertGet() 함수가 호출됩니다.</p>
<p>처음에는 이름인 toZigbee::converterGet()에 매우 혼동을 겪었어요. 왜 fromzigbee가 아니지? 네트워크에서 데이터를 받는 거 아니면서도 말이죠? 그런데 코드를 더 정확하게 살펴보니까 더 명확해졌어요: toZigbee 구성 요소는 (읽기 요청이더라도) 네트워크로 요청을 준비하는 역할을 담당하고 있어요. 장치는 나중에 읽기 속성 응답 메시지를 포함한 읽기 값이 들어있는 응답을 보내줄 거예요. 그럼 fromZigbee 구성 요소는 네트워크로부터 도착한 내용을 구문 분석하게 됩니다 (하지만 이에 대해서는 나중에 더 자세히 이야기할게요).</p>
<p>대부분의 변환기 구현은 한 번에 모든 속성을 가져오기 위해 일괄 요청을 사용해요 - Zigbee 사양이 이를 허용하기 때문이죠. 안타깝게도, 표준 속성('switchActions')과 제조사별 속성을 사용하고 있기 때문에 이들을 한 번에 가져오기가 불가능해요. 따라서 제 구현은 한 번에 하나의 속성을 가져올 거에요. 물론, 표준이 아닌 속성을 읽는 것은 제조사 코드가 필요할 거에요.</p>
<p>스니퍼에서 읽기 요청이 어떻게 보이는지 살펴보세요.</p>
<p>이것이 테이블 태그이며, 이것이 답변입니다.</p>
<p><img src="/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_4.png" alt="이미지"></p>
<p>단말기에서 패킷을 수신한 코디네이터는 fromZigbee 구성 요소가 요청의 구문 분석을 수행합니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getKey</span> = (<span class="hljs-params">object, value</span>) => {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> object) {
        <span class="hljs-keyword">if</span> (object[key] == value) <span class="hljs-keyword">return</span> key;
    }
};

<span class="hljs-keyword">const</span> fromZigbee_OnOffSwitchCfg = {
   <span class="hljs-attr">cluster</span>: <span class="hljs-string">'genOnOffSwitchCfg'</span>,
   <span class="hljs-attr">type</span>: [<span class="hljs-string">'attributeReport'</span>, <span class="hljs-string">'readResponse'</span>],

   <span class="hljs-attr">convert</span>: <span class="hljs-function">(<span class="hljs-params">model, msg, publish, options, meta</span>) =></span> {

       <span class="hljs-keyword">const</span> ep_name = <span class="hljs-title function_">getKey</span>(model.<span class="hljs-title function_">endpoint</span>(msg.<span class="hljs-property">device</span>), msg.<span class="hljs-property">endpoint</span>.<span class="hljs-property">ID</span>);
       <span class="hljs-keyword">const</span> result = {};

       <span class="hljs-comment">// switch type</span>
       <span class="hljs-keyword">if</span>(msg.<span class="hljs-property">data</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'65280'</span>)) {
           result[<span class="hljs-string">`switch_mode_<span class="hljs-subst">${ep_name}</span>`</span>] = switchModeValues[msg.<span class="hljs-property">data</span>[<span class="hljs-string">'65280'</span>]];
       }

       <span class="hljs-comment">// switch action</span>
       <span class="hljs-keyword">if</span>(msg.<span class="hljs-property">data</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'switchActions'</span>)) { <span class="hljs-comment">// use standard 'switchActions' attribute identifier</span>
           result[<span class="hljs-string">`switch_actions_<span class="hljs-subst">${ep_name}</span>`</span>] = switchActionValues[msg.<span class="hljs-property">data</span>[<span class="hljs-string">'switchActions'</span>]];
       }

       <span class="hljs-comment">// relay mode</span>
       <span class="hljs-keyword">if</span>(msg.<span class="hljs-property">data</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'65281'</span>)) {
           result[<span class="hljs-string">`relay_mode_<span class="hljs-subst">${ep_name}</span>`</span>] = relayModeValues[msg.<span class="hljs-property">data</span>[<span class="hljs-string">'65281'</span>]];
       }


       <span class="hljs-comment">// Maximum pause between button clicks in a multiclick</span>
       <span class="hljs-keyword">if</span>(msg.<span class="hljs-property">data</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'65282'</span>)) {
           result[<span class="hljs-string">`max_pause_<span class="hljs-subst">${ep_name}</span>`</span>] = msg.<span class="hljs-property">data</span>[<span class="hljs-string">'65282'</span>];
       }

       <span class="hljs-comment">// Minimal duration for the long press</span>
       <span class="hljs-keyword">if</span>(msg.<span class="hljs-property">data</span>.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">'65283'</span>)) {
           result[<span class="hljs-string">`min_long_press_<span class="hljs-subst">${ep_name}</span>`</span>] = msg.<span class="hljs-property">data</span>[<span class="hljs-string">'65283'</span>];
       }

       <span class="hljs-keyword">return</span> result;
   },
}
</code></pre>
<p>이 함수는 해당 보고서에서 속성 값들을 파싱하고, 이를 Z2M 구조로 <code>attribute_name</code>_<code>endpoint_name</code> 레코드로 분해하려고 노력합니다.</p>
<p>거의 다 끝났어요. 마지막 구조 하나만 더 남았는데, 이것은 모든 것을 함께 모을 것입니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> device = {
    <span class="hljs-attr">zigbeeModel</span>: [<span class="hljs-string">'Hello Zigbee Switch'</span>],
    <span class="hljs-attr">model</span>: <span class="hljs-string">'Hello Zigbee Switch'</span>,
    <span class="hljs-attr">vendor</span>: <span class="hljs-string">'NXP'</span>,
    <span class="hljs-attr">description</span>: <span class="hljs-string">'Hello Zigbee Switch'</span>,
    <span class="hljs-attr">fromZigbee</span>: [fz.<span class="hljs-property">on_off</span>, fromZigbee_OnOffSwitchCfg],
    <span class="hljs-attr">toZigbee</span>: [tz.<span class="hljs-property">on_off</span>, toZigbee_OnOffSwitchCfg],
    <span class="hljs-attr">exposes</span>: <span class="hljs-title function_">genEndpoints</span>(<span class="hljs-number">2</span>),
    <span class="hljs-attr">configure</span>: <span class="hljs-keyword">async</span> (device, coordinatorEndpoint, logger) => {
        device.<span class="hljs-property">endpoints</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">async</span> (ep) => {
            <span class="hljs-keyword">await</span> ep.<span class="hljs-title function_">read</span>(<span class="hljs-string">'genOnOff'</span>, [<span class="hljs-string">'onOff'</span>]);
            <span class="hljs-keyword">await</span> ep.<span class="hljs-title function_">read</span>(<span class="hljs-string">'genOnOffSwitchCfg'</span>, [<span class="hljs-string">'switchActions'</span>]);
            <span class="hljs-keyword">await</span> ep.<span class="hljs-title function_">read</span>(<span class="hljs-string">'genOnOffSwitchCfg'</span>, [<span class="hljs-number">65280</span>, <span class="hljs-number">65281</span>, <span class="hljs-number">65282</span>, <span class="hljs-number">65283</span>], manufacturerOptions.<span class="hljs-property">jennic</span>);
        });
    },
    <span class="hljs-attr">endpoint</span>: <span class="hljs-function">(<span class="hljs-params">device</span>) =></span> {
        <span class="hljs-keyword">return</span> {<span class="hljs-attr">button_1</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">button_2</span>: <span class="hljs-number">3</span>};
    },
};

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = device;
</code></pre>
<p>이 코드는 새로운 장치를 등록하고 해당 장치에 대한 컨버터를 등록합니다. On/Off 기능에는 표준 fz/tz.on_off 컨버터가 사용되며, 우리의 함수인 to/fromZigbee_OnOffSwitchCfg가 스위치 구성을 처리합니다.</p>
<p>이 장치는 이미 2개의 스위치 엔드포인트를 지원하므로, 컨버터는 2개의 설정 세트를 등록합니다. 또한, 기본 채널이 endpoint #1에 있고, 스위치 엔드포인트는 endpoint #2부터 시작한다는 점을 기억하십시오. 모든 것이 올바르게 보여지고 작동되도록 endpoint-to-buttons 재번호 매핑을 추가해야 했습니다.</p>
<p>또한 configure() 함수를 강조하고 싶습니다. Z2M을 시작할 때는 스위치의 현재 상태나 설정 값이 알려져 있지 않습니다 — 설정 섹션의 모든 필드는 비어 있을 것입니다. 제가 연구한 대부분의 컨버터는 속성 보고를 설정하며, 장치는 예를 들어 1분마다 상태와 속성을 보고합니다. 따라서 일부 장치는 시작 시 값이 즉시 표시되지 않지만 나중에 값이 나타납니다. 이는 온도 센서와 같은 장치에 적합한 옵션입니다. 저의 컨버터 버전에서는 시작 시에 실제 값을 간단히 읽기로 결정했습니다.</p>
<p>마지막 단계는 zigbee2mqtt에서 컨버터를 등록하는 것입니다. configuration.yaml에 다음 라인을 추가하고 Z2M을 다시 시작하면 됩니다.</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">external_converters:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-string">myswitch.js</span>
</code></pre>
<p>장치가 가입할 때, zigbee2mqtt는 장치 이름을 요청하고 해당하는 컨버터를 사용할 것입니다.</p>
<h1>다중 액션 지원</h1>
<p>기억하시다시피, 우리는 장치에 다중 입력 클러스터를 추가하여 단일/이중/삼중/긴 눌림을 보고할 수 있도록 했습니다. 이러한 이벤트들은 속성 변경 보고서로 제공됩니다. 하지만 이제는 Z2M이 이러한 보고서를 이해하고 적절한 액션을 생성할 수 있도록 가르쳐 주어야 합니다. 이를 위해 fromZigbee 컨버터를 또 추가해보죠. 이 클러스터에 뭔가를 장치에 쓰지 않을 것이므로 toZigbee 컨버터를 추가할 필요는 없습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> fromZigbee_MultistateInput = {
   <span class="hljs-attr">cluster</span>: <span class="hljs-string">'genMultistateInput'</span>,
   <span class="hljs-attr">type</span>: [<span class="hljs-string">'attributeReport'</span>, <span class="hljs-string">'readResponse'</span>],

   <span class="hljs-attr">convert</span>: <span class="hljs-function">(<span class="hljs-params">model, msg, publish, options, meta</span>) =></span> {
       <span class="hljs-keyword">const</span> actionLookup = {<span class="hljs-number">0</span>: <span class="hljs-string">'release'</span>, <span class="hljs-number">1</span>: <span class="hljs-string">'single'</span>, <span class="hljs-number">2</span>: <span class="hljs-string">'double'</span>, <span class="hljs-number">3</span>: <span class="hljs-string">'tripple'</span>, <span class="hljs-number">255</span>: <span class="hljs-string">'hold'</span>};
       <span class="hljs-keyword">const</span> value = msg.<span class="hljs-property">data</span>[<span class="hljs-string">'presentValue'</span>];
       <span class="hljs-keyword">const</span> action = actionLookup[value];

       <span class="hljs-keyword">const</span> result = {<span class="hljs-attr">action</span>: utils.<span class="hljs-title function_">postfixWithEndpointName</span>(action, msg, model)};
       <span class="hljs-keyword">return</span> result;
   },
}
</code></pre>
<p>이 컨버터는 ptvo_multistate_action 컨버터에서 영감을 받았습니다. presentValue 클러스터 속성을 간단히 추출하여 해당 작업 텍스트로 변환합니다.</p>
<p>이 컨버터는 장치가 생성할 수 있는 작업도 광고할 수 있어서 Home Assistant와 같은 다른 시스템이 준비할 수 있습니다.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">genSwitchActions</span>(<span class="hljs-params">endpoinsCount</span>) {
   <span class="hljs-keyword">let</span> actions = [];

   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &#x3C;= endpoinsCount; i++) {
       <span class="hljs-keyword">const</span> epName = <span class="hljs-string">`button_<span class="hljs-subst">${i}</span>`</span>;
       actions.<span class="hljs-title function_">push</span>(... [<span class="hljs-string">'single'</span>, <span class="hljs-string">'double'</span>, <span class="hljs-string">'triple'</span>, <span class="hljs-string">'hold'</span>, <span class="hljs-string">'release'</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">action</span> =></span> action + <span class="hljs-string">"_"</span> + epName));
   }

   <span class="hljs-keyword">return</span> actions;
}

...

<span class="hljs-keyword">const</span> device = {
...
   <span class="hljs-attr">fromZigbee</span>: [fz.<span class="hljs-property">on_off</span>, fromZigbee_OnOffSwitchCfg, fromZigbee_MultistateInput],
...
   <span class="hljs-attr">exposes</span>: [
       e.<span class="hljs-title function_">action</span>(<span class="hljs-title function_">genSwitchActions</span>(<span class="hljs-number">2</span>)),
       ...<span class="hljs-title function_">genSwitchEndpoints</span>(<span class="hljs-number">2</span>)
   ],
...
</code></pre>
<p>제가 원했던 것은 각 엔드포인트에서의 작업이 나머지 엔드포인트 정보와 함께 선언되기를 했지만(zigbee2mqtt 아키텍처는 이를 허용하지 않습니다), 이를 위한 genSwitchEndpoint() 함수에서 정의할 수 없습니다. 모든 작업은 exposes 필드에서 e.action() 함수를 사용하여 한 번만 정의해야 합니다(여기에 설명이 나와 있습니다).</p>
<p>자, 이제 버튼을 눌러서 zigbee2mqtt 쪽에서 어떻게 작동하는지 확인해 봅시다.</p>
<pre><code class="hljs language-js"><span class="hljs-title class_">Zigbee2MQTT</span>:debug <span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">19</span> <span class="hljs-number">22</span>:<span class="hljs-number">31</span>:<span class="hljs-number">53</span>: <span class="hljs-title class_">Received</span> <span class="hljs-title class_">Zigbee</span> message <span class="hljs-keyword">from</span> <span class="hljs-string">'TestSwitch'</span>, type <span class="hljs-string">'attributeReport'</span>, cluster <span class="hljs-string">'genMultistateInput'</span>, data <span class="hljs-string">'{"presentValue":255}'</span> <span class="hljs-keyword">from</span> endpoint <span class="hljs-number">3</span> <span class="hljs-keyword">with</span> groupID <span class="hljs-number">0</span>
<span class="hljs-title class_">Zigbee2MQTT</span>:info  <span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">19</span> <span class="hljs-number">22</span>:<span class="hljs-number">31</span>:<span class="hljs-number">53</span>: <span class="hljs-variable constant_">MQTT</span> <span class="hljs-attr">publish</span>: topic <span class="hljs-string">'zigbee2mqtt2/TestSwitch'</span>, payload <span class="hljs-string">'{"action":"hold_button_2","last_seen":1634671913843,"linkquality":70,"max_pause_button_1":null,"max_pause_button_2":null,"min_long_press_button_1":null,"min_long_press_button_2":null,"relay_mode_button_1":"front","relay_mode_button_2":"unlinked","state_button_1":"OFF","state_button_2":"OFF","switch_actions_button_1":null,"switch_actions_button_2":null,"switch_type_button_1":null,"switch_type_button_2":"momentary"}'</span>
<span class="hljs-title class_">Zigbee2MQTT</span>:info  <span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">19</span> <span class="hljs-number">22</span>:<span class="hljs-number">31</span>:<span class="hljs-number">53</span>: <span class="hljs-variable constant_">MQTT</span> <span class="hljs-attr">publish</span>: topic <span class="hljs-string">'zigbee2mqtt2/TestSwitch'</span>, payload <span class="hljs-string">'{"action":"","last_seen":1634671913843,"linkquality":70,"max_pause_button_1":null,"max_pause_button_2":null,"min_long_press_button_1":null,"min_long_press_button_2":null,"relay_mode_button_1":"front","relay_mode_button_2":"unlinked","state_button_1":"OFF","state_button_2":"OFF","switch_actions_button_1":null,"switch_actions_button_2":null,"switch_type_button_1":null,"switch_type_button_2":"momentary"}'</span>
<span class="hljs-title class_">Zigbee2MQTT</span>:info  <span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">19</span> <span class="hljs-number">22</span>:<span class="hljs-number">31</span>:<span class="hljs-number">53</span>: <span class="hljs-variable constant_">MQTT</span> <span class="hljs-attr">publish</span>: topic <span class="hljs-string">'zigbee2mqtt2/TestSwitch/action'</span>, payload <span class="hljs-string">'hold_button_2'</span>
</code></pre>
<p>우리는 genMultistateInput 클러스터 메시지가 정상적으로 처리되고 MQTT 메시지로 전환된 것을 볼 수 있습니다. 마지막 메시지가 간결하고 중요한데, 두 번째 버튼이 눌린 이벤트가 있었습니다. MQTT 이벤트를 구독할 수 있는 어떤 시스템이든 이러한 메시지를 쉽게 처리할 수 있습니다.</p>
<p>다른 두 개의 메시지가 조금 혼란스러울 수 있어요 — "action":"hold_button_2"를 보내고, 곧바로 "action":""를 보내죠. 하지만 이는 Zigbee2mqtt FAQ에 설명된 정상적인 동작인 걸 알게 된 것이죠.</p>
<p>팁:</p>
<p>이전에도 언급했듯이 Multistate 입력 클러스터는 일반적인 방식과는 조금 다르게 사용되어요 — 값 자체보다는 값 변경 이벤트에 관심이 있는 것이죠. 주요 속성이 다양한 값들을 취할 수 있는 편리한 클러스터일 뿐입니다.</p>
<p>하지만 Multistate 입력이 다양한 버튼 이벤트를 신호로 지시하는 유일한 방법은 아닙니다. 그래서 샤오미 WXKG01LM 스위치는 OnOff 클러스터의 비표준 확장을 구현합니다. 상태 속성의 표준 0 및 1 값 이외에도 클릭 수를 나타내는 다른 값을 사용할 수 있어요. 다른 디바이스들도 On/Off 클러스터의 비표준 확장을 구현하고 다양한 이벤트를 나타내는 추가 속성을 추가합니다.</p>
<p>일부 디바이스는 펌웨어 측면에서 다중 클릭 로직을 전혀 구현하지 않을 수 있습니다. 반면, 절대 표준적인 OnOff 클러스터가 사용되며, 다중 클릭은 z2m 컨버터에서 타이머를 사용하여 계산됩니다.</p>
<p>마지막으로 제조업체는 매우 사용자 정의된 클러스터를 개발하여 선호하는 형식으로 정보를 전송할 수도 있습니다.</p>
<h1>Home Assistant 자동화</h1>
<p>Home Assistant에 노출된 스위치는 거의 자동으로 통합되지만 몇 가지 문제점이 있습니다. 먼저, 기본적으로 대부분의 설정이 비활성화되어 Home Assistant에 숨겨져 있습니다. 각 설정을 수동으로 활성화한 후 Home Assistant를 다시 시작해야 합니다. 매개변수를 활성화한 후에는 기기 페이지가 다음과 같이 보입니다.</p>
<p>둘째, 숫자 매개변수는 편집할 수 없습니다. 안타깝게도 이 문제를 전혀 해결할 방법을 찾지 못했습니다. 이를 해결하기 위한 임시방편으로, 이러한 매개변수는 zigbee2mqtt 대시보드에서 편집하거나 해당 mqtt 메시지를 보내는 방법으로 편집할 수 있습니다.</p>
<p>작업에 대해 말하자면, 여기서는 조금 원할한 상황이 아닙니다. 변환기가 가능한 작업 목록을 광고하지만, Home Assistant는이 목록을 무시합니다. 자동화를 생성하려고 하면 HA가 더블/트리플/롱 프레스를 자동화 트리거로 제안하지 않습니다... 해당 작업이 최소한 한 번 발생할 때까지입니다. 그런 다음 해당 작업이 목록에 나타나며 자동화 마법사에서 사용할 수 있게 됩니다.</p>
<p>자, 이제 유용한 일을 해보고 흥미로운 자동화를 작성해 봅시다. 현재 나는 내 Xiaomi 스위치로 커튼을 부분적으로 열거나 닫을 수 있는 기능이 정말 그립습니다. 보통 매우 어렵게 깨어납니다. 커튼이 한꺼번에 완전히 열리면 눈에 매우 충격을 줍니다. 커튼의 정도를 동일한 스위치로 제어할 수 있는 기능이 있으면 좋겠습니다.</p>
<p>단 몇 분 만에, 홈 어시스턴트 시각적 편집기에서 몇 가지 자동화 규칙을 만들었어요.</p>
<p>첫 번째 자동화는 버튼 더블 클릭으로 커튼을 완전히 열거나 닫습니다.</p>
<pre><code class="hljs language-js">- <span class="hljs-attr">id</span>: <span class="hljs-string">'1635018171508'</span>
  <span class="hljs-attr">alias</span>: <span class="hljs-title class_">TestSwitch</span> <span class="hljs-title class_">Open</span>/<span class="hljs-title class_">Close</span> curtain
  <span class="hljs-attr">description</span>: <span class="hljs-string">'TestSwitch Open/Close curtain'</span>
  <span class="hljs-attr">trigger</span>:
  - <span class="hljs-attr">platform</span>: mqtt
    <span class="hljs-attr">topic</span>: zigbee2mqtt2/<span class="hljs-title class_">TestSwitch</span>/action
    <span class="hljs-attr">payload</span>: double_button_1
  <span class="hljs-attr">condition</span>: []
  <span class="hljs-attr">action</span>:
  - <span class="hljs-attr">service</span>: cover.<span class="hljs-property">toggle</span>
    <span class="hljs-attr">target</span>:
      <span class="hljs-attr">entity_id</span>: cover.<span class="hljs-property">living_room_curtain</span>
  <span class="hljs-attr">mode</span>: single
</code></pre>
<p>두 번째 자동화는 버튼을 세 번 클릭하면 커튼을 50%로 엽니다.</p>
<pre><code class="hljs language-yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">'1635017708545'</span>
  <span class="hljs-attr">alias:</span> <span class="hljs-string">TestSwitch</span> <span class="hljs-string">Half-open</span> <span class="hljs-string">curtains</span>
  <span class="hljs-attr">description:</span> <span class="hljs-string">'TestSwitch Half-open curtains'</span>
  <span class="hljs-attr">trigger:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">mqtt</span>
    <span class="hljs-attr">topic:</span> <span class="hljs-string">zigbee2mqtt2/TestSwitch/action</span>
    <span class="hljs-attr">payload:</span> <span class="hljs-string">triple_button_1</span>
  <span class="hljs-attr">condition:</span> []
  <span class="hljs-attr">action:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">service:</span> <span class="hljs-string">cover.set_cover_position</span>
    <span class="hljs-attr">target:</span>
      <span class="hljs-attr">entity_id:</span> <span class="hljs-string">cover.living_room_curtain</span>
    <span class="hljs-attr">data:</span>
      <span class="hljs-attr">position:</span> <span class="hljs-number">50</span>
  <span class="hljs-attr">mode:</span> <span class="hljs-string">single</span>
</code></pre>
<p>다음 두 가지 자동화는 길게 누르는 것을 사용합니다 — 버튼을 누르면 커튼이 움직이기 시작하고, 버튼을 놓으면 멈춥니다.</p>
<pre><code class="hljs language-yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">'1635017908150'</span>
  <span class="hljs-attr">alias:</span> <span class="hljs-string">TestSwitch</span> <span class="hljs-string">toggle</span> <span class="hljs-string">curtain</span> <span class="hljs-string">on</span> <span class="hljs-string">button</span> <span class="hljs-string">press</span>
  <span class="hljs-attr">description:</span> <span class="hljs-string">'TestSwitch toggle curtain on button press'</span>
  <span class="hljs-attr">trigger:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">mqtt</span>
    <span class="hljs-attr">topic:</span> <span class="hljs-string">zigbee2mqtt2/TestSwitch/action</span>
    <span class="hljs-attr">payload:</span> <span class="hljs-string">hold_button_1</span>
  <span class="hljs-attr">condition:</span> []
  <span class="hljs-attr">action:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">service:</span> <span class="hljs-string">cover.toggle</span>
    <span class="hljs-attr">target:</span>
      <span class="hljs-attr">entity_id:</span> <span class="hljs-string">cover.living_room_curtain</span>
  <span class="hljs-attr">mode:</span> <span class="hljs-string">single</span>

<span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">'1635017981037'</span>
  <span class="hljs-attr">alias:</span> <span class="hljs-string">TestSwitch</span> <span class="hljs-string">stop</span> <span class="hljs-string">curtain</span>
  <span class="hljs-attr">description:</span> <span class="hljs-string">'TestSwitch stop curtain'</span>
  <span class="hljs-attr">trigger:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">platform:</span> <span class="hljs-string">mqtt</span>
    <span class="hljs-attr">topic:</span> <span class="hljs-string">zigbee2mqtt2/TestSwitch/action</span>
    <span class="hljs-attr">payload:</span> <span class="hljs-string">release_button_1</span>
  <span class="hljs-attr">condition:</span> []
  <span class="hljs-attr">action:</span>
  <span class="hljs-bullet">-</span> <span class="hljs-attr">service:</span> <span class="hljs-string">cover.stop_cover</span>
    <span class="hljs-attr">target:</span>
      <span class="hljs-attr">entity_id:</span> <span class="hljs-string">cover.living_room_curtain</span>
  <span class="hljs-attr">mode:</span> <span class="hljs-string">single</span>
</code></pre>
<p>위와 같이 간단한 자동화를 사용하면 단일 버튼으로 커튼을 제어할 수 있습니다 — 열기, 닫기, 특정 개도로 설정하는 것도 가능합니다. 게다가, 버튼의 일반적인 단추도 주 조명을 전환할 수 있습니다.</p>
<h1>요약</h1>
<p>축하해요, 우리는 방금 Xiaomi Aqara 스위치를 새롭게 만들었어요! 음, 비슷한 스마트 스위치예요. 아마도 우리 장치는 좀 더 다양한 설정을 제공할지도 모르지만, 전반적으로 모든 것이 거의 같아요. 그래도 뭔가 다른 목표가 있었죠 — 사용자 정의 클러스터, genOnOffSettingCfg 및 genMultistateInput 클러스터를 생성하고 zigbee2mqtt를 위한 외부 컨버터를 작성해보는 것이었어요.</p>
<p>자신만의 클러스터를 만들거나 기존 클러스터를 확장하는 데 별로 어려운 점이 없다는 것이 밝혀졌어요. zigbee2mqtt를 다루는 데에는 조금 골치가 아팠지만, 그건 대부분 명쾌한 문서의 부재 때문이었어요. 이제 이 빈칸은 채워졌어요 :)</p>
<h1>링크</h1>
<ul>
<li>JN-UG-3113 ZigBee 3.0 스택 사용자 가이드</li>
<li>JN-UG-3114 ZigBee 3.0 디바이스 사용자 가이드</li>
<li>JN-UG-3076 ZigBee 홈 오토메이션 사용자 가이드</li>
<li>ZigBee 클래스 라이브러리 사양</li>
<li>Zigbee 트래픽을 감지하는 방법</li>
<li>zigbee2mqtt에 새로운 장치 추가</li>
<li>깃허브 프로젝트</li>
</ul>
<h1>지원</h1>
<p>이 프로젝트는 품앗이 프로젝트로 무료로 개발 중입니다. 동시에 작은 기부로 프로젝트를 지원하는 것을 고려해볼 수 있습니다.</p>
<p><img src="/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_6.png" alt="HelloZigbeeWorld"></p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"안녕하세요, 지그비 세계, 18부 - 사용자 정의 zigbee2mqtt 외부 변환기","description":"","date":"2024-06-19 17:08","slug":"2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter","content":"\n\n이전 두 편의 글에서는 스마트 스위치에 여러 작업을 지원하는 기능을 구현하여, 멀티스테이트 입력 클러스터를 통해 단일/더블/트리플/롱 프레스를 처리하고 보고할 수 있게 되었습니다. 또한 On/Off 스위치 설정 클러스터의 사용자 정의 확장을 통해 장치의 설정을 제어하는 기능도 구현했습니다. 이러한 추가 기능으로 사용자들은 Zigbee 시설을 이용하여 런타임에서 장치를 구성할 수 있게 됩니다.\n\n그러나 한 가지 문제가 있습니다: 우리는 장치 측면에서 이를 구현했지만, zigbee2mqtt와 같은 다른 시스템들은 이러한 추가 기능과 어떻게 작동해야 하는지 알지 못합니다. 이 글에서는 우리의 장치를 지원하기 위해 zigbee2mqtt용의 외부 컨버터 — 특별한 플러그인을 작성하는 방법을 상세히 설명하고 있습니다.\n\n일반적으로, 나의 코드는 이전 글에서 만든 코드를 기반으로 합니다. 개발 보드로는 NXP JN5169 마이크로컨트롤러를 기반으로 한 EBYTE E75-2G4M10S 모듈을 사용할 것입니다. 이 글은 Hello Zigbee 시리즈에 훌륭한 추가 내용이 되며, 처음부터 Zigbee 장치 펌웨어를 구축하는 방법을 설명하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# Zigbee2mqtt 외부 컨버터\n\n안타깝게도 외부 컨버터에 대한 문서화가 매우 미흡하며, 정확히 함수가 무엇을 해야 하는지에 대한 좋은 설명을 찾지 못했습니다. 조금 모호한 예제 몇 개가 있지만, 이에 대해 많은 의문이 듭니다.\n\n우리의 사용자 정의 On/Off Switch Configuration Cluster를 지원하기로 시작합시다. 저는 직접 `poke` 메서드를 사용하여 내 컨버터를 작성해야 했고, 그들이 어떻게 동작해야 하는지 파악하기 위해 수십 개의 기존 컨버터를 살펴보았습니다. 제가 제작 중일 때 컨버터에 대해 공부한 내용은 다음과 같습니다.\n\n모든 컨버터는 `imports`로 시작합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst fz = require('zigbee-herdsman-converters/converters/fromZigbee');\nconst tz = require('zigbee-herdsman-converters/converters/toZigbee');\nconst exposes = require('zigbee-herdsman-converters/lib/exposes');\nconst reporting = require('zigbee-herdsman-converters/lib/reporting');\nconst e = exposes.presets;\nconst ea = exposes.access;\n```\n\n우리가 맞춤 필드를 여러 개 추가했기 때문에, 그들과 관련된 유형 및 데이터 구조를 설명해야 합니다. Herdsman converters 프로젝트에서 정의된 모든 가능한 유형이 있습니다. 불행하게도, TypeScript에서 구조체를 JavaScript 코드로 가져오는 방법을 찾지 못해 필요한 유형의 값을 중복해서 작성해야 했습니다.\n\n```js\nconst DataType = {\n    uint16: 0x21,\n    enum8: 0x30,\n}\n```\n\n새로운 속성에 대한 열거형 값들을 정의해봅시다. 값들의 순서는 펌웨어 코드에 설명된 것과 동일하며, 변환기 코드는 목록에서 위치 번호를 해당 값과 일치시키기만 하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst switchTypeValues = ['toggle', 'momentary', 'multifunction'];\nconst switchActionValues = ['onOff', 'offOn', 'toggle'];\nconst relayModeValues = ['unlinked', 'front', 'single', 'double', 'tripple', 'long'];\n```\n\n제조업체별 속성을 참조할 때에는 속성 식별자 뿐만 아니라 제조업체 코드도 명시해야 합니다. 그렇지 않으면 ZCL 펌웨어 코드에서 요청을 거부합니다.\n\n```js\nconst manufacturerOptions = {\n    jennic: {manufacturerCode: 0x1037}\n}\n```\n\n이제 z2m 웹 양식에 해당 필드를 등록해야 합니다. 이러한 필드는 디바이스의 Exposes 탭에 표시됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nfunction genSwitchEndpoint(epName) {\n   return [\n       e.switch().withEndpoint(epName),\n       exposes.enum('switch_mode', ea.ALL, switchModeValues).withEndpoint(epName),\n       exposes.enum('switch_actions', ea.ALL, switchActionValues).withEndpoint(epName),\n       exposes.enum('relay_mode', ea.ALL, relayModeValues).withEndpoint(epName),\n       exposes.numeric('max_pause', ea.ALL).withEndpoint(epName),\n       exposes.numeric('min_long_press', ea.ALL).withEndpoint(epName),\n   ]\n}\n\nfunction genSwitchEndpoints(endpoinsCount) {\n   let features = [];\n\n   for (let i = 1; i \u003c= endpoinsCount; i++) {\n       const epName = `button_${i}`;\n       features.push(...genSwitchEndpoint(epName));\n   }\n\n   return features;\n}\n```\n\n주어진 엔드포인트 수에 대해 첫 번째 함수는 스위치 위젯 (e.switch())과 구성 필드 시리즈를 생성합니다. 결과물은 다음과 같습니다.\n\n\u003cimg src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_1.png\" /\u003e\n\n2~3개 값으로 이루어진 열거형 필드는 버튼으로, 다른 필드(relay_mode)는 드롭다운 목록으로 변환되었습니다. 마지막 두 숫자 필드는 증가/감소 화살표가 있는 입력 필드입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이제 이에 생명을 불어넣고, 3개의 변환 함수를 작성해야 합니다. 이 3개의 함수는 toZigbee 및 fromZigbee라는 코드명으로 구성되어야 합니다. 정확히 무슨 의미인지는 아래에서 설명하겠습니다.\n\n양식을 변경할 때 zigbee2mqtt는 toZigbee 구조에서 convertSet() 함수를 호출합니다. key 필드는 또한 우리의 컨버터가 처리할 수있는 매개변수 목록을 지정합니다.\n\n```js\nconst toZigbee_OnOffSwitchCfg = {\n   key: ['switch_mode', 'switch_actions', 'relay_mode', 'max_pause', 'min_long_press'],\n\n   convertSet: async (entity, key, value, meta) =\u003e {\n       let payload = {};\n       let newValue = value;\n\n       switch(key) {\n           case 'switch_mode':\n               newValue = switchModeValues.indexOf(value);\n               payload = {65280: {'value': newValue, 'type': DataType.enum8};\n               await entity.write('genOnOffSwitchCfg', payload, manufacturerOptions.jennic);\n               break;\n\n           case 'switch_actions':\n               newValue = switchActionValues.indexOf(value);\n               payload = {switchActions: newValue};\n               await entity.write('genOnOffSwitchCfg', payload);\n               break;\n\n           case 'relay_mode':\n               newValue = relayModeValues.indexOf(value);\n               payload = {65281: {'value': newValue, 'type': DataType.enum8};\n               await entity.write('genOnOffSwitchCfg', payload, manufacturerOptions.jennic);\n               break;\n\n           case 'max_pause':\n               payload = {65282: {'value': value, 'type': DataType.uint16};\n               await entity.write('genOnOffSwitchCfg', payload, manufacturerOptions.jennic);\n               break;\n\n           case 'min_long_press':\n               payload = {65283: {'value': value, 'type': DataType.uint16};\n               await entity.write('genOnOffSwitchCfg', payload, manufacturerOptions.jennic);\n               break;\n\n           default:\n               break;\n       }\n\n       result = {state: {[key]: value}\n       return result;\n   },\n```\n\ntoZigbee_OnOffSwitchCfg::convertSet() 함수는 텍스트 속성 이름과 설정할 속성 값들을 받습니다. 이 함수의 목표는 이를 네트워크로 전송할 수 있는 구조로 변환하는 것입니다. 표준 속성 (예: switch_actions)의 경우, 단순히 속성 키-값 쌍이 될 것이지만, 값은 숫자로 변환됩니다. herdsman 변환기 코드는 표준 속성 및 이들의 형식, 네트워크로 전달하는 방법 등을 알고 있습니다. 비표준 속성 (예: relay_mode)의 경우, 세 개의 값으로 변환해야 합니다:\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- 숫자 속성 식별자 (10진 형식으로 설정해야 함 — 예: 65280)\n- 속성 유형 (유형 식별자)\n- 값 (열거형의 경우 값 색인)\n\n이러한 값들은 낮은 수준의 Zigbee 메시지로 묶여 네트워크를 통해 전송됩니다. 엔티티 객체는 읽기 및 쓰기 명령이 실행되는 엔드포인트입니다. 비표준 속성을 위해 제조사별 코드를 지정하는 것이 필수적입니다 (manufacturerOptions.jennic 사용).\n\n함수는 속성의 새로운 상태를 반환해야 합니다. 그 결과는 꼼꼼한 종류의 구조로 구성되어야 하며, 그렇지 않으면 웹 양식의 버튼 값이 변경되지 않습니다.\n\n새로운 속성 값을 보내는 스니퍼는 다음과 같이 보일 것입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_2.png\" /\u003e\n\n디바이스 측에서는 ZCL 구현이 들어오는 요청을 파싱하고, 자동으로 새 값을 해당 필드에 설정합니다.\n\n```js\nZPS_EVENT_APS_DATA_INDICATION: SrcEP=1 DstEP=2 SrcAddr=0000 Cluster=0007 () Status=0\nZCL Write Attribute: Clustter 0007 Attrib ff00\nZCL Endpoint Callback: Write attributes completed\nZPS_EVENT_APS_DATA_CONFIRM: SrcEP=2 DstEP=1 DstAddr=0000 Status=0\nZPS_EVENT_APS_DATA_ACK: SrcEP=1 DrcEP=2 DstAddr=0000 Profile=0104 Cluster=0007 ()\n```\n\n속성을 읽는 것이 더 어려워 보입니다. 기본적으로 zigbee2mqtt UI는 현재 속성 값을 표시하지 않습니다. 속성 중 하나 옆의 \"업데이트\" 버튼을 클릭하면 toZigbeeConverter::convertGet() 함수가 호출됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n처음에는 이름인 toZigbee::converterGet()에 매우 혼동을 겪었어요. 왜 fromzigbee가 아니지? 네트워크에서 데이터를 받는 거 아니면서도 말이죠? 그런데 코드를 더 정확하게 살펴보니까 더 명확해졌어요: toZigbee 구성 요소는 (읽기 요청이더라도) 네트워크로 요청을 준비하는 역할을 담당하고 있어요. 장치는 나중에 읽기 속성 응답 메시지를 포함한 읽기 값이 들어있는 응답을 보내줄 거예요. 그럼 fromZigbee 구성 요소는 네트워크로부터 도착한 내용을 구문 분석하게 됩니다 (하지만 이에 대해서는 나중에 더 자세히 이야기할게요).\n\n대부분의 변환기 구현은 한 번에 모든 속성을 가져오기 위해 일괄 요청을 사용해요 - Zigbee 사양이 이를 허용하기 때문이죠. 안타깝게도, 표준 속성('switchActions')과 제조사별 속성을 사용하고 있기 때문에 이들을 한 번에 가져오기가 불가능해요. 따라서 제 구현은 한 번에 하나의 속성을 가져올 거에요. 물론, 표준이 아닌 속성을 읽는 것은 제조사 코드가 필요할 거에요.\n\n스니퍼에서 읽기 요청이 어떻게 보이는지 살펴보세요.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이것이 테이블 태그이며, 이것이 답변입니다.\n\n\n![이미지](/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_4.png)\n\n\n단말기에서 패킷을 수신한 코디네이터는 fromZigbee 구성 요소가 요청의 구문 분석을 수행합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst getKey = (object, value) =\u003e {\n    for (const key in object) {\n        if (object[key] == value) return key;\n    }\n};\n\nconst fromZigbee_OnOffSwitchCfg = {\n   cluster: 'genOnOffSwitchCfg',\n   type: ['attributeReport', 'readResponse'],\n\n   convert: (model, msg, publish, options, meta) =\u003e {\n\n       const ep_name = getKey(model.endpoint(msg.device), msg.endpoint.ID);\n       const result = {};\n\n       // switch type\n       if(msg.data.hasOwnProperty('65280')) {\n           result[`switch_mode_${ep_name}`] = switchModeValues[msg.data['65280']];\n       }\n\n       // switch action\n       if(msg.data.hasOwnProperty('switchActions')) { // use standard 'switchActions' attribute identifier\n           result[`switch_actions_${ep_name}`] = switchActionValues[msg.data['switchActions']];\n       }\n\n       // relay mode\n       if(msg.data.hasOwnProperty('65281')) {\n           result[`relay_mode_${ep_name}`] = relayModeValues[msg.data['65281']];\n       }\n\n\n       // Maximum pause between button clicks in a multiclick\n       if(msg.data.hasOwnProperty('65282')) {\n           result[`max_pause_${ep_name}`] = msg.data['65282'];\n       }\n\n       // Minimal duration for the long press\n       if(msg.data.hasOwnProperty('65283')) {\n           result[`min_long_press_${ep_name}`] = msg.data['65283'];\n       }\n\n       return result;\n   },\n}\n```\n\n이 함수는 해당 보고서에서 속성 값들을 파싱하고, 이를 Z2M 구조로 `attribute_name`_`endpoint_name` 레코드로 분해하려고 노력합니다.\n\n거의 다 끝났어요. 마지막 구조 하나만 더 남았는데, 이것은 모든 것을 함께 모을 것입니다.\n\n```js\nconst device = {\n    zigbeeModel: ['Hello Zigbee Switch'],\n    model: 'Hello Zigbee Switch',\n    vendor: 'NXP',\n    description: 'Hello Zigbee Switch',\n    fromZigbee: [fz.on_off, fromZigbee_OnOffSwitchCfg],\n    toZigbee: [tz.on_off, toZigbee_OnOffSwitchCfg],\n    exposes: genEndpoints(2),\n    configure: async (device, coordinatorEndpoint, logger) =\u003e {\n        device.endpoints.forEach(async (ep) =\u003e {\n            await ep.read('genOnOff', ['onOff']);\n            await ep.read('genOnOffSwitchCfg', ['switchActions']);\n            await ep.read('genOnOffSwitchCfg', [65280, 65281, 65282, 65283], manufacturerOptions.jennic);\n        });\n    },\n    endpoint: (device) =\u003e {\n        return {button_1: 2, button_2: 3};\n    },\n};\n\nmodule.exports = device;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 코드는 새로운 장치를 등록하고 해당 장치에 대한 컨버터를 등록합니다. On/Off 기능에는 표준 fz/tz.on_off 컨버터가 사용되며, 우리의 함수인 to/fromZigbee_OnOffSwitchCfg가 스위치 구성을 처리합니다.\n\n이 장치는 이미 2개의 스위치 엔드포인트를 지원하므로, 컨버터는 2개의 설정 세트를 등록합니다. 또한, 기본 채널이 endpoint #1에 있고, 스위치 엔드포인트는 endpoint #2부터 시작한다는 점을 기억하십시오. 모든 것이 올바르게 보여지고 작동되도록 endpoint-to-buttons 재번호 매핑을 추가해야 했습니다.\n\n또한 configure() 함수를 강조하고 싶습니다. Z2M을 시작할 때는 스위치의 현재 상태나 설정 값이 알려져 있지 않습니다 — 설정 섹션의 모든 필드는 비어 있을 것입니다. 제가 연구한 대부분의 컨버터는 속성 보고를 설정하며, 장치는 예를 들어 1분마다 상태와 속성을 보고합니다. 따라서 일부 장치는 시작 시 값이 즉시 표시되지 않지만 나중에 값이 나타납니다. 이는 온도 센서와 같은 장치에 적합한 옵션입니다. 저의 컨버터 버전에서는 시작 시에 실제 값을 간단히 읽기로 결정했습니다.\n\n마지막 단계는 zigbee2mqtt에서 컨버터를 등록하는 것입니다. configuration.yaml에 다음 라인을 추가하고 Z2M을 다시 시작하면 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\nexternal_converters:\n  - myswitch.js\n```\n\n장치가 가입할 때, zigbee2mqtt는 장치 이름을 요청하고 해당하는 컨버터를 사용할 것입니다.\n\n# 다중 액션 지원\n\n기억하시다시피, 우리는 장치에 다중 입력 클러스터를 추가하여 단일/이중/삼중/긴 눌림을 보고할 수 있도록 했습니다. 이러한 이벤트들은 속성 변경 보고서로 제공됩니다. 하지만 이제는 Z2M이 이러한 보고서를 이해하고 적절한 액션을 생성할 수 있도록 가르쳐 주어야 합니다. 이를 위해 fromZigbee 컨버터를 또 추가해보죠. 이 클러스터에 뭔가를 장치에 쓰지 않을 것이므로 toZigbee 컨버터를 추가할 필요는 없습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nconst fromZigbee_MultistateInput = {\n   cluster: 'genMultistateInput',\n   type: ['attributeReport', 'readResponse'],\n\n   convert: (model, msg, publish, options, meta) =\u003e {\n       const actionLookup = {0: 'release', 1: 'single', 2: 'double', 3: 'tripple', 255: 'hold'};\n       const value = msg.data['presentValue'];\n       const action = actionLookup[value];\n\n       const result = {action: utils.postfixWithEndpointName(action, msg, model)};\n       return result;\n   },\n}\n```\n\n이 컨버터는 ptvo_multistate_action 컨버터에서 영감을 받았습니다. presentValue 클러스터 속성을 간단히 추출하여 해당 작업 텍스트로 변환합니다.\n\n이 컨버터는 장치가 생성할 수 있는 작업도 광고할 수 있어서 Home Assistant와 같은 다른 시스템이 준비할 수 있습니다.\n\n```js\nfunction genSwitchActions(endpoinsCount) {\n   let actions = [];\n\n   for (let i = 1; i \u003c= endpoinsCount; i++) {\n       const epName = `button_${i}`;\n       actions.push(... ['single', 'double', 'triple', 'hold', 'release'].map(action =\u003e action + \"_\" + epName));\n   }\n\n   return actions;\n}\n\n...\n\nconst device = {\n...\n   fromZigbee: [fz.on_off, fromZigbee_OnOffSwitchCfg, fromZigbee_MultistateInput],\n...\n   exposes: [\n       e.action(genSwitchActions(2)),\n       ...genSwitchEndpoints(2)\n   ],\n...\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n제가 원했던 것은 각 엔드포인트에서의 작업이 나머지 엔드포인트 정보와 함께 선언되기를 했지만(zigbee2mqtt 아키텍처는 이를 허용하지 않습니다), 이를 위한 genSwitchEndpoint() 함수에서 정의할 수 없습니다. 모든 작업은 exposes 필드에서 e.action() 함수를 사용하여 한 번만 정의해야 합니다(여기에 설명이 나와 있습니다).\n\n자, 이제 버튼을 눌러서 zigbee2mqtt 쪽에서 어떻게 작동하는지 확인해 봅시다.\n\n```js\nZigbee2MQTT:debug 2021-10-19 22:31:53: Received Zigbee message from 'TestSwitch', type 'attributeReport', cluster 'genMultistateInput', data '{\"presentValue\":255}' from endpoint 3 with groupID 0\nZigbee2MQTT:info  2021-10-19 22:31:53: MQTT publish: topic 'zigbee2mqtt2/TestSwitch', payload '{\"action\":\"hold_button_2\",\"last_seen\":1634671913843,\"linkquality\":70,\"max_pause_button_1\":null,\"max_pause_button_2\":null,\"min_long_press_button_1\":null,\"min_long_press_button_2\":null,\"relay_mode_button_1\":\"front\",\"relay_mode_button_2\":\"unlinked\",\"state_button_1\":\"OFF\",\"state_button_2\":\"OFF\",\"switch_actions_button_1\":null,\"switch_actions_button_2\":null,\"switch_type_button_1\":null,\"switch_type_button_2\":\"momentary\"}'\nZigbee2MQTT:info  2021-10-19 22:31:53: MQTT publish: topic 'zigbee2mqtt2/TestSwitch', payload '{\"action\":\"\",\"last_seen\":1634671913843,\"linkquality\":70,\"max_pause_button_1\":null,\"max_pause_button_2\":null,\"min_long_press_button_1\":null,\"min_long_press_button_2\":null,\"relay_mode_button_1\":\"front\",\"relay_mode_button_2\":\"unlinked\",\"state_button_1\":\"OFF\",\"state_button_2\":\"OFF\",\"switch_actions_button_1\":null,\"switch_actions_button_2\":null,\"switch_type_button_1\":null,\"switch_type_button_2\":\"momentary\"}'\nZigbee2MQTT:info  2021-10-19 22:31:53: MQTT publish: topic 'zigbee2mqtt2/TestSwitch/action', payload 'hold_button_2'\n```\n\n우리는 genMultistateInput 클러스터 메시지가 정상적으로 처리되고 MQTT 메시지로 전환된 것을 볼 수 있습니다. 마지막 메시지가 간결하고 중요한데, 두 번째 버튼이 눌린 이벤트가 있었습니다. MQTT 이벤트를 구독할 수 있는 어떤 시스템이든 이러한 메시지를 쉽게 처리할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다른 두 개의 메시지가 조금 혼란스러울 수 있어요 — \"action\":\"hold_button_2\"를 보내고, 곧바로 \"action\":\"\"를 보내죠. 하지만 이는 Zigbee2mqtt FAQ에 설명된 정상적인 동작인 걸 알게 된 것이죠.\n\n팁:\n\n이전에도 언급했듯이 Multistate 입력 클러스터는 일반적인 방식과는 조금 다르게 사용되어요 — 값 자체보다는 값 변경 이벤트에 관심이 있는 것이죠. 주요 속성이 다양한 값들을 취할 수 있는 편리한 클러스터일 뿐입니다.\n\n하지만 Multistate 입력이 다양한 버튼 이벤트를 신호로 지시하는 유일한 방법은 아닙니다. 그래서 샤오미 WXKG01LM 스위치는 OnOff 클러스터의 비표준 확장을 구현합니다. 상태 속성의 표준 0 및 1 값 이외에도 클릭 수를 나타내는 다른 값을 사용할 수 있어요. 다른 디바이스들도 On/Off 클러스터의 비표준 확장을 구현하고 다양한 이벤트를 나타내는 추가 속성을 추가합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n일부 디바이스는 펌웨어 측면에서 다중 클릭 로직을 전혀 구현하지 않을 수 있습니다. 반면, 절대 표준적인 OnOff 클러스터가 사용되며, 다중 클릭은 z2m 컨버터에서 타이머를 사용하여 계산됩니다.\n\n마지막으로 제조업체는 매우 사용자 정의된 클러스터를 개발하여 선호하는 형식으로 정보를 전송할 수도 있습니다.\n\n# Home Assistant 자동화\n\nHome Assistant에 노출된 스위치는 거의 자동으로 통합되지만 몇 가지 문제점이 있습니다. 먼저, 기본적으로 대부분의 설정이 비활성화되어 Home Assistant에 숨겨져 있습니다. 각 설정을 수동으로 활성화한 후 Home Assistant를 다시 시작해야 합니다. 매개변수를 활성화한 후에는 기기 페이지가 다음과 같이 보입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_5.png\" /\u003e\n\n둘째, 숫자 매개변수는 편집할 수 없습니다. 안타깝게도 이 문제를 전혀 해결할 방법을 찾지 못했습니다. 이를 해결하기 위한 임시방편으로, 이러한 매개변수는 zigbee2mqtt 대시보드에서 편집하거나 해당 mqtt 메시지를 보내는 방법으로 편집할 수 있습니다.\n\n작업에 대해 말하자면, 여기서는 조금 원할한 상황이 아닙니다. 변환기가 가능한 작업 목록을 광고하지만, Home Assistant는이 목록을 무시합니다. 자동화를 생성하려고 하면 HA가 더블/트리플/롱 프레스를 자동화 트리거로 제안하지 않습니다... 해당 작업이 최소한 한 번 발생할 때까지입니다. 그런 다음 해당 작업이 목록에 나타나며 자동화 마법사에서 사용할 수 있게 됩니다.\n\n자, 이제 유용한 일을 해보고 흥미로운 자동화를 작성해 봅시다. 현재 나는 내 Xiaomi 스위치로 커튼을 부분적으로 열거나 닫을 수 있는 기능이 정말 그립습니다. 보통 매우 어렵게 깨어납니다. 커튼이 한꺼번에 완전히 열리면 눈에 매우 충격을 줍니다. 커튼의 정도를 동일한 스위치로 제어할 수 있는 기능이 있으면 좋겠습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n단 몇 분 만에, 홈 어시스턴트 시각적 편집기에서 몇 가지 자동화 규칙을 만들었어요.\n\n첫 번째 자동화는 버튼 더블 클릭으로 커튼을 완전히 열거나 닫습니다.\n\n```js\n- id: '1635018171508'\n  alias: TestSwitch Open/Close curtain\n  description: 'TestSwitch Open/Close curtain'\n  trigger:\n  - platform: mqtt\n    topic: zigbee2mqtt2/TestSwitch/action\n    payload: double_button_1\n  condition: []\n  action:\n  - service: cover.toggle\n    target:\n      entity_id: cover.living_room_curtain\n  mode: single\n```\n\n두 번째 자동화는 버튼을 세 번 클릭하면 커튼을 50%로 엽니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```yaml\n- id: '1635017708545'\n  alias: TestSwitch Half-open curtains\n  description: 'TestSwitch Half-open curtains'\n  trigger:\n  - platform: mqtt\n    topic: zigbee2mqtt2/TestSwitch/action\n    payload: triple_button_1\n  condition: []\n  action:\n  - service: cover.set_cover_position\n    target:\n      entity_id: cover.living_room_curtain\n    data:\n      position: 50\n  mode: single\n```\n\n다음 두 가지 자동화는 길게 누르는 것을 사용합니다 — 버튼을 누르면 커튼이 움직이기 시작하고, 버튼을 놓으면 멈춥니다.\n\n```yaml\n- id: '1635017908150'\n  alias: TestSwitch toggle curtain on button press\n  description: 'TestSwitch toggle curtain on button press'\n  trigger:\n  - platform: mqtt\n    topic: zigbee2mqtt2/TestSwitch/action\n    payload: hold_button_1\n  condition: []\n  action:\n  - service: cover.toggle\n    target:\n      entity_id: cover.living_room_curtain\n  mode: single\n\n- id: '1635017981037'\n  alias: TestSwitch stop curtain\n  description: 'TestSwitch stop curtain'\n  trigger:\n  - platform: mqtt\n    topic: zigbee2mqtt2/TestSwitch/action\n    payload: release_button_1\n  condition: []\n  action:\n  - service: cover.stop_cover\n    target:\n      entity_id: cover.living_room_curtain\n  mode: single\n```\n\n위와 같이 간단한 자동화를 사용하면 단일 버튼으로 커튼을 제어할 수 있습니다 — 열기, 닫기, 특정 개도로 설정하는 것도 가능합니다. 게다가, 버튼의 일반적인 단추도 주 조명을 전환할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# 요약\n\n축하해요, 우리는 방금 Xiaomi Aqara 스위치를 새롭게 만들었어요! 음, 비슷한 스마트 스위치예요. 아마도 우리 장치는 좀 더 다양한 설정을 제공할지도 모르지만, 전반적으로 모든 것이 거의 같아요. 그래도 뭔가 다른 목표가 있었죠 — 사용자 정의 클러스터, genOnOffSettingCfg 및 genMultistateInput 클러스터를 생성하고 zigbee2mqtt를 위한 외부 컨버터를 작성해보는 것이었어요.\n\n자신만의 클러스터를 만들거나 기존 클러스터를 확장하는 데 별로 어려운 점이 없다는 것이 밝혀졌어요. zigbee2mqtt를 다루는 데에는 조금 골치가 아팠지만, 그건 대부분 명쾌한 문서의 부재 때문이었어요. 이제 이 빈칸은 채워졌어요 :)\n\n# 링크\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n- JN-UG-3113 ZigBee 3.0 스택 사용자 가이드\n- JN-UG-3114 ZigBee 3.0 디바이스 사용자 가이드\n- JN-UG-3076 ZigBee 홈 오토메이션 사용자 가이드\n- ZigBee 클래스 라이브러리 사양\n- Zigbee 트래픽을 감지하는 방법\n- zigbee2mqtt에 새로운 장치 추가\n- 깃허브 프로젝트\n\n# 지원\n\n이 프로젝트는 품앗이 프로젝트로 무료로 개발 중입니다. 동시에 작은 기부로 프로젝트를 지원하는 것을 고려해볼 수 있습니다.\n\n![HelloZigbeeWorld](/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_6.png)","ogImage":{"url":"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_0.png"},"coverImage":"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_0.png","tag":["Tech"],"readingTime":18},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e이전 두 편의 글에서는 스마트 스위치에 여러 작업을 지원하는 기능을 구현하여, 멀티스테이트 입력 클러스터를 통해 단일/더블/트리플/롱 프레스를 처리하고 보고할 수 있게 되었습니다. 또한 On/Off 스위치 설정 클러스터의 사용자 정의 확장을 통해 장치의 설정을 제어하는 기능도 구현했습니다. 이러한 추가 기능으로 사용자들은 Zigbee 시설을 이용하여 런타임에서 장치를 구성할 수 있게 됩니다.\u003c/p\u003e\n\u003cp\u003e그러나 한 가지 문제가 있습니다: 우리는 장치 측면에서 이를 구현했지만, zigbee2mqtt와 같은 다른 시스템들은 이러한 추가 기능과 어떻게 작동해야 하는지 알지 못합니다. 이 글에서는 우리의 장치를 지원하기 위해 zigbee2mqtt용의 외부 컨버터 — 특별한 플러그인을 작성하는 방법을 상세히 설명하고 있습니다.\u003c/p\u003e\n\u003cp\u003e일반적으로, 나의 코드는 이전 글에서 만든 코드를 기반으로 합니다. 개발 보드로는 NXP JN5169 마이크로컨트롤러를 기반으로 한 EBYTE E75-2G4M10S 모듈을 사용할 것입니다. 이 글은 Hello Zigbee 시리즈에 훌륭한 추가 내용이 되며, 처음부터 Zigbee 장치 펌웨어를 구축하는 방법을 설명하고 있습니다.\u003c/p\u003e\n\u003ch1\u003eZigbee2mqtt 외부 컨버터\u003c/h1\u003e\n\u003cp\u003e안타깝게도 외부 컨버터에 대한 문서화가 매우 미흡하며, 정확히 함수가 무엇을 해야 하는지에 대한 좋은 설명을 찾지 못했습니다. 조금 모호한 예제 몇 개가 있지만, 이에 대해 많은 의문이 듭니다.\u003c/p\u003e\n\u003cp\u003e우리의 사용자 정의 On/Off Switch Configuration Cluster를 지원하기로 시작합시다. 저는 직접 \u003ccode\u003epoke\u003c/code\u003e 메서드를 사용하여 내 컨버터를 작성해야 했고, 그들이 어떻게 동작해야 하는지 파악하기 위해 수십 개의 기존 컨버터를 살펴보았습니다. 제가 제작 중일 때 컨버터에 대해 공부한 내용은 다음과 같습니다.\u003c/p\u003e\n\u003cp\u003e모든 컨버터는 \u003ccode\u003eimports\u003c/code\u003e로 시작합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fz = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'zigbee-herdsman-converters/converters/fromZigbee'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e tz = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'zigbee-herdsman-converters/converters/toZigbee'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e exposes = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'zigbee-herdsman-converters/lib/exposes'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e reporting = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'zigbee-herdsman-converters/lib/reporting'\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e e = exposes.\u003cspan class=\"hljs-property\"\u003epresets\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ea = exposes.\u003cspan class=\"hljs-property\"\u003eaccess\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리가 맞춤 필드를 여러 개 추가했기 때문에, 그들과 관련된 유형 및 데이터 구조를 설명해야 합니다. Herdsman converters 프로젝트에서 정의된 모든 가능한 유형이 있습니다. 불행하게도, TypeScript에서 구조체를 JavaScript 코드로 가져오는 방법을 찾지 못해 필요한 유형의 값을 중복해서 작성해야 했습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDataType\u003c/span\u003e = {\n    \u003cspan class=\"hljs-attr\"\u003euint16\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0x21\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eenum8\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0x30\u003c/span\u003e,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e새로운 속성에 대한 열거형 값들을 정의해봅시다. 값들의 순서는 펌웨어 코드에 설명된 것과 동일하며, 변환기 코드는 목록에서 위치 번호를 해당 값과 일치시키기만 하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e switchTypeValues = [\u003cspan class=\"hljs-string\"\u003e'toggle'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'momentary'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'multifunction'\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e switchActionValues = [\u003cspan class=\"hljs-string\"\u003e'onOff'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'offOn'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'toggle'\u003c/span\u003e];\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e relayModeValues = [\u003cspan class=\"hljs-string\"\u003e'unlinked'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'front'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'single'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'double'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'tripple'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'long'\u003c/span\u003e];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제조업체별 속성을 참조할 때에는 속성 식별자 뿐만 아니라 제조업체 코드도 명시해야 합니다. 그렇지 않으면 ZCL 펌웨어 코드에서 요청을 거부합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e manufacturerOptions = {\n    \u003cspan class=\"hljs-attr\"\u003ejennic\u003c/span\u003e: {\u003cspan class=\"hljs-attr\"\u003emanufacturerCode\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e0x1037\u003c/span\u003e}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 z2m 웹 양식에 해당 필드를 등록해야 합니다. 이러한 필드는 디바이스의 Exposes 탭에 표시됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egenSwitchEndpoint\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eepName\u003c/span\u003e) {\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [\n       e.\u003cspan class=\"hljs-title function_\"\u003eswitch\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ewithEndpoint\u003c/span\u003e(epName),\n       exposes.\u003cspan class=\"hljs-title function_\"\u003eenum\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'switch_mode'\u003c/span\u003e, ea.\u003cspan class=\"hljs-property\"\u003eALL\u003c/span\u003e, switchModeValues).\u003cspan class=\"hljs-title function_\"\u003ewithEndpoint\u003c/span\u003e(epName),\n       exposes.\u003cspan class=\"hljs-title function_\"\u003eenum\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'switch_actions'\u003c/span\u003e, ea.\u003cspan class=\"hljs-property\"\u003eALL\u003c/span\u003e, switchActionValues).\u003cspan class=\"hljs-title function_\"\u003ewithEndpoint\u003c/span\u003e(epName),\n       exposes.\u003cspan class=\"hljs-title function_\"\u003eenum\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'relay_mode'\u003c/span\u003e, ea.\u003cspan class=\"hljs-property\"\u003eALL\u003c/span\u003e, relayModeValues).\u003cspan class=\"hljs-title function_\"\u003ewithEndpoint\u003c/span\u003e(epName),\n       exposes.\u003cspan class=\"hljs-title function_\"\u003enumeric\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'max_pause'\u003c/span\u003e, ea.\u003cspan class=\"hljs-property\"\u003eALL\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ewithEndpoint\u003c/span\u003e(epName),\n       exposes.\u003cspan class=\"hljs-title function_\"\u003enumeric\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'min_long_press'\u003c/span\u003e, ea.\u003cspan class=\"hljs-property\"\u003eALL\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ewithEndpoint\u003c/span\u003e(epName),\n   ]\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egenSwitchEndpoints\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eendpoinsCount\u003c/span\u003e) {\n   \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e features = [];\n\n   \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; i \u0026#x3C;= endpoinsCount; i++) {\n       \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e epName = \u003cspan class=\"hljs-string\"\u003e`button_\u003cspan class=\"hljs-subst\"\u003e${i}\u003c/span\u003e`\u003c/span\u003e;\n       features.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(...\u003cspan class=\"hljs-title function_\"\u003egenSwitchEndpoint\u003c/span\u003e(epName));\n   }\n\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e features;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e주어진 엔드포인트 수에 대해 첫 번째 함수는 스위치 위젯 (e.switch())과 구성 필드 시리즈를 생성합니다. 결과물은 다음과 같습니다.\u003c/p\u003e\n\u003cp\u003e2~3개 값으로 이루어진 열거형 필드는 버튼으로, 다른 필드(relay_mode)는 드롭다운 목록으로 변환되었습니다. 마지막 두 숫자 필드는 증가/감소 화살표가 있는 입력 필드입니다.\u003c/p\u003e\n\u003cp\u003e이제 이에 생명을 불어넣고, 3개의 변환 함수를 작성해야 합니다. 이 3개의 함수는 toZigbee 및 fromZigbee라는 코드명으로 구성되어야 합니다. 정확히 무슨 의미인지는 아래에서 설명하겠습니다.\u003c/p\u003e\n\u003cp\u003e양식을 변경할 때 zigbee2mqtt는 toZigbee 구조에서 convertSet() 함수를 호출합니다. key 필드는 또한 우리의 컨버터가 처리할 수있는 매개변수 목록을 지정합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e toZigbee_OnOffSwitchCfg = {\n   \u003cspan class=\"hljs-attr\"\u003ekey\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'switch_mode'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'switch_actions'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'relay_mode'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'max_pause'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'min_long_press'\u003c/span\u003e],\n\n   \u003cspan class=\"hljs-attr\"\u003econvertSet\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (entity, key, value, meta) =\u003e {\n       \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e payload = {};\n       \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e newValue = value;\n\n       \u003cspan class=\"hljs-keyword\"\u003eswitch\u003c/span\u003e(key) {\n           \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'switch_mode'\u003c/span\u003e:\n               newValue = switchModeValues.\u003cspan class=\"hljs-title function_\"\u003eindexOf\u003c/span\u003e(value);\n               payload = {\u003cspan class=\"hljs-number\"\u003e65280\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e'value'\u003c/span\u003e: newValue, \u003cspan class=\"hljs-string\"\u003e'type'\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDataType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eenum8\u003c/span\u003e};\n               \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e entity.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'genOnOffSwitchCfg'\u003c/span\u003e, payload, manufacturerOptions.\u003cspan class=\"hljs-property\"\u003ejennic\u003c/span\u003e);\n               \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n\n           \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'switch_actions'\u003c/span\u003e:\n               newValue = switchActionValues.\u003cspan class=\"hljs-title function_\"\u003eindexOf\u003c/span\u003e(value);\n               payload = {\u003cspan class=\"hljs-attr\"\u003eswitchActions\u003c/span\u003e: newValue};\n               \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e entity.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'genOnOffSwitchCfg'\u003c/span\u003e, payload);\n               \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n\n           \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'relay_mode'\u003c/span\u003e:\n               newValue = relayModeValues.\u003cspan class=\"hljs-title function_\"\u003eindexOf\u003c/span\u003e(value);\n               payload = {\u003cspan class=\"hljs-number\"\u003e65281\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e'value'\u003c/span\u003e: newValue, \u003cspan class=\"hljs-string\"\u003e'type'\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDataType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eenum8\u003c/span\u003e};\n               \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e entity.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'genOnOffSwitchCfg'\u003c/span\u003e, payload, manufacturerOptions.\u003cspan class=\"hljs-property\"\u003ejennic\u003c/span\u003e);\n               \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n\n           \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'max_pause'\u003c/span\u003e:\n               payload = {\u003cspan class=\"hljs-number\"\u003e65282\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e'value'\u003c/span\u003e: value, \u003cspan class=\"hljs-string\"\u003e'type'\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDataType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003euint16\u003c/span\u003e};\n               \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e entity.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'genOnOffSwitchCfg'\u003c/span\u003e, payload, manufacturerOptions.\u003cspan class=\"hljs-property\"\u003ejennic\u003c/span\u003e);\n               \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n\n           \u003cspan class=\"hljs-keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'min_long_press'\u003c/span\u003e:\n               payload = {\u003cspan class=\"hljs-number\"\u003e65283\u003c/span\u003e: {\u003cspan class=\"hljs-string\"\u003e'value'\u003c/span\u003e: value, \u003cspan class=\"hljs-string\"\u003e'type'\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eDataType\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003euint16\u003c/span\u003e};\n               \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e entity.\u003cspan class=\"hljs-title function_\"\u003ewrite\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'genOnOffSwitchCfg'\u003c/span\u003e, payload, manufacturerOptions.\u003cspan class=\"hljs-property\"\u003ejennic\u003c/span\u003e);\n               \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n\n           \u003cspan class=\"hljs-attr\"\u003edefault\u003c/span\u003e:\n               \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n       }\n\n       result = {\u003cspan class=\"hljs-attr\"\u003estate\u003c/span\u003e: {[key]: value}\n       \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n   },\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003etoZigbee_OnOffSwitchCfg::convertSet() 함수는 텍스트 속성 이름과 설정할 속성 값들을 받습니다. 이 함수의 목표는 이를 네트워크로 전송할 수 있는 구조로 변환하는 것입니다. 표준 속성 (예: switch_actions)의 경우, 단순히 속성 키-값 쌍이 될 것이지만, 값은 숫자로 변환됩니다. herdsman 변환기 코드는 표준 속성 및 이들의 형식, 네트워크로 전달하는 방법 등을 알고 있습니다. 비표준 속성 (예: relay_mode)의 경우, 세 개의 값으로 변환해야 합니다:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e숫자 속성 식별자 (10진 형식으로 설정해야 함 — 예: 65280)\u003c/li\u003e\n\u003cli\u003e속성 유형 (유형 식별자)\u003c/li\u003e\n\u003cli\u003e값 (열거형의 경우 값 색인)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e이러한 값들은 낮은 수준의 Zigbee 메시지로 묶여 네트워크를 통해 전송됩니다. 엔티티 객체는 읽기 및 쓰기 명령이 실행되는 엔드포인트입니다. 비표준 속성을 위해 제조사별 코드를 지정하는 것이 필수적입니다 (manufacturerOptions.jennic 사용).\u003c/p\u003e\n\u003cp\u003e함수는 속성의 새로운 상태를 반환해야 합니다. 그 결과는 꼼꼼한 종류의 구조로 구성되어야 하며, 그렇지 않으면 웹 양식의 버튼 값이 변경되지 않습니다.\u003c/p\u003e\n\u003cp\u003e새로운 속성 값을 보내는 스니퍼는 다음과 같이 보일 것입니다.\u003c/p\u003e\n\u003cp\u003e디바이스 측에서는 ZCL 구현이 들어오는 요청을 파싱하고, 자동으로 새 값을 해당 필드에 설정합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-attr\"\u003eZPS_EVENT_APS_DATA_INDICATION\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSrcEP\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDstEP\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSrcAddr\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e0000\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCluster\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e0007\u003c/span\u003e () \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eZCL\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eWrite\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAttribute\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eClustter\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0007\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAttrib\u003c/span\u003e ff00\n\u003cspan class=\"hljs-variable constant_\"\u003eZCL\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEndpoint\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCallback\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eWrite\u003c/span\u003e attributes completed\n\u003cspan class=\"hljs-attr\"\u003eZPS_EVENT_APS_DATA_CONFIRM\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSrcEP\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDstEP\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDstAddr\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e0000\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eStatus\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\u003cspan class=\"hljs-attr\"\u003eZPS_EVENT_APS_DATA_ACK\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eSrcEP\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDrcEP\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDstAddr\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e0000\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProfile\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e0104\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCluster\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e0007\u003c/span\u003e ()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e속성을 읽는 것이 더 어려워 보입니다. 기본적으로 zigbee2mqtt UI는 현재 속성 값을 표시하지 않습니다. 속성 중 하나 옆의 \"업데이트\" 버튼을 클릭하면 toZigbeeConverter::convertGet() 함수가 호출됩니다.\u003c/p\u003e\n\u003cp\u003e처음에는 이름인 toZigbee::converterGet()에 매우 혼동을 겪었어요. 왜 fromzigbee가 아니지? 네트워크에서 데이터를 받는 거 아니면서도 말이죠? 그런데 코드를 더 정확하게 살펴보니까 더 명확해졌어요: toZigbee 구성 요소는 (읽기 요청이더라도) 네트워크로 요청을 준비하는 역할을 담당하고 있어요. 장치는 나중에 읽기 속성 응답 메시지를 포함한 읽기 값이 들어있는 응답을 보내줄 거예요. 그럼 fromZigbee 구성 요소는 네트워크로부터 도착한 내용을 구문 분석하게 됩니다 (하지만 이에 대해서는 나중에 더 자세히 이야기할게요).\u003c/p\u003e\n\u003cp\u003e대부분의 변환기 구현은 한 번에 모든 속성을 가져오기 위해 일괄 요청을 사용해요 - Zigbee 사양이 이를 허용하기 때문이죠. 안타깝게도, 표준 속성('switchActions')과 제조사별 속성을 사용하고 있기 때문에 이들을 한 번에 가져오기가 불가능해요. 따라서 제 구현은 한 번에 하나의 속성을 가져올 거에요. 물론, 표준이 아닌 속성을 읽는 것은 제조사 코드가 필요할 거에요.\u003c/p\u003e\n\u003cp\u003e스니퍼에서 읽기 요청이 어떻게 보이는지 살펴보세요.\u003c/p\u003e\n\u003cp\u003e이것이 테이블 태그이며, 이것이 답변입니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_4.png\" alt=\"이미지\"\u003e\u003c/p\u003e\n\u003cp\u003e단말기에서 패킷을 수신한 코디네이터는 fromZigbee 구성 요소가 요청의 구문 분석을 수행합니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetKey\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003eobject, value\u003c/span\u003e) =\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e key \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e object) {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (object[key] == value) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e key;\n    }\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fromZigbee_OnOffSwitchCfg = {\n   \u003cspan class=\"hljs-attr\"\u003ecluster\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'genOnOffSwitchCfg'\u003c/span\u003e,\n   \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'attributeReport'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'readResponse'\u003c/span\u003e],\n\n   \u003cspan class=\"hljs-attr\"\u003econvert\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emodel, msg, publish, options, meta\u003c/span\u003e) =\u003e\u003c/span\u003e {\n\n       \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ep_name = \u003cspan class=\"hljs-title function_\"\u003egetKey\u003c/span\u003e(model.\u003cspan class=\"hljs-title function_\"\u003eendpoint\u003c/span\u003e(msg.\u003cspan class=\"hljs-property\"\u003edevice\u003c/span\u003e), msg.\u003cspan class=\"hljs-property\"\u003eendpoint\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eID\u003c/span\u003e);\n       \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = {};\n\n       \u003cspan class=\"hljs-comment\"\u003e// switch type\u003c/span\u003e\n       \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(msg.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasOwnProperty\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'65280'\u003c/span\u003e)) {\n           result[\u003cspan class=\"hljs-string\"\u003e`switch_mode_\u003cspan class=\"hljs-subst\"\u003e${ep_name}\u003c/span\u003e`\u003c/span\u003e] = switchModeValues[msg.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'65280'\u003c/span\u003e]];\n       }\n\n       \u003cspan class=\"hljs-comment\"\u003e// switch action\u003c/span\u003e\n       \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(msg.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasOwnProperty\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'switchActions'\u003c/span\u003e)) { \u003cspan class=\"hljs-comment\"\u003e// use standard 'switchActions' attribute identifier\u003c/span\u003e\n           result[\u003cspan class=\"hljs-string\"\u003e`switch_actions_\u003cspan class=\"hljs-subst\"\u003e${ep_name}\u003c/span\u003e`\u003c/span\u003e] = switchActionValues[msg.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'switchActions'\u003c/span\u003e]];\n       }\n\n       \u003cspan class=\"hljs-comment\"\u003e// relay mode\u003c/span\u003e\n       \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(msg.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasOwnProperty\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'65281'\u003c/span\u003e)) {\n           result[\u003cspan class=\"hljs-string\"\u003e`relay_mode_\u003cspan class=\"hljs-subst\"\u003e${ep_name}\u003c/span\u003e`\u003c/span\u003e] = relayModeValues[msg.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'65281'\u003c/span\u003e]];\n       }\n\n\n       \u003cspan class=\"hljs-comment\"\u003e// Maximum pause between button clicks in a multiclick\u003c/span\u003e\n       \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(msg.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasOwnProperty\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'65282'\u003c/span\u003e)) {\n           result[\u003cspan class=\"hljs-string\"\u003e`max_pause_\u003cspan class=\"hljs-subst\"\u003e${ep_name}\u003c/span\u003e`\u003c/span\u003e] = msg.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'65282'\u003c/span\u003e];\n       }\n\n       \u003cspan class=\"hljs-comment\"\u003e// Minimal duration for the long press\u003c/span\u003e\n       \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(msg.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ehasOwnProperty\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'65283'\u003c/span\u003e)) {\n           result[\u003cspan class=\"hljs-string\"\u003e`min_long_press_\u003cspan class=\"hljs-subst\"\u003e${ep_name}\u003c/span\u003e`\u003c/span\u003e] = msg.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'65283'\u003c/span\u003e];\n       }\n\n       \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n   },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 함수는 해당 보고서에서 속성 값들을 파싱하고, 이를 Z2M 구조로 \u003ccode\u003eattribute_name\u003c/code\u003e_\u003ccode\u003eendpoint_name\u003c/code\u003e 레코드로 분해하려고 노력합니다.\u003c/p\u003e\n\u003cp\u003e거의 다 끝났어요. 마지막 구조 하나만 더 남았는데, 이것은 모든 것을 함께 모을 것입니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e device = {\n    \u003cspan class=\"hljs-attr\"\u003ezigbeeModel\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'Hello Zigbee Switch'\u003c/span\u003e],\n    \u003cspan class=\"hljs-attr\"\u003emodel\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Hello Zigbee Switch'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003evendor\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'NXP'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'Hello Zigbee Switch'\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003efromZigbee\u003c/span\u003e: [fz.\u003cspan class=\"hljs-property\"\u003eon_off\u003c/span\u003e, fromZigbee_OnOffSwitchCfg],\n    \u003cspan class=\"hljs-attr\"\u003etoZigbee\u003c/span\u003e: [tz.\u003cspan class=\"hljs-property\"\u003eon_off\u003c/span\u003e, toZigbee_OnOffSwitchCfg],\n    \u003cspan class=\"hljs-attr\"\u003eexposes\u003c/span\u003e: \u003cspan class=\"hljs-title function_\"\u003egenEndpoints\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e),\n    \u003cspan class=\"hljs-attr\"\u003econfigure\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (device, coordinatorEndpoint, logger) =\u003e {\n        device.\u003cspan class=\"hljs-property\"\u003eendpoints\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (ep) =\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ep.\u003cspan class=\"hljs-title function_\"\u003eread\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'genOnOff'\u003c/span\u003e, [\u003cspan class=\"hljs-string\"\u003e'onOff'\u003c/span\u003e]);\n            \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ep.\u003cspan class=\"hljs-title function_\"\u003eread\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'genOnOffSwitchCfg'\u003c/span\u003e, [\u003cspan class=\"hljs-string\"\u003e'switchActions'\u003c/span\u003e]);\n            \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e ep.\u003cspan class=\"hljs-title function_\"\u003eread\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'genOnOffSwitchCfg'\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e65280\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e65281\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e65282\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e65283\u003c/span\u003e], manufacturerOptions.\u003cspan class=\"hljs-property\"\u003ejennic\u003c/span\u003e);\n        });\n    },\n    \u003cspan class=\"hljs-attr\"\u003eendpoint\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edevice\u003c/span\u003e) =\u003e\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\u003cspan class=\"hljs-attr\"\u003ebutton_1\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ebutton_2\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e};\n    },\n};\n\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = device;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 코드는 새로운 장치를 등록하고 해당 장치에 대한 컨버터를 등록합니다. On/Off 기능에는 표준 fz/tz.on_off 컨버터가 사용되며, 우리의 함수인 to/fromZigbee_OnOffSwitchCfg가 스위치 구성을 처리합니다.\u003c/p\u003e\n\u003cp\u003e이 장치는 이미 2개의 스위치 엔드포인트를 지원하므로, 컨버터는 2개의 설정 세트를 등록합니다. 또한, 기본 채널이 endpoint #1에 있고, 스위치 엔드포인트는 endpoint #2부터 시작한다는 점을 기억하십시오. 모든 것이 올바르게 보여지고 작동되도록 endpoint-to-buttons 재번호 매핑을 추가해야 했습니다.\u003c/p\u003e\n\u003cp\u003e또한 configure() 함수를 강조하고 싶습니다. Z2M을 시작할 때는 스위치의 현재 상태나 설정 값이 알려져 있지 않습니다 — 설정 섹션의 모든 필드는 비어 있을 것입니다. 제가 연구한 대부분의 컨버터는 속성 보고를 설정하며, 장치는 예를 들어 1분마다 상태와 속성을 보고합니다. 따라서 일부 장치는 시작 시 값이 즉시 표시되지 않지만 나중에 값이 나타납니다. 이는 온도 센서와 같은 장치에 적합한 옵션입니다. 저의 컨버터 버전에서는 시작 시에 실제 값을 간단히 읽기로 결정했습니다.\u003c/p\u003e\n\u003cp\u003e마지막 단계는 zigbee2mqtt에서 컨버터를 등록하는 것입니다. configuration.yaml에 다음 라인을 추가하고 Z2M을 다시 시작하면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-attr\"\u003eexternal_converters:\u003c/span\u003e\n  \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emyswitch.js\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e장치가 가입할 때, zigbee2mqtt는 장치 이름을 요청하고 해당하는 컨버터를 사용할 것입니다.\u003c/p\u003e\n\u003ch1\u003e다중 액션 지원\u003c/h1\u003e\n\u003cp\u003e기억하시다시피, 우리는 장치에 다중 입력 클러스터를 추가하여 단일/이중/삼중/긴 눌림을 보고할 수 있도록 했습니다. 이러한 이벤트들은 속성 변경 보고서로 제공됩니다. 하지만 이제는 Z2M이 이러한 보고서를 이해하고 적절한 액션을 생성할 수 있도록 가르쳐 주어야 합니다. 이를 위해 fromZigbee 컨버터를 또 추가해보죠. 이 클러스터에 뭔가를 장치에 쓰지 않을 것이므로 toZigbee 컨버터를 추가할 필요는 없습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fromZigbee_MultistateInput = {\n   \u003cspan class=\"hljs-attr\"\u003ecluster\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'genMultistateInput'\u003c/span\u003e,\n   \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e'attributeReport'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'readResponse'\u003c/span\u003e],\n\n   \u003cspan class=\"hljs-attr\"\u003econvert\u003c/span\u003e: \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emodel, msg, publish, options, meta\u003c/span\u003e) =\u003e\u003c/span\u003e {\n       \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e actionLookup = {\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'release'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'single'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'double'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'tripple'\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e255\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'hold'\u003c/span\u003e};\n       \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e value = msg.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e'presentValue'\u003c/span\u003e];\n       \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e action = actionLookup[value];\n\n       \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = {\u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e: utils.\u003cspan class=\"hljs-title function_\"\u003epostfixWithEndpointName\u003c/span\u003e(action, msg, model)};\n       \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n   },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 컨버터는 ptvo_multistate_action 컨버터에서 영감을 받았습니다. presentValue 클러스터 속성을 간단히 추출하여 해당 작업 텍스트로 변환합니다.\u003c/p\u003e\n\u003cp\u003e이 컨버터는 장치가 생성할 수 있는 작업도 광고할 수 있어서 Home Assistant와 같은 다른 시스템이 준비할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egenSwitchActions\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eendpoinsCount\u003c/span\u003e) {\n   \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e actions = [];\n\n   \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; i \u0026#x3C;= endpoinsCount; i++) {\n       \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e epName = \u003cspan class=\"hljs-string\"\u003e`button_\u003cspan class=\"hljs-subst\"\u003e${i}\u003c/span\u003e`\u003c/span\u003e;\n       actions.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(... [\u003cspan class=\"hljs-string\"\u003e'single'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'double'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'triple'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'hold'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'release'\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eaction\u003c/span\u003e =\u003e\u003c/span\u003e action + \u003cspan class=\"hljs-string\"\u003e\"_\"\u003c/span\u003e + epName));\n   }\n\n   \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e actions;\n}\n\n...\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e device = {\n...\n   \u003cspan class=\"hljs-attr\"\u003efromZigbee\u003c/span\u003e: [fz.\u003cspan class=\"hljs-property\"\u003eon_off\u003c/span\u003e, fromZigbee_OnOffSwitchCfg, fromZigbee_MultistateInput],\n...\n   \u003cspan class=\"hljs-attr\"\u003eexposes\u003c/span\u003e: [\n       e.\u003cspan class=\"hljs-title function_\"\u003eaction\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003egenSwitchActions\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)),\n       ...\u003cspan class=\"hljs-title function_\"\u003egenSwitchEndpoints\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)\n   ],\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e제가 원했던 것은 각 엔드포인트에서의 작업이 나머지 엔드포인트 정보와 함께 선언되기를 했지만(zigbee2mqtt 아키텍처는 이를 허용하지 않습니다), 이를 위한 genSwitchEndpoint() 함수에서 정의할 수 없습니다. 모든 작업은 exposes 필드에서 e.action() 함수를 사용하여 한 번만 정의해야 합니다(여기에 설명이 나와 있습니다).\u003c/p\u003e\n\u003cp\u003e자, 이제 버튼을 눌러서 zigbee2mqtt 쪽에서 어떻게 작동하는지 확인해 봅시다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eZigbee2MQTT\u003c/span\u003e:debug \u003cspan class=\"hljs-number\"\u003e2021\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e19\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e31\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e53\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eReceived\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eZigbee\u003c/span\u003e message \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'TestSwitch'\u003c/span\u003e, type \u003cspan class=\"hljs-string\"\u003e'attributeReport'\u003c/span\u003e, cluster \u003cspan class=\"hljs-string\"\u003e'genMultistateInput'\u003c/span\u003e, data \u003cspan class=\"hljs-string\"\u003e'{\"presentValue\":255}'\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e endpoint \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e groupID \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eZigbee2MQTT\u003c/span\u003e:info  \u003cspan class=\"hljs-number\"\u003e2021\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e19\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e31\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e53\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eMQTT\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epublish\u003c/span\u003e: topic \u003cspan class=\"hljs-string\"\u003e'zigbee2mqtt2/TestSwitch'\u003c/span\u003e, payload \u003cspan class=\"hljs-string\"\u003e'{\"action\":\"hold_button_2\",\"last_seen\":1634671913843,\"linkquality\":70,\"max_pause_button_1\":null,\"max_pause_button_2\":null,\"min_long_press_button_1\":null,\"min_long_press_button_2\":null,\"relay_mode_button_1\":\"front\",\"relay_mode_button_2\":\"unlinked\",\"state_button_1\":\"OFF\",\"state_button_2\":\"OFF\",\"switch_actions_button_1\":null,\"switch_actions_button_2\":null,\"switch_type_button_1\":null,\"switch_type_button_2\":\"momentary\"}'\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eZigbee2MQTT\u003c/span\u003e:info  \u003cspan class=\"hljs-number\"\u003e2021\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e19\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e31\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e53\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eMQTT\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epublish\u003c/span\u003e: topic \u003cspan class=\"hljs-string\"\u003e'zigbee2mqtt2/TestSwitch'\u003c/span\u003e, payload \u003cspan class=\"hljs-string\"\u003e'{\"action\":\"\",\"last_seen\":1634671913843,\"linkquality\":70,\"max_pause_button_1\":null,\"max_pause_button_2\":null,\"min_long_press_button_1\":null,\"min_long_press_button_2\":null,\"relay_mode_button_1\":\"front\",\"relay_mode_button_2\":\"unlinked\",\"state_button_1\":\"OFF\",\"state_button_2\":\"OFF\",\"switch_actions_button_1\":null,\"switch_actions_button_2\":null,\"switch_type_button_1\":null,\"switch_type_button_2\":\"momentary\"}'\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eZigbee2MQTT\u003c/span\u003e:info  \u003cspan class=\"hljs-number\"\u003e2021\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e19\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e22\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e31\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e53\u003c/span\u003e: \u003cspan class=\"hljs-variable constant_\"\u003eMQTT\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003epublish\u003c/span\u003e: topic \u003cspan class=\"hljs-string\"\u003e'zigbee2mqtt2/TestSwitch/action'\u003c/span\u003e, payload \u003cspan class=\"hljs-string\"\u003e'hold_button_2'\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e우리는 genMultistateInput 클러스터 메시지가 정상적으로 처리되고 MQTT 메시지로 전환된 것을 볼 수 있습니다. 마지막 메시지가 간결하고 중요한데, 두 번째 버튼이 눌린 이벤트가 있었습니다. MQTT 이벤트를 구독할 수 있는 어떤 시스템이든 이러한 메시지를 쉽게 처리할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e다른 두 개의 메시지가 조금 혼란스러울 수 있어요 — \"action\":\"hold_button_2\"를 보내고, 곧바로 \"action\":\"\"를 보내죠. 하지만 이는 Zigbee2mqtt FAQ에 설명된 정상적인 동작인 걸 알게 된 것이죠.\u003c/p\u003e\n\u003cp\u003e팁:\u003c/p\u003e\n\u003cp\u003e이전에도 언급했듯이 Multistate 입력 클러스터는 일반적인 방식과는 조금 다르게 사용되어요 — 값 자체보다는 값 변경 이벤트에 관심이 있는 것이죠. 주요 속성이 다양한 값들을 취할 수 있는 편리한 클러스터일 뿐입니다.\u003c/p\u003e\n\u003cp\u003e하지만 Multistate 입력이 다양한 버튼 이벤트를 신호로 지시하는 유일한 방법은 아닙니다. 그래서 샤오미 WXKG01LM 스위치는 OnOff 클러스터의 비표준 확장을 구현합니다. 상태 속성의 표준 0 및 1 값 이외에도 클릭 수를 나타내는 다른 값을 사용할 수 있어요. 다른 디바이스들도 On/Off 클러스터의 비표준 확장을 구현하고 다양한 이벤트를 나타내는 추가 속성을 추가합니다.\u003c/p\u003e\n\u003cp\u003e일부 디바이스는 펌웨어 측면에서 다중 클릭 로직을 전혀 구현하지 않을 수 있습니다. 반면, 절대 표준적인 OnOff 클러스터가 사용되며, 다중 클릭은 z2m 컨버터에서 타이머를 사용하여 계산됩니다.\u003c/p\u003e\n\u003cp\u003e마지막으로 제조업체는 매우 사용자 정의된 클러스터를 개발하여 선호하는 형식으로 정보를 전송할 수도 있습니다.\u003c/p\u003e\n\u003ch1\u003eHome Assistant 자동화\u003c/h1\u003e\n\u003cp\u003eHome Assistant에 노출된 스위치는 거의 자동으로 통합되지만 몇 가지 문제점이 있습니다. 먼저, 기본적으로 대부분의 설정이 비활성화되어 Home Assistant에 숨겨져 있습니다. 각 설정을 수동으로 활성화한 후 Home Assistant를 다시 시작해야 합니다. 매개변수를 활성화한 후에는 기기 페이지가 다음과 같이 보입니다.\u003c/p\u003e\n\u003cp\u003e둘째, 숫자 매개변수는 편집할 수 없습니다. 안타깝게도 이 문제를 전혀 해결할 방법을 찾지 못했습니다. 이를 해결하기 위한 임시방편으로, 이러한 매개변수는 zigbee2mqtt 대시보드에서 편집하거나 해당 mqtt 메시지를 보내는 방법으로 편집할 수 있습니다.\u003c/p\u003e\n\u003cp\u003e작업에 대해 말하자면, 여기서는 조금 원할한 상황이 아닙니다. 변환기가 가능한 작업 목록을 광고하지만, Home Assistant는이 목록을 무시합니다. 자동화를 생성하려고 하면 HA가 더블/트리플/롱 프레스를 자동화 트리거로 제안하지 않습니다... 해당 작업이 최소한 한 번 발생할 때까지입니다. 그런 다음 해당 작업이 목록에 나타나며 자동화 마법사에서 사용할 수 있게 됩니다.\u003c/p\u003e\n\u003cp\u003e자, 이제 유용한 일을 해보고 흥미로운 자동화를 작성해 봅시다. 현재 나는 내 Xiaomi 스위치로 커튼을 부분적으로 열거나 닫을 수 있는 기능이 정말 그립습니다. 보통 매우 어렵게 깨어납니다. 커튼이 한꺼번에 완전히 열리면 눈에 매우 충격을 줍니다. 커튼의 정도를 동일한 스위치로 제어할 수 있는 기능이 있으면 좋겠습니다.\u003c/p\u003e\n\u003cp\u003e단 몇 분 만에, 홈 어시스턴트 시각적 편집기에서 몇 가지 자동화 규칙을 만들었어요.\u003c/p\u003e\n\u003cp\u003e첫 번째 자동화는 버튼 더블 클릭으로 커튼을 완전히 열거나 닫습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e- \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'1635018171508'\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ealias\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eTestSwitch\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eOpen\u003c/span\u003e/\u003cspan class=\"hljs-title class_\"\u003eClose\u003c/span\u003e curtain\n  \u003cspan class=\"hljs-attr\"\u003edescription\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e'TestSwitch Open/Close curtain'\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etrigger\u003c/span\u003e:\n  - \u003cspan class=\"hljs-attr\"\u003eplatform\u003c/span\u003e: mqtt\n    \u003cspan class=\"hljs-attr\"\u003etopic\u003c/span\u003e: zigbee2mqtt2/\u003cspan class=\"hljs-title class_\"\u003eTestSwitch\u003c/span\u003e/action\n    \u003cspan class=\"hljs-attr\"\u003epayload\u003c/span\u003e: double_button_1\n  \u003cspan class=\"hljs-attr\"\u003econdition\u003c/span\u003e: []\n  \u003cspan class=\"hljs-attr\"\u003eaction\u003c/span\u003e:\n  - \u003cspan class=\"hljs-attr\"\u003eservice\u003c/span\u003e: cover.\u003cspan class=\"hljs-property\"\u003etoggle\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003etarget\u003c/span\u003e:\n      \u003cspan class=\"hljs-attr\"\u003eentity_id\u003c/span\u003e: cover.\u003cspan class=\"hljs-property\"\u003eliving_room_curtain\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003emode\u003c/span\u003e: single\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 번째 자동화는 버튼을 세 번 클릭하면 커튼을 50%로 엽니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'1635017708545'\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ealias:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eTestSwitch\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eHalf-open\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecurtains\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003edescription:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'TestSwitch Half-open curtains'\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etrigger:\u003c/span\u003e\n  \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eplatform:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emqtt\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003etopic:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ezigbee2mqtt2/TestSwitch/action\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003epayload:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etriple_button_1\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003econdition:\u003c/span\u003e []\n  \u003cspan class=\"hljs-attr\"\u003eaction:\u003c/span\u003e\n  \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eservice:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecover.set_cover_position\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003etarget:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eentity_id:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecover.living_room_curtain\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003edata:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eposition:\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003emode:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003esingle\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다음 두 가지 자동화는 길게 누르는 것을 사용합니다 — 버튼을 누르면 커튼이 움직이기 시작하고, 버튼을 놓으면 멈춥니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-yaml\"\u003e\u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'1635017908150'\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ealias:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eTestSwitch\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003etoggle\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecurtain\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eon\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003epress\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003edescription:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'TestSwitch toggle curtain on button press'\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etrigger:\u003c/span\u003e\n  \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eplatform:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emqtt\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003etopic:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ezigbee2mqtt2/TestSwitch/action\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003epayload:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ehold_button_1\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003econdition:\u003c/span\u003e []\n  \u003cspan class=\"hljs-attr\"\u003eaction:\u003c/span\u003e\n  \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eservice:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecover.toggle\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003etarget:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eentity_id:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecover.living_room_curtain\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003emode:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003esingle\u003c/span\u003e\n\n\u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'1635017981037'\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ealias:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003eTestSwitch\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003estop\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecurtain\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003edescription:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'TestSwitch stop curtain'\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etrigger:\u003c/span\u003e\n  \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eplatform:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003emqtt\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003etopic:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ezigbee2mqtt2/TestSwitch/action\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003epayload:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003erelease_button_1\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003econdition:\u003c/span\u003e []\n  \u003cspan class=\"hljs-attr\"\u003eaction:\u003c/span\u003e\n  \u003cspan class=\"hljs-bullet\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eservice:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecover.stop_cover\u003c/span\u003e\n    \u003cspan class=\"hljs-attr\"\u003etarget:\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eentity_id:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ecover.living_room_curtain\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003emode:\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003esingle\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위와 같이 간단한 자동화를 사용하면 단일 버튼으로 커튼을 제어할 수 있습니다 — 열기, 닫기, 특정 개도로 설정하는 것도 가능합니다. 게다가, 버튼의 일반적인 단추도 주 조명을 전환할 수 있습니다.\u003c/p\u003e\n\u003ch1\u003e요약\u003c/h1\u003e\n\u003cp\u003e축하해요, 우리는 방금 Xiaomi Aqara 스위치를 새롭게 만들었어요! 음, 비슷한 스마트 스위치예요. 아마도 우리 장치는 좀 더 다양한 설정을 제공할지도 모르지만, 전반적으로 모든 것이 거의 같아요. 그래도 뭔가 다른 목표가 있었죠 — 사용자 정의 클러스터, genOnOffSettingCfg 및 genMultistateInput 클러스터를 생성하고 zigbee2mqtt를 위한 외부 컨버터를 작성해보는 것이었어요.\u003c/p\u003e\n\u003cp\u003e자신만의 클러스터를 만들거나 기존 클러스터를 확장하는 데 별로 어려운 점이 없다는 것이 밝혀졌어요. zigbee2mqtt를 다루는 데에는 조금 골치가 아팠지만, 그건 대부분 명쾌한 문서의 부재 때문이었어요. 이제 이 빈칸은 채워졌어요 :)\u003c/p\u003e\n\u003ch1\u003e링크\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eJN-UG-3113 ZigBee 3.0 스택 사용자 가이드\u003c/li\u003e\n\u003cli\u003eJN-UG-3114 ZigBee 3.0 디바이스 사용자 가이드\u003c/li\u003e\n\u003cli\u003eJN-UG-3076 ZigBee 홈 오토메이션 사용자 가이드\u003c/li\u003e\n\u003cli\u003eZigBee 클래스 라이브러리 사양\u003c/li\u003e\n\u003cli\u003eZigbee 트래픽을 감지하는 방법\u003c/li\u003e\n\u003cli\u003ezigbee2mqtt에 새로운 장치 추가\u003c/li\u003e\n\u003cli\u003e깃허브 프로젝트\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e지원\u003c/h1\u003e\n\u003cp\u003e이 프로젝트는 품앗이 프로젝트로 무료로 개발 중입니다. 동시에 작은 기부로 프로젝트를 지원하는 것을 고려해볼 수 있습니다.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_6.png\" alt=\"HelloZigbeeWorld\"\u003e\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter"},"buildId":"FH3Qr-mLAesqA0X5IFRQr","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>