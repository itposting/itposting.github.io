<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>DuckDB 빅데이터 업계의 떠오르는 스타 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="DuckDB 빅데이터 업계의 떠오르는 스타 | itposting" data-gatsby-head="true"/><meta property="og:title" content="DuckDB 빅데이터 업계의 떠오르는 스타 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape" data-gatsby-head="true"/><meta name="twitter:title" content="DuckDB 빅데이터 업계의 떠오르는 스타 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-22 17:38" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">DuckDB 빅데이터 업계의 떠오르는 스타</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="DuckDB 빅데이터 업계의 떠오르는 스타" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 22, 2024</span><span class="posts_reading_time__f7YPP">6<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<h1>빅 데이터의 현재 상태</h1>
<p>지난 십 년 동안 빅 데이터 환경은 놀라운 변화를 겪었습니다. 이 빠르게 발전하는 분야에서 오늘날 사용 가능한 도구의 숫자는 엄청납니다 — 십 년 전과 비교하면 약 9배나 다양합니다.</p>
<p>이 다양성은 데이터 웨어하우스, 데이터 레이크, 레이크하우스로만 한정되지 않고, ETL (추출, 변환, 적재)에서 ELT (추출, 적재, 변환), EL (추출, 적재) 등의 처리 방법론까지 확대되었습니다. 선택의 폭증은 하나의 기술에 대한 전문가가 되는 일이 어렵다는 점을 복합화시키는 것으로, 결국 시간은 우리 모두에게 동등합니다!</p>
<p>SQL이 다양하고 다양한 이 생태계에서 데이터 변환의 선택 도구로 자리 잡았으며, 많은 데이터 처리 플랫폼에서 선택 언어로 자리잡았음을 입증하고 있습니다.</p>
<div class="content-ad"></div>
<p>다양한 도구 중 하나인 DuckDB가 큰 인기를 끌고 있어요! 알아맞히셨죠... DuckDB!</p>
<h1>DuckDB가 뭔지, 그리고 왜 신경 써야 할까요!?</h1>
<p>DuckDB는 빠르게 인기를 얻고 있는 인프로세스 SQL 분석 엔진입니다. 그 인기를 증명하는 인상적인 통계들이 있어요:</p>
<ul>
<li>PyPI에서 매달 170만 다운로드</li>
<li>GitHub에서 13,800개의 스타를 기록하며 Postgres와 같은 관심을 절반의 시간에 도달합니다.</li>
</ul>
<div class="content-ad"></div>
<img src="/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_0.png">
<ul>
<li>DuckDB는 DB-Engines의 트렌드 보고서에 의하면 Snowflake와 유사한 두 년간의 기간 동안 인기가 급증했습니다. 다음 몇 년 동안 주류가 될 것으로 전망되며, 현재 전통적인 데이터 웨어하우스에서 처리되는 일부 페이로드를 대체하는 것으로 잘 준비되어 있는 것으로 보입니다.</li>
</ul>
<img src="/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_1.png">
<p>DuckDB의 오픈 소스 성격은 영구적인 MIT 라이선스로 보장되어 있어 매력을 더합니다.</p>
<div class="content-ad"></div>
<h1>DuckDB의 주요 이점</h1>
<ul>
<li>설치의 용이성: DuckDB를 실행하는 것은 brew install duckdb(이것은 DuckDB CLI를 설치합니다)처럼 매우 간단합니다.</li>
<li>낮은 복잡성: 서버가 없다는 점 (DuckDB는 바이너리일 뿐입니다)로, 자격 증명, 액세스 제어 목록, 방화벽 구성 등과 같은 복잡한 작업이 필요하지 않습니다.</li>
<li>보편적 호환성: 매우 적은 종속성을 가지고 DuckDB는 이식성을 대표합니다. 심지어 브라우저에서도 실행할 수 있습니다!</li>
<li>DataFrame 통합: DuckDB의 Python 라이브러리는 Pandas DataFrames를 쿼리할 수 있는 능력을 갖고 있어 게임 체인저입니다! 직접 쿼리할 수 없는 어떤 시스템과도 통합 계층 또는 '접착제' 역할을 하여 데이터 처리의 변환 단계를 용이하게 합니다.</li>
<li>확장 기능: DuckDB는 유연한 확장 메커니즘을 가지고 있어 JSON 및 Parquet에서 데이터를 직접 읽거나 S3에서 데이터를 직접 읽는 경우와 같은 유연성을 제공합니다. 이 능력은 개발자들의 경험을 크게 향상시킵니다.</li>
<li>안정성과 효율성: DuckDB는 메모리 제한을 초과하는 작업 부담을 처리하도록 설계되었습니다 (일부 제한 사항이 있음). 이것은 분석 데이터셋이 사용 가능한 RAM보다 훨씬 크지만 디스크에 맞는 작은 경우에 특히 관련이 있으며, 이는 '싼' 및 쉽게 이용 가능한 하드웨어(예: 랩톱)를 사용하여 분석을 완료할 수 있도록 해줍니다.</li>
</ul>
<h1>실제 데이터 파이프라인에서의 DuckDB</h1>
<p>클라우드 기반 시스템과 비교할 때 DuckDB는 최소한의 요구 사항과 비용 효율성으로 두드러지게 나타납니다. DuckDB는 클라우드 계정, 할당량 또는 추가 비용이 필요하지 않습니다. 개발자의 랩톱에서 제품 설정까지 DuckDB의 일관성은 데이터가 스테일하거나 잘못될 경우 시간이 지남에 따라 발생하는 클라우드 기반 솔루션과는 대조적입니다.</p>
<div class="content-ad"></div>
<p>DuckDB의 간편한 실행은 데이터를 계산 노드로 이동하거나 VM/작업 오케스트레이션, 장애 처리와 같은 분산 시스템에서 볼 수 있는 일반적인 도전 과제를 우회합니다. Apple의 M1 SoC로 구동되는 클라우드 기반 또는 유사한 현대 기계의 성능은 DuckDB의 유용성을 더욱 향상시킵니다. 이는 대규모 데이터셋을 처리하는 단일 기계 처리 시나리오를 가능케 하죠. 실제로 매일 TB 단위의 데이터를 처리해야 하는 고객은 매우 적고, 이들은 모든 공개 클라우드에서 사용 가능한 CPU 성능보다 더 많은 CPU 성능이 필요하게 될 것입니다.</p>
<h1>SQL 구문 설탕</h1>
<p>DuckDB의 상대적인 신선함은 GROUP BY ALL, SELECT * EXCLUDE, ASOF JOINS 등과 같은 새로운 SQL 구문 개선을 도입할 수 있는 유연성을 제공합니다. 이러한 추가 기능은 SQL 쿼리를 더 직관적이고 가독성 있게 만들어줍니다. 아래 코드 스니펫을 살펴보세요:</p>
<pre><code class="hljs language-js">-- <span class="hljs-variable constant_">ANSI</span> <span class="hljs-variable constant_">SQL</span>에서 여러 필드로 그룹화
<span class="hljs-variable constant_">SELECT</span> country, city, region, postal_code, <span class="hljs-title function_">AVG</span>(price) <span class="hljs-variable constant_">AS</span> avg_price
<span class="hljs-variable constant_">FROM</span> customers
-- 집계되지 않는 필드는 여기서 반복되어야 함
<span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> country, city, region, postal_code;

-- <span class="hljs-title class_">DuckDB</span>에서 모두를 기준으로 그룹화
<span class="hljs-variable constant_">SELECT</span> country, city, region, postal_code, <span class="hljs-title function_">AVG</span>(price) <span class="hljs-variable constant_">AS</span> avg_price
-- 필드는 한 번만 나열됨. 코드 유지 관리가 더 쉬워집니다
<span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-variable constant_">ALL</span>;
</code></pre>
<div class="content-ad"></div>
<pre><code class="hljs language-js">-- <span class="hljs-string">'email'</span> 필드를 제외한 모든 데이터를 <span class="hljs-variable constant_">ANSI</span> <span class="hljs-variable constant_">SQL</span>에서 쿼리합니다.
<span class="hljs-variable constant_">SELECT</span> country, city, region, postal_code, address, phone_number
  <span class="hljs-comment">/*, email*/</span>
<span class="hljs-variable constant_">FROM</span> customers;

-- <span class="hljs-string">'email'</span> 필드를 제외한 모든 데이터를 <span class="hljs-title class_">DuckDB</span>에서 쿼리합니다.
<span class="hljs-variable constant_">SELECT</span> * <span class="hljs-variable constant_">EXCLUDE</span> (email) <span class="hljs-variable constant_">FROM</span> customers;
</code></pre>
<pre><code class="hljs language-js">-- <span class="hljs-string">'대략적으로'</span> 동일한 타임스탬프를 조인하는 것을 고려합니다.
-- <span class="hljs-variable constant_">ANSI</span> <span class="hljs-variable constant_">SQL</span>에서는 보통 이를 버킷화해야 합니다.
-- <span class="hljs-title class_">DuckDB</span>에서는 <span class="hljs-variable constant_">ASOF</span> <span class="hljs-variable constant_">JOIN</span>을 사용하여 동일한 결과를 더 간편하고 효율적으로 얻을 수 있습니다.
<span class="hljs-variable constant_">SELECT</span> events.<span class="hljs-property">id</span>, events.<span class="hljs-property">ts</span>, events.<span class="hljs-property">val</span>, metadata.<span class="hljs-property">details</span>
<span class="hljs-variable constant_">FROM</span> events
<span class="hljs-variable constant_">ASOF</span> <span class="hljs-variable constant_">JOIN</span> metadata <span class="hljs-title function_">USING</span>(id, ts);
</code></pre>
<h1>Pandas 데이터프레임 통합</h1>
<p>특히 Python 생태계에서 DuckDB의 중요한 장점은 Pandas 데이터프레임과의 원활한 통합 기능입니다. 이 기능은 다양한 소스에서 다양한 데이터셋을 병합하는 프로세스를 간소화하여 데이터 분석 및 변환 작업을 용이하게 합니다.</p>
<div class="content-ad"></div>
<p>예를 들어, Jupyter Notebook에서 다음을 수행할 수 있습니다 (영화 추천 시스템 데이터셋을 기반으로):</p>
<pre><code class="hljs language-js"># 의존성 설치
%pip install --quiet duckdb
%pip install --quiet jupysql
%pip install --quiet duckdb-engine
%pip install --quiet pandas
%pip install --quiet matplotlib
%pip install --quiet psycopg2-binary
%pip install --quiet dash
%pip install --quiet plotly

<span class="hljs-keyword">import</span> duckdb
<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd

# jupysql 로드 및 구성
%load_ext sql
%config <span class="hljs-title class_">SqlMagic</span>.<span class="hljs-property">autopandas</span> = <span class="hljs-title class_">True</span>
%config <span class="hljs-title class_">SqlMagic</span>.<span class="hljs-property">feedback</span> = <span class="hljs-title class_">False</span>
%config <span class="hljs-title class_">SqlMagic</span>.<span class="hljs-property">displaycon</span> = <span class="hljs-title class_">False</span>
%config <span class="hljs-title class_">SqlMagic</span>.<span class="hljs-property">named_parameters</span>=<span class="hljs-title class_">True</span>

# 로컬 <span class="hljs-title class_">DuckDB</span> 인스턴스에 연결
%sql <span class="hljs-attr">duckdb</span>:<span class="hljs-comment">///</span>

# <span class="hljs-title class_">DuckDB</span>를 사용하여 원격 파일 조회 활성화 (예: <span class="hljs-variable constant_">S3</span>)
%%sql
<span class="hljs-variable constant_">INSTALL</span> httpfs;
<span class="hljs-variable constant_">LOAD</span> httpfs;

# <span class="hljs-variable constant_">S3</span> 액세스 키 구성
<span class="hljs-variable constant_">SET</span> s3_region = <span class="hljs-string">'...'</span>;
<span class="hljs-variable constant_">SET</span> s3_access_key_id = <span class="hljs-string">'...'</span>;
<span class="hljs-variable constant_">SET</span> s3_secret_access_key = <span class="hljs-string">'...'</span>;

# 원격 <span class="hljs-title class_">Postgres</span> 데이터베이스에 연결
<span class="hljs-variable constant_">ATTACH</span> <span class="hljs-string">'dbname=DATABASE user=USER host=HOST password=PASSWORD connect_timeout=10'</span> <span class="hljs-variable constant_">AS</span> postgres (<span class="hljs-variable constant_">TYPE</span> postgres, <span class="hljs-variable constant_">READ_ONLY</span>);

# 쿼리를 실행하고 데이터프레임에 저장
%%sql
df &#x3C;&#x3C; <span class="hljs-variable constant_">SELECT</span> 
    t1.<span class="hljs-property">movieId</span>,
    t1.<span class="hljs-property">title</span>,
    t1.<span class="hljs-property">genres</span>,
    t2.<span class="hljs-property">userId</span>,
    t2.<span class="hljs-property">rating</span>,
    t3.<span class="hljs-property">tag</span>
  # <span class="hljs-title class_">Postgres</span>의 테이블 쿼리
  <span class="hljs-variable constant_">FROM</span> postgres.<span class="hljs-property">public</span>.<span class="hljs-property">movies</span> <span class="hljs-variable constant_">AS</span> t1
  # <span class="hljs-title class_">DuckDB</span>의 테이블과 조인
  <span class="hljs-variable constant_">INNER</span> <span class="hljs-variable constant_">JOIN</span> ratings <span class="hljs-variable constant_">AS</span> t2 <span class="hljs-variable constant_">USING</span> (movieId)
  # <span class="hljs-variable constant_">S3</span>의 <span class="hljs-title class_">JSON</span> 데이터셋과 조인
  <span class="hljs-variable constant_">INNER</span> <span class="hljs-variable constant_">JOIN</span> <span class="hljs-string">'s3://S3-BUCKET/tags.json'</span> <span class="hljs-variable constant_">AS</span> t3 <span class="hljs-variable constant_">USING</span> (userId, movieId)

# 마지막으로 다른 쿼리에서 데이터프레임을 참조
%%sql
by_genres &#x3C;&#x3C; <span class="hljs-variable constant_">SELECT</span> genres, <span class="hljs-title function_">COUNT</span>(*) <span class="hljs-variable constant_">AS</span> cnt 
             <span class="hljs-variable constant_">FROM</span> df
             <span class="hljs-variable constant_">GROUP</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-variable constant_">ALL</span>
             <span class="hljs-variable constant_">ORDER</span> <span class="hljs-variable constant_">BY</span> <span class="hljs-number">2</span> <span class="hljs-variable constant_">DESC</span>
             <span class="hljs-variable constant_">LIMIT</span> <span class="hljs-number">5</span>;

# 또는 변형된 데이터셋 플롯
<span class="hljs-keyword">import</span> plotly.<span class="hljs-property">express</span> <span class="hljs-keyword">as</span> px
fig = px.<span class="hljs-title function_">pie</span>(by_genres,
             values=<span class="hljs-string">'cnt'</span>,
             names=<span class="hljs-string">'genres'</span>,
             title=<span class="hljs-string">'Top 5 movie genres'</span>)
fig.<span class="hljs-title function_">show</span>()
</code></pre>
<h1>결론</h1>
<p>DuckDB의 개요를 통해 이 도구가 대용량 데이터 영역에서 다재다능하고 효율적이며 사용자 친화적인 잠재력을 갖고 있음을 강조했습니다. 상대적으로 새로운 참가자로서, 데이터 엔지니어와 소프트웨어 개발자들의 변화하는 요구에 부합하는 솔루션을 가능하게 하고 간극을 좁히는 독특한 위치에 있습니다.</p>
<div class="content-ad"></div>
<p>가장 일반적인 데이터 처리 사용 사례를 다루는 데 그 유틸리티와 다양성에 대해 자신이 있습니다. DuckDB와 관련한 여러분의 경험과 통찰력에 대해 듣고 싶습니다!</p>
<p>다음에 또 만나요 - 계속해서 쿼리해 보세요! 🦆</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"DuckDB 빅데이터 업계의 떠오르는 스타","description":"","date":"2024-06-22 17:38","slug":"2024-06-22-DuckDBTheRisingStarintheBigDataLandscape","content":"\n\n# 빅 데이터의 현재 상태\n\n지난 십 년 동안 빅 데이터 환경은 놀라운 변화를 겪었습니다. 이 빠르게 발전하는 분야에서 오늘날 사용 가능한 도구의 숫자는 엄청납니다 — 십 년 전과 비교하면 약 9배나 다양합니다.\n\n이 다양성은 데이터 웨어하우스, 데이터 레이크, 레이크하우스로만 한정되지 않고, ETL (추출, 변환, 적재)에서 ELT (추출, 적재, 변환), EL (추출, 적재) 등의 처리 방법론까지 확대되었습니다. 선택의 폭증은 하나의 기술에 대한 전문가가 되는 일이 어렵다는 점을 복합화시키는 것으로, 결국 시간은 우리 모두에게 동등합니다!\n\nSQL이 다양하고 다양한 이 생태계에서 데이터 변환의 선택 도구로 자리 잡았으며, 많은 데이터 처리 플랫폼에서 선택 언어로 자리잡았음을 입증하고 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n다양한 도구 중 하나인 DuckDB가 큰 인기를 끌고 있어요! 알아맞히셨죠... DuckDB!\n\n# DuckDB가 뭔지, 그리고 왜 신경 써야 할까요!?\n\nDuckDB는 빠르게 인기를 얻고 있는 인프로세스 SQL 분석 엔진입니다. 그 인기를 증명하는 인상적인 통계들이 있어요:\n\n- PyPI에서 매달 170만 다운로드\n- GitHub에서 13,800개의 스타를 기록하며 Postgres와 같은 관심을 절반의 시간에 도달합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n\u003cimg src=\"/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_0.png\" /\u003e\n\n- DuckDB는 DB-Engines의 트렌드 보고서에 의하면 Snowflake와 유사한 두 년간의 기간 동안 인기가 급증했습니다. 다음 몇 년 동안 주류가 될 것으로 전망되며, 현재 전통적인 데이터 웨어하우스에서 처리되는 일부 페이로드를 대체하는 것으로 잘 준비되어 있는 것으로 보입니다.\n\n\u003cimg src=\"/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_1.png\" /\u003e\n\nDuckDB의 오픈 소스 성격은 영구적인 MIT 라이선스로 보장되어 있어 매력을 더합니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n# DuckDB의 주요 이점\n\n- 설치의 용이성: DuckDB를 실행하는 것은 brew install duckdb(이것은 DuckDB CLI를 설치합니다)처럼 매우 간단합니다.\n- 낮은 복잡성: 서버가 없다는 점 (DuckDB는 바이너리일 뿐입니다)로, 자격 증명, 액세스 제어 목록, 방화벽 구성 등과 같은 복잡한 작업이 필요하지 않습니다.\n- 보편적 호환성: 매우 적은 종속성을 가지고 DuckDB는 이식성을 대표합니다. 심지어 브라우저에서도 실행할 수 있습니다!\n- DataFrame 통합: DuckDB의 Python 라이브러리는 Pandas DataFrames를 쿼리할 수 있는 능력을 갖고 있어 게임 체인저입니다! 직접 쿼리할 수 없는 어떤 시스템과도 통합 계층 또는 '접착제' 역할을 하여 데이터 처리의 변환 단계를 용이하게 합니다.\n- 확장 기능: DuckDB는 유연한 확장 메커니즘을 가지고 있어 JSON 및 Parquet에서 데이터를 직접 읽거나 S3에서 데이터를 직접 읽는 경우와 같은 유연성을 제공합니다. 이 능력은 개발자들의 경험을 크게 향상시킵니다.\n- 안정성과 효율성: DuckDB는 메모리 제한을 초과하는 작업 부담을 처리하도록 설계되었습니다 (일부 제한 사항이 있음). 이것은 분석 데이터셋이 사용 가능한 RAM보다 훨씬 크지만 디스크에 맞는 작은 경우에 특히 관련이 있으며, 이는 '싼' 및 쉽게 이용 가능한 하드웨어(예: 랩톱)를 사용하여 분석을 완료할 수 있도록 해줍니다.\n\n# 실제 데이터 파이프라인에서의 DuckDB\n\n클라우드 기반 시스템과 비교할 때 DuckDB는 최소한의 요구 사항과 비용 효율성으로 두드러지게 나타납니다. DuckDB는 클라우드 계정, 할당량 또는 추가 비용이 필요하지 않습니다. 개발자의 랩톱에서 제품 설정까지 DuckDB의 일관성은 데이터가 스테일하거나 잘못될 경우 시간이 지남에 따라 발생하는 클라우드 기반 솔루션과는 대조적입니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nDuckDB의 간편한 실행은 데이터를 계산 노드로 이동하거나 VM/작업 오케스트레이션, 장애 처리와 같은 분산 시스템에서 볼 수 있는 일반적인 도전 과제를 우회합니다. Apple의 M1 SoC로 구동되는 클라우드 기반 또는 유사한 현대 기계의 성능은 DuckDB의 유용성을 더욱 향상시킵니다. 이는 대규모 데이터셋을 처리하는 단일 기계 처리 시나리오를 가능케 하죠. 실제로 매일 TB 단위의 데이터를 처리해야 하는 고객은 매우 적고, 이들은 모든 공개 클라우드에서 사용 가능한 CPU 성능보다 더 많은 CPU 성능이 필요하게 될 것입니다.\n\n# SQL 구문 설탕\n\nDuckDB의 상대적인 신선함은 GROUP BY ALL, SELECT * EXCLUDE, ASOF JOINS 등과 같은 새로운 SQL 구문 개선을 도입할 수 있는 유연성을 제공합니다. 이러한 추가 기능은 SQL 쿼리를 더 직관적이고 가독성 있게 만들어줍니다. 아래 코드 스니펫을 살펴보세요:\n\n```js\n-- ANSI SQL에서 여러 필드로 그룹화\nSELECT country, city, region, postal_code, AVG(price) AS avg_price\nFROM customers\n-- 집계되지 않는 필드는 여기서 반복되어야 함\nGROUP BY country, city, region, postal_code;\n\n-- DuckDB에서 모두를 기준으로 그룹화\nSELECT country, city, region, postal_code, AVG(price) AS avg_price\n-- 필드는 한 번만 나열됨. 코드 유지 관리가 더 쉬워집니다\nGROUP BY ALL;\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n-- 'email' 필드를 제외한 모든 데이터를 ANSI SQL에서 쿼리합니다.\nSELECT country, city, region, postal_code, address, phone_number\n  /*, email*/\nFROM customers;\n\n-- 'email' 필드를 제외한 모든 데이터를 DuckDB에서 쿼리합니다.\nSELECT * EXCLUDE (email) FROM customers;\n```\n\n```js\n-- '대략적으로' 동일한 타임스탬프를 조인하는 것을 고려합니다.\n-- ANSI SQL에서는 보통 이를 버킷화해야 합니다.\n-- DuckDB에서는 ASOF JOIN을 사용하여 동일한 결과를 더 간편하고 효율적으로 얻을 수 있습니다.\nSELECT events.id, events.ts, events.val, metadata.details\nFROM events\nASOF JOIN metadata USING(id, ts);\n```\n\n# Pandas 데이터프레임 통합\n\n특히 Python 생태계에서 DuckDB의 중요한 장점은 Pandas 데이터프레임과의 원활한 통합 기능입니다. 이 기능은 다양한 소스에서 다양한 데이터셋을 병합하는 프로세스를 간소화하여 데이터 분석 및 변환 작업을 용이하게 합니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n예를 들어, Jupyter Notebook에서 다음을 수행할 수 있습니다 (영화 추천 시스템 데이터셋을 기반으로):\n\n```js\n# 의존성 설치\n%pip install --quiet duckdb\n%pip install --quiet jupysql\n%pip install --quiet duckdb-engine\n%pip install --quiet pandas\n%pip install --quiet matplotlib\n%pip install --quiet psycopg2-binary\n%pip install --quiet dash\n%pip install --quiet plotly\n\nimport duckdb\nimport pandas as pd\n\n# jupysql 로드 및 구성\n%load_ext sql\n%config SqlMagic.autopandas = True\n%config SqlMagic.feedback = False\n%config SqlMagic.displaycon = False\n%config SqlMagic.named_parameters=True\n\n# 로컬 DuckDB 인스턴스에 연결\n%sql duckdb:///\n\n# DuckDB를 사용하여 원격 파일 조회 활성화 (예: S3)\n%%sql\nINSTALL httpfs;\nLOAD httpfs;\n\n# S3 액세스 키 구성\nSET s3_region = '...';\nSET s3_access_key_id = '...';\nSET s3_secret_access_key = '...';\n\n# 원격 Postgres 데이터베이스에 연결\nATTACH 'dbname=DATABASE user=USER host=HOST password=PASSWORD connect_timeout=10' AS postgres (TYPE postgres, READ_ONLY);\n\n# 쿼리를 실행하고 데이터프레임에 저장\n%%sql\ndf \u003c\u003c SELECT \n    t1.movieId,\n    t1.title,\n    t1.genres,\n    t2.userId,\n    t2.rating,\n    t3.tag\n  # Postgres의 테이블 쿼리\n  FROM postgres.public.movies AS t1\n  # DuckDB의 테이블과 조인\n  INNER JOIN ratings AS t2 USING (movieId)\n  # S3의 JSON 데이터셋과 조인\n  INNER JOIN 's3://S3-BUCKET/tags.json' AS t3 USING (userId, movieId)\n\n# 마지막으로 다른 쿼리에서 데이터프레임을 참조\n%%sql\nby_genres \u003c\u003c SELECT genres, COUNT(*) AS cnt \n             FROM df\n             GROUP BY ALL\n             ORDER BY 2 DESC\n             LIMIT 5;\n\n# 또는 변형된 데이터셋 플롯\nimport plotly.express as px\nfig = px.pie(by_genres,\n             values='cnt',\n             names='genres',\n             title='Top 5 movie genres')\nfig.show()\n```\n\n# 결론\n\nDuckDB의 개요를 통해 이 도구가 대용량 데이터 영역에서 다재다능하고 효율적이며 사용자 친화적인 잠재력을 갖고 있음을 강조했습니다. 상대적으로 새로운 참가자로서, 데이터 엔지니어와 소프트웨어 개발자들의 변화하는 요구에 부합하는 솔루션을 가능하게 하고 간극을 좁히는 독특한 위치에 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n가장 일반적인 데이터 처리 사용 사례를 다루는 데 그 유틸리티와 다양성에 대해 자신이 있습니다. DuckDB와 관련한 여러분의 경험과 통찰력에 대해 듣고 싶습니다!\n\n다음에 또 만나요 - 계속해서 쿼리해 보세요! 🦆","ogImage":{"url":"/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_0.png"},"coverImage":"/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_0.png","tag":["Tech"],"readingTime":6},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003ch1\u003e빅 데이터의 현재 상태\u003c/h1\u003e\n\u003cp\u003e지난 십 년 동안 빅 데이터 환경은 놀라운 변화를 겪었습니다. 이 빠르게 발전하는 분야에서 오늘날 사용 가능한 도구의 숫자는 엄청납니다 — 십 년 전과 비교하면 약 9배나 다양합니다.\u003c/p\u003e\n\u003cp\u003e이 다양성은 데이터 웨어하우스, 데이터 레이크, 레이크하우스로만 한정되지 않고, ETL (추출, 변환, 적재)에서 ELT (추출, 적재, 변환), EL (추출, 적재) 등의 처리 방법론까지 확대되었습니다. 선택의 폭증은 하나의 기술에 대한 전문가가 되는 일이 어렵다는 점을 복합화시키는 것으로, 결국 시간은 우리 모두에게 동등합니다!\u003c/p\u003e\n\u003cp\u003eSQL이 다양하고 다양한 이 생태계에서 데이터 변환의 선택 도구로 자리 잡았으며, 많은 데이터 처리 플랫폼에서 선택 언어로 자리잡았음을 입증하고 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e다양한 도구 중 하나인 DuckDB가 큰 인기를 끌고 있어요! 알아맞히셨죠... DuckDB!\u003c/p\u003e\n\u003ch1\u003eDuckDB가 뭔지, 그리고 왜 신경 써야 할까요!?\u003c/h1\u003e\n\u003cp\u003eDuckDB는 빠르게 인기를 얻고 있는 인프로세스 SQL 분석 엔진입니다. 그 인기를 증명하는 인상적인 통계들이 있어요:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePyPI에서 매달 170만 다운로드\u003c/li\u003e\n\u003cli\u003eGitHub에서 13,800개의 스타를 기록하며 Postgres와 같은 관심을 절반의 시간에 도달합니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cimg src=\"/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_0.png\"\u003e\n\u003cul\u003e\n\u003cli\u003eDuckDB는 DB-Engines의 트렌드 보고서에 의하면 Snowflake와 유사한 두 년간의 기간 동안 인기가 급증했습니다. 다음 몇 년 동안 주류가 될 것으로 전망되며, 현재 전통적인 데이터 웨어하우스에서 처리되는 일부 페이로드를 대체하는 것으로 잘 준비되어 있는 것으로 보입니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"/assets/img/2024-06-22-DuckDBTheRisingStarintheBigDataLandscape_1.png\"\u003e\n\u003cp\u003eDuckDB의 오픈 소스 성격은 영구적인 MIT 라이선스로 보장되어 있어 매력을 더합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003ch1\u003eDuckDB의 주요 이점\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e설치의 용이성: DuckDB를 실행하는 것은 brew install duckdb(이것은 DuckDB CLI를 설치합니다)처럼 매우 간단합니다.\u003c/li\u003e\n\u003cli\u003e낮은 복잡성: 서버가 없다는 점 (DuckDB는 바이너리일 뿐입니다)로, 자격 증명, 액세스 제어 목록, 방화벽 구성 등과 같은 복잡한 작업이 필요하지 않습니다.\u003c/li\u003e\n\u003cli\u003e보편적 호환성: 매우 적은 종속성을 가지고 DuckDB는 이식성을 대표합니다. 심지어 브라우저에서도 실행할 수 있습니다!\u003c/li\u003e\n\u003cli\u003eDataFrame 통합: DuckDB의 Python 라이브러리는 Pandas DataFrames를 쿼리할 수 있는 능력을 갖고 있어 게임 체인저입니다! 직접 쿼리할 수 없는 어떤 시스템과도 통합 계층 또는 '접착제' 역할을 하여 데이터 처리의 변환 단계를 용이하게 합니다.\u003c/li\u003e\n\u003cli\u003e확장 기능: DuckDB는 유연한 확장 메커니즘을 가지고 있어 JSON 및 Parquet에서 데이터를 직접 읽거나 S3에서 데이터를 직접 읽는 경우와 같은 유연성을 제공합니다. 이 능력은 개발자들의 경험을 크게 향상시킵니다.\u003c/li\u003e\n\u003cli\u003e안정성과 효율성: DuckDB는 메모리 제한을 초과하는 작업 부담을 처리하도록 설계되었습니다 (일부 제한 사항이 있음). 이것은 분석 데이터셋이 사용 가능한 RAM보다 훨씬 크지만 디스크에 맞는 작은 경우에 특히 관련이 있으며, 이는 '싼' 및 쉽게 이용 가능한 하드웨어(예: 랩톱)를 사용하여 분석을 완료할 수 있도록 해줍니다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1\u003e실제 데이터 파이프라인에서의 DuckDB\u003c/h1\u003e\n\u003cp\u003e클라우드 기반 시스템과 비교할 때 DuckDB는 최소한의 요구 사항과 비용 효율성으로 두드러지게 나타납니다. DuckDB는 클라우드 계정, 할당량 또는 추가 비용이 필요하지 않습니다. 개발자의 랩톱에서 제품 설정까지 DuckDB의 일관성은 데이터가 스테일하거나 잘못될 경우 시간이 지남에 따라 발생하는 클라우드 기반 솔루션과는 대조적입니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eDuckDB의 간편한 실행은 데이터를 계산 노드로 이동하거나 VM/작업 오케스트레이션, 장애 처리와 같은 분산 시스템에서 볼 수 있는 일반적인 도전 과제를 우회합니다. Apple의 M1 SoC로 구동되는 클라우드 기반 또는 유사한 현대 기계의 성능은 DuckDB의 유용성을 더욱 향상시킵니다. 이는 대규모 데이터셋을 처리하는 단일 기계 처리 시나리오를 가능케 하죠. 실제로 매일 TB 단위의 데이터를 처리해야 하는 고객은 매우 적고, 이들은 모든 공개 클라우드에서 사용 가능한 CPU 성능보다 더 많은 CPU 성능이 필요하게 될 것입니다.\u003c/p\u003e\n\u003ch1\u003eSQL 구문 설탕\u003c/h1\u003e\n\u003cp\u003eDuckDB의 상대적인 신선함은 GROUP BY ALL, SELECT * EXCLUDE, ASOF JOINS 등과 같은 새로운 SQL 구문 개선을 도입할 수 있는 유연성을 제공합니다. 이러한 추가 기능은 SQL 쿼리를 더 직관적이고 가독성 있게 만들어줍니다. 아래 코드 스니펫을 살펴보세요:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e-- \u003cspan class=\"hljs-variable constant_\"\u003eANSI\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSQL\u003c/span\u003e에서 여러 필드로 그룹화\n\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e country, city, region, postal_code, \u003cspan class=\"hljs-title function_\"\u003eAVG\u003c/span\u003e(price) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e avg_price\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e customers\n-- 집계되지 않는 필드는 여기서 반복되어야 함\n\u003cspan class=\"hljs-variable constant_\"\u003eGROUP\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e country, city, region, postal_code;\n\n-- \u003cspan class=\"hljs-title class_\"\u003eDuckDB\u003c/span\u003e에서 모두를 기준으로 그룹화\n\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e country, city, region, postal_code, \u003cspan class=\"hljs-title function_\"\u003eAVG\u003c/span\u003e(price) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e avg_price\n-- 필드는 한 번만 나열됨. 코드 유지 관리가 더 쉬워집니다\n\u003cspan class=\"hljs-variable constant_\"\u003eGROUP\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eALL\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e-- \u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e 필드를 제외한 모든 데이터를 \u003cspan class=\"hljs-variable constant_\"\u003eANSI\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSQL\u003c/span\u003e에서 쿼리합니다.\n\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e country, city, region, postal_code, address, phone_number\n  \u003cspan class=\"hljs-comment\"\u003e/*, email*/\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e customers;\n\n-- \u003cspan class=\"hljs-string\"\u003e'email'\u003c/span\u003e 필드를 제외한 모든 데이터를 \u003cspan class=\"hljs-title class_\"\u003eDuckDB\u003c/span\u003e에서 쿼리합니다.\n\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e * \u003cspan class=\"hljs-variable constant_\"\u003eEXCLUDE\u003c/span\u003e (email) \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e customers;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e-- \u003cspan class=\"hljs-string\"\u003e'대략적으로'\u003c/span\u003e 동일한 타임스탬프를 조인하는 것을 고려합니다.\n-- \u003cspan class=\"hljs-variable constant_\"\u003eANSI\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eSQL\u003c/span\u003e에서는 보통 이를 버킷화해야 합니다.\n-- \u003cspan class=\"hljs-title class_\"\u003eDuckDB\u003c/span\u003e에서는 \u003cspan class=\"hljs-variable constant_\"\u003eASOF\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eJOIN\u003c/span\u003e을 사용하여 동일한 결과를 더 간편하고 효율적으로 얻을 수 있습니다.\n\u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e events.\u003cspan class=\"hljs-property\"\u003eid\u003c/span\u003e, events.\u003cspan class=\"hljs-property\"\u003ets\u003c/span\u003e, events.\u003cspan class=\"hljs-property\"\u003eval\u003c/span\u003e, metadata.\u003cspan class=\"hljs-property\"\u003edetails\u003c/span\u003e\n\u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e events\n\u003cspan class=\"hljs-variable constant_\"\u003eASOF\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eJOIN\u003c/span\u003e metadata \u003cspan class=\"hljs-title function_\"\u003eUSING\u003c/span\u003e(id, ts);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003ePandas 데이터프레임 통합\u003c/h1\u003e\n\u003cp\u003e특히 Python 생태계에서 DuckDB의 중요한 장점은 Pandas 데이터프레임과의 원활한 통합 기능입니다. 이 기능은 다양한 소스에서 다양한 데이터셋을 병합하는 프로세스를 간소화하여 데이터 분석 및 변환 작업을 용이하게 합니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e예를 들어, Jupyter Notebook에서 다음을 수행할 수 있습니다 (영화 추천 시스템 데이터셋을 기반으로):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e# 의존성 설치\n%pip install --quiet duckdb\n%pip install --quiet jupysql\n%pip install --quiet duckdb-engine\n%pip install --quiet pandas\n%pip install --quiet matplotlib\n%pip install --quiet psycopg2-binary\n%pip install --quiet dash\n%pip install --quiet plotly\n\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e duckdb\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pandas \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e pd\n\n# jupysql 로드 및 구성\n%load_ext sql\n%config \u003cspan class=\"hljs-title class_\"\u003eSqlMagic\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eautopandas\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n%config \u003cspan class=\"hljs-title class_\"\u003eSqlMagic\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003efeedback\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n%config \u003cspan class=\"hljs-title class_\"\u003eSqlMagic\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edisplaycon\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eFalse\u003c/span\u003e\n%config \u003cspan class=\"hljs-title class_\"\u003eSqlMagic\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003enamed_parameters\u003c/span\u003e=\u003cspan class=\"hljs-title class_\"\u003eTrue\u003c/span\u003e\n\n# 로컬 \u003cspan class=\"hljs-title class_\"\u003eDuckDB\u003c/span\u003e 인스턴스에 연결\n%sql \u003cspan class=\"hljs-attr\"\u003educkdb\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e///\u003c/span\u003e\n\n# \u003cspan class=\"hljs-title class_\"\u003eDuckDB\u003c/span\u003e를 사용하여 원격 파일 조회 활성화 (예: \u003cspan class=\"hljs-variable constant_\"\u003eS3\u003c/span\u003e)\n%%sql\n\u003cspan class=\"hljs-variable constant_\"\u003eINSTALL\u003c/span\u003e httpfs;\n\u003cspan class=\"hljs-variable constant_\"\u003eLOAD\u003c/span\u003e httpfs;\n\n# \u003cspan class=\"hljs-variable constant_\"\u003eS3\u003c/span\u003e 액세스 키 구성\n\u003cspan class=\"hljs-variable constant_\"\u003eSET\u003c/span\u003e s3_region = \u003cspan class=\"hljs-string\"\u003e'...'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable constant_\"\u003eSET\u003c/span\u003e s3_access_key_id = \u003cspan class=\"hljs-string\"\u003e'...'\u003c/span\u003e;\n\u003cspan class=\"hljs-variable constant_\"\u003eSET\u003c/span\u003e s3_secret_access_key = \u003cspan class=\"hljs-string\"\u003e'...'\u003c/span\u003e;\n\n# 원격 \u003cspan class=\"hljs-title class_\"\u003ePostgres\u003c/span\u003e 데이터베이스에 연결\n\u003cspan class=\"hljs-variable constant_\"\u003eATTACH\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e'dbname=DATABASE user=USER host=HOST password=PASSWORD connect_timeout=10'\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e postgres (\u003cspan class=\"hljs-variable constant_\"\u003eTYPE\u003c/span\u003e postgres, \u003cspan class=\"hljs-variable constant_\"\u003eREAD_ONLY\u003c/span\u003e);\n\n# 쿼리를 실행하고 데이터프레임에 저장\n%%sql\ndf \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e \n    t1.\u003cspan class=\"hljs-property\"\u003emovieId\u003c/span\u003e,\n    t1.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e,\n    t1.\u003cspan class=\"hljs-property\"\u003egenres\u003c/span\u003e,\n    t2.\u003cspan class=\"hljs-property\"\u003euserId\u003c/span\u003e,\n    t2.\u003cspan class=\"hljs-property\"\u003erating\u003c/span\u003e,\n    t3.\u003cspan class=\"hljs-property\"\u003etag\u003c/span\u003e\n  # \u003cspan class=\"hljs-title class_\"\u003ePostgres\u003c/span\u003e의 테이블 쿼리\n  \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e postgres.\u003cspan class=\"hljs-property\"\u003epublic\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emovies\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e t1\n  # \u003cspan class=\"hljs-title class_\"\u003eDuckDB\u003c/span\u003e의 테이블과 조인\n  \u003cspan class=\"hljs-variable constant_\"\u003eINNER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eJOIN\u003c/span\u003e ratings \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e t2 \u003cspan class=\"hljs-variable constant_\"\u003eUSING\u003c/span\u003e (movieId)\n  # \u003cspan class=\"hljs-variable constant_\"\u003eS3\u003c/span\u003e의 \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e 데이터셋과 조인\n  \u003cspan class=\"hljs-variable constant_\"\u003eINNER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eJOIN\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e's3://S3-BUCKET/tags.json'\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e t3 \u003cspan class=\"hljs-variable constant_\"\u003eUSING\u003c/span\u003e (userId, movieId)\n\n# 마지막으로 다른 쿼리에서 데이터프레임을 참조\n%%sql\nby_genres \u0026#x3C;\u0026#x3C; \u003cspan class=\"hljs-variable constant_\"\u003eSELECT\u003c/span\u003e genres, \u003cspan class=\"hljs-title function_\"\u003eCOUNT\u003c/span\u003e(*) \u003cspan class=\"hljs-variable constant_\"\u003eAS\u003c/span\u003e cnt \n             \u003cspan class=\"hljs-variable constant_\"\u003eFROM\u003c/span\u003e df\n             \u003cspan class=\"hljs-variable constant_\"\u003eGROUP\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eALL\u003c/span\u003e\n             \u003cspan class=\"hljs-variable constant_\"\u003eORDER\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eBY\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eDESC\u003c/span\u003e\n             \u003cspan class=\"hljs-variable constant_\"\u003eLIMIT\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e;\n\n# 또는 변형된 데이터셋 플롯\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e plotly.\u003cspan class=\"hljs-property\"\u003eexpress\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e px\nfig = px.\u003cspan class=\"hljs-title function_\"\u003epie\u003c/span\u003e(by_genres,\n             values=\u003cspan class=\"hljs-string\"\u003e'cnt'\u003c/span\u003e,\n             names=\u003cspan class=\"hljs-string\"\u003e'genres'\u003c/span\u003e,\n             title=\u003cspan class=\"hljs-string\"\u003e'Top 5 movie genres'\u003c/span\u003e)\nfig.\u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1\u003e결론\u003c/h1\u003e\n\u003cp\u003eDuckDB의 개요를 통해 이 도구가 대용량 데이터 영역에서 다재다능하고 효율적이며 사용자 친화적인 잠재력을 갖고 있음을 강조했습니다. 상대적으로 새로운 참가자로서, 데이터 엔지니어와 소프트웨어 개발자들의 변화하는 요구에 부합하는 솔루션을 가능하게 하고 간극을 좁히는 독특한 위치에 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e가장 일반적인 데이터 처리 사용 사례를 다루는 데 그 유틸리티와 다양성에 대해 자신이 있습니다. DuckDB와 관련한 여러분의 경험과 통찰력에 대해 듣고 싶습니다!\u003c/p\u003e\n\u003cp\u003e다음에 또 만나요 - 계속해서 쿼리해 보세요! 🦆\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-22-DuckDBTheRisingStarintheBigDataLandscape"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>