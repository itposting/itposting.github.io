<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><title>SSH  비밀번호 | itposting</title><meta name="description" content=""/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:url" content="https://itposting.github.io///post/2024-06-19-SSHPasswords" data-gatsby-head="true"/><meta property="og:type" content="website" data-gatsby-head="true"/><meta property="og:site_name" content="SSH  비밀번호 | itposting" data-gatsby-head="true"/><meta property="og:title" content="SSH  비밀번호 | itposting" data-gatsby-head="true"/><meta property="og:description" content="" data-gatsby-head="true"/><meta property="og:image" content="/assets/img/2024-06-19-SSHPasswords_0.png" data-gatsby-head="true"/><meta property="og:locale" content="en_US" data-gatsby-head="true"/><meta name="twitter:card" content="summary_large_image" data-gatsby-head="true"/><meta property="twitter:domain" content="https://itposting.github.io/" data-gatsby-head="true"/><meta property="twitter:url" content="https://itposting.github.io///post/2024-06-19-SSHPasswords" data-gatsby-head="true"/><meta name="twitter:title" content="SSH  비밀번호 | itposting" data-gatsby-head="true"/><meta name="twitter:description" content="" data-gatsby-head="true"/><meta name="twitter:image" content="/assets/img/2024-06-19-SSHPasswords_0.png" data-gatsby-head="true"/><meta name="twitter:data1" content="Dev | itposting" data-gatsby-head="true"/><meta name="article:published_time" content="2024-06-19 08:39" data-gatsby-head="true"/><meta name="next-head-count" content="19"/><meta name="google-site-verification" content="a-yehRo3k3xv7fg6LqRaE8jlE42e5wP2bDE_2F849O4"/><link rel="stylesheet" href="/favicons/favicon.ico"/><link rel="icon" type="image/png" sizes="16x16" href="/assets/favicons/favicon-16x16.png"/><link rel="icon" type="image/png" sizes="32x32" href="/assets/favicons/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="96x96" href="/assets/favicons/favicon-96x96.png"/><link rel="icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-icon" href="/favicons/apple-icon-180x180.png"/><link rel="apple-touch-startup-image" href="/startup.png"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-status-bar-style" content="black"/><meta name="msapplication-config" content="/favicons/browserconfig.xml"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-23YXDLKDCL"></script><script>window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
          
            gtag('config', 'G-23YXDLKDCL');</script><link rel="preload" href="/_next/static/css/6e57edcf9f2ce551.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6e57edcf9f2ce551.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8ef307c9aee1e34.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8ef307c9aee1e34.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-ee6df16fdc6dae4d.js" defer=""></script><script src="/_next/static/chunks/framework-46611630e39cfdeb.js" defer=""></script><script src="/_next/static/chunks/main-cf4a52eec9a970a0.js" defer=""></script><script src="/_next/static/chunks/pages/_app-6fae11262ee5c69b.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-ac4aa08aae62f90e.js" defer=""></script><script src="/_next/static/chunks/463-0429087d4c0b0335.js" defer=""></script><script src="/_next/static/chunks/pages/post/%5Bslug%5D-d849684d6d83f07a.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_buildManifest.js" defer=""></script><script src="/_next/static/QYe6gFAUryFKFgjKBoIfo/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="Header_header__Z8PUO"><div class="Header_inner__tfr0u"><strong class="Header_title__Otn70"><a href="/">IT Posting</a></strong><nav class="Header_nav_area__6KVpk"><a class="nav_item" href="/posts/1">Posts</a></nav></div></header><main class="posts_container__NyRU3"><div class="posts_inner__i3n_i"><h1 class="posts_post_title__EbxNx">SSH  비밀번호</h1><div class="posts_meta__cR7lu"><div class="posts_profile_wrap__mslMl"><div class="posts_profile_image_wrap__kPikV"><img alt="SSH  비밀번호" loading="lazy" width="44" height="44" decoding="async" data-nimg="1" class="profile" style="color:transparent" src="/favicons/apple-icon-114x114.png"/></div><div class="posts_textarea__w_iKT"><span class="writer">IT Posting</span><span class="posts_info__5KJdN"><span class="posts_date__ctqHI">Posted On Jun 19, 2024</span><span class="posts_reading_time__f7YPP">4<!-- --> min read</span></span></div></div><img alt="" loading="lazy" width="50" height="50" decoding="async" data-nimg="1" class="posts_view_badge__tcbfm" style="color:transparent" src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fallround-coder.github.io/post/2024-06-19-SSHPasswords&amp;count_bg=%2379C83D&amp;title_bg=%23555555&amp;icon=&amp;icon_color=%23E7E7E7&amp;title=views&amp;edge_flat=false"/></div><article class="posts_post_content__n_L6j"><div><!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
</head>
<body>
<p>아주 많은 사람들이 비밀번호와 그 작동 방식에 익숙합니다. 그래서 이 글에서는 SSH 키에 조금 더 초점을 맞추어 어떻게 작동하는지 살펴보겠습니다.</p>
<p>SSH가 무엇인가요?</p>
<p>SSH는 Secure Shell의 약자입니다. SSH는 컴퓨터가 리소스에 액세스하고 리눅스 서버에 변경을 가하는 데 사용되는 프로토콜입니다. 간단히 말해 SSH는 사용자가 파일과 같은 서버에 저장된 리소스를 볼 수 있고 변경할 수 있도록 해줍니다.</p>
<div class="content-ad"></div>
<p>SSH 키</p>
<p>SSH 키는 클라이언트 측 또는 사용자 컴퓨터에서 생성되는 암호화 키 세트로, 인증에 사용됩니다. 이를 통해 특정 개인만 서버 자원에 액세스할 수 있도록 보장합니다. 비밀번호가 작동하는 방식과 유사하지만 더 안전합니다. SSH 키는 쌍으로 생성됩니다. 공유되어서는 안 되는 비공개 키와 항상 사용자 장치에 보관되어야 하는 개인 키가 있으며, 다른 장치나 서버와의 SSH 액세스에 사용하려는 공개 키가 있습니다.</p>
<p>SSH 작동 방식</p>
<p>SSH 키를 사용하여 서버에 연결하는 것이 아마도 더 안전하고 번거롭지 않을 것입니다. 사용자가 서버에 액세스하려면 간단한 bash 명령을 입력하면 되며, 원격 서버는 사용자의 공개 키가 원격 서버의 authorized_keys 파일에 저장된 공개 키와 일치하는지 확인합니다. 일치하는 경우, 원격 서버는 무작위 문자열을 생성한 후 이를 암호화하여 SSH 터널을 통해 사용자에게 보냅니다. 암호화된 문자열을 수신한 사용자 장치는 자체 개인 키를 사용하여 이를 복호화합니다. 복호화된 문자열은 이전에 합의된 세션 ID와 결합되어 MD5 해시를 생성하며, 이러한 MD5 해시는 해당 서버에서 무작위 문자열과 세션 ID로 생성한 MD5 해시와 비교하기 위해 서버로 다시 보내집니다. 두 MD5 해시가 일치하는 경우 사용자는 서버에 액세스할 수 있습니다.</p>
<div class="content-ad"></div>
<p>이 방법으로 서버에 접속하는 것은 암호보다 더 안전합니다. 보통 사람들이 봇을 사용하여 암호를 추측하고 서버에 액세스하는 경우가 적기 때문입니다.</p>
<p>SSH 키 생성(리눅스)</p>
<p>SSH 키를 생성하기 전에 먼저 SSH 프로그램이 설치되어 있는지 확인해야 합니다. 대부분의 경우 리눅스에는 SSH가 미리 설치되어 있지만, 설치되어 있지 않은 경우 다음 명령을 실행하여 설치할 수 있습니다:</p>
<pre><code class="hljs language-js">sudo apt-get install openssh-server
</code></pre>
<div class="content-ad"></div>
<p>그런 다음 SSH 키 쌍을 생성하기 위해 다음 명령을 실행합니다:</p>
<pre><code class="hljs language-js">sudo ssh-keygen -t rsa
</code></pre>
<p>여기서 <code>-t</code> 플래그는 키페어를 생성할 때 사용할 알고리즘을 지정합니다. 우리의 경우 RSA 입니다. "t rsa" 부분을 제외하면 기본 알고리즘인 RSA를 사용하여 키가 생성됩니다.</p>
<p>위 명령을 실행한 후 우리는 키를 저장할 위치를 입력하라는 메시지를 받게 됩니다. 이 옵션을 비워두고 Enter를 누르면 키는 기본 위치인 /your_home/.ssh/id_rsa에 저장됩니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js"><span class="hljs-variable constant_">RSA</span> 키 쌍을 생성 중입니다.
키를 저장할 파일 이름을 입력하세요 (<span class="hljs-regexp">/your_home/</span>.<span class="hljs-property">ssh</span>/id_rsa):
</code></pre>
<p>그런 다음 패스프레이즈를 추가하라는 메시지가 나타납니다. 패스프레이즈를 추가하면 더 많은 보안층이 추가됩니다. 하지만 원하지 않는다면 패스프레이즈를 추가하지 않아도 됩니다. 패스프레이즈가 필요하지 않다면 이 부분을 비우고 엔터 키를 누르면 됩니다.</p>
<pre><code class="hljs language-js">패스프레이즈 입력 (패스프레이즈 없음 시 공백 입력):
</code></pre>
<p>위 단계를 완료하면 특정 위치에 키 쌍이 생성되며, 이제 해당 키를 사용하여 서버에 액세스할 수 있게 됩니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">당신의 식별 정보가 /your_home/.<span class="hljs-property">ssh</span>/id_rsa에 저장되었습니다.
당신의 공개 키가 /your_home/.<span class="hljs-property">ssh</span>/id_rsa.<span class="hljs-property">pub</span>에 저장되었습니다.
키 지문은:
<span class="hljs-title class_">SHA256</span>:/hk7MJ5n5aiqdfTVUZr+2Qt+qCiS7BIm5Iv0dxrc3ks user@host
키의 랜덤아트 이미지는:
+---[<span class="hljs-variable constant_">RSA</span> <span class="hljs-number">3072</span>]----+
|                .|
|               + |
|              +  |
| .           o . |
|o       S   . o  |
| + o. .<span class="hljs-property">oo</span>. ..  .<span class="hljs-property">o</span>|
|o = oooooEo+ ...o|
|.. o *o+=.*+o....|
|    =+=ooB=o.... |
+----[<span class="hljs-title class_">SHA256</span>]-----+
</code></pre>
<p>서버에 우리의 공개 키 추가하기</p>
<p>앞에서 말했듯이, 개인 키는 우리 장치에 남아 있어 누구와도 공유되어서는 안 되지만, 공개 키는 접속하려는 서버로 복사해야 합니다.</p>
<p>간단한 명령어로 우리의 공개 키 파일 내용에 접근할 수 있습니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-sh"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub
</code></pre>
<p>이 명령어를 입력하면 공개 키의 내용이 표시되며 이를 복사할 수 있습니다. 파일 이름은 키를 생성할 때 사용된 알고리즘에 따라 다를 수 있지만, 주로 공개 키는 ‘.pub’ 확장자로 끝나고 개인 키는 보통 ‘.pub’ 확장자를 가지지 않습니다.</p>
<p>서버에 암호 액세스 권한이 있고 SSH가 이미 설치되어 있는 경우, 우리의 공개 키 내용을 복사하여 authorized_keys 파일에 붙여넣을 수 있습니다. 이렇게 하면 권한 없는 키를 가진 사람들이 서버에 액세스하는 것을 방지할 수 있습니다. 아래 간단한 bash 명령어로 이 모든 작업을 수행할 수 있습니다:</p>
<pre><code class="hljs language-sh">ssh-copy-id user@remote_server
</code></pre>
<div class="content-ad"></div>
<p>원격 서버에 사용자명을 본인의 사용자명으로 변경하고 원격 서버를 호스트 이름 또는 IP 주소로 바꿉니다.</p>
<p>비밀번호를 입력하고 나면 공개 키가 "/etc/ssh/authorized_keys" 위치로 복사됩니다.</p>
<p>SSH를 사용하여 원격 서버에 연결합니다.</p>
<p>이제 간단한 명령을 사용하여 원격 서버에 연결할 수 있습니다. 이렇게 하면 로컬 머신에 쓴 명령이 암호화되어 SSH 터널을 통해 전송되고 원격 서버에서 해독되어 실행됩니다.</p>
<div class="content-ad"></div>
<pre><code class="hljs language-js">ssh user@remote_server
</code></pre>
<p>지금부터 로컬 머신에서 입력하는 모든 명령이 원격 서버에서 실행됩니다. 세션을 종료하기 전까지는 보통 간단한 exit 명령으로 세션을 종료할 수 있습니다.</p>
<pre><code class="hljs language-js">exit
</code></pre>
<p>맺음말</p>
<div class="content-ad"></div>
<p>마지막으로, 원격 서버에 액세스하는 경우 SSH 키가 더 안전한 옵션이며 표준이어야 한다고 생각합니다.</p>
<p>이에 대해 토론하고 싶거나 다른 주제에 대해 이야기하고 싶으시면 언제든지 <a href="mailto:mitchkodes@gmail.com">mitchkodes@gmail.com</a> 또는 모든 소셜 미디어 플랫폼에서 @mitch_codes로 연락 주십시오. 시간 내 주셔서 감사합니다.</p>
</body>
</html>
</div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"SSH  비밀번호","description":"","date":"2024-06-19 08:39","slug":"2024-06-19-SSHPasswords","content":"\n\n아주 많은 사람들이 비밀번호와 그 작동 방식에 익숙합니다. 그래서 이 글에서는 SSH 키에 조금 더 초점을 맞추어 어떻게 작동하는지 살펴보겠습니다.\n\nSSH가 무엇인가요?\n\nSSH는 Secure Shell의 약자입니다. SSH는 컴퓨터가 리소스에 액세스하고 리눅스 서버에 변경을 가하는 데 사용되는 프로토콜입니다. 간단히 말해 SSH는 사용자가 파일과 같은 서버에 저장된 리소스를 볼 수 있고 변경할 수 있도록 해줍니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\nSSH 키\n\nSSH 키는 클라이언트 측 또는 사용자 컴퓨터에서 생성되는 암호화 키 세트로, 인증에 사용됩니다. 이를 통해 특정 개인만 서버 자원에 액세스할 수 있도록 보장합니다. 비밀번호가 작동하는 방식과 유사하지만 더 안전합니다. SSH 키는 쌍으로 생성됩니다. 공유되어서는 안 되는 비공개 키와 항상 사용자 장치에 보관되어야 하는 개인 키가 있으며, 다른 장치나 서버와의 SSH 액세스에 사용하려는 공개 키가 있습니다.\n\nSSH 작동 방식\n\nSSH 키를 사용하여 서버에 연결하는 것이 아마도 더 안전하고 번거롭지 않을 것입니다. 사용자가 서버에 액세스하려면 간단한 bash 명령을 입력하면 되며, 원격 서버는 사용자의 공개 키가 원격 서버의 authorized_keys 파일에 저장된 공개 키와 일치하는지 확인합니다. 일치하는 경우, 원격 서버는 무작위 문자열을 생성한 후 이를 암호화하여 SSH 터널을 통해 사용자에게 보냅니다. 암호화된 문자열을 수신한 사용자 장치는 자체 개인 키를 사용하여 이를 복호화합니다. 복호화된 문자열은 이전에 합의된 세션 ID와 결합되어 MD5 해시를 생성하며, 이러한 MD5 해시는 해당 서버에서 무작위 문자열과 세션 ID로 생성한 MD5 해시와 비교하기 위해 서버로 다시 보내집니다. 두 MD5 해시가 일치하는 경우 사용자는 서버에 액세스할 수 있습니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n이 방법으로 서버에 접속하는 것은 암호보다 더 안전합니다. 보통 사람들이 봇을 사용하여 암호를 추측하고 서버에 액세스하는 경우가 적기 때문입니다.\n\nSSH 키 생성(리눅스)\n\nSSH 키를 생성하기 전에 먼저 SSH 프로그램이 설치되어 있는지 확인해야 합니다. 대부분의 경우 리눅스에는 SSH가 미리 설치되어 있지만, 설치되어 있지 않은 경우 다음 명령을 실행하여 설치할 수 있습니다:\n\n```js\nsudo apt-get install openssh-server\n```\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n그런 다음 SSH 키 쌍을 생성하기 위해 다음 명령을 실행합니다:\n\n```js\nsudo ssh-keygen -t rsa\n```\n\n여기서 `-t` 플래그는 키페어를 생성할 때 사용할 알고리즘을 지정합니다. 우리의 경우 RSA 입니다. \"t rsa\" 부분을 제외하면 기본 알고리즘인 RSA를 사용하여 키가 생성됩니다.\n\n위 명령을 실행한 후 우리는 키를 저장할 위치를 입력하라는 메시지를 받게 됩니다. 이 옵션을 비워두고 Enter를 누르면 키는 기본 위치인 /your_home/.ssh/id_rsa에 저장됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nRSA 키 쌍을 생성 중입니다.\n키를 저장할 파일 이름을 입력하세요 (/your_home/.ssh/id_rsa):\n```\n\n그런 다음 패스프레이즈를 추가하라는 메시지가 나타납니다. 패스프레이즈를 추가하면 더 많은 보안층이 추가됩니다. 하지만 원하지 않는다면 패스프레이즈를 추가하지 않아도 됩니다. 패스프레이즈가 필요하지 않다면 이 부분을 비우고 엔터 키를 누르면 됩니다.\n\n```js\n패스프레이즈 입력 (패스프레이즈 없음 시 공백 입력):\n```\n\n위 단계를 완료하면 특정 위치에 키 쌍이 생성되며, 이제 해당 키를 사용하여 서버에 액세스할 수 있게 됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\n당신의 식별 정보가 /your_home/.ssh/id_rsa에 저장되었습니다.\n당신의 공개 키가 /your_home/.ssh/id_rsa.pub에 저장되었습니다.\n키 지문은:\nSHA256:/hk7MJ5n5aiqdfTVUZr+2Qt+qCiS7BIm5Iv0dxrc3ks user@host\n키의 랜덤아트 이미지는:\n+---[RSA 3072]----+\n|                .|\n|               + |\n|              +  |\n| .           o . |\n|o       S   . o  |\n| + o. .oo. ..  .o|\n|o = oooooEo+ ...o|\n|.. o *o+=.*+o....|\n|    =+=ooB=o.... |\n+----[SHA256]-----+\n```\n\n서버에 우리의 공개 키 추가하기\n\n앞에서 말했듯이, 개인 키는 우리 장치에 남아 있어 누구와도 공유되어서는 안 되지만, 공개 키는 접속하려는 서버로 복사해야 합니다.\n\n간단한 명령어로 우리의 공개 키 파일 내용에 접근할 수 있습니다.\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```sh\ncat ~/.ssh/id_rsa.pub\n```\n\n이 명령어를 입력하면 공개 키의 내용이 표시되며 이를 복사할 수 있습니다. 파일 이름은 키를 생성할 때 사용된 알고리즘에 따라 다를 수 있지만, 주로 공개 키는 ‘.pub’ 확장자로 끝나고 개인 키는 보통 ‘.pub’ 확장자를 가지지 않습니다.\n\n서버에 암호 액세스 권한이 있고 SSH가 이미 설치되어 있는 경우, 우리의 공개 키 내용을 복사하여 authorized_keys 파일에 붙여넣을 수 있습니다. 이렇게 하면 권한 없는 키를 가진 사람들이 서버에 액세스하는 것을 방지할 수 있습니다. 아래 간단한 bash 명령어로 이 모든 작업을 수행할 수 있습니다:\n\n```sh\nssh-copy-id user@remote_server\n```  \n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n원격 서버에 사용자명을 본인의 사용자명으로 변경하고 원격 서버를 호스트 이름 또는 IP 주소로 바꿉니다.\n\n비밀번호를 입력하고 나면 공개 키가 \"/etc/ssh/authorized_keys\" 위치로 복사됩니다.\n\nSSH를 사용하여 원격 서버에 연결합니다.\n\n이제 간단한 명령을 사용하여 원격 서버에 연결할 수 있습니다. 이렇게 하면 로컬 머신에 쓴 명령이 암호화되어 SSH 터널을 통해 전송되고 원격 서버에서 해독되어 실행됩니다.\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n```js\nssh user@remote_server\n```\n\n지금부터 로컬 머신에서 입력하는 모든 명령이 원격 서버에서 실행됩니다. 세션을 종료하기 전까지는 보통 간단한 exit 명령으로 세션을 종료할 수 있습니다.\n\n```js\nexit\n```\n\n맺음말\n\n\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\n마지막으로, 원격 서버에 액세스하는 경우 SSH 키가 더 안전한 옵션이며 표준이어야 한다고 생각합니다.\n\n이에 대해 토론하고 싶거나 다른 주제에 대해 이야기하고 싶으시면 언제든지 mitchkodes@gmail.com 또는 모든 소셜 미디어 플랫폼에서 @mitch_codes로 연락 주십시오. 시간 내 주셔서 감사합니다.","ogImage":{"url":"/assets/img/2024-06-19-SSHPasswords_0.png"},"coverImage":"/assets/img/2024-06-19-SSHPasswords_0.png","tag":["Tech"],"readingTime":4},"content":"\u003c!doctype html\u003e\n\u003chtml lang=\"en\"\u003e\n\u003chead\u003e\n\u003cmeta charset=\"utf-8\"\u003e\n\u003cmeta content=\"width=device-width, initial-scale=1\" name=\"viewport\"\u003e\n\u003c/head\u003e\n\u003cbody\u003e\n\u003cp\u003e아주 많은 사람들이 비밀번호와 그 작동 방식에 익숙합니다. 그래서 이 글에서는 SSH 키에 조금 더 초점을 맞추어 어떻게 작동하는지 살펴보겠습니다.\u003c/p\u003e\n\u003cp\u003eSSH가 무엇인가요?\u003c/p\u003e\n\u003cp\u003eSSH는 Secure Shell의 약자입니다. SSH는 컴퓨터가 리소스에 액세스하고 리눅스 서버에 변경을 가하는 데 사용되는 프로토콜입니다. 간단히 말해 SSH는 사용자가 파일과 같은 서버에 저장된 리소스를 볼 수 있고 변경할 수 있도록 해줍니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003eSSH 키\u003c/p\u003e\n\u003cp\u003eSSH 키는 클라이언트 측 또는 사용자 컴퓨터에서 생성되는 암호화 키 세트로, 인증에 사용됩니다. 이를 통해 특정 개인만 서버 자원에 액세스할 수 있도록 보장합니다. 비밀번호가 작동하는 방식과 유사하지만 더 안전합니다. SSH 키는 쌍으로 생성됩니다. 공유되어서는 안 되는 비공개 키와 항상 사용자 장치에 보관되어야 하는 개인 키가 있으며, 다른 장치나 서버와의 SSH 액세스에 사용하려는 공개 키가 있습니다.\u003c/p\u003e\n\u003cp\u003eSSH 작동 방식\u003c/p\u003e\n\u003cp\u003eSSH 키를 사용하여 서버에 연결하는 것이 아마도 더 안전하고 번거롭지 않을 것입니다. 사용자가 서버에 액세스하려면 간단한 bash 명령을 입력하면 되며, 원격 서버는 사용자의 공개 키가 원격 서버의 authorized_keys 파일에 저장된 공개 키와 일치하는지 확인합니다. 일치하는 경우, 원격 서버는 무작위 문자열을 생성한 후 이를 암호화하여 SSH 터널을 통해 사용자에게 보냅니다. 암호화된 문자열을 수신한 사용자 장치는 자체 개인 키를 사용하여 이를 복호화합니다. 복호화된 문자열은 이전에 합의된 세션 ID와 결합되어 MD5 해시를 생성하며, 이러한 MD5 해시는 해당 서버에서 무작위 문자열과 세션 ID로 생성한 MD5 해시와 비교하기 위해 서버로 다시 보내집니다. 두 MD5 해시가 일치하는 경우 사용자는 서버에 액세스할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e이 방법으로 서버에 접속하는 것은 암호보다 더 안전합니다. 보통 사람들이 봇을 사용하여 암호를 추측하고 서버에 액세스하는 경우가 적기 때문입니다.\u003c/p\u003e\n\u003cp\u003eSSH 키 생성(리눅스)\u003c/p\u003e\n\u003cp\u003eSSH 키를 생성하기 전에 먼저 SSH 프로그램이 설치되어 있는지 확인해야 합니다. 대부분의 경우 리눅스에는 SSH가 미리 설치되어 있지만, 설치되어 있지 않은 경우 다음 명령을 실행하여 설치할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esudo apt-get install openssh-server\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e그런 다음 SSH 키 쌍을 생성하기 위해 다음 명령을 실행합니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003esudo ssh-keygen -t rsa\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e여기서 \u003ccode\u003e-t\u003c/code\u003e 플래그는 키페어를 생성할 때 사용할 알고리즘을 지정합니다. 우리의 경우 RSA 입니다. \"t rsa\" 부분을 제외하면 기본 알고리즘인 RSA를 사용하여 키가 생성됩니다.\u003c/p\u003e\n\u003cp\u003e위 명령을 실행한 후 우리는 키를 저장할 위치를 입력하라는 메시지를 받게 됩니다. 이 옵션을 비워두고 Enter를 누르면 키는 기본 위치인 /your_home/.ssh/id_rsa에 저장됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e\u003cspan class=\"hljs-variable constant_\"\u003eRSA\u003c/span\u003e 키 쌍을 생성 중입니다.\n키를 저장할 파일 이름을 입력하세요 (\u003cspan class=\"hljs-regexp\"\u003e/your_home/\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003essh\u003c/span\u003e/id_rsa):\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그런 다음 패스프레이즈를 추가하라는 메시지가 나타납니다. 패스프레이즈를 추가하면 더 많은 보안층이 추가됩니다. 하지만 원하지 않는다면 패스프레이즈를 추가하지 않아도 됩니다. 패스프레이즈가 필요하지 않다면 이 부분을 비우고 엔터 키를 누르면 됩니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e패스프레이즈 입력 (패스프레이즈 없음 시 공백 입력):\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 단계를 완료하면 특정 위치에 키 쌍이 생성되며, 이제 해당 키를 사용하여 서버에 액세스할 수 있게 됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003e당신의 식별 정보가 /your_home/.\u003cspan class=\"hljs-property\"\u003essh\u003c/span\u003e/id_rsa에 저장되었습니다.\n당신의 공개 키가 /your_home/.\u003cspan class=\"hljs-property\"\u003essh\u003c/span\u003e/id_rsa.\u003cspan class=\"hljs-property\"\u003epub\u003c/span\u003e에 저장되었습니다.\n키 지문은:\n\u003cspan class=\"hljs-title class_\"\u003eSHA256\u003c/span\u003e:/hk7MJ5n5aiqdfTVUZr+2Qt+qCiS7BIm5Iv0dxrc3ks user@host\n키의 랜덤아트 이미지는:\n+---[\u003cspan class=\"hljs-variable constant_\"\u003eRSA\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3072\u003c/span\u003e]----+\n|                .|\n|               + |\n|              +  |\n| .           o . |\n|o       S   . o  |\n| + o. .\u003cspan class=\"hljs-property\"\u003eoo\u003c/span\u003e. ..  .\u003cspan class=\"hljs-property\"\u003eo\u003c/span\u003e|\n|o = oooooEo+ ...o|\n|.. o *o+=.*+o....|\n|    =+=ooB=o.... |\n+----[\u003cspan class=\"hljs-title class_\"\u003eSHA256\u003c/span\u003e]-----+\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e서버에 우리의 공개 키 추가하기\u003c/p\u003e\n\u003cp\u003e앞에서 말했듯이, 개인 키는 우리 장치에 남아 있어 누구와도 공유되어서는 안 되지만, 공개 키는 접속하려는 서버로 복사해야 합니다.\u003c/p\u003e\n\u003cp\u003e간단한 명령어로 우리의 공개 키 파일 내용에 접근할 수 있습니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sh\"\u003e\u003cspan class=\"hljs-built_in\"\u003ecat\u003c/span\u003e ~/.ssh/id_rsa.pub\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 명령어를 입력하면 공개 키의 내용이 표시되며 이를 복사할 수 있습니다. 파일 이름은 키를 생성할 때 사용된 알고리즘에 따라 다를 수 있지만, 주로 공개 키는 ‘.pub’ 확장자로 끝나고 개인 키는 보통 ‘.pub’ 확장자를 가지지 않습니다.\u003c/p\u003e\n\u003cp\u003e서버에 암호 액세스 권한이 있고 SSH가 이미 설치되어 있는 경우, 우리의 공개 키 내용을 복사하여 authorized_keys 파일에 붙여넣을 수 있습니다. 이렇게 하면 권한 없는 키를 가진 사람들이 서버에 액세스하는 것을 방지할 수 있습니다. 아래 간단한 bash 명령어로 이 모든 작업을 수행할 수 있습니다:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-sh\"\u003essh-copy-id user@remote_server\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e원격 서버에 사용자명을 본인의 사용자명으로 변경하고 원격 서버를 호스트 이름 또는 IP 주소로 바꿉니다.\u003c/p\u003e\n\u003cp\u003e비밀번호를 입력하고 나면 공개 키가 \"/etc/ssh/authorized_keys\" 위치로 복사됩니다.\u003c/p\u003e\n\u003cp\u003eSSH를 사용하여 원격 서버에 연결합니다.\u003c/p\u003e\n\u003cp\u003e이제 간단한 명령을 사용하여 원격 서버에 연결할 수 있습니다. 이렇게 하면 로컬 머신에 쓴 명령이 암호화되어 SSH 터널을 통해 전송되고 원격 서버에서 해독되어 실행됩니다.\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003essh user@remote_server\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e지금부터 로컬 머신에서 입력하는 모든 명령이 원격 서버에서 실행됩니다. 세션을 종료하기 전까지는 보통 간단한 exit 명령으로 세션을 종료할 수 있습니다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-js\"\u003eexit\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e맺음말\u003c/p\u003e\n\u003cdiv class=\"content-ad\"\u003e\u003c/div\u003e\n\u003cp\u003e마지막으로, 원격 서버에 액세스하는 경우 SSH 키가 더 안전한 옵션이며 표준이어야 한다고 생각합니다.\u003c/p\u003e\n\u003cp\u003e이에 대해 토론하고 싶거나 다른 주제에 대해 이야기하고 싶으시면 언제든지 \u003ca href=\"mailto:mitchkodes@gmail.com\"\u003emitchkodes@gmail.com\u003c/a\u003e 또는 모든 소셜 미디어 플랫폼에서 @mitch_codes로 연락 주십시오. 시간 내 주셔서 감사합니다.\u003c/p\u003e\n\u003c/body\u003e\n\u003c/html\u003e\n"},"__N_SSG":true},"page":"/post/[slug]","query":{"slug":"2024-06-19-SSHPasswords"},"buildId":"QYe6gFAUryFKFgjKBoIfo","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>