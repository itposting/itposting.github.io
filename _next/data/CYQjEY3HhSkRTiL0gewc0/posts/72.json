{"pageProps":{"posts":[{"title":"기계 공학 스킬 향상을 위한 확인된 온라인 강좌 상위 50개","description":"","date":"2024-06-19 17:29","slug":"2024-06-19-MechanicalEngineeringTop50VerifiedOnlineCoursesforSkillEnhancement","content":"\n\n온라인 교육을 통해 집에서 편안하게 필요한 기술을 습득할 수 있다는 것이 매우 흥미로운 점입니다. 세계 어디에서든 이점을 누릴 수 있어요.\n\n기본부터 시작해 볼까요? 오픈 온라인 강좌란 정확히 무엇인가요?\n\n대규모 온라인 강좌(MOOC)는 무제한 참여와 웹을 통한 자유로운 접근을 목표로 하는 온라인 강좌를 의미합니다. (출처: 위키피디아)\n\n10년 전, 나는 기계 및 항공우주 공학 학부생으로서 온라인 교육의 힘을 활용하기 시작했습니다. 그때부터 기계 공학 기술을 확장하기 위한 노력으로 전 세계의 명문 대학으로부터 14개의 검증된 자격증을 획득했습니다. 또한, 비인증 트랙에서 50개 이상의 강좌를 수료함으로써 소중한 지식을 얻었습니다.\n\n<div class=\"content-ad\"></div>\n\n이 문서에서는 세계적으로 유명한 대학들이 제공하는 무료 및 검증된 기계 공학 과목(MOOCs) 목록을 정리했습니다.\n\n내 목록에 있는 강좌의 주요 출처는 다음과 같습니다:\n\n- edX\n- Coursera\n\n<div class=\"content-ad\"></div>\n\n- NPTEL (National Program on Technology Enhanced Learning)\n- MIT OpenCourseWare (OCW)\n\n이 글은 학술 기관에서 제공하는 과정에만 초점을 맞추고 있음을 알려드립니다. YouTube, LinkedIn Learning 및 Udemy와 같은 플랫폼에서도 놀라운 학습 자료가 있으니, 미래 글에서 살펴볼 계획입니다.\n\n# 과정 카테고리\n\n<div class=\"content-ad\"></div>\n\n현재 및 과거 MOOC(Massive Open Online Course)를 다양한 제공업체에서 철저히 조사한 결과, 이러한 강좌들을 아래 기사 이미지에 나와 있는 8 개 부문으로 분류했습니다:\n\n제조업, 제품 개발, 구조 공학, 소재 공학, 의료 기기, 자동차, 로봇 공학, 기타\n\n리스트를 자세히 살펴보기 전에 특집 온라인 강좌 제공 업체로부터 MOOC에 접근하는 방법에 대한 주요 내용을 살펴보겠습니다:\n\nedX:\n\n\n<div class=\"content-ad\"></div>\n\n대부분의 edX 코스는 무료로 강의를 청강할 수 있어요. 이를 통해 당신의 속도로 편안하게 강의를 수강하고 모든 자료와 강의에 무료로 접근할 수 있어요. 하지만, 코스 완료를 증명하는 인증서를 받고 싶다면 일반적으로 수수료를 지불해야 해요. 인증서는 수수료가 발생할 수 있지만, 전체 비용을 지불할 수 없는 사람들을 위한 재정 지원도 제공돼요. 저 또한 몇 번의 경우 수강료의 90%까지를 지원받아 큰 도움을 받았어요.\n\nCoursera:\n\nCoursera도 무료 강의 청강을 제공하며, 자료에 접근할 수 있지만 과제 평가와 인증서는 제외돼요. 그럼에도 불구하고, 코스 콘텐츠와 학습 자료에 대한 광범위한 접근이 가능해요.\n\n<div class=\"content-ad\"></div>\n\n학습자들은 무료로 NPTEL 코스에 등록할 수 있어요. 이를 통해 강의 비디오, 과제, 그리고 퀴즈를 포함한 코스 콘텐츠에 접속할 수 있어요. 일반적으로 수료 후 인증을 받기 위해서는 수수료가 필요하며, 이는 선택 사항이며 행정 비용을 포함해요. 인증이 필수적이지 않다면 무료로 교육 콘텐츠에 여전히 접속할 수 있어요.\n\nMIT OCW:\n\nMIT OpenCourseWare은 완전히 무료이며 일반인에게 개방돼 있어요. 강의 노트, 과제, 시험, 그리고 추가 자료에 접근할 수 있어요.\n\n# 교육과정 목록:\n\n<div class=\"content-ad\"></div>\n\n이곳은 온라인 개방형 강좌들의 종합 목록입니다:\n\n제조업:\n\n1. 제조 공정 기본지식 — 매사추세츠 공과대학교 edX (MITx)에서 진행\n(마이클 좋아하는 강좌, MIT의 존 하트 교수님 강의)\n\n2. Monozukuri: 물건 만들기 — 도쿄 공과대학교 edX (TokyoTechX)에서 진행\n\n<div class=\"content-ad\"></div>\n\n3. 컴퓨터 수치 제어 소개 — TenarisUniversity on edX (Tenaris Corporate)\n\n4. 3D 프린팅과 첨가 제조: 5개 과정의 전문화 — 쿠르세라의 일리노이 대학\n\n5. 기계의 작동 방법과 이유 — MIT OpenCourseWare\n\n6. 기계 설계 파트 I — 조지아 공과대학의 쿠르세라\n\n<div class=\"content-ad\"></div>\n\n제품 디자인 및 개발:\n\n1. 제품 디자인, 프로토타이핑 및 테스트 — edX의 메릴랜드 주립 대학교\n\n2. 공학 및 디자인 소개 — edX의 브라운 대학교 (BrownX)\n\n3. 제품 디자인: 델프트 디자인 접근법 — edX의 델프트 공과대학 (DelftX)\n\n<div class=\"content-ad\"></div>\n\n4. 엔지니어링 및 제품 디자인 프로세스 - Coursera의 애리조나 주립 대학교\n\n5. 제품 디자인 및 개발 - MIT OpenCourseWare 프로젝트 기반 강좌\n\n6. 디자인 및 제조 I - MIT OpenCourseWare\n\n7. 디자인 및 제조 II - MIT OpenCourseWare\n\n<div class=\"content-ad\"></div>\n\n8. 제품 디자인 및 제조 - 인도 기술 연구소, 캔푸르 (IIT)의 NPTEL\n\n구조공학:\n\n1. 우리 주변 구조물의 공학 - edX의 다트머스 대학교 (DartmouthX)\n\n2. 구조공학의 예술: 다리 - edX의 프린스턴 대학교 (PrincetonX)\n\n<div class=\"content-ad\"></div>\n\n3. The Art of Structural Engineering: Vaults — Princeton University on edX (PrincetonX)\n\n4. Introduction to Aerospace Structures and Materials — Delft University of Technology on edX (항공 우주공학 과정이지만 기계 공학자에게도 동등하게 유용함)\n\n5. Structural Materials: Selection and Economics — Massachusetts Institute of Technology on edX (MITx)\n\n6. Stability and Design of Structural Members — Purdue University on edX (PurdueX)\n\n<div class=\"content-ad\"></div>\n\n7. 구조 역학의 기초 — Coursera의 ISAE SUPAERO\n\n재료 과학:\n\n1. 재료 역학 및 공학 역학: Coursera의 조지아 공과 대학교에서 진행하는 8과목 시리즈\n(아마도 제프 웨인트만 박사가 지도하는 조지아 공과 대학교의 가장 포괄적인 강의 모음으로, 정적 및 재료 강도에 관한 모든 것을 배울 수 있습니다)\n\n2. 재료 행동 — Coursera의 조지아 공과 대학교\n\n<div class=\"content-ad\"></div>\n\n3. 재료 처리 — Coursera의 조지아 공과대학\n\n4. 섬유 강화 고분자 복합 구조물의 역학 — NPTEL(IIT)의 Guwahati 인도 공과대학\n\n의료기기:\n\n1. 인체 해부학: 근골격 사례 — edX(HarvardX)의 하버드 대학 온라인 강의 \n(의료 기기 산업에서 일하려는 기계 공학자를 위한 이 과정은 해부학의 복잡한 세부 사항을 이해하는데 좋은 기초가 됩니다. Van Houten 교수님은 훌륭한 강사입니다)\n\n<div class=\"content-ad\"></div>\n\n2. 생명 의공학자가 되고 싶다면 - edX(UCSanDiegoX)에서 캘리포니아 대학 샌디에고(University of California, San Diego) 강의\n\n3. 생체 재료 및 바이오패브리케이션: 디자인, 엔지니어링 및 혁신 - edX(BayreuthX)에서 바이로이트 대학(University of Bayreuth) 강의\n\n4. 생체 의료 장비: 생체 의료 기기 수리 및 유지 관리 - edX(DelftX)에서 Delft 기술 대학(Delft University of Technology) 강의\n\n자동차:\n\n<div class=\"content-ad\"></div>\n\n1. 전문 자격증: 전기 자동차 - Delft 대학교 (DelftX)에서 edX로 수료\n(전기 자동차의 기초, 기술, 비즈니스 및 정책에 중점을 둔 4개 과정으로 구성되어 있습니다. 이러한 각 과정을 무료로 개별적으로 수강하거나 전문 자격증을 획들하기 위해 유료 버전을 선택할 수 있습니다.)\n\n2. 전기 및 일반 차량 - Chalmers 대학교 (ChalmersX)에서 edX로 수료\n\n3. 하이브리드 차량 - Chalmers 대학교 (ChalmersX)에서 edX로 수료\n\n4. 자동차 공학에서 도로 교통 안전 - Chalmers 대학교 (ChalmersX)에서 edX로 수료\n\n<div class=\"content-ad\"></div>\n\n5. 자동차 시스템의 기초, 인도 기술 연구소, 마드라스 교수들의 NPTEL(IIT)\n\n6. 자동차 디자인의 인간공학, 인도 기술 연구소, 구와하티의 NPTEL (IIT)\n\n로보틱스:\n\n1. 메카트로닉스 혁명: 기초 및 핵심 개념 - 조지아 공과대학의 edX (GTx)\n\n<div class=\"content-ad\"></div>\n\n- 로보틱스 기초 I: 로봇 모델링 — 나폴리 페데리코 2세 대학교 edX(FedericaX)에서\n\n- Hello (Real) World with ROS — 로봇 운영 시스템 — 드레흐트 공과대학 edX(DelftX)에서\n\n- 로보틱스 전문 과정 — 펜실베이니아 대학교 Coursera에서\n(로봇공학에 관한 6개의 과정 시리즈와 마무리로 캡스톤 과정이 있습니다)\n\n- 현대 로보틱스 전문 과정 — 노스웨스턴 대학교 Coursera에서\n(또 다른 흥미진 6개의 과정 시리즈로, 마지막에 캡스톤 프로젝트가 제공됩니다)\n\n<div class=\"content-ad\"></div>\n\n## 기타:\n\n1. [Engineering Simulations에 대한 실전 소개](https://www.edx.org/course/a-hands-on-introduction-to-engineering-simulations) — 콘넬 대학교의 edX (CornellX)\n   (유한 요소 해석 (FEA)과 ANSYS 시뮬레이션 소프트웨어 기초 학습에 좋은 강의 중 하나)\n\n2. [물리학 문제를 위한 유한 요소법](https://www.coursera.org/umich) — 미시건 대학교의 Coursera\n\n3. [운동과 힘, 에너지 및 중력 역학: 입자에서 행성까지](https://www.coursera.org/ns) — 뉴사우스웨일스 대학교의 Coursera\n\n<div class=\"content-ad\"></div>\n\n4. Forensic Engineering: Learning from Failures — Delft University of Technology on edX (DelftX)\n(공학적 실패로부터 배우기 및 그 원인을 찾는 과정에 대한 조사 방법을 이해합니다)\n\n5. Question Everything: Scientific Thinking in Real Life — The University of Queensland on edX (UQx)\n(수학과 과학을 활용하여 일상 문제를 해결하는 방법을 배워 비판적 사고력을 키웁니다)\n\n6. Generative Design for Manufacturing — Coursera에서 Autodesk가 제공하는 4개 과정의 시리즈\n\n7. CS50: Introduction to Computer Science — Harvard University Online on edX (HarvardX)\n(프로그래밍을 배우는 것은 기계 공학자를 위한 귀중한 기술입니다. 처음부터 프로그래밍을 배우려 한다면 이 강좌보다 나은 곳이 없습니다)\n\n<div class=\"content-ad\"></div>\n\n8. 공개 연설 소개 - edX에서 워싱턴 대학교(UWashingtonX) 강좌\n(기계 공학자로서의 효과적인 커뮤니케이션은 특히 공급 업체와 프로젝트 발표와 관련하여 전문적 성공의 핵심 요소입니다)\n\n9. 학술 및 비즈니스 글쓰기 - edX에서 캘리포니아 대학 버클리 캠퍼스(BerkeleyX) 강좌\n\n## 결론\n\n이 *세심하게* 선별된 강좌 목록이 기계 공학 커뮤니티에 도움이 되기를 바랍니다. 아래 댓글 섹션에서 피드백과 새로운 발견을 자유롭게 공유해 주세요. 저는 계속해서 이 글을 새로운 강좌와 통찰로 업데이트할 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n# 중요한 공지\n\n온라인 강좌는 기술을 향상시키고 취업 기회를 늘리는 데 유용한 자원입니다. 그러나 이는 공식 교육과 실무 경험을 대체하기 위한 것은 아닙니다.\n\n온라인 강좌만으로는 대학생이나 초보 기계 엔지니어가 실무 경험과 기술을 향상시키기에는 충분하지 않습니다. 채용 담당자와 리크루터들은 실무 기술을 갖춘 인턴십과 혁신적인 개인 프로젝트를 높이 평가합니다.\n\n온라인 학습을 실무 프로젝트, 인턴십, 또는 공식 학위와 결합하면 광범위한 교육을 제공받을 수 있고 취직 시 경쟁력을 높일 수 있습니다. 또한 직무 요구사항과 직접적으로 관련된 인증서와 강좌들은 당신의 기술이 특정 직책의 필요에 부합함을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n만약 이 기사를 즐겨 읽으셨다면, LinkedIn과 다른 플랫폼에서 공유해 주시면 감사하겠습니다. 동료 기계 공학자들 사이에 지식을 공유합시다.\n\nRizwan Syed\nLinkedIn\nInstagram","ogImage":{"url":"/assets/img/2024-06-19-MechanicalEngineeringTop50VerifiedOnlineCoursesforSkillEnhancement_0.png"},"coverImage":"/assets/img/2024-06-19-MechanicalEngineeringTop50VerifiedOnlineCoursesforSkillEnhancement_0.png","tag":["Tech"],"readingTime":7},{"title":"안의 수수께끼 파트 5","description":"","date":"2024-06-19 17:28","slug":"2024-06-19-MysteriesofAnPart5","content":"\n\n환영합니다! “Mysteries of An” 시리즈에 오신 것을 환영합니다. 각각의 디지털 아트 작품은 알려지지 않은 신비한 세계를 엿보게 해줍니다. 수수께끼의 공기와 매혹적인 풍경을 지닌 행성 An은 이 시리즈의 영감의 원천으로 봉사합니다.\n\n“Mysteries of An”의 각 작품은 다른 작품들과 함께 통일되고 매혹적인 이야기를 이루는 대규모 캔버스의 한 부분입니다. Anomalites가 살아나며 그들의 고대 이야기와 신비한 전설을 전합니다. 마법의 생물, 환상적인 풍경, 그리고 풀리지 않은 미스터리가 당신 앞에 펼쳐지며, 마술과 기술이 조화롭게 공존하는 세계에 몰입할 수 있습니다.\n\n각 작품은 행성 An의 탐험되지 않은 구석을 여행하며 숨겨진 진실과 비밀을 발견할 수 있도록 섬세한 세부 사항으로 가득합니다. 이 시리즈는 완성된 그림 뿐만 아니라 스케치, 초고, 그리고 향후 작품의 개별 요소까지 모두 포함되어 있어, An 우주 내에서의 창조와 발견 과정을 목격할 수 있습니다. “Mysteries of An”을 탐험하고, 디지털 캔버스마다 숨겨진 마법을 발견하며, 환상과 경이로운 세계로 자신을 떠나보세요.\n\n<div class=\"content-ad\"></div>\n\n이 지도의 안내 마크를 따라가면 여행자들은 놀라운 발견과 마법의 모험으로 가득한 행성 An의 숨겨진 곳을 발견할 수 있어요.\n\n여기에 들러서 내 예술 세계에 대해 알게 되어서 정말 좋아요!\n\n더 많은 정보는 제 웹사이트나 트위터 / 와프캐스트에서 찾아볼 수 있어요.\n\n오늘 하루도 멋지게 보내세요!","ogImage":{"url":"/assets/img/2024-06-19-MysteriesofAnPart5_0.png"},"coverImage":"/assets/img/2024-06-19-MysteriesofAnPart5_0.png","tag":["Tech"],"readingTime":1},{"title":"강력한 3D 프린트를 만드는 방법","description":"","date":"2024-06-19 17:26","slug":"2024-06-19-Howtomakestrong3Dprints","content":"\n\n3D 프린팅에서의 구조적인 견고함은 기능하는 동안에 붕괴해서는 안 되기 때문에 중요합니다. 3D 프린팅은 고품질을 제공하여 폭넓게 수용되는 대중적인 제조 공정입니다. 3D 프린팅 부품의 강도를 향상시키기 위해 다양한 요소들이 작용합니다.\n\n본 글은 강력한 3D 프린트를 만드는 방법에 대한 세부 내용을 제공하며, 개인용 3D 프린터를 소유하거나 신속한 프로토타이핑 서비스를 외부에 위탁하려는 사람들에게 도움이 될 것입니다. 개인용 3D 프린터가 있다면 설정을 조정하여 최상의 결과물을 얻는 방법을 배우게 될 것입니다. 프로젝트를 외부에 위탁하려는 경우, 서로 다른 재료와 최신 후처리 기술에 대한 정보를 얻어 프로토타이핑 서비스와 원활하게 소통하는 방법을 파악할 수 있을 것입니다. 3D 프린팅 부품을 강하게 만드는 간단한 방법을 살펴보십시오.\n\n# 프린터 설정 조정\n\n개인 공작물로 3D 프린터를 사용하는 것은 개인 제품 제조에 더욱 효율적이고 효과적입니다. 그러나 3D 프린팅과 관련된 지식을 가지고 있지 않다면, 강한 3D 프린트를 만드는 데 약간의 어려움이 있을 수 있습니다. 3D 프린터에는 고품질이며 강도 있는 프린트를 얻기 위해 조정할 수 있는 많은 설정이 있습니다. 이를 사용하여 강한 3D 프린트를 만드는 방법은 다음과 같습니다.\n\n<div class=\"content-ad\"></div>\n\n# 인필 증강\n\n![인필이미지](/assets/img/2024-06-19-Howtomakestrong3Dprints_0.png)\n\n3D 프린트의 강도를 높이는 한 가지 방법은 내부 밀도를 증가시키는 것입니다. 내부 밀도는 0%에서 100%까지 변화하며, 0은 완전히 비어있음을 의미하고 100은 완전히 고체임을 의미합니다.\n\n이론적으로, 100%의 인필 밀도를 가지면 3D 프린트가 매우 강해질 것으로 예상됩니다. 그러나 실제로 대부분의 디자이너들은 70% 이상은 3D 프린트를 강화하는 데 미미한 영향을 준다는 것을 알아냈습니다. 대신에, 필라멘트 사용량, 인쇄 시간, 비용, 그리고 3D 프린터에 부담이 커지는 것이 크게 늘어납니다.\n\n<div class=\"content-ad\"></div>\n\n노트: 강도를 위해 최소 20% 인필 밀도를 사용하고, 가능하다면 인핰 밀도를 늘리기 전에 벽 두께(아래 설명함)를 조절하세요.\n\n# 벽 두께 늘리기\n\n![image](/assets/img/2024-06-19-Howtomakestrong3Dprints_1.png)\n\n3D 프린트 재료의 벽 두께는 \"벽 라인 수\"와 \"외부 라인 폭\"으로 측정됩니다. 벽을 두껍게 하는 것은 강한 3D 프린트물을 만드는 중요한 방법입니다. 벽 두께를 늘리면 3D 프린트된 부품은 안쪽보다 바깥쪽에서 더 많은 변형을 겪기 때문에 강도가 늘어납니다.\n\n<div class=\"content-ad\"></div>\n\n벽 두께를 높이면 인쇄된 재료가 강해지는데 그치지 않고, 오버행(인쇄가 어려운 3D 모델의 기하학 모양)과 방수성도 향상됩니다.\n\n참고: 일반 제품의 경우, 벽 두께가 1.2mm 이상이어야 합니다. 그 이상으로 늘려 강도를 높일 수 있습니다.\n\n# 더 얇은 층 사용\n\n![이미지](/assets/img/2024-06-19-Howtomakestrong3Dprints_2.png)\n\n<div class=\"content-ad\"></div>\n\n다음 층 사이에 얇은 층을 사용하면 3D 프린트 부품의 접착력과 밀도가 향상되어 강도가 증가합니다. 디자이너들은 0.1mm (100 마이크론)까지 내려가면 강도가 극대화된다고 말했습니다. 그러나 프린팅 시간도 증가한다고 합니다.\n\n# 견고한 채움 패턴 사용하기\n\n![이미지](/assets/img/2024-06-19-Howtomakestrong3Dprints_3.png)\n\n3D 프린트를 보강하는 또 다른 방법은 적절한 채움 패턴을 사용하는 것입니다. 채움 패턴은 채움 밀도와 함께 작용하며, 3D 프린트의 내부 지지구조 역할을 합니다. 또한 부품에 약간의 강성을 추가하여 벽 변형을 방지합니다. 채움 패턴을 사용하여 강한 3D 프린트를 만드는 방법에 대해, 30–50% 범위의 밀도가 높은 채움 패턴을 사용해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n사용하는 채움 패턴에 따라 3D 프린트의 강도가 결정됩니다. 시도해 볼 수 있는 세 가지 채움 방식은 다음과 같습니다:\n\n## · 삼각형 채움 패턴\n\n![삼각형 채움 패턴](/assets/img/2024-06-19-Howtomakestrong3Dprints_4.png)\n\n삼각형 채움 패턴은 변형의 가능성이 적고 최상의 지지 구조를 제공하기 때문에 강도가 뛰어납니다. 대부분의 3D 애호가는 이것이 삼각형이 가장 강한 모양이기 때문이라고 생각합니다.\n\n<div class=\"content-ad\"></div>\n\n삼각형 인필을 사용하면 프린트 헤드의 직선 이동으로 인해 인쇄 속도가 향상되며 인장과 속도는 다수의 3D 애호가들 사이에서 가장 좋은 선택이 됩니다.\n\n## - 직사각형 인필 패턴\n\n![이미지](/assets/img/2024-06-19-Howtomakestrong3Dprints_5.png)\n\n직사각형 인필은 평행 및 수직 텍스트 블록으로 이루어진 격자 구조 때문에 100%의 인필 밀도를 달성할 수 있습니다. 삼각형 인필과 마찬가지로 프린트 헤드의 직선 이동으로 인해 높은 인쇄 속도를 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## · 육각형 인필 패턴\n\n![](/assets/img/2024-06-19-Howtomakestrong3Dprints_6.png)\n\n이들은 육각형으로 구성되어 있으며 무게 대비 강도가 가장 높습니다. 이전 두 가지 인필 패턴과 달리 인쇄 속도가 느립니다. 이는 프린트 헤드가 지속적으로 방향을 변경하기 때문인데, 그러나 3D 프린트를 보강하는 데도 효과적입니다.\n\n# 플로우 비율 조정\n\n<div class=\"content-ad\"></div>\n\n유동 속도 조절도 3D 프린트 부품을 강하게 만드는 이상적인 방법일 수 있어요. 그러나 이 방법을 사용할 때에는 과하거나 미달 압출이 발생하지 않도록 조심해야 해요. 따라서 대부분의 디자이너들은 작은 변화만을 가하도록 합니다.\n\n다음에 대해 유동 속도를 조절할 수 있어요:\n\n- 벽 유동 (외벽 유동 및 내부벽 유동)\n- 인필 유동\n- 지지 유동\n\n유동 속도를 조절하여 3D 프린트를 강화할 수 있어요. 하지만 대부분의 사람들은 유동 속도를 조정하여 부피 유량 달성이 어려운 것을 해결하고 정확성을 향상시키는 등 다른 3D 프린트 문제를 해결할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n# 선 폭 수정\n\n![이미지](/assets/img/2024-06-19-Howtomakestrong3Dprints_7.png)\n\nCura에 따르면, 인기 있는 슬라이서 중에 하나로 3D 프린트를 강화하는 방법 중 하나는 선 폭을 레이어 높이의 배수로 조절하는 것입니다. 그러나 선 폭은 텍스트럴과 직접적으로 관련이 있기 때문에, 선 폭의 대량한 변경은 너무 많거나 너무 적은 추출로 이어질 수 있으므로 신중해야 합니다.\n\n# 냉각량 감소\n\n<div class=\"content-ad\"></div>\n\n3D 프린팅에서 냉각은 설정 후 레이어가 부착되는 과정에 영향을 미치는 중요한 프로세스입니다. 빠른 냉각은 후속 레이어가 다른 레이어와 결합하지 못하여 부착력을 줄일 수 있습니다. 그러나 냉각은 사용 중인 재료에 따라 다릅니다. 예를 들어, PLA는 강력한 냉각 팬의 작용 아래에서 가장 잘 작동합니다. 따라서 사용하는 재료에 따라 냉각 속도를 조절해야 합니다.\n\n# 강도가 센 재료를 선택하여 강한 3D 프린트 작성하기\n\n![image](/assets/img/2024-06-19-Howtomakestrong3Dprints_8.png)\n\n3D 프린팅에서 일부 재료는 약하다고 알려져 있습니다. 따라서 강력한 3D 프린트를 만드는 것은 강력한 3D 프린팅 재료를 사용하는 것과 관련이 있을 수 있습니다. 강도와 동의어인 세 가지 주요 재료가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# ABS\n\nABS는 강력한 3D 프린트를 만들기 위한 훌륭한 소재로, 하지만 중량이 많은 사용에는 적합하지 않습니다. 강한 소재와 가벼운 특성을 가진 열가소성 소재로, 3D 프린팅에서 최고의 플라스틱 고분자 소재입니다.\n\n# PLA\n\nPLA는 고가의 3D 프린팅 소재로, 중량이 많고 고해상도의 프린트에 적합합니다. 7250 psi의 인장 강도를 가지고 있지만 빛에 노출되면 분해될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# PETG\n\n이것은 강도 때문에 최근 인기를 얻고 있는 새로운 필라멘트입니다. 압축 강도는 약 4100~8500 psi로, PLA보다는 강하고 ABS보다는 약합니다. 그러나 PLA보다는 덜 유연하고 ABS보다는 더 유연합니다.\n\n# 적절한 소재 선택\n\n세 가지 소재 중에서 적절한 소재를 선택하려면 저항성 힘, 층 사이의 결합, 굽힘 힘, 강성 및 충격에 대한 저항력을 고려해야 합니다. 아래는 각각에 대한 이들의 비교입니다:\n\n<div class=\"content-ad\"></div>\n\n- 저항력: PETG ` PLA ` ABS\n- 층 간 결합: PETG ` ABS 및 PLA\n- 굽히는 힘: ABS ` PETG ` PLA\n- 충격 저항: ABS = PETG ` PLA\n\n더 많은 정보를 원한다면, PLA vs ABS 간의 차이에 대한 빠른 다이렉트의 기사를 확인해보세요.\n\n# 부품 방향 결정\n\n![이미지](/assets/img/2024-06-19-Howtomakestrong3Dprints_9.png)\n\n<div class=\"content-ad\"></div>\n\n3D 프린트를 보강하는 또 다른 방법은 부품 방향을 활용하는 것입니다. 부품 방향은 3D 프린터 상에서 부품의 위치를 말합니다. 3D 프린터는 녹아든 재료의 얇은 층을 점진적으로 쌓아가는 방식으로 작동합니다. 높이가 점진적으로 증가하는 것이 3차원 부품을 형성하는 원리입니다. 층을 쌓을 때 이전 층에 맞닿게 되며 결합됩니다. 그러나 두 층 사이의 경계면은 약한 지점이며, 3D 프린트는 이러한 경계면에서 파손될 수 있습니다.\n\n이를 이해하는 좋은 방법은 선반에 사용되는 브라켓을 만들어 보는 것입니다. 브라켓이 선반에 부착되는 곳에서 가장 큰 힘이 작용한다는 것을 알 수 있을 것입니다. 따라서 부품을 인쇄할 때, 힘이 반대 방향인 인터페이스가 있는 측면에 출력하는 것이 좋습니다.\n\n부품 방향이 어렵다면 결합 경향이 더 좋은 재료인 예를 들어 PETG를 사용해야 합니다. 또한, 부품 방향은 인쇄 표면의 매끄러움과 많은 재료가 필요하므로 인쇄 비용에도 영향을 줄 수 있습니다.\n\n# 3D 프린트에 에폭시 코팅 적용하기\n\n<div class=\"content-ad\"></div>\n\n직접적으로 강한 3D 프린트를 만드는 과정은 아니지만 프린트 후에 발생합니다. 이 과정은 에폭시/폴리에폭사이드를 사용하여 3D 프린트를 강화하는 것입니다. 에폭시 코팅은 하드너와 에폭시 코팅으로 만들어진 불용이성 표면 코팅입니다. 용제 저항성, 내구성이 뛰어나고 단단하여 PLA, ABS 및 SLA와 같은 재료를 코팅하기에 적합합니다.\n\n3D 프린트에 에폭시 코팅을 하는 것은 쉬운 작업입니다. 아래 단계를 따라해보세요:\n\n- 제품 디자인에 따라 제품을 3D 프린트합니다.\n- 식히고 표면을 깨끗하게 닦습니다.\n- 컵에 조금 부은 후 점도가 있는 유동체를 만들기 위해 가열합니다.\n- 브러시를 사용하여 브러시로 모델에 에폭시 코팅을 바르고 코팅이 측면으로 흘러내리지 않도록 합니다. 또한 구멍과 모서리에 접근하기 위해 작은 브러시를 사용합니다.\n- 3D 프린트가 마르도록 합니다.\n\n많은 양을 사용할 필요가 없으며 하드너의 적은 양이 프린트를 코팅하고 강화할 수 있습니다. 3D 프린트에 에폭시 코팅을 하는 것은 그것을 더 강하게 만들어 주고 맑고 반짝이는 표면을 제공해줍니다.\n\n<div class=\"content-ad\"></div>\n\n# 3D 프린팅 부품을 강하게 만들기 위한 다른 고려 사항\n\n3D 프린터 설정을 조정하는 것만이 3D 출력물을 강하게 만드는 유일한 방법은 아닙니다. 에폭시 코팅 외에 후처리 방법이 있으며, 사용할 수 있는 다른 방법들이 있습니다. 아래에는 최근 인기 있는 두 가지 중요한 방법이 소개되어 있습니다.\n\n# 3D 출력물 가공\n\n소성은 강화 목적으로 3D 출력물을 온도를 높이는 방법입니다. 실험에 따르면, 소성은 사용 후 강도를 약 40% 증가시킨다고 합니다. 이 방법은 PLA, ABS, PETG 및 ASA와 같은 소재와 호환됩니다.\n\n<div class=\"content-ad\"></div>\n\n플라스틱의 구조 때문에 단열 처리는 3D 프린트를 강화하는 데 중요합니다. 3D 프린트 전에는 플라스틱이 비정형/무질서한 미세 구조를 가지고 있습니다. 그러나 3D 프린트를 가열하면 비정형 구조가 결정 구조로 재배치되어 3D 프린트가 파괴될 가능성이 높아집니다.\n\n여기서 중요한 것은 단열로 3D 프린트의 결정 구조를 큰 결정에서 작은 결정으로 변경하는데 있습니다. 플라스틱 고분자 또는 완성된 3D 프린트 제품을 단열할 수 있습니다. 플라스틱 고분자나 3D 프린트 부품을 단열하려면 유리 전이점보다 높고 녹는 점보다 낮은 온도로 가열하십시오.\n\n# 플라스틱 3D 프린트의 전기 도금\n\n전기 도금은 실용적이고 가격이 저렴하여 인기 있는 방법입니다. 이 방법은 3D 프린트를 전해질과 도금 금속(인기있는 산업 금속은 아연, 크롬, 니켈 등이 있습니다)에 넣는 과정을 포함합니다. 전해질을 통해 전기를 통과시키면 금속 이온이 3D 프린트 주위에 코팅을 형성합니다. 이는 내구성이 강하고 오래가는 3D 프린트 형성으로 이어집니다.\n\n<div class=\"content-ad\"></div>\n\n그 목적에 적합하지만 단점은 높은 강도를 가진 더 나은 3D 부품을 만들기 위해 많은 레이어가 필요하다는 것입니다.\n\n# 결론\n\n사용 중에 붕괴되지 않는 강력한 3D 프린트는 3D 프린트를 어떻게 강하게 만들 것인지 아는 것이 매우 중요합니다. 3D 프린트를 강화하는 방법에는 세 가지가 있습니다. 하나는 과정 중에(3D 프린터의 설정을 조정하여) 강화하는 것, 적절한 소재 사용, 그리고 후처리입니다. 이 중 하나를 사용하면 강한 3D 프린트를 만들 수 있거나, 3D 프린팅된 부품을 강화하는 방법에 대해 프로토타이핑 서비스와 대화하거나 소통할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-Howtomakestrong3Dprints_0.png"},"coverImage":"/assets/img/2024-06-19-Howtomakestrong3Dprints_0.png","tag":["Tech"],"readingTime":8},{"title":"프레디를 살려내기 웨어러블 프레디 파즈베어 헤드 3D 프린팅하기","description":"","date":"2024-06-19 17:24","slug":"2024-06-19-BringingFreddytoLife3dPrintingaWearableFreddyFazbearHead","content":"\n\n\n![Freddy Fazbear Head](/assets/img/2024-06-19-BringingFreddytoLife3dPrintingaWearableFreddyFazbearHead_0.png)\n\n**참고** - 본 글에는 제휴 링크가 포함되어 있습니다. 만약 제가 한 것과 비슷한 작업을 따라하고 싶다면, 제가 사용한 제품 링크를 클릭하면 제 3D 프린팅 여정을 크게 지원해 주시고 무언가를 구입하려는 경우 추가 비용이 들지 않습니다.\n\n지금까지 제 3D 프린팅은 화분이나 조각과 같은 한 조각 프린트를 만드는 데 주로 사용되었고, 가장 복잡한 작품은 틱택스를 쏘는 장난감 총이었는데 (작은 민트를 거의 쏘지 못했다).\n\nGlamrock Freddy의 머리는 방대한 작업이 될 것이다. 머리만 20개 정도의 조각으로 구성되어 있을 뿐만 아니라, 제 3D 프린터는 작은 인쇄 베드를 사용하고 있으며, 20개의 대부분의 조각은 더 작은 조각으로 나눠져야 했다.\n\n\n<div class=\"content-ad\"></div>\n\n모든 조각들은 조립되어 접착되어야 했습니다. 때로는 짜증이 나는 프로젝트가 되었지만, 이를 하면서 많은 것을 배우게 되었고, 사람들이 이 과정을 흥미롭게 여길 수 있을 것 같아요.\n\n## 파이브 나이츠 앳 프레디\n\n파이브 나이츠 앳 프레디는 Scott Cawthon이 만든 매우 무서운 비디오 게임으로 시작했습니다. 플레이어는 오랜 기간 폐쇄된 프레디 파즈베어 피자라 불리는 이전 피자 가게를 지키는 보안관의 역할을 합니다. 이 피자 가게에는 어린이들을 즐겁게 해줄 애니메이트로닉이 있었습니다. 프레디 파즈베어는 첫 번째 게임에서 애니메이트로닉스들의 리더였고, 치카, 바니, 폭시와 함께 피자가게를 지켰습니다.\n\n게임 초반의 이유는 알려져 있지 않지만, 피자가게는 왜 폐쇄되었고, 어린이들을 기쁘게 했던 애니메이트로닉스는 버려지고 파손된 상태로 남았습니다.\n\n<div class=\"content-ad\"></div>\n\n애니매트로닉스는 밤에 살아나서 피자 가게 안을 배회하며 보안 근무자의 방에 들어가려고 합니다. 왜 그런지는 모르지만, 그들은 플레이어인 여러분이 거기에 있기를 정말 싫어합니다. 그들은 보안 방에 침입하려는 욕망에서 끝없이 힘을 뺍니다. 게임은 제한된 전기 자원을 관리하고 보안 카메라를 통해 애니매트로닉스의 위치를 모니터링하며 소리를 듣는 것을 중심으로 합니다.\n\n표면적으로만 보면, 애니매트로닉스가 보안 방에 침입하고 화면으로 뛰어들며 소리지르고 무서운 얼굴을 내보이는 점프 스케어가 가득한 게임일 것이라고 생각할 수 있습니다.\n\n하지만 FNaF는 훨씬 더 많습니다. 플레이하는 동안 배경 포스터나 숨은 \"이스터 에그\"를 통해 드리운 이야기가 펼쳐집니다.\n\n첫 번째 게임은 상당히 간단합니다. 애니매트로닉스는 실제로 움직이지 않고, 주로 여러 카메라 화면을 왔다갔다 하면서 자리를 바꿉니다. 오싹한 분위기와 유령 같은 소리와 속삭이는 소리가 결합되어 진정한 공포 팬이라면 꼭 경험해야 할 무서운 게임이 만들어졌습니다.\n\n<div class=\"content-ad\"></div>\n\n이 게임은 다수의 시퀄, 프리퀄, 그리고 팬메이드 게임뿐만 아니라 책과 최근에는 영화도 있는 현상으로 발전했습니다. 이 게임은 직접적으로 전달되지 않는 일련의 이야기를 조합하려고 애쓰는 많은 팬들이 있는 대규모의 팬층을 보유하고 있습니다. 이 이야기의 많은 부분이 해석의 여지가 있습니다.\n\n게임 Five Nights at Freddy’s: Security Breach에서, 글램락 프레디는 죽이려 하지 않고 오히려 당신을 도와줍니다. 그는 80년대 \"글램\" 밴드를 모티프로 한 애니메트로닉 밴드의 리드 싱어입니다. 이전 버전의 프레디와 달리, 글램락 프레디는 반짝이며 새롭고 선명한 색상을 가지고 있습니다.\n\n## 3D 디자인\n\n저는 이 프린트를 디자인했다고 말씀드리고 싶지만, 실제로는 그렇지 않습니다. 이 3D 프린트 파일은 매우 재능 있는 코스플레이어이자 예술가인 Littlegem이 만들었으며, 이 파일을 사용하여 자신만의 글램락 프레디 머리를 만들 수 있게 아주 관대하게 허용합니다. 다만 만들어서 판매는 하지 마세요.\n\n<div class=\"content-ad\"></div>\n\n3D 디자인은 내가 시작한 지 얼마 안돼서, 언젠가는 직접 만들 수 있을 거에요. 하지만 지금은 나를 위해 3D 디자인을 만들어주는 다른 아티스트들에게 의지해야 해요.\n\n## 프린팅\n\n![이미지](/assets/img/2024-06-19-BringingFreddytoLife3dPrintingaWearableFreddyFazbearHead_1.png)\n\n이 디자인을 만드는 데 Flashforge Creator Pro를 사용했어요. 이 프린터는 대부분 초보자에게 적합하지만, 더 큰 빌드 플레이트를 가진 새로운 모델을 구매하여 파일을 잘 맞게 조각내지 않아도 되도록 하고 싶어요. 3D 프린터를 찾고 있다면, 자동 레벨링 빌드 플레이트가 있는 것을 추천해요. 이렇게 하면 많은 답답함을 피하고 프로젝트에 집중할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n나는 3D 프린팅 매체로 PLA를 사용했어요. 이건 매우 넉넉하고 유해한 증기가 없어서, 다른 종류들이 가지고 있는 그런 걱정은 없어요. 비유해요도, 무해하고 어떤 것을 엎어놓는 것에 대해 걱정할 필요가 없어요.\n\n내가 개인적으로 가장 좋아하는 PLA는 Silk나 Anycubic 브랜드였어요. 이 브랜드들로 인해 더 적은 막힘과 부착 문제, 그리고 덜 답답함을 겪었어요. 이는 다시 인쇄하고 시간을 적게 낭비하게 해줬어요.\n\n![이미지](/assets/img/2024-06-19-BringingFreddytoLife3dPrintingaWearableFreddyFazbearHead_2.png)\n\n나는 나의 프린터를 살펴보고 왜 실패한 출력물이 계속되는지 해결하려고 시간을 많이 보냈어요. 그리고 내가 가장 큰 문제로 겪었던 것은 빌드 플레이트를 프린트 노즐에 적절하게 맞추지 않은 것이었어요.\n\n<div class=\"content-ad\"></div>\n\n제 Creator Pro에서 문제가 발생해서 원인을 알 수 없을 때 여러 모순 내지에 빠졌었어요. 답답한 마음에 더 큰 프린트 베드를 가진 중고 Ender3을 구입했는데, 그것이 내가 한 최악의 결정이었습니다. 저렴한 중고 Ender3를 발견하자마자 구입했어요.\n\n![이미지](/assets/img/2024-06-19-BringingFreddytoLife3dPrintingaWearableFreddyFazbearHead_3.png)\n\n프린트가 제대로 되지 않는 것에 대해 매우 많은 시간을 들였는데, 프로젝트를 중단할 뻔했어요. 프린트가 베드에 딱 붙지 않는 이유를 알아보느라 몇 주 동안 밤새 문제를 해결하려고 노력했어요. Ender를 작동시키기 위한 모든 희망이 사라지자 Creator Pro를 다시 꺼내서 마지막으로 Ender가 제대로 프린트되도록 노력했어요.\n\n베드를 정확하게 수평 조절하지 않았고 노즐이 프린트 베드에 너무 근접해 있어서 필라멘트가 프린트 노즐에 차단되었던 것이었어요. Creator Pro를 분해해서 노즐을 교환하고 녹아든 필라멘트를 청소하는 일에 능숙해졌어요.\n\n<div class=\"content-ad\"></div>\n\n요 추천 사항은 자동 레벨링 프린트 베드입니다.\n\n다른 문제는 프린트에 사용한 지지 구조였습니다. 저는 프린트를 위해 슬라이싱 프로그램을 사용하여 자동으로 지지물을 생성했는데, 이는 많은 경우에 빠른 설정을 위해 잘 작동합니다. 하지만 제 경우에는 프린트를 제대로 지지하기 위해 수동으로 지지물을 만들어야 했습니다 또는 작은 상자를 만들어 사용해야 했습니다.\n\n실패한 프린트로 인해 더 많은 필라멘트를 낭비했는데, 그러지 않고 상자를 만들거나 수동 지지물을 사용했더라면 필요했을 양 이상을 사용하지 않았을 것입니다.\n\n적절한 베드 레벨링으로 이 문제를 해결하고 나서, 나는 높은 성공률로 조각들을 출력할 수 있었습니다. 또한 출력 속도를 약간 느리게 조정했는데, 그것도 도움이 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n일부 출력물 중에서 마지막으로 좀 답답한 부분이 있었어요. 머리 부분의 몇 조각이 다른 조각들보다 훨씬 더 두꺼운 서포트를 가지고 있었고, 이를 제거할 때 일반적인 기술로는 출력물을 손상시키지 않고 떼어낼 수가 없었어요.\n\n일반적으로 'Godhand' 클리퍼를 사용해서 서포트를 제거하는데, 그 두꺼운 부분들은 너무 고집스러워서 몇 번이나 출력물을 부러뜨려야 했고, 그것들을 제거하기 위해 더 강력한 방법을 동원해야 했어요. 결과적으로 Dremel 회전공구와 절단 비트를 사용해서 서포트를 그물어 냈어요.\n\n그 과정에서 발생한 열 문제는 PLA를 녹일 정도로 뜨거웠고, 실수로 출력물 벽을 통과해 구멍을 남겨버리지 않도록 하는 게 어려웠어요.\n\n<div class=\"content-ad\"></div>\n\n더 작은 지원 구조로 출력할 수도 있었지만, 각 부분마다 약 14시간이 걸렸기 때문에 더 많은 출력 실패를 걱정했기 때문에 그 시간을 낭비하고 싶지 않았어요.\n\n모든 부분을 출력하고 프로젝트의 다음 단계로 넘어갈 수 있게 되어 기쁘네요.\n\n## 프레디의 머리 조립\n\n머리를 조립하기 시작할 때, 먼저 턱부터 시작했어요. 나머지 머리 부위로 넘어가기 전에 턱을 완성해 크기를 맞추고 적절히 맞는지 확인했어요. 너무 작으면 제 분할 프로그램(제조사 프로그램인 Flashprint를 사용합니다)에서 더 크게 만들고, 나머지 모든 부분의 크기를 동일한 비율로 증가시킬 수 있었어요.\n\n<div class=\"content-ad\"></div>\n\n피스를 접합하는 데 2부 실란트를 사용했어요. 이는 피스가 제대로 결합되기 위해 몇 분 동안 피스를 함께 잡고 있어야 했다는 뜻이에요.\n\n![이미지](/assets/img/2024-06-19-BringingFreddytoLife3dPrintingaWearableFreddyFazbearHead_5.png)\n\n머리 윗부분을 만들 때, 뒷부분을 먼저 붙인 다음 앞부분을 붙여서 두 개의 반쪽으로 만들었어요. 머리 속에서는 말이 되었지만, 작은 결함들이 큰 차이로 나타났어요.\n\n시계방향으로 조립했다면 더 쉬웠을 것 같아요. 두 반쪽이 완벽하게 일치하지 않아서 눈에 띌 정도로 선이 보이지 않도록 맞추기 위해 많이 압력을 주어야 했어요. 너무 세게 눌러야 해서 무언가를 부술 것 같은 걱정이 들었어요. 다행히도 피스는 부서지지 않았고 실란트로 잘 고정되었어요.\n\n<div class=\"content-ad\"></div>\n\n대부분의 조각들은 제 작은 프린터에 너무 크기가 커서, 반으로 잘라서 프린트한 뒤에 붙였어요. 작동은 했지만, 더 많은 조각을 붙여야 했어요. 또한, 프린트 실패 가능성도 높아졌고, 조각들이 정확히 일치하지 않을 수도 있었어요.\n\n![이미지](/assets/img/2024-06-19-BringingFreddytoLife3dPrintingaWearableFreddyFazbearHead_6.png)\n\n전체 머리를 다 붙인 후에, 오토바디 필러를 사용해 줄무늬를 메웠어요. 사용하는 종류에 따라, 모두 갈아내고 매끄럽게 다듬기까지 시간이 1시간부터 24시간이 소요될 수 있어요.\n\n머리를 다 갈고 난 후에, 이제 그림을 그릴 시간이에요!\n\n<div class=\"content-ad\"></div>\n\n## 프레디의 머리 색칠하기\n\n![이미지](/assets/img/2024-06-19-BringingFreddytoLife3dPrintingaWearableFreddyFazbearHead_7.png)\n\n페인트를 칠하는 가장 쉬운 방법은 스프레이 페인트를 사용하는 것이라고 결정했어요. 구매할 수 있는 일부 페인트에는 프라이머가 내장되어 있는 것도 있지만, 저는 그런 제품을 사용하면 잘되지 않는다고 생각해서 전용 회색 프라이머를 사용하고 거기서 색을 칠해나갔어요. 최근에 페인팅 수준을 끌어올려줄 수 있을 것 같은 에어브러시를 구입했어요.\n\n가장 큰 부분부터 시작해서 작은 부분으로 넘어가기 전에 칠할 부분을 정했어요. 큰 부분이라서 오버스프레이가 일어나지 않을 것이라 생각했지만, 제 생각은 틀렸어요. 오버스프레이가 여기저기로 날아가서 몇 군데 다시 해야했죠.\n\n<div class=\"content-ad\"></div>\n\n작품의 일부를 가리는 것이 반드시 필요합니다! 오버스프레이로부터 보호해야 하는 넓은 영역에는 오래된 신문을 사용했어요. 팁 - 마스킹 테이프를 사용할 때는 저점착 테이프를 사용하세요. 그렇지 않으면 페인트가 바로 벗겨질 거에요.\n\n![이미지](/assets/img/2024-06-19-BringingFreddytoLife3dPrintingaWearableFreddyFazbearHead_8.png)\n\n페인팅 중에 마주한 또 다른 문제는 페인트가 마른 채로 주름이 생기는 현상이었어요. 인터넷에 따르면, 층간에 충분한 시간을 두지 않아 가스가 빠져나가면서 주름이 생기는 것으로, 제가 그 부분을 닦아내고 다시 페인트하는 일이 있었고, 조금 나아졌지만 완전히 해결되지는 않았어요.\n\n## 프레디의 머리 적합성\n\n<div class=\"content-ad\"></div>\n\n머리 부분을 맞추는 것이 생각했던 것보다 어렵지 않았습니다. 모기장으로 1인치 폭의 줄을 만들어 머리에 측정하는 용도로 사용했습니다. 핫 접착제를 선택해서 사용했습니다.\n\n그런 다음 모기장을 머리에 접착하고, 목이 잘 밀착되도록 가면의 턱을 나의 것과 단단히 붙였습니다. 그렇게 하면 입을 벌릴 때 턱이 움직이게 됩니다. 그 결과는 쉽게 입과 턱을 열고 닫을 수 있는 머리가 완성되었습니다.\n\n## 최종 제품\n\n이 프로젝트에 얼마나 많은 시간을 썼는지 시도조차 하고 싶지 않습니다. 인쇄 과정에서 많은 어려움을 겪었지만, 배운 점에서 긍정적인 면을 바라보고 싶습니다.\n\n<div class=\"content-ad\"></div>\n\n이제 Creator Pro를 분해하고 노즐에서 막힘을 깨끗이 제거하는 것에 매우 익숙해졌어요. 인쇄 프로그램의 설정을 쉽게 조작할 수 있게 되었어요. 내 손가락을 3번이나 접착제로 붙인 적이 있지만요. 캔의 뚜껑 안에 스프레이 페인트를 뿌려 작은 붓으로 세부 사항을 처리할 수 있다는 것을 알게 되었어요.\n\n이 프로젝트를 처음부터 다시 한다면, 분명히 더 적은 시간 안에 완성할 수 있을 것 같아요.\n\n학습하는 가장 좋은 방법이라고 생각해요. 인쇄물을 만드는 방법에 대해 많이 읽었지만, 실제로 해보면서 훨씬 더 많은 것을 배우게 되었어요.\n\n이번 글에서 제가 'Glamrock Freddy Head'를 만든 경험을 좋아해주셨으면 좋겠어요. 이 프로젝트를 즐기며 만들었고, 앞으로 제가 하는 프로젝트에 대해 더 쓰게 될 것 같아요.\n\n<div class=\"content-ad\"></div>\n\n만약 이 기사가 마음에 드셨다면 아래에 박수나 댓글을 남겨주시고, 이 빌드에 대해 궁금한 점이 있으면 언제든지 질문해주세요!\n\n<img src=\"/assets/img/2024-06-19-BringingFreddytoLife3dPrintingaWearableFreddyFazbearHead_9.png\" />","ogImage":{"url":"/assets/img/2024-06-19-BringingFreddytoLife3dPrintingaWearableFreddyFazbearHead_0.png"},"coverImage":"/assets/img/2024-06-19-BringingFreddytoLife3dPrintingaWearableFreddyFazbearHead_0.png","tag":["Tech"],"readingTime":8},{"title":"예술가에서 인공지능 예술가로 디지털 시대에서 변화하는 장인 정신","description":"","date":"2024-06-19 17:22","slug":"2024-06-19-ArtisantoAI-tisanHowCraftsmanshipisEvolvingintheDigitalAge","content":"\n\n인공지능 (AI)과 3D 프린팅은 전통적인 장인 정신에 신선한 변화를 가져오고 있어요. 이러한 새로운 기술들은 속도와 정밀성을 향상시키는 것뿐만 아니라 예술가들이 창의력을 다양한 방법으로 탐험할 수 있는 날개를 달아줘요.\n\n# 지능적인 도움으로 디자인을 새롭게 상상하기\n\n장인들은 AI를 디자인에 큰 도움이 되는 컴패니언으로 본다고 해요. 기계 학습 알고리즘은 대규모의 패턴들을 연구하고 전통적인 아름다움과 현대적인 생각을 결합한 새로운 모델을 제작할 수 있어요. 이를 통해 장인들은 자신의 재능을 이어가면서 더 많은 종류의 예술작품을 생산할 수 있어요.\n\n## 3D 프린팅: 장인 정신을 더욱 발전시켜요!\n\n<div class=\"content-ad\"></div>\n\n3D 프린팅이 재능을 무시할 수 없다. 이 기술은 장인들에게 빠르게 프로토타입을 만들고, 디자인을 개선하며, 기존 방법으로는 어려운 복잡한 물건을 생산할 수 있는 능력을 제공합니다. 이 기술은 보석업자와 도자기 예술가들에게 중요한 역할을 합니다. 이제 이들은 자신의 작품에서 지속 가능성을 증진하기 위해 생물 플라스틱이나 재활용된 금속과 같은 새로운 소재를 시도할 수 있습니다.\n\n## 새로운 지평을 향한 시너지\n\n진정한 마법은 인공지능이 3D 프린팅과 함께 작동할 때 일어납니다. 인공지능은 프린팅에 적합한 모델을 만들어 내어 소재 낭비를 줄이고 제품의 강도를 향상시킵니다. 이 협업은 옛 방식을 뛰어넘는 신선한 형태와 구조의 가능성을 창출합니다.\n\n# 예술 분야를 넘나드는 혁신\n\n<div class=\"content-ad\"></div>\n\nAI는 주얼리 디자인을 위한 독특한 패턴을 만드는 데 도전받았습니다. 이후 3D 프린팅의 정확성을 통해 현실로 구현됩니다. 이를 통해 생산 기간을 단축하고 맞춤형 디자인을 실현할 수 있게 됩니다.\n\n미술 복원 분야도 혁명을 경험하고 있습니다. 인공 지능은 손상된 작품의 잔해를 검토하고 부재한 조각을 디지털적으로 재구성합니다. 이를 3D로 출력하고 아무런 차이 없이 조합하여 작품을 원래 상태로 되돌립니다.\n\n도자기 분야에서는 AI가 상세한 패턴 제작에 활용되는 예가 있습니다. 이러한 패턴은 3D 프린팅을 통해 현실로 구현됩니다. 이를 통해 예술가들은 다양한 세부 사항이 가능한 복잡한 형태를 만들 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-ArtisantoAI-tisanHowCraftsmanshipisEvolvingintheDigitalAge_0.png)\n\n<div class=\"content-ad\"></div>\n\n# 기술과 전통이 깃든 미래\n\n인공지능과 3D 프린팅이 장인 정신의 미래와 긴밀하게 연결되어 있습니다. 이 도구들은 전통적인 방법을 보존하는 데 그치지 않고 창의적 표현과 친환경 생산을 위한 새로운 방법을 제공하면서 효율성을 증진시킵니다.\n\n# 변화하는 풍경\n\n인공지능과 3D 프린팅이 장인 정신에 미치는 영향은 정말로 변화적입니다. 이들은 제품 생산성을 향상시키면서 장인 정신을 보존하며 예술가의 성격과 손재주의 오래된 가치를 유지합니다.\n\n<div class=\"content-ad\"></div>\n\n# 중요 사항\n\n디자인에서 AI의 역할\nAI는 대규모 데이터 세트를 연구하여 새로운 패턴을 제안하고 이전 요소를 혼합하여 복잡한 디자인을 만드는 데 도움을 줍니다. 이를 통해 장인들은 다양한 창조적 영역을 탐험할 수 있는 능력을 얻습니다.\n\n3D 프린팅의 영향\n3D 프린팅의 도움으로 예술가 및 디자이너는 신속하게 프로토 타입을 만들 수 있을 뿐만 아니라 다양한 재료를 시도해보며 전통적인 방법으로는 불가능했을지도 모를 복잡한 디자인을 만들 수 있게 됩니다. 디자인 과정이 빨라지고 아이디어를 현실로 구현하는 데 걸리는 시간이 단축되며 맞춤화 기회가 늘어납니다.\n\n# 도전과 고려사항\n\n<div class=\"content-ad\"></div>\n\nAI와 3D 프린팅이 장인 정신과 결합하면 많은 가능성이 있지만 극복해야 할 장애물들이 있습니다. 중요한 문제 중 하나는 장인들이 이러한 기술을 잘 활용하기 위해 필요한 기술과 지식을 보유하고 있는지 확인하는 것입니다. 또한, 장인 정신을 실천하는 모든 사람들에게 고품질 3D 프린팅 장소가 얼마나 저렴하고 이용 가능한지 생각해 봐야 합니다. 아마도 가장 중요한 어려움은 전통을 지키는 것과 새로운 방법을 수용하는 것 사이의 균형을 찾는 것입니다.\n\n# 간단히 말하자면...\n\n## AI와 3D 프린팅은 다양한 이점을 제공합니다:\n\n- 향상된 창의성\nAI는 혁신적인 디자인을 더욱 강화시키고, 3D 프린팅은 복잡한 기하학을 가능하게 합니다.\n- 증진된 효율성\n프로토타이핑 및 생산이 빨라져 시장 출시 시간을 줄입니다.\n- 폐기물 절감\nAI와 3D 프린팅은 재료 사용을 최적화할 수 있습니다.\n- 맞춤화\n맞춤형 제품은 고객의 선호에 맞게 맞춤형으로 제작될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 그러나 고려해야 할 단점들이 있습니다:\n\n- 높은 비용\nAI 및 3D 프린팅 기술에 대한 초기 투자가 상당할 수 있습니다.\n- 학습 곡선\n기술을 최대한 활용하기 위해 장인들은 새로운 기술을 습득해야 합니다.\n- 직업 대체\n기술이 몇몇 전통적인 장인 직업을 대체할 수 있다는 두려움이 있습니다.\n- 기술 손실\n기술에 과도하게 의존하는 것은 전통적인 기술의 감소로 이어질 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-ArtisantoAI-tisanHowCraftsmanshipisEvolvingintheDigitalAge_1.png)\n\n주요 논점 중 하나는 인공지능 및 3D 프린팅이 전통 장인 기술에 가져다 줄 수 있는 잠재적인 위험에 대한 논쟁입니다. 그러나 이러한 기술들이 함께 존재하며 서로를 발전시킬 수 있다고 생각하는 사람들도 있습니다. 인공지능은 디자인에 강력한 도움이 될 수 있고, 3D 프린팅은 우리가 사물을 만드는 방식을 변화시킬 수 있습니다. 마지막으로, 이러한 새로운 장인 기술 단계는 전통과 혁신을 결합한 미래를 만드는 데 중점을 두고 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-ArtisantoAI-tisanHowCraftsmanshipisEvolvingintheDigitalAge_0.png"},"coverImage":"/assets/img/2024-06-19-ArtisantoAI-tisanHowCraftsmanshipisEvolvingintheDigitalAge_0.png","tag":["Tech"],"readingTime":3},{"title":"지도를 3D로 출력하는 방법 - 블렌더로 GIS 산책하기 - 완전한 해설","description":"","date":"2024-06-19 17:21","slug":"2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough","content":"\n\n# 저자\n\n![이미지](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_0.png)\n\n# 시작해 봅시다...\n\n요즘 저는 블렌더(Blender)용 애드온을 시도해 보는 것에 열정을 느끼고 있어요. 이 애드온을 사용하면 지도를 쉽게 다운로드하고 3D로 출력할 수 있어요. 3D 프린팅 이외에도 발표 자료, 비디오 제작, VR 등 다양한 용도로 활용할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n단계 1:\n\nBlender 3.6 또는 4.02을 다운로드하세요.\n\n단계 2:\n\nhttps://github.com/domlysz/BlenderGIS.git을 다운로드하세요.\n\n<div class=\"content-ad\"></div>\n\nStep 3:\n\n`Preferences` Add-ons을 편집하세요.\n* 전체 Zip 파일을 가져오고 푸지 마세요.\n* 가져온 후에는 이미지에 있는대로 확인 표시를 클릭해야 합니다.\n\n![이미지](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_1.png)\n\n단계 4:\n\n<div class=\"content-ad\"></div>\n\nStep 5:\n\n![image](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_2.png)\n\nStep 6:\n\n<div class=\"content-ad\"></div>\n\n구글 지도가 열리면 원하는 곳으로 확대하고 선택을 마쳤을 때 'E'를 눌러주세요 🙂\n\n![image](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_4.png)\n\n7단계:\n\n고도 데이터를 가져오기\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_5.png)\n\n![Image](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_6.png)\n\n*Always remember to select the map indicated by the orange contour around the map area, as shown in the image below.*\n\n![Image](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_7.png)\n\n\n<div class=\"content-ad\"></div>\n\n8단계:\n\n고도를 변경하면서 강도를 조절해보세요\n\n![image](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_8.png)\n\n1과 2의 순서대로 수락하세요.\n\n<div class=\"content-ad\"></div>\n\n\nStep 9:\n\n좌측 상단 모드를 편집 모드로 변경한 후 맵을 우클릭하여 하위 분할을 선택하고 좌측 하단 메뉴에서 10개로 선택하세요.\n* 변경을 수락하거나 적용할 필요가 없습니다. 변경 사항이 자동으로 적용됩니다.\n\n\n<div class=\"content-ad\"></div>\n\nStep 10:\n\n지금은 지도 아래에 볼륨을 만들고 z축으로 추출하여 인쇄할 수 있게끔 합니다. 그렇지 않으면 인쇄할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n현재 무언가를 클릭하기 전에 지금 하는 것을 멈추고 마우스나 키보드로 아무 것도 클릭하기 전에 아래 내용을 꼭 읽어 주세요.\n\n![이미지](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_13.png)\n\n익스트루더를 누른 후에 엣지만 선택된 상태에서 다음 순서대로 눌러 주세요:\nS - Z - 0\n\n<div class=\"content-ad\"></div>\n\n이 작업을 수행하면 아래쪽이 평평해집니다.\n\n*이 조합을 잘못하면 CTRL-Z를 눌러 처음부터 다시 시작하세요.\n\n![image](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_14.png)\n\n작업을 마치면 마우스로 왼쪽 클릭한 후 가운데 버튼을 사용하여 맵을 회전시킵니다. 여전히 선택된 가장자리로 F (면)를 누르고 F3를 눌러 poke face를 검색합니다.\n\n<div class=\"content-ad\"></div>\n\n이것이 최종 결과입니다.\n\n![이미지](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_15.png)\n\n단계 11:\n\n다음을 삭제하세요\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 표기된 문장입니다.\n\n\n![이미지](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_16.png)\n\n클릭 ` A `, 모든 지도를 선택합니다.\n\n![이미지](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_17.png)\n\n파일로 이동하여 `Export` > `STL`을 클릭하세요.\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_18.png)\n\nTick Selection Only and Scale it to 0.01\n\n![image](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_19.png)\n\nClick on Export STL\n\n\n<div class=\"content-ad\"></div>\n\n\n![Step 12](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_20.png)\n\nOpen Bambu Studio\n\n![Image](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_21.png)\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_22.png)\n\n그게 다야, 비만항문 문제와 같은 몇 가지 주제들을 더 다룰 수 있겠지만, 그건 다른 안내서를 위한 자료야. 이 주제에 대한 더 많은 안내서가 필요하다면 Linkedin과 Medium에서 팔로우해주세요.\n\n# Stackademic 🎓\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n\n<div class=\"content-ad\"></div>\n\n- 작가에게 박수를 보내고 팔로우를 부탁드려요! 👏\n- 팔로우하기: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼 방문하기: In Plain English | CoFeed | Venture | Cubed\n- 더 많은 콘텐츠: Stackademic.com","ogImage":{"url":"/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_0.png"},"coverImage":"/assets/img/2024-06-19-Howto3DPrintMapsGISwithBlenderAcompletewalkthrough_0.png","tag":["Tech"],"readingTime":4},{"title":"잠재력 발휘 현대 제조업에서의 3D 프린팅의 변혁적인 힘","description":"","date":"2024-06-19 17:19","slug":"2024-06-19-UnleashingPotentialTransformativePowerof3DPrintinginModernManufacturing","content":"\n\n상상력에 제한이 없는 창조의 시대에 발을 딛고 있는 것을 상상해 보세요. 3D 프린팅의 세계로 환영합니다. 이는 과학 소설의 판타지에서 현실로 순조롭게 전환된 미래 지향적 기술로, 현재 우리가 아는 제조 산업을 혁명화하고 있습니다. 다양한 산업 영역에 걸쳐 적용되는 그것의 수많은 장점과 멀리 뻗어나가는 응용 분야로, 3D 프린팅은 디자인, 생산 및 맞춤 제작에서 가능한 것을 재정의할 산업의 부흥선에 오르고 있습니다. 우리와 함께 이 블로그 글을 통해 이 기술적 진화 속의 장점에 촉매되어 제조업의 미래를 풀어가는 여정에 나서 보세요. 전통적인 조립 라인이 디지털 프린터 앞에 곧 무릎 꿇을지도 모릅니다.\n\n![image](/assets/img/2024-06-19-UnleashingPotentialTransformativePowerof3DPrintinginModernManufacturing_0.png)\n\n3D 프린팅의 다양한 차원\n\n1. 혁신과 맞춤화의 가속\n\n<div class=\"content-ad\"></div>\n\n새로운 창의성 시대를 공개합니다 - 3D 프린팅을 통해 기업과 창작자가 디자인을 실험하고 빠르게 반복하며, 정밀하고 개인화된 디테일로 제품을 살아있게 만드는 방법을 알아봅니다. 복잡한 프로토 타입부터 맞춤형 보청기까지, 이 부분은 3D 프린팅의 독특한 능력을 활용하여 다양한 분야에서 성장 가능성을 탐구합니다. \n\n2. 효율성 증진: 지속 가능한 제조업의 최고 수준\n\n재료 낭비와 자원 활용의 감소부터 공급망의 간소화까지, 이 혁신적인 기술이 자동차부터 항공우주분야까지 다양한 산업에서 환경 영향을 최소화하면서 지속 가능한 제조업 실천의 기초를 새롭게 구축하는 방법을 배웁니다.\n\n3. 비용 절감과 유연성: 성공을 위한 비즈니스 모델 재정의\n\n<div class=\"content-ad\"></div>\n\n비즈니스들이 3D 프린팅 기술을 활용하여 생산 비용을 줄이고, 생산 리드 타임을 단축하며, 온디맨드 제조를 통해 재고 관리의 유연성을 높이는 방법을 발견하세요. 이 섹션은 기껏한 혁신으로 조직들을 성공 전략의 중요한 부분으로 받아들이도록 격려하고 있는 금전적 이점을 탐구합니다.\n\n4. 의료혁명: 3D 프린팅이 삶, 치료, 희망이 교차하는 지점에서\n\n의료 분야에서 3D 프린팅이 맞벽을 넘어감으로써 맞춤형 보철, 임플란트를 가능하게 하고, 수술 계획을 간소화하며, 장기 이식을 위한 조직 공학 연구 발전을 이끌어나가는 방법을 탐색하세요. 이 기술이 다양한 의료 분야에서 환자 치료와 결과에 미친 놀라운 영향을 직접 목격하세요.\n\n5. 도전과 전망: 내일의 가능성을 받아들이는데 어려움을 극복하기\n\n<div class=\"content-ad\"></div>\n\n3D 프린팅의 잠재력은 끝없이 보이지만, 모든 기술적인 발전처럼 그것에는 어려움과 제약이 따릅니다. 본 섹션은 제조업자와 연구자들이 이 기술의 능력을 완전히 활용하는 데 직면한 현재의 도전 과제를 살펴보며, 더 나아가 3D 프린팅을 혁신 센터인 미래 산업으로 더 멀리 이끌 것으로 약속한 떠오르는 트렌드에 주목합니다.\n\n3D 프린팅을 나침반으로 한 제조업의 새로운 방향 그리기\n\n우리의 탐험을 마무리하며, 3D 프린팅이 현대 제조업 내에서 자리잡았을 뿐만 아니라 디자인과 생산의 미래를 계속해서 형성하리라는 것은 분명합니다. 이 기술의 잠재력을 포용함으로써, 세계의 기업과 산업은 성장을 위한 전략을 재정립하는 기회를 얻을 뿐 아니라 혁신을 통해 긍정적인 사회적 영향을 주도할 수 있게 됩니다.\n\n3D 프린팅과 같은 혁신적인 기술은 제조업에 탐험정신을 발휘하고 미개척된 영역을 탐험하려는 사람들을 기다리는 무한한 가능성을 보여줍니다. 이 파워를 이용함으로써, 우리는 창의력, 지속가능성, 그리고 효율성이 번영하는 글로벌 생태계의 필수적인 기둥이 되는 흥미진진한 미래로 세계를 공동으로 이끌 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 블로그 포스트를 마무리하면 3D 프린팅의 힘이 내일의 제조업 세계가 어떻게 보일지에 대한 당신의 생각에 영감을 줄 것입니다. 기술과 창의력이 만나서 우리의 꿈 속을 뛰어넘는 솔루션을 제공하는 시대 - 이런 혁명적 기술에 대한 통찰력 있는 토론을 더 많이 보려면 팔로우해주세요. 더 나은 미래를 형성하는 혁신들 중 하나씩!","ogImage":{"url":"/assets/img/2024-06-19-UnleashingPotentialTransformativePowerof3DPrintinginModernManufacturing_0.png"},"coverImage":"/assets/img/2024-06-19-UnleashingPotentialTransformativePowerof3DPrintinginModernManufacturing_0.png","tag":["Tech"],"readingTime":3},{"title":"안녕하세요, 지그비 월드 25화  OTA 펌웨어 업데이트","description":"","date":"2024-06-19 17:13","slug":"2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates","content":"\n\n<img src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_0.png\" />\n\n만약 당신의 장치에 마이크로컨트롤러가 포함되어 있다면, 언젠가는 펌웨어 업데이트를 고려할 것입니다. 장치가 USB 또는 SD 카드 업데이트와 같은 쉬운 업데이트 방법을 지원하는 경우에는 보너스입니다. 또한 플래싱 도구를 가지고 이 도구를 장치에 연결할 수 있는 가능성도 좋은 선택지입니다. 그렇지 않다면 어떻게 해야 할까요?\n\n다행히도 이에 대한 해결책이 있습니다: Zigbee의 표준화된 무선 업데이트(OTA). NXP JN5169 마이크로컨트롤러에는 OTA 펌웨어 업데이트를 구현하기에 충분한 플래시 메모리가 있습니다. 이 글에서 설명하는 지침은 Zigbee 사양을 준수하며 OTA 업데이트를 적용할 수 있지만, OTA 업데이트를 구현하는 것에는 복잡함이 딸립니다.\n\n이 글은 Hello Zigbee 시리즈를 계속해서, 바닥부터 Zigbee 장치 펌웨어를 개발하는 데 초점을 맞춘 내용입니다. 저는 NXP JN5169 마이크로컨트롤러가 장착된 EBYTE E75-2G4M10S 모듈을 활용하여, 이 시리즈 이전 글에서 구축된 코드를 기반으로 구축할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n자 이제 함께 알아봅시다.\n\n# Zigbee OTA 이론\n\n## OTA 업데이트 프로토콜\n\nOTA 클러스터는 꽤 복잡합니다. 메인 펌웨어와 다중 마이크로컨트롤러를 가진 장치의 보조 프로세서 펌웨어를 업데이트하기 위한 상세한 설정을 제공합니다. 프로세스에는 네트워크 혼잡을 피하기 위해 다운로드 속도를 관리하는 방법이 포함되어 있습니다. 또한 업데이트 절차는 다른 타임아웃 및 오류 코드에 의해 원활한 운영이 보장됩니다.\n\n<div class=\"content-ad\"></div>\n\n복잡해 보이지만 펌웨어 업데이트 프로세스는 더 높은 수준에서는 간단합니다. 다음 다이어그램으로 요약할 수 있습니다.\n\n![Hello Zigbee World Part 25 OTA Firmware Updates](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_1.png)\n\n프로세스에는 두 장치가 관여됩니다. 코디네이터가 될 수 있지만 꼭 그럴 필요는 없는 서버가 다양한 클라이언트 장치의 펌웨어를 보관합니다. 클라이언트 장치는 업데이트 준비가 되면 서버에게 이용 가능한 펌웨어 업데이트 정보 및 펌웨어 데이터의 다음 부분을 요청합니다.\n\n클라이언트가 펌웨어 업데이트 프로세스를 관리합니다. 새로운 정보를 받을 준비가 되면서 서버는 수동적인 역할을 합니다. 서버는 중간 업데이트 상태를 유지하지 않으며 모든 정보는 클라이언트에 저장됩니다. 그러나 펌웨어 업데이트 프로세스를 시작하는 것은 서버의 책임에 속할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n펌웨어 업데이트 프로세스 단계는 다음과 같습니다:\n\n- 이미지 알림 메시지를 통해 서버는 기기에 새로운 펌웨어가 사용 가능하다는 정보를 전달할 수 있습니다. 재미있는 점은 이 메시지가 펌웨어 자체에 대한 구체적인 정보를 포함하지 않을 수 있다는 것입니다. 이는 더 많이 \"알려드립니다, 나에게 궁금증이 있는 것이 있어\"라는 메시지로, 클라이언트 기기에게 정확히 무엇인지 서버에게 문의하도록 유도합니다.\n- 서버는 특정 기기 또는 특정 유형 및 제조업체의 여러 기기들에 대해 한 번에 알림을 보낼 수 있습니다. 대량 업데이트의 경우, 최종 기기들은 동시 업데이트와 네트워크 혼잡을 피하기 위해 임의 지연 후 펌웨어 업데이트를 시작합니다.\n- 쿼리 넥스트 이미지 메시지를 통해 기기는 서버로부터 펌웨어의 구체적인 정보(버전, 크기 및 기타 매개변수)를 요청할 수 있으며, 현재 펌웨어 및 하드웨어 버전을 언급합니다.\n- 특정 기기 모델 및 하드웨어 버전에 대한 새로운 펌웨어가 있으면 서버는 쿼리 넥스트 이미지 응답 메시지로 응답합니다.\n- 이미지 블록 요청 메시지를 사용하여 기기는 펌웨어의 시작으로부터의 오프셋 및 필요한 바이트 수를 지정하여 작은 데이터 청크를 요청합니다. 서버는 요청된 바이트를 이미지 블록 응답 메시지로 전송합니다.\n- Zigbee 메시지 크기 제한으로 한 번에 너무 많은 바이트를 전송하는 것을 방지합니다. NXP 기기의 경우, 전형적인 값은 48바이트입니다. 이론적으로 더 많은 바이트를 전송할 수도 있지만, 그러면 메시지가 단편화되어 조각조각 전송되어야 하며, 중간 기기가 이 전송 형식을 이해하고 단편화된 패킷을 재조립하기 위해 추가 논리 및 리소스를 사용해야 합니다. 이것은 전송 속도를 높이는 것이 아닐 수 있으므로 피하는 것이 좋습니다.\n- 펌웨어를 다운로드한 후, 기기는 업그레이드 엔드 요청 메시지로 서버에 보고합니다. 클라이언트 기기는 무결성, 체크섬 및 요청에 언급된 대로 디지털 서명을 확인해야 합니다. 메시지는 또한 기기가 업데이트할 준비가 되었는지 또는 펌웨어를 다시 다운로드해야 하는지 또는 기기의 다른 마이크로컨트롤러에 대한 추가 펌웨어를 다운로드해야 하는지를 나타냅니다.\n- 서버는 엔드 업그레이드 응답 메시지로 응답하여, 실제로 펌웨어를 플래시 메모리에 기록할 때를 지정합니다. 이는 여러 기기 간의 조정된 펌웨어 업데이트 또는 별도의 펌웨어를 필요로 하는 다중 마이크로컨트롤러가 있는 기기 내에서 업데이트를 조정하는 데 필요할 수 있습니다.\n\nZigbee2mqtt는 일반적으로 이 프로세스를 따르며, 사용 가능한 펌웨어를 확인하고 실제로 펌웨어 업데이트를 구현하는 두 가지 시나리오를 실행합니다.\n\n사용 가능한 업데이트를 확인하는 방법에 대해 이야기해 봅시다. 나는 zigbee2mqtt가 외부 서버에서만 펌웨어 업데이트를 찾는 줄 알았고, 기기 자체가 이 프로세스에 참여해야 하는 이유를 이해하지 못했습니다. 작동 방식은 다음과 같습니다.\n\n<div class=\"content-ad\"></div>\n\n기본적으로 Zigbee2mqtt(Z2M)는 장치의 현재 펌웨어 버전이나 하드웨어 버전을 알지 못합니다(다른 하드웨어 버전은 다른 펌웨어가 필요할 수 있습니다). 게다가 펌웨어 파일은 외부 서버에 위치해 있으며, Z2M은 언제든 사용 가능한 펌웨어 버전을 미리 알지 못합니다. 모든 필요한 정보를 알아내기 위해 다음과 같은 과정이 진행됩니다:\n\n- Zigbee2mqtt는 Image Notify 메시지를 장치에 보냅니다(\"장치야, 뭔가 가지고 왔는데, 이 메시지에서는 뭔지 말하지 않겠어\").\n- 장치는 현재 펌웨어 및 하드웨어 버전을 알리는 Query Next Image Request를 서버에 보냅니다.\n- Zigbee2mqtt는 응답하지 않습니다(Query Next Image Response 메시지 전송 없음)​ ​, 그리고 시간이 초과되면 장치는 초기 상태로 돌아갑니다.\n- 그러나 이제 Z2M은 장치에 설치된 펌웨어와 하드웨어를 알고, 외부 펌웨어 서버에서 업데이트를 확인할 수 있습니다.\n- 업데이트를 찾고 해당 장치의 하드웨어 버전과 호환되면 Zigbee2mqtt 대시보드에 이 정보를 빨간색 \"장치 펌웨어 업데이트\" 버튼과 함께 표시합니다.\n\n사용자가 \"장치 펌웨어 업데이트\" 버튼을 클릭하면, 설명한 과정이 진행됩니다: Image Notify - Query Next Image Request - Image Block Request - End Update Request.\n\n일반적인 OTA 펌웨어 업데이트 체계에 대한 설명을 마치며, 몇 가지 Wireshark 스크린샷을 보여드리겠습니다. 여기에는 현재 펌웨어 버전을 확인하는 부분이 포함되어 있습니다(나중에 업데이트가 있는지 확인하기 위해).\n\n<div class=\"content-ad\"></div>\n\n아래는 펌웨어 업데이트 과정에 대한 몇 개의 스크린샷이 있습니다.\n\n![image1](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_3.png)\n\n![image2](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_4.png)\n\n<div class=\"content-ad\"></div>\n\n업데이트 전체 구조는 명확해 보입니다. 그러나 사실은 그렇게 간단하지 않아요. 이제 세부 사항에 대해 자세히 살펴보려고 해요.\n\n## 속도 제한\n\n위 스크린샷에서 OTA 메시지가 일반 지그비 메시지와 동일하다는 것을 알 수 있어요. 메시지가 직접 전달되지 못할 경우 중간 라우터를 통해 전달됩니다. 펌웨어 데이터 메시지는 네트워크를 통해 일반 장치의 메시지와 함께 이동합니다. 패킷이 손실되면 메시지가 다시 전송됩니다.\n\n항상 절전 모드인 최종 장치에 대한 펌웨어 업데이트도 작동해요. 장치는 다음 메시지를 받기 위해 부모 라우터를 계속 폴링해야 해요. 이 과정은 매우 활동적이며 에너지를 많이 소비해요. 그래서 배터리 구동 장치의 경우 배터리 수준을 지속적으로 확인하고 충전량이 충분하지 않은 경우 업데이트를 시작하지 않아야 합니다.\n\n<div class=\"content-ad\"></div>\n\n또한, Zigbee 네트워크의 대역폭이 매우 높지 않다는 것을 기억해주세요. 이 네트워크는 250 kBaud 속도로 작동하지만 실제로는 실제 처리량이 낮습니다:\n\n- 여러 장치가 동일한 주파수를 공유하며, 한 장치가 업데이트되는 동안 나머지는 정상적으로 작동하여 메시지를 송수신합니다.\n- 대부분의 메시지에는 네트워크 수준의 확인 응답이 전송되며 때로는 응용 프로그램 수준의 응답도 채널을 잠시 사용합니다.\n- 데이터가 중간 라우터를 통해 전송되는 경우, 각 메시지는 적어도 두 번 전송됩니다. 발신자에서 라우터로, 그리고 라우터에서 수신자로. 이 모든 것이 동일한 대역폭을 공유합니다.\n\n펌웨어 업데이트에는 수십 또는 수백 킬로바이트로 측정되는 상당한 양의 데이터가 포함됩니다. 계속해서 스트리밍되는 경우 다른 장치들은 메시지를 보낼 수 없게 됩니다. 그래서 펌웨어 전송 중 데이터 흐름 속도를 제한하기 위한 절차가 개발되었습니다.\n\n여기 작동 방식입니다. 장치는 Image Block Request 메시지로 다음 데이터 블록을 요청합니다. 네트워크가 비교적 자유로울 때, 서버는 SUCCESS 상태와 데이터 바이트를 포함한 Image Block Response를 보냅니다. 그러나 네트워크가 현재 바쁜 상태인 경우, 서버는 기다려야 하는 시간을 나타내며 Image Block Response 메시지를 WAIT_FOR_DATA 상태로 보냅니다.\n\n<div class=\"content-ad\"></div>\n\n또한 빈 메시지를 주고 받지 않도록 하기 위해, 서버는 OTA 클러스터에서 클라이언트에게 MinBlockRequestDelay 속성을 설정할 수 있습니다. 이는 디바이스가 요청 간에 기다려야 하는 최소 시간을 지정합니다. 이를 위해 OTA 클러스터는 밀리초 타이머 메시지를 구독해야 하며, 클러스터는 필요한 시간 간격을 측정할 것입니다.\n\n그러나 패키지 속도 제한은 펌웨어 측면에서 다루지 않을 것입니다. 이 기능은 이미 zigbee2mqtt (더 정확히는 herdsman-converters)에 내장되어 있습니다. 서버 자체가 요청 빈도를 모니터링하고, Image Block Response 패킷을 간단히 지연함으로써 250ms 간격을 유지할 것입니다.\n\n## 상태 지속성\n\n패킷 간에 일시 중지를 포함한 작은 청크로 데이터를 전송하기 때문에, 펌웨어 업데이트는 수십 분 단위로 측정될 수 있는 상당한 시간이 소요될 수 있습니다. 이 기간 동안 다양한 문제가 발생할 수 있습니다 — 배터리가 소진될 수 있고, 전기가 차단될 수 있으며, 네트워크가 사라질 수도 있고, 서버가 고장날 수도 있습니다. 이러한 경우에는 마이크로컨트롤러의 EEPROM에 중간 상태를 저장하여 사용합니다. 따라서 이 상태를 복원하고 펌웨어 다운로드를 계속할 수 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n다행히도 대부분의 이 기능은 SDK에서 구현이 되어 있습니다. 우리는 상태를 저장하고 복원하기 위한 함수만 제공하면 됩니다.\n\n## [Optional] 서버 발견 업그레이드\n\n이전에 업데이트 가능 여부를 확인하고 서버에서 시작된 업데이트 프로세스를 검토한 적이 있습니다. 실제로, 디바이스가 직접 서버에 쿼리 다음 이미지 요청을 보내어 펌웨어 업데이트를 시작할 수 있는 업데이트 시나리오도 있습니다.\n\n일반적으로 OTA 업데이트 서버와 코디네이터는 같은 디바이스일 필요는 없습니다. 업데이트 서버는 다른 주소에 있을 수도 있습니다. 디바이스는 보통 업데이트 서버가 어디에 있는지 알지 못하기 때문에 클라이언트 디바이스를 구성하기 위해 몇 가지 예비 단계가 필요합니다. 이것이 업데이트 서버 발견 절차가 필요한 이유입니다.\n\n<div class=\"content-ad\"></div>\n\n일반적인 개발 과정에요. 클라이언트 기기는 OTA 서버 클러스터를 지원하는지 묻는 방송 Match Descriptor Request를 보냅니다. 서버는 Match Descriptor Response를 보내 응답합니다.\n\n하지만 여기서 끝이 아닙니다. 클라이언트 기기는 서버의 16비트 주소만 알게 되는데 이는 변경될 수 있습니다. 그래서 추가로 IEEE 주소 조회 요청이 필요합니다.\n\n이는 JavaScript 또는 Python과 같은 고수준 언어로 쉽게 구현할 수 있는 선형 알고리즘처럼 보일 수 있습니다. 그러나 펌웨어에는 await이 없기 때문에 요청, 응답 및 그들 사이의 타임아웃을 주의 깊게 처리하는 상태 기계를 만들어야 합니다. 이는 표준의 선택적 부분이며 SDK에 구현되어 있지 않습니다. NXP의 예제에서 이러한 상태 기계는 약 천 줄 정도의 코드로 구현됩니다.\n\n하지만 좋은 소식도 있습니다. 디바이스가 업데이트를 시작하는 기능을 포기하고 zigbee2mqtt가 코디네이터 및 업데이트 서버로 동작한다고 가정하면 Update Server Discovery 절차를 생략할 수 있습니다. 서버가 이미지 알림 메시지로 디바이스에 접근할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## OTA 파일 형식\n\n지그비 장치는 다양한 제조업체와 아키텍처의 마이크로컨트롤러를 사용하여 구축할 수 있습니다. 당연히, 이러한 마이크로컨트롤러용 펌웨어 형식은 다를 것입니다. 그럼에도 불구하고, zigbee2mqtt는 서로 다른 기기에 올바른 펌웨어 버전을 제공하기 위해 각 펌웨어 파일을 어떤 식으로든 구별해야 합니다.\n\n따라서 Zigbee OTA는 모든 제조업체와 마이크로컨트롤러 아키텍처를 위해 통합된 펌웨어 형식을 사용합니다. 이 형식은 Zigbee ZCL 명세서에 자세히 기술되어 있습니다.\n\n![이미지](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_5.png)\n\n<div class=\"content-ad\"></div>\n\n이 형식은 컴파일러 및 링커가 생성하는 것과 다릅니다. 게다가 OTA 펌웨어 파일을 생성할 수 있는데, 예를 들어, 장치에 여러 개의 마이크로컨트롤러가 있는 경우 해당 펌웨어를 업데이트해야 합니다.\n\n좋은 소식은 이것이 실제로 컴파일러에 의해 생성된 펌웨어 파일 위에 덧씌운 것에 불과하다는 점입니다. 그러나 이러한 래퍼를 생성하기 위해서는 여전히 약간의 노력이 필요할 것입니다.\n\n## 플래시 메모리 리매핑 기능\n\nZigbee 프로토콜 측면을 더 잘 이해하려면 JN-AN-1003: JN51xx 부트로더 동작 문서를 참조하시기 바랍니다. 이 문서는 실제로 펌웨어를 마이크로컨트롤러로 로드하는 방법과 해당 펌웨어의 형식, 그리고 UART 펌웨어 업로드 작업에 대해 설명합니다.\n\n<div class=\"content-ad\"></div>\n\n마이크로컨트롤러에는 32KB씩 16개의 섹터로 나누어진 512KB의 플래시 메모리가 포함되어 있습니다. 이 섹터 중 일부는 현재 마이크로컨트롤러의 펌웨어를 호스팅합니다. 나머지 블록은 다운로드한 펌웨어를 저장하는 데 사용될 수 있습니다. 그러나 마이크로컨트롤러를 새 펌웨어로 전환하는 방법은 무엇일까요?\n\nJN5169 마이크로컨트롤러에는 섹터 리매핑 기능이 있습니다. 현재 펌웨어가 들어 있는 섹터와 새 펌웨어를 다운로드할 위치를 지정할 수 있습니다. 새 펌웨어로 전환하는 것은 단순히 섹터를 리매핑하는 것입니다.\n\n물리적 및 논리적 섹터가 어떻게 매치되는지에 대한 예제를 살펴보겠습니다. 처음에는 물리적 및 논리적 섹터의 번호 매기기가 일치할 것입니다.\n\n![이미지](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_6.png)\n\n<div class=\"content-ad\"></div>\n\n새 firmware이 물리적 섹터 0x8부터 0xF까지 다운로드되면, 마이크로컨트롤러는 섹터 리매핑 프로시저를 수행할 수 있습니다 — 논리적 섹터 0은 그 후 물리적 섹터 8을 가리킬 것이고, 섹터 1은 섹터 9를, 이와 같이 계속됩니다 (그 반대도 마찬가지). Firmware은 논리적 주소에서 작동하기 때문에 새 firmware은 재부팅 후에 로드될 것입니다.\n\n![이미지](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_7.png)\n\n위 예시는 firmware 크기가 약 256k이고 8개 섹터를 차지하는 경우를 개요로 합니다. JN-AN-1003 문서와 JN-UG-3115 문서의 부록 F에서는 firmware 크기가 8개 섹터보다 작은 경우의 특별한 노트가 있습니다. 예를 들어, firmware 크기가 딱 6개 섹터인 경우를 살펴보겠습니다. 이 경우, 섹터 0x8부터 0xD에 다운로드되고, 0xE와 0xF 섹터는 사용되지 않습니다.\n\n![이미지](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_8.png)\n\n<div class=\"content-ad\"></div>\n\n재부팅 중에 부트로더는 섹터를 다시 매핑하지만 다운로드한 펌웨어 데이터를 포함하는 섹터에 대해서만 수행합니다 (0x8부터 0xD까지의 섹터). 이것은 섹터 0xE와 0xF에 일부 데이터를 보존하고 싶을 때 유용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_9.png)\n\n펌웨어를 다시 업데이트하기로 결정하면, 논리적인 섹터 0x8부터 0x0F에 다운로드됩니다. 하지만, 다음 펌웨어가 더 크고 6개 대신 7개의 섹터를 사용하는 경우, 물리적인 섹터 0부터 5와 0xE에 쓰여질 것입니다. 이는 펌웨어가 연속적이지 않은 섹터에 기록될 것을 의미합니다. 먼저, 이는 보존하고 싶었던 섹터 0xE의 가치 있는 데이터를 덮어쓸 수 있습니다. 그리고 부트로더는 펌웨어가 연속적인 섹터에 위치해야 하므로, 그렇지 않으면 펌웨어가 올바르게 로드되지 않을 수 있습니다.\n\n저희 예제에서는 어떠한 데이터도 저장하기 위해 플래시 섹터를 사용하지 않을 것입니다 — 마이크로컨트롤러에는 PDM으로 지속되는 값들에 충분한 4k 이프롬이 있습니다. 우리 모델에서는 펌웨어 업데이트를 수행할 때 항상 섹터 0부터 7을 섹터 8부터 0xF로 교체할 예정입니다. 이렇게 함으로써 섹터 번호의 단편화를 피하고 펌웨어 코드를 간단하게 만들 수 있을 것입니다. 따라서 현재 펌웨어는 항상 물리적인 섹터 0부터 7까지 차지하고 있으며, 새로운 펌웨어는 섹터 8부터 0xF에 다운로드된 후 역할이 변경될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n단연코, 펌웨어는 플래시 메모리의 절반인 256 KB보다 커서는 안 됩니다. 그러나 마이크로컨트롤러(그리고 OTA 구현)는 보드에 외부 SPI 플래시 메모리가 있다면 해당 플래시 메모리로 펌웨어를 로드할 수 있습니다. 그래서 256 KB보다 많은 공간이 필요한 사람들은 이 옵션을 탐색하는 것이 유용할 수 있습니다.\n\n# 구현\n\n## OTA 클러스터 추가\n\n그래서 코드 작업을 진행해 봅시다. OTA 클러스터 자체를 추가하는 방법은 다른 클러스터를 추가하는 것과 크게 다르지 않습니다. 먼저, Zigbee 구성 편집기에 OTA 클러스터를 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n위의 GUI에서 변경된 사항은 빌드 프로세스의 일부로 실행되는 ZPSConfig 도구를 사용하여 zps_gen.c/h 파일로 변환됩니다.\n\n다음으로 zcl_options.h에서 클러스터 및 해당 설정을 활성화하세요.\n\n```js\n#define CLD_OTA\n#define OTA_CLIENT\n#define OTA_NO_CERTIFICATE\n#define OTA_CLD_ATTR_FILE_OFFSET\n#define OTA_CLD_ATTR_CURRENT_FILE_VERSION\n#define OTA_CLD_ATTR_CURRENT_ZIGBEE_STACK_VERSION\n#define OTA_MAX_BLOCK_SIZE 48\n#define OTA_TIME_INTERVAL_BETWEEN_RETRIES 10\n#define OTA_STRING_COMPARE\n#define OTA_UPGRADE_VOLTAGE_CHECK\n```\n\n<div class=\"content-ad\"></div>\n\n이제 재미있는 부분이 시작됩니다. 이러한 설정들은 몇 가지 설명이 필요합니다. 그렇지 않으면 OTA 클러스터가 컴파일되지 않습니다:\n\n- CLD_OTA 및 OTA_CLIENT는 OTA 클러스터를 클라이언트 모드로 구현하는 기능을 활성화합니다.\n- OTA_NO_CERTIFICATE — 암호화 인증서를 사용하지 않을 것입니다. 이러한 인증서가 없으며 디지털 서명 검증에 사용되는 라이브러리가 없습니다.\n- OTA_CLD_ATTR_*는 여러 OTA 클러스터 속성을 활성화합니다. zigbee2mqtt에서 사용되지 않을 수 있지만 일부 속성을 포함하겠습니다. 흥미로운 것으로 간주되는 일부 속성을 활성화했습니다.\n- OTA_MAX_BLOCK_SIZE는 다운로드 블록 크기를 48바이트로 설정합니다. 이 매개변수는 데이터를 플래시 메모리에 쓰기 위해 16의 배수여야 합니다. 또한 최대 Zigbee 패킷 크기를 초과하지 않도록 너무 크지 않아야 합니다.\n- OTA_TIME_INTERVAL_BETWEEN_RETRIES — 서버 요청 재시도 간의 간격(예: 서버와의 연결이 끊어졌을 때). 클라이언트가 너무 자주 서버에 요청을 보내지 않도록 간격을 설정합니다.\n- OTA_STRING_COMPARE는 특히 OTA 펌웨어 헤더의 32바이트 문자열 식별자를 통한 펌웨어 유효성 검사를 활성화합니다. 기대하는 값과 일치하지 않으면 펌웨어 업데이트가 오류와 함께 중지됩니다. 또한 이 검사는 펌웨어 다운로드의 맨 처음에 수행됩니다: 헤더와 함께 작은 부분이 다운로드되며 문자열 식별자가 체크되며, 일치하지 않으면 펌웨어가 심지어 다운로드되지 않습니다.\n- OTA_UPGRADE_VOLTAGE_CHECK는 펌웨어를 업데이트하기 전에 배터리 잔량을 확인하고 (배터리가 낮으면 업데이트를 방지) 적용합니다. 라우터에는 관련성이 없지만 전원이 배터리로 공급되는 장치에 유용할 수 있습니다.\n\n또한, `OTA_INTERNAL_STORAGE` 정의를 추가하십시오 — 이 설정은 마이크로콘트롤러의 내부 플래시 메모리에 쓰기를 활성화합니다 (외부 플래시 드라이브가 아닌). 이 define은 OTA 클러스터 코드에서만 사용되지만, 이 설정은 OTA 클러스터 설정이 아닌 보드 및 마이크로컨트롤러의 물리적 특성과 관련이 있다고 생각되어 CMakeList.txt에 배치하기로 결정했습니다.\n\n```js\nADD_DEFINITIONS(\n...\n        -DOTA_INTERNAL_STORAGE\n```\n\n<div class=\"content-ad\"></div>\n\n## OTA 클러스터 초기화\n\n일반 프로젝트 설정이 끝났으니, 추가적인 코드 작성을 시작해봅시다. 문서에는 초기화 프로세스에 대해 상세히 설명되어 있습니다. 흥미로운 점은 NXP 예제에서 몇 가지 측면을 약간 다르게 처리한다는 것입니다. 특히 문서와 다르게 몇 가지 부정확한 정보가 있기 때문에 우리는 문서에서 벗어나 허용하려고 합니다.\n\n문서는 초기화 프로세스를 다음과 같이 설명합니다.\n\n![2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_11.png](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_11.png)\n\n<div class=\"content-ad\"></div>\n\n1~3단계에 문제가 없어요. 이미 Main.cpp에서 우리의 펌웨어를 처리했어요. 하지만 4번째 단계의 설명이 약간 부정확해 보여요. 문서에는 eOTA_Create()를 호출한 후에 즉시 eOTA_UpdateClientAttributes()를 호출하라고 합니다. 하지만 이 방법은 작동하지 않아요. 왜냐하면 eOTA_UpdateClientAttributes()를 호출하려면 OTA 엔드포인트가 먼저 등록되어 있어야 해요. 즉, 6단계(엔드포인트 등록)를 eOTA_Create()와 eOTA_UpdateClientAttributes() 사이에 완료해야 해요.\n\n내 구현에서 OTA 클러스터는 BasicClusterEndpoint 클래스의 다른 기본 장치 클러스터들과 함께 사용될 거예요.\n\n```js\nvoid BasicClusterEndpoint::init()\n{\n    registerBasicCluster();\n    registerIdentifyCluster();\n    registerOtaCluster();\n    registerEndpoint();\n...\n    // OTA 초기화\n    otaHandlers.initOTA(getEndpointId());\n}\n```\n\nOTA 클러스터는 eOTA_Create() 함수로 등록되어요.\n\n<div class=\"content-ad\"></div>\n\n```cpp\nvoid BasicClusterEndpoint::registerOtaCluster()\n{\n    DBG_vPrintf(TRUE, \"BasicClusterEndpoint::registerOtaCluster(): Registering ota cluster\\n\");\n    // 클라이언트로서 OTA 클러스터의 인스턴스를 생성합니다\n    teZCL_Status status = eOTA_Create(&clusterInstances.sOTAClient,\n                                      FALSE,  /* 클라이언트 */\n                                      &sCLD_OTA,\n                                      &sOTAClientCluster,  /* 클러스터 정의 */\n                                      getEndpointId(),\n                                      NULL,\n                                      &sOTACustomDataStruct);\n\n    if(status != E_ZCL_SUCCESS)\n        DBG_vPrintf(TRUE, \"BasicClusterEndpoint::registerOtaCluster(): OTA 클러스터 인스턴스 생성에 실패했습니다. 상태=%d\\n\", status);\n}\n```\n\n이제 OTA 초기화를 진행해야 합니다. OTA와 관련된 모든 것(클러스터 등록을 제외하고)를 단순히 기능을 그룹화하기 위해 별도의 클래스인 `OTAHandlers`로 이동했습니다.\n\n```cpp\nclass OTAHandlers\n{\n    uint8 otaEp;\n    PersistedValue<tsOTA_PersistedData, PDM_ID_OTA_DATA> sPersistedData;\n...\n```\n\n지침의 4단계에서 제안한 대로, OTA 클러스터 속성을 초기화해야 합니다. 언급했듯이 OTA 구현은 펌웨어 업데이트 상태가 EEPROM에 저장되고 재부팅 후에 복원될 것을 가정합니다. 저는 이를 다음과 같이 구현했습니다.\n\n<div class=\"content-ad\"></div>\n\n```cpp\nvoid resetPersistedOTAData(tsOTA_PersistedData * persistedData)\n{\n    memset(persistedData, 0, sizeof(tsOTA_PersistedData));\n}\n\nvoid OTAHandlers::restoreOTAAttributes()\n{\n    // 클러스터 속성을 초기값으로 설정합니다.\n    teZCL_Status status = eOTA_UpdateClientAttributes(otaEp, 0);\n    if(status != E_ZCL_SUCCESS)\n        DBG_vPrintf(TRUE, \"OTAHandlers::restoreOTAAttributes(): OTA 클러스터 속성 생성 실패. 상태=%d\\n\", status);\n\n    // 이전 값 복원 또는 제로 리셋\n    sPersistedData.init(resetPersistedOTAData, \"OTA 데이터\");\n    status = eOTA_RestoreClientData(otaEp, &sPersistedData, TRUE);\n    if(status != E_ZCL_SUCCESS)\n        DBG_vPrintf(TRUE, \"OTAHandlers::restoreOTAAttributes(): OTA 데이터 복원 실패. 상태=%d\\n\", status);\n}\n```\n\neOTA_UpdateClientAttributes() 함수는 클러스터 속성을 일부 초기값으로 설정합니다.\n\n펌웨어 업그레이드 진행 상황은 tsOTA_PersistedData 구조체에 저장됩니다. 이는 펌웨어 업그레이드 프로세스가 재부팅 후 일시 중지 및 재개할 수 있는 모든 정보를 포함합니다. 현재 다운로드된 펌웨어 메타데이터, 크기, 현재 파일 오프셋, 재시도 횟수 등이 포함됩니다. OTA ZCL 구현은 현재 상태를 주기적으로 EEPROM에 저장합니다.\n\n두 번째 코드 블록은 플래시 메모리에서 상태를 읽고 이 정보를 OTA 클러스터 내부 구조에 복원합니다. 첫 번째 장치 시작이며 EEPROM에 상태 레코드가 없는 경우, resetPersistedOTAData() 함수가 호출되어 구조체를 제로값으로 초기화합니다.\n\n<div class=\"content-ad\"></div>\n\n## 플래시 메모리 초기화\n\n이제 펌웨어가 다운로드될 플래시 메모리를 초기화하는 데 집중할 시간입니다.\n\n```js\nvoid OTAHandlers::initFlash()\n{\n    // 잘못된 또는 비연속적인 플래시 리매핑을 수정하고 최적화\n    if (u32REG_SysRead(REG_SYS_FLASH_REMAP) & 0xf)\n    {\n        vREG_SysWrite(REG_SYS_FLASH_REMAP,  0xfedcba98);\n        vREG_SysWrite(REG_SYS_FLASH_REMAP2, 0x76543210);\n    }\n...\n```\n\n이 코드는 논리적인 섹터 0–7 및 8–0xF가 연속적인 물리적 섹터를 사용하도록 섹터 매핑을 준비합니다. 리매핑 과정은 위의 전용 섹션에 설명되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다음으로, 새 펌웨어가 쓰여질 플래시 메모리 공간을 초기화하는 시간입니다. 말씀드렸듯이, 마이크로컨트롤러는 펌웨어용 외부 메모리를 지원합니다. 그러나 현재는 내부 메모리만으로도 충분합니다. (네, 이미 OTA_INTERNAL_STORAGE를 정의했지만, NXP 개발자들에게는 그게 충분하지 않은 것 같습니다).\n\nMarkdown 형식으로 표를 변경합니다.\n\n```js\n    // 다운로드된 펌웨어를 저장하기 위한 플래시 메모리 초기화\n    tsNvmDefs sNvmDefs;\n    sNvmDefs.u32SectorSize = 32*1024; // 섹터 크기 = 32K\n    sNvmDefs.u8FlashDeviceType = E_FL_CHIP_INTERNAL;\n    vOTA_FlashInit(NULL, &sNvmDefs);\n```\n\n여기 또 하나 흥미로운 코드 조각이 있습니다.\n\n```js\n    // 엔드포인트에 대한 일부 OTA 관련 레코드 작성\n    uint8 au8CAPublicKey[22] = {0};\n    uint8 u8StartSector[1] = {8};\n    teZCL_Status status = eOTA_AllocateEndpointOTASpace(\n                            otaEp,\n                            u8StartSector,\n                            OTA_MAX_IMAGES_PER_ENDPOINT,\n                            8,                                 // 이미지당 최대 섹터 수\n                            FALSE,\n                            au8CAPublicKey);\n    if(status != E_ZCL_SUCCESS)\n        DBG_vPrintf(TRUE, \"OTAHandlers::initFlash(): 엔드포인트 OTA 공간 할당 실패 (OTA 빌드가 아닌 경우 무시할 수 있습니다). status=%d\\n\", status);\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드는 새 펌웨어를 다운로드할 위치(논리 섹터 8부터 시작) 및 최대 펌웨어 크기(8개 섹터, 즉 256k)를 지정합니다.\n\n## ZCL 타이머\n\n이어서 펌웨어 업데이트 프로토콜은 외관상 간단해 보이지만 여러 잠재적인 고장 지점이 있습니다. 메시지가 도착하지 않을 수도 있고, 늦게 도착할 수도 있으며, 잘못된 데이터를 포함할 수도 있습니다. 내부 상태 기계는 이러한 상황을 처리하기 위해 가능한 신뢰성 있어야 합니다. 일관되지 않은 상태가 발생하거나 타임아웃이 발생하면 상태 기계는 장치를 정상 작동 상태로 되돌려야 합니다. 실제로 이러한 상황은 상당히 자주 발생합니다. 제 테스트 네트워크에서는 펌웨어 업데이트 중에 3~4회 발생합니다.\n\n지금까지 사용한 대부분의 클러스터는 시간과 독립적으로 작동합니다. 그들은 들어오는 요청을 처리하거나 내부 이벤트가 발생하면 상태 알림을 보냅니다. 그러나 OTA 클러스터는 타임아웃을 세어내려가기 위해 시간을 알아야 합니다. 이를 위해 OTA 클러스터는 한 번에 한 번씩 틱하는 ZCL 타이머를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n그 전에 다음과 같이 ZCLTimer 클래스를 추가했습니다. 그래서 새로운 코드가 필요하지 않습니다. 내용은 다음과 같습니다.\n\n```js\nclass ZCLTimer: public PeriodicTask\n{\n    uint32 tick1s;\n    uint32 tick100ms;\n\npublic:\n    ZCLTimer();\n    void init();\n\nprotected:\n    virtual void timerCallback();\n};\n\nvoid ZCLTimer::init()\n{\n    PeriodicTask::init(10);\n    tick1s = 0;\n    tick100ms = 0;\n}\n\nvoid ZCLTimer::timerCallback()\n{\n    tick1s++;\n    tick100ms++;\n\n    if(tick100ms >= 10)\n    {\n        eZCL_Update100mS();\n\n        tick100ms = 0;\n    }\n\n    if(tick1s >= 100)\n    {\n        // Process ZCL timers\n        tsZCL_CallBackEvent sCallBackEvent;\n        sCallBackEvent.pZPSevent = NULL;\n        sCallBackEvent.eEventType = E_ZCL_CBET_TIMER;\n        vZCL_EventHandler(&sCallBackEvent);\n\n        tick1s = 0;\n    }\n}\n```\n\n내부 타이머는 매 10ms마다 틱하게 됩니다. 1초 주기가 도달하면 코드가 E_ZCL_CBET_TIMER를 생성하고, ZCL이 OTA 작업을 모두 처리합니다.\n\n## OTA 이벤트 처리\n\n<div class=\"content-ad\"></div>\n\nOTA 클러스터는 펌웨어 업데이트 프로세스를 완전히 구현합니다. 때때로 ZCL은 업데이트 진행 상황에 관한 알림을 보냅니다. OTA 관련 작업은 별도의 클래스에서 처리되므로 이벤트 리다이렉션을 OTAHandlers 클래스로 설정했습니다.\n\n```js\nvoid BasicClusterEndpoint::handleClusterUpdate(tsZCL_CallBackEvent *psEvent)\n{\n    uint16 clusterId = psEvent->psClusterInstance->psClusterDefinition->u16ClusterEnum;\n    switch(clusterId)\n    {\n...\n        case OTA_CLUSTER_ID:\n            handleOTAClusterUpdate(psEvent);\n            break;\n...\n\nvoid BasicClusterEndpoint::handleOTAClusterUpdate(tsZCL_CallBackEvent *psEvent)\n{\n    // OTA 메시지 파싱 및 처리\n    tsOTA_CallBackMessage *psCallBackMessage = (tsOTA_CallBackMessage *)psEvent->uMessage.sClusterCustomMessage.pvCustomData;\n    otaHandlers.handleOTAMessage(psCallBackMessage);\n}\n\n...\n\nvoid OTAHandlers::handleOTAMessage(tsOTA_CallBackMessage * pMsg)\n{\n    vDumpOTAMessage(pMsg);\n...\n}\n```\n\n이러한 이벤트 대부분은 우리에게 정보 제공을 위한 것이며 별도의 처리가 필요하지 않습니다. 실제로 이러한 이벤트에 대한 핸들러를 구현하지 않고도 안정적인 펌웨어 업데이트를 성공적으로 달성했습니다.\n\n그러나 이러한 이벤트는 사용자 정의 가능한 가능성을 제공합니다. 예를 들어, NXP의 예시는 OTA 이벤트를 사용하여 장치의 업데이트 필요 여부, 다운로드된 펌웨어의 무결성, 추가적인 타임아웃, 다운로드 상태 모니터링을 확인하는 데 사용합니다(표준 구현 위에 많이 구축하였습니다).\n\n<div class=\"content-ad\"></div>\n\n## [Optional] 컨텍스트 저장 및 복원\n\n핸들링이 필요한 유일한 이벤트는 컨텍스트 저장입니다. OTA 클러스터 구현은 때때로 상태를 저장하여 예기치 않은 재부팅 후 펌웨어 다운로드를 재개할 수 있도록 합니다.\n\n상태를 저장하는 코드는 다음과 같습니다. 상태 자체는 OTA 클러스터 인스턴스 내부에 저장되며 거기서 추출해야 합니다. NXP 예제에서는 OTA의 내부에 직접 액세스하지만, 저는 모듈 간 경계를 유지하고 예의와 존중을 유지하려고 노력했습니다.\n\n```js\nvoid OTAHandlers::saveOTAContext(tsOTA_PersistedData * pData)\n{\n    DBG_vPrintf(TRUE, \"OTA 컨텍스트 저장 중... \");\n\n    // 데이터 저장\n    sPersistedData = *pdData;\n\n    DBG_vPrintf(TRUE, \"완료\\n\");\n}\n\nvoid OTAHandlers::handleOTAMessage(tsOTA_CallBackMessage * pMsg)\n{\n    vDumpOTAMessage(pMsg);\n\n    switch(pMsg->eEventId)\n    {\n    case E_CLD_OTA_INTERNAL_COMMAND_SAVE_CONTEXT:\n        saveOTAContext(&pMsg->sPersistedData);\n        break;\n    default:\n        break;\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n로딩 및 복원 상태도 일부 개선이 필요합니다 (NXP의 예시에서 영감을 받았어요).\n\n```js\nvoid OTAHandlers::restoreOTAAttributes()\n{\n    // 속성을 기본 값으로 재설정합니다\n    teZCL_Status status = eOTA_UpdateClientAttributes(otaEp, 0);\n    if(status != E_ZCL_SUCCESS)\n        DBG_vPrintf(TRUE, \"OTAHandlers::restoreOTAAttributes(): OTA 클러스터 속성 생성에 실패했습니다. status=%d\\n\", status);\n\n    // 이전 값 복원 또는 0으로 재설정\n    sPersistedData.init(resetPersistedOTAData, \"OTA 데이터\");\n\n    // 10초 후 다시 시도되도록 재시도 타이머를 수정합니다\n    if((&sPersistedData)->u32RequestBlockRequestTime != 0)\n    {\n        DBG_vPrintf(TRUE, \"OTAHandlers::restoreOTAAttriutes(): 현재 작업을 10초 후 다시 시도할 것입니다 (이전 값 %d)\\n\", (&sPersistedData)->u32RequestBlockRequestTime);\n        (&sPersistedData)->u32RequestBlockRequestTime = 10;\n    }\n\n    status = eOTA_RestoreClientData(otaEp, &sPersistedData, TRUE);\n    if(status != E_ZCL_SUCCESS)\n        DBG_vPrintf(TRUE, \"OTAHandlers::restoreOTAAttributes(): OTA 데이터 복원에 실패했습니다. status=%d\\n\", status);\n}\n```\n\nu32RequestBlockRequestTime 변수를 조정하는 코드가 추가되었습니다. 기본적으로 긴 시간 초과 (예: 1시간)으로 설정되어 있지만, 재부팅 후 펌웨어 다운로드를 더 빨리 재개하고자 합니다 (10초 이내).\n\n솔직히 말해서, 이 코드에 대해 자신감이 많이 없어요. 한 번 이 설정 전체가 일관성 없는 상태에 갇혔던 적이 있어요. 이게 어떻게 발생했는지 알려드릴게요.\n\n<div class=\"content-ad\"></div>\n\n테스트 목적으로 펌웨어 업데이트 중에 디바이스를 끄고 zigbee2mqtt에서 타임아웃이 발생할 때 어떤 일이 일어날지 확인해봤어요. 다시 켜니까, 디바이스가 이전 상태를 복원했어요. 디바이스는 다음 블록을 요청하려고 시도했지만 물론 받지 못했죠. 여러 차례 시도한 후, 디바이스는 포기하고 정상 작동으로 돌아갔어요.\n\n문제는 이 \"정상 상태\"가 EEPROM에 저장되지 않았고, 내 코드는 이에 대해 전혀 알지 못했어요. 디바이스가 재부팅되면 EEPROM에서 잘못된 상태를 다시 읽고 펌웨어 업데이트를 계속하려고 시도했어요.\n\nNXP 사에서는 이 문제를 해결하기 위해 예제에 추가적인 타임아웃을 넣었더라고 해요. 이 타임아웃이 트리거되면, OTA 클러스터 깊숙한 곳에서 무언가를 강제로 수정하여 원래 상태로 돌아가게 했어요.\n\n아직 이 행동을 처리하거나 컨텍스트 저장을 완전히 비활성화할지 결정하지 않았어요. 디바이스가 리부팅 후 깨끗한 상태로 시작하고, 단순히 펌웨어 업데이트 프로세스를 다시 시작하는게 나을지도 모르겠네요.\n\n<div class=\"content-ad\"></div>\n\n## 펌웨어 바이너리 크기 수정\n\n플래시 메모리에 쓰기 위해서는 데이터가 16바이트의 배수인 블록으로 이루어져야 합니다. 그러나 컴파일러의 펌웨어는 항상 이 크기 요구 사항을 충족시키지 않을 수 있습니다.\n\n이상적으로는 필요한 경우 코드를 조정하여 추가 바이트를 추가하는 것이 간단할 것입니다. 그러나 NXP의 OTA 구현에서 한 가지 문제가 있습니다: 펌웨어가 16바이트의 배수가 아닌 경우, 장치가 실제 크기를 넘어선 블록을 추가로 요청하는 버그가 발생합니다.\n\nOTA 코드에서 이 버그를 수정하는 것이 가능하지만, SDK 코드를 수정하는 것은 제 선택이 아니었습니다. 대신, 이진 크기를 16바이트의 배수로 반올림하는 방법을 찾았으나, 이를 달성하는 방법을 모르겠습니다 (파이썬 스크립트를 사용하여 바이트를 추가하는 방법 뿐일지도 모릅니다).\n\n<div class=\"content-ad\"></div>\n\n결국 특정 스크립트를 사용하여 링커를 조정하는 데 성공했습니다.\n\n```js\nINCLUDE AppBuildZBPro.ld\n\nSECTIONS\n{\n...\n        /*\n         * 이전 섹션이 16바이트 경계로 패딩되도록 더미 섹션을 만듭니다.\n         */\n        .pad ((LOADADDR(.text) + SIZEOF(.text) + SIZEOF(.data) + 15) & ~ 15 ):\n        {\n            . = ALIGN (16);\n            LONG(0x00000000)\n            LONG(0x00000000)\n            LONG(0x00000000)\n            LONG(0x00000000)\n        } > flash\n}\n```\n\n펌웨어 크기를 조정하는 마법은 SDK의 AppBuildZBPro.ld 스크립트를 먼저 실행하는 데 있습니다. 이 스크립트는 필요한 섹션을 삽입하고 모든 것을 마이크로컨트롤러 메모리에 올바르게 배치하여 완전한 이진 파일을 빌드합니다.\n\n핵심은 16개의 0으로 구성된 \"pad\" 섹션을 추가하는 것입니다. 이 섹션은 .text 및 .data 섹션 다음에 16바이트로 정렬됩니다. 이 정렬로 링커는 .pad 섹션 앞에 충분한 바이트를 추가하여 펌웨어의 총 크기가 16바이트의 배수가 되도록합니다. OTA 업데이트용으로 파일 서명이 시작할 때 추가 4바이트도 있지만 이것은 펌웨어의 일부로 간주되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n링커 스크립트는 다음과 같이 CMakeList.txt에 포함되어 있습니다:\n\n```js\nSET(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -T${HelloZigbee_SOURCE_DIR}/HelloZigbee.ld\")\n```\n\n컴파일러 및 링커는 .elf 파일을 생성하며, 이 파일은 마이크로컨트롤러에 직접로드할 수 없습니다. .elf 파일을 플래시 가능한 이진 파일로 변환하기 위해 `objcopy` 유틸리티를 사용합니다. 이 유틸리티를 호출하는 것은 이미 빌드 스크립트의 일부이지만, 우리는 .pad 섹션을 유지하도록 지시해야 합니다. 그렇지 않으면 섹션이 삭제되고 그 앞의 추가 바이트가 제거됩니다. 이를 objcopy 명령에 \" -j .ota\" 옵션을 추가하여 해결합니다.\n\n## OTA 헤더 추가하기\n\n<div class=\"content-ad\"></div>\n\n모두 해결되었다고 생각했을 때, 그 이상이 있습니다! 이 코드가 작동하려면 또 다른 링커 매직이 필요합니다.\n\nOTA 업데이트 서버는 마이크로컨트롤러에 로드된 펌웨어를 식별해야 합니다. 이는 펌웨어 버전, 하드웨어 버전, 펌웨어 파일 유형 및 기타 세부 정보를 포함합니다. 이 모든 정보를 상수나 정의로 컴파일하여 펌웨어에 포함시킬 수 있지만, NXP 개발자들은 펌웨어에 완전한 OTA 헤더를 포함하기로 선택했습니다. 이 구조의 모든 필드가 컴파일 시간에 알려지지 않기 때문에 펌웨어 코드는 .ro_ota_header 섹션에 구조체에 대한 공간을 예약하여 이를 처리합니다. 이 구조체는 완성된 펌웨어 이진 파일에서 외부 Jennic 암호화 도구(JET)를 통해 직접 채워집니다.\n\n하지만 문제가 있습니다. JET은 펌웨어 내 OTA 구조의 정확한 위치를 알아야 합니다. 이를 위해 링커는 파일 시작점으로부터 특정 오프셋에 .ro_ota_header 섹션을 배치해야 합니다.\n\n그 외에도 이 섹션 앞에 다른 섹션이 필요합니다. 즉, .ro_mac_address가 있어야 합니다. 각 칩은 공장에서 고유한 MAC 주소가 할당되지만 때로는 JET 도구를 사용하여 이 주소를 재정의해야 할 수도 있습니다. 재정의 MAC 주소 기능을 사용하지는 않지만, .ro_mac_address 섹션이 펌웨어에 있어야 합니다. 그렇지 않으면 JET이 .ro_ota_header를 놓칠 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n사용되지 않더라도 파일에 모든 섹션이 유지되도록 하려면 다른 링커 기술을 사용할 수 있습니다. 링커 스크립트의 KEEP 키워드는 모든 필요한 섹션을 보존하여 이를 달성하는 데 도움을 줍니다.\n\n```js\nSECTIONS\n{\n        .ro_mac_address :\n        {\n            KEEP(*(.ro_mac_address));\n        } > flash\n\n        .ro_ota_header :\n        {\n            KEEP(*(.ro_ota_header));\n        } > flash\n        \n        .ro_se_lnkKey :\n        {\n            KEEP(*(.ro_se_lnkKey));\n        } > flash\n...\n```\n\n이전에 결과 이진 파일에서 모든 섹션을 유지하도록 objcopy 유틸리티에 알려야 한다고 언급했습니다. 이를 위해 \"objcopy\"의 command line 옵션에 \"-j .ro_mac_address -j .ro_ota_header\"를 추가합니다.\n\nSDK에 포함된 JET 유틸리티에 대해 이해해야 합니다. 해당 작업은 JN-UG-3081 문서에 자세히 설명되어 있습니다. 불행히도 이 문서는 내재적인 프로세스를 충분히 명확히 하지 않습니다. 기존 지식을 전제로 한 세부 정보를 생략합니다. 그래서 올바른 설정을 찾기 위해 시행착오 방법을 사용해야 했습니다.\n\n<div class=\"content-ad\"></div>\n\n\nC:\\NXP\\bstudio_nxp\\sdk\\JN-SW-4170\\Tools\\OTAUtils\\JET.exe -m otamerge --embed_hdr -c HelloZigbee.bin -o HelloZigbee.ota.bin -v JN516x -n 1 -t 1 -u 0x1037 -j \"HelloZigbee2021                 \"\n\n\n위 명령어에서 각 옵션의 의미는 다음과 같습니다:\n\n- -m otamerge는 다양한 OTA 정보를 단일 이진 파일로 병합하는 모드를 활성화합니다.\n- --embed_hdr는 OTA 헤더를 이진 파일에 포함하는 서브 모드를 활성화합니다.\n- -c HelloZigbee.bin은 objcopy에서 얻은 소스 펌웨어 파일을 지정합니다. -c는 펌웨어가 OTA 클라이언트용으로 빌드되었음을 나타냅니다.\n- -o HelloZigbee.ota.bin은 결과 파일의 이름을 지정합니다. 이 파일은 아직 서버에 배치될 수 없지만 이미 마이크로컨트롤러에 플래시될 수 있습니다.\n- -v JN516x는 마이크로컨트롤러 패밀리명을 나타냅니다 (다른 마이크로컨트롤러는 다른 펌웨어 형식을 갖습니다).\n- -n 1은 펌웨어 파일 버전을 설정합니다.\n- -t 1은 펌웨어 파일 유형을 설정합니다 (보드에 여러 마이크로컨트롤러가 있고 각각이 자체 펌웨어를 필요로 하는 경우 해당됨. 여기서는 하나의 유형만 사용할 것입니다).\n- -u 0x1037은 제조사 ID를 지정합니다. 현재는 NXP의 ID를 사용합니다.\n- -j “HelloZigbee2021 “ (위 명령줄과 같이 정확히 많은 공백이 있는 상태) — OTA 헤더에 32바이트 문자열을 플래시합니다. 이 문자열은 펌웨어 업데이트 중에 확인되며 (업데이트할 펌웨어는 동일한 헤더 문자열을 가져야 함) 펌웨어가 로드되지 않습니다.\n\n참고로, OTA 헤더에 포함된 펌웨어 버전은 기본 클러스터에서 보고되고 Z2M 장치 정보 페이지에 표시되는 펌웨어 버전 문자열과 동일하지 않습니다. 이는 단순히 업데이트 프로세스에 참여하지 않는 문자열일 뿐입니다.\n\n\n<div class=\"content-ad\"></div>\n\n## OTAP 펌웨어\n\n이러한 단계를 따르면 마이크로컨트롤러에 플래시할 준비가 된 적절한 펌웨어를 생성할 수 있습니다. 완료되면 펌웨어 내부의 OTAP 헤더에 액세스해야 하는 모든 기능이 의도대로 작동합니다. 그러나 올바른 펌웨어를 생성하는 것만으로는 서버에 업로드하여 OTAP 업데이트를 할 수 없습니다.\n\n이전에 설명했듯이 OTAP 업데이트용 펌웨어의 구조는 지그비 표준에 의해 지정됩니다. 이 펌웨어는 주요 마이크로컨트롤러 펌웨어 주변을 감싸며 무선 업데이트에 적합한 형식을 제공합니다.\n\n이러한 유형의 파일을 준비하기 위해 JET 유틸리티를 다시 사용하지만 다른 설정으로 사용합니다. 이전에 사용한 -- embed_hdr 대신 -- ota 옵션을 사용합니다. 이 방법을 통해 펌웨어가 OTAP 배포를 위한 올바른 형식으로 되어 있음을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nJET.exe -m otamerge --ota -v JN516x -n 2 -t 1 -u 0x1037 -p 1 -c HelloZigbee.bin -o HelloZigbee.ota\n```\n\n다음은 매개변수 설명입니다.\n\n- -m otamerge는 서로 다른 OTA 정보를 하나의 이진 파일로 병합하는 모드를 활성화합니다.\n- --ota는 하나 또는 여러 이진 파일에서 OTA 형식 펌웨어를 컴파일하는 하위 모드를 활성화합니다.\n- -c HelloZigbee.bin은 이전 단계에서 얻은 소스 펌웨어 파일을 지정합니다. (임베디드 OTA 헤더가 포함됨). -c는 OTA 클라이언트용이므로 사용됩니다.\n- -o HelloZigbee.ota는 생성된 파일의 이름을 지정하며, 이후 서버에 배치할 수 있습니다.\n- -v JN516x는 마이크로컨트롤러 패밀리 이름을 나타냅니다. (다른 마이크로컨트롤러는 다른 펌웨어 형식을 가지고 있습니다).\n- -n 2는 펌웨어 파일 버전을 설정합니다.\n- -t 1은 펌웨어 파일 유형을 설정합니다 (보드에 여러 마이크로컨트롤러가 있고 각각의 펌웨어가 필요한 경우 해당됩니다. 여기서는 하나의 유형만 사용합니다).\n- -u 0x1037은 제조사 ID를 지정합니다. 현재는 NXP의 ID를 사용합니다.\n- -p 1은 매우 중요한 스위치입니다. 파일의 시작 부분에 4바이트 서명을 추가합니다. 이를 사용하지 않으면 zigbee2mqtt가 이러한 펌웨어를 거부합니다.\n\n이상적으로는 빌드마다 증가하는 버전 번호를 자동으로 생성하는 CI를 설정하는 것이 좋습니다. 하지만 현재 CI를 설정하기 귀찮아서 다음과 같은 해킹을 사용합니다. 플래시 도구를 통해 플래시될 펌웨어를 빌드할 때는 버전 #1을 지정하고, 서버에 배치할 펌웨어를 컴파일할 때는 #2를 포함합니다 (-n 2 키를 보십시오). 이렇게 하면 서버의 버전이 마이크로컨트롤러의 버전보다 항상 최신 상태가 됩니다. 물론 실제 장치에 대해서는 더 전문적으로 처리해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n저는 상기 설명된 모든 마법같은 기능들을 여러 개의 CMake 함수로 캡슐화했습니다.\n\n```js\nFUNCTION(ADD_HEX_BIN_TARGETS TARGET)\n    IF(EXECUTABLE_OUTPUT_PATH)\n      SET(FILENAME \"${EXECUTABLE_OUTPUT_PATH}/${TARGET}\")\n    ELSE()\n      SET(FILENAME \"${TARGET}\")\n    ENDIF()\n    ADD_CUSTOM_TARGET(OUTPUT \"${TARGET}.hex\"\n        DEPENDS ${TARGET}\n        COMMAND ${CMAKE_OBJCOPY} -Oihex ${FILENAME} ${FILENAME}.hex\n    )\n    ADD_CUSTOM_TARGET(\"${TARGET}.bin\"\n        DEPENDS ${TARGET}\n        COMMAND ${CMAKE_OBJCOPY} -j .version -j .bir -j .flashheader -j .vsr_table -j .vsr_handlers -j .rodata -j .text -j .data -j .bss -j .heap -j .stack -j .ro_mac_address -j .ro_ota_header -j .pad -S -O binary ${FILENAME} ${FILENAME}.tmp.bin\n        COMMAND \"${SDK_PREFIX}\\\\Tools\\\\OTAUtils\\\\JET.exe\" -m otamerge --embed_hdr -c ${FILENAME}.tmp.bin -v JN516x -n 1 -t 1 -u 0x1037 -o ${FILENAME}.bin\n    )\nENDFUNCTION()\n\nFUNCTION(ADD_OTA_BIN_TARGETS TARGET)\n    IF(EXECUTABLE_OUTPUT_PATH)\n      SET(FILENAME \"${EXECUTABLE_OUTPUT_PATH}/${TARGET}\")\n    ELSE()\n      SET(FILENAME \"${TARGET}\")\n    ENDIF()\n    ADD_CUSTOM_TARGET(${TARGET}.ota\n        DEPENDS ${TARGET}.bin\n # HACK/TODO: setting file version to 2 (-n 2), so that OTA image is always newer than current version\n        COMMAND \"${SDK_PREFIX}\\\\Tools\\\\OTAUtils\\\\JET.exe\" -m otamerge --ota -v JN516x -n 2 -t 1 -u 0x1037 -p 1 -c ${FILENAME}.bin -o ${FILENAME}.ota\n    )\nENDFUNCTION()\n```\n\n생성된 OTA 파일에는 두 개의 OTA 헤더가 포함되어 있는 점을 중요하게 고려해야 합니다:\n\n- 첫 번째는 Zigbee 표준을 준수하는 펌웨어를 보장하는 외부 래퍼입니다. 이 헤더는 zigbee2mqtt에게 펌웨어 파일의 특성에 대한 정보를 제공합니다.\n- 두 번째는 펌웨어 자체에 내장된 헤더입니다. OTA 업데이트 과정에서 외부 래퍼는 삭제되고, 내장 OTA 헤더가 펌웨어가 자체 세부 사항을 이해하는 소스로 남게 됩니다. 버전, 이름 문자열, 제조업체 코드 등에 대한 정보가 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n## OTA 펌웨어 업데이트 with zigbee2mqtt\n\nzigbee2mqtt 대시보드를 통해 OTA 펌웨어 업그레이드를 시작하려면, 먼저 장치 변환기를 구성하여 해당 장치가 OTA 업데이트를 지원함을 인식하도록 설정해야 합니다. 이를 위해 herdsman-converter가 제공하는 표준 OTA 프로시저를 활용할 것입니다.\n\n```js\nconst ota = require('zigbee-herdsman-converters/lib/ota')\n\nconst device = {\n...\n    ota: ota.zigbeeOTA\n};\n```\n\nOTA 펌웨어 업데이트는 z2m 대시보드의 OTA 탭에서 수행됩니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_12.png\" />\n\n지그비2mqtt 대시보드에서 '새 업데이트 확인' 버튼을 클릭하면, 지그비 허즈맨이 온라인 목록을 쿼리하여 사용 가능한 펌웨어 업데이트를 확인합니다. 당연히, 이 목록에는 사용자 정의 펌웨어가 포함되지 않을 것입니다. 그러나 지그비 허즈맨은 인덱스 오버라이드 파일의 사용을 허용하여 로컬 파일을 지정할 수 있습니다. 이러한 로컬 파일의 경우, 모든 세부 정보를 입력할 필요는 없습니다 — 파일 위치만 필요합니다. 따라서, 우리의 인덱스 파일은 이에 맞게 설정될 것입니다.\n\n```js\n[\n    {\n        \"url\": \"HelloZigbee.ota\",\n        \"force\": true\n    }\n]\n```\n\n지그비2mqtt는 서버에 있는 펌웨어 버전을 기기에 현재 있는 버전과 비교하여 업그레이드가 제안되는지 확인하고, 서버 버전이 더 최신일 때에만 업그레이드 제안을 합니다. 개발 중에는 버전 비교와 관계없이 특정 펌웨어로 업그레이드를 강제로 실행하는 것이 유용할 수 있습니다. 이를 위해, 인덱스 파일에 \"force\": true 옵션을 포함합니다. 이 설정은 기기에 있는 버전이 서버에 있는 버전과 동일하거나 더 최신해도 zigbee2mqtt가 업데이트를 계속 진행하도록 지시합니다.\n\n<div class=\"content-ad\"></div>\n\n이제 이 인덱스가 configuration.yaml에서 활성화되어야 합니다.\n\n```yaml\nota:\n    zigbee_ota_override_index_location: index.json\n```\n\nHelloZigbee.ota 펌웨어 파일과 index.json 파일은 데이터 디렉토리 안에 configuration.yaml 파일과 함께 위치해야 합니다. 다시 시작한 후, zigbee2mqtt는 인덱스 파일을 인식하고 사용 가능한 업데이트 목록에 펌웨어를 포함시킵니다.\n\n'새 업데이트 확인' 버튼을 클릭하면 zigbee2mqtt가 디바이스의 현재 펌웨어 버전을 문의합니다. 서버의 펌웨어가 디바이스의 것보다 최신이거나 \"force\" 옵션이 활성화된 경우, zigbee2mqtt는 펌웨어 업데이트를 제안할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## 요약\n\n우후, 아마도 가장 어려운 부분이었을 것 같아요. 정보가 부족하다는 게 아니에요 — 오히려, 한꺼번에 너무 많은 정보를 소화해야 했어요. 그러나 이해하고 모든 것이 정리되면 그리 어려운 게 아니라는 걸 알게 되었죠.\n\n이 기사에서는 Zigbee 기기에 대한 무선 펌웨어 업데이트를 수행하는 방법을 보여드렸어요. 단계별 안내뿐만 아니라 각 단계의 목적과 다르게 처리할 경우 어떤 일이 발생할지에 대해서도 설명하려고 노력했어요.\n\n# 링크\n\n<div class=\"content-ad\"></div>\n\n- 깃허브 프로젝트\n- JN-UG-3115 지그비 클러스터 라이브러리 (지그비 3.0용) 사용자 가이드\n- JN-UG-3113 지그비 3.0 스택 사용자 가이드\n- 응용 프로그램 노트: JN-AN-1003: JN51xx 부트로더 작동\n- JN-UG-3081 JN51xx 암호화 도구 (JET) 사용자 가이드\n- 지그비 클래스 라이브러리 명세서\n- 지그비 트래픽을 스니핑하는 방법\n- zigbee2mqtt에 새 기기 추가\n\n# 지원\n\n이 프로젝트는 취미 프로젝트로 무료로 개발 중입니다. 동시에 작은 기부로 프로젝트를 지원해주시면 감사하겠습니다.\n\n<img src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_13.png\" />","ogImage":{"url":"/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_0.png"},"coverImage":"/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_0.png","tag":["Tech"],"readingTime":32},{"title":"조시ai, 커스텀 설치자들의 작업 흐름을 간소화하는 Specifi 파트너 ","description":"","date":"2024-06-19 17:11","slug":"2024-06-19-JoshaiSpecifiPartnertoStreamlineWorkflowsforCustomInstallers","content":"\n\n<img src=\"/assets/img/2024-06-19-JoshaiSpecifiPartnertoStreamlineWorkflowsforCustomInstallers_0.png\" />\n\n댄버 — 2024년 6월 11일 — AI 기반 스마트 홈 제어 분야의 선두주자인 Josh.ai가, 전문 설치자를 위한 시스템 설계, 제안 및 프로젝트 관리 소프트웨어를 제공하는 신속히 성장 중인 Specifi와의 파트너십을 발표했습니다. 이 협업은 Specifi 딜러들을 위한 설계 및 제안 워크플로우를 간소화하며, Josh.ai 제품에 쉽게 접근할 수 있게 함과 동시에 고객을 위한 설득력 있는 제안서를 작성할 수 있게 지원합니다.\n\nSpecifi와의 이번 파트너십은 Josh.ai가 딜러들에게 최고 수준의 영업 지원 도구를 제공하는 데 대한 의지를 보여줍니다. 본 파트너십을 통해 Specifi 사용자들은 다음과 같은 혜택을 누릴 수 있습니다:\n\n- 모든 시스템 설계와 제안서에 Josh.ai 제품을 효율적으로 추가할 수 있습니다.\n- 견적 작성 시 Josh.ai 대표 및 기술 지원팀과 실시간 협업이 가능합니다.\n- Josh.ai 솔루션을 효과적으로 전시하는 전문적이고 시각적으로 매력적인 제안서를 작성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-JoshaiSpecifiPartnertoStreamlineWorkflowsforCustomInstallers_1.png\" />\n\n## Specifi IO 소개\n\nSpecifi IO는 2021년에 북아일랜드 벨파스트에서 설립되었습니다. 이 프로젝트 관리 및 제안 플랫폼은 특히 맞춤형 인테그레이터를 위해 설계되었습니다. Specifi IO의 클라우드 기반 플랫폼을 통해 인테그레이터들은 업무 흐름을 최적화하고 효율성을 향상시킬 수 있습니다. 전 세계 주요 인테그레이터들이 사용하는 Specifi IO는 최근 출시된 Specifi WebBuilder로 온라인 존재감을 향상시키는 데도 도움을 줍니다. (https://www.specifi.io/website-builder).\n\n## Josh.ai 소개\n\n<div class=\"content-ad\"></div>\n\n2015년에 설립된 Josh.ai는 덴버를 기반으로 하는 회사로, 일상생활에서 기술과 진정한 자연스러운 상호 작용을 가능하게 하는 플랫폼과 제품을 만들고 있습니다. AI, 기계 학습 및 직관적인 디자인에 초점을 맞춰, Josh.ai의 미션은 우리가 환경 속에서 살아가는 방식을 변화시키는 것입니다. Josh.ai가 제공하는 간단하고 비공개적이며 마법같은 스마트 홈 경험에 대해 더 알아보려면 www.josh.ai을 방문하거나 hello@josh.ai로 이메일을 보내주세요.","ogImage":{"url":"/assets/img/2024-06-19-JoshaiSpecifiPartnertoStreamlineWorkflowsforCustomInstallers_0.png"},"coverImage":"/assets/img/2024-06-19-JoshaiSpecifiPartnertoStreamlineWorkflowsforCustomInstallers_0.png","tag":["Tech"],"readingTime":2},{"title":"안녕하세요, 지그비 세계, 18부 - 사용자 정의 zigbee2mqtt 외부 변환기","description":"","date":"2024-06-19 17:08","slug":"2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter","content":"\n\n이전 두 편의 글에서는 스마트 스위치에 여러 작업을 지원하는 기능을 구현하여, 멀티스테이트 입력 클러스터를 통해 단일/더블/트리플/롱 프레스를 처리하고 보고할 수 있게 되었습니다. 또한 On/Off 스위치 설정 클러스터의 사용자 정의 확장을 통해 장치의 설정을 제어하는 기능도 구현했습니다. 이러한 추가 기능으로 사용자들은 Zigbee 시설을 이용하여 런타임에서 장치를 구성할 수 있게 됩니다.\n\n그러나 한 가지 문제가 있습니다: 우리는 장치 측면에서 이를 구현했지만, zigbee2mqtt와 같은 다른 시스템들은 이러한 추가 기능과 어떻게 작동해야 하는지 알지 못합니다. 이 글에서는 우리의 장치를 지원하기 위해 zigbee2mqtt용의 외부 컨버터 — 특별한 플러그인을 작성하는 방법을 상세히 설명하고 있습니다.\n\n일반적으로, 나의 코드는 이전 글에서 만든 코드를 기반으로 합니다. 개발 보드로는 NXP JN5169 마이크로컨트롤러를 기반으로 한 EBYTE E75-2G4M10S 모듈을 사용할 것입니다. 이 글은 Hello Zigbee 시리즈에 훌륭한 추가 내용이 되며, 처음부터 Zigbee 장치 펌웨어를 구축하는 방법을 설명하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Zigbee2mqtt 외부 컨버터\n\n안타깝게도 외부 컨버터에 대한 문서화가 매우 미흡하며, 정확히 함수가 무엇을 해야 하는지에 대한 좋은 설명을 찾지 못했습니다. 조금 모호한 예제 몇 개가 있지만, 이에 대해 많은 의문이 듭니다.\n\n우리의 사용자 정의 On/Off Switch Configuration Cluster를 지원하기로 시작합시다. 저는 직접 `poke` 메서드를 사용하여 내 컨버터를 작성해야 했고, 그들이 어떻게 동작해야 하는지 파악하기 위해 수십 개의 기존 컨버터를 살펴보았습니다. 제가 제작 중일 때 컨버터에 대해 공부한 내용은 다음과 같습니다.\n\n모든 컨버터는 `imports`로 시작합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst fz = require('zigbee-herdsman-converters/converters/fromZigbee');\nconst tz = require('zigbee-herdsman-converters/converters/toZigbee');\nconst exposes = require('zigbee-herdsman-converters/lib/exposes');\nconst reporting = require('zigbee-herdsman-converters/lib/reporting');\nconst e = exposes.presets;\nconst ea = exposes.access;\n```\n\n우리가 맞춤 필드를 여러 개 추가했기 때문에, 그들과 관련된 유형 및 데이터 구조를 설명해야 합니다. Herdsman converters 프로젝트에서 정의된 모든 가능한 유형이 있습니다. 불행하게도, TypeScript에서 구조체를 JavaScript 코드로 가져오는 방법을 찾지 못해 필요한 유형의 값을 중복해서 작성해야 했습니다.\n\n```js\nconst DataType = {\n    uint16: 0x21,\n    enum8: 0x30,\n}\n```\n\n새로운 속성에 대한 열거형 값들을 정의해봅시다. 값들의 순서는 펌웨어 코드에 설명된 것과 동일하며, 변환기 코드는 목록에서 위치 번호를 해당 값과 일치시키기만 하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst switchTypeValues = ['toggle', 'momentary', 'multifunction'];\nconst switchActionValues = ['onOff', 'offOn', 'toggle'];\nconst relayModeValues = ['unlinked', 'front', 'single', 'double', 'tripple', 'long'];\n```\n\n제조업체별 속성을 참조할 때에는 속성 식별자 뿐만 아니라 제조업체 코드도 명시해야 합니다. 그렇지 않으면 ZCL 펌웨어 코드에서 요청을 거부합니다.\n\n```js\nconst manufacturerOptions = {\n    jennic: {manufacturerCode: 0x1037}\n}\n```\n\n이제 z2m 웹 양식에 해당 필드를 등록해야 합니다. 이러한 필드는 디바이스의 Exposes 탭에 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction genSwitchEndpoint(epName) {\n   return [\n       e.switch().withEndpoint(epName),\n       exposes.enum('switch_mode', ea.ALL, switchModeValues).withEndpoint(epName),\n       exposes.enum('switch_actions', ea.ALL, switchActionValues).withEndpoint(epName),\n       exposes.enum('relay_mode', ea.ALL, relayModeValues).withEndpoint(epName),\n       exposes.numeric('max_pause', ea.ALL).withEndpoint(epName),\n       exposes.numeric('min_long_press', ea.ALL).withEndpoint(epName),\n   ]\n}\n\nfunction genSwitchEndpoints(endpoinsCount) {\n   let features = [];\n\n   for (let i = 1; i <= endpoinsCount; i++) {\n       const epName = `button_${i}`;\n       features.push(...genSwitchEndpoint(epName));\n   }\n\n   return features;\n}\n```\n\n주어진 엔드포인트 수에 대해 첫 번째 함수는 스위치 위젯 (e.switch())과 구성 필드 시리즈를 생성합니다. 결과물은 다음과 같습니다.\n\n<img src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_1.png\" />\n\n2~3개 값으로 이루어진 열거형 필드는 버튼으로, 다른 필드(relay_mode)는 드롭다운 목록으로 변환되었습니다. 마지막 두 숫자 필드는 증가/감소 화살표가 있는 입력 필드입니다.\n\n<div class=\"content-ad\"></div>\n\n이제 이에 생명을 불어넣고, 3개의 변환 함수를 작성해야 합니다. 이 3개의 함수는 toZigbee 및 fromZigbee라는 코드명으로 구성되어야 합니다. 정확히 무슨 의미인지는 아래에서 설명하겠습니다.\n\n양식을 변경할 때 zigbee2mqtt는 toZigbee 구조에서 convertSet() 함수를 호출합니다. key 필드는 또한 우리의 컨버터가 처리할 수있는 매개변수 목록을 지정합니다.\n\n```js\nconst toZigbee_OnOffSwitchCfg = {\n   key: ['switch_mode', 'switch_actions', 'relay_mode', 'max_pause', 'min_long_press'],\n\n   convertSet: async (entity, key, value, meta) => {\n       let payload = {};\n       let newValue = value;\n\n       switch(key) {\n           case 'switch_mode':\n               newValue = switchModeValues.indexOf(value);\n               payload = {65280: {'value': newValue, 'type': DataType.enum8};\n               await entity.write('genOnOffSwitchCfg', payload, manufacturerOptions.jennic);\n               break;\n\n           case 'switch_actions':\n               newValue = switchActionValues.indexOf(value);\n               payload = {switchActions: newValue};\n               await entity.write('genOnOffSwitchCfg', payload);\n               break;\n\n           case 'relay_mode':\n               newValue = relayModeValues.indexOf(value);\n               payload = {65281: {'value': newValue, 'type': DataType.enum8};\n               await entity.write('genOnOffSwitchCfg', payload, manufacturerOptions.jennic);\n               break;\n\n           case 'max_pause':\n               payload = {65282: {'value': value, 'type': DataType.uint16};\n               await entity.write('genOnOffSwitchCfg', payload, manufacturerOptions.jennic);\n               break;\n\n           case 'min_long_press':\n               payload = {65283: {'value': value, 'type': DataType.uint16};\n               await entity.write('genOnOffSwitchCfg', payload, manufacturerOptions.jennic);\n               break;\n\n           default:\n               break;\n       }\n\n       result = {state: {[key]: value}\n       return result;\n   },\n```\n\ntoZigbee_OnOffSwitchCfg::convertSet() 함수는 텍스트 속성 이름과 설정할 속성 값들을 받습니다. 이 함수의 목표는 이를 네트워크로 전송할 수 있는 구조로 변환하는 것입니다. 표준 속성 (예: switch_actions)의 경우, 단순히 속성 키-값 쌍이 될 것이지만, 값은 숫자로 변환됩니다. herdsman 변환기 코드는 표준 속성 및 이들의 형식, 네트워크로 전달하는 방법 등을 알고 있습니다. 비표준 속성 (예: relay_mode)의 경우, 세 개의 값으로 변환해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n- 숫자 속성 식별자 (10진 형식으로 설정해야 함 — 예: 65280)\n- 속성 유형 (유형 식별자)\n- 값 (열거형의 경우 값 색인)\n\n이러한 값들은 낮은 수준의 Zigbee 메시지로 묶여 네트워크를 통해 전송됩니다. 엔티티 객체는 읽기 및 쓰기 명령이 실행되는 엔드포인트입니다. 비표준 속성을 위해 제조사별 코드를 지정하는 것이 필수적입니다 (manufacturerOptions.jennic 사용).\n\n함수는 속성의 새로운 상태를 반환해야 합니다. 그 결과는 꼼꼼한 종류의 구조로 구성되어야 하며, 그렇지 않으면 웹 양식의 버튼 값이 변경되지 않습니다.\n\n새로운 속성 값을 보내는 스니퍼는 다음과 같이 보일 것입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_2.png\" />\n\n디바이스 측에서는 ZCL 구현이 들어오는 요청을 파싱하고, 자동으로 새 값을 해당 필드에 설정합니다.\n\n```js\nZPS_EVENT_APS_DATA_INDICATION: SrcEP=1 DstEP=2 SrcAddr=0000 Cluster=0007 () Status=0\nZCL Write Attribute: Clustter 0007 Attrib ff00\nZCL Endpoint Callback: Write attributes completed\nZPS_EVENT_APS_DATA_CONFIRM: SrcEP=2 DstEP=1 DstAddr=0000 Status=0\nZPS_EVENT_APS_DATA_ACK: SrcEP=1 DrcEP=2 DstAddr=0000 Profile=0104 Cluster=0007 ()\n```\n\n속성을 읽는 것이 더 어려워 보입니다. 기본적으로 zigbee2mqtt UI는 현재 속성 값을 표시하지 않습니다. 속성 중 하나 옆의 \"업데이트\" 버튼을 클릭하면 toZigbeeConverter::convertGet() 함수가 호출됩니다.\n\n<div class=\"content-ad\"></div>\n\n처음에는 이름인 toZigbee::converterGet()에 매우 혼동을 겪었어요. 왜 fromzigbee가 아니지? 네트워크에서 데이터를 받는 거 아니면서도 말이죠? 그런데 코드를 더 정확하게 살펴보니까 더 명확해졌어요: toZigbee 구성 요소는 (읽기 요청이더라도) 네트워크로 요청을 준비하는 역할을 담당하고 있어요. 장치는 나중에 읽기 속성 응답 메시지를 포함한 읽기 값이 들어있는 응답을 보내줄 거예요. 그럼 fromZigbee 구성 요소는 네트워크로부터 도착한 내용을 구문 분석하게 됩니다 (하지만 이에 대해서는 나중에 더 자세히 이야기할게요).\n\n대부분의 변환기 구현은 한 번에 모든 속성을 가져오기 위해 일괄 요청을 사용해요 - Zigbee 사양이 이를 허용하기 때문이죠. 안타깝게도, 표준 속성('switchActions')과 제조사별 속성을 사용하고 있기 때문에 이들을 한 번에 가져오기가 불가능해요. 따라서 제 구현은 한 번에 하나의 속성을 가져올 거에요. 물론, 표준이 아닌 속성을 읽는 것은 제조사 코드가 필요할 거에요.\n\n스니퍼에서 읽기 요청이 어떻게 보이는지 살펴보세요.\n\n<div class=\"content-ad\"></div>\n\n이것이 테이블 태그이며, 이것이 답변입니다.\n\n\n![이미지](/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_4.png)\n\n\n단말기에서 패킷을 수신한 코디네이터는 fromZigbee 구성 요소가 요청의 구문 분석을 수행합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst getKey = (object, value) => {\n    for (const key in object) {\n        if (object[key] == value) return key;\n    }\n};\n\nconst fromZigbee_OnOffSwitchCfg = {\n   cluster: 'genOnOffSwitchCfg',\n   type: ['attributeReport', 'readResponse'],\n\n   convert: (model, msg, publish, options, meta) => {\n\n       const ep_name = getKey(model.endpoint(msg.device), msg.endpoint.ID);\n       const result = {};\n\n       // switch type\n       if(msg.data.hasOwnProperty('65280')) {\n           result[`switch_mode_${ep_name}`] = switchModeValues[msg.data['65280']];\n       }\n\n       // switch action\n       if(msg.data.hasOwnProperty('switchActions')) { // use standard 'switchActions' attribute identifier\n           result[`switch_actions_${ep_name}`] = switchActionValues[msg.data['switchActions']];\n       }\n\n       // relay mode\n       if(msg.data.hasOwnProperty('65281')) {\n           result[`relay_mode_${ep_name}`] = relayModeValues[msg.data['65281']];\n       }\n\n\n       // Maximum pause between button clicks in a multiclick\n       if(msg.data.hasOwnProperty('65282')) {\n           result[`max_pause_${ep_name}`] = msg.data['65282'];\n       }\n\n       // Minimal duration for the long press\n       if(msg.data.hasOwnProperty('65283')) {\n           result[`min_long_press_${ep_name}`] = msg.data['65283'];\n       }\n\n       return result;\n   },\n}\n```\n\n이 함수는 해당 보고서에서 속성 값들을 파싱하고, 이를 Z2M 구조로 `attribute_name`_`endpoint_name` 레코드로 분해하려고 노력합니다.\n\n거의 다 끝났어요. 마지막 구조 하나만 더 남았는데, 이것은 모든 것을 함께 모을 것입니다.\n\n```js\nconst device = {\n    zigbeeModel: ['Hello Zigbee Switch'],\n    model: 'Hello Zigbee Switch',\n    vendor: 'NXP',\n    description: 'Hello Zigbee Switch',\n    fromZigbee: [fz.on_off, fromZigbee_OnOffSwitchCfg],\n    toZigbee: [tz.on_off, toZigbee_OnOffSwitchCfg],\n    exposes: genEndpoints(2),\n    configure: async (device, coordinatorEndpoint, logger) => {\n        device.endpoints.forEach(async (ep) => {\n            await ep.read('genOnOff', ['onOff']);\n            await ep.read('genOnOffSwitchCfg', ['switchActions']);\n            await ep.read('genOnOffSwitchCfg', [65280, 65281, 65282, 65283], manufacturerOptions.jennic);\n        });\n    },\n    endpoint: (device) => {\n        return {button_1: 2, button_2: 3};\n    },\n};\n\nmodule.exports = device;\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드는 새로운 장치를 등록하고 해당 장치에 대한 컨버터를 등록합니다. On/Off 기능에는 표준 fz/tz.on_off 컨버터가 사용되며, 우리의 함수인 to/fromZigbee_OnOffSwitchCfg가 스위치 구성을 처리합니다.\n\n이 장치는 이미 2개의 스위치 엔드포인트를 지원하므로, 컨버터는 2개의 설정 세트를 등록합니다. 또한, 기본 채널이 endpoint #1에 있고, 스위치 엔드포인트는 endpoint #2부터 시작한다는 점을 기억하십시오. 모든 것이 올바르게 보여지고 작동되도록 endpoint-to-buttons 재번호 매핑을 추가해야 했습니다.\n\n또한 configure() 함수를 강조하고 싶습니다. Z2M을 시작할 때는 스위치의 현재 상태나 설정 값이 알려져 있지 않습니다 — 설정 섹션의 모든 필드는 비어 있을 것입니다. 제가 연구한 대부분의 컨버터는 속성 보고를 설정하며, 장치는 예를 들어 1분마다 상태와 속성을 보고합니다. 따라서 일부 장치는 시작 시 값이 즉시 표시되지 않지만 나중에 값이 나타납니다. 이는 온도 센서와 같은 장치에 적합한 옵션입니다. 저의 컨버터 버전에서는 시작 시에 실제 값을 간단히 읽기로 결정했습니다.\n\n마지막 단계는 zigbee2mqtt에서 컨버터를 등록하는 것입니다. configuration.yaml에 다음 라인을 추가하고 Z2M을 다시 시작하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```yaml\nexternal_converters:\n  - myswitch.js\n```\n\n장치가 가입할 때, zigbee2mqtt는 장치 이름을 요청하고 해당하는 컨버터를 사용할 것입니다.\n\n# 다중 액션 지원\n\n기억하시다시피, 우리는 장치에 다중 입력 클러스터를 추가하여 단일/이중/삼중/긴 눌림을 보고할 수 있도록 했습니다. 이러한 이벤트들은 속성 변경 보고서로 제공됩니다. 하지만 이제는 Z2M이 이러한 보고서를 이해하고 적절한 액션을 생성할 수 있도록 가르쳐 주어야 합니다. 이를 위해 fromZigbee 컨버터를 또 추가해보죠. 이 클러스터에 뭔가를 장치에 쓰지 않을 것이므로 toZigbee 컨버터를 추가할 필요는 없습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst fromZigbee_MultistateInput = {\n   cluster: 'genMultistateInput',\n   type: ['attributeReport', 'readResponse'],\n\n   convert: (model, msg, publish, options, meta) => {\n       const actionLookup = {0: 'release', 1: 'single', 2: 'double', 3: 'tripple', 255: 'hold'};\n       const value = msg.data['presentValue'];\n       const action = actionLookup[value];\n\n       const result = {action: utils.postfixWithEndpointName(action, msg, model)};\n       return result;\n   },\n}\n```\n\n이 컨버터는 ptvo_multistate_action 컨버터에서 영감을 받았습니다. presentValue 클러스터 속성을 간단히 추출하여 해당 작업 텍스트로 변환합니다.\n\n이 컨버터는 장치가 생성할 수 있는 작업도 광고할 수 있어서 Home Assistant와 같은 다른 시스템이 준비할 수 있습니다.\n\n```js\nfunction genSwitchActions(endpoinsCount) {\n   let actions = [];\n\n   for (let i = 1; i <= endpoinsCount; i++) {\n       const epName = `button_${i}`;\n       actions.push(... ['single', 'double', 'triple', 'hold', 'release'].map(action => action + \"_\" + epName));\n   }\n\n   return actions;\n}\n\n...\n\nconst device = {\n...\n   fromZigbee: [fz.on_off, fromZigbee_OnOffSwitchCfg, fromZigbee_MultistateInput],\n...\n   exposes: [\n       e.action(genSwitchActions(2)),\n       ...genSwitchEndpoints(2)\n   ],\n...\n```\n\n<div class=\"content-ad\"></div>\n\n제가 원했던 것은 각 엔드포인트에서의 작업이 나머지 엔드포인트 정보와 함께 선언되기를 했지만(zigbee2mqtt 아키텍처는 이를 허용하지 않습니다), 이를 위한 genSwitchEndpoint() 함수에서 정의할 수 없습니다. 모든 작업은 exposes 필드에서 e.action() 함수를 사용하여 한 번만 정의해야 합니다(여기에 설명이 나와 있습니다).\n\n자, 이제 버튼을 눌러서 zigbee2mqtt 쪽에서 어떻게 작동하는지 확인해 봅시다.\n\n```js\nZigbee2MQTT:debug 2021-10-19 22:31:53: Received Zigbee message from 'TestSwitch', type 'attributeReport', cluster 'genMultistateInput', data '{\"presentValue\":255}' from endpoint 3 with groupID 0\nZigbee2MQTT:info  2021-10-19 22:31:53: MQTT publish: topic 'zigbee2mqtt2/TestSwitch', payload '{\"action\":\"hold_button_2\",\"last_seen\":1634671913843,\"linkquality\":70,\"max_pause_button_1\":null,\"max_pause_button_2\":null,\"min_long_press_button_1\":null,\"min_long_press_button_2\":null,\"relay_mode_button_1\":\"front\",\"relay_mode_button_2\":\"unlinked\",\"state_button_1\":\"OFF\",\"state_button_2\":\"OFF\",\"switch_actions_button_1\":null,\"switch_actions_button_2\":null,\"switch_type_button_1\":null,\"switch_type_button_2\":\"momentary\"}'\nZigbee2MQTT:info  2021-10-19 22:31:53: MQTT publish: topic 'zigbee2mqtt2/TestSwitch', payload '{\"action\":\"\",\"last_seen\":1634671913843,\"linkquality\":70,\"max_pause_button_1\":null,\"max_pause_button_2\":null,\"min_long_press_button_1\":null,\"min_long_press_button_2\":null,\"relay_mode_button_1\":\"front\",\"relay_mode_button_2\":\"unlinked\",\"state_button_1\":\"OFF\",\"state_button_2\":\"OFF\",\"switch_actions_button_1\":null,\"switch_actions_button_2\":null,\"switch_type_button_1\":null,\"switch_type_button_2\":\"momentary\"}'\nZigbee2MQTT:info  2021-10-19 22:31:53: MQTT publish: topic 'zigbee2mqtt2/TestSwitch/action', payload 'hold_button_2'\n```\n\n우리는 genMultistateInput 클러스터 메시지가 정상적으로 처리되고 MQTT 메시지로 전환된 것을 볼 수 있습니다. 마지막 메시지가 간결하고 중요한데, 두 번째 버튼이 눌린 이벤트가 있었습니다. MQTT 이벤트를 구독할 수 있는 어떤 시스템이든 이러한 메시지를 쉽게 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다른 두 개의 메시지가 조금 혼란스러울 수 있어요 — \"action\":\"hold_button_2\"를 보내고, 곧바로 \"action\":\"\"를 보내죠. 하지만 이는 Zigbee2mqtt FAQ에 설명된 정상적인 동작인 걸 알게 된 것이죠.\n\n팁:\n\n이전에도 언급했듯이 Multistate 입력 클러스터는 일반적인 방식과는 조금 다르게 사용되어요 — 값 자체보다는 값 변경 이벤트에 관심이 있는 것이죠. 주요 속성이 다양한 값들을 취할 수 있는 편리한 클러스터일 뿐입니다.\n\n하지만 Multistate 입력이 다양한 버튼 이벤트를 신호로 지시하는 유일한 방법은 아닙니다. 그래서 샤오미 WXKG01LM 스위치는 OnOff 클러스터의 비표준 확장을 구현합니다. 상태 속성의 표준 0 및 1 값 이외에도 클릭 수를 나타내는 다른 값을 사용할 수 있어요. 다른 디바이스들도 On/Off 클러스터의 비표준 확장을 구현하고 다양한 이벤트를 나타내는 추가 속성을 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n일부 디바이스는 펌웨어 측면에서 다중 클릭 로직을 전혀 구현하지 않을 수 있습니다. 반면, 절대 표준적인 OnOff 클러스터가 사용되며, 다중 클릭은 z2m 컨버터에서 타이머를 사용하여 계산됩니다.\n\n마지막으로 제조업체는 매우 사용자 정의된 클러스터를 개발하여 선호하는 형식으로 정보를 전송할 수도 있습니다.\n\n# Home Assistant 자동화\n\nHome Assistant에 노출된 스위치는 거의 자동으로 통합되지만 몇 가지 문제점이 있습니다. 먼저, 기본적으로 대부분의 설정이 비활성화되어 Home Assistant에 숨겨져 있습니다. 각 설정을 수동으로 활성화한 후 Home Assistant를 다시 시작해야 합니다. 매개변수를 활성화한 후에는 기기 페이지가 다음과 같이 보입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_5.png\" />\n\n둘째, 숫자 매개변수는 편집할 수 없습니다. 안타깝게도 이 문제를 전혀 해결할 방법을 찾지 못했습니다. 이를 해결하기 위한 임시방편으로, 이러한 매개변수는 zigbee2mqtt 대시보드에서 편집하거나 해당 mqtt 메시지를 보내는 방법으로 편집할 수 있습니다.\n\n작업에 대해 말하자면, 여기서는 조금 원할한 상황이 아닙니다. 변환기가 가능한 작업 목록을 광고하지만, Home Assistant는이 목록을 무시합니다. 자동화를 생성하려고 하면 HA가 더블/트리플/롱 프레스를 자동화 트리거로 제안하지 않습니다... 해당 작업이 최소한 한 번 발생할 때까지입니다. 그런 다음 해당 작업이 목록에 나타나며 자동화 마법사에서 사용할 수 있게 됩니다.\n\n자, 이제 유용한 일을 해보고 흥미로운 자동화를 작성해 봅시다. 현재 나는 내 Xiaomi 스위치로 커튼을 부분적으로 열거나 닫을 수 있는 기능이 정말 그립습니다. 보통 매우 어렵게 깨어납니다. 커튼이 한꺼번에 완전히 열리면 눈에 매우 충격을 줍니다. 커튼의 정도를 동일한 스위치로 제어할 수 있는 기능이 있으면 좋겠습니다.\n\n<div class=\"content-ad\"></div>\n\n단 몇 분 만에, 홈 어시스턴트 시각적 편집기에서 몇 가지 자동화 규칙을 만들었어요.\n\n첫 번째 자동화는 버튼 더블 클릭으로 커튼을 완전히 열거나 닫습니다.\n\n```js\n- id: '1635018171508'\n  alias: TestSwitch Open/Close curtain\n  description: 'TestSwitch Open/Close curtain'\n  trigger:\n  - platform: mqtt\n    topic: zigbee2mqtt2/TestSwitch/action\n    payload: double_button_1\n  condition: []\n  action:\n  - service: cover.toggle\n    target:\n      entity_id: cover.living_room_curtain\n  mode: single\n```\n\n두 번째 자동화는 버튼을 세 번 클릭하면 커튼을 50%로 엽니다.\n\n<div class=\"content-ad\"></div>\n\n```yaml\n- id: '1635017708545'\n  alias: TestSwitch Half-open curtains\n  description: 'TestSwitch Half-open curtains'\n  trigger:\n  - platform: mqtt\n    topic: zigbee2mqtt2/TestSwitch/action\n    payload: triple_button_1\n  condition: []\n  action:\n  - service: cover.set_cover_position\n    target:\n      entity_id: cover.living_room_curtain\n    data:\n      position: 50\n  mode: single\n```\n\n다음 두 가지 자동화는 길게 누르는 것을 사용합니다 — 버튼을 누르면 커튼이 움직이기 시작하고, 버튼을 놓으면 멈춥니다.\n\n```yaml\n- id: '1635017908150'\n  alias: TestSwitch toggle curtain on button press\n  description: 'TestSwitch toggle curtain on button press'\n  trigger:\n  - platform: mqtt\n    topic: zigbee2mqtt2/TestSwitch/action\n    payload: hold_button_1\n  condition: []\n  action:\n  - service: cover.toggle\n    target:\n      entity_id: cover.living_room_curtain\n  mode: single\n\n- id: '1635017981037'\n  alias: TestSwitch stop curtain\n  description: 'TestSwitch stop curtain'\n  trigger:\n  - platform: mqtt\n    topic: zigbee2mqtt2/TestSwitch/action\n    payload: release_button_1\n  condition: []\n  action:\n  - service: cover.stop_cover\n    target:\n      entity_id: cover.living_room_curtain\n  mode: single\n```\n\n위와 같이 간단한 자동화를 사용하면 단일 버튼으로 커튼을 제어할 수 있습니다 — 열기, 닫기, 특정 개도로 설정하는 것도 가능합니다. 게다가, 버튼의 일반적인 단추도 주 조명을 전환할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 요약\n\n축하해요, 우리는 방금 Xiaomi Aqara 스위치를 새롭게 만들었어요! 음, 비슷한 스마트 스위치예요. 아마도 우리 장치는 좀 더 다양한 설정을 제공할지도 모르지만, 전반적으로 모든 것이 거의 같아요. 그래도 뭔가 다른 목표가 있었죠 — 사용자 정의 클러스터, genOnOffSettingCfg 및 genMultistateInput 클러스터를 생성하고 zigbee2mqtt를 위한 외부 컨버터를 작성해보는 것이었어요.\n\n자신만의 클러스터를 만들거나 기존 클러스터를 확장하는 데 별로 어려운 점이 없다는 것이 밝혀졌어요. zigbee2mqtt를 다루는 데에는 조금 골치가 아팠지만, 그건 대부분 명쾌한 문서의 부재 때문이었어요. 이제 이 빈칸은 채워졌어요 :)\n\n# 링크\n\n<div class=\"content-ad\"></div>\n\n- JN-UG-3113 ZigBee 3.0 스택 사용자 가이드\n- JN-UG-3114 ZigBee 3.0 디바이스 사용자 가이드\n- JN-UG-3076 ZigBee 홈 오토메이션 사용자 가이드\n- ZigBee 클래스 라이브러리 사양\n- Zigbee 트래픽을 감지하는 방법\n- zigbee2mqtt에 새로운 장치 추가\n- 깃허브 프로젝트\n\n# 지원\n\n이 프로젝트는 품앗이 프로젝트로 무료로 개발 중입니다. 동시에 작은 기부로 프로젝트를 지원하는 것을 고려해볼 수 있습니다.\n\n![HelloZigbeeWorld](/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_6.png)","ogImage":{"url":"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_0.png"},"coverImage":"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_0.png","tag":["Tech"],"readingTime":18}],"page":"72","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}