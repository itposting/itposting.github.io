{"pageProps":{"posts":[{"title":"Windows 11의 추적 기능을 비활성화하는 방법","description":"","date":"2024-06-19 09:03","slug":"2024-06-19-HowToDisableWindows11sTrackingFeatures","content":"\n\nWindows 11에서 개인 정보 보호 보장: 단계별 안내서\n\n![이미지](/assets/img/2024-06-19-HowToDisableWindows11sTrackingFeatures_0.png)\n\nWindows 11은 이전의 마이크로소프트 운영 체제와 마찬가지로 광고, 진단 및 기타 목적을 위해 상당량의 사용자 데이터를 수집합니다. 개인 정보 보호를 중요시하고 마이크로소프트가 수집하는 데이터를 제한하고 싶다면, 이 안내서를 통해 Windows 11의 다양한 추적 기능을 비활성화하는 데 도움이 될 것입니다.\n\n# 맞춤 광고 비활성화하기\n\n<div class=\"content-ad\"></div>\n\n개인 맞춤형 광고를 해제하려면:\n\n- 설정 앱을 엽니다. 시작 버튼을 마우스 오른쪽으로 클릭하고 설정을 선택하거나 Windows 키 + I 단축키를 사용하여 이 작업을 수행할 수 있습니다.\n- 왼쪽 패널에서 \"개인 정보 및 보안\"을 선택합니다.\n- Windows 권한 아래에서 \"일반\"을 클릭합니다.\n- 다음 옵션을 해제합니다:\n\n  - 광고 ID를 사용하여 앱이 개인 맞춤형 광고를 표시하도록 허용\n  - 언어 목록에 액세스하여 로컬 관련 콘텐츠를 제공하는 웹사이트가 나에게 콘텐츠를 표시하도록 허용\n  - 앱 시작을 추적하여 시작 및 검색 결과를 개선하도록 Windows가 허용\n  - 설정 앱에서 제안된 콘텐츠를 표시하도록 허용\n\n위 설정을 비활성화하면 여전히 광고를 볼 수 있지만 사용자 행동에 기반한 대상 지정이 되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n# 진닑 데이터 수집 줄이기\n\n다음 단계를 따라 진닑 데이터 수집을 제한하세요:\n\n- 설정 앱에서 개인 정보 및 보안으로 이동합니다.\n- Windows 권한 아래에서 진닑과 피드백을 선택합니다.\n- 선택 사항 진닑 데이터 보내기를 끕니다. 이것은 또한 메모와 입력 개선을 비활성화합니다.\n- 맞춤형 경험을 끄면 진닑 데이터를 사용하여 개인화 된 팁, 광고 및 추천을 받지 않게 할 수 있습니다.\n- Microsoft가 진닑 데이터의 사본을 사용하지 못하도록 하려면 진닑 데이터 삭제를 클릭하세요.\n\n# 활동 추적 비활성화하기\n\n<div class=\"content-ad\"></div>\n\n활동 추적은 개인 정보 보호에 관련된 중요한 문제가 될 수 있습니다:\n\n- 설정 앱에서 개인 정보 및 보안을 선택합니다.\n- 아래로 스크롤하여 활동 기록을 선택합니다.\n- Microsoft에 내 활동 기록 보내기를 꺼서 사용하는 앱 및 서비스, 그리고 방문하는 웹사이트에 대한 데이터 수집을 방지할 수 있습니다.\n\n# 내 기기 찾기 끄기\n\n분실된 기기를 찾는 데 유용하지만, 내 기기 찾기도 위치 데이터를 업로드합니다:\n\n<div class=\"content-ad\"></div>\n\n- 개인정보 및 보안에서 '내 기기 찾기'를 선택하세요.\n- Microsoft가 위치를 추적하지 않으려면 스위치를 끄세요.\n\n# Microsoft Edge에서 추적 줄이기\n\nEdge에서 브라우징할 때 추적기를 차단하려면:\n\n- 우측 상단에 있는 세 점 메뉴 아이콘을 클릭하세요.\n- 드롭다운 메뉴에서 설정을 선택하세요.\n- 왼쪽 패널에서 '개인정보, 검색 및 서비스'를 선택하세요.\n- 추적 방지 기능을 활성화하고 필요에 맞는 수준을 선택하세요. 일반 사용자를 위해 균형있게 권장하는 것이 바람직하지만, 엄격한 수준은 대부분의 추적기를 차단하지만 일부 웹사이트 기능을 깨뜨릴 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 마이크로소프트 계정에서 데이터 지우기\n\n마이크로소프트 계정과 연결된 데이터를 삭제하려면:\n\n- 모든 브라우저를 열고 account.microsoft.com 으로 이동합니다.\n- 계정에 로그인합니다.\n- 상단바에서 **개인정보**를 클릭합니다.\n- 활동 데이터 관리로 스크롤하여 내려갑니다.\n- 첫 네 가지 범주에 초점을 맞춥니다: 위치 활동, 브라우징 기록, 검색 기록 및 앱 및 서비스 활동.\n- 각 범주에 대해 **모두 지우기** 를 선택합니다. 예를 들어, 브라우징 기록을 지우려면, **모두 브라우징 활동 지우기** 를 클릭한 후 확인을 위해 **지우기** 를 클릭합니다. 또한 데이터를 30일마다 자동으로 지우도록 설정할 수 있습니다.\n\n이러한 단계를 따르면 Windows 11에서 개인 정보 보호를 크게 향상시킬 수 있습니다. 만약 이 안내서가 도움이 되었다면 좋아요를 눌러주시고 다른 사람들과 공유해주세요. 여전히 개인 정보 보호를 우선시하는지 또는 현대 기술의 일환으로 데이터 수집을 수용했는지를 댓글로 알려주세요. 최신 Windows 11 및 기술 관련 비디오를 업데이트하려면 채널을 구독하지 않도록 잊지 마세요.","ogImage":{"url":"/assets/img/2024-06-19-HowToDisableWindows11sTrackingFeatures_0.png"},"coverImage":"/assets/img/2024-06-19-HowToDisableWindows11sTrackingFeatures_0.png","tag":["Tech"],"readingTime":3},{"title":"윈도우 포렌식 오피스 문서","description":"","date":"2024-06-19 09:02","slug":"2024-06-19-WindowsForensicsOfficeDocuments","content":"\n\n# Windows 포렌식 - 파일/폴더 오픈, 응용프로그램 실행과 관련된 증거\n\n## 개요\n\n이 글은 프리패치 파일부터 셸 항목 및 레지스트리 분석까지 여러 가지를 다룰 것입니다. 우리는 대상 사용자가 Microsoft Office 제품을 실행하고 Word 문서와 활발히 작업한 사실을 보여줄 것입니다. 마지막으로 우리는 Word에서 사용자가 본 정확한 페이지를 확인하고 해당 페이지를 우리 자신의 기계에서 재작성하여 용의자 사용자가 마지막으로 본 것을 확인할 수 있게 될 것입니다.\n\n## 시스템에서 Microsoft Office 제품이 실행되었는지 확인하는 방법\n\n<div class=\"content-ad\"></div>\n\n## 사전 로드 파일\n\n사전 로드 파일은 응용 프로그램 실행에 대한 자세한 정보를 제공합니다. 그들의 주요 기능은 응용 프로그램의 일부 메모리를 디스크에 기록하여 사용자가 특정 응용 프로그램을 두 번째로 실행할 때 일부 데이터가 이미 캐싱되어 있어 더 빨리 시작되도록 하는 것입니다. 사전 로드가 캐시하는 정보는 다음과 같습니다:\n\n- 로드된 DLL\n- 응용 프로그램이 상호 작용한 다른 파일(다른 PE 파일 포함)\n- 응용 프로그램이 상호 작용한 디렉터리의 상대 경로\n- 응용 프로그램을 실행한 횟수\n- 응용 프로그램을 실행한 마지막 8개의 타임스탬프\n- 파일 시스템 타임스탬프(생성, 수정, 액세스)\n- 파일 크기\n- 응용 프로그램 해시\n- 볼륨 정보\n\n사전 로드 파일은 C:\\Windows\\Prefetch에 저장되며 파일 확장자는 .pf입니다. 이것이 우리가 시작할 지점이 될 것이며, 대상 시스템에서 Office 제품이 실행되었는지 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n에릭 짐머만의 PECmd 도구를 사용하면 전체 디렉토리를 구문 분석하여 CSV 파일로 출력하거나 한 번에 하나의 .pf 파일을 구문 분석할 수 있습니다. 우리는 사무 문서에만 관심이 있기 때문에 Microsoft Word용 prefetch 파일 하나를 구문 분석할 것입니다.\n\n## Word Prefetch (Application Execution)\n\n```js\n# 하나의 prefetch 파일을 구문 분석하는 구문\npecmd -f $파일\n```\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_0.png)\n\n<div class=\"content-ad\"></div>\n\n가장 먼저 지적하고 싶은 것은 최근 실행된 타임스탬프와 파일 시스템 수정된 타임스탬프 간의 불일치입니다. 이론적으로는 응용 프로그램이 실행될 때 NTFS 파일 시스템에서 수정된 타임스탬프가 업데이트되므로 이러한 타임스탬프는 일치해야 합니다. 그러나 최근 실행 시간이 파일 시스템보다 2초 빠르게 기록되었습니다. 이것은 중요한 고려 사항이며 파일 시스템 타임스탬프만 놓고 보면 고려해야 할 사항입니다. 실행 후 파일 시스템이 수정된 시간을 업데이트하기까지 최대 10초가 소요될 수 있습니다.\n\n이제 우리는 컴퓨터에서 Word가 실행되었음을 알고 있으며 다음과 같은 세부 사항이 있습니다:\n\n- Word가 23번 실행되었습니다\n- 최근 실행 시간은 2024년 5월 30일 12:50:01에 있었습니다 (모든 타임스탬프는 UTC, 24시간 형식입니다)\n- 볼륨 GUID\n- 그리고 응용 프로그램이 상호 작용한 디렉토리 및 파일 목록 (스크린샷에 포함되지 않음)\n\n# 문서가 열렸는지 확인하기\n\n<div class=\"content-ad\"></div>\n\n## 바로 가기 파일 (LNK)\n\nWord가 열려 있다고 해서 그와 함께 문서가 열리는 것은 아닙니다. LNK 파일을 활용하여 어떤 문서가 열렸는지 추측하는 데 도움을 받을 수 있습니다. 이러한 증거들은 사용자의 프로필에 저장됩니다: C:\\Users\\$user\\AppData\\Roaming\\Microsoft\\Windows\\Recent.\n\nLNK 파일은 파일이나 폴더가 열릴 때 기록이 되며, 제어판 앱도 포함됩니다. 이러한 쉘 항목들은 다음을 기록합니다:\n\n- 파일 시스템 타임스탬프\n- 대상 타임스탬프 (쉘 항목은 대상 파일을 가리키며, LNK 파일은 실제로 다른 개체에 액세스하는 방법에 대한 메타데이터를 저장)\n- 파일 크기, 속성 및 플래그\n- 대상 파일의 상대 경로\n- 대상 파일의 작업 디렉토리\n- 볼륨 정보\n- 그리고 $MFT 레코드 정보\n\n<div class=\"content-ad\"></div>\n\n에릭 짐머만의 도구 중 하나인 LECmd를 사용하여 이 파일들을 구문 분석할 수 있습니다.\n\n```js\n# LECmd 사용법\nlecmd -f $file\n```\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_1.png)\n\n위 스크린샷에서 우리는 CIRT_SOP.docx라는 문서를 위한 LNK 파일을 볼 수 있습니다. 이 파일이 마지막으로 수정된 날짜는 Word가 마지막으로 실행된 날짜와 같음을 알 수 있습니다. 하나 이상의 문서가 열렸다는 것을 알기 때문에 사용자 레지스트리를 확인하여 파일이 마지막으로 열리고 닫힌 시간을 결정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 파일 활동 기간 결정하기\n\n사용자의 NTUSER.dat 파일에서 Microsoft Office 문서와 관련된 레지스트리 키를 찾을 수 있습니다. 주로 이러한 키들은 NTUSER\\Software\\Microsoft\\Office\\16.0\\Word 경로에 있습니다.\n\n## 파일이 마지막으로 열린 날짜\n\n저는 Microsoft 365 계정을 사용하고 있기 때문에 NTUSER\\Software\\Microsoft\\Office\\16.0\\Word\\File MRU에는 문서가 나열되지 않습니다. 대신 개인 Office 365 라이선스와 관련된 키를 참조해야 합니다: NTUSER\\Software\\Microsoft\\Office\\16.0\\Word\\User MRU\\LiveId_$hash\\File MRU. 이 항목들은 가장 최근에 사용된 순서대로 나열됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지 1](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_2.png)\n\n파일이 처음 열린 시간을 나타내는 타임스탬프는 64비트 FILETIME에서, big endian 형식으로 “T” 뒤에 나오는 바이트 입니다. 아래 화면은 아이템 1에 대한 디코딩된 시간을 보여줍니다.\n\n![이미지 2](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_3.png)\n\n![이미지 3](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n## 파일 종료 날짜\n\n파일이 마지막으로 닫힌 날짜를 확인하려면 다른 레지스트리 키인 NTUSER\\Software\\Microsoft\\Office\\16.0\\Word\\Reading Locations로 전환해야 합니다. 각 문서에는 중요한 하위 키/값 쌍을 포함하는 자체 하위 키가 생성됩니다.\n\n![image](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_5.png)\n\n![image](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_6.png)\n\n<div class=\"content-ad\"></div>\n\nDatetime에 나열된 값에 유의하세요. 이 값은 시스템의 로컬 시간입니다 (정확한 시스템 프로필링이 반드시 필요함을 증명합니다). Datetime에 나열된 시간을 UTC로 변환하면 레지스트리의 마지막 쓰기 시간 (2024–05–30 20:45:56)과 일치하는 것을 볼 수 있습니다. 이것은 파일이 마지막으로 닫힌 시간입니다.\n\nPosition 값은 사용자가 마지막으로 보고 있던 문서의 위치를 기록합니다. 이것은 Word가 시행하는 \"이전에 멈췄던 곳부터 다시 시작\" 기능입니다. 이론적으로, 사용자가 마지막으로 머물렀던 정확한 페이지를 결정할 수 있습니다:\n\n- 해당 대상 파일을 우리 시스템으로 복사\n- 문서를 열기\n- 문서를 닫아 우리의 NTUSER 하이브에 기록되도록 함\n- 용의자의 NTUSER 하이브에서 Position 값 복사하여 우리 NTUSER 하이브로 이동.\n\n# 문서의 마지막 위치 결정\n\n<div class=\"content-ad\"></div>\n\n일하고 있는 문서를 추적 중이었던 것이 회사 작업을 위해 작업 중이던 것이기 때문에 사용자가 마지막으로 중지한 위치를 확인할 때 concept 확인을 위해 다른 문서로 전환할 것입니다. Reading Locations에 나열된 Document 1이라는 파일을 사용할 것입니다.\n\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_7.png)\n\n\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_8.png)\n\n\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_9.png)\n\n\n<div class=\"content-ad\"></div>\n\n이론적으로는 Position에 나열된 값과 일치하도록 변경하여 사용자가 마지막으로 보고 있던 내용을 복원할 수 있어야 합니다.\n\n![image1](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_10.png)\n\n이제 파일을 다시 열 때, 우리는 중단했던 곳부터 이어서 작업할 것을 요청받아야 합니다.\n\n![image2](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_11.png)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_12.png\" />\n\n# 이 기사의 목적\n\n저는 이 기사를 쓴 이유는 학습하고 있는 개념을 강화하고 있는 것인데, 메모에 너무 의존하는 것을 줄이고 지식을 내재화하는 노력에 있습니다. 사용자가 마지막으로 머물렀던 정확한 페이지를 확인할 수 있는 것이 가능하다는 것을 알게 되었을 때 정말 멋있었고, HackTheBox 머신에서 사용자/루트 쉘을 얻는 것보다 더 흥미로웠습니다. 이 글을 통해 새로운 지식을 얻거나 흥미를 느낀 사람이 있다면 좋겠습니다. 배운 것들을 다른 사람들과 공유해주세요!","ogImage":{"url":"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_0.png"},"coverImage":"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_0.png","tag":["Tech"],"readingTime":6},{"title":"쉘코드 삽입 및 악성 코드 역분류에 대한 기본 소개","description":"","date":"2024-06-19 09:00","slug":"2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware","content":"\n\n안녕하세요! 이 게시물의 목적은 제가 배우고 있는 연구 및 개발 방법 중 일부를 공유하는 것입니다!\n\n오늘은 Windows 앱, 드라이버, 심지어 커널 자체에 대한 강력한 디버깅 솔루션인 WinDbg의 사용에 대해 이야기하고 싶었습니다. WinDbg를 좋아하는 한 가지 이유는 도구가 매우 유연하며 체계적인 시스템 분석을 위한 놀라운 기능이 포함되어 있다는 것입니다.\n\n몇 가지 예시를 제공하기 위해, 'AAAA'를 notepad.exe의 주소 공간에 간단히 주입하는 간단한 셸코드 주입 프로그램을 만들어 보았습니다. 선택한 프로그램이 시스템에서 실행 중이고 보호받는 프로세스가 아닌 한 사용할 수 있습니다!\n\n참고: 이러한 기술을 배우는 데 도움을 준 MalDev Academy 및 멋진 YT 채널을 운영하는 cr0w에게 감사드립니다!\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png)\n\n프로그램 실행 후에 보이는 것처럼, 이 프로그램은 PID를 매개변수로 사용하고 핸들을 획득한 다음 할당된 메모리에 쉘코드를 주입하여 코드 실행을 달성합니다!\n\n더 나아가기 전에 현대 시스템에서는 어떤 종류의 합법적인 쉘 코드도 대부분의 보안 제품을 우회하기 위해 강력하게 난독화되어야 하거나, 디스크나 메모리의 별도 위치에 저장되어야 할 것으로 강조하고 싶습니다. 이것은 단순한 개념 증명일 뿐입니다.\n\n프로그램의 기본 개요는 아마도 쉘 코드를 주입하는 가장 일반적인 방법을 따릅니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 해당 PID로 프로세스를 식별하고 핸들을 획득합니다.\n- 그 프로세스의 가상 주소 공간 내에서 RWX 권한으로 메모리를 할당합니다.\n- 쉘 코드의 내용을 버퍼에 쓰고 그것을 할당된 메모리 공간에 전달합니다.\n- 생성 및 호출하여 페이로드가 실행될 스레드를 만들어 실행을 트리거합니다.\n\n![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_1.png)\n\n위는 우리 프로그램의 \"Main\"이라는 단어를 포함하는 여러 기능들의 분해입니다. 여기서 \"x `프로그램이름`!`함수이름`\" 명령을 사용하여 이를 달성합니다. \n\n주소가 a5f00으로 끝나는 곳에서 우리 main 함수의 진입점을 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_2.png)\n\n메인 함수에 중단점을 설정하고 실행을 계속한 후, 프로그램을 분해하여 현재 레지스터 값들을 검사할 수 있습니다. 여기서 소스 코드 왼쪽에 할당된 변수를 NULL로 설정했다고 알 수 있습니다. 오른쪽에는 스택에 반영된 할당이 보이며, 값 0이 스택의 기본 위치로부터 다양한 오프셋에 저장되는 것을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_3.png)\n\n여기서 \"cmp\" 명령어를 볼 수 있는데, 이는 결국 인수 개수 함수입니다. 인수 개수가 2와 일치하면 함수가 실행되고, 그렇지 않으면 사용법 라인에 정의된 문자열을 출력합니다.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_4.png\" />\n\n위 캡처에서는 특정 메모리 주소에 포함된 값들을 표시할 수 있습니다. 여기서는 db 명령어 뒤에 주소를 넣어 해당 내용을 바이트로 표시합니다. 하지만 \"display as ascii\"를 위해 da를 활용할 수도 있습니다.\n\n이 메모리 주소로부터 함수가 계속 실행되는 동안 어떤 문자열이 출력되는지 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_5.png\" />\n\n<div class=\"content-ad\"></div>\n\n이제 페이로드 저장에 대해 이야기하겠습니다. 한 발 물러서서 rep movs 명령어를 강조하고 싶어요. 우리가 인자 수를 비교하기 전에 우리의 ECX 또는 카운터 레지스터에 값 5를 할당했다는 것을 주목하세요. 그리고 나서 우리는 반복적으로 스택으로 한 번에 한 바이트씩 복사합니다.\n\n우리의 페이로드는 AAAA로만 구성되어 있으므로, 왜 5라는 값이 우리의 페이로드에서 몇 바이트를 복사할지 결정하는 데 사용되는 걸까요? 이 5번째 바이트는 아마도 우리의 페이로드가 NULL 종료된 문자열이라는 사실을 고려하기 때문에, 마지막으로 복사해야 하는 바이트는 NULL 바이트일 것입니다.\n\n이와 마지막으로, 페이로드 식별에 대해서 이야기할게요. \"dd/db\" 명령을 활용하여 특정 레지스터의 내용을 표시할 수 있어요! 이렇게 멋진 걸요! 그래서 프로그램 실행을 따라가면서 레지스터가 어떻게 변하는지, 어떤 값이 저장되는지를 살펴볼 수 있고, 아마도 프로그램이 무엇을 하는지 추측할 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\nRAX 레지스터에 저장된 페이로드의 바이트 및 ASCII 내용을 공개함으로써 거기에 4개의 A가 있다는 것을 확인할 수 있습니다.\n\n마지막으로: 이 WinDbg 프로그램에서 할 수 있는 작업은 스택 추적을 검토하거나 레지스터를 조작하거나 API 호출 및 그 매개변수를 찾는 등 훨씬 더 많습니다. 저는 기본적인 분석 기술을 강조하고 앞으로 더 복잡한 주제를 탐구할 것을 희망합니다. 또한, ProcessHacker2나 일부 Sysinternals 도구와 같은 도구를 사용하여 프로그램을 실행하는 동안 메모장 메모리 내용을 검토하거나 페이로드가 삽입되는 방식 및 스레드가 호출되거나 호출되는 방식을 파악할 수도 있습니다.\n\n읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png"},"coverImage":"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png","tag":["Tech"],"readingTime":4},{"title":"HomeBrew를 사용하여 MacOS2021에 Java JDK11을 설치하는 방법","description":"","date":"2024-06-19 08:59","slug":"2024-06-19-UsingHomeBrewtoInstallJavaJDK11onMacOS2021","content":"\n\n제목이 정확히 같은 게시물이 있지만 조금 오래됐기 때문에 최신 솔루션을 구글링하는 사람들을 위해 약간 수정된 버전을 게시하고 싶습니다.\n\n## 단계 1: Homebrew 설치 (아직 하지 않은 경우)\n\n```js\n$ /bin/bash -c “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)” \n```\n\n## 단계 2: 업데이트 (아직 하지 않은 경우)\n\n<div class=\"content-ad\"></div>\n\n```js\n$ brew update\n```\n\n## 단계 3: Java11 설치\n\n```js\n$ brew install java11\n```\n\n## 단계 4: Symlink 설정하기\n\n<div class=\"content-ad\"></div>\n\n만약 이 단계를 건너뛰면 시스템이 사용할 자바 런타임을 찾지 못할 수 있어요.\n\n```js\nsudo ln -sfn /usr/local/opt/openjdk@11/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-11.jdk\n```\n\n## 단계 5: 테스트\n\n버전 플래그를 사용하여 명령을 입력한 후 비슷한 내용을 보신다면 성공적으로 진행된 거예요! 🙂\n\n<div class=\"content-ad\"></div>\n\n```js\n$ java --version\nopenjdk 11.0.10 2021-01-19\nOpenJDK Runtime Environment (build 11.0.10+9)\nOpenJDK 64-Bit Server VM (build 11.0.10+9, mixed mode)\n```\n\n문제가 발생하면 저에게 알려주시면 이 안내서를 업데이트할 수 있습니다. 좋은 하루 보내세요!\n","ogImage":{"url":"/assets/img/2024-06-19-UsingHomeBrewtoInstallJavaJDK11onMacOS2021_0.png"},"coverImage":"/assets/img/2024-06-19-UsingHomeBrewtoInstallJavaJDK11onMacOS2021_0.png","tag":["Tech"],"readingTime":1},{"title":"Windows 10에서 DMG를 USB에 불러 넣는 모든 가능한 방법","description":"","date":"2024-06-19 08:57","slug":"2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10","content":"\n\n만일 당신이 맥 사용자이라면, DMG에 익숙할 것입니다. 사실, 이는 소프트웨어 및 OS 설치에 사용할 수 있는 가장 인기 있는 macOS 파일 형식 중 하나입니다.\n\n긴급한 경우, 맥이 고장 났거나 제대로 작동하지 않을 때 문제를 해결하는 데 매우 효과적입니다. DMG 파일로부터 부팅 가능한 macOS 부팅 USB를 만들어 문제를 해결할 수 있습니다. OS 재설치는 일반적인 문제의 대부분을 해결할 것입니다. 이는 맥에 내장된 creatinstallmedia 명령으로 쉽게 할 수 있지만, 윈도우에서는 훨씬 더 어려운 작업입니다. 이 글은 윈도우 10 PC에서 DMG를 USB 드라이브로 복사하는 방법에 대한 내용입니다.\n\n![그림](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_0.png)\n\n참고로, DMG는 Apple의 독점 디스크 이미지 형식이며, 윈도우에서 기본적으로 지원되지 않습니다. 그래서 PC에서 DMG 파일을 USB에 복사하는 것이 어려운 이유입니다.\n\n<div class=\"content-ad\"></div>\n\n좌절하지 마세요. PC에서 작업을 완료할 수 있는 몇 가지 해결책이 아직도 있습니다. 이 튜토리얼에서는 macOS DMG 파일을 macOS 또는 Windows 10에 USB에 불러오는 단계를 안내해 드릴 거예요. 먼저 쉬운 해결책으로 시작해볼게요.\n\n# UUByte DMG Editor: DMG를 USB 또는 DVD에 불러오는 크로스 플랫폼 소프트웨어\n\nUUByte DMG Editor는 데이터를 손상시키지 않고 Windows와 macOS 모두에서 DMG 파일을 USB 드라이브에 불러올 수 있게 도와주는 전문 도구에요. 이 도구가 다른 경쟁 업체와 다른 점은 사용하기 쉬운 인터페이스와 속도에 있어요. 실제로 매우 빠릅니다. 필요한 것은 몇 번의 클릭 뿐이에요.\n\n이 도구는 기술적 전문 지식이 필요하지 않아요. Windows와 macOS를 동시에 사용하고 있는 입문자를 위해 특별히 설계되었어요. UUByte DMG Editor는 macOS 부팅 가능 USB 드라이브를 만들어 macOS를 어떤 Mac 기기에도 설치할 수 있게 해줘요.\n\n<div class=\"content-ad\"></div>\n\nWin 다운로드: [다운로드 링크](https://www.uubyte.com/download/dmg-editor.exe)\n\nMac 다운로드: [다운로드 링크](https://www.uubyte.com/download/dmg-editor.dmg)\n\n단계 1: Windows 10 컴퓨터에서 도구를 다운로드하고 평소와 같이 설치하세요. 이 도구는 이제 무료 평가판과 유료 버전을 제공합니다. 무료 버전은 도구 사용에 제한이 있으므로, 더 많은 고급 기능과 안정성을 제공하는 유료 버전을 선택하는 것을 권장합니다.\n\n단계 2: 이제 USB 드라이브를 Windows 10 PC에 넣으세요. USB 드라이브의 저장 용량이 적어도 16GB 이상이어야 하며 도구를 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n스텝 3: 메인 메뉴에서 Burn 버튼을 선택한 후 USB 드라이브에 복사하려는 macOS DMG 파일을 선택합니다.\n\n![이미지](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_1.png)\n\n스텝 4: Burn 버튼을 클릭하면 도구가 DMG 파일을 USB 드라이브에 복사하기 시작합니다 (본 프로세스는 완료까지 몇 초 정도 소요됩니다).\n\n![이미지](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_2.png)\n\n<div class=\"content-ad\"></div>\n\n5단계: 이제 USB 드라이브에서 Mac을 부팅하고 해당 Mac에 macOS를 설치할 수 있습니다.\n\n## 장점:\n- 훌륭한 UI 디자인을 갖춘 간단한 단계.\n- macOS Big Sur, Catalina, Mojave 및 High Sierra를 지원합니다.\n- 매우 빠른 속도로 빠르고 시간을 절약할 수 있습니다.\n- Windows 10을 완전히 지원하며 오류가 적습니다.\n\n## 단점:\n\n<div class=\"content-ad\"></div>\n\n- 유료 소프트웨어.\n\n# AnyBurn: DMG 파일을 USB로 복사하는 무료 도구\n\nAnyBurn은 Mac과 Windows 모두에서 DMG 파일을 USB에 복사하는 데에 좋은 도구입니다. 가장 좋은 점은 가정 및 비즈니스용으로 완전히 무료이므로 프리미엄 기능을 지원하면서도 돈을 내지 않아도 된다는 것입니다. UUByte DMG Editor와의 차이점은 매우 가볍지만 여전히 다양한 복사 도구를 제공한다는 것입니다. 이 경우 AnyBurn을 사용하여 macOS DMG 파일을 USB 드라이브에 복사할 수 있습니다. 아래는 진행 방법입니다:\n\n단계 1: 컴퓨터에서 AnyBurn을 실행하고 부팅 가능한 USB 드라이브 만들기를 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_3.png)\n\n단계 2: 부팅 가능한 USB 드라이브 창에서 Windows 컴퓨터의 macOS DMG 파일을 선택합니다. 도구는 현재 컴퓨터에 연결된 모든 드라이브를 나열할 것입니다. 컴퓨터에 삽입한 드라이브를 선택하고 써진 데이터 확인 옵션 옆에 체크하세요.\n\n![이미지](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_4.png)\n\n단계 3: 'Burn' 버튼을 클릭하면 도구가 DMG 파일을 삽입된 USB 드라이브에 불를 붙이기 시작합니다. 과정 중에 진행률 표시 막대가 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 장점:\n\n- 무료입니다.\n- 이미지 복사 및 붙여넣기를 위한 더 많은 기능이 있습니다.\n\n## 단점:\n\n- 파일 불러오기 속도가 훨씬 느립니다.\n- 실행하려면 관리자 권한이 필요합니다.\n- 사용자 인터페이스가 오래되었습니다.\n\n<div class=\"content-ad\"></div>\n\n# TransMac: Windows 전용 프로그램으로 DMG 파일을 USB 드라이브에 복원 및 불러오기\n\nTransMac는 Windows에서 DMG 파일을 USB에 불러오는 좋은 옵션이에요. 이 도구는 수년간 사용되어 왔으며, Windows 사용자들을 위한 여러 훌륭한 기능을 제공하고 있어요. DMG 파일을 만들고 압축하며 확장하고 분할하는 기능을 포함하고 있어요.\n\nTransMac는 무료가 아니에요. 현재 사용자 라이선스는 59달러로, 위에 나열된 방법보다 더 비싸요. 그러나 15일 무료 평가판을 제공하고 있으며, 평가판을 사용하려면 신용카드를 등록해야 하기 때문에 다소 귀찮을 수 있어요.\n\n시작하기 전에, 이제 16GB 저장 공간을 가진 USB 드라이브가 있고 드라이브에 중요한 것이 없는지 확인하세요. 프로세스가 드라이브의 모든 것을 삭제할 거에요.\n\n<div class=\"content-ad\"></div>\n\nTransMac을 설치하고 PC에서 실행하세요. 관리자 권한으로 실행하고 USB 드라이브를 컴퓨터에 삽입하세요.\n\n![image](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_5.png)\n\n메인 창에서 왼쪽 패널에서 USB 드라이브를 마우스 오른쪽 버튼으로 클릭한 다음, 디스크 이미지 복원 옵션을 선택하세요. 팝업에서 Yes를 클릭한 후 DMG 파일을 선택하세요. 그 후에 OK 버튼을 눌러 Windows 10 PC에 DMG 파일을 USB에 복사하는 작업을 시작하세요.\n\n## 장점:\n\n<div class=\"content-ad\"></div>\n\n- 무료 체험이 가능합니다.\n- dmg 파일을 열고 압축 해제할 수 있습니다.\n- USB를 맥 파일 시스템으로 포맷할 수 있습니다.\n\n## 단점:\n\n- 너무 비싸요.\n- 사용 중 많은 오류가 발생합니다.\n- 사용하기 어렵습니다.\n\n# VMWare Workstation: macOS 가상 머신에서 DMG를 USB에 기록하기\n\n<div class=\"content-ad\"></div>\n\nWindows 사용자라면 macOS 가상 머신을 생성한 후 내장 명령을 사용하여 DMG 파일을 USB 드라이브에 불 수 있습니다. Windows에서 macOS VM을 만드는 두 가지 방법이 있습니다. VMWare Workstation과 VirtualBox를 사용할 수 있는데, 아래 섹션에서는 VMWare 방법을 사용할 것입니다.\n\n시작하기 전에 VMWare Workstation Pro 및 macOS Unlocker V3가 설치된 컴퓨터를 준비하세요. 또한 macOS Big Sur IOS 파일이 필요합니다. 이 파일은 다음 링크에서 다운로드할 수 있습니다.\n\nmacOS Unlocker를 다운로드하고 나면 win-install.cmd를 마우스 오른쪽 버튼으로 클릭하고 \"관리자 권한으로 실행\"을 선택하세요.\n\n## Windows 10 PC에서 macOS 가상 머신 만들기\n\n<div class=\"content-ad\"></div>\n\n단계 1: 이제 컴퓨터에서 VMWare를 실행하고 새 가상 머신 만들기를 클릭한 다음 Typical (권장) 옆에 있는 상자를 선택해주세요.\n\n단계 2: 여기서 운영 체제를 나중에 설치하겠다고 선택하고 다음을 클릭해주세요. 그 후에 게스트 운영 체제 목록에서 macOS X를 선택하고 다음 버튼을 클릭해주세요.\n\n단계 3: 가상 머신에 이름을 입력해주세요. 이 경우 \"macOS Big Sur\"를 입력하고 가상 머신을 저장할 위치를 선택해주세요. 그런 다음 다음 버튼을 클릭하고 다음 단계로 진행해주세요.\n\n단계 4: 가상 머신의 디스크 크기를 지정하고 가상 디스크를 단일 파일로 저장하는 옵션 옆에 있는 상자를 선택한 후 다음을 클릭해주세요.\n\n<div class=\"content-ad\"></div>\n\n5단계: 다음 창에서 '하드웨어 사용자 정의'를 클릭한 후에 가상 머신의 메모리를 4GB에서 8GB로 조정해주세요. 윈도우에서 실행 중인 가상 머신에 대한 성능을 높일 수 있습니다.\n\n6단계: 이어서 '프로세서'를 선택한 후 CPU 프로세서를 2코어에서 4코어로 늘려주세요. 그 후 'ISO 이미지 파일 사용' 옵션 옆에 체크를 하고 '찾아보기'를 클릭해주세요.\n\n![이미지](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_6.png)\n\n7단계: 이제 macOS Big Sur ISO 파일을 선택하고 '열기'를 눌러주세요. 작업을 마치면, '닫기'를 클릭하여 하드웨어 창을 닫아주세요.\n\n<div class=\"content-ad\"></div>\n\n**단계 8:** 새 가상 머신 마법사 창에서 완료를 클릭하세요. 그 후 macOS Big Sur VM 폴더를 찾아 macOS Big Sur.vmx를 클릭하고 메모장을 통해 열어주세요.\n\n**단계 9:** 이제 메모장 아래로 스크롤하여 다음 코드를 추가한 후 저장을 클릭하세요.\n\n\nsmbios.reflectHost = “TRUE”\nhw.model = “MacBookPro14,3”\n\n\n<div class=\"content-ad\"></div>\n\nboard-id = “Mac-551B86E5744E2388”\n\nsmc.version = “0”\n\nStep 10: 이제 VMWare를 열어 macOS VM에서 Windows에서 이 가상 머신의 전원을 켜고 macOS Big Sur가 부팅 될 때까지 기다립니다.\n\n![이미지](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_7.png)\n\n<div class=\"content-ad\"></div>\n\n**단계 11:** 초기 설정을 진행하여 디스크 유틸리티 옵션을 보게 될 때까지 이어주세요. 해당 옵션을 클릭하고 계속을 눌러주세요.\n\n**단계 12:** 이제 VMware Virtual SATA Hard Drive Media를 선택하고 지우기를 클릭하세요. 여기서 macOS Big Sur를 입력한 다음, 포맷 드롭다운 목록에서 APFS를 선택하고 지우기를 클릭하세요.\n\n**단계 13:** 완료를 클릭한 후 디스크 유틸리티를 종료하고 macOS 설치를 클릭하세요. 윈도우에서 macOS VM 설치를 완료하기 위해 단계를 따라 진행하세요.\n\n## macOS 가상 머신에서 DMG를 USB에 불러오기\n\n<div class=\"content-ad\"></div>\n\nStep 1: macOS 가상 머신이 Windows에서 실행 중이라면, 이제 터미널을 사용하여 DMG 파일을 USB에 복사할 수 있어요.\n\nStep 2: USB 드라이브를 PC에 연결하고 터미널을 열어주세요. 여기서 다음 명령을 실행해주세요:\n\nsudo /Applications/Install\\ macOS\\ Big\\ Sur.app/Contents/Resources/createinstallmedia — volume /Volumes/MyVolume\n\n· MyVolume을 USB 드라이브의 이름으로 바꿔주세요.\n\n<div class=\"content-ad\"></div>\n\n3단계: Return을 누르고 관리자 암호를 입력하세요. 그 후에 드라이브를 지우려면 y를 입력하고 OK를 클릭하세요.\n\n만일 처음 세 가지 방법이 모두 실패한다면, 가상 머신 소프트웨어를 사용하여 작업을 완료하는 것은 권장되지 않습니다. 그런데 이미 PC에 macOS 가상 머신이 있다면 이 방법을 고려해볼 수 있습니다.\n\n[업데이트] 누군가가 dmg 파일을 ISO로 변환하고 ISO를 USB에 ISO 복사 도구로 불을 수 있는 가능한 해킹 방법을 보고했습니다. 이를 무료 도구 dmg2img 명령줄 유틸리티로 수행할 수 있습니다. 그러나 저는 이 방법으로 성공한 적이 없습니다.","ogImage":{"url":"/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_0.png"},"coverImage":"/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_0.png","tag":["Tech"],"readingTime":7},{"title":"맥을 더 빠르게 만드는 방법 macOS Ventura","description":"","date":"2024-06-19 08:56","slug":"2024-06-19-HowtoSpeedUpYourMacWithmacOSVentura","content":"\n\n## macOS 13.1 Venture에서 맥을 빠르게 하는 다섯 가지 방법\n\n<img src=\"/assets/img/2024-06-19-HowtoSpeedUpYourMacWithmacOSVentura_0.png\" />\n\n이 기사에서는 macOS Ventura 속도를 최적화하는 방법을 살펴보겠습니다. 보통 나는 내 맥을 완벽하게 만족하지만 13.1 버전으로 업데이트한 후에 부팅 중 간헐적으로 멈춤이 발생하고, 포토샵이 멈추며, 애니메이션이 느려지는 것을 알아챘습니다. 그래서 이를 고치는 방법에 대해 연구를 시작하고 다음 다섯 가지를 찾아냈습니다.\n\n## 부팅 후 애플리케이션\n\n<div class=\"content-ad\"></div>\n\n일부 설치한 애플리케이션은 시스템 부팅 후 자동으로 시작할 수 있습니다. 이는 시스템이 부팅되는 동안 macOS를 시작하는데 바쁘기 때문에 앱을 즉시 사용할 수 있지만 앱을 실행하는 것이 전체 부팅 프로세스를 늦출 수 있다는 것을 의미합니다.\n\n거기에, 대부분의 경우 부팅 후 바로 앱을 사용하지는 않습니다. 따라서 부팅을 빨리 하려면 부팅 후 자동으로 실행되는 앱을 확인하고 필요한 경우 그 목록을 줄이는 것이 좋습니다.\n\n이를 위해서는 → 시스템 환경 설정 → 일반 → 로그인으로 이동하십시오. 여기에서 상단에 있는 \"시작 시 열기\" 앱 목록을 선택하고, 필요한 경우 왼쪽 아래쪽에 있는 체크를 해제할 수 있습니다.\n\n## 디스크 오류\n\n<div class=\"content-ad\"></div>\n\n최근에 맥북이 느려지거나 종종 다시 부팅하거나 종료해야 하는 경우가 있나요? 그렇게 대답한다면, 디스크에 오류가 있을 수 있어서 이러한 문제가 발생할 수 있습니다.\n\n![맥북 속도 향상 팁](/assets/img/2024-06-19-HowtoSpeedUpYourMacWithmacOSVentura_1.png)\n\n그러나 맥에서 간단한 테스트를 실행하여 오류를 찾고 수정할 수 있습니다. 디스크 유틸리티 앱을 열고 왼쪽에 있는 내부 디스크를 강조 표시한 다음 상단의 \"고급 수리\"를 탭하고 마법사를 따라 오류를 제거할 수 있습니다.\n\n## 도전적인 응용 프로그램\n\n<div class=\"content-ad\"></div>\n\n새로운 운영 체제로 업그레이드 한 후, 우리의 경우 macOS 13.1 Ventura, 가끔 앱이 제대로 작동하지 않을 수도 있습니다.\n\n가끔은 개발자의 잘못이거나, 가끔은 시스템의 잘못일 수도 있지만, 그것을 받아들여야 합니다. 앱이 제대로 작동하지 않으면 \"루핑\"과 같은 문제를 일으킬 수 있어서 꼭 필요한 작업이 중단되고 전력이 과다 사용되어 속도가 느려질 수 있습니다. 업데이트 후 Mac이 느리게 실행되는 경우 무거운 앱을 확인해보세요.\n\nActivity Monitor 앱으로 이동하고 CPU 범주로 이동한 다음 % CPU에 따라 내림차순으로 프로세스를 정렬합니다. 그런 다음 상위 위치에 의심스러운 앱을 찾은 경우 해당 앱을 누르고, 그런 다음 상단의 X를 누릅니다. 그런 다음 강제 종료를 누릅니다.\n\n## 효과 및 애니메이션\n\n<div class=\"content-ad\"></div>\n\n맥OS에서는 앱을 열 때, 제스처를 사용할 때 등 다양한 효과와 애니메이션이 보입니다. 그러나 이러한 모든 효과와 애니메이션을 렌더링하는 데에는 일정한 성능이 필요하며, 이는 예전 맥에서는 여분으로 가지고 있지 않을 수 있습니다.\n\n다행히도, macOS에서는 효과와 애니메이션을 쉽게 제한할 수 있습니다. 시스템 설정 → 접근성 → 모니터로 이동하여 '모션 제한 활성화'를 설정할 수 있습니다. 더불어 '투명도 줄이기'도 활성화할 수 있습니다.\n\n게다가, 애니메이션 자체가 수행하는 데 시간이 걸리므로 이를 끄면 맥이 즉시 빠르게 느껴질 것이며, 이는 새로운 기계에서도 느낄 수 있을 것입니다.\n\n## 저장 공간\n\n<div class=\"content-ad\"></div>\n\n맥이 빠르고 안정적으로 작동되도록 보장하려면 저장 공간에 충분한 여유 공간이 있는지 확인해야 합니다. 물론 맥이 여유 공간이 부족하다면 알려줄 겁니다.\n\n하지만, 여유 공간이 없어진다면, 애플은 불필요한 파일을 삭제하여 저장 공간을 확보하기 위해 하드웨어 리소스를 주로 할당할 것입니다. 이는 심각한 속도 저하로 이어질 수 있습니다.\n\n맥이 저장 공간을 확보하지 못하면 종료되고 데이터를 삭제한 상태에서 다시 설치해야 할 수도 있습니다. 비슷한 문제가 발생했거나 맥 미니를 맥 이상으로 사용하고 있는 건 아닌지요?\n\n이 글을 읽어주셔서 감사합니다! 마음에 드셨다면 좋아요 👏🏻와 댓글 💬로 지지해주시면 감사하겠습니다. 그리고 더 많은 콘텐츠를 원한다면, 저를 팔로우해주시기 바랍니다! 즐거운 하루 보내세요 😊👌👋\n\n<div class=\"content-ad\"></div>\n\n제 작업을 직접적으로 지원해 주시면 감사하겠습니다: [https://ko-fi.com/jakubjirak](https://ko-fi.com/jakubjirak)","ogImage":{"url":"/assets/img/2024-06-19-HowtoSpeedUpYourMacWithmacOSVentura_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoSpeedUpYourMacWithmacOSVentura_0.png","tag":["Tech"],"readingTime":3},{"title":"맥 해독하기 macOS 커널에서 고급 CPU 메트릭스 조사하기","description":"","date":"2024-06-19 08:54","slug":"2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics","content":"\n\n<img src=\"/assets/img/2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics_0.png\" />\n\n우리의 지난 탐험에서는 인텔과 애플 실리콘 간 CPU 사용량 차이에 대해 표면을 긁었습니다. 이제는 더 깊이 파고들어볼 시간입니다. macOS 커널은 CPU 사용량을 어떻게 추적하고, 다른 커널 서브시스템들이 시간 기록에 대해 어떤 가정을 하는지 살펴봅니다. 본 글은 Mach 리카운트 서브시스템으로 빠져들어, CPU 시간의 매 틱이 면밀하게 기록되는 과정을 안내합니다.\n\n외부에서 커널 밖에서 CPU 부하를 정확히 결정하는 것은 불가능하다는 것을 이해한 뒤, 서로 다른 CPU 코어가 서로 다른 속도로 동작한다는 점에서 좋은 근사치를 찾겠다는 다짐을 하였습니다. 결국, 우리는 시스템 문제 진단을 제공하고 정확한 시스템 사용 보고서를 제공하는 대신에 도움을 제공해야 합니다.\n\nproc_pidinfo(PROC_PIDTASKINFO) 시스템 호출을 통해 프로세스별 CPU 시간 사용량을 사용할 수 있게 되었는데, 우리가 찾고 있는 것은 전체 시스템에서 (유휴 시간 포함) 사용된 CPU 시간을 결정하여 프로세스별 비율을 수립하는 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n# 초기 접근 방식: host_process_info 메트릭 값을 합산하기\n\n일반적으로 가장 명백한 해결책을 먼저 시도하고, 그 후에 이를 발전시키는 편입니다. 이 경우, host_process_info() API는 이미 각 프로세서별 전체 CPU 부하를 반환하며, 여기에 idle 시간이 포함되어 있기 때문에 이를 합산하는 것은 각 프로세스를 측정할 기준을 결정하는 명백한 방법일 수 있습니다.\n\n그러나 결과를 보고 실망했습니다: 테스트 프로세스를 설정하여 전체 CPU 시간의 약 10%를 사용하도록 하였으나, 이 방법을 따르면 보고된 사용량이 약 0.01%와 같은 수준으로 표시되었습니다. 결과에 일정한 배수를 곱하면 일부 결과가 더 좋아지지만, 유감스럽게도 동일한 배수로 모든 결과를 의미 있게 변환할 수 없었습니다.\n\n점점 더 가까워지는 기분이었습니다. 이러한 차이로 인해 처음에 host_process_info()와 proc_pidinfo API에서 사용되는 시간 단위에 차이가 있을 수 있다고 생각하게 되었습니다. 내 관찰 아래에 정확히 무엇이 있는지 알아보기 위해, 시스템 질문에 대한 모든 답을 찾을 수 있는 유일한 장소인 케널 소스로 의존하게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n# 유일한 진실의 근원\n\n리눅스를 기반으로 한 네트워크 보안 장치를 개발하던 시절, 리눅스 네트워킹 구현을 이해하기 위한 책을 추천해 줄 수 있느냐고 동료에게 물어보았어요. 그때 동료가 한 말을 절대로 잊지 못할 거예요: 왜 구식 책을 사서 읽느냐고 할 때, 커널 소스로부터 가장 정확한 답변을 받을 수 있는데?\n\n그 이후로는 언제나 코드베이스에 접근하는 방식이 바뀌었어요.\n\n커널 소스에 내 질문에 대한 답변이 반드시 포함되어 있을 것이라고 확신을 가지고, 이 버그를 최종적으로 해결하기로 결심했어요.\n\n<div class=\"content-ad\"></div>\n\n## 올바른 질문하기\n\n커널 소스를 연구하기 전에 항상 답변하고자하는 구체적인 질문을 생각해냅니다. 이러한 질문들을 프로그램이라는 복잡한 운영 체제 커널을 특징 짓는 지나치게 많은 세부 사항을 탐색하는 데 도움이 되는 지도로 생각하세요.\n\nhost_process_info()와 proc_pidinfo(PROC_PIDTASKINFO)은 아마도 서로 다른 시간 단위를 사용할 것으로 의심했기 때문에 아직 찾아야 할 것이 있었습니다:\n\n- 각 API가 사용하는 시간 단위는 무엇인가요?\n- 이러한 시간 단위를 서로 변환하는 방법은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n세부적으로 각 API를 살펴보기 전에 Mach 커널이 리소스 회계를 수행하는 방법을 이해하려면 우회해야 합니다.\n\n# Mach 재계산 서브시스템\n\n작업 리소스 사용에 대한 카운터를 유지하는 Mach 커널의 일부는 재계산(Recount)이라고 합니다. recount_context_switch() 함수는 문맥 전환이 발생할 때 호출되며 현재 실행 중인 작업에 대한 사용량 카운터를 업데이트하는 역할을 합니다.\n\n재계산 서브시스템은 다른 리소스 유형에 대해 서로 다른 세분도를 사용하며, 청소 및 메모리 사용의 효율성 사이의 균형을 유지합니다.\n\n<div class=\"content-ad\"></div>\n\n저는 당신의 조사와 관련된 사안으로, Recount 이름이 곧 커널 소스에 나타날 것임을 확인했습니다.\n\n# 첫 번째 정착지: proc_pidinfo\n\nproc_pidinfo API를 살펴보면서 시작했습니다. 이 API는 단일 프로세스가 사용한 CPU 시간을 보고합니다.\n\n해당 함수를 검색하고 스택 추적을 따라가 보니, fill_taskprocinfo 함수가 Mach 커널에서 작업 정보를 획득하고 보고하는데 궁극적으로 관여하고 있음을 알 수 있었습니다. task_info 속성인 pti_total_system과 pti_total_user를 거슬러 올라가면 proc_pidinfo() API와 Mach Recount 서브시스템 사이의 관련성이 드러납니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics_1.png)\n\n해설: fill_taskprocinfo 함수에서 이 코드 조각은 CPU 시간 정보를 수집하는 방법을 보여줍니다. recount_task_times 함수는 작업에 대한 총 시스템 및 사용자 시간을 수집하며, proc_pidinfo API가 CPU 사용량을 보고하는 방법을 이해하는 데 중요합니다.\n\nrecount_task_times()로 호출 스택을 따라가면, 최종적으로 집계되는 필드는 rt_usage라는 것을 알 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n설명: recount_usage 구조는 Mach 시간 단위에서 사용자 및 시스템 시간을 구체적으로 유지하는 CPU 사용 메트릭을 저장합니다. 이를 통해 proc_pidinfo API가 CPU 시간을 어떻게 검색하고 보고하는지 이해할 수 있습니다.\n\n저는 recount_usage 구조의 필드가 동일한 접미사(_time_mach)를 가지고 있는 것을 발견했습니다. 이는 사용된 시간 단위에 대한 초기 힌트로 이해했습니다.\n\n# 다음 정거장: host_process_info\n\nhost_process_info() 함수는 각 CPU 코어가 사용한 전체 CPU 시간을 보고합니다. processor_cpu_load_info() 함수가 이 정보를 보고하는 데 책임이 있다는 것을 알아보는 데 시간이 오래 걸리지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n\n\n![이미지](/assets/img/2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics_3.png)\n\n설명: 이 함수에서는 recount_processor_usage가 Mach 시간의 CPU 사용률 데이터를 제공하고, hz_tick_interval을 사용하여 해당 데이터를 틱으로 변환합니다. 이 변환 단계는 서로 다른 API 간에 CPU 시간 보고에 대한 불일치를 이해하는 데 중요합니다.\n\n이것은 host_process_info와 Mach Recount 서브시스템 간의 연결이고, Recount로부터 얻은 지표가 Mach 시간으로 보고되며 반환되기 전에 상수 요소 hz_tick_interval로 나눠진다는 사실이 더 중요합니다.\n\n저는 실험 중에 이전에 관찰했던 내용이 변환 시간 단위 사이에 상수 요소가 포함되어 있다는 명백한 확인을 발견해서 기뻤습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이를 통해 proc_pidinfo API가 Mach 시간 단위로 CPU 사용량을 반환하고 host_process_info API가 대신 틱을 사용한다는 것을 알았습니다. 두 단위는 hz_tick_interval 요소를 사용하여 변환할 수 있습니다. 즉, hz_tick_interval 값을 결정할 수 있다면 두 시간 단위를 변환하고 버그를 해결할 수 있을 것입니다.\n\n그러므로, 다음으로 해야 할 당연한 단계는 hz_tick_interval 값을 찾는 것입니다.\n\n## hz_tick_interval 역추적\n\n안타깝게도 hz_tick_interval은 사용자 공간에서 접근할 수 없습니다. 빠른 해결책에 대한 희망이 사라졌지만, 최소한 값을 가져와서 아이디어가 유효한지 확인할 수 있다면 좋겠습니다.\n\n<div class=\"content-ad\"></div>\n\n이 상수를 찾는 것은 커널의 어느 부분이 관련되느냐에 따라 달랜 시간 기록 가정들의 미로에 들어간 것 같았습니다. 예를 들어, hz_tick_interval의 정의를 보며 BSD 부분에서 틱이 10ms를 나타내는 것으로 예상한다는 코멘트를 보았습니다. 이것이 서로 다른 API에서 서로 다른 시간 단위가 사용되는 이유일 것입니다.\n\n사용할 수 있는 변환 루틴을 찾아보았습니다. 궁극적으로는 사용자 공간에서 접근할 수 없는 rtclock_sec_divisor 상수인 것 같습니다. 이 값은 부트로더가 시스템 부팅 시 채우는 것입니다. 따라서, 제 가정을 수동으로 확인하기 위해 이 값을 설정하는 것은 성공하지 못했습니다.\n\n이 값을 제공할 것으로 예상했던 사용자 공간 API인 mach_timebase_info가 실제로는 기대한 결과를 제공하지 않았습니다. 따라서 다시 한 번 원점으로 돌아간 것 같은 느낌이 들었습니다!\n\nproc_pidinfo와 host_process_info 간의 시간 단위 불일치를 추적하는 것은 도전적이지만 유익한 여정이었습니다. Mach Recount 하위 시스템을 면밀히 살펴보고 macOS에서의 CPU 시간 보고 복잡성을 밝혀냈습니다. 문제의 근원을 이해했지만, 사용자 공간에서 hz_tick_interval에 접근할 수 없어 해결책을 찾는 것이 쉽지 않습니다. 그러나 이 도전은 끝이 아니라 혁신적인 해결책을 찾을 기회입니다. 다음 부분에서 이러한 시간 단위를 변환하고 정확한 CPU 메트릭을 보장하는 방법을 탐색할 것입니다. 더 많은 통찰과 실용적인 응용 프로그램을 기대해 주세요!","ogImage":{"url":"/assets/img/2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics_0.png"},"coverImage":"/assets/img/2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics_0.png","tag":["Tech"],"readingTime":6},{"title":"2024년 개발자를 위한 macOS에서 반드시 필요한 도구 및 앱","description":"","date":"2024-06-19 08:52","slug":"2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024","content":"\n\n\n![매체 기사](/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_0.png)\n\n여기가 내 첫 번째 매체 기사야.\n\n10년 이상 동안 macOS를 활용해온 나는 아키텍처, 클라우드, 모바일 앱, 웹 앱에 집중하며 반드시 필요한 다음과 같은 도구들을 소개하고 싶다.\nVS Code, Intellij IDEA, Xcode, Android Studio, Docker와 같이 흔히 쓰는 것들은 건너뛰겠어. 그런데 Fleet에 관심 있는 사람 있나요? 나한테 알려줘.\n\n\n<div class=\"content-ad\"></div>\n\n# 개발자 도구\n\nBrew (무료)\n\nHomebrew는 Apple의 운영 체제인 macOS에 소프트웨어를 설치하는 작업을 단순화하는 무료 오픈 소스 소프트웨어 패키지 관리 시스템입니다. 사용하기 쉽고 몇 가지 간단한 단계로 설치할 수 있습니다. Homebrew를 설치하면 Homebrew 리포지토리에서 소프트웨어를 설치할 수 있습니다. Homebrew 리포지토리에는 수천 가지 패키지가 포함되어 있습니다. GitHub와 같은 다른 소스에서 소프트웨어를 설치하는 데도 Homebrew를 사용할 수 있습니다. Homebrew는 macOS를 최신 소프트웨어로 유지하고 macOS 앱 스토어에 없는 소프트웨어를 설치하는 좋은 방법입니다.\n\n이것은 macOS를 새로 설치한 후 맨 처음 설치하는 앱입니다.\n\n<div class=\"content-ad\"></div>\n\n이제 아래 명령어를 사용하여 Homebrew를 설치해보세요.\n\n```js\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\nHomebrew가 설치되면 매우 간단하게 대부분의 앱을 Homebrew로 설치할 수 있어요. 아래는 몇 가지 IDE 예시입니다:\n\n```js\n# VS Code 설치\nbrew install --cask visual-studio-code\n\n# Intellij IDEA Community Edition 설치\nbrew install --cask intellij-idea-ce\n\n# Android Studio 설치\nbrew install --cask android-studio\n```\n\n<div class=\"content-ad\"></div>\n\nbrew 앱을 업데이트하려면 아래 명령어를 사용하세요 (또는 MacUpdater, Latest app을 사용하세요). 자동화하려면 크론 작업을 설정할 수도 있어요 :)\n\n```js\nbrew update && brew upgrade && brew cleanup\n```\n\nWarp Terminal (무료/유료)\n\nWarp Terminal은 macOS용 현대적이고 빠르며 사용자 정의가 가능한 터미널 에뮬레이터입니다. Rust로 개발되었으며 GPU 가속을 사용하여 부드럽고 반응이 빠른 경험을 제공합니다. Warp Terminal은 탭, 분할 창 및 다중 프로필을 포함한 다양한 기능을 지원합니다. 또한 내장 파일 관리자와 강력한 검색 도구를 갖추고 있습니다. Warp Terminal은 개발자와 강력하고 사용자 정의 가능한 터미널 에뮬레이터를 원하는 모든 사람들에게 좋은 선택입니다.\n\n<div class=\"content-ad\"></div>\n\n\n\n![Image](/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_1.png)\n\n요즘 모든 도구와 마찬가지로 이것도 AI (GPT ahem ahem) 기능을 갖추고 있습니다. Mac에서 숨겨진 파일을 표시하는 명령을 요청할 수 있어요. 가장 좋아하는 기능은 구문 강조, 자동 제안 및 북마크 옵션으로 시간을 많이 절약할 수 있습니다.\n\nbrew를 사용하여 설치해보세요\n\n```js\nbrew install --cask warp\n``` \n\n\n<div class=\"content-ad\"></div>\n\nCotEditor (무료)\n\nCotEditor는 웹 페이지 (HTML, CSS), 프로그램 소스 코드 (Python, Ruby, Perl 등), 구조화된 텍스트 (Markdown, Textile, TeX 등) 또는 기타 종류의 일반 텍스트를 편집하기 위해 설계된 오픈 소스 경량이면서 강력한 텍스트 편집기입니다. macOS용으로 만들어져 macOS 응용 프로그램이 가져야 할 외관과 기능을 갖추고 있습니다.\n\n![이미지](/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_2.png)\n\n\"또 다른 텍스트 편집기가 필요한 이유가 뭐냐구요?\"라고 궁금해하실 수도 있습니다. 그런데 때로는 파일을 저장하지 않아도 문법 강조를 할 수 있는 곳에 코드를 복사하여 붙여넣고 싶을 때도 있거든요 (이것이 Sublime에서 잘 되지 않는 부분입니다). CotEditor는 바로 그런 상황에 유용하죠.\n\n<div class=\"content-ad\"></div>\n\n맥 앱 스토어에서 설치하거나 간단히 brew를 사용할 수 있어요.\n\n```js\nbrew install --cask coteditor\n```\n\nFork (유료)\n\nFork는 맥과 윈도우용 빠르고 친근한 Git 클라이언트에요. 사용하기 쉽도록 설계되어 깔끔하고 직관적인 인터페이스를 갖췄어요. Fork는 기본적인 Git 명령뿐만 아니라 더 고급 기능인 병합 충돌 해결 및 대화식 리베이스도 지원해요. 내장된 차이점 뷰어와 강력한 검색 도구도 있어요. Fork는 강력하면서 사용하기 쉬운 Git 클라이언트를 원하는 개발자들에게 좋은 선택이에요.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_3.png)\n\nFork를 사용하는 이유는 macOS 앱 같은 느낌이 들기 때문이에요 :) SourceTree나 Tower와 같은 대안이 있지만, 난 항상 간단함 때문에 Fork로 돌아오게 되죠.\n\n일반적으로 brew를 사용하여 설치하세요.\n\n```js\nbrew install --cask fork\n```\n\n<div class=\"content-ad\"></div>\n\n새 파일 메뉴(유료)\n\n새 파일 메뉴는 Finder 확장 프로그램으로, Finder 콘텍스트 메뉴를 통해 손쉽고 빠르게 새 파일을 만들 수 있습니다. Finder 창이나 데스크톱에서 마우스 오른쪽 버튼을 클릭하여 새 파일을 생성하거나 한꺼번에 여러 파일을 만들 수 있습니다. 새 파일 메뉴는 텍스트 파일, 문서, 스프레드시트, 프레젠테이션 등 다양한 파일 유형을 지원하며 html, dart, go 등을 위한 새 템플릿을 추가할 수도 있습니다.\n\nMac App Store에서 다운로드하세요.\n\n<div class=\"content-ad\"></div>\n\nColorSlurp (무료/유료)\n\n맥OS와 iOS용 컬러 피커 앱인 ColorSlurp은 화면에서 색상을 선택하고 편집하고, 컬러 팔레트를 만들고, 다양한 형식으로 색상을 내보낼 수 있습니다. 디자이너와 개발자들에게 강력한 도구로 만드는 다양한 기능을 갖고 있습니다. 초정밀 확대 도구, 다양한 컬러 선택 도구, 사진에서 자동으로 팔레트 만드는 기능 등이 있습니다. ColorSlurp은 사용하기 쉽고, 세련된 모던한 인터페이스를 갖추고 있습니다.\n\n![이미지](/assets/img/2024-06-19-Must-have-tools-and-apps-for-macOS-for-developers-in-2024_5.png)\n\n맥 앱 스토어에서 받아보세요.\n\n<div class=\"content-ad\"></div>\n\nUTM (무료)\n\n이것은 macOS용 무료 오픈소스 가상 머신 앱입니다. 인기 있는 시스템 에뮬레이터인 QEMU를 기반으로하며 사용자 친화적 인터페이스를 제공하여 가상 머신을 만들고 관리할 수 있습니다. UTM은 Mac에서 Windows, Linux, macOS를 포함한 다양한 운영 체제를 실행하는 데 사용할 수 있습니다. macOS에서 지원되지 않는 새 소프트웨어를 테스트하거나 예전 운영 체제를 실행하려는 개발자와 사용자들에게 강력한 도구입니다.\n\nM1/M2 기반 Mac에 최적화되어 있습니다.\n\n대안으로는 Parallels ($$$), VMware Fusion (무료/유료), VirtualBox (무료)가 있습니다. 개인적으로 저는 Parallels와 같은 구독 기반 앱을 선호하지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_6.png\" />\n\nbrew를 사용하여 설치하세요\n\n```js\nbrew install --cask utm\n```\n\nShellHistory (유료)\n\n<div class=\"content-ad\"></div>\n\n백업, 동기화 및 쉘 히스토리를 정리하는 데 도움을 줍니다. 이 도구는 쉘 히스토리를 SQLite 데이터베이스에 Write-Ahead-Log로 저장하여 단순한 텍스트 파일이 아니라 iCloud에 백업합니다. 전체 텍스트 검색을 사용하여 명령을 쉽게 찾을 수 있습니다. 또한 ShellHistory는 종료 코드, 작업 디렉토리, 호스트, 사용자, 명령의 경과 시간 및 세션 ID를 포함하여 히스토리를 확장합니다. 쉘 히스토리에서 명령을 노트북에 정리할 수 있습니다.\n\n필수는 아니지만 유용합니다. 기억하지 못하는 명령을 사용한 경우 UI에서 빠르게 검색하고 복사할 수 있습니다.\n\n맥 앱 스토어에서 다운로드하세요.\n\n![이미지](/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_7.png)\n\n<div class=\"content-ad\"></div>\n\n# 유틸리티\n\n사각형 (무료/유료)\n\n우리가 정말로 인정해야 할 것은, macOS에서의 창 관리가 없다는 것입니다. 그래서 이 앱이 필요한 것입니다. 우리는 항상 코드를 작성하고 미리보기를 나란히 표시하는 간단한 해결책을 찾고 있었고, 이 앱은 정확히 그 역할을 해주며 더 많은 일도 할 수 있습니다. 더 많은 기능이 있는 프로 버전도 있습니다.\n\n![이미지](/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_8.png)\n\n<div class=\"content-ad\"></div>\n\nbrew을 사용하여 설치하세요.\n\n```js\nbrew install --cask rectangle\n```\n\nMacUpdater (유료)\n\nMac App Store 앱이 아닌 앱을 최신 상태로 유지하는 필수 앱입니다. 이 앱은 유료이지만 모든 돈을 할 가치가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_9.png)\n\nbrew를 사용하여 설치하세요\n\n```js\nbrew install --cask macupdater\n```\n\n최신 버전 (무료)\n\n\n<div class=\"content-ad\"></div>\n\n맥업데이터의 대안으로 오픈 소스이며, 모든 앱의 업데이트를 보여주지 않는 유일한 제한이 있습니다. 그러나 맥업데이터보다 한 가지 장점이 있습니다. 맥 앱 스토어 앱의 업데이트를 정확히 보여주며, 한 번 클릭으로 모두 업데이트할 수 있습니다. 솔직히 말해서, 저는 두 앱 모두 사용합니다 :)\n\n![image](/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_10.png)\n\nbrew를 사용하여 설치할 수 있습니다\n\n```js\nbrew install --cask latest\n```\n\n<div class=\"content-ad\"></div>\n\nShottr (무료)\n\nShottr은 macOS용 무료 경량화면 캡처 앱입니다. M1/M2 맥에 최적화되어 있고 프리미엄 도구에서 기대할 수 있는 기능을 제공합니다. 캡처 모드에서 Shottr 앱은 스크롤링 스냅샷 및 창 스냅샷과 함께 배경을 추가한 고급 캡처를 수행할 수 있습니다. 또한 스크린샷에 주석을 추가하거나 텍스트를 넣고 민감한 정보를 흐릴 수 있는 내장 편집기도 있습니다. Shottr은 가격표가 부착되지 않은 강력한 스크린샷 앱을 찾고 있는 사용자들에게 좋은 선택지입니다.\n\n![이미지](/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_11.png)\n\nHomebrew를 사용하여 설치하세요\n\n<div class=\"content-ad\"></div>\n\n```js\nbrew install --cask shottr\n```\n\nOpenIn (유료)\n\nOpenIn은 macOS용 앱으로, 링크, 이메일 및 파일을 선택한 애플리케이션에서 열 수 있게 해줍니다. 링크, 이메일 및 파일을 위한 선택 목록을 사용자 정의하여 업무 흐름을 간소화할 수 있습니다.\n\n예를 들어, Teams 앱에서 클릭한 링크를 Edge 브라우저에서 열도록 구성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_12.png\" />\n\n맥 앱 스토어에서 설치하세요.\n\nOnyX (무료)\n\nOnyX는 macOS용의 다기능 유틸리티로, 부팅 디스크와 시스템 파일 구조를 확인하고 미사용 파일을 정리하며 기타 유지 보수 작업을 수행할 수 있습니다. Apple 애플리케이션의 숨겨진 매개변수를 구성하고 다양한 기능을 제공합니다. OnyX는 복잡한 명령어를 사용하여 입력해야 할 작업을 많이 처리할 수 있는 신뢰할 수 있는 응용 프로그램으로서, 명령 줄 인터페이스를 통해 작업할 필요가 없도록 깔끔한 인터페이스를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n아래의 표를 마크다운 형식으로 변경해 주세요.\n\n![이미지](/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_13.png)\n\nbrew를 사용하여 설치하실 수 있습니다.\n\n```js\nbrew install --cask onyx\n```\n\nHand Mirror (무료/유료)\n\n<div class=\"content-ad\"></div>\n\n핸드 미러는 메뉴 바에 위치한 무료 맥 유틸리티입니다. 클릭할 때마다 셀피 카메라의 작은 미리보기가 표시됩니다. 비디오 통화에 참여하기 전에 외모를 확인하거나 프레임에 부끄러운 것이 없는지 확인하는 데 유용합니다. 핸드 미러에는 유료 애드온이 있어 미리보기 창을 화면 다른 곳으로 이동하고 외관을 변경하거나 다른 앱 아이콘을 선택하는 기능과 같은 보너스 기능들을 잠금 해제할 수 있습니다.\n\n맥 앱 스토어에서 설치하세요.\n\nRaycast (무료/유료)\n\n<div class=\"content-ad\"></div>\n\nRaycast은 macOS용 생산성 앱으로, 작업을 완료하고 계산하며 공통 링크를 공유하며 등 손쉽게 할 수 있게 해줍니다. 이 앱은 앱을 실행하거나 파일을 검색하고 어떤 일이든 키보드 단축키를 만들 수 있는 확장 가능한 런처로 사용할 수 있습니다. Raycast에는 질문에 대답하거나 채팅하고 작업을 간소화할 수 있는 내장 AI 어시스턴트도 포함되어 있습니다.\n\nbrew를 사용하여 설치하세요\n\n```js\nbrew install --cask raycast\n```\n\n<div class=\"content-ad\"></div>\n\nTinkerTool (무료)\n\nTinkerTool은 macOS용 무료 오픈 소스 시스템 유틸리티로, 사용자들이 macOS의 숨겨진 환경 설정과 일부 시스템과 함께 제공되는 애플리케이션의 환경 설정을 변경할 수 있습니다. macOS의 룩앤필을 사용자 정의하고 macOS에서 발생할 수 있는 일부 문제를 해결하는 데 사용할 수 있는 강력한 도구입니다. TinkerTool은 사용이 쉽고 관리자 권한이 필요하지 않습니다. macOS 시스템에서 더 많이 활용하고 싶은 사람들에게 좋은 도구입니다.\n\n<img src=\"/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_16.png\" />\n\n그들의 웹사이트에서 다운로드하세요.\n\n<div class=\"content-ad\"></div>\n\nNumi (유료)\n\nNumi은 macOS용 계산기 앱으로, 자연스럽게 작업을 설명하고 정확한 답변을 즉시 얻을 수 있게 해줍니다. 예를 들어 \"9달러를 유로로\" 입력하면 Numi가 대신 정확히 계산해줍니다. Numi는 단위 변환, 날짜 및 시간 처리, Alfred 통합도 지원합니다.\n\n![이미지](/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_17.png)\n\nbrew를 사용하여 설치하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nbrew install --cask numi\n```\n\n## AltTab (무료)\n\nAltTab의 개발자로써, 이 앱은 macOS에 윈도우의 \"alt-tab\" 창 전환기능을 가져옵니다. 윈도우에서 앱 전환 중 미리 보기를 그리워한 적이 있나요? macOS에서 창을 찾는 고통을 알고 계시겠죠. 동일한 앱에 대해 여러 창이 있는 경우 cmd+tab로는 그것들이 표시되지도 않아요. 이상한 이동을 해야만 하는데요. 즉, cmd+tab 그리고 cmd+~입니다. 하지만 더 이상 그럴 필요가 없어요. AltTab은 이러한 모든 문제를 해결하면서 멋지게 보여줍니다. 내 의견으로는 반드시 필요한 도구이며, 무료입니다!\n\n<img src=\"/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_18.png\" />\n\n\n<div class=\"content-ad\"></div>\n\nbrew를 사용하여 설치해 보세요\n\n```js\nbrew install --cask alt-tab\n```\n\n다른 인기 있는 어플로는 Bartender, iStat Menus, 그리고 Amphetamine이 있어요.\n\n여기까지입니다. 이 어플들은 저가 거의 매일 사용하는 것들이에요. 다른 개발자들이 작업을 더 빨리 할 수 있도록 이들이 도움이 됐으면 좋겠네요.\n\n<div class=\"content-ad\"></div>\n\n다음 기사에서 VS Code 플러그인을 다룐다면 알려주세요. 또한 목록에 추가해야 할 애플리케이션이 있으면 아래 댓글로 알려주세요.\n\n2023년 8월 12일 업데이트: AltTab을 목록에 추가했습니다. 이 앱이 정말 좋으니까요.\n\n2024년 1월 12일 업데이트: 2024년에 앱들이 여전히 관련성이 있기 때문에 제목을 업데이트했어요 🤓\n\n2024년 3월 13일 업데이트: Fig를 삭제했습니다. 이제 Fig 팀은 명령줄을 위해 Amazon CodeWhisperer을 권장하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n감사합니다!","ogImage":{"url":"/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_0.png"},"coverImage":"/assets/img/2024-06-19-Must-havetoolsandappsformacOSfordevelopersin2024_0.png","tag":["Tech"],"readingTime":10},{"title":"나만의 창작글 작성 환경","description":"","date":"2024-06-19 08:49","slug":"2024-06-19-MyCreativeWritingSetup","content":"\n\n\n![My Creative Writing Setup](/assets/img/2024-06-19-MyCreativeWritingSetup_0.png)\n\n저는 드디어 2년간의 노력 끝에 첫 소설을 마쳤고 이미 두 번째 작품에도 착수했습니다. 또한 여러 단편 소설을 쓰고 있으며 몇 가지 게임 보조 자료도 천천히 작업 중에 있어요.\n\n많은 분들이 이러한 정보를 궁금해하니, 창작 작업을 위한 제 세팅을 공유하는 시간이 된 것 같아요. \"창작 작업\"이라고 명시한 이유는 다른 글쓰기 활동을 위한 도구 체인이 따로 있기 때문이에요. 이에 대해 미래 게시물에서 더 읽어보실 수 있어요.\n\n## 아이디어 기록\n\n\n<div class=\"content-ad\"></div>\n\n아이디어를 기록하고 추적하는 내 방식은 다소 산발적이며, 이제야 형식화하기 시작했습니다.\n\n아이디어가 떠오를 때 내가 어디에 있는지에 크게 달려 있습니다. 저는 사과 생태계의 일부분만 사용하는 이상한 사람 중 한 명입니다. 아이패드, 맥북, 그리고 안드로이드 폰을 사용하고 있습니다.\n\n폰에서 아이디어를 기록할 때는 보통 Zoho Notebook에 메모를 남기는 편이며, 이 애플리케이션을 사용하게 된 이유는 이 블로그 포스트에서 확인할 수 있어요.\n\n아이패드와 맥북을 오가며 여러 애플리케이션을 사용한 끝에, 아이디어를 위해 대부분 Apple Notes를 사용하고 있습니다. 가끔씩 Zoho Notebook이나 Mind Node를 사용하기도 하고, Freeform도 사용해봤지만, 내 아이디어가 주로 단어들의 연속이기 때문에 Notes만으로도 충분합니다.\n\n<div class=\"content-ad\"></div>\n\n가끔은 Trello 보드에 아이디어를 추가하기도 합니다. 하지만 일반적으로 아이디어가 프로젝트적 성격을 띄는 경우에 Trello를 사용하는 편이에요. 하지만 아이들이 언제 프로젝트로 전환되는지에 대한 정의가 약간 모호하다는 것을 인정해요.\n\n아이디어를 더 탐구하고 싶을 때, 일반적으로 Trello 아이템과 Scrivener 프로젝트의 텍스트 파일을 만들어요. Scrivener에 대해서는 나중에 자세히 이야기할게요!\n\n## 계획\n\n일반적으로 계획을 세울 때는 \"팬서\" 스타일입니다. 즉, 아이디어의 큰 그림을 그리고 \"바로 쓰기\"로 뛰어들고, 나중에 수정 단계에서 더 많은 계획과 연구를 합니다. 짧은 이야기의 경우, 그림을 그리고 연구를 하는 것을 최소화합니다. 대부분 몇 천 단어밖에 되지 않는 단편 소설의 경우에는 아이디어를 발견하는 탐험이 된다고 생각하기 때문이에요. 단편 소설의 특정 부분은 연구가 필요한 경우도 있지만 일반적으로는 최소한으로 합니다.\n\n<div class=\"content-ad\"></div>\n\n내 장편 소설과 게임 글쓰기에는 계획과 연구가 필요하며, 다시 말해 여러 가지 도구를 사용합니다.\n\n## 타임라인\n\n누가 어디서 무엇을 하는지 빠르게 헷갈리는 성격이에요. 어떤 방법을 따르는 사람이기도 한데, 제 생각에는 스티븐 킹이 제안했던 방법인데, 틀릴 수도 있어요. 타임라인의 적절한 세부 수준에 대한 방법을 따르고 있어요. 소설 주변의 전체 타임라인을 알 필요는 없지만, 소설 주변에서 일어난 일들을 대략적으로 파악하는 것이 도움이 될 수 있어요. 왜냐하면 그러한 사건들이 소설의 직접적인 타임라인에 어떻게 영향을 미치는지 알 수 있기 때문이에요. 소설의 기간에 대한 타임라인의 세부 수준은 나중에 논의할 주제로, 더 자세히 다루는 것이 좋을 것 같아요. 그렇다고 해도, 보통 더 자세한 내용이 필요한 편이에요.\n\n<div class=\"content-ad\"></div>\n\n타임 라인 작업에선 정말 멋진 Aeon Timeline을 사용해요. 이 앱은 잠재력의 한 부분만 사용하고 있다는 걸 알지만, 그 중 일부분을 활용하고 있어요. 주로 \"타임라인\" 보기에서 사용하고 있지만, 어디에서 누가 무엇을 하는지 확인할 수 있는 점이 마음에 들어요. Aeon Timeline은 엔티티(캐릭터, 장소, 장면 등)를 Scrivener와 동기화할 수도 있어요. 이는 제가 \"세계의 상태\" 개요 도구로 사용한 다음 더 발전시키는 데 활용할 수 있게 해줘요.\n\nMac 버전은 Setapp의 일부로 제공받고 있어요. Apple Pencil로 좀 더 캐주얼한 구성 및 계획을 위해 iPad 버전을 구입하고 싶지만, 효과적으로 저에게는 단일 플랫폼뿐인 가격을 아직 정당화하기 어려운 상황이에요. Setapp에서 삭제된다면 결정을 내릴 것 같아요.\n\n## 연구 및 추가 사항\n\n연구를 위한 제 설정은 아이디어를 기록하는 것처럼 여기저기 흩어져 있어요. 사용하는 각 방법과 그 이유에 대해 만족스러워하지만, 이들을 더 효율적으로 통합하는 방법을 끊임없이 찾고 있어요. 태그 등을 활용해 서로 다른 소스를 연결하려고 노력하지만, 아직 이 태그 중 어느 하나도 통합된 인터페이스를 통해 접근할 수 있는 방법이 없어요.\n\n<div class=\"content-ad\"></div>\n\n## Raindrop\n\n![Raindrop](/assets/img/2024-06-19-MyCreativeWritingSetup_2.png)\n\n기본적으로 크로스 플랫폼 및 크로스 브라우저 북마크 매니저입니다. Raindrop은 다양한 용도로 유용하게 사용할 수 있지만, 연구 관련 문맥에서는 웹 페이지를 조직화, 태그 지정 및 주석 달기가 가능합니다. 많은 연구가 온라인에서 시작되므로 연구를 관리하는 좋은 시작점이 될 수 있습니다.\n\n## MarginNote\n\n<div class=\"content-ad\"></div>\n\n\n![My Creative Writing Setup](/assets/img/2024-06-19-MyCreativeWritingSetup_3.png)\n\nI mentioned MarginNote before in my note-taking post, and it remains my main way of taking notes on PDFs and ePubs. It also lets you then collate notes from multiple documents into large mind maps for further exploration of connected ideas.\n\n## Apple Notes\n\nI mostly use Apple notes for gathering images and text ideas based on research. For examples, images acquired from The State Library of Victoria for my second novel. The in-built image annotation features of macOS also means I can scrawl ideas on those images. It’s still a bit of a miscellaneous dumping ground for research, but the integration with the rest of macOS means it’s easy to get content in and out.\n\n\n<div class=\"content-ad\"></div>\n\n## 스크리브너\n\n저는 Scrivener에 대한 논의를 글쓰기 섹션까지 저질러두려고 합니다. 하지만 이는 특히 캐릭터와 같은 텍스트와 직접적으로 관련된 연구 자료에 대한 훌륭한 저장소이기도 합니다. 그리고 Aeon Timeline 동기화 설정을 통해 동기화가 자동으로 폴더와 엔티티 파일을 만들어 제가 연구 자료를 추가하기 쉽게 만들어 줍니다.\n\n이 책이나 시퀄로 사용될 수 있는 노트 조각들의 흩어진 폴더가 있습니다. 텍스트에 언급된 사항에 대한 더 많은 맥락을 제공하는 아이디어와 개념이 섞여 있습니다. 이것은 나에게 개념들 사이의 일관성을 유지할 수 있도록 참조용으로 더 많은 정보를 제공합니다. Scrivener의 링크 기능을 사용하면 향후 참조로 텍스트 조각들을 해당 개념에 연결할 수 있으며, 컴파일할 때 모든 링크를 독자를 위해 제거할 수 있습니다.\n\nScrivener은 이 모든 자료에 대한 훌륭한 위치이지만 항상 찾기 쉬운 것은 아닙니다. 하지만 아마도 이게 제 잘못이거나 제 프로젝트 조직의 문제인 것일지도 모릅니다.\n\n<div class=\"content-ad\"></div>\n\n## 글쓰기\n\n창조적인 글쓰기를 위해, 저는 이제 Scrivener만 사용합니다 (당신이 이런 걸 기대하지 못했겠죠!). 잠깐 Ulysses를 사용했지만, 이제는 다른 쓰기 작업에만 사용합니다. 글쓰기에만 집중하고 싶을 때는 기능이 제한된 iPad 버전을 사용합니다.\n\n![이미지](/assets/img/2024-06-19-MyCreativeWritingSetup_4.png)\n\nScrivener는 매우 유연하고 주장이 없는 응용 프로그램 중 하나입니다. 여러분에게 공백 캔버스를 제시하고 원하는 대로 구성할 수 있게 해줍니다. 많은 초보자들에게는 이것이 직면해야 하는 문제일 수 있습니다. 아직 원하는 바를 모르기 때문이죠.\n\n<div class=\"content-ad\"></div>\n\nScrivener를 사용할 때 제 주요 조언은 꾸준히 사용하는 것입니다. Scrivener 안에 있는 모든 것은 폴더 안의 파일들의 연속입니다. 이 유연성은 프로젝트를 어떻게 설정하고 조직할지에 대한 생각을 바꾼다 해도 아무것도 잃지 않고 그냥 재조직할 수 있다는 것을 의미합니다.\n\n그것을 염두에 두고, 여기에 어떻게 기계를 구성하는지에 대한 아이디어를 드리겠습니다. 가장 간단한 것부터 가장 복잡한 것까지 순서로 시작합니다.\n\n## 단편 소설과 게임\n\n제가 쓴 가장 긴 단편 소설은 약 4,000 단어 정도인데, 각 단편 소설을 위해 별도의 프로젝트를 만드는 것은 너무 지루해 보였습니다. 그래서 모든 소설을 하나의 프로젝트로 결합했습니다. 아직 이 모든 단편 소설을 어디에 어떻게 발표할지를 고민 중이기 때문에 나중에는 컬렉션 기반 프로젝트로 소설들을 재조직할 수도 있습니다. \"매커스크립트\" 폴더(기본 이름)가 하나 있고 각각의 이야기가 파일로 되어 있습니다. 각 파일에 몇 가지 사용자 정의 메타데이터를 첨부하여 이야기의 진행 상황을 추적하고 수정에서 오디오 버전을 만들었는지 또는 이미 어디에 발표했는지 등을 파악합니다. 이 정보를 다른 곳(예: Trello)에서 추적하고 싶을지에 대해 확신이 없지만 아직 결정은 내리지 않았습니다. 현재는 사용자 정의 메타데이터와 목록 보기가 잘 작동하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n과거에 Scrivener가 플러그인 아키텍처를 가졌었던 걸 기억하시나요? 그래서 다른 곳으로 내보내는 것이 가능했던 거죠. 예를 들어, 짧은 이야기의 경우, Medium과 같은 곳으로 내보내는 것이 좋을 것 같아요.\n\n아직 Scrivener에서 게임 책을 쓰는 가장 좋은 방법을 완전히 알아내지는 못했어요. 그것들은 사실상 많은 연구가 필요한 책이기 때문에 가능해야 하지만, Scrivener가 어려워하는 부분이 사용하는 사용자 지정 서식일 수도 있어요.\n\n## 긴 이야기\n\n글을 쓰고 긴 형식의 콘텐츠를 조직하는 것이 Scrivener가 빛나는 곳이에요.\n\n<div class=\"content-ad\"></div>\n\n저는 저자 찰스 스트로스가 스크리브너 팟캐스트에서 한 말을 듣고 이것이 스크리브너의 진정한 유연성과 잠재력에 대해 눈을 뜨게 되었습니다. 그가 말한 내용을 그대로 전할 순 없겠지만, 그는 말했습니다:\n\n당시 제가 그것을 하고 있었지만, 그의 말로 인해 스크리브너가 당신이 원하는 순서대로 파일을 조직할 수 있는 방식이 실제 강점이라는 것을 깨닫게 되었습니다. 다른 많은 텍스트 편집기들은 하나의 긴 파일에 작성하도록 유도하는 경향이 있습니다. 이것은 위험할 수 있지만, 선형적으로 생각하게 만들기도 합니다. 그 당시에 저는 책의 중간부분에서 막혀 있었습니다. 그래서 키보드에 머리를 부딪히는 대신에, 저는 앞으로 나아가서 끝부분을 썼습니다. 이것이 제 블록을 해결해 주었으며, 어떻게 중간을 채워야 끝 부분에 도달할 수 있는지 이해하는 데 도움이 되었습니다.\n\n제 경우에는 제 책을 네 가지 섹션으로 구성하여 각각을 여러 장으로 이뤄진 챕터들로 나눴습니다. 아직 책을 어떻게 나눌지 완전히 확신하지는 못했지만, 스크리브너가 이후에 선택권을 줄 수 있도록 유연성을 제공해줍니다.\n\n나의 베타 독자들은 텍스트를 다양한 형식으로 요청합니다. 여러 형식으로 쉽게 내보내기는 가능하지만, 동시에 모든 메모, 링크, 주석을 보전할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n저는 쓰는 기능 중에서 선호하는 몇 가지를 소개했고, 사용 가능한 것들입니다. 더 유용한 것들이 많이 있을 거라는 것을 알고 있어요. Scrivener이 유용하긴 한데 조금은 닫힌 상자 같은 면이 있어서 확장성 옵션을 정말 원해요. 언어 검사기를 손쉽게 사용하거나 텍스트를 번역하거나 다른 매체에 출판하는 옵션이 없어서 번거로워요.\n\n## 계속해서 글쓰기\n\n그것이 전부입니다. 지금은요. 창작글 쓰기에 속도를 내고 있고 예전보다 많이 창작하고 있어요. 이것은 더 많은 도구 사용하고 프로세스를 개선해서 내생각을 더 많이 나누게 될 것이란 걸 의미해요. 그래서, 몇 달 동안 어떤 변화들을 시도하고 그 변화가 제게 어떤 영향을 미치는지 블로그를 구독해서 확인해주세요.\n\n<div class=\"content-ad\"></div>\n\n창작 작업을 할 때 어떤 도구를 사용하시나요? 그 도구들이 어떻게 도움이 되나요?","ogImage":{"url":"/assets/img/2024-06-19-MyCreativeWritingSetup_0.png"},"coverImage":"/assets/img/2024-06-19-MyCreativeWritingSetup_0.png","tag":["Tech"],"readingTime":7},{"title":"매번 놓치기 힘든 MacOS 개발자를 위한 소프트웨어","description":"","date":"2024-06-19 08:48","slug":"2024-06-19-SoftwareforMacOSDevelopersthatcannotMissAgain","content":"\n\n맥OS 개발을 위한 필수 소프트웨어 요약입니다. 이 도구들은 모두 무료이며 대부분 오픈 소스입니다. 여러분의 개발 경험을 향상시키기를 바랍니다.\n\n# 기본 사항\n\n## Git\n\nGit은 설명이 필요 없을 정도로 유명합니다. 터미널에서 간단히 git을 실행하면 대화 상자가 나타납니다. 설치를 클릭하십시오. 이렇게 하면 일반적으로 기본 Xcode 런타임 환경이 함께 설치됩니다. 다른 방법으로는 터미널에서 xcode-select --install을 실행하여 설치할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## ServBay\n\nServBay는 아맥에서 사용하기 가장 훌륭한 개발 환경일 거예요. 다양한 개발 환경을 쉽게 원클릭 설치할 수 있고, 이후의 업그레이드도 간편해요. 팀원들을 위해 의존성과 설정을 일관되게 유지해 줍니다.\n\n![이미지](/assets/img/2024-06-19-SoftwareforMacOSDevelopersthatcannotMissAgain_0.png)\n\n# 터미널 도구\n\n<div class=\"content-ad\"></div>\n\n## iTerm2 + Oh-My-Zsh\n\niTerm2는 Mac에서 최고의 터미널이며, Oh-My-Zsh는 강력한 테마 및 플러그인 기능을 제공합니다.\n\n![image](/assets/img/2024-06-19-SoftwareforMacOSDevelopersthatcannotMissAgain_1.png)\n\n## Terminus\n\n<div class=\"content-ad\"></div>\n\n저는 자주 사용하는 간단하고 크로스 플랫폼 셸 도구입니다. 이것을 사용하여 클라우드 서버에 연결합니다.\n\n![이미지](/assets/img/2024-06-19-SoftwareforMacOSDevelopersthatcannotMissAgain_2.png)\n\n# 디버깅 도구\n\n## Bruno\n\n<div class=\"content-ad\"></div>\n\nPostman이 유료로 전환되었기 때문에 대안으로 Bruno로 전환했어요. 이는 데이터 저장에 JSON을 사용하여 Git을 통한 버전 관리를 가능케 하며, 팀 협업 요구를 충족합니다. 게다가 API 도구 중 최고 수준의 UI를 제공해요.\n\n![image](/assets/img/2024-06-19-SoftwareforMacOSDevelopersthatcannotMissAgain_3.png)\n\n## SwitchHosts\n\n로컬 HTTPS 디버깅을 쉽게 만들어주는 여러 호스트 구성을 관리하고 전환할 수 있는 도구에요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-SoftwareforMacOSDevelopersthatcannotMissAgain_4.png\" />\n\n## AnotherRedisDesktopManager\n\n무료이지만 강력한 Redis GUI 도구입니다.\n\n## CotEditor\n\n<div class=\"content-ad\"></div>\n\n가볍지만 강력한 기능을 갖춘 텍스트 편집기입니다. 시스템 기본 텍스트 편집기를 대체하기에 적합합니다. 더 복잡한 텍스트 편집이 필요한 경우, VS Code를 사용해보세요.\n\n![이미지](/assets/img/2024-06-19-SoftwareforMacOSDevelopersthatcannotMissAgain_5.png)\n\n편리성을 위해 명령줄 도구를 설치하세요:\n\n```js\n# Cot 명령 설치\nsudo ln -s /Applications/CotEditor.app/Contents/SharedSupport/bin/cot /usr/local/bin/cot\n\n# cot 명령을 사용하여 xxx 오픈\ncot ~/.zshrc\n```\n\n<div class=\"content-ad\"></div>\n\n# 생산성 도구들\n\n## 히든 바\n\n숨겨진 작업 표시줄 아이콘을 사용자 정의하여 무료 및 오픈 소스로 이용하세요.\n\n![이미지](/assets/img/2024-06-19-SoftwareforMacOSDevelopersthatcannotMissAgain_6.png)\n\n<div class=\"content-ad\"></div>\n\n## Fork - 강력 추천합니다\n\n직관적인 선형 히스토리 뷰를 제공하는 강력한 Git GUI 소프트웨어로, 브랜치 관리를 쉽게 만들어줍니다. 머지/스쿼시/리베이스/수정과 같은 작업이 빠르고 부드럽게 이루어집니다.\n\n![이미지](/assets/img/2024-06-19-SoftwareforMacOSDevelopersthatcannotMissAgain_7.png)\n\n## Maccy\n\n<div class=\"content-ad\"></div>\n\n최근 복사한 내용을 쉽게 찾을 수 있도록 도와주는 필수 클립보드 도구입니다. 이미지와 검색을 모두 지원합니다!\n\n![Clipboard Tool](/assets/img/2024-06-19-SoftwareforMacOSDevelopersthatcannotMissAgain_8.png)","ogImage":{"url":"/assets/img/2024-06-19-SoftwareforMacOSDevelopersthatcannotMissAgain_0.png"},"coverImage":"/assets/img/2024-06-19-SoftwareforMacOSDevelopersthatcannotMissAgain_0.png","tag":["Tech"],"readingTime":3}],"page":"83","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}