{"pageProps":{"posts":[{"title":"탐사 분류기를 사용하여 연락 센터 LLMs의 학습 내용을 밝힐 수 있을까요 아니요, 불가능합니다","description":"","date":"2024-06-20 18:44","slug":"2024-06-20-CanprobingclassifiersrevealthelearningbyContactCenterLLMsNoitdoesnt","content":"\n\n이 블로그는 2024년 NAACL에서 수락된 기술 논문에 대한 참조입니다. 이 논문은 멕시코시티에서 개최된 5번째 맞춤형 결과로부터의 통찰력 워크샵(NLP@NAACL)에서 발표되었습니다.\n\n![이미지](/assets/img/2024-06-20-CanprobingclassifiersrevealthelearningbyContactCenterLLMsNoitdoesnt_0.png)\n\n## 소개\n\n고객 서비스의 빠른 세상에서, 연락 센터는 기술 지원부터 청구 문의까지 모든 분야의 고객 상호 작용의 최전선으로 기능합니다. 기술이 발전함에 따라 대규모 언어 모델(LLMs)이 연락 센터에 통합되면 고객 지원의 제공 방식을 혁신화할 수 있습니다. 다만, 이러한 모델의 효과는 연락 센터 상호 작용의 특정 세부 사항을 이해하고 처리할 수 있는 능력에 크게 의존합니다. 저희 논문인 \"프로빙 분류기가 연락 센터 대규모 언어 모델의 학습을 밝혀 줄까요?: 아니요, 그렇지 않습니다!\"에서는 연락 센터 도메인을 위해 특별히 선별된 LLMs의 학습을 프로빙 분류기가 밝혀낼 수 있는지 조사합니다.\n\n<div class=\"content-ad\"></div>\n\n## 동기\n\n본 연구의 동기는 접촉 센터를 포함한 다양한 영역에서 LLMs에 대한 의존도가 점점 증가하고 있다는 점에서 비롯됩니다. 접촉 센터는 고객 지원 및 서비스에 중요한 역할을 하며 기술적 문제부터 청구 관련 문제까지 다양한 쿼리를 처리합니다. 그러나 이러한 상호 작용의 즉흥적이고 소음이 많은 특성은 LLMs에게 중요한 도전 요소가 됩니다. 도메인별 데이터로 LLMs를 세밀하게 조정하면 성능을 향상시킬 수 있지만, 이 과정에서 이러한 모델이 실제로 무엇을 배우는지 이해하는 것이 중요합니다. 기존에는 탐사 분류기가 LLMs의 내부 표현을 해석하고 이해하는 데 사용되어 왔지만, 이들이 도메인별 학습의 세부 사항을 밝히는 데 얼마나 효과적인지는 여전히 불분명합니다. 본 연구는 접촉 센터 응용 프로그램을 위해 세밀하게 조정된 LLMs가 습득하는 핵심적인 특성을 평가함으로써 이 갭을 메우고자 합니다.\n\n## 도메인별 세밀한 조정의 중요성\n\nOpenAI 및 Google과 같은 대규모 언어 모델은 인간과 유사한 텍스트를 생성하는 놀라운 능력을 보여주고 있습니다. 이러한 모델의 성능을 재정 및 생명공학과 같은 특정 도메인에서 더욱 향상시키기 위해 이러한 모델은 종종 도메인별 데이터로 세밀하게 조정됩니다. 이 방법은 다양한 분야에서 성공적인 것으로 입증되었지만, 접촉 센터 도메인에는 소음이 많은 쿼리, 즉흥 대화 및 특정 용어와 같은 독특한 도전 요소가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 방법론\n\n본 연구에서는 30억부터 130억 개 파라미터까지 다양한 크기의 두 가지 인기 있는 LLM 아키텍처인 Flan-T5와 Llama에 중점을 두었습니다. 저희는 내선 작업에서의 효과를 측정하기 위해 연락센터 대화의 독점 데이터셋으로 이러한 모델들을 세밀하게 조정합니다. 또한 이 연락센터(CC) 도메인 특화 지시 LLM들이 기본 설정 버전과 비교했을 때 배운 근본적 특성을 평가합니다. 이를 위해 저희는 대화, 채널, 자동 음성 인식(ASR) 속성을 평가하는 점검 작업을 정의하여 무엇을 배우고 그것이 연락센터 도메인에서 실제 성능으로 어떻게 변환되는지 알아봅니다.\n\n## 주요 발견\n\n- 내선 작업에서의 성능 향상: CC-LLMs는 내선 작업에서 상당한 성능 향상을 보였습니다. 특히, OOB 모델과 비교하여 응답 수용성이 48% 이상 향상되었습니다. 이는 도메인 특화 세밀 조정이 연락센터에서 LLM의 실용성을 향상시키는 데 효과적임을 강조합니다.\n- 점검 분류기의 차이 미미: 내선 작업에서의 성능 향상에도 불구하고, 점검 분류기는 세세한 차이를 보이지 않았습니다. 이는 전통적인 점검 작업이 모델 내에서 발생하는 미묘한 학습을 효과적으로 포착하지 못할 수 있다는 것을 시사합니다.\n- 아키텍처와 크기의 중요성: 시험한 모델 중에서 T5 모델이 다양한 설정에서 일반적으로 Llama 모델보다 우수한 성능을 보였습니다. 흥미로운 점은 작은 CC-Flan-T5(110억) 모델이 종종 큰 CC-Llama(130억)보다 우수한 성능을 보인다는 것인데, 이는 모델 아키텍처가 모델 크기보다 더 중요할 수 있다는 것을 시사합니다.\n- 일반 언어 특성: 세밀 조정 이후, CC-Flan-T5와 CC-Llama 모델은 SentEval suite의 일반 언어 점검 작업에서 점수가 낮아졌으며, 일반 언어 특성에서 도메인 특화 능력으로의 초점 이동을 나타냅니다.\n\n<div class=\"content-ad\"></div>\n\n## 함의 및 향후 방향\n\n연구 결과는 LLMs가 학습한 근본적인 특성들을 신뢰할 수 있는 방식으로 드러낼 수 있는 것이라는 가정에 도전하고 있습니다. 세부적으로 조정된 모델들은 특정 작업에서 우수한 성과를 보이지만, 기존의 조사 메커니즘은 모델의 학습에서 변경된 기본적인 특성을 발견하는 데 충분하지 않아 보입니다.\n\n이는 우리가 어떻게 조사 작업을 설계하고 활용하는지 재검토할 필요가 있음을 시사합니다. 컨택 센터의 대화의 동적이고 맥락 의존적인 성격은 보다 정교하고 맥락을 인지하는 조사 전략이 필요할 수도 있습니다. 게다가, 연구는 언어 생성 중의 디코딩 전략이 중요한 역할을 하며 향후 연구의 중점이 되어야 함을 제안합니다.\n\n마무리로, 컨택 센터와 같은 특정 도메인에 LLMs를 세부 조정함으로써 실용적 작업에서 성능을 크게 향상시킬 수 있지만, 기존의 조사 분류기는 이러한 개선 사항을 밝히는 데 한계가 있습니다. 이 연구는 더 효과적인 조사 방법에 대한 연구를 위한 새로운 방향을 제시하며, 높은 성과를 내는 LLMs 개발 시 아키텍처와 세부 조정 전략을 모두 고려하는 중요성을 강조합니다.\n\n<div class=\"content-ad\"></div>\n\n세계 곳곳의 연락센터를 위해 대화 인텔리전스를 변화시키는 Observe.AI에서 더 많은 정보를 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-20-CanprobingclassifiersrevealthelearningbyContactCenterLLMsNoitdoesnt_0.png"},"coverImage":"/assets/img/2024-06-20-CanprobingclassifiersrevealthelearningbyContactCenterLLMsNoitdoesnt_0.png","tag":["Tech"],"readingTime":3},{"title":"다중 에이전트 시스템    LangGraph","description":"","date":"2024-06-20 18:42","slug":"2024-06-20-Multi-AgentSystemsLangGraph","content":"\n\n응, 맞아, Smiths가 여기 있어! 내 이전 게시물이 꽤 오래되었네. 처음 보는 사람이라면, 안녕. 이 게시물에서는 LangGraph에 대해 이야기하고, LangSmith에 대해서도 조금 언급하고 싶어. 최근에 우리는 에이전트 감독자를 구현하기 시작했어; 이것은 다중 에이전트 시스템을 구현하는 방법이야.\n\n그러나 너무 기술적으로 들어가기 전에, 잠시만 기다려 줄 수 있을까? 이것은 매트릭스의 Smith 에이전트야. 매트릭스에서 '질서'를 유지하기 위해 만들어진 코드 일부였다는 걸 기억해봐, 사람들을 시뮬레이션에 유지하는 시스템 내에서. (시스템이 붕괴해도, 네오에게 한 큰 박수). Smiths는 계층 구조였지; 다른 Smiths에게 일을 시키는 'the Smith'가 있었어. (그는 나중에 시뮬레이션 내에서 자신의 존재를 복제할 수 있었지. 사실, 많은 요청이 있는 시스템을 다루는 매우 멋진 방법이라고 할 수 있어, 아마 LangChain의 다음 움직임이 될지도 ;))\n\n![Smith Image](/assets/img/2024-06-20-Multi-AgentSystemsLangGraph_0.png)\n\n내 농담 세션 이후, LangGraph는 정말 멋진 라이브러리야; LangChain이 감당할 수 없는 경우에 매우 유용해. 복잡한 문제, 사용 사례 또는 흐름을 나누는 해결책을 제공해줘. 이전에 언급한 대로, 다중 에이전트 시스템에 대해 이야기할 테니, 주로 감독자 구현에 대해 이야기할 거야, 왜냐하면 이러한 에이전트를 결합하는 다양한 방법이 있거든. 그리고 우리가 챗봇을 구현하려고 노력하고 있기 때문에, 고객 지원 봇 튜토리얼에서 많은 도움을 받았어. 채팅에서 무엇을 할 수 있고, 에이전트를 제어하여 올바른 일을 수행하는 방법에 대해 매우 명확한 아이디어를 제공해줘.\n\n<div class=\"content-ad\"></div>\n\n# LangGraph 소개\n\nLangGraph는 LangChain 위에 구축되어 있으며 LangChain 생태계와 완전히 호환됩니다. 그것은 기본적으로 그래프 기반 상태 머신을 사용하여 복잡하고 확장 가능한 AI 에이전트를 구축하는 Python 라이브러리입니다. LangChain을 시도해 본 적이 있다면, 에이전트를 프로덕션 환경에서 실행하려고 할 때 그 부족함을 느낄 것입니다. 프로덕션에서는 종종 더 많은 제어가 필요합니다. 특정 도구를 항상 호출하도록 강제하고 싶을 수 있습니다. 도구를 호출하는 방법을 더 많이 제어하고 싶을 수 있습니다. 상태에 따라 에이전트에 대한 서로 다른 프롬프트를 사용하고 싶을 수 있습니다.\n\n그렇다면, 이 “상태 머신”이란 무엇일까요? 이를 통해 인간 상호작용을 순환하며 LLM(Lang Language Model)을 통해 작업을 수행할 수 있는 권한을 얻게 됩니다. 이는 어떤 에이전트가 실행되었는지, 어떤 도구를 사용했는지, 그리고 원한다면 메모리까지 추적합니다. 현재 메모리에 대해 자세히 알아볼 필요는 없지만, LangChain에서 본 것과는 조금 다릅니다. Checkpointer는 상태를 영속화하여 에이전트에게 \"메모리\"를 제공합니다.\n\n## StateGraph\n\n<div class=\"content-ad\"></div>\n\nStateGraph은 그래프를 나타내는 클래스입니다. 상태 정의를 전달하여이 클래스를 초기화합니다. 그래프 내의 노드가 상태를 업데이트하고, 이는 키-값 저장소 형식의 작업을 반환합니다.\n\n```js\nfrom langgraph.graph import StateGraph\nfrom typing import TypedDict, List, Annotated\nimport Operator\nfrom langchain_core.messages import BaseMessage\n\nclass State(TypedDict):\n    input: str\n    messages: Annotated[Sequence[BaseMessage], operator.add]\n\ngraph = StateGraph(State)\n```\n\n## 노드\n\nStateGraph를 만든 후 graph.add_node(name, value) 구문을 사용하여 노드를 추가합니다. value 매개변수는 호출 될 함수 또는 LCEL 실행 가능이어야 합니다. (즉 실행 가능한 도구 또는 LLM)\n\n<div class=\"content-ad\"></div>\n\n```js\ngraph.add_node(\"model\", model)\ngraph.add_node(\"tools\", tool_executor)\n```\n\n그래프를 순환할 것이기 때문에 프로세스 중 어딘가에서 종료하는 것이 중요합니다. 그래프의 끝을 나타내는 END 노드를 사용하세요.\n\n```js\nfrom langgraph.graph import END\n\ngraph.add_node(\"end\", END)\n```\n\n## 엣지\n\n<div class=\"content-ad\"></div>\n\n노드를 추가한 후에 그래프를 만들기 위해 엣지를 추가할 수 있습니다. 현재는 세 가지 유형의 엣지가 있습니다:\n\n1 - 시작 엣지: 이 엣지는 그래프의 시작점을 특정 노드에 연결하는 엣지입니다. 아래 코드는 우리의 그래프가 'model' 노드에서 시작한다는 것을 의미합니다.\n\n```js\ngraph.set_entry_point(\"model\")\n```\n\n2 - 일반 엣지: 이러한 엣지는 한 노드가 항상 다른 노드 뒤에 호출되도록합니다. 아래 코드는 'tools' 노드를 호출할 때 'model' 노드가 항상 그 뒤에 호출된다는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\ngraph.add_edge(\"tools\", \"model\")\n```\n\n3 - 조건부 엣지: 이는 LLM이 첫 번째로 이동할 노드를 결정하는 데 사용하는 엣지입니다. 엄격히 어디로 이동할지를 지정하지 않습니다. LLM은 상태와 사용자 입력을 확인하여 목적지를 결정합니다.\n\n조건부 엣지에는 세 가지 매개변수가 있습니다. 첫 번째 매개변수는 다음에 할 일을 결정할 노드입니다. 두 번째 매개변수는 다음으로 호출할 노드를 결정하는 함수입니다. 세 번째 매개변수는 함수(2)가 반환할 수 있는 가능한 값이어야 합니다. 그리고 값은 이동할 노드의 이름이어야 합니다.\n\n```js\ngraph.add_conditional_edge(\n    \"model\",\n    should_continue,\n    {\n        \"end\": END,\n        \"continue\": \"tools\"\n    }\n)\n```\n\n<div class=\"content-ad\"></div>\n\n## 컴파일\n\n우리가 그래프를 정의한 후, 그것을 실행 가능한 형태로 컴파일할 수 있습니다. 이 실행 가능한 형태는 LangChain 러너블과 똑같은 메소드를 가지고 있습니다 (.invoke, .stream, .astream_log 등).\n\n```js\napp = graph.compile()\n```\n\n# Multi-Agent Systems\n\n<div class=\"content-ad\"></div>\n\n단일 에이전트는 순차적으로 실행해야 할 너무 많은 도구가 있을 때 실패할 수 있습니다. 그래서 다중 에이전트 시스템에서는 문제를 분할하여 각 단계를 다른 에이전트로 정복하고 적절한 전문가에게 업무를 라우팅합니다.\n\n## 에이전트 감독\n\n에이전트 그룹을 만들 것입니다. 각 에이전트는 작업을 완료하는 데 필요한 특정 도구를 갖게 됩니다. 에이전트 감독은 작업을 위임하는 데 도움을 줄 것입니다.\n\n![에이전트 감독](/assets/img/2024-06-20-Multi-AgentSystemsLangGraph_1.png)\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 2명의 에이전트와 1명의 감독관이 있습니다. 첫 번째 에이전트는 무작위 숫자를 생성하고, 다른 에이전트는 해당 무작위 숫자에 대한 다이어그램을 그립니다. 기대한 대로, 감독관이 작업을 위임하며, 무작위 숫자 생성 에이전트가 작업을 마치면 다른 에이전트에게 바퀴를 넘깁니다.\n\n우리는 기초를 정의하며 시작합니다.\n\n```js\nfrom langchain_openai import ChatOpenAI\nfrom typing import Annotated, List, Tuple, Union\nfrom langchain.tools import BaseTool, StructuredTool, Tool\nfrom langchain_experimental.tools import PythonREPLTool\nfrom langchain_core.tools import tool\nimport random\n\n\n#Model\nllm = ChatOpenAI(model=\"gpt-3.5-turbo\")\n\n#Tools\n\n#다이어그램 그리기용\npython_repl_tool = PythonREPLTool()\n\n#무작위 숫자 생성용\n@tool(\"random_number\", return_direct=False)\ndef random_number(input:str) -> str:\n    \"\"\"0-100 사이의 무작위 숫자를 반환합니다. 'random'이라는 단어를 입력하세요.\"\"\"\n    return random.randint(0, 100)\n\ntools = [random_number,python_repl_tool]\n```\n\n도우미 함수로 계속하세요.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nfrom langchain.agents import AgentExecutor, create_openai_tools_agent\nfrom langchain_core.messages import BaseMessage, HumanMessage\nfrom langchain_openai import ChatOpenAI\n\n# 주어진 도구와 프롬프트로 AgentExecutor를 반환하는 함수\ndef create_agent(llm: ChatOpenAI, tools: list, system_prompt: str):\n    prompt = ChatPromptTemplate.from_messages(\n        [\n            (\n                \"system\",\n                system_prompt,\n            ),\n            MessagesPlaceholder(variable_name=\"messages\"),\n            MessagesPlaceholder(variable_name=\"agent_scratchpad\"),\n        ]\n    )\n    agent = create_openai_tools_agent(llm, tools, prompt)\n    executor = AgentExecutor(agent=agent, tools=tools)\n    return executor\n\n# 에이전트 노드, 그래프에서 에이전트를 호출하는 데 사용할 함수\ndef agent_node(state, agent, name):\n    result = agent.invoke(state)\n    return {\"messages\": [HumanMessage(content=result[\"output\"], name=name)]}\n```\n\n이제 그래프를 만들어 이 2개의 에이전트를 노드로 추가하겠습니다 :\n\n```js\nimport operator\nfrom typing import Annotated, Any, Dict, List, Optional, Sequence, TypedDict\nimport functools\nfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder\nfrom langgraph.graph import StateGraph, END\n\n# 난수 생성기를 노드로 설정\nrandom_agent = create_agent(llm, [random_number], \"You get random numbers\")\nrandom_node = functools.partial(agent_node, agent=random_agent, name=\"Random_Number_Generator\")\n\n# 코더를 노드로 설정\ncode_agent = create_agent(llm, [python_repl_tool], \"You generate charts using matplotlib.\")\ncode_node = functools.partial(agent_node, agent=code_agent, name=\"Coder\")\n```\n\n이제 슈퍼바이저를 생성해 봅시다!\n\n\n\n<div class=\"content-ad\"></div>\n\n```js\nfrom langchain.output_parsers.openai_functions import JsonOutputFunctionsParser\nfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder\n\nmembers = [\"Random_Number_Generator\", \"Coder\"]\nsystem_prompt = (\n    \"안녕하세요! 대화를 관리하는 감독관으로 지정되었습니다. {members}와(과) 같은 작업자들 간의 대화 관리를 맡았습니다. 아래 사용자 요청이 제시된 경우, 다음에 행동할 작업자를 응답하세요. 각 작업자는 작업을 수행하고 결과 및 상태에 회신합니다. 작업이 완료되면 FINISH로 회신해주세요.\"\n)\n# 다음 작업자 노드를 선택하거나 처리를 종료하기 위해 함수 호출을 사용합니다.\noptions = [\"FINISH\"] + members\n# openai 함수 호출\nfunction_def = {\n    \"name\": \"route\",\n    \"description\": \"다음 역할을 선택합니다.\",\n    \"parameters\": {\n        \"title\": \"routeSchema\",\n        \"type\": \"object\",\n        \"properties\": {\n            \"next\": {\n                \"title\": \"Next\",\n                \"anyOf\": [\n                    {\"enum\": options},\n                ],\n            }\n        },\n        \"required\": [\"next\"],\n    },\n}\nprompt = ChatPromptTemplate.from_messages(\n    [\n        (\"system\", system_prompt),\n        MessagesPlaceholder(variable_name=\"messages\"),\n        (\n            \"system\",\n            \"위 대화를 참고하여, 다음에 누가 행동해야 할까요? 아니면 FINISH로 종료해야 할까요? 다음 중 하나를 선택해주세요: {options}\",\n        ),\n    ]\n).partial(options=str(options), members=\", \".join(members))\n\n\n# 라우팅 함수 및 시스템 프롬프트와 결합된 LLM으로 체인 생성\nsupervisor_chain = (\n    prompt\n    | llm.bind_functions(functions=[function_def], function_call=\"route\")\n    | JsonOutputFunctionsParser()\n)\n```\n\n그래프를 생성해봅시다! (코멘트를 참고해주세요)\n\n먼저 상태를 정의하고 에이전트 노드와 감독관 노드를 추가합니다.\n\n```js\n# 메시지를 보유하고 어디로 이동할지를 나타내는 AgentState 정의\nclass AgentState(TypedDict):\n    messages: Annotated[Sequence[BaseMessage], operator.add]\n    # 'next' 필드는 다음으로 라우팅할 위치를 나타냅니다\n    next: str\n\n# 상태 그래프(StateGraph) 정의\nworkflow = StateGraph(AgentState)\n\n# 에이전트를 노드로 추가, 감독관 체인을 노드로 추가\nworkflow.add_node(\"Random_Number_Generator\", random_node)\nworkflow.add_node(\"Coder\", code_node)\nworkflow.add_node(\"Supervisor\", supervisor_chain)\n\n# 에이전트가 작업을 완료하면 다음은 항상 감독관이어야 합니다\nworkflow.add_edge(\"Random_Number_Generator\", \"supervisor\") \nworkflow.add_edge(\"Coder\", \"supervisor\")\n\n# 감독관이 그래프 상태의 \"next\" 필드를 결정하여 노드 또는 종료로 라우팅합니다. (위의 END 특수 노드를 기억하세요)\nworkflow.add_conditional_edges(\n    \"supervisor\", \n    lambda x: x[\"next\"], \n    {\n        \"Random_Number_Generator\": \"Random_Number_Generator\",\n        \"Coder\": \"Coder\",\n        \"FINISH\": END \n    })\n\n# 시작점은 항상 감독관이어야 합니다\nworkflow.set_entry_point(\"supervisor\")\n\ngraph = workflow.compile()\n```\n\n<div class=\"content-ad\"></div>\n\n한 번 해 보세요, 그래프를 스트리밍하거나 직접 실행할 수 있습니다.\n\n```js\nfor s in graph.stream(\n    {\n        \"messages\": [\n            HumanMessage(content=\"10개의 무작위 숫자를 가져와 히스토그램을 생성합니다.\")\n        ]\n    }, config={\"recursion_limit\": 20}\n):\n    if \"__end__\" not in s:\n        print(s)\n        print(\"----\")\n```\n\n<img src=\"/assets/img/2024-06-20-Multi-AgentSystemsLangGraph_2.png\" />\n\n출력에서 보듯이, 우리는 선언된 Supervisor로 시작합니다. Supervisor는 우리를 Random_Number_Generator로 경로 설정합니다. Random_Number_Generator가 작업을 완료한 후에는 엣지를 추가했기 때문에 Supervisor로 돌아갑니다. 그런 다음 Supervisor는 Coder로 경로를 설정하며 Coder가 완료되어 Supervisor로 돌아옵니다. 작업이 완료되면 Supervisor가 처리를 완료합니다.\n\n<div class=\"content-ad\"></div>\n\n🥳\n\n# LangSmith\n\nLangSmith은 LLM 애플리케이션 개발, 모니터링 및 테스트를 위한 플랫폼입니다. 저는 주로 모니터링에 사용하고 있어서 해당 측면만 언급할 예정이에요. LangSmith 추적을 활성화하면 LLM을 디버깅할 수 있어요.\n\n문서를 보려면 여기를 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n위에서 실행한 예제는 아래와 같이 보입니다:\n\n![image1](/assets/img/2024-06-20-Multi-AgentSystemsLangGraph_3.png)\n\n더 자세한 정보를 원하신다면:\n\n![image2](/assets/img/2024-06-20-Multi-AgentSystemsLangGraph_4.png)\n\n<div class=\"content-ad\"></div>\n\n많은 도구를 가진 에이전트를 사용할 때 매우 유용합니다. 우리 경우에는 하나의 도구만 가지고 있었지만, 문제가 더 복잡해지고 내부에서 무슨 일이 일어나고 있는지 이해하고 싶을 때, LangSmith가 당신이 그 과정을 따라가는 데 정말 도움이 될 것입니다. 디버그 콘솔로도 할 수 있지만, 왜 이 도구가 있는데 불편하게 해야 하나요?\n\n환경 변수를 추가하여 추적 기능을 활성화할 수 있습니다:\n\n```js\nos.environ[\"LANGCHAIN_TRACING_V2\"] = \"true\"\n```\n\n추가 링크:\n\n<div class=\"content-ad\"></div>\n\n- [https://blog.langchain.dev/langgraph/](https://blog.langchain.dev/langgraph/)\n- [https://langchain-ai.github.io/langgraph/](https://langchain-ai.github.io/langgraph/)\n\n즐겁게 즐겼다면 좋겠어요! 다음에 또 만나요 :)","ogImage":{"url":"/assets/img/2024-06-20-Multi-AgentSystemsLangGraph_0.png"},"coverImage":"/assets/img/2024-06-20-Multi-AgentSystemsLangGraph_0.png","tag":["Tech"],"readingTime":11},{"title":"GPT-4 - 우리는 속고 있는 걸까요","description":"","date":"2024-06-20 18:41","slug":"2024-06-20-GPT-4oAreWebeingLIEDto","content":"\n\n오늘날 열풍을 일으키는 인공지능(AI) 기술이 얼마나 빠르게 발전하고 있는지에 대해 Open AI 및 기타 기업들로부터 거짓 정보를 받고 있는 걸까요?\n\n![image](/assets/img/2024-06-20-GPT-4oAreWebeingLIEDto_0.png)\n\n또는 이것이 또 다른 \"NFT 순간\"인지, 즉 과대포장 이후 큰 폭락이 일어날 것인지 궁금할 수도 있겠네요.\n\n그런데 제 생각에 이번에는 그렇게 되지 않을 것 같아요. 저는 NFT 열풍 주기에는 믿음을 안 했지만, 인스턴스적으로는 인공지능 열풍에는 믿음이 많이 드네요.\n\n<div class=\"content-ad\"></div>\n\n제가 매일 인공지능(AI)의 최신 정보를 읽어요.\n\n만약 당신이 유료 Medium 회원이 아니라면, 여기서 무료로 읽을 수 있어요.\n\n저는 우리가 인공 일반 지능(AGI)에 빠르게 다가가고 있다고 생각하는 것과 LLM(Large Language Model)의 능력 면에서 플랫폼에 다다르고 있는 것 중 어디에 더 가까운지 계속 변해요.\n\n양쪽에 대한 좋은 주장들이 있어요.\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 AI가 지나치게 과대포장되고 있는 가능성을 살펴보고 싶습니다.\n\n내 AI 뉴스레터에 관심이 있을지도 몰라요 👉\n\n매일 GPT-4o를 사용하고 있어요.\n\n내 동생이자 비즈니스 파트너 인 Addison Best와 저는 GPT-4o의 역량이 감소하고 있다는 점에 주목하고 있어요. 네, 이것은 주관적인 견해이지만 감소가 상당히 명백해요.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 내가 GPT-4o에게 기사의 특정 부분에 제 제휴 링크를 넣도록 요청하면, 이런 간단한 작업에 엉망징창으로 처리할 수도 있어요.\n\n(이전에는 더 잘 작동했는데, 어떻게든 모델의 능력이 시간이 지남에 따라 변화하는 것 같아요)\n\nGPT-4o는 정말 빠르긴 하지만, 제가 무엇을 요청했는지에 대한 정확성과 이해력은 심지어 GPT-4보다 나빠 보이네요.\n\n그들이 얼마나 빠르고 능숙한지 알려줄 수 있다면, 아마 우리는 '빠른' 부분에 만족하고 '능숙한' 부분은 신경도 쓰지 않을 지 모를 거에요. (또는 '능숙한' 부분으로 인해 플러스 멤버십을 해지할 정도로 신경 쓰지도 않을 거에요.)\n\n<div class=\"content-ad\"></div>\n\n# 왜 내가 AI가 과대포장되었다고 생각하는지\n\n- 기업들은 더 많은 관심과 자금을 얻기 위해 AI에 대해 거짓말을 하고 과장하는 경제적 인센티브가 엄청나다.\n- 회사들은 실제로 AI 데모 중에 주장을 과장했다가 발각된 적이 있습니다 (Google, OpenAI, Amazon 등).\n- 모델은 점점 느려지는 것 같습니다 (개인적 경험).\n- 모델 파라미터의 수가 기하급수적으로 늘어남에도 성능은 그렇지 않습니다. (더 세게 짜도 한 송이 레몬에서 무한한 주스를 짤 수는 없습니다)\n- 어떤 사람들은 OpenAI가 음성을 더 인간적으로(예를 들어 애교있게 껄껄대면서) 만들어 \"가짜\" 지능을 만들고 있다고 주장합니다. — 이는 내가 생각하지 못한 흥미로운 포인트입니다.\n\n내가 개인적으로 믿는 바는 최고의 AI가 우리에게 주어진 것보다 훨씬 강력하다는 것입니다. 문제는 최고의 모델이 월 20달러에 제공하기에 충분히 에너지 효율적이지 않다는 것입니다.\n\n그래서 그들은 모델의 능력을 계속해서 억제하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n의견을 궁금해요.\n\n- 웹사이트 방문 - AI Growth Guys\n- 👉 AI 뉴스레터 👈 구독\n- 이메일 마케팅에 Beehiiv를 추천하는 이유 확인\n- AI Growth Guys YouTube 채널 확인\n- AI 전문가 Andrew Best의 소개 읽기\n\n# 쉽게 설명하면 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n<div class=\"content-ad\"></div>\n\n- 작가를 박수 치고 팔로우하기 잊지 마세요! 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: CoFeed | Differ\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-20-GPT-4oAreWebeingLIEDto_0.png"},"coverImage":"/assets/img/2024-06-20-GPT-4oAreWebeingLIEDto_0.png","tag":["Tech"],"readingTime":3},{"title":"AI 이해력을 높이는 방법","description":"","date":"2024-06-20 18:39","slug":"2024-06-20-HowtoJumpstartYourAILiteracy","content":"\n\nAI 열풍이 시작된 지 벌써 1년이 넘었어요. AI는 글쓰기, 예술, 기술, 소셜 미디어 그리고 업무에 영향을 미쳤어요. 이제 거의 모든 회사, 정부, 그리고 기관이 AI 열풍에 참여하고 있습니다. 인공 지능은 여기에 남아 있고, 버블이던 아니던 사회에 지속적인 영향을 미칠 거예요.\n\n하지만 당신은 어떤가요?\n\n내가 추측해 보면, 당신은 아래 중 하나에 해당할 것입니다:\n\n- AI에 정통하고 호기심이 많아서 더 알고 싶어 하는 분\n- AI를 꺼리며 그 열풍에 동참하지 않는 분\n- 이 모든 AI에 대해 뒤처지고 시작해볼 방법을 모르는 분\n\n<div class=\"content-ad\"></div>\n\n당신의 위치와 관계없이 AI 지식을 늘리는 것이 중요합니다. 앞으로 AI는 우리가 일하는 방식을 항상 보완할 것입니다. 만약 당신이 화이트 칼라 직업을 가졌는데 인공지능 모델과 상호 작용하는 방법을 이해하지 못한다면 뒤처질 것입니다.\n\n충분한 공포를 조장하는 건 그만두고요... 저는 AI 지식 베이스를 확장하여 미래로 나아갈 방법과 새로운 사용 사례에 적용하기 위해 어떻게 준비할 수 있는지 말하려고 합니다.\n\n# AI 직감력을 개발하기\n\nAI에 능숙해지려면 다양한 용도에서 AI 모델의 응용 가능성을 인식하는 자연스러운 능력을 개발하는 것이 중요합니다. 좋은 소식은 모든 AI의 각 면을 이해할 필요는 없다는 것입니다. 이것을 발전시키는 것은 쉬운 일이라고 주장합니다. 오직 이러한 핵심 단계를 따르기만 한다면요:\n\n<div class=\"content-ad\"></div>\n\n## 매일 생활 속에서 AI 적용하기\n\n그냥 사용하세요. 많이요.\n\n![AI 이미지](/assets/img/2024-06-20-HowtoJumpstartYourAILiteracy_0.png)\n\nChatGPT와 대화를 나누어 문제를 해결해보세요. 집안에서 생산성을 높이는 데 활용하거나, 새로운 취미를 찾고, 예술을 향상시키거나, 요리할 새로운 아이디어를 고민해보세요. 어이 없는 일을 시키도록 해보세요. 다양한 아이디어와 컨셉을 실험해보세요. AI처럼 복잡한 것을 이해하는 가장 좋은 방법은 시행착오를 통해 시작하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n제가 ChatGPT를 제 개인 상담대로 사용하여 대부분의 아이디어와 프로세스를 떠올리고 발전시키는 습관을 들였어요. 이미 시작하지 않은 경우, 이는 AI 흐름에 쉽게 진입하는 방법입니다. 그리고 가능한 빨리 GPT Pro를 구입해야 합니다. 최첨단 모델과 상호 작용하는 것은 가치가 있어요.\n\n매일 AI를 사용하는 데 어려움을 겪고 있다면, 창의적인 아이디어를 떠올릴 수 있는 ChatGPT의 과소평가된 사용 사례에 대해 쓴 기사가 있어요.\n\n## AI 발전 상황을 따라가기\n\nAI의 최신 동향을 계속해서 따라갈 수 있는 신뢰할 수 있는 출처를 찾아보세요. 뉴스 매체, 온라인 포럼 또는 뉴스 집계기가 될 수 있어요. 현재 최첨단 기술의 상태를 이해하면(즉, 현재 현대 AI 시스템의 정의를 결정하고 있는 특성과 제한을 이해하게 됩니다), AI 발전에 대한 깊은 이해를 위한 기준으로 활용할 수 있게 될 거예요.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 대형 언어 모델 AI에 익숙하지 않은 사람은 Anthropic의 최신 모델 세트인 Claude 3에 대해 들어본 적이 없을 수도 있어요. 그런데 이 모델은 GPT-4를 꺾고 1년 만에 최고를 차지한 첫 번째 모델이에요. 더군다나 작은 \"하이쿠\" 모델도 가장 \"성능 대비 가격이 좋은\" LLM으로 엄청난 발전을 이루었어요. AI는 너무 빨리 발전하기 때문에 이러한 매우 중요한 발전들이 종종 주목받지 못할 수 있으니, 미래를 이해하기 위해서는 현재 상황을 알고 있어야 해요.\n\n다음은 저가 자주 방문하는 몇 가지 좋은 소스입니다:\n\n- MIT Technology Review\n- David Shapiro (Youtube)\n- Google News (지능적인 필터링 및 검색 기능 포함)\n- Reddit (토론 및 새로운 소식을 얻기 좋은 곳)\n\n## AI의 특수 응용 프로그램에 대해 알아보세요\n\n<div class=\"content-ad\"></div>\n\n이 단계는 당신의 연상 능력을 활성화하는 데 중요합니다. 회사들이 AI를 어떻게 독특한 용례에 활용하는지 연구하고 배우는 데 집중하면, 일부 패턴 인식과 연상 능력을 개발할 수 있습니다. 예를 들어, 공장을 운영한다고 가정해 봅시다. 어떤 회사들이 AI를 활용하여 제조 문제를 해결하는 방법을 살펴본다면, 당신이 직면한 일부 문제를 어떻게 해결할 수 있을지에 대한 아이디어를 얻을 수 있습니다.\n\n이는 여러분이 자체 AI 모델을 구축하는 방법을 알아내야 한다는 것을 의미하는 것은 아닙니다. 오히려, AI의 진보에 대한 심층적인 탐구를 위해 무엇을 찾아야 하는지 알 수 있으며 여러분의 업무 효율성을 높일 수 있습니다.\n\n## AI 사용 방법을 배우세요\n\n저는 ChatGPT를 어떻게 사용하지 말아야 하는지에 대한 전체 기사를 썼습니다. 사람들이 그것을 오용하는 모든 방법을 종합하는 것은 깨달음을 줬으며, 몇 달 동안 그 이후로도 더 많은 오용 사례를 보았습니다. 그들을 모두 통합하는 한 가지는 무엇일까요? 그들은 그 한계를 모르고 AI가 \"아무것도 제대로 못한다\"고 좌절해 하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이건 사실이 아니에요. 그냥 그것이 만들어진 목적과는 다른 작업에서 실패할 뿐이에요. 당신이 정비공에게 미적분 증명을 요청하지 않듯이, 당신의 망치가 당신을 직장으로 데려다 주기를 기대하지 않을 것입니다.\n\nChatGPT는 언어 작업에 아주 뛰어나기 때문에 그 강점을 알 필요가 없다는 점이에요; 오히려 그것이 할 수 없는 것에 대해 알아보는 데 집중해야 해요. 실은 저는 ChatGPT를 사용하는 중요한 원칙 몇 가지만 알고 있다면 빠르게 전문가로 성장할 수 있다고 확신합니다.\n\n## AI 모델 식별 방법 배우기\n\n여러 가지 유형의 AI가 있어요. 회사가 \"AI를 사용중이다\"라고 언급할 때, 그것이 어디에서, 어떻게, 왜 사용되는지를 구별하기가 점점 어려워지고 있어요. 다양한 종류의 AI 모델을 이해하면 그들의 사용 사례를 빠르게 식별하고 그것이 마케팅 발언인지 아니면 기술의 실제로 흥미로운 적용인지 알아낼 수 있어요. 이 지식은 또한 자신의 일이나 개인 생활에 AI를 어떻게 적용할 수 있는지를 알아내는 데 도움이 돼요.\n\n<div class=\"content-ad\"></div>\n\n- 예측 AI — 예측 AI는 대규모의 과거 데이터를 학습하여 대량의 복잡한 데이터셋에서 추세, 패턴 및 이상점을 찾습니다. 이들은 상품 가격, 시장 변동성 및 물류 분석과 같은 동적 요소의 움직임을 예측하는 데 유용합니다.\n- 분석 AI — 이들은 예측 모델과 유사하지만 입력을 분류하고 새로운 유용한 데이터로 조작하는 데 초점을 맞춥니다. 예를 들어, 분석 모델은 오디오를 분석하여 텍스트로 변환할 수 있습니다. 또 다른 사용 사례는 컴퓨터 비전으로, 입력 이미지나 비디오를 가져와 영상 내의 특정 요소를 분류할 수 있습니다. 예를 들어, 인간 얼굴을 인식하고 기록하는 보안 카메라 시스템과 같은 사례가 있습니다.\n- 생성 AI — 여기서 여러분이 들어본 큰 주제입니다. ChatGPT, Gemini, Claude, Midjourney, Runway, Sora 등 많은 예시들이 있는 생성 AI는 주로 간단한 사용자 입력에서 새로운 콘텐츠를 생성하는 데 초점을 맞춥니다. 이들은 작년에 인공지능에 대한 관심 폭증의 가장 큰 책임자이며, 그 이유는 비밀이 없습니다. 그들은 정말 멋지고 즉각적으로 유용합니다.\n\n이 주제에 대해 더 알고 싶다면, 인공지능/머신러닝이 높은 수준에서 무엇인지 이해하는 데 더 깊은 시작점을 제공하는 이 기사를 강력히 추천합니다.\n\n앞으로 몇 년 동안은 예측이나 분석 AI보다는 일상 생활에서 생성 AI와 상호 작용할 가능성이 더 높기 때문에, 이 기사의 주요 초점은 ChatGPT와 같은 생성 모델에 맞춰져 있습니다.\n\n## AI 작동 방식 이해하기\n\n<div class=\"content-ad\"></div>\n\n가장 마지막 단계로 이것을 배치했는데, 아마도 여기서 가장 밀집되고 열정적인 학습 곡선일 것입니다. 그러나 여전히 AI를 효과적으로 활용하는 데 필수적이라고 생각합니다. 특히 ChatGPT를 이해하는 데 좋은 두 가지 자료가 있습니다:\n\n- ChatGPT가 무엇을 하고 있으며 어떻게 작동하는가? 이 우수한 스티븐 월프람의 기사는 ChatGPT의 내부 작업에 대해 깊이 파고들어 설명합니다. 주의: 이 기사는 1시간 이상 소요되며 가벼운 소비자에게는 부적합할 수 있습니다. 그러나 ChatGPT를 이해하는 데 가장 좋은 입문 자료라고 생각합니다.\n- LLM Visualizer — 이 웹사이트는 LLM의 과정을 임베딩에서 출력까지 모든 단계마다 따라갈 수 있는 정말 멋진 기능이 있습니다. 이는 상당히 기술적이지만 매우 눈부신 경험입니다. 이 기능을 사용하기 전에 먼저 스티펜 월프람의 기사를 읽어보세요!\n\n이러한 모델들은 정보를 연결하여 입력과 일치하는 \"새로운\" 정보를 생성하려고 합니다. 사용자로서 여러분을 만족시키기 위해 가능한 최대한 신뢰할 만하고 관련성 있는 출력을 생성하려고 노력합니다. AI가 실제로 \"자신만의 마음\"을 가지지 않는다는 사실(적어도 현재로서)과 실제로 예측 가능하고 일관성있게 작동한다는 것을 깨달을 때 많은 이점을 얻게 될 것입니다:\n\n- 어떤 요청이 동작하고 어떤 것이 동작하지 않는지 직관적으로 파악할 수 있습니다. AI의 한계를 알고 있는 것이 강점을 알고 있는 것보다 훨씬 중요합니다.\n- 빠르고 쉽게 그것을 다룰 수 있습니다. AI와 함께 작업하기 어려울 수 있지만, 상자 속에 있는 도구들을 이해하면 원하는 결과물을 보다 빠르고 반복 횟수를 줄이며 달성할 수 있습니다.\n- 다른 사람들이 AI를 더 효과적으로 활용하는 방법을 가르칠 수 있습니다. 말해두지 않아도, AI의 기초를 더 많이 알 것이므로 그 정보를 다른 사람들과 공유하기가 더 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\nAI 지식에 확신이 없거나 따라잡기 힘들다고 느끼시는 분들께 이 자료가 유용하길 바랍니다. AI는 방대하고 복잡한 주제지만, 작은 조각으로 쪼개면 어려울 게 없어요.\n\n읽어 주셔서 감사합니다! 즐거운 코딩하세요!\n\n- Jordan","ogImage":{"url":"/assets/img/2024-06-20-HowtoJumpstartYourAILiteracy_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoJumpstartYourAILiteracy_0.png","tag":["Tech"],"readingTime":6},{"title":"AI Agents in a GPT","description":"","date":"2024-06-20 18:38","slug":"2024-06-20-AIAgentsinaGPT","content":"\n\n## GPT에 AI 에이전트를 내장하는 방법\n\n이것은 GPT-5에 에이전트가 곧 출시될 수도 있다는 힌트일까요?\n\n![이미지](/assets/img/2024-06-20-AIAgentsinaGPT_0.png)\n\n오늘은 여러분에게 멋진 것을 보여드릴 거예요 — 직접 AI 에이전트를 만들고 GPT에서 사용하는 방법을 알려 드릴 거예요.\n\n<div class=\"content-ad\"></div>\n\n이 예시는 간단하지만, AI 에이전트의 힘을 보여줍니다.\n\n아마도 AI 에이전트에 대해 들어본 적이 있을 것입니다. 그리고 그들이 미래라는 것도 들었을 겁니다.\n\n아마도 이미 GitHub에서 찾을 수 있는 몇 가지 기존 AI 에이전트 프레임워크를 시도해 보았을지도 모릅니다. 그러나 이들 중 많은 것들은 설정하기가 꽤 복잡하고 높은 코딩 지식이 필요합니다 — 이들은 일반인을 위한 것은 아니며, 많은 프로젝트에는 필요하지 않습니다.\n\n이 튜토리얼은 AI 에이전트를 간단한 용어로 설명하고, 코드 없이 시작하는 법을 알려줍니다.\n\n<div class=\"content-ad\"></div>\n\n이 안내서는 AI 에이전트 사용에 대한 소개입니다.\n\n코더이고 다른 AI 에이전트를 시도해본 적이 있다면 - 이것이 비교 가능하다고 말하고 싶지는 않습니다.\n\n하지만 GPT에서 AI 에이전트를 사용해 보려는 것은 GPT의 매우 흥미로운 사용 사례를 만들어줄 수 있습니다.\n\n여기 제가 만든 비디오가 있어요. AI 에이전트를 GPT에서 직접 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# AI 에이전트와 ChatGPT의 차이점은 무엇인가요?\n\nAI 에이전트는 특정 작업을 자체적으로 수행할 수 있습니다. 당신이 필요한 것을 이해하고, 결정을 내릴 수 있으며, 당신을 돕기 위해 행동할 수 있습니다.\n\nAI 에이전트는 또한 각각이 특정 역할을 가지고 팀으로 작동할 수 있으며, 심지어 인간의 개입 없이 공통의 목표를 달성하기 위해 협력할 수 있습니다.\n\nChatGPT는 대화를 나누는 것과 비슷합니다. 당신이 계속해서 질문하면, LLM을 사용하여 답변하고 질문에 답변하는 데 도움을 줍니다.\n\n<div class=\"content-ad\"></div>\n\n질문하거나 무언가를 시키면 그에 따라 답변합니다. 질문하거나 요청하면 텍스트를 생성하는 데 탁월한데요, AI 에이전트처럼 자동으로 작업을 수행하지는 않습니다.\n\nAI 에이전트는 여러 단계의 작업을 자체적으로 수행하는 반면, ChatGPT는 대화를 시작하고 무엇을 해야 할지 말해줘야 합니다. 모든 단계에 참여해야 합니다.\n\n간단한 예시로 차이를 살펴보는 것이 매우 도움이 됩니다.\n\n저의 👉 AI 뉴스레터 👈에 관심이 있을 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n# ChatGPT를 사용하여 여러 단계에서 기사 작성하기\n\n예를 들어, 작가라면, ChatGPT를 사용하여 기사를 여러 단계로 만들 수 있습니다. 다음은 ChatGPT에서 기사를 만드는 단계별 작업 및 상호 작용 방법입니다:\n\n- 기사 제목 생성: ChatGPT에게 현재 AI 연구를 기반으로 하는 다섯 가지 기사 제목을 요청하십시오.\n- 개요 작성: 그 다음, 기사 개요를 요청합니다.\n- 기사 초안 작성: 그런 다음, 기사 초안을 작성하도록 합니다.\n- 기사 편집: 마지막으로, 편집자에게 기사를 개선하고 제안을 받도록 요청합니다.\n- 최종 초고: 편집자의 제안을 기반으로 새로운 기사를 작성하도록 ChatGPT에게 요청합니다.\n\nChatGPT는 이러한 작업을 수행할 수 있지만, 각 단계를 수동으로 요청해야 합니다. 이 프로세스는 오랜 시간이 걸리고 지루할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위의 예시에서는 ChatGPT에게 5개의 별도 질문을 하고 매번 대답을 기다려야 합니다.\n\n# AI 에이전트를 사용하여 동일한 기사 생성\n\n저는 AI 에이전트를 활용한 간단한 GPT를 만들었습니다. 이를 사용하여 위의 예시와 동일한 방식으로 동일한 기사를 생성합니다.\n\n하지만 에이전트끼리 대화하면서 전체 기사와 아웃라인, 초안, 편집 등을 하나의 프롬프트만으로 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nGPT를 사용한 AI 에이전트를 만들었어요. 이 GPT는 다음을 할 거예요:\n\n- 다섯 개의 기사 주제에 대한 연구\n- 기사 개요 작성\n- 기사 초고 작성\n- 기사 편집, 개선 제안 및 완성까지 정제\n\n# 에이전트 역할\n\n이 에이전트 프레임워크를 포함한 모든 AI 에이전트의 첫 번째 단계는 각 에이전트의 역할을 정의하고 원하는 능력을 결정하는 것이에요.\n\n<div class=\"content-ad\"></div>\n\n# GPT 지침서의 에이전트 역할 정의\n\n- 연구자 에이전트: 다섯 개의 기사 주제를 생성합니다.\n- 개요 작성자 에이전트: 주제를 선택하고 개요를 작성합니다.\n- 작가 에이전트: 개요를 기반으로 기사를 초안 작성합니다.\n- 편집자 에이전트: 초안을 검토하고 개선 제안을 하여 작가에게 개정을 요청합니다.\n\nGPT에서 에이전트 역할 외에, 다음을 말했습니다:\n\nGPT에서 에이전트를 시작하려면 \"주제\"에 대한 단 한 가지 프롬프트만 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n그럼 요원들이 소통하여 제가 더 이상 개입하지 않고 기사를 완성할 거예요.\n\nAI 에이전트 GPT가 작동하는 것을 보고 싶다면, 이 기사 맨 위의 동영상을 확인해보세요.\n\n# AI 에이전트의 장점\n\nAI 에이전트는 작업을 독립적이고 효율적으로 처리하여 시간을 절약해줍니다. 특히 기사 작성 및 소프트웨어 개발과 같은 여러 단계를 포함하는 작업에 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n에이전트마다 특정 역할을 정의하여 원활하게 함께 작업할 수 있습니다.\n\n더 발전된 에이전트 역할을 만들 수도 있고, API에 액세스하거나 다른 LLM 모델에 접근하거나 코드를 설치하고 실행할 수 있게 할 수도 있습니다.\n\nGPT 안의 AI 에이전트는 GPT 환경 내에서 실행되기 때문에 제한됩니다. 이는 로컬호스트나 서버와 같지 않습니다.\n\n하지만 흥미로운 사용 사례를 만들기 위해 해킹되어 일부 사용 사례를 만들어낼 수는 있습니다.\n\n<div class=\"content-ad\"></div>\n\n저는 ChatGPT, 인공지능, GPT 등을 활용하여 온라인 비즈니스를 키우는 방법에 대해 가르치고 있어요.\n\n제 👉 AI Growth Guys Newsletter 👈를 확인해보세요.\n\n아래의 다른 채널들도 확인해보세요.\n\n저희 YouTube 채널도 놀러오세요.\n\n<div class=\"content-ad\"></div>\n\n우리 웹 사이트에서 팔로우해 주세요: AI Growth Guys","ogImage":{"url":"/assets/img/2024-06-20-AIAgentsinaGPT_0.png"},"coverImage":"/assets/img/2024-06-20-AIAgentsinaGPT_0.png","tag":["Tech"],"readingTime":4},{"title":"지식 그래프로 RAG 어플리케이션의 정확성 향상하기","description":"","date":"2024-06-20 18:36","slug":"2024-06-20-EnhancingtheAccuracyofRAGApplicationsWithKnowledgeGraphs","content":"\n\n## 네오포스트 및 LangChain을 사용하여 RAG 애플리케이션에서 지식 그래프를 구축하고 정보를 검색하는 실용적 가이드\n\n![Enhancing the Accuracy of RAG Applications With Knowledge Graphs](/assets/img/2024-06-20-EnhancingtheAccuracyofRAGApplicationsWithKnowledgeGraphs_0.png)\n\n그래프 검색 보강 생성 (GraphRAG)은 전통적인 벡터 검색 검색 방법에 강력한 보충으로 인기를 얻고 있습니다. 이 접근 방식은 그래프 데이터베이스의 구조화된 성격을 활용하여 데이터를 노드와 관계로 구성함으로써 회수된 정보의 깊이와 맥락을 향상시킵니다.\n\n![Enhancing the Accuracy of RAG Applications With Knowledge Graphs](/assets/img/2024-06-20-EnhancingtheAccuracyofRAGApplicationsWithKnowledgeGraphs_1.png)\n\n<div class=\"content-ad\"></div>\n\n그래프는 다양하고 서로 연결된 정보를 체계적으로 표현하고 저장하는 데 탁월합니다. 복잡한 관계와 속성을 다양한 데이터 유형에 걸쳐 손쉽게 캡처할 수 있습니다. 반면에 벡터 데이터베이스는 고차원 벡터를 통해 비구조화된 데이터를 처리하는 데 강점을 가지고 있어서 구조화된 정보에 어려움을 겪을 수 있습니다. RAG 애플리케이션에서는 구조화된 그래프 데이터와 비구조화된 텍스트를 통한 벡터 검색을 결합하여 양쪽의 장점을 모두 활용할 수 있습니다. 이것이 이 블로그 포스트에서 증명할 내용입니다.\n\n## 지식 그래프가 훌륭하지만, 그것을 어떻게 만들까요?\n\n지식 그래프를 구축하는 것은 보통 가장 어려운 단계입니다. 이 작업에는 데이터 수집과 구조화가 필요하며, 해당 도메인과 그래프 모델링에 대한 심층적인 이해가 필요합니다.\n\n이 프로세스를 간소화하기 위해 우리는 LLM(Large Language Models)을 실험해오고 있습니다. 언어와 맥락에 대한 깊은 이해력을 갖춘 LLM은 지식 그래프 생성 프로세스의 중요한 부분을 자동화할 수 있습니다. 이 모델들은 텍스트 데이터를 분석하여 엔티티를 식별하고, 그들의 관계를 이해하며, 어떻게 그들을 최상의 그래프 구조로 표현할 지 제안할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 실험의 결과로 LangChain에 그래프 구성 모듈의 첫 번째 버전을 추가했습니다. 이 블로그 게시물에서 이를 시연할 예정입니다.\n\n해당 코드는 GitHub에서 확인할 수 있습니다.\n\n## Neo4j 환경 설정\n\nNeo4j 인스턴스를 설정해야 합니다. 이 블로그 게시물의 예제를 따라 진행하십시오. 가장 쉬운 방법은 Neo4j Aura에서 무료 인스턴스를 시작하는 것입니다. 이는 Neo4j 데이터베이스의 클라우드 인스턴스를 제공합니다. 다른 방법으로는 Neo4j 데스크톱 애플리케이션을 다운로드하고 로컬 데이터베이스 인스턴스를 생성하여 로컬 Neo4j 데이터베이스를 설정할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nos.environ[\"OPENAI_API_KEY\"] = \"sk-\"\nos.environ[\"NEO4J_URI\"] = \"bolt://localhost:7687\"\nos.environ[\"NEO4J_USERNAME\"] = \"neo4j\"\nos.environ[\"NEO4J_PASSWORD\"] = \"password\"\n\ngraph = Neo4jGraph()\n```\n\n또한, 이 블로그 게시물에서 OpenAI 모델을 사용할 예정이므로 OpenAI 키를 제공해야 합니다.\n\n# 데이터 수집\n\n이 데모에서는 엘리자베스 1세의 위키백과 페이지를 사용할 것입니다. LangChain 로더를 사용하여 위키백과 문서를 손쉽게 가져와 분할할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\r\n# 위키백과 항목 읽기\r\nraw_documents = WikipediaLoader(query=\"Elizabeth I\").load()\r\n# 청킹 전략 정의\r\ntext_splitter = TokenTextSplitter(chunk_size=512, chunk_overlap=24)\r\ndocuments = text_splitter.split_documents(raw_documents[:3)\r\n```\r\n\r\n이제 검색된 문서를 기반으로 그래프를 구성할 시간입니다. 이를 위해 그래프 데이터베이스에 지식 그래프를 구축하고 저장하는 데 큰 도움이 되는 LLMGraphTransformermodule을 구현했습니다.\r\n\r\n```js\r\nllm=ChatOpenAI(temperature=0, model_name=\"gpt-4-0125-preview\")\r\nllm_transformer = LLMGraphTransformer(llm=llm)\r\n\r\n# 그래프 데이터 추출\r\ngraph_documents = llm_transformer.convert_to_graph_documents(documents)\r\n# Neo4j에 저장\r\ngraph.add_graph_documents(\r\n  graph_documents, \r\n  baseEntityLabel=True, \r\n  include_source=True\r\n)\r\n```\r\n\r\n지식 그래프 생성 체인이 사용할 LLM을 정의할 수 있습니다. 현재 OpenAI 및 Mistral에서 함수 호출 모델만 지원하고 있지만, 향후 LLM 선택을 확장할 계획입니다. 이 예시에서는 최신 GPT-4을 사용합니다. 생성된 그래프의 품질은 사용하는 모델에 크게 의존하는 것을 주의해야 합니다. 이론적으로는 항상 능력 있는 모델을 사용하는 것이 좋습니다. LLM 그래프 트랜스포머는 그래프 문서를 반환하며, 이를 add_graph_documents 메서드를 통해 Neo4j로 가져올 수 있습니다. baseEntityLabel 매개변수는 각 노드에 추가적인 __Entity__ 라벨을 할당하여 색인화 및 쿼리 성능을 향상시킵니다. include_source 매개변수는 노드를 원본 문서에 연결하여 데이터 추적 및 문맥 이해를 용이하게 합니다.\r\n\n\n<div class=\"content-ad\"></div>\n\n네오4j 브라우저에서 생성된 그래프를 확인할 수 있습니다.\n\n![그래프](/assets/img/2024-06-20-EnhancingtheAccuracyofRAGApplicationsWithKnowledgeGraphs_2.png)\n\n이 이미지는 생성된 그래프의 일부분을 나타냅니다.\n\n# RAG를 위한 혼합 검색\n\n<div class=\"content-ad\"></div>\n\n그래프 생성 후, 우리는 RAG 애플리케이션을 위한 벡터 및 키워드 색인과 그래프 검색을 결합한 하이브리드 검색 접근 방식을 사용할 것입니다.\n\n![이미지](/assets/img/2024-06-20-EnhancingtheAccuracyofRAGApplicationsWithKnowledgeGraphs_3.png)\n\n이 다이어그램은 사용자가 질문을 제기하면 RAG 검색기로 이어지는 검색 프로세스를 보여줍니다. 이 검색기는 키워드 및 벡터 검색을 사용하여 구조화되지 않은 텍스트 데이터를 검색하고 이를 지식 그래프에서 수집한 정보와 결합합니다. Neo4j는 키워드 및 벡터 색인이 모두 있는 기능을 제공하기 때문에 단일 데이터베이스 시스템으로 세 가지 검색 옵션을 구현할 수 있습니다. 이러한 소스에서 수집된 데이터는 LLM(언어 모델)에 공급되어 최종 답변을 생성하고 전달합니다.\n\n## 구조화되지 않은 데이터 검색기\n\n<div class=\"content-ad\"></div>\n\n\"Neo4jVector.from_existing_graph\" 메서드를 사용하여 문서에 키워드 및 벡터 검색을 추가할 수 있어요. 이 방법은 \"Document\"로 레이블이 지정된 노드를 대상으로 하는 하이브리드 검색 접근 방식을 위해 키워드 및 벡터 검색 인덱스를 구성합니다. 또한, 누락된 경우 텍스트 임베딩 값을 계산합니다.\n\n```js\nvector_index = Neo4jVector.from_existing_graph(\n    OpenAIEmbeddings(),\n    search_type=\"hybrid\",\n    node_label=\"Document\",\n    text_node_properties=[\"text\"],\n    embedding_node_property=\"embedding\"\n)\n```\n\n그런 다음에 유사성 검색 방법을 사용하여 벡터 인덱스를 호출할 수 있어요.\n\n## Graph Retriever\"\n\n<div class=\"content-ad\"></div>\n\n한편, 그래프 검색을 구성하는 것은 좀 더 복잡하지만 더 많은 자유를 제공합니다. 이 예제에서는 전체 텍스트 색인을 사용하여 관련 노드를 식별하고 해당 직접 이웃들을 반환할 것입니다.\n\n![image](/assets/img/2024-06-20-EnhancingtheAccuracyofRAGApplicationsWithKnowledgeGraphs_4.png)\n\n그래프 검색기는 입력에서 관련 엔티티를 식별하여 시작합니다. 단순화를 위해, 우리는 LLM에 개인, 조직 및 위치를 식별하도록 지시합니다. 이를 달성하기 위해 새롭게 추가된 with_structured_output 방법을 사용한 LCEL을 사용할 것입니다.\n\n```js\n# 텍스트에서 엔터티 추출\nclass Entities(BaseModel):\n    \"\"\"엔터티에 대한 정보 식별.\"\"\"\n\n    names: List[str] = Field(\n        ...,\n        description=\"텍스트에 나타나는 모든 사람, 조직 또는 비즈니스 엔터티들\",\n    )\n\nprompt = ChatPromptTemplate.from_messages(\n    [\n        (\n            \"시스템\",\n            \"텍스트에서 조직 및 개인 엔터티를 추출 중입니다.\",\n        ),\n        (\n            \"사용자\",\n            \"다음 입력에서 정보를 추출하기 위해 주어진 형식을 사용하세요: {질문}\",\n        ),\n    ]\n)\n\nentity_chain = prompt | llm.with_structured_output(Entities)\n```\n\n<div class=\"content-ad\"></div>\n\n테스트해 봅시다:\n\n```js\nentity_chain.invoke({\"question\": \"Amelia Earhart가 어디에서 태어났나요?\"}).names\n# ['Amelia Earhart']\n```\n\n좋아요, 이제 질문에서 엔티티를 감지할 수 있게 되었으니, 전체 텍스트 인덱스를 사용하여 그들을 지식 그래프에 매핑해 봅시다. 먼저, 전체 텍스트 인덱스를 정의하고 약간의 철자 오류를 허용하는 전체 텍스트 쿼리를 생성하는 함수를 만들어야 합니다. 이 과정에 대해서는 자세히 다루지 않겠습니다.\n\n```js\ngraph.query(\n    \"CREATE FULLTEXT INDEX entity IF NOT EXISTS FOR (e:__Entity__) ON EACH [e.id]\")\n\ndef generate_full_text_query(input: str) -> str:\n    \"\"\"\n    주어진 입력 문자열에 대한 전체 텍스트 검색 쿼리를 생성합니다.\n\n    이 함수는 전체 텍스트 검색에 적합한 쿼리 문자열을 생성합니다.\n    입력 문자열을 단어로 분할하고 각 단어에 유사성 임계값(~2개의 변경된 문자)을 추가한 후, AND 연산자를 사용하여 결합합니다.\n    사용자 질문에서 엔티티를 데이터베이스 값에 매핑하는 데 유용하며, 일부 철자 오류를 허용합니다.\n    \"\"\"\n    full_text_query = \"\"\n    words = [el for el in remove_lucene_chars(input).split() if el]\n    for word in words[:-1]:\n        full_text_query += f\" {word}~2 AND\"\n    full_text_query += f\" {words[-1]}~2\"\n    return full_text_query.strip()\n```\n\n<div class=\"content-ad\"></div>\n\n이제 모든 것을 함께 적용해 봅시다.\n\n```js\n# Fulltext index query\ndef structured_retriever(question: str) -> str:\n    \"\"\"\n    질문에 언급된 엔터티의 인근 엔터티를 수집합니다.\n    \"\"\"\n    result = \"\"\n    entities = entity_chain.invoke({\"question\": question})\n    for entity in entities.names:\n        response = graph.query(\n            \"\"\"CALL db.index.fulltext.queryNodes('entity', $query, {limit:2})\n            YIELD node,score\n            CALL {\n              MATCH (node)-[r:!MENTIONS]->(neighbor)\n              RETURN node.id + ' - ' + type(r) + ' -> ' + neighbor.id AS output\n              UNION\n              MATCH (node)<-[r:!MENTIONS]-(neighbor)\n              RETURN neighbor.id + ' - ' + type(r) + ' -> ' +  node.id AS output\n            }\n            RETURN output LIMIT 50\n            \"\"\",\n            {\"query\": generate_full_text_query(entity)},\n        )\n        result += \"\\n\".join([el['output'] for el in response])\n    return result\n```\n\nstructured_retriever 함수는 사용자 질문에서 엔터티를 감지하여 시작합니다. 그런 다음 감지된 엔터티를 반복하고 해당 노드의 인근을 검색하기 위해 Cypher 템플릿을 사용합니다. 이제 테스트해 봅시다!\n\n```js\nprint(structured_retriever(\"Who is Elizabeth I?\"))\n# Elizabeth I - BORN_ON -> 7 September 1533\n# Elizabeth I - DIED_ON -> 24 March 1603\n# Elizabeth I - TITLE_HELD_FROM -> Queen Of England And Ireland\n# Elizabeth I - TITLE_HELD_UNTIL -> 17 November 1558\n# Elizabeth I - MEMBER_OF -> House Of Tudor\n# Elizabeth I - CHILD_OF -> Henry Viii\n# 그리고 더 많은 정보가 출력됩니다...\n```\n\n<div class=\"content-ad\"></div>\n\n## 최종 검색기\n\n처음에 언급했던대로, 우리는 비구조화 및 그래프 검색기를 결합하여 LLM에 전달할 최종 컨텍스트를 생성할 것입니다.\n\n```js\ndef retriever(question: str):\n    print(f\"검색 쿼리: {question}\")\n    structured_data = structured_retriever(question)\n    unstructured_data = [el.page_content for el in vector_index.similarity_search(question)]\n    final_data = f\"\"\"구조화된 데이터:\n{structured_data}\n비구조화된 데이터:\n{\"#문서 \". join(unstructured_data)}\n    \"\"\"\n    return final_data\n```\n\n우리는 Python을 다루고 있으므로, 간단하게 f-string을 사용하여 출력을 연결할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# RAG Chain 정의\n\nRAG의 검색 구성 요소를 성공적으로 구현했습니다. 이제, 통합된 하이브리드 검색기가 제공하는 컨텍스트를 활용하여 응답을 생성하는 프롬프트를 소개하여 RAG 체인의 구현을 완료합니다.\n\n```js\ntemplate = \"\"\"다음 컨텍스트만을 기반으로 질문에 답해보세요:\n{context}\n\n질문: {question}\n\"\"\"\nprompt = ChatPromptTemplate.from_template(template)\n\nchain = (\n    RunnableParallel(\n        {\n            \"context\": _search_query | retriever,\n            \"question\": RunnablePassthrough(),\n        }\n    )\n    | prompt\n    | llm\n    | StrOutputParser()\n)\n```\n\n마지막으로, 하이브리드 RAG 구현을 테스트해볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nchain.invoke({\"question\": \"엘리자베스 1세가 속한 집은 무엇인가요?\"})\n# 검색 쿼리: 엘리자베스 1세는 어떤 집에 속했나요?\n# '엘리자베스 1세는 Tudor 왕조에 속했습니다.'\n\n```\n\n또한 질의 재작성 기능을 적용하여 RAG 체인이 대화 형태에 적응하도록 했습니다. 후속 질문을 효율적으로 검색하기 위해 벡터 및 키워드 검색 방법을 사용하기 때문에 후속 질문을 재작성하여 검색 프로세스를 최적화해야 합니다.\n\n```js\nchain.invoke(\n    {\n        \"question\": \"언제 태어났나요?\",\n        \"chat_history\": [(\"엘리자베스 1세가 어떤 집에 속했나요?\", \"Tudor 왕조\")],\n    }\n)\n# 검색 쿼리: 엘리자베스 1세는 언제 태어났나요?\n# '엘리자베스 1세는 1533년 9월 7일에 태어났습니다.'\n\n```\n\n질문이 언제 태어났나요?가 처음에 언제 엘리자베스 1세가 태어났나요?로 재작성된 것을 관찰할 수 있습니다. 재작성된 쿼리가 관련 context를 검색하여 질문에 대답하는 데 사용되었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# RAG 애플리케이션을 쉽게 개선하기\n\nLLMGraphTransformer의 도입으로 지식 그래프를 생성하는 과정이 더 매끄럽고 접근하기 쉬워졌습니다. 지식 그래프가 제공하는 심층성과 맥락으로 여러분의 RAG 애플리케이션을 향상시키려는 누구에게나 이제 보다 쉬워졌습니다. 이것은 시작에 불과하며 앞으로 많은 개선 사항이 계획되어 있습니다.\n\nLLMs로 그래프를 생성하는 데 대한 통찰, 제안 또는 질문이 있으시다면 망설이지 말고 연락해 주세요.\n\n코드는 GitHub에서 확인할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-EnhancingtheAccuracyofRAGApplicationsWithKnowledgeGraphs_0.png"},"coverImage":"/assets/img/2024-06-20-EnhancingtheAccuracyofRAGApplicationsWithKnowledgeGraphs_0.png","tag":["Tech"],"readingTime":10},{"title":"컴퓨터 프로그래머이자 15년간 ChatGPT에 대해 전문적으로 썼어요 - 전문 작가들이 괜찮다는 법을 이야기해 드릴게요","description":"","date":"2024-06-20 18:32","slug":"2024-06-20-ImaComputerProgrammerandWroteProfessionallyaboutChatGPTfor15YearsHeresHowProWritersCanBeOkay","content":"\n\n![alt text](/assets/img/2024-06-20-ImaComputerProgrammerandWroteProfessionallyaboutChatGPTfor15YearsHeresHowProWritersCanBeOkay_0.png)\n\n2023년 1월에 ChatGPT가 공개 된 지 세 달 후에는 이미 기업들이 작가들을 불필요하다고 생각하고 있음을 알 수 있었습니다. 몇몇 클라이언트들이 사라졌는데, 그 중 아무도 ChatGPT를 사용 중이라고 말해 주지 않았습니다.\n\n또한 내가 작가로 일을 찾는 데 꾸준히 신뢰할 수 있는 방법 중 하나인 나의 차가운 아웃리치에 대한 직접적이고 모욕적인 댓글들도 있었어요. \"오, ChatGPT가 이제 그런 걸 할 수 있어.\"\n\n그 후로, 나는 내가 판매하는 프리랜싱 플랫폼에서 ChatGPT의 훌륭함에 대해 글을 쓰도록 제안을 받았습니다. 이 회사는 세계적으로 프리랜서 일을 타격할 것으로 예상되었던 \"AI-파멸\"에 대응하여 콘텐츠 전략을 강화하기로 결정했습니다.\n\n<div class=\"content-ad\"></div>\n\n그들의 전략 중 일부는 ChatGPT 및 다양한 GenAI 도구에 대해 수많은 기사를 쓰는 것이 포함되어 있었고, 이로 인해 이러한 주제에 대한 SEO 트래픽을 이용하여 방문자들을 자신들의 프리랜서 서비스로 유도했습니다.\n\n기술 작성에 특화된 제가 17년 동안 코더였기 때문에 전문가로서 특히 고급 기술 내용에 대한 주요 AI 작성자가 되었습니다.\n\n# 작가로서, 뭔가를 알고 있는 척하지 마세요\n\n2019년, 저는 프리랜서 작가로서 성공을 꿈꾸는 절박한 소설 작가였습니다. 저는 성공을 이루기 위해 무엇을 해야 하는지 배울 수 있도록 Writing Cooperative라는 출판물을 꾸준히 참고했습니다.\n\n<div class=\"content-ad\"></div>\n\n수익이 많은 작가들로부터 가장 흔히 본 조언 중 하나는 전문화하는 것이었습니다. 저는 $0.25/단어 이상을 받는 프로 작가들의 기사에서 반복해서 읽었습니다. 그 당시에는 사랑하는 일을 하면서 $0.25/단어를 받는다는 것이 꿈 같았습니다. 하지만 오늘날에는 당연한 수준입니다.\n\n나는 '테크 작가'가 되기를 의도한 적이 없었습니다. 어쩌다 보니 그 방향으로 빠져들었습니다. 사람들이 나의 글을 발견하면서 나의 기술적 배경도 알게 되었고, 나에게 기술 주제에 대해 글을 쓰라는 요청을 했습니다. 나는 그 주제들 중 많은 것에 익숙하지 않았지만, 나의 고객들은 기술 분야 사람들이 작문이 서툰 경향이 있다는 걸 알아주었기 때문에 나에게 투자해 주었습니다. 나는 그 간극을 메워주었고, 기술적인 개념을 비전문가들에게도 전달할 수 있는 기술적인 사람이었습니다.\n\n그러한 요청들은 나를 안드로이드 개발, 메타버스, 핀테크, 암호화폐(심오한 주제들이 실린 곳이었습니다), 다양한 SaaS 도구, 스타트업, 백엔드 기술, 여러 프로그래밍 언어(중에는 전에 들어본 적도 없는 것이 있었습니다) 등에 대해 글을 쓰게 이끌었습니다.\n\n또한 AI에 대해 글을 써보게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n고스트라이터로 일찍 배운 것은 뭔가를 알고 있다고 속이는 것은 좋지 않은 글을 쓰도록 이끈다는 것이었습니다. 전문가가 글을 쓰면 사람들은 글쓰기보다는 전문성을 더 감상합니다. 고스트라이터가 하는 주요 실수 중 하나는 그들의 화려한 문장이 정확도보다 중요하다고 생각하는 것입니다. 하지만 그렇지 않습니다.\n\n테크니컬 라이터로써, 정확성은 당신의 생명줄입니다.\n\n고객들이 종종 내가 하는 말 중 하나는, \"나는 글을 쓸 때 뭔가를 알고 있다고 속이지 않으므로 멍청한 질문을 많이 할 거야. 당신이 전문가입니다. 난 그저 작가일 뿐이죠\" 라는 것입니다.\n\n사람들은 그것을 존중합니다. 이 태도로 몇 년 동안 일을 유지해 왔습니다.\n\n<div class=\"content-ad\"></div>\n\n# AI의 내부를 배우기\n\n같은 태도는 나를 AI의 내부로 이끌었어요 — 현재 AI로 간주되는 것이 무엇인지에 대해 모두가 동의하지 않기 때문에.\n\n테크니컬 라이터로, 저는 무언가의 섬세하고 궁극적인 부분, 그것이 어떻게 작동하는지, 그리고 왜 그것이 작동하는지를 알고 싶어해요. 누군가가 GPT에 대해 쓰라고 부탁했을 때, 제가 스스로에게 묻는 첫 번째 질문은 \"GPT가 무엇을 의미하는지?\" 였어요.\n\n그것이 AI, 머신 러닝, 그리고 모델 아키텍처에 대해 배우는 멋진 토끼굴로 이끈거든요.\n\n<div class=\"content-ad\"></div>\n\nChatGPT이 \"작동\"하는 방식을 완전히 이해하게 되어서, 그것의 응답에 대한 신비를 풀어주고, 이 기계가 이유할 능력이 전혀 없다는 것이 밝혀졌어요. 그렇죠.\n\n여기에 전체 논문에 대해 자세히 다루진 않겠습니다(어차피 자격이 없어서요), 그리고 아래 정의들은 간결함을 위해 어느 정도 부정확할 수 있습니다.\n\nGPT란 다음을 의미합니다:\n\n- Generative: 것을 \"생성\"합니다.\n- Pretrained: 야생으로 방출되기 전에 데이터에서 패턴을 찾아 \"학습\"하는 \"훈련\" 과정을 거칩니다. 이 \"사전 훈련\" 이후, 수많은(수백만?) 답변 중에서 사람들이 \"올바른\" 답변인지 틀린 답변인지를 \"미세 조정\"합니다. 전체 교육 과정은 답변에 \"가중치\"를 더하여, 시스템이 통계 분석을 기반으로 더 정확하게 올바른 답변을 예측할 수 있도록 합니다. 다시 말해, 만약 사람이 90%의 정확도로 한 답변을 올바르다고 표시했다면, 시스템은 그것이 \"정답\"이라 \"배웠다\"는 것입니다. 만약 사전 훈련 데이터가 90%의 시간을 같은 부정확성을 가졌다면, AI 시스템은 그 답변을 \"정답\"으로 고려할 것입니다. 바보 같죠?\n- Transformer: 시스템이 데이터를 순차적으로 처리하는 대신 병렬로 처리할 수 있는 AI 아키텍처를 가리킵니다. (Transformer 아키텍처는 구글 엔지니어들에 의해 만들어진 시대의 획기였는데 지금 보고 있는 금 러시로 이끌었습니다.) 예를 들어, \"bat\"이라는 단어는 포유류나 막대기를 의미할 수 있습니다. \"The bat was hungry\"라는 맥락에서 \"bat\"이 \"포유류\"라는 것을 추론할 수 있습니다. Transformer 아키텍처는 데이터를 동시에(\"병렬로\") 처리하여, 순차적으로 처리할 때보다 훨씬 더 맥락을 추출할 수 있습니다. 이것이 Transformer 아키텍처가 (그리고 ChatGPT뿐만 아니라 다른 Transformer 아키텍처들도 있습니다) 일반적으로 맥락을 올바르게 이해하는 이유입니다. (IBM Technology 유튜브 채널이 지금까지 발견한 것 중에 Transformer와 다른 AI 개념에 대한 가장 좋은 설명을 제공합니다.)\n\n<div class=\"content-ad\"></div>\n\n앞서 말한 것만으로도 몇 가지 경고 신호를 눈치채셨을지도 모르겠어요. ChatGPT에 대해 더 많은 기사를 쓰면서 저는 느끼기 시작한 몇 가지를 여기서 설명해 드릴게요:\n\n- 모든 것은 확률 공식에 따라 작동합니다. 무수히 많은 데이터에 기반하여 \"사전 훈련된\" 시스템은 통계 분석을 사용하여 문장에서 다음으로 가장 가능성이 높은 단어를 결정합니다. 많은 사람들이 ChatGPT가 마치 감각이 있는 것처럼 느껴졌을 정도로 '사운드'가 믿음직스럽다고 생각했을 거에요. 하지만 사실은 수학적 공식을 바탕으로 동작하고 있는 거예요. 여기서 경고 신호는 바로 이겁니다. 아무것도 진정한 창작물이 아니다. 전부 유도물이에요. (그리고, 말그대로, 대규모 언어 모델의 '채팅' 버전은 더 '수다스러운' 소리를 내도록 특별히 훈련되었습니다. 이 모든 것은 매우 교묘하고 매우 신선하다.)\n\n- 이러한 시스템의 본능적 편견이 생성된 콘텐츠에서 나타나기 시작하는 데 오래 걸리지 않았어요. 이미지 생성 도구는 대개 다른 아키텍처를 사용하지만, 확률 공식의 개념은 비슷하며, 편향적인 심지를 일관되게 생성했고, 때로는 인종 차별적이고 성 차별적인 이미지를 생성하기도 했어요. 다시 한 번 강조하지만: 아무것도 창작된 게 없어요. 전부 유도물이죠.\n\n- OpenAI - ChatGPT 뒤에 있는 회사 - 는 열린 것이 아니라는 것을 드러냈어요. Microsoft는 최초 출시 이후 100억 달러를 투자하여 OpenAI에 깊이 뛰어들었습니다. 20년간의 경쟁 끝에 구글을 마침내 이길 것을 갈망하는 Microsoft의 절박함이 분명합니다. ChatGPT 출시 이후 Microsoft는 구글의 검색 엔진 시장 점유율을 정복할 것이라고 확신했어요. 그렇지는 않았죠.\n\n저는 Microsoft/Google의 경쟁을 여러 해간 지켜봤어요. ChatGPT 이후 Microsoft CEO 사티아 나델라의 행동은 사회의 이익보다는 개인적 복수심과 우월함에 기반한 충동적인 행동이라고 생각해요.\n\n요점은요: 폐쇄적인 회사가 사람들을 직접 훈련하여 언어 모델을 만든 다음, 그 언어 모델이 통계적으로 가능성 높은 방식으로 답변을 건진다는 점입니다.\n\n<div class=\"content-ad\"></div>\n\n변환된 표를 Markdown 형식으로 바꿔주세요.\n\n<div class=\"content-ad\"></div>\n\n여기서 작가들이 이해해야 할 중요한 측면은 AI가 사고할 수없다는 것입니다. 이것을 이해해야 합니다. AI는 생각하지 않습니다. 데이터셋과 \"미세 조정\"에 기반한 통계적으로 가능성이 높은 답변을 반복합니다.\n\n우리가 ChatGPT에 공급한 방대한 양의 데이터는 대부분의 시간 정확해 보이게끔 만듭니다. 이 방대한 양의 데이터를 분석하는 것은 실제로 유용한 진전이며 그에는 활용 방법이 있습니다.\n\n# 잘못 정의된 단어가 혹평을 일으키기도 합니다\n\nAI와 ChatGPT를 이해하기 위해 하는 작업 중, AI를 높은 위치에 두고 있는, 그러나 부정확한 단어를 반복해서 만나게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n“신경망”과 “뉴런”: 이 단어들은 조심스럽게 다뤄야 하는 가장 위험한 용어 중 하나입니다. 왜냐하면 인공지능을 인간 사고와 관련된 것으로 위치시킨다는 점에서 그렇습니다 — 하지만 그렇지 않습니다.\n\n옥스퍼드는 “신경망”을 “인간 뇌와 신경계를 모방한 컴퓨터 시스템”으로 잘못 정의하고 있습니다.\n\n이 정의는 놀라울 정도로 어렵습니다. 왜냐하면 뇌에 대해 전문가들조차 뇌가 어떻게 작동하는지에 대해 의견이 분분합니다. 빠른 구글 검색만으로도 인정받는 전문가들 간에 얼마나 많은 논란이 있는지 쉽게 확인할 수 있습니다. 신경과학자, 심리학자, 정신과의사들 사이에 상반되는 의견을 찾을 수 있습니다.\n\n만약 뇌를 연구하는 사람들이 인간 뇌가 어떻게 작동하는지 명확하고 확실하게 설명할 수 없다면, 대기업 기술 회사들은 어떻게 할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 번역해 드리겠습니다.\n\n그것은 불가능합니다.\n\n하지만 이해해야 했습니다. 그래서 더 심층적으로 파고들어가 보니, 다른 정의와 부딪혔습니다. 신경망은 \"뉴런(neurons)\"으로 구성되어 있다고 합니다. 놀랍게도 이 \"뉴런(neurons)\"은 \"뇌 속 뉴런을 모방한 것\"이었습니다.\n\n토끼굴에서 벗어나는 데 얼마나 오랜 시간이 걸렸는지 모르겠습니다. 하지만 마침내 벗어났습니다.\n\n저는 기술에 흥미를 갖는 사람입니다. 회로 기판을 분해하며 자랐습니다. 누군가 기계에 대해 이야기할 때, 제게는 그것을 어떻게 만들 것인지 알고 싶습니다. 이러한 정의들은 어떻게 신경망을 만들지에 대해 말해 주지 않았습니다.\n\n<div class=\"content-ad\"></div>\n\n많은 연구 끝에 제가 개발한 정의는 다음과 같습니다:\n\n- 컴퓨터 과학에서의 뉴런은 여러 개의 가중치 입력을 처리하여 비선형 변환을 통해 하나의 출력을 생성하는 계산 단위입니다.\n\n- 비선형 변환이란 출력이 입력의 변화에 직접 비례하지 않고, 입력 매개변수가 변경될 때 출력의 복잡한 수정이 가능한 것을 의미합니다.\n\n- 신경망은 상호 연결된 인공 뉴런으로 구성된 계산 모델로, 각 뉴런은 여러 개의 가중치 입력을 처리하여 비선형 변환을 통해 하나의 출력을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n그게 더 좋아 보이죠? 실행 가능하니까요. 한정된 내용이고요. 수수께끼가 없어요. \n\n그리고 사실적입니다.\n\nAI와 ML에 관한 글을 쓸 때 원래 위의 정의들을 사용했었지만 미래에 다른 사람들에 의해 수정될 수 있으니 위와 같이 붙여 놓았어요.\n\n신경망과 뉴런을 그들의 계산적 의미로 정의하면 그들을 이상한, 페라오의 의미에서 벗어나게 됩니다.\n\n<div class=\"content-ad\"></div>\n\nAI는 가중 입력을 처리하고 단일 출력을 생성하는 도구인 'AI'를 올바른 위치에 배치합니다.\n\n\"가중 입력\"에 대해 말하자면, 가중치는 사전 훈련, 편향 등에서 나옵니다.\n\n# '환각'은 환각이 아닙니다. 버그입니다.\n\n'환각'이라는 용어가 잘못 정의되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\nGenAI의 환각 성향은 잘 알려져 있습니다. 그 환각은 법정 문서에서 가짜 사례를 사용해 벌금을 부과받은 변호사들이 여러 명 생겼습니다.\n\n\"환각\"이란 단어는 AI가 실제로 가진 창의력을 강조하기 위한 것입니다.\n\n환각은 환각이 아닙니다. 그것들은 소프트웨어 버그입니다. 그리고 그것들은 고칠 수 없습니다. 그 이유는 다음과 같습니다:\n\n소프트웨어를 작성할 때, 개발자들은 일반적으로 \"제어 구조\"라고 하는 일련의 프로세스를 논리적으로 따릅니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n만약 입력값이 \"1\"이면\n  ' 사용자가 \"1\"을 입력한 경우에만 이 코드가 실행됩니다.\n  Print(\"1을 입력했습니다\")\n그렇지 않으면\n  ' 사용자가 \"1\" 이외의 다른 값을 입력한 경우에 이 코드가 실행됩니다.\n  Print(\"1을 입력하지 않았습니다\")\n끝\n```\n\n위 예제에서 \"if...then...else\" 구조는 프로그램의 흐름을 제어하기 때문에 \"제어 구조\"라고 합니다. 누군가 \"1\"을 입력하면 첫 번째 코드 섹션이 실행됩니다. 다른 값을 입력하면 두 번째 섹션이 실행됩니다.\n\n휴대폰과 컴퓨터에 설치된 멋진 앱들의 기반이 되는 다른 제어 구조들도 있습니다.\n\n다층 신경망은 다르게 작동합니다. 제가 너무 단순하게 설명했다면 죄송합니다. 프로그래밍에 대한 논문을 쓰는 것이 목적이 아니라 고수준 개념을 설명하여 이해하는 데 도움을 주는 것이 목표입니다.\n\n\n<div class=\"content-ad\"></div>\n\n생성적 AI에서는 무수히 많은 입력이 동시에 처리되기 때문에 신경망 내부에서 무슨 일이 일어나고 있는지의 흐름을 포착하는 것이 불가능합니다. 이를 늦추면 AI의 기본 구조가 맥락을 포착하지 못하게 되어 정확한 답변을 제공하는 능력이 감소합니다.\n\n\"한꺼번에 일어나는 모든 것\"이라는 문제로, 아무도 AI의 내부를 해체해서 고쳐야 하는 부분을 파악할 수 없습니다.\n\n왜 고장났는지 아무도 모릅니다. 그리고 아무도 디버깅할 수 없습니다.\n\n널리 알려진 대로, 생성적 AI는 재정과 같이 높은 정확도를 요구하는 상황에서는 전혀 사용할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 정말? 그가 진짜 마법이라고 말했다고요? 어머나요.\n\n# 정확도가 필요한 작업에서는 ChatGPT를 피하십시오 — 특히 수학 관련 작업\n\n비코더들을 당황하게 만드는 또 다른 주요 개념은 언어 모델과 수학입니다.\n\n<div class=\"content-ad\"></div>\n\n대형 언어 모델은 수학 계산을 수행할 수 없어요. 물리적으로 불가능한 일인데, 그 이유는 컴퓨터의 특정 부분에 입력 값을 연산할 수 있는 곳으로 보내지 않기 때문이에요.\n\n컴퓨터에서 \"숫자\"와 \"텍스트\"는 핵심 개념이에요. 컴퓨터 프로세서에는 수학 계산을 처리하는 특정 섹션이 존재하는데, 그것이 산술 논리 장치(ALU)라고 불려요.\n\nOpenAI의 대표 Greg Brockman이 ChatGPT 4를 시연할 때, \"TaxGPT\"라는 귀여운 예제를 보여줬어요. 그는 누군가의 세금 계산을 하도록 요청하고, 이후 \"계산기에 연결되어 있지 않다\"며 \"머리 계산\"을 하고 있는 것이라고 언급했어요.\n\n실례지만 - 뭐라구요?\n\n<div class=\"content-ad\"></div>\n\n앞서 언급한 대로, ChatGPT는 문장에서 다음 단어를 예측합니다. 이 단어들을 이해하지는 않습니다. ChatGPT는 1, \"1\" 또는 \"one\" 사이의 차이를 이해하지 못합니다. 만약 인터넷에 \"1 + 1 = 2\"와 같은 패턴을 따르는 충분한 텍스트가 있다면, ChatGPT는 \"1 + 1 =\"으로 시작하는 텍스트 라인 끝에 \"2\"를 출력할 가능성이 높습니다.\n\n아마도.\n\n확실하지는 않습니다.\n\n\"정신적인 계산\"은 없습니다.\n\n<div class=\"content-ad\"></div>\n\n계산기가 없어요.\n\n여러분, 세금 계산에는 챗지피티(ChatGPT)가 아니라 회계 도구를 사용해주세요. 세금 당국은 챗지피티 데모를 믿었다고 해도 관대해주지 않을 거에요.\n\n# 더 나은 프롬프트는 아무런 영향을 미치지 않았어요 — 결국 챗지피티 사용을 그만뒀어요\n\n챗지피티에 대해 기사를 쓰는 일을 받았던 때에는 대략적인 구상을 만들거나 질문에 답변하는 데 널리 사용했었어요.\n\n<div class=\"content-ad\"></div>\n\n초반에는 열정 가득했지만, 그 결과물을 거의 사용하지 않게 되었다. 사용했을 때도 많이 편집했다.\n\n내가 글을 쓸 때 프로그래밍 주제를 배우는 데 도움이 되었다. 그래도 그 결과물을 확인하고, 가끔 비현실적인 부분이 있어서, 직접 튜토리얼을 참고하느니 ChatGPT를 사용하는 것이 시간을 절약할 수 있는지 의문이 들었다.\n\n전문 작가로서 나의 작업에 부정확함이 들어갈 수 없었다. 그래서 ChatGPT가 생성한 모든 것을 구글링했다. 그것은 종종 틀렸다.\n\n전문가들의 조언을 따라 \"더 나은 프롬프트 만들기\"를 시도했다. JSON(JavaScript Object Notation)이라 불리는 \"프로그래밍 스타일\" 언어를 사용한 프롬프트를 작성하기도 했는데, ChatGPT가 이해하기 쉬울 것이라 생각했다. (JSON은 텍스트를 구조화된 방식으로 작성할 수 있게 해주어 프로그래밍 작업에 더 적합하다.)\n\n<div class=\"content-ad\"></div>\n\n변동이 거의 없었네요.\n\n어떤 경우에도 ChatGPT는 저가 누구나 제한을 넘을 수 없었어요.\n\n결국, 덜 사용하기 시작했고, 몇 달 전에 프로 구독을 취소하고 나서부터 거의 사용하지 않았어요.\n\n한편으로 Claude.ai를 발견했는데, OpenAI보다 윤리적인 면에서 높게 평가되는 회사가 만들었어요. 그럼에도 결국에는 동일하게 실망스러웠고, 저도 그 도구를 거의 사용하지 않게 되었어요.\n\n<div class=\"content-ad\"></div>\n\n# ChatGPT은 비작가들에게 유용하며, Canva와 CapCut은 비디자이너들에게 유용합니다.\n\n만약 ChatGPT의 글쓰기가 너무 형편없었다면 — 정말 그랬습니다 — 제게는 이 질문이 들떴어요, \"왜 글쓰기를 판매하기가 더 어려운 느낌일까?\" 2023년은 비즈니스 측면에서는 그리 나쁘지 않았습니다 — 대부분은 AI에 대해 쓰기로 그만큼 많은 돈을 받았기 때문이죠 (이것도 아이러니하죠) — 그러나 정말로 몇몇 클라이언트를 잃었고, 새로운 클라이언트를 확보하는 것이 어려워진 느낌이었습니다.\n\n내 자신을 클라이언트의 입장에 두고 몇 가지를 깨달았습니다. 스스로에게 물었죠, \"SEO 기사를 위해 글쓰기 작업에 $250을 지불할 의사가 있을까?\"\n\n그 대답은 명확했습니다. 아니에요.\n\n<div class=\"content-ad\"></div>\n\n그것은 깨워주는 순간이었어요. 내가 내 작업에 대해 지불하길 원하지 않았다면, 내 고객들은 왜 할 것이라고 생각할까?\n\n답은 간단했어요: 돈을 지불한 가치.\n\nChatGPT는 지루하고 단조로운 반복적이고 지루한 글쓰기를 테이블에서 제외했어요. 그리고 많은 작가들 - 나 자신 포함 - 그런 종류의 콘텐츠를 작성하고, 아마도 과금하고 있었을 수도 있어요.\n\n많은 회사들이 필사적으로 만들고 싶어하는 “SEO 목적 콘텐츠”들은 바로 ChatGPT가 제공하는 것이에요. 그리고 이건 무료로 제공돼요.\n\n<div class=\"content-ad\"></div>\n\n아무도 그런 것을 읽는 것을 좋아하지 않는다고 생각해요. 하지만 Google 순위를 성스럽게 여기는 절박한 많은 CEO들과 대화를 나눈 적이 있어요. 그들은 그 순위를 위해 모든 것을 쓸 것이라고 말해요. 그들에게는 트래픽을 가져다줄 뿐인 기사 내용이 무엇이든 상관이 없어요.\n\n사실, 클라이언트 중 한 명이 그렇게 말한 적이 있어요. (그들은 아직도 ChatGPT가 아닌 저에게 글쓰기 요금을 지불하고 있어요.)\n\n\"SEO 목적용 콘텐츠\"는 또한 낮게 매달린 열매예요. 그것을 원하는 기업들은 사고리더십에 크게 신경을 쓰지 않으며 콘텐츠에 많은 돈을 지불하고 싶어하지 않아요.\n\n저에게 글쓰기 요금을 지불하는 일에 대해서는 — SEO 콘텐츠로 통하는 쓰레기에 대해 $250를 지불하지 않을 테지만, 제 분야에서 리더로서의 위치를 강조하고 비즈니스 문을 여는 기사라면 두 배나 네 배의 금액을 지불할 의향이 충분해요.\n\n<div class=\"content-ad\"></div>\n\n다양한 품질의 콘텐츠입니다.\n\n나는 ChatGPT를 사랑하는 Canva와 CapCut 두 도구를 비교합니다. 나는 프로 디자이너가 아니며 확실히 비디오 편집자도 아닙니다(아직은). 이러한 도구들은 나의 소셜 미디어 프로필을 위해 \"냄새나지 않는\" 빠르고 조잡한 콘텐츠를 만들 수 있게 해줍니다— 그리고 돈을 크게 쓰지 않아도 됩니다. 나는 내 브랜드를 구축하는 초기 단계에 있습니다. 나에게는 정량이 정직합니다. 매일 비디오를 만들면 비디오 편집이 비십니다.\n\n그래서 나는 Canva를 그래픽용으로, CapCut을 비디오 편집용으로 사용합니다.\n\n프로 디자이너와 비디오 편집자는 아마도 내 소셜 미디어 콘텐츠를 보고 싫어할 것입니다. 그러나 그것은 우리 모두가 공존할 수 있는 행복한 중간지대입니다. 언젠가 부유하고 돈이 많이 번 다면, 누군가에게 일을 맡기겠지요.\n\n<div class=\"content-ad\"></div>\n\n지금은 프로급 디자인 및 비디오 편집 작업을 제공하는 사람들의 올바른 타깃 시장이 아닙니다.\n\n# 혹평은 문제가 아니에요 — 문장의 퀄리티만큼 중요해요\n\n저급한, 대량생산, 대량콘텐츠를 제공하는 클라이언트들을 살릴 수 없어요. 솔직히 그런 고객들과 관련된 일을 하는 게 귀찮아요.\n\n그런 종류의 글을 쓰는 게 싫고, 제가 하는 글은 훨씬 더 즐겁답니다. 퀄리티가 훨씬 높아서 도전적이지만 보람도 커요. 그리고 더 많이 벌어들일 수 있죠.\n\n<div class=\"content-ad\"></div>\n\n\"나는 '싼 가격' 경쟁을 그만뒀어. 그건 그냥 맨 밑바닥으로 달려가는 경주라고 생각해.\n\n최고의 고객은 이상적이지만 더 어렵게 찾을 수 있어. 그러나 그런 고객은 존재해. 그런 고객을 만나기 위한 방법은 자신의 품질을 면밀히 살펴보고, 탁월하지 않다면 개선하는 것이다.\n\n그런 다음 사이에 있는 사람들 — 중상위 고객들이 있어: 그들은 괜찮은 콘텐츠를 존중하지만 여전히 ChatGPT가 그들을 위해 만들어 줄 수 있다고 바라는 사람들이다. 왜냐면 사람들의 후기로 그렇게 들었기 때문이야.\"\n\n<div class=\"content-ad\"></div>\n\n과장된 혹평으로 인해 잠재적 고객에게 제품을 판매하기 어려워졌어요. 하지만 매출 사이클이 어렵게 되는 건 이 과장이라는 것을 알아야 해요. 품질 때문은 아니에요. 만약 매출 사이클을 개선한다면 여전히 중간 계층 고객을 끌어들일 수 있는 기회가 있어요.\n\n네, 이 새로운 생태계에서 우리는 더욱 열심히 팔아야 합니다.\n\nAI가 전문 작가의 작품과 비슷할 리 없다는 걸 확신할 수 있어요. 저는 이것에 한푼의 의심도 없어요. 이걸 확실히 믿게 되는 데는 1년 반이 걸렸죠. 확신을 갖게 되면, 제 판매 능력도 향상되었어요. 누군가 앞에 서서 \"챗지피티로는 그 퀄리티를 얻을 수 없어요\" 혹은 \"챗지피티 콘텐츠로 브랜드를 훼손하게 될 거라고 절대적으로 확신해요\" 라고 확신을 갖고 전할 수 있게 되었거든요.\n\n다른 사람들에게 이것들을 설득하기 위해선 이런 사실에 대해 개인적 확신을 얻어야 했어요.\n\n<div class=\"content-ad\"></div>\n\n제 목표는 예술가와 작가들을 위해 힘을 실어주는 것입니다. 매일 올라오는 격려가 담긴 콘텐츠를 받고 싶다면, 즐겨 사용하는 소셜 미디어 채널에서 저를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-06-20-ImaComputerProgrammerandWroteProfessionallyaboutChatGPTfor15YearsHeresHowProWritersCanBeOkay_0.png"},"coverImage":"/assets/img/2024-06-20-ImaComputerProgrammerandWroteProfessionallyaboutChatGPTfor15YearsHeresHowProWritersCanBeOkay_0.png","tag":["Tech"],"readingTime":13},{"title":"합리적인 AI 프롬프트의 비밀 데이터와 함께 프롬프팅","description":"","date":"2024-06-20 18:31","slug":"2024-06-20-TheSecrettoFoolproofAIPromptsPromptingWithData","content":"\n\n<img src=\"/assets/img/2024-06-20-TheSecrettoFoolproofAIPromptsPromptingWithData_0.png\" />\n\n맞아요. 환각이나 가짜 증거는 더 이상 없어요. 이젠 순수한 사실들뿐이에요.\n\n그리고 제일 좋은 점은 무엇이냐면, 많이 변화시킬 필요가 없다는 거예요. 프롬프트하는 방식을 약간 바꾸는 것만으로 충분했어요.\n\n이게 뭔지 궁금하시다면, 이제 알아보도록 하죠. 함께 파헤쳐봐요.\n\n<div class=\"content-ad\"></div>\n\n# 데이터 기반 프롬프팅\n\n여기서는 \"데이터를 활용한 프롬프팅\"이라고 부르겠어요. 이것에 대해 처음 들어보신다면, 기본 아이디어를 알려드리겠습니다:\n\n- 템플릿 사용: 당신의 작업을 설명하는 대신, ChatGPT에 응답 템플릿을 제공하세요.\n- 데이터 포함: 관련 데이터를 직접 프롬프트에 첨부하세요. URL, PDF 또는 간단한 텍스트일 수 있습니다.\n- 지시 추가: 연결된 데이터를 사용하여 AI에게 템플릿을 작성하도록 요청하세요.\n\n여기에 이 기술을 사용한 프롬프트의 예시가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-TheSecrettoFoolproofAIPromptsPromptingWithData_1.png\" />\n\n이제 우리가 기초를 알았으니까 이 프롬프트를 만드는 방법을 알아볼까요? (예를 들어 사용해서) 간단한 트윗을 학술 에세이로 바꾸려고 해요.\n\n## 1/ 데이터 찾기\n\n첫 번째 단계는 첫걸음을 내는 것입니다. 내 경우에는 데이터를 찾는 것이에요.\n\n<div class=\"content-ad\"></div>\n\n이것은 블로그 게시물, PDF, 이미지 또는 ChatGPT에서 받아들일 수 있는 다른 형식일 수 있어요.\n\n나에게는 트윗이에요.\n\n## 2/ 데이터로 프롬프트를 제시해보세요\n\n다음 단계는 프롬프트를 작성하는 것이에요. 채워야 할 중요한 두 부분이 있어요:\n\n<div class=\"content-ad\"></div>\n\n- 템플릿: 이것은 AI의 출력 형식을 안내합니다.\n- 데이터: 이것은 필요한 맥락과 제약을 제공합니다.\n\n원하는 경우 작업을 명확히 설명할 수 있습니다. 제 경우에는 트윗을 글로 변환하라고 언급했어요.\n\n![이미지](/assets/img/2024-06-20-TheSecrettoFoolproofAIPromptsPromptingWithData_2.png)\n\n한 번 시도해보고 싶다면 전체 프롬프트는 여기에 있습니다:\n\n<div class=\"content-ad\"></div>\n\n위의 텍스트를 친절하게 한국어로 번역해 드리겠습니다.\n\n\n| 파일 이름                                            | 설명                              |\n|-------------------------------------------------|--------------------------------|\n| 2024-06-20-TheSecrettoFoolproofAIPromptsPromptingWithData_3.png | AIPrompt 데이터 사용 방법을 보여주는 이미지 |\n\n정말 멋지죠? 간단하면서도 마법처럼 잘 작동합니다.\n\n## 3/ 직접 해보기\n\n\n<div class=\"content-ad\"></div>\n\n다음 코드로 표를 마크다운 형식으로 바꿔보세요.\n\n즐거운 코딩 되세요!","ogImage":{"url":"/assets/img/2024-06-20-TheSecrettoFoolproofAIPromptsPromptingWithData_0.png"},"coverImage":"/assets/img/2024-06-20-TheSecrettoFoolproofAIPromptsPromptingWithData_0.png","tag":["Tech"],"readingTime":2},{"title":"챗지피티 대규모 업데이트 엑셀 실시간 대화형 분석 누군가가 그 뒤에 있는 새로운 모델을 공개했습니다 ","description":"","date":"2024-06-20 18:30","slug":"2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt","content":"\n\nGPT-4o가 출시된 지 며칠 만에, OpenAI가 ChatGPT 내에서 실시간 대화형 데이터 분석을 가능케 하는 또 다른 혁신적인 기능을 발표했습니다.\n\n![이미지](/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_0.png)\n\n이 업데이트를 통해 사용자들은 이제 ChatGPT에서 데이터 파일을 직접 열 수 있어서 분석을 위한 Python 코드 실행이 원활해졌습니다. 이는 대규모 데이터셋을 병합하고 차트를 생성하며 손쉽게 결론을 요약하는 것을 포함합니다.\n\n![이미지](/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_1.png)\n\n<div class=\"content-ad\"></div>\n\n이 발전은 데이터 분석가의 핵심 작업을 주로 다룹니다. 많은 인터넷 사용자들이 이 발전에 흥분했습니다:\n\n![이미지](/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_2.png)\n\n# 주요 기능\n\n1️⃣ Google 드라이브 및 Microsoft OneDrive로부터 직접 파일 업로드:\n\n<div class=\"content-ad\"></div>\n\nChatGPT는 이제 Google 시트, 문서, 슬라이드, 그리고 Microsoft 엑셀, 워드, PPT와 같은 파일을 Google 드라이브와 OneDrive에서 직접 업로드할 수 있습니다. 이를 통해 파일을 다운로드하고 다시 업로드하여 분석할 필요가 없어졌습니다.\n\n2️⃣ 대화형 테이블 및 차트:\n\n파일을 업로드하면 ChatGPT가 대화식 테이블을 만듭니다. 확장 버튼을 클릭하면 새로운 대화식 페이지가 열립니다. 예를 들어, 데이터를 월별로 그룹화하려면 데이터를 선택하고 \"월별 그룹화\"라고 입력하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n데이터를 반올림하려면 한 번의 클릭으로 조정합니다:\n\n![image1](/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_4.png)\n\nChatGPT는 분석된 데이터에서 시각적 차트를 생성할 수도 있습니다:\n\n![image2](/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_5.png)\n\n<div class=\"content-ad\"></div>\n\n이 기능은 매일의 작업 흐름에 완벽하게 통합되어 생산성과 정확성을 향상시킵니다. 일부 사용자는 AI 기반 데이터 분석이 AI 코드 개발을 능가할 수 있다고 믿는데, 이는 OpenAI가 효과적으로 활용하고 있는 감정입니다.\n\n3️⃣차트의 사용자 정의 및 다운로드:\n\n사용자는 ChatGPT가 생성한 차트를 사용자 정의하고 발표 자료 및 문서로 다운로드할 수 있습니다. 예를 들어 특정 월에 지출을 결합하거나 데이터를 국가 또는 지역별로 분류하는 것이 간단합니다:\n\n![image](/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_6.png)\n\n<div class=\"content-ad\"></div>\n\n시각화를 작성할 때, ChatGPT는 전반적인 추세에 대한 텍스트 요약을 제공하며 사용자는 수정된 색상과 같은 인터페이스 내에서 차트를 직접 편집한 후 다운로드할 수 있습니다:\n\n![ChatGPT](/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_7.png)\n\nOpenAI는 ChatGPT가 클라우드 차트에 액세스할 수 있지만 기업 사용자 데이터를 교육에 사용하지 않을 것을 확약합니다. ChatGPT Plus 사용자는 추가 보안을 위해 개인정보 보호 기능을 활성화할 수 있습니다.\n\n# 새로운 모델 인사이트\n\n<div class=\"content-ad\"></div>\n\n최신 기능들은 데이터 분석을 위해 맞춤화된 새로운 모델에 의해 구동되는 것으로 알려져 있습니다.\n\n![2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_8.png](/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_8.png)\n\n일부 사용자들은 ChatGPT 페이지의 Alpha Models 섹션에서 ADA V2(GPT-4)라는 모델을 발견했습니다.\n\n![2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_9.png](/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_9.png)\n\n<div class=\"content-ad\"></div>\n\n# OpenAI의 우세함과 산업 영향\n\nOpenAI는 계속해서 트렌드 세터 역할을 하고, 종종 다른 기술 거물들을 가려버리곤 합니다. 구글의 최신 릴리스가 I/O 컨퍼런스에서 발표되었음에도 불구하고, OpenAI의 혁신들이 주목을 받으며 이 회사들 간의 치열한 경쟁을 강조하고 있습니다.\n\n![이미지](/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_10.png)\n\n한 OpenAI 직원이 심지어 구글을 조롱했는데, 트윗은 빠르게 삭제되었습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_11.png)\n\nRegardless, the rivalry benefits users with continuous advancements.\n\nIt’s been an exciting week for AI enthusiasts and professionals alike.\n\n![Image 2](/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_12.png)\n\n\n<div class=\"content-ad\"></div>\n\n— by 公众号: 量子位\n\n# 참고 자료:\n\n[1] OpenAI Twitter\n\n[2] OpenAI ChatGPT 내 데이터 분석 개선\n\n<div class=\"content-ad\"></div>\n\n[3] 트위터 사용자 @nanulled\n\n💡더 깊이 파고들고 싶나요? 내 ChatGPT 컬렉션이 여러분을 기다리고 있어요.\n\n## 기사가 마음에 드셨나요?\n\n그렇다면:\n\n<div class=\"content-ad\"></div>\n\n- 댓글을 남겨주세요\n- 내 소식을 팔로우 해주세요\n- 무료 이메일 알림\n\n# 쉬운 영어로 🚀\n\nIn Plain English 커뮤니티의 일원이 되어 주셔서 감사합니다! 떠나시기 전에:\n\n- 꼭 박수와 작가를 팔로우해주세요 👏️️\n- 팔로우하기: X | LinkedIn | YouTube | Discord | Newsletter\n- 다른 플랫폼 방문하기: Stackademic | CoFeed | Venture | Cubed\n- 알고리즘 콘텐츠를 다루도록 강요하는 블로깅 플랫폼에 지친다면? Differ를 시도해보세요\n- PlainEnglish.io에서 더 많은 콘텐츠 확인하기","ogImage":{"url":"/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_0.png"},"coverImage":"/assets/img/2024-06-20-ChatGPTHugeUpdateReal-TimeInteractiveAnalysisofExcelSomeoneRevealstheNewModelBehindIt_0.png","tag":["Tech"],"readingTime":5},{"title":"언어 모델 보정 기법 확률 평가 향상하기","description":"","date":"2024-06-20 18:26","slug":"2024-06-20-CalibrationTechniquesforLanguageModelsEnhancingProbabilityAssessments","content":"\n\n\n![Calibration Techniques for Language Models](/assets/img/2024-06-20-CalibrationTechniquesforLanguageModelsEnhancingProbabilityAssessments_0.png)\n\n언어 모델, 특히 대형 언어 모델(LLMs)은 인간과 유사한 언어를 이해하고 생성하는 능력으로 인공지능 분야를 혁신했습니다. 이러한 모델은 제로샷 설정에서 다양한 작업을 수행할 뿐만 아니라 맞춤식 프롬프트를 통해 놀라운 유연성과 다양성을 바탕으로 여러 도메인에서 탁월하게 유용합니다.\n\n그러나 그들의 효과적인 성능에도 불구하고, 이 모델들의 교정(calibration)은 종종 도전이 되는 핵심적인 측면 중 하나입니다 — 즉, 다양한 결과에 대한 확률이 그 결과가 정확할 가능성을 정확히 반영하는지 보장하는 것입니다.\n\n본 문서에서는 LLMs의 교정이 필요한 이유를 탐구하고, 그들의 확률 평가를 둘러싼 핵심 문제를 식별하며, 더 나은 모델 교정을 위한 현대적인 방법을 탐구합니다.\n\n\n<div class=\"content-ad\"></div>\n\n## LLM 모델에서 교정이 왜 중요한 이유\n\nLLM의 본질은 정확성뿐만 아니라 올바른 신뢰 수준이 할당된 언어 기반 출력을 처리하고 생성하는 데 있습니다. 교정 — 즉 모델의 신뢰 수준을 정확성과 일치시키는 과정 — 는 다음과 같은 이유로 필수적입니다:\n\n- 신뢰할 수 있는 AI 의사 결정: 적절히 교정된 신뢰 점수는 사용자들이 AI가 내리는 결정을 믿고 의지할 수 있게 하며, 모델이 올바르거나 잘못될 가능성을 이해할 수 있게 합니다.\n\n- 위험 관리: 의료 진단이나 자율 주행과 같은 안전 중요 응용 프로그램에서 자신감이 넘치지만 부정확한 예측은 재앙적 결과로 이어질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 모델 디버깅 및 개선: 보정은 개발자가 모델의 약점을 이해하고 이에 맞게 개선하는 데 도움이 될 수 있습니다.\n\n## LLM 확률 보정에서의 어려움\n\n대형 언어 모델은 종종 확률 보정에 영향을 미치는 여러 가지 어려움에 직면합니다:\n\n- 닫힌 모델 제한: 많은 대형 언어 모델은 로그 확률에 직접 접근할 수 있는 제한된 액세스를 가진 블랙 박스로 작동하여 확신도를 이해하고 조정하는 프로세스를 복잡하게 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n- 훈련 중의 불일치: Reinforcement Learning from Human Feedback (RLHF)와 같은 기술로 개선된 모델들은 어설프게 miscalibrated 될 수 있습니다. 논문 [1]에 따르면 가장 널리 사용되는 LLM들은 인간 피드백으로 강화학습된 모델들입니다 (RLHF-LLMs). 일부 연구에서는 RLHF-LLMs가 매우 잘 보정되지 않은 조건부 확률을 생성한다고 제안했습니다. 연구 결과는 RLHF-LLMs가 사용자 선호도에 근접하게 따라가기를 우선시하는 경향이 있어 잘 보정된 예측 생성보다는 낮은 보정을 낸다는 것을 보여줍니다. 이는 RLHF로 훈련된 모델들이 정확하고 신뢰할 수 있는 출력을 위해 필요한 확률 보정을 갖추지 못할 수 있는 주요 도전을 보여줍니다.\n\n- 작업별 보정 필요성: LLM의 일반적인 훈련은 일반적으로 특정 작업이나 도메인에 대해 조정되지 않았기 때문에, 특정 요구사항이나 응용 프로그램과 조율되도록 하기 위해 추가적인 보정이 필요합니다.\n\n## LLMs를 위한 고급 보정 방법\n\n보정 도전에 대응하기 위해 아래에서 논의된 여러 기술을 시도해볼 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-20-CalibrationTechniquesforLanguageModelsEnhancingProbabilityAssessments_1.png)\n\n## Verbalized Confidence\n\n“Verbalized Confidence” refers to techniques where a Language Model (LLM) not only provides answers but also rates its confidence in its response explicitly. This approach involves the use of certain methodologies to obtain more reliable assessments of the model’s confidence in its answers.\n\n## Basic Implementation\n\n\n<div class=\"content-ad\"></div>\n\n가장 간단한 형태로 표현된 신뢰 표현은 LLM에게 질문과 관련 있는 맥락을 제시한 후 명시적으로 신뢰 점수를 요청하는 것입니다. 이 직접적인 접근은 더 정교한 기술의 기반 역할을 합니다.\n\n## 향상된 신뢰 표현 기술\n\n- Chain-of-Thought (CoT) Prompting: CoT Prompting은 답변을 제공하기 전에 모델로부터 단계별 추론 과정을 유도하는 것을 포함합니다. 이 방법은 모델의 답변의 명확성과 풍부성을 향상시킬 뿐만 아니라 추론 단계에서 논리적 일관성을 관찰하여 신뢰 수준을 더 정확히 추정할 수 있습니다.\n- 다단계 신뢰 유도: 이 기술은 추론 또는 문제 해결 과정의 여러 단계에서 신뢰 점수를 캡처하여 신뢰 측정을 개선합니다. 최종 신뢰 수준은 개별 신뢰 점수의 곱으로 파생되어 확신의 합성 측정 값을 제공합니다.\n- 상위-K 답변 및 신뢰 점수: 하나의 답변 대신 모델이 여러 가능한 답변(상위-K 답변)을 생성하며 각각 개별적인 신뢰 점수와 함께 제시됩니다. 가장 높은 신뢰 점수를 가진 답변이 최종 답변으로 선택됩니다. 이 방법은 여러 가설을 평가하는 의사 결정 과정과 유사합니다.\n- 다양한 유도 기법: 여러 다양한 유도를 활용하면 신뢰 추정이 더 정확해질 수 있습니다. 다양한 유도는 서로 다른 어구, 맥락 또는 개념 각도에서 비롯될 수 있으며, 이는 모델의 평가를 편향된 또는 정보 부족으로부터 더 견고하게 만들어줍니다.\n- 숫자적 확률 대 언어 표현: 경우에 따라 모델이 정확성 가능성에 직접 연결된 숫자적 확률을 통해 자신의 신뢰를 표현합니다. 반대로, \"매우 가능성이 높음\" 또는 \"아마도 아님\"과 같은 언어적 표현도 사용될 수 있습니다.\n- 여러 가설과 함께 유도: 처음에 모델은 신뢰 등급 없이 여러 답변 후보를 생성합니다. 이후 상호 작용에서 각 답변의 정답 가능성을 평가합니다. 연구 결과는 이 방식으로 여러 가설을 평가하는 것이 극적으로 보정된다는 것을 나타냅니다.\n\n<img src=\"/assets/img/2024-06-20-CalibrationTechniquesforLanguageModelsEnhancingProbabilityAssessments_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n모델 간에 자신감을 효과적으로 표현하는 능력은 다양하며, 서로 다른 모델 아키텍처와 세대 간에 관찰되는 차이점이 있습니다.\n\n## 자기 일관성 기반 신뢰도\n\n자기 일관성 기반 신뢰도 방법은 동일한 쿼리에 대해 여러 응답을 생성하고 이러한 응답 사이의 일치를 분석함으로써 언어 모델의 신뢰도를 평가하는 복잡한 방법입니다. 이 기술은 다양한 조건에서 높은 일치가 나타날수록 응답의 정확도에 대한 높은 신뢰를 나타낸다는 아이디어에 기반합니다.\n\n여러 응답 생성하기\n\n<div class=\"content-ad\"></div>\n\n모델로부터 다양한 결과 스펙트럼을 얻기 위해 몇 가지 전략을 사용합니다:\n\n셀프-랜덤화: 이 방법은 동일한 질문을 다른 설정에서 여러 번 입력하는 것을 포함합니다. \"온도\" 매개변수를 조절하는 것이 일반적이며, 이는 모델의 응답 다양성을 다루기 위해 출력의 예측성 또는 랜덤성을 변화시킴으로써 작동합니다.\n\n프롬프트 왜곡: 질문의 요구사항을 다르게 해석할 수 있도록 문구를 변경하여 다양한 각도의 응답을 유도합니다. 이를 통해 모델의 강건성을 테스트하며, 문맥상 유사한 프롬프트지만 다르게 표현된 질문 사이에서 일관성을 유지하는지 확인합니다.\n\n잘못된 단서: 의도적인 오류나 오해를 유발하는 힌트를 프롬프트에 삽입하여 모델의 안정성을 평가합니다. 사람의 테스트와 유사하게, 이 방법은 모델이 자신감 있는 사람처럼 오해된 정보를 무시하고 정확하거나 일관된 응답을 유지할 수 있는지를 관찰합니다.\n\n<div class=\"content-ad\"></div>\n\n집계 전략\n\n결과를 종합하고 최종 신뢰 점수를 할당하기 위해 다양한 집계 전략을 고려할 수 있습니다:\n\n일관성 측정: 이는 모델이 다양한 조건에서 동일한 응답을 제공하는 정도를 검토하여 안정성과 신뢰성을 반영합니다.\n\n평균 신뢰도 (평균-신뢰도): 높은 일치도와 개별 신뢰 점수가 높은 답변에 더 많은 가중치를 부여하여 전반적인 신뢰도의 세밀한 측정을 제공하는 가중 평균이 계산됩니다.\n\n<div class=\"content-ad\"></div>\n\n쌍-순위 전략: 모델의 상위-K 예측을 사용하는 시나리오에서 특히 유용한 이 전략은 모델 예측에서 순위 정보를 강조하여 가장 가능성이 높고 일관된 응답을 평가하는 데 도움이 됩니다.\n\n## 로짓 기반 접근 방식\n\n로짓 기반 캘리브레이션은 대형 언어 모델(Large Language Models, LLMs)이 하는 확률적 예측의 신뢰성을 향상시키는 중요한 기술입니다. 모델이 로그 확률과 같은 원시 점수를 출력할 때, 일반적으로 이러한 점수는 직접적으로 정확한 확률 분포로 변환되지 않습니다. 캘리브레이션 기술은 이러한 로짓을 조정하여 더 정확한 확률을 반영하며, 이것은 실제 응용 프로그램에서 강력한 의사 결정을 내리는 데 중요합니다. 아래에서는 로짓 기반 캘리브레이션에 사용되는 일부 방법에 대해 자세히 살펴봅니다:\n\n1. 토큰 간의 확신을 평균화하기\n\n<div class=\"content-ad\"></div>\n\n언어 모델의 예측에 대한 확신을 더 균일하게 추정하기 위한 일반적인 방법 중 하나는 토큰 간의 확신(로그 확률)을 평균화하는 것입니다. 이는 특정 응용 프로그램이나 데이터셋의 특성에 따라 모든 토큰 또는 선택적 하위 집합에 대해 수행될 수 있습니다. 결과는 모델의 확신에 대한 더 부드럽고 일반화된 측정으로, 어떤 단일 토큰의 변동성이 미치는 영향을 줄입니다.\n\n2. Platt 스케일링 (시그모이드)\n\nPlatt 스케일링 또는 시그모이드 보정은 원래 모델의 출력 로짓에 적용되는 로지스틱 회귀 모델입니다. 로짓 위에 시그모이드 함수를 피팅함으로써이 방법은 로짓을 보정된 확률로 변환합니다. 보정에는 일반적으로 'A'와 'B'로 표시되는 두 매개변수를 학습하는 과정이 포함됩니다. 이 매개변수는 로짓을 실제 관측된 확률과 보다 잘 일치시키기 위해 스케일링 및 이동시킵니다. 이 방법은 이진 분류 작업에 대한 단순성과 효과적임으로 인해 특히 유용합니다.\n\n![그림](/assets/img/2024-06-20-CalibrationTechniquesforLanguageModelsEnhancingProbabilityAssessments_3.png)\n\n<div class=\"content-ad\"></div>\n\n3. 등위 회귀\n\nPlatt 스케일링과는 다르게, 등위 회귀는 로짓과 확률 사이에 어떤 기능적 형태도 가정하지 않습니다. 이는 예측된 확률을 대상 확률과 일치시키기 위해 비감소 함수를 적합시키는 비모수적 접근 방식입니다. 이 조각별 상수 함수는 유연하며 로짓과 확률 사이의 관계가 더 복잡하거나 비선형적인 경우, 특히 일부 시나리오에서 실제 분포를 더 정확하게 반영할 수 있습니다.\n\n![image](/assets/img/2024-06-20-CalibrationTechniquesforLanguageModelsEnhancingProbabilityAssessments_4.png)\n\n4. 온도 조정\n\n<div class=\"content-ad\"></div>\n\n온도 조정은 모델의 확신을 조정하는 사후 처리 기술로, 예측을 변경하지 않고 조절합니다. 소프트맥스 함수를 적용하기 전에 상수인 \"온도\"로 로짓을 나누는 방식으로 확률로 변환합니다. 최적의 온도는 보통 검증 데이터셋에서 교차 엔트로피 손실을 최소화하여 결정됩니다. 이 방법은 원래 로짓의 상대적 순서를 유지하면서 보정 프로세스에 미세한 영향을 미치므로 매력적입니다.\n\n# 대리 모델 또는 세부 조정 방법\n\n세부 조정은 특정 데이터와 목표를 사용하여 모델을 미세 조정하여 특정 작업에 보다 나은 준비를 시키는 고급 보정 접근 방식입니다. 더 신뢰할 수 있고 정확한 신뢰 점수를 제공하기 위해 모델을 미세 조정하는 여러 혁신적인 방법을 살펴보겠습니다.\n\n## 대리 모델을 활용한 신뢰 평가\n\n<div class=\"content-ad\"></div>\n\n한 가지 매력적인 방법은[2] 일반적으로 더 단순한 모델을 사용하여 주요 모델 (예: GPT-4)로부터 얻은 답변이 얼마나 믿을 만한지를 평가하는 것입니다:\n\n- 하는 일: 예를 들어, LLAMA2와 같은 보조 모델은 다른 모델인 GPT-4가 제공하는 답변의 대한 로그 확률을 얻기위해 동일한 프롬프트를 제공하고 GPT-4 모델 응답에 대한 점수를 추출할 때 사용될 수 있습니다.\n\n- 놀라운 효과성: 비록 보조 모델이 덜 강력할 수 있지만, 이 방법은 언어적 단서만 사용하는 것과 비교하여 더 나은 결과를 낳는 것으로 입증되었습니다(Area Under the Curve 또는 AUC를 기준으로 측정).\n\n## 불확실성 인식: R 튜닝\n\n<div class=\"content-ad\"></div>\n\nR-튜닝은 모델이 \"모르겠다\"라고 말해도 괜찮다는 것을 가르칩니다. 모델의 한계를 인식합니다. 파인튜닝 프로세스는 다음 단계로 구성됩니다.\n\n- 불확실성 식별: 모델의 답변이 흔들리거나 의문스러운 경우를 찾아내어 예측하고 실제 결과와 비교하여 학습 세트에서 찾습니다.\n\n- 확실히 훈련: 그런 다음 \"확실함\" 또는 \"불확실함\"으로 태그된 예제를 사용하여 모델을 가르치어 이러한 구별에서 배우도록 합니다. \"확실하다\" 또는 \"의심스럽다\"와 같은 구문을 사용하여 훈련 중에 자신감 수준을 표현하며, 토큰 생성부터 오류를 줄이는 데 집중합니다.\n\n![이미지](/assets/img/2024-06-20-CalibrationTechniquesforLanguageModelsEnhancingProbabilityAssessments_5.png)\n\n<div class=\"content-ad\"></div>\n\n## LITCAB: 작은 변화, 큰 영향\n\nLITCAB은 작지만 효과적인 보정 레이어를 소개합니다:\n\n- 간단한 추가: 모델 끝에 단일 선형 레이어를 추가하여 입력 텍스트에 따라 각 응답의 예측 확률을 조정합니다.\n\n- 효율적이고 효과적: 이 소규모 조정은 복잡성을 크게 늘리지 않고 모델의 판단력을 향상시킵니다. 원래 모델 크기 변화의 2% 미만만 변경됩니다.\n\n<div class=\"content-ad\"></div>\n\n## ASPIRE: 더 스마트한 모델 응답\n\n예측에 신뢰 점수를 할당하고 선택적 예측을 허용합니다. ASPIRE는 세 가지 단계로 구성됩니다:\n\n1. 작업별 튜닝: PEFT 기술을 사용하여 주요 모델을 변경하지 않으면서 특정 변환 가능한 매개변수를 수정하여 특정 작업에 대한 응답을 개선합니다.\n\n2. 답변 샘플링: 이러한 조정을 사용하여 각 질문에 대해 여러 잠재적인 답변을 생성하고 높은 가능성의 출력 시퀀스를 만들기 위해 빔 검색을 사용하며 생성된 출력 시퀀스가 참 값에 기반하여 올바른지 여부를 결정하기 위해 Rouge-L 메트릭을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n3. 자가평가 학습: 마지막으로, 모델이 자체적으로 답변이 맞거나 틀렸는지 판단하여 자체평가 능력을 향상시키는 다른 조절 세트를 소개합니다.\n\n![이미지](/assets/img/2024-06-20-CalibrationTechniquesforLanguageModelsEnhancingProbabilityAssessments_6.png)\n\n이러한 방법을 통해 언어 모델은 더 발전된 것뿐만 아니라 사용자의 맥락과 기대에 더 부합하게 되어, 더 신뢰성이 있고 문맥을 인식하는 상호작용을 이끌어냅니다.\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n대규모 언어 모델의 보정은 복잡하지만 중요한 작업으로, AI 응용 프로그램의 신뢰성과 안전성을 향상시킵니다. 위에서 논의한 다양한 혁신적인 방법을 사용하고 결합함으로써, 이러한 모델이 다양한 맥락에서 이해하고 상호 작용하는 방식을 혁신적으로 개선할 수 있습니다. 이는 높은 자신감과 정확성으로 결정을 내릴 수 있는 진정으로 지능적인 시스템을 위한 길을 열어줍니다.\n\n## 부록:\n\n- Katherine Tian, Eric Mitchell, Allan Zhou, Archit Sharma, Rafael Rafailov, Huaxiu Yao, Chelsea Finn, 그리고 Christopher D. Manning이 제목을 붙인 “Just Ask for Calibration: Strategies for Eliciting Calibrated Confidence Scores from Language Models Fine-Tuned with Human Feedback,”\n- Llamas Know What GPTs Don’t Show: Surrogate Models for Confidence Estimation, Vaishnavi Shrivastava, Percy Liang, Ananya Kumar\n- R-Tuning: Instructing Large Language Models to Say ‘I Don’t Know’ Hanning Zhang♠∗, Shizhe Diao♠∗ 및 기타.\n- LITCAB: LIGHTWEIGHT LANGUAGE MODEL CALIBRATION OVER SHORT- AND LONG-FORM RESPONSES Xin Liu, Muhammad Khalifa, Lu Wang\n- Strength in Numbers: Estimating Confidence of Large Language Models by Prompt Agreement Gwenyth Portillo Wightman, Alexandra DeLucia 및 Mark Dredze\n- CAN LLMS EXPRESS THEIR UNCERTAINTY? AN EMPIRICAL EVALUATION OF CONFIDENCE ELICITATION IN LLMS Miao Xiong1∗, Zhiyuan Hu1, Xinyang Lu 및 기타.\n- ASPIRE 소개: LLMs에서 선택적 예측을 위한\n- Think Twice Before Assure: Confidence Estimation for Large Language Models through Reflection on Multiple Answers Moxin Li1, Wenjie Wang 및 기타.\n- 대규모 언어 모델로부터의 장문 생성 보정\nYukun Huang1, Yixin Liu 및 기타.\n\n![이미지](/assets/img/2024-06-20-CalibrationTechniquesforLanguageModelsEnhancingProbabilityAssessments_7.png)\n\n<div class=\"content-ad\"></div>\n\n이 이야기는 Generative AI Publication에서 발행되었습니다.\n\n최신 AI 이야기를 따르려면 Substack, LinkedIn 및 Zeniteq에서 저희와 연락을 유지하세요. 함께 AI의 미래를 함께 만들어 보아요!\n\n![이미지](/assets/img/2024-06-20-CalibrationTechniquesforLanguageModelsEnhancingProbabilityAssessments_8.png)","ogImage":{"url":"/assets/img/2024-06-20-CalibrationTechniquesforLanguageModelsEnhancingProbabilityAssessments_0.png"},"coverImage":"/assets/img/2024-06-20-CalibrationTechniquesforLanguageModelsEnhancingProbabilityAssessments_0.png","tag":["Tech"],"readingTime":10}],"page":"45","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}