{"pageProps":{"posts":[{"title":"블록체인으로 IoT의 잠재력이 발휘되는 방법 혜택, 장애물","description":"","date":"2024-06-19 16:46","slug":"2024-06-19-UnlockingIoTsPotentialwithBlockchainBenefitsObstacles","content":"\n\n![이미지](/assets/img/2024-06-19-UnlockingIoTsPotentialwithBlockchainBenefitsObstacles_0.png)\n\n사물 인터넷(IoT)은 무수히 많은 장치를 연결하여 실시간 데이터를 교환함으로써 우리의 삶과 일상을 변화시키고 있습니다. 스마트 홈부터 공장까지, IoT 네트워크는 빠르게 확장되고 있습니다. 그러나 대규모로 안전하고 투명한 장치 간 통신을 보장하는 것은 간단한 일이 아닙니다.\n\n블록체인은 비트코인과 같은 암호화폐 뒤에 있는 분산원장 기술입니다. IoT 시스템에 블록체인을 통합함으로써 변조 방지 장치 추적을 생성하고, 프로세스 자동화 및 동료 간 거래를 용이하게 할 수 있습니다. 이 강력한 조합은 흥미로운 기회를 제공할 뿐 아니라 어려운 도전도 함께하고 있습니다.\n\n블록체인/IoT 융합의 양면을 탐험하여 우리의 연결된 미래에 미칠 잠재적 영향을 이해해봅시다.\n\n<div class=\"content-ad\"></div>\n\n# IoT에 대한 블록체인의 주요 이점\n\nIoT 아키텍처 옆에 블록체인을 구현하면 몇 가지 매력적인 이점이 나타날 수 있습니다:\n\n# 1. 강화된 보안 :lock:\n\n블록체인의 주요 장점 중 하나는 미인가된 데이터 조작을 방지하고 견고한 인증 메커니즘을 제공하는 능력입니다. 이는 IoT 생태계 전반에 걸쳐 보안을 강화합니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어 블록체인은 의료 IoT 장치로 전송되는 민감한 건강 데이터를 안전하게 유지하여 개인 정보 침해나 기록 변경과 같은 위험을 완화할 수 있습니다. 승인된 당사자만이 변경할 수 있는 불변의 데이터 트레일에 액세스할 수 있습니다.\n\n## 2. 파괴할 수 없는 데이터 무결성\n\n위조 방지할 수 있는 감사 트레일에 대해 이야기할 때, 블록체인의 분산형 및 추가 전용 원장은 IoT 센서 네트워크 전체에서 데이터 무결성을 보장하는 데 완벽합니다.\n\n새로운 장치 전송마다 불변의 블록체인 트랜잭션이 생성됩니다. 이 영구 기록은 공급망 모니터링과 같은 사용 사례에서 중요한 역할을 하는 과거 IoT 데이터가 수정되거나 삭제되지 않도록 방지합니다.\n\n<div class=\"content-ad\"></div>\n\n## 3. 분산으로 강화된 탄력성\n\n전통적인 IoT 시스템은 단일 장악 지점이 있는 중앙집중식 제어를 특징으로 하며, 이는 단일 장애 지점을 만들어냅니다. 이 중앙 서버가 다운되면 전체 네트워크가 마비됩니다.\n\n반면, 블록체인은 권한이 없는 분산된 P2P 네트워크로 데이터를 분산합니다. 따라서 특정 노드가 오프라인이 되어도 전체 블록체인/IoT 시스템은 작동 가능하고 탄력적입니다.\n\n## 4. 스마트 계약으로 자동화된 신뢰\n\n<div class=\"content-ad\"></div>\n\n블록체인의 스마트 계약(자체 실행 코드)은 IoT 데이터 스트림에 의해 트리거된 수많은 프로세스와 거래를 자동화할 수 있습니다. 써드파티 검증이 필요하지 않습니다.\n\n예를 들어, 스마트 계약은 미리 정의된 매개 변수에 따라 IoT 센서가 물품이 목적지에 도착했다고 확인하면 자동으로 결제를 해제할 수 있습니다. 이 프로그래밍된 신뢰는 효율성을 향상시킵니다.\n\n## 5. 급진적 투명성\n\n블록체인 네트워크는 모든 허가된 참가자에게 표시되는 공유 및 변경할 수 없는 원장을 유지합니다. 이 투명성은 IoT 이해 관계자들 사이에 신뢰와 책임을 증진하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n유틸리티 제공 업체는 블록체인의 투명성을 활용하여 IoT 기능을 갖춘 스마트 미터링 및 청구 시스템을 구축할 수 있습니다. 이를 통해 고객들은 실시간으로 사용량 데이터를 확인할 수 있습니다.\n\n# 6. 비용 절감\n\n기존의 IoT 시스템은 중앙 서버와 클라우드 서비스에 의존하여 장치 간 통신을 조정하며, 이로 인해 인프라 비용이 발생합니다. 블록체인은 직접적인 P2P 데이터 전송을 용이하게 하는데, 중간 매개 비용을 줄일 수 있습니다.\n\n스마트 시티 센서 네트워크와 같은 대규모 IoT 시스템 배포에서는 본질적으로 분산화된 방식이 클라우드 기반 대안에 비해 주요한 비용 효율성을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n블록체인과 IoT의 잠재적인 장점을 살펴봤으니, 이들이 마주한 장애물을 알아봅시다:\n\n## 블록체인/IoT 통합을 직면한 주요 도전과제\n\n약속은 있지만, 이 두 기술을 통합하는 것은 극복해야 할 난관도 동반하고 있습니다:\n\n### 1. 확장성에 대한 어려움\n\n<div class=\"content-ad\"></div>\n\n블록체인의 가장 큰 한계 중 하나는 처리량 용량이 제한된다는 점입니다. 대부분의 기존 블록체인 플랫폼은 초당 처리할 수 있는 거래의 수가 제한되어 있습니다.\n\n안타깝게도, 이는 수백만 대 또는 수십억 대의 기기에서 지속적으로 데이터를 스트리밍하는 대규모 사물 인터넷(IoT) 배치의 고속 요구사항과는 거리가 멉니다.\n\n이 확장성 병목 현상을 해결하지 못한다면 블록체인/IoT 융합은 거래 지연과 네트워크 혼잡을 일으킬 수 있습니다. 처리량 제한을 극복하는 것은 활발히 연구되는 우선 과제입니다.\n\n## 2. 상호 운용성 미로\n\n<div class=\"content-ad\"></div>\n\nIoT 산업은 다양한 제조업체의 장치, 프로토콜 및 표준으로 이루어진 복잡한 혼합물입니다. 한편, 다양한 블록체인 플랫폼 간에 통일된 표준과 아키텍처가 부족합니다.\n\n이러한 다양한 기술을 통합하여 일관된 블록체인/IoT 솔루션을 만드는 것은 번역 계층, 게이트웨이 및 공개 표준의 도입을 통해 해결해야 할 중대한 상호 운용성 퍼즐입니다.\n\n## 3. 비용 장벽\n\n블록체인은 클라우드 서비스와 같은 일부 운영 비용을 줄일 수 있지만, 그에 따른 비용 요구 사항은 상당합니다. 대부분의 블록체인 네트워크에 참여하려면 전문화된 고성능 컴퓨팅 하드웨어에 투자해야 하며 전력 소비량이 증가하고 더 많은 데이터 저장 공간이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n많은 회사들에게 금융적 장벽을 만드는 초기 투자 비용들이 있습니다. 특히 ROI가 덜 매력적인 낮은 가치의 IoT 자산 추적 사용 사례에 대해서는 더욱 그렇습니다.\n\n# 4. 에너지 낭비\n\n이 투자 비용에 더해, 많은 블록체인 플랫폼은 자원 집약적인 채굴이나 합의 메커니즘을 사용하여 산업 규모에서 전기를 대량으로 소비합니다.\n\n이는 IoT의 절반에 필요한 에너지 효율적이고 저전력 운영과 대조적입니다. 전형적인 IoT 전원 제약과 일치하는 환경 친화적 합의 프로토콜을 찾는 것은 열린 도전입니다.\n\n<div class=\"content-ad\"></div>\n\n# 5. 규정의 모호함 😕\n\n블록체인이 여전히 떠오르는 신기술임에도 불구하고, IoT 시스템과의 통합을 안내할 명확한 법적 프레임워크와 규정이 불행히도 부족합니다.\n\n보안 표준, 데이터 개인정보 보호, 관할권 문제 등에 대한 여전히 불분명한 문제들이 블록체인/IoT 솔루션의 광범위한 기업 채택을 방해하는 불확실성을 야기합니다. 더 많은 지침이 필요합니다.\n\n# 6. 센서 (비)신뢰성\n\n<div class=\"content-ad\"></div>\n\n많은 IoT 사용 사례가 블록체인 거래 및 스마트 계약 이벤트를 유도하기 위해 센서 데이터에 의존합니다. 하지만 물리적 IoT 센서의 품질과 정확성은 결코 완벽하지 않습니다.\n\n센서 드리프트, 보정 문제, 그리고 의도적인 조작과 같은 요소들이 블록체인에 잘못된 데이터를 포함할 수 있습니다. 변하지 않는 원장에 데이터를 기록하기 전에 센서의 무결성을 검증하는 견고한 메커니즘이 필요합니다.\n\n# 7. 스마트 계약의 보안 취약점\n\n신뢰와 자동화의 강력한 기반인 스마트 계약은 그들의 기본 코드만큼 안전하지 않습니다. 코드 취약점으로 인한 스마트 계약 위반은 재진입 버그와 같은 코딩 취약점으로 전체 블록체인 네트워크를 위협할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nIoT 거래가 스마트 계약에 점점 더 의존하게 되는 요즘, 공식 검증, 엄격한 테스트 및 안전한 코딩 관행이 매우 중요합니다.\n\n## 8. 개인 정보 리스크\n\n의료 분야와 같이 민감한 IoT 응용 프로그램의 경우, 공개 블록체인 네트워크에서 제공되는 투명성 자체가 개인 정보 보호 문제를 야기할 수 있습니다.\n\n블록체인은 영구적이고 변경할 수 없는 데이터 트레일을 생성하기 때문에, 악의적인 사용자가 이러한 공개 데이터 스트림을 분석하여 개인 신원이나 행동 패턴을 추측할 수 있는 위험이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n암호화, 개인 블록체인, 그리고 고급 익명 보존 기술을 도입하는 것은 특정 사례에서 사용자 프라이버시를 보호하는 데 필요할 수 있습니다.\n\n도전 과제들은 꽤 어려울 수 있지만, 극복하기 불가능한 것은 아닙니다. 어떻게 선구자들이 주요 문제를 해결하고 있는지 살펴볼까요?\n\n## 장애물 극복하기\n\n산업 고정체와 스타트업 모두 블록체인/IoT의 고통점에 대한 해결책을 성실히 연구하고 개발 중입니다.\n\n<div class=\"content-ad\"></div>\n\n# 처리량 확장\n\n블록체인의 처리량 제약을 완화하기 위해 여러 확장 솔루션이 등장하고 있습니다:\n\n- 샤딩은 네트워크를 작은 파티션으로 분리하여 트랜잭션을 병렬로 처리합니다.\n- Plasma과 같은 Layer 2 기술은 별도의 \"차일드\" 블록체인을 생성하여 본체 외부에서 트랜잭션을 처리합니다.\n- 이더리움 2.0과 같은 주요 프로젝트는 더 효율적인 스테이크 공증 모델로 이전하고 있습니다.\n\n기업들은 일부의 탈중앙화를 희생함으로써 더 높은 처리량을 달성할 수 있는 Hyperledger Fabric와 같은 엔터프라이즈 급 허가형 블록체인을 탐색하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 상호 운용성 강화\n\n다양한 IoT 기기와 블록체인 플랫폼 간의 상호 운용성 과제에 대처하기 위해 다음과 같은 주요 노력이 진행 중입니다:\n\n- Trusted IoT Alliance는 산업 리더들이 참여하여 오픈 소스 블록체인/IoT 통합 표준을 개발\n- 이더리움 기반 Cascadiq 프로젝트는 어떤 IoT 기기도 어떤 블록체인에도 신속하게 연결하는 범용 미들웨어를 제안\n- IONiX와 같은 프레임워크는 다양한 블록체인 및 IoT 통신 프로토콜 간의 번역을 담당\n\n이 통합 표준 및 번역 계층이 점차 보급되면 상호 운용성 장벽이 점차 해소될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 투자 비용 절감\n\n블록체인은 처음에는 상당한 인프라 투자를 요구하지만, 다수의 혁신을 통해 장기적으로 소유 비용을 낮출 수 있습니다:\n\n- Proof-of-Stake와 같은 더 효율적인 합의 모델은 에너지/하드웨어 요구를 줄입니다.\n- 오프체인 계산과 IPFS 저장소와 같은 기술은 온체인 부풀임을 줄입니다.\n- Blockchain-as-a-Service 클라우드 서비스는 유연하고 요금을 지불하는 형식을 가능하게 합니다.\n\n게다가, 제3자 중개업체를 제거함으로써 얻을 수 있는 잠재적인 비용 절감은 다양한 사물 인터넷 사용 사례에서 블록체인 비용을 상쇄할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 지속 가능한 합의 모델\n\n연구자들은 현재 IoT의 저전력 제약에 맞춰 더욱 에너지 효율적인 합의 메커니즘을 개발하고 있습니다:\n\n- 인텔의 Proof-of-Elapsed Time과 같은 프로토콜은 합의를 달성하기 위해 최소한의 컴퓨팅 작업이 필요합니다.\n- Proof-of-Authority와 같은 대체 \"녹색\" 모델은 전력 소비를 더욱 줄일 수 있습니다.\n- IoT용으로 설계된 블록체인인 IOTA는 수수료 없이, 제로 마이닝 작업을 목표로 하고 있습니다.\n\nIoT 기기 근처에서 데이터를 처리하는 엣지 컴퓨팅 아키텍처는 에너지를 많이 소모하는 클라우드 전송을 최소화할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 거버넌스 및 규제 육성\n\n메인스트림 채택을 위해서는 명확한 블록체인/IoT 규제와 산업 전반에 걸친 표준이 중요합니다. 다음과 같은 여러 가지 노력이 진행 중에 있습니다:\n\n- IEEE 및 ISO와 같은 글로벌 기관이 보안, 개인 정보 보호 등을 위한 기술 표준을 개발 중입니다.\n- 유럽 블록체인 파트너십과 같은 정부 블록체인 이니셔티브가 정책을 구성 중입니다.\n- Blockchain in Transport Alliance와 같은 다업종 그룹이 섹터별 지침을 만들어내고 있습니다.\n\n더욱 신뢰할 수 있는 지침이 나올수록 기업 배포를 원활하게 하기 위한 중요한 법적 확증을 제공할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 보안 및 개인 정보 보호 강화\n\n블록체인은 기본적으로 안전한 설계로 되어 있지만, IoT의 독특한 요구 사항은 추가 암호 보호가 필요합니다.\n\n- Trusted execution environments (TEEs)은 블록체인/IoT 통합을 위한 안전한 빈옥으로 작용할 수 있습니다.\n- 제로 지식 증명과 같은 신기술은 블록체인 개인 정보 보호를 가능케 합니다.\n- 형식적 검증 도구는 스마트 계약을 배포하기 전에 수학적으로 확인할 수 있습니다.\n\n계속되는 암호 혁신은 IoT 생태계 전체에 걸쳐 블록체인의 보안 보증을 강화할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이러한 핵심 문제들에 대해 선도적인 R&D 및 산업간 협력을 통해 직면하면, 블록체인/IoT 융합은 조각난 실험에서부터 매끄럽게 상호 운용 가능하고 확장 가능한 현실로 진화하고 있습니다.\n\n## 실제 사용 사례\n\n블록체인과 IoT가 융합되었을 때의 변혁적 잠재력을 설명하기 위해, 몇 가지 강력한 사용 사례를 살펴보겠습니다:\n\n## 공급망 투명성\n\n<div class=\"content-ad\"></div>\n\nIoT 센서와 블록체인을 활용하면 기업들이 최종적으로 진정한 공급망 투명성과 추적성을 달성할 수 있습니다.\n\n예를 들어, 식품 공급업체는 IoT 센서를 사용하여 출하물의 위치, 온도, 습도 및 기타 정보를 모니터링할 수 있으며, 이 모든 데이터를 블록체인에 불변하게 기록할 수 있습니다.\n\n도착 시 소매업체는 제품을 간단히 스캔하여 농장부터 상점까지의 전 과정소유권을 확인할 수 있습니다. 스마트 계약을 통해 온도 위반과 같은 위반 사항에 자동으로 벌금을 부과할 수도 있습니다.\n\nWalmart 및 Maersk와 같은 선구자들은 이미 블록체인/IoT 실험을 통해 공급망 책임성을 높이고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 분산 에너지 그리드\n\n태양 규모소규모 그리드와 같은 분산 에너지 모델은 블록체인의 분산형 기능과 완벽하게 어울립니다.\n\n사물 인터넷 기기는 에너지 생산, 소비, 그리드 상태 등을 실시간으로 모니터링하고 보고할 수 있습니다. 이러한 모든 데이터는 변경할 수 없는 공유 장부에 기록됩니다.\n\n가정에서는 그 이후, 중개인이 필요하지 않은 안전한 스마트 계약을 통해 에너지 과잉을 이웃 또는 공공 시설과 직접 거래할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n파워 레저와 같은 스타트업들은 블록체인 위에 거래형 에너지 플랫폼을 구축했습니다. 브루클린 마이크로그리드 시범 프로젝트는 거주자들 간에 재생 에너지를 지역적으로 거래하는 것을 시연했습니다.\n\n# 의료 및 제약품 공급망\n\n의료 분야는 블록체인의 불변한 데이터 트랙, 신뢰할 수 있는 신원, 안전한 데이터 공유의 장점을 절실히 필요로 합니다.\n\n환자 측면에서 블록체인은 개인이 IoT 웨어러블 및 연결된 장치로부터 의료 데이터를 선택적으로 제공하는 데 도움을 줄 수 있습니다. 이 데이터는 직접 공급자와 공유될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n약품 공급 체인에 대해 블록체인과 사물인터넷(IoT) 기술을 활용하면 모든 제조, 유통 및 처방 과정을 추적하여 위조 약품에 대항할 수 있습니다. 환자들은 그러면 약품의 출처를 암호화하여 확인할 수 있게 될 거예요.\n\nSimplyVital Health와 같은 기업들은 블록체인 기반의 IoT 아키텍처 위에 탈중앙화된 건강 유틸리티 네트워크를 구축하고 있어요.\n\n# 스마트 시티 최적화\n\n지방자치단체들이 스마트 시티 구축에 투자할 때, 블록체인은 대규모로 IoT 센서 데이터 흐름을 조율하는 시냅스 역할을 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n거리등, 교통 신호, 공공시설 미터 등 인프라는 자체적으로 IoT 데이터를 모든 이해관계자들이 공유하는 불변한 블록체인 장부로 보고할 수 있습니다.\n\n이 통합 데이터 저장소는 예측 유지보수부터 적응형 교통 관리, 효율적 자원 할당까지의 차세대 스마트 시티 응용 프로그램을 가능하게 합니다.\n\n바르셀로나, 두바이, 오스틴과 같은 세계 각지의 도시들이 블록체인/IoT 스마트 시티 파일럿 프로젝트를 시작했습니다.\n\n# 산업 자산 관리\n\n<div class=\"content-ad\"></div>\n\n제조업, 건설업, 항공 및 에너지와 같은 자산 집중 산업에서는 블록체인이 IoT 자산 추적과 결합되면 종합적인 수명주기 추적이 가능해집니다.\n\n블록체인 원장에 센서 데이터를 기록함으로써, 기업들은 장비의 위치, 사용, 유지보수 등에 대한 감사 가능한 이력을 얻을 수 있습니다.\n\n스마트 계약을 통해 실시간 IoT 상태 데이터를 기반으로 예방 정비, 부품 주문 및 서비스 일정을 자동화할 수도 있습니다.\n\nBoeing과 같은 주요 기업들은 유지보수 작업과 부품 추적을 최적화하기 위해 블록체인/IoT를 탐구하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 자율 장치 경제\n\n앞으로 블록체인의 신뢰 없는 동등 피어간 기능은 자율 주행 자동차, 드론, 로봇과 같은 장치들이 완전히 협력하는 전체 경제를 가능하게 할 수 있습니다.\n\n이러한 장치들은 블록체인을 활용하여 사람 개입 없이도 교통, 유지보수, 계산, 에너지 등의 서비스를 안전하게 인증, 협상 및 결제할 수 있습니다.\n\n이러한 \"분산된 기계 네트워크\"는 산업 프로세스와 이동 서비스를 최적화하는 것은 오늘날에는 SF 영화 같아 보일 수 있지만, 이는 블록체인/IoT 융합의 자연스러운 진화입니다.\n\n<div class=\"content-ad\"></div>\n\n아직도 막대한 도전이 남아 있지만, 이러한 혁신적인 사용 사례들은 블록체인이 IoT 생태계에 투명성, 자동화, 그리고 신뢰를 가져다 줄 잠재력을 보여줍니다.\n\n## 주요 내용\n\n- 블록체인은 IoT 보안, 데이터 무결성, 자동화, 투명성, 그리고 회복력을 향상시킵니다 :shield:\n- 하지만 주요한 블록체인/IoT 장벽으로는 확장성, 상호 운용성, 비용, 그리고 규제가 있습니다 :warning:\n- 카팅 엣지 솔루션들이 이러한 장애물을 극복하기 위해 등장하고 있습니다 :muscle:\n- 실제 사용 사례들이 공급망, 에너지, 의료 및 기타 분야에 미치는 잠재적 영향을 강조합니다 :bulb:\n- 장기적으로 블록체인/IoT 융합을 통해 탈 중앙화 된 자율 기계 경제를 가능하게 할 수 있습니다 :factory:\n\n## 미래 전망\n\n<div class=\"content-ad\"></div>\n\n앞서 언급한 확장성, 상호 운용성, 비용, 에너지, 규정, 그리고 보안과 관련된 도전에 대한 대처가 계속되는 가운데, 블록체인과 사물 인터넷이 밀접하게 얽혀진 미래를 상상할 수 있습니다. :sparkles:\n\n일부 미래 가능성에는 다음과 같은 것들이 있습니다:\n\n## 분산 자율 조직\n\n블록체인 스마트 계약의 자동화와 사물 인터넷 센서 데이터의 결합은 새로운 분산 자율 조직 (DAOs)을 만들어 낼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n자율 공급망이 상상되나요? 블록체인 상에서 상호 연결된 IoT 장치들이 거래하며 인간 감독 없이도 자율적으로 운영되는 모습을 상상해 보세요. 기업의 계층 구조와 프로세스마저도 간소화된 코드로 운영되는 시스템으로 대체될 수 있습니다.\n\n# 탄력 있는 메시 네트워크\n\n중앙 집중식 클라이언트-서버 모델 대신, 미래의 IoT 네트워크는 견고한 메시 아키텍처로 구성될 수 있습니다. 장치들이 블록체인 상에서 상호 통신하며 중앙 집중식이 아닌 P2P 방식으로 동작하는 구조입니다.\n\n이는 단일 장애 지점을 제거하고, 주변 노드들이 오프라인 피어를 우회하도록 하는 것을 의미합니다. 블록체인을 통해 유연한 메시 네트워크 상에서 안전한 노드 인증과 데이터 라우팅을 제공할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 분산 AI 및 분석\n\n블록체인에 집약된 통합 센서 데이터 스트림은 산업 및 지리적으로 공유되는 경우 강력한 협업 AI 및 분석 기능을 발휘할 수 있습니다.\n\n독점적인 데이터 대신 열린 불변의 \"블록체인 데이터 마켓플레이스\"가 나타날 수 있어 이를 통해 이해력 있는 AI 모델을 확보하고 IoT 데이터를 활용하여 이해력 있는 AI 모델을 크라우드소싱할 수 있습니다.\n\n# 민주화된 기계경제\n\n<div class=\"content-ad\"></div>\n\n결국, 블록체인이 신뢰를 자동화하는 능력은 자율적인 장치들이 인간의 개입 없이 거래하고 협력할 수 있는 새로운 \"기계 경제\"를 일으킬 수도 있습니다.\n\n자율주행 차량, 드론, 로봇 등의 군대는 블록체인의 변경할 수 없는 감사 트레일을 활용하여 자신들의 서비스, 계산, 자원 공유를 매끄럽게 협상할 수 있습니다.\n\n공급망, 스마트 시티, 이동 서비스 및 기타 경제 엔진을 통해 발생하는 마찰 없는 기계 간 협업은 물류, 운송, 에너지 사용 등을 이전에 불가능했던 놀라운 효율적인 방법으로 최적화할 수 있을 것입니다.\n\n블록체인은 오늘날의 관료주의적 과정과 느린 중개인 대신 기계 간의 순간적인 가치 교환과 협조의 새로운 패러다임을 가능하게 하여, 참으로 자율적인 산업 운영과 비즈니스 모델의 미래를 열어줄 것입니다.\n\n<div class=\"content-ad\"></div>\n\n물론, 이러한 급진적인 비전을 실현하기 위해서는 남아 있는 기술적, 규제적 및 사회적 장벽을 극복해야 할 것입니다. 그러나 블록체인과 사물인터넷 혁신의 끊임없는 속도로, 이러한 원활한 기계 경제가 예상보다 빨리 나타날 수 있습니다.\n\n기술 변화의 기회를 포용하면서 리스크를 줄이면, 변혁적 기술의 융합은 공급망, 이동성, 에너지 및 그 이상에서 경제적 권력을 재분배할 수 있는 시대를 촉매할 수 있습니다.\n\n가능성은 거의 무한합니다.\n\n이런 미래에 대한 업데이트를 기대해 주세요. 그리고 이 신기술의 선두에 대한 짧은 시사를 찾으셨다면, 이 글을 공유하는 데 도움이 되기 위해 박수 버튼을 눌러 주세요!\n\n<div class=\"content-ad\"></div>\n\n더 흥미로운 콘텐츠를 읽고 싶다면 꼭 제 블로그를 확인해보세요.","ogImage":{"url":"/assets/img/2024-06-19-UnlockingIoTsPotentialwithBlockchainBenefitsObstacles_0.png"},"coverImage":"/assets/img/2024-06-19-UnlockingIoTsPotentialwithBlockchainBenefitsObstacles_0.png","tag":["Tech"],"readingTime":12},{"title":"내 소개  Grace","description":"","date":"2024-06-19 16:45","slug":"2024-06-19-AboutMeGrace","content":"\n\n![Grace's profile picture](/assets/img/2024-06-19-AboutMeGrace_0.png)\n\n먼저, 세 번째 사람으로 쓰는 것을 싫어하지만 이렇게 써야겠네요...\n\nGrace는 군인 가족에서 자란 경험으로 인해 다양성에 대한 깊은 감사함과 모든 삶의 영역에서 개인들을 진실로 존중하는 태도를 갖추었습니다. 주변의 다양한 문화에 노출되어 성장한 과정에서 여행을 사랑하게 되었으며 다양한 배경을 가진 사람들과의 인연을 형성하는 데 흥미를 느끼게 되었습니다.\n\n앨리드 헬스 사이언스 학사와 데브리 대학교에서 기술 경영학 학사 학위를 취득한 Grace는 다양한 분야에서 독특한 시각을 제공합니다. 그녀의 글은 자기계발, 정신 건강, 비즈니스, 경영 및 기술이 기업 환경에서 통합되는 주제를 포함하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n날카로운 지성과 꾸준한 탐구 정신에 이끌리는 그레이스는 새로운 주제와 떠오르는 기술에 몰두하는 열정적인 연구자입니다. 역사적 사건의 복잡성을 파헤치거나 최신 기술의 발전을 탐구할 때도, 그녀는 각 주제에 열정적인 역량으로 다가가며 스스로의 이해력을 넓히고 개인 성장과 전문적 노력을 풍성하게 만듭니다.\n\n직업 외적으로 그레이스는 헌신적인 어머니로서의 역할을 가장 중요시합니다. 기업가의 책임과 부모로서의 즐거움을 균형 있게 유지하면서, 따뜻함, 공감, 의도를 프로젝트에 들어내어 독특한 시각을 선보입니다. 글쓰기와 출판 사업을 통해 다른 이들에게 자기 계발과 도전을 통해 삶의 어려움을 극복하고 소망을 이루기 위한 도구와 영감을 제공하고자 합니다.\n\nPurpose Publisher에서 그레이스는 의미 있는 이야기에 심취한 비전을 가진 리더로 자리매깁니다. 각 출판물은 그녀가 듣지 못할 수도 있는 목소리를 높여주는 헌신을 반영합니다. 일관된 진실성과 성실함에 대한 그녀의 헌신은 동료와 독자들의 존경과 칭찬을 받으며 작업 전반에 울려 퍼집니다.\n\n상업적 이해와 일시적 트렌드에 주도되는 산업 속에서 그레이스는 창조성, 동정심, 또한 탄탄한 헌신의 전형으로 빛나는 존재입니다. 문학과 학습에 대한 끈기있는 열정으로 출판 산업을 이끌어가며, 세계의 독자들의 마음에 영원한 흔적을 남기고 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-AboutMeGrace_0.png"},"coverImage":"/assets/img/2024-06-19-AboutMeGrace_0.png","tag":["Tech"],"readingTime":2},{"title":"탑 블로거 MrBeast가 이 방법을 사용하여 수백만을 벌어요","description":"","date":"2024-06-19 16:44","slug":"2024-06-19-TopVloggerMrBeastMakesMillionsUsingThisApproach","content":"\n\n마케팅 전략은 그의 팬들을 늘리는 데 도움이 됩니다.\n\n![MrBeast](/assets/img/2024-06-19-TopVloggerMrBeastMakesMillionsUsingThisApproach_0.png)\n\n누구죠, MrBeast는? 아니면 MrBeast는 무엇인가요? 지난 몇 년 동안 이 이름을 종종 들어왔지만 YouTube에서 돈을 벌기 위한 가장 좋은 방법을 연구하기 시작할 때, 돈을 벌어들이는 놀라운 YouTube 채널 MrBeast를 발견하게 되었습니다.\n\n일요일 오후를 보낼 때 활기찬, 매력적인 젊은 남자가 진행하는 몇 가지 영상을 살펴보았습니다. 본 영상 중에 젊은 남자가 수 많은 돈을 나눠주는 내용도 있었고, 게임 요소도 함께 들어가 있었습니다. 이 독특하고 놀라운 채널에 대해 더 많은 사람들이 들어봐야 하는 건 아닐까요? 아마도, 나뿐일 수도 있습니다. 사실 몇 년 전, 인기를 얻기 전에 한 명의 팬 스타 아티스트는 공연 뒤에 지역 댄스 클럽에서 춤을 추곤 했습니다. 몇 년이 흘렀을 때, 그녀가 국가적 뉴스 앵커에 의해 마지막 이야기에 추가되었을 때 큰 성공을 거둔 줄 알았습니다. 레이디 가가죠. 사람들이 가가해지는 순간이 시작되었습니다.\n\n<div class=\"content-ad\"></div>\n\nMrBeast에 대해 다시 이야기해보겠습니다. 그가 주최하는 이벤트가 대부분 자선활동과 관련이 있다는 사실이 정말 흥미롭다고 생각해요. 어느 날, 그가 국립 뉴스를 하게 될지도 모르겠죠.\n\n- 한 에피소드에서, 그가 한 젊은 남자에게 $10,000을 주었어요. 그 남자는 가게에 밤을 지낼 것에 동의했기 때문에 추가 금전도 받았어요. 꽤 쉬워보였어요.\n- 다른 에피소드에서는 그가 뱀들과 함께 나오지만요. 그는 뱀에 대한 공포를 극복하고 돈을 받을 수 있을까요?\n- 또 다른 에피소드에서는 그가 또 한 번 자선활동을 통해 많은 동물을 구했다고 합니다.\n\n그는 최근에 1000대의 휴대폰을 구입하고, 구독한 사람들에게 모두 나눠줄 것이라고 약속했어요. 그 행동에 감동받아, 저도 구독했답니다!\n\n그의 채널 중 하나는 '비스트 자선활동'이라고 적절하게 이름 지었습니다. 이 채널은 남아프리카에 있는 고아원을 입양하거나, 과테말라에 튼튼한 마을을 건설하여 주민들이 환경으로부터 보호받을 수 있도록 하는 등 높이 평가받는 자선활동을 소개하고 있어요.\n\n<div class=\"content-ad\"></div>\n\n## 너에 대해 잘 몰라도 난 이게 미친 것 같고, 이것 때문에 인류에 대한 긍정적인 생각이 들어.\n\nMrBeast에 대해 들어봤니? 그의 행동에 대해 어떻게 생각해?\n\n또 다른 좋은 점은 진행자가 매력적으로 보인다는 거야! 누가 돈을 쏟아 주는 남자를 싫어하겠어?\n\n안타깝게도, 그는 미국에 살고 있어. 그래서 그의 비디오에 참가하고 돈을 받기는 좀 어려울 거야. 그래니까 이사 가거나 해야 하거든. 그런데 MrBeast는 꽤 이동이 잘 되는 것 같아, 그래서 얼마든지 당신 근처의 도시나 마을에 올 수도 있을 거야.\n\n<div class=\"content-ad\"></div>\n\n## MrBeast에 대한 정보.\n\n그의 이름은 제임스 스티븐 도널드슨이며, 26세에만 유튜브 구독자 수가 2억 7700만 명으로 유튜브에서 가장 많은 구독자를 보유한 채널 중 하나입니다.\n\n그가 왜 성공적인지 궁금하다면, 한 마케팅 블로거가 다음과 같이 정리했습니다:\n\n## 흥미로운 콘텐츠 작성\n\n<div class=\"content-ad\"></div>\n\nMrBeast는 멋진 이야기꾼이자 멋진 제목을 가진 사람입니다. 시간이 없다면 짧은 영상부터 긴 영상까지 볼 수 있어요.\n\n## 바이럴 트렌드에 적응\n\n그 중 하나의 영상은 Netflix에서 인기를 끌던 Squid Game과 비슷한 챌린지를 도입했어요.\n\n## 커뮤니티 확장과 팬과 소통하기\n\n<div class=\"content-ad\"></div>\n\n그는 우리 사람들을 좋아하는 것 같아요. 새 가입자들에게 핸드폰을 쏜다는 건 충격적이고 핸드폰 사용자에게 매력적입니다.\n\n## 비디오 업로드 마스터하기\n\n이 마케팅 블로거는 자신의 제목 작성 기술이 마케팅 스킬의 달인이라고 느낍니다. 그의 섬네일 당 투자액은 $10,000이라고 합니다.\n\n이 블로거의 목소리를 들어봐요. 그의 MrBeast 사이트에는 구인 공고가 게시되어 있는데, 그는 자신의 미션 스테이트먼트로 유머, 스펙터클, 일반적인 선한 행동, 자선을 제공하는 것이라고 말합니다.\n\n<div class=\"content-ad\"></div>\n\n저의 주관적인 견해로는, 그의 대상 청중은 10살 어린이부터 밀레니얼 세대, 할머니, 테크 팬들까지 누구든지 포함되어 있습니다.\n\n어떻게 하면 돈을 벌 수 있을까요?\n\n매월 약 300만 달러에서 500만 달러 사이를 광고 수익과 유료 스폰서십을 통해 벌어들인다고 보도되었습니다.\n\n유튜브에서 돈을 벌기에 진지한 사람이라면 꼭 MrBeast 채널과 같은 인기 있는 블로거를 확인해보는 게 좋겠어요.\n\n<div class=\"content-ad\"></div>\n\n언젠가는 TV 스튜디오를 사거나 더 큰 야망을 키울 수도 있을 것 같아요. 대통령 후보 MrBeast? 어떻게 생각하세요?\n\n만약 그가 모든 것을 혼자 했다고 생각했다면, 다시 생각해보세요. 그를 도와주는 전문가 팀이 있어요. 미국에 거주하거나 이사할 의지가 있다면, 그가 당신을 고용할 수도 있답니다!\n\n그가 채용하려는 사람들은 3D 디자이너, 캐스팅 프로듀서, 컨셉 아티스트, 크리에이티브 프로듀서 등이 있어요. 자격이 부족하다고 생각된다면, YouTube나 다른 경험을 기재할 수 있는 오픈 지원서를 통해 신청할 수 있어요.\n\n이상으로 오늘은 마칩니다.\n\n<div class=\"content-ad\"></div>\n\n이메일을 통해 제 최신 기사를 받아보실 수도 있습니다. 삶의 큰 신비를 생각해보게 하는 이야기를 제공하기 위해 노력하고 있어요. 제 블로그를 구독해주시면 더 많은 영감을 주는 이야기를 제공할 수 있도록 격려받게 됩니다.\n\n제 마지막 이야기도 확인해보세요:","ogImage":{"url":"/assets/img/2024-06-19-TopVloggerMrBeastMakesMillionsUsingThisApproach_0.png"},"coverImage":"/assets/img/2024-06-19-TopVloggerMrBeastMakesMillionsUsingThisApproach_0.png","tag":["Tech"],"readingTime":3},{"title":"로라WAN 없이 LoRa 사용하기","description":"","date":"2024-06-19 16:43","slug":"2024-06-19-UsingLoRawithoutLoRaWAN","content":"\n\n<img src=\"/assets/img/2024-06-19-UsingLoRawithoutLoRaWAN_0.png\" />\n\n이전 게시물에서는 LoRa가 무엇인지, LoRa가 다른 변조 방식과 어떻게 비교되는지에 대해 언급했습니다. 이번 포스트에서는 LoRa 위에 LoRaWAN 프로토콜을 사용하는 것과 \"원시\" LoRa를 사용하는 것 간의 차이점에 초점을 맞출 것입니다.\n\n# 왜 나의 말을 들어봐야 할까요?\n\n자세한 내용은 이전 게시물을 참조하십시오. 간단히 말하면: 나의 LoRa 여정은 약 10년 전 (2023년 11월 기준) IBM 연구소에서 시작되었으며, 거기서 제 전직 동료 두 명이 실제로 LoRaWAN 표준을 (공동으로) 작성한 것을 확인할 수 있습니다 — LoRaWAN 1.0의 두 번째 페이지를 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n# LoRa를 사용하려면 LoRaWAN이 필요한가요?\n\n아니요, 그렇지 않아요. 하지만 LoRaWAN이 좋은 솔루션인 경우도 있어요. 'WAN'이라는 이름이 붙은 이유가 있어요. LoRa를 광역 네트워크에서 사용할 계획이라면, LoRaWAN이 적합해요.\n\n그런데 WAN이 얼마나 넓은지 궁금하신가요? LoRaWAN은 전국 규모 네트워크를 운영하는 회사들이나 실제 이동 통신망 운영자들이 운영하도록 설계되었어요. 하지만 장거리 통신이 중요한 사설 네트워크에서도 많이 사용되고 있어요. 사설 네트워크에서의 면적은 일반적으로 한 사이트에 해당해요. 한 사이트가 공장 바닥이나 작은 유럽 국가 크기의 오스트레일리아 농장일 수 있다는 걸 어렵게 깨달았어요.\n\n귀하의 사용 사례가 광역 네트워크가 아니라면, LoRaWAN이 필요하지 않을 확률이 높아요.\n\n<div class=\"content-ad\"></div>\n\n# LoRa가 스스로 서 있을 수 있는 곳은?\n\nLoRa는 피어 투 피어 연결에 효과적으로 사용될 수 있습니다. 이른바 초기에는 LoRa를 통해 멀리 떨어진 곳에서 쿼드콥터를 조종하는 것에 열광하는 사람들이 있었습니다. 그들은 각 LoRa 프레임에 조이스틱 제어 값을 담아 실제 프로토콜 없이 작동시켰습니다!\n\nLoRaWAN은 스타 형태의 네트워크이지만, 필요에 따라 LoRa 위에 메시 네트워크를 운영하는 것을 방해하는 것은 없습니다.\n\nLoRa는 대부분 ~900MHz 대역에서 사용되지만, 규제가 허용하는 한 다른 주파수에서도 작동시킬 수 있습니다. 이를테면 비지구 네트워크 중 일부가 실제로 그렇게 했어요.\n\n<div class=\"content-ad\"></div>\n\n일반화하는 것은 여기까지입니다. 이제 LoRa를 물리적 계층으로 사용하는 몇 가지 구체적인 사용 사례를 살펴보겠습니다.\n\n# LoRa를 사용하는 Non-LoRaWAN 프로토콜\n\n## Amazon Sidewalk\n\nAmazon Echo 중 많은 제품이 내장 LoRa 라디오를 사용한다는 사실을 알고 계셨나요? 이 라디오 위에서 실행되는 네트워크는 Sidewalk라고 합니다. 상세 내용이 공식적으로 발표되기 전에 예전에 저는 그에 대해 글을 썼습니다. Sidewalk는 LoRaWAN과 많은 유사점이 있지만 LoRaWAN은 아닙니다.\n\n<div class=\"content-ad\"></div>\n\nLoRaWAN을 사용하지 않는 이유에 대한 추측은 게이트웨이 칩의 비용 때문이라고 생각해요. Echos는 값싼 가격에 판매되고 있기 때문에, SX130x를 사용하면 상업적으로 가능한 범위를 넘어설 수 있을 거에요.\n\n## Meshtastic\n\nLoRa 위에 메쉬 네트워크를 운영할 수 있다고 했나요? 사실 LoRa 기반의 메쉬 네트워크인 Meshtastic에 대한 전체 생태계가 있는데요.\n\n제가 아는 바로는, Meshtastic은 주로 이동통신망 범위가 없는 지역이나, 사람들에게 연락이 어렵거나 비상 시에 사용됩니다. 자원봉사자들이 지원하고 있기 때문에 비천연적인 솔루션의 서비스 수준을 비교할 수 없지만, LoRa의 좋은 비용 효율적 사용 사례라고 할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n## 링크 랩스\n\n링크 랩스는 몇 년 동안 많은 변화를 겪었습니다. 나는 처음으로 그들을 2015년에 만났는데, 그 당시에는 LoRa 위에 US 전용 MAC 레이어를 개척하고 있었으며, 이는 LoRaWAN이 아니었습니다.\n\n미국 915MHz 주파수 대역의 규정은 유럽의 868MHz 주파수 대역 사용을 관리하는 규정과 매우 다릅니다. 만약 당신의 제품이 미국 시장에 집중된 경우, 링크 랩스와 마찬가지로 미국 규정을 더 잘 반영하는 MAC 레이어를 실행할 수 있을 것입니다.\n\n## 차량이동식 스마트 미터링\n\n<div class=\"content-ad\"></div>\n\n이전에는 도로변 스마트 미터링 유즈 케이스에 참여하여, 정기적인 LoRaWAN 게이트웨이 인프라가 필요하지만 불가능한 것으로 판명되었어요.\n\n그 목표는 수동 미터 독서 차량을 대체하여 LoRaWAN을 통해 데이터를 수집하는 것이었어요. 계획 단계에서 100% 커버리지를 얻기 위해 LoRaWAN 게이트웨이를 배치하는 것이 경제적이지 않다는 것이 밝혀졌고, 결과적으로 도로변 차량 전체를 폐지하기 위한 방안이 이루어지지 않았어요.\n\n그래서 LoRaWAN 대신, 회사는 그냥 주기적으로 미터 값들을 브로드캐스트하는 LoRa를 사용하기로 결정했어요. 도로변 차량은 크기가 줄고 LoRa 장치로 업그레이드되어 무선으로 미터링 데이터를 수집하게 되었어요.\n\n[비꼬는 말] 아직도 이 유즈 케이스가 동네 주변을 비행하는 자율 드론으로 고도화되어 미터링 데이터를 수집하기를 기다리고 있어요. [비꼬는 말 끝]\n\n<div class=\"content-ad\"></div>\n\n## 스마트 조명\n\n거리 조명은 특별한 도전을 가지고 있습니다. LoRaWAN으로 스마트 조명으로 업그레이드하려면 모든 장치에 시야를 가지고 있거나 반사되는 것이 필요합니다.\n\n밀도가 높은 도심 지역의 긴 거리를 업그레이드하는 경우, 결국 시야 범위를 넘어설 것이고, 반사로 인해 운이 없어질 수도 있습니다. 특히, 게이트웨이를 거리 수준에 배치하는 경우 더 그렇습니다.\n\n다행히도 배터리 전원이 고갈되는 것에 대해 걱정할 필요가 없습니다. 최종적으로, 저는 작업한 사용 사례에서 게이트웨이를 신뢰할 수 있는 방식으로 모든 조명을 커버하도록 배치하려는 것보다, LoRa 프레임을 거리 조명에서 거리 조명으로 홉할 수 있는 브로드캐스트/멀티캐스트 가능한 망를 배치하는 것이 더 쉽다는 것을 알게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n한 개의 메쉬 노드가 메쉬를 관리 시스템에 연결하는 게이트웨이 역할을 하게 됩니다.\n\n## 2.4 GHz LoRa\n\n인기 있는 서브-GHz 대역 외의 다른 주파수에서 LoRa에 대해 들어보았을 수 있습니다. 그 중 하나는 2.4 GHz에서의 LoRa이며, Semtech에서 이미 사용 가능한 칩 포트폴리오를 갖고 있습니다.\n\n2.4 GHz용 LoRaWAN 규격이 없다는 점을 감안하면, 어떤 경우에도 자체 프로토콜을 개발해야 합니다. 물론 LoRaWAN의 재사용 가능한 부분을 2.4 GHz 물리 계층(PHY)으로 이식할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n어쨌든, 2.4 GHz PHY는 서브-GHz 대응편과는 다른 전략을 가지고 있어요.\n\n2.4 GHz LoRa를 블루투스에 조금 더 범위를 늘린 것이라고 생각해볼 수도 있고, 대역폭이 조금 더 작을 수도 있어요. 무엇보다도, 2.4 GHz LoRa 칩은 블루투스 호환 모드를 보유하고 있어요.\n\n## 위성 직통 LoRa\n\n마지막으로 소개할 비-LoRaWAN 사용 사례는 위성과 직접 통신하는 것이에요.\n\n<div class=\"content-ad\"></div>\n\n위성의 문제는 그들이 많은 잡음을 듣는다는 것입니다. 그들의 시야는 정말 세계 밖이기 때문이죠. 그게 아니라, 우주에서 대규모 장치 집단으로 다운링크를 보내는 것은 어렵습니다. 그것은 그 거리에서 좁은 무선 빔으로 단일 장치를 타겟팅하는 것이 어려워서입니다.\n\n즉, 많은 비지구 네트워크(NTN)는 LoRaWAN 호환성을 가지고 있을 수 있지만 (프레임은 LoRaWAN처럼 보일 것입니다), 그들은 상향링크 방향(장치-위성)에 중점을 둘 수 있으며 LoRaWAN의 모든 다운링크(위성-장치) 기능을 지원할 수 없을 수도 있습니다. 따라서 LoRaWAN에 충분히 가깝지만 완전하지는 않습니다.\n\n# LoRaWAN(및 LoRa)의 범위를 넘어서 무엇이 있는가?\n\nLoRaWAN을 통해 비디오를 스트리밍할 수 없습니다.\n실제로 LoRaWAN을 통해 오디오를 스트리밍하면 안 됩니다.\n그리고 파일을 보내면 안 됩니다 - 비둘기가 더 빠를 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n일반적으로, 스트리밍으로 레이블 지정할 수 있는 모든 사용 사례는 LoRaWAN과는 잘 맞지 않습니다. 킬로바이트나 메가바이트보다는 수십바이트를 생각해보세요.\n\n# LoRa로는 어떤 것들이 가능할까요?\n\nLoRa (LoRaWAN 없이)를 사용하면 훨씬 더 많은 자유가 주어집니다. 비디오 스트리밍을 기대해서는 안 되지만, 주파수 대역과 사용 가능한 채널 대역폭에 따라서 LoRaWAN보다 훨씬 높은 데이터 전송 속도를 제공받을 수도 있습니다.\n\n따라서, LoRa의 범위를 넘는 것에 대해 일반적인 진술은 하지 않겠습니다. LoRaWAN으로는 불가능하지만 멋진 LoRa 기반 사용 사례가 있다면 공유해 주세요! LoRa가 한계까지 이끌어지는 사용 사례에 대해 배우는 것을 고대하고 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-UsingLoRawithoutLoRaWAN_0.png"},"coverImage":"/assets/img/2024-06-19-UsingLoRawithoutLoRaWAN_0.png","tag":["Tech"],"readingTime":5},{"title":"인터넷 오브 씽스IoT란 무엇인가요","description":"","date":"2024-06-19 16:41","slug":"2024-06-19-WhatistheInternetofThings","content":"\n\n\n![What is the Internet of Things](/assets/img/2024-06-19-WhatistheInternetofThings_0.png)\n\n'인터넷 물건'이라는 용어는 1999년 Kevin Ashton에 의해 만들어졌으며, 센서를 통해 인터넷을 물리적 세계에 연결하는 것을 지칭합니다. 그 이후로 이 용어는 일반적으로 센서에서 데이터를 수집하거나 액츄에이터(스위치를 켜거나 LED를 켜는 것과 같은 동작을 하는 장치)를 통해 실제 세계와 상호작용하는 장치로 설명하기 위해 사용되었습니다. 이러한 장치들은 일반적으로 다른 장치나 인터넷에 연결되어 있습니다.\n\nIoT는 장치뿐만 아니라 클라우드 기반 서비스도 포함하며, 이 서비스는 센서 데이터를 처리하거나 요청을 보내는 기능을 포함합니다. 또한 IoT 장치에 연결된 액츄에이터에도 해당됩니다. 또한 인터넷 연결이 필요하지 않은 장치 또는 인터넷 연결이 없는 장치들도 포함되며, 이는 종종 엣지 장치(edge devices)로 알려져 있습니다. 이러한 장치들은 클라우드에서 훈련된 AI 모델을 사용하여 일반적으로 센서 데이터를 처리하고 응답할 수 있는 장치입니다.\n\nIoT는 빠르게 성장하고 있는 기술 분야입니다. 2020년 말까지 30억 개의 IoT 장치가 배포되어 인터넷에 연결되었다고 추정됩니다. 미래를 전망해보면, 2025년까지 IoT 장치가 거의 80 젯바이트 또는 80조 기가바이트의 데이터를 수집하고 있다는 것이 추정됩니다. 정말 방대한 양의 데이터죠!\n\n\n<div class=\"content-ad\"></div>\n\n# IoT 장치\n\n![IoT Devices](/assets/img/2024-06-19-WhatistheInternetofThings_1.png)\n\nIoT에서의 T는 '사물'을 나타냅니다. 주변의 물리적 세계와 상호작용하는 장치들입니다. 센서에서 데이터를 수집하거나 액추에이터를 통해 실제 세상과 상호작용을 제공하는 방식으로 작동합니다.\n\n생산이나 상업용 장치인 소비자 피트니스 트래커나 산업용 기계 컨트롤러와 같은 장치들은 보통 맞춤형으로 제작됩니다. 특정 작업의 요구 사항을 충족시키기 위해 설계된 사용자 정의 회로 기판, 때로는 사용자 정의 프로세서를 사용할 수 있습니다. 그 작업이 팔목에 맞게 충분히 작고 높은 온도, 고압력 또는 높은 진동 공장 환경에서 작동하기 충분히 견고해야 할지라도요.\n\n<div class=\"content-ad\"></div>\n\nIoT나 장치 프로토타입을 만들 때는 개발 키트로 시작해야 합니다. 이들은 개발자를 위해 설계된 범용 IoT 장치로, 종종 제품 장치에는 없는 기능이 포함되어 있습니다. 예를 들어 센서나 구동기를 연결할 수 있는 외부 핀 세트, 디버깅을 지원하는 하드웨어, 대량 제조 시 불필요한 비용이 추가되는 추가 자원 등이 있습니다.\n\nIoT는 여러 분야의 다양한 사용 사례를 아우르며, 크게 네 가지 그룹으로 나눌 수 있습니다:\n\n- 소비자 IoT\n- 상용 IoT\n- 산업용 IoT\n- 인프라 구축 IoT\n\n## 소비자 IoT\n\n<div class=\"content-ad\"></div>\n\n소비자 IoT는 소비자가 구매하고 집 주변에서 사용하는 IoT 기기를 가리킵니다. 이러한 기기 중 일부는 매우 유용하며, 스마트 스피커, 스마트 난방 시스템 및 로봇 진공 청소기와 같습니다. 다른 기기는 의문을 일으키는데, 음성으로 제어되는 수전이 그것 때문에 소리가 크게 울리는 경우 끌 수 없다는 의미입니다.\n\n소비자 IoT 기기는 주변 환경에서 더 많은 것을 이룰 수 있도록 돕습니다, 특히 장애를 가진 10억 명에게.\n\n## 상업용 IoT\n\n상업용 IoT는 직장에서의 IoT 사용을 다룹니다. 사무실 환경에서는 조명과 난방을 관리하기 위한 층 점유 센서와 움직임 감지기가 있을 수 있습니다. 필요하지 않을 때에만 조명과 난방을 꺼두어 비용과 탄소 배출량을 줄일 수 있습니다. 공장에서는 IoT 기기가 안전 위험을 모니터링할 수 있습니다. 예를 들어, 작업자가 안전모를 쓰지 않거나 소음이 위험 수준에 도달한 경우입니다.\n\n<div class=\"content-ad\"></div>\n\n소매업에서 IoT 장치는 냉동보관의 온도를 측정하여, 냉장고나 냉동고가 필요한 온도 범위를 벗어나면 가게 주인에게 알릴 수 있습니다. 또는 선반에 있는 물품들을 모니터링하여 판매된 농산물을 보충할 때 직원을 안내하는 것도 가능합니다. 운송 산업은 차량 위치를 모니터링하거나 도로 사용자 요금 청구를 위해 도로 주행 마일리지를 추적하며, 운전자의 운전 시간 및 휴식 준수를 추적하고, 차량이 입고 또는 출고 준비를 위해 창고에 접근할 때 직원에게 통보하는 데 IoT를 점점 더 많이 활용하고 있습니다.\n\n## 산업용 IoT\n\n산업용 IoT 또는 IIoT는 대규모로 기계를 제어하고 관리하기 위해 IoT 장치를 사용하는 것을 말합니다. 이는 공장부터 디지털 농업까지 다양한 사용 사례를 커버합니다.\n\n공장에서는 IoT 장치를 여러 센서로 모니터링하여 기계의 온도, 진동 및 회전 속도와 같은 것들을 추적할 수 있습니다. 이 데이터는 기계가 일정한 허용 한계를 넘어가게 되면 멈출 수 있도록 하기 위해 모니터링됩니다. 예를 들어 과열되면 종료되는 등의 상황이 있을 수 있습니다. 또한 이 데이터는 시간이 지남에 따라 수집되고 분석되어, AI 모델이 고장 발생 전 데이터를 분석하고, 이를 사용하여 다른 고장이 발생하기 전에 예측하는 예방 정비를 수행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 인프라 IoT\n\n인프라 IoT는 사람들이 매일 사용하는 지역 및 전역 인프라를 모니터링하고 제어하는 것을 말합니다. 스마트 시티는 도시에 대한 데이터를 수집하고 그것을 사용하여 도시 운영을 개선하는 IoT 장치를 사용하는 도시입니다. 이러한 도시들은 일반적으로 지방 정부, 학계 및 지역 기업 간의 협력을 통해 운영되며, 교통부터 주차장 및 공해까지 여러 가지를 추적하고 관리합니다. 예를 들어, 덴마크의 코펜하겐에서는 대기 오염이 지역 주민에게 중요합니다. 따라서, 대기 오염이 측정되며, 해당 데이터는 가장 깨끗한 자전거 타기 및 조깅 경로에 대한 정보를 제공하는 데 사용됩니다.\n\n## 주변에 있는 IoT 장치 예시\n\n<img src=\"/assets/img/2024-06-19-WhatistheInternetofThings_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n당신이 주변에 가지고 있는 IoT 장치의 수에 대해 궁금할 만큼 놀랄 것입니다. 저는 집에서 이 글을 쓰고 있는데, 인터넷에 연결되어 스마트 기능을 가진 다음과 같은 장치들이 있어요. 앱 제어, 음성 제어, 또는 전화로 데이터를 보낼 수 있는 기능이 있는 장치들입니다.\n\n이러한 유형의 장치들은 센서나 구동기가 장착되어 있으며 인터넷과 통신합니다. 내 폰에서 확인할 수 있어요. 차고 문이 열려 있으면, 스마트 스피커에 말하면 닫아주죠. 심지어 타이머로 설정해놓으면, 밤에도 열려 있으면 자동으로 닫아줍니다. 문이 울리면, 폰에서 누가 있는지 확인할 수 있어요. 세계 어디에서든 상대방과 대화를 나눌 수 있고, 문에 내장된 스피커와 마이크를 통해 소통할 수 있어요. 혈당, 심박수, 그리고 수면 패턴을 모니터링하며 데이터에서 건강 개선을 위한 패턴을 찾아내요. 구름을 통해 조명을 제어할 수 있고, 인터넷 연결이 끊겨서 어둠 속에 앉을 때도 있어요.\n\nIoT 장치의 예시\n\n- 다수의 스마트 스피커\n- 냉장고, 식기세척기, 오븐, 전자렌지\n- 태양광 패널용 전기 모니터\n- 스마트 플러그\n- 비디오 도어벨 및 보안 카메라\n- 다중 스마트 룸 센서가 장착된 스마트 온도 조절기\n- 차고 문 오프너\n- 가정용 엔터테인먼트 시스템 및 음성 제어 TV\n- 조명\n\n<div class=\"content-ad\"></div>\n\n이 문서는 사한 비랑가가 작성했습니다.","ogImage":{"url":"/assets/img/2024-06-19-WhatistheInternetofThings_0.png"},"coverImage":"/assets/img/2024-06-19-WhatistheInternetofThings_0.png","tag":["Tech"],"readingTime":4},{"title":"파이썬 - 데이터베이스 작업하는 3가지 방법SQL, ORM, Query Builder","description":"","date":"2024-06-19 16:39","slug":"2024-06-19-Python3WaystoWorkwithDatabasesSQLORMQueryBuilder","content":"\n\n## 원시 SQL 쿼리, ORM 및 SQL 쿼리 빌더 비교와 코드 예제\n\n대부분의 데이터 엔지니어링 스크립트는 어떤 식으로든 데이터베이스에 연결하는 작업을 수반합니다. 우리는 종종 데이터를 검색하고, 해당 데이터에 작업을 수행한 후 다시 데이터벤에로로드해야합니다. 다행히도, 현대 프로그래밍 언어는 이러한 워크플로우를 실행할 수 있는 여러 가지 방법을 제공합니다.\n\n가장 간단한 접근 방법은 SQL 쿼리를 사용하는 것인데, 이는 텍스트로 작성되고 이를 통해 데이터베이스와 통신합니다. 파이썬은 이러한 목적으로 Database API라는 형식의 표준을 제공합니다. 그러나 이 방법은 크고 복잡한 프로그램에 대해 복잡해질 수 있습니다.\n\n따라서 ORM (객체 관계 매핑) 및 SQL 쿼리 빌더와 같은 다른 옵션이 있습니다. 이 둘은 각각의 장단점을 가지고 있습니다. 이 세 가지 표준을 모두 탐구해 보기 위해 여기에 들어가 봅시다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-Python3WaystoWorkwithDatabasesSQLORMQueryBuilder_0.png\" />\n\n내 GitHub에서 모든 코드를 확인할 수 있습니다. 또한 제 다른 기사 예시도 찾아볼 수 있어요. 자유롭게 사용하시고 질문이 있으면 언제든지 물어봐주세요.\n\n## 사전 준비 작업\n\n다양한 방법을 논의하기 전에 PostgreSQL 데이터베이스에 테이블을 생성해야 합니다. 이전에 SQL 문의 순서에 대해 썼던 이전 기사 중 하나에서 동일한 데이터를 사용했습니다. 생성 문은 그곳에서 찾을 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n이 모든 방법을 비교하기 위해 동일한 SELECT 문을 사용할 것입니다. 이 SELECT 문은 모든 중요한 작업을 포함하고 있습니다. 집계 및 필터링 (GROUP BY, WHERE 및 HAVING) 같은 작업입니다.\n\n```js\nSELECT\n c.country\n ,c.year\n ,MAX(e.horse_power) AS max_horse_power\nFROM public.cars c\nJOIN public.engines e\n ON c.engine_name = e.name\nWHERE c.country != 'USA'\nGROUP BY\n c.country\n ,c.year\nHAVING MAX(e.horse_power) > 200\nORDER BY max_horse_power DESC\n```\n\n![이미지](/assets/img/2024-06-19-Python3WaystoWorkwithDatabasesSQLORMQueryBuilder_1.png)\n\n## Raw SQL\n\n<div class=\"content-ad\"></div>\n\n장점: 사용하기 쉽고 SQL 언어의 모든 기능을 활용할 수 있습니다.\n\n단점: SQL 방언에 따라 다르며, 대규모 애플리케이션에서 확장성과 가독성에 문제가 있을 수 있습니다.\n\n가장 쉬운 옵션부터 시작해 보죠. 데이터베이스와 통신하기 위해 쿼리를 사용하는 것입니다. 이를 위해 psycopg2 (또는 다른 데이터베이스)와 같은 라이브러리를 사용할 때의 표준 규칙을 따른 스크립트를 만들었습니다.\n\n```js\nimport psycopg2\nfrom pathlib import Path\n\nconn = psycopg2.connect()\ncur = conn.cursor()\n\nsql = Path('python-sql/sql/max_horsepower.sql').read_text()\n\ncur.execute(sql)\nres = cur.fetchall()\nprint(res)\n\ncur.close()\nconn.close()\n\n# [('Germany', 2019, 612), ('UK', 2019, 612), ('Germany', 2021, 510), ('Germany', 2023, 469)]\n```\n\n<div class=\"content-ad\"></div>\n\n위 내용을 보면 코드에서 SQL 문을 구현하는 것이 간단하며, 데이터베이스 쪽에서 하는 것처럼 사용할 수 있습니다. 그러나 대규모 애플리케이션을 작업할 때 여러 SQL 스크립트를 처리하는 것은 복잡할 수 있습니다. 다시 말해, 확장 가능하고 가독성이 좋은 코드를 개발하는 가장 최적의 방법은 아닐 수 있습니다.\n\n## ORM (객체 관계 매핑)\n\n장점: 가독성이 높다. 텍스트 SQL 쿼리가 없으므로 보안이 강화된다. 쉽게 확장하여 새로운 기능을 추가할 수 있다. 모든 언어에 적합하다.\n\n단점: 추가적인 학습이 필요하며 구현하는 데 더 많은 노력이 필요하다. 기능이 제한될 수 있으며, 서로 다른 ORM은 다른 사용 방법을 가질 수 있다. 엄격한 스키마를 가질 수 있다.\n\n<div class=\"content-ad\"></div>\n\nORM (Object-Relational Mapping)은 시간이 흐름에 따라 많은 애플리케이션에서 널리 사용되는 기술입니다. 이는 클래스와 객체를 사용하여 테이블을 나타내며, 이러한 클래스를 사용하여 레코드를 다룰 수 있습니다. 본질적으로, 이는 데이터베이스 테이블을 Python 클래스로 변환한 다음 이 언어에서 사용하는 것을 의미합니다.\n\nPython에서 ORM에 대한 가장 인기 있는 프레임워크는 SQLAlchemy입니다. 그러나 Django를 개발할 때도 같은 개념을 만날 수 있으므로 더 효율적으로 작업하기 위해 이를 탐구하고 공부해보는 것이 좋습니다. 코드가 더 길고 복잡해 보일 수 있지만, 보다 유연한 클래스를 사용하여 Python으로 완전히 작성되었다는 점을 주목해주세요. ORM 객체를 사용하여 쿼리를 수행하는 방법에도 주의를 기울여야 합니다. 이는 각각의 명령문(join 및 group_by와 같은)에 대한 메서드를 사용하는 것을 보여줍니다.\n\n```python\nfrom dotenv import load_dotenv\nimport os\n\nfrom sqlalchemy import URL, create_engine, func, select\nfrom sqlalchemy.orm import declarative_base, sessionmaker\nfrom sqlalchemy import Column, Integer, String\n\nBase = declarative_base()\n\nclass Cars(Base):\n    __tablename__ = \"cars\"\n    \n    manufacturer = Column(String(64))\n    model = Column(String(64))\n    country = Column(String(64))\n    engine_name = Column(String(64), primary_key=True, nullable=False)\n    year = Column(Integer)\n    \nclass Engines(Base):\n    __tablename__ = \"engines\"\n    \n    name = Column(String(64), primary_key=True, nullable=False)\n    horse_power = Column(Integer)\n\ndef main():\n    \n    load_dotenv()\n    \n    connection_string = URL.create(\n        'postgresql',\n        username=os.getenv('USERNAME'),\n        password=os.getenv('PASSWORD'),\n        host=os.getenv('HOST'),\n        database=os.getenv('DB'),\n        #connect_args={'sslmode':'require'}\n        )\n    \n    engine = create_engine(connection_string)\n    Session = sessionmaker(bind=engine)\n    session = Session()\n    \n    sql = (\n        select(\n            Cars.country,\n            Cars.year,\n            func.max(Engines.horse_power).label(\"max_horse_power\"),\n        )\n        .join(Engines, Cars.engine_name == Engines.name)\n        .where(Cars.country != 'USA')\n        .group_by(Cars.country, Cars.year)\n        .having(func.max(Engines.horse_power) > 200)\n        .order_by(func.max(Engines.horse_power).label(\"max_horse_power\").desc())\n    )\n    \n    for i in session.execute(sql):\n        print(i)\n    \nif __name__ == '__main__':\n    main()\n\n#('Germany', 2019, 612)\n#('UK', 2019, 612)\n#('Germany', 2021, 510)\n#('Germany', 2023, 469)\n```\n\n여기에는 SELECT 쿼리만을 위한 예제가 있지만, SQLAlchemy는 모든 중요한 작업 (INSERT, UPDATE, DELETE 및 기타 작업)을 위한 기능을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n## SQL 쿼리 빌더\n\n장점: 각 테이블에 대한 클래스(모델)를 결정하지 않고도 Python 코드만 사용하여 구현이 쉬우며 가독성 및 기타 장점을 유지할 수 있음\n\n단점: 각 라이브러리마다 특정 구문을 사용해야 하며, 일부 SQL 기능이 아직 누락될 수 있음\n\nPython에서 쿼리 빌더를 사용하는 것은 원시 문장과 ORM 사이의 중간 옵션이다. 각 테이블의 스키마를 정의할 필요가 없고 테이블 이름만 사용하면 된다.\n\n<div class=\"content-ad\"></div>\n\n쿼리 빌더에는 준수해야 하는 특정 구문이 있습니다. 이 구문의 목적은 Python 코드를 SQL 문으로 변환하여 데이터베이스로 전송하는 것입니다. 아래 예제에서는 이를 위해 pypika 라이브러리를 사용하고 있습니다. 또한 psycopg2를 통해 간단한 데이터베이스 통신을 수행합니다.\n\n```python\nfrom pypika import Query, Table, functions, Order\nimport psycopg2\n\nconn = psycopg2.connect()\ncur = conn.cursor()\n\ncars = Table(\"cars\")\nengines = Table(\"engines\")\n\nquery = (\n    Query.from_(cars)\n    .join(engines)\n    .on(cars.engine_name == engines.name)\n    .where(cars.country != \"USA\")\n    .groupby(cars.country, cars.year)\n    .having(functions.Max(engines.horse_power) > 200)\n    .orderby(functions.Max(engines.horse_power), order=Order.desc)\n    .select(\n        cars.country,\n        cars.year,\n        functions.Max(engines.horse_power).as_(\"max_horse_power\")\n    )\n)\nsql = query.get_sql()\n\ncur.execute(sql)\nres = cur.fetchall()\nprint(res)\n\ncur.close()\nconn.close()\n\n# [('Germany', 2019, 612), ('UK', 2019, 612), ('Germany', 2021, 510), ('Germany', 2023, 469)]\n```\n\n흥미로운 점은 모든 작업을 실제로 SQL 측에서 실행되는 순서대로 작성한다는 것입니다. 위에서 언급한 대로, 이 순서를 설명한 이전 게시물을 방문할 수 있습니다.\n\n## 결론\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 파이썬에서 데이터베이스와 상호 작용하는 세 가지 주요 방법에 대해 논의했습니다. 각각에는 장단점이 있습니다. 그러나 사용할 방법을 선택하는 것은 대부분 귀하의 구체적인 사용 사례에 달려 있습니다.\n\n- SQL 쿼리의 구문에 익숙하고 빠르고 간단한 해결책을 찾는 경우, 원시 SQL 쿼리를 사용하는 것이 최선일 수 있습니다. 또한 복잡한 쿼리를 실행해야 하는 경우 이 접근 방식이 유일한 선택일 수도 있습니다.\n- 반면에, 보안 요구 사항이 있는 대규모 복잡한 애플리케이션을 개발해야 하는 경우 ORM을 사용하는 것이 가장 적합할 것입니다.\n- 보안이 필요한 작은 애플리케이션을 개발하고자 하는 경우 쿼리 빌더를 사용하는 것이 좋은 선택일 수 있습니다. 쿼리 빌더는 모델을 만들 필요 없이 ORM의 대부분의 장점을 제공합니다.\n\n이 기사를 읽고 나서 다양한 접근 방식에 대해 더 잘 이해하고 차후 프로젝트에 최적의 방법을 선택할 수 있기를 바랍니다.\n\nLinkedIn에서 저를 만날 수 있으며, 데이터 과학과 데이터 엔지니어링의 복잡한 세계에 대해 함께 논의하고 싶습니다. 연결하기를 기다리고 있습니다. 함께 흥미로운 대화를 나눠봅시다.\n\n<div class=\"content-ad\"></div>\n\n# 스택데믹\n\n끝까지 읽어 주셔서 감사합니다. 떠나시기 전에:\n\n- 작가를 박수로 격려하고 팔로우해 주세요! 👏\n- 저희를 팔로우해 주세요: X | LinkedIn | YouTube | Discord\n- 다른 플랫폼도 방문해 주세요: In Plain English | CoFeed | Venture","ogImage":{"url":"/assets/img/2024-06-19-Python3WaystoWorkwithDatabasesSQLORMQueryBuilder_0.png"},"coverImage":"/assets/img/2024-06-19-Python3WaystoWorkwithDatabasesSQLORMQueryBuilder_0.png","tag":["Tech"],"readingTime":7},{"title":"파이썬을 PostgreSQL에 연결하는 방법 데이터 과학자를 위한 단계별 안내","description":"","date":"2024-06-19 16:38","slug":"2024-06-19-HowtoconnectPythontoPostgreSQLAStep-by-StepGuideforDataScientists","content":"\n\n데이터 과학자들은 종종 분석, EDA, ETL 등의 작업을 수행하기 위해 데이터 웨어하우스에 액세스해야 합니다.\n\n산업에서 가장 인기 있는 데이터베이스 중 하나는 PostgreSQL입니다.\n\nPostgreSQL은 모든 레벨의 개발자와 모든 규모의 기업에서 널리 사용됩니다. 또한 주요 데이터베이스를 완벽하게 구동하는 다양한 확장 기능과 애드온이 있는 멋진 생태계를 가지고 있습니다.\n\n사이드 프로젝트용 사용자 지정 데이터베이스를 만들거나 프로덕션 수준의 트랜잭션/분석용 데이터베이스가 필요한 경우, PostgreSQL은 훌륭한 선택지입니다.\n\n<div class=\"content-ad\"></div>\n\n이해해요, 소리 좋네요. 하지만 여러분이 여기 계신 이유는 파이썬을 PostgreSQL 데이터베이스에 연결하는 방법을 배우기 위해서에요. 따라와서 그 방법을 배우세요!\n\n![이미지](/assets/img/2024-06-19-HowtoconnectPythontoPostgreSQLAStep-by-StepGuideforDataScientists_0.png)\n\n## 1. 가상 환경 생성\n\n많은 데이터 과학자/분석가들이 구글 콜랩 환경에 머물며 가상 환경에 익숙하지 않게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n이것은 코드가 실행될 때마다 항상 올바른 패키지/라이브러리 버전이 일관되게 사용되도록 보장하는 멋진 방법입니다. 따라서 결과의 근본성을 위해 \"데이터 과학\" 부분을 잊지 마세요.\n\n이를 위한 단계:\n\n- Windows의 명령 프롬프트 또는 Linux/Mac의 터미널을 엽니다.\n- 둘째로, 프로젝트 파일을 저장할 새 디렉터리를 만듭니다. 이름은 원하는 대로 할 수 있지만, 저는 'analytics'라고 지을 겁니다:\n\n```js\nmkdir analytics\n```\n\n<div class=\"content-ad\"></div>\n\n3. 새 디렉토리 안에 내장된 venv 모듈을 사용하여 .venv라는 새 가상 환경을 생성하세요. 문법은 단순합니다. python3 -m venv 만들고자 하는 환경 경로 입니다:\n\n```js\npython3 -m venv .venv\n```\n\n4. 마지막으로, 가상 환경을 활성화/시작하세요:\n\n```js\n# Windows에서\n.venv/scripts/activate\n\n# Mac 및 Linux에서\nsource venv/bin/activate\n```\n\n<div class=\"content-ad\"></div>\n\n# 2. psycopg2 모듈 설치\n\nPsycopg2는 PostgreSQL 데이터베이스 드라이버로, 파이썬을 사용하여 PostgreSQL에서 작업을 수행하기 위해 필요합니다.\n\n먼저 다음 pip 명령어를 사용하여 psycopg2 패키지를 설치하세요:\n\n```js\npip install psycopg2\n```\n\n<div class=\"content-ad\"></div>\n\n두 번째로, requirements.txt 파일을 만들어주세요:\n\n```js\npip3 freeze > requirements.txt\n```\n\nrequirements.txt 파일을 작성하면 정확한 패키지 버전을 지정하여 재현성을 확보할 수 있어 일관된 환경과 결과를 얻을 수 있습니다.\n\n# 3. 파이썬에서 PostgreSQL 데이터베이스에 연결하기\n\n<div class=\"content-ad\"></div>\n\n이제 PostgreSQL 데이터베이스에 연결할 준비가 되었습니다.\n\n먼저, 프로젝트 디렉토리에 데이터베이스 연결 매개변수를 저장할 database.ini라는 구성 파일을 생성해야합니다.\n\n```js\n[postgresql]\nhost=호스트_주소\ndatabase=데이터베이스_이름\nuser=사용자_이름\npassword=비밀번호\n```\n\ndatabase.ini 파일에서 호스트_주소, 데이터베이스_이름, 사용자_이름, 비밀번호를 실제 값으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n이제 프로젝트 디렉토리에 config.py라는 새 파일을 생성합니다:\n\n```js\ntouch config.py\n```\n\n이제 데이터베이스.ini 파일에서 구성 데이터를 읽는 함수를 작성해 봅시다:\n\n```js\nfrom configparser import ConfigParser\n\ndef load_config(filename='database.ini', section='postgresql'):\n  parser = ConfigParser()\n  parser.read(filename)\n\n  # 섹션 가져오기, 기본값은 postgresql\n  config = {}\n  if parser.has_section(section):\n    params = parser.items(section)\n    for param in params:\n      config[param[0]] = param[1]\n  else:\n    raise Exception('섹션 {0}을 {1} 파일에서 찾을 수 없습니다.'.format(section, filename))\n  return config\n\nif __name__ == '__main__':\n  config = load_config()\n  print(config)\n```\n\n<div class=\"content-ad\"></div>\n\nload_config() 함수는 Python의 내장 configparser 패키지를 사용하여 database.ini 파일에서 데이터를 읽습니다.\n\ndatabase.ini를 사용하면 Python에 직접 자격 증명을 하드 코딩하는 것이 아니기 때문에 PostgreSQL 연결 매개변수는 서로 다른 환경(예: 테스트, 운영 및 개발)에서 사용될 때 유연해집니다.\n\n그러나 귀하의 database.ini 파일을 .gitignore 파일에 항상 추가하여 코드를 Git Hub에 푸시할 때 외부에 귀하의 자격 증명을 노출하지 않도록하십시오.\n\n단순히 .gitignore 파일을 만들고 다음 줄을 추가하십시오:\n\n<div class=\"content-ad\"></div>\n\n마지막으로 database.ini 파일을 생성하겠습니다. 그리고 load_config() 함수를 사용하여 데이터베이스 구성을 읽고, 최종적으로 코드를 PostgreSQL에 연결할 connect.py라는 새 파일을 만들어보겠습니다:\n\n```js\nimport psycopg2\nfrom config import load_config\n\ndef connect(config):\n  \"\"\" PostgreSQL 데이터베이스 서버에 연결 \"\"\"\n  try:\n    with psycopg2.connect(**config) as conn:\n      print('PostgreSQL 서버에 연결되었습니다.')\n      return conn\n  except (psycopg2.DatabaseError, Exception) as error:\n    print(error)\n\nif __name__ == '__main__':\n  config = load_config()\n  connect(config)\n```\n\nconfig.py 모듈을 사용하기 때문에 구성을 connect() 함수로 전달하고, ** 연산자를 사용하여 언패킹할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위의 방법이 다음과 같이 자격 증명을 직접 함수에 전달하는 대안보다 더 나은 방법이며 안전합니다.\n\n```js\nconn = psycopg2.connect(\n    host=\"호스트 주소\",\n    database=\"데이터베이스 이름\",\n    user=\"귀하의 사용자 이름\",\n    password=\"귀하의 비밀번호\"\n)\n```\n\n# 마무리 맺음\n\nPostgreSQL은 멋지며 Python과 결합되면 더욱 좋습니다. 데이터베이스.ini, connect.py 및 config.py 파일을 구성 폴더에 보관하는 것을 적극 권장합니다. 이렇게 결정하신 경우 load_config() 함수의 'filename' 인수를 \"config/database.ini\"로 수정해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n만약 이 튜토리얼이 마음에 드셨다면 친구들과 공유하고, 어떤 부분이 가장 마음에 들었고 더 개선할 점이 있다면 댓글을 남겨주세요. LinkedIn과 GitHub에서 저를 팔로우하시고 궁금한 점이 있으면 언제든지 연락해 주세요.","ogImage":{"url":"/assets/img/2024-06-19-HowtoconnectPythontoPostgreSQLAStep-by-StepGuideforDataScientists_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoconnectPythontoPostgreSQLAStep-by-StepGuideforDataScientists_0.png","tag":["Tech"],"readingTime":5},{"title":"데이터 분석 프로젝트  스마트폰 데이터 분석","description":"","date":"2024-06-19 16:37","slug":"2024-06-19-ADataAnalysisProjectSmartPhonesDataAnalysis","content":"\n\n## SQL 및 SSMS를 사용하여 스마트폰 데이터의 통찰력 추출\n\n![image](/assets/img/2024-06-19-ADataAnalysisProjectSmartPhonesDataAnalysis_0.png)\n\n저는 Kaggle(데이터 세트) 웹사이트에서 수집한 스마트폰 데이터를 이용한 데이터 분석 프로젝트를 진행했습니다. 이 데이터는 최신 업데이트된 데이터로, 산업에 대한 훌륭한 통찰력을 추출하고 이해하기 위해 사용하는 것이 좋습니다.\n\n주어진 데이터 세트에는 다양한 스마트폰 세부 정보에 관한 정보가 포함되어 있습니다. 아래에서 언급된 것과 같이 다양한 정보를 전달하는 열이 있습니다.\n\n<div class=\"content-ad\"></div>\n\ni. 스마트폰 브랜드 이름 및 모델.\nii. 스마트폰 가격, 평가, 5g, 그리고 ir 블라스트의 세부 정보.\niii. 스마트폰의 프로세서 브랜드, 각각의 코어 수, 그리고 처리 속도.\niv. 배터리 용량, RAM 용량, 빠른 충전 지원 여부, 그리고 내부 메모리 세부 정보.\nv. 스마트폰 화면 크기, 주사율, 후면 카메라 수, 운영 체제, 그리고 해상도 세부 정보가 제공됩니다.\n\n이것은 주어진 데이터 세트가 전달하는 기본 정보입니다. 이제 우리는 이 데이터에서 다양한 통찰과 분석을 추출할 예정입니다. 추출할 수 있는 다양한 통찰이 많이 있습니다. 아래에 언급된 몇 가지 통찰은 비즈니스가 판매 및 제품 업그레이드를 위해 필요한 작업을 할 수 있도록 도와줍니다.\n\n다음 질문에 대한 조사/추출할 데이터.\n\n여기 내 YouTube 채널이 있습니다. 더 많은 정보를 받고 최신 업데이트를 즉시 확인하려면 구독해 주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n-----1. 상점에서 브랜드 및 모델 수 그리고 브랜드 당 모델 수를 찾아보세요.\n정렬 기능을 사용하여 롤링 합계로 모델 수를 확인하세요.\n\nselect count(distinct brand_name) as Number_of_brands from SmartPhones_data;\nselect count(distinct model) as number_of_models from SmartPhones_data;\n\nwith cte as(\nselect brand_name, count(distinct model) as number_of_models from SmartPhones_data \ngroup by brand_name)\nselect c.*, sum(c.number_of_models) over(order by number_of_models desc, brand_name asc) as total_number_of_models from cte c\n\n----2. 각 브랜드의 휴대폰 및 모델의 총 가격, 또한 브랜드 및 모델과 함께 각 브랜드의 휴대폰 가격을 찾아보세요.\nsql\nselect brand_name, sum(price) as total_cost from SmartPhones_data group by brand_name order by 1 asc;\nselect model, sum(price) as total_cost from SmartPhones_data group by model order by 2 desc;\nselect brand_name, model, sum(price) as total_cost from SmartPhones_data group by brand_name, model order by 1;\n\nwith cte as(\nselect brand_name, model, sum(price) as total_cost from SmartPhones_data group by brand_name, model),\ncte2 as(select c.*, sum(total_cost) over(partition by brand_name order by total_cost) as total_cost_by_brand from cte c)\n,cte3 as(select c1.*, dense_rank() over(partition by brand_name order by total_cost_by_brand desc) as rnk from cte2 c1)\nselect brand_name, total_cost_by_brand from cte3 where rnk=1\n\n저는 window 함수를 사용하여 각 브랜드의 총 비용을 롤링 합산하여 결과를 확인했습니다. (역공학)\n\n----3. 최고 평점을 받은 상위 3개 브랜드와 모델을 찾아보세요.\nsql\nselect brand_name, model from(\nselect distinct brand_name, model, rating, dense_rank() over(order by rating desc) as rnk from SmartPhones_data)a \nwhere a.rnk<=3 order by rnk\n\n<div class=\"content-ad\"></div>\n\n이 데이터를 사용하여 안전하지만 5G는 아닌 더 빠른 모델을 선택할 수 있습니다. 이는 5G 모델이 아닙니다. \n\n---4. 5g를 갖고 있지 않거나 ir 블라스터를 갖고 있는 모바일 기기.\nselect 모델 from SmartPhones_data where has_5g = 0 and has_ir_blaster = 1\n\nselect count(distinct processor_brand) number_of_processor_brands from smartphones_data\n\nselect processor_brand, count(모델) from SmartPhones_data where processor_brand is not null \ngroup by processor_brand\norder by 2 desc \n\n---6. 모델당 코어 수. 코어 수에 따라 순위를 매깁니다.\nselect distinct 모델, num_cores as number_of_cores from SmartPhones_data\n\nselect * from (\nselect distinct 모델, num_cores as number_of_cores, dense_rank() over(order by num_cores desc) as rank from \nSmartPhones_data)a order by 3\n\n<div class=\"content-ad\"></div>\n\n----7. 브랜드와 모델별로 가장 높은 프로세서 속도.\nselect brand_name, model, processor_speed from(\nselect brand_name, model, processor_speed, dense_rank() over(order by processor_speed desc) as rnk\nfrom SmartPhones_data)a where a.rnk=1\n\n<img src=\"/assets/img/2024-06-19-ADataAnalysisProjectSmartPhonesDataAnalysis_1.png\" />\n\n----8. 가장 높은 배터리 용량을 가진 상위 5개 모델 및 그들의 브랜드.\nselect brand_name, model, battery_capacity from (\nselect brand_name, model, battery_capacity, dense_rank() over(order by battery_capacity desc) as rnk \nfrom SmartPhones_data )a where a.rnk<=5\n\n----9. 가장 높은 RAM 용량과 내부 메모리를 가진 상위 5개 브랜드 및 모델 나열.\nselect brand_name, model, ram_capacity, internal_memory from(\nselect brand_name, model, ram_capacity, internal_memory, dense_rank() over(order by ram_capacity desc, internal_memory desc) as\nrnk from smartphones_data)a where rnk <=5\n\n<div class=\"content-ad\"></div>\n\n---10. 화면 크기가 작은 상위 10개 모델 및 브랜드를 나열합니다.\nselect brand_name, model, screen_size from(\nselect brand_name, model, screen_size, dense_rank() over(order by screen_size) as rnk from SmartPhones_data)a\nwhere a.rnk<=10\n\n이와 유사하게, 나머지로부터도 통찰을 얻을 수 있습니다. 이전 질문을 참조하여 이러한 작업을 수행할 수 있었으면 좋겠습니다. 그렇지 않으면 아래 질문에 대한 통찰을 얻는 데 대해 궁금한 점이 있으면 댓글을 통해 질문할 수 있습니다.\n\n데이터 분석 프로젝트에 대해 더 많이 보고 싶으신가요?\n아래에 언급된 데이터 분석 프로젝트를 확인하실 수 있습니다.\n\n# 데이터 분석 프로젝트 시리즈:\n\n\n<div class=\"content-ad\"></div>\n\ni. 데이터 분석 프로젝트 - 커피숍 매출 분석.\n\nii. 데이터 분석 프로젝트 - 아디다스 매출 보고서.\n\niii. 데이터 분석 프로젝트 - 전기 차량 보급 데이터.\n\niv. 데이터 분석 프로젝트 - 데이터 과학 채용 공고.\n\n<div class=\"content-ad\"></div>\n\n이 기사가 SQL을 사용한 데이터 분석을 진행하고 기본 개념을 적용하는 데 도움이 되기를 바랍니다.\n\n[여기를 클릭](https://github.com/)하여 데이터 분석에 중점을 둔 내 독서 목록에서 몇 가지 데이터 분석가 면접 질문과 사용 사례를 준비하세요. 내 GitHub에서 데이터와 SQL 파일을 볼 수 있습니다.\n\n향후 프로젝트에 연계되기 위해 모든 프로젝트에 접근하려면 꼭 나의 GitHub를 팔로우하세요.\n\n포트폴리오를 구축하고 다양한 클라이언트의 신뢰를 얻기 위해 최소 요율로 프리랜서로서 나의 서비스를 제공하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n개인(1:1) 트레이닝 전 세계 어디서나 가능하며 Zoom을 통해 연결할 거에요.\n\nmahendraee204@gmail.com 으로 연락주세요.\n\n저를 팔로우하면 중요한 소식을 놓치지 않을 수 있어요.\n\n감사합니다 :)","ogImage":{"url":"/assets/img/2024-06-19-ADataAnalysisProjectSmartPhonesDataAnalysis_0.png"},"coverImage":"/assets/img/2024-06-19-ADataAnalysisProjectSmartPhonesDataAnalysis_0.png","tag":["Tech"],"readingTime":6},{"title":" SQL 조인 마스터하기","description":"","date":"2024-06-19 16:31","slug":"2024-06-19-MasteringSQLJoins","content":"\n\n![SQL Join](/assets/img/2024-06-19-MasteringSQLJoins_0.png)\n\n저희의 최신 SQL 데이터 과학 탐험에 오신 것을 환영합니다. 이전 글에서는 단일 테이블 내에서 데이터 세트를 조작하는 것에 대해 자세히 다뤘습니다. 데이터 추출, 변환, 계산, 필터링을 통해 통찰과 패턴을 발견했습니다.\n\n이러한 기본적인 기술은 중요하지만, SQL의 실제 응용은 종종 보다 복잡한 접근을 요구합니다. 특히 다중 테이블에서 데이터를 통합해야 하는 경우가 많습니다. 이는 관계형 데이터베이스에 데이터가 일반적으로 저장되는 방식을 반영한 것으로, 서로 다른 테이블 간에 특정 키와 속성을 통해 관련되어 있습니다.\n\n본 문서에서는 단일 테이블 작업을 넘어서서 다중 테이블 조인에 대한 이해와 적용을 다룰 것입니다. 조인 작업은 SQL에서 중요한데, 서로 다른 테이블에서 데이터를 통합하고 교차 참조하여 정보를 종합적으로 파악할 수 있게 합니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 조인 연산의 기본 개념을 다룰 것이며, 다양한 종류의 조인과 그 응용에 대해 다룰 것입니다. 이 글을 마칠 때쯤이면, 현실 세계의 데이터 과학적 도전의 복잡성을 반영하는 정교한 데이터 조작을 수행하는 데 필요한 실용적인 노하우를 갖추게 될 것입니다. 데이터 과학을 위해 관계형 데이터베이스의 전체 잠재력을 탐색하고 활용하기 위한 전략을 발견하는 다중 테이블 관련의 복잡성에 대해 파고들어 봅시다.\n\n# 데이터 관련성 이해\n\n테이블 조인과 SQL에 대한 우리의 탐험의 핵심에는 기본 개념이 있습니다: 데이터 관계. 테이블을 조인하는 메커니즘을 깊이 파헤치기 전에, 데이터가 관련되어 있는지와 이러한 관계가 관계형 데이터베이스의 기반이 되는 방식을 이해하는 것이 중요합니다.\n\n거의 모든 제품을 판매하는 거의 모든 비즈니스에서 흔히 볼 수 있는 기본적인 예제를 고려해 보겠습니다 — 제품 카탈로그 테이블입니다. 이 테이블은 회사 데이터베이스의 중요한 구성 요소로, 판매 가능한 제품들의 구조화된 개요를 제공합니다. 일반적으로 제품 코드, 제품 이름, 판매 가격, 제품 카테고리와 같은 필드가 포함되어 있습니다. 이러한 각 필드는 특정 목적을 제공합니다:\n\n<div class=\"content-ad\"></div>\n\n- 제품 코드: 각 제품에 대한 고유 식별자입니다.\n- 제품 이름: 제품의 이름으로, 사용자들이 식별하는 데 도움이 됩니다.\n- 판매 가격: 제품이 고객에게 판매되는 가격입니다.\n- 제품 카테고리: 제품을 더 넓은 범주로 그룹화하는 분류입니다.\n\n이 표는 제품 정보를 관리 가능한 방식으로 구성하는 데 도움이 되며, 데이터가 어떻게 상호 연결될 수 있는지 이해하는 데 기초를 제공합니다.\n\n예를 들어, 제품 카테고리 필드는 개별 제품을 더 큰 범주에 연결하여 데이터 내에서 간단하지만 강력한 관계를 암시합니다. 진행하면서 이러한 관계가 단일 표를 넘어 확장되어 다중 소스에서 데이터를 결합하여 더 풍부한 통찰과 포괄적인 분석을 제공할 수 있음을 알게됩니다.\n\n다음 섹션에서는 테이블 조인의 메커니즘에 대해 깊이 있게 다룰 것인데, 이 기술은 이러한 관계를 활용하여 두 개 이상의 테이블에서 데이터를 병합하여 데이터를 질의하고 분석할 수 있는 능력을 향상시키는 데 활용됩니다.\n\n<div class=\"content-ad\"></div>\n\n데이터 관계의 기본 개념을 이해하면 데이터 과학에서 SQL의 강력함을 더욱 실감할 수 있어요.\n\n![MasteringSQLJoins_1.png](/assets/img/2024-06-19-MasteringSQLJoins_1.png)\n\n쿼리 분석 및 시각화 생성 측면에서 PRODUCTS 테이블은 잘 구성되어 있어서 SQL 작업에 적합해 보여요.\n\nPRODUCTS 테이블에서 카테고리가 특히 `가정용 가전제품`인 제품 이름을 검색하려면 다음과 같은 SQL 쿼리를 실행할 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n```sql\nSELECT product_name \nFROM PRODUCTS \nWHERE category = 'Home Appliances'\n```\n\n우리 예제 테이블에서 이 쿼리를 실행하면 'Home Appliances' 카테고리에 세 개의 제품이 있다는 것을 나타내는 세 개의 행이 반환됩니다.\n\n따라서 이 데이터 하위 집합을 가져오는 데 문제가 없습니다. 더 나아가, 우리는 카테고리 당 제품 평균 가치를 계산하는 분석을 확장할 수 있습니다.\n\n이러한 작업을 위해서는 AVG 함수를 사용하여 평균 제품 가치를 계산합니다. SQL 명령을 구조화하는 방법은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nSELECT category, AVG(product_value)\nFROM PRODUCTS\nGROUP BY category;\n```\n\n이 명령어는 두 가지 업무를 수행합니다:\n\n- 출력에 포함될 카테고리 열을 선택하여 각 카테고리의 평균 값에 대한 고유한 식별자를 제공합니다.\n- AVG 함수를 사용하여 제품 가치의 평균을 계산합니다. 이는 저희 다음 장에서 더 자세히 살펴볼 집계 함수입니다.\n\nGROUP BY category를 사용하여 각 고유 카테고리에 대한 평균 값을 PRODUCTS 테이블 내에서 계산합니다. 이러한 집계는 데이터 분석에서 핵심 역할을 합니다. 다른 제품 세그먼트 내에서의 패턴과 트렌드를 식별하는 데 도움이 됩니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 더 자세히 살펴보면, 카테고리 열에서 비효율성이 드러납니다: 용어 '가전제품'이 여러 번 반복됩니다. 처음에는 각 제품의 카테고리를 나타내는 것이 필요해 보일 수 있지만, 이 중복은 몇 가지 문제로 이어질 수 있습니다:\n\n- 데이터 저장: 중복 데이터는 저장면에서 비용이 소모될 수 있습니다. '가전제품'의 각 반복은 디스크 공간을 추가로 차지하는데, 이는 이 정보를 표현하는 더 효율적인 방법이 없는 한 불필요합니다.\n- 성능: 자주 업데이트되는 테이블은 이러한 중복이 포함되어 있을 경우 로드하는 데 시간이 오래 걸릴 수 있습니다. 수백만 또는 수십억 개의 레코드로 확장된 이 테이블을 상상해보세요. 반복된 카테고리 항목으로 인해 성능에 미치는 영향은 상당할 수 있습니다.\n- 쿼리 효율성: 대규모 테이블을 쿼리할 때 중복된 카테고리가 있는 경우, 데이터베이스 엔진은 필요 이상의 데이터를 스캔해야 하는 일이 늘어날 수 있습니다.\n\n따라서, 보고 목적으로는 테이블이 충분해 보일지라도, 관리 및 운영 측면에서는 상당한 비효율성이 드러납니다.\n\n이러한 도전에 대처하려면, 데이터베이스를 재구성하여 중복을 줄이고 데이터 무결성을 개선하는 정규화(Normalization)이라는 해결책이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n이 문제를 해결하는 일반적인 방법 중 하나는 고유한 카테고리 이름과 해당 식별자를 보유하는 별도의 CATEGORIES 테이블을 생성하는 것입니다.\n\n그럼으로써, PRODUCTS 테이블의 각 제품은 식별자를 통해 적절한 카테고리를 참조하게 됩니다. 이 방법을 외부 키 참조라고 합니다.\n\n이 변경은 저장 공간을 절약하는 데 도움이 되는 것뿐만 아니라 데이터 작업과 쿼리의 성능을 최적화합니다.\n\n다음은 이러한 비효율성을 해결하기 위해 데이터베이스를 구조화하는 예시입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n-- 카테고리에 대한 새 테이블 생성\nCREATE TABLE CATEGORIES (\n    category_id INT PRIMARY KEY,\n    category_name VARCHAR(255)\n);\n\n-- 고유한 카테고리를 CATEGORIES 테이블에 삽입\nINSERT INTO CATEGORIES (category_id, category_name)\nVALUES (1, '가전제품'), (2, '가구'), (3, '식품');\n\n-- PRODUCTS 테이블을 수정하여 CATEGORIES에 대한 외부 키 참조를 추가\nALTER TABLE PRODUCTS\nADD COLUMN category_id INT,\nADD FOREIGN KEY (category_id) REFERENCES CATEGORIES(category_id);\r\n```\n\n![이미지](/assets/img/2024-06-19-MasteringSQLJoins_2.png)\n\n이 접근 방식은 여러 문제를 해결해 줍니다. 'Home Appliances'라는 단어를 더 이상 반복하지 않아도 되므로, 수십억 개의 레코드가 있는 테이블에서 중요합니다.\n\nCATEGORIES 테이블을 자주로드할 필요가 없으므로로딩 시간이 줄어들 확률이 높습니다. 이 테이블은 한 번 생성되고 시간이 지남에 따라 거의 변경되지 않습니다. PRODUCTS 테이블은 카테고리 관련 텍스트를 반복할 필요가 없으므로 로드 및 업데이트 속도가 빨라집니다.\n\n<div class=\"content-ad\"></div>\n\n쿼리를 실행하는 과정은 두 테이블을 조인해야 하므로 약간 복잡할 수 있습니다. 그러나 이런 교체는 쿼리가 텍스트 기반의 카테고리 열이 아닌 ID를 참조하고, 해당 카테고리가 반복되지 않는 CATEGORIES 테이블에 조인하여 성능이 더 우수해질 수 있도록 도와줍니다.\n\n아래는 카테고리가 '가전제품'인 제품 이름을 검색하는 쿼리의 예시입니다:\n\n```js\nSELECT p.product_name, p.product_value\nFROM PRODUCTS p\nJOIN CATEGORIES c ON p.category_id = c.category_id\nWHERE c.category_name = 'Home Appliances';\n```\n\n이 SQL 문은 PRODUCTS 테이블과 CATEGORIES 테이블을 공유된 category_id를 기준으로 조인합니다. 이렇게 함으로써 'Home Appliances' 카테고리와 연관된 제품 이름과 값을 효율적으로 검색합니다.\n\n<div class=\"content-ad\"></div>\n\n- p 및 c는 각각 PRODUCTS 및 CATEGORIES의 별칭으로, 쿼리를 간단하게 만듭니다.\n- ON 절은 category_id를 일치시켜 두 테이블을 연결합니다.\n- WHERE 절은 결과를 '가정용 가전제품' 만 포함하도록 필터링합니다.\n\n테이블 별칭이 없는 열 이름은 한 테이블에만 고유한 열에서 나온 것으로, 별칭이 필요 없어집니다. 그러나 쿼리가 복잡해지면 명확성을 위해 별칭을 사용하는 것이 일반적인 관행입니다.\n\n저희는 앞으로 LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN 및 CROSS JOIN과 같은 다양한 종류의 조인을 다룰 것입니다.\n\n# SQL 조인 이해하기: 개념적 접근\n\n<div class=\"content-ad\"></div>\n\nSQL 영역에서 테이블을 결합하는 능력은 복잡한 데이터 검색을 가능하게 하는 강력한 기능입니다.\n\n시작하기 전에 한 가지 조언을 드리겠습니다: 유혹에 넘어가지 말고 조인 규칙을 암기하려는 욕구를 억제하세요. 진정한 이해는 단순 암기가 아니라 근본적인 원리를 이해하는 데서 나옵니다.\n\n이 섹션에서는 SQL 조인에 대한 개요를 제시하고 일반적인 개념을 파악하기 위한 다이어그램을 보완합니다. 실제 연습으로 이동하면서 목표지향적인 방법으로 SQL 조인 학습을 강조할 것입니다.\n\n조인을 마스터하는 핵심은 원하는 결과에 초점을 맞추는 것입니다: 어떤 데이터가 필요한가요? 얼마나 많은 데이터가 필요한가요? 어떤 테이블에서요?\n\n<div class=\"content-ad\"></div>\n\n이러한 질문들이 있습니다. 해당 조인 유형을 결정하는 데 도움이 됩니다. 조인이란 본질적으로 세트 이론 규칙의 적용이며, 이 개념을 이해하는 것은 단순 외움보다 전략적입니다.\n\n그럼에도 불구하고 이는 하나의 관점에 불과합니다. 우리가 다가올 수업에서 INNER JOIN, LEFT JOIN, RIGHT JOIN, FULL OUTER JOIN 등을 포함한 다양한 조인 유형을 탐색하면서 직접 결론을 도출하는 것을 장려합니다.\n\n<div class=\"content-ad\"></div>\n\nSQL 조인은 본질적으로 집합 이론의 실용적 적용입니다. 이 개념은 대부분 사람들이 초등 교육을 받을 때 소개 받는 개념입니다. 이 아이디어는 간단합니다: 조인을 통해 하나의 세트, 다른 세트 또는 둘 다에 속하는 데이터를 검색할 수 있습니다. SQL에서 이러한 세트는 우리의 데이터를 포함하는 테이블입니다.\n\n다음 시각화를 고려해보세요: 각 원은 데이터 세트 또는 테이블을 나타냅니다. 우리는 다음과 같은 데이터를 검색할 수 있습니다:\n\n## Inner Join\n\n\"조인\"에 대해 들으면, 그것은 일반적으로 사용되는 조인 유형 중 하나인 내부 조인을 가리키는 것입니다. 이는 두 테이블에서 일치하는 값을 가진 레코드를 반환합니다. 아래 다이어그램은 이해를 돕습니다.\n\n<div class=\"content-ad\"></div>\n\n## Left Join (또는 Left Outer Join)\n\n가끔 \"Outer\"를 생략하여 \"Left Join\"이라고도 불리며, 이는 왼쪽 테이블의 모든 레코드와 오른쪽 테이블의 해당 레코드를 반환합니다. SQL 쿼리에서 테이블의 순서는 결과에 중대한 영향을 미칩니다. 따라서 쿼리에서 테이블의 순서를 지정하는 것이 중요합니다.\n\n## Right Join (또는 Right Outer Join)\n\n이 조인은 오른쪽 테이블의 모든 레코드와 왼쪽 테이블의 일치하는 레코드를 반환합니다. 아래 다이어그램은 이 개념을 시각적으로 설명합니다.\n\n<div class=\"content-ad\"></div>\n\n## Full Join (또는 Full Outer Join)\n\n왼쪽, 오른쪽 또는 두 테이블에서 일치하는 항목이있을 때 모든 레코드를 반환하여 모든 것을 검색합니다.\n\n## Cross Join\n\n성능 이슈로 인해 덜 사용되지만, 두 테이블의 모든 레코드의 카테시안 곱을 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n위의 예시는 단순성을 위해 두 개의 테이블을 사용했지만, 실제로는 몇 개의 테이블이든 상관없이 동일한 원칙이 적용됨을 알아두는 것이 중요합니다. 3개, 4개, 5개 또는 100만 개의 테이블을 조인하든 상관없이 논리는 일관적으로 유지됩니다.\n\n## Self Join\n\n이 기술은 재귀를 활용하여 테이블을 자신에 조인하는 것으로, 컴퓨터 프로그래밍에서 널리 사용되는 개념입니다.\n\n다음 다이어그램은 제공된 설명을 요약하였습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-MasteringSQLJoins_4.png\" />\n\n위 요약은 방금 논의한 조인 유형을 요약한 것이지만, 각 조인 유형마다 쿼리에서 필터를 구성하는 방식에 대한 주요한 차이점이 있다는 점을 기억하는 것이 중요합니다.\n\n우리는 이전에 필터에 대해 탐구했었죠. 필터는 사실 SQL 개념의 기초입니다.\n\n조인을 구성하는 방식은 적용하는 필터에 따라 완전히 변경될 수 있습니다. 그래서 이러한 조인 및 약간의 변형을 소개했지만, 개인적으로는 조인의 이름을 기억하는 데 신경 쓰지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n그 대신, 제가 집중하는 것은 필요한 것을 이해하는 데 있어요:\n\n- 나는 왼쪽과 오른쪽 테이블에서 데이터를 반환하고 싶은가?\n- 한 테이블에만 존재하고 다른 테이블에는 없는 데이터를 검색하려고 하는가?\n- 아니면 동일한 테이블 내에서 관계가 있는 데이터를 반환하고 싶은가?\n\n이것들은 제가 고민하는 질문들이며, 이러한 실용적인 수업을 통해 안내해 드릴 거에요. 이 방법은 최적의 조인 전략을 정의하는 데 도움이 돼요. 물론, 이 모든 것을 즉시 이해하는 것은 쉽지 않을 수 있어요; 연습이 중요하죠.\n\n나는 다가오는 세션에서 여러 예시들을 제공하여 여러분이 이러한 개념을 이해하고 적용할 수 있도록 강화할 거에요.\n\n<div class=\"content-ad\"></div>\n\n# SQL에서 Table Joins 탐색하기\n\nSQL에서 Table Joins에 대해 자세히 살펴보겠습니다. 이 섹션은 최대한 가르치기 쉬운 방법으로 기초부터 순서대로 명확하게 설명하려는 목적으로 강조합니다.\n\n나의 목표는 여러분이 개념을 명확히 이해하도록 돕는 것입니다. Table Joins는 점차적으로 복잡해지는 쿼리를 다룰 때 다음 장에서 활용될 것입니다.\n\n가상 데이터셋을 활용하여 SQL Joins를 마스터하는 여정을 수월하게 진행해 보겠습니다. 시작해 봅시다!\n\n<div class=\"content-ad\"></div>\n\n```sql\nCREATE SCHEMA `chapter04`;\n```\n\n먼저 일부 허구 데이터로 테이블을 로드한 다음, 두 번째 테이블을 만들고 데이터를 로드하고, 그리고 데이터로드를 적용하기 전에 세 번째 테이블을 만들겠습니다.\n\n인터페이스에서 마우스 오른쪽 버튼을 클릭하여 \"스키마 생성\"을 선택할 수는 있지만, 실행을 위해 모든 명령을 하나의 스크립트로 제공하고 있습니다. 실행하면 로그에 성공 메시지가 표시됩니다.\n\n그런 다음 좌측 사이드바에서 마우스 오른쪽 버튼을 클릭하고 새로 고침을 누르면 \"Chapter 04\" 스키마가 나타납니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 고객 테이블 생성하기\n\n아래의 SQL DDL (데이터 정의 언어) 명령문을 복사하여 붙여넣어서 고객 테이블을 생성하세요:\n\n```js\nCREATE TABLE `chapter04`.`CUSTOMERS` (\n  `customer_id` INT NULL,\n  `customer_name` VARCHAR(50) NULL,\n  `customer_address` VARCHAR(50) NULL,\n  `customer_city` VARCHAR(50) NULL,\n  `customer_state` VARCHAR(2) NULL);\n```\n\n이 섹션의 최종 목표는 데이터베이스 내에서 객체를 생성하는 것입니다. 따라서 CUSTOMERS 테이블을 만드는 것은 DDL (데이터 정의 언어) 명령입니다.\n\n<div class=\"content-ad\"></div>\n\nDDL은 데이터베이스에 무언가를 생성할 때 사용됩니다. 예를 들어, 테이블을 만들 때 사용됩니다. 이 경우에는 chapter04 스키마에 CUSTOMERS 테이블을 만들 예정이며, 이 테이블에는 고객 ID, 고객 이름, 고객 주소, 도시 및 주(지역)를 위한 열이 포함될 것입니다.\n\n자, 이제 이를 실행해 봅시다. 성공적으로 실행하면 로그에 확인 메시지가 표시될 것입니다. 화살표를 클릭한 다음 '테이블' 섹션을 클릭하면, 우리의 첫 번째 테이블이 생성된 것을 확인할 수 있습니다. 이제 이 테이블에 INSERT 문을 사용하여 가상 데이터를 채워넣는 시간입니다.\n\n# CUSTOMERS 테이블 채우기\n\nCUSTOMERS 테이블에 데이터를 추가하기 위해 INSERT INTO 문을 사용합니다. 이 문은 테이블에 새 레코드를 추가하는 데이터 조작 언어(DML)의 중요한 구성 요소입니다.\n\n<div class=\"content-ad\"></div>\n\n가상 고객 데이터를 시스템적으로 삽입하는 방법은 다음과 같습니다:\n\n```js\n-- CUSTOMERS 테이블에 데이터 삽입\n\nINSERT INTO `chapter04`.`CUSTOMERS` \n(`customer_id`, `customer_name`, `customer_address`, `customer_city`, `customer_state`)\nVALUES \n(1, 'John Smith', '123 Maple Street', 'Orlando', 'FL');\n\nINSERT INTO `chapter04`.`CUSTOMERS` \n(`customer_id`, `customer_name`, `customer_address`, `customer_city`, `customer_state`)\nVALUES \n(2, 'Susan Johnson', '456 Oak Avenue', 'Austin', 'TX');\n\nINSERT INTO `chapter04`.`CUSTOMERS` \n(`customer_id`, `customer_name`, `customer_address`, `customer_city`, `customer_state`)\nVALUES \n(3, 'Robert Brown', '789 Pine Lane', 'Phoenix', 'AZ');\n\nINSERT INTO `chapter04`.`CUSTOMERS` \n(`customer_id`, `customer_name`, `customer_address`, `customer_city`, `customer_state`)\nVALUES \n(4, 'Linda Davis', '321 Birch Blvd', 'Raleigh', 'NC');\n\nINSERT INTO `chapter04`.`CUSTOMERS` \n(`customer_id`, `customer_name`, `customer_address`, `customer_city`, `customer_state`)\nVALUES \n(5, 'Michael Miller', '654 Cedar Place', 'Atlanta', 'GA');\n```\n\n각 INSERT INTO 명령은 CUSTOMERS 테이블에 새로운 행을 추가하며 customer_id, customer_name, customer_address, customer_city, customer_state의 값을 지정합니다.\n\n이 방법을 사용하면 각기 다른 항목을 가진 다양한 항목으로 테이블이 체계적으로 채워지며, SQL 쿼리 및 작업을 위한 기반을 마련할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 명령을 실행한 후에는 샘플 레코드가 채워진 CUSTOMERS 테이블이 생성되어서, 이후 레슨에서 SQL 함수 및 테이블 조인을 탐색하는 데 도움이 될 것입니다.\n\n# ORDERS 테이블 생성 및 채우기\n\nCUSTOMERS 테이블을 설정한 후, 다음 단계는 동일한 chapter04 스키마 내에서 ORDERS 테이블을 설정하는 것입니다.\n\n이 테이블은 고객 주문에 관한 다양한 세부 정보를 기록하며, 관련된 영업 직원 및 배송 정보가 포함됩니다. ORDERS 테이블을 생성하는 방법은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nCREATE TABLE `chapter04`.`ORDERS` (\n  `order_id` INT NULL,\n  `customer_id` INT NULL,\n  `salesperson_id` INT NULL,\n  `order_date` DATETIME NULL,\n  `delivery_id` INT NULL);\n```\n\n이 테이블 스키마에는 다음이 포함되어 있습니다:\n\n- order_id: 각 주문의 고유 식별자입니다.\n- customer_id: 주문을 접수한 고객을 가리키는 CUSTOMERS 테이블과 연결된 참조입니다.\n- salesperson_id: 주문을 처리한 영업 담당자의 식별자입니다.\n- order_date: 주문이 접수된 날짜와 시간으로 DATETIME 형식을 사용합니다. 주문의 정확한 타이밍을 기록하기 위해 DATETIME 형식을 사용하는 것이 중요합니다.\n- delivery_id: 주문과 관련된 배송 세부 정보를 식별하는 식별자입니다.\n\nORDERS 테이블을 만들기 위해 이 명령을 실행한 후, MySQL Workbench(또는 선택한 SQL 관리 도구)에서 스키마 view를 새로 고침하여 chapter04 스키마 아래에 새로 생성된 테이블을 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다음으로, 이 ORDERS 테이블에 데이터를 채워넣을 것입니다. 레코드를 삽입할 때 order_date 열의 DATETIME 형식에 유의해주세요.\n\n# 현재 데이터로 ORDERS 테이블 채우기\n\nORDERS 테이블을 채우기 위해 INSERT INTO 문을 사용하여 레코드를 추가하고 있습니다.\n\n각 주문의 고유 ID, 고객 ID, 판매자 ID, 주문의 현재 날짜 및 시간, 배송 ID를 지정하는 것을 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n요거교과 자료에있는 DATETIME 유형의 order_date 컬럼에 정확한 현재 날짜와 시간을 캡처하는 SQL NOW() 함수 사용 방법을 확인해보세요:\n\n```js\nINSERT INTO `chapter04`.`ORDERS` (`order_id`, `customer_id`, `salesperson_id`, `order_date`, `delivery_id`)\nVALUES (1001, 1, 5, now(), 23);\n\nINSERT INTO `chapter04`.`ORDERS` (`order_id`, `customer_id`, `salesperson_id`, `order_date`, `delivery_id`)\nVALUES (1002, 1, 7, now(), 24);\n\nINSERT INTO `chapter04`.`ORDERS` (`order_id`, `customer_id`, `salesperson_id`, `order_date`, `delivery_id`)\nVALUES (1003, 2, 5, now(), 23);\n```\n\nNOW() 함수는 SQL에서 현재 날짜와 시간을 데이터베이스 서버가 실행 중인 시스템에서 가져오는 편리한 기능으로, 각 데이터 삽입 시 주문 날짜 컬럼이 정확하게 타임스탬프가 찍히는 것을 보장합니다.\n\n이 명령을 실행한 후, 각 레코드가 삽입 순간의 정확한 시간으로 타임스탬프가 찍히며, 현재 날짜와 시간 입력에 대한 NOW() 함수의 유용성을 잘 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\nSQL 기능은 각기 다른 데이터베이스 관리 시스템(DBMS)마다 약간 다를 수 있습니다. 사용 중인 SQL 방언(MYSQL, PostgreSQL 등)에 대한 고유한 기능과 구문을 이해하기 위해 해당 문서를 참고하는 것이 중요합니다.\n\n이 단계는 데이터베이스에 데이터를 삽입하는 방법을 보여주는 것뿐만 아니라, 다양한 DBMS 환경에서 SQL 기능 및 응용 프로그램을 익히는 중요성을 강조합니다.\n\n다음으로, SELECT 쿼리를 실행하여 삽입된 데이터를 검토하고, 세 번째이자 마지막 테이블을 생성하고 채우기로 넘어갑니다.\n\n# SALESPERSON 테이블 생성 및 채우기\n\n<div class=\"content-ad\"></div>\n\nSQL 여행을 계속하면서, 이제는 SALESPERSON 테이블 설정에 초점을 맞춥니다. 이 테이블은 영업 직원에 관한 정보를 저장하는 데 사용됩니다. 그들의 ID 및 이름을 포함합니다. 아래는 SALESPERSON 테이블을 생성하는 SQL 명령문입니다:\n\n```js\nCREATE TABLE `chapter04`.`SALESPERSON` (\n  `salesperson_id` INT NULL,\n  `salesperson_name` VARCHAR(50) NULL);\n```\n\n이 명령을 실행한 후에는 SALESPERSON 테이블이 설정되어, 영업 직원에 관한 데이터를 채울 준비가 되어 있습니다.\n\n# SALESPERSON 테이블 채우기\n\n<div class=\"content-ad\"></div>\n\n\"SALESPERSON\" 테이블에 데이터를 입력하려면 각 판매원 레코드에 대해 INSERT INTO문을 사용합니다.\n\n`INSERT` 명령의 구체적인 내용은 안내서엔 포함되어 있지 않지만, 해당 명령의 일반적인 형태는 다음과 같습니다:\n\n```js\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (1, \"판매원 1\");\n\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (2, \"판매원 2\");\n\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (3, \"판매원 3\");\n\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (4, \"판매원 4\");\n\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (5, \"판매원 5\");\n\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (6, \"판매원 6\");\n\nINSERT INTO `chapter04`.`SALESPERSON` (`salesperson_id`, `salesperson_name`)\nVALUES (7, \"판매원 7\");\n```\n\n# 주문 ID 및 고객 이름 가져오기\n\n<div class=\"content-ad\"></div>\n\n고객 이름은 CUSTOMERS 테이블에 있고 주문 ID는 ORDERS 테이블에 있습니다. 이 두 가지 다른 테이블에서 데이터를 추출해야 하는 상황입니다.\n\n이 시나리오는 SQL에서 테이블 조인의 필요성을 완벽하게 보여줍니다. 이를 통해 테이블 간의 관계를 형성하여 결합된 데이터를 검색할 수 있습니다.\n\n각 주문이 특정 고객과 연결되어 있다는 것은 ORDERS 테이블의 고객 ID로 확인할 수 있었습니다. 이 두 테이블 간에 관계형 열이 있는 것이 분명합니다.\n\n이 연결은 무작위가 아니라, 데이터베이스 설계의 의도적인 측면으로, 주문이 고객과 연관이 있는 것을 나타냅니다. 실제적으로 주문은 관련된 고객이 없이는 존재할 수 없다는 논리적인 규칙이 데이터베이스 모델링 단계에서 설정되었습니다.\n\n<div class=\"content-ad\"></div>\n\n손님 ID가 일반적으로 기본 키로 작용하는 이유는 각 손님을 고유하게 식별하여 동일한 ID를 가진 두 명의 손님이 없도록 하는 것입니다. 이는 개인이 고유한 식별 번호를 갖는 것과 유사합니다.\n\n필요한 정보를 가져 오기 위해 ORDERS 및 CUSTOMERS 테이블 간의 Inner Join을 실행할 것입니다. 이 쿼리를 어떻게 구성하는지 살펴보겠습니다:\n\n```js\nSELECT o.order_id, c.customer_name\nFROM `chapter04`.`ORDERS` o\nINNER JOIN `chapter04`.`CUSTOMERS` c \nON o.customer_id = c.customer_id;\n```\n\n- o 및 c는 각각 ORDERS 및 CUSTOMERS 테이블에 대한 별칭으로, 우리의 표기법을 간단하게하는 데 도움이 됩니다.\n- SELECT 문은 주문 테이블(o)에서 order_id 및 고객 테이블(c)에서 customer_name을 가져 오겠다고 지정합니다.\n- INNER JOIN 절은 두 테이블을 공통 customer_id 열에 연결하여 해당 고객 레코드가있는 주문 만 검색됨을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n이 접근 방식은 SQL에서 Inner Join의 강점을 보여줍니다. 이는 공통 관계에 따라 여러 테이블에서 데이터를 결합하여 분석이나 보고 목적으로 포괄적인 데이터 집합을 편집하는 데 도움이 됩니다.\n\n```js\nSELECT o.order_id, c.customer_name\nFROM ORDERS o\nINNER JOIN chapter04.CUSTOMERS c ON o.customer_id = c.customer_id;\n```\n\n이 쿼리는 주문 ID와 해당 주문을 한 고객의 이름을 반환합니다. 이는 주문 및 고객 테이블 간의 공통 customer_id 필드를 기반으로 Inner Join을 수행하여 가능합니다.\n\nSQL 쿼리에서 'o'를 ORDERS 테이블과 'c'를 CUSTOMERS 테이블에 대한 별칭으로 사용하면 구문을 간소화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 주문 ID와 고객 이름을 검색하려면 INNER JOIN을 사용하여 customer_id와 같은 공통 열을 기준으로 이러한 테이블을 연결할 수 있습니다.\n\n```js\nSELECT p.order_id, c.customer_name\nFROM ORDERS p\nINNER JOIN CUSTOMERS c ON p.customer_id = c.customer_id;\n```\n\n이 쿼리는 WHERE 절을 사용하여 두 테이블을 연결하는 대안으로 INNER JOIN 구문을 활용하여 customer_id에 따라 주문과 고객을 효과적으로 매칭합니다.\n\nINNER JOIN의 사용법을 보여드린 것은, 명확한 관계가 존재하는 데이터를 가져오는 능력 때문에 널 값이 발생하지 않습니다. INNER JOIN 대신 WHERE 절을 사용하여 직접 열을 비교할 수 있어 이와 동일한 결과를 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n두 개의 쿼리를 옆으로 배치하면 차이가 명확해집니다. 두 쿼리를 실행하면 동일한 결과가 나옵니다. INNER JOIN이 교집합 집합 이론에서의 역할을 강조합니다 — 이는 초등 교육에서 소개된 개념입니다.\n\n테이블 조인을 위해 INNER JOIN 또는 WHERE를 사용하는 것은 개인적인 선택입니다. WHERE를 선호하는 사람도 있을 수 있습니다. 이는 직접적인 연결 이해와 일치하기 때문에 테이블 연결을 간편하게 만들 수 있습니다. 그러나 두 방법 간에는 문법적인 차이가 있으므로 문법 인식이 중요합니다.\n\n```js\n# 주문 ID, 고객 이름, 영업 담당자 이름 반환\n# 3개의 테이블과의 Inner Join\n\nSELECT O.order_id, C.customer_name, S.salesperson_name\nFROM chapter04.ORDERS AS O\nINNER JOIN chapter04.CUSTOMERS AS C ON O.customer_id = C.customer_id\nINNER JOIN chapter04.SALESPERSON AS S ON O.salesperson_id = S.salesperson_id;\n```\n\n이 쿼리는 ORDERS, CUSTOMERS, SALESPERSONS 세 개의 테이블에서 INNER JOIN을 실행하여 각 주문의 주문 ID, 고객 이름 및 영업 담당자 이름을 검색합니다.\n\n<div class=\"content-ad\"></div>\n\nORDERS 테이블에서 시작하여 customer_id를 매칭하여 CUSTOMERS와 조인한 다음, salesperson_id를 기준으로 SALESPERSONS와 또 다른 조인을 수행합니다.\n\n이 쿼리는 데이터를 교차시켜 테이블 간 관련 레코드의 가장 작은 집합으로 결과를 제한하며, 세 주문과 해당하는 고객 및 영업사원을 리턴합니다.\n\n이 접근 방식은 정확하지만 INNER JOIN을 사용하지 않고 대안적인 방법으로 적용할 수도 있어 이해를 간소화할 수 있습니다.\n\n```js\nSELECT O.order_id, C.customer_name, S.salesperson_name\nFROM chapter04.ORDERS AS O, \nchapter04.CUSTOMERS AS C, \nchapter04.SALESPERSONS AS S\nWHERE O.customer_id = C.customer_id\nAND O.salesperson_id = S.salesperson_id;\n```\n\n<div class=\"content-ad\"></div>\n\n이 쿼리는 WHERE 절을 사용하여 customer_id와 salesperson_id를 일치시켜 ORDERS, CUSTOMERS, 그리고 SALESPERSON 테이블을 조인하고, 괄호 없이 주문 ID, 고객 이름, 그리고 영업 직원 이름을 검색합니다.\n\n이 접근 방식은 ID를 직접 비교하여 이해를 단순화하고, 필요한 데이터 관계를 설정하여 다수의 테이블에 확장 가능한 논리적 방식으로 INNER JOIN을 수행하는 간단한 방법을 보여줍니다.\n\n이 방법은 가장 일반적인 테이블 조인 기법 중 하나를 보여주며, 이 코스에서 더 자세히 탐구할 다양한 조인 방법을 시사합니다.\n\n# INNER JOIN 사용 및 구문에 대한 심층적 탐색\n\n<div class=\"content-ad\"></div>\n\nINNER JOIN에 대해 더 깊이 들어가 봅시다. INNER JOIN은 WHERE, ORDER BY, GROUP BY 등의 SQL 절과 결합할 수 있는 가장 일반적인 조인 유형입니다.\n\n```js\n# Inner Join - ANSI 표준\nSELECT O.order_id, C.customer_name\nFROM chapter04.ORDERS AS O\nJOIN chapter04.CUSTOMERS AS C ON O.customer_id = C.customer_id;\n```\n\n위 쿼리는 ANSI 표준 INNER JOIN을 보여주며, 이는 이전에 사용한 것으로, ANSI 표준을 준수하는 데이터베이스 관리 시스템(DBMS) 전반에서 보편적으로 지원되는 형식입니다.\n\n거의 모든 최신 DBMS가 이 표준을 지원하여 호환성을 확보합니다. 흥미로운 점은 INNER를 생략하고 JOIN만 사용하면 동일한 결과를 얻는다는 것이며, 이는 JOIN 만으로도 기본적으로 INNER JOIN으로 간주됨을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 LEFT JOIN 또는 RIGHT JOIN의 경우 \"left\" 또는 \"right\" 특정 키워드를 명시적으로 사용해야합니다.\n\n# USING 절을 사용한 INNER JOIN 단순화\n\n동일한 이름의 열을 사용하여 테이블을 조인할 때, USING 절은 간편한 방식을 제공합니다. ON 절에서 각 테이블의 열을 명시하는 대신, USING은 조인을 위한 공통 열을 직접 식별합니다. 이 방법은 코드 가독성을 향상시키며, SQL뿐만 아니라 모든 프로그래밍 관행에서 중요합니다. 명확하고 이해하기 쉬운 코드를 유지하면 향후 검토나 수정이 보다 쉬워지며, 여러분이나 다른 사람들이 코드를 유지할 때 도움이 됩니다.\n\n다음은 테이블 간에 동일한 이름을 갖는 열에 대해 USING을 사용하여 INNER JOIN을 적용하고, 결과를 필터링하고 정렬하는 방법입니다:\n\n<div class=\"content-ad\"></div>\n\n```sql\n# INNER JOIN과 WHERE, ORDER BY 사용한 쿼리\nSELECT O.order_id, C.customer_name\nFROM chapter04.ORDERS AS O\nINNER JOIN chapter04.CUSTOMERS AS C USING (customer_id)\nWHERE C.customer_name LIKE 'Bob%'\nORDER BY O.order_id DESC;\n```\n\n이 쿼리는 주문 및 고객 이름을 추출하는 데 초점을 맞추며, 구체적으로 \"Bob\"이라는 이름을 가진 고객을 대상으로 하고 주문 ID를 기준으로 내림차순으로 결과를 정렬합니다.\n\n테이블 간의 관계를 customer_id를 사용하여 활용함으로써, 이 쿼리는 근사적인 일치를 나타내는 LIKE 연산자를 사용하여 \"Bob\"으로 시작하는 모든 이름을 캡처하는 데이터를 능숙하게 필터링합니다.\n\n이 체계적인 방법은 SQL의 INNER JOIN의 적응성과 깊이를 강조하며, 다른 절과 결합될 때 데이터 분석의 범위를 크게 확장시킵니다.\n\n<div class=\"content-ad\"></div>\n\n쿼리가 여러 테이블을 조인하고 필터를 적용하거나 정렬 또는 그룹화를 실행하는 등 보다 정교한 데이터 조작 기술로 진화하는 방식을 보여줍니다. 이어지는 장에서는 더 복잡한 데이터 조작 기법을 약속합니다.\n\n# SQL에서 LEFT JOIN 탐색\n\nINNER JOIN을 탐색한 후에 이제 LEFT JOIN에 주목해 보겠습니다.\n\n이 유형의 조인은 오른쪽 테이블에 일치하는 항목이 있는지 여부와 관계없이 왼쪽 테이블의 모든 레코드를 포함하여 테이블 간 관계를 보다 폭넓게 이해할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 방법을 사용하면 이론에서 실제 SQL 코드 구현으로 원활하게 전환하여 개념을 포괄적으로 이해할 수 있습니다.\n\n```js\n# WHERE 및 ORDER BY를 사용한 Inner Join\n\nSELECT O.order_id, C.customer_name\nFROM chapter04.ORDERS AS O\nINNER JOIN chapter04.CUSTOMERS AS C USING (customer_id)\nWHERE C.customer_name LIKE 'Bob%'\nORDER BY O.order_id DESC;\n```\n\n# 데이터 검색을 위한 LEFT JOIN 활용\n\nMySQL Workbench에서 INNER JOIN을 활용한 주문 ID와 고객명을 가져오는 시나리오입니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 일부 고객이 아직 주문을하지 않았을 수 있다는 점을 인식하여, 주문 상태에 관계없이 모든 고객을 포함하는 쿼리를 찾고 있습니다. 이 경우 INNER JOIN은 목적에 부합하지 않습니다. 왜냐하면 주문이 있는 고객만 반환하기 때문입니다.\n\n이를 해결하기 위해 LEFT JOIN이 선택된 도구가 되어, 왼쪽 테이블에서 일치 항목이 없는 고객까지 모두 검색할 수 있도록 해줍니다. 따라서 보고서나 관리 인사이트를 위한 완전한 데이터 세트를 제공합니다.\n\n```js\n# Left Join – 오른쪽 테이블에서 일치 항목이 없어도 왼쪽 테이블의 모든 데이터를 가져오고자 함\nSELECT C.customer_name, O.order_id\nFROM chapter04.CUSTOMERS AS C\nLEFT JOIN chapter04.ORDERS AS O ON C.customer_id = O.customer_id;\n```\n\n# LEFT JOIN으로 쿼리 순서에 미치는 영향\n\n<div class=\"content-ad\"></div>\n\n쿼리에서 테이블의 순서는 결과에 큰 영향을 미칩니다.\n\n이를 보여주기 위해, 'C'를 CUSTOMERS에, 'P'를 CORDERS에 별칭으로 사용하여 고객 이름과 주문 ID를 가져오는 쿼리를 설정했습니다.\n\nLEFT JOIN을 실행하여, 모든 주문과 관련이 있는지 없는지와 상관없이 모든 고객을 포함하는 것이 목표였습니다. 이 기술을 사용하면 주문을 한 고객 및 주문이 없는 고객을 NULL로 나타낼 수 있습니다.\n\nNULL을 설명적인 값으로 대체하기 위해 CASE 문을 사용하는 등의 조정을 통해 출력을 더 정제할 수 있습니다. 궁극적으로 LEFT JOIN(또는 LEFT OUTER JOIN으로 교차 사용 가능)을 사용하면 왼쪽 테이블의 모든 항목이 반환되어 오른쪽 테이블에서 일치하는 레코드 여부에 관계없이 데이터 무결성을 유지할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```sql\nSELECT C.customer_name, O.order_id\nFROM chapter04.CUSTOMERS AS C\nLEFT OUTER JOIN chapter04.ORDERS AS O \nON C.customer_id = O.customer_id;\n```\n\n# LEFT JOIN vs. LEFT OUTER JOIN\n\nLEFT OUTER JOIN을 사용하면 LEFT JOIN과 동일한 결과가 나오며 SQL에서 두 용어가 서로 바꿔 사용될 수 있음을 강조합니다. 그러나 \"LEFT\"를 제거하면 쿼리의 동작이 근본적으로 변경되어 INNER JOIN으로 기본 설정되어 오른쪽 테이블과 일치하는 레코드에만 중점이 맞춰집니다.\n\n이 차이점은 \"LEFT\"를 명시하여 왼쪽 테이블의 모든 레코드를 포함시킬 중요성을 강조합니다.\n\n<div class=\"content-ad\"></div>\n\nOUTER 옵션을 사용하는 것은 주로 간소화를 위해 생략되는 경우가 많습니다. 쿼리에서 테이블 순서를 변경해 보는 것은 더 많은 통찰력을 제공할 수 있으며, 해당 조정이 쿼리 결과에 미치는 영향을 완전히 이해하기 위해 실험하는 것을 촉구합니다.\n\n```js\n# 테이블 순서를 바꾸면 결과가 달라집니다\nSELECT C.customer_name, O.order_id\nFROM chapter04.ORDERS AS P\nLEFT JOIN chapter04.CUSTOMERS AS C \nON C.customer_id = P.customer_id;\n```\n\n# LEFT JOIN 쿼리에서 테이블 순서의 영향\n\n위에 표시된 LEFT JOIN 쿼리를 실행하면, 모든 고객이 올바르게 반환되며, 그들이 주문을 한 여부에 상관없이 모두 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n테이블 순서를 반전하여 LEFT JOIN을 유지하더라도 결과가 크게 바뀐다는 것을 알 수 있습니다. 이는 INNER JOIN의 동작과 유사한 모습을 보여줍니다.\n\nLEFT 또는 RIGHT JOIN을 사용할 때 테이블의 순서가 중요하며, 방향(왼쪽 또는 오른쪽)은 어떤 테이블의 레코드가 결과에 완전하게 포함될지를 지정합니다.\n\n다음 수업에서는 이 개념을 더 깊이 탐구하여 RIGHT JOIN을 살펴보고, SQL 조인 작업 및 테이블 순서에 대한 의존성을 이해하는 데 도움이 될 것입니다.\n\n# RIGHT JOIN을 사용하여 테이블 순서 문제 해결하기\n\n<div class=\"content-ad\"></div>\n\n이전 비디오에서는 주문이 있는 경우에도 고객을 모두 포함하는 LEFT JOIN을 탐색했어요. 표의 순서를 바꾸면 INNER JOIN과 유사한 동작을 나타냈죠.\n\n표를 재배열하지 않고 이를 해결하기 위해 RIGHT JOIN이 해답이에요. 이는 오른쪽 테이블(이 경우 CUSTOMERS)의 모든 항목이 포함되도록 합니다. 왼쪽 테이블(ORDERS)에서 일치하는 값이 없어도요. 이 접근 방식은 초기 LEFT JOIN 전략을 반대로 하여 포괄적 데이터 검색을 위해 오른쪽 테이블에 중점을 둡니다.\n\n```js\n# Right Join – 왼쪽 테이블에서 일치하는 값이 없어도 오른쪽 테이블의 모든 데이터를 가져오고 싶다는 것을 나타냅니다\nSELECT C.customer_name, O.order_id\nFROM chapter04.ORDERS AS P\nRIGHT JOIN chapter04.CUSTOMERS AS C \nON C.customer_id = P.customer_id;\n```\n\n# 표준 접근법을 이용한 JOIN 전략 최적화\n\n<div class=\"content-ad\"></div>\n\n테이블 순서를 변경하는 것은 번거로울 수 있습니다. 따라서 포괄적인 보고서를 위해 항상 LEFT JOIN을 사용하는 선호도가 있습니다.\n\n이 개인적인 전략은 일관된 패턴을 확립하여 쿼리 실행을 간소화하고 학습 및 기억을 향상시킵니다. 일상 업무에서 이러한 표준을 채택하면 SQL 개념을 신속하게 이해하고 적용하는 데 도움이 됩니다. LEFT 또는 RIGHT JOIN 선택은 테이블 위치 및 모든 데이터를 포함해야 하는 요구에 따라 다릅니다.\n\n이 체계적인 방법론은 효율적이고 효과적인 데이터 검색을 위해 SQL 실습에서 일관성의 중요성을 강조합니다.\n\n# 포괄적 데이터 분석을 위한 쿼리 작성\n\n<div class=\"content-ad\"></div>\n\n해당 작업은 주문 날짜, 고객 이름 및 모든 판매원을 반환하는 쿼리를 작성하는 것입니다. 주문과 연관이 있는 여부에 관계 없이 모든 판매원을 고객 이름순으로 정렬하여야 합니다.\n\nLEFT JOIN, RIGHT JOIN 또는 INNER JOIN을 사용할지 여부는 특정 데이터 검색 목표에 따라 결정되며, 학습 과정에서 문제 해결 능력의 중요성을 강조합니다. 아래는 이 작업을 수행하는 방법입니다:\n\n```js\n# 주문 날짜, 고객 이름 및 모든 판매원을 고객 이름순으로 확인\nSELECT O.order_date, C.customer_name, S.salesperson_name\nFROM chapter04.ORDERS AS O\nJOIN chapter04.CUSTOMERS AS C ON O.customer_id = C.customer_id\nRIGHT JOIN chapter04.SALESPERSON AS S ON O.salesperson_id = S.salesperson_id\nORDER BY C.customer_name;\n```\n\n이 해결책은 모든 관련 데이터를 포함해야 하는 요구사항에 따라 적절한 JOIN 유형을 선택해야 함을 보여줍니다. 여기서는 주문과 관련이 있는지 여부에 관계 없이 모든 판매원이 나열되고 결과를 고객 이름으로 정렬합니다.\n\n<div class=\"content-ad\"></div>\n\n해당 쿼리는 정확한 데이터 쿼리 기술을 통해 비즈니스 요구 사항을 해결하는 SQL의 전략적 측면을 강조합니다.\n\n이 쿼리는 모든 주문에 대한 주문 날짜와 고객 이름을 제공하며, 모든 영업사원을 포함합니다. 연관된 주문이 있는 경우와 없는 경우 모두 결과를 정렬하여 고객 이름을 기준으로 정렬합니다. 영업사원이 연관된 주문이 없는 경우 결과에서 주문 날짜와 고객 이름 필드는 NULL일 것입니다.\n\n```js\n# 주문 날짜, 고객 이름, 모든 영업사원을 반환하며, 연관된 주문이 있는지 여부에 관계없이 결과를 고객 이름을 기준으로 정렬합니다.\nSELECT\n  CASE\n    WHEN O.order_date IS NULL THEN '주문 없음'\n    ELSE O.order_date\n  END AS order_date,\n  CASE\n    WHEN C.customer_name IS NULL THEN '주문 없음'\n    ELSE C.customer_name\n  END AS customer_name,\n  S.salesperson_name\nFROM chapter04.ORDERS AS O\nJOIN chapter04.CUSTOMERS AS C ON O.customer_id = C.customer_id\nRIGHT JOIN chapter04.SALESPERSON AS S ON O.salesperson_id = S.salesperson_id\nORDER BY C.customer_name;\n```\n\n# 조건부 서식을 사용하여 결과 향상하기\n\n<div class=\"content-ad\"></div>\n\nCASE 문을 사용하여 조건부 논리를 실행함으로써 보고서에는 널 값이 표시되지 않도록 보장합니다.\n\n그 대신, 누락된 주문 날짜 또는 고객 이름은 '주문 없음'으로 레이블이 지정되어, 임원 검토를 위해 명확성과 유틸리티를 향상시켜줍니다.\n\n이 쿼리는 주문 결과를 고객 이름별로 철저하게 정렬하여, 조직적이고 정보를 얻기 쉬운 출력을 제공하여 추가 분석이나 프레젠테이션에 적합합니다.\n\n```js\nSELECT\n  CASE\n    WHEN O.order_date IS NULL THEN '주문 없음'\n    ELSE O.order_date\n  END AS order_date,\n  CASE\n    WHEN C.customer_name IS NULL THEN '주문 없음'\n    ELSE C.customer_name\n  END AS customer_name,\n  S.salesperson_name\nFROM chapter04.ORDERS AS O\nRIGHT JOIN chapter04.CUSTOMERS AS C ON O.customer_id = C.customer_id\nRIGHT JOIN chapter04.SALESPERSON AS S ON O.salesperson_id = S.salesperson_id\nORDER BY C.customer_name;\n```\n\n<div class=\"content-ad\"></div>\n\n이 방식은 철저한 데이터 수집의 즉각적인 요구 사항 뿐만 아니라 널 값(null values)을 의미 있는 자리 표시자로 대체함으로써 보고서의 표현을 개선하여, 경영 총괄 또는 분석 처리에 대비한 완전히 형식화된 뷰를 제공합니다.\n\n# 참조 무결성 오류 해결\n\nORDERS 테이블에 “고아(orphans)” 레코드를 추가하는 것 — 해당 고객이나 판매원과 연관이 없는 주문 —은 관계형 데이터베이스에서 참조 무결성을 유지하는 도전을 강조합니다.\n\n이 개념은 데이터베이스의 모든 레코드가 적절하게 연결되어 있어 고아 데이터의 존재를 방지하는 것을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 이 예제는 이러한 제약 조건을 우회하여 SQL이 이러한 불일치를 식별하는 데 어떻게 사용될 수 있는지 보여주기 위해 일부러 만들어졌습니다.\n\n```js\nINSERT INTO `chapter04`.`ORDERS` (`order_id`, `customer_id`, `salesperson_id`, `order_date`, `delivery_id`)\nVALUES (1004, 10, 6, NOW(), 23);\n```\n\n성공적으로 실행된 이 삽입은 참조 무결성 검사가 적용되지 않았음을 나타내며, 유효한 고객 링크가 없는 주문을 만들 수 있게 했습니다.\n\n이 시나리오는 성능 저하와 데이터 불일치로 이어질 수 있는 일반적인 데이터베이스 문제를 나타냅니다. 성능 문제를 해결하기 위해 일시적으로 참조 무결성을 비활성화하는 경우도 있지만, 속도를 위해 데이터 무결성이 더 손상될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n오늘은 주체 없는 레코드를 식별하는 SQL 전략에 대해 살펴보겠습니다. 데이터 신뢰성과 시스템 무결성을 보장하기 위해 견고한 데이터베이스 관리 관행의 중요성을 강조할 것입니다.\n\n# SQL 조인을 활용한 주체 없는 레코드 식별\n\n의도적으로 데이터베이스에 도입된 주체 없는 레코드를 식별하는 과제에 대처하기 위해 SQL 조인의 사용법을 살펴보겠습니다.\n\n이러한 문제를 생성하고 해결하는 일련의 과정은 SQL 지식을 실제 시나리오에서 실용적으로 적용하는 가치 있는 학습 도구로 작용합니다.\n\n<div class=\"content-ad\"></div>\n\nLEFT JOIN을 사용하여 고객 및 해당 주문 ID를 모두 검색하여 주문이 존재하지 않는 경우에는 주문이 없는 상태인 NULL 값을 사용하여 고아 레코드를 감지하려고 시도했습니다:\n\n```js\n# 누락된 주문 식별을 위한 Left Join\nSELECT C.customer_name, O.order_id\nFROM chapter04.CUSTOMERS AS C\nLEFT OUTER JOIN chapter04.ORDERS AS O ON C.customer_id = O.customer_id;\n```\n\n이 쿼리는 모든 고객을 성공적으로 나열하며, 주문이 누락될 때 NULL 주문 ID로 나타냅니다. 그러나 모든 종류의 고아 레코드를 감지하는 문제를 완전히 해결하지는 않습니다. RIGHT JOIN으로 전환하면 고객이 없는 주문을 제외하고 연결된 고객이 없는 주문을 나열할 수 있습니다.\n\n모든 불일치 사항을 종합적으로 식별하기 위한 논리적 단계는 LEFT 및 RIGHT JOIN의 통찰을 결합하려고 하는 FULL OUTER JOIN을 사용하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\nFULL OUTER JOIN은 모든 SQL 데이터베이스 관리 시스템에서 일반적으로 지원되지 않으므로 MySQL을 포함한 SQL에서 모든 고아 레코드를 식별하는 포괄적인 솔루션을 제공하기 위해 분리된 LEFT 및 RIGHT JOIN 쿼리의 결과를 병합하기 위해 UNION을 사용하는 것이 논리적인 다음 단계입니다. 이 방법은 다음 레슨에서 자세히 다룰 예정입니다.\n\n# UNION과 UNION ALL 데이터 검색 활용하기\n\n주문 및 고객을 모두 식별하는 도전을 해결하기 위해 관련이 없는 것을 포함하여 SQL은 UNION과 UNION ALL 명령을 제공합니다. 이러한 명령은 별도의 쿼리 결과를 병합하여 완전한 데이터 세트를 형성합니다.\n\n- LEFT OUTER JOIN: 주문이 없는 모든 고객을 검색하며, NULL로 표시된 미배치 주문을 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nSELECT C.customer_name, O.order_id\n FROM chapter04.CUSTOMERS AS C\n LEFT OUTER JOIN chapter04.ORDERS AS O ON C.customer_id = O.customer_id;\n```\n\n- RIGHT OUTER JOIN: 연결된 고객이 없어도 모든 주문을 포착합니다.\n\n```js\nSELECT C.customer_name, O.order_id\n FROM chapter04.CUSTOMERS AS C\n RIGHT OUTER JOIN chapter04.ORDERS AS O ON C.customer_id = O.customer_id;\n```\n\n- UNION ALL: 위의 조인 결과를 결합하여 중복을 허용합니다.\n- UNION: UNION ALL과 유사하지만 중복 레코드를 제거하여 고유한 결과만 반환합니다.\n\n<div class=\"content-ad\"></div>\n\nUNION과 UNION ALL의 주요 차이점은 중복 핸들링에 있습니다: UNION ALL은 중복을 포함하여 모든 레코드를 포함하고, UNION은 중복을 필터링하여 고유한 결과만 표시합니다.\n\n이 차이는 종합적인 데이터 포함이 필요한 작업 또는 정제된, 고유한 결과가 필요한 작업에 중요합니다.\n\nUNION 명령을 사용할 때 중요한 고려 사항은 결합된 쿼리 전체에 걸친 열의 개수와 유형을 일치시키고 데이터 무결성 및 쿼리 성능을 보장하기 위해 일관된 열 순서를 유지하는 것입니다.\n\nUNION 작업은 성능에 영향을 미칠 수 있지만, FULL OUTER JOIN을 지원하지 않는 환경에서 원하는 데이터 컴파일을 달성하는 유일한 해결책일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 테이블 조인 요약\n\n이번 개요는 SQL Server 커뮤니티에서 주목받는 인물인 Steve Stedman이 작성한 차트를 참조하고 있습니다. 해당 차트는 SQL Server 및 MySQL와 같은 다른 SQL 데이터베이스 시스템에서 적용 가능한 다양한 조인 유형을 설명하고 있습니다.\n\nStedman의 블로그는 데이터베이스 지식을 널리 보급해 왔으며 SQL Server의 미묘한 점들을 강의 및 참고 자료를 통해 제공하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 기본 선택 및 조인: 두 테이블에서 데이터를 선택하는 것으로 시작하여 INNER JOIN(교차), LEFT 및 RIGHT OUTER JOINS를 다루며 'OUTER' 키워드 없이도 동등성을 강조합니다.\n- 고급 조인 개념: SEMI-JOIN 및 ANTI-SEMI-JOIN을 소개하며 SQL의 EXISTS 연산자를 사용하여 데이터를 고유하게 필터링하고, 한 테이블에서 부분 또는 배타적 데이터 집합을 검색하는 방법을 보여줍니다.\n- CROSS 및 FULL OUTER JOINS: CROSS JOIN(카테시안 곱)과 FULL OUTER JOIN(일치하는 항목이 있는 경우와 없는 모든 레코드를 결합)을 구별하며, 그래픽 표현에서 보이는 유사성에 대해 경계를 주의합니다.\n- 연합 작업: UNION 및 UNION ALL을 사용하여 직접적인 지원이 없는 시스템에서 FULL OUTER JOIN 효과를 모방하는 방법을 설명하며 포괄적인 데이터 통합을 달성합니다.\n- 복잡한 관계: 다양한 조인 유형을 통해 다중 테이블 관계를 처리하는 것으로 마무리되며, 질의 복잡성 및 데이터 검색 능력을 향상시킵니다.\n\n이 차트는 기본부터 복잡한 시나리오까지 SQL 조인을 적용하는 실용적인 가이드로, SQL에서 테이블 조인 기술을 숙달하기 위해 실습을 장려합니다.\n\n# *SQL 테이블 조인에 대한 결론\n\n이 글을 통해 SQL에서 테이블 조인의 세계로 들어가 보았습니다. 관계형 데이터베이스를 다루는 데 중요한 측면 중 하나입니다. Steve Stedman의 블로그와 MySQL Workbench와 같은 도구에서의 실습을 통해, 다양한 조인 유형을 통해 효과적인 데이터 조작을 둘러싼 복잡성의 층을 해제해 나갔습니다.\n\n<div class=\"content-ad\"></div>\n\nINNER JOIN과 LEFT 및 RIGHT OUTER JOIN의 적응성부터 직접적인 지원이 없는 시스템에서 FULL OUTER JOIN을 구현하는 도전에 대처하는 기본 조작부터, 조인 유형의 선택이 쿼리 결과와 성능에 직접적 영향을 미친다는 것을 배웠습니다. 우리는 참조 무결성의 가치를 강조했고 고아 레코드를 감지하고 해결하는 방법을 강조하여 데이터 일관성과 신뢰성을 보장했습니다.\n\nUNION 및 UNION ALL을 결합하여 완전한 조인을 시뮬레이트하고 CROSS JOIN을 특정 시나리오에 적용함으로써 SQL의 다양성을 강조하여 복잡한 데이터 분석 요구를 충족시키는 능력을 보여주었습니다. 반 조인과 안티-반 조인과 같은 고급 개념을 소개하여 SQL이 특정 데이터 필터링과 선택을 위해 능력을 강조하여 전통적인 조인 경계를 넘어섰습니다.\n\n이 기사는 쿼리 표준을 설정하고 코드 가독성을 유지하며 데이터베이스 유지, 이해 및 확장을 시간이 지남에 걸쳐 용이하게 하는 중요성을 재확인했습니다. 우리는 계속된 학습과 실험을 촉구하며, 마주한 각 도전을 극복함으로써 SQL 능력을 향상시키고 전문가들이 복잡한 비즈니스 문제를 효율적으로 정확하게 해결할 수 있도록 장비를 되찾습니다.\n\n요약하자면, 테이블 조인은 단순히 기술적 도구가 아니라, 원시 데이터를 가치 있는 통찰로 변환하는 의미 있는 쿼리를 만드는 기본입니다. 우리가 향향할 미래 챕터로 나아가면서, 자신감과 전문지식을 갖춘 방대한 데이터베이스 세계를 탐색하는 데 필요한 견고한 지식 기반과 실무 경험을 지속적으로 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n감사합니다! 🐼❤️","ogImage":{"url":"/assets/img/2024-06-19-MasteringSQLJoins_0.png"},"coverImage":"/assets/img/2024-06-19-MasteringSQLJoins_0.png","tag":["Tech"],"readingTime":31},{"title":"파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략","description":"","date":"2024-06-19 16:29","slug":"2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement","content":"\n\n프로젝트에서 데이터베이스와 상호 작용하는 프로그래밍을 할 때, 쿼리를 어떻게 조직화하고 재사용할지 고민하는 일이 종종 있어요. 이럴 때 몇몇 개발자는 쿼리를 보다 동적으로 만들기 위해 문자열을 연결하는 함수를 만들기도 하고, 다른 사람들은 이 쿼리를 정의하는 변수를 만들기를 선호하기도 해요. 일부 더 고급 개발자들은 쿼리를 정의할 때 SQLAlchemy 객체 선언을 사용하기도 하는데, 이 방법은 배우는 곡선이 있어서 더 복잡한 쿼리를 다룰 때 개발 프로세스를 어렵게 만들 수 있어요.\n\n어느 날, 저는 코드를 지나치게 복잡하게 만들지 않고도 조직적이고 재사용 가능한 방식으로 작업하기 위한 해결책을 찾던 중 흥미로운 라이브러리인 aiosql을 우연히 발견했어요.\n\n<div class=\"content-ad\"></div>\n\n다음 기사에서는 aiosql 라이브러리를 어떻게 사용하는지를 검토하고 문서에서 설명되는 내용과 함께 다른 컨텍스트에서 구현하는 데 사용한 몇 가지 방법을 공유하겠습니다.\n\n# ⚙️ aiosql 라이브러리란 무엇인가요?\n\nAiosql은 🐍파이썬 라이브러리로, SQL 쿼리를 주요 파이썬 프로젝트 코드와 분리된 파일에 쉽게 작성할 수 있도록 도와줍니다. 이러한 쿼리는 SQL 파일에 저장되며, 이후에는 🐍파이썬 객체 내의 메서드로 변환됩니다.\n\nAiosql의 또 다른 주목할 만한 기능은 매개변수를 받아들이는 동적 메서드를 생성할 수 있는 능력으로, 유연한 쿼리 실행과 기본 데이터베이스와의 효과적인 상호 작용을 가능케합니다.\n\n<div class=\"content-ad\"></div>\n\nSQL 쿼리를 Python 코드에서 분리함으로써 코드를 더 깔끔하고 모듈식으로 유지하는 데 도움이 됩니다. 이는 프로젝트의 가독성과 유지보수성을 향상시킵니다.\n\n# ⚙️ aiosql의 작동 방식\n\n다이어그램에서 볼 수 있듯이 SQL 파일에서 모든 쿼리를 가져와서 Python 코드에서 쿼리 헤더에 정의된 이름으로 호출하여 사용할 수 있습니다. 이후에 Python 코드에서 필요한 매개변수를 직접 전달하여 쿼리를 실행할 수 있습니다. 이를 통해 쿼리를 재사용하고 유지보수하기 쉽게 만들 수 있습니다.\n\n<img src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n# ⚙️ Aiosql 라이브러리 핵심 기능\n\n아래에서는 이 라이브러리가 이미 갖고 있거나 사용에 기반한 기능을 가질 수 있는 일련의 기능을 공유하겠습니다:\n\n- 데이터베이스 작업을 위한 CRUD 기능 제공 (Create: Insert, Read: Select, Update, Delete).\n- Python 코드와 SQL 코드를 분리하여 여러 데이터베이스가 있는 프로젝트에서 쿼리를 찾기 쉽게 함.\n- 각 쿼리에 설명적인 이름과 독스트링을 할당할 수 있어 Python 함수와 유사하게 쿼리를 문서화할 수 있음.\n- 프로젝트 내에서 쿼리 카탈로그를 작성하도록 지원하여 엔터티, 데이터베이스 또는 기타 그룹별 식별을 용이하게 함.\n- 동적 값 전달과 필요에 따라 수정할 수 있는 동적 쿼리를 쉽게 생성할 수 있음.\n\n![PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2](/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2.png)\n\n<div class=\"content-ad\"></div>\n\n# ⚙️ Aiosql 튜토리얼\n\n## 🔧 사전 준비 사항\n\n- 🐳 도커\n- 🐙 도커 컴포즈\n- 🐍 Python 라이브러리 설치:\n\n```js\npip install aiosql pandas\n```\n\n<div class=\"content-ad\"></div>\n\n# 🚀 빠른 시작\n\n## 🛠️ 포스트그레스 데이터베이스 만들기\n\n- 1️⃣ — 이 저장소를 복제합니다: aiosql-tutorial\n\n```js\ngit clone https://github.com/r0mymendez/aiosql-tutorial.git\n```\n\n<div class=\"content-ad\"></div>\n\n- 2️⃣ 'postgres' 폴더로 디렉토리 변경해주세요\n\n```js\ncd aiosql-tutorial/postgres\n```\n\n- 3️⃣ PostgreSQL 데이터베이스를 생성해주세요 → 터미널에서 실행하세요:\n\n```js\ndocker-compose -f docker-compose.yml up --build\n```\n\n<div class=\"content-ad\"></div>\n\n- 4️⃣ 이제 컨테이너가 실행 중인지 확인하세요 → 터미널에서 다음을 실행해보세요:\n\n```js\ndocker ps\n```\n\n- 5️⃣ CSV 파일을 로드하세요 → 컨테이너 내에서 CSV 파일을 로드하려면 다음 명령어를 실행하세요:\n\n```js\ncd src\npython3 etl.py\n```\n\n<div class=\"content-ad\"></div>\n\n# 🏥 병원 데이터\n\naiosql을 구현하기 위해 Synthea에서 제공하는 데이터셋을 사용할 것입니다. 이 데이터는 매사추세츠 지역 인구의 다양한 변수를 고려한 시뮬레이션에서 생성된 합성 데이터입니다. 이 데이터셋에서는 `conditions`, `encounters`, `patients` 테이블을 사용할 것입니다.\n\n# 👥 사용자 이야기\n\n실제 상황을 반영하기 위해 3가지 사용 사례를 만들어보겠습니다:\n* 1️⃣ — 데이터 분석가로서, 방문 횟수가 90번 백분위 이상인 환자 목록을 검색할 수 있기를 원합니다. 이를 통해 병원에서 가장 활발한 환자들을 식별할 수 있습니다. 또한 나중에 쉽게 조정할 수 있도록 이 백분위를 구성할 수 있기를 원합니다.\n* 2️⃣ — **연구원 또는 데이터 분석가**로서, 일정 기간 동안 가장 빈도가 높은 10가지 진단을 받은 환자 데이터에 액세스하고, 추세를 분석하고 의료 서비스의 품질을 개선하기 위해 사용하고 싶습니다.\n* 3️⃣ — **마케팅 분석가**로서, 환자 만족도 조사용 테이블을 작성하고, 의료 서비스의 품질에 대한 피드백을 수집하여 개선 조치를 취하고자 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 🚀 구현\n\n우리가 만들 것인 사용자 스토리에 기반하여, 실행해야 하는 쿼리와 스크립트를 로드할 두 개의 파일을 정의할 것입니다:\n\n- patients.sql: 회복 중인 환자 데이터에 관련된 모든 쿼리가 있는 곳입니다.\n- visits.sql: 설문 조사와 같은 방문에 관련된 모든 쿼리가 있는 곳입니다.\n\n그러므로 우리 프로젝트에서는 이러한 폴더 및 파일 구조를 가지게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n📁 db\n\n    - 📁 queries\n        - 📄 patients.sql\n        - 📄 visits.sql\n\n📄 main.ipynb\n```\n\n1️⃣ — Python 라이브러리를 가져옵시다.\n\n```js\nimport aiosql\nimport psycopg2\nimport pandas as pd\n```\n\n2️⃣ — SQL 쿼리를 가져와 데이터베이스 드라이버를 설정합시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nsql = aiosql.from_path('src/db/queries', 'psycopg2')\n```\n\n3️⃣ — PostgreSQL 데이터베이스에 연결합니다.\n\n```js\npostgres_secrets = {'host': 'localhost','port': 5432, 'user': 'postgres', 'password': 'postgres', 'dbname': 'postgres'}\nconn = psycopg2.connect(**postgres_secrets)\nconn.autocommit = True\n```\n\n## 👥 사용자 이야기 I: 정적 값들\n\n<div class=\"content-ad\"></div>\n\n위의 사용자 스토리를 기반으로, 먼저 90번째 백분위수 이상의 방문 빈도를 가진 환자 목록을 검색할 수 있는 쿼리를 생성할 것입니다.\n\n1️⃣ — sql 파일에서 첫 번째 사용자 스토리에 대한 쿼리가 있습니다.\n\n다음은 aiosq에서 SQL 문이 구성되는 세 가지 구성 요소입니다:\n\n- 📗 Name: 이는 Python 코드에서 쿼리를 호출하는 데 사용되는 서술적인 이름입니다. 다음 예제에서 이름은 “fn_get_patients_adove_90th_percentile\" 입니다.\n- 📗 Description: 이는 문서 문자열을 생성하는 데 사용되는 자세한 설명입니다. 쿼리의 목적과 맥락에 대해 더 포괄적으로 설명합니다. 다음 예제에서 설명은 “90번째 백분위수 이상의 방문보다 더 많은 환자를 가져옵니다…\" 입니다.\n- 📗 Query: 여기에는 데이터베이스에서 실행될 SQL 쿼리가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n📄 sql: db/queries/patients.sql\n\n```js\n-- 이름: fn_get_patients_adove_90th_percentile\n-- 모든 환자 중 방문이 90 번째 백분위수보다 많은 환자들을 가져옵니다. 모든 데이터는 encounters 테이블에 저장되어 있습니다.\n WITH patient_visits AS (\n     SELECT\n         patient,\n         COUNT(*) AS visit_count\n     FROM\n         hospital.encounters\n     GROUP BY\n         patient\n ),\n percentil_n AS (\n   SELECT\n     percentile_cont(0.9) WITHIN GROUP (ORDER BY visit_count) AS p_visits\n   FROM\n   patient_visits\n )\n SELECT \n     pv.patient, \n     pv.visit_count\n FROM \n     patient_visits pv\n CROSS JOIN \n     percentil_n pn\n WHERE \n     pv.visit_count >= pn.p_visits;\n```\n\n2️⃣ — 'fn_get_patients_above_90th_percentile' SQL 함수를 데이터베이스 연결 'conn'을 사용하여 실행합니다.\n\n```js\nresponse = sql.fn_get_patients_above_90th_percentile(conn)\n```\n\n<div class=\"content-ad\"></div>\n\n3️⃣ — 이제 응답 객체를 판다스 데이터프레임으로 변환하여 데이터 조작을 더 쉽게 할 수 있습니다.\n\n```python\ndata = pd.DataFrame([item for item in response], columns=['patient_id', 'num_visit'])\n# 데이터프레임 표시.\ndata\n```\n\n![이미지](/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_3.png)\n\n쿼리를 확인하고 싶으면 다음 코드를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nprint(sql.fn_get_patients_adove_90th_percentile.sql)\n```\n\n## 👥 사용자 스토리 I: 동적 값\n\n이제 우리는 다른 백분위 값들을 받아들일 수 있는 쿼리를 생성하여 전달된 값에 기반하여 동적으로 수정될 수 있도록 할 것입니다. 우리의 경우, 75번째 백분위 이상의 환자 목록을 얻는 예시를 제공할 것입니다.\n\n```js\n-- name: fn_get_patients_above_n_percentile\n WITH patient_visits AS (\n     SELECT\n         patient,\n         COUNT(*) AS visit_count\n     FROM\n         hospital.encounters\n     GROUP BY\n         patient\n ),\n percentil_n AS (\n   SELECT\n     percentile_cont(:percentil_value) WITHIN GROUP (ORDER BY visit_count) AS p_visits\n   FROM\n   patient_visits\n )\n SELECT \n     pv.patient, \n     pv.visit_count\n FROM \n     patient_visits pv\n CROSS JOIN \n     percentil_n pn\n WHERE \n     pv.visit_count >= pn.p_visits;\n```\n\n<div class=\"content-ad\"></div>\n\n1️⃣ - 다음 코드는 입력값으로 다른 백분위 값을 허용하는 동적 SQL 쿼리를 실행합니다.\n\n```js\n# 이 경우에는 75 백분위 이상의 환자들을 얻습니다.\nresponse = sql.fn_get_patients_above_n_percentile(conn, percentil_value=0.75)\ndata = pd.DataFrame([item for item in response], columns=['patient_id', 'num_visit'])\n```\n\n## 👥 사용자 스토리 II\n\n이 사용자 스토리를 해결하기 위해 지정된 기간 내에서 가장 일반적인 질환이 있는 환자들을 검색하는 쿼리를 생성할 것입니다. 이 쿼리는 동적이며, 향후 관심 있는 질환 수의 변화를 허용할 것입니다.\n이 쿼리는 세 개의 매개변수를 받습니다:\n\n<div class=\"content-ad\"></div>\n\n- num_condition: 우리가 관심 있는 조건의 수를 제한할 수 있게 해줄 것입니다 (예: 가장 일반적인 상위 10개 조건).\n- period_start_date와 period_start_end는 데이터를 검색하려는 시간 창을 정의할 것입니다.\n\n```js\n--name: fn_get_patients_top_conditions\n--주어진 기간 동안 최상위 조건을 가진 환자 가져오기, 환자는 조건을 가진 날 수와 데이터 소스가 병원 스키마인 기준으로 정렬됩니다.\nwith top_n_conditions as(\n  SELECT code, description, COUNT(*) \n   FROM hospital.CONDITIONS \n  GROUP BY code,description \n  ORDER BY COUNT(*) DESC \n  LIMIT :num_condition\n),\ntop_n_condition_patients as (\n  SELECT \n     p.ID, \n     p.FIRST, \n     p.LAST, \n     p.CITY, \n     p.GENDER, \n     EXTRACT(YEAR FROM AGE(p.BIRTHDATE)) AS age,\n     c.start condition_start_date,\n     c.stop condition_stop_date,\n     EXTRACT(DAY FROM (c.stop - c.start )) AS condition_days, \n     c.encounter,\n     c.code,\n     c.description\n   from hospital.patients p \n   inner join hospital.conditions c on c.patient = p.id\n   inner join top_n_conditions t on t.code=c.code\n)\nselect * \n from top_n_condition_patients\n where condition_start_date between :period_start_date and :period_start_end;\n```\n\n```js\nresponse = sql.fn_get_patients_top_conditions(conn, num_condition_days=10, \n period_start_date='2022–01–01', \n period_start_end='2022–12–31')\ncolumn_name=['id', 'first','last','city','gender',\n'age','condition_start_date','condition_stop_date','condition_days','encounter','code','description']\ndata = pd.DataFrame([item for item in response], columns=column_name)\ndata.head()\n```\n\n## 👥 사용자 이야기 III\n\n<div class=\"content-ad\"></div>\n\n이제 aiosql을 사용하여 테이블을 생성할 것입니다. 만약 SQL 코드를 살펴보시면 # 기호가 추가된 것을 보실 수 있습니다. 이러한 기호들은 aiosql이 다양한 작업을 식별하는 데 사용됩니다.\n\n```js\n--name: fn_create_survey_table#\nCREATE TABLE HOSPITAL.VISIT_SURVEY(\n ID SERIAL PRIMARY KEY,\n PATIENT_ID VARCHAR(50),\n SURVEY_DATE TIMESTAMP,\n RATING INT,\n COMMENTS TEXT,\n CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n<img src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_4.png\" />\n\n1️⃣ — 'fn_create_survey_table' SQL 함수를 실행하여 데이터베이스에 새 테이블을 만드세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nsql.fn_create_survey_table(conn)\n```\n\n```js\n# output\nCREATE TABLE\n```\n\n2️⃣ — 테이블이 생성되면 아래 삽입문을 사용하여 환자의 리뷰를 삽입할 수 있습니다.\n\n```js\n-- name: fn_add_one_visit_survey<!\ninsert into HOSPITAL.VISIT_SURVEY(PATIENT_ID,SURVEY_DATE,RATING,COMMENTS) \n values (:patient_id, :survey_date, :rating,:comments) returning ID;\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n# 새로운 방문 조사 레코드 추가\nsql.fn_add_one_visit_survey(conn, \n patient_id='8b9a93f6-3df3-203d-932f-f456e00d2c01', \n survey_date='2022-01-01', \n rating=5,\n comments='이 병원 정말 좋아요!' )\n```\n\n3️⃣ — 이제 여러 리뷰를 로드하기 위해 새로운 삽입문을 활용할 것입니다. 이 리뷰들은 딕셔너리 목록에 저장되어 있습니다 (파이썬의 각 딕셔너리는 리뷰에 해당합니다). 이를 수행하기 위해 비슷한 쿼리를 활용하겠지만 그 이름을 수정해야 합니다.\n\n```js\n-- name: fn_add_many_visit_survey*!\n insert into HOSPITAL.VISIT_SURVEY(PATIENT_ID,SURVEY_DATE,RATING,COMMENTS) \n values (:patient_id, :survey_date, :rating ,:comments) returning ID;\n```\n\n```js\n# 여러 방문 조사 레코드 추가\nresponse_survey = [\n     {\n       'patient_id': '8b9a93f6-3df3-203d-932f-f456e00d2c01',\n       'survey_date': '2022-01-01',\n       'rating': 3,\n       'comments': '서비스는 좋았어요. 다만 대기 시간이 조금 길었습니다.'\n     },\n     {\n       'patient_id': '7c8a93f6-4df3-203d-932f-f456e00d2c02',\n       'survey_date': '2022-02-01',\n       'rating': 4,\n       'comments': '직원들이 매우 친절했어요!'\n     },\n     {\n       'patient_id': '6b7a93f6-5ef3-203d-932f-f456e00d2c03',\n       'survey_date': '2022-03-01',\n       'rating': 3,\n       'comments': '대기 시간이 조금 길었습니다.'\n     }\n]\nsql.fn_add_many_visit_survey(conn, response_survey)\n```\n\n<div class=\"content-ad\"></div>\n\n# 📚 프로젝트 쿼리 카탈로그\n\n튜토리얼 초반에는 프로젝트용 쿼리 카탈로그를 만들 수 있는 가능성을 언급했습니다. 이 라이브러리는 이 기능을 직접 제공하지는 않지만, 나의 GitHub 저장소에서 이 튜토리얼의 완전한 코드와 데이터에 액세스하여 이를 수행하는 방법을 확인할 수 있습니다.\n\n유용하게 사용하시면, ⭐️ 스타를 남겨주시고 새로운 글 알림을 받기 위해 팔로우해주시면 저에게 큰 도움이 됩니다. 기술 커뮤니티에서 성장하고 더 많은 콘텐츠를 제작할 수 있게 될 것입니다.\n\n# 🔍 최종 결론\n\n<div class=\"content-ad\"></div>\n\n- 다양성과 유틸리티: 저는 aiosql이 다른 프로젝트에서 쿼리를 효율적으로 구현할 수 있게 해주는 유용한 라이브러리라고 생각합니다. 이 라이브러리는 SQL 쿼리를 관리하고 실행하는 구조적인 방법을 제공하여 본 코드베이스와 별도로 처리할 수 있어 가독성과 유지 보수성을 향상시킵니다.\n- 유연한 쿼리 처리: aiosql은 데이터베이스 연결을 통해 쿼리를 직접 실행할 수 있는 환경을 제공하지만, 저의 프로젝트에서는 주로 Python 코드로 이미 설정한 클래스를 사용하여 SQL 코드를 반환하고 실행합니다.\n- 다른 데이터베이스: 쿼리를 저장하고 관리할 수 있는 기능은 SQL 데이터베이스를 넘어서기도 합니다. 예를 들어 이 접근 방식은 Neo4j와 같은 NoSQL 데이터베이스에도 적용할 수 있습니다. 구조적인 방식으로 쿼리를 구성하고 처리함으로써 다양한 유형의 데이터베이스와의 상호 작용을 최적화할 수 있습니다.\n\n## 📚 참고 자료\n\n학습하고 싶다면...","ogImage":{"url":"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_0.png"},"coverImage":"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_0.png","tag":["Tech"],"readingTime":12}],"page":"74","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}