{"pageProps":{"posts":[{"title":"럭키 참스 시리얼, 얼마나 행운을 가져다줄까","description":"","date":"2024-06-22 16:40","slug":"2024-06-22-HowLuckyisaBowlofLuckyCharms","content":"\n\ntl;dr 버전: 학생 팀이 럭키참스 시리얼 그릇이 박스 전체에 걸쳐 동일하게 \"운이 좋은지\"를 결정하기 위한 실험을 디자인하고 수행하는 데 도움을 주었습니다. 결과는 별로다. 우리는 한 그릇당 약 2.7개 정도의 전체 참을 추가함에 따라 감소한다고 추정합니다. 첫 번째 그릇부터 마지막 그릇까지의 참은 50% 이상 줄어드는 것과 일치합니다. 시리얼의 무게도 역할을 하는 것으로 나타나며, 그릇을 일정하게 유지할 때 당 1g의 시리얼마다 평균적으로 0.5개 더 많은 참이 있는 것으로 추정됩니다. 그릇과 무게 사이의 상호 작용은 통계적으로 유의하지 않습니다.\n\n데이터, 코드, 사진 등을 확인하려면 이 GitHub 저장소를 참조하세요.\n\n[![BowlofLuckyCharms Image](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_0.png)](이미지 주소)\n\n## 배경\n\n<div class=\"content-ad\"></div>\n\n2010년대 초반에는 \"더블 스탭\" 오레오가 실제로 더블 스태프인지 여부에 대한 조사로 인해 인터넷 상에서 소란이 있었습니다. (실제로는 아닙니다.) 흥미로운 아이디어였고, 그 이후로 많은 자료가 작성되었습니다. 첫걸음으로 여기를 참고해보세요. 이 토론은 충분한 주목을 받아 몇몇 교사들이 수업 활동으로 해당 실험을 반복하는 것을 글쎄요 증명했으며, 현지 학생들은 10년 이상 후에도 자신들의 학교에서 유사한 실험을 수행했다고 보고했습니다.\n\n## 소개\n\n2023년 여름 어느 아침, 아침 식사로 럭키 참스를 먹고 있었습니다. 상자는 거의 비어가고, \"새 상자를 열 수 있게 될 때까지 기다릴 수 없어...\" 하고 내게 한숨을 내쉬었습니다. 저와 비슷한 사람이거나 수백만 명의 다른 사람들처럼, 당신이 럭키 참스를 좋아하고 기억할 수 있는 한을 넘어 60년간 생산되어 온 제품이었습니다. 그들은 정말로 마법 같이 맛있어요. 그런데 그 여름 아침에 숟가락을 쥔 채 앉아서 먹고 있는 그 시리얼 그릇이 전보다 조금 덜 마법 같았습니다. 뭔가 부족해 보였어요. (물론 상징인데요.) 제 생각일까요? 이 효과가 실재성이 있을까요? 그렇다면 측정할 수 있을까요?\n\n당시 대학생 확률 및 통계 과목을 가르치고 있었고, 네 명의 학생과 함께 이를 밝혀보기로 결심했습니다.\n\n<div class=\"content-ad\"></div>\n\n# 실험과 데이터\n\n토론을 거친 후, 팀은 다음 재료와 방법을 결정했습니다.\n\n## 재료\n\n- 가족 사이즈 럭키 참스 6박스 (18.6oz, 527g)\n- 전자 주방 저울\n- 플라스틱 “그릇” 2개, A 그릇과 B 그릇 (각각 40.125g 및 28.375g)\n- 폐기물을 담을 큰 그릇, 일부 휴지봉투, 기타 용품\n\n<div class=\"content-ad\"></div>\n\n럭키 참스는 지역 소매업체인 월마트에서 구입했어요. n = 6 상자에 특별한 점은 없었는데, 이것은 한 번의 여행으로 6층 카파로 홀의 6층에 두 손으로 운반할 수 있는 상자의 수였어요. 부엌 저울은 시리얼의 무게를 측정하기 위한 것이었는데, 팀은 이것이 중요할 것이라고 생각했고, 또한 시럽을 정확히 매번 샘플링하는 데 과도하게 전념하고 싶지 않았어요.\n\n![이미지](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_1.png)\n\n# 방법\n\n이 실험의 목적을 위해 \"그릇\"은 상자에서 권장된 대로 (1컵 또는 36g) 대략적으로 1인분의 시리얼을 의미했어요. 아침 식사로 럭키 참스의 36g를 먹기에는 작은 요술사나 리틀매직나인을 제외하고는 불가능하다 고 봐도 될 만큼이나 적은 양이었어요. 팀은 그릇 크기 일치에 특별히 까다롭지 않았고, 1컵에 가까운 양이라면 충분하다고 생각했어요. 어차피 부엌 저울로 시리얼의 질량을 고려하고 있었기 때문에 우리는 건강한 범위의 관측 무게를 목표로 삼았어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_2.png\" />\n\n시리얼 한 그릇씩은 상자에서 바로 플라스틱 용기로 붓고, 체중을 측정한 후에 토스트된 오트밀은 마시멜로와 분리되어 버려졌습니다. 그런 다음, 다음 여덟 가지 행운의 매력적인 종류가 인식되고 숫자가 기록되었습니다: 핑크 하트, 무지개, 보라색 굴초, 파란 달, 녹색 클로버, 유니콘, 맛있는 빨간 풍선, 그리고 주황색 별.\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_3.png\" />\n\n가끔 그릇 안에는 작은 마시멜로 조각이 있었습니다; 모든 매력이 100% 완전하지는 않았습니다. 이를 처리하기 위해, 팀은 조각을 매력의 종류(녹색 클로버, 파란 달 등)로 분류하려고 노력했으며, 그 종류를 확인할 수 있다면 해당 분류에서 그 조각을 1로 계산했습니다. 조각이 불명확하거나 유형 식별에 너무 작으면 버렸습니다.\n\n<div class=\"content-ad\"></div>\n\n# 데이터\n데이터는 두 차례에 걸쳐 수집되었습니다. 학생들은 캐릭터를 부어서 세는 것을 쌍으로 협력하여 수행했습니다. 저는 저울과 무게 값을 기록해 컴퓨터에 입력하기 위해 불려지는 동안 하드 복사본을 도왔습니다. 팀은 데이터 수집 분위기에 접어들었고 실험이 끝날 때까지 4명의 학생이 독립적으로 캐릭터를 부어서 세었습니다.\n\n![이미지](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_4.png)\n\n플라스틱 용기 + 시리얼은 매 라운드마다 함께 저울에 올려 차곡차곡 무게를 측정하였고 실험 초기에 측정된 용기의 무게가 관찰된 총 무게에서 빼졌습니다. 캐릭터는 각각의 열에 입력되어 총계가 계산되었습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_5.png)\n\n# 측정된 변수\n\n- 상자: 상자 번호 (1부터 6번)\n- 그릇: 각 상자의 연속 그릇 (1부터 13까지 범위)\n- 관측: 상자 전체에서 그릇의 관찰된 순서 (1부터 69까지)\n- 전체 무게: 플라스틱 용기와 시리얼의 무게(그램)\n- 무게: 용기의 무게를 뺀 시리얼의 무게(그램)\n- 하트, 별, 기타: 해당 그릇에 대한 그 매력의 개수\n- 전체 매력: 여러 매력의 총합\n\n![이미지](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n여기 R 코드로 데이터 세트의 상위 부분(첫 6행)을 읽고 표시하는 방법이 있습니다. 이 데이터 및 모든 코드는 이 GitHub 저장소에서 공유됩니다.\n\n```R\nlibrary(readxl)\nLucky <- read_excel(\"Lucky.xlsx\")\nLucky$Box <- as.factor(Lucky$Box)\nhead(Lucky)\n```\n\n이 데이터를 사용하면 관찰된 무게의 평균은 약 46.3g이었고, 한 그릇에 특정 매력의 최대 수는 15개였습니다(분홍색 하트가 자주색 편못과 동일함). 실제로 이 데이터 집합에 대한 통계를 계산하는 데 하루 종일 할애할 수 있지만, 현재는 주로 Totcharms 및 그것이 그릇과 어느 정도 무게와 관련이 있는지에 초점을 맞추고 있습니다.\n\n다음은 그릇별 Totcharms의 그래프입니다. 상자로 색칠되었습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nLucky |> ggplot(aes(x = Bowl, y = Totcharms, color = Box)) + \n  geom_point(size = 3) +\n  labs(y = '# Charms') -> p1\np1\n```\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_7.png\" />\n\n여기서는 볼의 증가에 따라 Totcharms가 감소하는 명확한 추세를 볼 수 있으며, 패턴이 놀랍도록 선형적입니다. 약간의 곡률이 있을 수 있습니다. 색상을 구분하기 어렵기 때문에 라인 플롯을 만들고 몇 가지 시리즈를 강조해 보겠습니다:\n\n```js\nsizes <- c(2, 1, 2, 1, 1, 1)\nalphas <- c(1, 0.2, 1, 0.2, 0.2, 0.2)\nLucky |> ggplot(aes(x = Bowl, y = Totcharms)) +\n  geom_line(aes(colour = Box, linewidth = Box, alpha = Box)) +\n  scale_discrete_manual(\"linewidth\", values = sizes) +\n  scale_alpha_manual(values = alphas, guide = \"none\")\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_8.png\" />\n\n모든 시리즈가 전반적으로 하강하는 추세를 보이지만, 각 상자별로 그 경로는 다양합니다. Box 3이 높은 위치에서 시작해 몇 개의 그릇마다 높은 위치에 머물다가 10그릇까지 부드럽게 내려가다가 곧 허사로 떨어지는 모습을 주목해 보세요. Box 1은 군중 중에서 가장 낮은 위치에서 시작하여 5그릇 후에 증가하며, 8그릇에 정점을 찍은 뒤 12그릇까지 급격히 하강하는 모습을 살펴보세요. 데이터에 따르면 Box 3 꼭대기 부근에 매력을 집중시켰지만, Box 1 중간 부분에 몰려 있었습니다. 일부 상자는 왔다갔다 하고, 다른 상자는 더 일직선적으로 내려가죠. 하지만 모두를 합치면 전반적으로 감소하는 선형적인 추세를 보입니다. 모든 상자가 적어도 11그릇까지는 갔지만, 12그릇을 가진 상자는 2개 뿐이었고, 하나의 상자인 Box 4만 13그릇까지 간 것을 유의하세요.\n\n이제 Totcharms 대 Weight를 비교해 보겠습니다:\n\n```js\nLucky |> ggplot(aes(x = Weight, y = Totcharms, color = Box)) + \n  geom_point(size = 3) +\n  labs(x = 'Weight (g)', y = '# Charms') -> p2\np2\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Plot Image](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_9.png)\n\n이 플롯은 소음이 많습니다. 최소 무게가 30g 미만부터 최대 무게가 70g 근처까지 다양한 무게 범위를 갖고 있습니다. 특이하게 하나의 그릇이 예외적으로 무거운 무게를 기록했습니다. 이 이상치에는 명백한 설명이 없지만 조금 더 깊이 파고들어 Weight 대 Bowl을 플롯하면 어떤 통찰을 얻을 수 있을지도 모릅니다.\n\n```js\nLucky |> ggplot(aes(x = Bowl, y = Weight, color = Box)) + \n  geom_point(size = 3) + ylim(5, 75) +\n  labs(y = 'Weight (g)') -> p3\np3\n```\n\n![Plot Image](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_10.png)\n\n\n<div class=\"content-ad\"></div>\n\n아쉽게도 그 특정 데이터 포인트의 출처는 시간이 흘러 잊혀진 상태입니다. 하지만 팀이 처음 마무리한 상자였기 때문에 최종적으로 남은 시리얼 양을 판단하는 것이 어려웠을 수도 있으며, 아마 모든 잔여물이 그 마지막 그릇에 붓겨진 것일 수도 있습니다. 아침 식사할 때도 종종 시리얼 상자를 비우려고 할 때 비슷한 일을 하곤 합니다. 만약 그 70g의 12번째 그릇을 (예를 들어) 40g과 30g의 그릇 두 개로 나누었다면, 단 하나가 아니라 두 상자가 모두 13그릇까지 갈 수도 있었고, 아마 아래 모델들이 데이터에 조금 더 잘 맞을지도 모릅니다. 아쉽게도, 그렇게 알 수 없습니다. 과학적인 기업이란 바로 그런 것이죠.\n\n복적과 무게 자체로는 선형 관계가 크지 않지만, Totcharms, Bowl 및 Weight 간에 숨겨진 관계가 있습니다. 이 관계는 3D 시각화로 가장 잘 탐색할 수 있습니다:\n\n```js\nlibrary(plotly)\nfig <- plot_ly(Lucky, x = ~Bowl, y = ~Weight, z = ~Totcharms, color = ~Box) |>\n  add_markers() |>\n  layout(scene = list(xaxis = list(title = '그릇'),\n                                   yaxis = list(title = '무게 (g)'),\n                                   zaxis = list(title = '# 별')),\n                      legend=list(title=list(text='상자')))\nfig\n```\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_11.png\" />\n\n<div class=\"content-ad\"></div>\n\n3D 플롯은 정말 멋져요, 하지만 위의 정적 디스플레이는 데이터에 정의를 제대로 하지 못해요. 저는 대부분의 모바일/데스크톱 브라우저에서 작동하는 대화형 플롯 버전을 다음 링크에 설정했어요:\n\n거기로 가서 데이터를 돌리고, 확대 및 축소, 이동 등을 확인해보세요. 정확히 올바르게 돌리면 데이터가 3D 공간의 평면 주위에 흩뿌려진 것을 볼 수 있을 거에요. 이것이 우리가 여러 선형 회귀 모델에서 찾고 있는 관계의 정확한 종류에요 (우리는 잠시 후에 다룰 거에요).\n\n# 모델 맞추기\n\n이제 이 변수들 간의 선형 관계를 양적으로 측정해보도록 할게요. Totcharms와 Bowl 간의 단순 선형 회귀 모델부터 시작할 거에요.\n\n<div class=\"content-ad\"></div>\n\n# 그릇\n\n다음은 모델입니다:\n\n```js\nmod1 <- lm(Totcharms ~ 그릇, data = Lucky)\nsummary(mod1)\n```\n\n```js\n## \n## Call:\n## lm(formula = Totcharms ~ 그릇, data = Lucky)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -16.7629  -5.7629  -0.4327   6.2277  22.2277 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)    \n## (Intercept)  55.1309     2.1237  25.960  < 2e-16 ***\n## 그릇         -2.6698     0.2985  -8.945 4.81e-13 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 8.313 on 67 degrees of freedom\n## Multiple R-squared:  0.5442, Adjusted R-squared:  0.5374 \n## F-statistic: 80.01 on 1 and 67 DF,  p-value: 4.807e-13\n```\n\n<div class=\"content-ad\"></div>\n\n볼이 고치에 강하게 선형으로 연관되어 있음을 알 수 있습니다. 볼의 기울기는 대략 -2.7이며, 다시 말해, 럭키 참즈 한 그릇을 추가로 먹을 때마다 평균 Totcharms가 2.7개 줄어들 것으로 추정됩니다. 결정 계수(R²)는 0.5442로, Totcharms의 분산의 약 54%가 Bowl을 예측 변수로 사용한 회귀 모델에 의해 설명됨을 의미합니다. 다음으로 적절한 잔차 분석을 포함해야 하지만 일단 건너뛸 것입니다. 말 그대로, 잔차 그림이 상대적으로 잘 작동합니다. 기본값으로 회귀선에 대한 신뢰 대역이 포함된 적합된 선 그래프를 확인해 보겠습니다:\n\n```js\np1 + geom_smooth(method = \"lm\", aes(group=1), colour=\"black\")\n```\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_12.png\" />\n\n단 명확한 감소 추세가 있는 멋진 관계입니다.\n\n<div class=\"content-ad\"></div>\n\n# 무게에 대한\n\n우리는 무게에 대해 동일한 작업을 할 것이며, 일단 그릇을 무시할 것입니다. 여기서 시작합니다:\n\n```js\nmod2 <- lm(Totcharms ~ Weight, data = Lucky)\nsummary(mod2)\n```\n\n```js\n## \n## Call:\n## lm(formula = Totcharms ~ Weight, data = Lucky)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -27.0151  -8.7745   0.6901   7.8328  24.4701 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)  \n## (Intercept)  22.1370    10.5650   2.095   0.0399 *\n## Weight        0.3502     0.2256   1.552   0.1254  \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 12.1 on 67 degrees of freedom\n## Multiple R-squared:  0.0347, Adjusted R-squared:  0.02029 \n## F-statistic: 2.409 on 1 and 67 DF,  p-value: 0.1254\n```\n\n<div class=\"content-ad\"></div>\n\nWeight가 단독으로 Totcharms를 예측하는 데 유용하지 않다고 생각합니다. 이는 이전에 본 산점도와 일치합니다. Weight의 기울기는 0.3502로, 행운의 매 당 1g 추가는 평균적으로 0.35 매의 Totcharms 증가에 해당합니다. 이는 합리적으로 들립니다: 시리얼이 많으면 매력도 많아집니다. 결정 계수는 상당히 낮습니다: R² = 0.0347, 즉 Totcharms의 분산 중 약 NONE%가 Weight를 예측 변수로 사용하는 회귀 모형에 의해 설명된다는 것입니다. 괜찮아요; Weight는 시리얼 양의 가변성을 조절하기 위한 보조 장치였습니다. 여기서 잔차 분석 결과는 생각했던 것보다 그리 나쁘지 않았습니다. 무엇보다 위/아래 끝의 극단적인 관측치가 포함되어 있기 때문에 일부 문제가 예상되었습니다. 완성도를 위해 또 다른 적합 선 그래플을 넣었습니다:\n\n```js\np2 + geom_smooth(method = \"lm\", aes(group=1), colour=\"black\")\n```\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_13.png\" />\n\n원래 ggpubr 패키지를 사용하여 이러한 적합 선 그래프를 함께 놓고 토론에서 공간을 절약하려고 계획했지만, 그래프가 협소하고 정보가 나오지 않았습니다. 어쨌든, 내가 하려던 건 이거였어요:\n\n<div class=\"content-ad\"></div>\n\n```r\nlibrary(ggpubr)\nggarrange(p1 + geom_smooth(method = \"lm\", aes(group=1), colour=\"black\"),\n          p2 + geom_smooth(method = \"lm\", aes(group=1), colour=\"black\"),\n          align = 'h', labels=c('A', 'B'), legend = \"right\",\n          common.legend = TRUE)\n```\n\n# Multiple regression\n\n이제 재미있는 부분으로 넘어가 봅시다: Totcharms ~ Bowl 및 Totcharms ~ Weight 관계를 개별적으로 탐색해 보았지만, 이들을 함께 넣으면 어떻게 될까요? 알아보죠:\n\n```r\nmod3 <- lm(Totcharms ~ Bowl + Weight, data = Lucky)\nsummary(mod3)\n```\n\n<div class=\"content-ad\"></div>\n\n```js\r\n## \n## 호출:\n## lm(formula = Totcharms ~ Bowl + Weight, data = Lucky)\n## \n## 잔차:\n##      Min       1Q   Median       3Q      Max \n## -12.8825  -5.4425  -0.9975   5.2475  26.5304 \n## \n## 계수:\n##             추정치 표준 오차 t 값 유의확률    \n## (Intercept)  33.3168     6.8655   4.853 7.78e-06 ***\n## Bowl         -2.7552     0.2796  -9.855 1.35e-14 ***\n## Weight        0.4819     0.1452   3.318  0.00148 ** \n## ---\n## 유의수준:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## 잔차 표준 오차: 7.754, 자유도: 66\n## 다중 R-제곱:  0.6094, 조정 R-제곱:  0.5976 \n## F-통계량: 51.49, 자유도: 2, 66,  p값: 3.363e-14\r\n```\n\n여기 보세요! 이제 Bowl과 Weight는 Totcharms와 강한 선형 관계가 있습니다. Bowl의 기울기는 거의 이전과 같은 -2.7이지만, Weight의 추정 기울기는 거의 0.5 charms로 증가했습니다. 각각의 추가적인 1g 시리얼에 대해. (조정된) 다중 R²가 거의 60%로 상승했습니다. 이는 샘플 크기(n = 6), 데이터셋의 일반적인 잡음 수준 및 (작은 마시멜로 조각이 1로 계산된다든가 하는) 의문을 제기할만한 설계 선택에도 불구하고 주목할 만한 것입니다. 회고적으로, 데이터가 훨씬 나쁠 수 있었음에도 불구하고 꽤 놀라운 것입니다.야외에서 손수 수집된 실제 데이터는 그리 친절하지 않은 경우가 흔합니다.\n\n# 회귀 평면 추가\n\n이 시각화를 위한 코드는 다른 예제들보다 좀 더 복잡하고, 간결함을 위해 생략되었지만, 이 모든 것을 GitHub Gist에서 확인할 수 있습니다. 이제 그림을 살펴보도록 하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_14.png)\n\n다시 말해요: 정적 버전만으로는 데이터를 충분히 표현할 수 없어요. 대화형 버전을 확인해보세요:\n\n대화형 3D 플롯은 정말 재미있어요. 그래프와 놀면서 즐기시는 만큼 저도 즐겁게 살포시 플레이했어요. 마지막으로, tl;dr 문구에서 우리는 \"보울과 무게 사이의 상호작용이 중요하지 않다\"고 주장했어요. 독자는 다음과 같은 출력을 통해 확인할 수 있어요 (출력은 생략됨):\n\n```js\nsummary(lm(Totcharms ~ Bowl * Weight, data = Lucky))\n```\n\n<div class=\"content-ad\"></div>\n\n# 토론 및 질문\n\n원래 전체적으로 생각했던 것은 모든 것이 내 상상의 산물이거나 효과가 너무 작아서 'Lucky Charms'가 많이 필요할 수 있다는 것이었습니다. 두 가지 모두 잘못되었습니다. 효과는 실제로 존재하며, 손으로 두 개 상자분을 사용하여 감지할 수만 있다는 것을 깨달았습니다.\n\n# 럭키 참 드롭\n\n전체 모델을 통해 우리는 빠르게 몇 가지 놀라운 결론에 도달합니다. 예를 들어 'Lucky Charms' 상자의 첫 번째 그릇에 얼마나 많은 부적을 추정하십니까? 이 연구에서 평균 무게가 46.3g임을 앞서 확인했습니다. 상자 = 1 일 때, 모델은 평균 부적(Charms) 수를 어림잡아 추정합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n33.3168 + (-2.7552)*1 + 0.4819*46.3\n```\n\n```js\n## [1] 52.87357\n```\n\n그래서 첫 번째 시리얼 그릇에는 약 53개의 매료가 들어 있어요—음, 입맛이 벌써 돕니다. 마지막 그릇은 어떨까요? 좋아요, 모든 상자가 13그릇까지 만들지는 못했지만, 모든 상자가 11그릇까지는 만들었어요. 매료가 몇 개 들어 있을까요?\n\n```js\n33.3168 + (-2.7552)*11 + 0.4819*46.3\n```\n\n<div class=\"content-ad\"></div>\n\n\n## [1] 25.32157\n\n\n와우. 평균 25.3개의 매력이 있네요. 이것은 첫 그릇부터 열한 번째 그릇까지 매력이 52% 감소했다는 것을 의미합니다. 아니요, 제 상상력이 아닙니다. 다변수 선형 회귀 모델이나 화려한 3D 플롯은 잊어버리세요, 배고픈 유아도 눈을 가리고 이 차이를 감지할 수 있을 것입니다.\n\n다음 질문은 무엇일까요? 왜 감소하는 걸까요? 물리적인 측면에서 분석해보면 이렇게 설명할 수 있습니다: 럭키 참스를 박스 단위로 간단한 기계적인 혼합물로 간주합니다. 설탕이 올라간 구운 꺾은 꺼풀과 마시멜로우의 혼합입니다. 운송 중에 흔들림이나 가게 선반에 올려놓는 과정, 집으로 운송하는 과정, 그리고 찬장 주변의 활동 등 많은 외부 힘들이 상자를 괴롭힙니다. 그 결과 약간 밀도가 낮은 마시멜로우는 상자의 윗부분으로 이동하고, 밀도가 높은 구운 꺾은 꺼풀은 상자의 아랫부분으로 쌓입니다.\n\n이런 논리는 타당하다고 생각합니다. 하지만 이에 관련된 몇 가지 질문은 답이 없습니다:\n\n<div class=\"content-ad\"></div>\n\n- 개별 매력 유형에 대해서도 동일한 패턴이 유지되는가요? (빠르게 봤을 때 \"아니요\"라는 것을 시사합니다.)\n- 연관성이 정말 선형인가요, 아니면 더 복잡한 모델이 관계를 더 잘 설명할까요?\n- 우리가 간과한 중요한 요인은 무엇인가요?\n- 행운의 부적이 감소하는 것을 늦추는 데 사용할 수 있는 전략은 무엇인가요?\n\n- 우리는 매운맛을 더 잘 섞기 위해 상자를 똑똑하게 흔들 수 있을까요? (어떻게든)\n- 보관 방법은 어떤가요? 상자를 거꾸로 보관하는 것이 도움이 될까요?\n- 아니면 옆으로 평평하게 두는 것은요?\n- 등등.\n\n이러한 미해결된 질문들은 다음 기회로 미루어야 할 것 같습니다.\n\n# 다음 단계\n\n<div class=\"content-ad\"></div>\n\n오리지널 실험 이후 2023년 여름, 더 많은 학생 그룹들과 몇 번의 실험을 다시 진행했어요. 첫 번째는 2023년 11월 YSU 메가매쓰 데이에서 중학생들과 함께한 실험이었어요. 메가매쓰 학생들에게 매우 구체적인 지침을 주지 않아서, 상자에서 시리얼 봉지를 빼고 탁상 위로 펴진 봉지 중앙에서 스쿱을 하는 것을 발견했어요. 그들을 탓할 수 없었어요; 봉지를 펼쳐놓은 것이 중앙에서 시리얼을 스쿱하기 더 편리하니까요. 안타깝게도, 이 접근법은 존재했을 지도 하는 어떠한 천연 밀도 정렬 순서도 완전히 파괴했고, 이것이 우리가 의심하는 핵심 기저 요소인 실험의 무결성을 저해했어요. 게다가, 아무도 부모님이 든지 Lucky Charms를 그렇게 먹는 걸 허락하지 않을 거라고 생각해요.\n\n두 번째 실험은 2024년 2월 YSU 수학 축제에서 고등학생들을 대상으로 진행한 두 개의 워크샵 연속으로 진행되었어요. 이번에는 그들을 위해 준비가 돼 있었어요. 더 자세한 지침이 담긴 데이터 수집 시트를 만들어 배포했어요. 여기에서 찾아볼 수 있어요. 추가 데이터셋은 GitHub의 extraData 디렉토리에서 확인할 수 있어요.\n\n앞으로, Lucky Charm의 손실을 더 정확히 추정하기 위해 더 많은 데이터가 필요하고, 상자 안의 Charm을 더 균일하게 분배하는 전략을 테스트하는 것이 흥미로울 것 같아요. 성공한다면, 상자의 첫 번째 그릇은 그렇게 마법적이지 않을 수 있겠지만, 반면에 마지막 그릇들은 새로운 Lucky Charms 상자를 열기를 기다리는 짐 같이 느껴지지 않을 수도 있겠죠!\n\n# 감사의 글\n\n<div class=\"content-ad\"></div>\n\n이 실험과 결과는 여름 2023에 STAT 3743 수업을 듣는 Brenna Brocker, Kate Coppola, Gavin Duwe, 그리고 Haziq Rabbani 네 명의 학생들의 열정적인 도움과 섬세한 주의 덕분에 가능했습니다. 나는 그들이 이 통계적인 길을 함께 걸어준 데 대해 감사하게 생각합니다. 또한, Youngstown State University의 수학 및 통계학 부서가 이 연구와 YSU MegaMath Day 및 YSU MathFest에서의 추가 데이터 수집을 지원해 준 데에도 감사드립니다.\n\n# 공표사항\n\n이미 명백하게 나타났겠지만, 저자와 네 명의 학생 모두가 Lucky Charms 팬이라는 것을 알려드립니다. 여기서 보고된 결과는 General Mills, Inc.와 그 계열사, 공장 생산 기준, 그리고 일하는 사람들 또는 로봇들에 대한 비평이 아니며, 우리는 모두 동일한 물리 법칙에 얽힘을 알아야 합니다. 아침 식사 시리얼 상자도 포함됩니다.\n\n또한, 전체 자료를 재실행하여 수집한 이 추가 데이터를 엿보았습니다. 내가 볼 수 있는 한에, 그 영향은 여전히 존재하지만, 그 정도는 그리 극적이지 않습니다. 원래 추정한 것보다 효과가 실제로 더 작은지, 아니면 중/고등학교 설정에서의 데이터 수집 프로토콜과 어떤 관련이 있는지 알 수 없습니다. 시간과 더 많은 자료가 말해줄 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료 및 코드 예제\n\n이 문서를 작성하는 동안 필요한 그래프를 만들기 위한 코드를 찾아다니면서 대부분의 링크들을 기록해 보았습니다. 하지만 몇 가지 빠뜨린 링크들이 있을 수도 있습니다. 만약 빠진 부분이 있으면 댓글로 알려주시면 수정하도록 하겠습니다.\n\n- https://stackoverflow.com/questions/74750478/correct-syntax-for-manually-scaling-the-width-of-lines-in-ggplot\n- https://www.statology.org/ggplot-default-colors/\n- https://stackoverflow.com/questions/37348719/ggplot2-single-regression-line-when-colour-is-coded-for-by-a-variable\n- http://blog.recursiveprocess.com/2013/03/03/oreo-original-vs-double-vs-mega/\n- https://stackoverflow.com/questions/38331198/add-regression-plane-to-3d-scatter-plot-in-plotly\n- https://stackoverflow.com/questions/38593153/plotly-regression-line-r\n- https://stackoverflow.com/questions/15633714/adding-a-regression-line-on-a-ggplot","ogImage":{"url":"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_0.png"},"coverImage":"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_0.png","tag":["Tech"],"readingTime":16},{"title":"치우친 분포 시각화에 유용한 데이터 시각화 기법 5가지","description":"","date":"2024-06-22 16:38","slug":"2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution","content":"\n\n## 클러스터링된 데이터에서 숨겨진 패턴을 발견하는 주요 기술\n\n왜곡된 데이터는 매우 불균형한 분포를 갖는 데이터를 가리킵니다. 대부분의 데이터 포인트가 분포의 왼쪽에 집중되어 있으며 긴 꼬리가 오른쪽 쪽으로 뻗어 나간다(오른쪽으로 치우친 경우) 또는 그 반대(왼쪽으로 치우친 경우), 더 복잡한 왜곡 패턴일 수 있습니다. 긴 꼬리(희소 데이터)가 그래픽 공간을 지배하며 대부분의 데이터 포인트를 플롯 모서리로 압축하여 클러스터링된 데이터 대다수의 근본적인 패턴을 확인하기 어렵게 만듭니다.\n\n이 글에서는 왜곡된 분포를 가진 데이터를 시각화하는 강력한 방법을 요약했습니다.\n\n# 투명도, 비어 있는 원, 색상 및 주변 분포를 사용하여 클러스터링된 데이터 패턴 드러내기\n\n<div class=\"content-ad\"></div>\n\n왼쪽의 scatterplot은 주택 판매량과 가격 간의 관계를 보여줍니다. 높은 판매량에서의 희소한 데이터 포인트는 대부분의 데이터를 플롯의 왼쪽 가장자리로 쫓아가게 합니다. 이는 중요한 데이터 포인트 클러스터링 및 겹침으로 이어지며 기저 분포 패턴을 가리게 만듭니다.\n\n![scatterplot](/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_0.png)\n\n오른쪽의 개선된 scatterplot은 데이터의 비대칭성을 진단하고 기저 데이터 구조를 드러내기 위해 몇 가지 간단한 기술을 사용합니다:\n\n- 점 크기 축소 및 윤곽 내의 모양 (속이 채워진 원 대신 열린 원과 같은)은 데이터가 겹치는 것을 완화하는 데 도움이 됩니다.\n- 데이터 포인트의 투명도는 데이터 클러스터링의 정도를 드러내는 데 도움을 줍니다.\n- 색상은 데이터 패턴을 드러내는 데 중요한 도구입니다. 이 경우 다른 도시의 점들을 다양한 색상으로 보여줌으로써 도시가 가격과 판매에 미치는 영향이 데이터 변동성의 중요한 소스임을 강조합니다.\n- 단변량 분포의 주변 시각화는 비대칭성의 원인을 보여줍니다. 여기서는 판매량 (x 축) 및 가격 (y 축)의 분포를 바코드 이미지와 밀도 플롯으로 표시했습니다. 이를 통해 판매량이 주요하게 비대칭된 변수임을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n# 데이터를 각 왜도 소스별로 서브플롯으로 분할하기\n\n위 그래프는 해당 도시가 데이터 왜도의 중요한 기여 요소임을 시사합니다. 데이터 왜도 분포에 도시의 영향을 제거하려면 여기서는 각 도시별로 서브플롯으로 그래프를 나누어 각 도시에 대한 축 스케일이 별도로 표시됩니다.\n\n![Plot](/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_1.png)\n\n도시 변수를 데이터 왜도의 중요한 소스로 식별하고, 각 도시별로 서브플롯을 만들어 데이터 왜도를 줄인 데 운이 좋았지만, 다른 데이터 시각화 작업에서 이렇게 할 수 있는 것은 항상 쉽거나 가능한 것은 아닙니다. 또한, 고집 센 이상치는 단일 변수 내에서 존재할 수 있으며, 서브플롯을 만들어 해결할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n아래 토론에서는 도시 변수의 서브플롯에 의존하지 않고, 왜곡된 데이터셋을 시각화하는 기술을 직접 시연할 것입니다.\n\n## 왜곡된 데이터 시각화를 위한 2D 히스토그램 생성\n\n2D 히스토그램은 산점도에서 마주치는 데이터 왜곡을 해결하기 위한 가장 효율적인 접근 방식 중 하나입니다. 이는 x 및 y 축을 따라 n개의 간격/바구니를 생성하고, 플롯을 n × n 셀의 그리드로 나눕니다. 각 셀 안에 떨어지는 데이터 포인트 수를 세어서 컬러 스케일에 매핑합니다. 더 높은 바구니 번호는 더 높은 해상도를 제공합니다.\n\n![2D 히스토그램으로 왜곡된 데이터 시각화하기](/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 2D 밀도 플롯 생성\n\n2D 밀도 플롯은 2D 히스토그램과 유사하지만 이산적 간격에서 카운트를 생성하는 대신에 기본 연속 데이터의 확률 밀도 함수(PDF)를 추정합니다. (밀도는 연속적 등고선 또는 이산 그리드로 그려낼 수 있습니다.)\n\n왼쪽에 있는 밀도 플롯은 플롯의 좌하단에 데이터 포인트의 극도로 집중된 것을 강조하고, 나머지는 아주 드문 데이터 포인트들이 최소 밀도값을 갖고 전혀 배경으로 완전히 섞인 것을 보여줍니다 (밀도가 0인 배경).\n\n<img src=\"/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_3.png\" />\n\n<div class=\"content-ad\"></div>\n\n💡 보다 눈에 띄게 희소한 데이터를 보기 쉽게 만들기 위해, 먼저 밀도 값을 세제곱근으로 변환했습니다. 이 값들을 색상 스케일에 매핑했습니다. 세제곱근 변환은 밀도 값을 소수점 숫자의 값으로 증가시키지만 (밀도 값의) 영(零)에는 영향을 주지 않습니다. 이러한 방식으로 변환된 데이터는 배경 위에 \"높게\" 떠 있어서 더욱 쉽게 구별할 수 있도록 해주며, 밀집된 데이터 중심과 희소한 데이터 지역을 아주 잘 드러내줍니다. (그러나 소수점 숫자의 팽창 효과는 경우에 따라 원하지 않는 시각적 효과를 초래할 수 있음을 나중 예제에서 보여드릴게요.)\n\n# 데이터를 색상에 반영한 수학적 변환\n\n오른쪽에 있는 밀도 플롯은 수학적으로 변환된 데이터를 색상에 매핑하는 방법이 어떻게 숨겨진 데이터 구조를 효과적으로 드러내는지 명확히 보여줍니다. 하지만 저의 가장 좋아하는 예제는 아래에 있답니다.\n\n히트맵은 제곤지북 반경 당 아프리카 인구를 보여줍니다: 최소 밀도는 0(지도상의 이집트 대부분 지역 등)이며, 0.0000004에서 20,000까지의 비영(非零)값 범위가 있습니다. 대부분의 밀도 값은 제한된 지리적 지역에서만 발견됩니다. 밀도는 클래식 버리디스 색상 스케일로 반영되었습니다.\n\n<div class=\"content-ad\"></div>\n\n만약 데이터 변환을 하지 않은 상태에서는 지도가 완전히 검게 나옵니다 (왼쪽 플롯 참조): 매우 흩어진 대 값들(밝은 색으로 표시되는)이 작은 숫자들의 대부분에 의해 압도당하고 무시당합니다. \n\n<img src=\"/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_4.png\" />\n\n로그 변환은 넓게 퍼진 데이터를 처리하는 흔한 방법입니다. 이 방법은 데이터를 더 정규화된 분포로 변환하여 시각화하기 쉽게 만듭니다. 이 방법은 이집트의 나일 강을 따라 밀집된 인구와 같은 더 잘 그려진 데이터 패턴을 가진 히트맵을 만듭니다. (색상 막대는 원본 데이터가 아니라 변환된 데이터로 레이블이 지정되어 있어 해석이 쉽습니다). 그러나 이집트 대부분의 지역은 회색으로 가려져 있습니다. 이곳은 0인 인구 값을 가지고 있어 로그에 정의되지 않으므로 데이터가 \"누락된 값\"(-무한대, 구체적으로)으로 처리됩니다.\n\n의사 로그 변환은 큰 수를 위한 전통적인 로그 연산을 수행하나 값이 0에 접근할 때 선형 스케일로 점진적으로 전환됩니다. 큰 값과 분수적인 값, 그리고 0(음수 값 포함)을 부드럽게 처리합니다. 이러한 변환은 주요 지리적 위치와 지도상의 광활한 사하라 사막의 가혹한 환대를 강조한 잘 정의된 데이터 패턴을 보여주는 인상적인 히트맵을 생성합니다. 놀라운 기법의 자세한 내용은 이 기사에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n의사로그 변환과 비교하면, 높은 베이스(예: 7 ~ 10)를 가진 루트 변환은 유사한 시각적 효과를 얻습니다. 그러나 이집트와 일부 다른 장소는 검게 처리됩니다. 이는 루트 변환 때문에 분수를 팽창시키지만 0은 영향을 받지 않기 때문입니다. 이로 인해 변환된 분수와 0 사이에 급격한 불연속성이 발생하여, 이집트와 주변 지역 사이에 갑작스러운 색상 전환으로 반영됩니다. (더 많은 토론은 위에 링크된 동일한 기사에서 찾을 수 있습니다)\n\n여담으로 말씀드리자면, 원시 데이터의 수학적 변환이 아닌, 대신 색상과 이상치의 그래픽적 조정과 어떻게 연결해야 하는지를 전략적으로 조정할 수도 있습니다. 예를 들어 다음 히트맵은 백신 도입 전후 미국의 감염병 발생 횟수를 보여줍니다 (검은 선으로 표시됨). 이 그래프는 고발별의 낮은 발생률 데이터 대부분을 나타내기 위해 짧은 범위의 파란색과 녹색만 사용하고, 협소한 데이터 영역의 높은 발생률을 강조하기 위해 초록색과 빨간색 등 경고 신호의 다양한 색상 범위를 활용합니다. 이러한 디자인은 백신의 질병 통제 능력을 효과적으로 강조했습니다.\n\n# 데이터의 수학적 변환을 축에 대칭화\n\n이제 부동산 매매 가격 예시로 다시 돌아가봅시다. 아래 그래프들에서 x축은 10을 기준으로 한 로그 스케일로 변환됩니다. 이렇게 하면 보통 매우 모여 있는 데이터 포인트들이 데이터 구조를 밝혀내기 위해 더 넓은 범위로 펼쳐집니다. 재미를 더하기 위해 같은 데이터로 두 그래프를 만들었는데, 왼쪽은 각 포인트의 이웃 번호를 색상 스케일로 선형 매핑한 산점도이며, 오른쪽 그래프는 콘투어 서클로 이산화된 2D 히스토그램이며, 연속으로 확률 밀도 함수를 그리고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Golden Methods to Visualize Data with Skewed Distribution](/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_5.png)\n\n또 다른 예로, 아래 산점도는 1800년대부터 2015년까지 GDP와 인간 수명 기대치의 증가를 보여줍니다. 이는 축 로그 변환을 사용하여 그렇지 않으면 클러스터링 된 데이터 세트를 펼치는 것을 보여줍니다. x축이 log10 스케일인 반면 라벨은 원래 데이터 값으로 주석이 달려 있음을 주목하세요.\n\n![Golden Methods to Visualize Data with Skewed Distribution](/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_6.png)\n\n수학적 변환은 분포 프로필을 항상 변경하지는 않음을 유의하세요. 예를 들어, 평균으로 중심화하고 표준 편차로 스케일링하여 표준화된 z-점수로 변환하거나 [0, 1] 범위로 정규화하여 최솟값을 뺀 다음 최대값과 최소값의 차이로 스케일링하는 것은 이러한 맥락에서 분포 패턴을 변경하지 않습니다. 이러한 방법은 (다변량 모델링 및 주성분 분석과 같은 관련 시각화에서 중요하지만) 비대칭 데이터를 시각화하는 데 효과적이지 않습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 클러스터린된 데이터 지역 확대\n\n전체 데이터셋을 먼저 표시하고, 그 다음 가장 클러스터된 지역을 확대해서 자세한 시각적 확인을 할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_7.png)\n\n## 마지막으로, 이 유용한 전략들을 아래에 요약합니다:","ogImage":{"url":"/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_0.png"},"coverImage":"/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_0.png","tag":["Tech"],"readingTime":6},{"title":"PowerShell을 사용한 Windows 바로가기 만들기, 커스터마이징 및 위치 지정 방법","description":"","date":"2024-06-22 16:35","slug":"2024-06-22-WindowsShortcutsWithPowerShellHowToMakeCustomizeAndPointThemToPlaces","content":"\n\n이제와서 당신이 손에 가장 흔한 작업인 것처럼 확신을 갖고 \"응, 30분 만에 끝낼 거야!\" 라고 생각할 때 상황이 발생할 것입니다. 그리고 2시간 후에 일부 희미한 문서를 찾아보며, 코드 예제를 보면서 \"이게 정말 이런 건가?\" 라고 생생히 느낄 수도 있죠.\n\n얼마 전, Windows 11의 제어판 소리 설정의 \"녹음\" 패널에 데스크톱 바로 가기를 생성하고 배포해야 하는 상황이 발생했습니다. PowerShell에는 바로 가기를 생성하는 \"기본\" 방법이 없다는 것을 이미 알고 있어서 몇 가지 쉘 방법을 탐색할 예정이었습니다. 그런데 만약에 해당 바로 가기를 제어판 항목의 하위 메뉴로 가리키고 싶거나, 이미 컴퓨터에 존재하지만 동적 라이브러리 안에 저장된 사용자 정의 아이콘을 사용하고 싶다면 어떨까요?\n\n좋아요, 친애하는 독자 여러분, 해결 방법은 있습니다. 때로는 운영 체제의 내부를 살펴 경로를 찾아야 할 때도 있습니다. Windows 바로 가기를 생성하고 사용자 정의하는 방법에 대해 자세히 알아봅시다.\n\n<div class=\"content-ad\"></div>\n\n# 단축키, 심볼릭 링크 및 PowerShell\n\n우선 중요한 것은 PowerShell에 내장된 New-Item cmdlet을 사용하여 심볼릭 링크를 만들 수 있는 방법이 있다는 것입니다.\n\n```js\nNew-Item -ItemType SymbolicLink -Path \"C:\\example-link.lnk\" -Target \"C:\\Users\\dbilanoski\\Documents\\some-text.txt\"\n```\n\n다른 곳에서 이와 같은 단축키를 생성하는 방법을 제안하는 지침을 만날 수 있습니다. 그러나 주의해야 할 점은 이러한 것들이 정확히 동일한 것이 아니라는 것입니다.\n\n<div class=\"content-ad\"></div>\n\nSymbolic links(심볼릭 링크)는 파일 시스템 자체에서 해석된 다른 파일로의 직접적인 링크입니다. 일반 파일과 다르며 크기가 없으며 응용 프로그램이 이를 내재적으로 인식합니다. 사용할 때 실제로 링크된 대상을 직접 사용하는 것처럼 사용됩니다.\n\n한편 바로 가기(Shortcuts)는 Windows 사용자 인터페이스에서 해석된 참조된 객체의 경로를 포함하는 일반 파일입니다. 크기가 있으며 아이콘으로 구성될 수 있으며 사용할 때 이를 읽고 있는 무언가와 대상 경로를 갖고 있어야 합니다(Windows 사용자 인터페이스).\n\nWindows에서 바로 가기가 필요할 때는 바로 가기를 원할 것입니다. 왜냐하면?\n\n- 바로 가기는 참조하는 파일을 추적하여 변경 사항이 발생할 때 업데이트되어 깨질 가능성이 줄어듭니다.\n- 파일과 폴더 외에도 네트워크 위치, 구성 패널, 파일 시스템에 있는 파일 경로로 존재하지 않는 특수 폴더를 엽니다.\n- 특정 폴더의 컨텍스트에서 시작되도록 구성된 바로 가기를 사용할 수 있습니다.\n- 심볼릭 링크를 사용하면 대상 경로에 실행 파일에 대한 명령줄 인수를 포함할 수 없습니다.\n- 아이콘을 심볼릭 링크에 구성할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n단축키를 친숙하고 편리하게 만드는 이유는 Windows 사용자 인터페이스(셸)에서 처리하기 때문입니다. Windows 사용자 인터페이스는 추가 기능과 편의성을 제공합니다. 그러나 PowerShell에서 이를 만들기 위해서는 셸 메소드에 접근해야 하며, 이로 인해 프로세스가 조금 더 복잡해지게 됩니다.\n\n# 서둘러야 할 때를 위해\n\nPowerShell을 사용하여 단축키를 만들고 고유 아이콘을 사용자 정의하려면 아래의 기본 예시를 참고하세요. 특정 상황에 맞게 경로와 파일 이름을 수정해야 합니다.\n\n```js\n$ShortcutTarget= \"타겟-경로\\타겟-이름\"\n$ShortcutFile = \"단축키-경로\\단축키-이름.lnk\"\n$WScriptShell = New-Object -ComObject WScript.Shell\n$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)\n$Shortcut.TargetPath = $ShortcutTarget\n$Shortcut.IconLocation = \"아이콘-경로\\아이콘-이름.ico\"\n$Shortcut.Save()\n```\n\n<div class=\"content-ad\"></div>\n\n한 줄로 된 스크립트가 필요하시면:\n\n```js\n# PowerShell 스크립트용\n$ws = New-Object -ComObject WScript.Shell; $s = $ws.CreateShortcut('실행할-바로가기-파일-경로\\바로가기-파일명.lnk'); $s.TargetPath = '대상-파일-경로\\대상-파일명'; $s.IconLocation = '아이콘-파일-경로\\아이콘-파일명.ico'; $s.Save()\n\n# 배치 (CMD) 스크립트용\npowershell -ExecutionPolicy Bypass -Command \"$ws = New-Object -ComObject WScript.Shell; $s = $ws.CreateShortcut('실행할-바로가기-파일-경로\\바로가기-파일명.lnk'); $s.TargetPath = '대상-파일-경로\\대상-파일명'; $s.IconLocation = '아이콘-파일-경로\\아이콘-파일명.ico'; $s.Save()\"\n```\n\n## 구체적인 예시\n\n서로 다른 바로가기 대상 유형에 대한 적합한 TargetPath 및 필요시 Arguments 구성.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 파일 지정하기\n$Shortcut.TargetPath = \"C:\\Windows\\System32\\notepad.exe\"\n\n# 폴더 지정하기\n$Shortcut.TargetPath = \"C:\\Users\\Public\\Documents\"\n\n# 네트워크 공유 지정하기\n$Shortcut.TargetPath = \"C:\\Windows\\explorer.exe\"\n$Shortcut.Arguments = \"\\\\192.168.10.2\\shares\"\n\n# 환경 변수를 사용하여 지정하기\n$Shortcut.TargetPath = $env:userprofile + \"\\Downloads\"\n\n# .cpl 파일을 지정하기\n$Shortcut.TargetPath = \"C:\\Windows\\System32\\mmsys.cpl\"\n\n# MS:SETTINGS URI 스킴을 사용하여 지정하기\n$Shortcut.TargetPath = \"ms-settings:installed-apps\"\n\n# 이름으로 shell 명령어를 사용하여 지정하기\n$Shortcut.TargetPath = \"C:\\Windows\\explorer.exe\"\n$Shortcut.Arguments = \"shell:NetworkPlacesFolder\"\n\n# CLSID GUID로 shell 명령어를 사용하여 지정하기\n$Shortcut.TargetPath = \"C:\\Windows\\explorer.exe\"\n$Shortcut.Arguments = \"shell:::{BB06C0E4-D293-4f75-8A90-CB05B6477EEE}\"\n\n# rundll32를 사용하여 dll 탐색으로 지정하기\n$Shortcut.TargetPath = \"C:\\Windows\\System32\\rundll32.exe\"\n$Shortcut.Arguments = \"shell32.dll,Control_RunDLL inetcpl.cpl,,4\"\r\n```\n\n# 세부 정보\n\n## Powershell로 바로 가기 생성\n\nPowerShell을 사용하여 바로 가기를 생성하려면, WScript.Shell 클래스의 인스턴스를 포함할 컨테이너로 작동할 COM 객체를 생성해야 합니다. 이는 아마도 초기에 Visual Basic 스크립트를 위해 고안된 꽤 오래된 COM 인터페이스의 일부인 WScript.Shell 클래스의 인스턴스를 담을 객체를 만들 것입니다. 즉, 코드로 바로 가기를 처리하기 위해 필요한 모든 좋은 기능이 구비된 객체를 만들 것입니다. 이는 변수와 속성을 다루는 작업을 포함하므로, 이를 단계적으로 나누어 설명하겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n컴퓨터의 각 사용자에 대해 notepad.exe(Windows에서 널리 사용되는 텍스트 편집 도구)에 대한 데스크탑 바로 가기를 만들고자 합니다.\n\n1. 먼저 대상 객체와 해당 바로 가기의 경로를 저장할 변수를 만듭니다.\n\n```js\n# 내 바로 가기가 가리키는 위치\n$ShortcutTarget = \"C:\\Windows\\System32\\notepad.exe\"\n# 내 바로 가기가 저장될 곳 및 이름 설정\n$ShortcutFile = \"C:\\Users\\Public\\Desktop\\notepad.lnk\"\n```\n\n2. New-Object cmdlet을 사용하여 COM 개체로 WScript.Shell 클래스의 인스턴스를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n$WScriptShell = New-Object -ComObject WScript.Shell\n```\n\n3. WScript.Shell 인스턴스에서 CreateShortcut() 메서드를 사용하여 바로 가기를 만듭니다.\n\n```js\n$shortcut = $WScriptShell.CreateShortcut($ShortcutFile)\n```\n\n자, 이제 잠시 멈추고 바로 가기 객체의 속성과 메서드를 살펴보면서 우리가 할 수 있는 작업을 살펴보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![Shortcut Image](/assets/img/2024-06-22-WindowsShortcutsWithPowerShellHowToMakeCustomizeAndPointThemToPlaces_1.png)\n\n우리는 단축키를 생성하기 위해 TargetPath 속성에 Notepad.exe를 지정하고 Save() 메서드를 사용해야 합니다.\n\n우리의 단축키에 아이콘을 할당하려면 IconLocation 속성이 관련됩니다. TargetPath에 참조된 실행 파일에 명령줄 인수를 전달하려면 Arguments 속성이 관련됩니다.\n\nWorkingDirectory는 상대 경로 사용시 때로 필요하지만, 단축키를 다룰 때 상대 경로는 피하는 것이 좋습니다.\n\n\n<div class=\"content-ad\"></div>\n\n4. 기본 사항으로 계속해서, 앞서 설정한 변수를 사용하여 Target.Path 속성을 위치와 대상의 이름에 할당하십시오.\n\n```js\n$Shortcut.TargetPath = $ShortcutTarget\n```\n\n5. ShortcutFile 변수에 지정된 경로에 바로 가기를 저장하기 위해 Save() 메서드를 호출하여 프로세스를 완료하세요.\n\n```js\n$Shortcut.Save()\n```\n\n<div class=\"content-ad\"></div>\n\n당신의 바로 가기는 $ShortcutFile 변수에 정의된 위치에 준비될 것입니다.\n\n## 장소들을 가리키는 바로 가기\n\n파워쉘을 사용하여 프로그래밍적으로 바로 가기를 만드는 방법을 알게 되었으니, 파일 이외의 것을 가리킬 때는 어떻게 보이는지 살펴보겠습니다. 불행하게도 항상 명확하지는 않습니다.\n\n한두 개의 속성만 변경할 때는 주석이 있는 코드 블록에서 실제 예제를 사용할 것입니다. — TargetPath와 Arguments가 필요할 때 변경합니다.\n\n<div class=\"content-ad\"></div>\n\n폴더로의 바로 가기\n\n```js\n$Shortcut.TargetPath = \"C:\\Users\\Public\\Documents\"\n```\n\n네트워크 공유로의 바로 가기\n\n여기서는 Arguments 속성을 사용하여 TargetPath 속성에서 구성된 explorer.exe로 UNC 형식의 경로를 전달하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n주로 단축키 생성 프로시저에서 문제를 피하기 위한 것이며, 그렇지 않으면 명령이 실행된 문맥 내에서 경로에 액세스할 수 없는 경우 프로세스가 실패할 수 있습니다.\n\n```js\n$Shortcut.TargetPath = \"C:\\Windows\\explorer.exe\"\n$Shortcut.Arguments = \"\\\\192.168.10.2\\shares\"\n```\n\n환경 변수와 함께 사용되는 단축키 대상 경로\n\n```js\n# 표준 연결 방식인 + 기호를 사용하여\n$Shortcut.TargetPath = $env:userprofile + \"\\Downloads\"\n\n# Join-Path cmdlet을 사용하여\n$Shortcut.TargetPath = Join-Path -Path $env:userprofile -ChildPath \"Downloads\"\n```\n\n<div class=\"content-ad\"></div>\n\n컨트롤 패널 파일로의 바로 가기\n\n이 파일들은 C:\\Windows\\System32 폴더에 있으며, 컨트롤 패널 항목에 접근하기가 편리합니다. 그러나 대부분 다른 방법으로 그 곳에 도달하려고 할 것입니다.\n\n```js\n$Shortcut.TargetPath = \"C:\\Windows\\System32\\mmsys.cpl\"\n```\n\nWindows 설정 앱을 통한 패널로의 바로 가기\n\n<div class=\"content-ad\"></div>\n\nWindows 설정 응용 프로그램의 특정 페이지를 지정하는 방법을 제공합니다. ms-settings:`페이지 이름` 형식을 따라 이동할 수 있습니다.\n\n```js\n$Shortcut.TargetPath = \"ms-settings:installed-apps\"\n```\n\n셸 명령을 통한 위치 바로 가기\n\nWindows의 많은 위치는 파일과 유사한 절대 경로 접근이 없어서, 특정 패널이나 폴더에 프로그래밍적으로 어떻게 도달할지가 명확하지 않을 수 있습니다. 이러한 위치를 셸 폴더 또는 가상 폴더라고 하며 알려진 이름을 사용하거나 CLSID 고유 식별자 키 (GUID)를 사용하여 접근할 수 있습니다. CLSID는 레지스트리에서 직접 항목을 열 수 있도록 사용할 수 있는 특별한 키입니다.\n\n<div class=\"content-ad\"></div>\n\n그들에 대해 더 자세히 알고 싶거나 사용 가능한 Windows 11 바로 가기의 완전한 목록을 보고 싶다면, 여기에서 더 깊게 다루었어요.\n\n```js\n# 이름으로 셸 명령어를 사용하여\n$Shortcut.TargetPath = \"C:\\Windows\\explorer.exe\"\n$Shortcut.Arguments = \"shell:NetworkPlacesFolder\"\n\n# CLSID GUID로 셸 명령어를 사용하여\n$Shortcut.TargetPath = \"C:\\Windows\\explorer.exe\"\n$Shortcut.Arguments = \"shell:::{BB06C0E4-D293-4f75-8A90-CB05B6477EEE}\"\n```\n\n## 아이콘으로 바로 가기 맞춤 설정\n\n만약 당신의 바로 가기가 이미 아이콘이 있는 항목을 가리키고 있다면, 해당 아이콘의 경로는 IconLocation 속성에 저장됩니다.\n\n<div class=\"content-ad\"></div>\n\nPowerShell을 사용하여 단축키에 사용자 정의 아이콘을 할당하려면, 단축키를 만들 때 추가 단계로 IconLocation 속성을 구성하여 기존 아이콘에 도달 가능한 경로를 설정한 후 단축키를 저장하면 됩니다.\n\n```js\n$Shortcut.IconLocation = \"\\\\path-to-your-icon.ico\"\n```\n\n이제 사용자 정의 아이콘으로 구성된 단축키를 가지고 있으므로, 스크립트가 다른 곳에 배포되어야 할 경우 아이콘의 가용성을 확인해야 할 것입니다. 항상 컴퓨터에 이미 있는 요소를 활용하는 것이 좋은 접근 방식일 것입니다.\n\nWindows OS에는 일반 UI 아이콘이 저장되고 사용되는 곳이 있습니다. 일반적으로 이러한 아이콘은 여러 프로그램에서 동시에 공유되는 데이터를 포함하는 동적 링크 라이브러리(DLL)에 패킹되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n시스템 주변에는 많은 것들이 있지만, OS에서 가장 일반적으로 사용되는 DLL에는 다음과 같은 아이콘이 포함되어 있습니다:\n\n- C:\\Windows\\system32\\imageres.dll\n- C:\\Windows\\system32\\shell32.dll\n- C:\\Windows\\system32\\ddores.dll\n\n이러한 아이콘들은 표준 파일이 아니며, 적절한 인덱스 번호를 사용하여 DLL 파일 내에서 참조해야 합니다. 이러한 아이콘들은 쉽게 볼 수 없다는 것이 함정입니다. 따라서 텍스트의 시작 부분에 있는 2시간의 줄서기가 필요합니다.\n\n서드 파티 소프트웨어를 사용하지 않고 시간을 낭비하지 않고 DLL의 중첩된 아이콘 인덱스 번호를 확인하려면, 기존 바로 가기의 \"속성\" 패널을 사용하여 DLL 파일을 검색하십시오. 그곳에서 원하는 아이콘을 선택하고 변경 내용을 저장한 다음 해당 인덱스 번호를 코드에서 사용할 수 있도록 PowerShell의 WScriptShell의 COM 인스턴스에 바로 가기를 추가하십시오. IconLocation 속성을 검사하여 코드에서 사용할 수 있는 인덱스 번호를 식별할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nDLL 아이콘 참조하기\n\n에제로 살펴보겠습니다. 제 노트패드 바로 가기를 특정 라이브러리 중 하나로부터 가져온 독특한 아이콘과 함께 배포하고 싶다고 가정해 보겠습니다. 예를 들어, imageres.dll 라이브러리의 키보드 아이콘을 사용하고 싶다면 어떨까요?\n\n제 데스크탑에 있는 크롬 바로 가기의 현재 IconLocation을 살펴보면 chrome.exe(녹색 선) 패키지 내부의 아이콘(녹색 선)이 사용되고 있으며, 해당 아이콘의 인덱스 번호는 0(분홍색 선)입니다. 이 인덱스는 경로의 일부로 표시되며, 파일 경로와 인덱스 번호는 쉼표로 구분됩니다.\n\n![이미지](/assets/img/2024-06-22-WindowsShortcutsWithPowerShellHowToMakeCustomizeAndPointThemToPlaces_2.png)\n\n<div class=\"content-ad\"></div>\n\n또한 chrome.exe 패키지 내부에는 사용할 수 있는 다른 아이콘들이 있다는 것을 알 수 있습니다.\n\n우리는 동일한 Chrome 바로 가기를 사용하여 imageres.dll 라이브러리를 살펴보고 원하는 바로 가기를 선택하고 해당 인덱스 번호를 확인할 수 있습니다.\n\n1. 속성 페이지에 액세스하여 \"아이콘 변경\" 버튼을 클릭하고 \"C:\\Windows\\system32\\imageres.dll\"로 이동한 후 \"Enter\"를 눌러 사용 가능한 아이콘을 확인할 수 있습니다.\n\n여기에서 사용하고자 하는 키보드 아이콘을 선택했습니다.\n\n<div class=\"content-ad\"></div>\n\nMarkdown 형식으로 테이블 태그를 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n$Shortcut.IconLocation = \"C:\\Windows\\system32\\imageres.dll,173\"\n```\n\n## 원라이너\n\n간단하게 사용하기 위해 이를 한 줄로 표현하려면, \"첫 번째 명령; 두 번째 명령; 세 번째 명령\"과 같이 세미콜론을 사용하여 명령을 연결할 수 있습니다. 여기서는 경로 변수를 사용하지 않고 직접 속성과 메소드에 넣어줍니다.\n\n```js\n$ws = New-Object -ComObject WScript.Shell; $s = $ws.CreateShortcut(\"C:\\Users\\Public\\Desktop\\notepad.lnk\"); $s.TargetPath = \"C:\\Windows\\System32\\notepad.exe\"; $s.IconLocation = \"C:\\Windows\\system32\\imageres.dll,173\"; $s.Save()\n```\n\n<div class=\"content-ad\"></div>\n\ncmd를 통해 작업하는 우리에게:\n\n```js\npowershell -ExecutionPolicy bypass -Command \"$ws = New-Object -ComObject WScript.Shell; $s = $ws.CreateShortcut('C:\\Users\\Public\\Desktop\\notepad.lnk'); $s.TargetPath = 'C:\\Windows\\System32\\notepad.exe'; $s.IconLocation = 'C:\\Windows\\system32\\imageres.dll,173'; $s.Save()\"\n```\n\n# 결론\n\nPowerShell을 사용하여 바로 가기를 만드는 것은 COM 객체를 사용하여 WScript.Shell 클래스를 인스턴스화하여 바로 가기 생성 기능에 액세스하는 복잡성을 도입하지만, 프로퍼티 값을 구성하는 루틴 작업으로 단순화됩니다. 배포 전 철저한 테스트, 절대 경로 정확성에 대한 주의 및 아이콘이나 특정 경로와 같은 기존 시스템 요소를 재사용하는 마인드는 중요한 고려 사항입니다.\n\n<div class=\"content-ad\"></div>\n\n당신이 시간을 쏟을 수 있는 곳은 운영 체제의 복잡성에 깊이 파고들어 특정 패널이나 가상 폴더를 대상으로 하는 방법을 알아내는 것입니다. 그러나 대부분의 경우에는 결과적으로 필요한 배포 가능한 한 줄의 코드로 축약될 수 있습니다.\n\n# 작성자의 노트\n\n여기까지 오셨네요! 잘 하셨어요 친구들 — 제가 꽤 괜찮은 작가라서 그런지, 아니면 당신이 훌륭한 독자라서 그런 건지요. 우리는 후자를 택하도록 합시다😅.\n\n나는 기업의 혼돈을 탐내는 경험 많은 IT 서비스 전달 엔지니어 다닐로입니다. 저는 스크립팅, 시스템 관리자 관련 내용, 그리고 다른 곳에서 제대로 문서화되지 않은 주제들에 대해 글을 씁니다. 지식을 공유하고 글쓰기 기술을 향상시키기 위한 목적을 가지고요.\n\n<div class=\"content-ad\"></div>\n\n만졌더니 반복의 경우 피드백을 주세요!","ogImage":{"url":"/assets/img/2024-06-22-WindowsShortcutsWithPowerShellHowToMakeCustomizeAndPointThemToPlaces_0.png"},"coverImage":"/assets/img/2024-06-22-WindowsShortcutsWithPowerShellHowToMakeCustomizeAndPointThemToPlaces_0.png","tag":["Tech"],"readingTime":11},{"title":"최고의 입력을 받는 5가지 방법","description":"","date":"2024-06-22 16:34","slug":"2024-06-22-YourInputMatters","content":"\n\n나의 사이버보안 여정을 시작하며: Day 0\n\n안녕하세요, SoulfulZeus입니다! 오늘부터 나의 사이버보안 세계로의 여정이 시작되었어요. 여러분과 함께 이것을 나눌 수 있어 너무 흥분되고 기대돼요. 나는 매일 진행 상황을 문서화하기로 결정했어요. 그래서 여러분이 이 도전적이지만 보람 있는 분야를 탐험하는 내 모습을 따를 수 있을 거예요.\n\n로드맵과 목표\n\n이 여정을 시작하며, 8개월 안에 OSCP(Offensive Security Certified Professional) 자격증을 달성하는 야심찬 목표를 세우고 상세한 로드맵을 설계했어요. 다음은 내가 따를 계획입니다:\n\n<div class=\"content-ad\"></div>\n\n1. CompTIA Network+: 네트워킹 분야의 강한 기초를 구축하는 것은 시스템과 네트워크 간에 데이터가 어떻게 이동하는지를 이해하는 데 중요합니다.\n\n2. TCM LINUX 101: 리눅스는 사이버 보안 분야에서 널리 사용되며, 그것을 숙달하는 것은 공격적 및 방어적 역할 모두에 필수적일 것입니다.\n\n3. TCM Practical Ethical Hacking: 윤리적 해킹에 대한 실용적 기술은 취약점을 이해하고 공격자가 어떻게 생각하는지를 파악하는 데 중요합니다.\n\n4. TCM Windows PrevEsc and TCM Linux PrevEsc: Windows 및 Linux 시스템에서 권한 상승에 대해 학습함으로써 시스템 보안에 대한 이해를 더욱 깊게 할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n5. TryHackMe (THM) 랩: TryHackMe의 랩은 통제된 환경에서 실용적인 경험을 제공합니다.\n\n6. 동시에 HackTheBox (HTB) 랩: 마찬가지로, Hack The Box의 랩은 더 복잡한 시나리오로 나를 도전하여 기술을 갈고 닦을 기회를 제공합니다.\n\n게다가, 이 여정 동안 취업 기회를 높이기 위해 eJPT (eLearnSecurity Junior Penetration Tester) 자격증 취득을 목표로 하고 있습니다.\n\n이것을 왜 하고 있는 걸까요?\n\n<div class=\"content-ad\"></div>\n\n사이버 보안 분야는 저를 매혹시킵니다. 이 분야는 공격에 대처하는 것뿐만 아니라 계속해서 학습하고 적응하며 잠재적 위협에 선제적으로 대비하기 위해 해커처럼 사고하는 것이기 때문입니다. 문제 해결과 기술에 열정적인 저로서는 이 분야가 도전과 혁신을 완벽하게 결합한 영역이라고 생각합니다.\n\n# 당신의 의견이 중요합니다\n\n저는 여기있는 것이 단순히 제 여정을 기록하는 것뿐만이 아니라 커뮤니티로부터 배우기 위해서 여기에 있습니다. 제가 놓친 부분이 있는지 알릴 것이 있거나 자원, 기술 또는 격려의 말씀을 제시하고 싶다면 언제든 공유해주세요. 여러분의 통찰력은 이 길을 가는 동안 저에게는 귀중한 자산이 될 것입니다.\n\n이 여정에 함께해주세요\n\n<div class=\"content-ad\"></div>\n\n경계! 당신이 경험이 풍부한 사이버 보안 전문가이든, 신참이든, 이 분야에 관심이 있는 사람이든 상관없이 함께해요. 함께 배우고, 경험을 공유하며 서로 영감을 주어 우리의 한계를 뛰어넘을 수 있게 도와줍시다.\n\n내일 나는 CompTIA Network+를 공부하기 시작할 것입니다. 내가 사용하는 자원, 공부 세션을 구성하는 방법, 그리고 마주하는 어려움들을 나눌 예정입니다.\n\n그때까지는 호기심을 유지하고, 안전을 유지하며, 더 나은 미래를 위해 해킹해 봅시다!\n\n지금은 여기서 물러나겠습니다.\n\n<div class=\"content-ad\"></div>\n\nSoulfulZeus","ogImage":{"url":"/assets/img/2024-06-22-YourInputMatters_0.png"},"coverImage":"/assets/img/2024-06-22-YourInputMatters_0.png","tag":["Tech"],"readingTime":2},{"title":"윈도우 11에서 Microsoft Defender로 전체 바이러스 검사를 실행하는 방법","description":"","date":"2024-06-22 16:33","slug":"2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11","content":"\n\nMicrosoft Defender의 전체 바이러스 스캔을 PC에서 실행하는 세 가지 쉬운 방법을 알아보세요. Windows Security 앱, Powershell 및 명령 프롬프트를 사용하는 방법이 포함되어 있습니다.\n\n![이미지](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_0.png)\n\n컴퓨터를 악성 코드로부터 보호하는 데 관한 경우, 빠른 스캔은 종종 충분하지 않아 잠재적인 위협을 간과할 수 있습니다. 여기서 전체 바이러스 스캔이 필요한데요. 이는 PC의 각 모서리와 모퉁이를 악성 침입자를 위해 철저히 검사하는 철저한 스윕입니다. 이 과정은 일반적으로 몇 시간 정도 소요되므로 약간의 인내심이 필요하지만 결과는 가치 있을 수 있습니다.\n\n다행히 Windows 11의 내장 안티바이러스 프로그램인 Microsoft Defender를 사용하여 제3자 앱이 필요하지 않은 PC에서 효과적인 전체 바이러스 스캔을 실행할 수 있습니다. 또한 Windows Security 앱, Powershell 및 명령 프롬프트를 사용하여 다양한 방법으로 스캔을 시작할 수 있습니다. 자세한 방법을 알아보려면 계속 읽어보세요.\n\n<div class=\"content-ad\"></div>\n\n# 윈도우 보안 앱에서 전체 바이러스 검사 실행하는 방법\n\n윈도우 11에서 전체 바이러스 검사를 실행하는 가장 쉬운 방법은 Windows 보안 앱을 통해 실행하는 것입니다. 다음 단계를 따라 진행해보세요:\n\n- 시작 버튼을 클릭하여 메뉴를 엽니다.\n\n![이미지](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_1.png)\n\n<div class=\"content-ad\"></div>\n\n2. \"Windows Security\"을 검색하여 앱을 엽니다.\n\n![Windows Security](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_2.png)\n\n3. 왼쪽 사이드바에서 \"Virus & threat protection\"을 선택하세요.\n\n![Virus & threat protection](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_3.png)\n\n<div class=\"content-ad\"></div>\n\n4. \"Current threats\" 섹션 아래에 있는 \"Scan options\"를 클릭하세요.\n\n![Scan options](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_4.png)\n\n5. \"Full Scan\"을 선택하고 \"Scan now\"를 클릭하세요.\n\n![Full Scan](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_5.png)\n\n<div class=\"content-ad\"></div>\n\n스캔 프로세스가 시작됩니다. 마이크로소프트 디펜더가 악성 소프트웨어를 스캔하고 감지되면 수행 중인 것을 격리하거나 제거합니다. 스캔 프로세스가 완료되면 특정 앱이나 파일을 수동으로 격리, 제거 또는 허용할 수 있습니다.\n\n참고: PC에 저장된 데이터 양에 따라 스캔 프로세스에 시간이 걸릴 수 있으니 기다려 주시기 바랍니다.\n\n# 명령 프롬프트를 사용하여 전체 바이러스 스캔하는 방법\n\n다음 단계를 따라 마이크로소프트 디펜더 전체 바이러스 스캔을 명령 프롬프트를 통해 실행하는 방법을 알아보세요:\n\n<div class=\"content-ad\"></div>\n\n- 시작 메뉴를 열고 \"명령 프롬프트\"를 검색한 후 \"관리자로 실행\"을 선택하세요.\n\n![이미지](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_6.png)\n\n2. 명령 프롬프트에서 다음 명령어를 입력하고 \"Enter\"를 눌러 Microsoft Defender 바이러스 백신에 액세스하세요:\n\n\ncd C:\\ProgramData\\Microsoft\\Windows Defender\\Platform\\4*\n\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_7.png\" />\n\n3. Next, type the following command and press “Enter” to initiate a full scan in Microsoft Defender:\n\nmpcmdrun -scan -scantype 2\n\n<img src=\"/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_8.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n이 명령들을 실행하면 Microsoft Defender가 바이러스를 스캔하고 감지된 악성 코드를 제거할 것입니다. 스캔이 완료되면 화면에 \"스캔 완료\" 메시지가 표시됩니다.\n\n# PowerShell을 사용한 전체 바이러스 스캔 실행 방법\n\n아래 단계를 따라 PowerShell을 사용하여 Microsoft Defender 전체 바이러스 스캔을 실행할 수 있습니다:\n\n- 시작 메뉴를 열고 \"PowerShell\"을 검색한 후 \"관리자 권한으로 실행\"을 클릭하십시오.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_9.png\" />\n\n2. In Powershell, input the following command and hit “Enter” to initiate a Microsoft Defender full virus scan on your PC:\n\nstart-mpscan -scantype fullscan\n\n<img src=\"/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_10.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n해당 명령을 실행하면 전체 바이러스 스캔이 시작됩니다. PowerShell 화면에서 스캔 진행 상황을 백분율 바로 알려줄 거에요.\n\n# Microsoft Defender로 특정 파일이나 폴더를 스캔하는 방법\n\n전체 바이러스 스캔은 보통 몇 시간이 걸리기 때문에, 일부 사용자는 컴퓨터에서 악성 코드를 스캔하고 제거하는 보다 빠르고 효율적인 방법을 찾습니다. 만약 당신도 그 중 하나라면, \"사용자 정의 스캔\" 기능을 사용해 어떤 파일과 위치를 악성 코드를 확인할지 선택해볼 수 있습니다. 아래 단계를 따라해보세요:\n\n- 시작 메뉴를 열고 설정 아이콘을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변환된 내용입니다.\n\n\n![이미지1](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_11.png)\n\n2. Privacy & Security를 선택하고 Windows Security로 이동합니다.\n\n![이미지2](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_12.png)\n\n3. 그 다음, Virus & Threat protection을 클릭하고 Scan options 아래의 Customized scan을 클릭하세요.\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_13.png)\n\n4. '커스터마이즈된 스캔'을 클릭하면 탐색기 창이 열리고 특정 폴더를 선택할 수 있습니다. 창에서 개별 파일을 볼 수는 없지만 해당 폴더를 선택하고 '폴더 선택'을 클릭하여 스캔을 시작할 수 있습니다. 스캔이 완료되면 스캐닝이 시작됩니다. 해당 폴더의 모든 하위 폴더와 파일이 포함됩니다.\n\n![이미지](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_14.png)\n\n# 데이터를 잃기 전에 데이터를 보호하세요!\n\n\n<div class=\"content-ad\"></div>\n\n귀하의 PC에서 정기 바이러스 스캔을 수행하여 파일을 훼손하고 문제를 일으킬 수 있는 악성 소프트웨어를 발견하고 제거하는 것이 매우 중요합니다. 이 가이드에서는 Windows Security 앱, 명령 프롬프트 및 PowerShell을 사용하여 Microsoft Defender 전체 바이러스 스캔을 실행하는 세 가지 간단한 방법을 소개했습니다. 전체 바이러스 스캔이 완료될 때까지 몇 시간을 기다리기 싫다면 대신 특정 파일 및 폴더를 확인하여 시간을 적게 들이고 실용적인 검사용 옵션을 고려해보세요.","ogImage":{"url":"/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_0.png","tag":["Tech"],"readingTime":5},{"title":"PowerShell을 사용해 SMTP로 메일 보내는 방법","description":"","date":"2024-06-22 16:32","slug":"2024-06-22-HowtosendmailSMTPwithPowerShell","content":"\n\n파워셸로 이메일을 SMTP로 보내는 방법은 어떻게 해야 하나요? 오랜 시간 리눅스 사용자인 저에게 윈도우로 돌아오는 것은 새로운 경험이죠.\n\n작업 중에 애플리케이션이 이메일을 보내지 못하는 이유를 알 수 없어 곤란할 때가 종종 있죠. 컴퓨터에서 메일 연결을 테스트하여 제대로 작동하는지 확인하고 싶을 것입니다.\n\n자, 이제 PowerShell을 사용하여 인증된 SMTP로 메일을 보내는 테스트를 해볼 거에요.\n\n\n# 먼저 SMTP 정보를 가져오세요\n\n\n<div class=\"content-ad\"></div>\n\n우선, 이메일 SMTP를 테스트하여 메일 서버를 인증하는 계정으로 전송할 것입니다. 따라서 아래와 같은 정보를 얻어야 합니다:\n\n- 사용자 이름: 메일 서버에 로그인하는 데 사용되는 사용자 이름.\n- 암호: 메일 서버에 로그인하는 데 사용되는 암호.\n- SMTP 서버: 메일 서버의 주소.\n- SMTP 포트: 이메일을 전송하는 데 사용할 포트.\n\n예를 들어, 다음과 같이 얻었습니다:\n\n- 사용자 이름: usertest\n- 암호: Passtest123\n- SMTP 서버: retail.smtp.com (smtp.com을 사용)\n- SMTP 포트: 25\n\n<div class=\"content-ad\"></div>\n\n# PowerShell을 사용하여 이메일 SMTP 전송하기\n\n![이미지](/assets/img/2024-06-22-HowtosendmailSMTPwithPowerShell_0.png)\n\n이제 아래 명령어를 실행하기 전에 값을 본인에 맞게 변경해 주세요:\n\n```javascript\n$username = 'usertest'\n$password = 'Passtest123'\n$secpasswd = ConvertTo-SecureString $password -AsPlainText -Force\n$mycreds = New-Object System.Management.Automation.PSCredential ($username, $secpasswd)\nSend-MailMessage -Credential $mycreds -SmtpServer retail.smtp.com -Port 25 -From usertest@devopslite.com -To ghost@gmail.com -Subject test -Body test\n```\n\n<div class=\"content-ad\"></div>\n\n- $username: 이 줄은 사용자 이름을 정의합니다.\n- $password: 이 줄은 암호를 정의합니다.\n- $secpasswd: 일반 텍스트 암호를 비밀 문자열로 변환하는 함수를 호출합니다.\n- $mycreds: 사용자 이름과 비밀 암호로 새 객체를 만들어, Send-MailMessage 명령어에 전달됩니다.\n- Send-MailMessage: 이 명령은 주소 usertest@devopslite.com에서 ghost@gmail.com으로 이메일을 보내는 데 사용됩니다. -Subject 및 -Body 옵션을 따라 내용을 변경할 수도 있습니다.\n\n만약 smtp 포트 25를 사용하지 않는다면, 위 명령을 TLS 연결을 사용하는 포트 587을 사용하도록 변경할 수 있습니다.\n\n```js\n$username = 'usertest'\n$password = 'Passtest123'\n$secpasswd = ConvertTo-SecureString $password -AsPlainText -Force\n$mycreds = New-Object System.Management.Automation.PSCredential ($username, $secpasswd)\nSend-MailMessage -Credential $mycreds -SmtpServer retail.smtp.com -Port 587 -UseSsl -From usertest@devopslite.com -To ghost@gmail.com -Subject test -Body test\n```\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n간단한 명령어 몇 개만 사용하면 Windows에서 PowerShell을 사용하여 SMTP로 이메일을 보낼 수 있어요. 제 데모에서는 Windows 11 OS를 사용하고 있어서 다른 OS에서도 잘 동작할 거예요.\n\n원본 게시물: https://devopslite.com/how-to-send-mail-smtp-with-powershell/","ogImage":{"url":"/assets/img/2024-06-22-HowtosendmailSMTPwithPowerShell_0.png"},"coverImage":"/assets/img/2024-06-22-HowtosendmailSMTPwithPowerShell_0.png","tag":["Tech"],"readingTime":3},{"title":"윈도우에서 로컬 도커 개발을 위한 WSL2 설정 방법","description":"","date":"2024-06-22 16:31","slug":"2024-06-22-SetupWSL2forlocaldockerdevelopmentonWindows","content":"\n\n안녕하세요! 혹시 업무 중에 도커가 필요하고 관리해야 하는 상황이신가요?\n\n윈도우 기기를 사용 중이지만, 회사 보안 정책, 자금 부족, 또는 기기에 더 많은 소프트웨어를 추가하고 싶지 않아서 Docker Desktop과 같은 라이선스를 확보할 수 없는 상황이신가요?\n\n이 글은 여러분을 위한 것입니다. 개발자들이 리눅스 환경을 실행할 수 있도록 Windows의 기능인 WSL2(Windows 하위 시스템 for Linux)을 사용하여 로컬 기기를 도커 개발에 활성화하는 방법을 단계별로 안내해 드릴 거예요.\n\n<div class=\"content-ad\"></div>\n\n\n![Screenshot](/assets/img/2024-06-22-SetupWSL2forlocaldockerdevelopmentonWindows_0.png)\n\n# Setting up the host machine\n\n# Installing WSL2\n\nNavigate on Windows to %UserProfile% in Windows Explorer\n\n\n<div class=\"content-ad\"></div>\n\n\nAdd, .wslconfig document (note: DOT (.) is in the front → .wslconfig)\n\n```js\n# Settings apply across all Linux distros running on WSL 2\n# Can see memory in wsl2 with \"free -m\"\n# Goes in windows home directory as .wslconfig\n[wsl2]\n\n# Limits VM memory to use no more than 48 GB, defaults to 50% of ram\nmemory=4GB\n\n# Sets the VM to use 8 virtual processors\nprocessors=8\n\n# Sets the amount of swap storage space to 8GB, default is 25% of available RAM\nswap=1GB\n```\n\nOpen the command prompt and execute the following commands:\n\nChoose Linux distro\n\n\n<div class=\"content-ad\"></div>\n\n```js\nwsl --list --online\n```\n\n리눅스 배포판 설치\n\n```js\nwsl --install -d Ubuntu-20.04\n```\n\n설치 확인하기\n\n<div class=\"content-ad\"></div>\n\n\nwsl --list --verbose\n\n\n버전 2로 업그레이드하세요.\n\n\nwsl --set-default-version 2\nwsl --set-version Ubuntu-20.04 2\n\n\n버전이 2로 설정되었는지 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n\n다음 명령어를 실행해 WSL 목록을 볼 수 있어요.\n\n\nwsl --list --verbose\n\n\nWSL을 다시 시작할 수 있어요.\n\n\nwsl --shutdown\n\n\n바시 셸 (Ubuntu)을 열 수 있어요. Windows 시작 → Ubuntu 검색해보세요.\n\n<div class=\"content-ad\"></div>\n\n애플리케이션을 열어서 도커 엔진을 설치하러 이동해주세요.\n\n루트 사용자 이름과 암호를 설정하라는 메시지가 표시될 것입니다.\n\n# 도커 엔진 설치\n\n리눅스 배포판에 로그인하신 후에요.\n\n<div class=\"content-ad\"></div>\n\n사용자를 sudo(관리자)로 추가하세요.\n\n```js\ngrep -E 'sudo|wheel' /etc/group\n```\n\n확인:\n\n```js\nsudo grep -E '%sudo|%wheel' /etc/sudoers\n```\n\n<div class=\"content-ad\"></div>\n\n위의 내용은 다음과 같이 번역됩니다:\n\n\"테이블 태그를 마크다운 형식으로 변경해주세요.\"\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo apt remove docker docker-engine docker.io containerd runc\n```\n\n저장소를 이용해서 Docker를 설치해보세요.\n\napt를 업데이트하고 저장소를 HTTPS로 사용할 수 있도록 패키지를 설치해주세요.\n\n```js\nsudo apt-get update\n\nsudo apt-get install \\\n    ca-certificates \\\n    curl \\\n    gnupg \\\n    lsb-release\n```\n\n<div class=\"content-ad\"></div>\n\n도커 공식 GPG 키를 추가하세요.\n\n```bash\ncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg\n```\n\n안정적인 저장소를 설정하세요.\n\n```bash\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\\n  $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n```\n\n<div class=\"content-ad\"></div>\n\n도커 엔진 설치하기\n\n```js\nsudo apt-get update\n\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin\n```\n\n사용자를 도커 그룹에 추가하기\n\n```js\nsudo groupadd docker\nsudo usermod -aG docker $USER\n```\n\n<div class=\"content-ad\"></div>\n\n도커 서비스를 실행하세요.\n\n```sh\nsudo service docker start\n```\n\n상태를 확인하세요. (\"docker is running\"이어야 함)\n\n```sh\nsudo service docker status\n```\n\n<div class=\"content-ad\"></div>\n\n도커 컴포즈 (글 쓰는 시점의 최신 버전은 2.5.0입니다)를 설치해보세요.\n\n```js\nsudo curl -L https://github.com/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose\n```\n\n실행 권한 부여하기\n\n```js\nsudo chmod +x /usr/local/bin/docker-compose\n```\n\n<div class=\"content-ad\"></div>\n\n버전 확인\n\n```js\ndocker-compose --version\n```\n\n출력: docker-compose version 1.27.4, build 40524192\n\n이제 \"wsl\"을 사용하여 CMD/Powershell을 통해 도커를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nwsl docker image ls\n```\n\n# 도커를 로컬 머신에 노출시키기\n\netc/docker/daemon.json 위치에서 daemon.json을 편집하세요.\n\n<div class=\"content-ad\"></div>\n\n\"hosts\": [ \"unix:///var/run/docker.sock\",\"tcp://0.0.0.0:2375\"]를 입력하고 저장하세요.\n\n![이미지](/assets/img/2024-06-22-SetupWSL2forlocaldockerdevelopmentonWindows_1.png)\n\n머신을 재시작하고 dockerd로 도커를 시작하세요.\n\n로그를 확인하여 위 사진의 호스트를 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n잘 했어요! 도커와 도커 컴포즈를 사용하여 로컬 환경을 설정하고 생산적으로 사용할 수 있도록 세팅했네요 :)!\n\n참고 자료:\nhttps://learn.microsoft.com/en-us/windows/wsl/install\nhttps://dev.to/_nicolas_louis_/how-to-run-docker-on-windows-without-docker-desktop-hik\nhttps://dev.to/bowmanjd/install-docker-on-windows-wsl-without-docker-desktop-34m9\nhttps://medium.com/geekculture/run-docker-in-windows-10-11-wsl-without-docker-desktop-a2a7eb90556d","ogImage":{"url":"/assets/img/2024-06-22-SetupWSL2forlocaldockerdevelopmentonWindows_0.png"},"coverImage":"/assets/img/2024-06-22-SetupWSL2forlocaldockerdevelopmentonWindows_0.png","tag":["Tech"],"readingTime":5},{"title":"12700162893 오류 설명 자주 발생하는 문제 해결 방법","description":"","date":"2024-06-22 16:30","slug":"2024-06-22-12700162893ExplainedTroubleshootingCommonErrors","content":"\n\n\n![ExplainedTroubleshootingCommonErrors](/assets/img/2024-06-22-12700162893ExplainedTroubleshootingCommonErrors_0.png)\n\n암호화된 주소인 127.0.0.1 및 127.0.0.1:62893은 소프트웨어 및 네트워크 개발에서 종종 이해하기 어렵습니다. 그러나 이 IP 주소는 여러분이 생각하는 것보다 복잡하지 않습니다. 각 단계가 무엇을 의미하는지 이해하면 소프트웨어를 탐색, 사용 및 개발하는 것이 생각보다 쉬워집니다.\n\n## 127.0.0.1 IP 주소 127.0.0.1:62893이란?\n\n이는 서버를 가리키는 특수 주소로, 루프백 또는 로컬호스트로도 알려져 있습니다. 이는 사용 중인 컴퓨터에 특정한 IP 주소로서 사용됩니다. 이 호스트는 누군가가 서버에 연결하고 있는 로컬 컴퓨터의 IP 주소를 모르는 경우에 사용됩니다. 이를 통해 주소를 해결할 수 있도록 도와줍니다.\n\n\n<div class=\"content-ad\"></div>\n\nIP 주소에는 소프트웨어 개발자들에게 다소 신비로운 추가 숫자가 포함될 수 있습니다. 추가 숫자는 다양한 종류의 통신을 수행하는 다른 컴퓨터 게이트웨이를 나타냅니다. 이러한 게이트는 포트라고 불리며, 컴퓨터 내에서 데이터를 송수신합니다. 예를 들어, IP 주소가 \"127.0.0.1:62893\"으로 표시된다면, 62893이 주소의 포트 부분입니다.\n\n컴퓨터에서의 메시지는 IP/TCP 응용 소프트웨어에 의해 생성됩니다. 이 소프트웨어는 127.0.0.1과 포트 62893을 가진 주소를 특별한 IP 주소로 간주하여 메시지를 수신하고 송신하기 위해 대기하는 주소로 인식합니다. 루프백은 IP/TCP 스택에서 동일한 컴퓨터로 메시지를 리디렉션합니다. 디바이스가 자체적으로 통신할 수 있도록 합니다.\n\nIP/localhost 주소는 여러 가지 방법으로 도움이 됩니다:\n\n1. 특정 장치에서 네트워크 트레이가 작동하는지 확인\n\n<div class=\"content-ad\"></div>\n\n2. 로컬호스트에서 실행 중인 서비스에 네트워크 연결 여부에 관계없이 연결할 수 있도록 지원하며 연결을 로컬 컴퓨터로 보냄으로써 도와줍니다.\n\n컴퓨터에서 localhost로 메시지를 보내지 않습니다. 기계에 직접 보냅니다.\n\n3. 라우터를 통해 전달되는 메시지를 필터링하여 컴퓨터에서 실행 중인 네트워크의 보안을 강화합니다. 다른 피드백을 포함하는 모든 메시지를 삭제하여 수행됩니다.\n\n이는 인터넷을 게이트웨이로 사용하려는 해커가 차단되도록 도와줍니다.\n\n<div class=\"content-ad\"></div>\n\n4. 다른 서버에서 온 것처럼 들어오는 메시지가 직접 127.0.0.1:62893을 통해 전송된 경우에도 메시지를 대기열에 넣습니다.\n\n5. 누군가가 터미널이나 CPU와 같은 장치를 사용하여 데이터를 기기로 보내려면 localhost를 사용하여 기기를 지정할 수 있습니다. 또한 브라우저는 호스트 요청을 통해 웹 서버로부터 특정 웹사이트의 위치를 찾을 수 있습니다.\n\n이것은 특정 웹사이트와의 연결 없이 로컬 서버에서 특정 웹사이트로 IP 주소를 통해 요청하는 것을 의미합니다. 컴퓨터가 웹사이트를 실행하는 컴퓨터의 IP 주소를 입력하면 컴퓨터가 https를 요청합니다.\n\n6. 이를 통해 소프트웨어 개발자는 실제로 실행하지 않고도 소프트웨어의 기능을 테스트할 수 있습니다. 소프트웨어를 인터넷에 배포하기 전에 기능을 테스트하는 것이 중요합니다. 사용하기 전에 실패할 수도 있기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n7. 이는 더 빠른 응용 프로그램 개발과 효율적인 응용 프로그램 응답 시간 측정을 보장합니다. 로컬 호스트로 핑을 보내기 때문에 인터넷 연결 속도에 의존하는 원격 서버에 연결하는 것보다 빠릅니다.\n\n원하는 사이트의 링크를 모르는 경우 유용합니다.\n\n8. 새로운 기능을 실험하고 테스트할 때 데이터 손실이나 손상을 걱정하지 않고 안전한 환경을 제공합니다. 로컬 호스트는 학생들이 어떤 프로그램이나 소프트웨어에 손상을 입히지 않고 시험하고 실험을 할 수 있는 안전한 공간을 만들어줍니다.\n\n## 컴퓨터의 IP 주소를 어떻게 얻을 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n다음 단계를 따라해보세요:\n\nWindows 사용자는 화면 왼쪽 하단의 시작 메뉴로 이동합니다.\nCMD를 입력하여 명령 프롬프트를 열고 ipconfig를 입력하여 주소를 얻습니다.\nLinux 사용자는 Ctrl + Alt + T를 눌러 터미널을 열고 ipconfig를 입력한 후 Enter 키를 누릅니다.\nIP 주소를 복사하고 브라우저 주소 표시줄에 붙여넣기합니다.\n\n당신의 컴퓨터에서 실행 중인 웹 서버에 요청을 보내고 기본 Apache 웹 페이지를 표시하세요. 이제 로컬 호스트(서버)에 액세스하여 사이트의 로컬로 생성한 모든 페이지에 액세스할 수 있습니다.\n\n이 페이지가 표시되지 않는다면, 컴퓨터에서 Apache 서버가 작동하지 않는 것을 의미합니다. 이 문제를 해결하려면 서버를 다시 시작하고 위의 단계를 따르세요. 또한 온라인 상태이어야 하며 근처 컴퓨터에 액세스해야 서버에 연결할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 자주 묻는 질문\n\n## 내 브라우저가 네트워크에 연결되지 않은 상태에서 로컬로 HTTP 요청을 할 수 있나요?\n\n예, 여러분의 컴퓨터는 이 작업을 위해 네트워크에 연결되어 있을 필요가 없어요! 자기 자신과 소통할 수 있어요! 사실, 여러분의 컴퓨터가 인터넷에 연결되어 있지 않은 경우, 기본 주소인 127.0.0.1에 연결될 거예요. 이 주소는 특정 네트워크에 속해 있지 않아요.\n\n## 로컬호스트와 IPv6 주소 사이에 무엇이 다른가요?\n\n<div class=\"content-ad\"></div>\n\n로컬호스트(Localhost)는 주로 숫자로 지정된 기본 IPv4 주소로서 127.0.0.1이며, 포트 62893이며, 컴퓨터에 대한 주소로 작용합니다. 반면, IPv6 주소는 숫자 시퀀스 127.0.0.1과 함께 나타나는 인터넷 프로토콜 v6 시퀀스입니다. 이들은 IPv4 주소와 같이 여러 주소를 형성하지 않는 루프백 주소입니다.\n\n## 루프백 주소를 사용하여 웹사이트를 차단할 수 있을까요? 가능하다면, 어떻게 할까요?\n\n네, 가능합니다. 아래 단계를 따라주십시오:\n\n관리자 권한으로 메모장을 엽니다. 사용자 계정 컨트롤 프롬프트를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n파일을 클릭한 다음 열기를 선택하세요.\n\n호스트 파일 열기\n\n다음을 입력하세요: \n\n0.1-와 주소 사이에 슬래시를 넣고 저장하세요.\n\n<div class=\"content-ad\"></div>\n\n컴퓨터를 다시 시작해주세요.\n\n## 시스템 복원이 프록시 바이러스 127.0.0.1: 62893를 고쳤나요?\n\n네. 시스템 복원은 최근에 다운로드한 파일이나 앱을 제거하여 오류를 해결하는 데 도움을 줄 수 있습니다. 이는 중요한 파일들이 위험에 노출되지 않음을 의미합니다.","ogImage":{"url":"/assets/img/2024-06-22-12700162893ExplainedTroubleshootingCommonErrors_0.png"},"coverImage":"/assets/img/2024-06-22-12700162893ExplainedTroubleshootingCommonErrors_0.png","tag":["Tech"],"readingTime":4},{"title":"Windows 11 KB5039212 업데이트  2024년 6월, 새로운 기능은 무엇일까요","description":"","date":"2024-06-22 16:29","slug":"2024-06-22-Windows11KB5039212UpdateJune2024Whatsnew","content":"\n\n마이크로소프트가 Windows 11용 KB5039212를 발표했어요. 2024년 6월 패치 화요일 업데이트입니다. 이제 알아야 할 모든 것이 여기 있어요!\n\n![이미지](/assets/img/2024-06-22-Windows11KB5039212UpdateJune2024Whatsnew_0.png)\n\n마이크로소프트가 Windows 11 버전 23H2 및 버전 22H2용 KB5039212를 출시했습니다. 이 업데이트는 기존 기능을 위한 여러 개선 사항, 보안 개선 사항 및 최신 버그 수정을 제공합니다. 업데이트를 다운로드하고 설치하려면 설정 - Windows 업데이트로 이동하여 업데이트를 확인하세요. 변경 사항을 적용하려면 디바이스를 다시 시작해야 합니다. KB5039212를 설치하면 Windows 11 빌드 22631.3737를 업그레이드할 수 있고 웹페이지 및 파일을 공유하기 위한 QR 코드를 생성할 수 있습니다. 또한 파일 탐색기 주소 표시줄의 breadcrumb 사이에서 파일을 끌어서 파일 경로 내 다른 위치로 쉽게 이동할 수 있습니다.\n\nWindows 11 KB5039212 직접 다운로드 링크: 64비트 및 32비트 (x86) | 마이크로소프트 업데이트 카탈로그.\n\n<div class=\"content-ad\"></div>\n\n# Windows 11 빌드 22631.3737의 새로운 기능\n\n- 이 업데이트는 작업 표시줄에 영향을 주는 알려진 문제를 해결합니다. 일시적으로 깜빡일 수 있거나 응답하지 않을 수 있습니다. 또한 사라졌다가 다시 나타날 수도 있습니다.\n- 이 업데이트는 lsass.exe에 영향을 주는 문제를 해결합니다. 이 프로세스가 응답을 중지합니다. 이는 Windows 서버에 2024년 4월 보안 업데이트를 설치한 후 발생합니다.\n- 이 업데이트는 비트록커를 켠 후에 시스템이 휴면에서 다시 시작되지 않을 수 있는 문제를 해결합니다.\n- 이 업데이트는 lsass.exe에 영향을 주는 문제를 해결합니다. 메모리 누수가 발생합니다. 이는 로컬 보안 권한 부여 기관(Domain Policy) 원격 프로토콜(LSARPC) 호출 중에 발생합니다.\n- 이 업데이트는 설치 프로세스에 영향을 주는 알려진 문제를 해결합니다. 시스템을 다시 시작할 때 오류가 발생할 수 있습니다. 또한 기기가 이전 업데이트로 롤백될 수도 있습니다. 주로 Arm 기반 Mac 장치에서 실행되는 Windows 가상 머신(Parallels Desktop)에서 발생합니다.\n\n이 업데이트에는 지난 달 미리보기 업데이트 Windows 11 KB5037853 (OS 빌드 22621.3672 및 22631.3672)의 변경 및 개선 사항이 포함되어 있습니다. 자세한 내용은 [링크](https://windows101tricks.com/windows-11-update/)를 참조하세요.","ogImage":{"url":"/assets/img/2024-06-22-Windows11KB5039212UpdateJune2024Whatsnew_0.png"},"coverImage":"/assets/img/2024-06-22-Windows11KB5039212UpdateJune2024Whatsnew_0.png","tag":["Tech"],"readingTime":2},{"title":"Snapdragon X Elite, Microsoft 때문에 제 성능을 발휘하지 못하는 이유","description":"","date":"2024-06-22 16:28","slug":"2024-06-22-SnapdragonXEliteIsBeingHeldBackByMicrosoft","content":"\n\n얼마 전에 Snapdragon X Elite에 대한 분석을 한 적이 있습니다. 이 분석은 초기 벤치마크를 기반으로 한 Qualcomm의 X Elite Matches M3 Loses To M4라는 제목의 글이었습니다. 그때는 몇 가지 출판물만이 칩을 손에 넣을 수 있었던 시절이었습니다. 그러나 지금은 Snapdragon X Elite가 공식적으로 출시되었는데, 성능은 어떨까요? 그다지 좋지 않습니다.\n\n전에 쓴 글에서 말한 모든 것에 여전히 공감합니다. Arm에 네이티브로 컴파일된 프로그램을 실행하는 경우 Snapdragon X Elite는 좋은 칩입니다. 그러나 Arm에 네이티브로 컴파일되지 않은 프로그램을 실행할 때는 약간 문제가 발생할 수 있습니다.\n\n그리고 Windows에는 Arm에 컴파일되지 않은 프로그램이 많습니다. 게임을 말하고 있습니다. 사실, 전 포스트에서 이에 대해 추측했던 적이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아미에서 실행되도록 이전 게임을 업데이트하는 동기는 그리 많지 않아요. GTA 5 같은 경우. X Elite에서 GTA 5를 업그레이드할까요? 전혀 아니에요, 대신 GTA 6를 사세요.\n\n라이브 서비스 게임과 구독 앱에 대해 말하고 싶은 게 있을 수 있지만, 그런 것들은 지원받아요. 제가 이에 대해 언급한 게시물 Why The Subscription Economy Is The Best Thing To Ever Happen To Software에 나와 있어요. 왜냐하면 그런 것을 지원하는 동기가 있기 때문이에요.\n\n생각해보니 GTA 5는 기술적으로 게임 내에서 구매를 할 수 있는 방법이 있고 GTA 6는 아직 출시되지 않았기 때문에 그 게임을 아미에서 실행할 수 있도록 업데이트할 수도 있겠네요. 하지만 저는 의심스러워요. 그냥 GTA 6로 넘어가서 모든 것을 다시 사세요.\n\n전체적으로 게임 상황이 좀 실망스러운 것 같아요. 아마도 저는 내 Steam Deck에 너무 행복해졌나 봐요. 그건 리눅스를 실행하고 있고 상당히 많은 게임이 실행되는데요. 하지만 Steam Deck은 x86-64 프로세서를 사용하고 있어서 좀 더 쉬울지도 몰라요. Steam Deck은 윈도우 시스템 콜을 리눅스 시스템 콜로 변환하면 되고요. 마이크로소프트의 프리즘에서는 실제 어셈블리 명령어를 변환해야 해요. 그 일은 더 많은 작업을 필요로 하고 심지어 애플의 로제타도 일부 앱을 변환할 수 없어요. 하지만 Apple Silicon에서 작동한 앱의 수는 처음부터 매우 높았어요.\n\n<div class=\"content-ad\"></div>\n\nWWDC 2023에서 애플은 Windows x86–64 게임을 Arm으로 자동으로 이식할 수 있는 도구를 소개했어요. 이 도구는 개발자용 도구이기 때문에 문제가 있을 수 있지만 꽤 잘 작동해요.\n\n마이크로소프트도 같은 작업을 할 수 있었으면 좋겠어요. 리뷰를 보면 Snapdragon X Elite에서 게임을 실행하는데 낮은 프레임 속도와 그래픽 아티팩트에 대해 리뷰어들이 일관되게 불평합니다. 게임이 실행되는 것조차 문제인 것 같아요. \n\n이는 걱정스럽네요. 만약 게임이 작동하지 않으면 비즈니스 소프트웨어는 어떨까요? 실제로 필요한 것들 말이에요, 학교 과정에서도 필요한 것들 말이죠. 더 쉬운 문제일 것이라고 생각할 수 있지만 아닐 수도 있어요. Windows는 광범위한 하위 호환성을 가지고 있어서 때때로 이전 버전에서 버그까지 이식하곤 해요. 이는 마이크로소프트가 앱을 업데이트할 믿음이 없어 보일 때문일지도 모르죠. Windows 프로그램은 아주 적은 업데이트를 받아요.\n\n보통 업데이트가 없으면 괜찮아요. 특히 윈도우가 매년, 십년마다 크게 변하지 않기 때문이죠. 하지만 Arm에서는 이것이 주요 문제가 될 것입니다. 왜냐하면 애플 실리콘이 출시되자 앱 업데이트가 아주 빨리 이루어졌는데, 윈도우에서는 그렇게 되지 않을 것 같아요.\n\n<div class=\"content-ad\"></div>\n\n신규 리뷰 중에는 일부 프로그램을 실행할 수 없다는 보고가 나온 것 같아요. 업데이트가 될까요? 누가 알겠죠?\n\n리뷰에 대해 이야기해봅시다. 일부 리뷰어들이 성능이 그리 좋지 않다고 불평을 했어요. 보고서를 충분히 선택적으로 골라내면 원하는 내용을 담긴 것처럼 만들 수 있죠. 공정하게 말하자면 Qualcomm도 상당히 선택적으로 결과를 보여줬습니다. 하지만 기술 리뷰어들도 마찬가지죠. 전체적으로 보면 이전에 보여진 것들과 크게 다르지 않은 벤치마크 결과들이에요.\n\n아직까지는 X Elite 노트북을 몇 개만 봤습니다. 총 4개의 X Elite 칩이 있어요. 냉각 및 내부 구성품 선택도 역할을 할 수 있어요. 속도는 그렇게 걱정하지 않아요. 지난 몇 년 동안의 어떤 메인스트림 칩이라도 충분히 빠를 거에요. 더 중요한 것은 배터리 수명이에요. X Elite은 이 측면에서 잘 동작하는 것 같아요. 비록 M1 MacBook Air을 이긴 것으로 주장한 것은 아니었지만요. 시연에서 X Elite 노트북이 에너자이저 배니처럼 꾸준히 작동하는 모습을 보여줬어요. 하지만 X Elite의 다양한 변형들은 특히 다양한 전력 효율 설정에 따라 다르게 동작할 수 있어요.\n\n그래서 X Elite에 대해 어떻게 생각하나요? 애플이 마침내 경쟁사가 생겼다는 것에 기뻐해요. 특히 그 아름다운 OLED 디스플레이들과 함께 말이에요. Vivobook S15을 사용하는 모든 리뷰어들이 화면이 얼마나 멋진지 늘 언급하고 있어요. 애플, 이제 Pro에 OLED를 넣어봐요. 무엇을 기다리고 있나요?\n\n<div class=\"content-ad\"></div>\n\n새 노트북을 사려고 생각 중이었어. 사실을 말하자면, 현재 애플의 맥북 제품에 대해 그다지 만족스럽지 않아. 새로운 맥북 에어 디자인이 싫어. 저 벌써 이물감이 드네. 저 노치 때문이야, 그리고 스피커도 더 안 좋아졌어. 혹시 저만 그런 걸까? 그리 나쁘진 않지만, 확실히 나의 M1과 비교하면 다운그레이드된 기분이야.\n\n맥북 프로도 노치가 있고, 게다가 엉망인 미니 LED 디스플레이를 달았어. 이것에 대해 너무 많이 불평을 해왔는데, 이젠 거의 웃기게까지 다가왔어. 요약하자면, 디스플레이 반응 시간이 69ms야. 그래서 이들 디스플레이를 120Hz라고 하는 건 오도독도하지. 모션 스무딩이 있는 15Hz로 마케팅되어야 하는 거야.\n\n어떻게 할 지 모르겠어. 다만 한 가지는 확실해: X Elite 노트북은 사지 않을 거야. 고민을 했지만, iOS 개발자로서 앱을 만들려면 다른 맥이 하나 더 필요하거든. 게다가 X Elite에서 많은 프로그램이 작동하지 않는 것도 나를 걱정시켜.\n\n얼마 전에는 X Elite에 너무 흥분했었어. 지금도 여전해. 칩이 튼튼하거든. 그러나 문제는 칩이 아니야. 문제는 x86-64에서 Arm64로의 번역 계층이야. 문제는 마이크로소프트야.","ogImage":{"url":"/assets/img/2024-06-22-SnapdragonXEliteIsBeingHeldBackByMicrosoft_0.png"},"coverImage":"/assets/img/2024-06-22-SnapdragonXEliteIsBeingHeldBackByMicrosoft_0.png","tag":["Tech"],"readingTime":4}],"page":"40","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}