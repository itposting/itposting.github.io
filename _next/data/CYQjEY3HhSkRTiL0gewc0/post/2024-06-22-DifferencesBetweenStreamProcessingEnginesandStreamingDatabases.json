{"pageProps":{"post":{"title":"스트림 프로세싱 엔진과 스트리밍 데이터베이스의 차이점","description":"","date":"2024-06-22 17:32","slug":"2024-06-22-DifferencesBetweenStreamProcessingEnginesandStreamingDatabases","content":"\n\n<img src=\"/assets/img/2024-06-22-DifferencesBetweenStreamProcessingEnginesandStreamingDatabases_0.png\" />\n\n리얼타임 분석 분야에서 빠르게 발전하는 가운데, 지난 10년간 다양한 스트림 처리 엔진이 등장했습니다. 주목할 만한 예시로는 Apache Storm, Apache Flink, Apache Samza 등이 있습니다. 이러한 엔진들은 다양한 기업에서 널리 받아들여져 실시간 처리 및 분석 애플리케이션에 상당한 지원을 제공하고 있습니다.\n\n지난 몇 년 동안 새롭고 흥미로운 혁신이 등장했습니다: 스트리밍 데이터베이스. PostgreSQL 플러그인으로 개발된 초기 솔루션이었던 PipelineDB를 시작으로, 카프카를 위해 디자인된 Confluent의 KsqlDB, 그리고 최근에 등장한 오픈 소스인 RisingWave - 분산 SQL 스트리밍 데이터베이스입니다. 이러한 시스템들은 꾸준히 수용과 인기를 얻어왔습니다.\n\n그럼 스트림 처리 엔진과 스트리밍 데이터베이스를 서로 교환해서 사용할 수 있을까요? 이 기사는 각각의 설계 원칙에 대해 알아보며, 이러한 흥미로운 기술들의 차이점, 유사성, 사용 사례, 그리고 잠재적인 미래 전망을 탐구합니다.\n\n<div class=\"content-ad\"></div>\n\n# 디자인 원칙\n\n스트림 처리 엔진과 데이터베이스는 데이터 스트림 처리에 중요한 기능을 제공합니다. 그러나 사용자 상호 작용 인터페이스 및 데이터 저장 옵션 측면에서 디자인 원칙에서 뚜렷한 차이가 있습니다. 이러한 기술이 등장한 역사적 배경을 명확히 이해하기 위해 각각의 독특한 특성에 대해 자세히 알아보기 전에 관심을 기울여야 합니다.\n\n# 스트림 처리 엔진의 진화\n\n데이터베이스 시스템은 60년 이상의 시간 동안 연구되어 왔지만, 배치 처리 및 스트림 처리를 포괄하는 컴퓨팅 엔진은 비교적 최근의 혁신입니다. 현대 스트림 처리로의 여정은 2004년 구글의 MapReduce 논문 발표로 시작되었습니다.\n\n<div class=\"content-ad\"></div>\n\nMapReduce는 최고의 성능을 위해 상품용 기계 네트워크를 효율적으로 최적화하는 것을 목표로 했습니다. 이 높은 목표는 MapReduce에서 두 가지 주요 기능, Map과 Reduce,을 갖춘 세련된 저수준 프로그래밍 인터페이스의 도입으로 이어졌습니다. 이러한 설계는 유경험 프로그래머에게 핵심 기능에 직접 액세스할 수 있게 해주어 특정 비즈니스 논리를 구현하고 프로그램 병렬 처리를 제어하며 다른 복잡한 세부사항을 자체적으로 관리할 수 있도록 했습니다.\n\nMapReduce를 독특하게 만든 점은 데이터 저장을 원격 분산 파일 시스템과 같은 외부 시스템에 위임하여 처리에만 초점을 맞춘 것입니다. 이 분할은 오늘날의 스트림 처리 엔진에 영향을 주고 스트리밍 데이터베이스와의 중요한 차이점 및 시너지 파악을 위한 무대를 설정했습니다.\n\n회사 내에서 MapReduce를 성공적으로 활용하기 위해 다음 세 가지 중요 사전 조건이 필요했습니다:\n\n- 회사는 상당량의 데이터와 관련 비즈니스 시나리오를 내부에 보유해야 합니다.\n- 회사는 상품용 기계에 충분히 액세스할 수 있어야 합니다.\n- 회사는 숙련된 소프트웨어 엔지니어 집단을 고용해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n이 세 가지 조건은 맵리듀스가 2004년에 소개될 때 대부분의 기업들이 달성하기 어려웠던 벽이었습니다. 소셜 네트워크와 모바일 인터넷의 폭발적인 성장으로 2010년 이후에야 첫 번째 조건이 충족되기 시작했습니다. 이러한 변화로 주요 기업들은 스트림 처리 기술에 관심을 기울이고, 두 번째와 세 번째 전제 조건을 충족하기 위해 크게 투자했습니다. 이 투자는 2010년쯤부터 시작된 스트림 처리 엔진의 발전 시대를 의미했습니다. 이 기간 동안 Apache Storm, Apache Samza, Apache Flink 등 다수의 탁월한 스트림 처리 엔진이 등장했습니다.\n\n이 신생 스트림 처리 엔진들은 맵리듀스 디자인 패턴의 핵심 원칙을 완전히 수용했습니다. 구체적으로 다음과 같습니다:\n\n- 사용자에게 저수준 프로그래밍 인터페이스 노출;\n- 데이터 스토리지 제어 양보.\n\n이 디자인은 빅데이터 시대에 적합하게 개조되었습니다. 일반적으로 대량 데이터 처리를 필요로 하는 기술 기업들은 자체 데이터 센터와 전문 엔지니어링 팀을 보유했습니다. 이 기업들이 필요로 한 것은 성능 향상과 더 다채로운 프로그래밍 패러다임이었습니다. 전문 엔지니어링 팀과 함께하면 보통 분산 파일 시스템을 배포하여 방대한 데이터 스토리지를 처리할 수 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 2015년 이후 클라우드 컴퓨팅 기술의 혁신적인 발전으로 풍경이 변화하기 시작했습니다. 기술적 배경이 부족한 기업들조차도 스트림 처리 기술에 접근하고자 했습니다. 이 수요에 대응하여 스트림 처리 엔진은 SQL을 채택해 간결하고 폭넓게 인정받는 프로그래밍 언어가 되었습니다. 이 적응으로 인해 더 많은 사용자들이 스트림 처리 기술의 혜택을 누릴 수 있게 되었습니다. 그 결과, 오늘날 주요한 스트림 처리 엔진은 사용자 상호작용에 계층적 접근 방식을 제공하며 Java와 Scala와 같은 낮은 수준의 프로그래밍 인터페이스와 더 접근성 있는 고수준의 SQL 프로그래밍 인터페이스를 제공합니다.\n\n# 사용자 상호작용 인터페이스\n\n현대의 스트림 처리 엔진은 Java와 Scala와 같은 낮은 수준의 프로그래밍 인터페이스뿐만 아니라 SQL 및 Python과 같은 고수준 인터페이스도 제공합니다. 이러한 인터페이스는 병렬성과 같은 다양한 시스템 런타임 세부 정보를 노출하여 사용자가 응용프로그램의 설령 미묘한 측면들을 제어할 수 있게 합니다. 다른 한편으로, 스트리밍 데이터베이스는 주로 SQL 인터페이스를 특징으로 하며 런타임 복잡성을 단순화합니다. 일부는 파이썬 및 자바와 같은 언어로 사용자 정의 함수(UDF)를 제공하여 표현 능력을 향상시킵니다. 이러한 사용자 상호작용 인터페이스의 다양성은 두 가지 주요 균형을 유발합니다.\n\n1. 유연성과 사용 편의성 사이의 균형 유지\n\n<div class=\"content-ad\"></div>\n\n능숙한 프로그래머들은 Java와 Scala와 같은 저수준 인터페이스가 제공하는 풍부한 표현 능력을 누릴 수 있습니다. Turing-complete 언어인 Java, Scala 및 유사한 언어는 이론적으로 사용자가 어떤 로직이든 표현할 수 있도록 합니다. 기존 Java 및 Scala 라이브러리를 보유한 기업에게는 특히 유리합니다.\n\n그러나 이러한 접근법은 Java나 Scala에 익숙하지 않은 사람들을 막을 수 있으며 복잡함 때문에 시간이 많이 소요될 수 있습니다. 시스템의 사용자 정의 API를 마스터하는 것은 기술적인 사용자에게도 어려울 수 있습니다.\n\n스트리밍 데이터베이스에서 더 높은 수준의 SQL 인터페이스를 통해 사용 편의성을 강조하면 몇 가지 사용 가능한 도전 과제가 있습니다. 첫 번째는 SQL 지원의 완성도로, 단순한 DML (데이터 조작 언어) 문이 아닌 복잡한 DDL (데이터 정의 언어) 작업이 필요할 수 있습니다. 사용자들은 종종 롤, 사용자, 인덱스 생성 또는 삭제와 같은 복잡한 작업이 필요합니다. 두 번째는 SQL 생태계의 지원으로, DBeaver나 pgAdmin과 같은 관리 도구와의 호환성을 포함하여 추가 노력이 필요할 수 있습니다.\n\n저수준 인터페이스는 기술 중심 사용자에게 더 많은 유연성을 제공하며, 스트리밍 데이터베이스의 SQL 인터페이스는 비즈니스 중심 사용자를 위해 특별히 설계되어 사용 편의성을 강조합니다.\n\n<div class=\"content-ad\"></div>\n\n2. 유연성과 성능의 균형\n\n낮은 수준의 프로그래밍 인터페이스의 가용성은 사용자가 이전 지식을 활용하여 시스템 성능을 최적화할 수 있게 합니다. 심층적인 프로그래밍 전문 지식과 비즈니스 논리 이해력을 갖춘 사람들은 종종 낮은 수준의 인터페이스를 통해 탁월한 성능을 얻을 수 있습니다. 그러나 이에는 회사가 엔지니어링 팀을 구축하기 위해 더 많은 투자를 해야 할 수도 있습니다.\n\n대조적으로, 고수준 프로그래밍 인터페이스를 사용할 때 계층적 스트림 처리 엔진은 성능 단점을 겪을 수 있습니다. 캡슐화는 성능 오버헤드를 야기하며 캡슐화 계층이 더 많을수록 성능이 더 나빠집니다. 스트림 처리 엔진의 중간 계층은 하위 디자인이 고수준 논리에 어둡게 되어 성능 손실을 야기할 수 있습니다. 비교적으로, SQL 인터페이스와 최적화 기능만을 제공하는 스트리밍 데이터베이스는 더 높은 성능 수준에 도달할 수 있습니다.\n\n요약하면, 낮은 수준의 인터페이스를 갖춘 스트림 처리 엔진은 기술 중심 사용자가 성능 이점을 얻을 수 있도록 해줍니다. 반면 SQL 인터페이스를 제공하는 스트리밍 데이터베이스는 비즈니스 중심 사용자를 위해 맞춤화되어 있으며 복잡한 기술 전문 지식이 필요 없이도 더 높은 성능 경계를 달성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 데이터 저장\n\n사용자 상호 작용 인터페이스 외에도 스트림 처리 엔진과 스트리밍 데이터베이스 사이의 가장 중요한 차이점은 시스템이 데이터를 저장하는지 여부입니다. 스트림 처리에서 데이터 저장의 유무는 성능, 오류 복구, 확장성 및 사용 사례와 같은 시스템의 여러 측면에 직접적으로 영향을 미칩니다.\n\n스트림 처리 엔진에서 데이터 입력 및 출력은 일반적으로 HDFS와 같은 원격 분산 파일 시스템과 같은 외부 시스템에서 발생합니다. 반면, 스트리밍 데이터베이스는 계산 능력 뿐만 아니라 데이터 저장 기능도 포함하고 있습니다. 이는 적어도 두 가지 작업을 수행할 수 있다는 것을 의미합니다: 1) 입력을 저장하고, 2) 출력을 저장합니다.\n\n데이터 입력 측면에서 데이터 저장은 중요한 성능 이점을 제공합니다. 예를 들어, 데이터 입력을 저장하는 경우 성능상의 이점이 있습니다. 메시지 큐(예: Kafka)에서의 데이터 스트림과 원격 데이터베이스(예: MySQL)에 저장된 테이블을 결합하는 단순한 스트림 처리 엔진의 시나리오를 고려해 보겠습니다. 스트림 처리 엔진이 데이터 저장 기능이 없는 경우, 새로운 데이터 항목이 스트림에 들어올 때마다 연산을 수행하기 전에 원격 데이터베이스에서 데이터를 가져와야 합니다. 이 접근 방식은 초기 분산 스트림 처리 엔진에서 채택되었습니다. 시스템 아키텍처를 간단화하는 장점이 있지만, 성능이 급격히 저하된다는 단점이 있습니다. 서로 다른 시스템 간의 데이터 접근은 명백히 높은 지연 시간을 유발하며, 지연 시간에 민감한 스트림 처리 엔진에 높은 지연 작업을 도입하면 성능이 떨어지게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n스트림 처리 시스템 내부에 데이터를 저장(또는 캐싱)하면 시스템 간 데이터 접근을 피할 수 있어 성능을 향상시킬 수 있습니다. 내장 저장 기능을 갖춘 스트림 처리 시스템인 스트리밍 데이터베이스에서는 사용자가 필요에 따라 메시지 대기열에서 데이터 스트림을 가져와 원격 데이터베이스의 테이블과 결합해야 할 때 해당 테이블을 직접 스트리밍 데이터베이스로 복제할 수 있습니다. 이렇게 하면 모든 접근이 내부 작업으로 처리되어 효율적인 처리가 가능해집니다. 물론 이것은 단순화된 예시일 뿐입니다. 실제 시나리오에서는 원격 데이터베이스의 대규모 또는 동적으로 변화하는 테이블과 같은 문제가 발생할 수 있으나 이에 대해 자세히 다루지는 않겠습니다.\n\n출력 측면에서 출력 결과를 저장하는 것은 상당한 이점을 제공할 수 있습니다. 간단히 말해 네 가지 주요 장점은 다음과 같습니다:\n\n- 데이터 스택 아키텍처를 단순화: 계산을 위해 별도의 스트림 처리 엔진과 데이터 저장 및 쿼리 응답을 위한 별도의 저장 시스템을 사용하는 대신 스트리밍 데이터베이스와 같이 단일 시스템이 계산, 저장 및 쿼리 응답을 처리할 수 있습니다. 이 방식은 데이터 스택을 크게 단순화하고 종종 비용 절감을 이루어냅니다.\n- 계산 리소스 공유 용이: 스트림 처리 엔진에서는 계산 결과가 입력 데이터를 사용하고 계산을 수행한 후 외부 시스템으로 내보내기 때문에 그 결과를 시스템 내에서 직접 재사용하기가 어렵습니다. 내장 저장 기능을 갖춘 스트리밍 데이터베이스는 계산 결과를 내부적으로 머티얼라이징된 뷰로 저장해 다른 계산이 이 리소스에 직접 액세스하고 재사용할 수 있게 해줍니다.\n- 데이터 일관성 보장: 스트림 처리 엔진은 처리에 대한 정확히 한 번 문맥을 보장할 수 있지만 결과 액세스 일관성을 보장할 수는 없습니다. 스트림 처리 엔진은 저장소가 없기 때문에 계산 결과를 하류 저장 시스템으로 가져와야 합니다. 상류 엔진은 결과의 버전 정보를 하류 시스템으로 출력하여 하류 시스템의 사용자에게 보여지는 일관된 결과를 얻도록 해야 합니다. 이는 일관성 보장 부담을 사용자에게 지우게 됩니다. 반면, 저장 기능을 갖춘 스트리밍 데이터베이스는 시스템 내에 계산 진행 상태와 결과 버전 정보를 관리하여 사용자가 다중 버전 컨트롤을 통해 항상 일관된 결과를 보게끔 해줍니다.\n- 프로그램 해석 용이성 향상: 프로그램 개발 중에는 반복적인 수정과 정확성 검증이 흔합니다. 정확성을 검증하는 공통 접근 방법은 입력 및 출력을 얻어와 계산 논리가 기대에 부응하는지 수동으로 검증하는 것입니다. 이 작업은 배치 처리 엔진에서는 비교적 간단하지만 스트림 처리 엔진에서는 더 복잡합니다. 스트림 처리 엔진에서는 입력 및 출력이 동적으로 변하기 때문에 엔진이 저장소가 없고 정확성을 검증하기 위해 상류 메시지 소스, 하류 결과 저장 시스템 및 스트림 처리 엔진을 횡단해야 합니다. 게다가 사용자는 계산 진행 정보를 인식해야 해 복잡한 작업이 됩니다. 이에 비해 스트리밍 데이터베이스에서는 계산 결과가 데이터베이스 내에 저장되므로 상류 시스템에서 입력을 얻은 후(일반적으로 Kafka와 같은 메시지 대기열로 직접 오프셋을 가져오는 방식) 단일 시스템 내에서 결과를 검증하기만 하면 됩니다. 이는 개발 효율을 크게 향상시킵니다.\n\n물론 공짜 점심은 없으며 소프트웨어 개발은 단순해 보이는 해결책을 제공하지 않습니다. 스트림 처리 엔진과 비교했을 때 저장 기능을 갖춘 스트리밍 데이터베이스는 아키텍처, 리소스 활용, 일관성 및 사용자 경험에서 많은 장점을 제공합니다. 하지만 그에 따라 어떤 것을 희생해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n한 가지 중요한 희생은 소프트웨어 설계의 복잡성입니다. MapReduce의 설계를 기억해보세요. MapReduce의 개념은 오라클과 IBM과 같은 거대 기업이 전체 데이터베이스 시장을 지배하던 시절에 뛰어났습니다. 왜냐하면 이들은 많은 보통 컴퓨터를 사용하는 기술 기업을 위해 대규모 병렬 컴퓨팅을 가능케 하는 간단한 모델을 효과적으로 활용했기 때문입니다.\n\nMapReduce는 데이터베이스의 저장 및 연산 통합 개념을 직접 역전시켰으며, 연산을 독립적인 제품으로 분리했습니다. 이를 통해 사용자는 프로그래밍을 통해 연산을 확장할 수 있게 되었습니다. 다시 말해, MapReduce는 간소화된 아키텍처를 통해 대규모 수평 스케일링을 실현했으며, 높은 수준의 전문 기술 사용자의 유능성에 의존했습니다.\n\n그러나 시스템이 데이터 저장을 필요로 하는 경우, 모든 것이 더욱 복잡해집니다. 그러한 시스템을 사용 가능하게 만들기 위해 개발자는 고가용성, 장애 복구, 동적 스케일링, 데이터 일치성 및 기타 다양한 도전에 대한 섬세한 설계와 구현을 고려해야 합니다. 다행히도 지난 10년 동안 대규모 데이터베이스와 스트림 처리의 이론과 실무가 크게 발전해왔습니다. 따라서 지금은 스트리밍 데이터베이스의 등장에 이상적인 시기라고 할 수 있습니다.\n\n# 활용 사례\n\n<div class=\"content-ad\"></div>\n\n계산 모델에서 유사성을 공유하고 있지만, 스트리밍 처리 엔진과 스트리밍 데이터베이스는 여전히 고유한 응용 및 기능으로 이어지는 세세한 점들이 있습니다. 이러한 기술들은 응용 분야에서 중첩되어 있지만, 최종 사용자의 초점에서 차이가 나타납니다.\n\n스트림 처리 엔진은 일반적으로 기계 중심의 작업과 더 일치하며 데이터 저장 기능이 부족하며 종종 계산 결과 소비를 위해 하류 시스템과 통합이 필요합니다. 반면에, 스트리밍 데이터베이스는 더 많은 인간 상호 작용을 고려하여 저장 및 임의 쿼리 지원을 제공함으로써 직접적인 인간 참여를 가능하게 합니다.\n\n기계와 인간 사이의 이분법은 기계가 하드코딩된 프로그램의 고성능 처리를 요구하면서, 인간은 더 인터랙티브하고 사용자 친화적인 경험을 선호한다는 것을 보여줍니다. 이 본질적인 이견으로 인해 스트림 처리 엔진과 스트리밍 데이터베이스 간의 기능, 사용자 경험 및 기타 측면에서 차이가 생깁니다.\n\n요약하면, 이러한 기술들 간의 응용 시나리오에서의 공통점은 최종 사용자와 상호 작용 모드에 특정 초점이 있어 각 시스템 내에서 독특한 기능을 결과로 낳습니다.\n\n<div class=\"content-ad\"></div>\n\n# 역사적 차원으로 나아가는 거담아, 아니면 현재 시대의 트렌드일까요?\n\n데이터베이스와 컴퓨팅 엔진은 종종 서로 다른 두 가지 설계 철학을 반영합니다. 그것들은 독특한 학계 기여와 산업 발전을 통해 명백히 입증됩니다.\n\n학계에서는 컴퓨팅 엔진 논문들이 주로 OSDI, SOSP, EuroSys와 같은 시스템 회의에서 발표되는 반면, 데이터베이스 중심 작업들은 주로 SIGMOD 및 VLDB 회의에서 자주 볼 수 있습니다. 이 분할은 2008년 David DeWitt와 Michael Stonebraker에 의한 \"MapReduce: 역사적인 큰 걸음\" 비평에 의해 유명하게 강조되었습니다. 그들은 MapReduce가 역사적으로 후퇴적이고 데이터베이스에 비해 더 많은 혁신이 필요하다고 주장했습니다.\n\n스트림 처리의 영역에서, 다음 질문이 등장합니다: 어떤 철학이 역사적으로 후퇴를 대표하고, 어떤 것이 현재 시대의 트렌드를 대변할까요? 저는 스트림 처리 엔진과 스트리밍 데이터베이스가 앞으로 최소 3~5년 동안 공존하고 계속 발전할 것으로 판단합니다.\n\n<div class=\"content-ad\"></div>\n\n스트림 처리 엔진은 극한의 성능과 유연성에 중점을 둬 기술적으로 뛰어난 사용자들을 대상으로 합니다. 한편, 스트리밍 데이터베이스는 사용자 경험의 우아함과 높은 성능 그리고 섬세한 내부 구현을 균형있게 갖추고 있습니다. 이러한 철학 간 상호 통합 트렌드는 SQL 인터페이스를 도입해 사용자 경험을 향상시키는 컴퓨팅 엔진과 UDF 기능을 활용해 프로그래밍 적응성을 높이는 데이터베이스 등 양쪽을 모두 강화시킵니다.\n\n# 스트림 처리의 미래 예측\n\n역사를 살펴보면, 스트리밍 데이터베이스 개념은 20년 전에 이미 제안되고 구현되었습니다. 예를 들어, 앞서 언급된 Aurora 시스템은 이미 스트리밍 데이터베이스입니다. 그러나 스트리밍 데이터베이스는 스트림 처리 시스템만큼 인기가 없습니다. 역사는 나선형 패턴으로 진행됩니다.\n\n빅 데이터 시대는 스트림 처리와 데이터베이스를 분리하고 오라클, IBM, Microsoft와 같은 세 거인의 독점을 무너뜨리는 트렌드를 경험했습니다. 최근 클라우드 시대에서는 2012년 전후부터 배치 처리 시스템 분야에서 Redshift, Snowflake, Clickhouse와 같은 시스템이 \"컴퓨팅 엔진\"을 \"데이터베이스\"로 돌아오게 하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n지금은 스트림 처리를 데이터베이스로 돌려보는 시기입니다. 이것이 현대 스트리밍 데이터베이스인 RisingWave와 Materialize의 주요 아이디어입니다. 그런데 왜 이 시점인 걸까요? 이 부분에서 자세히 분석해보겠습니다.\n\n20년 이상의 개발 노력을 거친 끝에, 스트림 처리는 상용적 채용이라는 측면에서 아직 초기 단계에 머물러 있습니다, 특히 배치 처리와 비교했을 때 말이죠. 그러나 산업계는 스트림 처리 방향에 대해 합의에 이르렀습니다. 스트림 처리 엔진과 스트리밍 데이터베이스 모두 스트림과 배치 처리를 지원해야 한다는 필요성에 동의합니다. 주요 차이점은 이 두 가지 다른 컴퓨팅 모델을 조화롭게 통합하는 데 있습니다. 본질적으로 “통합된 스트림과 배치 처리” 개념은 이 분야에서 공유되는 이해 관계가 되었습니다.\n\n이 통합을 달성하는 일반적인 세 가지 방법이 있습니다:\n\n- 단일 엔진 접근\n\n<div class=\"content-ad\"></div>\n\n이 전략은 스트림 처리 및 일괄 처리 기능을 관리하기 위해 동일한 컴퓨팅 엔진을 사용하는 것을 포함합니다. 이의 장점은 비교적 간단한 실행 계획과 더 통합된 사용자 경험을 제공한다는 것입니다. 그러나 스트림 처리 및 일괄 처리는 최적화 및 계산 방법과 같은 실행 측면에서 상당한 차이가 있기 때문에 각각을 구분하여 최고의 성능을 달성하기 위한 처리가 종종 필요합니다.\n\n2. 이중 엔진 접근\n\n이 접근 방식에서는 스트림 처리와 일괄 처리가 두 개의 고유한 시스템 엔진으로 별도로 구성됩니다. 각각을 특정 최적화할 수 있는 장점이 있지만, 공학 리소스의 상당한 투입, 공학 팀 내의 높은 협력 수준 및 엄격한 우선 순위 관리가 필요합니다. 양쪽을 조율하고 둘 다 원활하게 작동시키는 것이 상당한 도전이 될 수 있습니다.\n\n3. 섞여서 시스템 접근 방식\n\n<div class=\"content-ad\"></div>\n\n이 세 번째 접근 방식은 새로운 이상적인 시스템을 만드는 대신 기존 시스템을 재활용하여 통합된 사용자 경험을 제공하는 것을 포함합니다. 엔지니어링에 가장 부담이 적을 수 있는 방법으로 보이지만, 매끄러운 사용자 경험을 제공하는 것은 매우 어려울 수 있습니다. 기존 시장 시스템은 인터페이스 지원에서 다양하며 SQL을 사용하더라도 다른 방언을 사용할 수 있습니다. 이러한 불일치로부터 사용자를 보호하는 것이 핵심적인 문제가 됩니다. 게다가, 여러 시스템을 조율하여 상호 작용하고, 서로 인식하도록 유지하는 것은 복잡한 엔지니어링 과제를 도입합니다.\n\n비록 스트림 처리 엔진과 스트리밍 데이터베이스는 일부 중복과 디자인 및 실제적인 적용에서 차이가 있을 수 있지만, 둘 다 해당 배치 처리 시스템과 조화를 이루려고 노력합니다. 채택할 접근 방식을 선택하는 것은 궁극적으로 사용자의 평가에 달려 있으며, 그들의 특정 시나리오와 필요에 대한 고려를 고려합니다. 이 의사 결정 프로세스는 각 시스템의 고유한 특성과 요구 사항을 이해하고, 넓은 컴퓨팅 환경 내에 어떻게 맞는지 강조합니다.","ogImage":{"url":"/assets/img/2024-06-22-DifferencesBetweenStreamProcessingEnginesandStreamingDatabases_0.png"},"coverImage":"/assets/img/2024-06-22-DifferencesBetweenStreamProcessingEnginesandStreamingDatabases_0.png","tag":["Tech"],"readingTime":12},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-06-22-DifferencesBetweenStreamProcessingEnginesandStreamingDatabases_0.png\">\n<p>리얼타임 분석 분야에서 빠르게 발전하는 가운데, 지난 10년간 다양한 스트림 처리 엔진이 등장했습니다. 주목할 만한 예시로는 Apache Storm, Apache Flink, Apache Samza 등이 있습니다. 이러한 엔진들은 다양한 기업에서 널리 받아들여져 실시간 처리 및 분석 애플리케이션에 상당한 지원을 제공하고 있습니다.</p>\n<p>지난 몇 년 동안 새롭고 흥미로운 혁신이 등장했습니다: 스트리밍 데이터베이스. PostgreSQL 플러그인으로 개발된 초기 솔루션이었던 PipelineDB를 시작으로, 카프카를 위해 디자인된 Confluent의 KsqlDB, 그리고 최근에 등장한 오픈 소스인 RisingWave - 분산 SQL 스트리밍 데이터베이스입니다. 이러한 시스템들은 꾸준히 수용과 인기를 얻어왔습니다.</p>\n<p>그럼 스트림 처리 엔진과 스트리밍 데이터베이스를 서로 교환해서 사용할 수 있을까요? 이 기사는 각각의 설계 원칙에 대해 알아보며, 이러한 흥미로운 기술들의 차이점, 유사성, 사용 사례, 그리고 잠재적인 미래 전망을 탐구합니다.</p>\n<div class=\"content-ad\"></div>\n<h1>디자인 원칙</h1>\n<p>스트림 처리 엔진과 데이터베이스는 데이터 스트림 처리에 중요한 기능을 제공합니다. 그러나 사용자 상호 작용 인터페이스 및 데이터 저장 옵션 측면에서 디자인 원칙에서 뚜렷한 차이가 있습니다. 이러한 기술이 등장한 역사적 배경을 명확히 이해하기 위해 각각의 독특한 특성에 대해 자세히 알아보기 전에 관심을 기울여야 합니다.</p>\n<h1>스트림 처리 엔진의 진화</h1>\n<p>데이터베이스 시스템은 60년 이상의 시간 동안 연구되어 왔지만, 배치 처리 및 스트림 처리를 포괄하는 컴퓨팅 엔진은 비교적 최근의 혁신입니다. 현대 스트림 처리로의 여정은 2004년 구글의 MapReduce 논문 발표로 시작되었습니다.</p>\n<div class=\"content-ad\"></div>\n<p>MapReduce는 최고의 성능을 위해 상품용 기계 네트워크를 효율적으로 최적화하는 것을 목표로 했습니다. 이 높은 목표는 MapReduce에서 두 가지 주요 기능, Map과 Reduce,을 갖춘 세련된 저수준 프로그래밍 인터페이스의 도입으로 이어졌습니다. 이러한 설계는 유경험 프로그래머에게 핵심 기능에 직접 액세스할 수 있게 해주어 특정 비즈니스 논리를 구현하고 프로그램 병렬 처리를 제어하며 다른 복잡한 세부사항을 자체적으로 관리할 수 있도록 했습니다.</p>\n<p>MapReduce를 독특하게 만든 점은 데이터 저장을 원격 분산 파일 시스템과 같은 외부 시스템에 위임하여 처리에만 초점을 맞춘 것입니다. 이 분할은 오늘날의 스트림 처리 엔진에 영향을 주고 스트리밍 데이터베이스와의 중요한 차이점 및 시너지 파악을 위한 무대를 설정했습니다.</p>\n<p>회사 내에서 MapReduce를 성공적으로 활용하기 위해 다음 세 가지 중요 사전 조건이 필요했습니다:</p>\n<ul>\n<li>회사는 상당량의 데이터와 관련 비즈니스 시나리오를 내부에 보유해야 합니다.</li>\n<li>회사는 상품용 기계에 충분히 액세스할 수 있어야 합니다.</li>\n<li>회사는 숙련된 소프트웨어 엔지니어 집단을 고용해야 합니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>이 세 가지 조건은 맵리듀스가 2004년에 소개될 때 대부분의 기업들이 달성하기 어려웠던 벽이었습니다. 소셜 네트워크와 모바일 인터넷의 폭발적인 성장으로 2010년 이후에야 첫 번째 조건이 충족되기 시작했습니다. 이러한 변화로 주요 기업들은 스트림 처리 기술에 관심을 기울이고, 두 번째와 세 번째 전제 조건을 충족하기 위해 크게 투자했습니다. 이 투자는 2010년쯤부터 시작된 스트림 처리 엔진의 발전 시대를 의미했습니다. 이 기간 동안 Apache Storm, Apache Samza, Apache Flink 등 다수의 탁월한 스트림 처리 엔진이 등장했습니다.</p>\n<p>이 신생 스트림 처리 엔진들은 맵리듀스 디자인 패턴의 핵심 원칙을 완전히 수용했습니다. 구체적으로 다음과 같습니다:</p>\n<ul>\n<li>사용자에게 저수준 프로그래밍 인터페이스 노출;</li>\n<li>데이터 스토리지 제어 양보.</li>\n</ul>\n<p>이 디자인은 빅데이터 시대에 적합하게 개조되었습니다. 일반적으로 대량 데이터 처리를 필요로 하는 기술 기업들은 자체 데이터 센터와 전문 엔지니어링 팀을 보유했습니다. 이 기업들이 필요로 한 것은 성능 향상과 더 다채로운 프로그래밍 패러다임이었습니다. 전문 엔지니어링 팀과 함께하면 보통 분산 파일 시스템을 배포하여 방대한 데이터 스토리지를 처리할 수 있었습니다.</p>\n<div class=\"content-ad\"></div>\n<p>그러나 2015년 이후 클라우드 컴퓨팅 기술의 혁신적인 발전으로 풍경이 변화하기 시작했습니다. 기술적 배경이 부족한 기업들조차도 스트림 처리 기술에 접근하고자 했습니다. 이 수요에 대응하여 스트림 처리 엔진은 SQL을 채택해 간결하고 폭넓게 인정받는 프로그래밍 언어가 되었습니다. 이 적응으로 인해 더 많은 사용자들이 스트림 처리 기술의 혜택을 누릴 수 있게 되었습니다. 그 결과, 오늘날 주요한 스트림 처리 엔진은 사용자 상호작용에 계층적 접근 방식을 제공하며 Java와 Scala와 같은 낮은 수준의 프로그래밍 인터페이스와 더 접근성 있는 고수준의 SQL 프로그래밍 인터페이스를 제공합니다.</p>\n<h1>사용자 상호작용 인터페이스</h1>\n<p>현대의 스트림 처리 엔진은 Java와 Scala와 같은 낮은 수준의 프로그래밍 인터페이스뿐만 아니라 SQL 및 Python과 같은 고수준 인터페이스도 제공합니다. 이러한 인터페이스는 병렬성과 같은 다양한 시스템 런타임 세부 정보를 노출하여 사용자가 응용프로그램의 설령 미묘한 측면들을 제어할 수 있게 합니다. 다른 한편으로, 스트리밍 데이터베이스는 주로 SQL 인터페이스를 특징으로 하며 런타임 복잡성을 단순화합니다. 일부는 파이썬 및 자바와 같은 언어로 사용자 정의 함수(UDF)를 제공하여 표현 능력을 향상시킵니다. 이러한 사용자 상호작용 인터페이스의 다양성은 두 가지 주요 균형을 유발합니다.</p>\n<ol>\n<li>유연성과 사용 편의성 사이의 균형 유지</li>\n</ol>\n<div class=\"content-ad\"></div>\n<p>능숙한 프로그래머들은 Java와 Scala와 같은 저수준 인터페이스가 제공하는 풍부한 표현 능력을 누릴 수 있습니다. Turing-complete 언어인 Java, Scala 및 유사한 언어는 이론적으로 사용자가 어떤 로직이든 표현할 수 있도록 합니다. 기존 Java 및 Scala 라이브러리를 보유한 기업에게는 특히 유리합니다.</p>\n<p>그러나 이러한 접근법은 Java나 Scala에 익숙하지 않은 사람들을 막을 수 있으며 복잡함 때문에 시간이 많이 소요될 수 있습니다. 시스템의 사용자 정의 API를 마스터하는 것은 기술적인 사용자에게도 어려울 수 있습니다.</p>\n<p>스트리밍 데이터베이스에서 더 높은 수준의 SQL 인터페이스를 통해 사용 편의성을 강조하면 몇 가지 사용 가능한 도전 과제가 있습니다. 첫 번째는 SQL 지원의 완성도로, 단순한 DML (데이터 조작 언어) 문이 아닌 복잡한 DDL (데이터 정의 언어) 작업이 필요할 수 있습니다. 사용자들은 종종 롤, 사용자, 인덱스 생성 또는 삭제와 같은 복잡한 작업이 필요합니다. 두 번째는 SQL 생태계의 지원으로, DBeaver나 pgAdmin과 같은 관리 도구와의 호환성을 포함하여 추가 노력이 필요할 수 있습니다.</p>\n<p>저수준 인터페이스는 기술 중심 사용자에게 더 많은 유연성을 제공하며, 스트리밍 데이터베이스의 SQL 인터페이스는 비즈니스 중심 사용자를 위해 특별히 설계되어 사용 편의성을 강조합니다.</p>\n<div class=\"content-ad\"></div>\n<ol start=\"2\">\n<li>유연성과 성능의 균형</li>\n</ol>\n<p>낮은 수준의 프로그래밍 인터페이스의 가용성은 사용자가 이전 지식을 활용하여 시스템 성능을 최적화할 수 있게 합니다. 심층적인 프로그래밍 전문 지식과 비즈니스 논리 이해력을 갖춘 사람들은 종종 낮은 수준의 인터페이스를 통해 탁월한 성능을 얻을 수 있습니다. 그러나 이에는 회사가 엔지니어링 팀을 구축하기 위해 더 많은 투자를 해야 할 수도 있습니다.</p>\n<p>대조적으로, 고수준 프로그래밍 인터페이스를 사용할 때 계층적 스트림 처리 엔진은 성능 단점을 겪을 수 있습니다. 캡슐화는 성능 오버헤드를 야기하며 캡슐화 계층이 더 많을수록 성능이 더 나빠집니다. 스트림 처리 엔진의 중간 계층은 하위 디자인이 고수준 논리에 어둡게 되어 성능 손실을 야기할 수 있습니다. 비교적으로, SQL 인터페이스와 최적화 기능만을 제공하는 스트리밍 데이터베이스는 더 높은 성능 수준에 도달할 수 있습니다.</p>\n<p>요약하면, 낮은 수준의 인터페이스를 갖춘 스트림 처리 엔진은 기술 중심 사용자가 성능 이점을 얻을 수 있도록 해줍니다. 반면 SQL 인터페이스를 제공하는 스트리밍 데이터베이스는 비즈니스 중심 사용자를 위해 맞춤화되어 있으며 복잡한 기술 전문 지식이 필요 없이도 더 높은 성능 경계를 달성할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<h1>데이터 저장</h1>\n<p>사용자 상호 작용 인터페이스 외에도 스트림 처리 엔진과 스트리밍 데이터베이스 사이의 가장 중요한 차이점은 시스템이 데이터를 저장하는지 여부입니다. 스트림 처리에서 데이터 저장의 유무는 성능, 오류 복구, 확장성 및 사용 사례와 같은 시스템의 여러 측면에 직접적으로 영향을 미칩니다.</p>\n<p>스트림 처리 엔진에서 데이터 입력 및 출력은 일반적으로 HDFS와 같은 원격 분산 파일 시스템과 같은 외부 시스템에서 발생합니다. 반면, 스트리밍 데이터베이스는 계산 능력 뿐만 아니라 데이터 저장 기능도 포함하고 있습니다. 이는 적어도 두 가지 작업을 수행할 수 있다는 것을 의미합니다: 1) 입력을 저장하고, 2) 출력을 저장합니다.</p>\n<p>데이터 입력 측면에서 데이터 저장은 중요한 성능 이점을 제공합니다. 예를 들어, 데이터 입력을 저장하는 경우 성능상의 이점이 있습니다. 메시지 큐(예: Kafka)에서의 데이터 스트림과 원격 데이터베이스(예: MySQL)에 저장된 테이블을 결합하는 단순한 스트림 처리 엔진의 시나리오를 고려해 보겠습니다. 스트림 처리 엔진이 데이터 저장 기능이 없는 경우, 새로운 데이터 항목이 스트림에 들어올 때마다 연산을 수행하기 전에 원격 데이터베이스에서 데이터를 가져와야 합니다. 이 접근 방식은 초기 분산 스트림 처리 엔진에서 채택되었습니다. 시스템 아키텍처를 간단화하는 장점이 있지만, 성능이 급격히 저하된다는 단점이 있습니다. 서로 다른 시스템 간의 데이터 접근은 명백히 높은 지연 시간을 유발하며, 지연 시간에 민감한 스트림 처리 엔진에 높은 지연 작업을 도입하면 성능이 떨어지게 됩니다.</p>\n<div class=\"content-ad\"></div>\n<p>스트림 처리 시스템 내부에 데이터를 저장(또는 캐싱)하면 시스템 간 데이터 접근을 피할 수 있어 성능을 향상시킬 수 있습니다. 내장 저장 기능을 갖춘 스트림 처리 시스템인 스트리밍 데이터베이스에서는 사용자가 필요에 따라 메시지 대기열에서 데이터 스트림을 가져와 원격 데이터베이스의 테이블과 결합해야 할 때 해당 테이블을 직접 스트리밍 데이터베이스로 복제할 수 있습니다. 이렇게 하면 모든 접근이 내부 작업으로 처리되어 효율적인 처리가 가능해집니다. 물론 이것은 단순화된 예시일 뿐입니다. 실제 시나리오에서는 원격 데이터베이스의 대규모 또는 동적으로 변화하는 테이블과 같은 문제가 발생할 수 있으나 이에 대해 자세히 다루지는 않겠습니다.</p>\n<p>출력 측면에서 출력 결과를 저장하는 것은 상당한 이점을 제공할 수 있습니다. 간단히 말해 네 가지 주요 장점은 다음과 같습니다:</p>\n<ul>\n<li>데이터 스택 아키텍처를 단순화: 계산을 위해 별도의 스트림 처리 엔진과 데이터 저장 및 쿼리 응답을 위한 별도의 저장 시스템을 사용하는 대신 스트리밍 데이터베이스와 같이 단일 시스템이 계산, 저장 및 쿼리 응답을 처리할 수 있습니다. 이 방식은 데이터 스택을 크게 단순화하고 종종 비용 절감을 이루어냅니다.</li>\n<li>계산 리소스 공유 용이: 스트림 처리 엔진에서는 계산 결과가 입력 데이터를 사용하고 계산을 수행한 후 외부 시스템으로 내보내기 때문에 그 결과를 시스템 내에서 직접 재사용하기가 어렵습니다. 내장 저장 기능을 갖춘 스트리밍 데이터베이스는 계산 결과를 내부적으로 머티얼라이징된 뷰로 저장해 다른 계산이 이 리소스에 직접 액세스하고 재사용할 수 있게 해줍니다.</li>\n<li>데이터 일관성 보장: 스트림 처리 엔진은 처리에 대한 정확히 한 번 문맥을 보장할 수 있지만 결과 액세스 일관성을 보장할 수는 없습니다. 스트림 처리 엔진은 저장소가 없기 때문에 계산 결과를 하류 저장 시스템으로 가져와야 합니다. 상류 엔진은 결과의 버전 정보를 하류 시스템으로 출력하여 하류 시스템의 사용자에게 보여지는 일관된 결과를 얻도록 해야 합니다. 이는 일관성 보장 부담을 사용자에게 지우게 됩니다. 반면, 저장 기능을 갖춘 스트리밍 데이터베이스는 시스템 내에 계산 진행 상태와 결과 버전 정보를 관리하여 사용자가 다중 버전 컨트롤을 통해 항상 일관된 결과를 보게끔 해줍니다.</li>\n<li>프로그램 해석 용이성 향상: 프로그램 개발 중에는 반복적인 수정과 정확성 검증이 흔합니다. 정확성을 검증하는 공통 접근 방법은 입력 및 출력을 얻어와 계산 논리가 기대에 부응하는지 수동으로 검증하는 것입니다. 이 작업은 배치 처리 엔진에서는 비교적 간단하지만 스트림 처리 엔진에서는 더 복잡합니다. 스트림 처리 엔진에서는 입력 및 출력이 동적으로 변하기 때문에 엔진이 저장소가 없고 정확성을 검증하기 위해 상류 메시지 소스, 하류 결과 저장 시스템 및 스트림 처리 엔진을 횡단해야 합니다. 게다가 사용자는 계산 진행 정보를 인식해야 해 복잡한 작업이 됩니다. 이에 비해 스트리밍 데이터베이스에서는 계산 결과가 데이터베이스 내에 저장되므로 상류 시스템에서 입력을 얻은 후(일반적으로 Kafka와 같은 메시지 대기열로 직접 오프셋을 가져오는 방식) 단일 시스템 내에서 결과를 검증하기만 하면 됩니다. 이는 개발 효율을 크게 향상시킵니다.</li>\n</ul>\n<p>물론 공짜 점심은 없으며 소프트웨어 개발은 단순해 보이는 해결책을 제공하지 않습니다. 스트림 처리 엔진과 비교했을 때 저장 기능을 갖춘 스트리밍 데이터베이스는 아키텍처, 리소스 활용, 일관성 및 사용자 경험에서 많은 장점을 제공합니다. 하지만 그에 따라 어떤 것을 희생해야 할까요?</p>\n<div class=\"content-ad\"></div>\n<p>한 가지 중요한 희생은 소프트웨어 설계의 복잡성입니다. MapReduce의 설계를 기억해보세요. MapReduce의 개념은 오라클과 IBM과 같은 거대 기업이 전체 데이터베이스 시장을 지배하던 시절에 뛰어났습니다. 왜냐하면 이들은 많은 보통 컴퓨터를 사용하는 기술 기업을 위해 대규모 병렬 컴퓨팅을 가능케 하는 간단한 모델을 효과적으로 활용했기 때문입니다.</p>\n<p>MapReduce는 데이터베이스의 저장 및 연산 통합 개념을 직접 역전시켰으며, 연산을 독립적인 제품으로 분리했습니다. 이를 통해 사용자는 프로그래밍을 통해 연산을 확장할 수 있게 되었습니다. 다시 말해, MapReduce는 간소화된 아키텍처를 통해 대규모 수평 스케일링을 실현했으며, 높은 수준의 전문 기술 사용자의 유능성에 의존했습니다.</p>\n<p>그러나 시스템이 데이터 저장을 필요로 하는 경우, 모든 것이 더욱 복잡해집니다. 그러한 시스템을 사용 가능하게 만들기 위해 개발자는 고가용성, 장애 복구, 동적 스케일링, 데이터 일치성 및 기타 다양한 도전에 대한 섬세한 설계와 구현을 고려해야 합니다. 다행히도 지난 10년 동안 대규모 데이터베이스와 스트림 처리의 이론과 실무가 크게 발전해왔습니다. 따라서 지금은 스트리밍 데이터베이스의 등장에 이상적인 시기라고 할 수 있습니다.</p>\n<h1>활용 사례</h1>\n<div class=\"content-ad\"></div>\n<p>계산 모델에서 유사성을 공유하고 있지만, 스트리밍 처리 엔진과 스트리밍 데이터베이스는 여전히 고유한 응용 및 기능으로 이어지는 세세한 점들이 있습니다. 이러한 기술들은 응용 분야에서 중첩되어 있지만, 최종 사용자의 초점에서 차이가 나타납니다.</p>\n<p>스트림 처리 엔진은 일반적으로 기계 중심의 작업과 더 일치하며 데이터 저장 기능이 부족하며 종종 계산 결과 소비를 위해 하류 시스템과 통합이 필요합니다. 반면에, 스트리밍 데이터베이스는 더 많은 인간 상호 작용을 고려하여 저장 및 임의 쿼리 지원을 제공함으로써 직접적인 인간 참여를 가능하게 합니다.</p>\n<p>기계와 인간 사이의 이분법은 기계가 하드코딩된 프로그램의 고성능 처리를 요구하면서, 인간은 더 인터랙티브하고 사용자 친화적인 경험을 선호한다는 것을 보여줍니다. 이 본질적인 이견으로 인해 스트림 처리 엔진과 스트리밍 데이터베이스 간의 기능, 사용자 경험 및 기타 측면에서 차이가 생깁니다.</p>\n<p>요약하면, 이러한 기술들 간의 응용 시나리오에서의 공통점은 최종 사용자와 상호 작용 모드에 특정 초점이 있어 각 시스템 내에서 독특한 기능을 결과로 낳습니다.</p>\n<div class=\"content-ad\"></div>\n<h1>역사적 차원으로 나아가는 거담아, 아니면 현재 시대의 트렌드일까요?</h1>\n<p>데이터베이스와 컴퓨팅 엔진은 종종 서로 다른 두 가지 설계 철학을 반영합니다. 그것들은 독특한 학계 기여와 산업 발전을 통해 명백히 입증됩니다.</p>\n<p>학계에서는 컴퓨팅 엔진 논문들이 주로 OSDI, SOSP, EuroSys와 같은 시스템 회의에서 발표되는 반면, 데이터베이스 중심 작업들은 주로 SIGMOD 및 VLDB 회의에서 자주 볼 수 있습니다. 이 분할은 2008년 David DeWitt와 Michael Stonebraker에 의한 \"MapReduce: 역사적인 큰 걸음\" 비평에 의해 유명하게 강조되었습니다. 그들은 MapReduce가 역사적으로 후퇴적이고 데이터베이스에 비해 더 많은 혁신이 필요하다고 주장했습니다.</p>\n<p>스트림 처리의 영역에서, 다음 질문이 등장합니다: 어떤 철학이 역사적으로 후퇴를 대표하고, 어떤 것이 현재 시대의 트렌드를 대변할까요? 저는 스트림 처리 엔진과 스트리밍 데이터베이스가 앞으로 최소 3~5년 동안 공존하고 계속 발전할 것으로 판단합니다.</p>\n<div class=\"content-ad\"></div>\n<p>스트림 처리 엔진은 극한의 성능과 유연성에 중점을 둬 기술적으로 뛰어난 사용자들을 대상으로 합니다. 한편, 스트리밍 데이터베이스는 사용자 경험의 우아함과 높은 성능 그리고 섬세한 내부 구현을 균형있게 갖추고 있습니다. 이러한 철학 간 상호 통합 트렌드는 SQL 인터페이스를 도입해 사용자 경험을 향상시키는 컴퓨팅 엔진과 UDF 기능을 활용해 프로그래밍 적응성을 높이는 데이터베이스 등 양쪽을 모두 강화시킵니다.</p>\n<h1>스트림 처리의 미래 예측</h1>\n<p>역사를 살펴보면, 스트리밍 데이터베이스 개념은 20년 전에 이미 제안되고 구현되었습니다. 예를 들어, 앞서 언급된 Aurora 시스템은 이미 스트리밍 데이터베이스입니다. 그러나 스트리밍 데이터베이스는 스트림 처리 시스템만큼 인기가 없습니다. 역사는 나선형 패턴으로 진행됩니다.</p>\n<p>빅 데이터 시대는 스트림 처리와 데이터베이스를 분리하고 오라클, IBM, Microsoft와 같은 세 거인의 독점을 무너뜨리는 트렌드를 경험했습니다. 최근 클라우드 시대에서는 2012년 전후부터 배치 처리 시스템 분야에서 Redshift, Snowflake, Clickhouse와 같은 시스템이 \"컴퓨팅 엔진\"을 \"데이터베이스\"로 돌아오게 하고 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>지금은 스트림 처리를 데이터베이스로 돌려보는 시기입니다. 이것이 현대 스트리밍 데이터베이스인 RisingWave와 Materialize의 주요 아이디어입니다. 그런데 왜 이 시점인 걸까요? 이 부분에서 자세히 분석해보겠습니다.</p>\n<p>20년 이상의 개발 노력을 거친 끝에, 스트림 처리는 상용적 채용이라는 측면에서 아직 초기 단계에 머물러 있습니다, 특히 배치 처리와 비교했을 때 말이죠. 그러나 산업계는 스트림 처리 방향에 대해 합의에 이르렀습니다. 스트림 처리 엔진과 스트리밍 데이터베이스 모두 스트림과 배치 처리를 지원해야 한다는 필요성에 동의합니다. 주요 차이점은 이 두 가지 다른 컴퓨팅 모델을 조화롭게 통합하는 데 있습니다. 본질적으로 “통합된 스트림과 배치 처리” 개념은 이 분야에서 공유되는 이해 관계가 되었습니다.</p>\n<p>이 통합을 달성하는 일반적인 세 가지 방법이 있습니다:</p>\n<ul>\n<li>단일 엔진 접근</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>이 전략은 스트림 처리 및 일괄 처리 기능을 관리하기 위해 동일한 컴퓨팅 엔진을 사용하는 것을 포함합니다. 이의 장점은 비교적 간단한 실행 계획과 더 통합된 사용자 경험을 제공한다는 것입니다. 그러나 스트림 처리 및 일괄 처리는 최적화 및 계산 방법과 같은 실행 측면에서 상당한 차이가 있기 때문에 각각을 구분하여 최고의 성능을 달성하기 위한 처리가 종종 필요합니다.</p>\n<ol start=\"2\">\n<li>이중 엔진 접근</li>\n</ol>\n<p>이 접근 방식에서는 스트림 처리와 일괄 처리가 두 개의 고유한 시스템 엔진으로 별도로 구성됩니다. 각각을 특정 최적화할 수 있는 장점이 있지만, 공학 리소스의 상당한 투입, 공학 팀 내의 높은 협력 수준 및 엄격한 우선 순위 관리가 필요합니다. 양쪽을 조율하고 둘 다 원활하게 작동시키는 것이 상당한 도전이 될 수 있습니다.</p>\n<ol start=\"3\">\n<li>섞여서 시스템 접근 방식</li>\n</ol>\n<div class=\"content-ad\"></div>\n<p>이 세 번째 접근 방식은 새로운 이상적인 시스템을 만드는 대신 기존 시스템을 재활용하여 통합된 사용자 경험을 제공하는 것을 포함합니다. 엔지니어링에 가장 부담이 적을 수 있는 방법으로 보이지만, 매끄러운 사용자 경험을 제공하는 것은 매우 어려울 수 있습니다. 기존 시장 시스템은 인터페이스 지원에서 다양하며 SQL을 사용하더라도 다른 방언을 사용할 수 있습니다. 이러한 불일치로부터 사용자를 보호하는 것이 핵심적인 문제가 됩니다. 게다가, 여러 시스템을 조율하여 상호 작용하고, 서로 인식하도록 유지하는 것은 복잡한 엔지니어링 과제를 도입합니다.</p>\n<p>비록 스트림 처리 엔진과 스트리밍 데이터베이스는 일부 중복과 디자인 및 실제적인 적용에서 차이가 있을 수 있지만, 둘 다 해당 배치 처리 시스템과 조화를 이루려고 노력합니다. 채택할 접근 방식을 선택하는 것은 궁극적으로 사용자의 평가에 달려 있으며, 그들의 특정 시나리오와 필요에 대한 고려를 고려합니다. 이 의사 결정 프로세스는 각 시스템의 고유한 특성과 요구 사항을 이해하고, 넓은 컴퓨팅 환경 내에 어떻게 맞는지 강조합니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}