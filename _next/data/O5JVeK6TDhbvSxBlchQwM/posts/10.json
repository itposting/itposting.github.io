{"pageProps":{"posts":[{"title":"윈도우 포렌식 여정 - LastUsedUsername 시스템에 마지막으로 로그인한 사용자의 사용자 이름","description":"","date":"2024-05-27 12:38","slug":"2024-05-27-TheWindowsForensicJourneyLastUsedUsernameUsernameoftheLastLoggedOnUsertotheSystem","content":"\n\n\"LastUsedUsername\"은 레지스트리에서 값 이름으로, 시스템에 마지막으로 로그인한 사용자의 사용자 이름을 저장합니다. 레지스트리 내에서의 전체 위치는 \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\"입니다. 이 정보가 시스템 전체에 대해 전역적이므로 HKLM 하이브의 일부입니다 — 아래 스크린샷에 표시된 것처럼.\n\n따라서 우리는 시스템에 마지막으로 로그인한 사용자를 알기 위해 이 값을 읽을 수 있습니다 (관련된 이벤트 로그 항목이 삭제되었더라도). 또한 사용자 프로필 디렉토리의 폴더의 MAC (수정/액세스/생성) 시간과 연관시킬 수 있습니다.\n\n마지막으로, 우리는 라이브 머신을 조사하거나 오프라인 SYSTEM 하이브 또는 원격 머신(원격 레지스트리 서비스가 실행 중이고 SMB/MS-RPC를 사용하여 접근 가능한 경우)에서 이 정보에 접근할 수 있습니다. 다음 글에서 만나요. :-) 트위터에서 제 소식을 확인하실 수 있습니다 — @boutnaru(https://twitter.com/boutnaru). 또한, 중간 — https://medium.com/@boutnaru에서 다른 글을 읽을 수 있습니다. 무료 eBook은 https://TheLearningJourneyEbooks.com에서 확인하실 수 있습니다.\"","ogImage":{"url":"/assets/img/2024-05-27-TheWindowsForensicJourneyLastUsedUsernameUsernameoftheLastLoggedOnUsertotheSystem_0.png"},"coverImage":"/assets/img/2024-05-27-TheWindowsForensicJourneyLastUsedUsernameUsernameoftheLastLoggedOnUsertotheSystem_0.png","tag":["Tech"],"readingTime":1},{"title":"사이버렌즈 - TryHackMe 후기","description":"","date":"2024-05-27 12:37","slug":"2024-05-27-CyberLens-TryHackMeWriteup","content":"\n\n![이미지](/assets/img/2024-05-27-CyberLens-TryHackMeWriteup_0.png)\n\n이 방은 Windows 해킹 및 웹 애플리케이션 취약점을 알려드립니다. 그럼, 바로 시작해봅시다 🥂.\n\n방 링크: https://tryhackme.com/r/room/cyberlensp6\n\n참고: 이 문서는 꽤 직관적이며 현실적으로 마주치게 될 많은 막다른 곳을 건너뛰고 있습니다. 시간이 오래 걸리거나 윤리적 해킹에 완전히 새로운 경우에만 사용하는 것이 좋습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![사진](/assets/img/2024-05-27-CyberLens-TryHackMeWriteup_1.png)\n\n# 해결 방법\n\n## 열거\n\nnmap 스캔을 시작하기 전에 방 노트에 표시된 대로 호스트 파일에 cyberlens.thm 항목을 추가해야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n약 5분 후, 다음과 같은 전체 포트 nmap 스캔을 실행해 주세요:\n\n```js\nnmap -sV -T5 -Pn -p- -oN ./nmap_scan <IP> -vv\n```\n\n이는 서비스 버전을 확인하는 비교적 빠른 TCP 스캔이며 결과를 나중에 확인할 수 있도록 저장하며 상세합니다.\n\n포트 80의 웹 서버를 조사하려면 브라우저를 열고 해당 웹 사이트로 이동하세요. 다음과 같은 내용을 볼 수 있어야 합니다:\n\n<div class=\"content-ad\"></div>\n\n사이트를 둘러보다 보면 '사이버렌즈 이미지 추출기'를 찾을 수 있어요. 이 기능을 테스트하면 이미지를 가져와 메타데이터를 보여줍니다. 페이지 소스를 보면 모든 마법이 일어나는 JavaScript를 볼 수 있어요.\n\n사이트를 둘러보다 보면 '사이버렌즈 이미지 추출기'를 찾을 수 있어요. 이 기능을 테스트하면 이미지를 가져와 메타데이터를 보여줍니다. 페이지 소스를 보면 모든 마법이 일어나는 JavaScript를 볼 수 있어요.\n\n추출기는 작업을 수행하기 위해 다른 포트와 통신하는 것으로 보입니다. 브라우저에서 조금 더 자세히 살펴보자고요.\n\n<div class=\"content-ad\"></div>\n\nhttp://cyberlens.thm:61777에 Apache Tika 1.17이 실행 중인 것을 확인할 수 있어요.\n\n![이미지](/assets/img/2024-05-27-CyberLens-TryHackMeWriteup_4.png)\n\nMetasploit에서 Apache Tika를 검색하면 Apache Tika Header Command Injection이라는 모듈이 나올 거에요. 서버를 공격해 봅시다.\n\n## 공격\n\n<div class=\"content-ad\"></div>\n\nMetasploit을 열고 위의 Apache Tika 모듈을 검색해보세요. RHOSTS, RPORT, SRVHOST, 그리고 LHOST를 설정해야 합니다 (마지막 두 개에는 OpenVPN 또는 Attackbox IP를 사용하세요).\n\nExploit을 실행하면 셸을 얻을 수 있습니다. C:\\Users\\CyberLens\\Desktop로 이동해보세요. 거기에 유저 플래그가 있을 거에요 🚩.\n\n![이미지](/assets/img/2024-05-27-CyberLens-TryHackMeWriteup_5.png)\n\n## 권한 상슨\n\n<div class=\"content-ad\"></div>\n\n세션을 백그라운드로 전환하고 Multi Recon Local Exploit Suggester 모듈을 검색해보세요. 이 모듈은 관리자 권한을 얻기 위한 일부 로컬 익스플로잇을 제공할 것입니다. SESSION을 설정한 다음 실행하세요.\n\n![이미지](/assets/img/2024-05-27-CyberLens-TryHackMeWriteup_6.png)\n\n첫 번째 제안을 선택하여 always_install_elevated 모듈을 사용하세요. SESSION 및 LHOST 옵션을 구성하는 것을 잊지 마세요. 그러면 익스플로잇을 진행할 수 있을 겁니다.\n\n![이미지](/assets/img/2024-05-27-CyberLens-TryHackMeWriteup_7.png)\n\n<div class=\"content-ad\"></div>\n\n지금은 관리자 권한을 갖고 있습니다. 이를 확인하려면 쉘을 열고 whoami를 입력하세요.\n\n![이미지](/assets/img/2024-05-27-CyberLens-TryHackMeWriteup_8.png)\n\n관리자 권한 플래그를 얻으려면 C:\\Users\\Administrator\\Desktop로 이동하세요 🚩. 마무리할 때 /etc/hosts 파일에서 CyberLens 항목을 제거하는 것을 잊지 마세요.\n\n![이미지](/assets/img/2024-05-27-CyberLens-TryHackMeWriteup_9.png)\n\n<div class=\"content-ad\"></div>\n\n실제로는 모든 것이 이렇게 쉽지 않을 수도 있습니다. 중요한 건 인내심이에요. 실제로 처음으로 시도했을 때의 개인 노트입니다 📝:\n\n```js\nName: CyberLens\nDescription: CyberLens 웹 서버를 공격하고 숨겨진 플래그를 발견할 수 있을까요?\n\n참고: 아마도 Windows 기기일 것으로 예상됩니다.\n\n[+] 절차:\n - 서버에 기본, 전체 및 udp 스캔을 실행했습니다.\n - 포트 80에서 nikto 스캔 실행\n - 웹사이트 살펴보기\n - /about.html에 메타데이터를 추출하는 이미지 추출기가 있는 것 같습니다.\n - /contact.html에 양식이 있습니다.\n - 이미지 추출기가 정적인 것 같습니다. 브루스위트를 사용해 사이트 살펴보기 시도\n - 그 전에 apache 버전에 대한 취약점을 찾아보기\n - 취약점을 찾지 못했습니다\n - 브루스위트를 열어 살펴봄\n - 소스 코드를 살펴보니 도메인 이름 cyberlens.thm을 발견했습니다. /etc/hosts 파일에 추가를 잊지 않았어야 했는데\n - 이제 추출기가 작동 중입니다. 파일 업로드 취약점에 취약할 수 있음\n - 사이버렌즈 /aboutus 안의 사진을 사용해보려고 합니다. 무언가 흥미로운 것이 있을지 모르겠죠?\n - 이건 왜 이렇게 많은 정보가 있죠?\n - 페이지 소스를 살펴보면 61777 포트를 통해 파일이 서버로 전송되고 해당 파일에 대한 메타데이터를 반환한다는 것을 알 수 있습니다. 이것을 악용할 수 있을까요?\n - Nikto는 /css, /images 디렉토리를 발견했습니다\n - 이 두 디렉토리에는 흥미로운 것이 없었습니다\n - 숨겨진 디렉토리를 찾기 위해 gobuster 사용\n - 그 과정 동안 다른 포트를 확인해보고 있습니다\n - 기다리세요. 전체 스캔을 살펴보니 61777 포트에서 실행되는 서비스를 발견했습니다 - Jetty 8.y.z-SNAPSHOT\n - Port 139를 열거하는 데 metasploit 사용\n - 로컬 smb 열거를 통해 사용자를 찾으려 했지만 아무 것도 발견되지 않았습니다\n - 해당 61777 포트를 다시 살펴봄\n - 61777 포트는 PUT 메서드를 사용하기 때문에 웹 서버인 것으로 보입니다\n - Apache Tika 1.17 서버를 발견했습니다. 취약점을 찾아봄\n - 취약점을 찾았습니다. 실행을 시도해봅니다\n - '들어왔어요'\n - 플래그를 찾기\n - 관리자 액세스를 얻기 위해 열거하는 중이지만 여기서는 경험이 없습니다. 구글을 시도해보고 있습니다\n - multi/recon/local_exploit_suggester 모듈을 사용해보려고 합니다\n - 매우 유용했고 5가지 취약점을 제공했습니다\n - 첫 번째 것을 사용해보려고 합니다\n - 작동했습니다\n - C:/User/Administrator/Desktop에 플래그를 찾는 중입니다\n\n[+] 가능한 벡터:\n - Apache 2.4.57 (Win 64) - 취약점을 발견하지 못했습니다\n - /about.html\n - /contact.html - 가능한 XSS\n - cyberlens 사이트 이미지의 메타데이터\n - Jetty 8.y.z-SNAPSHOT - 가능한 디렉터리 탐색\n - 135 포트로 RCE 가능성 - 자격 증명 필요\n - SMB 3.1.1 발견\n - Apache Tika 1.17\n```\n\n이 글이 마음에 드신다면 박수와 팔로우, 친구들과 공유하는 것을 잊지 마세요. 다른 글도 읽어보거나 Twitter/X에서 제 다른 글을 팔로우하셔서 사이버 보안 팁, 트릭 및 정보를 더 받아보세요.\n\n그리고 항상 말씀드리는 대로, Happy Hacking 🙃.\n","ogImage":{"url":"/assets/img/2024-05-27-CyberLens-TryHackMeWriteup_0.png"},"coverImage":"/assets/img/2024-05-27-CyberLens-TryHackMeWriteup_0.png","tag":["Tech"],"readingTime":5},{"title":"윈도우에서 UEFI 프로그래밍을 위한 히치하이커 안내서","description":"","date":"2024-05-27 12:32","slug":"2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows","content":"\n## 왕밍재는 Secure Boot가 활성화된 실제 시스템에 개발한 UEFI 프로그램의 전체 과정을 설명합니다. 그의 안내로 엔지니어들은 UEFI 환경의 다양한 요소를 이해하고 UEFI 프로그램의 실행과 배포에 미치는 영향을 파악할 수 있습니다. 민재는 다양한 실용적 고려 사항을 포함하여 독자들이 다양한 배포 옵션을 평가하는 데 도움을 줍니다.\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_0.png)\n\n# 소개\n\nUEFI (통합 확장 펌웨어 인터페이스) 개발은 대부분 EDK II (EFI 개발 키트 II) 리포를 사용하여 수행됩니다. EFI는 원래 BIOS를 대체하기 위해 Intel 내에서 시작된 프로젝트였습니다. 노력은 1998년 Tiano 프로젝트 내에서 시작되었으며 규격과 이를 구현하는 펌웨어로 이루어져 있습니다. 2004년, Intel은 EFI 펌웨어의 기본 코드를 오픈 소스로 공개했습니다. 2005년, 컴퓨터 산업의 주요 업체들이 UEFI 포럼을 결성하여 특정 규격을 소유하게 되었으며 2006년에 UEFI 2.0 규격을 발표했습니다. 이후 오픈 소스 코드는 EDK로 발전하고 마침내 오늘날의 EDK II로 이어졌습니다. 개발자 커뮤니티인 TianoCore는 GitHub에서 소스 코드를 유지보수합니다.\n\n<div class=\"content-ad\"></div>\n\nWindows에서 UEFI 개발은 예전에는 복잡한 프로세스였습니다. 많은 수동 단계가 필요했죠. UEFI는 사용자 지정 빌드 도구 체인을 구현하며 IDE를 통한 개발을 지원하지 않습니다. 온라인에서 다양한 안내서를 찾을 수 있고 컨테이너를 사용하여 빌드 프로세스가 개선되었지만, 여전히 IDE의 편리함에는 미치지 못합니다. 게다가 UEFI 실행 파일을 설치/배포하는 방법에 대한 충분한 자료가 없으며, Secure Boot를 활성화한 상태에서 실행시키는 방법에 대한 정보는 더 드물죠.\n\n그래서 이 안내서는 이러한 공백을 메우고 UEFI 실행 파일을 배포하려는 사람들에게 도움이 되기를 희망합니다. 개인적인 용도든 제품 환경에서든 UEFI 실행 파일을 배포하려는 분들에게 도움이 될 것입니다.\n\n이 안내서를 읽는 독자들은 다음을 기본적으로 이해하고 있을 것으로 예상됩니다:\n\n- UEFI가 무엇인지\n- C 프로그래밍 언어\n- Visual Studio IDE\n\n<div class=\"content-ad\"></div>\n\n## 설치 및 빌드\n\n이전에 언급된 개발 도전에 직면하던 중, Windows Internals 저자 중 한 명인 Alex Ionescu는 VisualUefi를 만들어 EDK II의 소스 코드를 Visual Studio 솔루션으로 래핑하였습니다. IDE 내에서 빌드가 이루어지며, EDK II의 사용자 정의 빌드 툴 체인을 완전히 우회합니다. 사용자의 UEFI 실행 파일을 개발하기 위해서는 두 번째 솔루션을 사용합니다.\n\nVisualUefi 저장소의 지침에 따라 진행하세요.\n\n## 실행\n\n<div class=\"content-ad\"></div>\n\nUEFI 실행 파일은 OS에서 직접 실행되지 않고 OS 부팅 전에 있는 UEFI 환경에서만 실행될 수 있습니다. 따라서 VisualUEFI는 QEMU와 EDK II의 OVMF (Open Virtual Machine Firmware) 모듈을 사용하여 펌웨어 실행 환경을 에뮬레이트합니다. VisualUEFI는 UEFI 실행 파일이 일반적인 명령행 실행 파일과 거의 동일하게 실행될 수 있도록 QEMU와 OVMF를 통합합니다.\n\n## EFI 셸에서 실행하기\n\n이 섹션은 VisualUEFI의 단계와 동일하며 스크린샷이 추가되었습니다.\n\n샘플 솔루션에서 Ctrl+F5를 눌러 QEMU를 실행하세요. 이렇게 하면 EFI 셸로 직접 부팅되며 여기서 샘플 UEFI 실행 파일을 실행할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Screenshot 1](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_1.png)\n\nF5를 사용해도 되지만, 이 방법은 Visual Studio 디버거를 시작하는데 이 경우에는 QEMU 또는 UEFI 실행 파일에 연결할 수 없기 때문에 쓸모가 없습니다.\n\n해결책의 빌드 출력 디렉토리 VisualUefi\\samples\\x64\\Release\\은 가상 볼륨으로 fs1:라는 레이블 아래로 탑재됩니다. 이 디렉토리의 내용을 나열하면 Windows에서 볼 수 있는 것과 동일한 파일과 폴더가 표시됩니다:\n\n![Screenshot 2](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n첫째로, UefiDriver.efi를 로드해주세요:\n\n`![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_3.png)`\n\n드라이버가 로드되었는지 확인하려면 devtree -b 명령을 사용하세요. -b 플래그는 출력을 한 번에 한 화면씩 표시합니다. 로딩 전후의 출력을 비교해보세요:\n\n동일한 방식으로 drivers 명령어를 사용할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n어플리케이션을 실행하세요:\n\n![application](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_4.png)\n\n## 새 부팅 옵션에서 실행하기 — 어플리케이션 설치\n\n큐뮤를 실행한 후, 펌웨어 메뉴로 진입할 때까지 Esc 키를 누른 채로 유지하세요. 또는 EFI 셸에서 exit 명령을 입력하여 펌웨어 메뉴로 나갈 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Boot Maintenance Manager](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_5.png)\n\nSelect Boot Options.\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_7.png)\n\nSelect Add Boot Option.\n\n![image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_8.png)\n\nSelect the first option.\n\n\n<div class=\"content-ad\"></div>\n\n\n![image 1](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_9.png)\n\nSelect UefiApplication.efi.\n\n![image 2](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_10.png)\n\nEnter any description; this will be the display name of the new boot option. The Optional Data field specifies the arguments that are passed to the UEFI executable. Leave it blank as the sample application does not use it.\n\n\n<div class=\"content-ad\"></div>\n\n변경 사항을 저장하고 펌웨어 메뉴 페이지로 돌아가세요. 부트 매니저 옵션을 선택하세요:\n\n![부트 매니저](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_11.png)\n\n새로 추가된 부팅 옵션이 마지막 항목으로 표시됩니다. 실행하려면 그냥 선택하면 됩니다. 응용 프로그램이 종료되면 사용자는 즉시 펌웨어 메뉴로 돌아가며 출력은 빠르게 지나갑니다. 출력을 유지하려면 응용 프로그램의 코드를 변경해야 합니다.\n\n사용자가 키를 눌러야 응용 프로그램이 돌아올 때까지 기다리도록 하는 방법이 있습니다. 이는 edk2\\MdeModulePkg\\Library\\CustomizedDisplayLib\\CustomizedDisplayLibInternal.c의 WaitForKeyStroke 함수를 사용하여 달성할 수 있습니다. 그러나 EDK-II 솔루션에 이 라이브러리가 포함되어 있지 않아 사용할 수 없습니다. Visual Studio 프로젝트를 만들어 새 라이브러리를 빌드하는 것은 본 안내서의 범위를 넘어서므로 지금은 응용 프로그램에 코드를 복제하는 것만으로 충분합니다.\n\n<div class=\"content-ad\"></div>\n\n\nEFI_STATUS\nWaitForKeyStroke(\n    OUT  EFI_INPUT_KEY* Key\n)\n{\n    EFI_STATUS  Status;\n    UINTN       Index;\n    while (TRUE) {\n        Status = gST->ConIn->ReadKeyStroke(gST->ConIn, Key);\n        if (!EFI_ERROR(Status)) {\n            break;\n        }\n        if (Status != EFI_NOT_READY) {\n            continue;\n        }\n        gBS->WaitForEvent(1, &gST->ConIn->WaitForKey, &Index);\n    }\n    return Status;\n}\n\n\n호출하는 코드:\n\n\nPrint(L\"Press any key to continue...\\n\");\nEFI_INPUT_KEY keyInput;\nefiStatus = WaitForKeyStroke(&keyInput);\nif (EFI_ERROR(efiStatus))\n{\n    Print(L\"Failed to get keystroke: %lx\\n\", efiStatus);\n    goto Exit;\n}\n\n\n주의할 점: 샘플 응용 프로그램의 코드에 3가지 문제가 있습니다:\n\n\n\n<div class=\"content-ad\"></div>\n\n- 94번 라인:\n\n```js\nefiStatus = ShellInitialize();\n```\n\n이 코드는 EFI 셸에서만 작동합니다. 셸 대신에 우리 애플리케이션을 먼저 실행하고 있기 때문에 ShellInitialize() 호출이 실패할 것입니다.\n\n- 104번 라인:\n\n<div class=\"content-ad\"></div>\n\n\n```js\nefiStatus = ShellOpenFileByName(L\"fs1:\\\\UefiApplication.efi\",\n```\n\n볼륨 레이블 fs1:이 항상 사용 가능하고 실행 파일이 항상 거기에 저장되어 있다고 가정합니다. 그러나 볼륨 레이블을 할당하는 것은 EFI 셸의 역할이므로 EFI 셸이 없으면 fs1:이 없어지고 ShellOpenFileByName()은 실패할 것입니다.\n\n- 134번째 줄:\n\n```js\nefiStatus = gBS->LocateProtocol(&gEfiSampleDriverProtocolGuid, NULL, &sampleProtocol);\n```\n\n\n\n<div class=\"content-ad\"></div>\n\n샘플 드라이버에 액세스하려고 시도되었지만, 아직 드라이버를 설치하지 않았기 때문에 이 작업도 실패합니다.\n\n코드는 항상 실패 시에 항상 \"Exit;\"으로 이동하므로 사용자의 키 입력을 읽는 코드를 제일 위에 삽입해야 실행이 보장됩니다.\n\n부트 매니저 UI를 항상 입력해야 하는 것을 피하기 위해 부팅 순서를 EFI 셸 대신 새로운 옵션을 먼저 부팅하도록 변경할 수 있습니다. 그러려면, Boot Maintenance Manager ` Boot Options ` Change Boot Order로 이동하십시오:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_12.png)\n\n<div class=\"content-ad\"></div>\n\n이 경우에는 애플리케이션이 펌웨어 메뉴 대신 EFI 셸로 종료됩니다. 부팅할 때 부팅 옵션이 EFI_SUCCESS를 반환하면 제어가 펌웨어 메뉴로 돌아가고, 그렇지 않으면 다음 부팅 옵션이 실행되며, 모든 부팅 옵션이 시도될 때까지 EFI_SUCCESS를 반환하거나 모든 부팅 옵션이 소진됩니다(UFI 사양서 섹션 3.1.1 참조). 위에서 언급한 3가지 문제로 인해 애플리케이션은 EFI_SUCCESS를 반환하지 않으므로 펌웨어는 다음 옵션인 UEFI 셸을 실행합니다.\n\n위의 부팅 옵션 처리에 대한 예외 사항은 애플리케이션이 ExitBootServices()를 호출하는 경우에 있습니다. 그러나 이 내용은 이 안내서의 범위를 벗어납니다.\n\n## 새 부팅 옵션에서 실행 - 드라이버 설치\n\n부팅 유지 관리자 페이지에서 드라이버 옵션을 선택하세요:\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_13.png)\n\nAdd Driver 옵션을 선택하세요.\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_14.png)\n\n파일을 사용하여 Add Driver 옵션을 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n\n\n![image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_15.png)\n\nSelect the first option.\n\n![image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_16.png)\n\nSelect UefiDriver.efi.\n\n\n\n<div class=\"content-ad\"></div>\n\n\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_17.png)\n\n어떤 설명을 입력하세요; 이는 새 드라이버 옵션의 표시 이름이 될 것입니다. 옵션 데이터 필드는 UEFI 실행 파일에 전달되는 인수를 지정합니다. 샘플 드라이버가 사용하지 않기 때문에 비워 두세요.\n\n로드 옵션 Reconnect 필드는 펌웨어 부팅 관리자 실행 전에로드된 모든 드라이버를 무시하도록 드라이버에게 허용합니다 (UEFI 사양 섹션 3.1.3 참조). devtree 및 drivers 명령의 출력을 상기하세요 - 샘플 드라이버를 제외한 모든 항목은 펌웨어와 함께 제공된 드라이버이며 펌웨어 부팅 관리자 실행 전에 로드되었습니다. 호환성 문제가 발생할 수 있으므로 장치는 하나의 드라이버로 관리되어야 합니다. 샘플 드라이버는 기존 드라이버를 무시하지 않으므로 옵션을 활성화하는 것은 필요하지 않으며 순수한 효과가 없을 것입니다. 이 페이지를 저장하고 나가세요.\n\n펌웨어 부팅 관리자는 부팅 시 부트와 드라이버 옵션을 자동으로 실행하는 펌웨어 구성 요소를 가리킵니다; 사용자가 수동으로 실행할 부트 옵션을 선택하는 부팅 관리자 UI와 혼동하면 안 됩니다. 또한 드라이버 오버라이드를 적용하려면 마지막 드라이버 옵션이 처리된 후 모든 UEFI 드라이버가 시스템에서 연결 해제되고 다시 연결되어야 합니다.\n\n\n\n\n<div class=\"content-ad\"></div>\n\n펌웨어 부트 매니저는 부팅 옵션을 처리하기 전에 모든 드라이버 옵션을 자동으로 처리합니다. 그러므로 부팅 옵션과는 달리 펌웨어 메뉴는 명시적으로 특정 드라이버 옵션을 로드할 수 있는 방법을 제공하지 않습니다. 또한 필요하지 않습니다. 설치된 모든 드라이버 옵션이 로드됩니다.\n\n## EFI 쉘을 통한 수동 설치\n\n펌웨어 메뉴를 사용하는 것 외에도, EFI 쉘에서 bcfg 명령을 사용하여 새로운 부팅 및 드라이버 옵션을 설치할 수 있습니다. 자세한 내용은 도움말 bcfg의 결과를 확인하세요.\n\n펌웨어가 새로운 부팅 옵션 및/또는 드라이버 옵션을 추가할 수 있는 능력을 제공하지 않는 시스템에서 유용합니다. 이는 UEFI 사양 섹션 3에서 정의된 메커니즘 (NVRAM 변수, UEFI 변수로도 불리는)에 따라 옵션이 구현된 방식 때문입니다. 즉, 모든 UEFI 호환 펌웨어는 설명된 방식으로 옵션을 구현하고 처리해야합니다. bcfg는 동일한 메커니즘으로 작동하기 때문에, 펌웨어가 명시적으로 이를 지원하지 않더라도 옵션을 수정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n사실 NVRAM 변수를 직접 수정하여 부팅 및 드라이버 옵션을 설치하거나 수정할 수 있습니다. 그러나 이것은 이 안내서의 범위를 벗어납니다.\n\n## 기존 부팅 옵션에서 실행\n\n부팅 매니저 페이지에서 샘플 애플리케이션 옵션의 장치 경로 설명을 볼 수 있습니다. 그러나 EFI 셸 옵션에는 실행 파일의 이름이 누락되어 있을 수 있습니다:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_18.png)\n\n<div class=\"content-ad\"></div>\n\n해당 옵션의 Device Path(UEFI 셸에서 fs0: 볼륨 레이블로 할당)로 가리키는 파티션 내용을 나열하면 EnrollDefaultKeys.efi라는 유일한 UEFI 실행 파일만 있는 것을 알 수 있습니다. 이것이 EFI 셸처럼 들리지 않는 것이 분명합니다.\n\n이것이 일어나는 것은 펌웨어 부트 관리자가 모든 탈착 가능 미디어 및 고정 미디어 장치를 열거하고, 각 장치에 대한 부팅 옵션을 만드는 것입니다(UEFI 사양 섹션 13.3에 자세히 설명된 것처럼, 파일 시스템이 FAT인 경우). 이러한 항목을 부팅할 때 펌웨어가 장치 경로에 다음을 추가합니다: \\EFI\\BOOT\\BOOT'machine type short-name'.EFI 여기서 machine type short-name은 PE32+ 이미지 형식 아키텍처를 정의합니다. 가능한 값은:\n\n\n<div class=\"content-ad\"></div>\n\nPE(Portable Executable) 실행 파일 머신 유형은 Microsoft Portable Executable and Common Object File Format Specification, Revision 6.0에서 정의된 COFF 파일 헤더의 machine 필드에 지정됩니다.\n\n여러 CPU 아키텍처를 지원하기 위해 장치는 \\EFI\\BOOT\\ 하위 디렉터리에 서로 다른 아키텍처용으로 구축된 여러 실행 파일을 저장할 수 있습니다. 자세한 내용은 UEFI 명세의 섹션 3.1.2 및 3.5를 참조하십시오.\n\n따라서 fs0: 내의 모든 .efi를 나열하면 FS0:\\efi\\boot\\ 내에 bootx64.efi가 나타납니다. 이것이 EFI 셸입니다:\n\n![EFI Shell](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_21.png)\n\n<div class=\"content-ad\"></div>\n\n따라서 샘플 애플리케이션에 대해 동일한 방법을 적용할 수 있습니다. VisualUefi\\samples\\x64\\Release\\ 하위에 \\EFI\\BOOT\\ 하위 디렉토리를 만들고 샘플 애플리케이션을 복사하여 BOOTx64.efi로 이름을 바꿉니다. 실행하려면 부트 매니저 UI에서 기존 UEFI Misc 장치 옵션을 선택하면 됩니다. 또는 부팅 옵션을 재정렬하여 QEMU가 먼저 부팅하도록 할 수도 있습니다.\n\n이 접근 방식은 UEFI가 탈착식 미디어에서 부팅하는 방법을 지원하는 방식입니다. 예를 들어 Windows 설치 플래시 드라이브를 만들 때 설치 프로그램 실행 파일을 \\EFI\\BOOT\\BOOTx64.efi에 저장합니다. 설치하려면 펌웨어 메뉴에 들어가서 플래시 드라이브에서 부팅 옵션을 선택합니다. 또는 이미 플래시 드라이브를 첫 번째 부팅 옵션으로 구성했다면 시스템은 자동으로 설치 프로그램으로 부팅합니다.\n\n## EFI 셸\n\n셸은 본질적으로 UEFI 펌웨어의 명령 프롬프트 / bash 셸 버전입니다. bash와 동일한 명령어를 지원하며 모든 지원되는 명령을 나열하려면 help 명령을 사용하면 됩니다. 이를 통해 사용자는 OS에 부팅하지 않고 시스템의 파일에 접근하거나 수정할 수 있습니다. UEFI 펌웨어는 기본적으로 FAT 파일 시스템만 지원하므로 셸이 액세스할 수 있는 파일 시스템도 FAT 파일 시스템뿐입니다. 다른 파일 시스템의 지원은 관련 UEFI 드라이버가 설치되고 로드되어 있는지에 따라 달라집니다.\n\n<div class=\"content-ad\"></div>\n\nstartup.nsh\n쉘을 실행하면 다음과 같은 프롬프트가 나타납니다:\n\n```js\nPress ESC in 5 seconds to skip startup.nsh, any other key to continue.\n```\n\n셸은 실행할 때마다 startup.nsh를 실행합니다. 셸을 첫 번째 부팅 옵션으로 구성하면(이미 QEMU의 기본값으로 설정되어 있음), 이를 통해 OS에 부팅하지 않고 시스템에서 자동으로 스크립트 작업을 실행할 수 있습니다.\n\n기본적으로 스크립트 파일이 없지만 ESP(EFI 시스템 파티션)의 루트 디렉터리에 직접 만들 수 있습니다. 시험해보려면 셸에서 다음 명령을 입력하세요:\n\n<div class=\"content-ad\"></div>\n\n```md\necho \"@echo test startup script\" > fs0:\\startup.nsh\n```\n\n여기서 ESP의 볼륨 라벨인 fs0:에 스크립트 파일을 만들었어요.\n\nexit 명령어로 셸을 종료하고 다시 실행하세요:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_22.png)\n\n\n\n<div class=\"content-ad\"></div>\n\n## EFI 시스템 파티션 (ESP)\n\n이것은 UEFI 사양에 의해 정의된 특수 파티션이며 UEFI 펌웨어에서 액세스할 수 있습니다. 이것이 무엇인지 궁금하다면, 파티션에 액세스하는 것은 기본 작업이므로 이것이 운영 체제에만 해당되었다는 것을 알아두세요. UEFI가 대체하는 BIOS는 디스크의 전체 파티션에 액세스할 수 없었습니다. BIOS가 디스크에서 액세스 할 수 있는 유일한 요소는 MBR (마스터 부트 레코드) 및 VBR (볼륨 부트 레코드)였는데, 이들은 UEFI에 의해 대체되었습니다.\n\nESP에는 일반적으로 OS 부트로더 및 / 또는 부트 매니저가 위치합니다. Windows에서는 이 파티션은 디스크 관리.msc에서 볼 수 있듯이 기본적으로 드라이브 문자가 할당되지 않으므로 직접 액세스 할 수 없습니다:\n\n![파티션 예시](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_23.png)\n\n<div class=\"content-ad\"></div>\n\n접근하려면 고정된 명령 프롬프트를 열고 명령 mountvol X: /S를 사용하여 드라이브 문자를 할당하십시오. 여기서 X는 사용되지 않는 드라이브 문자입니다.\n\nWindows 부트 매니저의 위치를 확인하려면:\n\n```js\nX:\\>dir /b/s *.efi\nX:\\EFI\\Microsoft\\Boot\\bootmgr.efi\nX:\\EFI\\Microsoft\\Boot\\memtest.efi\nX:\\EFI\\Microsoft\\Boot\\bootmgfw.efi\nX:\\EFI\\Microsoft\\Boot\\SecureBootRecovery.efi\nX:\\EFI\\Boot\\bootx64.efi\n```\n\nbootmgfw.efi가 Windows 부팅 매니저입니다. 또한 EFI\\Boot\\bootx64.efi 항목에 주목하세요. 이것은 bootmgfw.efi의 사본이며, bootmgfw.efi가 없거나 손상된 경우 대비 용도로 제공됩니다.\n\n<div class=\"content-ad\"></div>\n\n# Secure Boot\n\n지금까지 모든 UEFI 실행 파일은 Secure Boot가 비활성화된 상태로 실행되었습니다. Secure Boot는 UEFI 펌웨어의 보안 기능으로 신뢰할 수 있는 UEFI 실행 파일만을 실행할 수 있게 합니다. 이를 통해 시스템이 악성 UEFI 실행 파일(예: 부트킷)로부터 안전하게 보호되며, 제품 환경에서 항상 활성화되어야 합니다. 신뢰는 실행 파일의 서명이 승인된 서명 데이터베이스에 있고 금지된 서명 데이터베이스에 없는 것으로 정의됩니다. 서명은 다음 중 하나로 정의됩니다:\n\n- 실행 파일의 SHA-1 Authenticode 해시\n- 실행 파일의 SHA-256 Authenticode 해시\n- 실행 파일의 SHA-224 Authenticode 해시\n- 실행 파일의 SHA-384 Authenticode 해시\n- 실행 파일의 SHA-512 Authenticode 해시\n- 실행 파일의 SHA-256 Authenticode 해시에 대한 RSA-2048 서명\n- 실행 파일의 SHA-1 Authenticode 해시에 대한 RSA-2048 서명\n- 실행 파일을 서명한 RSA-2048 키의 모듈러스 (공개 키 지수는 0x10001로 가정)\n- 실행 파일을 서명한 키의 DER로 인코딩된 X.509 인증서\n- 타임스탬프를 포함하는 더 복잡한 것들\n\nAuthenticode 해시가 어떻게 계산되는지에 대한 정보는 Windows Authenticode Portable Executable Signature Format에서 \"PE 이미지 해시 계산\" 섹션을 참조하십시오. X.509 인증서의 경우에는 UEFI 사양 섹션 8.2.6 및 32.6.3.3에 따라 실행 파일의 서명 인증서가 X.509 인증서 체인의 모든 수준에 존재하는 한 일치가 발견됩니다.\n\n<div class=\"content-ad\"></div>\n\n따라서 샘플 실행 파일이 안전 부팅이 활성화된 상태에서 실행되도록 하려면 이 중 하나의 서명을 안전 부팅 승인된 데이터베이스로 가져와야 합니다. 인증서를 사용하는 것이 더 유연한 옵션이며 해당 개인 키로 서명된 모든 실행 파일을 실행할 수 있습니다. 이로 인해 개발 및 테스트 중에 유용한 반복적인 수정 및 실행 파일 재구축이 가능해집니다. 그러나 해시를 사용하는 것보다 안전하지 않습니다. 왜냐하면 개인 키 침해의 위험이 있기 때문입니다.\n\n서명을 설치하려면 펌웨어 메뉴로 이동하십시오:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_24.png)\n\n장치 관리자를 선택하십시오.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_25.png)\n\nSelect Secure Boot Configuration.\n\n![Image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_26.png)\n\nThe Current Secure Boot State is set to Disabled. This entry is not configurable and is only meant to display the current state. The Attempt Secure Boot option itself is disabled (explained later), and the only option that can be changed is Secure Boot Mode. Change this from Standard Mode and Custom Mode which is the only other option available:\n\n\n<div class=\"content-ad\"></div>\n\n<table>\n  <tr>\n    <td><img src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_27.png\" /></td>\n  </tr>\n</table>\n\n친구 안전 부팅 옵션을 선택하십시오.\n\n<table>\n  <tr>\n    <td><img src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_28.png\" /></td>\n  </tr>\n</table>\n\n다섯 가지 옵션 각각이 안전 부팅 키 유형에 해당합니다. DB는 승인된 서명 데이터베이스이며 DBX는 금지된 서명 데이터베이스입니다. UEFI 명세서에서 \"키\"라는 용어를 사용하고 있지만, 각 유형의 \"키\"에 저장된 항목은 실제로 앞서 언급한 유형의 서명 중 하나입니다. 명세서를 따라서 \"키\"를 일반적인 서명을 가리키는 용어로 사용하겠습니다. 각 항목을 살펴보면:\n\n<div class=\"content-ad\"></div>\n\n새 키를 등록하거나 기존 키를 삭제할 수 있는 옵션을 볼 수 있습니다. 기존 키 목록을 표시할 옵션은 없지만 삭제 옵션을 사용하여 삭제할 수 있습니다. 이렇게 하면 모든 키가 비어 있는 것을 확인할 수 있습니다. 이것이 안전 부팅을 활성화할 수 없는 이유입니다 — 안전 부팅을 활성화하려면 PK(플랫폼 키)가 있어야 합니다. 우리는 직접 하나 만들 수 있지만, 앞서 EnrollDefaultKeys.efi를 본 것을 기억해보세요.\n\n## 기본 안전 부팅 키 설치\n\n기본 안전 부팅 키를 설치하려면 EFI 셸에서 EnrollDefaultKeys.efi를 실행하십시오. 이 작업은 모든 기존 키를 덮어씁니다:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_29.png)\n\n<div class=\"content-ad\"></div>\n\nSecure Boot은 PK가 없는 경우 설정 모드에 있습니다. PK를 설치하면 자동으로 Secure Boot가 사용자 모드로 전환됩니다 (UEFI 사양 섹션 32.3 참조, 이에 대해 나중에 자세히 논의할 예정입니다).\n\n셸을 종료하고 다시 Secure Boot 구성을 확인하십시오:\n\n![Secure Boot Configuration](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_30.png)\n\n이제 Secure Boot가 활성화되고 \"Attempt Secure Boot\" 옵션이 활성화되어 설정되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 다시 Secure Boot Mode를 Custom으로 변경하고 키를 나열해 보겠습니다:\n\n- PK: 이전에 활성화되었던 Enroll PK 옵션이 이제 비활성화되었습니다. 시스템에는 하나의 PK만 있을 수 있기 때문에 그렇습니다.\n- KEK: GUID로 명명된 두 항목이 있습니다. 모든 Secure Boot 키는 키의 소유자를 나타내는 SignatureOwner GUID와 연결됩니다:\n  - d5c1df0b-1bac-4edf-ba48-08834009ca5a: 이 소유자는 알 수 없습니다.\n  - 77fa9abd-0359-4d32-bd60-28f4e78f784b: 이것은 Microsoft입니다 (나중에 설명될 것입니다).\n- DB: Microsoft에 속한 두 항목이 있습니다 (나중에 설명될 것입니다).\n- DBX: 여기서 키는 유형에 따라 목록으로 그룹화됩니다. 유형이 SHA256인 목록만 한 개 존재합니다. Secure Boot 키의 모든 유형은 유형별 목록에 저장되는데, 이 펌웨어에서는 이 정보를 DBX에 대해서만 보여주기로 결정했습니다. 목록을 선택하면:\n\n  ![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_31.png)\n\n  KEK에 있는 알 수 없는 GUID와 같은 GUID가 나오며, 해시 E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855는 비어 있는 파일의 해시입니다. 이는 아마도 예제로 제공된 것일 것입니다. 최신 시스템에서는 DBX에 알려진 취약한 UEFI 실행 파일의 항목이 포함됩니다. 이러한 실행 파일 및 DBX를 업데이트하기 위한 이진 blob의 목록은 UEFI Forum에서 관리됩니다. Microsoft는 GitHub repo에서 이 목록의 미러를 유지합니다.\n\n<div class=\"content-ad\"></div>\n\n- DBT: 여전히 비어 있습니다.\n\n이제 부팅을 시도해 봅시다:\n\n![부팅 이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_32.png)\n\nEFI 쉘 또는 샘플 응용 프로그램은 서명되지 않았으며, 그 서명 또한 DB에 없기 때문에 이는 예상대로입니다.\n\n<div class=\"content-ad\"></div>\n\n# EFI 서명 인증서 생성\n\n샘플 애플리케이션을 서명하기 위해 먼저 인증서를 생성할 것입니다. Windows SDK에 포함된 명령줄 도구를 사용할 것입니다. 이 도구들은 %programfiles(x86)%\\Windows Kits\\10\\bin\\10.0.22621.0\\x64\\에 위치해 있습니다. 설치된 SDK 버전에 따라 하위 디렉토리의 이름이 다를 수 있습니다.\n\n먼저, 다음 명령을 명령 프롬프트에서 사용하여 개인 키와 해당 인증서를 생성해 보세요:\n\n```js\nMakeCert.exe -a sha256 -n \"CN=SampleEfiSigner\" -r -sv SampleEfiSigner.pvk SampleEfiSigner.cer\n```\n\n<div class=\"content-ad\"></div>\n\n출력 파일은 DER 인코딩된 X.509 형식으로 제공되며, 이는 지원되는 DB 서명 유형 중 하나입니다.\n\n옵션에 대한 설명:\n\n- -a 서명의 다이제스트 알고리즘(기본값은 SHA1)\n- -n 인증서 소유자 X509 이름\n- -r 자체 서명된 인증서 생성\n- -sv 서브젝트의 PVK 파일, 존재하지 않는 경우 생성됩니다.\n\n이 명령은 비공개 키 파일을 사용할 비밀번호를 요청하는 팝업 프롬프트를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_33.png)\n\n다음으로 임의의 암호를 설정하고 확인을 누르세요.\n\n이렇게 하면 이전 단계에서 설정한 암호를 요청하는 두 번째 프롬프트가 생성됩니다. 이는 자체 서명 작업을 위한 것입니다:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_34.png)\n\n\n<div class=\"content-ad\"></div>\n\nMakeCert 명령어의 결과는 다음과 같아야 합니다:\n\n```js\nSucceeded;\n```\n\n그런 다음 .pvk 파일을 .pfx로 변환하여 signtool에서 UEFI 실행 파일에 서명할 수 있도록 합니다:\n\n```js\npvk2pfx.exe -pvk SampleEfiSigner.pvk -pi <password> -spc SampleEfiSigner.cer -pfx SampleEfiSigner.pfx\n```\n\n<div class=\"content-ad\"></div>\n\n`password`를 개인 키 파일의 비밀번호로 바꾸세요. 이 명령은 출력물이 없습니다.\n\n옵션 설명:\n\n- -pvk 입력 PVK 파일 이름\n- -pi PVK 파일의 비밀번호\n- -spc 입력 SPC 파일 이름\n- -pfx 출력 PFX 파일 이름\n\n## UEFI 실행 파일에 서명하기\n\n<div class=\"content-ad\"></div>\n\n이전 도구와 동일한 디렉토리에 있는 signtool을 사용해보세요:\n\n```js\nsigntool.exe sign /fd sha256 /ac SampleEfiSigner.cer /f SampleEfiSigner.pfx /p <비밀번호> <서명할 efi 파일>\n```\n\n`비밀번호`를 개인 키 파일의 비밀번호로 대체하세요. `서명할 efi 파일`은 대상 파일 이름으로 대체하세요. 이 명령은 다음을 출력해야 합니다:\n\n```js\nDone Adding Additional Store\nSuccessfully signed: <efiToSign>\n```\n\n<div class=\"content-ad\"></div>\n\n옵션 설명:\n\n- /fd 파일 서명에 사용할 파일 다이제스트 알고리즘 (기본값은 SHA1)\n- /ac 서명 블록에 추가 인증서 추가\n- /f 서명 인증서의 파일. 파일에 개인 키가 없는 경우 \"/csp\" 및 \"/kc\"를 사용하십시오.\n- /p PFX 파일의 암호\n\n파일의 속성 창을 열어 서명되었는지 확인하세요. 새로운 디지털 서명 탭이 있어야 합니다:\n\n![서명 확인](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_35.png)\n\n<div class=\"content-ad\"></div>\n\n## DB에 인증서 설치하기\n\nSampleEfiSigner.cer 파일을 VisualUefi\\samples\\x64\\Release\\ 폴더로 이동하세요. 우리는 이후 펌웨어 메뉴에서 이 파일에 접근해야 합니다. 펌웨어 메뉴에서 DB 옵션으로 이동하고 Enroll Signature를 선택하세요:\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_36.png)\n\nSelect Enroll Signature Using File.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_37.png\" />\n\n첫 번째 옵션을 선택하세요.\n\n<img src=\"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_38.png\" />\n\nSampleEfiSigner.cer를 선택하세요. 여기서 펌웨어는 DER로 인코딩된 X.509 인증서와 UEFI 실행 파일만 지원합니다. 후자의 경우 실행 파일의 SHA-256 Authenticode 해시를 계산하여 서명으로 저장할 것입니다.\n\n<div class=\"content-ad\"></div>\n\nUI가 등록 서명 페이지로 돌아갑니다. 서명 GUID 필드는 서명 소유자의 서명과 일치합니다. 임의의 값 입력하거나 기본값으로 모든 0의 GUID로 남겨 둡니다:\n\n![Enroll Signature](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_39.png)\n\n서명은 이제 삭제 서명 메뉴에 표시됩니다:\n\n![Delete Signature](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_40.png)\n\n<div class=\"content-ad\"></div>\n\nUEFI 실행 파일 자체를 선택했을 경우, 항목 설명은 PKCS7_GUID가 아니라 SHA256_GUID가 됩니다.\n\n다음으로 부팅을 시도해보세요:\n\n![부팅 시도 이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_42.png)\n\n<div class=\"content-ad\"></div>\n\n## 안전한 부팅 보안\n\n펌웨어 UI를 사용하여 서명을 등록하는 것 외에도 UEFI 런타임 서비스 함수 SetVariable()를 통해 프로그래밍 방식으로도 이를 수행할 수 있습니다. 이는 UEFI 실행 파일 및 OS 실행 파일 모두에서 호출할 수 있습니다 (Windows에서는 SetFirmwareEnvironmentVariable()로 노출됩니다). 그런데 여기서 의문이 생깁니다 - 이것이 안전한 방법인가요? Secure Boot가 활성화된 경우, 신뢰할 수 있는 UEFI 실행 파일만 실행되도록 허용되므로 서명을 수정할 수 있어야 합니다. 그러나 OS는 안전하지 않은 코드를 실행할 수 있으며, 악성 코드는 이에 대표적인 예시입니다 - 그들은 그들의 부트킷을 화이트리스트에 추가하거나 DBX에서 취약한 실행 파일을 제거할 수 있습니다. Windows는 SetFirmwareEnvironmentVariable()을 호출하는 것을 특권있는 사용자 (예: 관리자)만 허용하도록 제한하지만, 특권 상승 공격을 통해 여전히 우회될 수 있습니다. 이 때 PK와 KEK가 필요합니다.\n\nSecure Boot가 설정 모드인 경우 (즉, PK가 없는 경우), 사용자는 PK가 없는 제약 없이 펌웨어 UI 또는 SetVariable()을 통해 모든 Secure Boot 키를 수정할 수 있습니다. Secure Boot가 사용자 모드로 진입하면 (즉, PK가 설치된 경우), 사용자는 Secure Boot 키를 계속 펌웨어 UI를 통해 수정할 수 있지만, SetVariable()의 경우, 펌웨어는 쓰여질 데이터가 서명되어야 한다고 요구할 것입니다. 대상 Secure Boot 키는 어떤 서명 키가 필요한지를 결정합니다:\n\n- DB, DBX: PK 또는 KEK에 해당하는 개인 키로 서명\n- PK, KEK: PK에 해당하는 개인 키로 서명\n\n<div class=\"content-ad\"></div>\n\n단일 유형의 키로 DB 및 DBX를 안전하게 보호하는 것이 충분했겠지만, Secure Boot 키의 소유권 수준을 구분하기 위해 PK와 KEK 사이에 차이를 두었습니다. PK는 컴퓨터 하드웨어의 OEM이 소유하며 컴퓨터 당 하나뿐입니다. HP 및 Dell의 경우:\n\n![Image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_43.png)\n\nPK의 역할은 KEK의 설치를 제어하는 것입니다. 컴퓨터 당 여러 KEK가 있을 수 있으며, 각각이 DB 및 DBX로 서명을 설치하는 데 신뢰되는 엔티티에 해당합니다. 일반적으로 OEM 및 운영 체제만 해당됩니다. HP 및 Dell의 경우:\n\n![Image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_44.png)\n\n<div class=\"content-ad\"></div>\n\nWindows 시스템의 경우, Microsoft의 KEK는 다음과 같습니다:\n\n- Microsoft Corporation KEK CA 2011\n- Microsoft Corporation KEK 2K CA 2023\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_45.png)\n\n2023 CA는 2026에 만료되는 2011 CA를 대체하기 위해 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\nSecure Boot에 대한 자세한 내용은 UEFI 명세서 32장과 Microsoft의 Secure Boot 키 생성 및 관리 문서를 참조하세요.\n\n## 기본값으로 Microsoft 키\n\n웹 사이트 인증서의 경우 신뢰 여부는 Trusted Root 또는 중간 인증서에서의 체인 여부를 확인하는 것만으로 결정됩니다. 이러한 인증서는 종종 OS에 미리 설치되어 있으며 업데이트도 OS에서 처리됩니다.\n\n그러나 Secure Boot와 호환되는 UEFI 실행 파일을 배포하고 싶다면, 서명 인증서를 얻기 위해 찾아갈 수 있는 CA도 없고 실행 파일에 서명할 수 있는 CA도 없습니다.\n\n<div class=\"content-ad\"></div>\n\nWindows의 부팅 관리자(UEFI 애플리케이션)는 기본적으로 세계 제조사들과 협력하여 제품을 제조하는 모든 소매용 PC와 마더보드에 Microsoft의 KEK 및 DB 키가 설치되어 있기 때문에 Secure Boot가 활성화된 상태에서 즉시 실행될 수 있습니다. 모든 사람이 마찬가지로 할 수 있는 능력을 갖고 있는 것은 아니지만, 다행히도 Microsoft는 Windows 드라이버 서명 서비스와 유사한 UEFI 서명 서비스를 제공합니다. 서명된 후에 UEFI 실행 파일은 Windows와 동일한 하드웨어 범위와 호환되는 Secure Boot가 가능해집니다.\n\n이러한 협정은 마이크로소프트가 이름만 다르지 CA 등록인 Secure Boot CA인 것처럼 되어 있고, 이것이 또한 Microsoft의 키가 기본값으로 처리되는 이유이기도 합니다. 앞서 말한 KEK 외에도 Windows 시스템의 DB에는 다음과 같은 인증서가 설치되어 있습니다:\n\n- Microsoft Windows Production PCA 2011\n- Windows UEFI CA 2023\n\n![image](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_46.png)\n\n<div class=\"content-ad\"></div>\n\n위의 두 개의 키 중 하나로 Windows 부팅 관리자가 서명되었습니다.\n\n- Microsoft Corporation UEFI CA 2011\n- Microsoft UEFI CA 2023\n\n![이미지](/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_47.png)\n모든 타사 UEFI 실행 파일은 위의 두 키 중 하나로 서명됩니다.\n\n<div class=\"content-ad\"></div>\n\nEnrollDefaultKeys.efi를 실행한 후 DB에는 2011년 인증서인 두 개의 항목이 생성되었습니다. 2026년에 만료되는 2011년 인증서를 대체할 2023년 인증서가 있습니다.\n\nUEFI 실행 파일을 직접 서명하는 것 외에도 Microsoft가 할 수 있는 옵션은 다음과 같습니다:\n\n- Microsoft가 UEFI CA 인증서에 연결되는 인증서를 발행하고 이를 OS 업데이트를 통해 DB에 설치합니다.\n- 개발자가 제출한 DB 업데이트를 Microsoft가 수락하여 원하는 서명을 설치할 수 있도록 KEK를 사용합니다.\n\n그러나 이러한 옵션들은 악의적인 사용자들이 부팅 킷을 모든 Windows 시스템에 배포하는 더 많은 길을 제공할 수 있습니다 (Microsoft에 요청을 제출할 때 합법적인 개발자로 위장하거나 신뢰할 수 있는 개발자들의 서명 키를 도난당할 수 있음). Microsoft는 분명히 제출자들을 심사하는 책임을 지기를 원하지 않으며, 시스템의 보안과 안정성에서 부팅 모듈의 중요성을 고려할 때 Microsoft에게 중요한 것은 다음을 보증하는 것입니다:\n\n<div class=\"content-ad\"></div>\n\n- 해로운 저작물이 아니며 Secure Boot를 우회하는 수단을 제공하지 않습니다 (즉, 서명되지 않은 코드를 실행하지 않음)\n- Microsoft의 부팅 모듈과의 호환성 문제를 일으키지 않습니다.\n\n이것이 마이크로소프트가 실행 파일을 제출하도록 요청하는 유일한 옵션인 이유입니다.\n\n이러한 규정은 마이크로소프트가 서명한 UEFI 실행 파일에서 취약점이 발견된 경우 해당 취약성을 차단하는 유일한 방법은 해당 파일의 Authenticode 해시를 DBX에 추가하는 것입니다. 마이크로소프트의 UEFI CA 인증서는 DBX에 추가할 수 없습니다. 그렇게 되면 다른 취약하지 않은 실행 파일도 차단됩니다. Windows 부팅 매니저 (BlackLotus) 및 shim/GRUB2 (Boot Hole)의 취약성으로 인해 DBX에는 수백 개의 항목이 추가되었습니다.\n\n## 키 사용자 정의하기\n\n<div class=\"content-ad\"></div>\n\n더 많은 통제와 보안을 위해, 필요없는 기본 키를 제거하거나 사용자 정의 키를 설치하고 싶을 수 있습니다. UEFI 실행 파일을 Microsoft에 제출하지 않고 싶을 수도 있거나, 단순히 제출할 수 없을 수도 있습니다:\n\n이 모든 것은 대상 컴퓨터의 Secure Boot 키를 사용자 정의하는 것을 의미합니다. 그러나 소매 시스템의 기본 Secure Boot 모드는 사용자 모드(예: PK가 설치됨)이므로, 이러한 변경을 수동으로 접근하는 것이 유일한 방법일 것입니다. 일부 제한된 배포에 대해서는 실행 가능하지만, 대규모 배포(예: 기업)에 대해서는 비현실적할 것입니다 — 모든 시스템을 직접 방문하거나 다시 수집하는 것은 너무 많은 시간과 노력이 필요할 것입니다. 원격으로 변경하는 것은 해당 키 업데이트가 관련 키(PK 또는 KEK)로 서명된 경우에만 가능할 것입니다. 그러나 위에서 설명했듯이, 이러한 요청을 OEM 또는 이 키를 소유한 Microsoft가 보안 문제로 인해 받아들일 가능성은 없을 것입니다.\n\n대안으로 OEM이 키를 사용자 정의하거나 시스템을 전달하기 전에 PK를 제거하는 것이 가능할 수 있습니다; 그러나 이는 추가 비용이 발생하고 이미 전달된 시스템에 해당하지 않을 수 있습니다.\n\n마지막으로, 기본 PK 또는 KEK를 사용자 정의로 대체한다면, 이후 OEM/Microsoft에 의한 KEK 또는 DB/DBX의 모든 업데이트는 실패할 것입니다. 따라서 해당 업데이트를 원한다면, 영향을 받는 컴퓨터에 배포되기 전에 해당 사용자 정의 PK/KEK에 해당하는 개인 키로 서명해야 합니다. 업데이트의 서명 및 설치는 앞서 언급한 signtool.exe 및 PowerShell 명령 Format-SecureBootUEFI 및 Set-SecureBootUEFI를 사용하여 수행할 수 있습니다. 이를 수행하는 방법에 대한 세부 내용은 이 가이드의 범위를 벗어납니다.\n\n<div class=\"content-ad\"></div>\n\n## 실제 시스템에서 실행\n\nQEMU에서 UEFI 실행 파일을 실행하는 데 사용한 모든 방법은 실제 물리적 시스템에서도 적용됩니다. 주의해야 할 차이점은 다음과 같습니다:\n\n- 솔루션의 출력 디렉토리는 시스템에서 볼륨으로 마운트되지 않습니다. 따라서 실행할 실행 파일은 펌웨어에서 액세스 가능한 볼륨에 저장해야 합니다. 이는 ESP, 로컬 FAT 볼륨 또는 FAT 이동식 미디어가 될 수 있습니다.\n- BitLocker가 활성화되어 TPM을 키 보호자로 사용하도록 구성되어 있는 경우, Secure Boot를 비활성화하면 시스템이 BitLocker 복구 모드로 이동해야 할 수 있습니다. BitLocker 키를 봉인할 PCR 뱅크가 구성되어 있는 경우에는 심지어 서명된 UEFI 실행 파일이라도 BitLocker 복구 모드가 발생할 수 있습니다. 이는 이 안내서의 범위를 벗어난 이슈입니다. BitLocker 복구 키를 오프라인으로 가용하게 하고 펌웨어 설정을 변경하고 UEFI 실행 파일을 테스트하기 전에 BitLocker를 일시 중지하세요.\n- EFI 셸의 가용성은 시스템의 브랜드와 모델에 따라 다릅니다. 존재하는 경우 펌웨어 메뉴에서 액세스할 수 있어야 합니다. 없는 경우, 공식 edk2 릴리스 범위에서 다음과 같은 범위에서 얻을 수 있습니다: [edk2-stable201905, edk2-stable202002]. 이전 버전의 셸은 edk2 리포지토리의 ShellBinPkg 폴더의 일부로 커밋되었습니다. 해당 폴더는 2019년 4월 24일에 제거되었으며 내용은 릴리스 페이지로 이전되었습니다. 최신 버전의 경우 직접 빌드하거나 pbatard/UEFI-Shell과 같은 타사 소스에서 다운로드할 수 있습니다. 모든 edk2 릴리스는 서명되지 않았으며 펌웨어에 내장된 EFI 셸도 서명되지 않을 수 있으므로 이를 실행하려면 Secure Boot를 비활성화하거나 이들의 서명을 DB에 설치해야 합니다.\n- 펌웨어 UI 및 사용 가능한 구성은 시스템의 브랜드와 모델에 따라 다를 수 있으므로 Secure Boot를 비활성화하고 새 부팅 및 드라이버 옵션을 추가하는 등 설정을 변경하는 단계도 다를 것입니다.\n\n## 기타 주의 사항\n\n<div class=\"content-ad\"></div>\n\n- VisualUefi 저장소는 더 이상 활발하게 유지되지 않으며 심각하게 오래되었습니다 — 동기화된 edk2 커밋은 2019년이며 openssl의 경우 2018년입니다. 누군가는 수동으로 서브모듈을 원격 최신 커밋으로 업데이트해야 하며, 그런 다음 서브모듈 소스 트리의 변경으로 인해 Visual Studio 프로젝트를 업데이트해야 합니다.\n- VisualUefi는 선택된 edk2 라이브러리만 빌드하며 모든 edk2 소스 코드를 포함하지 않습니다. 추가 라이브러리를 포함하려면 새 Visual Studio 프로젝트를 만들어야 합니다.\n- UEFI 실행 파일의 디버깅은 라이브 디버깅을 위한 디버거를 연결할 방법이 없어 어려울 수 있습니다. 콘솔에 로깅하는 것이 도움이 될 수 있지만, 대량 로깅이 있는 대규모 프로그램에는 실용적이지 않을 수 있습니다. 로그 파일에 쓰는 것도 해결책이지만, 프로그램이 실행을 완료할 때까지 로그 파일을 조사하기 전까지 기다려야 합니다. 다른 해결책으로는 UEFI 실행 파일을 가상 머신에서 실행하고 호스트에 연결된 파이프로 로깅하는 것이 있습니다. 호스트에서는 파이프의 내용을 읽고 콘솔에 인쇄하는 프로그램을 실행하여 로그를 실시간으로 검토할 수 있습니다. 이를 위해서는 VisualUefi를 수정하여 새 edk2 라이브러리를 빌드하고 edk2 소스 코드를 수정해야 합니다.\n","ogImage":{"url":"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_0.png"},"coverImage":"/assets/img/2024-05-27-AhitchhikersguidetoUEFIprogramminginWindows_0.png","tag":["Tech"],"readingTime":27},{"title":"윈도우에 Pyspark 설치하는 단계별 안내법","description":"","date":"2024-05-27 12:29","slug":"2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows","content":"\n\n## 소개\n\n![image](/assets/img/2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows_0.png)\n\n아파치 스파크는 속도와 사용 편의성으로 인해 엄청난 인기를 얻은 강력한 오픈 소스 분산 컴퓨팅 시스템입니다. 파이스파크는 아파치 스파크를 사용하여 Python 프로그래밍 언어를 통해 스파크의 기능을 활용할 수 있도록 하는 파이썬 API입니다. 스파크는 보통 리눅스 환경과 관련이 있지만, Windows에 Pyspark를 설치하는 것은 다소 어려울 수 있습니다. 이 안내서에서는 Windows 기기에 Pyspark를 설치하는 프로세스를 단계별로 안내해 드리겠습니다.\n\n자, 그럼 Windows에 Pyspark를 설치하는 단계별 프로세스로 들어가 보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n단계 1: 로컬 시스템에 Python 설치하기\n\na. https://www.python.org/downloads/에서 최신 버전의 Python을 다운로드합니다.\n\nb. 설치 프로그램을 다운로드한 후 실행 파일(예: python-3.x.x.exe)을 더블 클릭하여 설치를 시작하고, 설치 중 \"Add Python to PATH\"란을 확인하는 상자를 선택해야 합니다.\n\nc. 명령 프롬프트를 열고 python --version 또는 python -V를 입력한 후 엔터를 눌러 Python이 설치되었는지 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows_1.png)\n\n단계 2: Java 개발 키트 (JDK) 설치하기\n\na. 오라클 웹사이트에서 최신 JDK 설치 프로그램을 다운로드합니다.\n\nb. 설치 프로그램을 실행하고 화면 안내에 따라 설치를 완료하세요.\n\n<div class=\"content-ad\"></div>\n\nc. JAVA_HOME 환경 변수를 설정합니다. 시스템 환경 변수에 JDK 설치 경로를 추가하세요.\n\n![image](/assets/img/2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows_2.png)\n\nd. 명령 프롬프트를 열어 java --version을 입력하고 엔터를 눌러 Java가 설치되었는지 확인하세요.\n\n![image](/assets/img/2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows_3.png)\n\n<div class=\"content-ad\"></div>\n\n**단계 3: Apache Spark 설치하기**\n\na. 스파크 다운로드 페이지(https://spark.apache.org/downloads.html)를 방문해주세요.\n\n![이미지](/assets/img/2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows_4.png)\n\nb. SPARK_HOME을 spark가 추출된 환경 변수에 설정하세요. 수정할 부분입니다.\n\n<div class=\"content-ad\"></div>\n\nMarkdown 형식으로 표를 변경해주세요.\n\n| 이미지 | 설명 |\n| --- | --- |\n| <img src=\"/assets/img/2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows_5.png\" /> | 스텝 4 : Hadoop 설정 |\n| a. | hadoop 폴더 생성 및 그 안에 bin 폴더 생성 |\n| b. | winutils 파일 다운로드 - https://github.com/steveloughran/winutils 및 bin 폴더에 넣기 |\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows_6.png\" />\n\nc. 환경 변수에서 HADOOP_HOME 경로 설정\n\n<img src=\"/assets/img/2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows_7.png\" />\n\n단계 5 : Pyspark 설치\n\n<div class=\"content-ad\"></div>\n\na. 명령 프롬프트를 열고 다음 명령어를 실행하세요 — pip install pyspark\n\nb. 환경 변수에서 PYSPARK_HOME 경로를 설정하세요\n\n![이미지](/assets/img/2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows_8.png)\n\n단계 6: 설치 확인\n\n<div class=\"content-ad\"></div>\n\na. 모든 변수를 경로에 추가해주세요\n\n![이미지](/assets/img/2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows_9.png)\n\nb. Python 쉘이나 Jupyter 노트북을 열고 다음 코드를 실행하여 설치를 확인해주세요:\n\n```python\nfrom pyspark.sql import SparkSession\n\nspark = SparkSession.builder.master(\"local\").appName(\"PySpark Installation Test\").getOrCreate()\ndf = spark.createDataFrame([(1, \"Hello\"), (2, \"World\")], [\"id\", \"message\"])\ndf.show()\n```\n\n<div class=\"content-ad\"></div>\n\n이미지 :\n\n<img src=\"/assets/img/2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows_10.png\" />\n\nWindows에서 PySpark 설치에 대한 주요 고려 사항 :\na. Apache Spark와 PySpark 버전 간의 호환성 확인\nb. 환경 변수 설정 후 명령 프롬프트 다시 시작\nc. 공식 문서를 의존하고 PySpark 및 종속성에 대해 최신 정보 유지\n\n## 결론:\n\n<div class=\"content-ad\"></div>\n\n축하합니다! Windows 컴퓨터에 PySpark를 성공적으로 설치하셨군요. 이제 Python 프로그래밍 언어의 간편함을 활용하여 분산 데이터 처리 및 분석을 수행할 수 있는 PySpark의 강력함을 경험할 수 있게 되었습니다. Windows 환경에서 PySpark가 제공하는 다양한 기능을 즐겨보세요.","ogImage":{"url":"/assets/img/2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows_0.png"},"coverImage":"/assets/img/2024-05-27-AStep-by-StepGuidetoInstallingPysparkonWindows_0.png","tag":["Tech"],"readingTime":4},{"title":"시스템 엔지니어, 시스템 관리자 및 사이트 신뢰성 엔지니어가 PowerShell 자동화를 통해 실무 경험을 쌓고 경력을 발전시킬 수 있는 방법","description":"","date":"2024-05-27 12:27","slug":"2024-05-27-HowSystemsEngineersSystemsAdministratorsandSiteReliabilityEngineersCanAdvanceTheirCareersthroughPracticalExperiencewithPowerShellAutomation","content":"\n\n자동화는 반복적인 수동 작업을 제거하기 위해 어디서나 진행 중입니다. 나는 2009년에 컴퓨터 시스템과 네트워크 전공 학업을 시작했는데, 동시에 마이크로소프트가 윈도우 XP SP2 및 윈도우 서버 2003 SP1용 파워셸 첫 번째 버전으로 옵션 구성 요소로 출시한 '파워셸 2.0'을 발표했던 해였다. 그 전에는 리눅스 전문가들이 마이크로소프트 OS에 별 관심을 두지 않았는데, 왜냐하면 윈도우 OS는 아이콘만 누르도록 허용하고 자동화 기능이 거의 없었기 때문이다.\n\n나의 첫 \"파워셸\" 접점은 그의 최초의 공식 OS 통합 릴리스인 2.0, 그리고 윈도우 서버 2008 R2와 윈도우 7에 통합될 때였습니다. 2009년부터 2013년까지 나는 학업적인 과제를 위해 윈도우 서버와 액티브 디렉터리에 대한 지식을 얻었는데, 이는 간단한 파워셸 명령 실행이 포함되었습니다. 그러나 이러한 파워셸 경험이 나의 전문적인 성공에 어떻게 기여할 수 있는지에 대해 고려한 적이 없었습니다.\n\n가장 초기의 파워셸 관련 직무 공고를 발견하세요.\n\n<div class=\"content-ad\"></div>\n\n2015년, 유명한 미국 기업의 SCCM 전문가로 임명되면서, 저의 경력이 PowerShell을 향한 급격한 전환을 겪게 되었습니다.\n\n그 기간 동안, 전 세계적으로 유명한 패스트푸드 가공 회사에 배치되었습니다. 그들은 전 세계에 40만 대 이상의 Windows 기반 엔드포인트를 유지했습니다.\n\n엔드포인트 구성 요구 사항을 분석하여 PowerShell 및 배치 스크립트를 작성하고 이러한 요구 사항을 충족시키며, 이를 SCCM을 통해 실제 상점에 전 세계적으로 배포하는 것이 제 3단계 업무의 일부였습니다.\n\n직무에 이상적인 후보는 아니었지만, 학업 과정에서 PowerShell에 익숙했던 것이 이 직무에 선발되는 데 중요한 요소였습니다.\n\n<div class=\"content-ad\"></div>\n\n2015년에 면접을 볼 때, 기본 PowerShell 명령에 대한 지식을 주로 시험했습니다. 서비스 정보 가져오기, 서버 통계 확인, Active Directory 사용자 세부 정보 수집, 사용자, 파일, 디렉토리 생성 등의 명령이 그 중에 포함됩니다. 이미 이에 익숙해서 어려움 없이 질문에 답했습니다.\n\n따라서 새로운 Powershell 기회를 활용하고 싶은 모든 분들이 첫 번째 Powershell 직업을 성공적으로 얻기 위해 다음 Microsoft Learn 온라인 강좌에서 숙달하길 강력히 권장합니다.\n\nhttps://learn.microsoft.com/en-us/training/paths/get-started-windows-powershell/\n\nhttps://learn.microsoft.com/en-us/training/modules/script-with-powershell/\n\n<div class=\"content-ad\"></div>\n\n첫 직장에서 승진 기회 및 PowerShell 노출 기회\n\n직무 배정의 첫 번째 지식 이전 과정 중에, 나는 40만 개 이상의 장치 대규모 배포에 완전히 책임을 져야 했는데, 이는 주로 내가 직접 작성한 사용자 정의 PowerShell 스크립트에 많이 의존하는 SCCM을 통해 진행되었습니다.\n\n게다가, 과거 PowerShell 배포에 대해 문제가 발생했던 사례에 대해 몇 명의 직원들이 언급했는데, 이로 인해 상당한 재정 손실이 발생했다고 했습니다. 그들은 본받을만한 SCCM PowerShell 배포에 대해 자신 있었으며, 실제 환경에서 배포를 수행하기 전에 PowerShell을 사용했습니다. 사실상, 이것은 PowerShell 기술 개발에 도움이 되었습니다. 직무에서 자주 마주치는 측면 중 하나는 대부분 PowerShell을 기반으로 한 매일 새로운 스크립트를 받는 것입니다.\n\n따라서 PowerShell 스크립트를 생성하라는 요청이 있을 때마다 오류가 없도록 하기 위해 항상 아래 절차를 준수했습니다.\n\n<div class=\"content-ad\"></div>\n\n단계 01: PowerShell 스크립트의 정확한 요구사항을 파악합니다.\n\n단계 02: 비슷한 요구사항을 충족시킬 수 있는 모든 관련 PowerShell 함수\\명령을 읽고 이해합니다.\n\n단계 03: 단계 02에서 찾은 내용을 활용하여 최적의 PowerShell 스크립트를 작성합니다.\n\n단계 04: 단일 테스트 머신을 사용하여 스크립트를 테스트합니다.\n\n<div class=\"content-ad\"></div>\n\nStep 05: 3대의 테스트 머신을 사용하여 스크립트를 테스트합니다.\n\nStep 06: 내 머신에 스크립트를 배포하여 잘못된 구성의 피해자가 되도록 합니다.\n\nStep 07: 3대의 프로덕션 머신에 스크립트를 배포하고 결과를 모니터링합니다.\n\nStep 08: 10대의 프로덕션 머신에 스크립트를 배포하고 결과를 모니터링합니다.\n\n<div class=\"content-ad\"></div>\n\nStep 09: 스크립트를 100대의 프로덕션 머신에 배포하고 결과를 모니터링합니다.\n\nStep 10: 스크립트를 1000대의 프로덕션 머신에 배포하고 결과를 모니터링합니다.\n\nStep 11: 스크립트를 100,000대 이상의 프로덕션 머신에 배포하고 결과를 모니터링합니다.\n\n저는 회사에서 3년 동안 업무 중 오류를 하나도 범하지 않았고, 오류 없는 배포 엔지니어 중 한 명이었습니다.\n\n오늘 일을 완벽하게 처리하는 것은 탁월한 성과로 간주되지 않습니다. 기대치를 충족하는 것뿐입니다. 우수한 팀원이 되려면 시간과 비용을 절약하고 생산성을 높이는 새로운 방법을 끊임없이 모색해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n생산성을 향상시키고 시간과 비용을 절약하는 가장 좋은 방법 중 하나는 Powershell을 활용하여 수동 프로세스를 자동화하는 것입니다. 시스템 아키텍트를 포함한 대부분의 시스템 엔지니어링 전문가는 여전히 Windows GUI를 사용하여 작업을 수행합니다. 자세히 살펴보면 Windows 플랫폼 전문가들이 매일 많은 반복 작업을 실행하는 것을 볼 수 있습니다. 그에 따라 PowerShell은 이러한 활동을 자동화하는 데 사용될 수 있으며 여러분의 기술을 보여주고 팀 내에서 여러분의 중요성을 강조할 수 있습니다. \n\n저는 이전 기업에서의 경력 중 PowerShell을 활용한 주목할만한 자동화 프로젝트 중 하나인 PowerShell 기반 스크립트에 의한 자동화된 장치 복구 및 에스컬레이션을 시작했습니다. 이 고급 PowerShell 스크립트는 2017년에 개발되었으며 2년간의 매일 PowerShell 스크립팅 경험을 통해 만들어졌습니다. 이 스크립트는 Windows 기기의 건강 상태를 실시간으로 식별하고, SCCM 및 SCOM과 같은 에이전트를 배포하여 건강 상태와 잠재적 문제를 확인하고, 문제가 지속되면 이러한 기기를 Excel로 필터링하여 문제를 관련 팀에 자동 이메일을 통해 필요한 조치가 취해지도록 전달할 수 있었습니다. 이 프로젝트의 결과는 회사의 전달 리뷰에서 매우 높게 평가되었으며, 저는 회사의 최고 인재로 선정되어 금융 장려도를 받았습니다. 이를 바탕으로 저는 이 Powershell 프로젝트로 인해 3년 동안 두 번의 승진을 했습니다.\n\n그러므로 Powershell 전문 지식을 통해 여러분의 우수한 성과를 효과적으로 시연할 수 있는 중요한 수단임을 강조합니다. \n\n이전 Powershell 경험과 성공적인 경력 간의 연결하기\n\n<div class=\"content-ad\"></div>\n\n나는 내 이전 직장에서 거의 4년간 봉사한 후, 유명 은행이 Active Directory 및 도메인 이름 시스템의 시스템 아키텍처 포지션을 제안하여 나에게 제공해주었습니다.\n\n내 ob은 Active Directory와 관련이 많이 있어 PowerShell 전문 지식을 유용하게 활용하고 PowerShell을 통해 Active Directory 능력의 모든 측면에서 자신감을 얻을 수 있었어요.\n\n가장 강조하고 싶은 것은 내가 ConnectWise Automate 전문가로 다음 직업을 얻은 방법입니다. 여기서 Windows 플랫폼을 Powershell로 자동화하고 글로벌 규모에서 7000개 이상의 장치 설정을 관리할 것입니다. 나는 이 기회를 위해 공식 지원서를 제출하지 않았습니다. 대신, 고용주가 나를 LinkedIn에서 발견하고 SCCM과 Powershell 경험에 관심이 있었어요. 회사에 합류한 후에 내 위치가 ConnectWise 플랫폼을 관리할 능력이 필요한 적절한 후보 부재로 두 번이나 공고 되었다는 것을 들었습니다.\n\n내 PowerShell 능력 덕분에 회사에서 일을 시작한 후 상대적으로 짧은 시간 안에 ConnectWise Automate Certified 전문가가 되었습니다. ConnectWise Automate 플랫폼 내에서 PowerShell을 활용함으로써 우수한 자동화를 신속히 수행하여 CEO 상, 빠른 직원 인정상, 최우수 수행자상 3개 주요 성과를 이루었습니다. 따라서 시스템 엔지니어, 시스템 관리자 또는 사이트 신뢰성 엔지니어라면 Powershell 학습을 강력히 권장합니다. 당신의 경력에 큰 변화를 가져다 줄 것입니다.","ogImage":{"url":"/assets/img/2024-05-27-HowSystemsEngineersSystemsAdministratorsandSiteReliabilityEngineersCanAdvanceTheirCareersthroughPracticalExperiencewithPowerShellAutomation_0.png"},"coverImage":"/assets/img/2024-05-27-HowSystemsEngineersSystemsAdministratorsandSiteReliabilityEngineersCanAdvanceTheirCareersthroughPracticalExperiencewithPowerShellAutomation_0.png","tag":["Tech"],"readingTime":5},{"title":"맥OS 공격 매트릭스 IOPlatformExpertDevice를 사용하여 시스템 정보 수집하기 파트  2","description":"","date":"2024-05-27 12:24","slug":"2024-05-27-MacOSAttackMatrixGatheringSystemInformationusingIOPlatformExpertDevicePart2","content":"\n\n![Screenshot](/assets/img/2024-05-27-MacOSAttackMatrixGatheringSystemInformationusingIOPlatformExpertDevicePart2_0.png)\n\nmacOS 시스템의 복잡한 미로를 헤쳐 나가는 레드팀 오퍼레이터들은 현대의 디지털 탐험가로, 가치 있는 데이터를 찾기 위해 모든 구석구석을 탐색합니다. 그들의 사용 가능한 도구 가운데, ioreg 명령어는 어두운 방에서 플래시라이트처럼 반짝이며, 정확하고 명확한 방법으로 기기 하드웨어의 숨겨진 세부 정보를 밝혀내줍니다.\n\n# ioreg 명령어 마스터하기\n\nmacOS 시스템 진단의 핵심에는 ioreg 명령어가 있습니다. 이 명령어는 I/O Kit 레지스트리의 광대하고 상세한 세계를 해제하는 열쇠 역할을 합니다. 이 레지스트리는 macOS 시스템에 연결된 모든 장치의 정보를 카탈로그화한 대규모 도서관 역할을 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n`ioreg` 명령을 효과적으로 다루는 방법을 이해하는 것은 고고학자가 발굴 작업을 위해 적절한 도구를 선택하는 것과 유사합니다. 가장 자세한 통찰을 끄집어내기 위해 설정하는 방법은 다음과 같습니다:\n\n```js\nioreg -c IOPlatformExpertDevice -d 2\n```\n\n## 데이터 미로를 탐색하기 위한 필수 플래그\n\n- `ioreg`: 하드웨어 레지스트리의 심층을 탐색하는 것을 시작합니다.\n- `-c 클래스`: 특정 클래스의 장치를 대상으로 지정합니다. 방대한 도서관에서 특정 장르를 선택하는 것과 유사합니다. 깊은 시스템 통찰을 얻기 위해 IOPlatformExpertDevice를 찾아보세요.\n- `-d 깊이`: 장치 트리를 얼마나 깊게 파고들지 설정하며, 깊이 2로 설정하면 통찰을 얻을 정도로 충분하지만 압도적이지는 않습니다.\n- `-l`: 장치의 모든 가능한 세부 정보를 펼쳐서 속성의 매우 상세한 내러티브를 제공합니다.\n- `-r`: 하드웨어 트리의 관련 가지에 대해 검색을 집중시켜 불필요한 혼란을 피합니다.\n\n<div class=\"content-ad\"></div>\n\n# 예시 및 샘플 출력 설명\n\n가장 기본적인 명령어를 실행할 때 예상할 수 있는 샘플 출력은 다음과 같습니다:\n\n```js\n+-o IOPlatformExpertDevice <class IOPlatformExpertDevice, id 0x100000000,\nregistered, matched, active, busy 0 (0 ms), retain 10>\n{\n  \"IOPlatformUUID\" = \"12345678-1234-1234-1234567890AB\"\n  \"model\" = <\"MacBookPro15,1\">\n  \"serial-number\" = <\"C02XXXXXXXD1\">\n  \"IOPlatfomSerialNumber\" = \"C02XXXXXXXD1\"\n  ...\n}\n```\n\n이 명령어를 실행하면 IOPlatformExpertDevice에 대한 자세한 정보가 나타나며, 중요하고 종종 숨겨진 속성을 강조해 줍니다.\n\n<div class=\"content-ad\"></div>\n\n- IOPlatformUUID: 시스템을 고유하게 식별하는 디지털 지문 역할을 합니다.\n- Model: Mac의 청사진을 공개하여 특정 취약점을 정확히 파악하는 데 중요합니다.\n- Serial-Number: 기기의 새겨진 서명으로, 추적 및 인증에 중요합니다.\n- IOPlatformSerialNumber: 특수 하드웨어 확인에 사용되는 식별의 보조 기호입니다.\n- IOPlatformExpert: 하드웨어 구성 뒤에 숨은 설계자의 이름을 밝혀, 사용자 정의 설정을 알려줍니다.\n\n# Red Team 작전에서의 실제 시나리오\n\nioreg 명령어를 이용해 레드 팀은 디지털 자물쇠 제작자로 변신할 수 있습니다. 이를 통해 하드웨어 비밀을 밝히고, 시스템의 방어 메커니즘을 우회하거나 악용하는 키를 만들어낼 수 있습니다.\n\n- 대상 프로파일링: 대상 시스템의 특정 아키텍처에 대한 공격을 정밀하게 튜닝하는 것은 특수한 정교한 수트를 만드는 것과 같습니다.\n- 자산 무결성 확인: 하드웨어가 변조되지 않았는지 확인하는 것은 금고 속 금의 순도를 확인하는 것과 유사합니다.\n- 사용자 정의 악용 개발: 일부 악용은 시스템 하드웨어의 정확한 형태가 필요한데, 이는 자물쇠 디자인을 기반으로 열쇠를 만들어내는 것과 유사합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-27-MacOSAttackMatrixGatheringSystemInformationusingIOPlatformExpertDevicePart2_1.png)\n\n# 빠른 참조용 치트 시트\n\n- 명령 개요: ioreg -c IOPlatformExpertDevice -d 2: 시스템 하드웨어의 영혼에 대한 손전등.\n- 주요 플래그:\n  -c: 검사할 장치의 클래스를 선택합니다.\n  -d: 탐사 깊이를 설정합니다.\n  -l: 각 장치에 대한 상세 설명을 제공합니다.\n  -r: 초점을 선명하고 관련성 있게 유지합니다.\n- 중요한 출력물:\n  IOPlatformUUID: 고유 식별자.\n  Model: 장치 모델에 대한 세부 정보.\n  SerialNumber: 장치 일련 번호에 대한 정보.\n  IOPlatformSerialNumber: 점검 및 균형을 위해 필수적입니다.\n  IOPlatformExpert: 장치 구성 전문가에 대한 통찰.\n\n# 결론\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-27-MacOSAttackMatrixGatheringSystemInformationusingIOPlatformExpertDevicePart2_2.png)\n\nThe `ioreg` command is not just a tool; it's a gateway to the hidden chambers of macOS hardware information. For security professionals, mastering this command is akin to mastering the art of map-making, charting unknown territories, and uncovering secrets that lie beneath the surface of every macOS device.\n\n","ogImage":{"url":"/assets/img/2024-05-27-MacOSAttackMatrixGatheringSystemInformationusingIOPlatformExpertDevicePart2_0.png"},"coverImage":"/assets/img/2024-05-27-MacOSAttackMatrixGatheringSystemInformationusingIOPlatformExpertDevicePart2_0.png","tag":["Tech"],"readingTime":4},{"title":"화면 녹화를 GIF로 변환하는 방법 macOS에서  생산성 1","description":"","date":"2024-05-27 12:23","slug":"2024-05-27-HowtoconvertyourscreenrecordingstoGIFonmacOSProductivity1","content":"\n프론트엔드 개발자로서, Pull/Merge Requests, 이슈 또는 Slack에서 종종 스크린샷이나 비디오 녹화를 공유해야 할 때가 많습니다.\n\n그리고 Bitbucket과 같은 플랫폼은 이미지만 받아들이고 비디오는 받아들이지 않기 때문에 GIF가 좋은 대안이 될 수 있습니다.\n\n그래서 저는 최근에 비디오 화면 녹화를 GIF로 쉽게 변환하는 도구를 만들었습니다. 이 도구는 빠르게 작동하며 Bitbucket에서 허용되는 크기의 작은 GIF를 생성하면서도 고해상도를 유지합니다.\n\n결과물을 직접 확인해 보세요:\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*m8Y5EaajsmCXSZuswBiHCw.gif)\n\n# 설치\n\n라이브러리를 몇 개만 설치하면 됩니다:\n\n```js\nbrew install ffmpeg imagemagick\n# 만약 macOS 실리콘을 사용 중이라면\narch -arm64 brew install ffmpeg imagemagick\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 해당 Apple 바로 가기를 설치해주세요: [https://www.icloud.com/shortcuts/ec417cfcb32941f7aa9316b3c44c32ff](https://www.icloud.com/shortcuts/ec417cfcb32941f7aa9316b3c44c32ff)\n\n# 즐기세요!\n\nmacOS에서는 CMD+Shift+5를 사용하여 화면을 쉽게 녹화할 수 있어요.\n\n화면을 녹화하고 .MOV 비디오를 가지고 있다면, Finder의 컨텍스트 메뉴를 사용하여 GIF로 바꿀 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n<div>\n  <img src=\"/assets/img/2024-05-27-HowtoconvertyourscreenrecordingstoGIFonmacOSProductivity1_0.png\" />\n</div>\n\n배시 스크립트에서 GIF로 변환하는 옵션이 있습니다.\n\n자세한 내용은 여기에서 확인하실 수 있습니다: [https://github.com/friedrith/productivity/blob/master/convert-video-to-gif.md](https://github.com/friedrith/productivity/blob/master/convert-video-to-gif.md)\n\n만약 이 도구가 유용하다고 생각된다면, 이 저장소에 스타를 부탁드리거나 이 게시물 아래에 댓글을 남겨주세요.\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/0*n3UdPtw5l6xSikMW.gif)\n\n안녕하세요! 제 이름은 티볼트이고, Ux 엔지니어로 일하고 있습니다. Ux, 코드 기술, 생산성, 과학 소설 등에 열정을 가지고 있습니다. 매달 새로운 기사를 게시하고 있어요. 이런 주제에 관심이 있다면, 제 Medium 페이지를 팔로우해주세요: https://medium.com/@thibault-friedrich.\n","ogImage":{"url":"/assets/img/2024-05-27-HowtoconvertyourscreenrecordingstoGIFonmacOSProductivity1_0.png"},"coverImage":"/assets/img/2024-05-27-HowtoconvertyourscreenrecordingstoGIFonmacOSProductivity1_0.png","tag":["Tech"],"readingTime":2},{"title":"이상한 선택과 큰 숫자 어제 애플이 무엇을 했는지","description":"","date":"2024-05-27 12:22","slug":"2024-05-27-WeirdChoicesandBigNumbersWhatAppleGotuptoYesterday","content":"\n\n아래의 표 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n애플이 하는 일입니다. 다음 이벤트에서 몇 개의 제품을 발표할지를 고민하며 앉아 있는 동안, 그들은 실제로 발표할 두 개나 세 개의 제품을 준비하고 있습니다.\n\n나머지는 모두 기다릴 수 있어요 - 심지어 그게 계획 안에 있는 것이라면 말이죠.\n\n어제는 맥 이벤트가 될 것이라는 것은 이미 예상됐어요. 미안해요.\n\n어제의 급속한 이벤트에서 이 방식은 새로운 세 개의 칩, 새로운 맥북 프로, 마침내 업데이트된 24인치 아이맥을 가져왔습니다. 아, 그리고 전체적으로 어젠트의 가장 인상적인 것 중 하나인 아이폰으로 촬영된 쇼도 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n지난 몇 주 동안 풀어야 할 것이 많지만, 새로운 M3 칩과 그 안에 들어간 기계에 대한 내 초기 생각은 다음과 같아요.\n\n## 인텔 팬들\n\n어제, 내가 가장 좋아하는 커피숍 중 한 군데에서 빛나는 Apple 로고가 두 개가 아닌 한 개만 보았던 것을 분명히 기억해요.\n\n저는 이것을 좋아해요; 사람들이 가능한 한 오랫동안 자신의 맥을 유지하는 것을 좋아해요. 제가 이것을 직업으로 하고 있지 않았더라면, 제가도 똑같이 할 것 같아요. 맥은 끝이 다소 끝날 때까지 많이 지지 않을까요. 게다가 맥은 천문학적으로 비싸요. 그들은 또한 몇 년 동안 그대로 남아 있고, 일반적으로, 윈도우 기반 경쟁 상품을 훨씬 뛰어넘어요. 실제로 내 비디오의 댓글 섹션에 들어오는 대부분의 사람들은 그들의 인텔 맥을 애플의 자체 칩이 돌아가는 것으로 업그레이드해야 하는지 여부를 물었어요. 어젯밤의 라이브스트림에서 누군가가 2009년식 맥 프로를 아직 사용 중이라고 알려줬어요. 놀라워요.\n\n<div class=\"content-ad\"></div>\n\n애플은 이에 대해 과도하게 알고 있습니다; 공식 숫자는 찾을 수 없었지만 트위터에서는 설치된 맥의 50% 이상이 아직도 인텔 기계를 사용하고 있다는 이야기가 나왔습니다.\n\n제가 주로 보는 커피숍에서의 경험을 고려하면, 이것은 전혀 놀라운 일이 아닙니다. 그것이 어제 저녁에 애플이 계속해서 인텔 맥 사용자들을 언급한 이유도 설명해 주죠.\n\n\"M3 맥으로 업그레이드하는 것을 진지하게 고려해야 합니다.\" 계속 그렇게 말하더라구요. 부디.\n\n애플이 직면한 과제는 인텔 맥이 여전히 그 사람들에게 유용하게 사용되고 있으며, 새 맥 하드웨어의 천문학적인 가격 때문에 업그레이드를 요청하는 것이 매우 어려운 부분입니다. (나중에 그것에 대해서 이야기하겠습니다.)\n\n<div class=\"content-ad\"></div>\n\n나는 당신이 인텔 Mac 사용자인 경우 M3에 유혹을 받나요? 아래에서 참여해주세요!\n\n## 13인치 MacBook Pro와 Touch Bar, 안녕\n\n어젯밤, 우리는 마침내 13인치 MacBook Pro와 Touch Bar에 작별 인사를 했어요.\n\n더 이상 애플 웹사이트에 없어요. 없어져 버렸어요. 역사책에 넣었어요. 완전히 끝났어요.\n\n<div class=\"content-ad\"></div>\n\n좋은 소식이 있어요.\n\n그 자리를 대신해 새로운 14인치 M3 MacBook Pro 변형이 출시되었어요. 그 전 13인치 버전보다 $100 저렴한 가격에 8코어 CPU, 10코어 GPU, 8GB의 통합 메모리, 그리고 512GB SSD가 탑재되어 있어요. 또한 ProMotion 장착된 Liquid Retina 디스플레이를 갖추고 있는데, 이는 이전 베이스 모델 MacBook Pro보다 상당한 업그레이드예요.\n\n그 메모리 선택에 대한 우려는 제쳐두고, 3나노미터 기반 MacBook Pro의 시작 가격이 £1,699/$1,599 정도라니 꽤 괜찮은 가격이죠. 제 생각에는 13인치 버전만큼 인기가 많을거야, 아니면 그 이상의 인기를 끌지도 몰라요.\n\n## 이상한 선택들\n\n<div class=\"content-ad\"></div>\n\n팀과 사람들한테 정말 이상한 선택지 없이 Apple 이벤트는 없을거에요, 맞죠?\n\n어젠 그랬어요. 전혀 실망시키지 않았죠.\n\n크게는 중요하지 않을 수도 있는 작은 디테일이 있었어요. 예를 들어, 기본 사양인 M3 Pro는 M2 Pro 버전보다 GPU 코어가 두 개 더 적고, 업그레이드된 M3 Pro는 GPU 코어가 하나 더 적었어요.\n\n그리고 더 크고 머리 아픈 일들도 있었죠. 우리는 새로운 MacBook Pro와 업그레이드된 24인치 iMac을 갖고 있지만, Mac mini, Mac Studio, MacBook Air, 그리고 Mac Pro는 여전히 M2 플랫폼을 사용하고 있어요.\n\n<div class=\"content-ad\"></div>\n\n언제쯤 업데이트를 받을 거죠, Tim? 지금 그 기계 중 하나를 사는 건 정말 긴장되는 느낌이 들어요.\n\n하지만 애플이 한 가장 크고 이상한 결정 중, 그리고 이번 아침 소셜 미디어에서 모든 관심을 받고 있는 결정은 새로운 iMac에 여전히 Lightning 기반 주변장치를 포함한 것입니다. 맞아요 – Magic Mouse, Magic Trackpad 및 Magic Keyboard는 아직 USB-C 충전을 지원하도록 업데이트되지 않았어요.\n\n음?\n\n## 내가 산 것\n\n<div class=\"content-ad\"></div>\n\n애플 제품 출시 때 가장 짜증나는 일 중 하나는 새 제품이 얼마나 더 비싼지 알려고 할 때인데 (솔직히 말하면 요즘은 대게 그렇죠). 구 버전은 즉시 애플 스토어 웹사이트에서 제거되어, 옛 기억력이 우수하고 기록을 잘 보관한 소수만이 이전 가격을 기억할 수 있는 행운을 누릴 수 있게 됩니다.\n\n나는 단지 4시간의 잠만 자고 깼는데, 솔직히 오늘은 제대로 알아보기 귀찮아요. 하지만 새 MacBook Pro는 명백히 상위 사양 옵션으로 넘어갈수록 더 비싸게 느껴집니다.\n\n어젯밤, 나는 우주 블랙 (당연히) 14인치 MacBook Pro를 주문했어요. M3 Max 칩 (16코어 CPU 및 40코어 GPU)이 완전히 적용된 제품이고, 통합 메모리 48GB와 2TB SSD를 갖췄어요. 그 결과로 나타난 은행 잔고를 탕감시키는 총액은 4,199 파운드예요.\n\n누군가 구급차를 불러주세요.\n\n<div class=\"content-ad\"></div>\n\n그리고, 네, 나는 지금 다른 ￡200을 쓰는 게 좋았을까 생각 중이에요 (결국 몬폴리 머니잖아요)그리고 통합 메모리의 64GB로 업그레이드해야 했을지도 모르겠네요.\n\n어쨌든, 새로운 MacBook Pro가 11월에 내게로 날아올 예정이에요. 제 전체적인 생각은 그 때에 밝히겠죠. 또한, 최신 올인원 iMac 24인치 기본 제원을 주문했어요, 애플의 최신 기술로 900일 이상 어느 정도 발전했는지 살펴볼 겁니다.\n\n어제 이벤트 후에 많은 사람들이 궁금해할 질문은 올해 비싼 M2 기반 MacBook Pro를 구입한 것이 후회되는지 아닌지일 것이에요. 그 플랫폼이 오래 가지 않았군요.\n\n음, 긍정적인 마무리를 지어보죠. 구매한 것에 대해 기분 좋아해야 해요. 솔직히요. 그 이유로 구입했고, 여전히 슈퍼 빠른 머신이잖아요. 누가 알아요, 아마도 10년 후에도 M2를 사용하고 있는 사람으로써 커피숍에서 발견되는 사람이 될 수도 있으니까요!\n\n\n<div class=\"content-ad\"></div>\n\n# 가기 전에\n\n테크 콘텐츠 크리에이터의 주간 비하인드 신간 비디오를 보기 위해 뉴스레터 목록에 가입하세요!\n\n원문은 2023년 10월 31일에 https://markellisreviews.com에서 게시되었습니다.","ogImage":{"url":"/assets/img/2024-05-27-WeirdChoicesandBigNumbersWhatAppleGotuptoYesterday_0.png"},"coverImage":"/assets/img/2024-05-27-WeirdChoicesandBigNumbersWhatAppleGotuptoYesterday_0.png","tag":["Tech"],"readingTime":4},{"title":"맥북 MacOS 키보드 단추로 스플릿 화면 창을 화면 왼쪽 또는 오른쪽으로 정렬","description":"","date":"2024-05-27 12:21","slug":"2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen","content":"\nWindows 운영 체제는 창을 분할 화면으로 이동하는 단축키를 Windows 키 + 왼쪽/오른쪽 화살표를 사용하여 수행할 수 있습니다. MacOS에서는 어떤 창의 전체 화면(녹색) 버튼 위에 마우스 포인터를 가져다 놓고 옵션을 선택하여 이 작업을 수행할 수 있습니다.\n\n![MacOS Keyboard Shortcuts for Split Screen](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_0.png)\n\n그러나 Mac OS에서는 유료 서드 파티 앱을 사용하지 않고는 이에 대한 키보드 단축키를 찾지 못했습니다. 하지만 직접 키보드 단축키를 만들 수 있다는 사실을 알게 되었습니다. 다음은 그 방법입니다:\n\n# 1. 키보드 설정으로 이동하기.\n\n<div class=\"content-ad\"></div>\n\nMac에서는 Apple 메뉴를 선택한 후 `시스템 환경 설정`을 클릭하고, 키보드를 클릭한 다음 가운데에 있는 `키보드 단축키` 탭을 클릭하세요.\n\n![이미지](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_1.png)\n\n![이미지](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_2.png)\n\n## 2. 앱 단축키 추가\n\n<div class=\"content-ad\"></div>\n\n왼쪽의 앱 단축키를 선택한 다음, 추가 버튼 +을 클릭하세요.\n\n![이미지](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_3.png)\n\n# 3. 화면 왼쪽에 타일 창 단축키 추가\n\n애플리케이션: \"모든 애플리케이션\" 유지합니다.\n메뉴 제목: \"화면 왼쪽에 타일 창\"을 입력합니다(모든 애플리케이션의 창 메뉴에있는 메뉴 항목 텍스트이기 때문에 정확히 그렇게 입력해야 합니다).\n키보드 단축키: Control, Command, 왼쪽 화살표 키 조합을 동시에 누릅니다. 아래 스크린샷을 참조하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![img](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_4.png)\n\n(참고: 다른 단축키를 선택할 수 있지만, 우리는 Command, 왼쪽 화살표 조합이 작동하지 않고 Option, Command, 왼쪽 화살표 조합도 Chrome 애플리케이션에서 작동하지 않는다는 것을 발견했습니다. 또한 시프트를 사용하지 마십시오. 그렇게 하면 창 타일링 효과가 슬로우 모션으로 발생합니다.)\n\n지금 이렇게 되어 있어야 합니다:\n\n![img](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n# 4. 화면 오른쪽에 타일 창 추가하기 바로 가기\n\n단계 #2와 #3을 다시 반복하세요. 이번에는 Left를 Right로 바꿉니다.  \n애플리케이션: \"모든 애플리케이션\" 유지합니다.  \n메뉴 제목: \"화면 오른쪽에 타일 창\"을 입력하세요 (이는 모든 애플리케이션의 창 메뉴 아래의 메뉴 항목 텍스트이기 때문에 정확히 그대로 입력해야 합니다).  \n키보드 바로 가기: 동시에 Control, Command, 오른쪽 화살표를 누르세요. 스크린샷은 아래에서 확인하세요.\n\n![스크린샷](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_6.png)\n\n(참고: 다른 바로 가기를 선택할 수 있지만, Command, 오른쪽 화살표 조합은 작동하지 않고 Chrome 애플리케이션에 대해서는 Option, Command, 오른쪽 화살표 조합도 작동하지 않는 것으로 확인되었습니다. 또한 Shift 사용을 피하십시오. 왜냐하면 Shift를 사용하면 타일 창 효과가 느리게 재생되기 때문입니다.)\n\n<div class=\"content-ad\"></div>\n\n이렇게 수정해 보세요:\n\n![Image](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_7.png)\n\n## 5. 단축키 테스트\n\nSafari 또는 Chrome과 같은 응용 프로그램을 엽니다. 창 메뉴를 선택합니다. 메뉴 항목에 키보드 단축키가 추가되었는지 확인하면 (\"Title Window to Left of Screen\" 및 \"Tile Window to Right of Screen\"), 단축키가 성공적으로 추가된 것입니다.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_8.png)\n\n이제 한 번 시도해 보세요! Control, Command, 왼쪽/오른쪽 화살표를 누르면 창이 왼쪽이나 오른쪽으로 타일될 것입니다.\n\n축하합니다! 이제 Mac OS 창을 화면 왼쪽이나 오른쪽에 타일하는 키보드 단축키를 성공적으로 추가했습니다.\n\n기술, 비즈니스 및 리더십 관련 팁을 얻으려면 제 팔로우를 해주세요.\n","ogImage":{"url":"/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_0.png"},"coverImage":"/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_0.png","tag":["Tech"],"readingTime":3},{"title":"내 첫 번째 홈 서버 만들기","description":"","date":"2024-05-27 12:19","slug":"2024-05-27-Creatingmyfirsthomeserver","content":"\n\n소프트웨어 및 제품 개발자로 일하고 있는데, 최근 몇 달간 컴퓨팅의 하드웨어/인프라 구성 요소에 대해 더 많이 배우고 있어요. 지식이 직접적인 영향을 미치지 않더라도, 일상적인 업무에 굉장히 중요한 컴퓨팅에 대한 일반적인 이해를 가지는 것이 도움이 될 것 같아요.\n\n집에서 예산에 맞는 서버를 만들어보기로 결심했어요.\n\n처음 떠오른 생각은 Raspberry Pi Zero 2 W를 Pi-hole 서버로 사용하는 것이었어요. 기술적으로는 작동했지만, 느리고 번잡스럽고 다른 서비스를 실행하기 힘들었어요. 하나의 서비스를 위해 심지어 Pi Zero만큼 작은 기기를 전용으로 사용하는 것은 말이 되지 않았어요.\n\n그래서 저는 주변에 버려져 있는 고장난 노트북을 살펴보기로 결정했어요. i5가 장착된 오래된 HP 노트북 g5 250이 있었어요. 몇 년 동안 사용하지 않은 이유는 배터리가 고장나고 두 번째 교체 배터리도 망가지고 하드 드라이브도 망가졌기 때문이에요. 그 노트북은 상태가 좋지 않아 보였어요. 하지만 가동시킬 수 있다면, 여러 서비스를 운영할 수 있는 저전력 서버로 완벽하지 않을까 생각했어요. 그래서 수리에 도전했죠!\n\n<div class=\"content-ad\"></div>\n\n# 노트북 수리하기\n\n## 하드 드라이브 교체하기\n\n운 좋게도 주변에 고장난 노트북이 하나 더 있었어요, 에이서 V5 (버리기 아까운 기술 무덤에 살고 있는데요, 죄송해요). 에이서에서 2.5인치 SATA 드라이브를 꺼내 HP 노트북에 꽂았어요. 그러면서 서버 구축에 또 다른 용도를 더할 수 있게 됐어요... 드라이브에서 옛날 영화들을 발견해서 백업하고, 이후 서버 구축에 활용할 거예요 (자세한 내용은 이따가요!)\n\n## 우분투로 윈도우 교체하기\n\n<div class=\"content-ad\"></div>\n\n이것은 조금 논란적인 의견이 될 것 같아요... HP에 꽂은 드라이브에는 Windows 8이 설치되어 있었어요. 저는 Windows 운영 체제(OS)를 업데이트하거나 버전 8을 유지할 수도 있었지만, 나이가 든 하드웨어와 750GB 하드 드라이브만 가진 노트북을 위해 가벼운 OS가 필요했어요. 특히 하드 드라이브 한 개가 저장소와 OS 부팅 모두로 사용된다는 점을 감안하면요. 그래서 리눅스 길을 선택하기로 결정했어요. 리눅스를 사용해 본 적이 없어서 Ubuntu를 선택했어요. 초보자에게 좋은 선택인 것 같았거든요.\n\n과정은 간단했어요. Ubuntu용 ISO 파일을 다운로드하고, Rufus를 사용해 USB 드라이브에 플래시 메모리하고, 그 USB 드라이브를 노트북에 꽂고, 노트북 BIOS로 부팅한 후 OS를 설치했어요.\n\n여러분 중 기술에 능통한 분들은 이미 Ubuntu 서버가 아닌 Ubuntu 데스크탑을 선택한 이유에 궁금해할 수도 있어요. 단순한 답은 저는 처음 시도하는 것이라 GUI를 통해 쉽게 설정하고 유지보수하기 위해서였어요. 예전에 소프트웨어 공학 강의 중 한 교수님으로부터 소중한 약어를 배운 적이 있어요. 그것을 자주 뇌물에 하죠: KISS. Keep it simple, stupid.\n\n<div class=\"content-ad\"></div>\n\n## 배터리를 완전히 제거하는 것\n\n조금 위험한 결정일 수 있지만, 이전에 싸게 구입한 써드 파티 배터리가 잘 안 되었던 경험이 있어서 공식 HP 배터리로 교체하는 것은 이번 빌드에 예산적으로 부담스러웠습니다. 이미 가지고 있는 것을 활용하고 싶었고, 그래서 서버를 계속 24시간 7일 가동할 예정이기 때문에 계속해서 전원을 사용했습니다.\n\n# 서버 설정하기\n\n작은 서버 구성을 연구하던 중 Zima Board라는 제품과 그 GUI 시스템인 CasaOS라는 오픈 소스 소프트웨어를 발견했습니다. 이 소프트웨어는 쉽게 Linux에서 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nCasa는 서버 관리에 대한 완벽한 초보자용 안내서입니다. 노트북 구성이 24/7 전원으로 설정되었으며, Casa를 터미널에 설치했습니다 (추가 정보: 리눅스의 터미널 및 명령어의 편리함은 윈도우즈와 비교할 때 매우 인상적입니다).\n\n처음에 약간의 어려움이 있었는데, Casa의 설치는 끝날 때 사용할 수 있는 IP 주소를 알려줘야 한다고 합니다. 나에게는 터미널에서 이러한 정보가 어떤 이유로든 표시되지 않았지만, 운 좋게도 라우터의 이벤트 로그에서 IP를 찾을 수 있었습니다.\n\n이제 Casa가 내 시스템에 설치되어 실행 중이었고, 내가 다운로드할 앱을 선택하고 다른 것을 연구하기만 하면 됐습니다. Casa는 기본적으로 Docker 컨테이너의 시각화입니다. 이전에 Docker에 대한 기본 경험을 해봤는데, 가벼우면서도 간단하게 서비스를 실행할 수 있는 Docker의 방법을 좋아합니다. Casa는 이를 더 쉽게 만들어줍니다.\n\n![이미지](/assets/img/2024-05-27-Creatingmyfirsthomeserver_1.png)\n\n<div class=\"content-ad\"></div>\n\n저도 Casa의 대시보드가 매끄럽고 초보자 친화적이라는 점을 좋아해요. 그리고 독립된 IP에서 호스팅되어 있어서 집 내 모든 기기에서 대시보드(그에 따라 서버에서 실행 중인 모든 서비스)에 접속할 수 있어요. 시스템을 설정하고 나서, 스마트 TV에서 IP에 접속하여 소파에서 편안하게 나머지 설정을 마쳤어요!\n\n![이미지](/assets/img/2024-05-27-Creatingmyfirsthomeserver_2.png)\n\n## 실행 중인 서비스들\n\n- Pi-hole — 네트워크 전체 광고 차단 프로그램.\n- Jellyfin — 자신의 미디어 파일에 대한 Netflix 스타일 경험을 제공하는 미디어 플레이어. 하드 드라이브에 있던 옛 영화 파일들에 대해 진정한 게임 체인저가 되었어요. 이 서비스를 통해 미디어 서버로 사용할 수 있다는 것에 정말 만족해요.\n- qBittorent — 파일을 토렌트하는 데 사용돼요.\n- Wireguard — VPN 프로토콜이지만 설정에 문제가 있어서 다시 시도해봐야 할 것 같아요.\n\n<div class=\"content-ad\"></div>\n\n## 향후 개선 사항\n\n- 반드시 Wireguard를 재구성하거나 대체할 수 있는 방법을 찾아야 할 것 같아요.\n- 이 기기의 저장 공간을 늘리거나 저장을 위한 별도의 NAS를 구매하는 사이에서 고민 중이에요.\n- Docker의 세계를 더 탐험해보려고 해요. Casa에는 쉽게 Docker 컨테이너를 설정해주는 '앱'이 묶여 있지만, 원하는 Docker 서비스를 원하는대로 설치할 수도 있어요.\n- 서버에서 웹 사이트를 호스팅하는 것이 좋을 것 같아요!","ogImage":{"url":"/assets/img/2024-05-27-Creatingmyfirsthomeserver_0.png"},"coverImage":"/assets/img/2024-05-27-Creatingmyfirsthomeserver_0.png","tag":["Tech"],"readingTime":4}],"page":"10","totalPageCount":11,"totalPageGroupCount":1,"lastPageGroup":11,"currentPageGroup":0},"__N_SSG":true}