{"pageProps":{"post":{"title":"작고 빠른 머신 러닝 TinyML  서포트 벡터 머신 분류기","description":"","date":"2024-06-19 02:27","slug":"2024-06-19-TinyMLSupportVectorMachinesClassifier","content":"\n\n수학적 기초부터 엣지 구현까지\n\n## 소셜 미디어:\n\n👨🏽‍💻 Github: thommaskevin/TinyML (github.com)\n👷🏾 Linkedin: Thommas Kevin | LinkedIn\n📽 Youtube: Thommas Kevin — YouTube\n👨🏻‍🏫 연구 그룹: Conecta.ai (ufrn.br)\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_0.png)\n\n<div class=\"content-ad\"></div>\n\n서포트 벡터 머신(SVMs) 또는 머신 러닝에서는 서포트 벡터 네트워크라고도 하는 SVMs는 학습 알고리즘을 갖춘 지도형 최대 마진 모델입니다. 이들은 분류와 회귀 분석을 위해 데이터를 분석합니다. Vladimir Vapnik과 동료들은 AT&T 벨 연구소에서 SVMs를 개발했습니다. SVMs는 Vapnik과 Chervonenkis가 1974년에 제안한 VC 이론과 통계 학습 프레임워크에 근거한 매우 연구된 모델 중 하나입니다.\n\n# 1 — 서포트 벡터 머신 이론\n\n## 1.1 — 선형 이진 분류\n\n기본적으로 SVM의 역할은 분리 가능한 데이터 집합에 대해 클래스나 레이블 간의 가장 효율적인 분리 경계를 식별하는 것입니다. SVM의 맥락에서 클래스를 완전히 분리할 수 있는 다양한 초평면들이 잠재적인 분리 경계로 간주됩니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 각 입력 xi가 D개의 속성(즉, D 차원으로 구성)을 가지고 있고 -1 또는 +1 중 하나의 클래스에 속하는 값 yi를 갖는 L개의 학습 포인트가 있습니다. 즉, 우리의 훈련 데이터는 다음과 같습니다.\n\n![training data](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_1.png)\n\n여기서 데이터가 선형적으로 분리 가능하다고 가정합니다. 즉, D = 2 일 때 x1 대 x2 그래프에 두 클래스를 분리하는 선을 그릴 수 있고, D ` 2 일 때 x1, x2...xD 그래프에 초평면을 그릴 수 있습니다.\n\n이 초평면은 w · x + b = 0으로 설명할 수 있습니다. 여기서:\n\n<div class=\"content-ad\"></div>\n\n- w는 초평면에 수직입니다.\n- b/||w||은 초평면으로부터 원점까지의 수직 거리입니다.\n\n서포트 벡터(Support Vectors)는 분리 초평면에 가장 가까운 예제들을 의미하며, 서포트 벡터 머신(SVM)의 목표는 이 초평면을 가능한 한 두 클래스의 가장 가까운 멤버와 멀리떨어지도록 방향을 조절하는 것입니다.\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_2.png)\n\n그림 1을 참조하면, SVM을 구현하는 것은 변수 w와 b를 선택하여 학습 데이터를 아래와 같이 설명할 수 있도록 하는 것으로 요약됩니다:\n\n<div class=\"content-ad\"></div>\n\n- xi · w + b ≥ +1 for yi = +1\n- xi · w + b ≤ −1 for yi = −1\n\n이러한 방정식은 다음과 같이 결합될 수 있습니다:\n\nyi(xi · w + b) − 1 ≥ 0 ∀i\n\n이제 분리 초평면에 가장 가까이 있는 점, 즉 서포트 벡터(도표에서 원으로 표시됨)만 고려한다면, 이 점이 있는 두 평면 H1과 H2는 다음과 같이 나타낼 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n표를 마크다운 형식으로 변경해주세요.\n\n\n| xi · w + b = +1 for H1 |\n|------------------------|\n| xi · w + b = −1 for H2 |\n\nFigure 1을 참고하여, d1은 H1로부터 초평면까지의 거리를 나타내고, d2는 H2로부터의 거리를 나타냅니다. H1과 H2로부터의 초평면의 등거리는 d1 = d2로 정의되며, 이를 SVM의 여백이라고 합니다. 초평면을 가능한 한 Support Vectors로부터 최대한 멀리 위치시키기 위해 이 여백을 최대화해야 합니다.\n\n간단한 벡터 기하학에 따르면, 여백은 (1/||w||)와 같고, 이를 최대화하기 위해서는 (1.3)의 제약 조건 하에 찾아야 할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![TinyMLSupportVectorMachinesClassifier_3](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_3.png)\n\nkwk을 최소화하는 것은 (0.5*||w||²)을 최소화하는 것과 동일한 것이며, 이 용어의 사용은 나중에 이차 프로그래밍(QP) 최적화를 수행할 수 있게 합니다. 따라서 우리는 다음을 찾아야 합니다:\n\n![TinyMLSupportVectorMachinesClassifier_4](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_4.png)\n\n이 최소화의 제약 사항을 고려하기 위해 Lagrange 배수 α를 할당해야 합니다. 여기서 αi ≥ 0 ∀i 여야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_5.png)\n\n우리는 최소화하는 w와 b 및 최대화하는 α를 찾고 싶습니다 (αi ≥ 0 ∀i를 유지하면서). 이를 위해 LP를 w와 b에 대해 미분하여 도함수를 0으로 설정할 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_6.png)\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_7.png)\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_8.png)\n\n이 새로운 제약 조건 LD는 주 기본 LP의 이중 형식으로 참조됩니다. 중요한 점은 이 이중 형식이 각 입력 벡터 xi의 내적만 계산하면 되므로 커널 트릭에서 중요하다는 점입니다.\n\nLP를 최소화하는 것에서 LD를 최대화하는 것으로 전환한 후, 우리는 다음을 찾아야 합니다:\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_9.png)\n\n\n<div class=\"content-ad\"></div>\n\n이것은 볼록 이차 최적화 문제이며 QP 솔버를 실행하여 α를 반환하고 (1.10)로부터 w를 제공받습니다. 남은 것은 b를 계산하는 것입니다.\n\n(1.11)을 만족하는 어떤 데이터 포인트는 지지 벡터 xs가 될 것이며 다음과 같은 형식을 갖습니다:\n\n![Support Vector](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_10.png)\n\n(1.10)을 대입하는 것입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_11.png)\n\n서포트 벡터의 지수 집합을 나타내는 S입니다. S는 αi ` 0인 지수 i를 찾아 결정됩니다. ys로 곱하고 (1.1) 및 (1.2)에서 ys² = 1을 사용하여:\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_12.png)\n\n임의의 서포트 벡터 xs를 사용하는 대신, S에 속하는 모든 서포트 벡터를 평균하는 것이 더 나은 방법입니다.\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_13.png)\n\n우리는 이제 서포트 벡터 머신을 정의하는 분리 초평면의 최적 방향을 결정하는 변수 w와 b를 가지고 있습니다.\n\n## 1.2 — 선형적으로 분리되지 않는 데이터의 분류\n\n완전히 선형적으로 분리되지 않는 데이터를 다룰 수 있도록 SVM 방법론을 확장하기 위해 (1.1)과 (1.2)의 제약 조건을 약간 완화하여 잘못 분류된 포인트를 허용합니다. 이는 긍정적인 slack 변수 ξi, i = 1, . . . L을 도입함으로써 수행됩니다:\n\n<div class=\"content-ad\"></div>\n\n아래의 내용을 다음과 같이 결합할 수 있어요:\n\n\n![img](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_15.png)\n\n![img](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_16.png)\n\n\n<div class=\"content-ad\"></div>\n\n이 소프트 마진 SVM에서, 마진 경계의 잘못된 쪽에 있는 데이터 포인트는 그로부터의 거리에 따라 증가하는 패널티를 받습니다. 우리는 오분류의 수를 줄이려고 하기 때문에, 이전의 목적 함수(1.6)를 적응하기 위한 합리적인 방법은 다음과 같습니다:\n\n![그림](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_17.png)\n\n여기서 매개변수 C는 여유 변수의 패널티와 마진의 크기 사이의 교환을 제어합니다. 라그랑지안으로 재정립하는 것은, w, b 및 ξi에 대해 최소화하고 α에 대해 최대화해야하는 함수를 찾아야 합니다 (여기서 αi ≥ 0, µi ≥ 0 ∀i):\n\n![그림](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_18.png)\n\n<div class=\"content-ad\"></div>\n\nw, b 및 ξi에 대해 미분하고 도함수를 0으로 설정합니다:\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_19.png)\n\n이를 대입하면, LD는 이전의 (1.14)와 동일한 형식을 가집니다. 그러나 (2.9)와 µi ≥ 0 ∀i 함께하면, α ≥ C를 함의합니다. 따라서 우리는 다음을 찾아야 합니다:\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_20.png)\n\n<div class=\"content-ad\"></div>\n\n그런 후에 b는 (1.6)과 동일한 방법으로 계산됩니다. 그러나 이 경우 b를 계산하기 위해 사용된 Support Vectors 집합은 0 ` αi ` C인 i의 인덱스를 찾아 결정됩니다.\n\n# 2. 하이퍼파라미터 조정: 커널, 정규화, 감마 및 마진.\n\n## 2.1 — 커널\n\n선형 분리 가능한 데이터에 SVM을 적용할 때 입력 변수의 내적으로 행렬 H를 생성하는 방식부터 시작했습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_21.png)\n\nk(xi, xj)는 Kernel Functions라는 함수 패밀리의 예시입니다 (k(xi, xj) = (xi^T)*(xj)가 선형 커널로 알려져 있습니다). 커널 함수의 집합은 두 벡터의 내적을 계산하는 것을 기반으로 하고 있어서 (4.2)의 변형으로 구성되어 있습니다. 이것은 함수들이 어떤 잠재적으로 비선형 특징 매핑 함수 x → φ(x)에 의해 더 높은 차원의 공간으로 다시 구성될 수 있다는 것을 의미합니다. 이는 매핑된 입력들의 내적만 계산하면 되기 때문에 우리는 명시적으로 φ를 계산할 필요가 없다는 것을 뜻합니다.\n\n이 커널 트릭이 유용한 이유는 입력 x의 공간에서 선형적으로 분류/회귀할 수 없는 많은 문제들이 존재하기 때문입니다. 이는 적합한 매핑 x→ φ(x)가 주어진 상태에서 더 높은 차원의 특징 공간에 있을 수 있기 때문입니다.\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_22.png)\n\n\n<div class=\"content-ad\"></div>\n\nFigure 3를 참조하면, 우리가 우리의 커널을 다음과 같이 정의한다면:\n\n![Kernel](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_23.png)\n\n그러면 2차원 데이터 공간 x에서 선형적으로 분리되지 않는 데이터 집합(그림 3의 좌측)은 이 비선형 커널 함수에 의해 암시적으로 정의된 비선형 피처 공간(그림 3의 우측)에서 분리될 수 있습니다. 이 커널 함수는 Radial Basis Kernel로 알려져 있습니다.\n\n분류 및 회귀를 위한 다른 인기 있는 커널로는 다항식 커널이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 [TinyMLSupportVectorMachinesClassifier_24.png] 이미지가 있는 표입니다.\n\n![TinyMLSupportVectorMachinesClassifier_24.png](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_24.png)\n\n아래는 Markdown 형식으로 [TinyMLSupportVectorMachinesClassifier_25.png] 이미지가 있는 표입니다.\n\n![TinyMLSupportVectorMachinesClassifier_25.png](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_25.png)\n\n여기서 a와 b는 커널의 동작을 정의하는 매개변수입니다.\n\n## 2.2 — 정규화\n\n<div class=\"content-ad\"></div>\n\n정규화 매개변수(파이썬의 sklearn 라이브러리에서 C 매개변수로 자주 표현됨)는 SVM 최적화에 각 훈련 예제를 잘못 분류하고 싶지 않은 정도를 알려줍니다.\n\nC 값이 큰 경우 최적화는 모든 훈련 포인트를 올바르게 분류하는 더 나은 작은 마진의 초평면을 선택할 것입니다. 반대로, C 값이 매우 작으면 옵티마이저는 더 큰 마진 분리 초평면을 찾아 더 많은 포인트를 잘못 분류하더라도 선택할 것입니다.\n\n아래 이미지는 두 가지 다른 정규화 매개변수의 예시입니다. 왼쪽 이미지는 낮은 정규화 값으로 인해 일부 오분류가 있습니다. 높은 값은 오른쪽 이미지와 같은 결과를 낳습니다.\n\n<div class=\"content-ad\"></div>\n\n## 2.3 — 감마\n\n감마 매개변수는 단일 학습 예제의 영향이 얼마나 멀리 미치는지를 정의하며, 낮은 값은 '멀리', 높은 값은 '가까이'를 의미합니다. 다시 말해, 낮은 감마 값에서는 확실한 분리 선에서 멀리 떨어진 점들이 분리 선 계산에 고려됩니다. 반면 높은 감마는 분리 선에 가까운 점들이 계산에 고려된다는 것을 의미합니다.\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_27.png)\n\n## 2.4 — 여백\n\n<div class=\"content-ad\"></div>\n\n표 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n!pip install micromlgen\n```\n\n2. 라이브러리 가져오기\n\n```js\nfrom micromlgen import port\nimport pandas as pd\nimport plotly.graph_objects as go\nimport numpy as np\nimport plotly.express as px\n```\n\n```js\nfrom sklearn.svm import SVC\nfrom sklearn.calibration import LabelEncoder\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import metrics\n```\n\n<div class=\"content-ad\"></div>\n\n3 - 데이터셋 로드\n\n아이리스 데이터셋은 머신 러닝과 통계 분야에서 고전적인 데이터셋입니다. 이는 1936년 Sir Ronald A. Fisher에 의해 도입되었으며 판별 분석의 예시로 사용되었습니다. 이 데이터셋은 교육 목적으로 자주 사용되며 패턴 분류 실습의 일반적인 시작 지점입니다.\n\n속성:\n\n- 꽃받침 길이 (센티미터)\n- 꽃받침 너비 (센티미터)\n- 꽃잎 길이 (센티미터)\n\n<div class=\"content-ad\"></div>\n\n종:\n\n- 0 — 세토사\n- 1 — 버시컬러\n\n```js\n# 아이리스 데이터셋 불러오기\ndata = load_iris()\n```\n\n```js\n# 데이터프레임 생성\ndf_iris = pd.DataFrame(data.data, columns=data.feature_names)\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n# DataFrame에 대상 변수를 추가합니다\ndf_iris['target'] = data.target\n```\n\n```js\n# NaN 값을 제거합니다\ndf = df_iris.dropna(axis='rows') # NaN 제거\n```\n\n```js\n# DataFrame을 표시합니다\nprint(df_iris.head())\n```\n\n```js\ndf = df_iris.iloc[:100, 1:4]\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nX=df.to_numpy()\n```\n\n```js\n# 레이블을 정수 유형으로 변환합니다: Setosa = 0, Versicolor = 1\ny=df_iris.iloc[:100,-1]\ny = LabelEncoder().fit_transform(y)\n```\n\n4 - 데이터셋 시각화\n\n```js\nfig = go.Figure()\n```\n\n<div class=\"content-ad\"></div>\n\n\n```js\nfig.add_trace(go.Scatter3d(x=df['sepal width (cm)'], y= df['petal length (cm)'], z=df['petal width (cm)'], mode='markers', marker=dict(color='blue')))\n```\n\n```js\nfig.update_layout(scene=dict(xaxis_title='꽃 받침 길이 (cm)', yaxis_title='꽃 받침 너비 (cm)', zaxis_title='꽃 잎 너비 (cm)'),\n                  scene_camera=dict(eye=dict(x=1.87, y=0.88, z=-0.64)),\n                  width=1000, height=600)\n```\n\n<img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_29.png\" />\n\n5 — 훈련 및 테스트 데이터로 분할\n\n\n<div class=\"content-ad\"></div>\n\n```js\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n```\n\n6. Create the classification model\n\n```js\nmodel = SVC(gamma=0.0000001, kernel='linear')\n```\n\n7. Train the model\n\n\n<div class=\"content-ad\"></div>\n\n```js\nmodel.fit(X_train, y_train)\n```\n\n8 — 훈련 데이터를 사용하여 모델 평가\n\n```js\ntraining_predict = model.predict(X_train)\n```\n\n```js\nprint(metrics.classification_report(y_train, training_predict, digits = 3))\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_30.png\" />\n\n```js\nprint(metrics.confusion_matrix(y_train, training_predict))\n```\n\n<img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_31.png\" />\n\n```js\nprint(f'Model accuracy: {round(metrics.accuracy_score(y_train, training_predict)*100,2)}%')\n```\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_32.png)\n\n9 — Hyperlane Train Data Visualization\n\n```js\nx_grid, y_grid = np.meshgrid(np.linspace(X_train[:, 0].min(), X_train[:, 0].max(), 100),\n                             np.linspace(X_train[:, 1].min(), X_train[:, 1].max(), 100))\nz_grid = np.zeros_like(x_grid)\n```\n\n```js\nfor i in range(len(x_grid)):\n    for j in range(len(y_grid)):\n        z_grid[i, j] = model.decision_function([[x_grid[i, j], y_grid[i, j], 0]])\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nfig = go.Figure()\n```\n\n```js\nfig.add_trace(go.Scatter3d(x=X_train[:, 0], y=X_train[:, 1], z=X_train[:, 2], mode='markers',\n                           marker=dict(size=5, color=y_train, opacity=0.7), name='Training Data'))\n```\n\n```js\nfig.add_trace(go.Surface(z=z_grid, x=x_grid, y=y_grid, opacity=0.5, colorscale='Bluered_r'))\n```\n\n```js\nfig.update_layout(scene=dict(xaxis_title='Sepal Width (cm)',\n                             yaxis_title='Petal Length (cm)',\n                             zaxis_title='Petal Width (cm)'))\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nfig.update_layout(width=1000, height=600)\n```\n\n```js\nfig.show()\n```\n\n<img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_33.png\" />\n\n10 — 테스트 데이터로 모델 평가하기\n\n<div class=\"content-ad\"></div>\n\n```js\ntest_predict = model.predict(X_test)\n```\n\n```js\nprint(metrics.classification_report(y_test, test_predict, digits = 3))\n```\n\n![Image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_34.png)\n\n```js\nprint(metrics.confusion_matrix(y_test, test_predict))\n```\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_35.png)\n\n```js\nprint(f'모델 정확도: {round(metrics.accuracy_score(y_test, test_predict)*100,2)}%')\n```\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_36.png)\n\n11 — 하이퍼플레인 테스트 데이터 시각화\n\n\n<div class=\"content-ad\"></div>\n\n```js\nx_grid, y_grid = np.meshgrid(np.linspace(X_test[:, 0].min(), X_test[:, 0].max(), 100),\n                             np.linspace(X_test[:, 1].min(), X_test[:, 1].max(), 100))\nz_grid = np.zeros_like(x_grid)\n```\n\n```js\nfor i in range(len(x_grid)):\n    for j in range(len(y_grid)):\n        z_grid[i, j] = model.decision_function([[x_grid[i, j], y_grid[i, j], 0]])\n```\n\n```js\nfig = go.Figure()\n```\n\n```js\nfig.add_trace(go.Scatter3d(x=X_test[:, 0], y=X_test[:, 1], z=X_test[:, 2], mode='markers',\n                           marker=dict(size=5, color=y_test), name='Training Data'))\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nfig.add_trace(go.Surface(z=z_grid, x=x_grid, y=y_grid, opacity=0.5, colorscale='Bluered_r'))\n```\n\n```js\nfig.update_layout(scene=dict(xaxis_title='꽃받침 너비 (cm)',\n                             yaxis_title='꽃잎 길이 (cm)',\n                             zaxis_title='꽃잎 너비 (cm)'))\n```\n\n```js\nfig.update_layout(width=1000, height=600)\n```\n\n```js\nfig.show()\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_37.png\" />\n\n12 — 마이크로컨트롤러에 구현될 모델 얻기\n\n```js\nprint(port(model))\n```\n\n```cpp\n#pragma once\n#include <cstdarg>\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class SVM {\n                public:\n                    /**\n                    * 특징 벡터에 대한 클래스 예측\n                    */\n                    int predict(float *x) {\n                        float kernels[3] = { 0 };\n                        float decisions[1] = { 0 };\n                        int votes[2] = { 0 };\n                        kernels[0] = compute_kernel(x,   3.4  , 1.9  , 0.2 );\n                        kernels[1] = compute_kernel(x,   3.3  , 1.7  , 0.5 );\n                        kernels[2] = compute_kernel(x,   2.4  , 3.3  , 1.0 );\n                        float decision = -0.833910342285;\n                        decision = decision - ( + kernels[0] * -0.31945543931  + kernels[1] * -0.240101867421 );\n                        decision = decision - ( + kernels[2] * 0.559557306731 );\n                        return decision > 0 ? 0 : 1;\n                    }\n                protected:\n                    /**\n                    * 특징 벡터와 서포트 벡터 사이의 커널 계산.\n                    * 커널 유형: 선형\n                    */\n                    float compute_kernel(float *x, ...) {\n                        va_list w;\n                        va_start(w, 3);\n                        float kernel = 0.0;\n                        for (uint16_t i = 0; i < 3; i++) {\n                            kernel += x[i] * va_arg(w, double);\n                        }\n                        return kernel;\n                    }\n                };\n            }\n        }\n    }\n```\n\n<div class=\"content-ad\"></div>\n\n다음은 테이블 태그를 마크다운 형식으로 변경합니다.\n\n13 — .h 파일에 템플릿을 저장합니다\n\n```js\nwith open('./SVMClassifier/SVMClassifier.h', 'w') as file:\n    file.write(port(model))\n```\n\n14 — 아두이노 스케치 완료\n\n아래와 같이 아두이노 스케치에 \"SVMClassifier.h\" 파일을 포함하세요:\n\n<div class=\"content-ad\"></div>\n\n\n```js\n#include \"SVMClassifier.h\"\n```\n\n```js\nEloquent::ML::Port::SVM classifier;\n```\n\n```js\nvoid setup() {\n  Serial.begin(115200);\n```\n\n\n<div class=\"content-ad\"></div>\n\n```js\nvoid loop() {\n  float X_1[] = {3.6, 1. , 0.2};\n  int result_1 = classifier.predict(X_1);\n  Serial.print(\"Result of predict with input X1:\");\n  Serial.println(result_1);\n  delay(2000);\n```\n\n```js\nfloat X_2[] = {2.9, 4.7, 1.4};\n  int result_2 = classifier.predict(X_2);\n  Serial.print(\"Result of predict with input X2:\");\n  Serial.println(result_2); \n  delay(2000);\n```\n\n```js\n}\n```\n\n결과:\n\n<div class=\"content-ad\"></div>\n\n0 — 셋토사 — 입력: '3.6, 1. , 0.2'\n\n1 — 버시컬러 — 입력: '2.9, 4.7, 1.4'\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_38.png)\n\n👀😲(보너스) 하이퍼파라미터 튜닝\n\n<div class=\"content-ad\"></div>\n\nRandomizedSearchCV는 Python의 scikit-learn 라이브러리에서 제공하는 함수로, 머신 러닝 모델의 하이퍼파라미터 튜닝을 위해 일반적으로 사용됩니다. 이 기술은 하이퍼파라미터의 다양한 값을 탐색할 때 유용하며, 가장 효과적인 조합을 식별하는 것을 목표로 합니다.\n\na) 파라미터 공간의 정의:\n\nRandomizedSearchCV를 활용하기 전에, 모델의 하이퍼파라미터를 위한 탐색 공간을 지정해야 합니다. 특정 값의 그리드를 제공하는 대신, 각 하이퍼파라미터에 대해 분포가 정의됩니다.\n\nb) 랜덤 샘플링:\n\n<div class=\"content-ad\"></div>\n\n예를 들어 GridSearchCV의 모든 가상 하이퍼파라미터 조합을 평가하는 대신, RandomizedSearchCV은 평가를 위해 일정한 하이퍼파라미터 조합을 무작위로 선택합니다. 이는 큰 탐색 공간을 다룰 때 유리합니다.\n\nc) 모델 훈련:\n\n무작위로 선택된 각 하이퍼파라미터 세트에 대해 RandomizedSearchCV는 교차 검증을 사용하여 모델을 훈련시킵니다. 데이터는 폴드로 나뉘며, 모델은 일부 폴드에서 훈련을 받고 나머지 폴드에서 평가를 받습니다.\n\nd) 성능 평가:\n\n<div class=\"content-ad\"></div>\n\n성능은 지정된 메트릭(예: 정확도, F1 점수)을 사용하여 측정됩니다. 목표는 주어진 문제에 따라 이 메트릭을 최대화하거나 최소화하는 하이퍼파라미터를 찾는 것입니다(예: 분류 문제에서 정확도를 최대화).\n\ne) 최적 모델 선택:\n\n랜덤 탐색이 완료되면, RandomizedSearchCV는 교차 검증 중 최상의 평균 성능을 보인 하이퍼파라미터 세트를 반환합니다.\n\nRandomizedSearchCV를 사용하면, 특히 큰 탐색 공간을 다룰 때 모든 가능한 조합을 평가하는 완전한 그리드 탐색(GridSearchCV)과 비교하여 계산 시간을 절약할 수 있습니다. 이 효율성은 모든 가능한 조합을 평가하는 대신 하이퍼파라미터 공간의 무작위 샘플을 탐색하는 데서 오게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n1. **라이브러리 가져오기**\n\n```python\nfrom sklearn.metrics import make_scorer, roc_auc_score\nfrom sklearn.model_selection import RandomizedSearchCV\n```\n\n2. **파라미터 조합을 위한 그리드 탐색 설정**\n\n```python\nparams = {\n    \"C\": np.arange(2, 10, 2),\n    \"gamma\": np.arange(0.1, 1, 0.01),\n    \"kernel\": ['rbf', 'linear', 'poly']}\n```\n\n<div class=\"content-ad\"></div>\n\n3- 성능 측정 지표 정의\n\n```js\nauc = make_scorer(roc_auc_score)\n```\n\n4- 최적 모델을 탐색합니다.\n\n```js\nbest_model = RandomizedSearchCV(model, param_distributions=params, random_state=42, n_iter=200, cv=3, verbose=1, n_jobs=1, return_train_score=True, scoring = auc)\nbest_model.fit(X_train, y_train)\n```\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_39.png)\n\n5-가장 좋은 모델 보고\n\n```python\ndef report_best_scores(results, n_top=3):\n    for i in range(1, n_top + 1):\n        candidates = np.flatnonzero(results['rank_test_score'] == i)\n        for candidate in candidates:\n            print(\"순위가 {0}인 모델\".format(i))\n            print(\"평균 검증 점수: {0:.3f} (표준편차: {1:.3f})\".format(\n                results['mean_test_score'][candidate],\n                results['std_test_score'][candidate]))\n            best_params = results['params'][candidate]\n            print(\"찾은 최적 파라미터:\")\n            for param, value in best_params.items():\n                print(\"  {0}: {1}\".format(param, value))\n            print(\"\")\n```\n\n```python\nreport_best_scores(best_model.cv_results_, 1)\n```\n\n<div class=\"content-ad\"></div>\n\n```Markdown\n![Image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_40.png)\n\nFull project in: [TinyML/05_support_vector_machine](https://github.com/thommaskevin/TinyML)\n\nReferences:\n\nFLETCHER, Tristan. Support vector machines explained. Tutorial paper, p. 1–19, 2009.\n```","ogImage":{"url":"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_0.png"},"coverImage":"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_0.png","tag":["Tech"],"readingTime":19},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>수학적 기초부터 엣지 구현까지</p>\n<h2>소셜 미디어:</h2>\n<p>👨🏽‍💻 Github: thommaskevin/TinyML (github.com)\n👷🏾 Linkedin: Thommas Kevin | LinkedIn\n📽 Youtube: Thommas Kevin — YouTube\n👨🏻‍🏫 연구 그룹: Conecta.ai (ufrn.br)</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_0.png\" alt=\"이미지\"></p>\n<p>서포트 벡터 머신(SVMs) 또는 머신 러닝에서는 서포트 벡터 네트워크라고도 하는 SVMs는 학습 알고리즘을 갖춘 지도형 최대 마진 모델입니다. 이들은 분류와 회귀 분석을 위해 데이터를 분석합니다. Vladimir Vapnik과 동료들은 AT&#x26;T 벨 연구소에서 SVMs를 개발했습니다. SVMs는 Vapnik과 Chervonenkis가 1974년에 제안한 VC 이론과 통계 학습 프레임워크에 근거한 매우 연구된 모델 중 하나입니다.</p>\n<h1>1 — 서포트 벡터 머신 이론</h1>\n<h2>1.1 — 선형 이진 분류</h2>\n<p>기본적으로 SVM의 역할은 분리 가능한 데이터 집합에 대해 클래스나 레이블 간의 가장 효율적인 분리 경계를 식별하는 것입니다. SVM의 맥락에서 클래스를 완전히 분리할 수 있는 다양한 초평면들이 잠재적인 분리 경계로 간주됩니다.</p>\n<p>우리는 각 입력 xi가 D개의 속성(즉, D 차원으로 구성)을 가지고 있고 -1 또는 +1 중 하나의 클래스에 속하는 값 yi를 갖는 L개의 학습 포인트가 있습니다. 즉, 우리의 훈련 데이터는 다음과 같습니다.</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_1.png\" alt=\"training data\"></p>\n<p>여기서 데이터가 선형적으로 분리 가능하다고 가정합니다. 즉, D = 2 일 때 x1 대 x2 그래프에 두 클래스를 분리하는 선을 그릴 수 있고, D ` 2 일 때 x1, x2...xD 그래프에 초평면을 그릴 수 있습니다.</p>\n<p>이 초평면은 w · x + b = 0으로 설명할 수 있습니다. 여기서:</p>\n<ul>\n<li>w는 초평면에 수직입니다.</li>\n<li>b/||w||은 초평면으로부터 원점까지의 수직 거리입니다.</li>\n</ul>\n<p>서포트 벡터(Support Vectors)는 분리 초평면에 가장 가까운 예제들을 의미하며, 서포트 벡터 머신(SVM)의 목표는 이 초평면을 가능한 한 두 클래스의 가장 가까운 멤버와 멀리떨어지도록 방향을 조절하는 것입니다.</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_2.png\" alt=\"image\"></p>\n<p>그림 1을 참조하면, SVM을 구현하는 것은 변수 w와 b를 선택하여 학습 데이터를 아래와 같이 설명할 수 있도록 하는 것으로 요약됩니다:</p>\n<ul>\n<li>xi · w + b ≥ +1 for yi = +1</li>\n<li>xi · w + b ≤ −1 for yi = −1</li>\n</ul>\n<p>이러한 방정식은 다음과 같이 결합될 수 있습니다:</p>\n<p>yi(xi · w + b) − 1 ≥ 0 ∀i</p>\n<p>이제 분리 초평면에 가장 가까이 있는 점, 즉 서포트 벡터(도표에서 원으로 표시됨)만 고려한다면, 이 점이 있는 두 평면 H1과 H2는 다음과 같이 나타낼 수 있습니다:</p>\n<p>표를 마크다운 형식으로 변경해주세요.</p>\n<table>\n<thead>\n<tr>\n<th>xi · w + b = +1 for H1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>xi · w + b = −1 for H2</td>\n</tr>\n</tbody>\n</table>\n<p>Figure 1을 참고하여, d1은 H1로부터 초평면까지의 거리를 나타내고, d2는 H2로부터의 거리를 나타냅니다. H1과 H2로부터의 초평면의 등거리는 d1 = d2로 정의되며, 이를 SVM의 여백이라고 합니다. 초평면을 가능한 한 Support Vectors로부터 최대한 멀리 위치시키기 위해 이 여백을 최대화해야 합니다.</p>\n<p>간단한 벡터 기하학에 따르면, 여백은 (1/||w||)와 같고, 이를 최대화하기 위해서는 (1.3)의 제약 조건 하에 찾아야 할 것입니다.</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_3.png\" alt=\"TinyMLSupportVectorMachinesClassifier_3\"></p>\n<p>kwk을 최소화하는 것은 (0.5*||w||²)을 최소화하는 것과 동일한 것이며, 이 용어의 사용은 나중에 이차 프로그래밍(QP) 최적화를 수행할 수 있게 합니다. 따라서 우리는 다음을 찾아야 합니다:</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_4.png\" alt=\"TinyMLSupportVectorMachinesClassifier_4\"></p>\n<p>이 최소화의 제약 사항을 고려하기 위해 Lagrange 배수 α를 할당해야 합니다. 여기서 αi ≥ 0 ∀i 여야 합니다.</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_5.png\" alt=\"이미지\"></p>\n<p>우리는 최소화하는 w와 b 및 최대화하는 α를 찾고 싶습니다 (αi ≥ 0 ∀i를 유지하면서). 이를 위해 LP를 w와 b에 대해 미분하여 도함수를 0으로 설정할 수 있습니다:</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_6.png\" alt=\"이미지\"></p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_7.png\" alt=\"이미지\"></p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_8.png\" alt=\"image\"></p>\n<p>이 새로운 제약 조건 LD는 주 기본 LP의 이중 형식으로 참조됩니다. 중요한 점은 이 이중 형식이 각 입력 벡터 xi의 내적만 계산하면 되므로 커널 트릭에서 중요하다는 점입니다.</p>\n<p>LP를 최소화하는 것에서 LD를 최대화하는 것으로 전환한 후, 우리는 다음을 찾아야 합니다:</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_9.png\" alt=\"image\"></p>\n<p>이것은 볼록 이차 최적화 문제이며 QP 솔버를 실행하여 α를 반환하고 (1.10)로부터 w를 제공받습니다. 남은 것은 b를 계산하는 것입니다.</p>\n<p>(1.11)을 만족하는 어떤 데이터 포인트는 지지 벡터 xs가 될 것이며 다음과 같은 형식을 갖습니다:</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_10.png\" alt=\"Support Vector\"></p>\n<p>(1.10)을 대입하는 것입니다:</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_11.png\" alt=\"image\"></p>\n<p>서포트 벡터의 지수 집합을 나타내는 S입니다. S는 αi ` 0인 지수 i를 찾아 결정됩니다. ys로 곱하고 (1.1) 및 (1.2)에서 ys² = 1을 사용하여:</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_12.png\" alt=\"image\"></p>\n<p>임의의 서포트 벡터 xs를 사용하는 대신, S에 속하는 모든 서포트 벡터를 평균하는 것이 더 나은 방법입니다.</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_13.png\" alt=\"이미지\"></p>\n<p>우리는 이제 서포트 벡터 머신을 정의하는 분리 초평면의 최적 방향을 결정하는 변수 w와 b를 가지고 있습니다.</p>\n<h2>1.2 — 선형적으로 분리되지 않는 데이터의 분류</h2>\n<p>완전히 선형적으로 분리되지 않는 데이터를 다룰 수 있도록 SVM 방법론을 확장하기 위해 (1.1)과 (1.2)의 제약 조건을 약간 완화하여 잘못 분류된 포인트를 허용합니다. 이는 긍정적인 slack 변수 ξi, i = 1, . . . L을 도입함으로써 수행됩니다:</p>\n<p>아래의 내용을 다음과 같이 결합할 수 있어요:</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_15.png\" alt=\"img\"></p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_16.png\" alt=\"img\"></p>\n<p>이 소프트 마진 SVM에서, 마진 경계의 잘못된 쪽에 있는 데이터 포인트는 그로부터의 거리에 따라 증가하는 패널티를 받습니다. 우리는 오분류의 수를 줄이려고 하기 때문에, 이전의 목적 함수(1.6)를 적응하기 위한 합리적인 방법은 다음과 같습니다:</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_17.png\" alt=\"그림\"></p>\n<p>여기서 매개변수 C는 여유 변수의 패널티와 마진의 크기 사이의 교환을 제어합니다. 라그랑지안으로 재정립하는 것은, w, b 및 ξi에 대해 최소화하고 α에 대해 최대화해야하는 함수를 찾아야 합니다 (여기서 αi ≥ 0, µi ≥ 0 ∀i):</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_18.png\" alt=\"그림\"></p>\n<p>w, b 및 ξi에 대해 미분하고 도함수를 0으로 설정합니다:</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_19.png\" alt=\"image\"></p>\n<p>이를 대입하면, LD는 이전의 (1.14)와 동일한 형식을 가집니다. 그러나 (2.9)와 µi ≥ 0 ∀i 함께하면, α ≥ C를 함의합니다. 따라서 우리는 다음을 찾아야 합니다:</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_20.png\" alt=\"image\"></p>\n<p>그런 후에 b는 (1.6)과 동일한 방법으로 계산됩니다. 그러나 이 경우 b를 계산하기 위해 사용된 Support Vectors 집합은 0 <code>αi</code> C인 i의 인덱스를 찾아 결정됩니다.</p>\n<h1>2. 하이퍼파라미터 조정: 커널, 정규화, 감마 및 마진.</h1>\n<h2>2.1 — 커널</h2>\n<p>선형 분리 가능한 데이터에 SVM을 적용할 때 입력 변수의 내적으로 행렬 H를 생성하는 방식부터 시작했습니다.</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_21.png\" alt=\"이미지\"></p>\n<p>k(xi, xj)는 Kernel Functions라는 함수 패밀리의 예시입니다 (k(xi, xj) = (xi^T)*(xj)가 선형 커널로 알려져 있습니다). 커널 함수의 집합은 두 벡터의 내적을 계산하는 것을 기반으로 하고 있어서 (4.2)의 변형으로 구성되어 있습니다. 이것은 함수들이 어떤 잠재적으로 비선형 특징 매핑 함수 x → φ(x)에 의해 더 높은 차원의 공간으로 다시 구성될 수 있다는 것을 의미합니다. 이는 매핑된 입력들의 내적만 계산하면 되기 때문에 우리는 명시적으로 φ를 계산할 필요가 없다는 것을 뜻합니다.</p>\n<p>이 커널 트릭이 유용한 이유는 입력 x의 공간에서 선형적으로 분류/회귀할 수 없는 많은 문제들이 존재하기 때문입니다. 이는 적합한 매핑 x→ φ(x)가 주어진 상태에서 더 높은 차원의 특징 공간에 있을 수 있기 때문입니다.</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_22.png\" alt=\"이미지\"></p>\n<p>Figure 3를 참조하면, 우리가 우리의 커널을 다음과 같이 정의한다면:</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_23.png\" alt=\"Kernel\"></p>\n<p>그러면 2차원 데이터 공간 x에서 선형적으로 분리되지 않는 데이터 집합(그림 3의 좌측)은 이 비선형 커널 함수에 의해 암시적으로 정의된 비선형 피처 공간(그림 3의 우측)에서 분리될 수 있습니다. 이 커널 함수는 Radial Basis Kernel로 알려져 있습니다.</p>\n<p>분류 및 회귀를 위한 다른 인기 있는 커널로는 다항식 커널이 있습니다.</p>\n<p>아래는 Markdown 형식으로 [TinyMLSupportVectorMachinesClassifier_24.png] 이미지가 있는 표입니다.</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_24.png\" alt=\"TinyMLSupportVectorMachinesClassifier_24.png\"></p>\n<p>아래는 Markdown 형식으로 [TinyMLSupportVectorMachinesClassifier_25.png] 이미지가 있는 표입니다.</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_25.png\" alt=\"TinyMLSupportVectorMachinesClassifier_25.png\"></p>\n<p>여기서 a와 b는 커널의 동작을 정의하는 매개변수입니다.</p>\n<h2>2.2 — 정규화</h2>\n<p>정규화 매개변수(파이썬의 sklearn 라이브러리에서 C 매개변수로 자주 표현됨)는 SVM 최적화에 각 훈련 예제를 잘못 분류하고 싶지 않은 정도를 알려줍니다.</p>\n<p>C 값이 큰 경우 최적화는 모든 훈련 포인트를 올바르게 분류하는 더 나은 작은 마진의 초평면을 선택할 것입니다. 반대로, C 값이 매우 작으면 옵티마이저는 더 큰 마진 분리 초평면을 찾아 더 많은 포인트를 잘못 분류하더라도 선택할 것입니다.</p>\n<p>아래 이미지는 두 가지 다른 정규화 매개변수의 예시입니다. 왼쪽 이미지는 낮은 정규화 값으로 인해 일부 오분류가 있습니다. 높은 값은 오른쪽 이미지와 같은 결과를 낳습니다.</p>\n<h2>2.3 — 감마</h2>\n<p>감마 매개변수는 단일 학습 예제의 영향이 얼마나 멀리 미치는지를 정의하며, 낮은 값은 '멀리', 높은 값은 '가까이'를 의미합니다. 다시 말해, 낮은 감마 값에서는 확실한 분리 선에서 멀리 떨어진 점들이 분리 선 계산에 고려됩니다. 반면 높은 감마는 분리 선에 가까운 점들이 계산에 고려된다는 것을 의미합니다.</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_27.png\" alt=\"image\"></p>\n<h2>2.4 — 여백</h2>\n<p>표 태그를 Markdown 형식으로 변경해주세요.</p>\n<pre><code class=\"hljs language-js\">!pip install micromlgen\n</code></pre>\n<ol start=\"2\">\n<li>라이브러리 가져오기</li>\n</ol>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> micromlgen <span class=\"hljs-keyword\">import</span> port\n<span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n<span class=\"hljs-keyword\">import</span> plotly.<span class=\"hljs-property\">graph_objects</span> <span class=\"hljs-keyword\">as</span> go\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> plotly.<span class=\"hljs-property\">express</span> <span class=\"hljs-keyword\">as</span> px\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> sklearn.<span class=\"hljs-property\">svm</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-variable constant_\">SVC</span>\n<span class=\"hljs-keyword\">from</span> sklearn.<span class=\"hljs-property\">calibration</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">LabelEncoder</span>\n<span class=\"hljs-keyword\">from</span> sklearn.<span class=\"hljs-property\">datasets</span> <span class=\"hljs-keyword\">import</span> load_iris\n<span class=\"hljs-keyword\">from</span> sklearn.<span class=\"hljs-property\">model_selection</span> <span class=\"hljs-keyword\">import</span> train_test_split\n<span class=\"hljs-keyword\">from</span> sklearn <span class=\"hljs-keyword\">import</span> metrics\n</code></pre>\n<p>3 - 데이터셋 로드</p>\n<p>아이리스 데이터셋은 머신 러닝과 통계 분야에서 고전적인 데이터셋입니다. 이는 1936년 Sir Ronald A. Fisher에 의해 도입되었으며 판별 분석의 예시로 사용되었습니다. 이 데이터셋은 교육 목적으로 자주 사용되며 패턴 분류 실습의 일반적인 시작 지점입니다.</p>\n<p>속성:</p>\n<ul>\n<li>꽃받침 길이 (센티미터)</li>\n<li>꽃받침 너비 (센티미터)</li>\n<li>꽃잎 길이 (센티미터)</li>\n</ul>\n<p>종:</p>\n<ul>\n<li>0 — 세토사</li>\n<li>1 — 버시컬러</li>\n</ul>\n<pre><code class=\"hljs language-js\"># 아이리스 데이터셋 불러오기\ndata = <span class=\"hljs-title function_\">load_iris</span>()\n</code></pre>\n<pre><code class=\"hljs language-js\"># 데이터프레임 생성\ndf_iris = pd.<span class=\"hljs-title class_\">DataFrame</span>(data.<span class=\"hljs-property\">data</span>, columns=data.<span class=\"hljs-property\">feature_names</span>)\n</code></pre>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">DataFrame</span>에 대상 변수를 추가합니다\ndf_iris[<span class=\"hljs-string\">'target'</span>] = data.<span class=\"hljs-property\">target</span>\n</code></pre>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">NaN</span> 값을 제거합니다\ndf = df_iris.<span class=\"hljs-title function_\">dropna</span>(axis=<span class=\"hljs-string\">'rows'</span>) # <span class=\"hljs-title class_\">NaN</span> 제거\n</code></pre>\n<pre><code class=\"hljs language-js\"># <span class=\"hljs-title class_\">DataFrame</span>을 표시합니다\n<span class=\"hljs-title function_\">print</span>(df_iris.<span class=\"hljs-title function_\">head</span>())\n</code></pre>\n<pre><code class=\"hljs language-js\">df = df_iris.<span class=\"hljs-property\">iloc</span>[:<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">4</span>]\n</code></pre>\n<pre><code class=\"hljs language-js\">X=df.<span class=\"hljs-title function_\">to_numpy</span>()\n</code></pre>\n<pre><code class=\"hljs language-js\"># 레이블을 정수 유형으로 변환합니다: <span class=\"hljs-title class_\">Setosa</span> = <span class=\"hljs-number\">0</span>, <span class=\"hljs-title class_\">Versicolor</span> = <span class=\"hljs-number\">1</span>\ny=df_iris.<span class=\"hljs-property\">iloc</span>[:<span class=\"hljs-number\">100</span>,-<span class=\"hljs-number\">1</span>]\ny = <span class=\"hljs-title class_\">LabelEncoder</span>().<span class=\"hljs-title function_\">fit_transform</span>(y)\n</code></pre>\n<p>4 - 데이터셋 시각화</p>\n<pre><code class=\"hljs language-js\">fig = go.<span class=\"hljs-title class_\">Figure</span>()\n</code></pre>\n<pre><code class=\"hljs language-js\">fig.<span class=\"hljs-title function_\">add_trace</span>(go.<span class=\"hljs-title class_\">Scatter3</span>d(x=df[<span class=\"hljs-string\">'sepal width (cm)'</span>], y= df[<span class=\"hljs-string\">'petal length (cm)'</span>], z=df[<span class=\"hljs-string\">'petal width (cm)'</span>], mode=<span class=\"hljs-string\">'markers'</span>, marker=<span class=\"hljs-title function_\">dict</span>(color=<span class=\"hljs-string\">'blue'</span>)))\n</code></pre>\n<pre><code class=\"hljs language-js\">fig.<span class=\"hljs-title function_\">update_layout</span>(scene=<span class=\"hljs-title function_\">dict</span>(xaxis_title=<span class=\"hljs-string\">'꽃 받침 길이 (cm)'</span>, yaxis_title=<span class=\"hljs-string\">'꽃 받침 너비 (cm)'</span>, zaxis_title=<span class=\"hljs-string\">'꽃 잎 너비 (cm)'</span>),\n                  scene_camera=<span class=\"hljs-title function_\">dict</span>(eye=<span class=\"hljs-title function_\">dict</span>(x=<span class=\"hljs-number\">1.87</span>, y=<span class=\"hljs-number\">0.88</span>, z=-<span class=\"hljs-number\">0.64</span>)),\n                  width=<span class=\"hljs-number\">1000</span>, height=<span class=\"hljs-number\">600</span>)\n</code></pre>\n<p>5 — 훈련 및 테스트 데이터로 분할</p>\n<pre><code class=\"hljs language-js\">X_train, X_test, y_train, y_test = <span class=\"hljs-title function_\">train_test_split</span>(X, y, test_size=<span class=\"hljs-number\">0.3</span>, random_state=<span class=\"hljs-number\">42</span>)\n</code></pre>\n<ol start=\"6\">\n<li>Create the classification model</li>\n</ol>\n<pre><code class=\"hljs language-js\">model = <span class=\"hljs-title function_\">SVC</span>(gamma=<span class=\"hljs-number\">0.0000001</span>, kernel=<span class=\"hljs-string\">'linear'</span>)\n</code></pre>\n<ol start=\"7\">\n<li>Train the model</li>\n</ol>\n<pre><code class=\"hljs language-js\">model.<span class=\"hljs-title function_\">fit</span>(X_train, y_train)\n</code></pre>\n<p>8 — 훈련 데이터를 사용하여 모델 평가</p>\n<pre><code class=\"hljs language-js\">training_predict = model.<span class=\"hljs-title function_\">predict</span>(X_train)\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">print</span>(metrics.<span class=\"hljs-title function_\">classification_report</span>(y_train, training_predict, digits = <span class=\"hljs-number\">3</span>))\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">print</span>(metrics.<span class=\"hljs-title function_\">confusion_matrix</span>(y_train, training_predict))\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">'Model accuracy: {round(metrics.accuracy_score(y_train, training_predict)*100,2)}%'</span>)\n</code></pre>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_32.png\" alt=\"이미지\"></p>\n<p>9 — Hyperlane Train Data Visualization</p>\n<pre><code class=\"hljs language-js\">x_grid, y_grid = np.<span class=\"hljs-title function_\">meshgrid</span>(np.<span class=\"hljs-title function_\">linspace</span>(X_train[:, <span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_\">min</span>(), X_train[:, <span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_\">max</span>(), <span class=\"hljs-number\">100</span>),\n                             np.<span class=\"hljs-title function_\">linspace</span>(X_train[:, <span class=\"hljs-number\">1</span>].<span class=\"hljs-title function_\">min</span>(), X_train[:, <span class=\"hljs-number\">1</span>].<span class=\"hljs-title function_\">max</span>(), <span class=\"hljs-number\">100</span>))\nz_grid = np.<span class=\"hljs-title function_\">zeros_like</span>(x_grid)\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-title function_\">len</span>(x_grid)):\n    <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-title function_\">len</span>(y_grid)):\n        z_grid[i, j] = model.<span class=\"hljs-title function_\">decision_function</span>([[x_grid[i, j], y_grid[i, j], <span class=\"hljs-number\">0</span>]])\n</code></pre>\n<pre><code class=\"hljs language-js\">fig = go.<span class=\"hljs-title class_\">Figure</span>()\n</code></pre>\n<pre><code class=\"hljs language-js\">fig.<span class=\"hljs-title function_\">add_trace</span>(go.<span class=\"hljs-title class_\">Scatter3</span>d(x=X_train[:, <span class=\"hljs-number\">0</span>], y=X_train[:, <span class=\"hljs-number\">1</span>], z=X_train[:, <span class=\"hljs-number\">2</span>], mode=<span class=\"hljs-string\">'markers'</span>,\n                           marker=<span class=\"hljs-title function_\">dict</span>(size=<span class=\"hljs-number\">5</span>, color=y_train, opacity=<span class=\"hljs-number\">0.7</span>), name=<span class=\"hljs-string\">'Training Data'</span>))\n</code></pre>\n<pre><code class=\"hljs language-js\">fig.<span class=\"hljs-title function_\">add_trace</span>(go.<span class=\"hljs-title class_\">Surface</span>(z=z_grid, x=x_grid, y=y_grid, opacity=<span class=\"hljs-number\">0.5</span>, colorscale=<span class=\"hljs-string\">'Bluered_r'</span>))\n</code></pre>\n<pre><code class=\"hljs language-js\">fig.<span class=\"hljs-title function_\">update_layout</span>(scene=<span class=\"hljs-title function_\">dict</span>(xaxis_title=<span class=\"hljs-string\">'Sepal Width (cm)'</span>,\n                             yaxis_title=<span class=\"hljs-string\">'Petal Length (cm)'</span>,\n                             zaxis_title=<span class=\"hljs-string\">'Petal Width (cm)'</span>))\n</code></pre>\n<pre><code class=\"hljs language-js\">fig.<span class=\"hljs-title function_\">update_layout</span>(width=<span class=\"hljs-number\">1000</span>, height=<span class=\"hljs-number\">600</span>)\n</code></pre>\n<pre><code class=\"hljs language-js\">fig.<span class=\"hljs-title function_\">show</span>()\n</code></pre>\n<p>10 — 테스트 데이터로 모델 평가하기</p>\n<pre><code class=\"hljs language-js\">test_predict = model.<span class=\"hljs-title function_\">predict</span>(X_test)\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">print</span>(metrics.<span class=\"hljs-title function_\">classification_report</span>(y_test, test_predict, digits = <span class=\"hljs-number\">3</span>))\n</code></pre>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_34.png\" alt=\"Image\"></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">print</span>(metrics.<span class=\"hljs-title function_\">confusion_matrix</span>(y_test, test_predict))\n</code></pre>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_35.png\" alt=\"image\"></p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">'모델 정확도: {round(metrics.accuracy_score(y_test, test_predict)*100,2)}%'</span>)\n</code></pre>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_36.png\" alt=\"image\"></p>\n<p>11 — 하이퍼플레인 테스트 데이터 시각화</p>\n<pre><code class=\"hljs language-js\">x_grid, y_grid = np.<span class=\"hljs-title function_\">meshgrid</span>(np.<span class=\"hljs-title function_\">linspace</span>(X_test[:, <span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_\">min</span>(), X_test[:, <span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_\">max</span>(), <span class=\"hljs-number\">100</span>),\n                             np.<span class=\"hljs-title function_\">linspace</span>(X_test[:, <span class=\"hljs-number\">1</span>].<span class=\"hljs-title function_\">min</span>(), X_test[:, <span class=\"hljs-number\">1</span>].<span class=\"hljs-title function_\">max</span>(), <span class=\"hljs-number\">100</span>))\nz_grid = np.<span class=\"hljs-title function_\">zeros_like</span>(x_grid)\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-title function_\">len</span>(x_grid)):\n    <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-title function_\">len</span>(y_grid)):\n        z_grid[i, j] = model.<span class=\"hljs-title function_\">decision_function</span>([[x_grid[i, j], y_grid[i, j], <span class=\"hljs-number\">0</span>]])\n</code></pre>\n<pre><code class=\"hljs language-js\">fig = go.<span class=\"hljs-title class_\">Figure</span>()\n</code></pre>\n<pre><code class=\"hljs language-js\">fig.<span class=\"hljs-title function_\">add_trace</span>(go.<span class=\"hljs-title class_\">Scatter3</span>d(x=X_test[:, <span class=\"hljs-number\">0</span>], y=X_test[:, <span class=\"hljs-number\">1</span>], z=X_test[:, <span class=\"hljs-number\">2</span>], mode=<span class=\"hljs-string\">'markers'</span>,\n                           marker=<span class=\"hljs-title function_\">dict</span>(size=<span class=\"hljs-number\">5</span>, color=y_test), name=<span class=\"hljs-string\">'Training Data'</span>))\n</code></pre>\n<pre><code class=\"hljs language-js\">fig.<span class=\"hljs-title function_\">add_trace</span>(go.<span class=\"hljs-title class_\">Surface</span>(z=z_grid, x=x_grid, y=y_grid, opacity=<span class=\"hljs-number\">0.5</span>, colorscale=<span class=\"hljs-string\">'Bluered_r'</span>))\n</code></pre>\n<pre><code class=\"hljs language-js\">fig.<span class=\"hljs-title function_\">update_layout</span>(scene=<span class=\"hljs-title function_\">dict</span>(xaxis_title=<span class=\"hljs-string\">'꽃받침 너비 (cm)'</span>,\n                             yaxis_title=<span class=\"hljs-string\">'꽃잎 길이 (cm)'</span>,\n                             zaxis_title=<span class=\"hljs-string\">'꽃잎 너비 (cm)'</span>))\n</code></pre>\n<pre><code class=\"hljs language-js\">fig.<span class=\"hljs-title function_\">update_layout</span>(width=<span class=\"hljs-number\">1000</span>, height=<span class=\"hljs-number\">600</span>)\n</code></pre>\n<pre><code class=\"hljs language-js\">fig.<span class=\"hljs-title function_\">show</span>()\n</code></pre>\n<p>12 — 마이크로컨트롤러에 구현될 모델 얻기</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">print</span>(<span class=\"hljs-title function_\">port</span>(model))\n</code></pre>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> once</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;cstdarg></span></span>\n<span class=\"hljs-keyword\">namespace</span> Eloquent {\n    <span class=\"hljs-keyword\">namespace</span> ML {\n        <span class=\"hljs-keyword\">namespace</span> Port {\n            <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SVM</span> {\n                <span class=\"hljs-keyword\">public</span>:\n                    <span class=\"hljs-comment\">/**\n                    * 특징 벡터에 대한 클래스 예측\n                    */</span>\n                    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">predict</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float</span> *x)</span> </span>{\n                        <span class=\"hljs-type\">float</span> kernels[<span class=\"hljs-number\">3</span>] = { <span class=\"hljs-number\">0</span> };\n                        <span class=\"hljs-type\">float</span> decisions[<span class=\"hljs-number\">1</span>] = { <span class=\"hljs-number\">0</span> };\n                        <span class=\"hljs-type\">int</span> votes[<span class=\"hljs-number\">2</span>] = { <span class=\"hljs-number\">0</span> };\n                        kernels[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-built_in\">compute_kernel</span>(x,   <span class=\"hljs-number\">3.4</span>  , <span class=\"hljs-number\">1.9</span>  , <span class=\"hljs-number\">0.2</span> );\n                        kernels[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-built_in\">compute_kernel</span>(x,   <span class=\"hljs-number\">3.3</span>  , <span class=\"hljs-number\">1.7</span>  , <span class=\"hljs-number\">0.5</span> );\n                        kernels[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-built_in\">compute_kernel</span>(x,   <span class=\"hljs-number\">2.4</span>  , <span class=\"hljs-number\">3.3</span>  , <span class=\"hljs-number\">1.0</span> );\n                        <span class=\"hljs-type\">float</span> decision = <span class=\"hljs-number\">-0.833910342285</span>;\n                        decision = decision - ( + kernels[<span class=\"hljs-number\">0</span>] * <span class=\"hljs-number\">-0.31945543931</span>  + kernels[<span class=\"hljs-number\">1</span>] * <span class=\"hljs-number\">-0.240101867421</span> );\n                        decision = decision - ( + kernels[<span class=\"hljs-number\">2</span>] * <span class=\"hljs-number\">0.559557306731</span> );\n                        <span class=\"hljs-keyword\">return</span> decision > <span class=\"hljs-number\">0</span> ? <span class=\"hljs-number\">0</span> : <span class=\"hljs-number\">1</span>;\n                    }\n                <span class=\"hljs-keyword\">protected</span>:\n                    <span class=\"hljs-comment\">/**\n                    * 특징 벡터와 서포트 벡터 사이의 커널 계산.\n                    * 커널 유형: 선형\n                    */</span>\n                    <span class=\"hljs-function\"><span class=\"hljs-type\">float</span> <span class=\"hljs-title\">compute_kernel</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float</span> *x, ...)</span> </span>{\n                        va_list w;\n                        <span class=\"hljs-built_in\">va_start</span>(w, <span class=\"hljs-number\">3</span>);\n                        <span class=\"hljs-type\">float</span> kernel = <span class=\"hljs-number\">0.0</span>;\n                        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint16_t</span> i = <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">3</span>; i++) {\n                            kernel += x[i] * <span class=\"hljs-built_in\">va_arg</span>(w, <span class=\"hljs-type\">double</span>);\n                        }\n                        <span class=\"hljs-keyword\">return</span> kernel;\n                    }\n                };\n            }\n        }\n    }\n</code></pre>\n<p>다음은 테이블 태그를 마크다운 형식으로 변경합니다.</p>\n<p>13 — .h 파일에 템플릿을 저장합니다</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">with</span> <span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">'./SVMClassifier/SVMClassifier.h'</span>, <span class=\"hljs-string\">'w'</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">file</span>:\n    file.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-title function_\">port</span>(model))\n</code></pre>\n<p>14 — 아두이노 스케치 완료</p>\n<p>아래와 같이 아두이노 스케치에 \"SVMClassifier.h\" 파일을 포함하세요:</p>\n<pre><code class=\"hljs language-js\">#include <span class=\"hljs-string\">\"SVMClassifier.h\"</span>\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Eloquent</span>::<span class=\"hljs-attr\">ML</span>::<span class=\"hljs-title class_\">Port</span>::<span class=\"hljs-variable constant_\">SVM</span> classifier;\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setup</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title class_\">Serial</span>.<span class=\"hljs-title function_\">begin</span>(<span class=\"hljs-number\">115200</span>);\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">loop</span>(<span class=\"hljs-params\"></span>) {\n  float <span class=\"hljs-variable constant_\">X_1</span>[] = {<span class=\"hljs-number\">3.6</span>, <span class=\"hljs-number\">1.</span> , <span class=\"hljs-number\">0.2</span>};\n  int result_1 = classifier.<span class=\"hljs-title function_\">predict</span>(<span class=\"hljs-variable constant_\">X_1</span>);\n  <span class=\"hljs-title class_\">Serial</span>.<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"Result of predict with input X1:\"</span>);\n  <span class=\"hljs-title class_\">Serial</span>.<span class=\"hljs-title function_\">println</span>(result_1);\n  <span class=\"hljs-title function_\">delay</span>(<span class=\"hljs-number\">2000</span>);\n</code></pre>\n<pre><code class=\"hljs language-js\">float <span class=\"hljs-variable constant_\">X_2</span>[] = {<span class=\"hljs-number\">2.9</span>, <span class=\"hljs-number\">4.7</span>, <span class=\"hljs-number\">1.4</span>};\n  int result_2 = classifier.<span class=\"hljs-title function_\">predict</span>(<span class=\"hljs-variable constant_\">X_2</span>);\n  <span class=\"hljs-title class_\">Serial</span>.<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"Result of predict with input X2:\"</span>);\n  <span class=\"hljs-title class_\">Serial</span>.<span class=\"hljs-title function_\">println</span>(result_2); \n  <span class=\"hljs-title function_\">delay</span>(<span class=\"hljs-number\">2000</span>);\n</code></pre>\n<pre><code class=\"hljs language-js\">}\n</code></pre>\n<p>결과:</p>\n<p>0 — 셋토사 — 입력: '3.6, 1. , 0.2'</p>\n<p>1 — 버시컬러 — 입력: '2.9, 4.7, 1.4'</p>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_38.png\" alt=\"이미지\"></p>\n<p>👀😲(보너스) 하이퍼파라미터 튜닝</p>\n<p>RandomizedSearchCV는 Python의 scikit-learn 라이브러리에서 제공하는 함수로, 머신 러닝 모델의 하이퍼파라미터 튜닝을 위해 일반적으로 사용됩니다. 이 기술은 하이퍼파라미터의 다양한 값을 탐색할 때 유용하며, 가장 효과적인 조합을 식별하는 것을 목표로 합니다.</p>\n<p>a) 파라미터 공간의 정의:</p>\n<p>RandomizedSearchCV를 활용하기 전에, 모델의 하이퍼파라미터를 위한 탐색 공간을 지정해야 합니다. 특정 값의 그리드를 제공하는 대신, 각 하이퍼파라미터에 대해 분포가 정의됩니다.</p>\n<p>b) 랜덤 샘플링:</p>\n<p>예를 들어 GridSearchCV의 모든 가상 하이퍼파라미터 조합을 평가하는 대신, RandomizedSearchCV은 평가를 위해 일정한 하이퍼파라미터 조합을 무작위로 선택합니다. 이는 큰 탐색 공간을 다룰 때 유리합니다.</p>\n<p>c) 모델 훈련:</p>\n<p>무작위로 선택된 각 하이퍼파라미터 세트에 대해 RandomizedSearchCV는 교차 검증을 사용하여 모델을 훈련시킵니다. 데이터는 폴드로 나뉘며, 모델은 일부 폴드에서 훈련을 받고 나머지 폴드에서 평가를 받습니다.</p>\n<p>d) 성능 평가:</p>\n<p>성능은 지정된 메트릭(예: 정확도, F1 점수)을 사용하여 측정됩니다. 목표는 주어진 문제에 따라 이 메트릭을 최대화하거나 최소화하는 하이퍼파라미터를 찾는 것입니다(예: 분류 문제에서 정확도를 최대화).</p>\n<p>e) 최적 모델 선택:</p>\n<p>랜덤 탐색이 완료되면, RandomizedSearchCV는 교차 검증 중 최상의 평균 성능을 보인 하이퍼파라미터 세트를 반환합니다.</p>\n<p>RandomizedSearchCV를 사용하면, 특히 큰 탐색 공간을 다룰 때 모든 가능한 조합을 평가하는 완전한 그리드 탐색(GridSearchCV)과 비교하여 계산 시간을 절약할 수 있습니다. 이 효율성은 모든 가능한 조합을 평가하는 대신 하이퍼파라미터 공간의 무작위 샘플을 탐색하는 데서 오게 됩니다.</p>\n<ol>\n<li><strong>라이브러리 가져오기</strong></li>\n</ol>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> sklearn.metrics <span class=\"hljs-keyword\">import</span> make_scorer, roc_auc_score\n<span class=\"hljs-keyword\">from</span> sklearn.model_selection <span class=\"hljs-keyword\">import</span> RandomizedSearchCV\n</code></pre>\n<ol start=\"2\">\n<li><strong>파라미터 조합을 위한 그리드 탐색 설정</strong></li>\n</ol>\n<pre><code class=\"hljs language-python\">params = {\n    <span class=\"hljs-string\">\"C\"</span>: np.arange(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">2</span>),\n    <span class=\"hljs-string\">\"gamma\"</span>: np.arange(<span class=\"hljs-number\">0.1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0.01</span>),\n    <span class=\"hljs-string\">\"kernel\"</span>: [<span class=\"hljs-string\">'rbf'</span>, <span class=\"hljs-string\">'linear'</span>, <span class=\"hljs-string\">'poly'</span>]}\n</code></pre>\n<p>3- 성능 측정 지표 정의</p>\n<pre><code class=\"hljs language-js\">auc = <span class=\"hljs-title function_\">make_scorer</span>(roc_auc_score)\n</code></pre>\n<p>4- 최적 모델을 탐색합니다.</p>\n<pre><code class=\"hljs language-js\">best_model = <span class=\"hljs-title class_\">RandomizedSearchCV</span>(model, param_distributions=params, random_state=<span class=\"hljs-number\">42</span>, n_iter=<span class=\"hljs-number\">200</span>, cv=<span class=\"hljs-number\">3</span>, verbose=<span class=\"hljs-number\">1</span>, n_jobs=<span class=\"hljs-number\">1</span>, return_train_score=<span class=\"hljs-title class_\">True</span>, scoring = auc)\nbest_model.<span class=\"hljs-title function_\">fit</span>(X_train, y_train)\n</code></pre>\n<p><img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_39.png\" alt=\"이미지\"></p>\n<p>5-가장 좋은 모델 보고</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">report_best_scores</span>(<span class=\"hljs-params\">results, n_top=<span class=\"hljs-number\">3</span></span>):\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, n_top + <span class=\"hljs-number\">1</span>):\n        candidates = np.flatnonzero(results[<span class=\"hljs-string\">'rank_test_score'</span>] == i)\n        <span class=\"hljs-keyword\">for</span> candidate <span class=\"hljs-keyword\">in</span> candidates:\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"순위가 {0}인 모델\"</span>.<span class=\"hljs-built_in\">format</span>(i))\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"평균 검증 점수: {0:.3f} (표준편차: {1:.3f})\"</span>.<span class=\"hljs-built_in\">format</span>(\n                results[<span class=\"hljs-string\">'mean_test_score'</span>][candidate],\n                results[<span class=\"hljs-string\">'std_test_score'</span>][candidate]))\n            best_params = results[<span class=\"hljs-string\">'params'</span>][candidate]\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"찾은 최적 파라미터:\"</span>)\n            <span class=\"hljs-keyword\">for</span> param, value <span class=\"hljs-keyword\">in</span> best_params.items():\n                <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"  {0}: {1}\"</span>.<span class=\"hljs-built_in\">format</span>(param, value))\n            <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"\"</span>)\n</code></pre>\n<pre><code class=\"hljs language-python\">report_best_scores(best_model.cv_results_, <span class=\"hljs-number\">1</span>)\n</code></pre>\n<pre><code class=\"hljs language-Markdown\">![<span class=\"hljs-string\">Image</span>](<span class=\"hljs-link\">/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_40.png</span>)\n\nFull project in: [<span class=\"hljs-string\">TinyML/05_support_vector_machine</span>](<span class=\"hljs-link\">https://github.com/thommaskevin/TinyML</span>)\n\nReferences:\n\nFLETCHER, Tristan. Support vector machines explained. Tutorial paper, p. 1–19, 2009.\n</code></pre>\n</body>\n</html>\n"},"__N_SSG":true}