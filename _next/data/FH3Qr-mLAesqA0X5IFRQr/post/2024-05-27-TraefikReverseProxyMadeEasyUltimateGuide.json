{"pageProps":{"post":{"title":"Traefik 역방향 프록시 만들기 쉽게 이해하기 - 궁극의 안내","description":"","date":"2024-05-27 12:08","slug":"2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide","content":"\n![Traefik 설치하기 쉽게 만든 Reverse Proxy의 최종 가이드](/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_0.png)\n\n셀프 호스팅 세계에서 많은 사람들이 Traefik의 설정이 어렵고 문서를 이해하기 어렵다고 불평한다는 것을 알았어요. 또한 기존 가이드 중 많은 것들이 Traefik가 어떻게 작동하는지 설명하지 않고 구성 예시만 제공하는 것을 알았어요.\n\nTraefik 가이드에 대한 저의 접근 방식은 ELI5 스타일로 Traefik에 대해 절대 모든 것을 이해하게 해줄 테니 기대해주세요.\n\nMedium 유료 회원이 아니신가요? 무료로 여기서 읽어보세요.\n\n<div class=\"content-ad\"></div>\n\n## 기초로 돌아가 — 반전 프록시란 무엇인가요?\n\n반전 프록시는 다른 서버들 앞에 위치한 서버로, 요청을 이러한 서버들로 전달할 수도 있고 수정하거나 거부할 수도 있습니다.\n\n예를 들어, 밥이가 있습니다. 밥이는 라즈베리 파이에 웹사이트를 배포했습니다. 그 라즈베리의 IP는 192.168.0.50이며, 그의 사이트는 http://192.168.0.50:8080 페이지로 접속할 수 있습니다. 그러나 그는 https://mysite.imbob.com을 입력하여 접속하고 싶어합니다. \"imbob.com\" 도메인을 소유하고 있다면, 반전 프록시를 이용하여 이를 할 수 있습니다. 더불어 IP를 화이트리스트로 추가하거나 인증을 추가하는 등의 보안 메커니즘을 추가할 수도 있습니다.\n\n<img src=\"/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n역방향 프록시는 로드 밸런서 역할을 할 수도 있습니다. 단일 서버가 처리할 수 있는 트래픽보다 많은 트래픽을 받으면, 역방향 프록시는 요청을 다른 서버들 사이에 분배할 수 있습니다.\n\n## Traefik 최소 구성\n\n당신이 Traefik을 설정할 때 Docker Compose를 사용한다고 가정하겠습니다. 여기 Traefik 문서에서 가져온 최소 예제가 있습니다:\n\nservices:\nreverse-proxy: # The official v3 Traefik docker image\nimage: traefik:v3.0 # Enables the web UI and tells Traefik to listen to docker\ncommand: --api.insecure=true --providers.docker\nports: # The HTTP port - \"80:80\" # The Web UI (enabled by --api.insecure=true) - \"8080:8080\"\nvolumes: # So that Traefik can listen to the Docker events - /var/run/docker.sock:/var/run/docker.sock\n\n<div class=\"content-ad\"></div>\n\n여기, 이해해야 할 몇 가지 사항이 있어요. --api.insecure=true은 API를 traefik 엔트리포인트에서 사용 가능하게 만들고 (--entrypoint에 대한 더 자세한 내용은 몇 분 후에 있습니다), --providers.docker은 도커 프로바이더를 활성화시켜 호스트에서 도커 서비스를 자동으로 발견할 수 있게 합니다. 이를 위해 Traefik 컨테이너에 도커 소켓을 마운트해야 하는데, 이는 볼륨 섹션에서 수행됩니다. 마지막으로 몇 가지 포트를 노출해야도 해요:\n\n- 80: 표준인 포트 80에서 HTTP 트래픽을 전달하기 위해\n- 8080: 웹 UI에 액세스하기 위해\n\n모든 것이 작동하는지 확인할 수 있어요. 웹 UI를 열어 http://your-ip:8080 (http://192.168.0.50:8080은 Bob의 경우)으로 접속할 수 있어요.\n\n## 설정 파일\n\n<div class=\"content-ad\"></div>\n\nTraefik을 구성하는 방법은 많이 있어요. 여기서 우리는 설정 매개변수를 컨테이너에 명령으로 전달했음을 볼 수 있어요. 이를 구성 파일을 통해 전달하거나 환경 변수를 통해 전달할 수도 있어요.\n\n우리의 간단한 예제를 위한 구성 파일은 다음과 같아요:\n\n```js\napi: insecure: true;\n\nproviders: docker: endpoint: \"unix:///var/run/docker.sock\";\n```\n\n이건 YAML 파일이에요. 이 파일을 사용하려면 간단히 컨테이너에 마운트하시면 돼요:\n\n<div class=\"content-ad\"></div>\n\n```yaml\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n```\n\n그리고 모든 것이 이전과 같이 작동해야 합니다. 설정을 원하는대로 자유롭게 할 수 있으며, 이를 컨테이너 설정 파일을 통해하거나 Traefik 설정 파일을 통해하거나 환경 변수를 통해 할 수 있습니다. 개인적으로 Traefik 설정 파일을 통해 하는 것을 선호하므로 그대로 진행할 겁니다.\n\n그런데 말이야, 지금 이야기하고 있는 설정은 정적 설정이라고 알려져 있어요. 이 설정을 변경할 때마다 Traefik을 재시작해야 합니다. 나중에 동적 설정에 대해 이야기할 거에요.\n\n## EntryPoints\n\n<div class=\"content-ad\"></div>\n\nEntryPoints의 역할은 특정 포트의 트래픽을 캡처하는 것입니다. 일반적인 Traefik 설치에서는 보통 포트 80과 포트 443의 트래픽을 캡처하고 싶을 것입니다. 하지만 가능한 모든 것이 있습니다. 예를 들어, 저는 포트 222를 통해 통과하는 SSH 트래픽을 리다이렉트하는 데에도 Traefik을 사용합니다.\n\nEntryPoints는 정적 구성에서 정의됩니다. 예를 들어:\n\n```js\nentryPoints: web: address: \":80\";\n\nwebsecure: address: \":443\";\n\nssh: address: \":222\";\n```\n\nEntryPoints의 이름은 원하는 대로 지정할 수 있습니다. 표준은 없습니다. EntryPoints를 구성하는 다양한 옵션들이 많이 있습니다. 이 안내서에서 모든 세부 내용을 다룰 수는 없으니, 기본 사항을 설명해 드리겠습니다. 더 알고 싶다면 문서를 참조해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n일반적으로 HTTP 트래픽을 모두 HTTPS 트래픽으로 리디렉션하여 연결을 보안하는 것이 좋습니다. 이를 수행하는 한 가지 방법은 EntryPoint에 리디렉션을 추가하는 것입니다:\n\n```js\nentryPoints: web: address: \":80\";\nhttp: redirections: entryPoint: to: websecure;\n```\n\n여기서 모든 HTTP 트래픽이 websecure EntryPoint로 리디렉션되어야 함을 나타냅니다. 현재 TLS 인증서를 구성하지 않았으므로 이것을 구성에 유지하지 않는 것이 좋습니다.\n\n또한, 각 EntryPoint에 대해 컴퓨터의 포트를 열어야 합니다. 그래서 우리의 새로운 docker-compose.yml 파일은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```yaml\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\" # web\n      - \"443:443\" # websecure\n      - \"1234:222\" # ssh\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n```\n\n알 수 있듯이, ssh 엔트리 포인트의 포트 매핑은 1234입니다. 즉, 포트 1234로 전송된 트래픽은 ssh 엔트리 포인트를 통해 전송됩니다. 제가 보여주려는 것은 포트를 원하는 대로 매핑할 수 있으며, 다른 포트를 80번 포트와 443번 포트로 매핑할 수도 있지만, 이는 표준이 아니므로 서비스에 액세스할 때 포트를 지정해야 합니다. 예를 들어, https://radarr.imbob.com:4430이라고 지정해야 하며, 443번 포트가 아닌 다른 포트로 매핑한 경우에는 https://radarr.imbob.com 대신에 이렇게 지정해야 할 것입니다.\n\n## DNS 레코드\n\n도메인을 소유하고 있다고 가정하겠습니다. 소유하고 있지 않다면, PiHole과 같은 DNS 서버로 자체 도메인을 만들고 여기에 DNS 레코드를 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\"저는 원하는 것이 'something.mydomain'을 입력하면 Traefik이 호스팅된 머신에 도달하도록 하고 싶어요. 어디에서든 서비스를 이용할지, 또는 집에서만 이용할지에 따라 사용해야 하는 IP가 다릅니다. 예를 들어, 저는 집에서만 서비스에 접속하고 싶다고 가정해봅시다.\n\n해야 할 일은 로컬로 서버에 접속할 때 사용하는 IP를 가져와서 도메인 호스트에서 이 IP를 가리키는 A 레코드를 생성하는 것뿐입니다.\n\n예를 들어, Bob은 DNS에 다음 레코드를 가지고 있습니다:\n\n```js\nA  *.imbob.com  192.168.0.50\n\n<div class=\"content-ad\"></div>\n\n만약 Bob이 자신의 서비스를 어디서든 접근할 수 있게 하고 싶다면, 공용 IP를 사용하고 라우터 구성에서 포트 80 및 443을 전달해야 했을 것입니다. 예를 들어 다음과 같은 결과가 나오게 됩니다:\n\nA  *.imbob.com  84.154.65.110\n\n84.154.65.110이 그의 공용 IP인 것으로 가정합니다.\n\n또 다른 예를 들어보겠습니다. 저는 VPN을 사용합니다. 이 VPN에 연결되어 있을 때, VPN에 할당된 다른 IP를 통해 내 기기에 접근할 수 있습니다. VPN에서 연결될 때 보이는 IP를 사용하여 내 서비스를 VPN에 속한 누구에게든 접근 가능하게 하고 싶다면, 다음과 같이 할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\nA  *.imbob.com  100.81.0.50\n\n## 첫 번째 서비스 추가하기\n\n예를 들어, Dozzle를 사용해보겠습니다. Dozzle에 http://dozzle.imbob.com에서 액세스하고 싶습니다.\n\n이제 docker-compose.yml에 Dozzle를 추가하겠습니다:\n\n<div class=\"content-ad\"></div>\n\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n      - \"1234:222\"\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n\n  dozzle:\n    container_name: dozzle\n    image: amir20/dozzle:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    ports:\n      - 8081:8080\n    labels:\n      - traefik.enable=true # 해당 서비스를 위해 Traefik를 활성화합니다\n      - traefik.http.routers.dozzle.entrypoints=web # 엔트리포인트를 명시합니다\n      - traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`) # 서비스에 액세스하는 규칙을 명시합니다\n\n또한, Traefik 구성 파일을 아래에서 확인하실 수 있습니다:\n\napi:\n  insecure: true\n\nentryPoints:\n  web:\n    address: \":80\"\n\n  websecure:\n    address: \":443\"\n\n  ssh:\n    address: \":222\"\n\nproviders:\n  docker:\n    endpoint: \"unix:///var/run/docker.sock\"\n\n이제 http://dozzle.imbob.com을 열어 사용하실 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 왜 이것이 작동하는 걸까요? 저희 서비스는 Traefik 서비스와 동일한 파일에 있기 때문에 동일한 Docker 네트워크에 속합니다. 이 네트워크는 포트 80과 443을 통해 노출되어 있습니다. 따라서 우리가 컴퓨터의 포트 80으로 요청을 보내면, 이는 Dozzle이 속한 Docker 네트워크로 진입하게 됩니다.\n\n이제 우리가 우리의 서비스를 해당 서비스를 자체 파일로 옮기고 싶다고 상상해 봅시다. 이 서비스를 Traefik의 Docker 네트워크에 연결해야 합니다. 다음과 같이 생성해 시작해 보죠:\n\ndocker network create traefik\n\n이제 우리의 두 서비스, Traefik과 Dozzle이 이 네트워크에 속한다는 것을 밝혀야 합니다:\n\n<div class=\"content-ad\"></div>\n\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n      - \"1234:222\"\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n    networks:  # required\n      - traefik\n\nnetworks:\n  traefik:\n    external: true\n\nservices:\n  dozzle:\n    container_name: dozzle\n    image: amir20/dozzle:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    ports:\n      - 8081:8080\n    labels:\n      - traefik.enable=true  # 해당 서비스에 대해 Traefik을 활성화합니다.\n      - traefik.http.routers.dozzle.entrypoints=web  # 엔트리포인트를 지정합니다.\n      - traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`)  # 서비스에 액세스하는 규칙을 지정합니다.\n    networks:  # required\n      - traefik\n\nnetworks:\n  traefik:\n    external: true\n\n그러면 작동합니다. 그렇지 않으면, Traefik은 Dozzle 컨테이너의 IP로 리다이렉팅하겠지만, 이 IP는 서버에서 노출된 네트워크 바깥에 있는 Dozzle 컨테이너로 이어지지 않습니다.\n\n## 라우터\n\n<div class=\"content-ad\"></div>\n\n라우터는 적절한 서비스로 요청을 전달하는 역할을 합니다. 이는 동적 구성의 일환입니다.\n\n도즐(Dozzle)의 경우, 다음 라우터를 정의했습니다:\n\n- traefik.http.routers.dozzle.entrypoints=web  # 우리는 엔트리포인트를 지정합니다\n- traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`)  # 저희 서비스에 접근하는 규칙을 지정합니다\n\n또한 Docker 레이블 대신 파일에서도 구성할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\nhttp: routers: dozzle: entrypoints: -web;\nrule: Host(`dozzle.imbob.com`);\n\n그런 다음 정적 구성 파일에서 파일 제공자로 추가하십시오:\n\nproviders:\n  docker:\n    ...\n  file:\n    filename: /dynamic.yml\n\n당연히 이 파일을 컨테이너에 마운트해야 합니다:\n\n<div class=\"content-ad\"></div>\n\nservices:\n  reverse-proxy:\n    ...\n    volumes:\n      - ./dynamic.yml:/dynamic.yml:ro\n\nTraefik을 사용하는 것은 Docker 레이블을 사용하는 큰 장점이죠. 그러니 일단 이것을 사용하도록 하겠습니다. Middleware를 정의할 때 이 파일을 다시 살펴볼 거에요.\n\nEntryPoints와 마찬가지로, Routers에도 많은 구성 옵션이 있습니다. 가장 중요한 것은 Rule 옵션입니다. 이 옵션을 사용하면 라우터가 요청을 서비스로 전달하기 위한 규칙을 정의할 수 있습니다.\n\nDozzle에 사용한 규칙은 다음과 같았습니다:\n\n<div class=\"content-ad\"></div>\n\n호스트(`dozzle.imbob.com`);\n\n예를 들어 다음과 같이 사용할 수 있습니다:\n\n호스트(`dozzle1.imbob.com`) || 호스트(`dozzle2.imbob.com`);\n\nDozzle에 http://dozzle1.imbob.com 또는 http://dozzle2.imbob.com에서 액세스할 수 있습니다. 규칙에 대한 자세한 내용은 Traefik 문서를 참조하십시오.\n\n<div class=\"content-ad\"></div>\n\n## 미들웨어\n\n미들웨어는 서비스로 전송되기 전에 요청을 조정하는 데 사용됩니다. 미들웨어는 동적 구성에 정의됩니다.\n\n도즐에 인증을 추가해 보겠습니다. 먼저, 패키지 apache2-utils에 포함된 htpasswd를 사용하여 비밀번호를 생성해야 합니다.\n\nhtpasswd -nB test\n새 암호:\n새 암호 다시 입력:\ntest:$2y$05$kLDHhc5ntBoHwAyp5S48U.wN.u2eQJYWpfYvRWSilayuAe5oF2xqy\n\n<div class=\"content-ad\"></div>\n\n참고: docker-compose.yml에서 사용할 때 해시 내의 모든 달러 기호는 이스케이핑을 위해 두 배로 사용되어야 합니다. 따라서 대신 다음 명령을 사용하여 이를 자동으로 수행할 수 있습니다:\n\necho $(htpasswd -nB test) | sed -e s/\\\\$/\\\\$\\\\$/g\n새 암호:\n새 암호 다시 입력:\ntest:$$2y$$05$$uo7dTQpudzoJtmAhXLesxudke9edoGlxC6oaOL9zStHVayoVZ6xwm\n\n이제 docker-compose.yml 파일에 인증 미들웨어를 추가할 수 있습니다:\n\nservices:\n  dozzle:\n    ...\n    labels:\n      ...\n        # 패스워드는 \"test\" 입니다\n      - traefik.http.middlewares.my-middleware.basicauth.users=test:$$2y$$05$$x4VT4lRFCy2.z/Ic3BQYbOgEzDILEqyhaStkuzykurT9KAuWKTSF.\n\n<div class=\"content-ad\"></div>\n\n여기서는 미들웨어를 만들라고만 되어 있어요. 라우터에 그것을 사용하도록 지시해야 해요. 그래서 다음 레이블을 추가해요:\n\n- traefik.http.routers.dozzle.middlewares=my-middleware\n\n참고로 동적 구성 파일을 사용해서도 똑같은 작업을 할 수 있어요.\n\n전체 Docker compose 파일은 다음과 같아요:\n\n<div class=\"content-ad\"></div>\n\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n\n  dozzle:\n    container_name: dozzle\n    image: amir20/dozzle:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    ports:\n      - 8081:8080\n    labels:\n      - traefik.enable=true\n      - traefik.http.routers.dozzle.entrypoints=web\n      - traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`)\n      - traefik.http.middlewares.my-middleware.basicauth.users=test:$$2y$$05$$x4VT4lRFCy2.z/Ic3BQYbOgEzDILEqyhaStkuzykurT9KAuWKTSF.\n      - traefik.http.routers.dozzle.middlewares=my-middleware\n\n그리고 이제 http://dozzle.imbob.com 으로 이동하여 웹앱에 액세스하려면 기본 HTTP 인증을 요구할 것입니다.\n\n참고: Traefik이 이해하는 설정을 언제든지 웹 UI를 통해 확인할 수 있습니다:\n\n![Traefik Reverse Proxy 설정 화면](/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_2.png)\n\n<div class=\"content-ad\"></div>\n\n## HTTPS 활성화\n\n오늘날, 사용자들에게 신뢰감을 줄 수 있는 가장 기본적인 작업은 암호화된 연결을 제공하는 것입니다. Traefik을 사용하면 HTTPS 트래픽을 쉽게 제공할 수 있습니다.\n\nTraefik을 구성하여 정적 인증서를 사용하거나 ACME 공급자에 의해 자동으로 생성된 인증서를 사용하도록 설정할 수 있습니다.\n\n두 번째 옵션인 자동 생성 인증서를 사용하는 것이 가장 좋고 간단합니다. 그러니 이렇게 설정해 봅시다. Traefik의 정적 구성에 추가할 구성은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\ncertificatesResolver:\n  letsEncrypt:\n    acme:\n      email: bob@gmail.com  # 여러분의 이메일을 입력해주세요\n      storage: /tls/acme.json\n      httpChallenge:\n        entryPoint: web\n\n여기서 \"letsEncrypt\"라는 인증서 리졸버를 선언하고 있습니다. 우리는 이를 위해 이메일 주소, 인증서를 저장할 위치 및 이 리졸버와 관련된 엔트리포인트를 제공해야 합니다.\n\n기본적으로 우리는 무료이면서 접근성이 좋은 Let's Encrypt를 사용하고 있습니다. 위의 구성은 일반적으로 여러분의 도메인에 관계없이 작동할 것입니다. 하지만 Porkbun과 같은 다른 제공업체를 지정할 수도 있습니다:\n\ncertificatesResolvers:\n  porkbun:\n    acme:\n      email: bob@gmail.com\n      storage: /tls/porkbun.json\n      dnsChallenge:\n        provider: porkbun\n        delayBeforeCheck: 0\n\n<div class=\"content-ad\"></div>\n\n사용하는 공급업체에 따라 특정 옵션을 수정할 수 있어요. 예를 들어 Porkbun의 경우 환경 변수로 전달하는 API 키와 비밀 값을 제공해야 해요:\n\nservices:\n  reverse-proxy:\n    ...\n    environment:\n      PORKBUN_SECRET_API_KEY: my-secret\n      PORKBUN_API_KEY: my-key\n\n자세한 내용은 문서에서 확인해주세요.\n\n컨테이너가 종료되어도 인증서가 유지되어야 여러 API에서 제한을 받지 않아요. 그래서 docker-compose.yml 파일에 볼륨을 추가해봅시다:\n\n<div class=\"content-ad\"></div>\n\n서비스:\n  reverse-proxy:\n    ...\n    볼륨:\n      - tls:/tls\n\n볼륨:\n  tls:\n\n마지막으로, 우리는 인증서 리졸버를 사용하고자 한다고 명시해야 합니다 (이것은 자동으로 이루어지지 않습니다). 그리고 우리의 EntryPoint를 HTTPS 트래픽과 관련된 하나를 사용하도록 수정해야 합니다 (우리의 경우에는 websecure), 그래서 우리의 라우터를 수정합니다:\n\n서비스:\n  dozzle:\n    ...\n    레이블:\n    ...\n      - traefik.http.routers.dozzle.entrypoints=websecure\n      - traefik.http.routers.dozzle.tls.certresolver=letsEncrypt\n\n그래서 이제, 여기가 전체 파일이에요, docker-compose.yml:\n\n<div class=\"content-ad\"></div>\n\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"8080:8080\"\n      - \"443:443\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n      - tls:/tls\n\n  dozzle:\n    container_name: dozzle\n    image: amir20/dozzle:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    ports:\n      - 8081:8080\n    labels:\n      - traefik.enable=true\n      - traefik.http.routers.dozzle.entrypoints=websecure\n      - traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`)\n      - traefik.http.routers.dozzle.middlewares=my-middleware\n      - traefik.http.middlewares.my-middleware.basicauth.users=test:$$2y$$05$$x4VT4lRFCy2.z/Ic3BQYbOgEzDILEqyhaStkuzykurT9KAuWKTSF.\n      - traefik.http.routers.dozzle.tls.certresolver=letsEncrypt\n\nvolumes:\n  tls:\n\n그리고 traefik.yml:\n\napi:\n  insecure: true\n\nentryPoints:\n  web:\n    address: \":80\"\n\n  websecure:\n    address: \":443\"\n\n  ssh:\n    address: \":222\"\n\nproviders:\n  docker:\n    endpoint: \"unix:///var/run/docker.sock\"\n\ncertificatesResolver:\n  letsEncrypt:\n    acme:\n      email: bob@gmail.com\n      storage: /tls/acme.json\n      httpChallenge:\n        entryPoint: web\n\n## 마무리하는 손짓\n\n<div class=\"content-ad\"></div>\n\n완료하려면 먼저 Traefik을 우리 도메인 이름을 통해 쉽게 접근할 수 있도록 만들어야 합니다. 몇 가지 레이블을 추가하겠습니다:\n\nservices:\n  reverse-proxy:\n    ...\n    labels:\n      - traefik.enable=true\n      - traefik.http.routers.traefik-secure.entrypoints=websecure\n      - traefik.http.routers.traefik-secure.rule=Host(`traefik.imbob.com`)\n      - traefik.http.routers.traefik-secure.service=api@internal\n      - traefik.http.routers.traefik-secure.tls.certresolver=letsEncrypt\n\nTraefik의 장점은 초기 구성이 완료된 후 리버스 프록시 뒤에 서비스를 쉽게 추가할 수 있다는 것입니다. 몇 가지 Docker 레이블로 가능합니다.\n\ntraefik.yml에서 api.insecure를 비활성화하고 api.dashboard를 활성화할 수도 있습니다:\n\n<div class=\"content-ad\"></div>\n\napi:\n  insecure: false\n  dashboard: true\n\n마지막으로, HTTP 트래픽을 HTTPS로 리디렉션하는 설정 블록을 추가해봅시다. traefik.yml에서 web 엔트리포인트를 수정하면 됩니다:\n\nweb:\n  address: \":80\"\n  http:\n    redirections:\n      entryPoint:\n        to: websecure\n\n## TCP 트래픽 전달하기\n\n<div class=\"content-ad\"></div>\n\n시작 부분의 예시를 다시 가져오겠습니다. SSH EntryPoint와 함께:\n\nentrypoints: ssh: address: \":222\";\n\n도메인 이름 뒤에 SSH 트래픽을 전달하려고 합니다. EntryPoint가 있습니다. 호스트에서 포트를 노출해야 합니다:\n\nservices:\n  reverse-proxy:\n    ...\n    ports:\n      - 222:222\n\n<div class=\"content-ad\"></div>\n\n이제, 우리는 SSH 서버를 정의하는 docker-compose.yml 파일에 TCP 라우터를 정의할 수 있습니다:\n\nservices:\n  server:\n    ...\n    ports:\n      - 222:22\n    labels:\n      - traefik.enable=true\n      - traefik.tcp.routers.ssh.entrypoints=ssh\n      - traefik.tcp.routers.ssh.rule=HostSNI(`*`)\n\nHostSNI(\\*)은 모든 요청을 일치시킬 것이라고 말합니다. 올바른 엔트리 포인트로 전송된다면 모든 요청을 일치시킵니다. 따라서 이는 example.mydomain.com:222뿐만 아니라 anything.mydomain.com:222도 일치시킵니다. 이는 TCP 트래픽에 대해 TLS를 사용하지 않는 경우 필수적이며, HTTP 및 HTTPS 포트가 아닌 표준 TCP 포트를 사용하지 않는 경우에는 실제로 문제가 되지 않습니다.\n\n이것으로 끝입니다! 참고로, 저는 이를 Gitea와 함께 사용하여 다음과 같은 원격 URL을 가지고 있습니다: ssh://git@gitea.mydomain.com:222/estebanthi/my-repo.git.\n\n<div class=\"content-ad\"></div>\n\n아무것이나 원하는 대로 할 수 있습니다. 저는 SQL 데이터베이스와 함께도 이를 사용해요.\n\n## 보너스: 여러 호스트\n\n이 부분은 여러 대의 서버를 사용하는 사람들에게만 관련됩니다.\n\n서비스가 Traefik을 통해 접근 가능하도록 하려면 도커 네트워크에 속해 있어야 한다고 말씀드렸죠? 만약 여러 대의 서버를 가지고 있다면 이것이 문제가 될 수 있습니다. 적어도 도커 레이블을 더 이상 사용할 수 없게 되며, 서비스를 노출하고 파일 공급자를 통해 Traefik에 추가해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n대안으로 traefik-kop을 사용할 수 있습니다. 이제 \"서버 1\" (192.168.0.50)에 Traefik이 있고 \"서버 2\" (192.168.0.51)에 Dozzle이 있다고 가정해 봅시다.\n\n먼저 Traefik에 Redis 공급자를 추가해 보겠습니다.\n\nproviders:\n  docker:\n    ...\n  redis:\n    endpoints:\n      - \"redis:6379\"\n\n여기에서 Traefik을 실행 중인 호스트와 동일한 호스트에 Redis를 만들어 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\nservices:\n  reverse-proxy: ...\n\n  redis:\n    image: redis:latest\n    restart: unless-stopped\n    ports:\n      - \"6379:6379\"\n\n이제 \"서버 2\"에서 traefik-kop을 배포할 것입니다.\n\nservices:\n  traefik-kop:\n    image: \"ghcr.io/jittering/traefik-kop:latest\"\n    restart: unless-stopped\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n      - \"REDIS_ADDR=192.168.0.50:6379\" # Redis 호스트의 IP\n      - \"BIND_IP=192.168.0.51\" # 현재 호스트의 IP\n\n그러면 이제 \"server 2\"에서 계속해서 사용해오던 라벨들을 사용할 수 있게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n그런데 Redis 호스트의 TCP 트래픽을 노출하고 redis.mydomain.com:6379을 통해 접근할 수 있도록 설정할 수 있어요. 그러면 \"REDIS_ADDR\"이 \"redis.mydomain.com:6379\"로 변경돼요 (저는 이렇게 했어요). 이제는 알고 계시잖아요.\n\n## 마지막으로\n\n제가 설명을 명확히 전달했기를 바랍니다. Traefik은 처음에는 조금 혼란스러울 수 있지만 최대한 간단하게 설명하려고 노력했어요. 이해에 어려움이 있다면 언제든지 댓글을 달아 주세요!\n\n읽어 주셔서 감사합니다! 더 많은 내용을 보고 싶으시다면 아래에서 제 모든 게시물을 찾아보세요.\n","ogImage":{"url":"/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_0.png"},"coverImage":"/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_0.png","tag":["Tech"],"readingTime":18},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_0.png\" alt=\"Traefik 설치하기 쉽게 만든 Reverse Proxy의 최종 가이드\"></p>\n<p>셀프 호스팅 세계에서 많은 사람들이 Traefik의 설정이 어렵고 문서를 이해하기 어렵다고 불평한다는 것을 알았어요. 또한 기존 가이드 중 많은 것들이 Traefik가 어떻게 작동하는지 설명하지 않고 구성 예시만 제공하는 것을 알았어요.</p>\n<p>Traefik 가이드에 대한 저의 접근 방식은 ELI5 스타일로 Traefik에 대해 절대 모든 것을 이해하게 해줄 테니 기대해주세요.</p>\n<p>Medium 유료 회원이 아니신가요? 무료로 여기서 읽어보세요.</p>\n<h2>기초로 돌아가 — 반전 프록시란 무엇인가요?</h2>\n<p>반전 프록시는 다른 서버들 앞에 위치한 서버로, 요청을 이러한 서버들로 전달할 수도 있고 수정하거나 거부할 수도 있습니다.</p>\n<p>예를 들어, 밥이가 있습니다. 밥이는 라즈베리 파이에 웹사이트를 배포했습니다. 그 라즈베리의 IP는 192.168.0.50이며, 그의 사이트는 <a href=\"http://192.168.0.50:8080\" rel=\"nofollow\" target=\"_blank\">http://192.168.0.50:8080</a> 페이지로 접속할 수 있습니다. 그러나 그는 <a href=\"https://mysite.imbob.com%EC%9D%84\" rel=\"nofollow\" target=\"_blank\">https://mysite.imbob.com을</a> 입력하여 접속하고 싶어합니다. \"imbob.com\" 도메인을 소유하고 있다면, 반전 프록시를 이용하여 이를 할 수 있습니다. 더불어 IP를 화이트리스트로 추가하거나 인증을 추가하는 등의 보안 메커니즘을 추가할 수도 있습니다.</p>\n<p>역방향 프록시는 로드 밸런서 역할을 할 수도 있습니다. 단일 서버가 처리할 수 있는 트래픽보다 많은 트래픽을 받으면, 역방향 프록시는 요청을 다른 서버들 사이에 분배할 수 있습니다.</p>\n<h2>Traefik 최소 구성</h2>\n<p>당신이 Traefik을 설정할 때 Docker Compose를 사용한다고 가정하겠습니다. 여기 Traefik 문서에서 가져온 최소 예제가 있습니다:</p>\n<p>services:\nreverse-proxy: # The official v3 Traefik docker image\nimage: traefik:v3.0 # Enables the web UI and tells Traefik to listen to docker\ncommand: --api.insecure=true --providers.docker\nports: # The HTTP port - \"80:80\" # The Web UI (enabled by --api.insecure=true) - \"8080:8080\"\nvolumes: # So that Traefik can listen to the Docker events - /var/run/docker.sock:/var/run/docker.sock</p>\n<p>여기, 이해해야 할 몇 가지 사항이 있어요. --api.insecure=true은 API를 traefik 엔트리포인트에서 사용 가능하게 만들고 (--entrypoint에 대한 더 자세한 내용은 몇 분 후에 있습니다), --providers.docker은 도커 프로바이더를 활성화시켜 호스트에서 도커 서비스를 자동으로 발견할 수 있게 합니다. 이를 위해 Traefik 컨테이너에 도커 소켓을 마운트해야 하는데, 이는 볼륨 섹션에서 수행됩니다. 마지막으로 몇 가지 포트를 노출해야도 해요:</p>\n<ul>\n<li>80: 표준인 포트 80에서 HTTP 트래픽을 전달하기 위해</li>\n<li>8080: 웹 UI에 액세스하기 위해</li>\n</ul>\n<p>모든 것이 작동하는지 확인할 수 있어요. 웹 UI를 열어 <a href=\"http://your-ip:8080\" rel=\"nofollow\" target=\"_blank\">http://your-ip:8080</a> (<a href=\"http://192.168.0.50:8080%EC%9D%80\" rel=\"nofollow\" target=\"_blank\">http://192.168.0.50:8080은</a> Bob의 경우)으로 접속할 수 있어요.</p>\n<h2>설정 파일</h2>\n<p>Traefik을 구성하는 방법은 많이 있어요. 여기서 우리는 설정 매개변수를 컨테이너에 명령으로 전달했음을 볼 수 있어요. 이를 구성 파일을 통해 전달하거나 환경 변수를 통해 전달할 수도 있어요.</p>\n<p>우리의 간단한 예제를 위한 구성 파일은 다음과 같아요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">api</span>: <span class=\"hljs-attr\">insecure</span>: <span class=\"hljs-literal\">true</span>;\n\n<span class=\"hljs-attr\">providers</span>: <span class=\"hljs-attr\">docker</span>: <span class=\"hljs-attr\">endpoint</span>: <span class=\"hljs-string\">\"unix:///var/run/docker.sock\"</span>;\n</code></pre>\n<p>이건 YAML 파일이에요. 이 파일을 사용하려면 간단히 컨테이너에 마운트하시면 돼요:</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">reverse-proxy:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">traefik:latest</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"80:80\"</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"8080:8080\"</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./traefik.yml:/traefik.yml:ro</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">/var/run/docker.sock:/var/run/docker.sock</span>\n</code></pre>\n<p>그리고 모든 것이 이전과 같이 작동해야 합니다. 설정을 원하는대로 자유롭게 할 수 있으며, 이를 컨테이너 설정 파일을 통해하거나 Traefik 설정 파일을 통해하거나 환경 변수를 통해 할 수 있습니다. 개인적으로 Traefik 설정 파일을 통해 하는 것을 선호하므로 그대로 진행할 겁니다.</p>\n<p>그런데 말이야, 지금 이야기하고 있는 설정은 정적 설정이라고 알려져 있어요. 이 설정을 변경할 때마다 Traefik을 재시작해야 합니다. 나중에 동적 설정에 대해 이야기할 거에요.</p>\n<h2>EntryPoints</h2>\n<p>EntryPoints의 역할은 특정 포트의 트래픽을 캡처하는 것입니다. 일반적인 Traefik 설치에서는 보통 포트 80과 포트 443의 트래픽을 캡처하고 싶을 것입니다. 하지만 가능한 모든 것이 있습니다. 예를 들어, 저는 포트 222를 통해 통과하는 SSH 트래픽을 리다이렉트하는 데에도 Traefik을 사용합니다.</p>\n<p>EntryPoints는 정적 구성에서 정의됩니다. 예를 들어:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">entryPoints</span>: <span class=\"hljs-attr\">web</span>: <span class=\"hljs-attr\">address</span>: <span class=\"hljs-string\">\":80\"</span>;\n\n<span class=\"hljs-attr\">websecure</span>: <span class=\"hljs-attr\">address</span>: <span class=\"hljs-string\">\":443\"</span>;\n\n<span class=\"hljs-attr\">ssh</span>: <span class=\"hljs-attr\">address</span>: <span class=\"hljs-string\">\":222\"</span>;\n</code></pre>\n<p>EntryPoints의 이름은 원하는 대로 지정할 수 있습니다. 표준은 없습니다. EntryPoints를 구성하는 다양한 옵션들이 많이 있습니다. 이 안내서에서 모든 세부 내용을 다룰 수는 없으니, 기본 사항을 설명해 드리겠습니다. 더 알고 싶다면 문서를 참조해야 합니다.</p>\n<p>일반적으로 HTTP 트래픽을 모두 HTTPS 트래픽으로 리디렉션하여 연결을 보안하는 것이 좋습니다. 이를 수행하는 한 가지 방법은 EntryPoint에 리디렉션을 추가하는 것입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-attr\">entryPoints</span>: <span class=\"hljs-attr\">web</span>: <span class=\"hljs-attr\">address</span>: <span class=\"hljs-string\">\":80\"</span>;\n<span class=\"hljs-attr\">http</span>: <span class=\"hljs-attr\">redirections</span>: <span class=\"hljs-attr\">entryPoint</span>: <span class=\"hljs-attr\">to</span>: websecure;\n</code></pre>\n<p>여기서 모든 HTTP 트래픽이 websecure EntryPoint로 리디렉션되어야 함을 나타냅니다. 현재 TLS 인증서를 구성하지 않았으므로 이것을 구성에 유지하지 않는 것이 좋습니다.</p>\n<p>또한, 각 EntryPoint에 대해 컴퓨터의 포트를 열어야 합니다. 그래서 우리의 새로운 docker-compose.yml 파일은 다음과 같습니다:</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">reverse-proxy:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">traefik:latest</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"80:80\"</span> <span class=\"hljs-comment\"># web</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"443:443\"</span> <span class=\"hljs-comment\"># websecure</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"1234:222\"</span> <span class=\"hljs-comment\"># ssh</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">\"8080:8080\"</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./traefik.yml:/traefik.yml:ro</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">/var/run/docker.sock:/var/run/docker.sock</span>\n</code></pre>\n<p>알 수 있듯이, ssh 엔트리 포인트의 포트 매핑은 1234입니다. 즉, 포트 1234로 전송된 트래픽은 ssh 엔트리 포인트를 통해 전송됩니다. 제가 보여주려는 것은 포트를 원하는 대로 매핑할 수 있으며, 다른 포트를 80번 포트와 443번 포트로 매핑할 수도 있지만, 이는 표준이 아니므로 서비스에 액세스할 때 포트를 지정해야 합니다. 예를 들어, <a href=\"https://radarr.imbob.com:4430%EC%9D%B4%EB%9D%BC%EA%B3%A0\" rel=\"nofollow\" target=\"_blank\">https://radarr.imbob.com:4430이라고</a> 지정해야 하며, 443번 포트가 아닌 다른 포트로 매핑한 경우에는 <a href=\"https://radarr.imbob.com\" rel=\"nofollow\" target=\"_blank\">https://radarr.imbob.com</a> 대신에 이렇게 지정해야 할 것입니다.</p>\n<h2>DNS 레코드</h2>\n<p>도메인을 소유하고 있다고 가정하겠습니다. 소유하고 있지 않다면, PiHole과 같은 DNS 서버로 자체 도메인을 만들고 여기에 DNS 레코드를 추가할 수 있습니다.</p>\n<p>\"저는 원하는 것이 'something.mydomain'을 입력하면 Traefik이 호스팅된 머신에 도달하도록 하고 싶어요. 어디에서든 서비스를 이용할지, 또는 집에서만 이용할지에 따라 사용해야 하는 IP가 다릅니다. 예를 들어, 저는 집에서만 서비스에 접속하고 싶다고 가정해봅시다.</p>\n<p>해야 할 일은 로컬로 서버에 접속할 때 사용하는 IP를 가져와서 도메인 호스트에서 이 IP를 가리키는 A 레코드를 생성하는 것뿐입니다.</p>\n<p>예를 들어, Bob은 DNS에 다음 레코드를 가지고 있습니다:</p>\n<pre><code class=\"hljs language-js\">A  *.<span class=\"hljs-property\">imbob</span>.<span class=\"hljs-property\">com</span>  <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.50</span>\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n만약 <span class=\"hljs-title class_\">Bob</span>이 자신의 서비스를 어디서든 접근할 수 있게 하고 싶다면, 공용 <span class=\"hljs-variable constant_\">IP</span>를 사용하고 라우터 구성에서 포트 <span class=\"hljs-number\">80</span> 및 <span class=\"hljs-number\">443</span>을 전달해야 했을 것입니다. 예를 들어 다음과 같은 결과가 나오게 됩니다:\n\nA  *.<span class=\"hljs-property\">imbob</span>.<span class=\"hljs-property\">com</span>  <span class=\"hljs-number\">84.154</span><span class=\"hljs-number\">.65</span><span class=\"hljs-number\">.110</span>\n\n<span class=\"hljs-number\">84.154</span><span class=\"hljs-number\">.65</span><span class=\"hljs-number\">.110</span>이 그의 공용 <span class=\"hljs-variable constant_\">IP</span>인 것으로 가정합니다.\n\n또 다른 예를 들어보겠습니다. 저는 <span class=\"hljs-variable constant_\">VPN</span>을 사용합니다. 이 <span class=\"hljs-variable constant_\">VPN</span>에 연결되어 있을 때, <span class=\"hljs-variable constant_\">VPN</span>에 할당된 다른 <span class=\"hljs-variable constant_\">IP</span>를 통해 내 기기에 접근할 수 있습니다. <span class=\"hljs-variable constant_\">VPN</span>에서 연결될 때 보이는 <span class=\"hljs-variable constant_\">IP</span>를 사용하여 내 서비스를 <span class=\"hljs-variable constant_\">VPN</span>에 속한 누구에게든 접근 가능하게 하고 싶다면, 다음과 같이 할 수 있습니다:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\nA  *.<span class=\"hljs-property\">imbob</span>.<span class=\"hljs-property\">com</span>  <span class=\"hljs-number\">100.81</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.50</span>\n\n## 첫 번째 서비스 추가하기\n\n예를 들어, <span class=\"hljs-title class_\">Dozzle</span>를 사용해보겠습니다. <span class=\"hljs-title class_\">Dozzle</span>에 <span class=\"hljs-attr\">http</span>:<span class=\"hljs-comment\">//dozzle.imbob.com에서 액세스하고 싶습니다.</span>\n\n이제 docker-compose.<span class=\"hljs-property\">yml</span>에 <span class=\"hljs-title class_\">Dozzle</span>를 추가하겠습니다:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-attr\">services</span>:\n  reverse-<span class=\"hljs-attr\">proxy</span>:\n    <span class=\"hljs-attr\">image</span>: <span class=\"hljs-attr\">traefik</span>:latest\n    <span class=\"hljs-attr\">ports</span>:\n      - <span class=\"hljs-string\">\"80:80\"</span>\n      - <span class=\"hljs-string\">\"443:443\"</span>\n      - <span class=\"hljs-string\">\"1234:222\"</span>\n      - <span class=\"hljs-string\">\"8080:8080\"</span>\n    <span class=\"hljs-attr\">volumes</span>:\n      - ./traefik.<span class=\"hljs-property\">yml</span>:/traefik.<span class=\"hljs-property\">yml</span>:ro\n      - <span class=\"hljs-regexp\">/var/</span>run/docker.<span class=\"hljs-property\">sock</span>:<span class=\"hljs-regexp\">/var/</span>run/docker.<span class=\"hljs-property\">sock</span>\n\n  <span class=\"hljs-attr\">dozzle</span>:\n    <span class=\"hljs-attr\">container_name</span>: dozzle\n    <span class=\"hljs-attr\">image</span>: amir20/<span class=\"hljs-attr\">dozzle</span>:latest\n    <span class=\"hljs-attr\">volumes</span>:\n      - <span class=\"hljs-regexp\">/var/</span>run/docker.<span class=\"hljs-property\">sock</span>:<span class=\"hljs-regexp\">/var/</span>run/docker.<span class=\"hljs-property\">sock</span>:ro\n    <span class=\"hljs-attr\">ports</span>:\n      - <span class=\"hljs-number\">8081</span>:<span class=\"hljs-number\">8080</span>\n    <span class=\"hljs-attr\">labels</span>:\n      - traefik.<span class=\"hljs-property\">enable</span>=<span class=\"hljs-literal\">true</span> # 해당 서비스를 위해 <span class=\"hljs-title class_\">Traefik</span>를 활성화합니다\n      - traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">dozzle</span>.<span class=\"hljs-property\">entrypoints</span>=web # 엔트리포인트를 명시합니다\n      - traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">dozzle</span>.<span class=\"hljs-property\">rule</span>=<span class=\"hljs-title class_\">Host</span>(<span class=\"hljs-string\">`dozzle.imbob.com`</span>) # 서비스에 액세스하는 규칙을 명시합니다\n\n또한, <span class=\"hljs-title class_\">Traefik</span> 구성 파일을 아래에서 확인하실 수 있습니다:\n\n<span class=\"hljs-attr\">api</span>:\n  <span class=\"hljs-attr\">insecure</span>: <span class=\"hljs-literal\">true</span>\n\n<span class=\"hljs-attr\">entryPoints</span>:\n  <span class=\"hljs-attr\">web</span>:\n    <span class=\"hljs-attr\">address</span>: <span class=\"hljs-string\">\":80\"</span>\n\n  <span class=\"hljs-attr\">websecure</span>:\n    <span class=\"hljs-attr\">address</span>: <span class=\"hljs-string\">\":443\"</span>\n\n  <span class=\"hljs-attr\">ssh</span>:\n    <span class=\"hljs-attr\">address</span>: <span class=\"hljs-string\">\":222\"</span>\n\n<span class=\"hljs-attr\">providers</span>:\n  <span class=\"hljs-attr\">docker</span>:\n    <span class=\"hljs-attr\">endpoint</span>: <span class=\"hljs-string\">\"unix:///var/run/docker.sock\"</span>\n\n이제 <span class=\"hljs-attr\">http</span>:<span class=\"hljs-comment\">//dozzle.imbob.com을 열어 사용하실 수 있습니다.</span>\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n하지만 왜 이것이 작동하는 걸까요? 저희 서비스는 <span class=\"hljs-title class_\">Traefik</span> 서비스와 동일한 파일에 있기 때문에 동일한 <span class=\"hljs-title class_\">Docker</span> 네트워크에 속합니다. 이 네트워크는 포트 <span class=\"hljs-number\">80</span>과 <span class=\"hljs-number\">443</span>을 통해 노출되어 있습니다. 따라서 우리가 컴퓨터의 포트 <span class=\"hljs-number\">80</span>으로 요청을 보내면, 이는 <span class=\"hljs-title class_\">Dozzle</span>이 속한 <span class=\"hljs-title class_\">Docker</span> 네트워크로 진입하게 됩니다.\n\n이제 우리가 우리의 서비스를 해당 서비스를 자체 파일로 옮기고 싶다고 상상해 봅시다. 이 서비스를 <span class=\"hljs-title class_\">Traefik</span>의 <span class=\"hljs-title class_\">Docker</span> 네트워크에 연결해야 합니다. 다음과 같이 생성해 시작해 보죠:\n\ndocker network create traefik\n\n이제 우리의 두 서비스, <span class=\"hljs-title class_\">Traefik</span>과 <span class=\"hljs-title class_\">Dozzle</span>이 이 네트워크에 속한다는 것을 밝혀야 합니다:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-attr\">services</span>:\n  reverse-<span class=\"hljs-attr\">proxy</span>:\n    <span class=\"hljs-attr\">image</span>: <span class=\"hljs-attr\">traefik</span>:latest\n    <span class=\"hljs-attr\">ports</span>:\n      - <span class=\"hljs-string\">\"80:80\"</span>\n      - <span class=\"hljs-string\">\"443:443\"</span>\n      - <span class=\"hljs-string\">\"1234:222\"</span>\n      - <span class=\"hljs-string\">\"8080:8080\"</span>\n    <span class=\"hljs-attr\">volumes</span>:\n      - ./traefik.<span class=\"hljs-property\">yml</span>:/traefik.<span class=\"hljs-property\">yml</span>:ro\n      - <span class=\"hljs-regexp\">/var/</span>run/docker.<span class=\"hljs-property\">sock</span>:<span class=\"hljs-regexp\">/var/</span>run/docker.<span class=\"hljs-property\">sock</span>\n    <span class=\"hljs-attr\">networks</span>:  # required\n      - traefik\n\n<span class=\"hljs-attr\">networks</span>:\n  <span class=\"hljs-attr\">traefik</span>:\n    <span class=\"hljs-attr\">external</span>: <span class=\"hljs-literal\">true</span>\n\n<span class=\"hljs-attr\">services</span>:\n  <span class=\"hljs-attr\">dozzle</span>:\n    <span class=\"hljs-attr\">container_name</span>: dozzle\n    <span class=\"hljs-attr\">image</span>: amir20/<span class=\"hljs-attr\">dozzle</span>:latest\n    <span class=\"hljs-attr\">volumes</span>:\n      - <span class=\"hljs-regexp\">/var/</span>run/docker.<span class=\"hljs-property\">sock</span>:<span class=\"hljs-regexp\">/var/</span>run/docker.<span class=\"hljs-property\">sock</span>:ro\n    <span class=\"hljs-attr\">ports</span>:\n      - <span class=\"hljs-number\">8081</span>:<span class=\"hljs-number\">8080</span>\n    <span class=\"hljs-attr\">labels</span>:\n      - traefik.<span class=\"hljs-property\">enable</span>=<span class=\"hljs-literal\">true</span>  # 해당 서비스에 대해 <span class=\"hljs-title class_\">Traefik</span>을 활성화합니다.\n      - traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">dozzle</span>.<span class=\"hljs-property\">entrypoints</span>=web  # 엔트리포인트를 지정합니다.\n      - traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">dozzle</span>.<span class=\"hljs-property\">rule</span>=<span class=\"hljs-title class_\">Host</span>(<span class=\"hljs-string\">`dozzle.imbob.com`</span>)  # 서비스에 액세스하는 규칙을 지정합니다.\n    <span class=\"hljs-attr\">networks</span>:  # required\n      - traefik\n\n<span class=\"hljs-attr\">networks</span>:\n  <span class=\"hljs-attr\">traefik</span>:\n    <span class=\"hljs-attr\">external</span>: <span class=\"hljs-literal\">true</span>\n\n그러면 작동합니다. 그렇지 않으면, <span class=\"hljs-title class_\">Traefik</span>은 <span class=\"hljs-title class_\">Dozzle</span> 컨테이너의 <span class=\"hljs-variable constant_\">IP</span>로 리다이렉팅하겠지만, 이 <span class=\"hljs-variable constant_\">IP</span>는 서버에서 노출된 네트워크 바깥에 있는 <span class=\"hljs-title class_\">Dozzle</span> 컨테이너로 이어지지 않습니다.\n\n## 라우터\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n라우터는 적절한 서비스로 요청을 전달하는 역할을 합니다. 이는 동적 구성의 일환입니다.\n\n도즐(<span class=\"hljs-title class_\">Dozzle</span>)의 경우, 다음 라우터를 정의했습니다:\n\n- traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">dozzle</span>.<span class=\"hljs-property\">entrypoints</span>=web  # 우리는 엔트리포인트를 지정합니다\n- traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">dozzle</span>.<span class=\"hljs-property\">rule</span>=<span class=\"hljs-title class_\">Host</span>(<span class=\"hljs-string\">`dozzle.imbob.com`</span>)  # 저희 서비스에 접근하는 규칙을 지정합니다\n\n또한 <span class=\"hljs-title class_\">Docker</span> 레이블 대신 파일에서도 구성할 수 있습니다:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-attr\">http</span>: <span class=\"hljs-attr\">routers</span>: <span class=\"hljs-attr\">dozzle</span>: <span class=\"hljs-attr\">entrypoints</span>: -web;\n<span class=\"hljs-attr\">rule</span>: <span class=\"hljs-title class_\">Host</span>(<span class=\"hljs-string\">`dozzle.imbob.com`</span>);\n\n그런 다음 정적 구성 파일에서 파일 제공자로 추가하십시오:\n\n<span class=\"hljs-attr\">providers</span>:\n  <span class=\"hljs-attr\">docker</span>:\n    ...\n  <span class=\"hljs-attr\">file</span>:\n    <span class=\"hljs-attr\">filename</span>: /dynamic.<span class=\"hljs-property\">yml</span>\n\n당연히 이 파일을 컨테이너에 마운트해야 합니다:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-attr\">services</span>:\n  reverse-<span class=\"hljs-attr\">proxy</span>:\n    ...\n    <span class=\"hljs-attr\">volumes</span>:\n      - ./dynamic.<span class=\"hljs-property\">yml</span>:/dynamic.<span class=\"hljs-property\">yml</span>:ro\n\n<span class=\"hljs-title class_\">Traefik</span>을 사용하는 것은 <span class=\"hljs-title class_\">Docker</span> 레이블을 사용하는 큰 장점이죠. 그러니 일단 이것을 사용하도록 하겠습니다. <span class=\"hljs-title class_\">Middleware</span>를 정의할 때 이 파일을 다시 살펴볼 거에요.\n\n<span class=\"hljs-title class_\">EntryPoints</span>와 마찬가지로, <span class=\"hljs-title class_\">Routers</span>에도 많은 구성 옵션이 있습니다. 가장 중요한 것은 <span class=\"hljs-title class_\">Rule</span> 옵션입니다. 이 옵션을 사용하면 라우터가 요청을 서비스로 전달하기 위한 규칙을 정의할 수 있습니다.\n\n<span class=\"hljs-title class_\">Dozzle</span>에 사용한 규칙은 다음과 같았습니다:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n호스트(<span class=\"hljs-string\">`dozzle.imbob.com`</span>);\n\n예를 들어 다음과 같이 사용할 수 있습니다:\n\n호스트(<span class=\"hljs-string\">`dozzle1.imbob.com`</span>) || 호스트(<span class=\"hljs-string\">`dozzle2.imbob.com`</span>);\n\n<span class=\"hljs-title class_\">Dozzle</span>에 <span class=\"hljs-attr\">http</span>:<span class=\"hljs-comment\">//dozzle1.imbob.com 또는 http://dozzle2.imbob.com에서 액세스할 수 있습니다. 규칙에 대한 자세한 내용은 Traefik 문서를 참조하십시오.</span>\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n## 미들웨어\n\n미들웨어는 서비스로 전송되기 전에 요청을 조정하는 데 사용됩니다. 미들웨어는 동적 구성에 정의됩니다.\n\n도즐에 인증을 추가해 보겠습니다. 먼저, 패키지 apache2-utils에 포함된 htpasswd를 사용하여 비밀번호를 생성해야 합니다.\n\nhtpasswd -nB test\n새 암호:\n새 암호 다시 입력:\n<span class=\"hljs-attr\">test</span>:$2y$05$kLDHhc5ntBoHwAyp5S48U.<span class=\"hljs-property\">wN</span>.<span class=\"hljs-property\">u2eQJYWpfYvRWSilayuAe5oF2xqy</span>\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n참고: docker-compose.<span class=\"hljs-property\">yml</span>에서 사용할 때 해시 내의 모든 달러 기호는 이스케이핑을 위해 두 배로 사용되어야 합니다. 따라서 대신 다음 명령을 사용하여 이를 자동으로 수행할 수 있습니다:\n\necho $(htpasswd -nB test) | sed -e s/\\\\$/\\\\$\\\\$/g\n새 암호:\n새 암호 다시 입력:\n<span class=\"hljs-attr\">test</span>:$$2y$$05$$uo7dTQpudzoJtmAhXLesxudke9edoGlxC6oaOL9zStHVayoVZ6xwm\n\n이제 docker-compose.<span class=\"hljs-property\">yml</span> 파일에 인증 미들웨어를 추가할 수 있습니다:\n\n<span class=\"hljs-attr\">services</span>:\n  <span class=\"hljs-attr\">dozzle</span>:\n    ...\n    <span class=\"hljs-attr\">labels</span>:\n      ...\n        # 패스워드는 <span class=\"hljs-string\">\"test\"</span> 입니다\n      - traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">middlewares</span>.<span class=\"hljs-property\">my</span>-middleware.<span class=\"hljs-property\">basicauth</span>.<span class=\"hljs-property\">users</span>=<span class=\"hljs-attr\">test</span>:$$2y$$05$$x4VT4lRFCy2.<span class=\"hljs-property\">z</span>/<span class=\"hljs-title class_\">Ic3BQYbOgEzDILEqyhaStkuzykurT9KAuWKTSF</span>.\n\n&#x3C;div <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>>&#x3C;/div>\n\n여기서는 미들웨어를 만들라고만 되어 있어요. 라우터에 그것을 사용하도록 지시해야 해요. 그래서 다음 레이블을 추가해요:\n\n- traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">dozzle</span>.<span class=\"hljs-property\">middlewares</span>=my-middleware\n\n참고로 동적 구성 파일을 사용해서도 똑같은 작업을 할 수 있어요.\n\n전체 <span class=\"hljs-title class_\">Docker</span> compose 파일은 다음과 같아요:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-attr\">services</span>:\n  reverse-<span class=\"hljs-attr\">proxy</span>:\n    <span class=\"hljs-attr\">image</span>: <span class=\"hljs-attr\">traefik</span>:latest\n    <span class=\"hljs-attr\">ports</span>:\n      - <span class=\"hljs-string\">\"80:80\"</span>\n      - <span class=\"hljs-string\">\"443:443\"</span>\n      - <span class=\"hljs-string\">\"8080:8080\"</span>\n    <span class=\"hljs-attr\">volumes</span>:\n      - ./traefik.<span class=\"hljs-property\">yml</span>:/traefik.<span class=\"hljs-property\">yml</span>:ro\n      - <span class=\"hljs-regexp\">/var/</span>run/docker.<span class=\"hljs-property\">sock</span>:<span class=\"hljs-regexp\">/var/</span>run/docker.<span class=\"hljs-property\">sock</span>\n\n  <span class=\"hljs-attr\">dozzle</span>:\n    <span class=\"hljs-attr\">container_name</span>: dozzle\n    <span class=\"hljs-attr\">image</span>: amir20/<span class=\"hljs-attr\">dozzle</span>:latest\n    <span class=\"hljs-attr\">volumes</span>:\n      - <span class=\"hljs-regexp\">/var/</span>run/docker.<span class=\"hljs-property\">sock</span>:<span class=\"hljs-regexp\">/var/</span>run/docker.<span class=\"hljs-property\">sock</span>:ro\n    <span class=\"hljs-attr\">ports</span>:\n      - <span class=\"hljs-number\">8081</span>:<span class=\"hljs-number\">8080</span>\n    <span class=\"hljs-attr\">labels</span>:\n      - traefik.<span class=\"hljs-property\">enable</span>=<span class=\"hljs-literal\">true</span>\n      - traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">dozzle</span>.<span class=\"hljs-property\">entrypoints</span>=web\n      - traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">dozzle</span>.<span class=\"hljs-property\">rule</span>=<span class=\"hljs-title class_\">Host</span>(<span class=\"hljs-string\">`dozzle.imbob.com`</span>)\n      - traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">middlewares</span>.<span class=\"hljs-property\">my</span>-middleware.<span class=\"hljs-property\">basicauth</span>.<span class=\"hljs-property\">users</span>=<span class=\"hljs-attr\">test</span>:$$2y$$05$$x4VT4lRFCy2.<span class=\"hljs-property\">z</span>/<span class=\"hljs-title class_\">Ic3BQYbOgEzDILEqyhaStkuzykurT9KAuWKTSF</span>.\n      - traefik.<span class=\"hljs-property\">http</span>.<span class=\"hljs-property\">routers</span>.<span class=\"hljs-property\">dozzle</span>.<span class=\"hljs-property\">middlewares</span>=my-middleware\n\n그리고 이제 <span class=\"hljs-attr\">http</span>:<span class=\"hljs-comment\">//dozzle.imbob.com 으로 이동하여 웹앱에 액세스하려면 기본 HTTP 인증을 요구할 것입니다.</span>\n\n참고: <span class=\"hljs-title class_\">Traefik</span>이 이해하는 설정을 언제든지 웹 <span class=\"hljs-variable constant_\">UI</span>를 통해 확인할 수 있습니다:\n\n![<span class=\"hljs-title class_\">Traefik</span> <span class=\"hljs-title class_\">Reverse</span> <span class=\"hljs-title class_\">Proxy</span> 설정 화면](<span class=\"hljs-regexp\">/assets/img</span><span class=\"hljs-regexp\">/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_2.png)\n\n&#x3C;div class=\"content-ad\">&#x3C;/</span>div>\n\n## <span class=\"hljs-variable constant_\">HTTPS</span> 활성화\n\n오늘날, 사용자들에게 신뢰감을 줄 수 있는 가장 기본적인 작업은 암호화된 연결을 제공하는 것입니다. <span class=\"hljs-title class_\">Traefik</span>을 사용하면 <span class=\"hljs-variable constant_\">HTTPS</span> 트래픽을 쉽게 제공할 수 있습니다.\n\n<span class=\"hljs-title class_\">Traefik</span>을 구성하여 정적 인증서를 사용하거나 <span class=\"hljs-variable constant_\">ACME</span> 공급자에 의해 자동으로 생성된 인증서를 사용하도록 설정할 수 있습니다.\n\n두 번째 옵션인 자동 생성 인증서를 사용하는 것이 가장 좋고 간단합니다. 그러니 이렇게 설정해 봅시다. <span class=\"hljs-title class_\">Traefik</span>의 정적 구성에 추가할 구성은 다음과 같습니다:\n\n<span class=\"xml\"><span class=\"hljs-tag\">&#x3C;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"content-ad\"</span>></span><span class=\"hljs-tag\">&#x3C;/<span class=\"hljs-name\">div</span>></span></span>\n\n<span class=\"hljs-attr\">certificatesResolver</span>:\n  <span class=\"hljs-attr\">letsEncrypt</span>:\n    <span class=\"hljs-attr\">acme</span>:\n      <span class=\"hljs-attr\">email</span>: bob@gmail.<span class=\"hljs-property\">com</span>  # 여러분의 이메일을 입력해주세요\n      <span class=\"hljs-attr\">storage</span>: <span class=\"hljs-regexp\">/tls/</span>acme.<span class=\"hljs-property\">json</span>\n      <span class=\"hljs-attr\">httpChallenge</span>:\n        <span class=\"hljs-attr\">entryPoint</span>: web\n\n여기서 <span class=\"hljs-string\">\"letsEncrypt\"</span>라는 인증서 리졸버를 선언하고 있습니다. 우리는 이를 위해 이메일 주소, 인증서를 저장할 위치 및 이 리졸버와 관련된 엔트리포인트를 제공해야 합니다.\n\n기본적으로 우리는 무료이면서 접근성이 좋은 <span class=\"hljs-title class_\">Let</span><span class=\"hljs-string\">'s Encrypt를 사용하고 있습니다. 위의 구성은 일반적으로 여러분의 도메인에 관계없이 작동할 것입니다. 하지만 Porkbun과 같은 다른 제공업체를 지정할 수도 있습니다:\n\ncertificatesResolvers:\n  porkbun:\n    acme:\n      email: bob@gmail.com\n      storage: /tls/porkbun.json\n      dnsChallenge:\n        provider: porkbun\n        delayBeforeCheck: 0\n\n&#x3C;div class=\"content-ad\">&#x3C;/div>\n\n사용하는 공급업체에 따라 특정 옵션을 수정할 수 있어요. 예를 들어 Porkbun의 경우 환경 변수로 전달하는 API 키와 비밀 값을 제공해야 해요:\n\nservices:\n  reverse-proxy:\n    ...\n    environment:\n      PORKBUN_SECRET_API_KEY: my-secret\n      PORKBUN_API_KEY: my-key\n\n자세한 내용은 문서에서 확인해주세요.\n\n컨테이너가 종료되어도 인증서가 유지되어야 여러 API에서 제한을 받지 않아요. 그래서 docker-compose.yml 파일에 볼륨을 추가해봅시다:\n\n&#x3C;div class=\"content-ad\">&#x3C;/div>\n\n서비스:\n  reverse-proxy:\n    ...\n    볼륨:\n      - tls:/tls\n\n볼륨:\n  tls:\n\n마지막으로, 우리는 인증서 리졸버를 사용하고자 한다고 명시해야 합니다 (이것은 자동으로 이루어지지 않습니다). 그리고 우리의 EntryPoint를 HTTPS 트래픽과 관련된 하나를 사용하도록 수정해야 합니다 (우리의 경우에는 websecure), 그래서 우리의 라우터를 수정합니다:\n\n서비스:\n  dozzle:\n    ...\n    레이블:\n    ...\n      - traefik.http.routers.dozzle.entrypoints=websecure\n      - traefik.http.routers.dozzle.tls.certresolver=letsEncrypt\n\n그래서 이제, 여기가 전체 파일이에요, docker-compose.yml:\n\n&#x3C;div class=\"content-ad\">&#x3C;/div>\n\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"8080:8080\"\n      - \"443:443\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n      - tls:/tls\n\n  dozzle:\n    container_name: dozzle\n    image: amir20/dozzle:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    ports:\n      - 8081:8080\n    labels:\n      - traefik.enable=true\n      - traefik.http.routers.dozzle.entrypoints=websecure\n      - traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`)\n      - traefik.http.routers.dozzle.middlewares=my-middleware\n      - traefik.http.middlewares.my-middleware.basicauth.users=test:$$2y$$05$$x4VT4lRFCy2.z/Ic3BQYbOgEzDILEqyhaStkuzykurT9KAuWKTSF.\n      - traefik.http.routers.dozzle.tls.certresolver=letsEncrypt\n\nvolumes:\n  tls:\n\n그리고 traefik.yml:\n\napi:\n  insecure: true\n\nentryPoints:\n  web:\n    address: \":80\"\n\n  websecure:\n    address: \":443\"\n\n  ssh:\n    address: \":222\"\n\nproviders:\n  docker:\n    endpoint: \"unix:///var/run/docker.sock\"\n\ncertificatesResolver:\n  letsEncrypt:\n    acme:\n      email: bob@gmail.com\n      storage: /tls/acme.json\n      httpChallenge:\n        entryPoint: web\n\n## 마무리하는 손짓\n\n&#x3C;div class=\"content-ad\">&#x3C;/div>\n\n완료하려면 먼저 Traefik을 우리 도메인 이름을 통해 쉽게 접근할 수 있도록 만들어야 합니다. 몇 가지 레이블을 추가하겠습니다:\n\nservices:\n  reverse-proxy:\n    ...\n    labels:\n      - traefik.enable=true\n      - traefik.http.routers.traefik-secure.entrypoints=websecure\n      - traefik.http.routers.traefik-secure.rule=Host(`traefik.imbob.com`)\n      - traefik.http.routers.traefik-secure.service=api@internal\n      - traefik.http.routers.traefik-secure.tls.certresolver=letsEncrypt\n\nTraefik의 장점은 초기 구성이 완료된 후 리버스 프록시 뒤에 서비스를 쉽게 추가할 수 있다는 것입니다. 몇 가지 Docker 레이블로 가능합니다.\n\ntraefik.yml에서 api.insecure를 비활성화하고 api.dashboard를 활성화할 수도 있습니다:\n\n&#x3C;div class=\"content-ad\">&#x3C;/div>\n\napi:\n  insecure: false\n  dashboard: true\n\n마지막으로, HTTP 트래픽을 HTTPS로 리디렉션하는 설정 블록을 추가해봅시다. traefik.yml에서 web 엔트리포인트를 수정하면 됩니다:\n\nweb:\n  address: \":80\"\n  http:\n    redirections:\n      entryPoint:\n        to: websecure\n\n## TCP 트래픽 전달하기\n\n&#x3C;div class=\"content-ad\">&#x3C;/div>\n\n시작 부분의 예시를 다시 가져오겠습니다. SSH EntryPoint와 함께:\n\nentrypoints: ssh: address: \":222\";\n\n도메인 이름 뒤에 SSH 트래픽을 전달하려고 합니다. EntryPoint가 있습니다. 호스트에서 포트를 노출해야 합니다:\n\nservices:\n  reverse-proxy:\n    ...\n    ports:\n      - 222:222\n\n&#x3C;div class=\"content-ad\">&#x3C;/div>\n\n이제, 우리는 SSH 서버를 정의하는 docker-compose.yml 파일에 TCP 라우터를 정의할 수 있습니다:\n\nservices:\n  server:\n    ...\n    ports:\n      - 222:22\n    labels:\n      - traefik.enable=true\n      - traefik.tcp.routers.ssh.entrypoints=ssh\n      - traefik.tcp.routers.ssh.rule=HostSNI(`*`)\n\nHostSNI(\\*)은 모든 요청을 일치시킬 것이라고 말합니다. 올바른 엔트리 포인트로 전송된다면 모든 요청을 일치시킵니다. 따라서 이는 example.mydomain.com:222뿐만 아니라 anything.mydomain.com:222도 일치시킵니다. 이는 TCP 트래픽에 대해 TLS를 사용하지 않는 경우 필수적이며, HTTP 및 HTTPS 포트가 아닌 표준 TCP 포트를 사용하지 않는 경우에는 실제로 문제가 되지 않습니다.\n\n이것으로 끝입니다! 참고로, 저는 이를 Gitea와 함께 사용하여 다음과 같은 원격 URL을 가지고 있습니다: ssh://git@gitea.mydomain.com:222/estebanthi/my-repo.git.\n\n&#x3C;div class=\"content-ad\">&#x3C;/div>\n\n아무것이나 원하는 대로 할 수 있습니다. 저는 SQL 데이터베이스와 함께도 이를 사용해요.\n\n## 보너스: 여러 호스트\n\n이 부분은 여러 대의 서버를 사용하는 사람들에게만 관련됩니다.\n\n서비스가 Traefik을 통해 접근 가능하도록 하려면 도커 네트워크에 속해 있어야 한다고 말씀드렸죠? 만약 여러 대의 서버를 가지고 있다면 이것이 문제가 될 수 있습니다. 적어도 도커 레이블을 더 이상 사용할 수 없게 되며, 서비스를 노출하고 파일 공급자를 통해 Traefik에 추가해야 합니다.\n\n&#x3C;div class=\"content-ad\">&#x3C;/div>\n\n대안으로 traefik-kop을 사용할 수 있습니다. 이제 \"서버 1\" (192.168.0.50)에 Traefik이 있고 \"서버 2\" (192.168.0.51)에 Dozzle이 있다고 가정해 봅시다.\n\n먼저 Traefik에 Redis 공급자를 추가해 보겠습니다.\n\nproviders:\n  docker:\n    ...\n  redis:\n    endpoints:\n      - \"redis:6379\"\n\n여기에서 Traefik을 실행 중인 호스트와 동일한 호스트에 Redis를 만들어 보겠습니다.\n\n&#x3C;div class=\"content-ad\">&#x3C;/div>\n\nservices:\n  reverse-proxy: ...\n\n  redis:\n    image: redis:latest\n    restart: unless-stopped\n    ports:\n      - \"6379:6379\"\n\n이제 \"서버 2\"에서 traefik-kop을 배포할 것입니다.\n\nservices:\n  traefik-kop:\n    image: \"ghcr.io/jittering/traefik-kop:latest\"\n    restart: unless-stopped\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n      - \"REDIS_ADDR=192.168.0.50:6379\" # Redis 호스트의 IP\n      - \"BIND_IP=192.168.0.51\" # 현재 호스트의 IP\n\n그러면 이제 \"server 2\"에서 계속해서 사용해오던 라벨들을 사용할 수 있게 됩니다.\n\n&#x3C;div class=\"content-ad\">&#x3C;/div>\n\n그런데 Redis 호스트의 TCP 트래픽을 노출하고 redis.mydomain.com:6379을 통해 접근할 수 있도록 설정할 수 있어요. 그러면 \"REDIS_ADDR\"이 \"redis.mydomain.com:6379\"로 변경돼요 (저는 이렇게 했어요). 이제는 알고 계시잖아요.\n\n## 마지막으로\n\n제가 설명을 명확히 전달했기를 바랍니다. Traefik은 처음에는 조금 혼란스러울 수 있지만 최대한 간단하게 설명하려고 노력했어요. 이해에 어려움이 있다면 언제든지 댓글을 달아 주세요!\n\n읽어 주셔서 감사합니다! 더 많은 내용을 보고 싶으시다면 아래에서 제 모든 게시물을 찾아보세요.\n</span></code></pre>\n</body>\n</html>\n"},"__N_SSG":true}