{"pageProps":{"post":{"title":"언데드의 정체 노출하기 리눅스에서의 좀비 프로세스 이해 및 제거","description":"","date":"2024-06-19 08:42","slug":"2024-06-19-UnmaskingtheUndeadUnderstandingandEliminatingZombieProcessesinLinux","content":"\n\n![링크 텍스트](/assets/img/2024-06-19-UnmaskingtheUndeadUnderstandingandEliminatingZombieProcessesinLinux_0.png)\n\n좀비 프로세스는 Linux를 포함한 Unix류 운영 체제에서 흔히 발생하는 현상입니다. 스포키한 이름을 가졌지만, 소수의 좀비 프로세스는 해로울 만큼은 아니지만 관리되지 않으면 시스템 성능 문제를 일으킬 수 있습니다. 이 글에서는 좀비 프로세스가 무엇인지, 어떻게 생성되는지, 다양한 명령어, 스크립트 및 예제를 사용하여 그것들을 어떻게 제거하는지 설명하겠습니다.\n\n## 좀비 프로세스란 무엇인가요?\n\n좀비 프로세스 또는 defunct 프로세스는 실행을 완료했지만 프로세스 테이블에 여전히 기록이 남아 있는 프로세스입니다. 이것은 부모 프로세스가 종료된 프로세스의 종료 상태를 아직 읽지 않았기 때문에 발생합니다. 결과적으로, 프로세스는 \"좀비\" 상태에 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 좀비 프로세스는 어떻게 생성되나요?\n\n프로세스가 종료되면 부모 프로세스에게 SIGCHLD 시그널을 보냅니다. 부모 프로세스는 wait() 또는 waitpid() 시스템 호출을 사용하여 자식 프로세스의 종료 상태를 읽어야 합니다. 부모 프로세스가 이를 하지 않으면 종료된 프로세스가 좀비로서 프로세스 테이블에 남게 됩니다.\n\n## 좀비 프로세스 식별하기\n\n좀비 프로세스를 식별하기 위해 ps, top, htop 등의 명령어를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n사용하실 때는 아래와 같이 Markdown 형식의 테이블로 변환해주시면 됩니다.\n\n\n| 명령어 |\n| --- |\n| ps aux | grep Z |\n\n\n출력 결과에서 STAT 열에 \"Z\"가 있는 경우에는 좀비 프로세스를 나타냅니다.\n\nUsing top\n\n<div class=\"content-ad\"></div>\n\ntop 명령에서 좀비 프로세스는 Z 상태로 표시됩니다.\n\n```js\ntop\n```\n\nShift + z를 눌러 top 인터페이스에서 좀비 프로세스를 강조할 수 있습니다.\n\nhtop을 사용하여\n\n<div class=\"content-ad\"></div>\n\nhtop에서 좀비 프로세스는 상태 열에 Z로 표시됩니다.\n\n```js\nhtop\n```\n\n## 예시와 시나리오\n\n예시 1: 좀비 프로세스 생성하기\n\n<div class=\"content-ad\"></div>\n\n간단한 시나리오를 만들어 좀비 프로세스가 어떻게 생성되는지 이해해봅시다. 다음과 같은 C 프로그램을 고려해보세요:\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid > 0) {\n        // 부모 프로세스\n        sleep(30); // 좀비를 관찰할 시간을 줍시다\n    } else if (pid == 0) {\n        // 자식 프로세스\n        exit(0); // 자식 프로세스는 즉시 종료됩니다\n    } else {\n        perror(\"fork\");\n        exit(1);\n    }\n    return 0;\n}\n```\n\n```bash\n이 프로그램을 컴파일하고 실행합니다:\n```\n\n```bash\ngcc -o zombie_example zombie_example.c\n./zombie_example\n```\n\n<div class=\"content-ad\"></div>\n\n부모 프로세스가 sleep 중일 때, 좀비 프로세스를 관찰하기 위해 ps 또는 top을 사용해보세요.\n\n예시 2: 좀비 프로세스 제거하기\n\n좀비 프로세스를 제거하려면, 부모 프로세스가 자식 프로세스의 종료 상태를 읽도록 해야 합니다. 이는 부모 프로세스를 수정하여 SIGCHLD 시그널을 처리하거나 wait()를 사용하는 방법으로 수행할 수 있습니다.\n\n이전 프로그램을 수정하여 SIGCHLD 시그널을 처리하는 예시를 아래에 제시합니다:\n\n<div class=\"content-ad\"></div>\n\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <signal.h>\n#include <sys/wait.h>\n\nvoid handle_sigchld(int sig) {\n    (void)sig; // 사용되지 않는 매개변수 경고 억제\n    while (waitpid(-1, NULL, WNOHANG) > 0) {\n        // 모든 종료된 자식 프로세스를 처리\n    }\n}\n\nint main() {\n    signal(SIGCHLD, handle_sigchld);\n    pid_t pid = fork();\n    if (pid > 0) {\n        // 부모 프로세스\n        sleep(30);\n    } else if (pid == 0) {\n        // 자식 프로세스\n        exit(0);\n    } else {\n        perror(\"fork\");\n        exit(1);\n    }\n    return 0;\n}\n```\n\n이제 변경된 프로그램을 다시 컴파일하여 실행하여 좀비 프로세스가 올바르게 처리되는지 확인하세요.\n\n## 좀비 프로세스 관리 스크립트\n\n실제 시나리오에서 여러 응용 프로그램에 의해 생성된 좀비 프로세스를 만날 수 있습니다. 아래는 좀비 프로세스를 관리하고 제거하는 데 도움이 되는 몇 가지 스크립트입니다.\n\n<div class=\"content-ad\"></div>\n\n스크립트 1: 좀비 프로세스 감시 및 보고\n\n좀비 프로세스를 모니터링하고 보고하는 스크립트를 만들어보세요:\n\n```bash\n#!/bin/bash\n\nwhile true; do\n    ZOMBIES=$(ps aux | awk '{if ($8 == \"Z\") print $2}')\n    if [ -n \"$ZOMBIES\" ]; then\n        echo \"좀비 프로세스가 감지되었습니다: $ZOMBIES\"\n    fi\n    sleep 5\ndone\n```\n\n이 스크립트를 monitor_zombies.sh로 저장하고, 실행 가능하도록 만든 후 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n\n```js\nchmod +x monitor_zombies.sh\n./monitor_zombies.sh\n```\n\nScript 2: Killing Parent Processes of Zombies\n\nIf you need to eliminate zombie processes quickly, you can kill their parent processes. Use this script with caution, as it will terminate the parent processes:\n\n```js\n#!/bin/bash\nZOMBIE_PARENTS=$(ps -eo ppid,stat | awk '$2 ~ /Z/ {print $1}' | sort -u)\nfor ppid in $ZOMBIE_PARENTS; do\n    echo \"Killing parent process $ppid of zombie processes\"\n    kill -9 $ppid\ndone\n``` \n\n\n<div class=\"content-ad\"></div>\n\n이 스크립트를 kill_zombie_parents.sh로 저장하고 실행 가능하게 만들어서 실행하세요:\n\n```js\nchmod +x kill_zombie_parents.sh\n./kill_zombie_parents.sh\n```\n\n좀비 프로세스는 즉시 해로운 것은 아니지만 확인되지 않으면 리소스 누출과 시스템의 불안정성으로 이어질 수 있습니다. 이러한 프로세스가 어떻게 생성되는지 이해하고 식별하여 제거하는 방법을 알아두는 것은 건강한 Linux 시스템을 유지하는 데 중요합니다. 제공된 명령어, 예시, 스크립트를 사용하여 효과적으로 좀비 프로세스를 관리하고 시스템이 원할하게 실행되도록 할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-UnmaskingtheUndeadUnderstandingandEliminatingZombieProcessesinLinux_0.png"},"coverImage":"/assets/img/2024-06-19-UnmaskingtheUndeadUnderstandingandEliminatingZombieProcessesinLinux_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-19-UnmaskingtheUndeadUnderstandingandEliminatingZombieProcessesinLinux_0.png\" alt=\"링크 텍스트\"></p>\n<p>좀비 프로세스는 Linux를 포함한 Unix류 운영 체제에서 흔히 발생하는 현상입니다. 스포키한 이름을 가졌지만, 소수의 좀비 프로세스는 해로울 만큼은 아니지만 관리되지 않으면 시스템 성능 문제를 일으킬 수 있습니다. 이 글에서는 좀비 프로세스가 무엇인지, 어떻게 생성되는지, 다양한 명령어, 스크립트 및 예제를 사용하여 그것들을 어떻게 제거하는지 설명하겠습니다.</p>\n<h2>좀비 프로세스란 무엇인가요?</h2>\n<p>좀비 프로세스 또는 defunct 프로세스는 실행을 완료했지만 프로세스 테이블에 여전히 기록이 남아 있는 프로세스입니다. 이것은 부모 프로세스가 종료된 프로세스의 종료 상태를 아직 읽지 않았기 때문에 발생합니다. 결과적으로, 프로세스는 \"좀비\" 상태에 있습니다.</p>\n<h2>좀비 프로세스는 어떻게 생성되나요?</h2>\n<p>프로세스가 종료되면 부모 프로세스에게 SIGCHLD 시그널을 보냅니다. 부모 프로세스는 wait() 또는 waitpid() 시스템 호출을 사용하여 자식 프로세스의 종료 상태를 읽어야 합니다. 부모 프로세스가 이를 하지 않으면 종료된 프로세스가 좀비로서 프로세스 테이블에 남게 됩니다.</p>\n<h2>좀비 프로세스 식별하기</h2>\n<p>좀비 프로세스를 식별하기 위해 ps, top, htop 등의 명령어를 사용할 수 있습니다.</p>\n<p>사용하실 때는 아래와 같이 Markdown 형식의 테이블로 변환해주시면 됩니다.</p>\n<table>\n<thead>\n<tr>\n<th>명령어</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ps aux</td>\n</tr>\n</tbody>\n</table>\n<p>출력 결과에서 STAT 열에 \"Z\"가 있는 경우에는 좀비 프로세스를 나타냅니다.</p>\n<p>Using top</p>\n<p>top 명령에서 좀비 프로세스는 Z 상태로 표시됩니다.</p>\n<pre><code class=\"hljs language-js\">top\n</code></pre>\n<p>Shift + z를 눌러 top 인터페이스에서 좀비 프로세스를 강조할 수 있습니다.</p>\n<p>htop을 사용하여</p>\n<p>htop에서 좀비 프로세스는 상태 열에 Z로 표시됩니다.</p>\n<pre><code class=\"hljs language-js\">htop\n</code></pre>\n<h2>예시와 시나리오</h2>\n<p>예시 1: 좀비 프로세스 생성하기</p>\n<p>간단한 시나리오를 만들어 좀비 프로세스가 어떻게 생성되는지 이해해봅시다. 다음과 같은 C 프로그램을 고려해보세요:</p>\n<pre><code class=\"hljs language-c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;stdio.h></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;stdlib.h></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;unistd.h></span></span>\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-type\">pid_t</span> pid = fork();\n    <span class=\"hljs-keyword\">if</span> (pid > <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-comment\">// 부모 프로세스</span>\n        sleep(<span class=\"hljs-number\">30</span>); <span class=\"hljs-comment\">// 좀비를 관찰할 시간을 줍시다</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pid == <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-comment\">// 자식 프로세스</span>\n        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// 자식 프로세스는 즉시 종료됩니다</span>\n    } <span class=\"hljs-keyword\">else</span> {\n        perror(<span class=\"hljs-string\">\"fork\"</span>);\n        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<pre><code class=\"hljs language-bash\">이 프로그램을 컴파일하고 실행합니다:\n</code></pre>\n<pre><code class=\"hljs language-bash\">gcc -o zombie_example zombie_example.c\n./zombie_example\n</code></pre>\n<p>부모 프로세스가 sleep 중일 때, 좀비 프로세스를 관찰하기 위해 ps 또는 top을 사용해보세요.</p>\n<p>예시 2: 좀비 프로세스 제거하기</p>\n<p>좀비 프로세스를 제거하려면, 부모 프로세스가 자식 프로세스의 종료 상태를 읽도록 해야 합니다. 이는 부모 프로세스를 수정하여 SIGCHLD 시그널을 처리하거나 wait()를 사용하는 방법으로 수행할 수 있습니다.</p>\n<p>이전 프로그램을 수정하여 SIGCHLD 시그널을 처리하는 예시를 아래에 제시합니다:</p>\n<pre><code class=\"hljs language-cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;stdio.h></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;stdlib.h></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;unistd.h></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;signal.h></span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&#x3C;sys/wait.h></span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">handle_sigchld</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> sig)</span> </span>{\n    (<span class=\"hljs-type\">void</span>)sig; <span class=\"hljs-comment\">// 사용되지 않는 매개변수 경고 억제</span>\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">waitpid</span>(<span class=\"hljs-number\">-1</span>, <span class=\"hljs-literal\">NULL</span>, WNOHANG) > <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-comment\">// 모든 종료된 자식 프로세스를 처리</span>\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">signal</span>(SIGCHLD, handle_sigchld);\n    <span class=\"hljs-type\">pid_t</span> pid = fork();\n    <span class=\"hljs-keyword\">if</span> (pid > <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-comment\">// 부모 프로세스</span>\n        <span class=\"hljs-built_in\">sleep</span>(<span class=\"hljs-number\">30</span>);\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pid == <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-comment\">// 자식 프로세스</span>\n        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">0</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n        <span class=\"hljs-built_in\">perror</span>(<span class=\"hljs-string\">\"fork\"</span>);\n        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n<p>이제 변경된 프로그램을 다시 컴파일하여 실행하여 좀비 프로세스가 올바르게 처리되는지 확인하세요.</p>\n<h2>좀비 프로세스 관리 스크립트</h2>\n<p>실제 시나리오에서 여러 응용 프로그램에 의해 생성된 좀비 프로세스를 만날 수 있습니다. 아래는 좀비 프로세스를 관리하고 제거하는 데 도움이 되는 몇 가지 스크립트입니다.</p>\n<p>스크립트 1: 좀비 프로세스 감시 및 보고</p>\n<p>좀비 프로세스를 모니터링하고 보고하는 스크립트를 만들어보세요:</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/bash</span>\n\n<span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">true</span>; <span class=\"hljs-keyword\">do</span>\n    ZOMBIES=$(ps aux | awk <span class=\"hljs-string\">'{if ($8 == \"Z\") print $2}'</span>)\n    <span class=\"hljs-keyword\">if</span> [ -n <span class=\"hljs-string\">\"<span class=\"hljs-variable\">$ZOMBIES</span>\"</span> ]; <span class=\"hljs-keyword\">then</span>\n        <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">\"좀비 프로세스가 감지되었습니다: <span class=\"hljs-variable\">$ZOMBIES</span>\"</span>\n    <span class=\"hljs-keyword\">fi</span>\n    <span class=\"hljs-built_in\">sleep</span> 5\n<span class=\"hljs-keyword\">done</span>\n</code></pre>\n<p>이 스크립트를 monitor_zombies.sh로 저장하고, 실행 가능하도록 만든 후 실행하세요:</p>\n<pre><code class=\"hljs language-js\">chmod +x monitor_zombies.<span class=\"hljs-property\">sh</span>\n./monitor_zombies.<span class=\"hljs-property\">sh</span>\n</code></pre>\n<p>Script 2: Killing Parent Processes of Zombies</p>\n<p>If you need to eliminate zombie processes quickly, you can kill their parent processes. Use this script with caution, as it will terminate the parent processes:</p>\n<pre><code class=\"hljs language-js\">#!<span class=\"hljs-regexp\">/bin/</span>bash\n<span class=\"hljs-variable constant_\">ZOMBIE_PARENTS</span>=$(ps -eo ppid,stat | awk <span class=\"hljs-string\">'$2 ~ /Z/ {print $1}'</span> | sort -u)\n<span class=\"hljs-keyword\">for</span> ppid <span class=\"hljs-keyword\">in</span> $ZOMBIE_PARENTS; <span class=\"hljs-keyword\">do</span>\n    echo <span class=\"hljs-string\">\"Killing parent process $ppid of zombie processes\"</span>\n    kill -<span class=\"hljs-number\">9</span> $ppid\ndone\n</code></pre>\n<p>이 스크립트를 kill_zombie_parents.sh로 저장하고 실행 가능하게 만들어서 실행하세요:</p>\n<pre><code class=\"hljs language-js\">chmod +x kill_zombie_parents.<span class=\"hljs-property\">sh</span>\n./kill_zombie_parents.<span class=\"hljs-property\">sh</span>\n</code></pre>\n<p>좀비 프로세스는 즉시 해로운 것은 아니지만 확인되지 않으면 리소스 누출과 시스템의 불안정성으로 이어질 수 있습니다. 이러한 프로세스가 어떻게 생성되는지 이해하고 식별하여 제거하는 방법을 알아두는 것은 건강한 Linux 시스템을 유지하는 데 중요합니다. 제공된 명령어, 예시, 스크립트를 사용하여 효과적으로 좀비 프로세스를 관리하고 시스템이 원할하게 실행되도록 할 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}