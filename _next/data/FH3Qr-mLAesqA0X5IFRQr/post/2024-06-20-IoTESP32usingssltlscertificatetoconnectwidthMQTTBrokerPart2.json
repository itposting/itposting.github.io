{"pageProps":{"post":{"title":"IoT ESP32가 MQTT Broker에 연결하기 위해 SSL TLS 인증서를 사용하는 방법 파트 2","description":"","date":"2024-06-20 17:06","slug":"2024-06-20-IoTESP32usingssltlscertificatetoconnectwidthMQTTBrokerPart2","content":"\n\n시작부터 따라오고 싶다면 다음 링크를 확인하세요 (Part 1)\n\n[Part 1](/assets/img/2024-06-20-IoTESP32usingssltlscertificatetoconnectwidthMQTTBrokerPart2_0.png)\n\n## 개요\n\n이 기사에서는 ESP32를 사용하여 SSL/TLS 프로토콜에서 MQTT 통신을 하는 방법을 보여줍니다. 암호화된 메시지를 발행하고 주제를 구독하는 방법에 대해 설명합니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 똑같은 Raspberry Pi 3에 설치된 Mosquitto 브로커를 사용할 것입니다. 이 브로커는 모든 메시지를 수신하고, 메시지를 필터링하며, 누가 관심이 있는지 결정하고 구독한 모든 클라이언트에게 메시지를 게시하는 역할을 합니다.\n\n# 준비 사항\n\n- Raspberry Pi에 익숙해야 합니다 — Getting Started with Raspberry Pi와 Arduino IDE를 읽어보세요.\n- Raspberry Pi에 Raspbian 운영 체제가 설치되어 있어야 합니다 — Raspbian Lite 설치와 SSH로 연결하는 방법에 대한 유튜브 비디오를 시청하세요.\n- esp32 컨트롤러가 필요합니다.\n- MQTT가 무엇이고 어떻게 작동하는지 배워보세요.\n\n여기가 전체 코드입니다:\n\n<div class=\"content-ad\"></div>\n\n```json\n#include \"WiFiClientSecure.h\"\n#include <PubSubClient.h>\n#include \"credentials.h\"\n\n// WiFi credentials\nconst char* ssid = \"<와이파이 라우터 이름>\";\nconst char* password = \"<와이파이 비밀번호>\";\n\n// MQTT Broker credentials\nconst char* mqtt_broker = \"<브로커의 IP 주소>\";\nconst char* topic = \"test\";\nconst int mqtt_port = 8883 ;\n\n// SSL 인증서 설정\nconst char* root_ca =  CA_CRT;\nconst char* server_cert = SERVER_CERT;\nconst char* server_key  = SERVER_KEY;\n\n// WiFiClient espClient;\nWiFiClientSecure espClient;\nPubSubClient client(espClient);\n\nvoid setup() {\n  // 소프트웨어 시리얼 보드레이트 설정: 115200\n  Serial.begin(115200);\n  // WiFi 네트워크에 연결\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.println(\"WiFi에 연결 중..\");\n  }\n  Serial.println(\"WiFi 네트워크에 연결되었습니다.\");\n  // SSL을 사용하여 MQTT 브로커에 연결\n  espClient.setCACert(root_ca);\n  espClient.setCertificate(server_cert);  // 클라이언트 확인을 위해\n  espClient.setPrivateKey(server_key);    // 클라이언트 확인을 위해\n\n  // 원격 MQTT 브로커에 연결\n  client.setServer(mqtt_broker, mqtt_port);\n  client.setCallback(callback);\n\n  while (!client.connected()) {\n    // 클라이언트 ID 생성\n    String client_id = \"esp32-client\";\n    client_id += String(WiFi.macAddress());\n    // esp32 컨트롤러의 이름과 ID 출력\n    Serial.printf(\"클라이언트 %s가 공개 MQTT 브로커에 연결합니다\\n\", client_id.c_str());\n    if (client.connect( client_id.c_str())) {\n      Serial.println(\"Public emqx mqtt 브로커에 연결되었습니다\");\n    } else {\n      Serial.print(\"연결 실패, 상태: \");\n      Serial.print(client.state());\n      delay(2000);\n    }\n  }\n  // 게시 및 구독\n  client.publish(topic, \"안녕, 나는 ESP32^^\");\n  client.subscribe(topic);\n}\n\nvoid callback(char* topic, byte* payload, unsigned int length) {\n  Serial.print(\"주제에서 메시지 도착: \");\n  Serial.println(topic);\n  Serial.print(\"메시지:\");\n  for (int i = 0; i < length; i++) {\n    Serial.print((char)payload[i]);\n  }\n  Serial.println();\n  Serial.println(\"-----------------------\");\n}\n\nvoid loop() {\n  client.loop();\n\n  client.publish(topic, \"ESP32가 MQTT 브로커로 암호화된 메시지를 보냅니다\");\n\n  // 10초마다 메시지 전송\n  delay(10000);\n}\n```\n\nSSL 인증서를 설정하려면 credentials.h 파일을 작성해야 합니다.\n\n아래와 같은 형태여야 합니다:\n\n```js\n#define CA_CRT                                                           \\\n    \"-----BEGIN CERTIFICATE-----\\n\"                                      \\\n    \"MIIDVzCCAj+gAwIBAgIUIwOnfZCxwCKrQXHpbI0rVksEcaMwDQYJKoZIhvcNAQEL\\n\" \\\n    // 중략\n#define SERVER_CERT                                                      \\\n    \"-----BEGIN CERTIFICATE-----\\n\"                                      \\\n    \"MIIDBTCCAe0CFHjJN1GNHVnqXiMyngV3yvLg/70FMA0GCSqGSIb3DQEBCwUAMDsx\\n\" \\\n    // 중략\n#define SERVER_KEY                                                       \\\n    \"-----BEGIN RSA PRIVATE KEY-----\\n\"                                  \\\n    \"MIIEpQIBAAKCAQEAvsxvL0H8M9HjGplper2/oRtQQTFfBYLX3JfBrTJIXD6A5HFJ\\n\" \\\n    // 중략\n```\n\n<div class=\"content-ad\"></div>\n\n그런 다음 자격 증명 파일을 업로드하려는 메인 파일에 자격 증명.h 파일을 가져와서 사용할 수 있습니다.\n\n## 마지막으로 MQTT 브로커에서 나타나는 다음 메시지를 확인해야합니다.\n\n![이미지](/assets/img/2024-06-20-IoTESP32usingssltlscertificatetoconnectwidthMQTTBrokerPart2_1.png)\n\n# 정리\n\n<div class=\"content-ad\"></div>\n\n요약하면, 저는 브로커 부분과 컨트롤러 부분을 포함한 가정용 IOT 시스템의 기본 개념을 보여드렸습니다.","ogImage":{"url":"/assets/img/2024-06-20-IoTESP32usingssltlscertificatetoconnectwidthMQTTBrokerPart2_0.png"},"coverImage":"/assets/img/2024-06-20-IoTESP32usingssltlscertificatetoconnectwidthMQTTBrokerPart2_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>시작부터 따라오고 싶다면 다음 링크를 확인하세요 (Part 1)</p>\n<p><a href=\"/assets/img/2024-06-20-IoTESP32usingssltlscertificatetoconnectwidthMQTTBrokerPart2_0.png\">Part 1</a></p>\n<h2>개요</h2>\n<p>이 기사에서는 ESP32를 사용하여 SSL/TLS 프로토콜에서 MQTT 통신을 하는 방법을 보여줍니다. 암호화된 메시지를 발행하고 주제를 구독하는 방법에 대해 설명합니다.</p>\n<p>우리는 똑같은 Raspberry Pi 3에 설치된 Mosquitto 브로커를 사용할 것입니다. 이 브로커는 모든 메시지를 수신하고, 메시지를 필터링하며, 누가 관심이 있는지 결정하고 구독한 모든 클라이언트에게 메시지를 게시하는 역할을 합니다.</p>\n<h1>준비 사항</h1>\n<ul>\n<li>Raspberry Pi에 익숙해야 합니다 — Getting Started with Raspberry Pi와 Arduino IDE를 읽어보세요.</li>\n<li>Raspberry Pi에 Raspbian 운영 체제가 설치되어 있어야 합니다 — Raspbian Lite 설치와 SSH로 연결하는 방법에 대한 유튜브 비디오를 시청하세요.</li>\n<li>esp32 컨트롤러가 필요합니다.</li>\n<li>MQTT가 무엇이고 어떻게 작동하는지 배워보세요.</li>\n</ul>\n<p>여기가 전체 코드입니다:</p>\n<pre><code class=\"hljs language-json\">#include <span class=\"hljs-string\">\"WiFiClientSecure.h\"</span>\n#include &#x3C;PubSubClient.h>\n#include <span class=\"hljs-string\">\"credentials.h\"</span>\n\n<span class=\"hljs-comment\">// WiFi credentials</span>\nconst char* ssid = <span class=\"hljs-string\">\"&#x3C;와이파이 라우터 이름>\"</span>;\nconst char* password = <span class=\"hljs-string\">\"&#x3C;와이파이 비밀번호>\"</span>;\n\n<span class=\"hljs-comment\">// MQTT Broker credentials</span>\nconst char* mqtt_broker = <span class=\"hljs-string\">\"&#x3C;브로커의 IP 주소>\"</span>;\nconst char* topic = <span class=\"hljs-string\">\"test\"</span>;\nconst int mqtt_port = <span class=\"hljs-number\">8883</span> ;\n\n<span class=\"hljs-comment\">// SSL 인증서 설정</span>\nconst char* root_ca =  CA_CRT;\nconst char* server_cert = SERVER_CERT;\nconst char* server_key  = SERVER_KEY;\n\n<span class=\"hljs-comment\">// WiFiClient espClient;</span>\nWiFiClientSecure espClient;\nPubSubClient client(espClient);\n\nvoid setup() <span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-comment\">// 소프트웨어 시리얼 보드레이트 설정: 115200</span>\n  Serial.begin(<span class=\"hljs-number\">115200</span>);\n  <span class=\"hljs-comment\">// WiFi 네트워크에 연결</span>\n  WiFi.begin(ssid<span class=\"hljs-punctuation\">,</span> password);\n  while (WiFi.status() != WL_CONNECTED) <span class=\"hljs-punctuation\">{</span>\n    delay(<span class=\"hljs-number\">500</span>);\n    Serial.println(<span class=\"hljs-string\">\"WiFi에 연결 중..\"</span>);\n  <span class=\"hljs-punctuation\">}</span>\n  Serial.println(<span class=\"hljs-string\">\"WiFi 네트워크에 연결되었습니다.\"</span>);\n  <span class=\"hljs-comment\">// SSL을 사용하여 MQTT 브로커에 연결</span>\n  espClient.setCACert(root_ca);\n  espClient.setCertificate(server_cert);  <span class=\"hljs-comment\">// 클라이언트 확인을 위해</span>\n  espClient.setPrivateKey(server_key);    <span class=\"hljs-comment\">// 클라이언트 확인을 위해</span>\n\n  <span class=\"hljs-comment\">// 원격 MQTT 브로커에 연결</span>\n  client.setServer(mqtt_broker<span class=\"hljs-punctuation\">,</span> mqtt_port);\n  client.setCallback(callback);\n\n  while (!client.connected()) <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-comment\">// 클라이언트 ID 생성</span>\n    String client_id = <span class=\"hljs-string\">\"esp32-client\"</span>;\n    client_id += String(WiFi.macAddress());\n    <span class=\"hljs-comment\">// esp32 컨트롤러의 이름과 ID 출력</span>\n    Serial.printf(<span class=\"hljs-string\">\"클라이언트 %s가 공개 MQTT 브로커에 연결합니다\\n\"</span><span class=\"hljs-punctuation\">,</span> client_id.c_str());\n    if (client.connect( client_id.c_str())) <span class=\"hljs-punctuation\">{</span>\n      Serial.println(<span class=\"hljs-string\">\"Public emqx mqtt 브로커에 연결되었습니다\"</span>);\n    <span class=\"hljs-punctuation\">}</span> else <span class=\"hljs-punctuation\">{</span>\n      Serial.print(<span class=\"hljs-string\">\"연결 실패, 상태: \"</span>);\n      Serial.print(client.state());\n      delay(<span class=\"hljs-number\">2000</span>);\n    <span class=\"hljs-punctuation\">}</span>\n  <span class=\"hljs-punctuation\">}</span>\n  <span class=\"hljs-comment\">// 게시 및 구독</span>\n  client.publish(topic<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-string\">\"안녕, 나는 ESP32^^\"</span>);\n  client.subscribe(topic);\n<span class=\"hljs-punctuation\">}</span>\n\nvoid callback(char* topic<span class=\"hljs-punctuation\">,</span> byte* payload<span class=\"hljs-punctuation\">,</span> unsigned int length) <span class=\"hljs-punctuation\">{</span>\n  Serial.print(<span class=\"hljs-string\">\"주제에서 메시지 도착: \"</span>);\n  Serial.println(topic);\n  Serial.print(<span class=\"hljs-string\">\"메시지:\"</span>);\n  for (int i = <span class=\"hljs-number\">0</span>; i &#x3C; length; i++) <span class=\"hljs-punctuation\">{</span>\n    Serial.print((char)payload<span class=\"hljs-punctuation\">[</span>i<span class=\"hljs-punctuation\">]</span>);\n  <span class=\"hljs-punctuation\">}</span>\n  Serial.println();\n  Serial.println(<span class=\"hljs-string\">\"-----------------------\"</span>);\n<span class=\"hljs-punctuation\">}</span>\n\nvoid loop() <span class=\"hljs-punctuation\">{</span>\n  client.loop();\n\n  client.publish(topic<span class=\"hljs-punctuation\">,</span> <span class=\"hljs-string\">\"ESP32가 MQTT 브로커로 암호화된 메시지를 보냅니다\"</span>);\n\n  <span class=\"hljs-comment\">// 10초마다 메시지 전송</span>\n  delay(<span class=\"hljs-number\">10000</span>);\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>SSL 인증서를 설정하려면 credentials.h 파일을 작성해야 합니다.</p>\n<p>아래와 같은 형태여야 합니다:</p>\n<pre><code class=\"hljs language-js\">#define <span class=\"hljs-variable constant_\">CA_CRT</span>                                                           \\\n    <span class=\"hljs-string\">\"-----BEGIN CERTIFICATE-----\\n\"</span>                                      \\\n    <span class=\"hljs-string\">\"MIIDVzCCAj+gAwIBAgIUIwOnfZCxwCKrQXHpbI0rVksEcaMwDQYJKoZIhvcNAQEL\\n\"</span> \\\n    <span class=\"hljs-comment\">// 중략</span>\n#define <span class=\"hljs-variable constant_\">SERVER_CERT</span>                                                      \\\n    <span class=\"hljs-string\">\"-----BEGIN CERTIFICATE-----\\n\"</span>                                      \\\n    <span class=\"hljs-string\">\"MIIDBTCCAe0CFHjJN1GNHVnqXiMyngV3yvLg/70FMA0GCSqGSIb3DQEBCwUAMDsx\\n\"</span> \\\n    <span class=\"hljs-comment\">// 중략</span>\n#define <span class=\"hljs-variable constant_\">SERVER_KEY</span>                                                       \\\n    <span class=\"hljs-string\">\"-----BEGIN RSA PRIVATE KEY-----\\n\"</span>                                  \\\n    <span class=\"hljs-string\">\"MIIEpQIBAAKCAQEAvsxvL0H8M9HjGplper2/oRtQQTFfBYLX3JfBrTJIXD6A5HFJ\\n\"</span> \\\n    <span class=\"hljs-comment\">// 중략</span>\n</code></pre>\n<p>그런 다음 자격 증명 파일을 업로드하려는 메인 파일에 자격 증명.h 파일을 가져와서 사용할 수 있습니다.</p>\n<h2>마지막으로 MQTT 브로커에서 나타나는 다음 메시지를 확인해야합니다.</h2>\n<p><img src=\"/assets/img/2024-06-20-IoTESP32usingssltlscertificatetoconnectwidthMQTTBrokerPart2_1.png\" alt=\"이미지\"></p>\n<h1>정리</h1>\n<p>요약하면, 저는 브로커 부분과 컨트롤러 부분을 포함한 가정용 IOT 시스템의 기본 개념을 보여드렸습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}