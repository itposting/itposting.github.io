{"pageProps":{"post":{"title":"실시간 얼굴 인식 끝에서 끝까지의 프로젝트","description":"","date":"2024-06-19 06:12","slug":"2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject","content":"\n\n단계별로 배우세요! PiCam을 사용하여 실시간으로 얼굴을 인식하는 방법을 배워보세요.\n\n![PiCam Image](/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_0.png)\n\n# 1. 소개\n\nOpenCV를 탐구하는 내 교재에서는 자동 비전 객체 추적을 배웠습니다. 이제 PiCam을 사용하여 실시간으로 얼굴을 인식해보겠습니다. 위에서 볼 수 있듯이, 함께해요!\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_1.png)\n\n이 프로젝트는 이 훌륭한 \"Open Source Computer Vision Library\" 인 OpenCV를 사용하여 수행되었습니다. 이 튜토리얼에서는 Raspberry Pi (즉, Raspbian을 사용한 OS)와 Python에 중점을 두지만 Mac에서 코드를 테스트하고 또한 잘 작동하는 것을 확인했습니다.\n\nOpenCV는 계산 효율성을 위해 설계되었으며 실시간 애플리케이션에 중점을 두고 있습니다. 따라서 카메라를 사용한 실시간 얼굴 인식에 적합합니다.\n\n## 3 단계\n\n\n<div class=\"content-ad\"></div>\n\n얼굴인식에 대한 완전한 프로젝트를 생성하려면 3가지 매우 다른 단계에서 작업해야 합니다:\n\n- 얼굴 감지 및 데이터 수집\n- 인식기 훈련\n- 얼굴 인식\n\n다음 블록 다이어그램은 이러한 단계들을 요약합니다:\n\n![Face Recognition Project Phases](/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 2. OpenCV 3 패키지 설치\n\n저는 최신 버전의 라스비안(Stretch)이 설치된 라즈베리 파이 V3를 사용하고 있습니다. 따라서 OpenCV를 설치하는 가장 좋은 방법은 Adrian Rosebrock이 개발한 훌륭한 튜토리얼을 따라하는 것입니다: \"Raspbian Stretch: 라즈베리 파이에 OpenCV 3 + Python 설치\".\n\nAdrian의 튜토리얼을 완료하면 라즈베리 파이에서 실험을 실행할 준비가 된 OpenCV 가상 환경이 준비됩니다.\n\n이제 가상 환경으로 이동하여 OpenCV 3이 올바르게 설치되었는지 확인해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n에드리안이 새 터미널을 열 때마다 \"source\" 명령을 실행하여 시스템 변수가 올바르게 설정되었는지 확인하는 것을 권장합니다.\n\n```js\nsource ~/.profile\n```\n\n다음으로, 가상 환경에 들어가 봅시다:\n\n```js\nworkon cv\n```\n\n<div class=\"content-ad\"></div>\n\n만약 당신이 cv 가상환경 앞에 있는 텍스트를 보신다면, cv 가상환경 안에 있습니다:\n\n```js\n(cv) pi@raspberry:~$\n```\n\n이제 파이썬 인터프리터로 들어가보세요:\n\n```js\npython\n```\n\n<div class=\"content-ad\"></div>\n\n저희가 현재 3.5 버전 (또는 그 이상)을 실행 중이라고 확인해주세요.\n\n인터프리터 안에 ( 가 표시될 것입니다), OpenCV 라이브러리를 import 해주세요:\n\n```js\nimport cv2\n```\n\n만약 에러 메시지가 나타나지 않는다면, OpenCV가 정확하게 파이썬 가상 환경에 설치된 것입니다.\n\n<div class=\"content-ad\"></div>\n\n설치된 OpenCV 버전을 확인할 수도 있어요:\n\n```js\ncv2.__version__\n```\n\n3.3.0이 표시되어야 해요 (또는 미래에 출시될 우수한 버전). \n\n<img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_3.png\" />\n\n<div class=\"content-ad\"></div>\n\n위의 터미널 스크린샷은 이전 단계를 보여줍니다.\n\n# 3. 카메라 테스트\n\nRPi에 OpenCV를 설치했다면 카메라가 제대로 작동하는지 확인하기 위해 테스트를 해봅시다.\n\n이미 PiCam을 설치하고 활성화했다는 것을 전제로 합니다.\n\n<div class=\"content-ad\"></div>\n\n아래 Python 코드를 IDE에 입력해보세요:\n\n```js\nimport numpy as np\nimport cv2\ncap = cv2.VideoCapture(0)\ncap.set(3,640) # 너비 설정\ncap.set(4,480) # 높이 설정\nwhile(True):\n    ret, frame = cap.read()\n    frame = cv2.flip(frame, -1) # 카메라 세로로 뒤집기\n    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n    \n    cv2.imshow('frame', frame)\n    cv2.imshow('gray', gray)\n    \n    k = cv2.waitKey(30) & 0xff\n    if k == 27: # 'ESC' 키를 눌러 종료\n        break\ncap.release()\ncv2.destroyAllWindows()\n```\n\n위 코드는 PiCam에서 생성된 비디오 스트림을 캡처하여 BGR 색상과 회색 모드로 모두 표시합니다.\n\n또는 GitHub에서 코드를 다운로드할 수도 있습니다: simpleCamTest.py\n\n<div class=\"content-ad\"></div>\n\n해당 스크립트를 실행하려면 다음 명령어를 입력해주세요:\n\n```js\npython simpleCamTest.py\n```\n\n<img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_4.png\" />\n\n위의 그림은 결과를 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n일부 사용자가 카메라를 열려고 시도할 때 문제가 발생하고 \"Assertion failed\" 오류 메시지가 표시된다는 것을 발겠어요. 이것은 카메라가 OpenCV 설치 중에 활성화되지 않았거나 카메라 드라이버가 올바르게 설치되지 않아 발생할 수 있습니다. 수정하려면 다음 명령을 사용하세요:\n\n```js\nsudo modprobe bcm2835-v4l2\n```\n\nOpenCV에 대해 더 알고 싶다면 다음 튜토리얼을 참고해보세요: loading-video-python-opencv-tutorial\n\n# 4. 얼굴 인식\n\n<div class=\"content-ad\"></div>\n\nFace Recognition에서 가장 기본적인 작업은 물론 \"얼굴 감지\"입니다. 무엇보다 먼저, 미래에 캡처된 새 얼굴과 비교할 수 있도록 얼굴을 캡처해야 합니다(Phase 1).\n\n(혹시 이전에 말한 'Capture'부분 해석이 잘못된 것 같아 원문에서 대체했습니다.)\n\n한 객체를 감지하는 가장 일반적인 방법은 \"Haar Cascade classifier\"를 사용하는 것입니다.\n\n\"Haar 특징 기반 캐스케이드 분류기\"를 사용한 객체 감지는 Paul Viola와 Michael Jones가 2001년에 발표한 논문 \"Rapid Object Detection using a Boosted Cascade of Simple Features\"에서 제안된 효과적인 객체 감지 방법입니다. 이는 많은 양의 긍정 이미지와 부정 이미지로부터 케스케이드 함수가 훈련된 기계 학습 기반 방법으로, 다른 이미지에서 객체를 감지하는 데 사용됩니다.\n\n여기서는 얼굴 감지 작업을 수행할 것입니다. 먼저, 알고리즘에는 분류기를 훈련시키기 위해 많은 양의 양성 이미지(얼굴 이미지)와 음성 이미지(얼굴이 없는 이미지)가 필요합니다. 그런 다음 그로부터 특징을 추출해야 합니다. 좋은 소식은 OpenCV에 트레이너와 탐지기가 함께 제공된다는 것입니다. 자동차, 비행기 등의 모든 객체에 대해 자체 분류기를 훈련시키고 싶다면 OpenCV를 사용해 생성할 수 있습니다. 자세한 내용은 여기를 참고하십시오: 캐스케이드 분류기 훈련.\n\n<div class=\"content-ad\"></div>\n\n만약 여러분이 자체 분류기를 만들고 싶지 않다면, OpenCV에는 이미 얼굴, 눈, 웃음 등을 위한 사전 훈련된 분류기가 많이 포함되어 있습니다. 이러한 XML 파일은 haarcascades 디렉토리에서 다운로드할 수 있습니다.\n\n이론은 이만하고, 이제 OpenCV를 사용하여 얼굴 탐지기를 만들어 봅시다!\n\n제 GitHub에서 파일 faceDetection.py를 다운로드하세요.\n\n```python\nimport numpy as np\nimport cv2\nfaceCascade = cv2.CascadeClassifier('Cascades/haarcascade_frontalface_default.xml')\ncap = cv2.VideoCapture(0)\ncap.set(3,640) # 너비 설정\ncap.set(4,480) # 높이 설정\nwhile True:\n    ret, img = cap.read()\n    img = cv2.flip(img, -1)\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    faces = faceCascade.detectMultiScale(\n        gray,\n        scaleFactor=1.2,\n        minNeighbors=5,\n        minSize=(20, 20)\n    )\n    for (x,y,w,h) in faces:\n        cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)\n        roi_gray = gray[y:y+h, x:x+w]\n        roi_color = img[y:y+h, x:x+w]\n    cv2.imshow('video',img)\n    k = cv2.waitKey(30) & 0xff\n    if k == 27: # 'ESC'를 눌러 종료\n        break\ncap.release()\ncv2.destroyAllWindows()\n```\n\n<div class=\"content-ad\"></div>\n\n믿을 수 있건대, Python과 OpenCV를 사용하여 얼굴을 감지하는 데 필요한 코드는 바로 위의 몇 줄 뿐입니다.\n\n카메라를 테스트하는 데 사용된 마지막 코드와 비교해보면, 약간의 부분이 추가되었음을 깨달을 것입니다. 아래의 줄을 주목해주세요:\n\n```js\nfaceCascade = cv2.CascadeClassifier('Cascades/haarcascade_frontalface_default.xml')\n```\n\n이 줄은 \"classifier\"를 로드하는 줄입니다 (프로젝트 디렉토리 하위에 \"Cascades/\"라는 디렉토리에 있어야 합니다).\n\n<div class=\"content-ad\"></div>\n\n그럼, 우리는 카메라를 설정하고 루프 내에서 입력 비디오를 회색조 모드로 불러올 것입니다 (이전에 보았던 것과 동일합니다).\n\n이제 분류기 함수를 호출해야 하는데, 이때 매우 중요한 매개변수들을 전달해주어야 합니다. 이들은 scale factor, 이웃의 수, 그리고 감지된 얼굴의 최소 크기입니다.\n\n```js\nfaces = faceCascade.detectMultiScale(\n        gray,     \n        scaleFactor=1.2,\n        minNeighbors=5,     \n        minSize=(20, 20)\n        )\n```\n\n여기서,\n\n<div class=\"content-ad\"></div>\n\n- gray는 입력 그레이스케일 이미지입니다.\n- scaleFactor는 각 이미지 스케일에서 이미지 크기가 감소하는 정도를 지정하는 매개 변수입니다. 스케일 피라미드를 만드는 데 사용됩니다.\n- minNeighbors는 각 후보 사각형이 유지해야 하는 이웃 수를 지정하는 매개 변수입니다. 숫자가 높을수록 낮은 거짓 양성이 발생합니다.\n- minSize는 고려해야 할 최소 사각형 크기입니다.\n\n함수는 이미지에서 얼굴을 감지합니다. 다음으로 이미지에서 얼굴을 \"표시\"해야 합니다. 예를 들어, 파란색 사각형 등을 사용합니다. 이 작업은 다음 코드 부분으로 수행됩니다:\n\n```js\nfor (x,y,w,h) in faces:\n    cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)\n    roi_gray = gray[y:y+h, x:x+w]\n    roi_color = img[y:y+h, x:x+w]\n```\n\n얼굴이 발견되면, 감지된 얼굴의 위치를 왼쪽 위 모서리인 (x,y)로 하는 네모 상자로 반환하며, \"w\"를 너비, \"h\"를 높이로 가집니다 == (x, y, w, h). 사진을 참조하세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_5.png\" />\n\n이 위치들을 얻으면, 얼굴을 위한 \"ROI\" (사각형으로 그린)를 만들고 imshow() 함수를 사용하여 결과를 표시할 수 있습니다.\n\nRpi 터미널을 사용하여 위의 Python 스크립트를 Python 환경에서 실행해보세요:\n\n```js\npython faceDetection.py\n```\n\n<div class=\"content-ad\"></div>\n\n결과:\n\n<img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_6.png\" />\n\n당신은 \"눈 탐지\" 또는 \"미소 탐지\"를 위한 분류기도 포함할 수 있습니다. 해당 경우에는 얼굴 루프 내에 분류기 함수와 사각형 그리기를 포함해야 합니다. 왜냐하면 얼굴 외부에서 눈이나 미소를 탐지하는 것은 의미가 없기 때문입니다.\n\n## 예시\n\n<div class=\"content-ad\"></div>\n\n내 GitHub에서 다른 예제들을 찾을 수 있어요:\n\n- faceEyeDetection.py\n- faceSmileDetection.py\n- faceSmileEyeDetection.py\n\n그리고 사진에서 결과를 확인할 수 있어요.\n\n![image](/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_7.png)\n\n<div class=\"content-ad\"></div>\n\n아래 튜토리얼을 따라해서 얼굴 감지에 대해 더 잘 이해할 수 있어요:\n\nHaar Cascade Object Detection Face & Eye OpenCV Python Tutorial\n\n# 5. 데이터 수집\n\n우선, 사진을 통한 얼굴 인식에 대한 람리즈 라자의 훌륭한 작업에 감사드려야 해요!\n\n<div class=\"content-ad\"></div>\n\nOPENCV와 Python을 사용한 얼굴 인식: 초보자를 위한 안내서\n\n그리고 비디오를 사용해 매우 포괄적인 튜토리얼을 개발한 Anirban Kar:\n\n얼굴 인식 - 3 부분\n\n두 튜토리얼을 꼭 확인해보시기를 적극 추천합니다.\n\n<div class=\"content-ad\"></div>\n\n그렇게 말씀하시면 프로젝트의 첫 단계를 시작하겠습니다. 여기서 우리가 할 일은 마지막 단계(얼굴 감지)부터 시작하여 간단히 데이터 세트를 만드는 것입니다. 각 ID에 대해, 얼굴 감지에 사용된 부분이 회색으로 표시된 사진 그룹을 저장할 것입니다.\n\n![이미지](/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_8.png)\n\n먼저, 프로젝트를 개발할 디렉터리를 만드세요. 예를 들어, FacialRecognitionProject:\n\n```js\nmkdir FacialRecognitionProject\n```\n\n<div class=\"content-ad\"></div>\n\n이 디렉토리에는 프로젝트용으로 만들 3개의 Python 스크립트뿐만 아니라 Facial Classifier도 저장해 두어야 해요. 이를 다운로드할 수 있는 GitHub 링크는 haarcascade_frontalface_default.xml입니다.\n\n그리고 우리의 얼굴 샘플을 저장할 하위 디렉토리를 만들어 이름을 \"dataset\"으로 지어줘요:\n\n```bash\nmkdir dataset\n```\n\n그리고 저의 GitHub에서 코드를 다운로드하세요: 01_face_dataset.py\n\n<div class=\"content-ad\"></div>\n\n```js\nimport cv2\nimport os\ncam = cv2.VideoCapture(0)\ncam.set(3, 640) # 비디오 너비 설정\ncam.set(4, 480) # 비디오 높이 설정\nface_detector = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')\n# 각 사람에 대해 하나의 숫자 얼굴 ID 입력\nface_id = input('\\n 사용자 ID를 입력하고 <return>을 누르세요 ==> ')\nprint(\"\\n [INFO] 얼굴 캡처 초기화. 카메라를 응시하고 기다리세요 ...\")\n# 개별 샘플링 얼굴 카운트 초기화\ncount = 0\nwhile(True):\n    ret, img = cam.read()\n    img = cv2.flip(img, -1) # 비디오 이미지 수직으로 뒤집기\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    faces = face_detector.detectMultiScale(gray, 1.3, 5)\n    for (x,y,w,h) in faces:\n        cv2.rectangle(img, (x,y), (x+w,y+h), (255,0,0), 2)     \n        count += 1\n        # 캡처된 이미지를 데이터셋 폴더에 저장\n        cv2.imwrite(\"dataset/User.\" + str(face_id) + '.' +  \n                    str(count) + \".jpg\", gray[y:y+h,x:x+w])\n        cv2.imshow('image', img)\n    k = cv2.waitKey(100) & 0xff # 'ESC' 키를 눌러 비디오 종료\n    if k == 27:\n        break\n    elif count >= 30: # 30개의 얼굴 샘플 촬영 후 비디오 중지\n         break\n# 청소 조금\nprint(\"\\n [INFO] 프로그램 종료 및 정리 진행\")\ncam.release()\ncv2.destroyAllWindows()\n``` \n\n코드는 얼굴 감지를 위한 코드와 매우 유사합니다. 추가한 부분은 \"사용자 ID를 캡처하기 위한 입력 명령\"이며, 이는 정수 번호(1, 2, 3 등)여야 합니다.\n\n```js\nface_id = input('\\n 사용자 ID를 입력하고 <return>을 누르세요 ==> ')\n```\n\n그리고 각 캡처된 프레임마다 \"데이터셋\" 디렉토리에 파일로 저장해야 합니다. \n\n<div class=\"content-ad\"></div>\n\n```js\ncv2.imwrite(\"dataset/User.\" + str(face_id) + '.' + str(count) + \".jpg\", gray[y:y+h,x:x+w])\n```\n\n위의 파일을 저장하기 위해서는 라이브러리 \"os\"를 import해야 합니다. 각 파일의 이름은 다음과 같은 구조를 따릅니다:\n\n```js\nUser.face_id.count.jpg\n```\n\n예를 들어, face_id가 1인 사용자의 경우, dataset/ 디렉토리에 있는 네 번째 샘플 파일은 아래와 같이 될 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nUser.1.4.jpg\n```\n\nPI 사진에서 보여지는 것과 같이:\n\n\n![Image](/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_9.png)\n\n내 코드에서는 각 ID로부터 30개의 샘플을 캡처하고 있습니다. 마지막 \"elif\"에서 이를 변경할 수 있습니다. 샘플의 수는 얼굴 샘플을 캡처하는 루프를 종료하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\n파이썬 스크립트를 실행하고 몇 개의 ID를 캡처하세요. 새 사용자를 집계하거나 이미 존재하는 사용자의 사진을 변경하려면 매번 스크립트를 실행해야 합니다.\n\n# 6. 트레이너\n\n이 두 번째 단계에서는 데이터셋에서 모든 사용자 데이터를 가져와 OpenCV Recognizer를 \"트레이닝\"해야 합니다. 이 작업은 특정한 OpenCV 함수를 사용하여 직접 수행됩니다. 결과는 \"trainer/\" 디렉토리에 저장된 .yml 파일이 될 것입니다.\n\n![이미지](/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_10.png)\n\n<div class=\"content-ad\"></div>\n\n그러면, 훈련 데이터를 저장할 하위 디렉토리를 만드는 것으로 시작해봐요:\n\n```js\nmkdir trainer\n```\n\n제 GitHub에서 두 번째 파이썬 스크립트를 다운로드하실 거에요: 02_face_training.py\n\n```js\nimport cv2\nimport numpy as np\nfrom PIL import Image\nimport os\n# 얼굴 이미지 데이터베이스 경로\npath = 'dataset'\nrecognizer = cv2.face.LBPHFaceRecognizer_create()\ndetector = cv2.CascadeClassifier(\"haarcascade_frontalface_default.xml\");\n# 이미지 및 레이블 데이터 가져오는 함수\ndef getImagesAndLabels(path):\n    imagePaths = [os.path.join(path,f) for f in os.listdir(path)]     \n    faceSamples=[]\n    ids = []\n    for imagePath in imagePaths:\n        PIL_img = Image.open(imagePath).convert('L') # 흑백\n        img_numpy = np.array(PIL_img,'uint8')\n        id = int(os.path.split(imagePath)[-1].split(\".\")[1])\n        faces = detector.detectMultiScale(img_numpy)\n        for (x,y,w,h) in faces:\n            faceSamples.append(img_numpy[y:y+h,x:x+w])\n            ids.append(id)\n    return faceSamples,ids\nprint (\"\\n [INFO] 얼굴을 학습 중입니다. 몇 초가 걸릴 것입니다. 기다려 주세요...\")\nfaces,ids = getImagesAndLabels(path)\nrecognizer.train(faces, np.array(ids))\n# 모델을 trainer/trainer.yml에 저장하기\nrecognizer.write('trainer/trainer.yml') \n# 학습된 얼굴 수 및 프로그램 종료 출력\nprint(\"\\n [INFO] {0} 개의 얼굴을 학습했습니다. 프로그램을 종료합니다.\".format(len(np.unique(ids))))\n```\n\n<div class=\"content-ad\"></div>\n\n라즈베리파이에 PIL 라이브러리가 설치되어 있는지 확인해주세요. 만약 설치되어 있지 않다면, 아래의 명령을 터미널에서 실행해주세요:\n\n```js\npip install pillow\n```\n\n우리는 OpenCV 패키지에 포함된 LBPH (LOCAL BINARY PATTERNS HISTOGRAMS) 얼굴 인식기(recognizer)를 사용할 것입니다. 아래와 같이 코드를 작성해주세요:\n\n```js\nrecognizer = cv2.face.LBPHFaceRecognizer_create()\n```\n\n<div class=\"content-ad\"></div>\n\n\"getImagesAndLabels (path)\" 함수는 \"dataset/\" 디렉토리의 모든 사진을 가져와서 \"Ids\"와 \"faces\" 두 가지 배열을 반환합니다. 이 배열을 입력으로 사용하여 \"인식기를 학습\"할 것입니다:\n\n```js\nrecognizer.train(faces, ids)\n```\n\n이 결과로 \"trainer.yml\"이라는 파일이 우리가 이전에 생성한 트레이너 디렉토리에 저장됩니다.\n\n여기까지입니다! 훈련시킨 사용자의 얼굴 수를 확인하기 위해 마지막으로 출력 문을 포함했습니다.\n\n<div class=\"content-ad\"></div>\n\n매번 Phase 1을 실행할 때마다 Phase 2도 실행해야 합니다.\n\n# 7. 인식기\n\n지금까지 우리 프로젝트의 마지막 단계에 도달했습니다. 여기서 우리는 카메라로 새로운 얼굴을 촬영하고, 이 사람이 이전에 그의 얼굴을 촬영하고 훈련했다면, 우리의 인식기는 \"예측\"을 수행하여 해당 ID와 일치 여부를 나타내는 지수를 반환합니다. 이로써 해당 일치에 대해 인식기가 얼마나 확신하는지 보여줍니다.\n\n![이미지](/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_11.png)\n\n<div class=\"content-ad\"></div>\n\nGitHub에서 3단계 Python 스크립트를 내려받아봅시다: 03_face_recognition.py.\n\n```python\nimport cv2\nimport numpy as np\nimport os \nrecognizer = cv2.face.LBPHFaceRecognizer_create()\nrecognizer.read('trainer/trainer.yml')\ncascadePath = \"haarcascade_frontalface_default.xml\"\nfaceCascade = cv2.CascadeClassifier(cascadePath)\nfont = cv2.FONT_HERSHEY_SIMPLEX\n# 아이디 카운터 초기화\nid = 0\n# id에 대응하는 이름: 예) Marcelo: id=1,  등\nnames = ['없음', '마르셀로', '파울라', '일자', 'Z', 'W'] \n# 실시간 비디오 캡처 시작\ncam = cv2.VideoCapture(0)\ncam.set(3, 640) # 비디오 너비 설정\ncam.set(4, 480) # 비디오 높이 설정\n# 얼굴 인식으로 인정할 최소 윈도우 크기 정의\nminW = 0.1*cam.get(3)\nminH = 0.1*cam.get(4)\nwhile True:\n    ret, img =cam.read()\n    img = cv2.flip(img, -1) # 수직으로 뒤집기\n    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)\n    \n    faces = faceCascade.detectMultiScale( \n        gray,\n        scaleFactor = 1.2,\n        minNeighbors = 5,\n        minSize = (int(minW), int(minH)),\n       )\n    for(x,y,w,h) in faces:\n        cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2)\n        id, confidence = recognizer.predict(gray[y:y+h,x:x+w])\n        # 신뢰도가 100 미만이면 \"0\" : 완벽 일치\n        if (confidence < 100):\n            id = names[id]\n            confidence = \"  {0}%\".format(round(100 - confidence))\n        else:\n            id = \"알수없음\"\n            confidence = \"  {0}%\".format(round(100 - confidence))\n        \n        cv2.putText(\n                    img, \n                    str(id), \n                    (x+5,y-5), \n                    font, \n                    1, \n                    (255,255,255), \n                    2\n                   )\n        cv2.putText(\n                    img, \n                    str(confidence), \n                    (x+5,y+h-5), \n                    font, \n                    1, \n                    (255,255,0), \n                    1\n                   )  \n    \n    cv2.imshow('camera',img) \n    k = cv2.waitKey(10) & 0xff # 'ESC'를 눌러 비디오 종료\n    if k == 27:\n        break\n# 정리 작업\nprint(\"\\n [INFO] 프로그램 종료 및 정리 작업\")\ncam.release()\ncv2.destroyAllWindows()\n```\n\n여기에 새 배열을 추가했으므로, 숫자로 된 ID 대신 \"names\"를 표시할 것입니다:\n\n```python\nnames = ['없음', '마르셀로', '파울라', '일자', 'Z', 'W']\n```\n\n<div class=\"content-ad\"></div>\n\n예를 들어, Marcelo는 id=1인 사용자이고, Paula는 id=2인 등입니다.\n\n다음으로, 우리는 얼굴을 감지할 것이며, 이전과 같이 haasCascade 분류기를 사용할 것입니다. 감지된 얼굴을 가지고 우리는 위의 코드에서 가장 중요한 함수를 호출할 수 있습니다:\n\n```js\nid, confidence = recognizer.predict(얼굴의 회색 부분)\n```\n\nrecognizer.predict()는 분석할 얼굴의 캡처된 부분을 매개변수로 사용하고, 해당 소유자와 일치에 대한 신뢰도를 나타내는 id 및 인식기의 신뢰도 값을 반환할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n그리고 마지막으로, 인식기가 얼굴을 예측할 수 있다면, 이미지 위에 “확률적 ID”와 일치가 올바른지에 대한 “확률”이 표시됩니다 (“확률” = 100 - 신뢰도 지수). 그렇지 않으면, “알 수 없음” 레이블이 얼굴 위에 표시됩니다.\n\n아래는 결과를 보여주는 gif입니다:\n\n![결과](/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_12.png)\n\n이 사진에서는 이 프로젝트로 수행한 일부 테스트를 보여드립니다. 여기서 인식기가 작동하는지 확인하기 위해 사진을 사용했습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_13.png\" />\n\n# 8. 결론\n\n<img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_14.png\" />\n\n언제나처럼, 이 프로젝트가 다른 사람들이 전자기술의 흥미로운 세계로 진입하는 데 도움이 되기를 바랍니다!\n\n<div class=\"content-ad\"></div>\n\n세부 정보 및 최종 코드는 제 GitHub 저장소를 방문해주세요:\n\nhttps://github.com/Mjrovai/OpenCV-Face-Recognition\n\n더 많은 프로젝트를 보시려면 제 블로그를 방문해주세요: MJRoBot.org\n\n이른 아침 인사드립니다!\n\n<div class=\"content-ad\"></div>\n\n다음 글에서 봐요!\n\n감사합니다,\n\n마르셀로","ogImage":{"url":"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_0.png"},"coverImage":"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_0.png","tag":["Tech"],"readingTime":16},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>단계별로 배우세요! PiCam을 사용하여 실시간으로 얼굴을 인식하는 방법을 배워보세요.</p>\n<p><img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_0.png\" alt=\"PiCam Image\"></p>\n<h1>1. 소개</h1>\n<p>OpenCV를 탐구하는 내 교재에서는 자동 비전 객체 추적을 배웠습니다. 이제 PiCam을 사용하여 실시간으로 얼굴을 인식해보겠습니다. 위에서 볼 수 있듯이, 함께해요!</p>\n<p><img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_1.png\" alt=\"image\"></p>\n<p>이 프로젝트는 이 훌륭한 \"Open Source Computer Vision Library\" 인 OpenCV를 사용하여 수행되었습니다. 이 튜토리얼에서는 Raspberry Pi (즉, Raspbian을 사용한 OS)와 Python에 중점을 두지만 Mac에서 코드를 테스트하고 또한 잘 작동하는 것을 확인했습니다.</p>\n<p>OpenCV는 계산 효율성을 위해 설계되었으며 실시간 애플리케이션에 중점을 두고 있습니다. 따라서 카메라를 사용한 실시간 얼굴 인식에 적합합니다.</p>\n<h2>3 단계</h2>\n<p>얼굴인식에 대한 완전한 프로젝트를 생성하려면 3가지 매우 다른 단계에서 작업해야 합니다:</p>\n<ul>\n<li>얼굴 감지 및 데이터 수집</li>\n<li>인식기 훈련</li>\n<li>얼굴 인식</li>\n</ul>\n<p>다음 블록 다이어그램은 이러한 단계들을 요약합니다:</p>\n<p><img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_2.png\" alt=\"Face Recognition Project Phases\"></p>\n<h1>2. OpenCV 3 패키지 설치</h1>\n<p>저는 최신 버전의 라스비안(Stretch)이 설치된 라즈베리 파이 V3를 사용하고 있습니다. 따라서 OpenCV를 설치하는 가장 좋은 방법은 Adrian Rosebrock이 개발한 훌륭한 튜토리얼을 따라하는 것입니다: \"Raspbian Stretch: 라즈베리 파이에 OpenCV 3 + Python 설치\".</p>\n<p>Adrian의 튜토리얼을 완료하면 라즈베리 파이에서 실험을 실행할 준비가 된 OpenCV 가상 환경이 준비됩니다.</p>\n<p>이제 가상 환경으로 이동하여 OpenCV 3이 올바르게 설치되었는지 확인해 보겠습니다.</p>\n<p>에드리안이 새 터미널을 열 때마다 \"source\" 명령을 실행하여 시스템 변수가 올바르게 설정되었는지 확인하는 것을 권장합니다.</p>\n<pre><code class=\"hljs language-js\">source ~/.<span class=\"hljs-property\">profile</span>\n</code></pre>\n<p>다음으로, 가상 환경에 들어가 봅시다:</p>\n<pre><code class=\"hljs language-js\">workon cv\n</code></pre>\n<p>만약 당신이 cv 가상환경 앞에 있는 텍스트를 보신다면, cv 가상환경 안에 있습니다:</p>\n<pre><code class=\"hljs language-js\">(cv) pi@<span class=\"hljs-attr\">raspberry</span>:~$\n</code></pre>\n<p>이제 파이썬 인터프리터로 들어가보세요:</p>\n<pre><code class=\"hljs language-js\">python\n</code></pre>\n<p>저희가 현재 3.5 버전 (또는 그 이상)을 실행 중이라고 확인해주세요.</p>\n<p>인터프리터 안에 ( 가 표시될 것입니다), OpenCV 라이브러리를 import 해주세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> cv2\n</code></pre>\n<p>만약 에러 메시지가 나타나지 않는다면, OpenCV가 정확하게 파이썬 가상 환경에 설치된 것입니다.</p>\n<p>설치된 OpenCV 버전을 확인할 수도 있어요:</p>\n<pre><code class=\"hljs language-js\">cv2.<span class=\"hljs-property\">__version__</span>\n</code></pre>\n<p>3.3.0이 표시되어야 해요 (또는 미래에 출시될 우수한 버전).</p>\n<p>위의 터미널 스크린샷은 이전 단계를 보여줍니다.</p>\n<h1>3. 카메라 테스트</h1>\n<p>RPi에 OpenCV를 설치했다면 카메라가 제대로 작동하는지 확인하기 위해 테스트를 해봅시다.</p>\n<p>이미 PiCam을 설치하고 활성화했다는 것을 전제로 합니다.</p>\n<p>아래 Python 코드를 IDE에 입력해보세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> cv2\ncap = cv2.<span class=\"hljs-title class_\">VideoCapture</span>(<span class=\"hljs-number\">0</span>)\ncap.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">640</span>) # 너비 설정\ncap.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">480</span>) # 높이 설정\n<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-title class_\">True</span>):\n    ret, frame = cap.<span class=\"hljs-title function_\">read</span>()\n    frame = cv2.<span class=\"hljs-title function_\">flip</span>(frame, -<span class=\"hljs-number\">1</span>) # 카메라 세로로 뒤집기\n    gray = cv2.<span class=\"hljs-title function_\">cvtColor</span>(frame, cv2.<span class=\"hljs-property\">COLOR_BGR2GRAY</span>)\n    \n    cv2.<span class=\"hljs-title function_\">imshow</span>(<span class=\"hljs-string\">'frame'</span>, frame)\n    cv2.<span class=\"hljs-title function_\">imshow</span>(<span class=\"hljs-string\">'gray'</span>, gray)\n    \n    k = cv2.<span class=\"hljs-title function_\">waitKey</span>(<span class=\"hljs-number\">30</span>) &#x26; <span class=\"hljs-number\">0xff</span>\n    <span class=\"hljs-keyword\">if</span> k == <span class=\"hljs-number\">27</span>: # <span class=\"hljs-string\">'ESC'</span> 키를 눌러 종료\n        <span class=\"hljs-keyword\">break</span>\ncap.<span class=\"hljs-title function_\">release</span>()\ncv2.<span class=\"hljs-title function_\">destroyAllWindows</span>()\n</code></pre>\n<p>위 코드는 PiCam에서 생성된 비디오 스트림을 캡처하여 BGR 색상과 회색 모드로 모두 표시합니다.</p>\n<p>또는 GitHub에서 코드를 다운로드할 수도 있습니다: simpleCamTest.py</p>\n<p>해당 스크립트를 실행하려면 다음 명령어를 입력해주세요:</p>\n<pre><code class=\"hljs language-js\">python simpleCamTest.<span class=\"hljs-property\">py</span>\n</code></pre>\n<p>위의 그림은 결과를 보여줍니다.</p>\n<p>일부 사용자가 카메라를 열려고 시도할 때 문제가 발생하고 \"Assertion failed\" 오류 메시지가 표시된다는 것을 발겠어요. 이것은 카메라가 OpenCV 설치 중에 활성화되지 않았거나 카메라 드라이버가 올바르게 설치되지 않아 발생할 수 있습니다. 수정하려면 다음 명령을 사용하세요:</p>\n<pre><code class=\"hljs language-js\">sudo modprobe bcm2835-v4l2\n</code></pre>\n<p>OpenCV에 대해 더 알고 싶다면 다음 튜토리얼을 참고해보세요: loading-video-python-opencv-tutorial</p>\n<h1>4. 얼굴 인식</h1>\n<p>Face Recognition에서 가장 기본적인 작업은 물론 \"얼굴 감지\"입니다. 무엇보다 먼저, 미래에 캡처된 새 얼굴과 비교할 수 있도록 얼굴을 캡처해야 합니다(Phase 1).</p>\n<p>(혹시 이전에 말한 'Capture'부분 해석이 잘못된 것 같아 원문에서 대체했습니다.)</p>\n<p>한 객체를 감지하는 가장 일반적인 방법은 \"Haar Cascade classifier\"를 사용하는 것입니다.</p>\n<p>\"Haar 특징 기반 캐스케이드 분류기\"를 사용한 객체 감지는 Paul Viola와 Michael Jones가 2001년에 발표한 논문 \"Rapid Object Detection using a Boosted Cascade of Simple Features\"에서 제안된 효과적인 객체 감지 방법입니다. 이는 많은 양의 긍정 이미지와 부정 이미지로부터 케스케이드 함수가 훈련된 기계 학습 기반 방법으로, 다른 이미지에서 객체를 감지하는 데 사용됩니다.</p>\n<p>여기서는 얼굴 감지 작업을 수행할 것입니다. 먼저, 알고리즘에는 분류기를 훈련시키기 위해 많은 양의 양성 이미지(얼굴 이미지)와 음성 이미지(얼굴이 없는 이미지)가 필요합니다. 그런 다음 그로부터 특징을 추출해야 합니다. 좋은 소식은 OpenCV에 트레이너와 탐지기가 함께 제공된다는 것입니다. 자동차, 비행기 등의 모든 객체에 대해 자체 분류기를 훈련시키고 싶다면 OpenCV를 사용해 생성할 수 있습니다. 자세한 내용은 여기를 참고하십시오: 캐스케이드 분류기 훈련.</p>\n<p>만약 여러분이 자체 분류기를 만들고 싶지 않다면, OpenCV에는 이미 얼굴, 눈, 웃음 등을 위한 사전 훈련된 분류기가 많이 포함되어 있습니다. 이러한 XML 파일은 haarcascades 디렉토리에서 다운로드할 수 있습니다.</p>\n<p>이론은 이만하고, 이제 OpenCV를 사용하여 얼굴 탐지기를 만들어 봅시다!</p>\n<p>제 GitHub에서 파일 faceDetection.py를 다운로드하세요.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> cv2\nfaceCascade = cv2.CascadeClassifier(<span class=\"hljs-string\">'Cascades/haarcascade_frontalface_default.xml'</span>)\ncap = cv2.VideoCapture(<span class=\"hljs-number\">0</span>)\ncap.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">640</span>) <span class=\"hljs-comment\"># 너비 설정</span>\ncap.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">480</span>) <span class=\"hljs-comment\"># 높이 설정</span>\n<span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n    ret, img = cap.read()\n    img = cv2.flip(img, -<span class=\"hljs-number\">1</span>)\n    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n    faces = faceCascade.detectMultiScale(\n        gray,\n        scaleFactor=<span class=\"hljs-number\">1.2</span>,\n        minNeighbors=<span class=\"hljs-number\">5</span>,\n        minSize=(<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">20</span>)\n    )\n    <span class=\"hljs-keyword\">for</span> (x,y,w,h) <span class=\"hljs-keyword\">in</span> faces:\n        cv2.rectangle(img,(x,y),(x+w,y+h),(<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>),<span class=\"hljs-number\">2</span>)\n        roi_gray = gray[y:y+h, x:x+w]\n        roi_color = img[y:y+h, x:x+w]\n    cv2.imshow(<span class=\"hljs-string\">'video'</span>,img)\n    k = cv2.waitKey(<span class=\"hljs-number\">30</span>) &#x26; <span class=\"hljs-number\">0xff</span>\n    <span class=\"hljs-keyword\">if</span> k == <span class=\"hljs-number\">27</span>: <span class=\"hljs-comment\"># 'ESC'를 눌러 종료</span>\n        <span class=\"hljs-keyword\">break</span>\ncap.release()\ncv2.destroyAllWindows()\n</code></pre>\n<p>믿을 수 있건대, Python과 OpenCV를 사용하여 얼굴을 감지하는 데 필요한 코드는 바로 위의 몇 줄 뿐입니다.</p>\n<p>카메라를 테스트하는 데 사용된 마지막 코드와 비교해보면, 약간의 부분이 추가되었음을 깨달을 것입니다. 아래의 줄을 주목해주세요:</p>\n<pre><code class=\"hljs language-js\">faceCascade = cv2.<span class=\"hljs-title class_\">CascadeClassifier</span>(<span class=\"hljs-string\">'Cascades/haarcascade_frontalface_default.xml'</span>)\n</code></pre>\n<p>이 줄은 \"classifier\"를 로드하는 줄입니다 (프로젝트 디렉토리 하위에 \"Cascades/\"라는 디렉토리에 있어야 합니다).</p>\n<p>그럼, 우리는 카메라를 설정하고 루프 내에서 입력 비디오를 회색조 모드로 불러올 것입니다 (이전에 보았던 것과 동일합니다).</p>\n<p>이제 분류기 함수를 호출해야 하는데, 이때 매우 중요한 매개변수들을 전달해주어야 합니다. 이들은 scale factor, 이웃의 수, 그리고 감지된 얼굴의 최소 크기입니다.</p>\n<pre><code class=\"hljs language-js\">faces = faceCascade.<span class=\"hljs-title function_\">detectMultiScale</span>(\n        gray,     \n        scaleFactor=<span class=\"hljs-number\">1.2</span>,\n        minNeighbors=<span class=\"hljs-number\">5</span>,     \n        minSize=(<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">20</span>)\n        )\n</code></pre>\n<p>여기서,</p>\n<ul>\n<li>gray는 입력 그레이스케일 이미지입니다.</li>\n<li>scaleFactor는 각 이미지 스케일에서 이미지 크기가 감소하는 정도를 지정하는 매개 변수입니다. 스케일 피라미드를 만드는 데 사용됩니다.</li>\n<li>minNeighbors는 각 후보 사각형이 유지해야 하는 이웃 수를 지정하는 매개 변수입니다. 숫자가 높을수록 낮은 거짓 양성이 발생합니다.</li>\n<li>minSize는 고려해야 할 최소 사각형 크기입니다.</li>\n</ul>\n<p>함수는 이미지에서 얼굴을 감지합니다. 다음으로 이미지에서 얼굴을 \"표시\"해야 합니다. 예를 들어, 파란색 사각형 등을 사용합니다. 이 작업은 다음 코드 부분으로 수행됩니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">for</span> (x,y,w,h) <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">faces</span>:\n    cv2.<span class=\"hljs-title function_\">rectangle</span>(img,(x,y),(x+w,y+h),(<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>),<span class=\"hljs-number\">2</span>)\n    roi_gray = gray[<span class=\"hljs-attr\">y</span>:y+h, <span class=\"hljs-attr\">x</span>:x+w]\n    roi_color = img[<span class=\"hljs-attr\">y</span>:y+h, <span class=\"hljs-attr\">x</span>:x+w]\n</code></pre>\n<p>얼굴이 발견되면, 감지된 얼굴의 위치를 왼쪽 위 모서리인 (x,y)로 하는 네모 상자로 반환하며, \"w\"를 너비, \"h\"를 높이로 가집니다 == (x, y, w, h). 사진을 참조하세요.</p>\n<p>이 위치들을 얻으면, 얼굴을 위한 \"ROI\" (사각형으로 그린)를 만들고 imshow() 함수를 사용하여 결과를 표시할 수 있습니다.</p>\n<p>Rpi 터미널을 사용하여 위의 Python 스크립트를 Python 환경에서 실행해보세요:</p>\n<pre><code class=\"hljs language-js\">python faceDetection.<span class=\"hljs-property\">py</span>\n</code></pre>\n<p>결과:</p>\n<p>당신은 \"눈 탐지\" 또는 \"미소 탐지\"를 위한 분류기도 포함할 수 있습니다. 해당 경우에는 얼굴 루프 내에 분류기 함수와 사각형 그리기를 포함해야 합니다. 왜냐하면 얼굴 외부에서 눈이나 미소를 탐지하는 것은 의미가 없기 때문입니다.</p>\n<h2>예시</h2>\n<p>내 GitHub에서 다른 예제들을 찾을 수 있어요:</p>\n<ul>\n<li>faceEyeDetection.py</li>\n<li>faceSmileDetection.py</li>\n<li>faceSmileEyeDetection.py</li>\n</ul>\n<p>그리고 사진에서 결과를 확인할 수 있어요.</p>\n<p><img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_7.png\" alt=\"image\"></p>\n<p>아래 튜토리얼을 따라해서 얼굴 감지에 대해 더 잘 이해할 수 있어요:</p>\n<p>Haar Cascade Object Detection Face &#x26; Eye OpenCV Python Tutorial</p>\n<h1>5. 데이터 수집</h1>\n<p>우선, 사진을 통한 얼굴 인식에 대한 람리즈 라자의 훌륭한 작업에 감사드려야 해요!</p>\n<p>OPENCV와 Python을 사용한 얼굴 인식: 초보자를 위한 안내서</p>\n<p>그리고 비디오를 사용해 매우 포괄적인 튜토리얼을 개발한 Anirban Kar:</p>\n<p>얼굴 인식 - 3 부분</p>\n<p>두 튜토리얼을 꼭 확인해보시기를 적극 추천합니다.</p>\n<p>그렇게 말씀하시면 프로젝트의 첫 단계를 시작하겠습니다. 여기서 우리가 할 일은 마지막 단계(얼굴 감지)부터 시작하여 간단히 데이터 세트를 만드는 것입니다. 각 ID에 대해, 얼굴 감지에 사용된 부분이 회색으로 표시된 사진 그룹을 저장할 것입니다.</p>\n<p><img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_8.png\" alt=\"이미지\"></p>\n<p>먼저, 프로젝트를 개발할 디렉터리를 만드세요. 예를 들어, FacialRecognitionProject:</p>\n<pre><code class=\"hljs language-js\">mkdir <span class=\"hljs-title class_\">FacialRecognitionProject</span>\n</code></pre>\n<p>이 디렉토리에는 프로젝트용으로 만들 3개의 Python 스크립트뿐만 아니라 Facial Classifier도 저장해 두어야 해요. 이를 다운로드할 수 있는 GitHub 링크는 haarcascade_frontalface_default.xml입니다.</p>\n<p>그리고 우리의 얼굴 샘플을 저장할 하위 디렉토리를 만들어 이름을 \"dataset\"으로 지어줘요:</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-built_in\">mkdir</span> dataset\n</code></pre>\n<p>그리고 저의 GitHub에서 코드를 다운로드하세요: 01_face_dataset.py</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> cv2\n<span class=\"hljs-keyword\">import</span> os\ncam = cv2.<span class=\"hljs-title class_\">VideoCapture</span>(<span class=\"hljs-number\">0</span>)\ncam.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">640</span>) # 비디오 너비 설정\ncam.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">480</span>) # 비디오 높이 설정\nface_detector = cv2.<span class=\"hljs-title class_\">CascadeClassifier</span>(<span class=\"hljs-string\">'haarcascade_frontalface_default.xml'</span>)\n# 각 사람에 대해 하나의 숫자 얼굴 <span class=\"hljs-variable constant_\">ID</span> 입력\nface_id = <span class=\"hljs-title function_\">input</span>(<span class=\"hljs-string\">'\\n 사용자 ID를 입력하고 &#x3C;return>을 누르세요 ==> '</span>)\n<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"\\n [INFO] 얼굴 캡처 초기화. 카메라를 응시하고 기다리세요 ...\"</span>)\n# 개별 샘플링 얼굴 카운트 초기화\ncount = <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">while</span>(<span class=\"hljs-title class_\">True</span>):\n    ret, img = cam.<span class=\"hljs-title function_\">read</span>()\n    img = cv2.<span class=\"hljs-title function_\">flip</span>(img, -<span class=\"hljs-number\">1</span>) # 비디오 이미지 수직으로 뒤집기\n    gray = cv2.<span class=\"hljs-title function_\">cvtColor</span>(img, cv2.<span class=\"hljs-property\">COLOR_BGR2GRAY</span>)\n    faces = face_detector.<span class=\"hljs-title function_\">detectMultiScale</span>(gray, <span class=\"hljs-number\">1.3</span>, <span class=\"hljs-number\">5</span>)\n    <span class=\"hljs-keyword\">for</span> (x,y,w,h) <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">faces</span>:\n        cv2.<span class=\"hljs-title function_\">rectangle</span>(img, (x,y), (x+w,y+h), (<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">0</span>), <span class=\"hljs-number\">2</span>)     \n        count += <span class=\"hljs-number\">1</span>\n        # 캡처된 이미지를 데이터셋 폴더에 저장\n        cv2.<span class=\"hljs-title function_\">imwrite</span>(<span class=\"hljs-string\">\"dataset/User.\"</span> + <span class=\"hljs-title function_\">str</span>(face_id) + <span class=\"hljs-string\">'.'</span> +  \n                    <span class=\"hljs-title function_\">str</span>(count) + <span class=\"hljs-string\">\".jpg\"</span>, gray[<span class=\"hljs-attr\">y</span>:y+h,<span class=\"hljs-attr\">x</span>:x+w])\n        cv2.<span class=\"hljs-title function_\">imshow</span>(<span class=\"hljs-string\">'image'</span>, img)\n    k = cv2.<span class=\"hljs-title function_\">waitKey</span>(<span class=\"hljs-number\">100</span>) &#x26; <span class=\"hljs-number\">0xff</span> # <span class=\"hljs-string\">'ESC'</span> 키를 눌러 비디오 종료\n    <span class=\"hljs-keyword\">if</span> k == <span class=\"hljs-number\">27</span>:\n        <span class=\"hljs-keyword\">break</span>\n    elif count >= <span class=\"hljs-number\">30</span>: # <span class=\"hljs-number\">30</span>개의 얼굴 샘플 촬영 후 비디오 중지\n         <span class=\"hljs-keyword\">break</span>\n# 청소 조금\n<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"\\n [INFO] 프로그램 종료 및 정리 진행\"</span>)\ncam.<span class=\"hljs-title function_\">release</span>()\ncv2.<span class=\"hljs-title function_\">destroyAllWindows</span>()\n</code></pre>\n<p>코드는 얼굴 감지를 위한 코드와 매우 유사합니다. 추가한 부분은 \"사용자 ID를 캡처하기 위한 입력 명령\"이며, 이는 정수 번호(1, 2, 3 등)여야 합니다.</p>\n<pre><code class=\"hljs language-js\">face_id = <span class=\"hljs-title function_\">input</span>(<span class=\"hljs-string\">'\\n 사용자 ID를 입력하고 &#x3C;return>을 누르세요 ==> '</span>)\n</code></pre>\n<p>그리고 각 캡처된 프레임마다 \"데이터셋\" 디렉토리에 파일로 저장해야 합니다.</p>\n<pre><code class=\"hljs language-js\">cv2.<span class=\"hljs-title function_\">imwrite</span>(<span class=\"hljs-string\">\"dataset/User.\"</span> + <span class=\"hljs-title function_\">str</span>(face_id) + <span class=\"hljs-string\">'.'</span> + <span class=\"hljs-title function_\">str</span>(count) + <span class=\"hljs-string\">\".jpg\"</span>, gray[<span class=\"hljs-attr\">y</span>:y+h,<span class=\"hljs-attr\">x</span>:x+w])\n</code></pre>\n<p>위의 파일을 저장하기 위해서는 라이브러리 \"os\"를 import해야 합니다. 각 파일의 이름은 다음과 같은 구조를 따릅니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">User</span>.<span class=\"hljs-property\">face_id</span>.<span class=\"hljs-property\">count</span>.<span class=\"hljs-property\">jpg</span>\n</code></pre>\n<p>예를 들어, face_id가 1인 사용자의 경우, dataset/ 디렉토리에 있는 네 번째 샘플 파일은 아래와 같이 될 것입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">User</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.4</span>.<span class=\"hljs-property\">jpg</span>\n</code></pre>\n<p>PI 사진에서 보여지는 것과 같이:</p>\n<p><img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_9.png\" alt=\"Image\"></p>\n<p>내 코드에서는 각 ID로부터 30개의 샘플을 캡처하고 있습니다. 마지막 \"elif\"에서 이를 변경할 수 있습니다. 샘플의 수는 얼굴 샘플을 캡처하는 루프를 종료하는 데 사용됩니다.</p>\n<p>파이썬 스크립트를 실행하고 몇 개의 ID를 캡처하세요. 새 사용자를 집계하거나 이미 존재하는 사용자의 사진을 변경하려면 매번 스크립트를 실행해야 합니다.</p>\n<h1>6. 트레이너</h1>\n<p>이 두 번째 단계에서는 데이터셋에서 모든 사용자 데이터를 가져와 OpenCV Recognizer를 \"트레이닝\"해야 합니다. 이 작업은 특정한 OpenCV 함수를 사용하여 직접 수행됩니다. 결과는 \"trainer/\" 디렉토리에 저장된 .yml 파일이 될 것입니다.</p>\n<p><img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_10.png\" alt=\"이미지\"></p>\n<p>그러면, 훈련 데이터를 저장할 하위 디렉토리를 만드는 것으로 시작해봐요:</p>\n<pre><code class=\"hljs language-js\">mkdir trainer\n</code></pre>\n<p>제 GitHub에서 두 번째 파이썬 스크립트를 다운로드하실 거에요: 02_face_training.py</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> cv2\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">from</span> <span class=\"hljs-variable constant_\">PIL</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Image</span>\n<span class=\"hljs-keyword\">import</span> os\n# 얼굴 이미지 데이터베이스 경로\npath = <span class=\"hljs-string\">'dataset'</span>\nrecognizer = cv2.<span class=\"hljs-property\">face</span>.<span class=\"hljs-title class_\">LBPHFaceRecognizer</span>_create()\ndetector = cv2.<span class=\"hljs-title class_\">CascadeClassifier</span>(<span class=\"hljs-string\">\"haarcascade_frontalface_default.xml\"</span>);\n# 이미지 및 레이블 데이터 가져오는 함수\ndef <span class=\"hljs-title function_\">getImagesAndLabels</span>(path):\n    imagePaths = [os.<span class=\"hljs-property\">path</span>.<span class=\"hljs-title function_\">join</span>(path,f) <span class=\"hljs-keyword\">for</span> f <span class=\"hljs-keyword\">in</span> os.<span class=\"hljs-title function_\">listdir</span>(path)]     \n    faceSamples=[]\n    ids = []\n    <span class=\"hljs-keyword\">for</span> imagePath <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">imagePaths</span>:\n        PIL_img = <span class=\"hljs-title class_\">Image</span>.<span class=\"hljs-title function_\">open</span>(imagePath).<span class=\"hljs-title function_\">convert</span>(<span class=\"hljs-string\">'L'</span>) # 흑백\n        img_numpy = np.<span class=\"hljs-title function_\">array</span>(PIL_img,<span class=\"hljs-string\">'uint8'</span>)\n        id = <span class=\"hljs-title function_\">int</span>(os.<span class=\"hljs-property\">path</span>.<span class=\"hljs-title function_\">split</span>(imagePath)[-<span class=\"hljs-number\">1</span>].<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">\".\"</span>)[<span class=\"hljs-number\">1</span>])\n        faces = detector.<span class=\"hljs-title function_\">detectMultiScale</span>(img_numpy)\n        <span class=\"hljs-keyword\">for</span> (x,y,w,h) <span class=\"hljs-keyword\">in</span> <span class=\"hljs-attr\">faces</span>:\n            faceSamples.<span class=\"hljs-title function_\">append</span>(img_numpy[<span class=\"hljs-attr\">y</span>:y+h,<span class=\"hljs-attr\">x</span>:x+w])\n            ids.<span class=\"hljs-title function_\">append</span>(id)\n    <span class=\"hljs-keyword\">return</span> faceSamples,ids\nprint (<span class=\"hljs-string\">\"\\n [INFO] 얼굴을 학습 중입니다. 몇 초가 걸릴 것입니다. 기다려 주세요...\"</span>)\nfaces,ids = <span class=\"hljs-title function_\">getImagesAndLabels</span>(path)\nrecognizer.<span class=\"hljs-title function_\">train</span>(faces, np.<span class=\"hljs-title function_\">array</span>(ids))\n# 모델을 trainer/trainer.<span class=\"hljs-property\">yml</span>에 저장하기\nrecognizer.<span class=\"hljs-title function_\">write</span>(<span class=\"hljs-string\">'trainer/trainer.yml'</span>) \n# 학습된 얼굴 수 및 프로그램 종료 출력\n<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"\\n [INFO] {0} 개의 얼굴을 학습했습니다. 프로그램을 종료합니다.\"</span>.<span class=\"hljs-title function_\">format</span>(<span class=\"hljs-title function_\">len</span>(np.<span class=\"hljs-title function_\">unique</span>(ids))))\n</code></pre>\n<p>라즈베리파이에 PIL 라이브러리가 설치되어 있는지 확인해주세요. 만약 설치되어 있지 않다면, 아래의 명령을 터미널에서 실행해주세요:</p>\n<pre><code class=\"hljs language-js\">pip install pillow\n</code></pre>\n<p>우리는 OpenCV 패키지에 포함된 LBPH (LOCAL BINARY PATTERNS HISTOGRAMS) 얼굴 인식기(recognizer)를 사용할 것입니다. 아래와 같이 코드를 작성해주세요:</p>\n<pre><code class=\"hljs language-js\">recognizer = cv2.<span class=\"hljs-property\">face</span>.<span class=\"hljs-title class_\">LBPHFaceRecognizer</span>_create()\n</code></pre>\n<p>\"getImagesAndLabels (path)\" 함수는 \"dataset/\" 디렉토리의 모든 사진을 가져와서 \"Ids\"와 \"faces\" 두 가지 배열을 반환합니다. 이 배열을 입력으로 사용하여 \"인식기를 학습\"할 것입니다:</p>\n<pre><code class=\"hljs language-js\">recognizer.<span class=\"hljs-title function_\">train</span>(faces, ids)\n</code></pre>\n<p>이 결과로 \"trainer.yml\"이라는 파일이 우리가 이전에 생성한 트레이너 디렉토리에 저장됩니다.</p>\n<p>여기까지입니다! 훈련시킨 사용자의 얼굴 수를 확인하기 위해 마지막으로 출력 문을 포함했습니다.</p>\n<p>매번 Phase 1을 실행할 때마다 Phase 2도 실행해야 합니다.</p>\n<h1>7. 인식기</h1>\n<p>지금까지 우리 프로젝트의 마지막 단계에 도달했습니다. 여기서 우리는 카메라로 새로운 얼굴을 촬영하고, 이 사람이 이전에 그의 얼굴을 촬영하고 훈련했다면, 우리의 인식기는 \"예측\"을 수행하여 해당 ID와 일치 여부를 나타내는 지수를 반환합니다. 이로써 해당 일치에 대해 인식기가 얼마나 확신하는지 보여줍니다.</p>\n<p><img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_11.png\" alt=\"이미지\"></p>\n<p>GitHub에서 3단계 Python 스크립트를 내려받아봅시다: 03_face_recognition.py.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> cv2\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> os \nrecognizer = cv2.face.LBPHFaceRecognizer_create()\nrecognizer.read(<span class=\"hljs-string\">'trainer/trainer.yml'</span>)\ncascadePath = <span class=\"hljs-string\">\"haarcascade_frontalface_default.xml\"</span>\nfaceCascade = cv2.CascadeClassifier(cascadePath)\nfont = cv2.FONT_HERSHEY_SIMPLEX\n<span class=\"hljs-comment\"># 아이디 카운터 초기화</span>\n<span class=\"hljs-built_in\">id</span> = <span class=\"hljs-number\">0</span>\n<span class=\"hljs-comment\"># id에 대응하는 이름: 예) Marcelo: id=1,  등</span>\nnames = [<span class=\"hljs-string\">'없음'</span>, <span class=\"hljs-string\">'마르셀로'</span>, <span class=\"hljs-string\">'파울라'</span>, <span class=\"hljs-string\">'일자'</span>, <span class=\"hljs-string\">'Z'</span>, <span class=\"hljs-string\">'W'</span>] \n<span class=\"hljs-comment\"># 실시간 비디오 캡처 시작</span>\ncam = cv2.VideoCapture(<span class=\"hljs-number\">0</span>)\ncam.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">640</span>) <span class=\"hljs-comment\"># 비디오 너비 설정</span>\ncam.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">480</span>) <span class=\"hljs-comment\"># 비디오 높이 설정</span>\n<span class=\"hljs-comment\"># 얼굴 인식으로 인정할 최소 윈도우 크기 정의</span>\nminW = <span class=\"hljs-number\">0.1</span>*cam.get(<span class=\"hljs-number\">3</span>)\nminH = <span class=\"hljs-number\">0.1</span>*cam.get(<span class=\"hljs-number\">4</span>)\n<span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n    ret, img =cam.read()\n    img = cv2.flip(img, -<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\"># 수직으로 뒤집기</span>\n    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)\n    \n    faces = faceCascade.detectMultiScale( \n        gray,\n        scaleFactor = <span class=\"hljs-number\">1.2</span>,\n        minNeighbors = <span class=\"hljs-number\">5</span>,\n        minSize = (<span class=\"hljs-built_in\">int</span>(minW), <span class=\"hljs-built_in\">int</span>(minH)),\n       )\n    <span class=\"hljs-keyword\">for</span>(x,y,w,h) <span class=\"hljs-keyword\">in</span> faces:\n        cv2.rectangle(img, (x,y), (x+w,y+h), (<span class=\"hljs-number\">0</span>,<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">0</span>), <span class=\"hljs-number\">2</span>)\n        <span class=\"hljs-built_in\">id</span>, confidence = recognizer.predict(gray[y:y+h,x:x+w])\n        <span class=\"hljs-comment\"># 신뢰도가 100 미만이면 \"0\" : 완벽 일치</span>\n        <span class=\"hljs-keyword\">if</span> (confidence &#x3C; <span class=\"hljs-number\">100</span>):\n            <span class=\"hljs-built_in\">id</span> = names[<span class=\"hljs-built_in\">id</span>]\n            confidence = <span class=\"hljs-string\">\"  {0}%\"</span>.<span class=\"hljs-built_in\">format</span>(<span class=\"hljs-built_in\">round</span>(<span class=\"hljs-number\">100</span> - confidence))\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-built_in\">id</span> = <span class=\"hljs-string\">\"알수없음\"</span>\n            confidence = <span class=\"hljs-string\">\"  {0}%\"</span>.<span class=\"hljs-built_in\">format</span>(<span class=\"hljs-built_in\">round</span>(<span class=\"hljs-number\">100</span> - confidence))\n        \n        cv2.putText(\n                    img, \n                    <span class=\"hljs-built_in\">str</span>(<span class=\"hljs-built_in\">id</span>), \n                    (x+<span class=\"hljs-number\">5</span>,y-<span class=\"hljs-number\">5</span>), \n                    font, \n                    <span class=\"hljs-number\">1</span>, \n                    (<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">255</span>), \n                    <span class=\"hljs-number\">2</span>\n                   )\n        cv2.putText(\n                    img, \n                    <span class=\"hljs-built_in\">str</span>(confidence), \n                    (x+<span class=\"hljs-number\">5</span>,y+h-<span class=\"hljs-number\">5</span>), \n                    font, \n                    <span class=\"hljs-number\">1</span>, \n                    (<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">255</span>,<span class=\"hljs-number\">0</span>), \n                    <span class=\"hljs-number\">1</span>\n                   )  \n    \n    cv2.imshow(<span class=\"hljs-string\">'camera'</span>,img) \n    k = cv2.waitKey(<span class=\"hljs-number\">10</span>) &#x26; <span class=\"hljs-number\">0xff</span> <span class=\"hljs-comment\"># 'ESC'를 눌러 비디오 종료</span>\n    <span class=\"hljs-keyword\">if</span> k == <span class=\"hljs-number\">27</span>:\n        <span class=\"hljs-keyword\">break</span>\n<span class=\"hljs-comment\"># 정리 작업</span>\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">\"\\n [INFO] 프로그램 종료 및 정리 작업\"</span>)\ncam.release()\ncv2.destroyAllWindows()\n</code></pre>\n<p>여기에 새 배열을 추가했으므로, 숫자로 된 ID 대신 \"names\"를 표시할 것입니다:</p>\n<pre><code class=\"hljs language-python\">names = [<span class=\"hljs-string\">'없음'</span>, <span class=\"hljs-string\">'마르셀로'</span>, <span class=\"hljs-string\">'파울라'</span>, <span class=\"hljs-string\">'일자'</span>, <span class=\"hljs-string\">'Z'</span>, <span class=\"hljs-string\">'W'</span>]\n</code></pre>\n<p>예를 들어, Marcelo는 id=1인 사용자이고, Paula는 id=2인 등입니다.</p>\n<p>다음으로, 우리는 얼굴을 감지할 것이며, 이전과 같이 haasCascade 분류기를 사용할 것입니다. 감지된 얼굴을 가지고 우리는 위의 코드에서 가장 중요한 함수를 호출할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\">id, confidence = recognizer.<span class=\"hljs-title function_\">predict</span>(얼굴의 회색 부분)\n</code></pre>\n<p>recognizer.predict()는 분석할 얼굴의 캡처된 부분을 매개변수로 사용하고, 해당 소유자와 일치에 대한 신뢰도를 나타내는 id 및 인식기의 신뢰도 값을 반환할 것입니다.</p>\n<p>그리고 마지막으로, 인식기가 얼굴을 예측할 수 있다면, 이미지 위에 “확률적 ID”와 일치가 올바른지에 대한 “확률”이 표시됩니다 (“확률” = 100 - 신뢰도 지수). 그렇지 않으면, “알 수 없음” 레이블이 얼굴 위에 표시됩니다.</p>\n<p>아래는 결과를 보여주는 gif입니다:</p>\n<p><img src=\"/assets/img/2024-06-19-Real-TimeFaceRecognitionAnEnd-To-EndProject_12.png\" alt=\"결과\"></p>\n<p>이 사진에서는 이 프로젝트로 수행한 일부 테스트를 보여드립니다. 여기서 인식기가 작동하는지 확인하기 위해 사진을 사용했습니다.</p>\n<h1>8. 결론</h1>\n<p>언제나처럼, 이 프로젝트가 다른 사람들이 전자기술의 흥미로운 세계로 진입하는 데 도움이 되기를 바랍니다!</p>\n<p>세부 정보 및 최종 코드는 제 GitHub 저장소를 방문해주세요:</p>\n<p><a href=\"https://github.com/Mjrovai/OpenCV-Face-Recognition\" rel=\"nofollow\" target=\"_blank\">https://github.com/Mjrovai/OpenCV-Face-Recognition</a></p>\n<p>더 많은 프로젝트를 보시려면 제 블로그를 방문해주세요: MJRoBot.org</p>\n<p>이른 아침 인사드립니다!</p>\n<p>다음 글에서 봐요!</p>\n<p>감사합니다,</p>\n<p>마르셀로</p>\n</body>\n</html>\n"},"__N_SSG":true}