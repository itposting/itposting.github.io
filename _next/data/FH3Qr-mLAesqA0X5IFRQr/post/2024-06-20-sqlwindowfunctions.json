{"pageProps":{"post":{"title":"SQL 윈도우 함수","description":"","date":"2024-06-20 14:38","slug":"2024-06-20-sqlwindowfunctions","content":"\n\n\n<img src=\"/assets/img/2024-06-20-sqlwindowfunctions_0.png\" />\n\nSQL 윈도우 함수는 현재 행과 관련된 일련의 테이블 행 전체에서 계산을 수행하는 강력한 도구입니다. 이러한 함수는 결과 집합을 단일 행으로 그룹화하지 않고, 순위, 러닝 합계, 이동 평균 등을 포함한 복잡한 쿼리를 실행하는 방법을 제공합니다. 여기에 일반적으로 사용되는 SQL 윈도우 함수 중 일부가 있습니다:\n\n# 1. ROW_NUMBER()\n\n결과 집합의 각 파티션 내에서 행에 고유한 연속 정수를 할당하며, 각 파티션의 첫 번째 행에 대해 1부터 시작합니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n```js\nSELECT \n    column1,\n    ROW_NUMBER() OVER (PARTITION BY column2 ORDER BY column3) AS row_num\nFROM \n    table_name;\n```\n\n# 2. RANK()\n\nAssigns a rank to each row within a partition of a result set. The rank of a row is one plus the number of ranks that come before it. Ties receive the same rank, and the next rank(s) are skipped.\n\n```js\nSELECT \n    column1,\n    RANK() OVER (PARTITION BY column2 ORDER BY column3) AS rank\nFROM \n    table_name;\n``` \n\n\n<div class=\"content-ad\"></div>\n\n# 3. DENSE_RANK()\n\nRANK()과 유사하지만 랭킹 시퀀스에 갭이 없습니다. 동점인 경우 동일한 순위를 받고, 다음 순위는 1씩 증가합니다.\n\n```js\nSELECT \n    column1,\n    DENSE_RANK() OVER (PARTITION BY column2 ORDER BY column3) AS dense_rank\nFROM \n    table_name;\n```\n\n# 4. NTILE(n)\n\n<div class=\"content-ad\"></div>\n\n결과 집합을 대략적으로 n개의 동일한 부분으로 나누고 각 행에 1부터 n까지 버킷 번호를 할당합니다.\n\n```js\nSELECT \n    column1,\n    NTILE(4) OVER (ORDER BY column2) AS quartile\nFROM \n    table_name;\n```\n\n**5. LAG()**\n\n결과 집합 내 현재 행 이전에 있는 주어진 물리적 오프셋의 행에 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```sql\nSELECT \n    column1,\n    LAG(column2, 1) OVER (ORDER BY column3) AS prev_value\nFROM \n    table_name;\n```\n\n## 6. LEAD()\n\n현재 행 다음에 나오는 주어진 물리적 오프셋 위치의 행에 대한 액세스를 제공합니다.\n\n```sql\nSELECT \n    column1,\n    LEAD(column2, 1) OVER (ORDER BY column3) AS next_value\nFROM \n    table_name;\n```\n\n<div class=\"content-ad\"></div>\n\n# 7. FIRST_VALUE()\n\n주어진 값들의 정렬된 세트에서 첫 번째 값을 반환합니다.\n\n```js\nSELECT \n    column1,\n    FIRST_VALUE(column2) OVER (PARTITION BY column3 ORDER BY column4) AS first_val\nFROM \n    table_name;\n```\n\n# 8. LAST_VALUE()\n\n<div class=\"content-ad\"></div>\n\n주어진 값들의 정렬된 세트에서 마지막 값을 반환합니다.\n\n```js\nSELECT \n    column1,\n    LAST_VALUE(column2) OVER (PARTITION BY column3 ORDER BY column4 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\nFROM \n    table_name;\n```\n\n## 9. SUM()\n\n지정된 윈도우 프레임에서 값들의 합을 계산합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nSELECT \n    column1,\n    SUM(column2) OVER (PARTITION BY column3 ORDER BY column4) AS running_total\nFROM \n    table_name;\n```\n\n# 10. AVG()\n\nCalculates the average of values in a specified window frame.\n\n```js\nSELECT \n    column1,\n    AVG(column2) OVER (PARTITION BY column3 ORDER BY column4) AS running_avg\nFROM \n    table_name;\n```\n\n<div class=\"content-ad\"></div>\n\n# 11. MIN() 및 MAX()\n\n지정된 창 프레임 내에서 최소값 및 최대값을 반환합니다.\n\n```js\nSELECT \n    column1,\n    MIN(column2) OVER (PARTITION BY column3 ORDER BY column4) AS min_val,\n    MAX(column2) OVER (PARTITION BY column3 ORDER BY column4) AS max_val\nFROM \n    table_name;\n```\n\n# 창 명세화\n\n<div class=\"content-ad\"></div>\n\nOVER 절은 세 부분으로 구성될 수 있습니다:\n\n- PARTITION BY: 윈도우 함수가 적용되는 파티션으로 결과 세트를 분할합니다.\n- ORDER BY: 각 파티션 내 행의 논리적 순서를 정의합니다.\n- Window Frame: 함수가 적용되는 파티션의 하위 집합을 지정합니다 (예: 1 PRECEDING부터 현재 행까지의 ROWS).\n\n완전한 윈도우 명세를 사용한 예시:\n\n```js\nSELECT \n    column1,\n    SUM(column2) OVER (PARTITION BY column3 ORDER BY column4 ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS running_total\nFROM \n    table_name;\n```\n\n<div class=\"content-ad\"></div>\n\n이러한 함수들을 사용하면 복잡한 계산을 처리하는 더 효율적이고 가독성이 좋은 방법을 제공하여 SQL 내에서 고급 데이터 분석을 수행할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-sqlwindowfunctions_0.png"},"coverImage":"/assets/img/2024-06-20-sqlwindowfunctions_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>SQL 윈도우 함수는 현재 행과 관련된 일련의 테이블 행 전체에서 계산을 수행하는 강력한 도구입니다. 이러한 함수는 결과 집합을 단일 행으로 그룹화하지 않고, 순위, 러닝 합계, 이동 평균 등을 포함한 복잡한 쿼리를 실행하는 방법을 제공합니다. 여기에 일반적으로 사용되는 SQL 윈도우 함수 중 일부가 있습니다:</p>\n<h1>1. ROW_NUMBER()</h1>\n<p>결과 집합의 각 파티션 내에서 행에 고유한 연속 정수를 할당하며, 각 파티션의 첫 번째 행에 대해 1부터 시작합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> \n    column1,\n    <span class=\"hljs-title function_\">ROW_NUMBER</span>() <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">PARTITION</span> <span class=\"hljs-variable constant_\">BY</span> column2 <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> column3) <span class=\"hljs-variable constant_\">AS</span> row_num\n<span class=\"hljs-variable constant_\">FROM</span> \n    table_name;\n</code></pre>\n<h1>2. RANK()</h1>\n<p>Assigns a rank to each row within a partition of a result set. The rank of a row is one plus the number of ranks that come before it. Ties receive the same rank, and the next rank(s) are skipped.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> \n    column1,\n    <span class=\"hljs-title function_\">RANK</span>() <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">PARTITION</span> <span class=\"hljs-variable constant_\">BY</span> column2 <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> column3) <span class=\"hljs-variable constant_\">AS</span> rank\n<span class=\"hljs-variable constant_\">FROM</span> \n    table_name;\n</code></pre>\n<h1>3. DENSE_RANK()</h1>\n<p>RANK()과 유사하지만 랭킹 시퀀스에 갭이 없습니다. 동점인 경우 동일한 순위를 받고, 다음 순위는 1씩 증가합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> \n    column1,\n    <span class=\"hljs-title function_\">DENSE_RANK</span>() <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">PARTITION</span> <span class=\"hljs-variable constant_\">BY</span> column2 <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> column3) <span class=\"hljs-variable constant_\">AS</span> dense_rank\n<span class=\"hljs-variable constant_\">FROM</span> \n    table_name;\n</code></pre>\n<h1>4. NTILE(n)</h1>\n<p>결과 집합을 대략적으로 n개의 동일한 부분으로 나누고 각 행에 1부터 n까지 버킷 번호를 할당합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> \n    column1,\n    <span class=\"hljs-title function_\">NTILE</span>(<span class=\"hljs-number\">4</span>) <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> column2) <span class=\"hljs-variable constant_\">AS</span> quartile\n<span class=\"hljs-variable constant_\">FROM</span> \n    table_name;\n</code></pre>\n<p><strong>5. LAG()</strong></p>\n<p>결과 집합 내 현재 행 이전에 있는 주어진 물리적 오프셋의 행에 액세스할 수 있습니다.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> \n    column1,\n    <span class=\"hljs-built_in\">LAG</span>(column2, <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">OVER</span> (<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> column3) <span class=\"hljs-keyword\">AS</span> prev_value\n<span class=\"hljs-keyword\">FROM</span> \n    table_name;\n</code></pre>\n<h2>6. LEAD()</h2>\n<p>현재 행 다음에 나오는 주어진 물리적 오프셋 위치의 행에 대한 액세스를 제공합니다.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> \n    column1,\n    <span class=\"hljs-built_in\">LEAD</span>(column2, <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">OVER</span> (<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> column3) <span class=\"hljs-keyword\">AS</span> next_value\n<span class=\"hljs-keyword\">FROM</span> \n    table_name;\n</code></pre>\n<h1>7. FIRST_VALUE()</h1>\n<p>주어진 값들의 정렬된 세트에서 첫 번째 값을 반환합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> \n    column1,\n    <span class=\"hljs-title function_\">FIRST_VALUE</span>(column2) <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">PARTITION</span> <span class=\"hljs-variable constant_\">BY</span> column3 <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> column4) <span class=\"hljs-variable constant_\">AS</span> first_val\n<span class=\"hljs-variable constant_\">FROM</span> \n    table_name;\n</code></pre>\n<h1>8. LAST_VALUE()</h1>\n<p>주어진 값들의 정렬된 세트에서 마지막 값을 반환합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> \n    column1,\n    <span class=\"hljs-title function_\">LAST_VALUE</span>(column2) <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">PARTITION</span> <span class=\"hljs-variable constant_\">BY</span> column3 <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> column4 <span class=\"hljs-variable constant_\">ROWS</span> <span class=\"hljs-variable constant_\">BETWEEN</span> <span class=\"hljs-variable constant_\">UNBOUNDED</span> <span class=\"hljs-variable constant_\">PRECEDING</span> <span class=\"hljs-variable constant_\">AND</span> <span class=\"hljs-variable constant_\">UNBOUNDED</span> <span class=\"hljs-variable constant_\">FOLLOWING</span>) <span class=\"hljs-variable constant_\">AS</span> last_val\n<span class=\"hljs-variable constant_\">FROM</span> \n    table_name;\n</code></pre>\n<h2>9. SUM()</h2>\n<p>지정된 윈도우 프레임에서 값들의 합을 계산합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> \n    column1,\n    <span class=\"hljs-title function_\">SUM</span>(column2) <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">PARTITION</span> <span class=\"hljs-variable constant_\">BY</span> column3 <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> column4) <span class=\"hljs-variable constant_\">AS</span> running_total\n<span class=\"hljs-variable constant_\">FROM</span> \n    table_name;\n</code></pre>\n<h1>10. AVG()</h1>\n<p>Calculates the average of values in a specified window frame.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> \n    column1,\n    <span class=\"hljs-title function_\">AVG</span>(column2) <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">PARTITION</span> <span class=\"hljs-variable constant_\">BY</span> column3 <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> column4) <span class=\"hljs-variable constant_\">AS</span> running_avg\n<span class=\"hljs-variable constant_\">FROM</span> \n    table_name;\n</code></pre>\n<h1>11. MIN() 및 MAX()</h1>\n<p>지정된 창 프레임 내에서 최소값 및 최대값을 반환합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> \n    column1,\n    <span class=\"hljs-title function_\">MIN</span>(column2) <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">PARTITION</span> <span class=\"hljs-variable constant_\">BY</span> column3 <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> column4) <span class=\"hljs-variable constant_\">AS</span> min_val,\n    <span class=\"hljs-title function_\">MAX</span>(column2) <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">PARTITION</span> <span class=\"hljs-variable constant_\">BY</span> column3 <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> column4) <span class=\"hljs-variable constant_\">AS</span> max_val\n<span class=\"hljs-variable constant_\">FROM</span> \n    table_name;\n</code></pre>\n<h1>창 명세화</h1>\n<p>OVER 절은 세 부분으로 구성될 수 있습니다:</p>\n<ul>\n<li>PARTITION BY: 윈도우 함수가 적용되는 파티션으로 결과 세트를 분할합니다.</li>\n<li>ORDER BY: 각 파티션 내 행의 논리적 순서를 정의합니다.</li>\n<li>Window Frame: 함수가 적용되는 파티션의 하위 집합을 지정합니다 (예: 1 PRECEDING부터 현재 행까지의 ROWS).</li>\n</ul>\n<p>완전한 윈도우 명세를 사용한 예시:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> \n    column1,\n    <span class=\"hljs-title function_\">SUM</span>(column2) <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">PARTITION</span> <span class=\"hljs-variable constant_\">BY</span> column3 <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> column4 <span class=\"hljs-variable constant_\">ROWS</span> <span class=\"hljs-variable constant_\">BETWEEN</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-variable constant_\">PRECEDING</span> <span class=\"hljs-variable constant_\">AND</span> <span class=\"hljs-variable constant_\">CURRENT</span> <span class=\"hljs-variable constant_\">ROW</span>) <span class=\"hljs-variable constant_\">AS</span> running_total\n<span class=\"hljs-variable constant_\">FROM</span> \n    table_name;\n</code></pre>\n<p>이러한 함수들을 사용하면 복잡한 계산을 처리하는 더 효율적이고 가독성이 좋은 방법을 제공하여 SQL 내에서 고급 데이터 분석을 수행할 수 있습니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}