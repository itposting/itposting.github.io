{"pageProps":{"post":{"title":"Flutter에서 MQTT 사용하여 ESP8266 IoT 기기 연결하는 완벽 가이드  PART II","description":"","date":"2024-06-23 16:56","slug":"2024-06-23-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTII","content":"\n지난 글에서는 Esp8266을 MQTT 브로커에 연결하도록 구성하는 방법에 대해 논의했습니다. 아직 확인하지 않으셨다면, 먼저 그 글을 읽는 것을 적극 권장합니다.\n\n<img src=\"/assets/img/2024-06-23-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTII_0.png\" />\n\n## 파트 3: Flutter 애플리케이션 만들기\n\n먼저 Flutter 앱을 생성하고 원하는 이름으로 지어보세요.\n\n<div class=\"content-ad\"></div>\n\n애플리케이션의 상태를 수정하고 주제를 게시하거나 구독하는 다양한 더 좋은 방법이 있지만, 여기서는 StreamBuilder를 사용하여 간단하게 유지하려고 합니다. 다른 해결책으로는 Bloc, Provider 등이 있을 수 있습니다.\n\n다음 라이브러리/패키지를 설치하십시오.\n\n그런 다음 프로젝트에 위젯을 만드십시오.\n\n```js\nclass HomePage extends StatefulWidget {\n  const HomePage({super.key});\n\n  @override\n  State<HomePage> createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(); // 이 부분은 나준에 업데이트할 예정입니다.\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\nMQTTServerClient 객체를 만들고 Future 객체를 초기화합니다.\n\n```js\nclass HomePage extends StatefulWidget {\n  const HomePage({Key key}) : super(key: key);\n\n  @override\n  State<HomePage> createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n\n  late MqttServerClient client; // 참고: 브라우저용 MqttBrowserClient도 있습니다\n\n  late Future _onConnect; // 브로커에 연결되었는지 확인하기 위해 사용합니다\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(); // 이 부분은 나중에 업데이트할 것입니다\n  }\n}\n```\n\n다음으로 연결을 위한 라이프사이클 함수를 만들어보겠습니다.\n\n```js\nFuture<void> onConnected() async {\n  Logger().i(\"Connected\"); // print를 사용하거나 Logger 라이브러리를 설치하여 사용할 수 있습니다\n\n  // \"test\" 토픽에 구독합니다\n  client.subscribe(\"test\", MqttQos.atLeastOnce);\n\n  Logger().i(\"Subscribed\");\n}\n\nFuture<void> connect() async {\n  try {\n    Logger().i(\"Connection Initiated\");\n\n    await client.connect(\"test2\", \"testpass123A\");\n\n  } catch (e) {\n    Logger().e(e);\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 initState 메소드를 작성합니다.\n\n```js\n@override\n  void initState() {\n    super.initState();\n\n    try{\n      client = MqttServerClient.withPort(\"<MQTT 호스트>\",\"<임의의 이름>\",<포트 번호 예: 8883>);\n\n      client.secure = true;\n\n      Logger().i(\"클라이언트가 생성되었습니다\");\n\n\n    Logger().i(\"프로토콜이 설정되었습니다\");\n\n    client.logging(on: true);\n\n    Logger().i(\"로깅이 설정되었습니다\");\n\n    client.onConnected = onConnected;\n\n    _onConnect = connect();\n\n    }catch(e){\n      Logger().e(e);\n    }\n\n  }\n```\n\n마지막으로 위젯을 작성합니다.\n\n```js\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: FutureBuilder(\n        future: _onConnect,\n        builder: (context, snapshot) {\n\n          // 연결이 진행 중인 경우 로딩 화면을 표시합니다\n          if(snapshot.connectionState == ConnectionState.waiting){\n            return const Center(\n              child: CircularProgressIndicator(),\n            );\n          }\n\n          return StreamBuilder<List<MqttReceivedMessage<MqttMessage?>>>(\n\n            stream: client.updates,\n\n            builder: (context, snapshot) {\n\n              if(snapshot.hasData){\n                // \"test\" 토픽에서 Esp8266에서 전송한 데이터를 읽습니다\n                final message = snapshot.data!.first.payload as MqttPublishMessage;\n\n                final payload = MqttPublishPayload.bytesToStringAsString(message.payload.message);\n\n                Logger().i(payload);\n\n                return Center(\n                  child: Column(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    children: <Widget>[\n                      const Text(\"센서 데이터\"),\n                      Text(payload),\n                    ],\n                  ),\n                );\n              }\n\n              return const Center(\n                child: Column(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: <Widget>[\n                    Text(\"데이터 없음\"),\n                  ],\n                ),\n              );\n            },\n          );\n        }\n      ),\n    );\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n전체 코드\n\n```js\nimport 'package:flutter/material.dart';\nimport 'package:logger/web.dart';\nimport 'package:mqtt_client/mqtt_client.dart';\nimport 'package:mqtt_client/mqtt_server_client.dart';\n\nvoid main() {\n  runApp(const MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  const MyApp({key});\n\n  // 애플리케이션의 루트인 위젯입니다.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const HomePage(),\n    );\n  }\n}\n\nclass HomePage extends StatefulWidget {\n  const HomePage({key});\n\n  @override\n  State<HomePage> createState() => _HomePageState();\n}\n\nclass _HomePageState extends State<HomePage> {\n  late MqttServerClient client;\n\n  Future<void> onConnected() async {\n    Logger().i(\"Connected\");\n\n    // \"test\" 주제에 구독합니다.\n    client.subscribe(\"test\", MqttQos.atLeastOnce);\n\n    Logger().i(\"Subscribed\");\n  }\n\n  Future<void> connect() async {\n    try {\n      Logger().i(\"Connection Initiated\");\n\n      await client.connect(\"test2\",\"testpass123A\");\n    } catch(e) {\n      Logger().e(e);\n    }\n  }\n\n  late Future _onConnect;\n\n  @override\n  void initState() {\n    super.initState();\n\n    try {\n      client = MqttServerClient.withPort(\"<MQTT HOST>\",\"<ANY NAME>\",<PORT like 8883>);\n\n      client.secure = true;\n      Logger().i(\"Client created\");\n\n      Logger().i(\"Protocol set\");\n\n      client.logging(on: true);\n      Logger().i(\"Logging set\");\n\n      client.onConnected = onConnected;\n\n      _onConnect = connect();\n\n    } catch(e) {\n      Logger().e(e);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: FutureBuilder(\n        future: _onConnect,\n        builder: (context, snapshot) {\n          if(snapshot.connectionState == ConnectionState.waiting) {\n            return const Center(\n              child: CircularProgressIndicator(),\n            );\n          }\n\n          return StreamBuilder<List<MqttReceivedMessage<MqttMessage?>>>(\n            stream: client.updates,\n            builder: (context, snapshot) {\n              if(snapshot.hasData) {\n                // \"test\" 주제에서 Esp8266이 보낸 데이터를 읽습니다.\n                final message = snapshot.data!.first.payload as MqttPublishMessage;\n                final payload = MqttPublishPayload.bytesToStringAsString(message.payload.message);\n                Logger().i(payload);\n\n                return Center(\n                  child: Column(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    children: <Widget>[\n                      const Text(\"Sensor Data\"),\n                      Text(payload),\n                    ],\n                  ),\n                );\n              }\n\n              return const Center(\n                child: Column(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: <Widget>[\n                    Text(\"No data\"),\n                  ],\n                ),\n              );\n            },\n          );\n        }\n      ),\n    );\n  }\n}\n```\n\n이제 Esp8266을 전원에 연결하고 앱을 실행하세요.\n\n다음과 같은 화면이 나타납니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](https://miro.medium.com/v2/resize:fit:1200/1*SWHkvNtFqG3cDvk6oGLxew.gif)\n\n# 우하하 !! 우리가 MQTT를 사용하여 Esp8266에서 앱으로 데이터 성공적으로 전송했어요 !\n\n## 마지막으로\n\n대부분의 경우에는 IOT 디바이스에서 모바일 앱으로 데이터를 직접 전송하는 것은 유용하지 않을 수 있습니다. 센서 데이터와 관련된 많은 처리가 필요하기 때문입니다. 이를 위해 센서에서 데이터를 가져오기 위해 브로커에 연결할 전용 백엔드가 필요하며, 그런 다음 처리된 데이터를 다른 주제에 발행하여 이를 모바일 애플리케이션이 구독하게 할 수 있습니다. 나는 미래에 IOT의 전체 인프라에 대한 자세한 기사를 쓸지도 모르겠어요.\n\n<div class=\"content-ad\"></div>\n\n감사합니다. 궁금한 점이 있으면 언제든지 말해주세요!\n\n만약 유용하다고 느끼신다면 LinkedIn에서 저를 팔로우해 주세요.\n\n<img src=\"/assets/img/2024-06-23-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTII_1.png\" />\n","ogImage":{"url":"/assets/img/2024-06-23-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTII_0.png"},"coverImage":"/assets/img/2024-06-23-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTII_0.png","tag":["Tech"],"readingTime":8},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>지난 글에서는 Esp8266을 MQTT 브로커에 연결하도록 구성하는 방법에 대해 논의했습니다. 아직 확인하지 않으셨다면, 먼저 그 글을 읽는 것을 적극 권장합니다.</p>\n<img src=\"/assets/img/2024-06-23-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTII_0.png\">\n<h2>파트 3: Flutter 애플리케이션 만들기</h2>\n<p>먼저 Flutter 앱을 생성하고 원하는 이름으로 지어보세요.</p>\n<div class=\"content-ad\"></div>\n<p>애플리케이션의 상태를 수정하고 주제를 게시하거나 구독하는 다양한 더 좋은 방법이 있지만, 여기서는 StreamBuilder를 사용하여 간단하게 유지하려고 합니다. 다른 해결책으로는 Bloc, Provider 등이 있을 수 있습니다.</p>\n<p>다음 라이브러리/패키지를 설치하십시오.</p>\n<p>그런 다음 프로젝트에 위젯을 만드십시오.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HomePage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatefulWidget</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">HomePage</span>({<span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">key</span>});\n\n  @override\n  <span class=\"hljs-title class_\">State</span>&#x3C;<span class=\"hljs-title class_\">HomePage</span>> <span class=\"hljs-title function_\">createState</span>() => <span class=\"hljs-title function_\">_HomePageState</span>();\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_HomePageState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">State</span>&#x3C;<span class=\"hljs-title class_\">HomePage</span>> {\n\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Container</span>(); <span class=\"hljs-comment\">// 이 부분은 나준에 업데이트할 예정입니다.</span>\n  }\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>MQTTServerClient 객체를 만들고 Future 객체를 초기화합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HomePage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatefulWidget</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">HomePage</span>({<span class=\"hljs-title class_\">Key</span> key}) : <span class=\"hljs-variable language_\">super</span>(<span class=\"hljs-attr\">key</span>: key);\n\n  @override\n  <span class=\"hljs-title class_\">State</span>&#x3C;<span class=\"hljs-title class_\">HomePage</span>> <span class=\"hljs-title function_\">createState</span>() => <span class=\"hljs-title function_\">_HomePageState</span>();\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_HomePageState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">State</span>&#x3C;<span class=\"hljs-title class_\">HomePage</span>> {\n\n  late <span class=\"hljs-title class_\">MqttServerClient</span> client; <span class=\"hljs-comment\">// 참고: 브라우저용 MqttBrowserClient도 있습니다</span>\n\n  late <span class=\"hljs-title class_\">Future</span> _onConnect; <span class=\"hljs-comment\">// 브로커에 연결되었는지 확인하기 위해 사용합니다</span>\n\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Container</span>(); <span class=\"hljs-comment\">// 이 부분은 나중에 업데이트할 것입니다</span>\n  }\n}\n</code></pre>\n<p>다음으로 연결을 위한 라이프사이클 함수를 만들어보겠습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-keyword\">void</span>> <span class=\"hljs-title function_\">onConnected</span>() <span class=\"hljs-keyword\">async</span> {\n  <span class=\"hljs-title class_\">Logger</span>().<span class=\"hljs-title function_\">i</span>(<span class=\"hljs-string\">\"Connected\"</span>); <span class=\"hljs-comment\">// print를 사용하거나 Logger 라이브러리를 설치하여 사용할 수 있습니다</span>\n\n  <span class=\"hljs-comment\">// \"test\" 토픽에 구독합니다</span>\n  client.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-string\">\"test\"</span>, <span class=\"hljs-title class_\">MqttQos</span>.<span class=\"hljs-property\">atLeastOnce</span>);\n\n  <span class=\"hljs-title class_\">Logger</span>().<span class=\"hljs-title function_\">i</span>(<span class=\"hljs-string\">\"Subscribed\"</span>);\n}\n\n<span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-keyword\">void</span>> <span class=\"hljs-title function_\">connect</span>() <span class=\"hljs-keyword\">async</span> {\n  <span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-title class_\">Logger</span>().<span class=\"hljs-title function_\">i</span>(<span class=\"hljs-string\">\"Connection Initiated\"</span>);\n\n    <span class=\"hljs-keyword\">await</span> client.<span class=\"hljs-title function_\">connect</span>(<span class=\"hljs-string\">\"test2\"</span>, <span class=\"hljs-string\">\"testpass123A\"</span>);\n\n  } <span class=\"hljs-keyword\">catch</span> (e) {\n    <span class=\"hljs-title class_\">Logger</span>().<span class=\"hljs-title function_\">e</span>(e);\n  }\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>그럼 initState 메소드를 작성합니다.</p>\n<pre><code class=\"hljs language-js\">@override\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">initState</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">initState</span>();\n\n    <span class=\"hljs-keyword\">try</span>{\n      client = <span class=\"hljs-title class_\">MqttServerClient</span>.<span class=\"hljs-title function_\">withPort</span>(<span class=\"hljs-string\">\"&#x3C;MQTT 호스트>\"</span>,<span class=\"hljs-string\">\"&#x3C;임의의 이름>\"</span>,&#x3C;포트 번호 예: <span class=\"hljs-number\">8883</span>>);\n\n      client.<span class=\"hljs-property\">secure</span> = <span class=\"hljs-literal\">true</span>;\n\n      <span class=\"hljs-title class_\">Logger</span>().<span class=\"hljs-title function_\">i</span>(<span class=\"hljs-string\">\"클라이언트가 생성되었습니다\"</span>);\n\n\n    <span class=\"hljs-title class_\">Logger</span>().<span class=\"hljs-title function_\">i</span>(<span class=\"hljs-string\">\"프로토콜이 설정되었습니다\"</span>);\n\n    client.<span class=\"hljs-title function_\">logging</span>(<span class=\"hljs-attr\">on</span>: <span class=\"hljs-literal\">true</span>);\n\n    <span class=\"hljs-title class_\">Logger</span>().<span class=\"hljs-title function_\">i</span>(<span class=\"hljs-string\">\"로깅이 설정되었습니다\"</span>);\n\n    client.<span class=\"hljs-property\">onConnected</span> = onConnected;\n\n    _onConnect = <span class=\"hljs-title function_\">connect</span>();\n\n    }<span class=\"hljs-keyword\">catch</span>(e){\n      <span class=\"hljs-title class_\">Logger</span>().<span class=\"hljs-title function_\">e</span>(e);\n    }\n\n  }\n</code></pre>\n<p>마지막으로 위젯을 작성합니다.</p>\n<pre><code class=\"hljs language-js\">  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Scaffold</span>(\n      <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">FutureBuilder</span>(\n        <span class=\"hljs-attr\">future</span>: _onConnect,\n        <span class=\"hljs-attr\">builder</span>: (context, snapshot) {\n\n          <span class=\"hljs-comment\">// 연결이 진행 중인 경우 로딩 화면을 표시합니다</span>\n          <span class=\"hljs-keyword\">if</span>(snapshot.<span class=\"hljs-property\">connectionState</span> == <span class=\"hljs-title class_\">ConnectionState</span>.<span class=\"hljs-property\">waiting</span>){\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Center</span>(\n              <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">CircularProgressIndicator</span>(),\n            );\n          }\n\n          <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">StreamBuilder</span>&#x3C;<span class=\"hljs-title class_\">List</span>&#x3C;<span class=\"hljs-title class_\">MqttReceivedMessage</span>&#x3C;<span class=\"hljs-title class_\">MqttMessage</span>?>>>(\n\n            <span class=\"hljs-attr\">stream</span>: client.<span class=\"hljs-property\">updates</span>,\n\n            <span class=\"hljs-attr\">builder</span>: (context, snapshot) {\n\n              <span class=\"hljs-keyword\">if</span>(snapshot.<span class=\"hljs-property\">hasData</span>){\n                <span class=\"hljs-comment\">// \"test\" 토픽에서 Esp8266에서 전송한 데이터를 읽습니다</span>\n                final message = snapshot.<span class=\"hljs-property\">data</span>!.<span class=\"hljs-property\">first</span>.<span class=\"hljs-property\">payload</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">MqttPublishMessage</span>;\n\n                final payload = <span class=\"hljs-title class_\">MqttPublishPayload</span>.<span class=\"hljs-title function_\">bytesToStringAsString</span>(message.<span class=\"hljs-property\">payload</span>.<span class=\"hljs-property\">message</span>);\n\n                <span class=\"hljs-title class_\">Logger</span>().<span class=\"hljs-title function_\">i</span>(payload);\n\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Center</span>(\n                  <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Column</span>(\n                    <span class=\"hljs-attr\">mainAxisAlignment</span>: <span class=\"hljs-title class_\">MainAxisAlignment</span>.<span class=\"hljs-property\">center</span>,\n                    <span class=\"hljs-attr\">children</span>: &#x3C;<span class=\"hljs-title class_\">Widget</span>>[\n                      <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"센서 데이터\"</span>),\n                      <span class=\"hljs-title class_\">Text</span>(payload),\n                    ],\n                  ),\n                );\n              }\n\n              <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">Center</span>(\n                <span class=\"hljs-attr\">child</span>: <span class=\"hljs-title class_\">Column</span>(\n                  <span class=\"hljs-attr\">mainAxisAlignment</span>: <span class=\"hljs-title class_\">MainAxisAlignment</span>.<span class=\"hljs-property\">center</span>,\n                  <span class=\"hljs-attr\">children</span>: &#x3C;<span class=\"hljs-title class_\">Widget</span>>[\n                    <span class=\"hljs-title class_\">Text</span>(<span class=\"hljs-string\">\"데이터 없음\"</span>),\n                  ],\n                ),\n              );\n            },\n          );\n        }\n      ),\n    );\n  }\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>전체 코드</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:flutter/material.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:logger/web.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:mqtt_client/mqtt_client.dart'</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">'package:mqtt_client/mqtt_server_client.dart'</span>;\n\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"></span>) {\n  <span class=\"hljs-title function_\">runApp</span>(<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MyApp</span>());\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyApp</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatelessWidget</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">MyApp</span>({key});\n\n  <span class=\"hljs-comment\">// 애플리케이션의 루트인 위젯입니다.</span>\n  @override\n  <span class=\"hljs-title class_\">Widget</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">BuildContext context</span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">MaterialApp</span>(\n      <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">'Flutter Demo'</span>,\n      <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-title class_\">ThemeData</span>(\n        <span class=\"hljs-attr\">colorScheme</span>: <span class=\"hljs-title class_\">ColorScheme</span>.<span class=\"hljs-title function_\">fromSeed</span>(<span class=\"hljs-attr\">seedColor</span>: <span class=\"hljs-title class_\">Colors</span>.<span class=\"hljs-property\">deepPurple</span>),\n        <span class=\"hljs-attr\">useMaterial3</span>: <span class=\"hljs-literal\">true</span>,\n      ),\n      <span class=\"hljs-attr\">home</span>: <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">HomePage</span>(),\n    );\n  }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HomePage</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">StatefulWidget</span> {\n  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">HomePage</span>({key});\n\n  @override\n  <span class=\"hljs-title class_\">State</span>&#x3C;<span class=\"hljs-title class_\">HomePage</span>> <span class=\"hljs-title function_\">createState</span>() => <span class=\"hljs-title function_\">_HomePageState</span>();\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">_HomePageState</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">State</span>&#x3C;<span class=\"hljs-title class_\">HomePage</span>> {\n  late <span class=\"hljs-title class_\">MqttServerClient</span> client;\n\n  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-keyword\">void</span>> <span class=\"hljs-title function_\">onConnected</span>() <span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-title class_\">Logger</span>().<span class=\"hljs-title function_\">i</span>(<span class=\"hljs-string\">\"Connected\"</span>);\n\n    <span class=\"hljs-comment\">// \"test\" 주제에 구독합니다.</span>\n    client.<span class=\"hljs-title function_\">subscribe</span>(<span class=\"hljs-string\">\"test\"</span>, <span class=\"hljs-title class_\">MqttQos</span>.<span class=\"hljs-property\">atLeastOnce</span>);\n\n    <span class=\"hljs-title class_\">Logger</span>().<span class=\"hljs-title function_\">i</span>(<span class=\"hljs-string\">\"Subscribed\"</span>);\n  }\n\n  <span class=\"hljs-title class_\">Future</span>&#x3C;<span class=\"hljs-keyword\">void</span>> <span class=\"hljs-title function_\">connect</span>() <span class=\"hljs-keyword\">async</span> {\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-title class_\">Logger</span>().<span class=\"hljs-title function_\">i</span>(<span class=\"hljs-string\">\"Connection Initiated\"</span>);\n\n      <span class=\"hljs-keyword\">await</span> client.<span class=\"hljs-title function_\">connect</span>(<span class=\"hljs-string\">\"test2\"</span>,<span class=\"hljs-string\">\"testpass123A\"</span>);\n    } <span class=\"hljs-keyword\">catch</span>(e) {\n      <span class=\"hljs-title class_\">Logger</span>().<span class=\"hljs-title function_\">e</span>(e);\n    }\n  }\n\n  late <span class=\"hljs-title class_\">Future</span> _onConnect;\n\n  @override\n  <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">initState</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-title function_\">initState</span>();\n\n    <span class=\"hljs-keyword\">try</span> {\n      client = <span class=\"hljs-title class_\">MqttServerClient</span>.<span class=\"hljs-title function_\">withPort</span>(<span class=\"hljs-string\">\"&#x3C;MQTT HOST>\"</span>,<span class=\"hljs-string\">\"&#x3C;ANY NAME>\"</span>,&#x3C;PORT like 8883>);\n\n      client.secure = true;\n      Logger().i(\"Client created\");\n\n      Logger().i(\"Protocol set\");\n\n      client.logging(on: true);\n      Logger().i(\"Logging set\");\n\n      client.onConnected = onConnected;\n\n      _onConnect = connect();\n\n    } catch(e) {\n      Logger().e(e);\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: FutureBuilder(\n        future: _onConnect,\n        builder: (context, snapshot) {\n          if(snapshot.connectionState == ConnectionState.waiting) {\n            return const Center(\n              child: CircularProgressIndicator(),\n            );\n          }\n\n          return StreamBuilder&#x3C;List&#x3C;MqttReceivedMessage&#x3C;MqttMessage?>>>(\n            stream: client.updates,\n            builder: (context, snapshot) {\n              if(snapshot.hasData) {\n                // \"test\" 주제에서 Esp8266이 보낸 데이터를 읽습니다.\n                final message = snapshot.data!.first.payload as MqttPublishMessage;\n                final payload = MqttPublishPayload.bytesToStringAsString(message.payload.message);\n                Logger().i(payload);\n\n                return Center(\n                  child: Column(\n                    mainAxisAlignment: MainAxisAlignment.center,\n                    children: &#x3C;Widget>[\n                      const Text(\"Sensor Data\"),\n                      Text(payload),\n                    ],\n                  ),\n                );\n              }\n\n              return const Center(\n                child: Column(\n                  mainAxisAlignment: MainAxisAlignment.center,\n                  children: &#x3C;Widget>[\n                    Text(\"No data\"),\n                  ],\n                ),\n              );\n            },\n          );\n        }\n      ),\n    );\n  }\n}\n</code></pre>\n<p>이제 Esp8266을 전원에 연결하고 앱을 실행하세요.</p>\n<p>다음과 같은 화면이 나타납니다.</p>\n<div class=\"content-ad\"></div>\n<p><img src=\"https://miro.medium.com/v2/resize:fit:1200/1*SWHkvNtFqG3cDvk6oGLxew.gif\" alt=\"이미지\"></p>\n<h1>우하하 !! 우리가 MQTT를 사용하여 Esp8266에서 앱으로 데이터 성공적으로 전송했어요 !</h1>\n<h2>마지막으로</h2>\n<p>대부분의 경우에는 IOT 디바이스에서 모바일 앱으로 데이터를 직접 전송하는 것은 유용하지 않을 수 있습니다. 센서 데이터와 관련된 많은 처리가 필요하기 때문입니다. 이를 위해 센서에서 데이터를 가져오기 위해 브로커에 연결할 전용 백엔드가 필요하며, 그런 다음 처리된 데이터를 다른 주제에 발행하여 이를 모바일 애플리케이션이 구독하게 할 수 있습니다. 나는 미래에 IOT의 전체 인프라에 대한 자세한 기사를 쓸지도 모르겠어요.</p>\n<div class=\"content-ad\"></div>\n<p>감사합니다. 궁금한 점이 있으면 언제든지 말해주세요!</p>\n<p>만약 유용하다고 느끼신다면 LinkedIn에서 저를 팔로우해 주세요.</p>\n<img src=\"/assets/img/2024-06-23-MQTTinFlutterAComprehensiveGuidetoConnectApplicationswithESP8266IOTDevicesPARTII_1.png\">\n</body>\n</html>\n"},"__N_SSG":true}