{"pageProps":{"post":{"title":"SQL 윈도우 함수 탐구 ROW_NUMBER, RANK, DENSE_RANK 사용 방법","description":"","date":"2024-06-22 17:39","slug":"2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK","content":"\n\nSQL 세계에서 윈도우 함수는 현재 행과 관련된 테이블 행 집합을 대상으로 계산을 수행할 수 있는 강력한 도구입니다. 이 글에서는 세 가지 필수 SQL 윈도우 함수인 ROW_NUMBER, RANK 및 DENSE_RANK에 대해 알아볼 것입니다. 이러한 함수를 사용하면 결과 세트 내에서 행에 고유한 번호나 순위를 할당하여 데이터에서 가치 있는 통찰을 추출하기가 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n일반 구문:\nROW_NUMBER() OVER (ORDER BY column)\n\n- ORDER BY는 결과 집합을 정렬하는 데 사용되는 열 또는 표현식을 지정합니다.\n\nROW_NUMBER() OVER (PARTITION BY column ORDER BY column)\n\n- PARTITION BY는 지정된 열을 기준으로 결과 집합을 분할하는 선택적 절입니다. 순위가 각 파티션 내에서 별도로 적용됩니다.\n\n<div class=\"content-ad\"></div>\n\n회사 직원들에게 급여 순으로 내림차순으로 새 직원 ID를 할당해 봅시다:\n\n```js\nSELECT * , ROW_NUMBER() OVER(ORDER BY salary DESC) AS new_employee_id\nFROM employees;\n```\n\n![이미지](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_1.png)\n\n직원들을 급여에 따라 내림차순으로 순위를 매기고, 'position' 열을 기준으로 결과 집합을 파티션으로 나눠 봅시다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\nSELECT * , ROW_NUMBER() OVER(PARTITION BY position ORDER BY salary DESC) AS employee_rank\nFROM employees;\n```\n\n![Exploring SQL Window Functions](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_2.png)\n\n## 2. RANK Function\n\nThe RANK() function assigns a unique rank to each row based on the values in one or more columns. Rows with the same values receive the same rank, and the next rank is skipped. It’s useful when you want to create a ranking with gaps.\n\n\n<div class=\"content-ad\"></div>\n\n일반적인 구문:\n\nRANK() OVER (ORDER BY column)\n\nRANK() OVER (PARTITION BY column ORDER BY column)\n\n우리는 직원들을 급여에 따라 내림차순으로 순위 매겨볼게요:\n\n<div class=\"content-ad\"></div>\n\n```sql\nSELECT * , RANK() OVER(ORDER BY salary DESC) AS salary_rank\nFROM employees;\n```\n\n![Exploring SQL Window Functions](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_3.png)\n\n## 3. DENSE_RANK Function: 동일한 순위를 가진 항목 그룹화하기\n\nDENSE_RANK() 함수는 동일한 순위를 가진 항목을 함께 그룹화하고 싶을 때 유용합니다. 동일한 값들을 갖는 행들은 동일한 순위를 부여받으며, 다음 순위가 건너뛰어지지 않습니다. 이 함수는 순위에 빈칸이 없는 순위를 만들고 싶을 때 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n일반적인 구문:\n\n\nDENSE_RANK() OVER (ORDER BY column)\n\nDENSE_RANK() OVER (PARTITION BY column ORDER BY column)\n\n\n만약 \"titles\"라는 테이블이 있고 \"title\"과 \"price\"라는 열이 있다고 가정해보겠습니다.\n책 제목을 가격순으로 순위를 매기고 동일한 가격을 가진 제목들을 그룹화하려면:\n\n<div class=\"content-ad\"></div>\n\n```js\nSELECT title, price, DENSE_RANK() OVER(ORDER BY price DESC) as 'rank'\nFROM titles;\n```\n\n![Exploring SQL Window Functions](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_4.png)\n\n‘type’ 열을 기반으로 결과 집합을 파티션으로 나눠 봅시다.\n\n```js\nSELECT title, price, type, DENSE_RANK() OVER(PARTITION BY type ORDER BY price DESC) as 'rank'\nFROM titles;\n```\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_5.png)\n\n가정하고 있는 것은 \"titles\"라는 테이블이 \"title\"과 \"ytd_sales\"라는 열을 가지고 있다는 것입니다. 성과가 좋은 책을 식별하기 위해 다음 쿼리를 사용할 수 있습니다:\n\n```js\nSELECT title, ytd_sales, DENSE_RANK() OVER(ORDER BY ytd_sales DESC) as 'rank'\nFROM titles;\n```\n\n![image](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n‘type’ 열을 기반으로 결과 집합을 파티션으로 나눠 봅시다.\n\n```js\nSELECT title, ytd_sales, type, DENSE_RANK() OVER(PARTITION BY type ORDER BY ytd_sales DESC) as 'rank'\nFROM titles;\n```\n\n![참고 이미지](/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_7.png)\n\n# 세 가지 함수를 모두 결합하기\n\n<div class=\"content-ad\"></div>\n\n직원의 급여와 함께 직원 목록이 있는 시나리오를 고려해보세요. 각 직원에 고유한 직원 ID를 할당하고, 급여순으로 순위를 매기고, 촘촘한 순위를 부여하려고 합니다.\n\n```js\nSELECT \n    first_name, last_name, position, salary,\n    ROW_NUMBER() OVER (ORDER BY salary) AS employee_id,\n    RANK() OVER (ORDER BY salary) AS salary_rank,\n    DENSE_RANK() OVER (ORDER BY salary) AS dense_salary_rank\nFROM employees;\n```\n\n이 예제에서는 세 윈도우 함수를 한 쿼리에서 모두 사용합니다:\n\n- ROW_NUMBER()는 각 직원에게 고유한 employee_id를 할당합니다.\n- RANK()는 직원들을 급여에 따라 순위를 매기되, 동일한 급여의 경우 갭을 둡니다.\n- DENSE_RANK()는 직원들을 급여에 따라 순위를 매기되, 동일한 급여의 경우 갭을 두지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n이 쿼리는 직원 데이터의 종합적인 정보를 제공합니다. 고유 식별자와 두 가지 유형의 급여 순위가 포함되어 있습니다.\n\n## 결론\n\nROW_NUMBER, RANK, DENSE_RANK와 같은 SQL 윈도우 함수는 데이터 분석 및 보고에 불가결한 도구입니다. 이들은 결과 집합 내에서 행에 고유한 번호나 순위를 할당하여 데이터에서 통찰을 도출하는 작업을 더 쉽게 만들어 줍니다.\n\n# SQL 기초 개념\n\n<div class=\"content-ad\"></div>\n\n감사합니다! 더 많은 콘텐츠는 SQL Fundamentals에서도 찾아볼 수 있어요! 🚀💫","ogImage":{"url":"/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_0.png"},"coverImage":"/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_0.png","tag":["Tech"],"readingTime":5},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>SQL 세계에서 윈도우 함수는 현재 행과 관련된 테이블 행 집합을 대상으로 계산을 수행할 수 있는 강력한 도구입니다. 이 글에서는 세 가지 필수 SQL 윈도우 함수인 ROW_NUMBER, RANK 및 DENSE_RANK에 대해 알아볼 것입니다. 이러한 함수를 사용하면 결과 세트 내에서 행에 고유한 번호나 순위를 할당하여 데이터에서 가치 있는 통찰을 추출하기가 쉬워집니다.</p>\n<div class=\"content-ad\"></div>\n<p>일반 구문:\nROW_NUMBER() OVER (ORDER BY column)</p>\n<ul>\n<li>ORDER BY는 결과 집합을 정렬하는 데 사용되는 열 또는 표현식을 지정합니다.</li>\n</ul>\n<p>ROW_NUMBER() OVER (PARTITION BY column ORDER BY column)</p>\n<ul>\n<li>PARTITION BY는 지정된 열을 기준으로 결과 집합을 분할하는 선택적 절입니다. 순위가 각 파티션 내에서 별도로 적용됩니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>회사 직원들에게 급여 순으로 내림차순으로 새 직원 ID를 할당해 봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> * , <span class=\"hljs-title function_\">ROW_NUMBER</span>() <span class=\"hljs-title function_\">OVER</span>(<span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> salary <span class=\"hljs-variable constant_\">DESC</span>) <span class=\"hljs-variable constant_\">AS</span> new_employee_id\n<span class=\"hljs-variable constant_\">FROM</span> employees;\n</code></pre>\n<p><img src=\"/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_1.png\" alt=\"이미지\"></p>\n<p>직원들을 급여에 따라 내림차순으로 순위를 매기고, 'position' 열을 기준으로 결과 집합을 파티션으로 나눠 봅시다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> * , <span class=\"hljs-title function_\">ROW_NUMBER</span>() <span class=\"hljs-title function_\">OVER</span>(<span class=\"hljs-variable constant_\">PARTITION</span> <span class=\"hljs-variable constant_\">BY</span> position <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> salary <span class=\"hljs-variable constant_\">DESC</span>) <span class=\"hljs-variable constant_\">AS</span> employee_rank\n<span class=\"hljs-variable constant_\">FROM</span> employees;\n</code></pre>\n<p><img src=\"/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_2.png\" alt=\"Exploring SQL Window Functions\"></p>\n<h2>2. RANK Function</h2>\n<p>The RANK() function assigns a unique rank to each row based on the values in one or more columns. Rows with the same values receive the same rank, and the next rank is skipped. It’s useful when you want to create a ranking with gaps.</p>\n<div class=\"content-ad\"></div>\n<p>일반적인 구문:</p>\n<p>RANK() OVER (ORDER BY column)</p>\n<p>RANK() OVER (PARTITION BY column ORDER BY column)</p>\n<p>우리는 직원들을 급여에 따라 내림차순으로 순위 매겨볼게요:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> , <span class=\"hljs-built_in\">RANK</span>() <span class=\"hljs-keyword\">OVER</span>(<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> salary <span class=\"hljs-keyword\">DESC</span>) <span class=\"hljs-keyword\">AS</span> salary_rank\n<span class=\"hljs-keyword\">FROM</span> employees;\n</code></pre>\n<p><img src=\"/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_3.png\" alt=\"Exploring SQL Window Functions\"></p>\n<h2>3. DENSE_RANK Function: 동일한 순위를 가진 항목 그룹화하기</h2>\n<p>DENSE_RANK() 함수는 동일한 순위를 가진 항목을 함께 그룹화하고 싶을 때 유용합니다. 동일한 값들을 갖는 행들은 동일한 순위를 부여받으며, 다음 순위가 건너뛰어지지 않습니다. 이 함수는 순위에 빈칸이 없는 순위를 만들고 싶을 때 유용합니다.</p>\n<div class=\"content-ad\"></div>\n<p>일반적인 구문:</p>\n<p>DENSE_RANK() OVER (ORDER BY column)</p>\n<p>DENSE_RANK() OVER (PARTITION BY column ORDER BY column)</p>\n<p>만약 \"titles\"라는 테이블이 있고 \"title\"과 \"price\"라는 열이 있다고 가정해보겠습니다.\n책 제목을 가격순으로 순위를 매기고 동일한 가격을 가진 제목들을 그룹화하려면:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> title, price, <span class=\"hljs-title function_\">DENSE_RANK</span>() <span class=\"hljs-title function_\">OVER</span>(<span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> price <span class=\"hljs-variable constant_\">DESC</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-string\">'rank'</span>\n<span class=\"hljs-variable constant_\">FROM</span> titles;\n</code></pre>\n<p><img src=\"/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_4.png\" alt=\"Exploring SQL Window Functions\"></p>\n<p>‘type’ 열을 기반으로 결과 집합을 파티션으로 나눠 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> title, price, type, <span class=\"hljs-title function_\">DENSE_RANK</span>() <span class=\"hljs-title function_\">OVER</span>(<span class=\"hljs-variable constant_\">PARTITION</span> <span class=\"hljs-variable constant_\">BY</span> type <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> price <span class=\"hljs-variable constant_\">DESC</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-string\">'rank'</span>\n<span class=\"hljs-variable constant_\">FROM</span> titles;\n</code></pre>\n<div class=\"content-ad\"></div>\n<p><img src=\"/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_5.png\" alt=\"image\"></p>\n<p>가정하고 있는 것은 \"titles\"라는 테이블이 \"title\"과 \"ytd_sales\"라는 열을 가지고 있다는 것입니다. 성과가 좋은 책을 식별하기 위해 다음 쿼리를 사용할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> title, ytd_sales, <span class=\"hljs-title function_\">DENSE_RANK</span>() <span class=\"hljs-title function_\">OVER</span>(<span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> ytd_sales <span class=\"hljs-variable constant_\">DESC</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-string\">'rank'</span>\n<span class=\"hljs-variable constant_\">FROM</span> titles;\n</code></pre>\n<p><img src=\"/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_6.png\" alt=\"image\"></p>\n<div class=\"content-ad\"></div>\n<p>‘type’ 열을 기반으로 결과 집합을 파티션으로 나눠 봅시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> title, ytd_sales, type, <span class=\"hljs-title function_\">DENSE_RANK</span>() <span class=\"hljs-title function_\">OVER</span>(<span class=\"hljs-variable constant_\">PARTITION</span> <span class=\"hljs-variable constant_\">BY</span> type <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> ytd_sales <span class=\"hljs-variable constant_\">DESC</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-string\">'rank'</span>\n<span class=\"hljs-variable constant_\">FROM</span> titles;\n</code></pre>\n<p><img src=\"/assets/img/2024-06-22-ExploringSQLWindowFunctionsROW_NUMBERRANKandDENSE_RANK_7.png\" alt=\"참고 이미지\"></p>\n<h1>세 가지 함수를 모두 결합하기</h1>\n<div class=\"content-ad\"></div>\n<p>직원의 급여와 함께 직원 목록이 있는 시나리오를 고려해보세요. 각 직원에 고유한 직원 ID를 할당하고, 급여순으로 순위를 매기고, 촘촘한 순위를 부여하려고 합니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">SELECT</span> \n    first_name, last_name, position, salary,\n    <span class=\"hljs-title function_\">ROW_NUMBER</span>() <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> salary) <span class=\"hljs-variable constant_\">AS</span> employee_id,\n    <span class=\"hljs-title function_\">RANK</span>() <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> salary) <span class=\"hljs-variable constant_\">AS</span> salary_rank,\n    <span class=\"hljs-title function_\">DENSE_RANK</span>() <span class=\"hljs-variable constant_\">OVER</span> (<span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> salary) <span class=\"hljs-variable constant_\">AS</span> dense_salary_rank\n<span class=\"hljs-variable constant_\">FROM</span> employees;\n</code></pre>\n<p>이 예제에서는 세 윈도우 함수를 한 쿼리에서 모두 사용합니다:</p>\n<ul>\n<li>ROW_NUMBER()는 각 직원에게 고유한 employee_id를 할당합니다.</li>\n<li>RANK()는 직원들을 급여에 따라 순위를 매기되, 동일한 급여의 경우 갭을 둡니다.</li>\n<li>DENSE_RANK()는 직원들을 급여에 따라 순위를 매기되, 동일한 급여의 경우 갭을 두지 않습니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>이 쿼리는 직원 데이터의 종합적인 정보를 제공합니다. 고유 식별자와 두 가지 유형의 급여 순위가 포함되어 있습니다.</p>\n<h2>결론</h2>\n<p>ROW_NUMBER, RANK, DENSE_RANK와 같은 SQL 윈도우 함수는 데이터 분석 및 보고에 불가결한 도구입니다. 이들은 결과 집합 내에서 행에 고유한 번호나 순위를 할당하여 데이터에서 통찰을 도출하는 작업을 더 쉽게 만들어 줍니다.</p>\n<h1>SQL 기초 개념</h1>\n<div class=\"content-ad\"></div>\n<p>감사합니다! 더 많은 콘텐츠는 SQL Fundamentals에서도 찾아볼 수 있어요! 🚀💫</p>\n</body>\n</html>\n"},"__N_SSG":true}