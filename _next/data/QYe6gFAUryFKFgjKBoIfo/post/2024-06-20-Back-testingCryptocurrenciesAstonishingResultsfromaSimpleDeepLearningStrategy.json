{"pageProps":{"post":{"title":"암호화폐 백테스팅 간단한 딥 러닝 전략의 놀라운 결과","description":"","date":"2024-06-20 18:11","slug":"2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy","content":"\n\n암호화폐 시장의 급격한 변동 속에서 백테스팅은 투자 전략을 검증하는 데 중요한 역할을 합니다. 본 연구는 비트코인, 이더리움, 바이낸스 코인, 솔라나 및 엑스알피와 같은 주요 암호화폐를 간단한 딥 러닝 모델을 활용해 평가하는 데 초점을 맞췄습니다. 놀랍게도, 이 방법은 다음과 같이 매우 뛰어난 성과 지표를 제시합니다:\n\n- 샤프 비율: 19.898, 비법적인 위험 조정 수익을 나타냅니다.\n- 소티노 비율: 114.442, 무시할 만한 하락 위험을 나타냅니다.\n- 베타: -0.131, 역시장 상관 관계를 보여줍니다.\n- 알파: 0.021, 주목할 만한 추세를 강조합니다.\n\n이 간단하고 효과적인 딥 러닝 모델에 의해 높은 성과를 이룬 이러한 결과는 전략적인 투자에 대한 깊은 통찰을 제공합니다.\n\n따라서, 우리는 바이낸스의 다섯 가지 암호화폐 쌍에 대해 (새 전략으로 불리는) 간단한 전략을 사용하여 백테스팅을 진행했습니다. 결과는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\nBTCUSDT\n\n![image1](/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_0.png)\n\n![image2](/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_1.png)\n\nETHUSDT\n\n<div class=\"content-ad\"></div>\n\nBNBUSDT\n\nSOLUSDT\n\nXRPUSDT\n\n# ETH/USDT 백테스팅 성능 지표 분석\n\n<div class=\"content-ad\"></div>\n\n간단한 딥 러닝 전략을 사용하여 ETH/USDT의 백 테스팅 결과는 다음과 같은 성능 지표를 보여줍니다:\n\n- 평균 절대 오차 (MAE): 19.994, 예측 오차의 평균 크기를 나타냅니다.\n- 제곱근 평균 제곱 오차 (RMSE): 25.152, 예측 값과 실제 값 사이의 평균 제곱 차이의 제곱근을 나타냅니다.\n- R-제곱 (R²): 0.997, 예측 값과 실제 가격 사이에 매우 높은 상관 관계를 보여줍니다. 이는 모델이 변동성 거의 모두를 설명한다는 것을 의미합니다.\n- 평균 절대 백분율 오차 (MAPE): 0.0007, 예측 값과 실제 값 사이의 평균 퍼센트 오차를 나타냅니다.\n- 샤프 비율 (신 전략): 15.967, 새 전략의 우수한 리스크 조정 수익을 보여줍니다.\n- 소티노 비율 (신 전략): 116.496, 최소한의 하향 리스크를 강조합니다.\n- 베타 (신 전략): 0.048, 시장과의 낮은 양의 상관 관계를 보여줍니다.\n- 알파 (신 전략): 0.022, 전략이 시장 기준에 비해 우수한 성과를 보여주는 것을 나타냅니다.\n- 교차 검증 MAE: 661.709 ± 499.095, 모델의 예측 오차를 데이터의 다양한 하위 집합에 걸쳐 추정합니다.\n\n이러한 지표들은 이 백 테스트에서 적용된 딥 러닝 전략의 높은 성능과 견고성을 강조합니다.\n\n이것은 단지 예시일 뿐이며, 충분한 데이터가 있다면 바이낸스나 다른 거래소의 모든 심볼에서도 좋은 결과를 얻을 수 있을 것이라고 생각합니다.\n\n<div class=\"content-ad\"></div>\n\n리플레이 결과\n\n이 결과를 다시 확인하거나 새로 시도하려면 다음 코드를 사용할 수 있습니다:\n\n- 모델 만들기\n\n```js\nimport ccxt\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom sklearn.preprocessing import MinMaxScaler\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Conv1D, MaxPooling1D, Dropout, Flatten\nimport tf2onnx\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom tensorflow.keras import callbacks\nfrom tensorflow.keras.callbacks import ModelCheckpoint\n\n# 바이낸스에서 데이터 다운로드하는 함수\ndef descargar_datos(symbol, timeframe='1d', start_date='2004-01-01T00:00:00Z', end_date='2024-01-01T00:00:00Z'):\n    exchange = ccxt.binance({'enableRateLimit': False})\n    since = exchange.parse8601(start_date)\n    end_date_timestamp = pd.to_datetime(end_date, utc=True)\n    all_data = []\n\n    while since < end_date_timestamp.timestamp() * 1000:\n        ohlc = exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=since)\n        all_data.extend(ohlc)\n        since = ohlc[-1][0] + 1  # 'since' 매개변수 1밀리초 증가\n\n    df = pd.DataFrame(all_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\n    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')\n    df.set_index('timestamp', inplace=True)\n\n    # 두 데이터 모두 타임존이 설정되어 있는지 확인하거나 필요한 경우 변환\n    if df.index.tz is None:\n        df.index = df.index.tz_localize('utc')\n    \n    df = df[df.index <= end_date_timestamp]\n    print(df)\n    return df['close'].values\n\n# 데이터 불러오기\ndata = descargar_datos('ETH/USDT')\n\n# 데이터 정규화\nscaler = MinMaxScaler(feature_range=(0, 1))\ndata = scaler.fit_transform(data.reshape(-1, 1))\n\n# 시퀀스에서 샘플 생성하는 함수\ndef crear_muestras(dataset, pasos_de_tiempo=120):\n    X, y = [], []\n    for i in range(pasos_de_tiempo, len(dataset)):\n        X.append(dataset[i-pasos_de_tiempo:i, 0])\n        y.append(dataset[i, 0])\n    return np.array(X), np.array(y)\n\n# 훈련 및 테스트 데이터 준비\npasos_de_tiempo = 120\nX, y = crear_muestras(data, pasos_de_tiempo)\nX = X.reshape(X.shape[0], X.shape[1], 1)  # LSTM용 변경\n\n# 데이터 분할 (훈련에 80% 할당)\nsplit = int(0.8 * len(X))\nX_train, X_test = X[:split], X[split:]\ny_train, y_test = y[:split], y[split:]\n\n# 모델 훈련\n\nmodel = Sequential()\nmodel.add(Conv1D(filters=256, kernel_size=2, activation='relu',padding = 'same',input_shape=(X_train.shape[1],1)))\nmodel.add(MaxPooling1D(pool_size=2))\nmodel.add(LSTM(100, return_sequences = True))\nmodel.add(Dropout(0.3))\nmodel.add(LSTM(100, return_sequences = False))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(units=1, activation = 'sigmoid'))\nmodel.compile(optimizer='adam', loss= 'mse' , metrics = [tf.keras.metrics.RootMeanSquaredError(name='rmse')])\n\n# 조기 종료 설정\nearly_stopping = callbacks.EarlyStopping(\n    monitor='val_loss',\n    patience=10,\n    restore_best_weights=True,\n)\n# 최적의 모델 저장할 체크포인트 설정\ncheckpoint = ModelCheckpoint(\n    'best_model.h5', \n    monitor='val_loss', \n    save_best_only=True, \n    save_weights_only=False\n)\n\n# 300 에폭 학습\nhistory = model.fit(X_train, y_train, epochs = 300 , validation_data = (X_test,y_test), batch_size=32, callbacks=[early_stopping, checkpoint], verbose=2)\n\n# 훈련 이력 그래프\nplt.figure(figsize=(10, 5))\nplt.plot(history.history['loss'], label='Train Loss')\nplt.plot(history.history['val_loss'], label='Validation Loss')\nplt.plot(history.history['rmse'], label='Train RMSE')\nplt.plot(history.history['val_rmse'], label='Validation RMSE')\nplt.title('Model Training History')\nplt.xlabel('Epochs')\nplt.ylabel('Loss/RMSE')\nplt.legend()\nplt.savefig('ETHUSDT.png')  # 그래프 이미지 파일로 저장\n\n# 모델을 ONNX로 변환\nonnx_model, _ = tf2onnx.convert.from_keras(model, opset=13, output_path=\"model_ethusdt.onnx\")\nprint(\"ONNX 모델을 'model_ethusdt.onnx'로 저장했습니다.\")\n\n# 모델 평가\ntrain_loss, train_rmse = model.evaluate(X_train, y_train, verbose=0)\ntest_loss, test_rmse = model.evaluate(X_test, y_test, verbose=0)\nprint(f\"train_loss={train_loss:.3f}, train_rmse={train_rmse:.3f}\")\nprint(f\"test_loss={test_loss:.3f}, test_rmse={test_rmse:.3f}\")\r\n```\n\n<div class=\"content-ad\"></div>\n\n- 백테스팅\n\n```js\nimport ccxt\nimport pandas as pd\nimport numpy as np\nimport onnx\nimport onnxruntime as ort\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score, mean_absolute_percentage_error\nfrom sklearn.model_selection import TimeSeriesSplit\n\n# 바이낸스 거래소 인스턴스 생성\nbinance = ccxt.binance()\n\n# 시장 심볼 및 시간 간격 정의\nsymbol = 'ETH/USDT'\ntimeframe = '1d'\nlimit = 1000  # 120일 신뢰 구간 보장을 위한 충분한 데이터 다운로드\n\n# 역사적 데이터 다운로드\nohlcv = binance.fetch_ohlcv(symbol, timeframe, limit=limit)\n\n# 데이터를 판다스 DataFrame으로 변환\ndf = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\ndf['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')\n\n# 데이터를 CSV 파일로 저장\ndf.to_csv('binance_data.csv', index=False)\nprint(\"'binance_data.csv'에 다운로드 및 저장된 데이터\")\n\n# 다운로드한 데이터 로드\ndata = pd.read_csv('binance_data.csv')\n\n# 'timestamp' 열을 datetime 형식으로 변환\ndata['timestamp'] = pd.to_datetime(data['timestamp'])\n\n# 정규화 값(정규화에 사용한 값에 맞게 조정)\nmin_close = data['close'].min()\nmax_close = data['close'].max()\n\n# 종가 데이터 정규화\ndata['close_normalized'] = (data['close'] - min_close) / (max_close - min_close)\n\n# ONNX 모델 로드\nmodel = onnx.load('model_ethusdt.onnx')\nonnx.checker.check_model(model)\n\n# 런타임 세션 생성\nort_session = ort.InferenceSession('model_ethusdt.onnx')\n\n# 모델에 주입할 데이터를 슬라이딩 윈도우로 준비\ninput_name = ort_session.get_inputs()[0].name\nsequence_length = 120  # 모델에 따라 조정\n\n# 예측값을 저장할 리스트 생성\npredictions_list = []\n\n# 예측 시작 날짜 설정\nstart_date = pd.Timestamp('2024-01-01')\nend_date = pd.Timestamp.today()\n\n# 날짜별 추론 실행\ncurrent_date = start_date\nwhile current_date <= end_date:\n    # 현재 날짜 이전 120일 데이터 선택\n    end_idx = data[data['timestamp'] <= current_date].index[-1]\n    start_idx = end_idx - sequence_length + 1\n\n    if start_idx < 0:\n        print(f\"{current_date} 날짜에 대한 데이터 부족\")\n        break\n\n    # 정규화된 데이터 윈도우 추출\n    window = data['close_normalized'].values[start_idx:end_idx+1]\n\n    if len(window) < sequence_length:\n        print(f\"{current_date} 날짜에 대한 데이터 부족\")\n        break\n\n    # 모델에 입력할 데이터 준비\n    input_window = np.array(window).astype(np.float32)\n    input_window = np.expand_dims(input_window, axis=0)  # 배치 크기 차원 추가\n    input_window = np.expand_dims(input_window, axis=2)  # 특성 차원 추가\n\n    # 추론 실행\n    output = ort_session.run(None, {input_name: input_window})\n    prediction = output[0][0][0]\n\n    # 예측값 역정규화\n    prediction = prediction * (max_close - min_close) + min_close\n\n    # 예측값 저장\n    predictions_list.append({'date': current_date, 'prediction': prediction})\n\n    # 날짜 증가\n    current_date += pd.Timedelta(days=1)\n\n# 예측값 리스트를 DataFrame으로 변환\npredictions_df = pd.DataFrame(predictions_list)\n\n# 예측값을 CSV 파일로 저장\npredictions_df.to_csv('predicted_data.csv', index=False)\nprint(\"'predicted_data.csv'에 저장된 예측값\")\n\n# 예측값과 실제 값 비교\ncomparison_df = pd.merge(predictions_df, data[['timestamp', 'close']], left_on='date', right_on='timestamp')\ncomparison_df = comparison_df.drop(columns=['timestamp'])\ncomparison_df = comparison_df.rename(columns={'close': 'actual'})\n\n# 오차 메트릭 계산\nmae = mean_absolute_error(comparison_df['actual'], comparison_df['prediction'])\nrmse = np.sqrt(mean_squared_error(comparison_df['actual'], comparison_df['prediction']))\nr2 = r2_score(comparison_df['actual'], comparison_df['prediction'])\nmape = mean_absolute_percentage_error(comparison_df['actual'], comparison_df['prediction'])\nprint(f'평균 절대 오차(MAE): {mae}')\nprint(f'제곱근 평균 제곱 오차(RMSE): {rmse}')\nprint(f'R^2 점수 (R2): {r2}')\nprint(f'평균 절대 백분율 오차(MAPE): {mape}')\n\n# 오차 밴드가 있는 그래프 그리기\nplt.figure(figsize=(14, 7))\nplt.plot(comparison_df['date'], comparison_df['actual'], label='실제 가격', color='blue')\nplt.plot(comparison_df['date'], comparison_df['prediction'], label='예측 가격', color='red')\nplt.fill_between(comparison_df['date'], comparison_df['prediction'] - mae, comparison_df['prediction'] + mae, color='gray', alpha=0.2, label='오차 밴드 (MAE)')\nplt.xlabel('날짜')\nplt.ylabel('가격')\nplt.title(f'{symbol} 가격 예측 대 비교')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_price_prediction.png\")\nplt.show()\nprint(f\"'{symbol.replace('/', '_')}_price_prediction.png'로 그래프 저장됨\")\n\n# 잔차 분석\nresiduals = comparison_df['actual'] - comparison_df['prediction']\nplt.figure(figsize=(14, 7))\nplt.plot(comparison_df['date'], residuals, label='잔차', color='purple')\nplt.axhline(0, color='black', linestyle='--', linewidth=0.8)\nplt.xlabel('날짜')\nplt.ylabel('잔차')\nplt.title(f'{symbol} 예측 잔차')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_residuals.png\")\nplt.show()\nprint(f\"'{symbol.replace('/', '_')}_residuals.png'로 잔차 그래프 저장됨\")\n\n# 상관관계 분석\ncorrelation = comparison_df['actual'].corr(comparison_df['prediction'])\nprint(f'실제 및 예측 가격 간 상관관계: {correlation}')\n\n# 예측 기반 투자 전략 시뮬레이션 (원본 전략)\ninvestment_df = comparison_df.copy()\ninvestment_df['strategy_returns'] = (investment_df['prediction'].shift(-1) - investment_df['actual']) / investment_df['actual']\ninvestment_df['buy_and_hold_returns'] = (investment_df['actual'].shift(-1) - investment_df['actual']) / investment_df['actual']\n\nstrategy_cumulative_returns = (investment_df['strategy_returns'] + 1).cumprod() - 1\nbuy_and_hold_cumulative_returns = (investment_df['buy_and_hold_returns'] + 1).cumprod() - 1\n\nplt.figure(figsize=(14, 7))\nplt.plot(investment_df['date'], strategy_cumulative_returns, label='전략 누적 수익', color='green')\nplt.plot(investment_df['date'], buy_and_hold_cumulative_returns, label='매수 및 보유 누적 수익', color='orange')\nplt.xlabel('날짜')\nplt.ylabel('누적 수익률')\nplt.title(f'{symbol} 투자 전략 대 매수 및 보유')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_investment_strategy.png\")\nplt.show()\nprint(f\"'{symbol.replace('/', '_')}_investment_strategy.png'로 투자 전략 그래프 저장됨\")\n\n# 손실 전망\ninvestment_df['drawdown'] = strategy_cumulative_returns.cummax() - strategy_cumulative_returns\ninvestment_df['max_drawdown'] = investment_df['drawdown'].max()\n\nplt.figure(figsize=(14, 7))\nplt.plot(investment_df['date'], investment_df['drawdown'], label='Drawdown', color='red')\nplt.xlabel('날짜')\nplt.ylabel('Drawdown')\nplt.title(f'{symbol} 전략 Drawdown')\nplt","ogImage":{"url":"/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_0.png"},"coverImage":"/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_0.png","tag":["Tech"],"readingTime":12},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>암호화폐 시장의 급격한 변동 속에서 백테스팅은 투자 전략을 검증하는 데 중요한 역할을 합니다. 본 연구는 비트코인, 이더리움, 바이낸스 코인, 솔라나 및 엑스알피와 같은 주요 암호화폐를 간단한 딥 러닝 모델을 활용해 평가하는 데 초점을 맞췄습니다. 놀랍게도, 이 방법은 다음과 같이 매우 뛰어난 성과 지표를 제시합니다:</p>\n<ul>\n<li>샤프 비율: 19.898, 비법적인 위험 조정 수익을 나타냅니다.</li>\n<li>소티노 비율: 114.442, 무시할 만한 하락 위험을 나타냅니다.</li>\n<li>베타: -0.131, 역시장 상관 관계를 보여줍니다.</li>\n<li>알파: 0.021, 주목할 만한 추세를 강조합니다.</li>\n</ul>\n<p>이 간단하고 효과적인 딥 러닝 모델에 의해 높은 성과를 이룬 이러한 결과는 전략적인 투자에 대한 깊은 통찰을 제공합니다.</p>\n<p>따라서, 우리는 바이낸스의 다섯 가지 암호화폐 쌍에 대해 (새 전략으로 불리는) 간단한 전략을 사용하여 백테스팅을 진행했습니다. 결과는 다음과 같습니다:</p>\n<div class=\"content-ad\"></div>\n<p>BTCUSDT</p>\n<p><img src=\"/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_0.png\" alt=\"image1\"></p>\n<p><img src=\"/assets/img/2024-06-20-Back-testingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategy_1.png\" alt=\"image2\"></p>\n<p>ETHUSDT</p>\n<div class=\"content-ad\"></div>\n<p>BNBUSDT</p>\n<p>SOLUSDT</p>\n<p>XRPUSDT</p>\n<h1>ETH/USDT 백테스팅 성능 지표 분석</h1>\n<div class=\"content-ad\"></div>\n<p>간단한 딥 러닝 전략을 사용하여 ETH/USDT의 백 테스팅 결과는 다음과 같은 성능 지표를 보여줍니다:</p>\n<ul>\n<li>평균 절대 오차 (MAE): 19.994, 예측 오차의 평균 크기를 나타냅니다.</li>\n<li>제곱근 평균 제곱 오차 (RMSE): 25.152, 예측 값과 실제 값 사이의 평균 제곱 차이의 제곱근을 나타냅니다.</li>\n<li>R-제곱 (R²): 0.997, 예측 값과 실제 가격 사이에 매우 높은 상관 관계를 보여줍니다. 이는 모델이 변동성 거의 모두를 설명한다는 것을 의미합니다.</li>\n<li>평균 절대 백분율 오차 (MAPE): 0.0007, 예측 값과 실제 값 사이의 평균 퍼센트 오차를 나타냅니다.</li>\n<li>샤프 비율 (신 전략): 15.967, 새 전략의 우수한 리스크 조정 수익을 보여줍니다.</li>\n<li>소티노 비율 (신 전략): 116.496, 최소한의 하향 리스크를 강조합니다.</li>\n<li>베타 (신 전략): 0.048, 시장과의 낮은 양의 상관 관계를 보여줍니다.</li>\n<li>알파 (신 전략): 0.022, 전략이 시장 기준에 비해 우수한 성과를 보여주는 것을 나타냅니다.</li>\n<li>교차 검증 MAE: 661.709 ± 499.095, 모델의 예측 오차를 데이터의 다양한 하위 집합에 걸쳐 추정합니다.</li>\n</ul>\n<p>이러한 지표들은 이 백 테스트에서 적용된 딥 러닝 전략의 높은 성능과 견고성을 강조합니다.</p>\n<p>이것은 단지 예시일 뿐이며, 충분한 데이터가 있다면 바이낸스나 다른 거래소의 모든 심볼에서도 좋은 결과를 얻을 수 있을 것이라고 생각합니다.</p>\n<div class=\"content-ad\"></div>\n<p>리플레이 결과</p>\n<p>이 결과를 다시 확인하거나 새로 시도하려면 다음 코드를 사용할 수 있습니다:</p>\n<ul>\n<li>모델 만들기</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> ccxt\n<span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n<span class=\"hljs-keyword\">from</span> datetime <span class=\"hljs-keyword\">import</span> datetime, timedelta\n<span class=\"hljs-keyword\">from</span> sklearn.<span class=\"hljs-property\">preprocessing</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">MinMaxScaler</span>\n<span class=\"hljs-keyword\">import</span> tensorflow <span class=\"hljs-keyword\">as</span> tf\n<span class=\"hljs-keyword\">from</span> tensorflow.<span class=\"hljs-property\">keras</span>.<span class=\"hljs-property\">models</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Sequential</span>\n<span class=\"hljs-keyword\">from</span> tensorflow.<span class=\"hljs-property\">keras</span>.<span class=\"hljs-property\">layers</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Dense</span>, <span class=\"hljs-variable constant_\">LSTM</span>, <span class=\"hljs-title class_\">Conv1D</span>, <span class=\"hljs-title class_\">MaxPooling1D</span>, <span class=\"hljs-title class_\">Dropout</span>, <span class=\"hljs-title class_\">Flatten</span>\n<span class=\"hljs-keyword\">import</span> tf2onnx\n<span class=\"hljs-keyword\">import</span> matplotlib.<span class=\"hljs-property\">pyplot</span> <span class=\"hljs-keyword\">as</span> plt\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">from</span> tensorflow.<span class=\"hljs-property\">keras</span> <span class=\"hljs-keyword\">import</span> callbacks\n<span class=\"hljs-keyword\">from</span> tensorflow.<span class=\"hljs-property\">keras</span>.<span class=\"hljs-property\">callbacks</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ModelCheckpoint</span>\n\n# 바이낸스에서 데이터 다운로드하는 함수\ndef <span class=\"hljs-title function_\">descargar_datos</span>(symbol, timeframe=<span class=\"hljs-string\">'1d'</span>, start_date=<span class=\"hljs-string\">'2004-01-01T00:00:00Z'</span>, end_date=<span class=\"hljs-string\">'2024-01-01T00:00:00Z'</span>):\n    exchange = ccxt.<span class=\"hljs-title function_\">binance</span>({<span class=\"hljs-string\">'enableRateLimit'</span>: <span class=\"hljs-title class_\">False</span>})\n    since = exchange.<span class=\"hljs-title function_\">parse8601</span>(start_date)\n    end_date_timestamp = pd.<span class=\"hljs-title function_\">to_datetime</span>(end_date, utc=<span class=\"hljs-title class_\">True</span>)\n    all_data = []\n\n    <span class=\"hljs-keyword\">while</span> since &#x3C; end_date_timestamp.<span class=\"hljs-title function_\">timestamp</span>() * <span class=\"hljs-number\">1000</span>:\n        ohlc = exchange.<span class=\"hljs-title function_\">fetch_ohlcv</span>(symbol, timeframe=timeframe, since=since)\n        all_data.<span class=\"hljs-title function_\">extend</span>(ohlc)\n        since = ohlc[-<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>] + <span class=\"hljs-number\">1</span>  # <span class=\"hljs-string\">'since'</span> 매개변수 <span class=\"hljs-number\">1</span>밀리초 증가\n\n    df = pd.<span class=\"hljs-title class_\">DataFrame</span>(all_data, columns=[<span class=\"hljs-string\">'timestamp'</span>, <span class=\"hljs-string\">'open'</span>, <span class=\"hljs-string\">'high'</span>, <span class=\"hljs-string\">'low'</span>, <span class=\"hljs-string\">'close'</span>, <span class=\"hljs-string\">'volume'</span>])\n    df[<span class=\"hljs-string\">'timestamp'</span>] = pd.<span class=\"hljs-title function_\">to_datetime</span>(df[<span class=\"hljs-string\">'timestamp'</span>], unit=<span class=\"hljs-string\">'ms'</span>)\n    df.<span class=\"hljs-title function_\">set_index</span>(<span class=\"hljs-string\">'timestamp'</span>, inplace=<span class=\"hljs-title class_\">True</span>)\n\n    # 두 데이터 모두 타임존이 설정되어 있는지 확인하거나 필요한 경우 변환\n    <span class=\"hljs-keyword\">if</span> df.<span class=\"hljs-property\">index</span>.<span class=\"hljs-property\">tz</span> is <span class=\"hljs-title class_\">None</span>:\n        df.<span class=\"hljs-property\">index</span> = df.<span class=\"hljs-property\">index</span>.<span class=\"hljs-title function_\">tz_localize</span>(<span class=\"hljs-string\">'utc'</span>)\n    \n    df = df[df.<span class=\"hljs-property\">index</span> &#x3C;= end_date_timestamp]\n    <span class=\"hljs-title function_\">print</span>(df)\n    <span class=\"hljs-keyword\">return</span> df[<span class=\"hljs-string\">'close'</span>].<span class=\"hljs-property\">values</span>\n\n# 데이터 불러오기\ndata = <span class=\"hljs-title function_\">descargar_datos</span>(<span class=\"hljs-string\">'ETH/USDT'</span>)\n\n# 데이터 정규화\nscaler = <span class=\"hljs-title class_\">MinMaxScaler</span>(feature_range=(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>))\ndata = scaler.<span class=\"hljs-title function_\">fit_transform</span>(data.<span class=\"hljs-title function_\">reshape</span>(-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>))\n\n# 시퀀스에서 샘플 생성하는 함수\ndef <span class=\"hljs-title function_\">crear_muestras</span>(dataset, pasos_de_tiempo=<span class=\"hljs-number\">120</span>):\n    X, y = [], []\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(pasos_de_tiempo, <span class=\"hljs-title function_\">len</span>(dataset)):\n        X.<span class=\"hljs-title function_\">append</span>(dataset[i-<span class=\"hljs-attr\">pasos_de_tiempo</span>:i, <span class=\"hljs-number\">0</span>])\n        y.<span class=\"hljs-title function_\">append</span>(dataset[i, <span class=\"hljs-number\">0</span>])\n    <span class=\"hljs-keyword\">return</span> np.<span class=\"hljs-title function_\">array</span>(X), np.<span class=\"hljs-title function_\">array</span>(y)\n\n# 훈련 및 테스트 데이터 준비\npasos_de_tiempo = <span class=\"hljs-number\">120</span>\nX, y = <span class=\"hljs-title function_\">crear_muestras</span>(data, pasos_de_tiempo)\nX = X.<span class=\"hljs-title function_\">reshape</span>(X.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">0</span>], X.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">1</span>], <span class=\"hljs-number\">1</span>)  # <span class=\"hljs-variable constant_\">LSTM</span>용 변경\n\n# 데이터 분할 (훈련에 <span class=\"hljs-number\">80</span>% 할당)\nsplit = <span class=\"hljs-title function_\">int</span>(<span class=\"hljs-number\">0.8</span> * <span class=\"hljs-title function_\">len</span>(X))\nX_train, X_test = X[:split], X[<span class=\"hljs-attr\">split</span>:]\ny_train, y_test = y[:split], y[<span class=\"hljs-attr\">split</span>:]\n\n# 모델 훈련\n\nmodel = <span class=\"hljs-title class_\">Sequential</span>()\nmodel.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title class_\">Conv1D</span>(filters=<span class=\"hljs-number\">256</span>, kernel_size=<span class=\"hljs-number\">2</span>, activation=<span class=\"hljs-string\">'relu'</span>,padding = <span class=\"hljs-string\">'same'</span>,input_shape=(X_train.<span class=\"hljs-property\">shape</span>[<span class=\"hljs-number\">1</span>],<span class=\"hljs-number\">1</span>)))\nmodel.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title class_\">MaxPooling1D</span>(pool_size=<span class=\"hljs-number\">2</span>))\nmodel.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title function_\">LSTM</span>(<span class=\"hljs-number\">100</span>, return_sequences = <span class=\"hljs-title class_\">True</span>))\nmodel.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title class_\">Dropout</span>(<span class=\"hljs-number\">0.3</span>))\nmodel.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title function_\">LSTM</span>(<span class=\"hljs-number\">100</span>, return_sequences = <span class=\"hljs-title class_\">False</span>))\nmodel.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title class_\">Dropout</span>(<span class=\"hljs-number\">0.3</span>))\nmodel.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-title class_\">Dense</span>(units=<span class=\"hljs-number\">1</span>, activation = <span class=\"hljs-string\">'sigmoid'</span>))\nmodel.<span class=\"hljs-title function_\">compile</span>(optimizer=<span class=\"hljs-string\">'adam'</span>, loss= <span class=\"hljs-string\">'mse'</span> , metrics = [tf.<span class=\"hljs-property\">keras</span>.<span class=\"hljs-property\">metrics</span>.<span class=\"hljs-title class_\">RootMeanSquaredError</span>(name=<span class=\"hljs-string\">'rmse'</span>)])\n\n# 조기 종료 설정\nearly_stopping = callbacks.<span class=\"hljs-title class_\">EarlyStopping</span>(\n    monitor=<span class=\"hljs-string\">'val_loss'</span>,\n    patience=<span class=\"hljs-number\">10</span>,\n    restore_best_weights=<span class=\"hljs-title class_\">True</span>,\n)\n# 최적의 모델 저장할 체크포인트 설정\ncheckpoint = <span class=\"hljs-title class_\">ModelCheckpoint</span>(\n    <span class=\"hljs-string\">'best_model.h5'</span>, \n    monitor=<span class=\"hljs-string\">'val_loss'</span>, \n    save_best_only=<span class=\"hljs-title class_\">True</span>, \n    save_weights_only=<span class=\"hljs-title class_\">False</span>\n)\n\n# <span class=\"hljs-number\">300</span> 에폭 학습\nhistory = model.<span class=\"hljs-title function_\">fit</span>(X_train, y_train, epochs = <span class=\"hljs-number\">300</span> , validation_data = (X_test,y_test), batch_size=<span class=\"hljs-number\">32</span>, callbacks=[early_stopping, checkpoint], verbose=<span class=\"hljs-number\">2</span>)\n\n# 훈련 이력 그래프\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">5</span>))\nplt.<span class=\"hljs-title function_\">plot</span>(history.<span class=\"hljs-property\">history</span>[<span class=\"hljs-string\">'loss'</span>], label=<span class=\"hljs-string\">'Train Loss'</span>)\nplt.<span class=\"hljs-title function_\">plot</span>(history.<span class=\"hljs-property\">history</span>[<span class=\"hljs-string\">'val_loss'</span>], label=<span class=\"hljs-string\">'Validation Loss'</span>)\nplt.<span class=\"hljs-title function_\">plot</span>(history.<span class=\"hljs-property\">history</span>[<span class=\"hljs-string\">'rmse'</span>], label=<span class=\"hljs-string\">'Train RMSE'</span>)\nplt.<span class=\"hljs-title function_\">plot</span>(history.<span class=\"hljs-property\">history</span>[<span class=\"hljs-string\">'val_rmse'</span>], label=<span class=\"hljs-string\">'Validation RMSE'</span>)\nplt.<span class=\"hljs-title function_\">title</span>(<span class=\"hljs-string\">'Model Training History'</span>)\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'Epochs'</span>)\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'Loss/RMSE'</span>)\nplt.<span class=\"hljs-title function_\">legend</span>()\nplt.<span class=\"hljs-title function_\">savefig</span>(<span class=\"hljs-string\">'ETHUSDT.png'</span>)  # 그래프 이미지 파일로 저장\n\n# 모델을 <span class=\"hljs-variable constant_\">ONNX</span>로 변환\nonnx_model, _ = tf2onnx.<span class=\"hljs-property\">convert</span>.<span class=\"hljs-title function_\">from_keras</span>(model, opset=<span class=\"hljs-number\">13</span>, output_path=<span class=\"hljs-string\">\"model_ethusdt.onnx\"</span>)\n<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"ONNX 모델을 'model_ethusdt.onnx'로 저장했습니다.\"</span>)\n\n# 모델 평가\ntrain_loss, train_rmse = model.evaluate(X_train, y_train, verbose=<span class=\"hljs-number\">0</span>)\ntest_loss, test_rmse = model.evaluate(X_test, y_test, verbose=<span class=\"hljs-number\">0</span>)\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"train_loss={train_loss:.3f}, train_rmse={train_rmse:.3f}\"</span>)\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"test_loss={test_loss:.3f}, test_rmse={test_rmse:.3f}\"</span>)\n</code></pre>\n<div class=\"content-ad\"></div>\n<ul>\n<li>백테스팅</li>\n</ul>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> ccxt\n<span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> onnx\n<span class=\"hljs-keyword\">import</span> onnxruntime <span class=\"hljs-keyword\">as</span> ort\n<span class=\"hljs-keyword\">import</span> matplotlib.<span class=\"hljs-property\">pyplot</span> <span class=\"hljs-keyword\">as</span> plt\n<span class=\"hljs-keyword\">from</span> sklearn.<span class=\"hljs-property\">metrics</span> <span class=\"hljs-keyword\">import</span> mean_absolute_error, mean_squared_error, r2_score, mean_absolute_percentage_error\n<span class=\"hljs-keyword\">from</span> sklearn.<span class=\"hljs-property\">model_selection</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">TimeSeriesSplit</span>\n\n# 바이낸스 거래소 인스턴스 생성\nbinance = ccxt.<span class=\"hljs-title function_\">binance</span>()\n\n# 시장 심볼 및 시간 간격 정의\nsymbol = <span class=\"hljs-string\">'ETH/USDT'</span>\ntimeframe = <span class=\"hljs-string\">'1d'</span>\nlimit = <span class=\"hljs-number\">1000</span>  # <span class=\"hljs-number\">120</span>일 신뢰 구간 보장을 위한 충분한 데이터 다운로드\n\n# 역사적 데이터 다운로드\nohlcv = binance.<span class=\"hljs-title function_\">fetch_ohlcv</span>(symbol, timeframe, limit=limit)\n\n# 데이터를 판다스 <span class=\"hljs-title class_\">DataFrame</span>으로 변환\ndf = pd.<span class=\"hljs-title class_\">DataFrame</span>(ohlcv, columns=[<span class=\"hljs-string\">'timestamp'</span>, <span class=\"hljs-string\">'open'</span>, <span class=\"hljs-string\">'high'</span>, <span class=\"hljs-string\">'low'</span>, <span class=\"hljs-string\">'close'</span>, <span class=\"hljs-string\">'volume'</span>])\ndf[<span class=\"hljs-string\">'timestamp'</span>] = pd.<span class=\"hljs-title function_\">to_datetime</span>(df[<span class=\"hljs-string\">'timestamp'</span>], unit=<span class=\"hljs-string\">'ms'</span>)\n\n# 데이터를 <span class=\"hljs-variable constant_\">CSV</span> 파일로 저장\ndf.<span class=\"hljs-title function_\">to_csv</span>(<span class=\"hljs-string\">'binance_data.csv'</span>, index=<span class=\"hljs-title class_\">False</span>)\n<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"'binance_data.csv'에 다운로드 및 저장된 데이터\"</span>)\n\n# 다운로드한 데이터 로드\ndata = pd.<span class=\"hljs-title function_\">read_csv</span>(<span class=\"hljs-string\">'binance_data.csv'</span>)\n\n# <span class=\"hljs-string\">'timestamp'</span> 열을 datetime 형식으로 변환\ndata[<span class=\"hljs-string\">'timestamp'</span>] = pd.<span class=\"hljs-title function_\">to_datetime</span>(data[<span class=\"hljs-string\">'timestamp'</span>])\n\n# 정규화 값(정규화에 사용한 값에 맞게 조정)\nmin_close = data[<span class=\"hljs-string\">'close'</span>].<span class=\"hljs-title function_\">min</span>()\nmax_close = data[<span class=\"hljs-string\">'close'</span>].<span class=\"hljs-title function_\">max</span>()\n\n# 종가 데이터 정규화\ndata[<span class=\"hljs-string\">'close_normalized'</span>] = (data[<span class=\"hljs-string\">'close'</span>] - min_close) / (max_close - min_close)\n\n# <span class=\"hljs-variable constant_\">ONNX</span> 모델 로드\nmodel = onnx.<span class=\"hljs-title function_\">load</span>(<span class=\"hljs-string\">'model_ethusdt.onnx'</span>)\nonnx.<span class=\"hljs-property\">checker</span>.<span class=\"hljs-title function_\">check_model</span>(model)\n\n# 런타임 세션 생성\nort_session = ort.<span class=\"hljs-title class_\">InferenceSession</span>(<span class=\"hljs-string\">'model_ethusdt.onnx'</span>)\n\n# 모델에 주입할 데이터를 슬라이딩 윈도우로 준비\ninput_name = ort_session.<span class=\"hljs-title function_\">get_inputs</span>()[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">name</span>\nsequence_length = <span class=\"hljs-number\">120</span>  # 모델에 따라 조정\n\n# 예측값을 저장할 리스트 생성\npredictions_list = []\n\n# 예측 시작 날짜 설정\nstart_date = pd.<span class=\"hljs-title class_\">Timestamp</span>(<span class=\"hljs-string\">'2024-01-01'</span>)\nend_date = pd.<span class=\"hljs-property\">Timestamp</span>.<span class=\"hljs-title function_\">today</span>()\n\n# 날짜별 추론 실행\ncurrent_date = start_date\n<span class=\"hljs-keyword\">while</span> current_date &#x3C;= <span class=\"hljs-attr\">end_date</span>:\n    # 현재 날짜 이전 <span class=\"hljs-number\">120</span>일 데이터 선택\n    end_idx = data[data[<span class=\"hljs-string\">'timestamp'</span>] &#x3C;= current_date].<span class=\"hljs-property\">index</span>[-<span class=\"hljs-number\">1</span>]\n    start_idx = end_idx - sequence_length + <span class=\"hljs-number\">1</span>\n\n    <span class=\"hljs-keyword\">if</span> start_idx &#x3C; <span class=\"hljs-number\">0</span>:\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"{current_date} 날짜에 대한 데이터 부족\"</span>)\n        <span class=\"hljs-keyword\">break</span>\n\n    # 정규화된 데이터 윈도우 추출\n    <span class=\"hljs-variable language_\">window</span> = data[<span class=\"hljs-string\">'close_normalized'</span>].<span class=\"hljs-property\">values</span>[<span class=\"hljs-attr\">start_idx</span>:end_idx+<span class=\"hljs-number\">1</span>]\n\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-title function_\">len</span>(<span class=\"hljs-variable language_\">window</span>) &#x3C; <span class=\"hljs-attr\">sequence_length</span>:\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"{current_date} 날짜에 대한 데이터 부족\"</span>)\n        <span class=\"hljs-keyword\">break</span>\n\n    # 모델에 입력할 데이터 준비\n    input_window = np.<span class=\"hljs-title function_\">array</span>(<span class=\"hljs-variable language_\">window</span>).<span class=\"hljs-title function_\">astype</span>(np.<span class=\"hljs-property\">float32</span>)\n    input_window = np.<span class=\"hljs-title function_\">expand_dims</span>(input_window, axis=<span class=\"hljs-number\">0</span>)  # 배치 크기 차원 추가\n    input_window = np.<span class=\"hljs-title function_\">expand_dims</span>(input_window, axis=<span class=\"hljs-number\">2</span>)  # 특성 차원 추가\n\n    # 추론 실행\n    output = ort_session.<span class=\"hljs-title function_\">run</span>(<span class=\"hljs-title class_\">None</span>, {<span class=\"hljs-attr\">input_name</span>: input_window})\n    prediction = output[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]\n\n    # 예측값 역정규화\n    prediction = prediction * (max_close - min_close) + min_close\n\n    # 예측값 저장\n    predictions_list.<span class=\"hljs-title function_\">append</span>({<span class=\"hljs-string\">'date'</span>: current_date, <span class=\"hljs-string\">'prediction'</span>: prediction})\n\n    # 날짜 증가\n    current_date += pd.<span class=\"hljs-title class_\">Timedelta</span>(days=<span class=\"hljs-number\">1</span>)\n\n# 예측값 리스트를 <span class=\"hljs-title class_\">DataFrame</span>으로 변환\npredictions_df = pd.<span class=\"hljs-title class_\">DataFrame</span>(predictions_list)\n\n# 예측값을 <span class=\"hljs-variable constant_\">CSV</span> 파일로 저장\npredictions_df.<span class=\"hljs-title function_\">to_csv</span>(<span class=\"hljs-string\">'predicted_data.csv'</span>, index=<span class=\"hljs-title class_\">False</span>)\n<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"'predicted_data.csv'에 저장된 예측값\"</span>)\n\n# 예측값과 실제 값 비교\ncomparison_df = pd.<span class=\"hljs-title function_\">merge</span>(predictions_df, data[[<span class=\"hljs-string\">'timestamp'</span>, <span class=\"hljs-string\">'close'</span>]], left_on=<span class=\"hljs-string\">'date'</span>, right_on=<span class=\"hljs-string\">'timestamp'</span>)\ncomparison_df = comparison_df.<span class=\"hljs-title function_\">drop</span>(columns=[<span class=\"hljs-string\">'timestamp'</span>])\ncomparison_df = comparison_df.<span class=\"hljs-title function_\">rename</span>(columns={<span class=\"hljs-string\">'close'</span>: <span class=\"hljs-string\">'actual'</span>})\n\n# 오차 메트릭 계산\nmae = <span class=\"hljs-title function_\">mean_absolute_error</span>(comparison_df[<span class=\"hljs-string\">'actual'</span>], comparison_df[<span class=\"hljs-string\">'prediction'</span>])\nrmse = np.<span class=\"hljs-title function_\">sqrt</span>(<span class=\"hljs-title function_\">mean_squared_error</span>(comparison_df[<span class=\"hljs-string\">'actual'</span>], comparison_df[<span class=\"hljs-string\">'prediction'</span>]))\nr2 = <span class=\"hljs-title function_\">r2_score</span>(comparison_df[<span class=\"hljs-string\">'actual'</span>], comparison_df[<span class=\"hljs-string\">'prediction'</span>])\nmape = <span class=\"hljs-title function_\">mean_absolute_percentage_error</span>(comparison_df[<span class=\"hljs-string\">'actual'</span>], comparison_df[<span class=\"hljs-string\">'prediction'</span>])\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">'평균 절대 오차(MAE): {mae}'</span>)\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">'제곱근 평균 제곱 오차(RMSE): {rmse}'</span>)\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">'R^2 점수 (R2): {r2}'</span>)\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">'평균 절대 백분율 오차(MAPE): {mape}'</span>)\n\n# 오차 밴드가 있는 그래프 그리기\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">7</span>))\nplt.<span class=\"hljs-title function_\">plot</span>(comparison_df[<span class=\"hljs-string\">'date'</span>], comparison_df[<span class=\"hljs-string\">'actual'</span>], label=<span class=\"hljs-string\">'실제 가격'</span>, color=<span class=\"hljs-string\">'blue'</span>)\nplt.<span class=\"hljs-title function_\">plot</span>(comparison_df[<span class=\"hljs-string\">'date'</span>], comparison_df[<span class=\"hljs-string\">'prediction'</span>], label=<span class=\"hljs-string\">'예측 가격'</span>, color=<span class=\"hljs-string\">'red'</span>)\nplt.<span class=\"hljs-title function_\">fill_between</span>(comparison_df[<span class=\"hljs-string\">'date'</span>], comparison_df[<span class=\"hljs-string\">'prediction'</span>] - mae, comparison_df[<span class=\"hljs-string\">'prediction'</span>] + mae, color=<span class=\"hljs-string\">'gray'</span>, alpha=<span class=\"hljs-number\">0.2</span>, label=<span class=\"hljs-string\">'오차 밴드 (MAE)'</span>)\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'날짜'</span>)\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'가격'</span>)\nplt.<span class=\"hljs-title function_\">title</span>(f<span class=\"hljs-string\">'{symbol} 가격 예측 대 비교'</span>)\nplt.<span class=\"hljs-title function_\">legend</span>()\nplt.<span class=\"hljs-title function_\">savefig</span>(f<span class=\"hljs-string\">\"{symbol.replace('/', '_')}_price_prediction.png\"</span>)\nplt.<span class=\"hljs-title function_\">show</span>()\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"'{symbol.replace('/', '_')}_price_prediction.png'로 그래프 저장됨\"</span>)\n\n# 잔차 분석\nresiduals = comparison_df[<span class=\"hljs-string\">'actual'</span>] - comparison_df[<span class=\"hljs-string\">'prediction'</span>]\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">7</span>))\nplt.<span class=\"hljs-title function_\">plot</span>(comparison_df[<span class=\"hljs-string\">'date'</span>], residuals, label=<span class=\"hljs-string\">'잔차'</span>, color=<span class=\"hljs-string\">'purple'</span>)\nplt.<span class=\"hljs-title function_\">axhline</span>(<span class=\"hljs-number\">0</span>, color=<span class=\"hljs-string\">'black'</span>, linestyle=<span class=\"hljs-string\">'--'</span>, linewidth=<span class=\"hljs-number\">0.8</span>)\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'날짜'</span>)\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'잔차'</span>)\nplt.<span class=\"hljs-title function_\">title</span>(f<span class=\"hljs-string\">'{symbol} 예측 잔차'</span>)\nplt.<span class=\"hljs-title function_\">legend</span>()\nplt.<span class=\"hljs-title function_\">savefig</span>(f<span class=\"hljs-string\">\"{symbol.replace('/', '_')}_residuals.png\"</span>)\nplt.<span class=\"hljs-title function_\">show</span>()\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"'{symbol.replace('/', '_')}_residuals.png'로 잔차 그래프 저장됨\"</span>)\n\n# 상관관계 분석\ncorrelation = comparison_df[<span class=\"hljs-string\">'actual'</span>].<span class=\"hljs-title function_\">corr</span>(comparison_df[<span class=\"hljs-string\">'prediction'</span>])\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">'실제 및 예측 가격 간 상관관계: {correlation}'</span>)\n\n# 예측 기반 투자 전략 시뮬레이션 (원본 전략)\ninvestment_df = comparison_df.<span class=\"hljs-title function_\">copy</span>()\ninvestment_df[<span class=\"hljs-string\">'strategy_returns'</span>] = (investment_df[<span class=\"hljs-string\">'prediction'</span>].<span class=\"hljs-title function_\">shift</span>(-<span class=\"hljs-number\">1</span>) - investment_df[<span class=\"hljs-string\">'actual'</span>]) / investment_df[<span class=\"hljs-string\">'actual'</span>]\ninvestment_df[<span class=\"hljs-string\">'buy_and_hold_returns'</span>] = (investment_df[<span class=\"hljs-string\">'actual'</span>].<span class=\"hljs-title function_\">shift</span>(-<span class=\"hljs-number\">1</span>) - investment_df[<span class=\"hljs-string\">'actual'</span>]) / investment_df[<span class=\"hljs-string\">'actual'</span>]\n\nstrategy_cumulative_returns = (investment_df[<span class=\"hljs-string\">'strategy_returns'</span>] + <span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">cumprod</span>() - <span class=\"hljs-number\">1</span>\nbuy_and_hold_cumulative_returns = (investment_df[<span class=\"hljs-string\">'buy_and_hold_returns'</span>] + <span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">cumprod</span>() - <span class=\"hljs-number\">1</span>\n\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">7</span>))\nplt.<span class=\"hljs-title function_\">plot</span>(investment_df[<span class=\"hljs-string\">'date'</span>], strategy_cumulative_returns, label=<span class=\"hljs-string\">'전략 누적 수익'</span>, color=<span class=\"hljs-string\">'green'</span>)\nplt.<span class=\"hljs-title function_\">plot</span>(investment_df[<span class=\"hljs-string\">'date'</span>], buy_and_hold_cumulative_returns, label=<span class=\"hljs-string\">'매수 및 보유 누적 수익'</span>, color=<span class=\"hljs-string\">'orange'</span>)\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'날짜'</span>)\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'누적 수익률'</span>)\nplt.<span class=\"hljs-title function_\">title</span>(f<span class=\"hljs-string\">'{symbol} 투자 전략 대 매수 및 보유'</span>)\nplt.<span class=\"hljs-title function_\">legend</span>()\nplt.<span class=\"hljs-title function_\">savefig</span>(f<span class=\"hljs-string\">\"{symbol.replace('/', '_')}_investment_strategy.png\"</span>)\nplt.<span class=\"hljs-title function_\">show</span>()\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"'{symbol.replace('/', '_')}_investment_strategy.png'로 투자 전략 그래프 저장됨\"</span>)\n\n# 손실 전망\ninvestment_df[<span class=\"hljs-string\">'drawdown'</span>] = strategy_cumulative_returns.<span class=\"hljs-title function_\">cummax</span>() - strategy_cumulative_returns\ninvestment_df[<span class=\"hljs-string\">'max_drawdown'</span>] = investment_df[<span class=\"hljs-string\">'drawdown'</span>].<span class=\"hljs-title function_\">max</span>()\n\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">7</span>))\nplt.<span class=\"hljs-title function_\">plot</span>(investment_df[<span class=\"hljs-string\">'date'</span>], investment_df[<span class=\"hljs-string\">'drawdown'</span>], label=<span class=\"hljs-string\">'Drawdown'</span>, color=<span class=\"hljs-string\">'red'</span>)\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'날짜'</span>)\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'Drawdown'</span>)\nplt.<span class=\"hljs-title function_\">title</span>(f<span class=\"hljs-string\">'{symbol} 전략 Drawdown'</span>)\nplt\n</code></pre>\n</body>\n</html>\n"},"__N_SSG":true}