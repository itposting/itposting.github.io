{"pageProps":{"post":{"title":"DBT  Airflow  ","description":"","date":"2024-06-19 09:45","slug":"2024-06-19-dbtAirflow","content":"\n\n![image](/assets/img/2024-06-19-dbtAirflow_0.png)\n\n요즘의 동적이고 경쟁적인 환경에서 기업은 데이터 기반 의사결정에 크게 의존하고 있습니다. 이를 실현하기 위해 조직은 믿을 수 있는 견고한 데이터 플랫폼과 고품질 데이터가 필요합니다. 이는 데이터를 효과적으로 수집하고 저장하는 시스템뿐만 아니라 데이터의 정확성과 신뢰성을 보장하는 것을 의미합니다.\n\n수백 개 또는 수천 개의 데이터 모델을 관리하는 것은 항상 간단한 과정은 아닙니다. 데이터 팀은 종종 데이터 자산을 효과적으로 구축, 테스트 및 유지하는 데 고민합니다. 플럼에서는 데이터 빌드 도구(dbt)를 활용하여 데이터 모델을 효과적으로 관리할 수 있는 CLI 도구에 의존합니다.\n\n그러나 dbt는 명령줄 인터페이스의 특성 때문에 도전적인 요소를 가지고 있습니다. 그렇다면, 제품 환경에 배포할 때 dbt의 장점을 팀이 어떻게 활용할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\ndbt Cloud가 당연한 선택처럼 보일 수 있지만, 모든 팀 또는 회사가 이 제품에 투자하기에 준비되어 있는 것은 아닙니다. 이러한 상황에서는 dbt 모델의 실행을 조율하고 그 사이의 종속성을 유지하는 대체 방법이 필요합니다.\n\n# 왜 자체 통합을 구축하기로 투자했는가\n\ndbt Cloud에 필요한 투자 외에도, 우리 팀은 특정 기능을 지원받길 원했습니다. 그러나 당시에는 플랫폼에서 이러한 기능 중 일부만 지원되었습니다. 아래에서 가장 기본적인 것들을 개요하겠습니다.\n\n![2024-06-19-dbtAirflow_1.png](/assets/img/2024-06-19-dbtAirflow_1.png)\n\n<div class=\"content-ad\"></div>\n\n- dbt 프로젝트 일정 설정: 우리는 dbt 프로젝트를 cron 작업 스타일로 일정을 잡고, 특정 시간 간격을 지정합니다.\n- 작업 세분화: 각 dbt 엔티티(모델, 테스트, 시드, 스냅샷을 포함)는 개별적으로 처리되어 필요한 경우에 개별적으로 트리거될 수 있도록 합니다.\n- dbt 의존성 유지: 또한, dbt 엔티티 간의 종속성을 유지해야 합니다. 예를 들어, 모델 A가 테스트를 포함하여 다른 모델 B의 상위 의존성으로 작용하는 경우 실행 순서를 유지해야 합니다.\n\n```js\n[dbt run A] -> [dbt test A] -> [dbt run B]\n```\n\n4. 다른 워크플로우 트리거: 특정 dbt 엔티티의 성공적인 완료 후에 특정 워크플로우를 시작해야 하며, 전체 dbt 프로젝트가 완료될 필요가 없는 경우가 있습니다. 또한, 두 dbt 엔티티 실행 사이에 특정 워크플로우를 시작해야할 경우가 있을 수 있습니다.\n\n```js\n[dbt run A] -> [dbt와 무관한 워크플로우 실행] -> [dbt run B]\n```\n\n<div class=\"content-ad\"></div>\n\n5. 알림: 문제가 발생했을 때, 슬랙으로 알림을 받아야 합니다.\n\n6. 컨테이너화된 dbt 프로젝트 실행: 각각의 dbt 프로젝트는 자체 Docker 이미지를 가져야 합니다. 필요시 다른 dbt 버전에서 실행할 수 있는 유연성을 제공합니다.\n\n7. 모델 하위 집합 트리거링: dbt 엔티티는 dbt 태그를 기반으로 필터링될 수 있어서 필요한 특정 모델 그룹을 실행할 수 있습니다.\n\n8. 여러 일정 생성: 동일한 프로젝트를 서로 다른 일정으로 실행해야 할 수도 있습니다. 이는 모델 하위 집합을 트리거할 필요와 밀접하게 관려이 있습니다. 예를 들어, 모델을 시간별, 일별, 주간별로 태그 지정하여 해당 일정에 맞춰 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다양한 대안을 탐색해 본 결과, 천문학자가 개발한 Cosmos 패키지를 포함해 어떤 것도 당시의 우리 사용 사례와 명확한 요구 사항에 적합하다는 것을 입증하지 못했습니다.\n\n이러한 도전에 직면하자, 우리는 우리의 요구에 맞게 제작된 자체 Python 패키지를 개발하기로 전략적인 결정을 내렸습니다. 이 맞춤형 솔루션은 우리에게 dbt와 Airflow를 원활하게 통합할 수 있는 유연성과 기능이 제공되어, 데이터 팀이 효과적으로 데이터 모델을 관리하고 최적화할 수 있게 해줍니다.\n\n# 왜 Airflow를 선택했나요?\n\n데이터 파이프라인 Orchestration 전략을 설계할 때, 우리는 특정 간격(시간별, 일별 또는 주별)으로 작업을 예약하고 관리할 수 있는 능력을 지향했습니다. 팀이 Airflow 및 Google Cloud의 Cloud Composer 서비스에 익숙하고 기존 인프라가 있었기 때문에 Airflow를 선택하는 것이 우리의 요구에 적합한 자연스러운 선택이었습니다.\n\n<div class=\"content-ad\"></div>\n\n또한 Airflow와 dbt는 Directed Acyclic Graphs (DAGs) 개념을 중심으로 하고 있어, dbt DAGs를 Airflow DAGs로 변환하여 Orchestration(오케스트레이션)할 수 있습니다.\n\nDAGs는 노드가 닫힌 순환 루프를 형성하지 않고 방향성을 가지고 연결된 작업 또는 데이터 모델을 나타내는 그래프입니다. dbt에서 DAGs는 데이터 모델 간의 관계와 종속성을 나타내고, Airflow에서는 DAGs는 데이터 파이프라인에 포함된 단계와 종속성을 시각화합니다.\n\n# 0부터 1까지: Cloud Composer에서 dbt 실행하기\n\n이 초기 단계에서 우리의 작업은 상대적으로 간단했습니다: Airflow를 사용하여 dbt 프로젝트를 실행하고 테스트하되, 각 모델, 테스트, 스냅샷 또는 시드를 개별 작업으로 설정할 필요가 없었습니다.\n\n<div class=\"content-ad\"></div>\n\n필요한 것은 GitHub Actions를 사용하여 CI/CD 파이프라인을 설정하는 것이었습니다. 이 파이프라인은 관련된 dbt 프로젝트를 Cloud Composer 버킷으로 복사하고 Airflow 내에서 DAG를 구성합니다. 이 DAG에는 모델을 실행하는 하나의 작업 및 해당 작업을 테스트하는 다른 작업이 포함됩니다.\n\n![2024-06-19-dbtAirflow_2](/assets/img/2024-06-19-dbtAirflow_2.png)\n\n이것은 Airflow에서 dbt 프로젝트를 실행하는 가장 간단한 방법일 수 있습니다. DAG는 BashOperator로 생성된 두 개의 작업으로 구성됩니다. 기본적으로, 이는 로컬에서 dbt run 및 dbt test 명령을 실행하는 dbt CLI를 사용한 프로세스를 반영합니다.\n\n그러나 이 방법에는 여러 가지 제약이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 만약에 dbt_run 작업 내에서 모델 실행이 실패한다면, 문제를 해결하기 위해 작업을 다시 실행해야 합니다. 이는 이전에 성공했던 모델들을 포함하여 모든 모델을 다시 실행해야 하므로 실행 시간과 비용이 증가하는 것을 의미합니다.\n- 모델 실행과 테스트는 완전히 독립적입니다. 모든 테스트는 워크플로우의 끝에 실행됩니다. 따라서 다른 모델들의 상위 종속성인 모델들에서 문제가 발생할 경우 너무 늦기 전까지 알아차리지 못할 수 있습니다.\n- 만약에 dbt_test 작업에서 모델 테스트가 실패한다면, 이 문제를 해결하기 위해 영향을 받는 모든 모델을 수정하기 위해 dbt_run과 dbt_test 작업을 검토하고 재실행해야 합니다.\n- Airflow 작업은 BashOperator를 사용하여 생성되며, Airflow 환경에 dbt 패키지 의존성이 설치되어 있어야 합니다. 이는 패키지 버전 호환성 문제로 인해 문제가 될 수 있으며, 특히 GCP의 Cloud Composer나 AWS의 MWAA와 같은 관리형 Airflow 서비스에서 더욱 그렇습니다.\n\n이 초기 시도는 Proof-of-Concept(PoC)로서의 느낌이 더 큰 노력입니다. 제한사항과 확장성 부족에도 불구하고, 팀의 기대에 부합하는 해결책을 개발할 자신감을 제공했습니다.\n\n우리의 다음 과제는 dbt 프로젝트를 Airflow DAG로 변환하여 각 dbt 엔티티가 해당하는 Airflow 작업으로 매핑되고 모든 종속성이 유지되도록 하는 것이었습니다.\n\n# dbt-airflow 빌딩\n\n<div class=\"content-ad\"></div>\n\ndbt DAG를 Airflow DAG로 변환하기 위해 첫 번째 작업은 dbt 엔터티에서 의존성을 추출하는 것이었습니다. 이는 데이터 모델 간의 관계를 구문 분석하고 DAG 내의 Airflow 작업에 매핑하는 것을 포함했습니다.\n\ndbt 의존성을 Airflow 작업으로 표현함으로써 데이터 워크플로를 원활하게 조정할 수 있었습니다. 작업(예: 모델 실행 또는 테스트)이 실패하면 분석가와 분석 엔지니어는 DAG의 나머지 부분을 해제하기 위해 기초 모델 문제에 대처해야 했습니다.\n\n이 접근 방식은 처음에는 방해적으로 보일 수 있지만, 물론 목표는 신뢰할 수 없는 데이터로 모델을 구축하는 것이 아닙니다. 그러나 초기 오류 감지는 우리 설계의 중요한 측면이었습니다. 이렇게 함으로써 비용을 최소화하고 계산 속도를 절약하며 데이터에 대한 신뢰를 유지할 수 있었습니다.\n\n## 반복 1: manifest.json 파일 활용\n\n<div class=\"content-ad\"></div>\n\n첫 번째 반복에서는 dbt가 생성한 manifest.json 파일을 읽는 파서를 개발했습니다. 이 메타데이터 파일은 dbt가 실행, 테스트 및 컴파일 중에 생성됩니다.\n\n이 파일의 내용을 사용하여 모든 dbt 엔티티와 해당 의존성을 추출할 수 있었습니다. 이 이정표는 dbt-airflow shaping의 탄생을 알리는 중요한 순간이었습니다.\n\n첫 릴리스는 manifest.json 파일에서 프로젝트를 읽고 모델 의존성을 추출하여 Airflow DAG 내의 TaskGroup으로 변환하는 능력을 갖추었습니다.\n\n이제 특정 작업이 실패할 때와 같이, 하류 의존성은 누군가 기본 문제를 해결할 때까지 일시 중지되어 DAG의 나머지 부분이 차단 해제됩니다.\n\n<div class=\"content-ad\"></div>\n\n이 방법을 통해 문제가 발생했을 때 전체 모델 또는 테스트 세트를 다시 실행할 필요가 없어졌어요. 결과적으로, 이 전략은 Airflow에서 실행되는 dbt 프로젝트의 실행 및 유지에 관련된 비용을 크게 줄였어요.\n\n초기 Airflow DAG는 다음과 같았어요;\n\n```js\nimport functools\nfrom datetime import datetime \nfrom datetime import timedelta\nfrom pathlib import Path\n\nfrom airflow import DAG\nfrom airflow.operators.empty import EmptyOperator\nfrom airflow.operators.python import PythonOperator\nfrom dbt_airflow.core.config import DbtAirflowConfig\nfrom dbt_airflow.core.config import DbtProfileConfig\nfrom dbt_airflow.core.config import DbtProjectConfig\nfrom dbt_airflow.core.task_group import DbtTaskGroup\nfrom dbt_airflow.operators.execution import ExecutionOperator\n\n\nwith DAG(\n    dag_id='test_dag',\n    start_date=datetime(2021, 1, 1),\n    catchup=False,\n    tags=['example'],\n    default_args={\n        'owner': 'airflow',\n        'retries': 1,\n        'retry_delay': timedelta(minutes=2),\n        },\n    on_failure_callback=functools.partial(\n        our_callback_function_to_send_slack_alerts\n    ),\n) as dag:\n\n    t1 = EmptyOperator(task_id='extract')\n    t2 = EmptyOperator(task_id='load')\n\n    tg = DbtTaskGroup(\n        group_id='transform',\n        dbt_project_config=DbtProjectConfig(\n            project_path=Path('/path/to/example_dbt_project/'),\n            manifest_path=Path('/path/to/example_dbt_project/target/manifest.json'),\n        ),\n        dbt_profile_config=DbtProfileConfig(\n            profiles_path=Path('/path/to/example_dbt_project/profiles'),\n            target='dev',\n        ),\n        dbt_airflow_config=DbtAirflowConfig(\n            execution_operator=ExecutionOperator.BASH,\n        ),\n    )\n\n    t1 >> t2 >> tg\n```\n\n프로젝트를 Cloud Composer에 배포하는 관점에서 이번 반복에서는 아무런 변경 사항이 없었어요.\n\n<div class=\"content-ad\"></div>\n\n\n![Screenshot 1](/assets/img/2024-06-19-dbtAirflow_3.png)\n\nBy the end of this first iteration, we were able to meet half of the requirements we specified during ideation:\n\n![Screenshot 2](/assets/img/2024-06-19-dbtAirflow_4.png)\n\n## Iteration 2: Introducing Extra Tasks\n\n\n<div class=\"content-ad\"></div>\n\n이번 반복에서는 초기 설계의 핵심 측면으로 초점을 옮겼습니다: 기존 모든 모델을 Airflow로 원활하게 마이그레이션할 수 있는 능력입니다.\n\nMachine Learning 워크플로우를 모델 실행 사이에 통합하여 하향 모델이 필요로 하는 데이터를 생성할 수 있도록 목표를 설정했습니다. 이 접근은 결과적으로 강하게 결합된 시스템을 만들어 내어 최선의 방법에 부합하지 않을 수 있지만, 이는 당시 실행 흐름을 대표했습니다. dbt-airflow가 이 흐름을 재현할 수 있도록 보장하는 것이 우선이었고, 이러한 구성 요소를 분리하는 구조 변경을 고려하기 전에 기술적 부채에 대한 대응은 그때의 주요 초점이 아니었습니다.\n\n그러나 이것은 다른 작업을 가속화할 수 있는 가치 있는 기능이었습니다. 예를 들어, 특정 dbt 모델에서 데이터에 의존하는 워크플로우는 해당 모델이 완료된 직후에 즉시 트리거될 수 있었고, 전체 DAG가 완료될 때까지 기다릴 필요가 없었습니다.\n\n기술적으로는 관심있는 dbt 프로젝트를 구문 분석한 후 생성된 Airflow 작업 이후에 Airflow Operator를 도입하려고 했습니다. 이를 달성하기 위해 Extra Task의 상위 또는 하위 작업을 명시해야 했습니다.\n\n<div class=\"content-ad\"></div>\n\n'Extra Tasks'를 표현하기 위해 우리는 ExtraTask라는 객체를 개발했습니다. 이 객체는 렌더링된 dbt 프로젝트 내에서 이러한 작업을 소개하는 데 활용될 수 있습니다.\n\n```js\nfrom airflow.operators.python import PythonOperator\nfrom dbt_airflow.core.task import ExtraTask\n\n\nExtraTask(\n    task_id='test_task',\n    operator=PythonOperator,\n    operator_args={\n        'python_callable': lambda: print('Hello world'),\n    },\n    upstream_task_ids={\n        'model.example_dbt_project.int_customers_per_store',\n        'model.example_dbt_project.int_revenue_by_date',\n    },\n)\n```\n\n다음은 dbt-airflow의 Extra Task 기능을 활용하여 유명한 Sakila 프로젝트를 사용하여 생성된 더미 dbt 프로젝트를 렌더링하고 실행하는 예시 DAG입니다.\n\n```js\nimport functools\nfrom datetime import datetime\nfrom datetime import timedelta\nfrom pathlib import Path\n\nfrom airflow import DAG\nfrom airflow.operators.empty import EmptyOperator\nfrom airflow.operators.python import PythonOperator\nfrom dbt_airflow.core.config import DbtAirflowConfig\nfrom dbt_airflow.core.config import DbtProfileConfig\nfrom dbt_airflow.core.config import DbtProjectConfig\nfrom dbt_airflow.core.task import ExtraTask\nfrom dbt_airflow.core.task_group import DbtTaskGroup\nfrom dbt_airflow.operators.execution import ExecutionOperator\n\n\nwith DAG(\n    dag_id='test_dag',\n    start_date=datetime(2021, 1, 1),\n    catchup=False,\n    tags=['example'],\n    default_args={\n        'owner': 'airflow',\n        'retries': 1,\n        'retry_delay': timedelta(minutes=2),\n    },\n    'on_failure_callback': functools.partial(\n        our_callback_function_to_send_slack_alerts\n    ),\n) as dag:\n\n    t1 = EmptyOperator(task_id='extract')\n    t2 = EmptyOperator(task_id='load')\n\n    extra_tasks = [\n        ExtraTask(\n            task_id='test_task',\n            operator=PythonOperator,\n            operator_args={\n                'python_callable': lambda: print('Hello world'),\n            },\n            upstream_task_ids={\n                'model.example_dbt_project.int_customers_per_store',\n                'model.example_dbt_project.int_revenue_by_date',\n            },\n        ),\n        ExtraTask(\n            task_id='another_test_task',\n            operator=PythonOperator,\n            operator_args={\n                'python_callable': lambda: print('Hello world 2!'),\n            },\n            upstream_task_ids={\n                'test.example_dbt_project.int_customers_per_store',\n            },\n            downstream_task_ids={\n                'snapshot.example_dbt_project.int_customers_per_store_snapshot',\n            },\n        ),\n        ExtraTask(\n            task_id='test_task_3',\n            operator=PythonOperator,\n            operator_args={\n                'python_callable': lambda: print('Hello world 3!'),\n            },\n            downstream_task_ids={\n                'snapshot.example_dbt_project.int_customers_per_store_snapshot',\n            },\n            upstream_task_ids={\n                'model.example_dbt_project.int_revenue_by_date',\n            },\n        )\n    ]\n\n    tg = DbtTaskGroup(\n        group_id='my-dbt-project',\n        dbt_project_config=DbtProjectConfig(\n            project_path=Path('/path/to/example_dbt_project/'),\n            manifest_path=Path('/path/to/example_dbt_project/target/manifest.json'),\n        ),\n        dbt_profile_config=DbtProfileConfig(\n            profiles_path=Path('/path/to/example_dbt_project/profiles'),\n            target='dev',\n        ),\n        dbt_airflow_config=DbtAirflowConfig(\n            extra_tasks=extra_tasks,\n            execution_operator=ExecutionOperator.BASH,\n        ),\n    )\n\n    t1 >> t2 >> tg\n```\n\n<div class=\"content-ad\"></div>\n\n두 번째 반복을 마칠 때, 우리는 더욱 우리가 목표로 한 최종 제품에 한 발짝 더 가까워졌어요.\n\n![이미지](/assets/img/2024-06-19-dbtAirflow_5.png)\n\n## 반복 3: 필터링 태그 및 다중 스케줄 생성\n\n이 반복에서, 우리의 목표는 특정 DAG 내에서 특정 dbt 엔티티의 하위 집합만 렌더링할 수 있게 하는 기능을 구현하는 것이었어요. 이는 여러 목적을 달성하기 위한 것이었죠:\n\n<div class=\"content-ad\"></div>\n\n- 동일한 모델에 대해 시간별, 일별 또는 주간별로 다른 일정을 생성하려면 해당 태그가 지정된 모델만 선택하여 선택하면 됩니다.\n- 특정 이유로 특정 태그가 지정된 모델을 특정 DAG에 포함하지 않으려면 필터링을 해야 합니다.\n- 다른 워크플로에서 특정 시점에 일부 모델을 새로 고침해야 할 때 일부 모델만 렌더링해야 할 수 있습니다.\n\n이를 달성하기 위해, DbtAirflowConfig 객체에 'include_tags'와 'exclude_tags' 두 가지 추가 인수를 도입했습니다. 두 인수 모두 렌더링된 프로젝트에서 Entity를 포함하거나 제외하는 데 사용되는 dbt 태그와 일치하는 문자열 목록을 수용합니다.\n\n이 기능 추가의 주요 도전 과제는 필터링된 노드가 올바른 종속성을 유지하는 것이어서 예상보다 복잡했습니다.\n\n이 반복에서 우리는 이 프로젝트를 시작할 때 목표로 했던 최종 버전에 한 걸음 가까워졌습니다!\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-dbtAirflow_6.png\" />\n\n## 이터레이션 4: 컨테이너화된 프로젝트 실행\n\n에어플로우에서 BashOperator를 통해 dbt 명령을 실행할 때는 Airflow 환경 내에서 결과가 자료화되는 대상 시스템을 기준으로 dbt-core 및 해당 dbt 어댑터를 설치하는 것이 중요합니다.\n\n그러나 이 접근 방식은 패키지의 호환성 문제 등의 위험과 어려움을 야기할 수 있습니다. 특히 제공 업체의 다른 클라우드 서비스와의 통합을 용이하게하기 위해 미리 정의된 종속성을 함께 제공하는 클라우드의 관리형 Airflow 서비스인 클라우드 컴포저와 같은 서비스를 사용할 때 이 문제가 발생할 가능성이 높아집니다.\n\n<div class=\"content-ad\"></div>\n\n그리고, 여러 개의 dbt 프로젝트를 관리하는 것은 서로 다른 dbt 버전에서 실행해야 할 수도 있습니다. 안타까운 점은 Airflow 환경에 dbt를 직접 설치하면 기술적으로 이것이 불가능하다는 것입니다.\n\n이러한 도전에 대처하고 버전 관리의 유연성을 보장하기 위해 우리는 dbt 프로젝트를 컨테이너화하고 k8s에서 실행하기로 결정했습니다. 이 방법은 다양한 사용 사례를 지원할뿐만 아니라 필요에 따라 dbt 버전을 업그레이드 또는 다운그레이드할 수 있는 유연성을 제공합니다.\n\n![이미지](/assets/img/2024-06-19-dbtAirflow_7.png)\n\n새 CI/CD 파이프라인이 트리거될 때마다, dbt 프로젝트를 포함하는 Docker 이미지가 빌드되어 Google Cloud의 Artifact Registry로 푸시됩니다. 그러나 dbt-airflow는 여전히 DAG를 렌더링하기 위해 manifest.json 파일에 의존하므로 전체 dbt 프로젝트를 복사하는 대신 manifest 파일만 Cloud Composer GCS 버킷으로 복사해야 합니다.\n\n<div class=\"content-ad\"></div>\n\ndbt-airflow에서는 라이브러리를 확장하여 KubernetesPodOperator를 사용하여 Airflow Tasks를 실행하는 지원을 추가했어요. 이 기능을 통해 DbtAirflowConfig 내에서 execution_operator=ExecutionOperator.KUBERNETES를 지정할 수 있게 되었어요. 이 설정을 사용하면 TaskGroup 내의 각 작업이 자체 Kubernetes pod에서 실행되며 지정된 컨테이너 및 추가 구성을 활용할 수 있어요.\n\n```python\nimport functools\nfrom datetime import datetime \nfrom datetime import timedelta\nfrom pathlib import Path\n\nfrom airflow import DAG\nfrom airflow.operators.empty import EmptyOperator\nfrom airflow.operators.python import PythonOperator\nfrom dbt_airflow.core.config import DbtAirflowConfig\nfrom dbt_airflow.core.config import DbtProfileConfig\nfrom dbt_airflow.core.config import DbtProjectConfig\nfrom dbt_airflow.core.task_group import DbtTaskGroup\nfrom dbt_airflow.operators.execution import ExecutionOperator\n\n\nwith DAG(\n    dag_id='test_dag',\n    start_date=datetime(2021, 1, 1),\n    catchup=False,\n    tags=['example'],\n    default_args={\n        'owner': 'airflow',\n        'retries': 1,\n        'retry_delay': timedelta(minutes=2),\n    },\n    'on_failure_callback': functools.partial(\n        our_callback_function_to_send_slack_alerts\n    ),\n) as dag:\n\n    t1 = EmptyOperator(task_id='extract')\n    t2 = EmptyOperator(task_id='load')\n\n    tg = DbtTaskGroup(\n        group_id='transform',\n        dbt_airflow_config=DbtAirflowConfig(\n            create_sub_task_groups=True,\n            execution_operator=ExecutionOperator.KUBERNETES,\n            operator_kwargs={\n                'name': f'dbt-project-1-dev',\n                'namespace': 'composer-user-workloads',\n                'image': 'gcp-region-docker.pkg.dev/gcp-project-name/ar-repo/dbt-project-1:latest',\n                'kubernetes_conn_id': 'kubernetes_default',\n                'config_file': '/home/airflow/composer_kube_config',\n                'image_pull_policy': 'Always',\n            },\n        ),\n        dbt_project_config=DbtProjectConfig(\n            project_path=Path('/home/project-1/'),  # 도커 컨테이너 내의 경로\n            manifest_path=Path('/home/airflow/gcs/dags/dbt/project-1/target/manifest.json'),  # Cloud Composer GCS 버킷에 있는 경로\n        ),\n        dbt_profile_config=DbtProfileConfig(\n            profiles_path=Path('/home/project-1/profiles/'),  # 도커 컨테이너 내의 경로\n            target=dbt_profile_target,\n        ),\n    )\n\n    t1 >> t2 >> tg\n```\n\n그리고 이 기능 추가로 프로젝트 초반에 지정된 초기 요구 사항 집필을 성공적으로 구현했어요.\n\n<img src=\"/assets/img/2024-06-19-dbtAirflow_8.png\" />\n\n<div class=\"content-ad\"></div>\n\n# dbt-airflow을 시작해 보세요\n\ndbt 프로젝트를 배포하고 일정을 예약하는 방법을 찾고 있다면, dbt-airflow를 사용하면 귀찮음을 덜 수 있습니다. Plum의 데이터팀은 이미 1년 이상 운영 중인 이 도구를 안정적이고 확장 가능하다고 입증했습니다. 그래서 여러분의 프로젝트에도 실제 가치를 제공할 수 있다고 자신합니다. 이 패키지는 플랫폼에 구애받지 않으며 dbt에서 지원하는 모든 대상과 함께 사용할 수 있습니다.\n\n이 프로젝트는 GitHub에서 유지되고 PyPI에서도 사용할 수 있습니다.\n\n또한 공식 문서에서 더 많은 세부 정보를 찾을 수 있습니다. 사실, 이 문서에서는 패키지가 제공하는 전체 기능 중 일부만 다루었습니다.\n\n<div class=\"content-ad\"></div>\n\n프로젝트에 기여하는 것을 장려합니다. 무언가 부족한 부분이 있으면 참여해 주시기를 바랍니다.\n\n코딩 즐기세요,\n\nPlum Data Engineering Team ❤","ogImage":{"url":"/assets/img/2024-06-19-dbtAirflow_0.png"},"coverImage":"/assets/img/2024-06-19-dbtAirflow_0.png","tag":["Tech"],"readingTime":16},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-19-dbtAirflow_0.png\" alt=\"image\"></p>\n<p>요즘의 동적이고 경쟁적인 환경에서 기업은 데이터 기반 의사결정에 크게 의존하고 있습니다. 이를 실현하기 위해 조직은 믿을 수 있는 견고한 데이터 플랫폼과 고품질 데이터가 필요합니다. 이는 데이터를 효과적으로 수집하고 저장하는 시스템뿐만 아니라 데이터의 정확성과 신뢰성을 보장하는 것을 의미합니다.</p>\n<p>수백 개 또는 수천 개의 데이터 모델을 관리하는 것은 항상 간단한 과정은 아닙니다. 데이터 팀은 종종 데이터 자산을 효과적으로 구축, 테스트 및 유지하는 데 고민합니다. 플럼에서는 데이터 빌드 도구(dbt)를 활용하여 데이터 모델을 효과적으로 관리할 수 있는 CLI 도구에 의존합니다.</p>\n<p>그러나 dbt는 명령줄 인터페이스의 특성 때문에 도전적인 요소를 가지고 있습니다. 그렇다면, 제품 환경에 배포할 때 dbt의 장점을 팀이 어떻게 활용할 수 있을까요?</p>\n<div class=\"content-ad\"></div>\n<p>dbt Cloud가 당연한 선택처럼 보일 수 있지만, 모든 팀 또는 회사가 이 제품에 투자하기에 준비되어 있는 것은 아닙니다. 이러한 상황에서는 dbt 모델의 실행을 조율하고 그 사이의 종속성을 유지하는 대체 방법이 필요합니다.</p>\n<h1>왜 자체 통합을 구축하기로 투자했는가</h1>\n<p>dbt Cloud에 필요한 투자 외에도, 우리 팀은 특정 기능을 지원받길 원했습니다. 그러나 당시에는 플랫폼에서 이러한 기능 중 일부만 지원되었습니다. 아래에서 가장 기본적인 것들을 개요하겠습니다.</p>\n<p><img src=\"/assets/img/2024-06-19-dbtAirflow_1.png\" alt=\"2024-06-19-dbtAirflow_1.png\"></p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>dbt 프로젝트 일정 설정: 우리는 dbt 프로젝트를 cron 작업 스타일로 일정을 잡고, 특정 시간 간격을 지정합니다.</li>\n<li>작업 세분화: 각 dbt 엔티티(모델, 테스트, 시드, 스냅샷을 포함)는 개별적으로 처리되어 필요한 경우에 개별적으로 트리거될 수 있도록 합니다.</li>\n<li>dbt 의존성 유지: 또한, dbt 엔티티 간의 종속성을 유지해야 합니다. 예를 들어, 모델 A가 테스트를 포함하여 다른 모델 B의 상위 의존성으로 작용하는 경우 실행 순서를 유지해야 합니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">[dbt run A] -> [dbt test A] -> [dbt run B]\n</code></pre>\n<ol start=\"4\">\n<li>다른 워크플로우 트리거: 특정 dbt 엔티티의 성공적인 완료 후에 특정 워크플로우를 시작해야 하며, 전체 dbt 프로젝트가 완료될 필요가 없는 경우가 있습니다. 또한, 두 dbt 엔티티 실행 사이에 특정 워크플로우를 시작해야할 경우가 있을 수 있습니다.</li>\n</ol>\n<pre><code class=\"hljs language-js\">[dbt run A] -> [dbt와 무관한 워크플로우 실행] -> [dbt run B]\n</code></pre>\n<div class=\"content-ad\"></div>\n<ol start=\"5\">\n<li>\n<p>알림: 문제가 발생했을 때, 슬랙으로 알림을 받아야 합니다.</p>\n</li>\n<li>\n<p>컨테이너화된 dbt 프로젝트 실행: 각각의 dbt 프로젝트는 자체 Docker 이미지를 가져야 합니다. 필요시 다른 dbt 버전에서 실행할 수 있는 유연성을 제공합니다.</p>\n</li>\n<li>\n<p>모델 하위 집합 트리거링: dbt 엔티티는 dbt 태그를 기반으로 필터링될 수 있어서 필요한 특정 모델 그룹을 실행할 수 있습니다.</p>\n</li>\n<li>\n<p>여러 일정 생성: 동일한 프로젝트를 서로 다른 일정으로 실행해야 할 수도 있습니다. 이는 모델 하위 집합을 트리거할 필요와 밀접하게 관려이 있습니다. 예를 들어, 모델을 시간별, 일별, 주간별로 태그 지정하여 해당 일정에 맞춰 실행할 수 있습니다.</p>\n</li>\n</ol>\n<div class=\"content-ad\"></div>\n<p>다양한 대안을 탐색해 본 결과, 천문학자가 개발한 Cosmos 패키지를 포함해 어떤 것도 당시의 우리 사용 사례와 명확한 요구 사항에 적합하다는 것을 입증하지 못했습니다.</p>\n<p>이러한 도전에 직면하자, 우리는 우리의 요구에 맞게 제작된 자체 Python 패키지를 개발하기로 전략적인 결정을 내렸습니다. 이 맞춤형 솔루션은 우리에게 dbt와 Airflow를 원활하게 통합할 수 있는 유연성과 기능이 제공되어, 데이터 팀이 효과적으로 데이터 모델을 관리하고 최적화할 수 있게 해줍니다.</p>\n<h1>왜 Airflow를 선택했나요?</h1>\n<p>데이터 파이프라인 Orchestration 전략을 설계할 때, 우리는 특정 간격(시간별, 일별 또는 주별)으로 작업을 예약하고 관리할 수 있는 능력을 지향했습니다. 팀이 Airflow 및 Google Cloud의 Cloud Composer 서비스에 익숙하고 기존 인프라가 있었기 때문에 Airflow를 선택하는 것이 우리의 요구에 적합한 자연스러운 선택이었습니다.</p>\n<div class=\"content-ad\"></div>\n<p>또한 Airflow와 dbt는 Directed Acyclic Graphs (DAGs) 개념을 중심으로 하고 있어, dbt DAGs를 Airflow DAGs로 변환하여 Orchestration(오케스트레이션)할 수 있습니다.</p>\n<p>DAGs는 노드가 닫힌 순환 루프를 형성하지 않고 방향성을 가지고 연결된 작업 또는 데이터 모델을 나타내는 그래프입니다. dbt에서 DAGs는 데이터 모델 간의 관계와 종속성을 나타내고, Airflow에서는 DAGs는 데이터 파이프라인에 포함된 단계와 종속성을 시각화합니다.</p>\n<h1>0부터 1까지: Cloud Composer에서 dbt 실행하기</h1>\n<p>이 초기 단계에서 우리의 작업은 상대적으로 간단했습니다: Airflow를 사용하여 dbt 프로젝트를 실행하고 테스트하되, 각 모델, 테스트, 스냅샷 또는 시드를 개별 작업으로 설정할 필요가 없었습니다.</p>\n<div class=\"content-ad\"></div>\n<p>필요한 것은 GitHub Actions를 사용하여 CI/CD 파이프라인을 설정하는 것이었습니다. 이 파이프라인은 관련된 dbt 프로젝트를 Cloud Composer 버킷으로 복사하고 Airflow 내에서 DAG를 구성합니다. 이 DAG에는 모델을 실행하는 하나의 작업 및 해당 작업을 테스트하는 다른 작업이 포함됩니다.</p>\n<p><img src=\"/assets/img/2024-06-19-dbtAirflow_2.png\" alt=\"2024-06-19-dbtAirflow_2\"></p>\n<p>이것은 Airflow에서 dbt 프로젝트를 실행하는 가장 간단한 방법일 수 있습니다. DAG는 BashOperator로 생성된 두 개의 작업으로 구성됩니다. 기본적으로, 이는 로컬에서 dbt run 및 dbt test 명령을 실행하는 dbt CLI를 사용한 프로세스를 반영합니다.</p>\n<p>그러나 이 방법에는 여러 가지 제약이 있습니다:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>만약에 dbt_run 작업 내에서 모델 실행이 실패한다면, 문제를 해결하기 위해 작업을 다시 실행해야 합니다. 이는 이전에 성공했던 모델들을 포함하여 모든 모델을 다시 실행해야 하므로 실행 시간과 비용이 증가하는 것을 의미합니다.</li>\n<li>모델 실행과 테스트는 완전히 독립적입니다. 모든 테스트는 워크플로우의 끝에 실행됩니다. 따라서 다른 모델들의 상위 종속성인 모델들에서 문제가 발생할 경우 너무 늦기 전까지 알아차리지 못할 수 있습니다.</li>\n<li>만약에 dbt_test 작업에서 모델 테스트가 실패한다면, 이 문제를 해결하기 위해 영향을 받는 모든 모델을 수정하기 위해 dbt_run과 dbt_test 작업을 검토하고 재실행해야 합니다.</li>\n<li>Airflow 작업은 BashOperator를 사용하여 생성되며, Airflow 환경에 dbt 패키지 의존성이 설치되어 있어야 합니다. 이는 패키지 버전 호환성 문제로 인해 문제가 될 수 있으며, 특히 GCP의 Cloud Composer나 AWS의 MWAA와 같은 관리형 Airflow 서비스에서 더욱 그렇습니다.</li>\n</ul>\n<p>이 초기 시도는 Proof-of-Concept(PoC)로서의 느낌이 더 큰 노력입니다. 제한사항과 확장성 부족에도 불구하고, 팀의 기대에 부합하는 해결책을 개발할 자신감을 제공했습니다.</p>\n<p>우리의 다음 과제는 dbt 프로젝트를 Airflow DAG로 변환하여 각 dbt 엔티티가 해당하는 Airflow 작업으로 매핑되고 모든 종속성이 유지되도록 하는 것이었습니다.</p>\n<h1>dbt-airflow 빌딩</h1>\n<div class=\"content-ad\"></div>\n<p>dbt DAG를 Airflow DAG로 변환하기 위해 첫 번째 작업은 dbt 엔터티에서 의존성을 추출하는 것이었습니다. 이는 데이터 모델 간의 관계를 구문 분석하고 DAG 내의 Airflow 작업에 매핑하는 것을 포함했습니다.</p>\n<p>dbt 의존성을 Airflow 작업으로 표현함으로써 데이터 워크플로를 원활하게 조정할 수 있었습니다. 작업(예: 모델 실행 또는 테스트)이 실패하면 분석가와 분석 엔지니어는 DAG의 나머지 부분을 해제하기 위해 기초 모델 문제에 대처해야 했습니다.</p>\n<p>이 접근 방식은 처음에는 방해적으로 보일 수 있지만, 물론 목표는 신뢰할 수 없는 데이터로 모델을 구축하는 것이 아닙니다. 그러나 초기 오류 감지는 우리 설계의 중요한 측면이었습니다. 이렇게 함으로써 비용을 최소화하고 계산 속도를 절약하며 데이터에 대한 신뢰를 유지할 수 있었습니다.</p>\n<h2>반복 1: manifest.json 파일 활용</h2>\n<div class=\"content-ad\"></div>\n<p>첫 번째 반복에서는 dbt가 생성한 manifest.json 파일을 읽는 파서를 개발했습니다. 이 메타데이터 파일은 dbt가 실행, 테스트 및 컴파일 중에 생성됩니다.</p>\n<p>이 파일의 내용을 사용하여 모든 dbt 엔티티와 해당 의존성을 추출할 수 있었습니다. 이 이정표는 dbt-airflow shaping의 탄생을 알리는 중요한 순간이었습니다.</p>\n<p>첫 릴리스는 manifest.json 파일에서 프로젝트를 읽고 모델 의존성을 추출하여 Airflow DAG 내의 TaskGroup으로 변환하는 능력을 갖추었습니다.</p>\n<p>이제 특정 작업이 실패할 때와 같이, 하류 의존성은 누군가 기본 문제를 해결할 때까지 일시 중지되어 DAG의 나머지 부분이 차단 해제됩니다.</p>\n<div class=\"content-ad\"></div>\n<p>이 방법을 통해 문제가 발생했을 때 전체 모델 또는 테스트 세트를 다시 실행할 필요가 없어졌어요. 결과적으로, 이 전략은 Airflow에서 실행되는 dbt 프로젝트의 실행 및 유지에 관련된 비용을 크게 줄였어요.</p>\n<p>초기 Airflow DAG는 다음과 같았어요;</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> functools\n<span class=\"hljs-keyword\">from</span> datetime <span class=\"hljs-keyword\">import</span> datetime \n<span class=\"hljs-keyword\">from</span> datetime <span class=\"hljs-keyword\">import</span> timedelta\n<span class=\"hljs-keyword\">from</span> pathlib <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Path</span>\n\n<span class=\"hljs-keyword\">from</span> airflow <span class=\"hljs-keyword\">import</span> <span class=\"hljs-variable constant_\">DAG</span>\n<span class=\"hljs-keyword\">from</span> airflow.<span class=\"hljs-property\">operators</span>.<span class=\"hljs-property\">empty</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">EmptyOperator</span>\n<span class=\"hljs-keyword\">from</span> airflow.<span class=\"hljs-property\">operators</span>.<span class=\"hljs-property\">python</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">PythonOperator</span>\n<span class=\"hljs-keyword\">from</span> dbt_airflow.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">config</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">DbtAirflowConfig</span>\n<span class=\"hljs-keyword\">from</span> dbt_airflow.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">config</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">DbtProfileConfig</span>\n<span class=\"hljs-keyword\">from</span> dbt_airflow.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">config</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">DbtProjectConfig</span>\n<span class=\"hljs-keyword\">from</span> dbt_airflow.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">task_group</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">DbtTaskGroup</span>\n<span class=\"hljs-keyword\">from</span> dbt_airflow.<span class=\"hljs-property\">operators</span>.<span class=\"hljs-property\">execution</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ExecutionOperator</span>\n\n\n<span class=\"hljs-keyword\">with</span> <span class=\"hljs-title function_\">DAG</span>(\n    dag_id=<span class=\"hljs-string\">'test_dag'</span>,\n    start_date=<span class=\"hljs-title function_\">datetime</span>(<span class=\"hljs-number\">2021</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>),\n    catchup=<span class=\"hljs-title class_\">False</span>,\n    tags=[<span class=\"hljs-string\">'example'</span>],\n    default_args={\n        <span class=\"hljs-string\">'owner'</span>: <span class=\"hljs-string\">'airflow'</span>,\n        <span class=\"hljs-string\">'retries'</span>: <span class=\"hljs-number\">1</span>,\n        <span class=\"hljs-string\">'retry_delay'</span>: <span class=\"hljs-title function_\">timedelta</span>(minutes=<span class=\"hljs-number\">2</span>),\n        },\n    on_failure_callback=functools.<span class=\"hljs-title function_\">partial</span>(\n        our_callback_function_to_send_slack_alerts\n    ),\n) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">dag</span>:\n\n    t1 = <span class=\"hljs-title class_\">EmptyOperator</span>(task_id=<span class=\"hljs-string\">'extract'</span>)\n    t2 = <span class=\"hljs-title class_\">EmptyOperator</span>(task_id=<span class=\"hljs-string\">'load'</span>)\n\n    tg = <span class=\"hljs-title class_\">DbtTaskGroup</span>(\n        group_id=<span class=\"hljs-string\">'transform'</span>,\n        dbt_project_config=<span class=\"hljs-title class_\">DbtProjectConfig</span>(\n            project_path=<span class=\"hljs-title class_\">Path</span>(<span class=\"hljs-string\">'/path/to/example_dbt_project/'</span>),\n            manifest_path=<span class=\"hljs-title class_\">Path</span>(<span class=\"hljs-string\">'/path/to/example_dbt_project/target/manifest.json'</span>),\n        ),\n        dbt_profile_config=<span class=\"hljs-title class_\">DbtProfileConfig</span>(\n            profiles_path=<span class=\"hljs-title class_\">Path</span>(<span class=\"hljs-string\">'/path/to/example_dbt_project/profiles'</span>),\n            target=<span class=\"hljs-string\">'dev'</span>,\n        ),\n        dbt_airflow_config=<span class=\"hljs-title class_\">DbtAirflowConfig</span>(\n            execution_operator=<span class=\"hljs-title class_\">ExecutionOperator</span>.<span class=\"hljs-property\">BASH</span>,\n        ),\n    )\n\n    t1 >> t2 >> tg\n</code></pre>\n<p>프로젝트를 Cloud Composer에 배포하는 관점에서 이번 반복에서는 아무런 변경 사항이 없었어요.</p>\n<div class=\"content-ad\"></div>\n<p><img src=\"/assets/img/2024-06-19-dbtAirflow_3.png\" alt=\"Screenshot 1\"></p>\n<p>By the end of this first iteration, we were able to meet half of the requirements we specified during ideation:</p>\n<p><img src=\"/assets/img/2024-06-19-dbtAirflow_4.png\" alt=\"Screenshot 2\"></p>\n<h2>Iteration 2: Introducing Extra Tasks</h2>\n<div class=\"content-ad\"></div>\n<p>이번 반복에서는 초기 설계의 핵심 측면으로 초점을 옮겼습니다: 기존 모든 모델을 Airflow로 원활하게 마이그레이션할 수 있는 능력입니다.</p>\n<p>Machine Learning 워크플로우를 모델 실행 사이에 통합하여 하향 모델이 필요로 하는 데이터를 생성할 수 있도록 목표를 설정했습니다. 이 접근은 결과적으로 강하게 결합된 시스템을 만들어 내어 최선의 방법에 부합하지 않을 수 있지만, 이는 당시 실행 흐름을 대표했습니다. dbt-airflow가 이 흐름을 재현할 수 있도록 보장하는 것이 우선이었고, 이러한 구성 요소를 분리하는 구조 변경을 고려하기 전에 기술적 부채에 대한 대응은 그때의 주요 초점이 아니었습니다.</p>\n<p>그러나 이것은 다른 작업을 가속화할 수 있는 가치 있는 기능이었습니다. 예를 들어, 특정 dbt 모델에서 데이터에 의존하는 워크플로우는 해당 모델이 완료된 직후에 즉시 트리거될 수 있었고, 전체 DAG가 완료될 때까지 기다릴 필요가 없었습니다.</p>\n<p>기술적으로는 관심있는 dbt 프로젝트를 구문 분석한 후 생성된 Airflow 작업 이후에 Airflow Operator를 도입하려고 했습니다. 이를 달성하기 위해 Extra Task의 상위 또는 하위 작업을 명시해야 했습니다.</p>\n<div class=\"content-ad\"></div>\n<p>'Extra Tasks'를 표현하기 위해 우리는 ExtraTask라는 객체를 개발했습니다. 이 객체는 렌더링된 dbt 프로젝트 내에서 이러한 작업을 소개하는 데 활용될 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> airflow.<span class=\"hljs-property\">operators</span>.<span class=\"hljs-property\">python</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">PythonOperator</span>\n<span class=\"hljs-keyword\">from</span> dbt_airflow.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">task</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ExtraTask</span>\n\n\n<span class=\"hljs-title class_\">ExtraTask</span>(\n    task_id=<span class=\"hljs-string\">'test_task'</span>,\n    operator=<span class=\"hljs-title class_\">PythonOperator</span>,\n    operator_args={\n        <span class=\"hljs-string\">'python_callable'</span>: <span class=\"hljs-attr\">lambda</span>: <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'Hello world'</span>),\n    },\n    upstream_task_ids={\n        <span class=\"hljs-string\">'model.example_dbt_project.int_customers_per_store'</span>,\n        <span class=\"hljs-string\">'model.example_dbt_project.int_revenue_by_date'</span>,\n    },\n)\n</code></pre>\n<p>다음은 dbt-airflow의 Extra Task 기능을 활용하여 유명한 Sakila 프로젝트를 사용하여 생성된 더미 dbt 프로젝트를 렌더링하고 실행하는 예시 DAG입니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> functools\n<span class=\"hljs-keyword\">from</span> datetime <span class=\"hljs-keyword\">import</span> datetime\n<span class=\"hljs-keyword\">from</span> datetime <span class=\"hljs-keyword\">import</span> timedelta\n<span class=\"hljs-keyword\">from</span> pathlib <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Path</span>\n\n<span class=\"hljs-keyword\">from</span> airflow <span class=\"hljs-keyword\">import</span> <span class=\"hljs-variable constant_\">DAG</span>\n<span class=\"hljs-keyword\">from</span> airflow.<span class=\"hljs-property\">operators</span>.<span class=\"hljs-property\">empty</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">EmptyOperator</span>\n<span class=\"hljs-keyword\">from</span> airflow.<span class=\"hljs-property\">operators</span>.<span class=\"hljs-property\">python</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">PythonOperator</span>\n<span class=\"hljs-keyword\">from</span> dbt_airflow.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">config</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">DbtAirflowConfig</span>\n<span class=\"hljs-keyword\">from</span> dbt_airflow.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">config</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">DbtProfileConfig</span>\n<span class=\"hljs-keyword\">from</span> dbt_airflow.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">config</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">DbtProjectConfig</span>\n<span class=\"hljs-keyword\">from</span> dbt_airflow.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">task</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ExtraTask</span>\n<span class=\"hljs-keyword\">from</span> dbt_airflow.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">task_group</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">DbtTaskGroup</span>\n<span class=\"hljs-keyword\">from</span> dbt_airflow.<span class=\"hljs-property\">operators</span>.<span class=\"hljs-property\">execution</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">ExecutionOperator</span>\n\n\n<span class=\"hljs-keyword\">with</span> <span class=\"hljs-title function_\">DAG</span>(\n    dag_id=<span class=\"hljs-string\">'test_dag'</span>,\n    start_date=<span class=\"hljs-title function_\">datetime</span>(<span class=\"hljs-number\">2021</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>),\n    catchup=<span class=\"hljs-title class_\">False</span>,\n    tags=[<span class=\"hljs-string\">'example'</span>],\n    default_args={\n        <span class=\"hljs-string\">'owner'</span>: <span class=\"hljs-string\">'airflow'</span>,\n        <span class=\"hljs-string\">'retries'</span>: <span class=\"hljs-number\">1</span>,\n        <span class=\"hljs-string\">'retry_delay'</span>: <span class=\"hljs-title function_\">timedelta</span>(minutes=<span class=\"hljs-number\">2</span>),\n    },\n    <span class=\"hljs-string\">'on_failure_callback'</span>: functools.<span class=\"hljs-title function_\">partial</span>(\n        our_callback_function_to_send_slack_alerts\n    ),\n) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">dag</span>:\n\n    t1 = <span class=\"hljs-title class_\">EmptyOperator</span>(task_id=<span class=\"hljs-string\">'extract'</span>)\n    t2 = <span class=\"hljs-title class_\">EmptyOperator</span>(task_id=<span class=\"hljs-string\">'load'</span>)\n\n    extra_tasks = [\n        <span class=\"hljs-title class_\">ExtraTask</span>(\n            task_id=<span class=\"hljs-string\">'test_task'</span>,\n            operator=<span class=\"hljs-title class_\">PythonOperator</span>,\n            operator_args={\n                <span class=\"hljs-string\">'python_callable'</span>: <span class=\"hljs-attr\">lambda</span>: <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'Hello world'</span>),\n            },\n            upstream_task_ids={\n                <span class=\"hljs-string\">'model.example_dbt_project.int_customers_per_store'</span>,\n                <span class=\"hljs-string\">'model.example_dbt_project.int_revenue_by_date'</span>,\n            },\n        ),\n        <span class=\"hljs-title class_\">ExtraTask</span>(\n            task_id=<span class=\"hljs-string\">'another_test_task'</span>,\n            operator=<span class=\"hljs-title class_\">PythonOperator</span>,\n            operator_args={\n                <span class=\"hljs-string\">'python_callable'</span>: <span class=\"hljs-attr\">lambda</span>: <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'Hello world 2!'</span>),\n            },\n            upstream_task_ids={\n                <span class=\"hljs-string\">'test.example_dbt_project.int_customers_per_store'</span>,\n            },\n            downstream_task_ids={\n                <span class=\"hljs-string\">'snapshot.example_dbt_project.int_customers_per_store_snapshot'</span>,\n            },\n        ),\n        <span class=\"hljs-title class_\">ExtraTask</span>(\n            task_id=<span class=\"hljs-string\">'test_task_3'</span>,\n            operator=<span class=\"hljs-title class_\">PythonOperator</span>,\n            operator_args={\n                <span class=\"hljs-string\">'python_callable'</span>: <span class=\"hljs-attr\">lambda</span>: <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">'Hello world 3!'</span>),\n            },\n            downstream_task_ids={\n                <span class=\"hljs-string\">'snapshot.example_dbt_project.int_customers_per_store_snapshot'</span>,\n            },\n            upstream_task_ids={\n                <span class=\"hljs-string\">'model.example_dbt_project.int_revenue_by_date'</span>,\n            },\n        )\n    ]\n\n    tg = <span class=\"hljs-title class_\">DbtTaskGroup</span>(\n        group_id=<span class=\"hljs-string\">'my-dbt-project'</span>,\n        dbt_project_config=<span class=\"hljs-title class_\">DbtProjectConfig</span>(\n            project_path=<span class=\"hljs-title class_\">Path</span>(<span class=\"hljs-string\">'/path/to/example_dbt_project/'</span>),\n            manifest_path=<span class=\"hljs-title class_\">Path</span>(<span class=\"hljs-string\">'/path/to/example_dbt_project/target/manifest.json'</span>),\n        ),\n        dbt_profile_config=<span class=\"hljs-title class_\">DbtProfileConfig</span>(\n            profiles_path=<span class=\"hljs-title class_\">Path</span>(<span class=\"hljs-string\">'/path/to/example_dbt_project/profiles'</span>),\n            target=<span class=\"hljs-string\">'dev'</span>,\n        ),\n        dbt_airflow_config=<span class=\"hljs-title class_\">DbtAirflowConfig</span>(\n            extra_tasks=extra_tasks,\n            execution_operator=<span class=\"hljs-title class_\">ExecutionOperator</span>.<span class=\"hljs-property\">BASH</span>,\n        ),\n    )\n\n    t1 >> t2 >> tg\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>두 번째 반복을 마칠 때, 우리는 더욱 우리가 목표로 한 최종 제품에 한 발짝 더 가까워졌어요.</p>\n<p><img src=\"/assets/img/2024-06-19-dbtAirflow_5.png\" alt=\"이미지\"></p>\n<h2>반복 3: 필터링 태그 및 다중 스케줄 생성</h2>\n<p>이 반복에서, 우리의 목표는 특정 DAG 내에서 특정 dbt 엔티티의 하위 집합만 렌더링할 수 있게 하는 기능을 구현하는 것이었어요. 이는 여러 목적을 달성하기 위한 것이었죠:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>동일한 모델에 대해 시간별, 일별 또는 주간별로 다른 일정을 생성하려면 해당 태그가 지정된 모델만 선택하여 선택하면 됩니다.</li>\n<li>특정 이유로 특정 태그가 지정된 모델을 특정 DAG에 포함하지 않으려면 필터링을 해야 합니다.</li>\n<li>다른 워크플로에서 특정 시점에 일부 모델을 새로 고침해야 할 때 일부 모델만 렌더링해야 할 수 있습니다.</li>\n</ul>\n<p>이를 달성하기 위해, DbtAirflowConfig 객체에 'include_tags'와 'exclude_tags' 두 가지 추가 인수를 도입했습니다. 두 인수 모두 렌더링된 프로젝트에서 Entity를 포함하거나 제외하는 데 사용되는 dbt 태그와 일치하는 문자열 목록을 수용합니다.</p>\n<p>이 기능 추가의 주요 도전 과제는 필터링된 노드가 올바른 종속성을 유지하는 것이어서 예상보다 복잡했습니다.</p>\n<p>이 반복에서 우리는 이 프로젝트를 시작할 때 목표로 했던 최종 버전에 한 걸음 가까워졌습니다!</p>\n<div class=\"content-ad\"></div>\n<img src=\"/assets/img/2024-06-19-dbtAirflow_6.png\">\n<h2>이터레이션 4: 컨테이너화된 프로젝트 실행</h2>\n<p>에어플로우에서 BashOperator를 통해 dbt 명령을 실행할 때는 Airflow 환경 내에서 결과가 자료화되는 대상 시스템을 기준으로 dbt-core 및 해당 dbt 어댑터를 설치하는 것이 중요합니다.</p>\n<p>그러나 이 접근 방식은 패키지의 호환성 문제 등의 위험과 어려움을 야기할 수 있습니다. 특히 제공 업체의 다른 클라우드 서비스와의 통합을 용이하게하기 위해 미리 정의된 종속성을 함께 제공하는 클라우드의 관리형 Airflow 서비스인 클라우드 컴포저와 같은 서비스를 사용할 때 이 문제가 발생할 가능성이 높아집니다.</p>\n<div class=\"content-ad\"></div>\n<p>그리고, 여러 개의 dbt 프로젝트를 관리하는 것은 서로 다른 dbt 버전에서 실행해야 할 수도 있습니다. 안타까운 점은 Airflow 환경에 dbt를 직접 설치하면 기술적으로 이것이 불가능하다는 것입니다.</p>\n<p>이러한 도전에 대처하고 버전 관리의 유연성을 보장하기 위해 우리는 dbt 프로젝트를 컨테이너화하고 k8s에서 실행하기로 결정했습니다. 이 방법은 다양한 사용 사례를 지원할뿐만 아니라 필요에 따라 dbt 버전을 업그레이드 또는 다운그레이드할 수 있는 유연성을 제공합니다.</p>\n<p><img src=\"/assets/img/2024-06-19-dbtAirflow_7.png\" alt=\"이미지\"></p>\n<p>새 CI/CD 파이프라인이 트리거될 때마다, dbt 프로젝트를 포함하는 Docker 이미지가 빌드되어 Google Cloud의 Artifact Registry로 푸시됩니다. 그러나 dbt-airflow는 여전히 DAG를 렌더링하기 위해 manifest.json 파일에 의존하므로 전체 dbt 프로젝트를 복사하는 대신 manifest 파일만 Cloud Composer GCS 버킷으로 복사해야 합니다.</p>\n<div class=\"content-ad\"></div>\n<p>dbt-airflow에서는 라이브러리를 확장하여 KubernetesPodOperator를 사용하여 Airflow Tasks를 실행하는 지원을 추가했어요. 이 기능을 통해 DbtAirflowConfig 내에서 execution_operator=ExecutionOperator.KUBERNETES를 지정할 수 있게 되었어요. 이 설정을 사용하면 TaskGroup 내의 각 작업이 자체 Kubernetes pod에서 실행되며 지정된 컨테이너 및 추가 구성을 활용할 수 있어요.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> functools\n<span class=\"hljs-keyword\">from</span> datetime <span class=\"hljs-keyword\">import</span> datetime \n<span class=\"hljs-keyword\">from</span> datetime <span class=\"hljs-keyword\">import</span> timedelta\n<span class=\"hljs-keyword\">from</span> pathlib <span class=\"hljs-keyword\">import</span> Path\n\n<span class=\"hljs-keyword\">from</span> airflow <span class=\"hljs-keyword\">import</span> DAG\n<span class=\"hljs-keyword\">from</span> airflow.operators.empty <span class=\"hljs-keyword\">import</span> EmptyOperator\n<span class=\"hljs-keyword\">from</span> airflow.operators.python <span class=\"hljs-keyword\">import</span> PythonOperator\n<span class=\"hljs-keyword\">from</span> dbt_airflow.core.config <span class=\"hljs-keyword\">import</span> DbtAirflowConfig\n<span class=\"hljs-keyword\">from</span> dbt_airflow.core.config <span class=\"hljs-keyword\">import</span> DbtProfileConfig\n<span class=\"hljs-keyword\">from</span> dbt_airflow.core.config <span class=\"hljs-keyword\">import</span> DbtProjectConfig\n<span class=\"hljs-keyword\">from</span> dbt_airflow.core.task_group <span class=\"hljs-keyword\">import</span> DbtTaskGroup\n<span class=\"hljs-keyword\">from</span> dbt_airflow.operators.execution <span class=\"hljs-keyword\">import</span> ExecutionOperator\n\n\n<span class=\"hljs-keyword\">with</span> DAG(\n    dag_id=<span class=\"hljs-string\">'test_dag'</span>,\n    start_date=datetime(<span class=\"hljs-number\">2021</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>),\n    catchup=<span class=\"hljs-literal\">False</span>,\n    tags=[<span class=\"hljs-string\">'example'</span>],\n    default_args={\n        <span class=\"hljs-string\">'owner'</span>: <span class=\"hljs-string\">'airflow'</span>,\n        <span class=\"hljs-string\">'retries'</span>: <span class=\"hljs-number\">1</span>,\n        <span class=\"hljs-string\">'retry_delay'</span>: timedelta(minutes=<span class=\"hljs-number\">2</span>),\n    },\n    <span class=\"hljs-string\">'on_failure_callback'</span>: functools.partial(\n        our_callback_function_to_send_slack_alerts\n    ),\n) <span class=\"hljs-keyword\">as</span> dag:\n\n    t1 = EmptyOperator(task_id=<span class=\"hljs-string\">'extract'</span>)\n    t2 = EmptyOperator(task_id=<span class=\"hljs-string\">'load'</span>)\n\n    tg = DbtTaskGroup(\n        group_id=<span class=\"hljs-string\">'transform'</span>,\n        dbt_airflow_config=DbtAirflowConfig(\n            create_sub_task_groups=<span class=\"hljs-literal\">True</span>,\n            execution_operator=ExecutionOperator.KUBERNETES,\n            operator_kwargs={\n                <span class=\"hljs-string\">'name'</span>: <span class=\"hljs-string\">f'dbt-project-1-dev'</span>,\n                <span class=\"hljs-string\">'namespace'</span>: <span class=\"hljs-string\">'composer-user-workloads'</span>,\n                <span class=\"hljs-string\">'image'</span>: <span class=\"hljs-string\">'gcp-region-docker.pkg.dev/gcp-project-name/ar-repo/dbt-project-1:latest'</span>,\n                <span class=\"hljs-string\">'kubernetes_conn_id'</span>: <span class=\"hljs-string\">'kubernetes_default'</span>,\n                <span class=\"hljs-string\">'config_file'</span>: <span class=\"hljs-string\">'/home/airflow/composer_kube_config'</span>,\n                <span class=\"hljs-string\">'image_pull_policy'</span>: <span class=\"hljs-string\">'Always'</span>,\n            },\n        ),\n        dbt_project_config=DbtProjectConfig(\n            project_path=Path(<span class=\"hljs-string\">'/home/project-1/'</span>),  <span class=\"hljs-comment\"># 도커 컨테이너 내의 경로</span>\n            manifest_path=Path(<span class=\"hljs-string\">'/home/airflow/gcs/dags/dbt/project-1/target/manifest.json'</span>),  <span class=\"hljs-comment\"># Cloud Composer GCS 버킷에 있는 경로</span>\n        ),\n        dbt_profile_config=DbtProfileConfig(\n            profiles_path=Path(<span class=\"hljs-string\">'/home/project-1/profiles/'</span>),  <span class=\"hljs-comment\"># 도커 컨테이너 내의 경로</span>\n            target=dbt_profile_target,\n        ),\n    )\n\n    t1 >> t2 >> tg\n</code></pre>\n<p>그리고 이 기능 추가로 프로젝트 초반에 지정된 초기 요구 사항 집필을 성공적으로 구현했어요.</p>\n<img src=\"/assets/img/2024-06-19-dbtAirflow_8.png\">\n<div class=\"content-ad\"></div>\n<h1>dbt-airflow을 시작해 보세요</h1>\n<p>dbt 프로젝트를 배포하고 일정을 예약하는 방법을 찾고 있다면, dbt-airflow를 사용하면 귀찮음을 덜 수 있습니다. Plum의 데이터팀은 이미 1년 이상 운영 중인 이 도구를 안정적이고 확장 가능하다고 입증했습니다. 그래서 여러분의 프로젝트에도 실제 가치를 제공할 수 있다고 자신합니다. 이 패키지는 플랫폼에 구애받지 않으며 dbt에서 지원하는 모든 대상과 함께 사용할 수 있습니다.</p>\n<p>이 프로젝트는 GitHub에서 유지되고 PyPI에서도 사용할 수 있습니다.</p>\n<p>또한 공식 문서에서 더 많은 세부 정보를 찾을 수 있습니다. 사실, 이 문서에서는 패키지가 제공하는 전체 기능 중 일부만 다루었습니다.</p>\n<div class=\"content-ad\"></div>\n<p>프로젝트에 기여하는 것을 장려합니다. 무언가 부족한 부분이 있으면 참여해 주시기를 바랍니다.</p>\n<p>코딩 즐기세요,</p>\n<p>Plum Data Engineering Team ❤</p>\n</body>\n</html>\n"},"__N_SSG":true}