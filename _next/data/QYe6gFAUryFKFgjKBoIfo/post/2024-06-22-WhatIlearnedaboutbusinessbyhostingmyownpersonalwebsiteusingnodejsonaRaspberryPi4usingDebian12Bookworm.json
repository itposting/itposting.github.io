{"pageProps":{"post":{"title":"Raspberry Pi 4과 Debian 12 Bookworm에 Nodejs를 사용하여 개인 웹사이트를 운영하며 배운 비즈니스 인사이트","description":"","date":"2024-06-22 19:29","slug":"2024-06-22-WhatIlearnedaboutbusinessbyhostingmyownpersonalwebsiteusingnodejsonaRaspberryPi4usingDebian12Bookworm","content":"\nTL;DR: 네, 확인해보세요 https://julianmkleber.com 시리즈 기사를 따라오면서 몇 일 동안 게임 속으로 빨려 들어갔군요. 멋지네요. 포식자들이 있더라도, 노력한다면 작은 (모델) 회사를 그들로부터 방어할 수 있다는 것을 배웠을 겁니다. 그래서 전 세계에 우리가 XMR을 채굴하여 돈을 버는 인프라를 구축할 수 있다는 것을 증명한 후, 웹사이트를 호스팅하는 것을 시작할 수 있습니다. 이 블로그 글에서는 node.js, podman, vue.js, certbot, fail2ban 및 nginx을 사용하여 정적 웹사이트를 호스팅하는 방법에 대해 설명하고 있습니다. 제 설정은 회사 설정에서 하나의 웹 프로젝트마다 연간 최소 $666을 절약합니다.\n\n![이미지](/assets/img/2024-06-22-WhatIlearnedaboutbusinessbyhostingmyownpersonalwebsiteusingnodejsonaRaspberryPi4usingDebian12Bookworm_0.png)\n\n# 서문\n\n이는 자체 호스팅된 산업 생산 환경에서 웹사이트를 개발, 유지 및 배포하기 위한 인프라를 설정할 것이기 때문에 매우 복잡합니다. APT(그래, 아직 약간의 공격성이 있습니다)에 의해 많은 사이버 공격을 받는 환경이라고 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 네트워크 준비하기\n\n네트워크를 분할하여 방화벽 및 라우터를 사용하고 웹 사이트를 호스팅하는 서버를 분리하는 것을 권장합니다. 예를 들어 Forgejo 인스턴스가 위치한 세그먼트 외부에 위치시킵니다.\n\n# Raspberry OS 준비하기\n\n최대 성능을 위해 64비트 Debian의 최소 설치판을 선택합니다. 이미지 생성 과정에서 다음을 확인해주세요:\n\n<div class=\"content-ad\"></div>\n\n- SSH 설정하기\n- 라즈베리 파이에 적절한 이름 지정하기\n- 라우터에서 MAC 주소를 사용하여 내부 IP 주소에 묶어 컴퓨터의 스푸핑 방지하기\n\n# Bookworm으로 업그레이드하기\n\n아직 Bookworm을 사용 중이 아니라면, 다른 문서에서 설명한 대로 라즈베리를 Bookworm으로 업그레이드하려 합니다.\n\n그래서 저희들\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo nano /etc/apt/sources.list\n```\n\n그리고 저희의 sources.list를 삽입해주세요. 최근에 변경되었으니 무엇을 삽입해야 하는지 문서를 참고해주시기 바랍니다.\n\n그리고 아래 명령어를 입력해주세요.\n\n```js\nsudo apt upgrade && sudo apt update\n```\n\n<div class=\"content-ad\"></div>\n\n# 2FA를 통해 시스템을 안전하게 유지하세요\n\n서버를 유지하는 것을 쉽게 만들면서도 원치 않는 방문자를 차단하기 위해 SSH 서버에 내부적으로 키와 비밀번호를 사용하여 인증할 것입니다.\n\n# 다수의 키 보유\n\n다수의 키를 보유하고 있다면 문제에 직면할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n따라서 올바른 인증 방법을 수동으로 추가해야 합니다. 자세한 내용은 블로그 게시물을 확인해 주세요.\n\n2단계 인증을 추가하려면 \"Standard behaviour\" 부분을 참고하시면 됩니다.\n\n# Standard behaviour\n\n저의 코드베르그에서 다음 명령을 따라할 수 있습니다. 먼저 컴퓨터에 추가하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nssh-keygen\ncat ~/.ssh/id_rsa.pub | ssh username@remote_host \"mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys\"\nssh-add path-to-priv-key\n```\n\n라즈베리 파이에서\n\n```js\nsudo nano /etc/ssh/sshd_config\n```\n\n라인 2에 삽입하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nAuthenticationMethods publickey,password\n```\n\n그런 다음 즐겨 사용하는 명령어를 실행하세요\n\n```js\nsudo systemctl daemon-reload && sudo systemctl restart sshd && sudo systemctl status sshd\n```\n\n# 컨테이너 만들기\n\n<div class=\"content-ad\"></div>\n\n우리는 Vuepress 웹사이트를 호스팅하려고 합니다. 그를 위해서는 node.js가 필요합니다. 컨테이너를 사용하여 노드 배포에 대한 실습을 해보기 위해 컨테이너를 설정할 것입니다.\n\n이를 위해 컨테이너를 만들고 레지스트리에 푸시한 다음 라즈베리 파이 4에서 다운로드할 것입니다.\n\n운이 좋게도, 이 작업은 간단하며 Codium을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo apt install podman\n```\n\n그런 다음, 저장소에 다음을 추가해줍니다.\n\n```js\ntouch Containerfile\n```\n\n그리고 구성을 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nFROM docker.io/node:lts-alpine\nENV NODE_ENV=production\nCOPY [\"package.json\", \"package-lock.json*\", \"npm-shrinkwrap.json*\", \"./\"]\nRUN npm install --production --silent\nRUN npm install -g serve\nCOPY ./docs/.vuepress/dist .\nEXPOSE 3000\nUSER node\nCMD serve ./dist\n```\n\n# harp00n을 사용하여 스테이징 서버 설정하기\n\n가끔씩 우리는 응용 프로그램을 개발하기 위해 시스템에서 노드를 사용할 수 있습니다. 이는 보안 취약점을 유발할 수 있어 프로덕션 서버에서는 그렇게 하고 싶지 않습니다.\n\n하지만, 이제 어떻게 애플리케이션을 레지스트리에 배포할 수 있을까요? 워크플로우는 꽤 단순합니다. 우리는 개발 머신에서 개발합니다 (보안 상의 이유로 웹 서비스와 통신할 수 없을 수 있음). 그리고 코드를 리포지토리에 푸시합니다. 그런 다음 코드 리뷰를 하고 코드를 스테이징 브랜치에 커밋합니다 (메인일 수도 있고 아닐 수도 있음 — 당신의 취향에 따라 다름). 그런 다음 스테이징 서버의 웹 후크가 트리거되어 컨테이너를 빌드하고 레지스트리에 컨테이너를 푸시하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-WhatIlearnedaboutbusinessbyhostingmyownpersonalwebsiteusingnodejsonaRaspberryPi4usingDebian12Bookworm_1.png\" />\n\n이상적으로는 프로덕션 머신의 웹 후크가 트리거되어 컨테이너 레지스트리에서 새 웹사이트를 가져 오게됩니다.\n\n그것은 꽤 간단한 일이죠? 오케이, 아마도 자체 블로그 기사가 필요할지도 모르겠네요... :)\n\n## 보안 고려 사항\n\n<div class=\"content-ad\"></div>\n\n배포 파이프라인은 우리 인프라의 마지막 구성 요소 중 하나로, 클라우드의 많은 표준 도구의 오버헤드와 보안 문제 없이 어느 정도 알찬 파이프라인을 실행할 수 있습니다. 어떻게냐고요? 제한된 종속성을 사용하여 필요한 최소한의 것들만 구축했기 때문입니다.\n\n우리 인프라의 공격 표면은 상당히 낮습니다. 유지 보수 비용 문제라고 주장할 수도 있겠지만, 지원 요원에게 전화하고 티켓을 기다리며 한 달에 여러 번 이를 반복하는 것 또한 유지 보수 비용으로 볼 수 있습니다. 예를 들면 저는 이로 인해 프리랜싱 플랫폼에서 떠나고 마케팅 인프라를 직접 운영하게 되었습니다.\n\n꼭 확인해 보세요!\n\n먼저, 웹 서버 애플리케이션을 설정하여 웹훅 상호작용을 처리합니다.\n\n<div class=\"content-ad\"></div>\n\n# 배포\n\n그런 다음 배포 스크립트를 설정합니다.\n\n```js\ntouch deploy.sh\n```\n\n필요한 명령어를 삽입합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\npodman build -t personal-website\npodman\n```\n\n위 명령어는 vuepress 사이트를 분배(dist)로 컴파일하고, node-alpine-LTS 이미지에서 노드 컨테이너를 만들어 레지스트리에 푸쉬하는 작업을 수행합니다.\n\n자주 사용하려면, 다음을 실행하세요.\n\n```js\nchmod u+x deploy.sh\n./deploy.sh\n```\n\n<div class=\"content-ad\"></div>\n\n이제 레지스트리에서 RPi4에서 그것을 가져올 수 있습니다.\n\n## 웹사이트 호스팅을 위한 데몬 설정\n\n따라서 라즈베리파이가 종료된 경우, 다시 부팅될 때 데몬을 다시 시작하여 다운타임을 최소화하려고 합니다.\n\n만약 더 적은 다운타임을 원한다면, 로드 밸런서와 여러 대의 기기가 웹사이트를 호스팅하는 환경을 구축할 수도 있습니다. 이 프로젝트에는 다소 복잡해 보일 수 있지만, 더 큰 프로젝트들이 곧 그런 요구사항이 필요할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 역방향 프록시 설정\n\n```js\nsudo apt install nginx\nsudo systemctl enable nginx && sudo systemctl status nginx\n```\n\nDDoS 보호를 위해 다음을 추가하려고 합니다:\n\n```js\nserver {\n    ...\n    limit_req zone=perip burst=5 nodelay;\n    limit_req zone=perserver burst=10;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n따라서, 우리의 구성은 다음과 같습니다:\n\n```js\nserver {\n    limit_req zone=perip burst=5 nodelay;\n    limit_req zone=perserver burst=10;\n\n    listen 443 http2 ssl;\n    listen [::]:443 http2 ssl;\n\n    ssl_certificate /etc/ssl/certs/julianmkleber.crt;\n    ssl_certificate_key /etc/ssl/private/julianmkleber.key;\n    ssl_dhparam /etc/ssl/certs/dhparam.pem;\n\n    server_name hostname ipaddress;\n\n    location / {\n        proxy_pass http://127.0.0.1:3000;\n        include proxy_params;\n    }\n}\n\nserver {\n    limit_req zone=perip burst=5 nodelay;\n    limit_req zone=perserver burst=10;\n    listen 80;\n    server_name ipaddress hostname;\n\n    # 모든 서브도메인에 대한 HTTP에서 HTTPS로의 리다이렉션\n    return 301 https://$host$request_uri;\n}\n```\n\n# 방화벽 설정\n\n네, 방화벽 없이 서버를 외부 세계에 노출시킬 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 이미 좋은 방화벽 규칙을 알고 있어요. 이번에는 iptables-persistent 패키지를 사용하지 않고 방화벽 서비스를 직접 만들 거에요 (방화벽을 설정하는 다른 관점을 얻기 위해서죠). 솔직히 말해서, 이 방법이 더 유연하게 보이기 때문에 나는 이 접근 방식을 더 좋아해요.\n\n먼저, 모든 규칙들을 설정해봐요.\n\n```js\nsudo iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\nsudo iptables -I INPUT -p tcp --dport 80 -j ACCEPT #http 포트\nsudo iptables -I INPUT -p tcp --dport 443 -j ACCEPT #https 포트\nsudo iptables -I INPUT -p tcp --dport 22 -j ACCEPT\nsudo iptables -I INPUT -p tcp --dport 5000 -j ACCEPT\nsudo iptables -A INPUT -p icmp --icmp-type 0 -m state --state ESTABLISHED,RELATED -j ACCEPT\nsudo iptables -A INPUT -i lo -j ACCEPT\nsudo iptables -A INPUT -j DROP\nsudo iptables -A INPUT -s 192.168.178.0/24  -j ACCEPT #공개 접근 피하기\nsudo iptables -I OUTPUT -d 192.168.1.0/24  -p tcp --dport 22 -j REJECT #서브넷으로 SSH 발신 차단\n```\n\n이 규칙들이 무엇을 하는지 궁금하죠?\n\n<div class=\"content-ad\"></div>\n\n- 서버로의 로컬 액세스를 ssh를 통해 제한합니다.\n- 외부 통신을 위한 리버스 프록시 포트 이외의 모든 포트의 모든 연결을 차단합니다.\n- 외부 ssh 제한\n\n그런 다음 덤프 결과를 파일에 저장합니다.\n\n```js\nsudo mkdir -p /usr/share/iptables/\nsudo touch /usr/share/iptables/iptables.conf\n```\n\n그런 다음 덤프를 복사합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo iptables-save\n```\n\n위 명령어를\n\n```js\nsudo nano /usr/share/iptables/iptables.conf\n```\n\n에 붙여넣기하세요. 먼저 실행 파일을 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n```bash\nsudo nano /usr/share/iptables/restore.sh\n```\n\n그리고 다음 내용을 추가하세요.\n\n```bash\n#!/bin/sh\n/usr/bin/flock /run/.iptables-restore /sbin/iptables-restore < /usr/share/iptables/iptables.conf\n```\n\n그리고 실행 가능하도록 변경하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo chmod u+x /usr/share/iptables/restore.sh\n```\n\n그런 다음, 다음과 같이 서비스를 설정합니다.\n\n```js\nsudo nano /etc/systemd/system/iptables-persistent.service\n```\n\n그리고 다음을 삽입하십시오.\n\n<div class=\"content-ad\"></div>\n\n[Unit]\nDescription=부팅 시 iptables restore를 실행합니다.\nConditionFileIsExecutable=/usr/share/iptables/restore.sh\nAfter=network.target\n\n[Service]\nType=forking\nExecStart=/usr/share/iptables/restore.sh\nTimeoutStartSec=0\nRemainAfterExit=yes\nGuessMainPID=no\n\n[Install]\nWantedBy=multi-user.target\n\n마지막으로, 세 가지 좋아하는 명령어를 실행해봅시다.\n\nsudo systemctl daemon-reload && sudo systemctl enable iptables-persistent.service && sudo systemctl start iptables-persistent.service && sudo systemctl status iptables-persistent.service\n\n이제 작동하는지 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n작동 여부를 확인하기 위해 시스템을 다시 시작하고 규칙을 확인해요\n\n```js\nsudo reboot\nsudo iptables -S\n```\n\n# Fail2Ban 설정\n\nDDoS 공격 및 기타 보안 위협을 피하기 위해 fail2ban을 설치할 거에요.\n\n<div class=\"content-ad\"></div>\n\n이것은 꽤 쉬워요. 다음과 같이 입력하세요.\n\n```js\nsudo apt install fail2ban -y\n```\n\nfail2ban이 오류와 함께 시작되지만, 우리는 이 오류를 수정하기 위해 구성을 수정하기만 하면 됩니다.\n\n우리에게 있어서 중요한 것은 SSH 브루트포스 공격자의 원격 IP와 내부 IP 모두에 대한 차단입니다 — 방화벽을 통해 그것을 제한할 예정이지만, 다른 서버에서 사고가 발생했을 경우를 대비해서요.\n\n<div class=\"content-ad\"></div>\n\n그럼, 먼저 테이블 태그를 Markdown 형식으로 바꿔보세요.\n\n```js\nsudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local\nsudo nano /etc/fail2ban/jail.local\n```\n\n그 다음 아래에 아래와 같이 삽입해 주세요.\n\n```js\n[sshd]\nenabled = true\nport = ssh\nfilter = sshd\nbackend=systemd\nlogpath = /var/log/auth.log\nmaxretry = 4\nbantime = 366\nignoreip = whitelist-IP\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로, nginx 웹 서버에서 DDoS 공격을 차단하려고 합니다:\n\n그래서, 아래 내용을 추가합니다.\n\n```js\nsudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local\nsudo nano /etc/fail2ban/jail.local\n```\n\n<div class=\"content-ad\"></div>\n\n```ini\n[nginx-req-limit]\n\nenabled = true\nfilter = nginx-req-limit\naction = iptables-multiport[name=ReqLimit, port=\"http,https\", protocol=tcp]\nlogpath = /var/log/nginx/*error.log\nfindtime = 600\nbantime = 7200\nmaxretry = 10\n```\n\nNginx 구성 파일 편집\n\n우리는 다음을 삽입합니다.\n\n```sh\nsudo nano /etc/nginx/nginx.conf\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nlimit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;\nlimit_req_zone $server_name zone=perserver:10m rate=100r/s;\n```\n\nI increased the parameters, so that even if many people visit my website at the same time (like when I give talks and the traffic spikes), it can handle the load.\n\nIn the server configuration block of our reverse proxy, we need to add another line (details are also provided in the respective section).\n\n<div class=\"content-ad\"></div>\n\n```js\nserver {\n    ...\n    limit_req zone=perip burst=5 nodelay;\n    limit_req zone=perserver burst=10;\n}\n```\n\n# 신뢰할 수 있는 SSL 인증서 생성하기\n\n## 인증서 제공업체에서 인증서 설치\n\n그럼 이제 이전과는 다르게 셀프 사인한 인증서를 생성하는 게 아니라, 인증서 기관(CA)에서 인증서를 얻는 방법에 대해 알아봅시다. 안전하다고 느껴진다면 제공업체에서 제공하는 인증서를 선택해보세요.\n\n<div class=\"content-ad\"></div>\n\n## Letsencrypt에서 SSL 인증서 설치하기\n\n이 과정에서는 서버가 이미 기능적이고 인터넷에서 접근 가능해야 합니다.\n\n보안상의 이유로 Letsencrypt를 사용할 것입니다(도메인 제공업체의 인증서가 손상됐을 지 모르기 때문에). 우리는 우리가 \"신뢰할 수 없는\" 인증서를 사용한다고 웹 브라우저를 달래기 위해 CA가 필요합니다. 저는 그것이 큰 헛소리라고 생각하고, 사실로 인해 상황을 더 복잡하게 만드는 것 같아요.\n\n## 자체 서명 인증서는 정말로 안전할 수 있어요\n\n<div class=\"content-ad\"></div>\n\n\"신뢰할 수없는 인증서의 개념에는 많은 결함이 있다는 것을 고려하는 것은 가치가 있습니다. 실제로, 저는 위에서 설명한대로 훼손된 신뢰할 수 있는 인증서를 가질 수 있으며 그 반대도 가능합니다. 그러나 사이버 보안은 돈이 관련될 때 항상 의미가 있는 것은 아니죠…\n\n## Let'sencrypt에서 민주적 인증서 요청하기\n\n솔직히 말해서, 이 워크플로우는 정말 복잡하다고 생각합니다.\n\n이 작업을 수행하려면 도메인의 소유권을 확인해야 합니다. 한 가지 방법은 HTTP 서버를 호스팅하는 것입니다. 배포 서버에 추가 소프트웨어를 설치하는 것을 원하지 않으므로 nginx를 사용합니다. 우리는 분명히 http-port가 필요하지 않습니다. 따라서 다음과 같이 합니다:\"\n\n<div class=\"content-ad\"></div>\n\n```js\n    server {\n        listen 80;\n        server_name apis.lemariva.com;\n        location ^~ /.well-known {\n            root /etc/nginx/ssl/bot;\n        }\n        location / {\n            return 301 https://$host$request_uri;\n        }\n    }\n```\n\n- \\*주의: 확인 후에 이 연결을 닫으세요\\*\\*\n\n데몬이 실행 중인 경우에만 사용하고 서비스가 인증서를 갱신할 때 사용하지 않는 두 개의 백업된 nginx 설정 파일을 보유하는 방식으로 이 작업을 수행할 수 있습니다.\n\nCertbot로 돌아가 봅시다. Let's encrypt가 인증서를 수동으로 설치할 수 있도록 certbot을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\nsnap은 권장하지 않습니다(사용하기 어렵다고 생각하기 때문에). 대신 podman에서 certbot을 사용할 거에요(certbot을 podman에서 사용하는 방법이 문서화되지 않았으니 제가 문서로 만들었어요).\n\n```js\nsudo apt install podman\n```\n\n그리고 podman으로 실행해봐요\n\n```js\nsudo mkdir -p /etc/letsencrypt\nsudo mkdir -p /var/lib/letsencrypt\nsudo podman run -it --rm --name certbot \\\n            -v \"/etc/letsencrypt:/etc/letsencrypt\" \\\n            -v \"/var/lib/letsencrypt:/var/lib/letsencrypt\" \\\n            docker.io/certbot/certbot certonly\n```\n\n<div class=\"content-ad\"></div>\n\n그러나 그 방법이 실패한다면 수동 모드를 시도해 볼 수 있어요.\n\n```js\nsudo apt install certbot\nsudo certbot certonly --manual\n```\n\n그 후 안내에 따라 진행해주세요.\n\n반드시 매 90일마다 해당 작업을 수행하도록 하세요. 더 나은 방법은 프로시저를 자동화하는 것이겠죠.\n\n<div class=\"content-ad\"></div>\n\n다른 방법은 DNS를 통해 확인하는 것입니다. 하지만, 이 방법을 사용하려면 서드 파티 패키지가 필요하며, 개발 프로세스 초기에 가능한 한 많은 위험을 줄이기 위해 서버를 가능한 깨끗하게 유지하려 합니다.\n\n## 인증서 자동 갱신을 위한 certbot.service 설정\n\n프로시저를 자동화하기 위해 데몬을 설정하겠습니다. 이 시리즈를 따라오셨다면, 다음 단계는 이미 표준 작업 목록에 포함되어 있어야 합니다.\n\n```js\nsudo nano /etc/systemd/system/cerbot.service\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 아래의 작업을 추가해 주세요.\n\n```sh\n#!/bin/sh\n\ncertbot renew\nsystemctl restart nginx\n```\n\n그리고 아래의 명령어를 실행해 주세요.\n\n```sh\nsudo systemctl enable certbot.service && sudo systemctl start certbot.service && sudo systemctl status cerbot.service\n```\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n오케이, 와아 휴😅. 정말 많았지요. 여러분이 실제로 돈을 내고 사는 소프트웨어 제품들을 만들었습니다💪. 그러나 괜찮아요 — 돈도 부족하고 시간도 부족해서 우리 일이죠. 우리는 비양식되고 비획기적인 소프트웨어 도구들을 사용할 시간이나 돈이 충분하지 않다는 거죠.\n\n## 혜택:\n\n세 명으로 이루어진 회사를 운영한다고 가정했을 때, 백엔드 작업 및 내부 웹 애플리케이션용으로 8코어 미니 서버를 350달러에 구입했습니다. 라즈베리 파이는 약 130달러했어요.\n\n<div class=\"content-ad\"></div>\n\n저는 단순한 혜택 계산을 하고 싶을 뿐입니다: 매년 사용자 당 $252을 지불하면 코드 호스팅과 CI를 위한 Github 통합($756)을 이용할 수 있습니다. 8 코어 머신에서 백엔드로 업그레이드 가능한 웹사이트 호스팅은 AWS에서 $867.90 입니다. $169/y에 웹플로우 호스팅도 제공됩니다. SSL 인증서 구매시 약 $10/y의 비용이 발생합니다. 해당 설정으로 연간 약 $666의 비용을 절안할 수 있습니다(이 숫자는 우연히 나온 숫자에 불과합니다). 물론 전기비는 포함되지 않았습니다. 이 비용으로 한 달 동안 주당 10시간씩 일하는 직원을 고용할 수 있습니다. 지수적으로 증가하기 때문에, 새로운 웹사이트를 추가하는 데 거의 비용이 들지 않으며, GitHub 수준의 연간 요금을 내야하는 내부 및 외부 서비스를 호스팅할 수도 있습니다.\n\n# 도움이 되는 기사\n\nhttps://easyengine.io/tutorials/nginx/fail2ban/\n","ogImage":{"url":"/assets/img/2024-06-22-WhatIlearnedaboutbusinessbyhostingmyownpersonalwebsiteusingnodejsonaRaspberryPi4usingDebian12Bookworm_0.png"},"coverImage":"/assets/img/2024-06-22-WhatIlearnedaboutbusinessbyhostingmyownpersonalwebsiteusingnodejsonaRaspberryPi4usingDebian12Bookworm_0.png","tag":["Tech"],"readingTime":14},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>TL;DR: 네, 확인해보세요 <a href=\"https://julianmkleber.com\" rel=\"nofollow\" target=\"_blank\">https://julianmkleber.com</a> 시리즈 기사를 따라오면서 몇 일 동안 게임 속으로 빨려 들어갔군요. 멋지네요. 포식자들이 있더라도, 노력한다면 작은 (모델) 회사를 그들로부터 방어할 수 있다는 것을 배웠을 겁니다. 그래서 전 세계에 우리가 XMR을 채굴하여 돈을 버는 인프라를 구축할 수 있다는 것을 증명한 후, 웹사이트를 호스팅하는 것을 시작할 수 있습니다. 이 블로그 글에서는 node.js, podman, vue.js, certbot, fail2ban 및 nginx을 사용하여 정적 웹사이트를 호스팅하는 방법에 대해 설명하고 있습니다. 제 설정은 회사 설정에서 하나의 웹 프로젝트마다 연간 최소 $666을 절약합니다.</p>\n<p><img src=\"/assets/img/2024-06-22-WhatIlearnedaboutbusinessbyhostingmyownpersonalwebsiteusingnodejsonaRaspberryPi4usingDebian12Bookworm_0.png\" alt=\"이미지\"></p>\n<h1>서문</h1>\n<p>이는 자체 호스팅된 산업 생산 환경에서 웹사이트를 개발, 유지 및 배포하기 위한 인프라를 설정할 것이기 때문에 매우 복잡합니다. APT(그래, 아직 약간의 공격성이 있습니다)에 의해 많은 사이버 공격을 받는 환경이라고 합니다.</p>\n<div class=\"content-ad\"></div>\n<h1>네트워크 준비하기</h1>\n<p>네트워크를 분할하여 방화벽 및 라우터를 사용하고 웹 사이트를 호스팅하는 서버를 분리하는 것을 권장합니다. 예를 들어 Forgejo 인스턴스가 위치한 세그먼트 외부에 위치시킵니다.</p>\n<h1>Raspberry OS 준비하기</h1>\n<p>최대 성능을 위해 64비트 Debian의 최소 설치판을 선택합니다. 이미지 생성 과정에서 다음을 확인해주세요:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>SSH 설정하기</li>\n<li>라즈베리 파이에 적절한 이름 지정하기</li>\n<li>라우터에서 MAC 주소를 사용하여 내부 IP 주소에 묶어 컴퓨터의 스푸핑 방지하기</li>\n</ul>\n<h1>Bookworm으로 업그레이드하기</h1>\n<p>아직 Bookworm을 사용 중이 아니라면, 다른 문서에서 설명한 대로 라즈베리를 Bookworm으로 업그레이드하려 합니다.</p>\n<p>그래서 저희들</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">sudo nano /etc/apt/sources.<span class=\"hljs-property\">list</span>\n</code></pre>\n<p>그리고 저희의 sources.list를 삽입해주세요. 최근에 변경되었으니 무엇을 삽입해야 하는지 문서를 참고해주시기 바랍니다.</p>\n<p>그리고 아래 명령어를 입력해주세요.</p>\n<pre><code class=\"hljs language-js\">sudo apt upgrade &#x26;&#x26; sudo apt update\n</code></pre>\n<div class=\"content-ad\"></div>\n<h1>2FA를 통해 시스템을 안전하게 유지하세요</h1>\n<p>서버를 유지하는 것을 쉽게 만들면서도 원치 않는 방문자를 차단하기 위해 SSH 서버에 내부적으로 키와 비밀번호를 사용하여 인증할 것입니다.</p>\n<h1>다수의 키 보유</h1>\n<p>다수의 키를 보유하고 있다면 문제에 직면할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>따라서 올바른 인증 방법을 수동으로 추가해야 합니다. 자세한 내용은 블로그 게시물을 확인해 주세요.</p>\n<p>2단계 인증을 추가하려면 \"Standard behaviour\" 부분을 참고하시면 됩니다.</p>\n<h1>Standard behaviour</h1>\n<p>저의 코드베르그에서 다음 명령을 따라할 수 있습니다. 먼저 컴퓨터에 추가하세요:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">ssh-keygen\ncat ~<span class=\"hljs-regexp\">/.ssh/i</span>d_rsa.<span class=\"hljs-property\">pub</span> | ssh username@remote_host <span class=\"hljs-string\">\"mkdir -p ~/.ssh &#x26;&#x26; cat >> ~/.ssh/authorized_keys\"</span>\nssh-add path-to-priv-key\n</code></pre>\n<p>라즈베리 파이에서</p>\n<pre><code class=\"hljs language-js\">sudo nano /etc/ssh/sshd_config\n</code></pre>\n<p>라인 2에 삽입하세요.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">AuthenticationMethods</span> publickey,password\n</code></pre>\n<p>그런 다음 즐겨 사용하는 명령어를 실행하세요</p>\n<pre><code class=\"hljs language-js\">sudo systemctl daemon-reload &#x26;&#x26; sudo systemctl restart sshd &#x26;&#x26; sudo systemctl status sshd\n</code></pre>\n<h1>컨테이너 만들기</h1>\n<div class=\"content-ad\"></div>\n<p>우리는 Vuepress 웹사이트를 호스팅하려고 합니다. 그를 위해서는 node.js가 필요합니다. 컨테이너를 사용하여 노드 배포에 대한 실습을 해보기 위해 컨테이너를 설정할 것입니다.</p>\n<p>이를 위해 컨테이너를 만들고 레지스트리에 푸시한 다음 라즈베리 파이 4에서 다운로드할 것입니다.</p>\n<p>운이 좋게도, 이 작업은 간단하며 Codium을 사용할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">sudo apt install podman\n</code></pre>\n<p>그런 다음, 저장소에 다음을 추가해줍니다.</p>\n<pre><code class=\"hljs language-js\">touch <span class=\"hljs-title class_\">Containerfile</span>\n</code></pre>\n<p>그리고 구성을 추가합니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-variable constant_\">FROM</span> docker.<span class=\"hljs-property\">io</span>/<span class=\"hljs-attr\">node</span>:lts-alpine\n<span class=\"hljs-variable constant_\">ENV</span> <span class=\"hljs-variable constant_\">NODE_ENV</span>=production\n<span class=\"hljs-variable constant_\">COPY</span> [<span class=\"hljs-string\">\"package.json\"</span>, <span class=\"hljs-string\">\"package-lock.json*\"</span>, <span class=\"hljs-string\">\"npm-shrinkwrap.json*\"</span>, <span class=\"hljs-string\">\"./\"</span>]\n<span class=\"hljs-variable constant_\">RUN</span> npm install --production --silent\n<span class=\"hljs-variable constant_\">RUN</span> npm install -g serve\n<span class=\"hljs-variable constant_\">COPY</span> ./docs/.<span class=\"hljs-property\">vuepress</span>/dist .\n<span class=\"hljs-variable constant_\">EXPOSE</span> <span class=\"hljs-number\">3000</span>\n<span class=\"hljs-variable constant_\">USER</span> node\n<span class=\"hljs-variable constant_\">CMD</span> serve ./dist\n</code></pre>\n<h1>harp00n을 사용하여 스테이징 서버 설정하기</h1>\n<p>가끔씩 우리는 응용 프로그램을 개발하기 위해 시스템에서 노드를 사용할 수 있습니다. 이는 보안 취약점을 유발할 수 있어 프로덕션 서버에서는 그렇게 하고 싶지 않습니다.</p>\n<p>하지만, 이제 어떻게 애플리케이션을 레지스트리에 배포할 수 있을까요? 워크플로우는 꽤 단순합니다. 우리는 개발 머신에서 개발합니다 (보안 상의 이유로 웹 서비스와 통신할 수 없을 수 있음). 그리고 코드를 리포지토리에 푸시합니다. 그런 다음 코드 리뷰를 하고 코드를 스테이징 브랜치에 커밋합니다 (메인일 수도 있고 아닐 수도 있음 — 당신의 취향에 따라 다름). 그런 다음 스테이징 서버의 웹 후크가 트리거되어 컨테이너를 빌드하고 레지스트리에 컨테이너를 푸시하게 됩니다.</p>\n<div class=\"content-ad\"></div>\n<img src=\"/assets/img/2024-06-22-WhatIlearnedaboutbusinessbyhostingmyownpersonalwebsiteusingnodejsonaRaspberryPi4usingDebian12Bookworm_1.png\">\n<p>이상적으로는 프로덕션 머신의 웹 후크가 트리거되어 컨테이너 레지스트리에서 새 웹사이트를 가져 오게됩니다.</p>\n<p>그것은 꽤 간단한 일이죠? 오케이, 아마도 자체 블로그 기사가 필요할지도 모르겠네요... :)</p>\n<h2>보안 고려 사항</h2>\n<div class=\"content-ad\"></div>\n<p>배포 파이프라인은 우리 인프라의 마지막 구성 요소 중 하나로, 클라우드의 많은 표준 도구의 오버헤드와 보안 문제 없이 어느 정도 알찬 파이프라인을 실행할 수 있습니다. 어떻게냐고요? 제한된 종속성을 사용하여 필요한 최소한의 것들만 구축했기 때문입니다.</p>\n<p>우리 인프라의 공격 표면은 상당히 낮습니다. 유지 보수 비용 문제라고 주장할 수도 있겠지만, 지원 요원에게 전화하고 티켓을 기다리며 한 달에 여러 번 이를 반복하는 것 또한 유지 보수 비용으로 볼 수 있습니다. 예를 들면 저는 이로 인해 프리랜싱 플랫폼에서 떠나고 마케팅 인프라를 직접 운영하게 되었습니다.</p>\n<p>꼭 확인해 보세요!</p>\n<p>먼저, 웹 서버 애플리케이션을 설정하여 웹훅 상호작용을 처리합니다.</p>\n<div class=\"content-ad\"></div>\n<h1>배포</h1>\n<p>그런 다음 배포 스크립트를 설정합니다.</p>\n<pre><code class=\"hljs language-js\">touch deploy.<span class=\"hljs-property\">sh</span>\n</code></pre>\n<p>필요한 명령어를 삽입합니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">podman build -t personal-website\npodman\n</code></pre>\n<p>위 명령어는 vuepress 사이트를 분배(dist)로 컴파일하고, node-alpine-LTS 이미지에서 노드 컨테이너를 만들어 레지스트리에 푸쉬하는 작업을 수행합니다.</p>\n<p>자주 사용하려면, 다음을 실행하세요.</p>\n<pre><code class=\"hljs language-js\">chmod u+x deploy.<span class=\"hljs-property\">sh</span>\n./deploy.<span class=\"hljs-property\">sh</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이제 레지스트리에서 RPi4에서 그것을 가져올 수 있습니다.</p>\n<h2>웹사이트 호스팅을 위한 데몬 설정</h2>\n<p>따라서 라즈베리파이가 종료된 경우, 다시 부팅될 때 데몬을 다시 시작하여 다운타임을 최소화하려고 합니다.</p>\n<p>만약 더 적은 다운타임을 원한다면, 로드 밸런서와 여러 대의 기기가 웹사이트를 호스팅하는 환경을 구축할 수도 있습니다. 이 프로젝트에는 다소 복잡해 보일 수 있지만, 더 큰 프로젝트들이 곧 그런 요구사항이 필요할 수도 있습니다.</p>\n<div class=\"content-ad\"></div>\n<h1>역방향 프록시 설정</h1>\n<pre><code class=\"hljs language-js\">sudo apt install nginx\nsudo systemctl enable nginx &#x26;&#x26; sudo systemctl status nginx\n</code></pre>\n<p>DDoS 보호를 위해 다음을 추가하려고 합니다:</p>\n<pre><code class=\"hljs language-js\">server {\n    ...\n    limit_req zone=perip burst=<span class=\"hljs-number\">5</span> nodelay;\n    limit_req zone=perserver burst=<span class=\"hljs-number\">10</span>;\n}\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>따라서, 우리의 구성은 다음과 같습니다:</p>\n<pre><code class=\"hljs language-js\">server {\n    limit_req zone=perip burst=<span class=\"hljs-number\">5</span> nodelay;\n    limit_req zone=perserver burst=<span class=\"hljs-number\">10</span>;\n\n    listen <span class=\"hljs-number\">443</span> http2 ssl;\n    listen [::]:<span class=\"hljs-number\">443</span> http2 ssl;\n\n    ssl_certificate /etc/ssl/certs/julianmkleber.<span class=\"hljs-property\">crt</span>;\n    ssl_certificate_key /etc/ssl/private/julianmkleber.<span class=\"hljs-property\">key</span>;\n    ssl_dhparam /etc/ssl/certs/dhparam.<span class=\"hljs-property\">pem</span>;\n\n    server_name hostname ipaddress;\n\n    location / {\n        proxy_pass <span class=\"hljs-attr\">http</span>:<span class=\"hljs-comment\">//127.0.0.1:3000;</span>\n        include proxy_params;\n    }\n}\n\nserver {\n    limit_req zone=perip burst=<span class=\"hljs-number\">5</span> nodelay;\n    limit_req zone=perserver burst=<span class=\"hljs-number\">10</span>;\n    listen <span class=\"hljs-number\">80</span>;\n    server_name ipaddress hostname;\n\n    # 모든 서브도메인에 대한 <span class=\"hljs-variable constant_\">HTTP</span>에서 <span class=\"hljs-variable constant_\">HTTPS</span>로의 리다이렉션\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">301</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//$host$request_uri;</span>\n}\n</code></pre>\n<h1>방화벽 설정</h1>\n<p>네, 방화벽 없이 서버를 외부 세계에 노출시킬 수 없습니다.</p>\n<div class=\"content-ad\"></div>\n<p>우리는 이미 좋은 방화벽 규칙을 알고 있어요. 이번에는 iptables-persistent 패키지를 사용하지 않고 방화벽 서비스를 직접 만들 거에요 (방화벽을 설정하는 다른 관점을 얻기 위해서죠). 솔직히 말해서, 이 방법이 더 유연하게 보이기 때문에 나는 이 접근 방식을 더 좋아해요.</p>\n<p>먼저, 모든 규칙들을 설정해봐요.</p>\n<pre><code class=\"hljs language-js\">sudo iptables -A <span class=\"hljs-variable constant_\">INPUT</span> -m state --state <span class=\"hljs-variable constant_\">ESTABLISHED</span>,<span class=\"hljs-variable constant_\">RELATED</span> -j <span class=\"hljs-variable constant_\">ACCEPT</span>\nsudo iptables -I <span class=\"hljs-variable constant_\">INPUT</span> -p tcp --dport <span class=\"hljs-number\">80</span> -j <span class=\"hljs-variable constant_\">ACCEPT</span> #http 포트\nsudo iptables -I <span class=\"hljs-variable constant_\">INPUT</span> -p tcp --dport <span class=\"hljs-number\">443</span> -j <span class=\"hljs-variable constant_\">ACCEPT</span> #https 포트\nsudo iptables -I <span class=\"hljs-variable constant_\">INPUT</span> -p tcp --dport <span class=\"hljs-number\">22</span> -j <span class=\"hljs-variable constant_\">ACCEPT</span>\nsudo iptables -I <span class=\"hljs-variable constant_\">INPUT</span> -p tcp --dport <span class=\"hljs-number\">5000</span> -j <span class=\"hljs-variable constant_\">ACCEPT</span>\nsudo iptables -A <span class=\"hljs-variable constant_\">INPUT</span> -p icmp --icmp-type <span class=\"hljs-number\">0</span> -m state --state <span class=\"hljs-variable constant_\">ESTABLISHED</span>,<span class=\"hljs-variable constant_\">RELATED</span> -j <span class=\"hljs-variable constant_\">ACCEPT</span>\nsudo iptables -A <span class=\"hljs-variable constant_\">INPUT</span> -i lo -j <span class=\"hljs-variable constant_\">ACCEPT</span>\nsudo iptables -A <span class=\"hljs-variable constant_\">INPUT</span> -j <span class=\"hljs-variable constant_\">DROP</span>\nsudo iptables -A <span class=\"hljs-variable constant_\">INPUT</span> -s <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.178</span><span class=\"hljs-number\">.0</span>/<span class=\"hljs-number\">24</span>  -j <span class=\"hljs-variable constant_\">ACCEPT</span> #공개 접근 피하기\nsudo iptables -I <span class=\"hljs-variable constant_\">OUTPUT</span> -d <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.1</span><span class=\"hljs-number\">.0</span>/<span class=\"hljs-number\">24</span>  -p tcp --dport <span class=\"hljs-number\">22</span> -j <span class=\"hljs-variable constant_\">REJECT</span> #서브넷으로 <span class=\"hljs-variable constant_\">SSH</span> 발신 차단\n</code></pre>\n<p>이 규칙들이 무엇을 하는지 궁금하죠?</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>서버로의 로컬 액세스를 ssh를 통해 제한합니다.</li>\n<li>외부 통신을 위한 리버스 프록시 포트 이외의 모든 포트의 모든 연결을 차단합니다.</li>\n<li>외부 ssh 제한</li>\n</ul>\n<p>그런 다음 덤프 결과를 파일에 저장합니다.</p>\n<pre><code class=\"hljs language-js\">sudo mkdir -p /usr/share/iptables/\nsudo touch /usr/share/iptables/iptables.<span class=\"hljs-property\">conf</span>\n</code></pre>\n<p>그런 다음 덤프를 복사합니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">sudo iptables-save\n</code></pre>\n<p>위 명령어를</p>\n<pre><code class=\"hljs language-js\">sudo nano /usr/share/iptables/iptables.<span class=\"hljs-property\">conf</span>\n</code></pre>\n<p>에 붙여넣기하세요. 먼저 실행 파일을 만듭니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-bash\">sudo nano /usr/share/iptables/restore.sh\n</code></pre>\n<p>그리고 다음 내용을 추가하세요.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/bin/sh</span>\n/usr/bin/flock /run/.iptables-restore /sbin/iptables-restore &#x3C; /usr/share/iptables/iptables.conf\n</code></pre>\n<p>그리고 실행 가능하도록 변경하세요.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">sudo chmod u+x /usr/share/iptables/restore.<span class=\"hljs-property\">sh</span>\n</code></pre>\n<p>그런 다음, 다음과 같이 서비스를 설정합니다.</p>\n<pre><code class=\"hljs language-js\">sudo nano /etc/systemd/system/iptables-persistent.<span class=\"hljs-property\">service</span>\n</code></pre>\n<p>그리고 다음을 삽입하십시오.</p>\n<div class=\"content-ad\"></div>\n<p>[Unit]\nDescription=부팅 시 iptables restore를 실행합니다.\nConditionFileIsExecutable=/usr/share/iptables/restore.sh\nAfter=network.target</p>\n<p>[Service]\nType=forking\nExecStart=/usr/share/iptables/restore.sh\nTimeoutStartSec=0\nRemainAfterExit=yes\nGuessMainPID=no</p>\n<p>[Install]\nWantedBy=multi-user.target</p>\n<p>마지막으로, 세 가지 좋아하는 명령어를 실행해봅시다.</p>\n<p>sudo systemctl daemon-reload &#x26;&#x26; sudo systemctl enable iptables-persistent.service &#x26;&#x26; sudo systemctl start iptables-persistent.service &#x26;&#x26; sudo systemctl status iptables-persistent.service</p>\n<p>이제 작동하는지 확인해보세요.</p>\n<div class=\"content-ad\"></div>\n<p>작동 여부를 확인하기 위해 시스템을 다시 시작하고 규칙을 확인해요</p>\n<pre><code class=\"hljs language-js\">sudo reboot\nsudo iptables -S\n</code></pre>\n<h1>Fail2Ban 설정</h1>\n<p>DDoS 공격 및 기타 보안 위협을 피하기 위해 fail2ban을 설치할 거에요.</p>\n<div class=\"content-ad\"></div>\n<p>이것은 꽤 쉬워요. 다음과 같이 입력하세요.</p>\n<pre><code class=\"hljs language-js\">sudo apt install fail2ban -y\n</code></pre>\n<p>fail2ban이 오류와 함께 시작되지만, 우리는 이 오류를 수정하기 위해 구성을 수정하기만 하면 됩니다.</p>\n<p>우리에게 있어서 중요한 것은 SSH 브루트포스 공격자의 원격 IP와 내부 IP 모두에 대한 차단입니다 — 방화벽을 통해 그것을 제한할 예정이지만, 다른 서버에서 사고가 발생했을 경우를 대비해서요.</p>\n<div class=\"content-ad\"></div>\n<p>그럼, 먼저 테이블 태그를 Markdown 형식으로 바꿔보세요.</p>\n<pre><code class=\"hljs language-js\">sudo cp /etc/fail2ban/jail.<span class=\"hljs-property\">conf</span> /etc/fail2ban/jail.<span class=\"hljs-property\">local</span>\nsudo nano /etc/fail2ban/jail.<span class=\"hljs-property\">local</span>\n</code></pre>\n<p>그 다음 아래에 아래와 같이 삽입해 주세요.</p>\n<pre><code class=\"hljs language-js\">[sshd]\nenabled = <span class=\"hljs-literal\">true</span>\nport = ssh\nfilter = sshd\nbackend=systemd\nlogpath = <span class=\"hljs-regexp\">/var/</span>log/auth.<span class=\"hljs-property\">log</span>\nmaxretry = <span class=\"hljs-number\">4</span>\nbantime = <span class=\"hljs-number\">366</span>\nignoreip = whitelist-<span class=\"hljs-variable constant_\">IP</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>다음으로, nginx 웹 서버에서 DDoS 공격을 차단하려고 합니다:</p>\n<p>그래서, 아래 내용을 추가합니다.</p>\n<pre><code class=\"hljs language-js\">sudo cp /etc/fail2ban/jail.<span class=\"hljs-property\">conf</span> /etc/fail2ban/jail.<span class=\"hljs-property\">local</span>\nsudo nano /etc/fail2ban/jail.<span class=\"hljs-property\">local</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-ini\"><span class=\"hljs-section\">[nginx-req-limit]</span>\n\n<span class=\"hljs-attr\">enabled</span> = <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-attr\">filter</span> = nginx-req-limit\n<span class=\"hljs-attr\">action</span> = iptables-multiport[name=ReqLimit, port=<span class=\"hljs-string\">\"http,https\"</span>, protocol=tcp]\n<span class=\"hljs-attr\">logpath</span> = /var/log/nginx/*error.log\n<span class=\"hljs-attr\">findtime</span> = <span class=\"hljs-number\">600</span>\n<span class=\"hljs-attr\">bantime</span> = <span class=\"hljs-number\">7200</span>\n<span class=\"hljs-attr\">maxretry</span> = <span class=\"hljs-number\">10</span>\n</code></pre>\n<p>Nginx 구성 파일 편집</p>\n<p>우리는 다음을 삽입합니다.</p>\n<pre><code class=\"hljs language-sh\">sudo nano /etc/nginx/nginx.conf\n</code></pre>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">limit_req_zone $binary_remote_addr zone=<span class=\"hljs-attr\">one</span>:10m rate=1r/s;\nlimit_req_zone $server_name zone=<span class=\"hljs-attr\">perserver</span>:10m rate=100r/s;\n</code></pre>\n<p>I increased the parameters, so that even if many people visit my website at the same time (like when I give talks and the traffic spikes), it can handle the load.</p>\n<p>In the server configuration block of our reverse proxy, we need to add another line (details are also provided in the respective section).</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">server {\n    ...\n    limit_req zone=perip burst=<span class=\"hljs-number\">5</span> nodelay;\n    limit_req zone=perserver burst=<span class=\"hljs-number\">10</span>;\n}\n</code></pre>\n<h1>신뢰할 수 있는 SSL 인증서 생성하기</h1>\n<h2>인증서 제공업체에서 인증서 설치</h2>\n<p>그럼 이제 이전과는 다르게 셀프 사인한 인증서를 생성하는 게 아니라, 인증서 기관(CA)에서 인증서를 얻는 방법에 대해 알아봅시다. 안전하다고 느껴진다면 제공업체에서 제공하는 인증서를 선택해보세요.</p>\n<div class=\"content-ad\"></div>\n<h2>Letsencrypt에서 SSL 인증서 설치하기</h2>\n<p>이 과정에서는 서버가 이미 기능적이고 인터넷에서 접근 가능해야 합니다.</p>\n<p>보안상의 이유로 Letsencrypt를 사용할 것입니다(도메인 제공업체의 인증서가 손상됐을 지 모르기 때문에). 우리는 우리가 \"신뢰할 수 없는\" 인증서를 사용한다고 웹 브라우저를 달래기 위해 CA가 필요합니다. 저는 그것이 큰 헛소리라고 생각하고, 사실로 인해 상황을 더 복잡하게 만드는 것 같아요.</p>\n<h2>자체 서명 인증서는 정말로 안전할 수 있어요</h2>\n<div class=\"content-ad\"></div>\n<p>\"신뢰할 수없는 인증서의 개념에는 많은 결함이 있다는 것을 고려하는 것은 가치가 있습니다. 실제로, 저는 위에서 설명한대로 훼손된 신뢰할 수 있는 인증서를 가질 수 있으며 그 반대도 가능합니다. 그러나 사이버 보안은 돈이 관련될 때 항상 의미가 있는 것은 아니죠…</p>\n<h2>Let'sencrypt에서 민주적 인증서 요청하기</h2>\n<p>솔직히 말해서, 이 워크플로우는 정말 복잡하다고 생각합니다.</p>\n<p>이 작업을 수행하려면 도메인의 소유권을 확인해야 합니다. 한 가지 방법은 HTTP 서버를 호스팅하는 것입니다. 배포 서버에 추가 소프트웨어를 설치하는 것을 원하지 않으므로 nginx를 사용합니다. 우리는 분명히 http-port가 필요하지 않습니다. 따라서 다음과 같이 합니다:\"</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">    server {\n        listen <span class=\"hljs-number\">80</span>;\n        server_name apis.<span class=\"hljs-property\">lemariva</span>.<span class=\"hljs-property\">com</span>;\n        location ^~ /.<span class=\"hljs-property\">well</span>-known {\n            root /etc/nginx/ssl/bot;\n        }\n        location / {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">301</span> <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//$host$request_uri;</span>\n        }\n    }\n</code></pre>\n<ul>\n<li>*주의: 확인 후에 이 연결을 닫으세요**</li>\n</ul>\n<p>데몬이 실행 중인 경우에만 사용하고 서비스가 인증서를 갱신할 때 사용하지 않는 두 개의 백업된 nginx 설정 파일을 보유하는 방식으로 이 작업을 수행할 수 있습니다.</p>\n<p>Certbot로 돌아가 봅시다. Let's encrypt가 인증서를 수동으로 설치할 수 있도록 certbot을 제공합니다.</p>\n<div class=\"content-ad\"></div>\n<p>snap은 권장하지 않습니다(사용하기 어렵다고 생각하기 때문에). 대신 podman에서 certbot을 사용할 거에요(certbot을 podman에서 사용하는 방법이 문서화되지 않았으니 제가 문서로 만들었어요).</p>\n<pre><code class=\"hljs language-js\">sudo apt install podman\n</code></pre>\n<p>그리고 podman으로 실행해봐요</p>\n<pre><code class=\"hljs language-js\">sudo mkdir -p /etc/letsencrypt\nsudo mkdir -p /<span class=\"hljs-keyword\">var</span>/lib/letsencrypt\nsudo podman run -it --rm --name certbot \\\n            -v <span class=\"hljs-string\">\"/etc/letsencrypt:/etc/letsencrypt\"</span> \\\n            -v <span class=\"hljs-string\">\"/var/lib/letsencrypt:/var/lib/letsencrypt\"</span> \\\n            docker.<span class=\"hljs-property\">io</span>/certbot/certbot certonly\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>그러나 그 방법이 실패한다면 수동 모드를 시도해 볼 수 있어요.</p>\n<pre><code class=\"hljs language-js\">sudo apt install certbot\nsudo certbot certonly --manual\n</code></pre>\n<p>그 후 안내에 따라 진행해주세요.</p>\n<p>반드시 매 90일마다 해당 작업을 수행하도록 하세요. 더 나은 방법은 프로시저를 자동화하는 것이겠죠.</p>\n<div class=\"content-ad\"></div>\n<p>다른 방법은 DNS를 통해 확인하는 것입니다. 하지만, 이 방법을 사용하려면 서드 파티 패키지가 필요하며, 개발 프로세스 초기에 가능한 한 많은 위험을 줄이기 위해 서버를 가능한 깨끗하게 유지하려 합니다.</p>\n<h2>인증서 자동 갱신을 위한 certbot.service 설정</h2>\n<p>프로시저를 자동화하기 위해 데몬을 설정하겠습니다. 이 시리즈를 따라오셨다면, 다음 단계는 이미 표준 작업 목록에 포함되어 있어야 합니다.</p>\n<pre><code class=\"hljs language-js\">sudo nano /etc/systemd/system/cerbot.<span class=\"hljs-property\">service</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>그리고 아래의 작업을 추가해 주세요.</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-meta\">#!/bin/sh</span>\n\ncertbot renew\nsystemctl restart nginx\n</code></pre>\n<p>그리고 아래의 명령어를 실행해 주세요.</p>\n<pre><code class=\"hljs language-sh\">sudo systemctl <span class=\"hljs-built_in\">enable</span> certbot.service &#x26;&#x26; sudo systemctl start certbot.service &#x26;&#x26; sudo systemctl status cerbot.service\n</code></pre>\n<div class=\"content-ad\"></div>\n<h1>결론</h1>\n<p>오케이, 와아 휴😅. 정말 많았지요. 여러분이 실제로 돈을 내고 사는 소프트웨어 제품들을 만들었습니다💪. 그러나 괜찮아요 — 돈도 부족하고 시간도 부족해서 우리 일이죠. 우리는 비양식되고 비획기적인 소프트웨어 도구들을 사용할 시간이나 돈이 충분하지 않다는 거죠.</p>\n<h2>혜택:</h2>\n<p>세 명으로 이루어진 회사를 운영한다고 가정했을 때, 백엔드 작업 및 내부 웹 애플리케이션용으로 8코어 미니 서버를 350달러에 구입했습니다. 라즈베리 파이는 약 130달러했어요.</p>\n<div class=\"content-ad\"></div>\n<p>저는 단순한 혜택 계산을 하고 싶을 뿐입니다: 매년 사용자 당 $252을 지불하면 코드 호스팅과 CI를 위한 Github 통합($756)을 이용할 수 있습니다. 8 코어 머신에서 백엔드로 업그레이드 가능한 웹사이트 호스팅은 AWS에서 $867.90 입니다. $169/y에 웹플로우 호스팅도 제공됩니다. SSL 인증서 구매시 약 $10/y의 비용이 발생합니다. 해당 설정으로 연간 약 $666의 비용을 절안할 수 있습니다(이 숫자는 우연히 나온 숫자에 불과합니다). 물론 전기비는 포함되지 않았습니다. 이 비용으로 한 달 동안 주당 10시간씩 일하는 직원을 고용할 수 있습니다. 지수적으로 증가하기 때문에, 새로운 웹사이트를 추가하는 데 거의 비용이 들지 않으며, GitHub 수준의 연간 요금을 내야하는 내부 및 외부 서비스를 호스팅할 수도 있습니다.</p>\n<h1>도움이 되는 기사</h1>\n<p><a href=\"https://easyengine.io/tutorials/nginx/fail2ban/\" rel=\"nofollow\" target=\"_blank\">https://easyengine.io/tutorials/nginx/fail2ban/</a></p>\n</body>\n</html>\n"},"__N_SSG":true}