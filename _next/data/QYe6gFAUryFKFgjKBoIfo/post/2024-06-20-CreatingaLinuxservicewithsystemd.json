{"pageProps":{"post":{"title":"시스템디 systemd를 사용하여 리눅스 서비스 만들기","description":"","date":"2024-06-20 14:19","slug":"2024-06-20-CreatingaLinuxservicewithsystemd","content":"\n\n\n![이미지](/assets/img/2024-06-20-CreatingaLinuxservicewithsystemd_0.png)\n\n웹 애플리케이션을 작성하는 동안, 계산이 많이 드는 작업을 비동기식 작업자 스크립트로 옮기거나 나중에 작업을 예약하거나, 심지어 클라이언트와 직접 통신하기 위해 소켓을 수신하는 데몬을 작성해야 하는 경우가 종종 있습니다.\n\n가끔 더 나은 도구가 있을 수도 있지만—항상 기존 소프트웨어를 먼저 사용하는 것을 고려하십시오—직접 서비스를 작성함으로써 제약사항에 바인딩되어 있을 때 얻을 수 없는 유연성을 얻을 수 있습니다.\n\n멋진 점은 리눅스 서비스를 만들기가 상당히 쉽다는 것입니다: 원하는 프로그래밍 언어로 장기 실행 프로그램을 작성하고, systemd를 사용하여 서비스로 변환하십시오.\n\n\n<div class=\"content-ad\"></div>\n\n# 프로그램\n\nPHP를 사용하여 작은 서버를 만들어 봅시다. 놀라실 거예요, 하지만 상당히 잘 작동합니다. UDP 포트 10000에서 수신 대기하고, 받은 메시지를 ROT13 변환하여 반환할 거에요.\n\n시작해 볼까요?\n\n```js\n$ php server.php\n```\n\n<div class=\"content-ad\"></div>\n\n그리고 다른 터미널에서 테스트해보세요:\n\n```js\n$ nc -u 127.0.0.1 10000\nHello, world!\nUryyb, jbeyq!\n```\n\n와우, 잘 작동하네요. 이제 우리는 이 스크립트가 항상 실행되도록 하고, 실패(예기치 않은 종료)할 경우 다시 시작되며 서버 재부팅 후에도 살아남을 수 있기를 원합니다. 그럴 때 systemd가 필요합니다.\n\n# 서비스로 변경\n\n<div class=\"content-ad\"></div>\n\n/etc/systemd/system/rot13.service이라는 파일을 만들어보겠습니다:\n\n```js\n[Unit]\nDescription=ROT13 데모 서비스\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=always\nRestartSec=1\nUser=여러분의_사용자이름\nExecStart=/usr/bin/env php /스크립트/경로/server.php\n\n[Install]\nWantedBy=multi-user.target\n```\n\n다음을 수행해야 합니다:\n- User= 뒤에 실제 사용자 이름 설정하기\n- ExecStart=에 스크립트의 적절한 경로 설정하기\n\n<div class=\"content-ad\"></div>\n\n그게 다에요. 이제 서비스를 시작할 수 있어요:\n\n```js\n$ systemctl start rot13\n```\n\n그리고 부팅 시 자동으로 시작되도록 설정할 수 있어요:\n\n```js\n$ systemctl enable rot13\n```\n\n<div class=\"content-ad\"></div>\n\n# 더 나아가기\n\n이제 서비스가 (아마도) 작동되므로 구성 옵션을 조금 더 심층적으로 탐색하여 항상 예상대로 작동하는지 확인하는 것이 중요할 수 있습니다.\n\n## 올바른 순서로 시작하기\n\nAfter= 지시문이 무엇을 하는 지 궁금해할 수도 있습니다. 이는 단순히 서비스가 네트워크가 준비되자마자 시작되어야 한다는 것을 의미합니다. 만약 프로그램이 MySQL 서버가 가동되고 작동 중인 것을 기대한다면 다음을 추가해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n\n## 종료 시 재시작\n\n기본적으로 systemd는 프로그램이 어떤 이유로든 종료되면 서비스를 다시 시작하지 않습니다. 일반적으로 항상 사용 가능해야 하는 서비스에 대해 원하는 동작이 아니므로 종료 시 항상 다시 시작하도록 지시합니다:\n\n```js\nRestart=always\n``` \n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 바꿀 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\n저는 개인적으로 이 부분에 두 번 이상 빠져들었어요. 기본적으로 우리가 하는 것처럼 Restart=always를 설정하면 systemd가 서비스가 10초 간격 내에 5번 이상 시작하지 못하면 다시 시작하는 것을 포기합니다. 영원히요.\n\n이에 대한 두 가지 [Unit] 구성 옵션이 있어요:\n\n```js\nStartLimitBurst=5\nStartLimitIntervalSec=10\n```\n\n또한 RestartSec 지시문은 결과에 영향을 줍니다: 3초 후에 다시 시작하도록 설정하면 10초 내에 5번의 실패한 재시도에 도달할 수 없어요.\n\n<div class=\"content-ad\"></div>\n\n항상 작동하는 간단한 해결책은 StartLimitIntervalSec=0로 설정하는 것입니다. 그렇게 하면 systemd가 서비스를 영원히 다시 시작하려고 시도할 것입니다.\n\n그러나 너무 많은 스트레스를 서버에 가하지 않기 위해 RestartSec를 적어도 1초로 설정하는 것이 좋습니다.\n\n대안으로는 기본 설정을 그대로 두고 StartLimitAction=reboot를 사용하여 시작 제한이 도달했을 때 systemd에 서버를 다시 시작하도록 요청할 수 있습니다.\n\n# 정말 그게 다인가요?\n\n<div class=\"content-ad\"></div>\n\n요즘에는 RHEL/CentOS, Fedora, Ubuntu, Debian 등에서 systemd가 기본 init 시스템으로 사용되고 있으므로, 아마도 귀하의 서버는 홈브류 서비스를 호스팅할 준비가 되어 있을 겁니다!","ogImage":{"url":"/assets/img/2024-06-20-CreatingaLinuxservicewithsystemd_0.png"},"coverImage":"/assets/img/2024-06-20-CreatingaLinuxservicewithsystemd_0.png","tag":["Tech"],"readingTime":3},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-20-CreatingaLinuxservicewithsystemd_0.png\" alt=\"이미지\"></p>\n<p>웹 애플리케이션을 작성하는 동안, 계산이 많이 드는 작업을 비동기식 작업자 스크립트로 옮기거나 나중에 작업을 예약하거나, 심지어 클라이언트와 직접 통신하기 위해 소켓을 수신하는 데몬을 작성해야 하는 경우가 종종 있습니다.</p>\n<p>가끔 더 나은 도구가 있을 수도 있지만—항상 기존 소프트웨어를 먼저 사용하는 것을 고려하십시오—직접 서비스를 작성함으로써 제약사항에 바인딩되어 있을 때 얻을 수 없는 유연성을 얻을 수 있습니다.</p>\n<p>멋진 점은 리눅스 서비스를 만들기가 상당히 쉽다는 것입니다: 원하는 프로그래밍 언어로 장기 실행 프로그램을 작성하고, systemd를 사용하여 서비스로 변환하십시오.</p>\n<div class=\"content-ad\"></div>\n<h1>프로그램</h1>\n<p>PHP를 사용하여 작은 서버를 만들어 봅시다. 놀라실 거예요, 하지만 상당히 잘 작동합니다. UDP 포트 10000에서 수신 대기하고, 받은 메시지를 ROT13 변환하여 반환할 거에요.</p>\n<p>시작해 볼까요?</p>\n<pre><code class=\"hljs language-js\">$ php server.<span class=\"hljs-property\">php</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>그리고 다른 터미널에서 테스트해보세요:</p>\n<pre><code class=\"hljs language-js\">$ nc -u <span class=\"hljs-number\">127.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span> <span class=\"hljs-number\">10000</span>\n<span class=\"hljs-title class_\">Hello</span>, world!\n<span class=\"hljs-title class_\">Uryyb</span>, jbeyq!\n</code></pre>\n<p>와우, 잘 작동하네요. 이제 우리는 이 스크립트가 항상 실행되도록 하고, 실패(예기치 않은 종료)할 경우 다시 시작되며 서버 재부팅 후에도 살아남을 수 있기를 원합니다. 그럴 때 systemd가 필요합니다.</p>\n<h1>서비스로 변경</h1>\n<div class=\"content-ad\"></div>\n<p>/etc/systemd/system/rot13.service이라는 파일을 만들어보겠습니다:</p>\n<pre><code class=\"hljs language-js\">[<span class=\"hljs-title class_\">Unit</span>]\n<span class=\"hljs-title class_\">Description</span>=<span class=\"hljs-title class_\">ROT13</span> 데모 서비스\n<span class=\"hljs-title class_\">After</span>=network.<span class=\"hljs-property\">target</span>\n<span class=\"hljs-title class_\">StartLimitIntervalSec</span>=<span class=\"hljs-number\">0</span>\n\n[<span class=\"hljs-title class_\">Service</span>]\n<span class=\"hljs-title class_\">Type</span>=simple\n<span class=\"hljs-title class_\">Restart</span>=always\n<span class=\"hljs-title class_\">RestartSec</span>=<span class=\"hljs-number\">1</span>\n<span class=\"hljs-title class_\">User</span>=여러분의_사용자이름\n<span class=\"hljs-title class_\">ExecStart</span>=<span class=\"hljs-regexp\">/usr/</span>bin/env php /스크립트/경로/server.<span class=\"hljs-property\">php</span>\n\n[<span class=\"hljs-title class_\">Install</span>]\n<span class=\"hljs-title class_\">WantedBy</span>=multi-user.<span class=\"hljs-property\">target</span>\n</code></pre>\n<p>다음을 수행해야 합니다:</p>\n<ul>\n<li>User= 뒤에 실제 사용자 이름 설정하기</li>\n<li>ExecStart=에 스크립트의 적절한 경로 설정하기</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>그게 다에요. 이제 서비스를 시작할 수 있어요:</p>\n<pre><code class=\"hljs language-js\">$ systemctl start rot13\n</code></pre>\n<p>그리고 부팅 시 자동으로 시작되도록 설정할 수 있어요:</p>\n<pre><code class=\"hljs language-js\">$ systemctl enable rot13\n</code></pre>\n<div class=\"content-ad\"></div>\n<h1>더 나아가기</h1>\n<p>이제 서비스가 (아마도) 작동되므로 구성 옵션을 조금 더 심층적으로 탐색하여 항상 예상대로 작동하는지 확인하는 것이 중요할 수 있습니다.</p>\n<h2>올바른 순서로 시작하기</h2>\n<p>After= 지시문이 무엇을 하는 지 궁금해할 수도 있습니다. 이는 단순히 서비스가 네트워크가 준비되자마자 시작되어야 한다는 것을 의미합니다. 만약 프로그램이 MySQL 서버가 가동되고 작동 중인 것을 기대한다면 다음을 추가해야 합니다:</p>\n<div class=\"content-ad\"></div>\n<h2>종료 시 재시작</h2>\n<p>기본적으로 systemd는 프로그램이 어떤 이유로든 종료되면 서비스를 다시 시작하지 않습니다. 일반적으로 항상 사용 가능해야 하는 서비스에 대해 원하는 동작이 아니므로 종료 시 항상 다시 시작하도록 지시합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">Restart</span>=always\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>테이블 태그를 마크다운 형식으로 바꿀 수도 있어요.</p>\n<div class=\"content-ad\"></div>\n<p>저는 개인적으로 이 부분에 두 번 이상 빠져들었어요. 기본적으로 우리가 하는 것처럼 Restart=always를 설정하면 systemd가 서비스가 10초 간격 내에 5번 이상 시작하지 못하면 다시 시작하는 것을 포기합니다. 영원히요.</p>\n<p>이에 대한 두 가지 [Unit] 구성 옵션이 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">StartLimitBurst</span>=<span class=\"hljs-number\">5</span>\n<span class=\"hljs-title class_\">StartLimitIntervalSec</span>=<span class=\"hljs-number\">10</span>\n</code></pre>\n<p>또한 RestartSec 지시문은 결과에 영향을 줍니다: 3초 후에 다시 시작하도록 설정하면 10초 내에 5번의 실패한 재시도에 도달할 수 없어요.</p>\n<div class=\"content-ad\"></div>\n<p>항상 작동하는 간단한 해결책은 StartLimitIntervalSec=0로 설정하는 것입니다. 그렇게 하면 systemd가 서비스를 영원히 다시 시작하려고 시도할 것입니다.</p>\n<p>그러나 너무 많은 스트레스를 서버에 가하지 않기 위해 RestartSec를 적어도 1초로 설정하는 것이 좋습니다.</p>\n<p>대안으로는 기본 설정을 그대로 두고 StartLimitAction=reboot를 사용하여 시작 제한이 도달했을 때 systemd에 서버를 다시 시작하도록 요청할 수 있습니다.</p>\n<h1>정말 그게 다인가요?</h1>\n<div class=\"content-ad\"></div>\n<p>요즘에는 RHEL/CentOS, Fedora, Ubuntu, Debian 등에서 systemd가 기본 init 시스템으로 사용되고 있으므로, 아마도 귀하의 서버는 홈브류 서비스를 호스팅할 준비가 되어 있을 겁니다!</p>\n</body>\n</html>\n"},"__N_SSG":true}