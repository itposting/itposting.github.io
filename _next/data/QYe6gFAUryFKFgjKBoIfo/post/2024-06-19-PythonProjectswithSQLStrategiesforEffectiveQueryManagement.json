{"pageProps":{"post":{"title":"파이썬 프로젝트와 SQL 효율적인 쿼리 관리 전략","description":"","date":"2024-06-19 16:29","slug":"2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement","content":"\n\n프로젝트에서 데이터베이스와 상호 작용하는 프로그래밍을 할 때, 쿼리를 어떻게 조직화하고 재사용할지 고민하는 일이 종종 있어요. 이럴 때 몇몇 개발자는 쿼리를 보다 동적으로 만들기 위해 문자열을 연결하는 함수를 만들기도 하고, 다른 사람들은 이 쿼리를 정의하는 변수를 만들기를 선호하기도 해요. 일부 더 고급 개발자들은 쿼리를 정의할 때 SQLAlchemy 객체 선언을 사용하기도 하는데, 이 방법은 배우는 곡선이 있어서 더 복잡한 쿼리를 다룰 때 개발 프로세스를 어렵게 만들 수 있어요.\n\n어느 날, 저는 코드를 지나치게 복잡하게 만들지 않고도 조직적이고 재사용 가능한 방식으로 작업하기 위한 해결책을 찾던 중 흥미로운 라이브러리인 aiosql을 우연히 발견했어요.\n\n<div class=\"content-ad\"></div>\n\n다음 기사에서는 aiosql 라이브러리를 어떻게 사용하는지를 검토하고 문서에서 설명되는 내용과 함께 다른 컨텍스트에서 구현하는 데 사용한 몇 가지 방법을 공유하겠습니다.\n\n# ⚙️ aiosql 라이브러리란 무엇인가요?\n\nAiosql은 🐍파이썬 라이브러리로, SQL 쿼리를 주요 파이썬 프로젝트 코드와 분리된 파일에 쉽게 작성할 수 있도록 도와줍니다. 이러한 쿼리는 SQL 파일에 저장되며, 이후에는 🐍파이썬 객체 내의 메서드로 변환됩니다.\n\nAiosql의 또 다른 주목할 만한 기능은 매개변수를 받아들이는 동적 메서드를 생성할 수 있는 능력으로, 유연한 쿼리 실행과 기본 데이터베이스와의 효과적인 상호 작용을 가능케합니다.\n\n<div class=\"content-ad\"></div>\n\nSQL 쿼리를 Python 코드에서 분리함으로써 코드를 더 깔끔하고 모듈식으로 유지하는 데 도움이 됩니다. 이는 프로젝트의 가독성과 유지보수성을 향상시킵니다.\n\n# ⚙️ aiosql의 작동 방식\n\n다이어그램에서 볼 수 있듯이 SQL 파일에서 모든 쿼리를 가져와서 Python 코드에서 쿼리 헤더에 정의된 이름으로 호출하여 사용할 수 있습니다. 이후에 Python 코드에서 필요한 매개변수를 직접 전달하여 쿼리를 실행할 수 있습니다. 이를 통해 쿼리를 재사용하고 유지보수하기 쉽게 만들 수 있습니다.\n\n<img src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n# ⚙️ Aiosql 라이브러리 핵심 기능\n\n아래에서는 이 라이브러리가 이미 갖고 있거나 사용에 기반한 기능을 가질 수 있는 일련의 기능을 공유하겠습니다:\n\n- 데이터베이스 작업을 위한 CRUD 기능 제공 (Create: Insert, Read: Select, Update, Delete).\n- Python 코드와 SQL 코드를 분리하여 여러 데이터베이스가 있는 프로젝트에서 쿼리를 찾기 쉽게 함.\n- 각 쿼리에 설명적인 이름과 독스트링을 할당할 수 있어 Python 함수와 유사하게 쿼리를 문서화할 수 있음.\n- 프로젝트 내에서 쿼리 카탈로그를 작성하도록 지원하여 엔터티, 데이터베이스 또는 기타 그룹별 식별을 용이하게 함.\n- 동적 값 전달과 필요에 따라 수정할 수 있는 동적 쿼리를 쉽게 생성할 수 있음.\n\n![PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2](/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2.png)\n\n<div class=\"content-ad\"></div>\n\n# ⚙️ Aiosql 튜토리얼\n\n## 🔧 사전 준비 사항\n\n- 🐳 도커\n- 🐙 도커 컴포즈\n- 🐍 Python 라이브러리 설치:\n\n```js\npip install aiosql pandas\n```\n\n<div class=\"content-ad\"></div>\n\n# 🚀 빠른 시작\n\n## 🛠️ 포스트그레스 데이터베이스 만들기\n\n- 1️⃣ — 이 저장소를 복제합니다: aiosql-tutorial\n\n```js\ngit clone https://github.com/r0mymendez/aiosql-tutorial.git\n```\n\n<div class=\"content-ad\"></div>\n\n- 2️⃣ 'postgres' 폴더로 디렉토리 변경해주세요\n\n```js\ncd aiosql-tutorial/postgres\n```\n\n- 3️⃣ PostgreSQL 데이터베이스를 생성해주세요 → 터미널에서 실행하세요:\n\n```js\ndocker-compose -f docker-compose.yml up --build\n```\n\n<div class=\"content-ad\"></div>\n\n- 4️⃣ 이제 컨테이너가 실행 중인지 확인하세요 → 터미널에서 다음을 실행해보세요:\n\n```js\ndocker ps\n```\n\n- 5️⃣ CSV 파일을 로드하세요 → 컨테이너 내에서 CSV 파일을 로드하려면 다음 명령어를 실행하세요:\n\n```js\ncd src\npython3 etl.py\n```\n\n<div class=\"content-ad\"></div>\n\n# 🏥 병원 데이터\n\naiosql을 구현하기 위해 Synthea에서 제공하는 데이터셋을 사용할 것입니다. 이 데이터는 매사추세츠 지역 인구의 다양한 변수를 고려한 시뮬레이션에서 생성된 합성 데이터입니다. 이 데이터셋에서는 `conditions`, `encounters`, `patients` 테이블을 사용할 것입니다.\n\n# 👥 사용자 이야기\n\n실제 상황을 반영하기 위해 3가지 사용 사례를 만들어보겠습니다:\n* 1️⃣ — 데이터 분석가로서, 방문 횟수가 90번 백분위 이상인 환자 목록을 검색할 수 있기를 원합니다. 이를 통해 병원에서 가장 활발한 환자들을 식별할 수 있습니다. 또한 나중에 쉽게 조정할 수 있도록 이 백분위를 구성할 수 있기를 원합니다.\n* 2️⃣ — **연구원 또는 데이터 분석가**로서, 일정 기간 동안 가장 빈도가 높은 10가지 진단을 받은 환자 데이터에 액세스하고, 추세를 분석하고 의료 서비스의 품질을 개선하기 위해 사용하고 싶습니다.\n* 3️⃣ — **마케팅 분석가**로서, 환자 만족도 조사용 테이블을 작성하고, 의료 서비스의 품질에 대한 피드백을 수집하여 개선 조치를 취하고자 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 🚀 구현\n\n우리가 만들 것인 사용자 스토리에 기반하여, 실행해야 하는 쿼리와 스크립트를 로드할 두 개의 파일을 정의할 것입니다:\n\n- patients.sql: 회복 중인 환자 데이터에 관련된 모든 쿼리가 있는 곳입니다.\n- visits.sql: 설문 조사와 같은 방문에 관련된 모든 쿼리가 있는 곳입니다.\n\n그러므로 우리 프로젝트에서는 이러한 폴더 및 파일 구조를 가지게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n📁 db\n\n    - 📁 queries\n        - 📄 patients.sql\n        - 📄 visits.sql\n\n📄 main.ipynb\n```\n\n1️⃣ — Python 라이브러리를 가져옵시다.\n\n```js\nimport aiosql\nimport psycopg2\nimport pandas as pd\n```\n\n2️⃣ — SQL 쿼리를 가져와 데이터베이스 드라이버를 설정합시다.\n\n<div class=\"content-ad\"></div>\n\n```js\nsql = aiosql.from_path('src/db/queries', 'psycopg2')\n```\n\n3️⃣ — PostgreSQL 데이터베이스에 연결합니다.\n\n```js\npostgres_secrets = {'host': 'localhost','port': 5432, 'user': 'postgres', 'password': 'postgres', 'dbname': 'postgres'}\nconn = psycopg2.connect(**postgres_secrets)\nconn.autocommit = True\n```\n\n## 👥 사용자 이야기 I: 정적 값들\n\n<div class=\"content-ad\"></div>\n\n위의 사용자 스토리를 기반으로, 먼저 90번째 백분위수 이상의 방문 빈도를 가진 환자 목록을 검색할 수 있는 쿼리를 생성할 것입니다.\n\n1️⃣ — sql 파일에서 첫 번째 사용자 스토리에 대한 쿼리가 있습니다.\n\n다음은 aiosq에서 SQL 문이 구성되는 세 가지 구성 요소입니다:\n\n- 📗 Name: 이는 Python 코드에서 쿼리를 호출하는 데 사용되는 서술적인 이름입니다. 다음 예제에서 이름은 “fn_get_patients_adove_90th_percentile\" 입니다.\n- 📗 Description: 이는 문서 문자열을 생성하는 데 사용되는 자세한 설명입니다. 쿼리의 목적과 맥락에 대해 더 포괄적으로 설명합니다. 다음 예제에서 설명은 “90번째 백분위수 이상의 방문보다 더 많은 환자를 가져옵니다…\" 입니다.\n- 📗 Query: 여기에는 데이터베이스에서 실행될 SQL 쿼리가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n📄 sql: db/queries/patients.sql\n\n```js\n-- 이름: fn_get_patients_adove_90th_percentile\n-- 모든 환자 중 방문이 90 번째 백분위수보다 많은 환자들을 가져옵니다. 모든 데이터는 encounters 테이블에 저장되어 있습니다.\n WITH patient_visits AS (\n     SELECT\n         patient,\n         COUNT(*) AS visit_count\n     FROM\n         hospital.encounters\n     GROUP BY\n         patient\n ),\n percentil_n AS (\n   SELECT\n     percentile_cont(0.9) WITHIN GROUP (ORDER BY visit_count) AS p_visits\n   FROM\n   patient_visits\n )\n SELECT \n     pv.patient, \n     pv.visit_count\n FROM \n     patient_visits pv\n CROSS JOIN \n     percentil_n pn\n WHERE \n     pv.visit_count >= pn.p_visits;\n```\n\n2️⃣ — 'fn_get_patients_above_90th_percentile' SQL 함수를 데이터베이스 연결 'conn'을 사용하여 실행합니다.\n\n```js\nresponse = sql.fn_get_patients_above_90th_percentile(conn)\n```\n\n<div class=\"content-ad\"></div>\n\n3️⃣ — 이제 응답 객체를 판다스 데이터프레임으로 변환하여 데이터 조작을 더 쉽게 할 수 있습니다.\n\n```python\ndata = pd.DataFrame([item for item in response], columns=['patient_id', 'num_visit'])\n# 데이터프레임 표시.\ndata\n```\n\n![이미지](/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_3.png)\n\n쿼리를 확인하고 싶으면 다음 코드를 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nprint(sql.fn_get_patients_adove_90th_percentile.sql)\n```\n\n## 👥 사용자 스토리 I: 동적 값\n\n이제 우리는 다른 백분위 값들을 받아들일 수 있는 쿼리를 생성하여 전달된 값에 기반하여 동적으로 수정될 수 있도록 할 것입니다. 우리의 경우, 75번째 백분위 이상의 환자 목록을 얻는 예시를 제공할 것입니다.\n\n```js\n-- name: fn_get_patients_above_n_percentile\n WITH patient_visits AS (\n     SELECT\n         patient,\n         COUNT(*) AS visit_count\n     FROM\n         hospital.encounters\n     GROUP BY\n         patient\n ),\n percentil_n AS (\n   SELECT\n     percentile_cont(:percentil_value) WITHIN GROUP (ORDER BY visit_count) AS p_visits\n   FROM\n   patient_visits\n )\n SELECT \n     pv.patient, \n     pv.visit_count\n FROM \n     patient_visits pv\n CROSS JOIN \n     percentil_n pn\n WHERE \n     pv.visit_count >= pn.p_visits;\n```\n\n<div class=\"content-ad\"></div>\n\n1️⃣ - 다음 코드는 입력값으로 다른 백분위 값을 허용하는 동적 SQL 쿼리를 실행합니다.\n\n```js\n# 이 경우에는 75 백분위 이상의 환자들을 얻습니다.\nresponse = sql.fn_get_patients_above_n_percentile(conn, percentil_value=0.75)\ndata = pd.DataFrame([item for item in response], columns=['patient_id', 'num_visit'])\n```\n\n## 👥 사용자 스토리 II\n\n이 사용자 스토리를 해결하기 위해 지정된 기간 내에서 가장 일반적인 질환이 있는 환자들을 검색하는 쿼리를 생성할 것입니다. 이 쿼리는 동적이며, 향후 관심 있는 질환 수의 변화를 허용할 것입니다.\n이 쿼리는 세 개의 매개변수를 받습니다:\n\n<div class=\"content-ad\"></div>\n\n- num_condition: 우리가 관심 있는 조건의 수를 제한할 수 있게 해줄 것입니다 (예: 가장 일반적인 상위 10개 조건).\n- period_start_date와 period_start_end는 데이터를 검색하려는 시간 창을 정의할 것입니다.\n\n```js\n--name: fn_get_patients_top_conditions\n--주어진 기간 동안 최상위 조건을 가진 환자 가져오기, 환자는 조건을 가진 날 수와 데이터 소스가 병원 스키마인 기준으로 정렬됩니다.\nwith top_n_conditions as(\n  SELECT code, description, COUNT(*) \n   FROM hospital.CONDITIONS \n  GROUP BY code,description \n  ORDER BY COUNT(*) DESC \n  LIMIT :num_condition\n),\ntop_n_condition_patients as (\n  SELECT \n     p.ID, \n     p.FIRST, \n     p.LAST, \n     p.CITY, \n     p.GENDER, \n     EXTRACT(YEAR FROM AGE(p.BIRTHDATE)) AS age,\n     c.start condition_start_date,\n     c.stop condition_stop_date,\n     EXTRACT(DAY FROM (c.stop - c.start )) AS condition_days, \n     c.encounter,\n     c.code,\n     c.description\n   from hospital.patients p \n   inner join hospital.conditions c on c.patient = p.id\n   inner join top_n_conditions t on t.code=c.code\n)\nselect * \n from top_n_condition_patients\n where condition_start_date between :period_start_date and :period_start_end;\n```\n\n```js\nresponse = sql.fn_get_patients_top_conditions(conn, num_condition_days=10, \n period_start_date='2022–01–01', \n period_start_end='2022–12–31')\ncolumn_name=['id', 'first','last','city','gender',\n'age','condition_start_date','condition_stop_date','condition_days','encounter','code','description']\ndata = pd.DataFrame([item for item in response], columns=column_name)\ndata.head()\n```\n\n## 👥 사용자 이야기 III\n\n<div class=\"content-ad\"></div>\n\n이제 aiosql을 사용하여 테이블을 생성할 것입니다. 만약 SQL 코드를 살펴보시면 # 기호가 추가된 것을 보실 수 있습니다. 이러한 기호들은 aiosql이 다양한 작업을 식별하는 데 사용됩니다.\n\n```js\n--name: fn_create_survey_table#\nCREATE TABLE HOSPITAL.VISIT_SURVEY(\n ID SERIAL PRIMARY KEY,\n PATIENT_ID VARCHAR(50),\n SURVEY_DATE TIMESTAMP,\n RATING INT,\n COMMENTS TEXT,\n CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n);\n```\n\n<img src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_4.png\" />\n\n1️⃣ — 'fn_create_survey_table' SQL 함수를 실행하여 데이터베이스에 새 테이블을 만드세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nsql.fn_create_survey_table(conn)\n```\n\n```js\n# output\nCREATE TABLE\n```\n\n2️⃣ — 테이블이 생성되면 아래 삽입문을 사용하여 환자의 리뷰를 삽입할 수 있습니다.\n\n```js\n-- name: fn_add_one_visit_survey<!\ninsert into HOSPITAL.VISIT_SURVEY(PATIENT_ID,SURVEY_DATE,RATING,COMMENTS) \n values (:patient_id, :survey_date, :rating,:comments) returning ID;\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n# 새로운 방문 조사 레코드 추가\nsql.fn_add_one_visit_survey(conn, \n patient_id='8b9a93f6-3df3-203d-932f-f456e00d2c01', \n survey_date='2022-01-01', \n rating=5,\n comments='이 병원 정말 좋아요!' )\n```\n\n3️⃣ — 이제 여러 리뷰를 로드하기 위해 새로운 삽입문을 활용할 것입니다. 이 리뷰들은 딕셔너리 목록에 저장되어 있습니다 (파이썬의 각 딕셔너리는 리뷰에 해당합니다). 이를 수행하기 위해 비슷한 쿼리를 활용하겠지만 그 이름을 수정해야 합니다.\n\n```js\n-- name: fn_add_many_visit_survey*!\n insert into HOSPITAL.VISIT_SURVEY(PATIENT_ID,SURVEY_DATE,RATING,COMMENTS) \n values (:patient_id, :survey_date, :rating ,:comments) returning ID;\n```\n\n```js\n# 여러 방문 조사 레코드 추가\nresponse_survey = [\n     {\n       'patient_id': '8b9a93f6-3df3-203d-932f-f456e00d2c01',\n       'survey_date': '2022-01-01',\n       'rating': 3,\n       'comments': '서비스는 좋았어요. 다만 대기 시간이 조금 길었습니다.'\n     },\n     {\n       'patient_id': '7c8a93f6-4df3-203d-932f-f456e00d2c02',\n       'survey_date': '2022-02-01',\n       'rating': 4,\n       'comments': '직원들이 매우 친절했어요!'\n     },\n     {\n       'patient_id': '6b7a93f6-5ef3-203d-932f-f456e00d2c03',\n       'survey_date': '2022-03-01',\n       'rating': 3,\n       'comments': '대기 시간이 조금 길었습니다.'\n     }\n]\nsql.fn_add_many_visit_survey(conn, response_survey)\n```\n\n<div class=\"content-ad\"></div>\n\n# 📚 프로젝트 쿼리 카탈로그\n\n튜토리얼 초반에는 프로젝트용 쿼리 카탈로그를 만들 수 있는 가능성을 언급했습니다. 이 라이브러리는 이 기능을 직접 제공하지는 않지만, 나의 GitHub 저장소에서 이 튜토리얼의 완전한 코드와 데이터에 액세스하여 이를 수행하는 방법을 확인할 수 있습니다.\n\n유용하게 사용하시면, ⭐️ 스타를 남겨주시고 새로운 글 알림을 받기 위해 팔로우해주시면 저에게 큰 도움이 됩니다. 기술 커뮤니티에서 성장하고 더 많은 콘텐츠를 제작할 수 있게 될 것입니다.\n\n# 🔍 최종 결론\n\n<div class=\"content-ad\"></div>\n\n- 다양성과 유틸리티: 저는 aiosql이 다른 프로젝트에서 쿼리를 효율적으로 구현할 수 있게 해주는 유용한 라이브러리라고 생각합니다. 이 라이브러리는 SQL 쿼리를 관리하고 실행하는 구조적인 방법을 제공하여 본 코드베이스와 별도로 처리할 수 있어 가독성과 유지 보수성을 향상시킵니다.\n- 유연한 쿼리 처리: aiosql은 데이터베이스 연결을 통해 쿼리를 직접 실행할 수 있는 환경을 제공하지만, 저의 프로젝트에서는 주로 Python 코드로 이미 설정한 클래스를 사용하여 SQL 코드를 반환하고 실행합니다.\n- 다른 데이터베이스: 쿼리를 저장하고 관리할 수 있는 기능은 SQL 데이터베이스를 넘어서기도 합니다. 예를 들어 이 접근 방식은 Neo4j와 같은 NoSQL 데이터베이스에도 적용할 수 있습니다. 구조적인 방식으로 쿼리를 구성하고 처리함으로써 다양한 유형의 데이터베이스와의 상호 작용을 최적화할 수 있습니다.\n\n## 📚 참고 자료\n\n학습하고 싶다면...","ogImage":{"url":"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_0.png"},"coverImage":"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_0.png","tag":["Tech"],"readingTime":12},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>프로젝트에서 데이터베이스와 상호 작용하는 프로그래밍을 할 때, 쿼리를 어떻게 조직화하고 재사용할지 고민하는 일이 종종 있어요. 이럴 때 몇몇 개발자는 쿼리를 보다 동적으로 만들기 위해 문자열을 연결하는 함수를 만들기도 하고, 다른 사람들은 이 쿼리를 정의하는 변수를 만들기를 선호하기도 해요. 일부 더 고급 개발자들은 쿼리를 정의할 때 SQLAlchemy 객체 선언을 사용하기도 하는데, 이 방법은 배우는 곡선이 있어서 더 복잡한 쿼리를 다룰 때 개발 프로세스를 어렵게 만들 수 있어요.</p>\n<p>어느 날, 저는 코드를 지나치게 복잡하게 만들지 않고도 조직적이고 재사용 가능한 방식으로 작업하기 위한 해결책을 찾던 중 흥미로운 라이브러리인 aiosql을 우연히 발견했어요.</p>\n<div class=\"content-ad\"></div>\n<p>다음 기사에서는 aiosql 라이브러리를 어떻게 사용하는지를 검토하고 문서에서 설명되는 내용과 함께 다른 컨텍스트에서 구현하는 데 사용한 몇 가지 방법을 공유하겠습니다.</p>\n<h1>⚙️ aiosql 라이브러리란 무엇인가요?</h1>\n<p>Aiosql은 🐍파이썬 라이브러리로, SQL 쿼리를 주요 파이썬 프로젝트 코드와 분리된 파일에 쉽게 작성할 수 있도록 도와줍니다. 이러한 쿼리는 SQL 파일에 저장되며, 이후에는 🐍파이썬 객체 내의 메서드로 변환됩니다.</p>\n<p>Aiosql의 또 다른 주목할 만한 기능은 매개변수를 받아들이는 동적 메서드를 생성할 수 있는 능력으로, 유연한 쿼리 실행과 기본 데이터베이스와의 효과적인 상호 작용을 가능케합니다.</p>\n<div class=\"content-ad\"></div>\n<p>SQL 쿼리를 Python 코드에서 분리함으로써 코드를 더 깔끔하고 모듈식으로 유지하는 데 도움이 됩니다. 이는 프로젝트의 가독성과 유지보수성을 향상시킵니다.</p>\n<h1>⚙️ aiosql의 작동 방식</h1>\n<p>다이어그램에서 볼 수 있듯이 SQL 파일에서 모든 쿼리를 가져와서 Python 코드에서 쿼리 헤더에 정의된 이름으로 호출하여 사용할 수 있습니다. 이후에 Python 코드에서 필요한 매개변수를 직접 전달하여 쿼리를 실행할 수 있습니다. 이를 통해 쿼리를 재사용하고 유지보수하기 쉽게 만들 수 있습니다.</p>\n<img src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_1.png\">\n<div class=\"content-ad\"></div>\n<h1>⚙️ Aiosql 라이브러리 핵심 기능</h1>\n<p>아래에서는 이 라이브러리가 이미 갖고 있거나 사용에 기반한 기능을 가질 수 있는 일련의 기능을 공유하겠습니다:</p>\n<ul>\n<li>데이터베이스 작업을 위한 CRUD 기능 제공 (Create: Insert, Read: Select, Update, Delete).</li>\n<li>Python 코드와 SQL 코드를 분리하여 여러 데이터베이스가 있는 프로젝트에서 쿼리를 찾기 쉽게 함.</li>\n<li>각 쿼리에 설명적인 이름과 독스트링을 할당할 수 있어 Python 함수와 유사하게 쿼리를 문서화할 수 있음.</li>\n<li>프로젝트 내에서 쿼리 카탈로그를 작성하도록 지원하여 엔터티, 데이터베이스 또는 기타 그룹별 식별을 용이하게 함.</li>\n<li>동적 값 전달과 필요에 따라 수정할 수 있는 동적 쿼리를 쉽게 생성할 수 있음.</li>\n</ul>\n<p><img src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2.png\" alt=\"PythonProjectswithSQLStrategiesforEffectiveQueryManagement_2\"></p>\n<div class=\"content-ad\"></div>\n<h1>⚙️ Aiosql 튜토리얼</h1>\n<h2>🔧 사전 준비 사항</h2>\n<ul>\n<li>🐳 도커</li>\n<li>🐙 도커 컴포즈</li>\n<li>🐍 Python 라이브러리 설치:</li>\n</ul>\n<pre><code class=\"hljs language-js\">pip install aiosql pandas\n</code></pre>\n<div class=\"content-ad\"></div>\n<h1>🚀 빠른 시작</h1>\n<h2>🛠️ 포스트그레스 데이터베이스 만들기</h2>\n<ul>\n<li>1️⃣ — 이 저장소를 복제합니다: aiosql-tutorial</li>\n</ul>\n<pre><code class=\"hljs language-js\">git clone <span class=\"hljs-attr\">https</span>:<span class=\"hljs-comment\">//github.com/r0mymendez/aiosql-tutorial.git</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<ul>\n<li>2️⃣ 'postgres' 폴더로 디렉토리 변경해주세요</li>\n</ul>\n<pre><code class=\"hljs language-js\">cd aiosql-tutorial/postgres\n</code></pre>\n<ul>\n<li>3️⃣ PostgreSQL 데이터베이스를 생성해주세요 → 터미널에서 실행하세요:</li>\n</ul>\n<pre><code class=\"hljs language-js\">docker-compose -f docker-compose.<span class=\"hljs-property\">yml</span> up --build\n</code></pre>\n<div class=\"content-ad\"></div>\n<ul>\n<li>4️⃣ 이제 컨테이너가 실행 중인지 확인하세요 → 터미널에서 다음을 실행해보세요:</li>\n</ul>\n<pre><code class=\"hljs language-js\">docker ps\n</code></pre>\n<ul>\n<li>5️⃣ CSV 파일을 로드하세요 → 컨테이너 내에서 CSV 파일을 로드하려면 다음 명령어를 실행하세요:</li>\n</ul>\n<pre><code class=\"hljs language-js\">cd src\npython3 etl.<span class=\"hljs-property\">py</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<h1>🏥 병원 데이터</h1>\n<p>aiosql을 구현하기 위해 Synthea에서 제공하는 데이터셋을 사용할 것입니다. 이 데이터는 매사추세츠 지역 인구의 다양한 변수를 고려한 시뮬레이션에서 생성된 합성 데이터입니다. 이 데이터셋에서는 <code>conditions</code>, <code>encounters</code>, <code>patients</code> 테이블을 사용할 것입니다.</p>\n<h1>👥 사용자 이야기</h1>\n<p>실제 상황을 반영하기 위해 3가지 사용 사례를 만들어보겠습니다:</p>\n<ul>\n<li>1️⃣ — 데이터 분석가로서, 방문 횟수가 90번 백분위 이상인 환자 목록을 검색할 수 있기를 원합니다. 이를 통해 병원에서 가장 활발한 환자들을 식별할 수 있습니다. 또한 나중에 쉽게 조정할 수 있도록 이 백분위를 구성할 수 있기를 원합니다.</li>\n<li>2️⃣ — <strong>연구원 또는 데이터 분석가</strong>로서, 일정 기간 동안 가장 빈도가 높은 10가지 진단을 받은 환자 데이터에 액세스하고, 추세를 분석하고 의료 서비스의 품질을 개선하기 위해 사용하고 싶습니다.</li>\n<li>3️⃣ — <strong>마케팅 분석가</strong>로서, 환자 만족도 조사용 테이블을 작성하고, 의료 서비스의 품질에 대한 피드백을 수집하여 개선 조치를 취하고자 합니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<h1>🚀 구현</h1>\n<p>우리가 만들 것인 사용자 스토리에 기반하여, 실행해야 하는 쿼리와 스크립트를 로드할 두 개의 파일을 정의할 것입니다:</p>\n<ul>\n<li>patients.sql: 회복 중인 환자 데이터에 관련된 모든 쿼리가 있는 곳입니다.</li>\n<li>visits.sql: 설문 조사와 같은 방문에 관련된 모든 쿼리가 있는 곳입니다.</li>\n</ul>\n<p>그러므로 우리 프로젝트에서는 이러한 폴더 및 파일 구조를 가지게 될 것입니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">📁 db\n\n    - 📁 queries\n        - 📄 patients.<span class=\"hljs-property\">sql</span>\n        - 📄 visits.<span class=\"hljs-property\">sql</span>\n\n📄 main.<span class=\"hljs-property\">ipynb</span>\n</code></pre>\n<p>1️⃣ — Python 라이브러리를 가져옵시다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> aiosql\n<span class=\"hljs-keyword\">import</span> psycopg2\n<span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n</code></pre>\n<p>2️⃣ — SQL 쿼리를 가져와 데이터베이스 드라이버를 설정합시다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">sql = aiosql.<span class=\"hljs-title function_\">from_path</span>(<span class=\"hljs-string\">'src/db/queries'</span>, <span class=\"hljs-string\">'psycopg2'</span>)\n</code></pre>\n<p>3️⃣ — PostgreSQL 데이터베이스에 연결합니다.</p>\n<pre><code class=\"hljs language-js\">postgres_secrets = {<span class=\"hljs-string\">'host'</span>: <span class=\"hljs-string\">'localhost'</span>,<span class=\"hljs-string\">'port'</span>: <span class=\"hljs-number\">5432</span>, <span class=\"hljs-string\">'user'</span>: <span class=\"hljs-string\">'postgres'</span>, <span class=\"hljs-string\">'password'</span>: <span class=\"hljs-string\">'postgres'</span>, <span class=\"hljs-string\">'dbname'</span>: <span class=\"hljs-string\">'postgres'</span>}\nconn = psycopg2.<span class=\"hljs-title function_\">connect</span>(**postgres_secrets)\nconn.<span class=\"hljs-property\">autocommit</span> = <span class=\"hljs-title class_\">True</span>\n</code></pre>\n<h2>👥 사용자 이야기 I: 정적 값들</h2>\n<div class=\"content-ad\"></div>\n<p>위의 사용자 스토리를 기반으로, 먼저 90번째 백분위수 이상의 방문 빈도를 가진 환자 목록을 검색할 수 있는 쿼리를 생성할 것입니다.</p>\n<p>1️⃣ — sql 파일에서 첫 번째 사용자 스토리에 대한 쿼리가 있습니다.</p>\n<p>다음은 aiosq에서 SQL 문이 구성되는 세 가지 구성 요소입니다:</p>\n<ul>\n<li>📗 Name: 이는 Python 코드에서 쿼리를 호출하는 데 사용되는 서술적인 이름입니다. 다음 예제에서 이름은 “fn_get_patients_adove_90th_percentile\" 입니다.</li>\n<li>📗 Description: 이는 문서 문자열을 생성하는 데 사용되는 자세한 설명입니다. 쿼리의 목적과 맥락에 대해 더 포괄적으로 설명합니다. 다음 예제에서 설명은 “90번째 백분위수 이상의 방문보다 더 많은 환자를 가져옵니다…\" 입니다.</li>\n<li>📗 Query: 여기에는 데이터베이스에서 실행될 SQL 쿼리가 있습니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>📄 sql: db/queries/patients.sql</p>\n<pre><code class=\"hljs language-js\">-- 이름: fn_get_patients_adove_90th_percentile\n-- 모든 환자 중 방문이 <span class=\"hljs-number\">90</span> 번째 백분위수보다 많은 환자들을 가져옵니다. 모든 데이터는 encounters 테이블에 저장되어 있습니다.\n <span class=\"hljs-variable constant_\">WITH</span> patient_visits <span class=\"hljs-variable constant_\">AS</span> (\n     <span class=\"hljs-variable constant_\">SELECT</span>\n         patient,\n         <span class=\"hljs-title function_\">COUNT</span>(*) <span class=\"hljs-variable constant_\">AS</span> visit_count\n     <span class=\"hljs-variable constant_\">FROM</span>\n         hospital.<span class=\"hljs-property\">encounters</span>\n     <span class=\"hljs-variable constant_\">GROUP</span> <span class=\"hljs-variable constant_\">BY</span>\n         patient\n ),\n percentil_n <span class=\"hljs-variable constant_\">AS</span> (\n   <span class=\"hljs-variable constant_\">SELECT</span>\n     <span class=\"hljs-title function_\">percentile_cont</span>(<span class=\"hljs-number\">0.9</span>) <span class=\"hljs-variable constant_\">WITHIN</span> <span class=\"hljs-variable constant_\">GROUP</span> (<span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> visit_count) <span class=\"hljs-variable constant_\">AS</span> p_visits\n   <span class=\"hljs-variable constant_\">FROM</span>\n   patient_visits\n )\n <span class=\"hljs-variable constant_\">SELECT</span> \n     pv.<span class=\"hljs-property\">patient</span>, \n     pv.<span class=\"hljs-property\">visit_count</span>\n <span class=\"hljs-variable constant_\">FROM</span> \n     patient_visits pv\n <span class=\"hljs-variable constant_\">CROSS</span> <span class=\"hljs-variable constant_\">JOIN</span> \n     percentil_n pn\n <span class=\"hljs-variable constant_\">WHERE</span> \n     pv.<span class=\"hljs-property\">visit_count</span> >= pn.<span class=\"hljs-property\">p_visits</span>;\n</code></pre>\n<p>2️⃣ — 'fn_get_patients_above_90th_percentile' SQL 함수를 데이터베이스 연결 'conn'을 사용하여 실행합니다.</p>\n<pre><code class=\"hljs language-js\">response = sql.<span class=\"hljs-title function_\">fn_get_patients_above_90th_percentile</span>(conn)\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>3️⃣ — 이제 응답 객체를 판다스 데이터프레임으로 변환하여 데이터 조작을 더 쉽게 할 수 있습니다.</p>\n<pre><code class=\"hljs language-python\">data = pd.DataFrame([item <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> response], columns=[<span class=\"hljs-string\">'patient_id'</span>, <span class=\"hljs-string\">'num_visit'</span>])\n<span class=\"hljs-comment\"># 데이터프레임 표시.</span>\ndata\n</code></pre>\n<p><img src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_3.png\" alt=\"이미지\"></p>\n<p>쿼리를 확인하고 싶으면 다음 코드를 사용할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title function_\">print</span>(sql.<span class=\"hljs-property\">fn_get_patients_adove_90th_percentile</span>.<span class=\"hljs-property\">sql</span>)\n</code></pre>\n<h2>👥 사용자 스토리 I: 동적 값</h2>\n<p>이제 우리는 다른 백분위 값들을 받아들일 수 있는 쿼리를 생성하여 전달된 값에 기반하여 동적으로 수정될 수 있도록 할 것입니다. 우리의 경우, 75번째 백분위 이상의 환자 목록을 얻는 예시를 제공할 것입니다.</p>\n<pre><code class=\"hljs language-js\">-- <span class=\"hljs-attr\">name</span>: fn_get_patients_above_n_percentile\n <span class=\"hljs-variable constant_\">WITH</span> patient_visits <span class=\"hljs-variable constant_\">AS</span> (\n     <span class=\"hljs-variable constant_\">SELECT</span>\n         patient,\n         <span class=\"hljs-title function_\">COUNT</span>(*) <span class=\"hljs-variable constant_\">AS</span> visit_count\n     <span class=\"hljs-variable constant_\">FROM</span>\n         hospital.<span class=\"hljs-property\">encounters</span>\n     <span class=\"hljs-variable constant_\">GROUP</span> <span class=\"hljs-variable constant_\">BY</span>\n         patient\n ),\n percentil_n <span class=\"hljs-variable constant_\">AS</span> (\n   <span class=\"hljs-variable constant_\">SELECT</span>\n     <span class=\"hljs-title function_\">percentile_cont</span>(:percentil_value) <span class=\"hljs-variable constant_\">WITHIN</span> <span class=\"hljs-variable constant_\">GROUP</span> (<span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> visit_count) <span class=\"hljs-variable constant_\">AS</span> p_visits\n   <span class=\"hljs-variable constant_\">FROM</span>\n   patient_visits\n )\n <span class=\"hljs-variable constant_\">SELECT</span> \n     pv.<span class=\"hljs-property\">patient</span>, \n     pv.<span class=\"hljs-property\">visit_count</span>\n <span class=\"hljs-variable constant_\">FROM</span> \n     patient_visits pv\n <span class=\"hljs-variable constant_\">CROSS</span> <span class=\"hljs-variable constant_\">JOIN</span> \n     percentil_n pn\n <span class=\"hljs-variable constant_\">WHERE</span> \n     pv.<span class=\"hljs-property\">visit_count</span> >= pn.<span class=\"hljs-property\">p_visits</span>;\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>1️⃣ - 다음 코드는 입력값으로 다른 백분위 값을 허용하는 동적 SQL 쿼리를 실행합니다.</p>\n<pre><code class=\"hljs language-js\"># 이 경우에는 <span class=\"hljs-number\">75</span> 백분위 이상의 환자들을 얻습니다.\nresponse = sql.<span class=\"hljs-title function_\">fn_get_patients_above_n_percentile</span>(conn, percentil_value=<span class=\"hljs-number\">0.75</span>)\ndata = pd.<span class=\"hljs-title class_\">DataFrame</span>([item <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> response], columns=[<span class=\"hljs-string\">'patient_id'</span>, <span class=\"hljs-string\">'num_visit'</span>])\n</code></pre>\n<h2>👥 사용자 스토리 II</h2>\n<p>이 사용자 스토리를 해결하기 위해 지정된 기간 내에서 가장 일반적인 질환이 있는 환자들을 검색하는 쿼리를 생성할 것입니다. 이 쿼리는 동적이며, 향후 관심 있는 질환 수의 변화를 허용할 것입니다.\n이 쿼리는 세 개의 매개변수를 받습니다:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>num_condition: 우리가 관심 있는 조건의 수를 제한할 수 있게 해줄 것입니다 (예: 가장 일반적인 상위 10개 조건).</li>\n<li>period_start_date와 period_start_end는 데이터를 검색하려는 시간 창을 정의할 것입니다.</li>\n</ul>\n<pre><code class=\"hljs language-js\">--<span class=\"hljs-attr\">name</span>: fn_get_patients_top_conditions\n--주어진 기간 동안 최상위 조건을 가진 환자 가져오기, 환자는 조건을 가진 날 수와 데이터 소스가 병원 스키마인 기준으로 정렬됩니다.\n<span class=\"hljs-keyword\">with</span> top_n_conditions <span class=\"hljs-title function_\">as</span>(\n  <span class=\"hljs-variable constant_\">SELECT</span> code, description, <span class=\"hljs-title function_\">COUNT</span>(*) \n   <span class=\"hljs-variable constant_\">FROM</span> hospital.<span class=\"hljs-property\">CONDITIONS</span> \n  <span class=\"hljs-variable constant_\">GROUP</span> <span class=\"hljs-variable constant_\">BY</span> code,description \n  <span class=\"hljs-variable constant_\">ORDER</span> <span class=\"hljs-variable constant_\">BY</span> <span class=\"hljs-title function_\">COUNT</span>(*) <span class=\"hljs-variable constant_\">DESC</span> \n  <span class=\"hljs-variable constant_\">LIMIT</span> :num_condition\n),\ntop_n_condition_patients <span class=\"hljs-keyword\">as</span> (\n  <span class=\"hljs-variable constant_\">SELECT</span> \n     p.<span class=\"hljs-property\">ID</span>, \n     p.<span class=\"hljs-property\">FIRST</span>, \n     p.<span class=\"hljs-property\">LAST</span>, \n     p.<span class=\"hljs-property\">CITY</span>, \n     p.<span class=\"hljs-property\">GENDER</span>, \n     <span class=\"hljs-title function_\">EXTRACT</span>(<span class=\"hljs-variable constant_\">YEAR</span> <span class=\"hljs-variable constant_\">FROM</span> <span class=\"hljs-title function_\">AGE</span>(p.<span class=\"hljs-property\">BIRTHDATE</span>)) <span class=\"hljs-variable constant_\">AS</span> age,\n     c.<span class=\"hljs-property\">start</span> condition_start_date,\n     c.<span class=\"hljs-property\">stop</span> condition_stop_date,\n     <span class=\"hljs-title function_\">EXTRACT</span>(<span class=\"hljs-variable constant_\">DAY</span> <span class=\"hljs-variable constant_\">FROM</span> (c.<span class=\"hljs-property\">stop</span> - c.<span class=\"hljs-property\">start</span> )) <span class=\"hljs-variable constant_\">AS</span> condition_days, \n     c.<span class=\"hljs-property\">encounter</span>,\n     c.<span class=\"hljs-property\">code</span>,\n     c.<span class=\"hljs-property\">description</span>\n   <span class=\"hljs-keyword\">from</span> hospital.<span class=\"hljs-property\">patients</span> p \n   inner join hospital.<span class=\"hljs-property\">conditions</span> c on c.<span class=\"hljs-property\">patient</span> = p.<span class=\"hljs-property\">id</span>\n   inner join top_n_conditions t on t.<span class=\"hljs-property\">code</span>=c.<span class=\"hljs-property\">code</span>\n)\nselect * \n <span class=\"hljs-keyword\">from</span> top_n_condition_patients\n where condition_start_date between :period_start_date and :period_start_end;\n</code></pre>\n<pre><code class=\"hljs language-js\">response = sql.<span class=\"hljs-title function_\">fn_get_patients_top_conditions</span>(conn, num_condition_days=<span class=\"hljs-number\">10</span>, \n period_start_date=<span class=\"hljs-string\">'2022–01–01'</span>, \n period_start_end=<span class=\"hljs-string\">'2022–12–31'</span>)\ncolumn_name=[<span class=\"hljs-string\">'id'</span>, <span class=\"hljs-string\">'first'</span>,<span class=\"hljs-string\">'last'</span>,<span class=\"hljs-string\">'city'</span>,<span class=\"hljs-string\">'gender'</span>,\n<span class=\"hljs-string\">'age'</span>,<span class=\"hljs-string\">'condition_start_date'</span>,<span class=\"hljs-string\">'condition_stop_date'</span>,<span class=\"hljs-string\">'condition_days'</span>,<span class=\"hljs-string\">'encounter'</span>,<span class=\"hljs-string\">'code'</span>,<span class=\"hljs-string\">'description'</span>]\ndata = pd.<span class=\"hljs-title class_\">DataFrame</span>([item <span class=\"hljs-keyword\">for</span> item <span class=\"hljs-keyword\">in</span> response], columns=column_name)\ndata.<span class=\"hljs-title function_\">head</span>()\n</code></pre>\n<h2>👥 사용자 이야기 III</h2>\n<div class=\"content-ad\"></div>\n<p>이제 aiosql을 사용하여 테이블을 생성할 것입니다. 만약 SQL 코드를 살펴보시면 # 기호가 추가된 것을 보실 수 있습니다. 이러한 기호들은 aiosql이 다양한 작업을 식별하는 데 사용됩니다.</p>\n<pre><code class=\"hljs language-js\">--<span class=\"hljs-attr\">name</span>: fn_create_survey_table#\n<span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TABLE</span> <span class=\"hljs-variable constant_\">HOSPITAL</span>.<span class=\"hljs-title function_\">VISIT_SURVEY</span>(\n <span class=\"hljs-variable constant_\">ID</span> <span class=\"hljs-variable constant_\">SERIAL</span> <span class=\"hljs-variable constant_\">PRIMARY</span> <span class=\"hljs-variable constant_\">KEY</span>,\n <span class=\"hljs-variable constant_\">PATIENT_ID</span> <span class=\"hljs-title function_\">VARCHAR</span>(<span class=\"hljs-number\">50</span>),\n <span class=\"hljs-variable constant_\">SURVEY_DATE</span> <span class=\"hljs-variable constant_\">TIMESTAMP</span>,\n <span class=\"hljs-variable constant_\">RATING</span> <span class=\"hljs-variable constant_\">INT</span>,\n <span class=\"hljs-variable constant_\">COMMENTS</span> <span class=\"hljs-variable constant_\">TEXT</span>,\n <span class=\"hljs-variable constant_\">CREATED_AT</span> <span class=\"hljs-variable constant_\">TIMESTAMP</span> <span class=\"hljs-variable constant_\">DEFAULT</span> <span class=\"hljs-variable constant_\">CURRENT_TIMESTAMP</span>\n);\n</code></pre>\n<img src=\"/assets/img/2024-06-19-PythonProjectswithSQLStrategiesforEffectiveQueryManagement_4.png\">\n<p>1️⃣ — 'fn_create_survey_table' SQL 함수를 실행하여 데이터베이스에 새 테이블을 만드세요.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">sql.<span class=\"hljs-title function_\">fn_create_survey_table</span>(conn)\n</code></pre>\n<pre><code class=\"hljs language-js\"># output\n<span class=\"hljs-variable constant_\">CREATE</span> <span class=\"hljs-variable constant_\">TABLE</span>\n</code></pre>\n<p>2️⃣ — 테이블이 생성되면 아래 삽입문을 사용하여 환자의 리뷰를 삽입할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\">-- <span class=\"hljs-attr\">name</span>: fn_add_one_visit_survey&#x3C;!\ninsert into <span class=\"hljs-variable constant_\">HOSPITAL</span>.<span class=\"hljs-title function_\">VISIT_SURVEY</span>(<span class=\"hljs-variable constant_\">PATIENT_ID</span>,<span class=\"hljs-variable constant_\">SURVEY_DATE</span>,<span class=\"hljs-variable constant_\">RATING</span>,<span class=\"hljs-variable constant_\">COMMENTS</span>) \n values (:patient_id, :survey_date, :rating,:comments) returning <span class=\"hljs-variable constant_\">ID</span>;\n</code></pre>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"># 새로운 방문 조사 레코드 추가\nsql.<span class=\"hljs-title function_\">fn_add_one_visit_survey</span>(conn, \n patient_id=<span class=\"hljs-string\">'8b9a93f6-3df3-203d-932f-f456e00d2c01'</span>, \n survey_date=<span class=\"hljs-string\">'2022-01-01'</span>, \n rating=<span class=\"hljs-number\">5</span>,\n comments=<span class=\"hljs-string\">'이 병원 정말 좋아요!'</span> )\n</code></pre>\n<p>3️⃣ — 이제 여러 리뷰를 로드하기 위해 새로운 삽입문을 활용할 것입니다. 이 리뷰들은 딕셔너리 목록에 저장되어 있습니다 (파이썬의 각 딕셔너리는 리뷰에 해당합니다). 이를 수행하기 위해 비슷한 쿼리를 활용하겠지만 그 이름을 수정해야 합니다.</p>\n<pre><code class=\"hljs language-js\">-- <span class=\"hljs-attr\">name</span>: fn_add_many_visit_survey*!\n insert into <span class=\"hljs-variable constant_\">HOSPITAL</span>.<span class=\"hljs-title function_\">VISIT_SURVEY</span>(<span class=\"hljs-variable constant_\">PATIENT_ID</span>,<span class=\"hljs-variable constant_\">SURVEY_DATE</span>,<span class=\"hljs-variable constant_\">RATING</span>,<span class=\"hljs-variable constant_\">COMMENTS</span>) \n values (:patient_id, :survey_date, :rating ,:comments) returning <span class=\"hljs-variable constant_\">ID</span>;\n</code></pre>\n<pre><code class=\"hljs language-js\"># 여러 방문 조사 레코드 추가\nresponse_survey = [\n     {\n       <span class=\"hljs-string\">'patient_id'</span>: <span class=\"hljs-string\">'8b9a93f6-3df3-203d-932f-f456e00d2c01'</span>,\n       <span class=\"hljs-string\">'survey_date'</span>: <span class=\"hljs-string\">'2022-01-01'</span>,\n       <span class=\"hljs-string\">'rating'</span>: <span class=\"hljs-number\">3</span>,\n       <span class=\"hljs-string\">'comments'</span>: <span class=\"hljs-string\">'서비스는 좋았어요. 다만 대기 시간이 조금 길었습니다.'</span>\n     },\n     {\n       <span class=\"hljs-string\">'patient_id'</span>: <span class=\"hljs-string\">'7c8a93f6-4df3-203d-932f-f456e00d2c02'</span>,\n       <span class=\"hljs-string\">'survey_date'</span>: <span class=\"hljs-string\">'2022-02-01'</span>,\n       <span class=\"hljs-string\">'rating'</span>: <span class=\"hljs-number\">4</span>,\n       <span class=\"hljs-string\">'comments'</span>: <span class=\"hljs-string\">'직원들이 매우 친절했어요!'</span>\n     },\n     {\n       <span class=\"hljs-string\">'patient_id'</span>: <span class=\"hljs-string\">'6b7a93f6-5ef3-203d-932f-f456e00d2c03'</span>,\n       <span class=\"hljs-string\">'survey_date'</span>: <span class=\"hljs-string\">'2022-03-01'</span>,\n       <span class=\"hljs-string\">'rating'</span>: <span class=\"hljs-number\">3</span>,\n       <span class=\"hljs-string\">'comments'</span>: <span class=\"hljs-string\">'대기 시간이 조금 길었습니다.'</span>\n     }\n]\nsql.<span class=\"hljs-title function_\">fn_add_many_visit_survey</span>(conn, response_survey)\n</code></pre>\n<div class=\"content-ad\"></div>\n<h1>📚 프로젝트 쿼리 카탈로그</h1>\n<p>튜토리얼 초반에는 프로젝트용 쿼리 카탈로그를 만들 수 있는 가능성을 언급했습니다. 이 라이브러리는 이 기능을 직접 제공하지는 않지만, 나의 GitHub 저장소에서 이 튜토리얼의 완전한 코드와 데이터에 액세스하여 이를 수행하는 방법을 확인할 수 있습니다.</p>\n<p>유용하게 사용하시면, ⭐️ 스타를 남겨주시고 새로운 글 알림을 받기 위해 팔로우해주시면 저에게 큰 도움이 됩니다. 기술 커뮤니티에서 성장하고 더 많은 콘텐츠를 제작할 수 있게 될 것입니다.</p>\n<h1>🔍 최종 결론</h1>\n<div class=\"content-ad\"></div>\n<ul>\n<li>다양성과 유틸리티: 저는 aiosql이 다른 프로젝트에서 쿼리를 효율적으로 구현할 수 있게 해주는 유용한 라이브러리라고 생각합니다. 이 라이브러리는 SQL 쿼리를 관리하고 실행하는 구조적인 방법을 제공하여 본 코드베이스와 별도로 처리할 수 있어 가독성과 유지 보수성을 향상시킵니다.</li>\n<li>유연한 쿼리 처리: aiosql은 데이터베이스 연결을 통해 쿼리를 직접 실행할 수 있는 환경을 제공하지만, 저의 프로젝트에서는 주로 Python 코드로 이미 설정한 클래스를 사용하여 SQL 코드를 반환하고 실행합니다.</li>\n<li>다른 데이터베이스: 쿼리를 저장하고 관리할 수 있는 기능은 SQL 데이터베이스를 넘어서기도 합니다. 예를 들어 이 접근 방식은 Neo4j와 같은 NoSQL 데이터베이스에도 적용할 수 있습니다. 구조적인 방식으로 쿼리를 구성하고 처리함으로써 다양한 유형의 데이터베이스와의 상호 작용을 최적화할 수 있습니다.</li>\n</ul>\n<h2>📚 참고 자료</h2>\n<p>학습하고 싶다면...</p>\n</body>\n</html>\n"},"__N_SSG":true}