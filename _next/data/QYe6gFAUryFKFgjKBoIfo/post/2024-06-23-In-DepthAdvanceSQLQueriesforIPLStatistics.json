{"pageProps":{"post":{"title":"IPL 통계 분석을 위한 고급 SQL 쿼리 완벽 가이드","description":"","date":"2024-06-23 16:34","slug":"2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics","content":"\n<img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_0.png\" />\n\n# 소개:\n\n상상해보세요. BCCI(인도크리켓통제위원회)에서 IPL 2150의 데이터 분석가로 고용되었다고 가정해 봅시다. 네, 2150 년에도 데이터 분석가는 여전히 높은 수요가 있고, AI가 아직 모든 일자리를 대체하지는 않았습니다. 누가 생각했겠습니까? 아마도 AI는 여전히 크리켓의 규칙을 이해하려고 노력 중일지도 모릅니다! 그런데, 이 프로젝트에서는 2150 년 자료가 제공되지 않습니다. 그래서 신경 쓰지 마세요.\n\n당신의 팀 매니저가 IPL 시즌 전체 기록을 포함하는 여러 CSV 파일을 손에 쥐고 여러분에게 접근합니다. 그들은 여러분에게 포괄적인 분석을 수행하고 이 데이터를 Postgres(RDBMS)로 이전하여 팀 내에서 더 효율적인 데이터 관리를 요청합니다.\n모든 데이터 집합과 마찬가지로, 도메인 지식은 데이터 분석가가 효과적으로 데이터 분석을 수행하는 데 중요합니다. IPL 크리켓에 익숙하지 않다면, 분석을 진행하기 전에 데이터 집합의 열을 먼저 살펴봄으로써 도메인 지식을 얻는 것이 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n# 데이터 세트:\n\nCSV 파일에는 아래 그림에 표시된 6개의 테이블이 포함되어 있으며, 이를 pgAdmin (postgreSQL의 RDMS)에서 다음 데이터베이스 스키마처럼 변환해야 합니다.\n실제 시나리오에서 기업은 일반적으로 CSV에서 SQL 데이터베이스로의 전환보다 DBMS(데이터베이스 관리 시스템)를 직접 사용합니다. 그러나 우리의 SQL 프로젝트 목적으로 이 전환이 수행되었습니다.\n\n<img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_1.png\" />\n\n제약 조건:\n\n<div class=\"content-ad\"></div>\n\n- 주어진 스키마에 포함된 기본 키 (Primary Key)와 외래 키 (Foreign Key) 제약 조건\n- out_type은 'caught', 'caught and bowled', 'bowled', 'stumped', 'retired hurt', 'keeper catch', 'lbw', 'run out', 'hit wicket', 또는 NULL(실제 null이 아닌 문자열 형태) 값만 가질 수 있습니다.\n- role_desc는 'Player', 'Keeper', 'CaptainKeeper' 또는 'Captain' 값만 가질 수 있습니다.\n- toss_name은 'field' 또는 'bat' 값만 가질 수 있습니다.\n- win_type은 'wickets', 'runs', 또는 NULL(실제 null이 아닌 문자열 형태) 값만 가질 수 있습니다.\n- ball_by_ball 테이블의 runs_scored 값은 0에서 6 사이여야 합니다.\n- ball_by_ball 테이블의 innings_no 값은 1 또는 2만 가능합니다.\n\n# 분석적 질문 및 해결책:\n\n자세한 분석을 위해 팀 매니저가 다음 작업을 할당하고 명확한 경로를 제시했습니다.\n\nQ 1: 주어진 데이터베이스 스키마에 따라 CSV 파일을 생성하고, 모든 제약 조건과 테이블 간 관계가 올바르게 반영되도록 하고, 그 후 pgAdmin에 가져오세요. (다른 RDBMS를 사용하는 경우, 모든 쿼리에 대해 구문을 조정하십시오)\n\n<div class=\"content-ad\"></div>\n\n해결책: 지정된 데이터베이스 스키마와 일치하도록 필요한 테이블을 적절한 제약 조건과 관계와 함께 생성하고 해당 CSV 파일에서 데이터를 가져옵니다.\n\n```js\n-- 해결책 1:\n-- 테이블을 생성할 때 위의 데이터베이스 스키마에 따라\n-- 필요한 제약 조건 및 관계 키를 추가해주세요\n\n-- venue 테이블 생성\ncreate table if not exists venue(\n venue_id int,\n venue_name varchar(50) not null,\n city_name varchar(50) not null,\n country_name varchar(50) not null,\n constraint pk_venue_venue_id primary key (venue_id)\n);\n-- venue.csv 파일에서 값 가져오기\ncopy venue\nfrom 'D:\\Downloads\\A Portfolio Projects\\SQL Projects\\IPL Analysis\\Dataset CSV\\venue.csv'\ndelimiter ','\ncsv header;\n\n-- team 테이블 생성\ncreate table if not exists team(\n team_id int,\n team_name varchar(50) not null,\n constraint pk_team_team_id primary key(team_id)\n);\n-- team.csv 파일에서 값 가져오기\ncopy team\nfrom 'D:\\Downloads\\A Portfolio Projects\\SQL Projects\\IPL Analysis\\Dataset CSV\\team.csv'\ndelimiter ','\ncsv header;\n\n-- player 테이블 생성\ncreate table if not exists player(\n player_id int,\n player_name varchar(50) not null,\n dob date not null,\n batting_hand varchar(50) not null,\n bowling_skill varchar(50) not null,\n country_name varchar(50) not null,\n constraint pk_player_player_id primary key(player_id)\n);\n-- player.csv 파일에서 값 가져오기\ncopy player\nfrom 'D:\\Downloads\\A Portfolio Projects\\SQL Projects\\IPL Analysis\\Dataset CSV\\player.csv'\ndelimiter ','\ncsv header;\n\n-- match 테이블 생성\ncreate table if not exists match(\n match_id int primary key,\n season_year int not null,\n team1 int not null references team(team_id),\n team2 int not null references team(team_id),\n venue_id int not null references venue(venue_id),\n toss_winner int not null references team(team_id),\n match_winner int not null references team(team_id),\n toss_name varchar(50) not null check(toss_name in ('field', 'bat')),\n win_type varchar(50) not null check(win_type in ('wickets', 'runs', 'NULL')),\n man_of_match int not null references player(player_id),\n win_margin int not null\n)\n-- match.csv 파일에서 값 가져오기\ncopy match\nfrom 'D:\\Downloads\\A Portfolio Projects\\SQL Projects\\IPL Analysis\\Dataset CSV\\match.csv'\ndelimiter ','\ncsv header;\n\n-- player_match 테이블 생성\ncreate table if not exists player_match(\n playermatch_key bigint primary key,\n match_id int not null references match(match_id),\n player_id int not null references player(player_id),\n role_desc varchar(50) not null check(role_desc in ('Player', 'Keeper', 'CaptainKeeper', 'Captain')),\n team_id int not null references team(team_id)\n);\n-- player_match.csv 파일에서 값 가져오기\ncopy player_match\nfrom 'D:\\Downloads\\A Portfolio Projects\\SQL Projects\\IPL Analysis\\Dataset CSV\\player_match.csv'\ndelimiter ','\ncsv header;\n\n-- ball_by_ball 테이블 생성\ncreate table if not exists ball_by_ball(\n match_id int not null references match(match_id),\n innings_no int not null check(innings_no<3 and innings_no>0),\n over_id int not null,\n ball_id int not null,\n runs_scored int not null check(runs_scored<=6 and runs_scored>=0),\n extra_runs int not null,\n out_type varchar(50) not null check(out_type in ('caught', 'caught and bowled', 'bowled', 'stumped', 'retired hurt', 'keeper catch', 'lbw', 'run out', 'hit wicket', 'NULL')),\n striker int not null references player(player_id),\n non_striker int not null references player(player_id),\n bowler int not null references player(player_id),\n constraint pk_ball_by_ball_id primary key(match_id, innings_no, over_id, ball_id)\n)\n-- ball_by_ball.csv 파일에서 값 가져오기\ncopy ball_by_ball\nfrom 'D:\\Downloads\\A Portfolio Projects\\SQL Projects\\IPL Analysis\\Dataset CSV\\ball_by_ball.csv'\ndelimiter ','\ncsv header;\n```\n\n질문 2: 생성한 테이블에서 각 경기장 마다 스코어된 평균 달성량을 찾으려면 스타디움에서 경기당 평균 달성량(두 팀의 총점)을 계산해야 합니다.\n총 점수를 계산하려면 ball_by_ball 테이블에서 runs_scored 및 extra_runs를 합산해야 합니다.\n\n해결책: 각 경기장에서 스코어된 평균 달성량을 찾으려면 다음 단계를 따라야 합니다. 먼저 각 경기장에서 플레이된 총 경기수를 계산하고, 그 다음 각 경기장에서 스코어된 총 점수를 결정합니다. 마지막으로 총 점수를 플레이된 경기수로 나누어 각 경기장의 경기 당 평균 달성량을 얻을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```sql\n-- 2단계: 각 구장에서의 경기 수 계산\nwith\nno_of_match_per_venue as\n (\n  select v.venue_id, v.venue_name, count(match_id) as no_of_matches\n  from match m\n  join venue v\n  on v.venue_id=m.venue_id\n  group by v.venue_id, v.venue_name\n ),\n-- 2단계: 각 구장에서의 총 득점 계산\ntotal_run_per_venue as\n (\n  select v.venue_id, sum(b.runs_scored+b.extra_runs) as total_run\n  from ball_by_ball b\n  join match m\n  on m.match_id = b.match_id\n  join venue v\n  on v.venue_id = m.venue_id\n  group by v.venue_id\n )\n-- 마지막으로 위의 두 임시 테이블을 사용하여\n-- 각 구장에서의 경기 당 평균 득점을 계산합니다\nselect  npv.venue_name, tpv.total_run, npv.no_of_matches,\nround(tpv.total_run/npv.no_of_matches::numeric,3) as avg_run\nfrom no_of_match_per_venue npv\njoin total_run_per_venue tpv\non npv.venue_id = tpv.venue_id\norder by avg_run desc;\n```\n\n![2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_2.png](/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_2.png)\n\n질문 3: 평균으로 경기 당 가장 많은 볼을 친 선수들을 찾고 상위 10명으로 제한하십시오.\n스트라이커로서 해당 선수가 등록된 경우 선수가 공을 쳤다고 간주합니다.\n\n해결책: 먼저 각 선수가 참가한 총 경기 수를 계산해야 합니다. 그 다음 각 선수가 스트라이커로서 받은 총 볼 수를 확인해야 합니다. 마지막으로 경기 당 평균으로 가장 많은 볼을 친 상위 10명의 선수를 식별할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n-- 솔루션 3:\n-- 단계 1: player_match 테이블에서 플레이어가 참가한 경기 수를 세기\nwith num_of_match_by_player as\n(\nselect player_id, count(match_id) as no_of_match from player_match\ngroup by player_id\n),\n-- 단계 2: 공격수로서 플레이어가 참가한 총 볼 수 계산\ntotal_ball_played_by_player as\n(\nselect striker, count(ball_id) as total_ball_played from ball_by_ball\ngroup by striker\n)\n-- 최종적으로 플레이어 당 평균 한 경기에서 가장 많이 볼을 친 상위 10명을 계산\nselect player_id, player_name, avg_ball_played from\n(\nselect \\*,\n-- 동률이 있는 경우를 포함하기 위해 rank 함수 사용\nrank() over(order by avg_ball_played desc) from\n(\n-- 평균 계산\nselect p.player_id, p.player_name,\n(tp.total_ball_played/mp.no_of_match) as avg_ball_played\nfrom num_of_match_by_player mp, total_ball_played_by_player tp, player p\nwhere mp.player_id = tp.striker\nand\np.player_id = mp.player_id\n)\n)\nwhere rank<=10; -- 상위 10개 가져오기\n\n![](/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_3.png)\n\nQ 4: 가장 빈도가 높은 6타자를 찾아보세요.\n즉, 플레이어가 차지한 볼 중에서 가장 높은 비율로 6점을 친 플레이어를 찾으세요. 플레이어 ID, 플레이어 이름, 플레이어가 6점을 얻은 횟수, 차진 볼 수, 6의 비율을 출력하세요.\n\n솔루션: 먼저 각 플레이어가 차진 볼 수를 계산합니다. 그런 다음, 각 플레이어가 친 6점을 결정합니다. 마지막으로 각 플레이어의 6의 비율을 계산하세요.\n\n<div class=\"content-ad\"></div>\n\n```sql\n-- Solution 4:\n-- 각 세션에서 각 선수가 참가한 공의 수 계산\nwith ball_by_player as(\n select striker, count(ball_id) as ball_played from ball_by_ball\n group by striker\n),\n-- 각 선수가 기록한 6점 수 계산\nsix_by_player as(\n select striker, count(ball_id) as no_of_six from ball_by_ball\n where runs_scored = 6\n group by striker\n)\n-- 최종 비율 얻기\nselect p.player_id, p.player_name, bp.ball_played, sp.no_of_six,\nround((sp.no_of_six::numeric/bp.ball_played),2) as fraction\nfrom ball_by_player as bp, six_by_player as sp, player as p\nwhere bp.striker = sp.striker and bp.striker = p.player_id\norder by fraction desc;\n```\n\n<img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_4.png\" />\n\nQ 5: 각 시즌에서 가장 많은 득점을 기록한 상위 3 타자 및 가장 많은 wickets를 따낸 상위 3 볼러 player_ids를 찾아보세요. Output (season_year, batsman, runs, bowler, wickets). 여기서 batsman 및 bowler는 선수들의 player_ids입니다. 동점인 경우 더 낮은 player_id를 먼저 출력합니다. season_year (날짜가 빠른 순)와 rank(특정 시즌에 더 많은 득점 및 wickets를 기록한 타자와 볼러)로 정렬합니다. (no_of_seasons\\*3)개의 행이 있을 것입니다.\n\nSolution: 먼저, 각 시즌에서 가장 많은 wickets를 기록한 상위 3 타자를 식별합니다. 다음으로, 각 시즌에서 가장 많은 wickets를 기록한 상위 3 볼러를 결정합니다. 마지막으로, 이러한 결과를 결합하여 최종 목록을 얻습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n-- 솔루션 5:\n-- 먼저 각 시즌에서 각각 가장 많은 횟수의 릴리를 기록한 상위 3명의 타자를 찾습니다.\nwith top_batsman as\n (\n select *,\n rank() over(partition by season_year order by run desc, striker) from\n  (\n  select m.season_year, b.striker, p.player_name, sum(runs_scored) as run\n  from ball_by_ball as b, match as m, player as p\n  where b.match_id = m.match_id and p.player_id = b.striker\n  group by m.season_year, b.striker, p.player_name\n  )\n ),\n-- 그리고 두 번째로, 각 시즌에서 각각 가장 많은 볼을 기록한 상위 3명의 볼러를 찾는다.\ntop_bowlers as(\n select *,\n rank() over(partition by season_year order by wicket desc, bowler) from\n  (\n  select m.season_year, b.bowler, p.player_name, count(out_type) as wicket\n  from ball_by_ball as b, match as m, player as p\n  where b.match_id = m.match_id and p.player_id = b.bowler\n  and b.out_type not in ('run out', 'retired hurt')\n  group by m.season_year, b.bowler, p.player_name\n  )\n )\n-- 위 두 가지를 조인하여 최종 결과를 얻으세요\nselect tbt.season_year, tbt.striker, tbt.player_name, tbt.run, tbo.bowler, tbo.player_name, tbo.wicket\nfrom top_batsman as tbt, top_bowlers as tbo\nwhere tbt.rank=tbo.rank and tbt.rank<=3 and tbo.rank<=3 and tbt.season_year = tbo.season_year\norder by season_year;\n```\n\n<img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_5.png\" />\n\n질문 6: 각 경기에서 최대 파트너십 득점을 달성한 선수의 ID를 찾기 위한 SQL 쿼리를 작성하세요. 결과에는 (match_id, player1, runs1, player2, runs2)가 포함되어야 하며, 파트너십 득점의 내림차순으로 정렬되어야 합니다. 동점의 경우 match_id가 오름차순으로 정렬되어야 합니다. runs1이 항상 runs2보다 큰지 확인하고, runs1과 runs2가 동일한 경우 player1_id가 player2_id보다 커야 합니다. extra_runs는 포함되어서는 안 됩니다. 서로 다른 선수가 동일한 파트너십 득점을 여러 번 달성하는 경우 각 경기의 여러 행이 존재할 수 있습니다.\n\n솔루션:\n단계 1- partnership이라는 공통 테이블 표현(CTE)을 사용하여 각 파트너십(경기 ID 및 연결된 선수 ID로 식별)이 가져온 총 득점(extr):\n단계 2- 다른 CTE인 striker_run_contributed는 각 파트너십에서 스트라이커가 기여한 총 득점을 계산합니다.\n단계 3- CTE final_table은 파트너십 득점을 스트라이커의 득점 기여와 결합하고, 비 스트라이커의 득점을 계산합니다. 각 경기의 최고 파트너십 득점만 포함하도록 필터링합니다.\n단계 4- 주 쿼리는 결과를 선택하고 정렬하여 더 높은 득점자가 항상 먼저 나오고 run1이 항상 run2보다 크도록 합니다. 두 선수가 동일한 득점인 경우 더 높은 ID를 가진 선수가 먼저 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n-- 질문 5:\n-- 각 경기에서 가장 많은 협력 득점을 얻은 플레이어들의 ID 찾기?\n-- 한 경기에 여러 개의 행이 있을 수 있습니다.\n-- 출력 (match_id, player1, runs1, player2, runs2),\n-- 협력 득점의 내림차순으로(동점인 경우 match_id는 오름차순으로 비교).\n-- 각 행에서 run1 > run2\n-- runs1=runs2인 경우 player1_id > player2_id. 참고: extra_runs는 계산하지 않아야 함\n-- 솔루션\n\nwith partnership as\n(\n select match_id, striker, non_striker, p_id, p_run from\n (\n  select *,\n  sum(runs_scored) over(partition by match_id, p_id order by match_id) as p_run,\n  row_number() over(partition by match_id, p_id order by match_id) as rank\n  from(\n   select b.match_id, b.runs_scored, b.striker, b.non_striker,\n   case when striker<non_striker then concat(non_striker,' ',striker)\n   else concat(striker, ' ', non_striker)\n   end as p_id\n   from ball_by_ball as b\n  )\n ) where rank=1\n order by p_run desc, match_id asc\n),\nstriker_run_contributed as\n (\n select b.match_id, b.striker, b.non_striker, sum(b.runs_scored) as striker_run\n from ball_by_ball as b\n group by b.match_id, b.striker, b.non_striker\n  ),\nfinal_table as\n(\n select p.match_id, p.striker, p.non_striker, sr.striker_run, (p.p_run-sr.striker_run) as non_striker_run,\n p.p_run\n from partnership as p, striker_run_contributed as sr\n where p.match_id = sr.match_id and p.striker = sr.striker and p.non_striker = sr.non_striker\n and p.p_run = (select max(p_run) from partnership as pt where pt.match_id = p.match_id)\n order by p.p_run desc, p.match_id asc\n  )\nselect match_id,\ncase when (striker_run = non_striker_run and striker>non_striker) then striker\n  when striker_run>non_striker_run then striker\n  else non_striker end as player_1,\ncase when (striker_run>non_striker_run) then striker_run\n  else non_striker_run end as run1,\ncase when (striker_run = non_striker_run and striker>non_striker) then non_striker\n  when striker_run>non_striker_run then non_striker\n  else striker end as player_2,\ncase when (striker_run>non_striker_run) then non_striker_run\n  else striker_run end as run2,\np_run as total_partnership\nfrom final_table;\n```\n\n<img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_6.png\" />\n\n질문 7: 이닝 유형이 wickets인 모든 경기에서 득점이 6점 미만인 이닝 ID를 찾으세요.\n출력 (match_id, innings_no, over_id). 참고: 이닝에서 득점된 점수에는 extra_runs도 포함됨.\n\n솔루션: 먼저 ball_by_ball 테이블과 이긴 경기 정보를 포함하는 match 테이블을 조인한 후, 득점이 6점 미만인 경우에 해당하는 over_id를 가져옵니다.\n\n<div class=\"content-ad\"></div>\n\n```sql\n-- 질문 7:\n-- 이닝 종료로 승리한 경기 중에서 6 미만의 점수를 기록한 이닝 ID를 찾아주세요.\n-- 출력 (match_id, innings_no, over_id). 참고: 이닝에서 기록된 점수에는 추가 점수도 포함됩니다.\n\n-- 해결 방법 7:\n\nselect b.match_id, b.innings_no, b.over_id\nfrom ball_by_ball as b\njoin match as m on m.match_id = b.match_id\nwhere win_type = 'wickets'\ngroup by b.match_id, b.innings_no, b.over_id\nhaving sum(b.runs_scored) + sum(extra_runs) < 6\n```\n\n![이미지](/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_7.png)\n\nQ 8: 2013 시즌에서 가장 많은 홈런을 친 상위 5명의 타자 나열하기?\n출력 (player_name).\n\n해결 방법: ball_by_ball 테이블을 match 테이블과 연결하여 시즌 연도를 얻고, player 테이블과 연결하여 선수명을 얻습니다. 2013년에 홈런을 세어 상위 5명을 제한하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```sql\n-- 질문 8:\n-- 2013 시즌에서 가장 많은 홈런을 친 상위 5명의 타자를 나열하십시오.\n-- 알파벳순으로 동점이 발생했을 경우를 고려하십시오. 결과 (선수 이름).\n\n-- 해결책 8:\nselect p.player_name from ball_by_ball as b, match as m, player as p\nwhere (b.match_id = m.match_id and b.striker = p.player_id)\nand (m.season_year = 2013 and b.runs_scored = 6)\ngroup by b.striker, p.player_name order by count(runs_scored) desc limit 5\n```\n\n![2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_8.png](/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_8.png)\n\nQ 9: 2013 시즌에서 가장 낮은 스트라이크 비율(평균 당 탈아웃당한 볼의 수)으로 상위 5명의 볼러를 나열하십시오. 알파벳순으로 동점이 발생했을 경우를 고려하십시오. 결과 (선수 이름).\n\n해결책: 우선 2013년에 각 선수가 얼마나 많은 아웃을 기록했는지를 계산하십시오. 'NULL', 'retired hurt', 'run out'과 같은 out_type은 볼러로 카운트되지 않습니다. 그래서 데이터 분석가는 데이터 세트에 대한 도메인 지식을 어느 정도 알고 있는 것이 중요합니다. 그런 다음 각 볼러가 한 공을 던진 횟수를 계산하십시오. 마지막으로 평균 비율을 구하고, 비율이 높을수록 볼러로서의 스트라이크 비율이 낮습니다.\n\n<div class=\"content-ad\"></div>\n\n```sql\n-- 질문 9: 2013 시즌에서 볼링 스트라이크율(얻은 퍼스트볼당 볼이 던져진 평균 수)이 가장 낮은 5명의 볼러를 나열하십시오. 알파벳순으로 동률 발생 시 이름순으로 정렬하십시오. 결과값은 (선수 이름)으로 출력합니다.\n\n-- 해결책 9:\nwith wicket as\n(\n select b.bowler, p.player_name, count(out_type) as no_of_wicket\n from ball_by_ball as b, player as p, match as m\n where (b.bowler = p.player_id and b.match_id = m.match_id)\n and (b.out_type not in ('NULL', 'retired hurt', 'run out')\n and m.season_year = 2013)\n group by b.bowler, p.player_name\n),\nballs as\n(\n select b.bowler, p.player_name, count(ball_id) as no_of_ball\n from ball_by_ball as b, player as p, match as m\n where (b.bowler = p.player_id and b.match_id = m.match_id)\n and m.season_year = 2013\n group by b.bowler, p.player_name\n\n)\nselect b.player_name, b.no_of_ball/w.no_of_wicket as ratio from wicket as w, balls as b\nwhere w.bowler = b.bowler\norder by ratio desc , b.player_name limit 5;\n```\n\n![이미지](/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_9.png)\n\nQ 10: 각 나라(적어도 한 명의 선수가 아웃 처리됨)별로 어떤 경기에서 볼 아웃된 선수의 수를 찾아내십시오? 결과값은 (나라 이름, 수)으로 출력합니다. 여기서 나라는 선수의 속한 국적입니다.\n\n해결책: 볼링 백볼 테이블을 선수 테이블과 조인하여 국가 이름을 얻고, out_type = \"볼드\"로 필터링합니다. 적어도 한 명의 선수가 있는 각 나라별로 볼드 아웃된 선수의 수를 그룹화하여 계산합니다.\n\n<div class=\"content-ad\"></div>\n\n```sql\n-- 질문 10:\n-- 적어도 한 명의 선수가 볼을 던진 나라마다\n-- 임의의 경기에서 볼 처리를 받은 플레이어의 수를 찾으세요.\n-- 출력 (country_name, count). 여기서 나라는 선수의 국적입니다.\n\n-- 해결 방법:\nselect p.country_name, count(striker) no_of_bowled_out\nfrom ball_by_ball as b, player as p\nwhere p.player_id = b.striker and b.out_type = 'bowled'\ngroup by p.country_name having count(striker) > 0 order by no_of_bowled_out desc\n```\n\n![이미지](/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_10.png)\n\nQ 11: ‘푸네’에서 진행된 임의의 경기에서 적어도 백을 득점한 오른손 타자의 이름을 나열해주세요? 출력 (player_name, run).\n\n해결 방법:\n\n<div class=\"content-ad\"></div>\n\n```sql\n-- 질문 11:\n-- 'Pune'에서 플레이된 모든 경기 중에서 적어도 한 번 센추리를 기록한 우포수 선수들의 이름을 나열하십시오. player_name을 알파벳순으로 출력하십시오.\n\n-- 해결책:\nselect p.player_name, sum(runs_scored) as run\nfrom ball_by_ball as b, match as m, venue as v, player as p\nwhere (b.match_id = m.match_id and m.venue_id = v.venue_id\n    and p.player_id = b.striker and v.city_name = 'Pune'\n    and p.batting_hand = 'Right-hand bat')\ngroup by b.striker, p.player_name having sum(runs_scored)>=100\norder by run desc, p.player_name;\n```\n\n![이미지](/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_11.png)\n\n보너스 질문:\n자체 해결해보기-\n적어도 한 번의 경기를 이겨온 모든 팀에 대한 승률을 찾으십시오(모든 시즌에 걸쳐). 팀 이름으로 알파벳순으로 결과를 정렬하십시오. 출력 (team_name, win_percentage).\n팀의 승률은 = (팀이 이긴 경기수 / 팀이 플레이한 총 경기수) \\* 100로 계산될 수 있습니다.\n참고: 소수점 셋째 자리까지 백분율로 계산하십시오.\n\n# 결론:\n\n<div class=\"content-ad\"></div>\n\n간단히 말씀드리자면, SQL을 사용하여 IPL 통계에 뛰어들어 본 것은 정말 즐거운 경험이었어요! 선수, 팀 및 경기에 관한 멋진 통찰력을 발견하여 트렌드와 우수한 성적을 눈에 띄게하기 쉬웠습니다.\n\n저의 Github 저장소를 참조하여 SQL 쿼리, 질문 및 데이터셋을 이용할 수 있습니다.\n\n도움이 되었기를 바라며 다시 한번 감사합니다.\n","ogImage":{"url":"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_0.png"},"coverImage":"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_0.png","tag":["Tech"],"readingTime":18},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_0.png\">\n<h1>소개:</h1>\n<p>상상해보세요. BCCI(인도크리켓통제위원회)에서 IPL 2150의 데이터 분석가로 고용되었다고 가정해 봅시다. 네, 2150 년에도 데이터 분석가는 여전히 높은 수요가 있고, AI가 아직 모든 일자리를 대체하지는 않았습니다. 누가 생각했겠습니까? 아마도 AI는 여전히 크리켓의 규칙을 이해하려고 노력 중일지도 모릅니다! 그런데, 이 프로젝트에서는 2150 년 자료가 제공되지 않습니다. 그래서 신경 쓰지 마세요.</p>\n<p>당신의 팀 매니저가 IPL 시즌 전체 기록을 포함하는 여러 CSV 파일을 손에 쥐고 여러분에게 접근합니다. 그들은 여러분에게 포괄적인 분석을 수행하고 이 데이터를 Postgres(RDBMS)로 이전하여 팀 내에서 더 효율적인 데이터 관리를 요청합니다.\n모든 데이터 집합과 마찬가지로, 도메인 지식은 데이터 분석가가 효과적으로 데이터 분석을 수행하는 데 중요합니다. IPL 크리켓에 익숙하지 않다면, 분석을 진행하기 전에 데이터 집합의 열을 먼저 살펴봄으로써 도메인 지식을 얻는 것이 좋습니다.</p>\n<div class=\"content-ad\"></div>\n<h1>데이터 세트:</h1>\n<p>CSV 파일에는 아래 그림에 표시된 6개의 테이블이 포함되어 있으며, 이를 pgAdmin (postgreSQL의 RDMS)에서 다음 데이터베이스 스키마처럼 변환해야 합니다.\n실제 시나리오에서 기업은 일반적으로 CSV에서 SQL 데이터베이스로의 전환보다 DBMS(데이터베이스 관리 시스템)를 직접 사용합니다. 그러나 우리의 SQL 프로젝트 목적으로 이 전환이 수행되었습니다.</p>\n<img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_1.png\">\n<p>제약 조건:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>주어진 스키마에 포함된 기본 키 (Primary Key)와 외래 키 (Foreign Key) 제약 조건</li>\n<li>out_type은 'caught', 'caught and bowled', 'bowled', 'stumped', 'retired hurt', 'keeper catch', 'lbw', 'run out', 'hit wicket', 또는 NULL(실제 null이 아닌 문자열 형태) 값만 가질 수 있습니다.</li>\n<li>role_desc는 'Player', 'Keeper', 'CaptainKeeper' 또는 'Captain' 값만 가질 수 있습니다.</li>\n<li>toss_name은 'field' 또는 'bat' 값만 가질 수 있습니다.</li>\n<li>win_type은 'wickets', 'runs', 또는 NULL(실제 null이 아닌 문자열 형태) 값만 가질 수 있습니다.</li>\n<li>ball_by_ball 테이블의 runs_scored 값은 0에서 6 사이여야 합니다.</li>\n<li>ball_by_ball 테이블의 innings_no 값은 1 또는 2만 가능합니다.</li>\n</ul>\n<h1>분석적 질문 및 해결책:</h1>\n<p>자세한 분석을 위해 팀 매니저가 다음 작업을 할당하고 명확한 경로를 제시했습니다.</p>\n<p>Q 1: 주어진 데이터베이스 스키마에 따라 CSV 파일을 생성하고, 모든 제약 조건과 테이블 간 관계가 올바르게 반영되도록 하고, 그 후 pgAdmin에 가져오세요. (다른 RDBMS를 사용하는 경우, 모든 쿼리에 대해 구문을 조정하십시오)</p>\n<div class=\"content-ad\"></div>\n<p>해결책: 지정된 데이터베이스 스키마와 일치하도록 필요한 테이블을 적절한 제약 조건과 관계와 함께 생성하고 해당 CSV 파일에서 데이터를 가져옵니다.</p>\n<pre><code class=\"hljs language-js\">-- 해결책 <span class=\"hljs-number\">1</span>:\n-- 테이블을 생성할 때 위의 데이터베이스 스키마에 따라\n-- 필요한 제약 조건 및 관계 키를 추가해주세요\n\n-- venue 테이블 생성\ncreate table <span class=\"hljs-keyword\">if</span> not exists <span class=\"hljs-title function_\">venue</span>(\n venue_id int,\n venue_name <span class=\"hljs-title function_\">varchar</span>(<span class=\"hljs-number\">50</span>) not <span class=\"hljs-literal\">null</span>,\n city_name <span class=\"hljs-title function_\">varchar</span>(<span class=\"hljs-number\">50</span>) not <span class=\"hljs-literal\">null</span>,\n country_name <span class=\"hljs-title function_\">varchar</span>(<span class=\"hljs-number\">50</span>) not <span class=\"hljs-literal\">null</span>,\n constraint pk_venue_venue_id primary key (venue_id)\n);\n-- venue.<span class=\"hljs-property\">csv</span> 파일에서 값 가져오기\ncopy venue\n<span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'D:\\Downloads\\A Portfolio Projects\\SQL Projects\\IPL Analysis\\Dataset CSV\\venue.csv'</span>\ndelimiter <span class=\"hljs-string\">','</span>\ncsv header;\n\n-- team 테이블 생성\ncreate table <span class=\"hljs-keyword\">if</span> not exists <span class=\"hljs-title function_\">team</span>(\n team_id int,\n team_name <span class=\"hljs-title function_\">varchar</span>(<span class=\"hljs-number\">50</span>) not <span class=\"hljs-literal\">null</span>,\n constraint pk_team_team_id primary <span class=\"hljs-title function_\">key</span>(team_id)\n);\n-- team.<span class=\"hljs-property\">csv</span> 파일에서 값 가져오기\ncopy team\n<span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'D:\\Downloads\\A Portfolio Projects\\SQL Projects\\IPL Analysis\\Dataset CSV\\team.csv'</span>\ndelimiter <span class=\"hljs-string\">','</span>\ncsv header;\n\n-- player 테이블 생성\ncreate table <span class=\"hljs-keyword\">if</span> not exists <span class=\"hljs-title function_\">player</span>(\n player_id int,\n player_name <span class=\"hljs-title function_\">varchar</span>(<span class=\"hljs-number\">50</span>) not <span class=\"hljs-literal\">null</span>,\n dob date not <span class=\"hljs-literal\">null</span>,\n batting_hand <span class=\"hljs-title function_\">varchar</span>(<span class=\"hljs-number\">50</span>) not <span class=\"hljs-literal\">null</span>,\n bowling_skill <span class=\"hljs-title function_\">varchar</span>(<span class=\"hljs-number\">50</span>) not <span class=\"hljs-literal\">null</span>,\n country_name <span class=\"hljs-title function_\">varchar</span>(<span class=\"hljs-number\">50</span>) not <span class=\"hljs-literal\">null</span>,\n constraint pk_player_player_id primary <span class=\"hljs-title function_\">key</span>(player_id)\n);\n-- player.<span class=\"hljs-property\">csv</span> 파일에서 값 가져오기\ncopy player\n<span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'D:\\Downloads\\A Portfolio Projects\\SQL Projects\\IPL Analysis\\Dataset CSV\\player.csv'</span>\ndelimiter <span class=\"hljs-string\">','</span>\ncsv header;\n\n-- match 테이블 생성\ncreate table <span class=\"hljs-keyword\">if</span> not exists <span class=\"hljs-title function_\">match</span>(\n match_id int primary key,\n season_year int not <span class=\"hljs-literal\">null</span>,\n team1 int not <span class=\"hljs-literal\">null</span> references <span class=\"hljs-title function_\">team</span>(team_id),\n team2 int not <span class=\"hljs-literal\">null</span> references <span class=\"hljs-title function_\">team</span>(team_id),\n venue_id int not <span class=\"hljs-literal\">null</span> references <span class=\"hljs-title function_\">venue</span>(venue_id),\n toss_winner int not <span class=\"hljs-literal\">null</span> references <span class=\"hljs-title function_\">team</span>(team_id),\n match_winner int not <span class=\"hljs-literal\">null</span> references <span class=\"hljs-title function_\">team</span>(team_id),\n toss_name <span class=\"hljs-title function_\">varchar</span>(<span class=\"hljs-number\">50</span>) not <span class=\"hljs-literal\">null</span> <span class=\"hljs-title function_\">check</span>(toss_name <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-string\">'field'</span>, <span class=\"hljs-string\">'bat'</span>)),\n win_type <span class=\"hljs-title function_\">varchar</span>(<span class=\"hljs-number\">50</span>) not <span class=\"hljs-literal\">null</span> <span class=\"hljs-title function_\">check</span>(win_type <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-string\">'wickets'</span>, <span class=\"hljs-string\">'runs'</span>, <span class=\"hljs-string\">'NULL'</span>)),\n man_of_match int not <span class=\"hljs-literal\">null</span> references <span class=\"hljs-title function_\">player</span>(player_id),\n win_margin int not <span class=\"hljs-literal\">null</span>\n)\n-- match.<span class=\"hljs-property\">csv</span> 파일에서 값 가져오기\ncopy match\n<span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'D:\\Downloads\\A Portfolio Projects\\SQL Projects\\IPL Analysis\\Dataset CSV\\match.csv'</span>\ndelimiter <span class=\"hljs-string\">','</span>\ncsv header;\n\n-- player_match 테이블 생성\ncreate table <span class=\"hljs-keyword\">if</span> not exists <span class=\"hljs-title function_\">player_match</span>(\n playermatch_key bigint primary key,\n match_id int not <span class=\"hljs-literal\">null</span> references <span class=\"hljs-title function_\">match</span>(match_id),\n player_id int not <span class=\"hljs-literal\">null</span> references <span class=\"hljs-title function_\">player</span>(player_id),\n role_desc <span class=\"hljs-title function_\">varchar</span>(<span class=\"hljs-number\">50</span>) not <span class=\"hljs-literal\">null</span> <span class=\"hljs-title function_\">check</span>(role_desc <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-string\">'Player'</span>, <span class=\"hljs-string\">'Keeper'</span>, <span class=\"hljs-string\">'CaptainKeeper'</span>, <span class=\"hljs-string\">'Captain'</span>)),\n team_id int not <span class=\"hljs-literal\">null</span> references <span class=\"hljs-title function_\">team</span>(team_id)\n);\n-- player_match.<span class=\"hljs-property\">csv</span> 파일에서 값 가져오기\ncopy player_match\n<span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'D:\\Downloads\\A Portfolio Projects\\SQL Projects\\IPL Analysis\\Dataset CSV\\player_match.csv'</span>\ndelimiter <span class=\"hljs-string\">','</span>\ncsv header;\n\n-- ball_by_ball 테이블 생성\ncreate table <span class=\"hljs-keyword\">if</span> not exists <span class=\"hljs-title function_\">ball_by_ball</span>(\n match_id int not <span class=\"hljs-literal\">null</span> references <span class=\"hljs-title function_\">match</span>(match_id),\n innings_no int not <span class=\"hljs-literal\">null</span> <span class=\"hljs-title function_\">check</span>(innings_no&#x3C;<span class=\"hljs-number\">3</span> and innings_no><span class=\"hljs-number\">0</span>),\n over_id int not <span class=\"hljs-literal\">null</span>,\n ball_id int not <span class=\"hljs-literal\">null</span>,\n runs_scored int not <span class=\"hljs-literal\">null</span> <span class=\"hljs-title function_\">check</span>(runs_scored&#x3C;=<span class=\"hljs-number\">6</span> and runs_scored>=<span class=\"hljs-number\">0</span>),\n extra_runs int not <span class=\"hljs-literal\">null</span>,\n out_type <span class=\"hljs-title function_\">varchar</span>(<span class=\"hljs-number\">50</span>) not <span class=\"hljs-literal\">null</span> <span class=\"hljs-title function_\">check</span>(out_type <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-string\">'caught'</span>, <span class=\"hljs-string\">'caught and bowled'</span>, <span class=\"hljs-string\">'bowled'</span>, <span class=\"hljs-string\">'stumped'</span>, <span class=\"hljs-string\">'retired hurt'</span>, <span class=\"hljs-string\">'keeper catch'</span>, <span class=\"hljs-string\">'lbw'</span>, <span class=\"hljs-string\">'run out'</span>, <span class=\"hljs-string\">'hit wicket'</span>, <span class=\"hljs-string\">'NULL'</span>)),\n striker int not <span class=\"hljs-literal\">null</span> references <span class=\"hljs-title function_\">player</span>(player_id),\n non_striker int not <span class=\"hljs-literal\">null</span> references <span class=\"hljs-title function_\">player</span>(player_id),\n bowler int not <span class=\"hljs-literal\">null</span> references <span class=\"hljs-title function_\">player</span>(player_id),\n constraint pk_ball_by_ball_id primary <span class=\"hljs-title function_\">key</span>(match_id, innings_no, over_id, ball_id)\n)\n-- ball_by_ball.<span class=\"hljs-property\">csv</span> 파일에서 값 가져오기\ncopy ball_by_ball\n<span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'D:\\Downloads\\A Portfolio Projects\\SQL Projects\\IPL Analysis\\Dataset CSV\\ball_by_ball.csv'</span>\ndelimiter <span class=\"hljs-string\">','</span>\ncsv header;\n</code></pre>\n<p>질문 2: 생성한 테이블에서 각 경기장 마다 스코어된 평균 달성량을 찾으려면 스타디움에서 경기당 평균 달성량(두 팀의 총점)을 계산해야 합니다.\n총 점수를 계산하려면 ball_by_ball 테이블에서 runs_scored 및 extra_runs를 합산해야 합니다.</p>\n<p>해결책: 각 경기장에서 스코어된 평균 달성량을 찾으려면 다음 단계를 따라야 합니다. 먼저 각 경기장에서 플레이된 총 경기수를 계산하고, 그 다음 각 경기장에서 스코어된 총 점수를 결정합니다. 마지막으로 총 점수를 플레이된 경기수로 나누어 각 경기장의 경기 당 평균 달성량을 얻을 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">-- 2단계: 각 구장에서의 경기 수 계산</span>\n<span class=\"hljs-keyword\">with</span>\nno_of_match_per_venue <span class=\"hljs-keyword\">as</span>\n (\n  <span class=\"hljs-keyword\">select</span> v.venue_id, v.venue_name, <span class=\"hljs-built_in\">count</span>(match_id) <span class=\"hljs-keyword\">as</span> no_of_matches\n  <span class=\"hljs-keyword\">from</span> <span class=\"hljs-keyword\">match</span> m\n  <span class=\"hljs-keyword\">join</span> venue v\n  <span class=\"hljs-keyword\">on</span> v.venue_id<span class=\"hljs-operator\">=</span>m.venue_id\n  <span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> v.venue_id, v.venue_name\n ),\n<span class=\"hljs-comment\">-- 2단계: 각 구장에서의 총 득점 계산</span>\ntotal_run_per_venue <span class=\"hljs-keyword\">as</span>\n (\n  <span class=\"hljs-keyword\">select</span> v.venue_id, <span class=\"hljs-built_in\">sum</span>(b.runs_scored<span class=\"hljs-operator\">+</span>b.extra_runs) <span class=\"hljs-keyword\">as</span> total_run\n  <span class=\"hljs-keyword\">from</span> ball_by_ball b\n  <span class=\"hljs-keyword\">join</span> <span class=\"hljs-keyword\">match</span> m\n  <span class=\"hljs-keyword\">on</span> m.match_id <span class=\"hljs-operator\">=</span> b.match_id\n  <span class=\"hljs-keyword\">join</span> venue v\n  <span class=\"hljs-keyword\">on</span> v.venue_id <span class=\"hljs-operator\">=</span> m.venue_id\n  <span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> v.venue_id\n )\n<span class=\"hljs-comment\">-- 마지막으로 위의 두 임시 테이블을 사용하여</span>\n<span class=\"hljs-comment\">-- 각 구장에서의 경기 당 평균 득점을 계산합니다</span>\n<span class=\"hljs-keyword\">select</span>  npv.venue_name, tpv.total_run, npv.no_of_matches,\nround(tpv.total_run<span class=\"hljs-operator\">/</span>npv.no_of_matches::<span class=\"hljs-type\">numeric</span>,<span class=\"hljs-number\">3</span>) <span class=\"hljs-keyword\">as</span> avg_run\n<span class=\"hljs-keyword\">from</span> no_of_match_per_venue npv\n<span class=\"hljs-keyword\">join</span> total_run_per_venue tpv\n<span class=\"hljs-keyword\">on</span> npv.venue_id <span class=\"hljs-operator\">=</span> tpv.venue_id\n<span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> avg_run <span class=\"hljs-keyword\">desc</span>;\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_2.png\" alt=\"2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_2.png\"></p>\n<p>질문 3: 평균으로 경기 당 가장 많은 볼을 친 선수들을 찾고 상위 10명으로 제한하십시오.\n스트라이커로서 해당 선수가 등록된 경우 선수가 공을 쳤다고 간주합니다.</p>\n<p>해결책: 먼저 각 선수가 참가한 총 경기 수를 계산해야 합니다. 그 다음 각 선수가 스트라이커로서 받은 총 볼 수를 확인해야 합니다. 마지막으로 경기 당 평균으로 가장 많은 볼을 친 상위 10명의 선수를 식별할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>-- 솔루션 3:\n-- 단계 1: player_match 테이블에서 플레이어가 참가한 경기 수를 세기\nwith num_of_match_by_player as\n(\nselect player_id, count(match_id) as no_of_match from player_match\ngroup by player_id\n),\n-- 단계 2: 공격수로서 플레이어가 참가한 총 볼 수 계산\ntotal_ball_played_by_player as\n(\nselect striker, count(ball_id) as total_ball_played from ball_by_ball\ngroup by striker\n)\n-- 최종적으로 플레이어 당 평균 한 경기에서 가장 많이 볼을 친 상위 10명을 계산\nselect player_id, player_name, avg_ball_played from\n(\nselect *,\n-- 동률이 있는 경우를 포함하기 위해 rank 함수 사용\nrank() over(order by avg_ball_played desc) from\n(\n-- 평균 계산\nselect p.player_id, p.player_name,\n(tp.total_ball_played/mp.no_of_match) as avg_ball_played\nfrom num_of_match_by_player mp, total_ball_played_by_player tp, player p\nwhere mp.player_id = tp.striker\nand\np.player_id = mp.player_id\n)\n)\nwhere rank&#x3C;=10; -- 상위 10개 가져오기</p>\n<p><img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_3.png\" alt=\"\"></p>\n<p>Q 4: 가장 빈도가 높은 6타자를 찾아보세요.\n즉, 플레이어가 차지한 볼 중에서 가장 높은 비율로 6점을 친 플레이어를 찾으세요. 플레이어 ID, 플레이어 이름, 플레이어가 6점을 얻은 횟수, 차진 볼 수, 6의 비율을 출력하세요.</p>\n<p>솔루션: 먼저 각 플레이어가 차진 볼 수를 계산합니다. 그런 다음, 각 플레이어가 친 6점을 결정합니다. 마지막으로 각 플레이어의 6의 비율을 계산하세요.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">-- Solution 4:</span>\n<span class=\"hljs-comment\">-- 각 세션에서 각 선수가 참가한 공의 수 계산</span>\n<span class=\"hljs-keyword\">with</span> ball_by_player <span class=\"hljs-keyword\">as</span>(\n <span class=\"hljs-keyword\">select</span> striker, <span class=\"hljs-built_in\">count</span>(ball_id) <span class=\"hljs-keyword\">as</span> ball_played <span class=\"hljs-keyword\">from</span> ball_by_ball\n <span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> striker\n),\n<span class=\"hljs-comment\">-- 각 선수가 기록한 6점 수 계산</span>\nsix_by_player <span class=\"hljs-keyword\">as</span>(\n <span class=\"hljs-keyword\">select</span> striker, <span class=\"hljs-built_in\">count</span>(ball_id) <span class=\"hljs-keyword\">as</span> no_of_six <span class=\"hljs-keyword\">from</span> ball_by_ball\n <span class=\"hljs-keyword\">where</span> runs_scored <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">6</span>\n <span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> striker\n)\n<span class=\"hljs-comment\">-- 최종 비율 얻기</span>\n<span class=\"hljs-keyword\">select</span> p.player_id, p.player_name, bp.ball_played, sp.no_of_six,\nround((sp.no_of_six::<span class=\"hljs-type\">numeric</span><span class=\"hljs-operator\">/</span>bp.ball_played),<span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">as</span> fraction\n<span class=\"hljs-keyword\">from</span> ball_by_player <span class=\"hljs-keyword\">as</span> bp, six_by_player <span class=\"hljs-keyword\">as</span> sp, player <span class=\"hljs-keyword\">as</span> p\n<span class=\"hljs-keyword\">where</span> bp.striker <span class=\"hljs-operator\">=</span> sp.striker <span class=\"hljs-keyword\">and</span> bp.striker <span class=\"hljs-operator\">=</span> p.player_id\n<span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> fraction <span class=\"hljs-keyword\">desc</span>;\n</code></pre>\n<img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_4.png\">\n<p>Q 5: 각 시즌에서 가장 많은 득점을 기록한 상위 3 타자 및 가장 많은 wickets를 따낸 상위 3 볼러 player_ids를 찾아보세요. Output (season_year, batsman, runs, bowler, wickets). 여기서 batsman 및 bowler는 선수들의 player_ids입니다. 동점인 경우 더 낮은 player_id를 먼저 출력합니다. season_year (날짜가 빠른 순)와 rank(특정 시즌에 더 많은 득점 및 wickets를 기록한 타자와 볼러)로 정렬합니다. (no_of_seasons*3)개의 행이 있을 것입니다.</p>\n<p>Solution: 먼저, 각 시즌에서 가장 많은 wickets를 기록한 상위 3 타자를 식별합니다. 다음으로, 각 시즌에서 가장 많은 wickets를 기록한 상위 3 볼러를 결정합니다. 마지막으로, 이러한 결과를 결합하여 최종 목록을 얻습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">-- 솔루션 <span class=\"hljs-number\">5</span>:\n-- 먼저 각 시즌에서 각각 가장 많은 횟수의 릴리를 기록한 상위 <span class=\"hljs-number\">3</span>명의 타자를 찾습니다.\n<span class=\"hljs-keyword\">with</span> top_batsman <span class=\"hljs-keyword\">as</span>\n (\n select *,\n <span class=\"hljs-title function_\">rank</span>() <span class=\"hljs-title function_\">over</span>(partition by season_year order by run desc, striker) <span class=\"hljs-keyword\">from</span>\n  (\n  select m.<span class=\"hljs-property\">season_year</span>, b.<span class=\"hljs-property\">striker</span>, p.<span class=\"hljs-property\">player_name</span>, <span class=\"hljs-title function_\">sum</span>(runs_scored) <span class=\"hljs-keyword\">as</span> run\n  <span class=\"hljs-keyword\">from</span> ball_by_ball <span class=\"hljs-keyword\">as</span> b, match <span class=\"hljs-keyword\">as</span> m, player <span class=\"hljs-keyword\">as</span> p\n  where b.<span class=\"hljs-property\">match_id</span> = m.<span class=\"hljs-property\">match_id</span> and p.<span class=\"hljs-property\">player_id</span> = b.<span class=\"hljs-property\">striker</span>\n  group by m.<span class=\"hljs-property\">season_year</span>, b.<span class=\"hljs-property\">striker</span>, p.<span class=\"hljs-property\">player_name</span>\n  )\n ),\n-- 그리고 두 번째로, 각 시즌에서 각각 가장 많은 볼을 기록한 상위 <span class=\"hljs-number\">3</span>명의 볼러를 찾는다.\ntop_bowlers <span class=\"hljs-title function_\">as</span>(\n select *,\n <span class=\"hljs-title function_\">rank</span>() <span class=\"hljs-title function_\">over</span>(partition by season_year order by wicket desc, bowler) <span class=\"hljs-keyword\">from</span>\n  (\n  select m.<span class=\"hljs-property\">season_year</span>, b.<span class=\"hljs-property\">bowler</span>, p.<span class=\"hljs-property\">player_name</span>, <span class=\"hljs-title function_\">count</span>(out_type) <span class=\"hljs-keyword\">as</span> wicket\n  <span class=\"hljs-keyword\">from</span> ball_by_ball <span class=\"hljs-keyword\">as</span> b, match <span class=\"hljs-keyword\">as</span> m, player <span class=\"hljs-keyword\">as</span> p\n  where b.<span class=\"hljs-property\">match_id</span> = m.<span class=\"hljs-property\">match_id</span> and p.<span class=\"hljs-property\">player_id</span> = b.<span class=\"hljs-property\">bowler</span>\n  and b.<span class=\"hljs-property\">out_type</span> not <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-string\">'run out'</span>, <span class=\"hljs-string\">'retired hurt'</span>)\n  group by m.<span class=\"hljs-property\">season_year</span>, b.<span class=\"hljs-property\">bowler</span>, p.<span class=\"hljs-property\">player_name</span>\n  )\n )\n-- 위 두 가지를 조인하여 최종 결과를 얻으세요\nselect tbt.<span class=\"hljs-property\">season_year</span>, tbt.<span class=\"hljs-property\">striker</span>, tbt.<span class=\"hljs-property\">player_name</span>, tbt.<span class=\"hljs-property\">run</span>, tbo.<span class=\"hljs-property\">bowler</span>, tbo.<span class=\"hljs-property\">player_name</span>, tbo.<span class=\"hljs-property\">wicket</span>\n<span class=\"hljs-keyword\">from</span> top_batsman <span class=\"hljs-keyword\">as</span> tbt, top_bowlers <span class=\"hljs-keyword\">as</span> tbo\nwhere tbt.<span class=\"hljs-property\">rank</span>=tbo.<span class=\"hljs-property\">rank</span> and tbt.<span class=\"hljs-property\">rank</span>&#x3C;=<span class=\"hljs-number\">3</span> and tbo.<span class=\"hljs-property\">rank</span>&#x3C;=<span class=\"hljs-number\">3</span> and tbt.<span class=\"hljs-property\">season_year</span> = tbo.<span class=\"hljs-property\">season_year</span>\norder by season_year;\n</code></pre>\n<img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_5.png\">\n<p>질문 6: 각 경기에서 최대 파트너십 득점을 달성한 선수의 ID를 찾기 위한 SQL 쿼리를 작성하세요. 결과에는 (match_id, player1, runs1, player2, runs2)가 포함되어야 하며, 파트너십 득점의 내림차순으로 정렬되어야 합니다. 동점의 경우 match_id가 오름차순으로 정렬되어야 합니다. runs1이 항상 runs2보다 큰지 확인하고, runs1과 runs2가 동일한 경우 player1_id가 player2_id보다 커야 합니다. extra_runs는 포함되어서는 안 됩니다. 서로 다른 선수가 동일한 파트너십 득점을 여러 번 달성하는 경우 각 경기의 여러 행이 존재할 수 있습니다.</p>\n<p>솔루션:\n단계 1- partnership이라는 공통 테이블 표현(CTE)을 사용하여 각 파트너십(경기 ID 및 연결된 선수 ID로 식별)이 가져온 총 득점(extr):\n단계 2- 다른 CTE인 striker_run_contributed는 각 파트너십에서 스트라이커가 기여한 총 득점을 계산합니다.\n단계 3- CTE final_table은 파트너십 득점을 스트라이커의 득점 기여와 결합하고, 비 스트라이커의 득점을 계산합니다. 각 경기의 최고 파트너십 득점만 포함하도록 필터링합니다.\n단계 4- 주 쿼리는 결과를 선택하고 정렬하여 더 높은 득점자가 항상 먼저 나오고 run1이 항상 run2보다 크도록 합니다. 두 선수가 동일한 득점인 경우 더 높은 ID를 가진 선수가 먼저 표시됩니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">-- 질문 <span class=\"hljs-number\">5</span>:\n-- 각 경기에서 가장 많은 협력 득점을 얻은 플레이어들의 <span class=\"hljs-variable constant_\">ID</span> 찾기?\n-- 한 경기에 여러 개의 행이 있을 수 있습니다.\n-- 출력 (match_id, player1, runs1, player2, runs2),\n-- 협력 득점의 내림차순으로(동점인 경우 match_id는 오름차순으로 비교).\n-- 각 행에서 run1 > run2\n-- runs1=runs2인 경우 player1_id > player2_id. 참고: extra_runs는 계산하지 않아야 함\n-- 솔루션\n\n<span class=\"hljs-keyword\">with</span> partnership <span class=\"hljs-keyword\">as</span>\n(\n select match_id, striker, non_striker, p_id, p_run <span class=\"hljs-keyword\">from</span>\n (\n  select *,\n  <span class=\"hljs-title function_\">sum</span>(runs_scored) <span class=\"hljs-title function_\">over</span>(partition by match_id, p_id order by match_id) <span class=\"hljs-keyword\">as</span> p_run,\n  <span class=\"hljs-title function_\">row_number</span>() <span class=\"hljs-title function_\">over</span>(partition by match_id, p_id order by match_id) <span class=\"hljs-keyword\">as</span> rank\n  <span class=\"hljs-title function_\">from</span>(\n   select b.<span class=\"hljs-property\">match_id</span>, b.<span class=\"hljs-property\">runs_scored</span>, b.<span class=\"hljs-property\">striker</span>, b.<span class=\"hljs-property\">non_striker</span>,\n   <span class=\"hljs-keyword\">case</span> when striker&#x3C;non_striker then <span class=\"hljs-title function_\">concat</span>(non_striker,<span class=\"hljs-string\">' '</span>,striker)\n   <span class=\"hljs-keyword\">else</span> <span class=\"hljs-title function_\">concat</span>(striker, <span class=\"hljs-string\">' '</span>, non_striker)\n   end <span class=\"hljs-keyword\">as</span> p_id\n   <span class=\"hljs-keyword\">from</span> ball_by_ball <span class=\"hljs-keyword\">as</span> b\n  )\n ) where rank=<span class=\"hljs-number\">1</span>\n order by p_run desc, match_id asc\n),\nstriker_run_contributed <span class=\"hljs-keyword\">as</span>\n (\n select b.<span class=\"hljs-property\">match_id</span>, b.<span class=\"hljs-property\">striker</span>, b.<span class=\"hljs-property\">non_striker</span>, <span class=\"hljs-title function_\">sum</span>(b.<span class=\"hljs-property\">runs_scored</span>) <span class=\"hljs-keyword\">as</span> striker_run\n <span class=\"hljs-keyword\">from</span> ball_by_ball <span class=\"hljs-keyword\">as</span> b\n group by b.<span class=\"hljs-property\">match_id</span>, b.<span class=\"hljs-property\">striker</span>, b.<span class=\"hljs-property\">non_striker</span>\n  ),\nfinal_table <span class=\"hljs-keyword\">as</span>\n(\n select p.<span class=\"hljs-property\">match_id</span>, p.<span class=\"hljs-property\">striker</span>, p.<span class=\"hljs-property\">non_striker</span>, sr.<span class=\"hljs-property\">striker_run</span>, (p.<span class=\"hljs-property\">p_run</span>-sr.<span class=\"hljs-property\">striker_run</span>) <span class=\"hljs-keyword\">as</span> non_striker_run,\n p.<span class=\"hljs-property\">p_run</span>\n <span class=\"hljs-keyword\">from</span> partnership <span class=\"hljs-keyword\">as</span> p, striker_run_contributed <span class=\"hljs-keyword\">as</span> sr\n where p.<span class=\"hljs-property\">match_id</span> = sr.<span class=\"hljs-property\">match_id</span> and p.<span class=\"hljs-property\">striker</span> = sr.<span class=\"hljs-property\">striker</span> and p.<span class=\"hljs-property\">non_striker</span> = sr.<span class=\"hljs-property\">non_striker</span>\n and p.<span class=\"hljs-property\">p_run</span> = (select <span class=\"hljs-title function_\">max</span>(p_run) <span class=\"hljs-keyword\">from</span> partnership <span class=\"hljs-keyword\">as</span> pt where pt.<span class=\"hljs-property\">match_id</span> = p.<span class=\"hljs-property\">match_id</span>)\n order by p.<span class=\"hljs-property\">p_run</span> desc, p.<span class=\"hljs-property\">match_id</span> asc\n  )\nselect match_id,\n<span class=\"hljs-keyword\">case</span> when (striker_run = non_striker_run and striker>non_striker) then striker\n  when striker_run>non_striker_run then striker\n  <span class=\"hljs-keyword\">else</span> non_striker end <span class=\"hljs-keyword\">as</span> player_1,\n<span class=\"hljs-keyword\">case</span> when (striker_run>non_striker_run) then striker_run\n  <span class=\"hljs-keyword\">else</span> non_striker_run end <span class=\"hljs-keyword\">as</span> run1,\n<span class=\"hljs-keyword\">case</span> when (striker_run = non_striker_run and striker>non_striker) then non_striker\n  when striker_run>non_striker_run then non_striker\n  <span class=\"hljs-keyword\">else</span> striker end <span class=\"hljs-keyword\">as</span> player_2,\n<span class=\"hljs-keyword\">case</span> when (striker_run>non_striker_run) then non_striker_run\n  <span class=\"hljs-keyword\">else</span> striker_run end <span class=\"hljs-keyword\">as</span> run2,\np_run <span class=\"hljs-keyword\">as</span> total_partnership\n<span class=\"hljs-keyword\">from</span> final_table;\n</code></pre>\n<img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_6.png\">\n<p>질문 7: 이닝 유형이 wickets인 모든 경기에서 득점이 6점 미만인 이닝 ID를 찾으세요.\n출력 (match_id, innings_no, over_id). 참고: 이닝에서 득점된 점수에는 extra_runs도 포함됨.</p>\n<p>솔루션: 먼저 ball_by_ball 테이블과 이긴 경기 정보를 포함하는 match 테이블을 조인한 후, 득점이 6점 미만인 경우에 해당하는 over_id를 가져옵니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">-- 질문 7:</span>\n<span class=\"hljs-comment\">-- 이닝 종료로 승리한 경기 중에서 6 미만의 점수를 기록한 이닝 ID를 찾아주세요.</span>\n<span class=\"hljs-comment\">-- 출력 (match_id, innings_no, over_id). 참고: 이닝에서 기록된 점수에는 추가 점수도 포함됩니다.</span>\n\n<span class=\"hljs-comment\">-- 해결 방법 7:</span>\n\n<span class=\"hljs-keyword\">select</span> b.match_id, b.innings_no, b.over_id\n<span class=\"hljs-keyword\">from</span> ball_by_ball <span class=\"hljs-keyword\">as</span> b\n<span class=\"hljs-keyword\">join</span> <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">as</span> m <span class=\"hljs-keyword\">on</span> m.match_id <span class=\"hljs-operator\">=</span> b.match_id\n<span class=\"hljs-keyword\">where</span> win_type <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">'wickets'</span>\n<span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> b.match_id, b.innings_no, b.over_id\n<span class=\"hljs-keyword\">having</span> <span class=\"hljs-built_in\">sum</span>(b.runs_scored) <span class=\"hljs-operator\">+</span> <span class=\"hljs-built_in\">sum</span>(extra_runs) <span class=\"hljs-operator\">&#x3C;</span> <span class=\"hljs-number\">6</span>\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_7.png\" alt=\"이미지\"></p>\n<p>Q 8: 2013 시즌에서 가장 많은 홈런을 친 상위 5명의 타자 나열하기?\n출력 (player_name).</p>\n<p>해결 방법: ball_by_ball 테이블을 match 테이블과 연결하여 시즌 연도를 얻고, player 테이블과 연결하여 선수명을 얻습니다. 2013년에 홈런을 세어 상위 5명을 제한하겠습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">-- 질문 8:</span>\n<span class=\"hljs-comment\">-- 2013 시즌에서 가장 많은 홈런을 친 상위 5명의 타자를 나열하십시오.</span>\n<span class=\"hljs-comment\">-- 알파벳순으로 동점이 발생했을 경우를 고려하십시오. 결과 (선수 이름).</span>\n\n<span class=\"hljs-comment\">-- 해결책 8:</span>\n<span class=\"hljs-keyword\">select</span> p.player_name <span class=\"hljs-keyword\">from</span> ball_by_ball <span class=\"hljs-keyword\">as</span> b, <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">as</span> m, player <span class=\"hljs-keyword\">as</span> p\n<span class=\"hljs-keyword\">where</span> (b.match_id <span class=\"hljs-operator\">=</span> m.match_id <span class=\"hljs-keyword\">and</span> b.striker <span class=\"hljs-operator\">=</span> p.player_id)\n<span class=\"hljs-keyword\">and</span> (m.season_year <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2013</span> <span class=\"hljs-keyword\">and</span> b.runs_scored <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">6</span>)\n<span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> b.striker, p.player_name <span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> <span class=\"hljs-built_in\">count</span>(runs_scored) <span class=\"hljs-keyword\">desc</span> limit <span class=\"hljs-number\">5</span>\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_8.png\" alt=\"2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_8.png\"></p>\n<p>Q 9: 2013 시즌에서 가장 낮은 스트라이크 비율(평균 당 탈아웃당한 볼의 수)으로 상위 5명의 볼러를 나열하십시오. 알파벳순으로 동점이 발생했을 경우를 고려하십시오. 결과 (선수 이름).</p>\n<p>해결책: 우선 2013년에 각 선수가 얼마나 많은 아웃을 기록했는지를 계산하십시오. 'NULL', 'retired hurt', 'run out'과 같은 out_type은 볼러로 카운트되지 않습니다. 그래서 데이터 분석가는 데이터 세트에 대한 도메인 지식을 어느 정도 알고 있는 것이 중요합니다. 그런 다음 각 볼러가 한 공을 던진 횟수를 계산하십시오. 마지막으로 평균 비율을 구하고, 비율이 높을수록 볼러로서의 스트라이크 비율이 낮습니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">-- 질문 9: 2013 시즌에서 볼링 스트라이크율(얻은 퍼스트볼당 볼이 던져진 평균 수)이 가장 낮은 5명의 볼러를 나열하십시오. 알파벳순으로 동률 발생 시 이름순으로 정렬하십시오. 결과값은 (선수 이름)으로 출력합니다.</span>\n\n<span class=\"hljs-comment\">-- 해결책 9:</span>\n<span class=\"hljs-keyword\">with</span> wicket <span class=\"hljs-keyword\">as</span>\n(\n <span class=\"hljs-keyword\">select</span> b.bowler, p.player_name, <span class=\"hljs-built_in\">count</span>(out_type) <span class=\"hljs-keyword\">as</span> no_of_wicket\n <span class=\"hljs-keyword\">from</span> ball_by_ball <span class=\"hljs-keyword\">as</span> b, player <span class=\"hljs-keyword\">as</span> p, <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">as</span> m\n <span class=\"hljs-keyword\">where</span> (b.bowler <span class=\"hljs-operator\">=</span> p.player_id <span class=\"hljs-keyword\">and</span> b.match_id <span class=\"hljs-operator\">=</span> m.match_id)\n <span class=\"hljs-keyword\">and</span> (b.out_type <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-string\">'NULL'</span>, <span class=\"hljs-string\">'retired hurt'</span>, <span class=\"hljs-string\">'run out'</span>)\n <span class=\"hljs-keyword\">and</span> m.season_year <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2013</span>)\n <span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> b.bowler, p.player_name\n),\nballs <span class=\"hljs-keyword\">as</span>\n(\n <span class=\"hljs-keyword\">select</span> b.bowler, p.player_name, <span class=\"hljs-built_in\">count</span>(ball_id) <span class=\"hljs-keyword\">as</span> no_of_ball\n <span class=\"hljs-keyword\">from</span> ball_by_ball <span class=\"hljs-keyword\">as</span> b, player <span class=\"hljs-keyword\">as</span> p, <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">as</span> m\n <span class=\"hljs-keyword\">where</span> (b.bowler <span class=\"hljs-operator\">=</span> p.player_id <span class=\"hljs-keyword\">and</span> b.match_id <span class=\"hljs-operator\">=</span> m.match_id)\n <span class=\"hljs-keyword\">and</span> m.season_year <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2013</span>\n <span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> b.bowler, p.player_name\n\n)\n<span class=\"hljs-keyword\">select</span> b.player_name, b.no_of_ball<span class=\"hljs-operator\">/</span>w.no_of_wicket <span class=\"hljs-keyword\">as</span> ratio <span class=\"hljs-keyword\">from</span> wicket <span class=\"hljs-keyword\">as</span> w, balls <span class=\"hljs-keyword\">as</span> b\n<span class=\"hljs-keyword\">where</span> w.bowler <span class=\"hljs-operator\">=</span> b.bowler\n<span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> ratio <span class=\"hljs-keyword\">desc</span> , b.player_name limit <span class=\"hljs-number\">5</span>;\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_9.png\" alt=\"이미지\"></p>\n<p>Q 10: 각 나라(적어도 한 명의 선수가 아웃 처리됨)별로 어떤 경기에서 볼 아웃된 선수의 수를 찾아내십시오? 결과값은 (나라 이름, 수)으로 출력합니다. 여기서 나라는 선수의 속한 국적입니다.</p>\n<p>해결책: 볼링 백볼 테이블을 선수 테이블과 조인하여 국가 이름을 얻고, out_type = \"볼드\"로 필터링합니다. 적어도 한 명의 선수가 있는 각 나라별로 볼드 아웃된 선수의 수를 그룹화하여 계산합니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">-- 질문 10:</span>\n<span class=\"hljs-comment\">-- 적어도 한 명의 선수가 볼을 던진 나라마다</span>\n<span class=\"hljs-comment\">-- 임의의 경기에서 볼 처리를 받은 플레이어의 수를 찾으세요.</span>\n<span class=\"hljs-comment\">-- 출력 (country_name, count). 여기서 나라는 선수의 국적입니다.</span>\n\n<span class=\"hljs-comment\">-- 해결 방법:</span>\n<span class=\"hljs-keyword\">select</span> p.country_name, <span class=\"hljs-built_in\">count</span>(striker) no_of_bowled_out\n<span class=\"hljs-keyword\">from</span> ball_by_ball <span class=\"hljs-keyword\">as</span> b, player <span class=\"hljs-keyword\">as</span> p\n<span class=\"hljs-keyword\">where</span> p.player_id <span class=\"hljs-operator\">=</span> b.striker <span class=\"hljs-keyword\">and</span> b.out_type <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">'bowled'</span>\n<span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> p.country_name <span class=\"hljs-keyword\">having</span> <span class=\"hljs-built_in\">count</span>(striker) <span class=\"hljs-operator\">></span> <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> no_of_bowled_out <span class=\"hljs-keyword\">desc</span>\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_10.png\" alt=\"이미지\"></p>\n<p>Q 11: ‘푸네’에서 진행된 임의의 경기에서 적어도 백을 득점한 오른손 타자의 이름을 나열해주세요? 출력 (player_name, run).</p>\n<p>해결 방법:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-comment\">-- 질문 11:</span>\n<span class=\"hljs-comment\">-- 'Pune'에서 플레이된 모든 경기 중에서 적어도 한 번 센추리를 기록한 우포수 선수들의 이름을 나열하십시오. player_name을 알파벳순으로 출력하십시오.</span>\n\n<span class=\"hljs-comment\">-- 해결책:</span>\n<span class=\"hljs-keyword\">select</span> p.player_name, <span class=\"hljs-built_in\">sum</span>(runs_scored) <span class=\"hljs-keyword\">as</span> run\n<span class=\"hljs-keyword\">from</span> ball_by_ball <span class=\"hljs-keyword\">as</span> b, <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">as</span> m, venue <span class=\"hljs-keyword\">as</span> v, player <span class=\"hljs-keyword\">as</span> p\n<span class=\"hljs-keyword\">where</span> (b.match_id <span class=\"hljs-operator\">=</span> m.match_id <span class=\"hljs-keyword\">and</span> m.venue_id <span class=\"hljs-operator\">=</span> v.venue_id\n    <span class=\"hljs-keyword\">and</span> p.player_id <span class=\"hljs-operator\">=</span> b.striker <span class=\"hljs-keyword\">and</span> v.city_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">'Pune'</span>\n    <span class=\"hljs-keyword\">and</span> p.batting_hand <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">'Right-hand bat'</span>)\n<span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> b.striker, p.player_name <span class=\"hljs-keyword\">having</span> <span class=\"hljs-built_in\">sum</span>(runs_scored)<span class=\"hljs-operator\">>=</span><span class=\"hljs-number\">100</span>\n<span class=\"hljs-keyword\">order</span> <span class=\"hljs-keyword\">by</span> run <span class=\"hljs-keyword\">desc</span>, p.player_name;\n</code></pre>\n<p><img src=\"/assets/img/2024-06-23-In-DepthAdvanceSQLQueriesforIPLStatistics_11.png\" alt=\"이미지\"></p>\n<p>보너스 질문:\n자체 해결해보기-\n적어도 한 번의 경기를 이겨온 모든 팀에 대한 승률을 찾으십시오(모든 시즌에 걸쳐). 팀 이름으로 알파벳순으로 결과를 정렬하십시오. 출력 (team_name, win_percentage).\n팀의 승률은 = (팀이 이긴 경기수 / 팀이 플레이한 총 경기수) * 100로 계산될 수 있습니다.\n참고: 소수점 셋째 자리까지 백분율로 계산하십시오.</p>\n<h1>결론:</h1>\n<div class=\"content-ad\"></div>\n<p>간단히 말씀드리자면, SQL을 사용하여 IPL 통계에 뛰어들어 본 것은 정말 즐거운 경험이었어요! 선수, 팀 및 경기에 관한 멋진 통찰력을 발견하여 트렌드와 우수한 성적을 눈에 띄게하기 쉬웠습니다.</p>\n<p>저의 Github 저장소를 참조하여 SQL 쿼리, 질문 및 데이터셋을 이용할 수 있습니다.</p>\n<p>도움이 되었기를 바라며 다시 한번 감사합니다.</p>\n</body>\n</html>\n"},"__N_SSG":true}