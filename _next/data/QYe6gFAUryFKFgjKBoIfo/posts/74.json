{"pageProps":{"posts":[{"title":"데이터 과학 채용 면접이 오지 않나요 시각성 문제가 있을 수 있습니다","description":"","date":"2024-06-19 16:19","slug":"2024-06-19-NotGettingDataScienceJobInterviewsYouHaveAVisibilityProblem","content":"\n\n취업중이신가요? 무료 5페이지 프로젝트 아이디어 안내서를 활용하여 개인 프로젝트를 개발하여 경쟁력을 확보하세요.\n\n다음에 데이터 과학 직무에 지원할 때 모든 것을 시도해봤다고 생각할 때, 기억해 두세요. 제가 한테서 일했던 사람 중 한 명이 작업 후... 웃기죠. 패러디 랩으로 직장을 구한 사람이 있었어요. 그 후보자는 이민엠이나 칠디시 감비노와 협업을 희망하지는 않지만 작업은 저명한 인턴쉽을 획들하는 데에 성공했어요. 이 작업은 10,000명 이상의 지원자들 중에서 선발되었습니다.\n\n엔터테인먼트 제작이라는 엄청난 경쟁이 일상인 세계에 파도를 쳐들기 위해 산업 경험(혹은 엘리트 컨택트)이 부족하다고 인식한 지원자 Jake는 도전적인 프로젝트에 착수했어요. 그는 Blackalicious의 \"알파벳 에어로빅\"을 샷-포-샷으로 재창작할 것이라고 결심했습니다.\n\n2014년 다니엘 래드클리프가 쇼에서 이 노래를 부르는 모습을 봤었기 때문에 이 노래를 선택한 게 아니었습니다.\n\n<div class=\"content-ad\"></div>\n\n물론, 예기치 못한 일이 있었습니다. 제이크는 쇼 직원들의 일에 관심을 갖고 가사를 재작성했습니다.\n\n그가 관례적인 인터뷰 요청을 기다리는 동안, 예상치 못한 반응을 받았습니다; 주인공 지미 팰런이 직접 그를 고용했습니다.*\n\n이 이야기를 비관적으로 해석하면: 그가 극단적인 조치를 취하지 않았다면 그 직업을 얻지 못했을 것이라는 겁니다.\n\n저는 보다 낙천적인 태도를 취하여, 그가 목적을 가지고 창의적이고, 무엇보다 중요한 점은 그가 노력했다는 것을 생각합니다.\n\n<div class=\"content-ad\"></div>\n\n데이터 과학 직무에 지원하는 모든 사람은 Jake의 예를 통해 자신만의 독특한 명함을 활용해 볼 수 있고, 당신을 뒷받침하는 업무가 없는 상태에서 어떤 대담한 내기도 무례하게 들릴 수 있다는 것을 깨닫게 될 거예요.\n\n![Jake's Example](/assets/img/2024-06-19-NotGettingDataScienceJobInterviewsYouHaveAVisibilityProblem_0.png)\n\n솔직히 말해서, 제이크와 저는 2017년 가을 Tonight에서 잠깐 겹쳤어요.\n\n만약 10,000명의 지원자 풀이 당신에게 와 닿는다면, 아마도 LinkedIn에서 많은 시간을 취업 지원에 사용했고 아마도 이 프롬프트를 본 적이 있을 거예요: \"다른 지원자 100명 (또는 1,000명 또는 10,000명)과 어떻게 비교되는지 확인해 보세요.\"\n\n<div class=\"content-ad\"></div>\n\n거의 모든 삶의 측면에서 경쟁 분석에 대한 자리가 있지만, 구직자가 너무 많은 정보(TMI)를 제공하는 것도 있습니다.\n\n그런 측정치가 후보자들의 유효성에 대해 투명하지 않다는 것도 말이죠. 기본 자격 요건을 충족하는 사람은 누구이며, 실제로 회사 사이트에 방문했는지, 그리고 “지금 신청”을 한 사람은 누군지, 아마도 가장 중요한 것은 봇인가요.\n\n좋은 소식은 대부분의 직업의 기본 자격 요건을 충족했다면 좋은 상태에 있습니다. 하지만, 당신이 그러하듯이, 특히 입문자 포지션은 경험을 얻기 위해서는 경험이 필요한 악순환입니다.\n\n특히 데이터 과학 시장이 점점 더 빡빡해지고 있는 상황에서, 혼자서도 존중받을만한 지원자로 자리잡기 위해서는 자기 인식과 균형이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n근무자 유리한 채용 주기에서는, 단지 무슨 일을 잘하거나 하고자하는 데 있어 개인적으로 뛰어나다는 것만으로 충분하지 않습니다.\n\n이제 공개적으로 활동해 보세요. 커뮤니티의 중심 지점에 참여하거나 시작하여, 자신을 채용 관리자와 채용 담당자들에게 눈에 띄게 만들어 주세요. 이를 통해 이력서를 던지거나 자동 거부 이메일을 발송하고 있는 채용 담당자와 차별화되어 보일 수 있습니다.\n\n명확하게 이렇게 말하고 싶어요. 더 많은 시야를 확보해야 한다고 할 때, LinkedIn 제목을 넣어서 프로필의 순위를 높여야 하는 의미가 아닙니다. 솔직히 말하자면, 당신이 자격이 없는 일이나 관심 없는 직무에 대해 연락을 받는 것은 원하는 것이 아닐 것입니다.\n\n그것은 모두의 시간을 낭비하는 일이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n졸업 후 하루만에 링크드인에 먼저 자리를 구할 것을 의미하지는 않아요. 데이터 과학 분야의 적임자로서 인식받기 위한 다음 단계는 다음과 같아요:\n\n- 데이터 과학 분야에서 돋보이는 독특한 기술 또는 가치 제안을 식별해 보세요.\n- 능력을 과시하는 (이 부분에 대해 의도적으로 개방적으로 말하고 있어요) 어떤 일을 하고, 그 결과물을 명함처럼 활용해 보세요.\n- 관리자들이 자주 방문할 것으로 예상되는 커뮤니티나 포럼을 식별하고 연결하세요. 링크드인도 좋지만, 매니저들이 머물 수 있는 많은 다른 플랫폼이 있어요. 예를 들어, GitHub, Glassdoor 및 Medium 등이 있어요.\n- 자신의 명함을 과시하세요.\n- 과정을 설명하세요.\n- 귀하의 작업에 관심 있는 사람들과 연락을 취하세요 - 아마도 인재영입자/매니저들일 거에요.\n\n## 가장 이상적인 상황\n\n<div class=\"content-ad\"></div>\n\nML 모델이 마음에 들지 않지만 대시보드 디자인에 큰 만족을 느끼는군요. 그러나 모든 사람들이 대시보드를 만들고 싶어하며 또 다른 Titanic 생존자의 막대 플롯을 보고 싶어하지 않는다고요.\n\n우연히도, 데이터 과학 숙제를 하면서 MLB를 많이 보고 있었습니다. 조금씩 통계 애호가가 되었습니다. 심지어 근처의 MLB 팀에서 데이터 분석가로 지원하는 것도 고려해봤습니다 (아마 뉴욕에 여러 팀이 있을 것으로 생각됩니다).\n\n동시에, Michael Lewis의 Moneyball을 읽고 있었고 Billy Beane가 섭외한 선수들에 대한 통계를 파헤치고 있습니다.\n\n수업에 지루해지자, 그 시대의 오클랜드 에스를 위한 스카우팅 대시보드를 만들어 사이드 프로젝트를 시작하기로 결심했습니다. 몇 주 동안 노력하여 대시보드를 만들어 자랑스러워하며 LinkedIn에 공유하기로 결정했습니다.\n\n<div class=\"content-ad\"></div>\n\nReddit의 r/dataisbeautiful(2000만 명 이상의 데이터 시각화 커뮤니티) 커뮤니티와 공유하도록 권장하는 연결 메시지가 도착했어요. 초기 대시보드에 대해 게시하는 것 외에도 Medium에서 접근 방법과 얻은 교훈에 대해 설명한 두 부분으로 된 시리즈를 작성했어요. 이 모든 것을 r/dataisbeautiful 게시물에 링크해놓았어요.\n\n잠복 중인 채용 매니저가 연락을 해와서 면접에 초대해 주었어요.\n\n비록 이 극적인 시나리오가 그렇게 매끄럽게 일어나는 경우는 드물겠지만, 표면상으로는 우연한 일들처럼 보이는 것에 드는 수많은 시간과 노력을 강조하고 싶어요.\n\n먼저, 우리 가정의 후보는 MLB 게임을 100시간 이상 지켜가며 데이터를 세심하게 기록하고 분석했어요. 그들은 인상적인 도메인 지식을 발전시키는데 그치지 않고 동시에 주도적으로 자신만의 데이터를 확보했습니다.\n\n<div class=\"content-ad\"></div>\n\n그들은 수업 외에도 관련성 있는 (하지만 재미있는) 데이터 과학 독해 자료를 읽으며 '머니볼'을 읽었습니다.\n\nLooker와 같은 기본 도구 대신 프로그래밍 방식으로 대시보드를 구축함으로써, 그들은 효과적인 데이터 분석가가 되기 위해 필요한 기술과 디자인 능력을 보여 주었습니다.\n\n그들이 자신의 작업을 공유하는 용기를 가지면, 그것은 주기적이고 쓰고 다듬어진 결과물이기 때문에 숙제 과제보다는 캡스톤 프로젝트나 학위 논문과 유사합니다.\n\n그리고 Medium에 '비하인드 더 신스'를 게시함으로써, 후보자는 채용 공고에서 자주 볼 수 있는 기술을 갖추고 있다는 것을 보여줍니다: \"비기술 관객을 위해 복잡한 기술 개념을 단순화할 수 있는 능력이 필요합니다.\"\n\n<div class=\"content-ad\"></div>\n\n이건 누군가가 \"나를 봐\"라고 하는 경우가 아니라, 누군가가 자신의 기술을 개발하는 이야기입니다.\n\n왜냐하면 짐작했을 것처럼, 이 이야기에는 행복한 결말이 없는 많은 방법들이 있다.\n\n제이크 이야기에서 가장 놀라운 측면 중 하나는 그의 고용에 대해 알게 된 것이 아닌, 그의 예가 무엇이 아닌지를 보는 사람들을 위해 느낀 간접적인 창피 기분이었습니다. 단축키가 아닌 것에 대해 그가 보여준 그 예에서 느낀 놀라움이었습니다.\n\n제이크가 비디오를 게시한 직후, NBCU의 엄격한 고용 절차 우회를 위한 빠른 길을 드러냈습니다. (디즈니 용어에 대해 죄송합니다)\n\n<div class=\"content-ad\"></div>\n\n\"투나잇 쇼 랩\"을 검색하면 이제 제이크가 출었던 영상 뿐만 아니라 똑같은 것을 하는 다른 수백 개의 영상도 나옵니다. 하지만 그들은 제작 품질이 낮은 나쁜 작품들이었습니다.\n\n요약하자면 이들은 독특한 아이디어의 모방이 아니라 대중들 사이에서 돋보이려는 진정성과 신중한 노력이 반영되지 않았기 때문에 나쁘다고 할 수 있습니다.\n\n부가 프로젝트를 만들 때 가능한 한 자신이 진정으로 알고 관심을 가지고 있는 것을 선택하세요. 제이크와 달리, 첫 번째 시도에서 당신의 후보 자격을 알릴 수 있는 확률은 매우 낮습니다.\n\n그래서 프로필을 끌어올리는 마지막 구성 요소는 일관성입니다.\"\n\n<div class=\"content-ad\"></div>\n\n고등학교 선생님 중 한 분이 계속 반복하던 주제를 가져왔어요. \"일관성이 최고야.\"\n\n당신의 지원을 시각적으로 부각시킬 수 있는 방법이 무엇이든 선택하셨다면, 그것이 반복 가능한 것임을 확인하세요. 첫 대시보드로 두 번째 눈길을 끄는 데 필요한 것은 아니기 때문에 몇 번 반복하는 것이 좋습니다.\n\n당신의 가시성과 신뢰성을 높이기 위해 전문가들이 깜짝 놀랐던 Medium에 처음 글을 쓸 때처럼, 큰 팔로워나 인기 있는 글이 없더라도 훌륭한 인터뷰를 기대할 수 있습니다.\n\n다시 말해, 그들이 감동받은 것은 결과물이 아니라 작품을 홍보하기 위한 용기와 노력(제품을 만드는 기술에 더해)이었습니다.\n\n<div class=\"content-ad\"></div>\n\n제이크의 원본 비디오는 30만 회 조회되었고, 그가 고용된 세그먼트는 수백만 회 조회를 기록했습니다. 때때로 좋은 어플리케이션은 그 자체로 이력서에 올라갈 만한 가치가 있는 것을 증명했죠.\n\n도와주실 수 있을까요? 이 블로그 이외에 어떻게 도와드릴 수 있는지 알려주시기 위해 3가지 질문으로 된 설문 조사에 한 분만 투자해 주세요. 모든 응답자께는 무료 선물이 제공됩니다.","ogImage":{"url":"/assets/img/2024-06-19-NotGettingDataScienceJobInterviewsYouHaveAVisibilityProblem_0.png"},"coverImage":"/assets/img/2024-06-19-NotGettingDataScienceJobInterviewsYouHaveAVisibilityProblem_0.png","tag":["Tech"],"readingTime":6},{"title":"데이터 엔지니어가 직면하는 다섯 가지 무자비한 진실","description":"","date":"2024-06-19 16:18","slug":"2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer","content":"\n\n\n![Five Brutal Truths About Being a Data Engineer](/assets/img/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer_0.png)\n\nI like my job! 🙂\n\nI really do!\n\nBut sometimes I have that feeling...\n\n\n<div class=\"content-ad\"></div>\n\n저는 그냥 노트북을 창문 밖으로 버리고 농부가 되고 싶어요. 😡\n\n모든 직업에는 면접 과정 중에 거의 다루지 않는 혹독한 진실이 있어요.\n\n당신이 데이터 엔지니어로 일할 때 알아야 할 5가지 혹독한 진실을 배울 거에요.\n\n나는 이것들을 제 경험을 바탕으로 만들었어요.\n\n<div class=\"content-ad\"></div>\n\n# 데이터는 종종 지저분하고 불완전해요\n\n![image](/assets/img/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer_1.png)\n\n프로젝트를 들어가서 기대하는 것은 깔끔하고 완전한 데이터셋(튜토리얼이나 수업 자료처럼)을 다루는 것이라면...\n\n그냥 잊으세요!\n\n<div class=\"content-ad\"></div>\n\n진짜 데이터셋들은 깨끗하지 않고, 완전하지 않고, 그저... \"아름답지\" 않아요! 😒\n\n데이터 엔지니어들은 분석, 시각화 또는 모델에 사용하기 전에 데이터를 정리하고 처리하는 데 상당한 시간을 투자합니다.\n\n# 요구 사항은 자주 변경될 수 있습니다\n\n![이미지](/assets/img/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer_2.png)\n\n<div class=\"content-ad\"></div>\n\n이것은 소프트웨어 엔지니어링 개발의 전형적인 사례이며, 따라서 데이터 엔지니어링에서도 매우 \"고전\"적이다.\n\n비즈니스 요구사항이 신속하게 변화할 수 있으며, 데이터 엔지니어들은 적응력을 갖추고 따라가야 합니다.\n\n이는 프로젝트 중간에 방향을 바꾸거나 새로운 기술을 신속하게 배워야 할 수도 있음을 의미할 수 있습니다.\n\n따라서 예산 압력으로 비즈니스가 오늘 변경해야 할 필요가 있다면...\n\n<div class=\"content-ad\"></div>\n\n네가 할 일이니까, 오늘은 바뀔거야.\n\n<div class=\"content-ad\"></div>\n\n# 나쁜 코드에 많은 시간을 낭비할 것입니다\n\n어디서나 나쁜 전문가가 존재합니다!\n\n모든 직책과 모든 회사에서, 적어도 한 명의 나쁜 전문가를 찾을 수 있습니다.\n\n그래서 이해관계자가 파이프라인이나 API에서 작은 변경을 요청하면... 나쁜 코드를 찾을 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n바로 숨 한 번 깊이 들이마시고 일에 전념하세요. 🤐\n\n# 때로는 데이터를 활용하지 못할 수도 있어요\n\n![Image](/assets/img/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer_3.png)\n\n상상해보세요:\n\n<div class=\"content-ad\"></div>\n\n- 프로젝트에 두 주 동안 집중해서 일했어요;\n- 세 번째 주에 제공한 데이터가 이후 스테이크홀더들에게 제공됐어요;\n- 스테이크홀더들은 제공한 데이터에 매우 만족했고 \"다음 학기에 매우 중요하다\"고 말했어요;\n- 다음 학기에는 프로젝트 파이프라인이 3일 동안 고장나도 한 사람도 불평하지 않았어요!! 이상하네요...\n- 그런데 결국 데이터를 사용하지 않는다는 걸 알게 되었어요... 😣\n\n이러한 상황은 불행히도 흔한 일입니다.\n이런 일이 발생할 수 있다는 점을 인식하고 그냥... 그렇게 내버려두어야 합니다.\n\n# 분야는 끊임없이 진화하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아래에 있는 두 이미지는 2023년과 2021년의 데이터 엔지니어링 생태계를 보여줍니다.\n\n두 해 동안 생태계가 많이 성장했다는 것을 알 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n새로운 기술과 도구들이 언제나 계속해서 등장하고 있어요.\n\n정말 빠르죠!!\n\n만약 오늘은 A 도구로 데이터 조정을 하고 있다면, 아마 내년에는 B 도구로 작업할지도 몰라요.\n\n가능한 해결책은 항상 최신 트렌드와 최신 기술에 대해 숙지하고 있어야 한다는 거예요.\n\n<div class=\"content-ad\"></div>\n\n만약 당신도 빠르게 움직이지 않는다면 뒤처질 것입니다.\n\n이 기사를 확인해보세요:\n\n## 결론\n\n데이터 엔지니어가 되는 것은 결코 간단하고 쉬운 여정이 아닙니다.\n\n<div class=\"content-ad\"></div>\n\n혼잡하고 불완전한 데이터로 작업하고, 자주 바뀌는 요구 사항에 적응하고, 나쁜 코드와 씨름하며, 사용되지 않는 데이터의 좌절을 겪으며, 끊임없이 발전하는 분야를 따라잡는 것은 받아들이기 어려울 수 있어요.\n\n이 기사를 마음에 드셨나요? 더 많은 기사를 위해 저를 팔로우해주세요.","ogImage":{"url":"/assets/img/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer_0.png"},"coverImage":"/assets/img/2024-06-19-FiveBrutalTruthsAboutBeingaDataEngineer_0.png","tag":["Tech"],"readingTime":3},{"title":"클래스워드 - 데이터베이스 열 이름 짓는데 내가 가장 좋아하는 컨벤션","description":"","date":"2024-06-19 16:16","slug":"2024-06-19-ClasswordsMyFavoriteConventionforNamingDatabaseColumns","content":"\n\n![이미지](/assets/img/2024-06-19-ClasswordsMyFavoriteConventionforNamingDatabaseColumns_0.png)\n\n클래스워드는 그냥 네이밍 프로토콜이 아니에요; 각 컬럼의 목적과 내용을 즉시 이해할 수 있도록 하는 명확한 커뮤니케이션 도구로서 작용해요. 핵심 아이디어는 간단해요: 각 데이터베이스 컬럼의 이름이 그 안에 포함된 데이터를 어떻게 나타내는지 전달되도록 해요. 날짜, 텍스트 설명, 숫자 값과 같이 특정 유형의 정보를 식별하거나, 클래스워드는 각 데이터 조각 뒤에 숨은 의도를 명확하게 합니다.\n\n이 규칙은 원하는 어떤 네이밍 스타일과도 잘 어울려요 — 카멜케이스, 패스칼케이스, 또는 스네이크케이스. 이 글에서는 가독성과 인기 때문에 스네이크케이스를 선호하지만, 클래스워드 사용의 본질은 이 문법적 선택을 초월합니다.\n\n좀 더 깊게 파고들어서, 클래스워드 적용 과정에 대해 공유하고 싶은 개인적인 감상이 있어요. 컬럼 이름에 클래스워드를 할당해야 할 때마다, 그 컬럼이 어떤 데이터를 보유하게 될지 심도 있게 생각하도록 강요받아요. 이 데이터가 정말로 무엇을 의미하는 걸까요? 데이터의 세부 사항을 충분히 이해했을까요? 이 내성적인 순간은 귀중해요. 네이밍만 하는 게 아니라, 이 데이터베이스를 사용하는 나와 다른 누군가가 해당 내용을 포괄적으로 이해할 수 있도록 하는 거예요. 클래스워드로 신중하게 네이밍하는 이 실천은, 내 경험 상으로 더 직관적이고 효율적인 데이터 관리 환경을 육성하는 데 중요한 역할을 해요.\n\n<div class=\"content-ad\"></div>\n\n# 클래스워드란 무엇인가요?\n\n클래스워드는 본질적으로 데이터베이스 열의 이름 뒤에 추가하는 키워드, 즉 데이터 유형을 나타내는 접미사입니다. 이 관례는 데이터의 형태와 기능 사이에 다리 역할을 하며, 데이터베이스와 상호작용하는 사람들이 해당 열이 어떤 종류의 정보를 포함하는지 즉각 파악할 수 있도록 돕습니다. 클래스워드 사용은 본질적으로 데이터베이스 구조에 의미론적 명확성의 한 층을 포함시키는 데 관한 것입니다.\n\n클래스워드의 아름다움은 그들의 간단함과 의미 전달 능력에 있습니다. 예를 들어, 열 이름 뒤에 _id를 추가하는 것은 이 열이 엔티티의 고유 식별자로 기능함을 나타냅니다. 비슷하게, _size_kb와 같은 접미사는 데이터의 크기를 킬로바이트 단위로 표현한 정보를 저장하는 열임을 알려줍니다. 이 의미론적 풍부함은 단순히 명명 규칙을 준수하는 데 그치는 것이 아니라, 데이터베이스에 명확성을 주입함으로써 일당팀을 초월하여 미래의 데이터 엔지니어나 데이터 분석가에게 다가갑니다.\n\n예를 들어, 상태라는 이름으로만 된 열을 고려해 봅시다. 추가적인 맥락이나 데이터 탐색 없이는 해당 열이 어떤 상태를 나타내는지 알기 어려울 것입니다. 이 상태는 상태 코드인가요, 상태에 대한 텍스트 설명인가요, 아니면 활성/비활성 상태를 나타내는 불리언 플래그인가요? 이 모호함은 일상적인 작업뿐만 아니라 데이터 분석과 보고서 작성에서도 혼란을 야기할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n클래스와드를 적용하면 가독성을 크게 향상시킬 수 있습니다. 예를 들어:\n\n- status_code — 숫자 또는 상징적 코드를 포함하는 열로, 아마도 문서 내 열거체나 룩업 테이블을 참조하는 다양한 상태를 나타내는 것으로 보입니다.\n- status_name — 상태의 설명적인 이름을 저장하는 열을 나타내며 열 내에서 직접 가독성 있는 맥락을 제공합니다.\n\n# 기본 Classwords\n\n카테고리 별로 기본 클래스와드를 더 자세히 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\n## 텍스트 클래스워드\n\n텍스트 클래스워드는 데이터베이스 내 텍스트 데이터의 성격과 기능을 정의하는 데 중요한 역할을 합니다.\n\n- 식별자 (또는 id) — 이 클래스워드는 고유성을 위해 중요합니다. 이는 엔티티의 인스턴스를 식별하는 숫자나 문자열입니다 (보통 시스템이 생성하는 것으로, 시퀀스에서 나온 숫자 값과 같은); 예: request_id.\n- 코드[_`표준`] — 코드는 보통 분류를 위해 사용되는 간략한 표현입니다. 예를 들어, status_code는 전체 이름을 저장하지 않고도 빠르게 상태를 식별하는 데 도움이 됩니다. 이 클래스워드를 사용할 때 해당하는 코딩 표준을 나타내는 것이 좋습니다 (해당하는 경우). 예: airport_code_iata는 IATA 공항 코드를 저장한다는 것을 명확히 나타냅니다 (ICAO나 다른 것이 아닌).\n- 이름 — 이름은 직관적이지만 인간이 읽기 쉽게 식별하기 위해 중요합니다. 예를 들어, product_name을 다룰 때, 이 컬럼이 제품 이름을 저장한다는 것이 즉시 명확합니다.\n- 설명 (또는 desc) — 설명은 더 자세한 통찰력을 제공합니다. 이를 간결하고 유익하게 유지하는 것이 좋은 실천법입니다. 예를 들어, service_description은 제공된 서비스에 대한 간략한 개요를 제공할 수 있습니다.\n- 지표 (또는 ind) — 지표는 \"예\" 또는 \"아니오\" 또는 \"참\" 또는 \"거짓\"을 나타내는 플래그입니다. 예를 들어, is_active_indicator, has_dependencies_indicator와 같이 Boolean 값으로 종종 사용되며 빠른 확인에 이상적입니다.\n- 숫자 — 이름과 달리, 여기서의 숫자는 종종 수학적인 의미에서의 숫자가 아닙니다. phone_number 및 serial_number가 그러한 예시로, 이 값이 식별에 사용되지만 계산을 위해 사용되지 않는 것입니다.\n- 텍스트 — 한 두 개의 단어로 충분하지 않을 때, comment_text 또는 feedback_text가 등장하여 확장된 문자열을 허용합니다.\n\n## 캘린더 클래스워드\n\n<div class=\"content-ad\"></div>\n\n달력 클래스워드는 시간 데이터를 관리하고 해석하는 데 필수적이며, 다양한 차원에서 시간을 추적하는 데 프레임워크를 제공합니다.\n\n- date — 달력 날짜만 필요할 때, event_date는 어떤 일이 언제 일어나는지를 알려주며 정확한 시간에 대해 걱정할 필요가 없습니다.\n- datetime[_`timezone`] (또는 dt[_`timezone`])**— 보다 정확한 타이밍을 위해, meeting_start_datetime은 시간까지 포함한 날짜를 보여주어 초까지 표시할 수 있습니다. 시간대 정보가 전달되지 않는 데이터 유형을 사용하는 경우, column 이름에 적절한 접미사를 추가하여 명확하게 만들어 주세요. 예를 들어, scheduled_start_dt_utc.\n- timestamp[_`timezone`] (또는 ts[_`timezone`])**— 시스템에서 생성되며 종종 초 단위까지 포함하는 시간대 정보가 있는 경우, record_created_timestamp는 행동이나 이벤트의 정확한 순간을 제공합니다. 마찬가지로, 시간대 정보가 포함되지 않는 데이터 유형의 경우, 적절한 접미사를 추가하여 해당 시간대를 나타내세요. 예를 들어, actual_start_ts_utc.\n\n## 숫자형 클래스워드\n\n숫자형 클래스워드는 양적 데이터에 순서와 명확성을 제공하여, 다양한 유형의 숫자 정보를 구별합니다. 아이템을 계산하거나 값, 비율을 측정하든, 이러한 클래스워드는 정확한 데이터 표현과 분석에 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n- count — 방문자 수 등을 합산하는 데 사용하며, 참여도나 트래픽을 측정하는 데 유용합니다.\n- amount[_`화폐단위`] — 이 클래스워드는 재무 데이터에 필수적입니다. sale_amount_usd는 미국 달러로 거래 가치를 명확히 나타냅니다(화폐 표기는 조건적*).\n- `quantity_property`[_`측정단위`] — 측정 가능한 속성에 대해 사용되며, cable_length_meters는 단순히 길이뿐 아니라 단위까지 명시합니다(측정단위 표기는 조건적*). 길이, 무게, 부피, 크기, 거리, 지속 시간 등 측정 가능한 모든 속성에 사용할 수 있습니다. 다른 예시로는: file_size_kb, job_duration_seconds, package_weight_kg, avg_speed_mph\n- ratio — aspect_ratio와 같은 비율은 연결된 단위 없이 비교하는 데 필수적입니다.\n- factor — tax_rate_factor와 같은 요소는 계산에 유용한 곱셈 효과를 제공합니다.\n- percent (또는 pct) — 이익률을 나타내는 profit_margin_percent와 같은 백분율은 상대적인 측정을 제공하며 보통 이해하기 쉬운 형식으로 표시됩니다. 그러나 이 값이 1에 기반한 1%를 나타내는지 100에 기반한 1%를 나타내는지 명확히하면 좋습니다.\n\n* 화폐나 측정단위를 표기하는 접미사의 조건부 포함은 관련 열이 해당 통화나 단위를 나타내는 열을 포함하는지 여부에 따라 결정됩니다. 그러한 열이 있는 경우 접두사가 필요하지 않습니다. 그러므로 tax_amount_usd를 사용하거나 tax_amount와 tax_amount_currency_code(기록이 다양한 통화로 세금액을 저장하는 경우) 쌍을 사용할 수 있습니다.\n\n# 도메인별 클래스워드\n\n도메인별 클래스워드를 네이밍 규칙에 통합하는 것은 유익할 뿐만 아니라 특정 분야의 세세한 점을 포착하는 데 필수적입니다. 이러한 전문화된 클래스워드는 이전에 논의한 더 일반적인 클래스워드에서 파생되며, 데이터 스키마에 추가적인 정확성, 네이밍 간소화 및 맥락을 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n예시:\n\n- uri (identifier 클래스워드의 전문화) — profile_picture_uri와 같은 URI 열은 인터넷 또는 현실 세계의 리소스에 대한 고유 식별자(또는 주소)를 저장합니다.\n- address (text 클래스워드의 전문화) — 주소와 유사한 열을 자주 사용한다면 postal_address_text와 같이 부르는 대신, 전문화된 address 키워드를 소개하고 postal_address와 같이 약칭 사용을 고려해보세요.\n- email (address 클래스워드의 전문화) — 이는 이메일 주소를 포함하는 열을 명명하는 유용한 단축키입니다. email 클래스워드는 uri를 특수화한 클래스워드도 될 수 있습니다. 이러한 출처를 확인하면 URI에 특화된 이메일 구문(예: \"mailto:someone.special@example.com\") 대신 간단한 \"someone.special@example.com\"이 아니라는 것을 나타낼 수 있습니다.\n- sku (code 클래스워드의 전문화) — 상업 분야에서 각 제품에 대한 고유 식별자인 Stock Keeping Unit에 유용한 전문화된 클래스워드를 사용할 수 있습니다. 예시: product_sku, 재고 관리 시스템에서 제품을 식별하기 위한 편리한 약어입니다.\n- json(text 클래스워드의 전문화) — config_settings_json과 같은 JSON 열은 구조화된 데이터를 압축된 형식으로 저장하며, 설정이나 데이터 교환에 적합합니다.\n- geojson (json 클래스워드의 전문화) — GIS 분야에서 GeoJSON 형식으로 지리 데이터를 저장하는 데 사용될 수 있습니다. 예시: parcel_border_geojson은 토지 경계를 나타내기 위한 지리 공간 데이터를 포함합니다.\n\n# Context에 유의하세요\n\n테이블 스키마를 설계할 때 항상 해당 테이블이 제공하는 문맥을 고려해보세요. 예를 들어, product라는 이름의 테이블에서는 모든 열 이름에 product_를 접두어로 붙이는 것은 중복되고 불필요하게 장황합니다. product_name, product_description 또는 product_launch_date와 같은 이름 대신 테이블 내에서 name, description 및 launch_date와 같은 간결한 이름을 사용하는 것이 반복적인 꼬리표 없이 필요한 모든 문맥을 제공합니다. 아래 쿼리가 충분히 읽기 쉽지 않나요?\n\n<div class=\"content-ad\"></div>\n\n```js\nSELECT name, description, launch_date\nFROM product\n```\n\n이 규칙은 나에게 Smurf 네이밍 컨벤션을 떠올리게 합니다. 이는 클래스를 네임스페이스에 맥락을 고려해 네이밍하는 프로그래밍 안티 패턴입니다. 하지만, 테이블 내의 열을 네이밍하는 것을 생각할 때, 좋은 비유가 될 수 있습니다.\n\n# 클래스워드 사용의 주요 이점\n\n데이터베이스 열 네이밍 규칙으로 클래스워드를 포함하는 것은 데이터 관리 프로세스를 스트림라인하게 하고 데이터베이스 스키마의 명확성을 높일 수 있는 다양한 이점을 제공합니다. 이것은 왜 나는 클래스워드를 내 데이터베이스 디자인 도구에서 없어서는 안 되는 부분으로 여기게 되었는지에 대한 이유입니다.\n\n<div class=\"content-ad\"></div>\n\n- 향상된 가독성과 명확성 — Classwords는 데이터베이스 열 이름의 가독성과 이해도를 크게 향상시켜줍니다. 이는 팀 구성원들의 학습 곡선을 최소화하고 상세 문서에 대한 의존을 줄여줍니다. 이로써 각 열의 목적과 데이터 유형을 한눈에 파악하기가 더욱 쉬워집니다.\n- AI 기반 SQL 쿼리 생성의 향상 — Classwords는 자연어 프롬프트로부터 SQL 쿼리를 생성하는 GenAI 모델의 정확성을 향상시킵니다. 이들은 AI 시스템이 데이터베이스 구조를 더 잘 이해하도록 돕고, 대화 인터페이스를 통해 더 쉽게 데이터 추출을 용이하게 합니다. 이를 통해 데이터베이스가 AI 친화적으로 변화합니다.\n- 모든 구문 기반 명명 스타일과의 호환성 — Classwords는 다재다능하며 문법적 명명 패턴인 camelCase, PascalCase 또는 snake_case와 쉽게 통합될 수 있습니다. 이 유연성은 classwords를 채택함에 있어 기존의 명명 규칙을 완전히 변경할 필요가 없게 만들어줍니다. 대신 의미론적 의미를 추가하여 기존 규칙을 향상시킵니다.\n\n이 클래스워드에 대한 탐구가 데이터베이스를 보다 관리 가능하고 이해하기 쉽도록 만드는 가치를 잘 보여줬으면 좋겠습니다. 제 경험은 이들이 데이터 무결성과 팀 협업에 미치는 중요한 영향을 입증합니다. 데이터베이스 관행에 classwords를 도입하여 더 명확하고 일관된 명명 규칙을 추구하는 것을 장려합니다.\n\n본문이 마음에 드셨다면, Database Naming Convention Checklist도 관심 있게 보실 수 있습니다.\n\n# 🖐🤓👉 재미있는 사실\n\n<div class=\"content-ad\"></div>\n\n헝가리안 표기법의 원래 의도가 종종 오해를 받았다는 사실을 알고 계셨나요? 대중적인 믿음과는 달리, 헝가리안 표기법은 데이터 유형과 관련된 것이 아닌 의미론적 유형 접두사를 사용하도록 설계되었습니다. 변수의 유형이 아닌 목적에 대한 통찰력을 제공하기 위한 것이었습니다. 오늘날 일부에서는 안티 패턴으로 간주되지만, 헝가리안 표기법의 본질은 의미 있는 명명의 중요성을 강조하며, 이는 데이터베이스 관리에서의 클래스워드의 가치와 resonates 한 원칙입니다.\n\n더 자세한 이해를 위해, 마이크로소프트의 문서에서 헝가리안 표기법을 설명한 원래 논문을 살펴보세요.\n\n혹시 이제 안티 패턴으로 간주해야 할지 다시 생각할 때가 온 것일지도 모릅니다! 🤔","ogImage":{"url":"/assets/img/2024-06-19-ClasswordsMyFavoriteConventionforNamingDatabaseColumns_0.png"},"coverImage":"/assets/img/2024-06-19-ClasswordsMyFavoriteConventionforNamingDatabaseColumns_0.png","tag":["Tech"],"readingTime":8},{"title":"벡터 DB를 사용하여 실시간 뉴스 검색 엔진을 구축하는 방법","description":"","date":"2024-06-19 16:12","slug":"2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs","content":"\n\n아파치 카프카, 바이트왁스, 그리고 업스태시 벡터 데이터베이스를 활용한 라이브 뉴스 집계 스트리밍 파이프라인 구현을 위한 실용적인 안내서입니다.\n\nearthweb.com에서 실시한 연구에 따르면, 매일 온라인 및 오프라인에서 유입되는 뉴스 기사는 200-300만 건 사이에 있다고 합니다!\n\n모든 방향에서 우리에게 쏟아지는 뉴스로 인해 정신없을 때가 많습니다. 그래서 우리는 실제로 관심 있는 뉴스를 빠르게 받아볼 수 있는 짧고 빠른 방법을 찾고 있습니다.\n\n본 문서에서는 이러한 문제를 해결하고자 합니다! 좀 더 구체적으로, 여러 출처로부터 데이터를 수집하고 해당 정보 채널을 당신의 관심사에 맞는 종단점으로 좁힐 수 있는 시스템을 구축할 것입니다 — 뉴스 검색 엔진입니다!\n\n<div class=\"content-ad\"></div>\n\n이론에 대해서만 이야기하거나 이러한 시스템을 구현하는 방법을 알려주는 것이 아니라, 우리는 단계별로 설명하고 보여줄 거예요!\n\n시작하기 전에, 이 기사에서 제공하는 모든 것은 Decoding ML Articles GitHub 저장소에서 완전한 코드 지원을 받습니다.\n\n# 목차\n\n- 아키텍처 개요\n- 도구 고려 사항\n- 전제 조건\n3.1 새로운 Upstash Kafka 클러스터 생성\n3.2 새로운 Upstash Vector 인덱스 생성\n3.3 2개의 라이브 뉴스 API에 등록\n3.4 설치\n- 데이터 수집\n4.1 기사 가져오기 관리자\n4.2 Kafka 메시지 제작\n4.3 Pydantic을 사용한 데이터 교환 모델\n4.4 KafkaProducers 실행\n- 수집 파이프라인\n5.1 Kafka에서 메시지 수신\n5.2 Bytewax 데이터플로 구현\n5.3 기사 정제, 형식 지정, 청크화, 삽입\n5.4 벡터 작성 및 VectorDB에 업서트\n- 파이프라인 시작\n- 사용자 인터페이스\n- 결론\n- 참고문헌\n\n<div class=\"content-ad\"></div>\n\n# 아키텍처 개요\n\n![이미지](/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_0.png)\n\n요약하자면, 우리는 뉴스 API에서 뉴스 기사를 가져와서 생생한 시스템을 구축할 것입니다. 가져온 데이터를 정의된 형식으로 파싱하고 포맷팅한 다음 첫 번째 단계로 Kafka 토픽에 메시지를 직렬화하고 스트리밍할 것입니다. \n두 번째 단계에서는 Bytewax를 사용하여 Kafka 토픽에서 메시지를 더 청소, 파싱, 청크, 임베드, 벡터를 업서팅하여 벡터 데이터베이스로 보내고, 데이터베이스와 상호 작용할 수 있는 UI로 마무리됩니다.\n\n# 툴 고려 사항\n\n<div class=\"content-ad\"></div>\n\n올바른 도구를 선택하는 것이 고성능, 확장성, 및 구현 용이성을 달성하는 핵심이었습니다. 프로젝트 전체에서 사용된 도구를 살펴보겠습니다:\n\n- Upstash Serverless Kafka: 인프라 관리에 대해 걱정할 필요 없이 강력하고 확장 가능한 이벤트 스트리밍을 위해 사용됩니다.\n- Python 스레딩: 여러 뉴스 API에서 동시에 데이터를 가져오면서 스레드 안전한 Kafka Producer 인스턴스를 공유하여 메모리 풋프린트와 성능을 최적화합니다.\n- Pydantic 모델: 일관된 및 유효한 데이터 교환 구조를 보장하기 위해 사용됩니다.\n- Bytewax: 스트리밍 데이터를 처리하고 변환하는 데 간편하고 빠른 속도를 제공하기 때문에 사용됩니다.\n- Upstash Vector Database: Serverless로 구성이 쉽고 Python, JS, 및 GO 내에서 쉽게 통합됩니다. UI 콘솔 대시보드에서 풍부한 탐색 옵션과 실시간 상태 메트릭을 제공하는 것이 큰 장점입니다.\n\n하드웨어 요구 사항에 따르면 GPU는 필요하지 않습니다.\n\n비용은 얼마입니까? — 무료입니다.\n이 안내서는 무료 티어 플랜만 사용하도록 설정했으므로 사용한 플랫폼에 대해 지불할 필요가 없습니다!\n\n<div class=\"content-ad\"></div>\n\n# 준비 사항\n\n어떠한 구현을 하기 전에, 각 서비스에 접근할 수 있는지 확인해야 합니다. 따라서 다음을 설정해야 합니다:\n\n- 새로운 Upstash Kafka 클러스터\n- 새로운 Upstash Vector Index\n- 뉴스 API 등록\n- 환경 설치\n\n처음 시작할 때는 약 5분 정도 걸립니다. 함께 해보세요!\n\n<div class=\"content-ad\"></div>\n\n## 새로운 Upstash Kafka 클러스터 생성\n\n먼저 Upstash에 등록해야 합니다. 로그인 후에 다음과 같은 대시보드가 나타납니다:\n\n![대시보드 이미지](/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_1.png)\n\n다음으로 상단 바에서 Kafka를 선택하고 + 클러스터 생성 버튼을 클릭하여 새 클러스터를 만들어야 합니다. 클릭하면 다음 모달이 나타납니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_2.png\" />\n\n클러스터에 이름을 지정하고 본인의 위치와 가장 가까운 지역을 선택한 후, 클러스터 생성을 클릭하여 완료하세요. 완료되면 새로운 Kafka 클러스터가 아래에 표시됩니다. 새로운 Kafka 클러스터를 선택하고 아래 화면으로 이동하게 됩니다:\n\n<img src=\"/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_3.png\" />\n\n이 뷰에서 주요 구성 요소를 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n- 상세 정보: 클러스터 개요 및 Upstash가 제공하는 기능을 보여줍니다.\n- 사용량: 생성/소비된 메시지 수, 비용 영향 등을 보여주는 차트입니다.\n- 주제: 이 탭에서는 Kafka 주제를 만들고 세부 정보를 모니터링할 수 있습니다.\n\n클러스터를 생성한 다음 해야 할 다음 단계는 메시지를 생성(보내기)하고 소비(받기)할 수 있는 주제를 정의하는 것입니다.\n\n주제 탭 아래에서 \"주제 생성\"을 선택하면 다음과 같은 화면이 나타납니다:\n\n<img src=\"/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n주제 이름을 지정하고, 나머지는 기본 상태로 두어서 Create를 클릭하세요.\n\n카프카 클러스터를 성공적으로 생성했습니다. 이제 클러스터에 연결하는 데 도움이 되는 환경 변수를 복사하고 설정해야 합니다. 이를 위해 클러스터 대시보드로 이동하여 세부 정보 탭에서 엔드포인트, 사용자 이름 및 비밀번호를 복사하여 .env 파일에 붙여넣으세요.\n그 후, Topics로 이동하여 카프카 토픽 이름을 복사하세요.\n\n지금까지 .env 파일이어야 하는 모습은 다음과 같습니다:\n\n```js\nUPSTASH_KAFKA_UNAME=\"[사용자 이름]\"\nUPSTASH_KAFKA_PASS=\"[비밀번호]\"\nUPSTASH_KAFKA_ENDPOINT=\"[엔드포인트]\"\nUPSTASH_KAFKA_TOPIC=\"[토픽 이름]\"\n```\n\n<div class=\"content-ad\"></div>\n\n## 새 Upstash Vector 색인 만들기\n\n이제 새로운 Vector 데이터베이스를 만들어 보겠습니다. 이를 위해 대시보드에서 Vector를 선택하고 + Index 작성을 클릭하세요. 그러면 다음 뷰로 이동됩니다:\n\n![이미지](/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_5.png)\n\n벡터 데이터베이스에 이름을 할당하고, 위치에 가장 가까운 지역을 선택한 다음 Embedding을 생성할 때 사용할 모델로 sentence-transformers/all-MiniLM-L6-v2을 선택하세요. 뉴스 기사의 임베딩을 생성할 때 사용할 모델과 벡터 간 거리 비교에 코사인 유사도 메트릭을 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n새로운 Vector Index를 만든 후에는 Kafka Cluster와 동일한 작업 흐름을 따를 수 있습니다. Index Name, Endpoint, Token을 복사하고 .env 파일에 붙여넣기하세요.\n\n현재 .env 파일은 다음과 같이 보여야 합니다:\n\n```js\nUPSTASH_KAFKA_UNAME=\"[여기에 사용자명 입력]\"\nUPSTASH_KAFKA_PASS=\"[여기에 비밀번호 입력]\"\nUPSTASH_KAFKA_ENDPOINT=\"[여기에 엔드포인트 입력]\"\nUPSTASH_KAFKA_TOPIC=\"[여기에 토픽 이름 입력]\"\n\nUPSTASH_VECTOR_ENDPOINT=\"[Vector 엔드포인트 입력]\"\nUPSTASH_VECTOR_TOPIC=\"[Vector 이름 입력]\"\nUPSTASH_VECTOR_KEY=\"[Vector 토큰 입력]\"\n``` \n\n## 뉴스 API에 등록하기\n\n<div class=\"content-ad\"></div>\n\n다음 APIs를 사용하여 기사를 가져올 예정입니다:\n\n- 🔗 NewsAPI\n\n하루에 100번의 API 호출을 할 수 있는 무료 개발자 플랜을 제공합니다.\n\n2. 🔗 NewsData\n\n<div class=\"content-ad\"></div>\n\n무료 요금제가 제공되며 하루에 200개의 크레딧을 받습니다. 각 크레딧은 10개의 기사와 동일하며, 이는 하루에 총 2000개의 기사를 가져올 수 있다는 것을 의미합니다.\n\n저희 현재의 사용 사례에는 이 API들이 충분한 기능을 제공하여 구축 중인 뉴스 검색 엔진을 구현하고 유효성을 검사할 수 있습니다. 동시에 기존 워크플로우가 동일하게 유지되므로 개선 및 확장할 여지도 남겨두고 있습니다.\n무료 요금제에 따른 유일한 제약은 타임드-배치 페치를 수행할 수 없다는 것입니다. 즉, 이 API들을 쿼리할 때 from_date, to_date를 사용할 수 없습니다. 하지만 이는 문제가 되지 않습니다.\n대신 페치 호출 간의 대기 시간을 이용하여 이 동작을 모방할 예정입니다.\n\n다음 단계는 두 플랫폼에 등록하는 것입니다 — 걱정 마세요, 가능한 간단합니다.\n\n- NewsAPI에 등록한 후, /account로 이동하여 API_KEY 필드를 확인한 후 이를 .env 파일의 NEWSAPI_KEY에 복사하여 붙여넣으십시오.\n- NewsData에 등록한 후, /api-key로 이동하여 API KEY를 확인한 후 이를 .env 파일의 NEWSDATAIO_KEY에 복사하여 붙여넣으십시오.\n\n<div class=\"content-ad\"></div>\n\n지루한 부분은 끝났습니다. 이제 이러한 API에 액세스할 수 있고, 기사를 가져올 수 있습니다. 각 API에서 페이로드가 어떻게 보이는지 살펴봅시다:\n\n![image](/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_6.png)\n\n## 사전 준비 조치 요약\n\nKafka 클러스터를 생성하고, 벡터 인덱스를 생성하고, 뉴스 API에 등록하는 이 3단계를 모두 마친 후에 .env 파일은 다음과 같은 모습이어야 합니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nUPSTASH_KAFKA_UNAME=\"[여기에 사용자 이름 입력]\"\nUPSTASH_KAFKA_PASS=\"[여기에 암호 입력]\"\nUPSTASH_KAFKA_ENDPOINT=\"[여기에 엔드포인트 입력]\"\nUPSTASH_KAFKA_TOPIC=\"[토픽 이름 입력]\"\n\nUPSTASH_VECTOR_ENDPOINT=\"[벡터 엔드포인트 입력]\"\nUPSTASH_VECTOR_TOPIC=\"[벡터 이름 입력]\"\nUPSTASH_VECTOR_KEY=\"[벡터 토큰 입력]\"\n\nNEWSAPI_KEY=\"[NEWSAPI 키 입력]\"\nNEWSDATAIO_KEY=\"[NEWSDATA 키 입력]\"\nNEWS_TOPIC = \"news\" # 이것은 가져올 기사의 카테고리입니다\n\n다음 단계는 구현 세부 정보에 들어가기 전에 환경과 필수 패키지를 설치하는 것입니다.\n다음은 Makefile 설치 단계의 모습입니다:\n\n# Makefile\n...\ninstall:\n @echo \"$(GREEN) [CONDA] [$(ENV_NAME)] 파이썬 환경 생성 $(RESET)\"\n conda create --name $(ENV_NAME) python=3.9 -y\n @echo \"환경 활성화 중...\"\n @bash -c \"source $$(conda info --base)/etc/profile.d/conda.sh && conda activate $(ENV_NAME) \\\n   && pip install poetry \\\n   poetry env use $(which python)\"\n @echo \"패키지 설치 중\"\n @echo \"pyproject.toml 위치로 변경 중...\"\n @bash -c \" PYTHON_KEYRING_BACKEND=keyring.backends.fail.Keyring poetry install\"\n...\n\n환경을 준비하려면 make install을 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n이제 이 소스로부터 기사를 가져오는 핸들러 구현을 조사해 봅시다.\n\n# 데이터 수집\n\n이 모듈의 목적은 두 API를 쿼리하는 기능을 캡슐화하고, 페이로드를 구문 분석하여 두 페이로드에 모두 존재하는 속성을 사용하여 공통 문서 형식으로 포매팅하고, 클러스터로 메시지를 보내기 위해 공유 KafkaProducer 인스턴스를 사용하는 것입니다.\n\n자세히 살펴볼 내용은 다음 하위 모듈들입니다:\n\n<div class=\"content-ad\"></div>\n\n- Articles Fetching Manager Class\n- 카프카 클러스터로 메시지를 보내는 방법\n- Pydantic 데이터 모델\n- 파이프라인 실행\n\n## Articles Fetching Manager Class\n\n구현 내용에 대해 알아보겠습니다:\n\nimport datetime\nimport functools\nimport logging\nfrom typing import Callable, Dict, List\n\nfrom newsapi import NewsApiClient\nfrom newsdataapi import NewsDataApiClient\nfrom pydantic import ValidationError\n\nfrom models import NewsAPIModel, NewsDataIOModel\nfrom settings import settings\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n\n\ndef handle_article_fetching(func: Callable) -> Callable:\n    \"\"\"\n    뉴스 기사 가져오기 기능에 대한 예외 처리를 담당하는 데코레이터입니다.\n\n    이 데코레이터는 기사 가져오기 기능을 감싸서 발생하는 예외를 catch하고 로깅합니다.\n    오류가 발생하면 오류를 기록하고 빈 목록을 반환합니다.\n\n    Args:\n        func (Callable): 감쌀 기사 가져오기 함수.\n\n    Returns:\n        Callable: 감싼 함수.\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except ValidationError as e:\n            logger.error(f\"기사 처리 중 유효성 검사 오류 발생: {e}\")\n        except Exception as e:\n            logger.error(f\"소스로부터 데이터를 가져오는 도중 오류 발생: {e}\")\n            logger.exception(e)\n        return []\n\n    return wrapper\n\nclass NewsFetcher:\n    \"\"\"\n    다양한 API에서 뉴스 기사를 가져오는 클래스입니다.\n\n    속성:\n        _newsapi (NewsApiClient): NewsAPI 클라이언트.\n        _newsdataapi (NewsDataApiClient): NewsDataAPI 클라이언트.\n\n    메서드:\n        fetch_from_newsapi(): NewsAPI로부터 기사 가져오기.\n        fetch_from_newsdataapi(): NewsDataAPI로부터 기사 가져오기.\n        sources: 호출 가능한 가져오기 함수 목록을 반환합니다.\n    \"\"\"\n\n    def __init__(self):\n        self._newsapi = NewsApiClient(api_key=settings.NEWSAPI_KEY)\n        self._newsdataapi = NewsDataApiClient(apikey=settings.NEWSDATAIO_KEY)\n\n    @handle_article_fetching\n    def fetch_from_newsapi(self) -> List[Dict]:\n        \"\"\"NewsAPI에서 상위 뉴스 가져오기.\"\"\"\n        response = self._newsapi.get_everything(\n            q=settings.NEWS_TOPIC,\n            language=\"en\",\n            page=settings.ARTICLES_BATCH_SIZE,\n            page_size=settings.ARTICLES_BATCH_SIZE,\n        )\n        return [\n            NewsAPIModel(**article).to_common()\n            for article in response.get(\"articles\", [])\n        ]\n\n    @handle_article_fetching\n    def fetch_from_newsdataapi(self) -> List[Dict]:\n        \"\"\"NewsDataAPI에서 뉴스 데이터 가져오기.\"\"\"\n        response = self._newsdataapi.news_api(\n            q=settings.NEWS_TOPIC,\n            language=\"en\",\n            size=settings.ARTICLES_BATCH_SIZE,\n        )\n        return [\n            NewsDataIOModel(**article).to_common()\n            for article in response.get(\"results\", [])\n        ]\n\n    @property\n    def sources(self) -> List[callable]:\n        \"\"\"뉴스 가져오기 함수 목록입니다.\"\"\"\n        return [self.fetch_from_newsapi, self.fetch_from_newsdataapi]\n\n<div class=\"content-ad\"></div>\n\n이 구현에서 고려해야 할 몇 가지 중요 사항이 있습니다:\n\n- NewsAPIModel과 NewsDataIOModel은 특정 페이로드 형식에 익숙한 Pydantic 모델입니다.\n- 우리는 handle_article_fetching 데코레이터를 사용하여 원시 페이로드를 Pydantic 모델로 변환할 때 유효성 오류나 더 넓은 예외를 잡습니다.\n- 우리에게는 API를 쿼리하는 callable 메서드를 반환하는 sources라는 속성이 있습니다. 이것은 데이터 수집 모듈 내에서 사용될 것이며 멀티 프로듀서 스레드를 생성하여 Kafka 클러스터로 메시지를 전송합니다. 다음에 이어서 설명하겠습니다.\n\n## Kafka 메시지 생성\n\n다음에 우리가 구현할 작업 흐름입니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_7.png\" />\n\n여기서 중요한 포인트들입니다:\n\n- API에서 가져오는 작업에 별도 스레드를 사용합니다.\n- 메시지를 보내기 위해 공통 카프카 프로듀서 인스턴스를 공유합니다.\n- 데이터 교환을 보증하기 위해 Pydantic 모델을 사용합니다.\n\n기사를 가져오는 데 별도 스레드를 사용하고, 클러스터로 메시지를 보내기 위해 단일 카프카 프로듀서 인스턴스를 사용하는 것이 우리의 사용 사례에서 권장되는 방법입니다. 그 이유는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 효율성 및 성능: KafkaProducer는 스레드 안전합니다. 새 인스턴스를 만드는 것은 네트워크 연결과 일부 설정이 필요합니다. 여러 스레드 간에 하나의 단일 인스턴스를 공유하면 이러한 작업과 관련된 오버헤드를 줄일 수 있습니다.\n- 처리량: 단일 프로듀서 인스턴스는 메시지를 Kafka 클러스터로 보내기 전에 메시지를 일괄 처리합니다.\n- 자원: 사용 사례에 완전히 적용되지는 않지만, 우리는 오직 2개의 프로듀서 스레드만 가지고 있기 때문에 인스턴스 수를 제한함으로써 시스템 자원 이용률을 최적화할 수 있습니다.\n\n여기 Kafka로 메시지 처리를 담당하는 주요 기능이 있습니다:\n\ndef run(self) -> NoReturn:\n        \"\"\"지속적으로 Kafka 주제로 메시지를 가져와 보냅니다.\"\"\"\n        while self.running.is_set():\n            try:\n                messages: List[CommonDocument] = self.fetch_function()\n                if messages:\n                    messages = [msg.to_kafka_payload() for msg in messages]\n                    self.producer.send(self.topic, value=messages)\n                    self.producer.flush()\n                logger.info(\n                    f\"프로듀서 : {self.producer_id}이(가) {len(messages)}개의 메시지를 전송함.\"\n                )\n                time.sleep(self.wait_window_sec)\n            except Exception as e:\n                logger.error(f\"프로듀서 작업자 {self.producer_id}에서 오류 발생: {e}\")\n                self.running.clear()  # 오류 시 스레드를 중지합니다\n\n구현에서 고려해야 할 중요 사항:\n\n<div class=\"content-ad\"></div>\n\n- 우리는 fetch sources의 수만큼 KafkaProducerThread 인스턴스가 생성됩니다.\n- 우리는 모든 스레드를 KafkaProducerSwarm 아래에 랩합니다.\n- 모든 스레드 사이에서 단일 KafkaProducer 인스턴스를 공유하며, 이는 클러스터와 통신할 것입니다.\n- 우리는 N개의 fetching 스레드로 확장할 수 있지만 여전히 단일 KafkaProducer 인스턴스를 유지하기 위해 싱글톤 디자인 패턴을 따릅니다.\n\n## Pydantic을 사용한 데이터 교환 모델\n\n위에서 제시한 코드 스니펫 구현에서, 이전에 설명되지 않았던 *Document, *Model 객체의 사용을 관찰했을 수 있습니다. 이 섹션에서 이들이 무엇인지 자세히 살펴보겠습니다.\n\n이들은 데이터 교환을 위한 Pydantic 모델들이며, 우리가 구축 중인 응용 프로그램 내에서 이러한 모델들은:\n\n<div class=\"content-ad\"></div>\n\n- NewsDataIOModel: NewsData API에서 가져온 원시 페이로드를 래핑하고 포맷합니다.\n- NewsAPIModel: NewsAPI API에서 가져온 원시 페이로드를 래핑하고 포맷합니다.\n- CommonDocument: 위에서 언급한 다양한 뉴스 형식 사이의 공통 형식을 설정합니다.\n- RefinedDocument: metadata 아래에 유용한 필드를 그룹화하고 기사 설명 텍스트와 같은 주요 필드를 강조하는 공통 형식을 필터링합니다.\n- ChunkedDocument: 텍스트를 청크로 나누고 chunk_id와 document_id 사이의 계보를 보장합니다.\n- EmbeddedDocument: 청크를 임베드하여 chunk_id와 document_id 사이의 계보를 보장합니다.\n\n예를 들어, 위 CommonDocument 모델은 다양한 뉴스 페이로드 형식 사이의 연결 역할을 나타내므로 이와 같이 구성됩니다:\n\nclass CommonDocument(BaseModel):\n    article_id: str = Field(default_factory=lambda: str(uuid4()))\n    title: str = Field(default_factory=lambda: \"N/A\")\n    url: str = Field(default_factory=lambda: \"N/A\")\n    published_at: str = Field(\n        default_factory=lambda: datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    )\n    source_name: str = Field(default_factory=lambda: \"Unknown\")\n    image_url: Optional[str] = Field(default_factory=lambda: None)\n    author: Optional[str] = Field(default_factory=lambda: \"Unknown\")\n    description: Optional[str] = Field(default_factory=lambda: None)\n    content: Optional[str] = Field(default_factory=lambda: None)\n\n    @field_validator(\"title\", \"description\", \"content\")\n    def clean_text_fields(cls, v):\n        if v is None or v == \"\":\n            return \"N/A\"\n        return clean_full(v)\n\n    @field_validator(\"url\", \"image_url\")\n    def clean_url_fields(cls, v):\n        if v is None:\n            return \"N/A\"\n        v = remove_html_tags(v)\n        v = normalize_whitespace(v)\n        return v\n\n    @field_validator(\"published_at\")\n    def clean_date_field(cls, v):\n        try:\n            parsed_date = parser.parse(v)\n            return parsed_date.strftime(\"%Y-%m-%d %H:%M:%S\")\n        except (ValueError, TypeError):\n            logger.error(f\"Error parsing date: {v}, using current date instead.\")\n\n    @classmethod\n    def from_json(cls, data: dict) -> \"CommonDocument\":\n        \"\"\"JSON 객체에서 CommonDocument를 만듭니다.\"\"\"\n        return cls(**data)\n\n    def to_kafka_payload(self) -> dict:\n        \"\"\"Kafka 페이로드의 공통 표현을 준비합니다.\"\"\"\n        return self.model_dump(exclude_none=False)\n\n해석해보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n- 뉴스 기사 형식에 공통 속성 시리즈가 포함되어 있습니다.\n- 각 필드를 유효성 검사하거나 field_validator 데코레이터를 사용하여 기본값을 지정합니다.\n- to_kafka_payload 메서드는 메시지 직렬화를 보장하여 Kafka 클러스터로 전송하기 전에 처리합니다.\n\n## 텍스트 필드 클린업 프로세스\n\n클린업 프로세스는 간단합니다. 텍스트를 정리하고 다음을 보장하기 위해 메서드를 사용합니다:\n\n- 끝에 있는 공백이나 \\n, \\t를 제거합니다.\n- ul/li 목록 항목을 제거합니다.\n- 텍스트 내에 HTML 태그가 있으면 제거합니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 이러한 변환을 간소화하기 위해 구조화되지 않은 [7] Python 라이브러리를 사용하고 있습니다.\n\n## KafkaProducers 실행\n\n지금까지 다음 모듈을 수행/구현했습니다:\n\n- 필요한 모든 서비스에 등록\n- Kafka 클러스터 및 벡터 데이터베이스 생성\n- 뉴스 기사 검색 핸들러 구현\n- 데이터 교환을 위한 Pydantic 모델 구현\n- KafkaProducer 로직 구현\n\n<div class=\"content-ad\"></div>\n\n작업이 완료되면 이제 안전하게 우리의 파이프라인에서 생산 단계를 실행하고 Upstash의 KafkaCluster에서 메시지를 확인할 수 있습니다.\n\n그럼 시작해봐요!\n프로젝트의 루트 디렉토리에서, Makefile에 데이터 수집을 실행하는 명령어가 있습니다:\n\n....\n\nrun_producers:\n @echo \"$(GREEN) [실행 중] 데이터 수집 파이프라인 Kafka 프로듀서 $(RESET)\"\n @bash -c \"poetry run python -m src.producer\"\n\n...\n\n이 🔗Makefile은 우리가 구축 중인 솔루션과 상호작용하기 위한 유용한 명령어가 포함되어 있습니다. 이 경우에는 make run_producers를 사용하여 run_producers를 실행해야 합니다. 이렇게 하면 KafkaSwarm이 시작되고 NewsAPIs에서 기사를 가져와 형식을 지정한 다음 Kafka 클러스터로 보내는 스레드를 다룰 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```\n![이미지](/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_8.png)\n\n로그를 통해 프로듀서 스레드가 각각 5개의 메시지를 보냈다는 것을 확인했습니다. 메시지들이 클러스터에 도달했는지 확인하려면 Upstash 콘솔로 이동하여 Kafka 클러스터 → 메시지를 확인하십시오. 다음과 같은 화면이 나타날 것입니다:\n\n![이미지](/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_9.png)\n\n이 시점에서는 API에서 뉴스 기사를 가져와 형식을 맞춘 후 Kafka로 메시지를 보내는 데이터 수집 파이프라인의 구현 및 테스트가 완료되었습니다. 다음으로는 Kafka에서 새 메시지를 처리하는 \"컨슈머\" 또는 적재 파이프라인을 구현할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 데이터 수집 파이프라인\n\n우리가 Kafka 주제에서 메시지를 받았다는 것을 확인한 후에는 \"소비자\" 파이프라인을 구현해야 합니다. 이는 다음을 의미합니다:\n\n- Kafka 주제에서 메시지 읽기\n- 파싱, 형식 지정, 청크화, 임베딩 생성\n- 벡터 객체 생성 및 Upstash Vector Index에 업서트\n\n![이미지](/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_10.png)\n\n<div class=\"content-ad\"></div>\n\n이를 위해 Bytewax [4]를 사용하여 이러한 단계를 올바른 순서로 연결하는 DataFlow를 정의할 것입니다.\n\n바로 구현에 들어가서 주요 개념을 설명해보겠습니다!\n\n- Bytewax Flow에 입력으로 Kafka Source를 정의합니다.\n\n```js\nimport json\nfrom typing import List\n\nfrom bytewax.connectors.kafka import KafkaSinkMessage, KafkaSource\n\nfrom logger import get_logger\nfrom models import CommonDocument\nfrom settings import settings\n\nlogger = get_logger(__name__)\n\ndef build_kafka_stream_client():\n    \"\"\"\n    Build a Kafka stream client to read messages from the Upstash Kafka topic using the ByteWax KafkaSource connector.\n    \"\"\"\n    kafka_config = {\n        \"bootstrap.servers\": settings.UPSTASH_KAFKA_ENDPOINT,\n        \"security.protocol\": \"SASL_SSL\",\n        \"sasl.mechanisms\": \"SCRAM-SHA-256\",\n        \"sasl.username\": settings.UPSTASH_KAFKA_UNAME,\n        \"sasl.password\": settings.UPSTASH_KAFKA_PASS,\n        \"auto.offset.reset\": \"earliest\",  # Start reading at the earliest message\n    }\n    kafka_input = KafkaSource(\n        topics=[settings.UPSTASH_KAFKA_TOPIC],\n        brokers=[settings.UPSTASH_KAFKA_ENDPOINT],\n        add_config=kafka_config,\n    )\n    logger.info(\"KafkaSource client created successfully.\")\n    return kafka_input\n\ndef process_message(message: KafkaSinkMessage):\n    \"\"\"\n    On a Kafka message, process the message and return a list of CommonDocuments.\n    - message: KafkaSinkMessage(key, value) where value is the message payload.\n    \"\"\"\n    documents: List[CommonDocument] = []\n    try:\n        json_str = message.value.decode(\"utf-8\")\n        data = json.loads(json_str)\n        documents = [CommonDocument.from_json(obj) for obj in data]\n        logger.info(f\"Decoded into {len(documents)} CommonDocuments\")\n        return documents\n    except StopIteration:\n        logger.info(\"No more documents to fetch from the client.\")\n    except KeyError as e:\n        logger.error(f\"Key error in processing document batch: {e}\")\n    except json.JSONDecodeError as e:\n        logger.error(f\"Error decoding JSON from message: {e}\")\n        raise\n    except Exception as e:\n        logger.exception(f\"Unexpected error in next_batch: {e}\")\n```\n\n<div class=\"content-ad\"></div>\n\n이 구현에서 중요한 점들:\n\n- build_kafka_stream_client : 미리 정의된 Bytewax KafkaSource 커넥터를 사용하여 KafkaConsumer의 인스턴스를 생성합니다.\n- process_message : Kafka Topic에서 메시지를 처리할 콜백 함수입니다.\n\n2. Bytewax 플로우의 출력으로 Upstash Vector (Index)를 정의합니다.\n\n```js\nfrom typing import Optional, List\n\nfrom bytewax.outputs import DynamicSink, StatelessSinkPartition\nfrom upstash_vector import Index, Vector\nfrom models import EmbeddedDocument\nfrom settings import settings\nfrom logger import get_logger\n\n\nlogger = get_logger(__name__)\n\n\nclass UpstashVectorOutput(DynamicSink):\n    \"\"\"Upstash 벡터 출력을 나타내는 클래스입니다.\n\n    이 클래스는 at-least-once 처리를 지원하는 동적 출력 유형인 Upstash 벡터 출력을 생성하는 데 사용됩니다.\n    resume 이후의 메시지는 resume 즉각적으로 복제됩니다.\n\n    Args:\n        vector_size (int): 벡터의 크기.\n        collection_name (str, optional): 컬렉션의 이름입니다. 기본값은 constants.VECTOR_DB_OUTPUT_COLLECTION_NAME입니다.\n        client (Optional[UpstashClient], optional): Upstash 클라이언트입니다. 기본값은 None입니다.\n    \"\"\"\n\n    def __init__(\n        self,\n        vector_size: int = settings.EMBEDDING_MODEL_MAX_INPUT_LENGTH,\n        collection_name: str = settings.UPSTASH_VECTOR_TOPIC,\n        client: Optional[Index] = None,\n    ):\n        self._collection_name = collection_name\n        self._vector_size = vector_size\n\n        if client:\n            self.client = client\n        else:\n            self.client = Index(\n                url=settings.UPSTASH_VECTOR_ENDPOINT,\n                token=settings.UPSTASH_VECTOR_KEY,\n                retries=settings.UPSTASH_VECTOR_RETRIES,\n                retry_interval=settings.UPSTASH_VECTOR_WAIT_INTERVAL,\n            )\n\n    def build(\n        self, step_id: str, worker_index: int, worker_count: int\n    ) -> StatelessSinkPartition:\n        return UpstashVectorSink(self.client, self._collection_name)\n\n\nclass UpstashVectorSink(StatelessSinkPartition):\n    \"\"\"\n    Upstash Vector 데이터베이스 컬렉션에 문서 임베딩을 작성하는 싱크입니다.\n    이 구현은 효율성을 높이기 위해 배치 업서트를 활용하며, 오류 처리 및 로깅을 향상시키고 가독성 및 유지 보수성을 위해 Pythonic한 모법을 따릅니다.\n\n    Args:\n        client (Index): 쓰기에 사용할 Upstash Vector 클라이언트입니다.\n        collection_name (str, optional): 쓸 컬렉션의 이름입니다. 기본값은 UPSTASH_VECTOR_TOPIC 환경 변수의 값입니다.\n    \"\"\"\n\n    def __init__(\n        self,\n        client: Index,\n        collection_name: str = None,\n    ):\n        self._client = client\n        self._collection_name = collection_name\n        self._upsert_batch_size = settings.UPSTASH_VECTOR_UPSERT_BATCH_SIZE\n\n    def write_batch(self, documents: List[EmbeddedDocument]):\n        \"\"\"\n        구성된 Upstash Vector 데이터베이스 컬렉션에 문서 임베딩의 배치를 작성합니다.\n\n        Args:\n            documents (List[EmbeddedDocument]): 쓸 문서들입니다.\n        \"\"\"\n        vectors = [\n            Vector(id=doc.doc_id, vector=doc.embeddings, metadata=doc.metadata)\n            for doc in documents\n        ]\n\n        # 효율성을 위한 배치 업서트\n        for i in range(0, len(vectors), self._upsert_batch_size):\n            batch_vectors = vectors[i : i + self._upsert_batch_size]\n            try:\n                self._client.upsert(vectors=batch_vectors)\n            except Exception as e:\n                logger.error(f\"배치 업서트 중 예외 발생 {e}\")\n```\n\n<div class=\"content-ad\"></div>\n\n이 구현에서 중요한 사항들입니다:\n\n- UpstashVectorOutput: 다양한 대상으로 데이터를 전달하기 위해 설계된 Bytewax DynamicSink 추상화를 인스턴스화합니다. 우리의 경우, 이는 Upstash Vector Index 클라이언트 연결 위에 래핑될 것입니다.\n- UpstashVectorSink: 우리의 DynamicSink을 래핑하고 업서트 벡터를 우리의 VectorDatabase에 처리하는 기능을 담당합니다. 이 StatelessSinkPartition은 DynamicSink가 어떠한 상태도 유지하지 않고 우리의 Sink에 대한 모든 입력을 write_batch 기능 구현에 따라 처리합니다.\n\n## 나머지 Bytewax Flow 빌드하기\n\n여기 Upstash Kafka Topic에서 메시지를 가져와 정제, 수정, 분할, 삽입하고 Upstash Vector Index에 벡터를 업서트하는 저희 DataFlow의 전체 구현입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n\"\"\"\n    이 스크립트는 Upstash 사용 사례에 대한 ByteWax 데이터플로 구현을 정의합니다.\n    데이터플로에는 다음 단계가 포함되어 있습니다:\n        1. 입력: 카프카 스트림에서 데이터를 읽기\n        2. 정제: 입력 데이터를 공통 형식으로 변환 \n        3. 청크 분리: 입력 데이터를 더 작은 청크로 분리\n        4. 임베드: 입력 데이터에 대한 임베딩 생성\n        5. 출력: 출력 데이터를 Upstash 벡터 데이터베이스에 쓰기\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Optional\n\nimport bytewax.operators as op\nfrom vector import UpstashVectorOutput\nfrom consumer import process_message, build_kafka_stream_client\nfrom bytewax.connectors.kafka import KafkaSource\nfrom bytewax.dataflow import Dataflow\nfrom bytewax.outputs import DynamicSink\nfrom embeddings import TextEmbedder\nfrom models import ChunkedDocument, EmbeddedDocument, RefinedDocument\nfrom logger import get_logger\n\nlogger = get_logger(__name__)\n\n\ndef build(\n    model_cache_dir: Optional[Path] = None,\n) -> Dataflow:\n    \"\"\"\n    Upstash 사용 사례에 대한 ByteWax 데이터플로를 구축합니다.\n    다음과 같은 데이터플로를 따릅니다:\n        * 1. Tag: ['kafka_input']   = KafkaSource에서 입력 데이터 읽기\n        * 2. Tag: ['map_kinp']      = KafkaSource에서 CommonDocument로 메시지 처리\n            * 2.1 [Optional] Tag ['dbg_map_kinp'] = ['map_kinp'] 후 디버깅\n        * 3. Tag: ['refine']        = 메시지를 정제된 문서 형식으로 변환\n            * 3.1 [Optional] Tag ['dbg_refine'] = ['refine'] 후 디버깅\n        * 4. Tag: ['chunkenize']    = 정제된 문서를 더 작은 청크로 나누기\n            * 4.1 [Optional] Tag ['dbg_chunkenize'] = ['chunkenize'] 후 디버깅\n        * 5. Tag: ['embed']         = 청크에 대한 임베딩 생성\n            * 5.1 [Optional] Tag ['dbg_embed'] = ['embed'] 후 디버깅\n        * 6. Tag: ['output']        = 임베딩을 Upstash 벡터 데이터베이스에 쓰기\n    노트:\n        각 선택적 태그는 문제 해결을 위해 활성화할 수 있는 디버깅 단계입니다.\n    \"\"\"\n    model = TextEmbedder(cache_dir=model_cache_dir)\n\n    dataflow = Dataflow(flow_id=\"news-to-upstash\")\n    stream = op.input(\n        step_id=\"kafka_input\",\n        flow=dataflow,\n        source=_build_input(),\n    )\n    stream = op.flat_map(\"map_kinp\", stream, process_message)\n    # _ = op.inspect(\"dbg_map_kinp\", stream)\n    stream = op.map(\"refine\", stream, RefinedDocument.from_common)\n    # _ = op.inspect(\"dbg_refine\", stream)\n    stream = op.flat_map(\n        \"chunkenize\",\n        stream,\n        lambda refined_doc: ChunkedDocument.from_refined(refined_doc, model),\n    )\n    # _ = op.inspect(\"dbg_chunkenize\", stream)\n    stream = op.map(\n        \"embed\",\n        stream,\n        lambda chunked_doc: EmbeddedDocument.from_chunked(chunked_doc, model),\n    )\n    # _ = op.inspect(\"dbg_embed\", stream)\n    stream = op.output(\"output\", stream, _build_output())\n    logger.info(\"성공적으로 ByteWax 데이터플로를 생성했습니다.\")\n    logger.info(\n        \"\\t단계: Kafka 입력 -> 매핑 -> 정제 -> 청크 분리 -> 임베딩 -> 업로드\"\n    )\n    return dataflow\n\n\ndef _build_input() -> KafkaSource:\n    return build_kafka_stream_client()\n\n\ndef _build_output() -> DynamicSink:\n    return UpstashVectorOutput()\n```\n\n<div class=\"content-ad\"></div>\n\n- kafka_input: 카프카 메시지를 가져와 CommonDocument Pydantic 형식으로 변환하는 단계입니다.\n- map_kinp: 카프카 입력을 의미하며, 수신된 메시지에 flat map을 적용하여 List[CommonDocument] Pydantic 객체를 생성합니다.\n- refine: List[CommonDocument]를 순회하고 RefinedDocument 인스턴스를 생성하는 단계입니다.\n- chunkenize: List[RefinedDocument]를 순회하고 ChunkedDocument 인스턴스를 생성하는 단계입니다.\n- embed: List[ChunkedDocuments]를 순회하고 EmbeddedDocument 인스턴스를 생성하는 단계입니다.\n- output: List[EmbeddedDocument]를 순회하고 Vector 객체를 생성하여 Upstash Vector Index에 업서트하는 단계입니다.\n\n# 파이프라인 시작\n\n지금까지 구현한 것은 다음과 같습니다:\n\n- 데이터 수집 파이프라인: 주기적으로 NewsAPI에서 원시 페이로드를 가져와 형식을 지정한 뒤, 카프카 토픽으로 메시지를 전송하는 단계입니다.\n- 인제션 파이프라인: 이는 Bytewax DataFlow로, 카프카 토픽에 연결되어 메시지를 소비하고, 최종적으로 벡터를 업서트하는 Vector 데이터베이스에 업데이트합니다.\n\n<div class=\"content-ad\"></div>\n\n프로젝트 루트에있는 Makefile에서 미리 정의된 명령을 사용하여 이 두 서비스를 모두 시작할 수 있습니다:\n\n```js\n# 카프카 메시지를 생성하기 위해 데이터 수집 파이프라인 실행\nmake run_producers\n\n# 카프카 메시지를 소비하고 벡터를 업데이트하기 위해 인제스처리 파이프라인 실행\nmake run_pipeline\n```\n\n그리고... 완료되었습니다!\n성공적으로 프로듀서/컨슈머 서비스를 시작했습니다.\n남은 모듈은 UI입니다. 벡터 데이터베이스와 뉴스 기사를 검색하는 데 상호 작용하는 데 사용됩니다.\n\n# 사용자 인터페이스\n\n<div class=\"content-ad\"></div>\n\nUI는 다음과 같은 기능을 갖춘 기본 Streamlit [8] 애플리케이션입니다:\n\n- 텍스트 검색 창\n- 벡터 데이터베이스에서 가져온 기사로 채워진 카드가 표시되는 div 섹션\n\n카드에는 다음과 같은 데이터 필드가 포함되어 있습니다:\n\n- 발행일\n- 유사도 점수\n- 기사 이미지\n- SeeMore 버튼을 클릭하면 원본 기사 URL로 이동합니다.\n\n<div class=\"content-ad\"></div>\n\n한번 메시지/질문을 텍스트 상자에 입력하면 입력이 정리되고 (소문자로 변환, 비ASCII 문자 제거 등) 그리고 삽입됩니다. 새로운 삽입물을 사용하여 벡터 데이터베이스를 쿼리하여 가장 유사한 항목을 가져옵니다. 그 결과는 구성되어 렌더링될 것입니다.\n\n다음은 예시입니다:\n\n\n![How to build a real-time News Search Engine using VectorDBs - Part 1](/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_11.png)\n\n![How to build a real-time News Search Engine using VectorDBs - Part 2](/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_12.png)\n\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n축하합니다!\n\n성공했습니다! 멋진 프로젝트만큼이나 라이브로 출시할 준비가 된 뉴스 검색 엔진을 만들었습니다. 단순히 무작정 던지는 것이 아니라, 우리는 최고의 소프트웨어 개발 관행을 따르기도 했습니다.\n\nPydantic을 사용하여 데이터를 잘 처리했고, 유닛 테스트를 작성하고, 스레딩을 활용하여 작업을 가속화했으며, Upstash의 서버리스 카프카와 벡터 데이터베이스를 활용하여 파이프라인을 쉽게 설정할 뿐만 아니라 빠르고 확장 가능하며 오류 대비 가능하도록 만들었습니다.\n\n<div class=\"content-ad\"></div>\n\n이제 당신은 이 청사진을 대부분의 데이터 기반 아이디어에 적용할 수 있는 능력을 갖게 되었어요. 이건 이 프로젝트뿐만 아니라 앞으로 만들게 될 멋진 것들을 위한 큰 승리에요.\n\n# 참고 자료\n\n[1] News Search Engine using Upstash Vector — Decoding ML Github (2024)\n[2] Upstash Serverless Kafka\n[3] Upstash Serverless Vector Database\n[4] Bytewax Stream Processing with Python\n[5] Singleton Pattern\n[6] sentence-transformers/all-MiniLM-L6-v2\n[7] unstructured Python Library\n[8] Streamlit Python\n\n# 더 읽을 거리\n\n<div class=\"content-ad\"></div>\n\n이 글과 관련성 순으로 정렬되었습니다.","ogImage":{"url":"/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_0.png"},"coverImage":"/assets/img/2024-06-19-Howtobuildareal-timeNewsSearchEngineusingVectorDBs_0.png","tag":["Tech"],"readingTime":28},{"title":"파이썬으로 간단한 ETL 파이프라인 구축하기 초보자를 위한 안내","description":"","date":"2024-06-19 16:10","slug":"2024-06-19-BuildingaSimpleETLPipelineinPythonABeginnersGuide","content":"\n\n소개:\n\nETL (추출, 변환, 로드)은 데이터 엔지니어링에서 필수적인 프로세스로, 다양한 소스에서 데이터를 수집, 변환 및 저장하는 기능을 제공합니다. 이 안내서에서는 Python을 사용하여 날씨 데이터를 API에서 추출, 변환하고 CSV 파일에 저장하는 간단한 ETL 파이프라인을 구축하는 방법을 안내해 드리겠습니다.\n\n설치:\n\n시작하려면 Python 3.8 이상 버전 및 몇 가지 라이브러리가 설치되어 있어야 합니다. 터미널을 열고 다음 명령을 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\npip install requests pandas\n```\n\n**단계 1: 날씨 데이터 추출 기능용 액세스 키 얻기**\n\n날씨 데이터를 가져오기 위해 OpenWeatherMap API를 사용할 것입니다. 먼저 API 키를 얻어야 합니다.\n\n1. API 키 등록하세요:\n\n\n<div class=\"content-ad\"></div>\n\n- OpenWeatherMap 웹사이트로 이동해 주세요.\n- 무료 계정을 등록하고 API 키를 획득해 주세요.\n\n**2. API 문서:**\n\n- 현재 날씨 데이터 섹션으로 이동해 주세요.\n- \"Current Weather Data\"를 클릭한 다음 \"API 문서\"를 클릭해 주세요.\n- 요청하는 방법을 이해하기 위해 \"도시 이름으로 내장된 API 요청\"으로 스크롤해 주세요.\n\n**단계 2: 함수 추출**\n\n<div class=\"content-ad\"></div>\n\n이제 API 키가 있으니, API에서 날씨 데이터를 가져오는 추출 함수를 작성해 봅시다.\n\n```js\n# 중요한 라이브러리들\n\nimport requests\nimport pandas as pd\n```\n\n```js\ndef fetch_weather_data(city: str, api_key: str):\n    url = f'http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric'\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.json()\n    else:\n        return None\n\n# 예시 사용법\napi_key = '당신의_openweathermap_api_키'\ncity = '런던'\nweather_data = fetch_weather_data(city, api_key)\nprint(weather_data)\n```\n\nfetch_weather_data 함수는 도시 이름과 API 키를 사용하여 API 요청 URL을 작성하고, API로 GET 요청을 보내 성공적인 요청이면 JSON 형식의 응답 데이터를 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n### 단계 3: 변환 함수\n\n이제 데이터를 보다 구조화된 형식으로 변환할 것입니다:\n\n```js\ndef transform_weather_data(data: dict):\n    if not data:\n        return None\n\n    weather_info = {\n        'city': data['name'],\n        'temperature': data['main']['temp'],\n        'humidity': data['main']['humidity'],\n        'weather': data['weather'][0]['description'],\n        'wind_speed': data['wind']['speed'],\n        'wind_deg': data['wind']['deg']\n    }\n    return weather_info\n\n# 예제 사용법\ntransformed_data = transform_weather_data(weather_data)\nprint(transformed_data)\r\n```\n\n### 단계 4: 모든 단계를 결합하는 함수\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 변환된 데이터를 CSV 파일로 로드하겠습니다:\n\n```js\ndef load_data_to_csv(data: dict, file_path: str):\n    df = pd.DataFrame([data])\n    df.to_csv(file_path, index=False)\n\n# 사용 예시\noutput_file = 'weather_data.csv'\nload_data_to_csv(transformed_data, output_file)\nprint(f'{output_file}에 데이터 저장 완료')\n```\n\n모든 단계를 통합한 완전한 스크립트입니다:\n\n<div class=\"content-ad\"></div>\n\n```python\ndef fetch_weather_data(city: str, api_key: str):\n    url = f'http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric'\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.json()\n    else:\n        return None\n\ndef transform_weather_data(data: dict):\n    if not data:\n        return None\n\n    weather_info = {\n        'city': data['name'],\n        'temperature': data['main']['temp'],\n        'humidity': data['main']['humidity'],\n        'weather': data['weather'][0]['description'],\n        'wind_speed': data['wind']['speed'],\n        'wind_deg': data['wind']['deg']\n    }\n    return weather_info\n\ndef load_data_to_csv(data: dict, file_path: str):\n    df = pd.DataFrame([data])\n    df.to_csv(file_path, index=False)\n\ndef main():\n    api_key = 'your_openweathermap_api_key'\n    city = 'London'\n    weather_data = fetch_weather_data(city, api_key)\n    if weather_data:\n        transformed_data = transform_weather_data(weather_data)\n        output_file = 'weather_data.csv'\n        load_data_to_csv(transformed_data, output_file)\n        print(f'Data saved to {output_file}')\n    else:\n        print('Failed to fetch data')\n\nif __name__ == '__main__':\n    main()\n```\n\n**결론**\n\n이번 튜토리얼에서는 Python으로 간단한 ETL(추출, 변환, 적재) 파이프라인을 만들었습니다. API에서 데이터를 가져와 변환한 뒤 CSV 파일로 저장했습니다. 이 기본 프로젝트를 통해 데이터 엔지니어링 및 분석에서 중요한 ETL 프로세스를 이해할 수 있습니다.\n\n**추가 자료**\n\n\n<div class=\"content-ad\"></div>\n\n- OpenWeatherMap API","ogImage":{"url":"/assets/img/2024-06-19-BuildingaSimpleETLPipelineinPythonABeginnersGuide_0.png"},"coverImage":"/assets/img/2024-06-19-BuildingaSimpleETLPipelineinPythonABeginnersGuide_0.png","tag":["Tech"],"readingTime":4},{"title":"윈도우 함수의 해부학","description":"","date":"2024-06-19 16:08","slug":"2024-06-19-AnatomyofWindowsFunctions","content":"\n\n## 소극적으로 여겨지는 SQL 작업의 이론과 실무\n\n![이미지](/assets/img/2024-06-19-AnatomyofWindowsFunctions_0.png)\n\n# 소개\n\nIT 분야는 매일 새로운 도구, 새로운 프레임워크, 새로운 클라우드 제공업체, 그리고 새로운 LLM이 생성되는 등 끊임없는 변화로 유명합니다. 그러나 이 바쁜 세계에서도 몇 가지 원칙, 패러다임, 그리고 도구는 '모든 것이 영원하지 않다'는 상태 쿼를 도전하는 것처럼 보입니다. 특히 데이터 분야에서는 SQL 언어만큼 강제적인 예가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n80년대에 탄생한 이후 데이터 웨어하우스 시대를 지나 Hadoop/Data-lake/Big Data로 활용되어 Hive로 거듭난 뒤 지금은 Spark API 중 하나로 살아 숨 쉬고 있어요. 세상은 많이 변했지만 SQL은 여전히 중요하고 존재감이 크죠.\n\n하지만 SQL은 마치 체스와 같아요. 기본 규칙을 이해하기 쉽지만 스스로를 완전히 다루기는 어려운 것 같아요! SQL은 많은 가능성을 지니고 있으며 같은 문제를 해결하는 다양한 방법, 다양한 함수와 키워드를 가지고 있습니다. 불행히도, 더 많이 알려지지 않은 기능들이 많아요. 이를 알면 쿼리를 작성할 때 많은 도움이 될 수 있습니다.\n\n그래서 이번 포스트에서는, 일상적인 쿼리를 작성할 때 굉장히 유용하게 느껴졌던, 그리 잘 알려지지 않은 SQL의 기능 중 하나에 대해 이야기해보려고 해요: 윈도우 함수.\n\n# 윈도우 함수란 무엇인가\n\n<div class=\"content-ad\"></div>\n\n전통적이고 가장 유명한 SGBD(PostgreSQL, MySQL 및 Oracle)는 관계 대수 개념에 기반을 두고 있습니다. 여기에는 행이 튜플로 불리며 테이블은 관계로 불립니다. 관계란 튜플들의 집합으로, 즉 튜플 간의 순서 또는 연결이 없습니다. 그래서 테이블 내의 행에 대한 기본적인 순서가 없으며, 한 행에 수행된 계산은 다른 결과에 영향을 주지 않으며 다른 결과에도 영향을 받지 않습니다. ORDER BY와 같은 절조차도 테이블만을 정렬할 뿐, 다른 행의 값을 기반으로 한 행에서의 계산을 수행하는 것은 불가능합니다.\n\n간단히 말하면, 윈도우 함수가 이를 해결해주며 SQL 기능을 확장하여 다른 행의 값을 기반으로 한 행에서 계산을 수행할 수 있습니다.\n\n# 이해를 돕는 기본 사례/해부학\n\n1- 집계 함수 사용하지 않고 집계하기\n\n<div class=\"content-ad\"></div>\n\nWindows 함수를 이해하는 가장 단순한 예는 '집계하지 않고 집계하는' 능력입니다.\n\n전통적인 GROUP BY를 사용하여 집계를 수행하면 전체 테이블이 두 번째 테이블로 압축되어 각 행이 그룹의 요소를 나타내게 됩니다. 그러나 Windows 함수를 사용하면 행을 압축하는 대신 동일한 테이블에 집계 결과가 포함된 새 열을 생성할 수 있습니다.\n\n예를 들어, 비용 테이블에서 모든 지출을 더해야 한다면, 전통적으로는 다음과 같이 수행할 것입니다:\n\n```js\nSELECT SUM(value) AS total FROM myTable\n```\n\n<div class=\"content-ad\"></div>\n\nWindows 함수를 사용하면 아래와 같이 만들 수 있어요:\n\n```js\nSELECT *, SUM(value) OVER() FROM myTable\n-- 창 함수(window function)가 쿼리에서 열 레벨에 정의됨에 주목하세요\n```\n\n아래 이미지는 결과를 보여줍니다:\n\n![윈도우 함수의 구조](/assets/img/2024-06-19-AnatomyofWindowsFunctions_1.png)\n\n<div class=\"content-ad\"></div>\n\n새로운 테이블을 생성하는 대신, 집계 값은 새로운 열에 반환됩니다. 값은 같지만 테이블이 '요약'되지 않았습니다. 원본 레코드가 유지되었고 계산된 집계를 집계하지는 않았다는 것을 주목하세요 ;)\n\nOVER 절은 윈도우 함수를 생성함을 나타냅니다. 이 절은 계산이 이루어질 레코드를 정의합니다. 위의 코드가 비어있으므로 모든 레코드에 대해 SUM()을 계산합니다.\n\n이는 열의 합계(또는 평균, 최솟값, 최댓값)을 기반으로 계산이 필요할 때 유용합니다. 예를 들어 각 비용이 총 비용에 대한 백분율로 얼마나 기여하는지를 계산하는 경우입니다.\n\n실제 케이스에서는 회사 부서별로 비용이 있는 예처럼 특정 카테고리에 대한 자세한 내용이 필요할 수 있습니다. 다시 말해서, 각 부서별 총 지출을 간단한 GROUP BY로 얻을 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nmyTable에서 depto 및 총합(value)을 그룹화하여 SELECT합니다.\n\n또는 윈도우 함수에서 PARTITION 로직을 지정할 수 있습니다.\n\nmyTable을 PARTITION BY depto로 지정하여 SELECT 및 SUM(value)을 실행합니다.\n\n결과를 확인하세요.\n```\n\n<div class=\"content-ad\"></div>\n\n\n![AnatomyofWindowsFunctions_2](/assets/img/2024-06-19-AnatomyofWindowsFunctions_2.png)\n\n이 예제는 해당 기능이 '창' 함수로 불리는 이유를 이해하는 데 도움이 됩니다. OVER 절은 해당 함수가 작동할 '창' 즉, 테이블의 일련의 줄을 정의합니다.\n\n위의 경우, SUM() 함수는 depto 열 (RH 및 SALES)에 의해 생성된 파티션에서 작동합니다. 이 함수는 depto 열의 각 항목에 대해 '값' 열의 모든 값들을 각각 개별적으로 합산합니다. 줄이 속한 그룹 (RH 또는 SALES)에 따라 '총계' 열의 값이 결정됩니다.\n\n2 — 시간과 순서의 인식\n\n\n<div class=\"content-ad\"></div>\n\n가끔은 다른 행의 값에 기반하여 하나의 행 안의 열의 값을 계산해야 할 때가 있습니다. 전형적인 예로 현재 값과 이전 값에서 계산한 국가의 GDP의 연간 증가율이 있습니다.\n\n지난 해의 값을 필요로 하는 이러한 계산, 현재 및 이전 행의 차이, 시리즈의 첫 번째 값 등을 필요로 하는 경우는 윈도우 함수의 강력함을 증명합니다. 사실, 표준 SQL 명령어로 이러한 동작을 달성할 수 있는지 모르겠습니다! 아마 가능할 것이지만, 매우 복잡한 쿼리가 될 것입니다...\n\n그러나 윈도우 함수를 사용하면 간단하게 할 수 있습니다. 아래 이미지는 (어린이의 키를 기록하는 테이블입니다):\n\n![테이블 스냅샷](/assets/img/2024-06-19-AnatomyofWindowsFunctions_3.png)\n\n<div class=\"content-ad\"></div>\n\n```js\nSELECT \n  year, height, \n  LAG(height) OVER (ORDER BY year) AS height_last_year\nFROM myTable\n```\n\nLAG('column') 함수는 이전 행의 'column' 값을 참조하는 역할을 합니다. 이것을 한 단계씩의 순차적인 단계로 상상해볼 수 있습니다: 두 번째 행에서는 첫 번째 값을 고려하고, 세 번째 행에서는 두 번째 값을 고려하고, 그 다음 계속 됩니다... 첫 번째 행은 카운트되지 않습니다(따라서 NULL 값이 반환되는 것), 이전 행이 없기 때문입니다.\n\n당연히 '이전 행'을 정의하기 위해 어떤 순서 조건이 필요합니다. 여기에서 윈도우 함수의 또 다른 중요한 개념인 분석 함수가 필요합니다.\n\n전통적인 SQL 함수와 대조적으로 분석 함수(LAG과 같은)는 행들 사이에 순서가 존재한다고 가정합니다 — 이 순서는 OVER() 안에 있는 ORDER BY 절에 의해 정의됩니다, 즉, 처음, 두 번째, 세 번째 행 등의 개념은 OVER 키워드 내에서 정의됩니다. 이러한 함수들의 주요 특징은 현재 행과 상대적인 다른 행을 참조할 수 있는 능력입니다: LAG는 이전 행을 참조하고, LEAD는 다음 행을 참조하고, FIRST는 분할 내 첫 번째 행을 참조하고, 등등이 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\nLAG 및 LEAD의 멋진 점 중 하나는 두 번째 인수인 오프셋을 받아들인다는 것입니다. 이 오프셋은 LEAD의 경우 앞으로 몇 개의 행(LEAD) 또는 뒤로 몇 개의 행(LAG)을 살펴볼지를 지정합니다.\n\n```js\nSELECT \n    LAG(height,  2) OVER (ORDER BY year) as height_two_years_ago,\n    LAG(height,  3) OVER (ORDER BY year) as height_three_years_ago,\n    LEAD(height)    OVER (ORDER BY year) as height_next_year\nFROM ...\n```\n\n또한 이러한 함수들로 계산을 수행하는 것도 완벽하게 가능합니다:\n\n```js\nSELECT \n    100*height/(LAG(height) OVER (ORDER BY year)) \n    AS \"annual_growth_%\"\nFROM ...\n```\n\n<div class=\"content-ad\"></div>\n\n3 - 시간 인식과 집계\n\n시간과 공간은 하나라고 아인슈타인이 한번 말했던 적이 있는데, 그런 느낌인 것 같아요. 잘 모르겠어요 ¯\\_(ツ)_/¯\n\n이제 파티션 분할과 정렬하는 방법을 알았으니, 두 가지를 함께 사용할 수 있어요! 이전 예제로 돌아와서, 그 표 위에 더 많은 아이들이 있다고 상상해 봅시다. 우리는 각 아이의 성장률을 계산해야 할 때가 왔어요. 매우 간단해요. 정렬과 파티션을 결합해 보세요! 년도별로 정렬하고 아이 이름별로 파티션하면 되겠네요.\n\n```js\nSELECT 1-height/LAG(height) OVER (ORDER BY year PARTITION BY name) ...\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_4.png\" />\n\n위의 쿼리는 다음을 수행합니다 — child에 따라 테이블을 분할하고 각 분할에서 년도별로 값을 정렬한 후 현재 년도의 높이 값을 이전 값으로 나눈 다음 (결과를 1에서 빼서) 계산합니다.\n\n'윈도우(window)'의 전체 개념에 점점 다가가고 있어요! 이것은 '윈도우(window)'가 테이블 슬라이스이며, PARTITION BY에서 정의된 열로 그룹화된 행 세트로서, ORDER BY에서 정의한 필드로 정렬되어, 동일한 그룹(분할) 내의 행만을 고려하며 특정 순서로 모든 계산이 이루어진다는 것입니다.\n\n4-순위 및 위치\n\n<div class=\"content-ad\"></div>\n\nWindows 함수는 세 가지 카테고리로 나뉠 수 있는데, 그 중 두 가지에 대해 이미 이야기했습니다: 집계 함수 ( COUNT, SUM, AVG, MAX, ... )와 분석 함수 ( LAG, LEAD, FIRST_VALUE, LAST_VALUE, ... ).\n\n세 번째 그룹은 가장 간단한 순위 함수입니다. 그 중에서도 row_number() 함수가 가장 큰 영향을 미칩니다. 해당 함수는 그룹 내에서 행의 위치를 나타내는 정수를 반환합니다 (정의된 순서에 따라).\n\n```js\nSELECT row_number() OVER(ORDER BY score)\n```\n\n순위 함수는 이름에서 알 수 있듯이 그룹 내 라인의 위치에 따라 값이 반환되며, 정렬 기준에 따라 정의된 그룹입니다. ROW_NUMBER, RANK 및 NTILE이 가장 많이 사용되는 함수 몇 가지입니다.\n\n<div class=\"content-ad\"></div>\n\n위의 이미지에서 각 플레이어의 점수에 기반한 행 번호가 생성됩니다.\n\n... 그리고 네, 1부터 시작하는 끔찍한 프로그래밍 죄악을 저질립니다.\n\n5-창 크기\n\n<div class=\"content-ad\"></div>\n\n현재까지 소개된 모든 함수들은 결과를 계산할 때 파티션/그룹 내의 모든 행을 고려합니다. 예를 들어, 첫 번째 예제에서 설명한 SUM() 함수는 총계를 계산할 때 모든 부서의 행을 고려합니다.\n\n하지만 더 작은 창 크기를 지정하여 현재 행 전후 몇 줄을 계산에 고려할 수도 있습니다. 이는 이동 평균/롤링 윈도우를 계산하는 데 유용한 기능입니다.\n\n다음 예제를 고려해 봅시다. 특정 질병의 일일 발병 건수를 포함하는 표가 있고, 현재 날짜와 이전 2일을 고려하여 발병 건수의 평균을 계산해야 하는 경우를 생각해 봅시다. 앞서 소개된 LAG 함수로도 이 문제를 해결할 수 있다는 점을 주목해 주세요:\n\n```js\nSELECT\n( n_cases + LAG(n_cases, 1) + LAG(n_cases, 2) )/3\nOVER (ORDER BY date_reference)\n```\n\n<div class=\"content-ad\"></div>\n\n하지만 더 우아하게 동일한 결과를 얻을 수 있습니다. 프레임 개념을 사용하여:\n\n```js\nSELECT\nAVG(n_cases)\nOVER (\n ORDER BY date_reference\n ROWS BETWEEN 2 PRECEDING AND CURRENT ROW \n)\n```\n\n위의 프레임은 이전 2개의 행과 현재 행에 대해서만 평균을 계산해야 함을 지정합니다. 이전, 현재 행 및 다음 행을 모두 고려하고 싶다면, 프레임을 변경할 수 있습니다:\n\n```js\nAVG(n_cases)\nOVER (\n ORDER BY date_reference\n ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n)\n```\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경하세요.\n\n그것이 프레임이란 거에요 — 특정한 범위 내에서 함수의 작용을 제한하는 방법입니다. 대부분의 경우, 윈도우 함수는 다음과 같은 프레임을 고려합니다:\n\n```js\nROWS BETWEEN UNBOUDED PRECEDING AND CURRENT ROW\n-- 이전의 모든 행 + 현재 행\n```\n\n<img src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_6.png\" />\n\n이 소개가 윈도우 함수가 무엇이고, 어떻게 작동하며, 실제 구문은 어떻게 되는지 더 잘 이해하도록 도와드리기를 바랍니다. 당연히 윈도우 함수에는 많은 다른 키워드가 추가될 수 있지만, 이미 다룬 명령어들이 일상 생활에서 많이 사용될 것으로 생각합니다. 이제 제가 일상에서 문제를 해결하기 위해 사용하는 흥미로운 실용적인 응용 프로그램 중 일부를 살펴보겠습니다 — 아주 흥미로운 것들이 있답니다!\n\n<div class=\"content-ad\"></div>\n\n# Windows 함수의 흥미로운 사용 사례\n\n## 시간별 누적 합계\n\n이것은 Windows 함수를 사용하는 가장 고전적인 사례 중 하나입니다.\n\n매월 당신의 급여가 나와 있는 표가 있다고 상상해보세요. 각 달에 얼마를 벌었는지 누적으로 알고 싶다면(이전 달 모두를 고려하여), 이것이 작동하는 방식입니다:\n\n<div class=\"content-ad\"></div>\n\n아주 쉽죠?\n\n이 쿼리에서 흥미로운 점은 SUM() 함수가 현재 행 및 이전 모든 행을 고려하여 집계를 계산한다는 것입니다.\n\n## 로그 테이블의 이벤트 지속 시간\n\n<div class=\"content-ad\"></div>\n\n제가 최근에 작성한 포스트인 \"덕DB의 My First Billion (of Rows)\"에서는 브라질의 전자 투표 기계에서 로그를 조작하는 내용을 다뤘어요. 대량의 데이터 처리에 관심이 있다면 한 번 확인해보세요.\n\n요약하면, 각 이벤트가 시작된 시간을 나타내는 타임스탬프와 이름, 그리고 고유 식별자로 구성된 로그 테이블을 상상해보세요. 각 이벤트는 이전 이벤트가 끝날 때 시작되기 때문에, 이벤트 기간을 나타내는 열을 쉽게 추가할 수 있어요:\n\n![이미지](/assets/img/2024-06-19-AnatomyofWindowsFunctions_8.png)\n\n## 누락된 값 채우기 (마지막 발생으로)\n\n<div class=\"content-ad\"></div>\n\n판다스를 활용한 머신 러닝 클래식! fillna, bfill 또는 다른 방법으로 널 값을 채우는 것만으로도 데이터 처리를 해결할 수 있어요.\n\nSQL에서는 이를 어떻게 할까요? 간단해요!\n\n![이미지](/assets/img/2024-06-19-AnatomyofWindowsFunctions_9.png)\n\n머신 러닝을 처음 공부할 때는 판다스와 같은 고수준의 함수들을 많이 사용하곤 해요. 하지만 실제 프로젝트를 진행할 때는 데이터 양이 매우 많아 판다스를 사용할 수 없는 경우가 많아요. 그럴 때는 PySpark, Snowflake, Hive+hadoop 등의 도구를 사용해야 하는데, 이들은 어떤 식으로든 SQL에서 작업이 가능해요. 그렇기 때문에 SQL에서 이러한 처리와 전처리를 어떻게 하는지 배우는 것이 중요하다고 생각해요.\n\n<div class=\"content-ad\"></div>\n\n## 누락된 값 채우기 (앞 행의 평균으로)\n\n널(빈 값)을 채우는 더 다양한 방법, 그래도 간단합니다!\n\n![Windows Functions](/assets/img/2024-06-19-AnatomyofWindowsFunctions_10.png)\n\n이 예는 윈도우 함수가 복잡하고 특별한 것으로 보일지라도 일반 열처럼 사용할 수 있다는 것을 강조합니다! CASE에 포함시킬 수 있고, 계산에 활용할 수 있습니다. 알고 있는 제한 사항 중 일부는 WHERE 절에 직접적으로 배치할 수 없다는 것뿐입니다.\n\n<div class=\"content-ad\"></div>\n\n```sql\nSELECT * FROM\nWHERE SUM() OVER() > 10 -- 이 기능은 postgres에서는 불가능합니다.\n```\n\n## 특정 열 기반의 행 중복 제거\n\n윈도우 함수의 또 다른 고전적인 사례! 때로는 하나의 열 집합을 기준으로 하여 테이블의 행을 중복 제거해야 할 때가 있습니다.\n\n물론 SQL에서는 DISTINCT 절을 사용할 수 있지만, 이는 전체 행이 중복될 때만 작동합니다. 테이블에 같은 ID 열의 값이지만 나머지 열에서는 다른 값이 있는 여러 행이 있는 경우 다음 로직을 사용하여 중복을 제거할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-AnatomyofWindowsFunctions_11.png\" />\n\n```js\nSELECT *\n  FROM (\n   SELECT\n   ROW_NUMBER() OVER (PARTITION BY id) as row_number\n  )\nWHERE row_number = 1\n```\n\n이 작업은 데이터 버전 관리도 가능합니다! 예를 들어, 시스템에서 사용자가 이름을 변경할 때마다 변경 날짜와 함께 새로운 줄을 저장하면(기존 줄을 변경하는 대신), 각 사용자의 현재 이름을 검색할 수 있습니다:\n\n```js\nSELECT\n    *\nFROM\n(\n  SELECT \n    name, \n    row_number() OVER (PARTITION BY id ORDER BY DATE DESC) AS row_number\n  FROM myTable\n) AS subquery\nWHERE row_number = 1\n```\n\n<div class=\"content-ad\"></div>\n\n<table> 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n그리고 여러분, Windows 함수의 흥미로운 케이스가 있나요? 공유하고 싶은 내용이 있다면 댓글에 남겨주세요!\n\n# 결론\n\nSQL이 고전적이거나 클래식하다고 말할 수 없겠죠. 이런 용어들은 과거를 가리키지만, SQL은 저에게 있어 현재에서 매우 중요하며 데이터 분야에서 일하는 사람들에게 꼭 필요한 언어입니다.\n\n그렇지만 SQL로만 해결하기 어려운 문제들이 몇 가지 있을 수도 있습니다. 이럴 때는 언어와 그 능력에 대한 좋은 이해가 정말 중요합니다. Windows 함수가 없다면, Python 관점에서는 보편적으로 간주되는 많은 문제들이 매우 어려우거나 심지어 불가능할 수도 있습니다. 하지만 우리가 도구를 올바르게 사용하는 방법을 안다면 마법을 부릴 수 있습니다!\n\n<div class=\"content-ad\"></div>\n\n이 게시물이 Windows 기능이 작동하는 방식과 실제로 해결할 수 있는 문제 유형을 더 잘 이해하는 데 도움이 되었으면 좋겠습니다. 여기에 제시된 모든 자료는 주로 PostgreSQL 구문을 기반으로 하고 있으며, 다른 데이터베이스에서는 바로 작동하지 않을 수 있지만 가장 중요한 것은 논리 자체입니다. 항상 전문가가 아니며, 해당 주제에 관심이 있는 모든 분들에게 깊이 있는 학습 및 많은 실습을 권장합니다.\n\n독자 여러분, 감사합니다! ;)\n\n# 참고 문헌\n\n[1] PostgreSQL 윈도우 함수를 사용한 데이터 처리. (미상). Timescale. 링크.\n[2] Kho, J. (2022, June 5). 고급 SQL 윈도우 함수 쉬운 안내 — Towards Data Science. Medium.\n[3] Markingmyname. (2023, November 16). Funções analíticas (Transact-SQL) — SQL Server. Microsoft Learn.\n[4] PostgreSQL Tutorial. (2021, April 27). PostgreSQL 윈도우 함수: 궁극의 안내. 링크.\n[5] VanMSFT. (2023, May 23). OVER 절 (Transact-SQL) — SQL Server. Microsoft Learn.\n[6] 윈도우 함수. (미상). SQLite 공식 문서.\n[7] 윈도우 함수. (2014, July 24). PostgreSQL 문서.\n\n<div class=\"content-ad\"></div>\n\n이 게시물의 모든 이미지는 저자가 제작했습니다.","ogImage":{"url":"/assets/img/2024-06-19-AnatomyofWindowsFunctions_0.png"},"coverImage":"/assets/img/2024-06-19-AnatomyofWindowsFunctions_0.png","tag":["Tech"],"readingTime":11},{"title":"카프카 API에 대한 부드러운 소개","description":"","date":"2024-06-19 16:05","slug":"2024-06-19-AGentleIntroductiontoKafkaAPI","content":"\n\n![Kafka API 소개](/assets/img/2024-06-19-AGentleIntroductiontoKafkaAPI_0.png)\n\n카프카는 링크드인에서 처음 시작되어 강력하고 확장 가능한 메시지 버스를 구축하기 위한 프로젝트입니다. 이는 링크드인의 데이터 인프라에서 중추적인 역할을 하였으며 독특한 기능과 능력으로 널리 채택되었습니다. 이 잠재력을 인지한 후, 2016년 링크드인은 카프카를 아파치 소프트웨어 재단에 기부하여 아파치 카프카로 발전시켜왔습니다. 이후 아파치 카프카는 초기 기능을 유지하면서 추가적인 기능과 개선을 얻게 되었습니다.\n\n카프카가 인기를 얻고 코드베이스가 성숙해짐에 따라 여러 업체가 자체 카프카 배포 버전을 출시하려고 포크했습니다. Redpanda나 Warpstream과 같은 기업들은 심지어 자바 이외의 다른 프로그래밍 언어로 전체 코드베이스를 다시 작성하는 일까지 진행했습니다.\n\n그러나 이러한 변경 사항들 속에서도 이 기업들은 중요한 한 가지를 변경하지 않으려았습니다 — 카프카 API입니다. 이 표준 인터페이스는 서로 다른 카프카 배포판 간의 호환성과 상호 운용성을 보장하는 데 중요한 역할을 합니다.\n\n<div class=\"content-ad\"></div>\n\n# 아파치 카프카 대 Kafka API\n\n아파치 카프카와 Kafka API의 차이를 이해하는 것이 중요합니다. 이 둘은 서로 다른 개체들입니다.\n\n아파치 카프카는 분산형 병합 전용 커밋 로그입니다. 이는 프로듀서로부터 메시지를 수신하고 이를 내결함성을 가진 방식으로 저장하여 소비자가 수신된 순서대로 이러한 메시지를 가져올 수 있도록 합니다. 이러한 설계로 인해 카프카는 안정적이고 매우 확장 가능한 실시간 데이터 피드 처리를 위한 발행-구독 메시징 시스템으로 확립되었습니다.\n\n당신은 Kafka API를 통해 Kafka와 작업할 것입니다. 개발자로서, Kafka API를 사용하여 Kafka에 데이터를 읽고 쓸 수 있는 클라이언트 응용 프로그램을 작성할 것입니다. 운영자로서, Kafka API를 사용하여 Kafka에 관리 작업을 수행할 것입니다. Kafka 배포가 오픈 소스인지 상업용 제품인지에 상관없이, 여전히 동일한 Kafka API를 사용해야 합니다. 따라서 Kafka API를 이해하는 것이 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-AGentleIntroductiontoKafkaAPI_1.png)\n\n이 게시물에서는 Kafka 배포를 사용할 때 마주치게 될 고수준 개념을 다룰 것입니다. 이 내용은 특정 프로그래밍 언어나 벤더와 무관합니다. Kafka 프로토콜이나 API 메서드의 세부 내용에 대해 깊이 있게 다루지 않고 개념적으로 논의할 것입니다.\n\n# 브로커와 클러스터\n\nKafka는 브로커가 이 시스템 내에서 단일 노드를 나타내는 분산 시스템입니다.\n\n\n<div class=\"content-ad\"></div>\n\n부킹 애플리케이션에서 클라이언트를 여러 개의 브로커에 초기 연결하려면 어떻게 해야 하나요? Bootstrap Server 주소를 사용해야 합니다. 이는 애플리케이션이 클러스터 메타데이터를 얻기 위해 상호 작용하는 첫 번째 브로커입니다. 추후 상세히 다룰 주제입니다. 위의 이미지를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n# 메시지\n\n카프카 세계에서 메시지, 레코드, 이벤트 모두 같은 개념을 가리킵니다 - 응용 프로그램과 브로커 간에 전송되는 데이터의 단위입니다.\n\n메시지는 키(key)와 값(value)으로 구성됩니다. 값은 실제 데이터 또는 보내거나 받고 싶은 페이로드를 포함합니다. 키는 null을 포함한 모든 값을 사용할 수 있습니다. 일반적으로 값과 관련된 속성이 키로 지정됩니다. 예를 들어 값이 주문 객체인 경우 키는 고객 ID가 될 수 있습니다. 키를 가지는 이유는 메시지를 주제 내의 특정 파티션으로 라우팅하기 위한 것입니다. 우리는 파티션에 대해 알아갈 때 이에 대해 배우게 될 것입니다.\n\n![이미지](/assets/img/2024-06-19-AGentleIntroductiontoKafkaAPI_3.png)\n\n<div class=\"content-ad\"></div>\n\n키와 값은 변수 길이의 바이트 배열로 표현됩니다. 이는 Kafka가 일반 텍스트에서 직렬화된 객체까지 다양한 데이터 유형을 처리할 수 있도록 합니다.\n\n# 토픽\n\n토픽은 메시지의 논리적 그룹화입니다. 관련된 레코드를 함께 유지하는 관계형 데이터베이스 세계의 테이블과 유사합니다. 서로 다른 목적을 위해 서로 다른 토픽을 가질 수 있습니다.\n\n토픽은 Kafka의 정보 계층구조에서 가장 높은 수준에 있습니다. 개발자로서 여러분은 클라이언트 응용 프로그램을 작성하게 될 것인데, 이는 다양한 토픽으로부터 데이터를 생성하고 소비합니다. 토픽은 메시지 브로커의 발행-구독 세맨틱스를 빌려옵니다. 토픽은 여러 생산자와 소비자에 의해 동시에 데이터 쓰기 및 읽기를 지원합니다. 또한 메시지가 한 토픽에서 생성되면 여러 소비자가 소비할 수 있는 방송/팬아웃 스타일 메시징을 지원합니다.\n\n<div class=\"content-ad\"></div>\n\n주제는 추가 작업만을 허용하며 임의로 변경할 수 없습니다. 따라서 한 번 메시지를 주제에 쓰면 그것을 다시 업데이트할 수 없습니다. 또한 주제에서 읽는 것은 파괴적인 작업이 아닙니다. 동일한 소비자는 나중에 다시 필요에 따라 메시지를 다시 읽을 수 있습니다. 소비자 오프셋에 대해 언급할 때 이에 대해 알아보겠습니다.\n\n![image](/assets/img/2024-06-19-AGentleIntroductiontoKafkaAPI_4.png)\n\n# 파티션과 오프셋\n\n주제는 연속적이지 않고 파티션으로 구성됩니다.\n\n<div class=\"content-ad\"></div>\n\n주제는 논리적인 개념이며, 파티션은 더 구체적인 엔티티입니다.\n\n주제 파티션은 한 주제에 속한 데이터 하위 집합을 저장하는 append-only 정렬된 로그 파일입니다. 주제는 하나 이상의 파티션이 있을 수 있으며, 이러한 파티션은 클러스터의 다른 브로커에 분산되어 부하 분산 및 내결함성을 제공합니다.\n\n## 파티션의 필요성\n\n파티션 개념이 없고 Kafka가 주제 데이터를 단일 블록으로 유지한다면 어떻게 될까요? 먼저, 데이터가 더 많이 쌓일수록 주제의 크기가 증가하고 곧 단일 기계의 저장 한도를 초과할 것입니다. 추가 저장소를 연결하고 기계를 더 크게 만들 수는 있습니다. 그러나 결국 그에도 한계가 존재할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n둘째, 모든 소비자는 그 큰 주제를 보유한 브로커에서 소비해야합니다. 그렇게 하면 소비자 부하 분산이 없기 때문에 해당 브로커의 부하가 증가합니다. 게다가 그런 방대한 주제를 백업하는 것은 시간이 많이 소요되며, 해당 주제를 저장하고 있는 브로커가 충돌하면 데이터 전체를 잃을 위험이 큽니다.\n\n요약하자면, Kafka에서 주제 파티션을 가지는 것은 데이터를 클러스터 내의 여러 브로커로 분산할 수 있어서 유익합니다. 이 분산은 부하 분산과 장애 허용성을 향상시킵니다. 하나의 기계의 저장 한계를 넘어서 주제 데이터가 성장할 수 있기 때문에 시스템이 확장 가능해집니다. 또한, 파티션은 소비자 부하 분산을 가능하게 하며, 소비자는 서로 다른 브로커에서 소비할 수 있습니다. 이렇게 함으로써 시스템은 보다 효율적이고 신뢰할 수 있어지며, 한 브로커가 충돌하더라도 데이터를 모두 잃을 위험이 줄어듭니다.\n\n## 파티션 오프셋\n\n파티션 내 각 메시지는 고유한 오프셋을 받습니다. 이는 해당 파티션 로그 파일에서 메시지 위치를 나타내는 단조로 증가하는 정수입니다. 간단히 말해, 오프셋은 로그 파일의 시작으로부터 메시지가 얼마나 떨어져 있는지를 말합니다.\n\n<div class=\"content-ad\"></div>\n\n메시지가 파티션에 작성되면 로그 끝에 추가되고 다음 순차적 오프셋이 할당됩니다. 오프셋은 소비자가 파티션에서 소비한 메시지를 추적하는 데 특히 유용합니다.\n\n![image](/assets/img/2024-06-19-AGentleIntroductiontoKafkaAPI_5.png)\n\n## 메시지 순서 및 파티션 라우팅\n\n파티션에 작성된 메시지는 항상 도착하는 순서대로 정렬됩니다. 그러나 토픽을 통해 메시지 순서가 보장되진 않습니다. 파티션 내에서 엄격한 순서가 필요한 경우 파티션 키를 올바르게 사용해야 합니다. 하지만 어떻게 해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n위에서 배운 바와 같이 메시지마다 키를 포함할 수 있습니다. 메시지를 수신하면 Kafka는 키에 해시 함수를 사용하여 메시지를 작성해야 하는 파티션을 결정합니다. 이를 통해 동일한 키로 생성된 모든 레코드가 보낸 순서대로 동일한 파티션에 도달한다는 것이 보장됩니다.\n\n![image](/assets/img/2024-06-19-AGentleIntroductiontoKafkaAPI_6.png)\n\n# 파티션 복제 - 리더와 팔로워\n\n파티션에는 여러 개의 복사본이 있을 수 있습니다. 이는 장애 허용 및 고가용성을 위해 복제됩니다.\n\n<div class=\"content-ad\"></div>\n\n동일한 데이터의 여러 복사본을 유지함으로써 Kafka는 하나의 브로커가 실패하더라도 다른 브로커가 데이터를 제공할 수 있도록 합니다. 이 중복성을 통해 시스템은 장애에도 계속 작동할 수 있습니다. 또한 여러 브로커에 걸쳐 복제본을 갖고 있음으로써 Kafka는 읽기 및 쓰기 요청의 부하를 균형 있게 분산시켜 시스템 성능을 향상시킬 수 있습니다.\n\n토픽을 생성할 때 파티션 수와 복제 요소를 선택적으로 지정할 수 있습니다. 10개의 파티션과 복제 요소를 3으로 설정한 토픽의 경우, 클러스터 전체에 10x3=30개의 파티션이 저장됩니다.\n\n## 파티션 리더와 팔로워\n\n각 파티션 복제본은 리더 또는 팔로워 중 하나입니다. 리더 복제본은 해당 파티션의 모든 읽기 및 쓰기 요청을 처리하고, 팔로워 복제본은 리더를 수동으로 복제합니다. 리더가 실패하면 팔로워 복제본 중 하나가 자동으로 새로운 리더가 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-19-AGentleIntroductiontoKafkaAPI_7.png)\n\nKafka는 파티션 리더를 어떻게 결정할까요? Kafka는 Apache Zookeeper와 같은 분산 콘센서스 알고리즘 구현에 의존하여 파티션에 대한 리더 선출을 처리합니다. 하나의 브로커가 실패하고 다시 온라인 상태로 돌아오거나 클러스터에 새 브로커가 추가될 때마다, ZooKeeper는 각 파티션에 대한 새 리더를 선출하는 데 도움을 줍니다. 선출 프로세스는 특정 파티션에 대해 한 번에 하나의 브로커만이 리더로 작동하도록 보장합니다.\n\n그러나 Kafka의 Zookeeper에 대한 의존성은 폐지되고 KRaft로 대체되고 있습니다. Redpanda와 같은 일부 브로커들은 브로커에 기본 Raft 구현을 통합했습니다.\n\n# Segments\n\n\n<div class=\"content-ad\"></div>\n\n파티션은 실체가 있는 것이라고 언급했지만, 정확히 그렇지는 않아요. 파티션은 더 작은 세그먼트로 나뉩니다.\n\n세그먼트는 카프카 저장소의 데이터 포함의 가장 작은 단위로, 기본적으로 메시지의 일부를 보유하는 추가 전용 정렬된 로그 파일입니다. 여러 세그먼트가 모여 하나의 파티션을 형성합니다.\n\n각 파티션에는 항상 데이터를 수신하는 하나의 활성 세그먼트만 있습니다. 충분한 메시지가 활성 세그먼트에 축적되면 그 세그먼트는 닫히거나 다음 활성 세그먼트로 \"회전\"합니다. 이 세그먼트 크기는 설정 가능합니다.\n\n![이미지](/assets/img/2024-06-19-AGentleIntroductiontoKafkaAPI_8.png)\n\n<div class=\"content-ad\"></div>\n\n시에어끼는 세그먼트에서 메시지는 삭제되거나 압축될 수 있어 디스크 공간을 절약할 수 있습니다. 이것은 구성 가능합니다. 게다가 티어드 스토리지를 사용하면 저렴한 비용으로 예전 로그 세그먼트를 아카이브할 수 있어, 예를 들어 스토리지 비용을 줄이기 위해 S3 버킷에 저장할 수 있습니다.\n\n파티션과 달리 세그먼트는 개발자에게 보이지도, 접근 가능하지도 않습니다. 이들은 주로 저장 및 운영 측면에 속합니다.\n\n# Kafka 클라이언트\n\n우리는 Kafka를 어리석은 파이프라고 말합니다. 그리고 프로듀서와 컨슈머는 스마트 엔드포인트입니다. 그들은 클라이언트 SDK에 포함된 많은 스마트 논리를 가진 두꺼운 클라이언트입니다.\n\n<div class=\"content-ad\"></div>\n\n개발자로서는 대응하는 Kafka 클라이언트 SDK가 있는 모든 프로그래밍 언어로 Kafka 클라이언트를 작성할 수 있습니다. Java 및 Scala가 기본적이며 Python, .NET, Go, Rust, C++ 등의 언어에 대한 Kafka 클라이언트 SDK도 제공됩니다.\n\n생산자(Producer)는 메시지를 생성하고 Kafka 주제(Topic)로 전송하는 클라이언트 애플리케이션입니다. SDK는 생성하는 데 사용되는 send() 메서드를 노출하는데, 해당 메서드는 주제 이름, 키, 값 및 파티션 ID를 매개변수로 사용하여 오버로드되어 있습니다. SDK는 메시지를 파티션별로 그룹화하여 일정 임계치에 도달하면 일괄로 묶어서 각 일괄을 브로커에 전송합니다.\n\n소비자(Consumer)는 Kafka 주제로부터 메시지를 읽는 클라이언트 애플리케이션입니다. Kafka 클라이언트 SDK는 메시지를 한 번에 하나씩 또는 일괄로 소비하는 메서드를 제공합니다. 소비자는 하나 이상의 주제를 구독하고 메시지를 작성된 순서대로 소비할 수 있습니다.\n\n소비자 그룹(Consumer Group)은 여러 사용자가 레코드 처리 작업을 나누는 기능입니다. 여러 소비자가 주제를 구독하고 동일한 소비자 그룹에 속한 경우, 그룹의 각 소비자는 레코드의 일부를 받게 됩니다. Kafka는 메시지가 그룹 내 하나의 소비자만에 의해서만 소비되도록 보장하고 장애 발생 시 소비자를 균형있게 조정하여 확장성과 내결함성에 도움이 되는 유용한 기능입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-AGentleIntroductiontoKafkaAPI_9.png\" />\n\n# 마무리\n\n요약하자면, 우리는 Kafka와 Kafka API의 기본 개념과 구성 요소를 다루었습니다. Kafka가 분산 추가 전용 커밋 로그로 작동하며 Kafka API가 이와 상호 작용하는 표준 인터페이스를 제공하는 방법에 대해 논의했습니다.\n\n브로커와 클러스터, 메시지, 토픽, 파티션, 오프셋 및 복제에 대한 개념, 세그먼트의 중요성 및 Kafka 클라이언트의 역할을 살폈다. 이러한 개념을 이해하는 것은 특정 배포 또는 프로그래밍 언어와는 무관하게 Kafka를 다루는 데 있어 중요합니다.","ogImage":{"url":"/assets/img/2024-06-19-AGentleIntroductiontoKafkaAPI_0.png"},"coverImage":"/assets/img/2024-06-19-AGentleIntroductiontoKafkaAPI_0.png","tag":["Tech"],"readingTime":8},{"title":"AWS Glue ETL을 사용하여 DynamoDB에서 Redshift로 데이터 이전하기","description":"","date":"2024-06-19 16:04","slug":"2024-06-19-DynamoDBtoRedshiftusingAWSGlueETL","content":"\n\nAWS Glue ETL을 사용하여 DynamoDB에서 Redshift로의 파이프라인을 구축하는 과정은 여러 단계로 이루어져 있습니다. 아래에 이를 설정하는 자세한 가이드가 있어요:\n\n단계 1: DynamoDB와 Redshift 설정하기\n\n1. DynamoDB:\n이미 하지 않았다면 DynamoDB 테이블을 생성하고 데이터로 채워 넣어주세요.\n\n2.Redshift:\nAmazon Redshift 클러스터를 설정하세요.\nRedshift에 DynamoDB 테이블 구조와 일치하도록 데이터베이스와 테이블을 생성해주세요.\n\n<div class=\"content-ad\"></div>\n\n단계 2: DynamoDB용 AWS Glue 크롤러 생성하기\n\n1. AWS Glue 콘솔을 엽니다.\n2. 새 크롤러를 생성합니다:\n이름: 크롤러에 이름을 지정합니다.\n데이터 원본: DynamoDB를 선택하고 테이블을 선택합니다.\nIAM 역할: 없는 경우 필요한 권한을 가진 IAM 역할을 생성합니다.\n데이터베이스: 기존의 Glue 데이터베이스를 선택하거나 새 데이터베이스를 생성합니다.\n실행 빈도: 요구 사항에 따라 설정합니다.\n\n3. 크롤러 실행:\n이 작업을 통해 Glue 데이터 카탈로그에 DynamoDB 테이블을 위한 테이블이 생성됩니다.\n\n단계 3: AWS Glue ETL 작업 생성하기\n\n<div class=\"content-ad\"></div>\n\n1. AWS Glue 콘솔을 엽니다.\n2. 새 작업을 만듭니다:\n이름: 작업에 이름을 지정합니다.\nIAM 역할: 동일한 역할 또는 필요한 권한이 있는 다른 역할을 사용합니다.\n유형: \"Spark\"를 선택합니다.\nGlue 버전: 적절한 Glue 버전을 선택합니다.\n보안 구성, 스크립트 라이브러리 및 작업 매개변수: 필요에 따라 구성합니다.\n작업 북마킹: 처리된 데이터를 추적하려면 활성화합니다.\n\n3. 스크립트 편집기:\nGlue Studio 시각적 편집기를 사용하거나 스크립트를 직접 편집할 수 있습니다.\n\n단계 4: ETL 스크립트 작성\n\n다음은 다이나모DB에서 Redshift로 데이터를 이동하는 예제 스크립트입니다:\n\n<div class=\"content-ad\"></div>\n\n```python\nimport sys\nfrom awsglue.transforms import *\nfrom awsglue.utils import getResolvedOptions\nfrom pyspark.context import SparkContext\nfrom awsglue.context import GlueContext\nfrom awsglue.job import Job\n\n# Glue 컨텍스트 초기화\nargs = getResolvedOptions(sys.argv, ['JOB_NAME'])\nsc = SparkContext()\nglueContext = GlueContext(sc)\nspark = glueContext.spark_session\njob = Job(glueContext)\njob.init(args['JOB_NAME'], args)\n\n# DynamoDB 테이블을 소스로 정의\ndynamodb_table = \"dynamodb_table_name\"\ndatasource0 = glueContext.create_dynamic_frame.from_catalog(\n    database=\"your_glue_database\",\n    table_name=dynamodb_table\n)\n\n# 필요한 변환 작업 적용\napplymapping1 = ApplyMapping.apply(\n    frame=datasource0,\n    mappings=[\n        (\"dynamodb_column1\", \"string\", \"redshift_column1\", \"string\"),\n        (\"dynamodb_column2\", \"number\", \"redshift_column2\", \"int\"),\n        # 필요한 경우 더 많은 열 추가\n    ]\n)\n```  \n\n<div class=\"content-ad\"></div>\n\n# Redshift 연결 옵션 정의하기\nredshift_tmp_dir = “s3://your-bucket/temp-dir/”\nredshift_connection_options = '\n“url”: “jdbc:redshift://your-redshift-cluster:5439/your_database”,\n“user”: “your_redshift_user”,\n“password”: “your_redshift_password”,\n“dbtable”: “your_redshift_table”,\n“redshiftTmpDir”: redshift_tmp_dir\n'\n\n# Redshift로 쓰기\ndatasink4 = glueContext.write_dynamic_frame.from_jdbc_conf(\nframe = applymapping1,\ncatalog_connection = “your_redshift_connection”,\nconnection_options = redshift_connection_options\n)\n\n# 작업 완료하기\njob.commit()\n\n단계 5: Glue Job 실행 및 예약하기\n\n<div class=\"content-ad\"></div>\n\n1. 작업 실행\nAWS Glue 콘솔에서 작업을 수동으로 실행할 수 있습니다.\n2. 작업 일정 설정:\nGlue 트리거를 사용하여 특정 간격에 작업을 실행할 수 있는 일정을 설정하세요.\n\n단계 6: ETL 작업 모니터링 및 관리\n\n1. 모니터링:\nAWS Glue의 모니터링 기능을 사용하여 작업 실행, 오류 및 성능을 추적하세요.\n2. 오류 처리:\n필요한 경우 스크립트에 오류 처리를 구현하세요.\n3. 최적화:\n특히 대규모 데이터 집합을 처리할 때 성능을 위해 ETL 작업을 최적화하세요.\n\n이러한 단계를 따르면 AWS Glue ETL 작업을 사용하여 DynamoDB에서 Redshift로 데이터를 전송하는 파이프라인을 설정할 수 있습니다. 감사합니다.","ogImage":{"url":"/assets/img/2024-06-19-DynamoDBtoRedshiftusingAWSGlueETL_0.png"},"coverImage":"/assets/img/2024-06-19-DynamoDBtoRedshiftusingAWSGlueETL_0.png","tag":["Tech"],"readingTime":3},{"title":"dbt 프로젝트 작업 흐름을 빠르게하는 방법 Makefile 사용하기","description":"","date":"2024-06-19 16:02","slug":"2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow","content":"\n\n## 명령 체계를 간소화하고 관련 명령을 그룹화하여 재사용성을 높이세요\n\n빌드, 실행, 테스트, 문서, 스냅샷, 복제 등 dbt 명령이 많이 있습니다. 저와 같은 경우면 필요한 명령어를 다시 입력하기 싫어서 명령어 히스토리를 계속 찾아다니고 있을 것입니다. 특히 여러 명령을 자주 함께 사용할 때는 더 그렇습니다. 더 나은 해결책이 있을 것입니다.\n\n![Makefile](/assets/img/2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow_0.png)\n\n# Makefile이 구원해줄 것입니다\n\n<div class=\"content-ad\"></div>\n\n소프트웨어를 컴파일한 적이 없다면 메이크파일을 본 적이 없을 수도 있어요. 메이크파일은 코드를 컴파일하는 데 필요한 모든 종속성과 명령을 관리하는 데 사용되지만, 리눅스나 맥 OS에서 어떤 작업을 자동화하는 데도 사용할 수 있어요.\n\n메이크파일을 사용하면 기본적으로 자신만의 추상화된 명령을 만들 수 있어요. 이를 필요로 하는 경우가 있습니다:\n\n- 같은 명령을 자주 실행하는 경우\n- 명령이 길고 매번 입력하기 귀찮거나 명령 기록을 찾기 싫은 경우\n- 명령을 논리적으로 && 그룹으로 묶고 싶은 경우\n- 명령을 공유하거나 일반적인 명령 패턴을 프로젝트에 포함하고 싶은 경우\n\n메이크파일의 미세한 세부 사항에 너무 심술을 파는 것은 필요하지 않아요. 알아야 할 주요한 점은 우리가 타겟과 명령으로 구성된 규칙을 만들 수 있다는 것이에요. 'Phony'라는 특별한 타겟을 사용할 것인데요, 아래에서 좀 더 자세히 알아볼게요.\n\n<div class=\"content-ad\"></div>\n\n# 간단한 예제\n\n다음은 dbt 문서를 생성하고 제공하는 간단한 makefile입니다:\n\n```js\n# 기본 대상에 대한 문서 생성 및 제공\n.PHONY: docs\ndocs:\n dbt docs generate && dbt docs serve\n```\n\n- 프로젝트의 루트 디렉토리에 위 줄을 포함한 Makefile(확장자 없음)이라는 파일을 만듭니다.\n- 프로젝트의 루트에서 make docs를 실행하면 dbt docs generate && dbt docs serve 명령이 실행됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n$ make docs\ndbt docs generate && dbt docs serve\n04:35:12  dbt 실행 중=1.7.9\n04:35:12  등록된 어댑터: duckdb=1.7.2\n04:35:12  모델 7개, 테스트 25개, 소스 3개, 노출 0개, 메트릭 0개, 매크로 582개, 그룹 0개, 의미 모델 0개 발견됨\n...\n...\n```\n\n# .PHONY\n\n.PHONY로 시작하는 줄을 본 적이 있을지도 모르겠죠. 이것은 홀덴 코필드와는 아무 상관이 없습니다. 이것은 'Phony targets'라고 불리는 사용자 정의 대상을 정의하는 방법입니다. 이는 파일이 아닌 명령을 참조하는 makefile 규칙입니다.\n\n기억해야 할 것은 대상을 올바르게 작동하도록 'Phony'로 식별하는 것입니다. 이를 간단한 예제처럼 각 대상 위에 할 수도 있고, 대신에 다음과 같이 한 곳에 모두 선언할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n.PHONY: build test docs help\n```\n\n이렇게 하면 build, test, docs, help 네 개의 가짜 대상이 정의되며, 여러분의 makefile 상단에 위치합니다.\n\n# 이것으로 빌드합니다\n\n추가하는 명령어는 실제로 여러분의 개인적인 워크플로우에 따라 다양합니다. 그것이 바로 이에 대한 아름다움입니다 — 그것들은 여러분의 프로젝트에 유용한 명령어로 이루어진 여러분만의 특정 명령어 세트입니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 추가적인 기본 예시 몇 가지가 있어요:\n\n```js\n.PHONY run seed docs kitchen-sink clean \n\nrun:\n dbt run && dbt test\n \nseed:\n dbt seed && dbt run\n \ndocs:\n dbt docs generate && dbt docs serve\n\nkitchen-sink:\n dbt clean && dbt deps && dbt seed && dbt run && dbt test\n\nclean:\n dbt clean && dbt deps\n```\n\n# 고급 예시\n\n명령줄에서 변수를 makefile로 전달하거나 환경 변수를 로드하여 더 심화된 수준으로 이어갈 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n## CLI에서 변수 전달하기\n\n가정해보자. dbt 빌드 명령을 실행하고 dbt 환경 대상을 지정하고 싶다면 다음과 같이 코드를 작성할 수 있습니다:\n\n```js\n.PHONY: build\n\nbuild:\n @echo \"Building project with environment: $(TARGET)\"\n dbt build --target $(TARGET)\n```\n\n그런 다음 make 명령을 실행할 때 사용할 dbt 대상을 지정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n$ make build TARGET=dev\n환경: dev으로 프로젝트 빌드 중\ndbt 빌드 --target dev\n04:11:42  dbt=1.7.9 버전으로 실행 중\n...\n```\n\n환경 변수와 함께 사용하면 makefile이 프로젝트를 조작하는 데 매우 강력한 도구가 될 수 있음을 알 수 있습니다.\n\n## 환경 변수 로드\n\n.env 파일을 로드하려면 makefile 맨 위에 다음을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\ninclude .env\nexport\n```\n\n이제 당신의 makefile은 모든 .env 변수를 불러올 것입니다. 예를 들어 기본 dbt 타겟을 지정할 수 있습니다:\n\n```js\nTARGET=dev\n```\n\n그런 다음, makefile을 업데이트하여 .env 변수가 설정되었는지 확인해주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\ninclude .env\nexport\n\n# Default value for TARGET if not set\nTARGET ?= $(TARGET)\n\n.PHONY: build\n\nbuild:\n @echo \"프로젝트를 환경과 함께 빌드 중: $(TARGET)\"\n dbt build --target $(TARGET)\n```\n\n이제 make build를 실행할 때, .env 파일에 정의된 대상인 dev가 사용됩니다. 그러나 make 명령을 실행할 때 TARGET를 지정하여 재정의할 수도 있습니다:\n\n```js\n# 기본 .env 대상 재정의\nmake build TARGET=prod\n```\n\n이로써 makefile이 일종의 bash 스크립트로 변환되었습니다 (이것을 말할 때 리눅스 전문가들이 나를 죽일지도 모릅니다). 특히 환경 변수를 로드할 수 있다는 점을 고려할 때입니다.\n\n<div class=\"content-ad\"></div>\n\n# 도움말 섹션\n\n명령을 완료하면 만든 모든 사용 가능한 명령에 대해 설명하는 도움말 섹션을 추가하십시오. 이렇게 하면 거의 자체 CLI 도구처럼 만들어집니다!\n\n```js\n# 사용 가능한 명령 표시\n.PHONY: help\nhelp:\n @echo \"사용 가능한 명령:\"\n @echo \"  docs - 기본 대상의 문서 생성 및 서비스\"\n``` \n\n# 일반 dbt 작업을 위한 보일러플레이트 makefile\n\n<div class=\"content-ad\"></div>\n\n여기 시작할 수 있는 보일러플레이트가 있어요. 별로 복잡하지 않지만 시작할 때 도움이 될 거에요:\n\n프로젝트를 위한 기본 TARGET 및 PROFILE을 가진 .env 파일을 만들어놓지 않았다면 기억하세요.\n\n## Makefile 활용\n\n구체적인 요구 사항과 의존성을 갖는 실제 프로젝트에서 makefile이 어떻게 보일 수 있는지 알고 싶다면, Alex가 Zero to dbt 프로젝트의 makefile에서 어떤 작업을 했는지 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n.include .env\n.export\n\n.PHONY: run clean clean_log duck_dev duck_prod\n\nDBT_TARGET = dev\n\nrun:\n @echo \"SPODBTIFY_SOURCE_PARQUET = $$SPODBTIFY_SOURCE_PARQUET\"\n dbt run --target $(DBT_TARGET)\n\ndoc: \n dbt docs generate && dbt docs serve \n\nduck_dev:\n duckdb spodbtify.duckdb -cmd \"USE spodbtify.dev; show all tables\"\n\nduck_prod:\n duckdb spodbtify.duckdb -cmd \"USE spodbtify.prod; show all tables\"\n\nclean: \n unset SPODBTIFY_SOURCE_PARQUET && dbt clean && rm -rf *.duckdb\n\nclean_log:\n rm -rf logs/*.log\n```\n\n이 프로젝트는 duckdb를 사용하므로 Alex가 duckdb를 실행하고 prod 및 dev의 테이블을 표시하는 몇 가지 타겟을 만들었습니다. 따라서 프로젝트에서 makefile을 사용하는 방식은 구성에 매우 의존함을 알 수 있습니다.\n\n# 결론\n\nMakefiles는 사용하는 명령어를 소유하는 강력한 방법이 될 수 있습니다. 여러 명령어를 자주 실행하거나 프로젝트별 공통 작업이 있는 경우 생명 구원자가 될 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n한 가지 단점은 원래 명령어를 추상화함으로써 해당 명령어로부터 동떨어져 있게 될 수 있다는 점입니다. 원래 명령어를 잊어버릴 수도 있고, 새로운 기능이나 사용 패턴을 놓칠 수도 있습니다. 따라서 자주 자신의 makefile을 다시 살펴보는 것이 좋습니다.\n\n프로젝트에서 makefile을 사용하고 계신가요? 팁이나 멋진 사용 예시가 있다면 댓글로 공유해주세요!","ogImage":{"url":"/assets/img/2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow_0.png"},"coverImage":"/assets/img/2024-06-19-HowtouseaMakefiletospeedupyourdbtprojectworkflow_0.png","tag":["Tech"],"readingTime":6},{"title":"AI 개발에서의 데이터 개인 정보 보호 데이터 지역화","description":"","date":"2024-06-19 16:00","slug":"2024-06-19-DataPrivacyinAIDevelopmentDataLocalization","content":"\n\n## 왜 데이터가 어디에 있는지 중요한지 알아야 할까요?\n\n![이미지](/assets/img/2024-06-19-DataPrivacyinAIDevelopmentDataLocalization_0.png)\n\n6월 25일 샌프란시스코에서 열리는 AI 품질 컨퍼런스를 위해 제 발표를 작성하는 과정에서 다루는 주제들이 많이 나왔어요. 발표하는 동안 간단히 언급할 시간이 부족할 것 같아 좀 더 자세히 설명해드리고자 관련 주제에 대한 소규모 칼럼 시리즈를 시작하려고 합니다. 이 칼럼 시리즈는 기계 학습과 AI 개발과 관련된 내용을 데이터 개인 정보 보호와 보안을 유지하면서 다뤄보려고 해요. 오늘은 데이터 위치 지정부터 시작해보겠습니다.\n\n시작하기 전에, 데이터 개인 정보 보호 및 보안 규정이 무엇을 다루는지 명확히 해야 해요. 간단하게 말해서, 이는 \"개인 데이터\"에 적용됩니다. 하지만 무엇이 개인 데이터로 간주될까요? 이는 관할권에 따라 다르지만 보통 PII(이름, 전화번호 등)와 결합되어 사람을 식별할 수 있는 데이터(우편번호, 생일, 성별, 인종, 정치 성향, 종교 등)가 포함됩니다. 이에는 사진, 영상이나 음성 녹음, 컴퓨터나 브라우저에 대한 자세한 정보, 검색 기록, 생체 인식 정보 등이 포함됩니다. GDPR에 대한 규정은 여기에서 설명되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다뤄봐야 할 게 다 되었으니, 데이터 로컬라이제이션에 대해 좀 더 알아보고, 기계 학습 개발자로서 우리에게 미치는 영향을 살펴봅시다.\n\n# 데이터 로컬라이제이션이란?\n\n물어봐 주셔서 감사합니다! 데이터 로컬라이제이션은 본질적으로 데이터가 저장된 지리적 위치에 관한 문제입니다. 데이터를 로컬라이즈하면 데이터를 생성된 위치에 유지하는 것입니다. (이것은 때로 \"데이터 소재지\"로 알려져 있으며 반대 개념은 \"데이터 이동성\"입니다.) 예를 들어, AWS S3에 있는 데이터셋이 us-east-1에 있다면, 당신의 데이터는 사실상 (데이터가 어느 지역에 존재하는지에 관해서는) 미국의 버지니아 북부 어딘가에 물리적으로 저장되어 있습니다. 좀 더 자세히 말하자면, AWS는 버지니아 북부에 여러 개의 특정 데이터 센터를 보유하고 있으며, 이들의 정확한 주소를 온라인으로 확인할 수 있습니다. 그러나 대부분의 경우, 이 정도의 수준에서 일반적인 지역 정보를 알고 있으면 충분합니다.\n\n# 데이터센터의 위치를 왜 신경 써야 하나요? 클라우드는 그냥 '어디에나' 있는 거 아닌가요?\n\n<div class=\"content-ad\"></div>\n\n데이터가 어디에 있는지를 알고 있는 것에는 좋은 이유가 있습니다. 하나는 데이터를 클라우드에 로딩/쓰는 데 실제 물리적인 속도 영향이 있을 수 있습니다. 여러분과 컴퓨터가 데이터 센터가 위치한 지역과 얼마나 떨어져 있는지에 따라 다를 수 있습니다. 하지만 이것은 극도로 빠른 계산을 하지 않는 한 큰 문제가 되지는 않을 것입니다.\n\n중요한 이유 중 하나는 데이터 프라이버시와 관련이 있습니다. 전 세계적으로 데이터 프라이버시 법률 (그리고 클라이언트와의 계약 및 고객이 작성한 동의서)에는 데이터 로컬라이제이션에 관한 규정이 포함되어 있습니다. 데이터 로컬라이제이션 규정은 특정 장소의 시민이나 거주자들에 대한 개인 데이터가 해당 장소의 서버에 저장되도록 요구됩니다.\n\n일반적인 주의 사항:\n\n- 모든 유형의 데이터에 항상 해당되는 것은 아닙니다 (재무 데이터가 보다 자주 해당됨)\n- 모든 유형의 사업에 항상 해당되는 것은 아닙니다 (기술 기업이 보다 자주 해당됨)\n- 정부 요청에 따라 발동되기도 하며, 자동으로 이루어지기도 합니다 (베트남 참조)\n- 데이터를 이동할 동의를 얻을 수 있는 경우도 있고 그렇지 않은 경우도 있습니다\n- 가끔은 초기에 데이터를 해당 국가에 저장하고 나중에 이동할 수도 있습니다 (러시아 참조)\n- 출신 국가 외부에 저장할 수도 있지만 다른 위치에 대한 제약 조건이 있을 수 있습니다 (EU 참조)\n\n<div class=\"content-ad\"></div>\n\n또한, 사설 회사들은 때때로 계약에서 데이터 로컬라이제이션 요구사항을 규제하며, 이는 이러한 법률을 준수하거나 데이터 유출 또는 다른 정부에 의한 감시 위험을 줄이기 위한 것일 수 있습니다.\n\n이것은 말 그대로, 특정 데이터를 저장할 수 있는 데이터 센터의 위치에 법적인 제한이 있을 수 있다는 것을 의미하는데, 이는 주로 데이터의 주체나 데이터 원본 소유자에 따라 결정될 수 있습니다.\n\n# 예시\n\n구체적인 (간소화된) 예시로 설명하는 것이 더 이해하기 쉬울 것입니다.\n\n<div class=\"content-ad\"></div>\n\n- 웹사이트를 운영하고 계신 것 같군요. 사람들이 구매를 할 수 있는 사이트인데요. 신용카드 정보, 주소, 이름, IP 주소, 그리고 기타 몇 가지 정보를 구매 중에 수집하고 계시네요. 동의 배너/소문에는 데이터의 로컬라이제이션에 대한 내용이 포함되어 있지 않다고 하시네요.\n- 러시아, 인도, 그리고 아랍에미리트 연합에서 고객을 받고 계신 것 같군요.\n- 명시적 동의를 받지 않았다면, 이 방문자들로부터 수집한 모든 개인 데이터는 다른 데이터 로컬라이제이션 규정의 영향을 받습니다.\n\n이것이 무엇을 의미하는지요? 이 모든 데이터는 다르게 처리되어야 합니다.\n\n- 러시아 고객의 데이터는 러시아 기반 서버에 처음으로 저장되어야 하며, 적용되는 규정에 따라 전송될 수 있습니다.\n- 유럽 연합 고객의 데이터는 데이터 보안 관련 법률이 충분한 국가에 저장될 수 있습니다 (주목할 점은 러시아가 아님).\n- 아랍에미리트 연합 고객 데이터는 동의를 받지 못해 이를 다른 곳에 저장하지 않아야 합니다.\n\n이로 인해 데이터 엔지니어링에는 분리된 파이프라인이 필요하게 되어 분명한 문제가 발생합니다. 또한 모델링과 훈련에도 어려움이 있을 수 있는데요. 실제로 사용할 데이터셋을 어떻게 구성해야 할까요?\n\n<div class=\"content-ad\"></div>\n\n# 동의 받기\n\nUAE 고객으로부터 데이터 이전에 동의를 받았다면 괜찮았을텐데요. 데이터 엔지니어링은 여전히 러시아 고객의 데이터를 특별한 경로를 통해 전달해야 하지만, 교육용으로 데이터를 결합할 수 있었을 거에요. 그러나 동의를 받지 않아서 지금 난처하게 되었습니다! 동의 도구가 어떤 권한과 인가를 포함하는지 잘 알고, 이런 문제에 빠지지 않도록 해야 해요.\n\n# 즉석 조합\n\n그것을 할 시간이 없다고 가정했을 때, 다른 해결책은 훈련 시간에 다른 데이터베이스에서 로드하는 컴퓨팅 플랫폼을 갖는 것이에요. 데이터셋을 그 때 그 때 결합하고, 모델을 디스크 어딘가에 데이터를 기록하지 않고 학습시키는 것이에요. 일반적으로 (법률적인 조언은 아니에요) 모델 자체가 개인 데이터가 아니기 때문에 법적 규칙의 적용을 받지 않는다는 것이 일반적인 합의입니다. 하지만 이것에는 작업과 인프라 작업이 필요하기 때문에 자신의 개발-운영 역량을 발휘해 보세요.\n\n<div class=\"content-ad\"></div>\n\n생각지도 못한 큰 데이터 양으로 인하여 계산 비용이 빠르게 증가할 수 있습니다. 이 데이터를 기반으로 피처를 생성하지만 사례에 대한 개인 데이터가 여전히 해석 가능하면, 이를 한 곳에 모두 저장할 수 없게 됩니다. 대신, 비식별화/집계된 피처를 별도로 저장하거나 원래 지역으로 돌려쓰거나, 혹은 필요할 때마다 다시 계산해야 할 수 있습니다. 이 모든 것들은 어려운 도전입니다.\n\n# 비식별화 및/또는 집계\n\n다행히도 또 다른 옵션이 있습니다. 데이터를 집계, 요약하거나 철저하게 (되돌릴 수 없게) 비식별화하면 개인 데이터 보호가 사라지고 더 쉽게 작업할 수 있습니다. 식별 가능한 개인 데이터를 저장하지 않는 것이 강력한 인센티브가 될 수 있습니다! (게다가 데이터 누설 및 해킹 위험을 줄일 수 있습니다.) 데이터가 이제 더 이상 고위험 데이터가 아니기 때문에 법적으로 보호되지 않게 되면, 원하는 대로 작업하고 원하는 대로 데이터를 저장할 수 있습니다. 식별되지 않는 피처를 추출하고 식별 가능한 데이터는 버리십시오. 가능하다면요.\n\n하지만 데이터가 언제 충분히 집계되거나 비식별화되어 지역화 법률이 더 이상 적용되지 않는지 결정하는 것은 때로는 어려운 문제일 수 있습니다. 왜냐하면 앞에서 설명한 것처럼, 많은 종류의 인구통계 데이터는 다른 데이터 포인트와 결합되면 식별성을 만들어낼 수 있기 때문입니다. 우리는 종종 PII(전체 이름, 주민등록번호 등)가 제거되면 데이터를 마음대로 사용해도 된다고 생각하는데, 이는 많은 관할권에서 법률이 이를 허용하지 않는 것입니다! 법률 부서와 상담하고 위험의 의미에 대해 성실하게 고려하십시오. 이상적으로, 데이터가 더 이상 개인 데이터가 아닌 경우에 가장 안전합니다. 즉, 개인 수준의 이름, 인구통계, 주소, 전화번호 등이 포함되지 않거나 해시되지 않고 사람이 읽을 수 있는 일반 텍스트로 표시되지 않습니다. 이 글은 법률적 자문이 아닙니다. 법률 부서와 상담해 주세요.\n\n<div class=\"content-ad\"></div>\n\n우리는 데이터를 어디에서든 가져와 조작하고 계산을 실행하고 데이터를 저장하는 데에 익숙합니다 - 노트북, S3 또는 GCS, 또는 원하는 곳 어디에서든요. 그러나 우리가 사람들에 관한 개인 데이터를 더 수집하고 전 세계적으로 더 많은 데이터 개인정보 보호법이 시행되면, 우리는 무엇을 해야 하는지에 대해 더 조심스러워져야 합니다.\n\n# 자주 묻는 질문\n\n## 데이터 출처를 모른다면 어떡해요?\n\n이것은 어려운 상황입니다. 사람들에 관한 일부 개인 데이터가 있고 그 데이터의 출처나 그 사람들의 위치를 전혀 모르고 (아마도 그들이 이행한 동의 양식도 모르는 경우), 안전한 해결책은 이 데이터를 민감한 정보로 다루어 그것을 비식별화하고, 사용 사례에 적합하다면 집계하고, 데이터 개인정보 보호법에 따르면 개인 정보나 민감한 데이터로 간주되지 않도록 하는 것입니다. 그러나 이 데이터를 사용해야 하는 방식으로 인해 그것이 선택지가 아니라면, 변명하지 않고 변호사와 상의할 시간입니다.\n\n<div class=\"content-ad\"></div>\n\n## 회사가 전세계적으로 데이터 센터를 견딜 여유가 없다면 어떻게 할까요?\n\n대부분 이는 동일한 대답입니다. 이상적으로는 사용자 또는 고객으로부터 데이터를 받는 즉시 해당 동의 솔루션을 마련하는 것이 좋지만, 그게 불가능한 경우라면 데이터를 즉시 비식별화하는 방법을 찾는 것을 추천합니다. 사용자로부터 데이터가 수신되면 해당 데이터를 해싱하여 뒤집을 수 없도록 만들고 사용하세요. 인구 통계 또는 다른 민감한 개인 데이터에 대해서는 특히 조심스러워야 하지만, 개인 식별 정보(PII)를 첫 번째로 비식별화하는 것이 중요합니다. 민감하거나 잠재적으로 누군가를 식별할 수 있는 데이터를 저장하지 않는다면 지역화에 대해 걱정할 필요가 없습니다. 이 글은 법적 자문이 아닙니다. 귀사의 법률 부서와 상의하세요.\n\n## 왜 국가들은 이러한 법을 만드는 걸까요?\n\n이에 대한 몇 가지 이유가 있습니다. 일부가 다른 것보다 좋은 이유가 있습니다. 첫째, 데이터가 실제로 국내에 저장된다면 해당 국가에 사실상 비즈니스 존재가 있기 때문입니다(또는 데이터 저장 제공업체가 있음). 따라서 그들은 시민들의 데이터를 남용할 경우 처벌할 권한을 지니게 되어 훨씬 용이해집니다. 둘째, 이는 어떤 국가에서 기술 분야의 경제 발전을 지원하기 위함입니다. 왜냐하면 누군가는 데이터 센터에 전력을 공급, 냉각, 직원 고용, 건축 등을 제공해야 하기 때문입니다. 셋째, 불행하게도 일부 국가는 자국 시민들에 대한 감시 체제를 운영하고 있습니다. 그리고 국내에 데이터 센터가 있으면 전체주의적인 정부가 이 데이터에 접근하기가 더 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n## 데이터 과학자로서 덜 힘들게 하려면 뭘 할 수 있을까요?\n\n미리 계획을 세우세요! 회사의 관련 당사자들과 협력하여 초기 데이터 처리가 준수되면서 필요한 데이터를 얻을 수 있도록 하십시오. 그리고 고객들이 부여하는 동의 및 해당 권한이 무엇인지에 대해 파악하여야 합니다. 만약 여전히 위치 규칙을 가지고 있는 데이터를 소유하게 된다면 해당 데이터가 잘못된 위치에 저장되지 않도록 데이터를 관리할 방법을 찾거나, 데이터를 식별 불가능하게 하거나/또는 집계하여 데이터가 민감하지 않게 만들도록 하여 데이터 개인정보 규정이 더 이상 적용되지 않도록 해야 합니다.\n\n## 알아두어야 할 중요한 데이터 지역화 법률은 무엇이 있나요?\n\n다음은 몇 가지 주요 법률 요약입니다. 그러나 많은 법률이 있으며 시간이 지남에 따라 새로운 법률이 계속 등장할 수 있으므로 이것이 모두가 아닙니다. (다시 한 번 강조하건대, 여기에 포함된 내용은 법적인 조언이 아닙니다):\n\n<div class=\"content-ad\"></div>\n\n- 인도: DPDP(디지털 개인 데이터 보호)는 국가 데이터 개인정보 보호 규정입니다. 이 법은 어떤 것보다 제한적이지는 않지만, 인도 정부 내의 개별 기관은 특정 종류의 데이터에 대해 보다 제한적인 정책을 수립할 수 있습니다. 인도 연방은 은행의 한 예로, 국가법보다 더 제한적인 데이터 로컬라이제이션 정책을 시행합니다. 아메리칸 익스프레스와 같은 금융 기업들은 인도 외부 서버에 인도 금융 거래 데이터를 저장한 것으로 벌금을 받은 사례도 있습니다.\n- 중국: PIPL은 중국의 국가 데이터 개인정보 보호 규정이며, 데이터 로컬라이제이션 규칙은 다소 복잡합니다. \"중국 내 개인들에게 제품이나 서비스를 제공하는 기업\" 및/또는 \"중국 내 자연인의 행위를 분석하고 평가하는 기업\"에 적용되므로 상당히 광범위합니다. 데이터가 법률적으로 \"중요하다\" 또는 \"자연인을 식별하거나 식별할 수 있는 정보\"로 간주된다면, 데이터 로컬라이제이션의 대상이 될 가능성이 높습니다. 앞서 말씀 드렸듯이, 이것은 법률 상담이 아니며 귀하의 법률부에 문의해야 합니다.\n- 러시아: 러시아는 오랜 시간 동안 데이터 로컬라이제이션 법을 시행해왔으며, Facebook 및 Twitter를 포함한 많은 기업이 위반으로 벌금을 받았습니다. \"데이터 로컬라이제이션 법의 제18항(5)에 따르면, 러시아 시민들의 개인 데이터를 수집하는 러시아 및 외국 데이터 처리자들은 초기에 러시아 데이터베이스를 사용하여 데이터를 기록, 저장, 정리, 업데이트하고 추출해야 합니다.\" 이를 적용하는 추가 법률도 있습니다(자세한 내용은 링크 참조). 러시아 서버에서 데이터를 초기 수집하고 저장한 후에는 데이터를 다른 곳으로 이전할 수 있습니다.\n- 베트남: 2018년 법률에 따르면 특정 데이터는 정부 요청에 따라 국내에 24개월 동안 저장되어야 합니다. 이는 전자상거래, 소셜 네트워킹 및 기타 디지털 서비스 분야의 국내 기업 및 특정 외국 기업에 적용됩니다. 또한, 데이터를 제3자에게 전송해야 하는 경우 고객의 동의가 필요합니다.\n- EU(GDPR): EU는 시민들의 데이터가 보관될 수 없는 특정 국가(예: 러시아)에 대한 우려로 인해 일부 국가에 대해 특정 규정을 설정합니다.\n- UAE: 대부분의 데이터에 대해 UAE 외부로 데이터를 전송하려면 해당 주체로부터 동의를 얻어야 합니다. 일부 선택적인 경우에는 이것만으로 충분하지 않을 수도 있으며, 예를 들어 결제 처리 데이터는 UAE 내에 보관되어야 합니다.\n- 일본: 데이터 주체는 일본과 특정 데이터 공유 협정에 가입한 다른 나라로 데이터를 전송할 때 동의를 해야 합니다.\n\n당신의 회사 크기와 같은 다른 고려 사항도 있습니다(일부 장소에서는 소규모 기업에 대해 제한적인 규칙이 적용되고, 일부 장소에서는 그렇지 않습니다), 그러므로 이것을 귀하의 비즈니스에 대한 결론적인 답변으로 받아들이면 안 됩니다.\n\n# 결론\n\n여기까지 읽어 주셔서 감사합니다! 지루할 수 있지만, 이야기로 보답하겠습니다. 한 번, 우리가 EU에서 생성된 데이터가 EU에 있어야하는 데이터 로컬라이제이션 조항이 포함된 계약에서 일한 적이 있습니다(법으로 아니라 다른 기업이 이러한 규칙을 설정한 경우), 그래서 미국에 북아메리카 데이터 저장소를 이미 구축한 상황이었습니다.\n\n<div class=\"content-ad\"></div>\n\n다양한 이유로 새로운 복제 데이터베이스가 만들어졌습니다. 이 데이터베이스는 EU 지역에 위치하고 EU 관련 데이터만 포함하고 있었습니다. 그래서 전체 Snowflake 데이터베이스의 두 버전을 병렬로 유지했습니다. 이는 새로운 테이블을 생성하거나 필드를 변경하거나 데이터베이스에서 무언가를 수행할 때 다른 쪽에서도 작업을 복사해야 했기 때문에 악몽이었습니다. 당연히 대부분의 사람들은 이를 기억하지 못했기 때문에 두 데이터베이스는 크게 다르게 발전했고, 스키마가 크게 다른 수준으로 발전했습니다. 그래서 쿼리 및 작업을 위한 끝없는 조건부 코드가 필요했고, 데이터를 추출하며 올바른 열 이름, 형식, 테이블 이름 등을 갖고 있어야 했기 때문에 데이터를 잘못된 위치에 저장하지 않고도 \"즉석에서\" 조합할 수 있었습니다. (BI 목적의 중복 대시보드에 대해 언급할 때는 하지 마세요.) 이를 권장하지 않습니다!\n\n이러한 규정은 다양한 분야의 데이터 과학자들에게 실질적인 도전을 제공하며, 법적 의무를 준수하고 작업과 회사를 책임질 수 있도록 하는 것이 중요합니다. 지역화 도전에 직면한 적이 있나요? 이 문제에 대한 제가 언급하지 않은 해결책을 발견했다면 이 기사에 댓글을 남겨주세요.\n\n# 추가 읽을거리\n\nhttps://www.techpolicy.press/the-human-rights-costs-of-data-localization-around-the-world/\n\n<div class=\"content-ad\"></div>\n\n아래는 친숙하게 번역한 내용입니다.\n\n1. [인도의 새로운 데이터 보호법 이해 - Carnegie Endowment for International Peace](https://carnegieendowment.org/research/2023/10/understanding-indias-new-data-protection-law?lang=en)\n\n2. [인도에서의 데이터 로컬라이제이션에 관한 모든 것 - IR Global](https://irglobal.com/article/all-about-data-localisation-in-india-2/#:~:text=The%20RBI%20ordered%20all%20payment,to%20abide%20by%20this%20instruction.)\n\n3. [RBI(인도 중앙 은행) FAQ](https://m.rbi.org.in/Scripts/FAQView.aspx?Id=130)","ogImage":{"url":"/assets/img/2024-06-19-DataPrivacyinAIDevelopmentDataLocalization_0.png"},"coverImage":"/assets/img/2024-06-19-DataPrivacyinAIDevelopmentDataLocalization_0.png","tag":["Tech"],"readingTime":10}],"page":"74","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}