{"pageProps":{"posts":[{"title":"지피에 초보이신가요 이제 첫 네트워크를 만들어 보세요","description":"","date":"2024-06-20 15:06","slug":"2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow","content":"\n\n2024년 6월 19일, 브로니카 에스피노자 박사\n\n▪트위터 (X) @Verukita1 ▪링크드인: Dra. Verónica Espinoza ▪웹사이트: www.nethabitus.org\n\n![이미지](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_0.png)\n\n# 소개\n\n<div class=\"content-ad\"></div>\n\n# Gephi란?\n\nGephi는 그래프를 탐색하고 이해하려는 데이터 분석가와 과학자들을 위한 도구입니다. Photoshop™가 그래프 데이터용으로 있는 것처럼, 사용자는 표현과 구조, 모양, 색상을 조작하여 숨겨진 패턴을 찾아냅니다 [1].\n\n이 도구의 목표는 데이터 분석가들이 가설을 세우고 직관적으로 패턴을 발견하거나 데이터 소싱 과정에서 구조의 특이성이나 결함을 격리하는 데 도움을 주는 것입니다. 시각화된 인터페이스와 상호작용을 통한 시각적 사고는 이제 추론을 용이하게 하는 것으로 인정받고 있어, 전통적인 통계의 보완 도구입니다. 이는 시각 분석 분야의 탐구에서 나온 탐색적 데이터 분석 소프트웨어입니다 [1, 2].\n\n# Gephi 인터페이스\n\n<div class=\"content-ad\"></div>\n\nGephi의 주요 섹션입니다.\n\n![image1](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_1.png)\n![image2](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_2.png)\n\n😉 Gephi에 대해 더 알고 싶다면, 이 이야기를 읽어보세요: Gephi란 무엇인가요? 유용한 네트워크 분석 도구를 만나보세요.\n\n<div class=\"content-ad\"></div>\n\n🌐 Gephi를 여기서 다운로드하세요: [https://gephi.org/](https://gephi.org/)\n\n# 이 이야기에서는 무엇을 검토할까요?\n\n본 튜토리얼에서는 5단계로 Gephi 네트워크를 시각화하는 방법을 배우게 될 것입니다. 이 연습에서는 Spotify API를 사용하여 Python 코드로 이전에 생성한 GEXF 파일을 사용할 것입니다. 이 파일은 Spotify에서 관련 아티스트의 네트워크를 나타냅니다.\n\n저도 이 튜토리얼에서 사용할 동일한 GEXF 파일을 공유하므로 여러분도 연습을 따라 할 수 있습니다!\n\n<div class=\"content-ad\"></div>\n\n👉 이 연습을 위한 GEXF 파일을 다운로드하세요.\n\n![이미지](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_3.png)\n\n# 이 튜토리얼에서 다룰 5단계의 시각적 요약.\n\n# 🏁 시작해 봅시다!\n\n<div class=\"content-ad\"></div>\n\n# 단계 1. 통계 적용: 모듈러리티 실행\n\n당신의 Gephi 도구 / 개요 탭에서:\n\n- 저와 공유한 GEXF 파일을 엽니다. 파일 ➡ 파일 열기.\n- 통계 섹션에서: 모듈러리티 적용 ➡ 확인.\n\n여기에서 모듈러리티 알고리즘에 대해 알아보세요: [링크1](링크 주소) 및 [링크2](링크 주소)\n\n<div class=\"content-ad\"></div>\n\n🎦 아래는 이 단계의 데모입니다. 파일을 열어보세요 — 통계 적용: 모듈성 실행.\n\n![미리보기](https://miro.medium.com/v2/resize:fit:1400/1*NUdHo3fKobSTJ52OYFoSFg.gif) \n\n# 단계 2. 외형 조정.\n\n개요 탭 / 외형 섹션:\n\n<div class=\"content-ad\"></div>\n\n- 모듈러리티에 따라 노드 색상 지정하기 (경로: 색상 아이콘 ➡ 노드 ➡ 파티션 ➡ 모듈러리티 클래스 선택 ➡ 적용 ▶)\n\n![이미지](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_4.png)\n\n- 팔로워 수에 따라 노드 크기 순위 매기기 (경로: 크기 아이콘 ➡ 노드 ➡ 랭킹 ➡ 팔로워 선택 ➡ 최소 크기: 2, 최대 크기: 14 조정 ➡ 적용 ▶)\n\n![이미지](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_5.png)\n\n<div class=\"content-ad\"></div>\n\n- 팔로워별로 글꼴 크기를 조정하세요. (경로: 레이블 크기 아이콘 ➡ 노드 ➡ 랭킹 ➡ 팔로워 선택 ➡ 최소 크기: 0.3, 최대 크기: 0.5 조정 ➡ 적용 ▶)\n\n![이미지](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_6.png)\n\n🎦 아래에서는 이 단계의 시연이 제공됩니다 — 외관 조정.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*-QRqxxCeH3YMy0UPxfbltw.gif)\n\n<div class=\"content-ad\"></div>\n\n# 단계 3. 레이아웃 적용\n\n개요 탭 / 레이아웃 섹션:\n\n- ForceAtlas 2 적용\n- Prevent Overlap 선택\n- ▶실행 ➡◼정지\n\n이 논문에서 ForceAtlas 2 레이아웃 알고리즘에 대해 알아보기\n\n<div class=\"content-ad\"></div>\n\n아래에서는 이 단계인 \"레이아웃 적용\"의 데모가 제공됩니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*6EgxWEHzuIOfBYMfAGVOrQ.gif)\n\n# 단계 4. 미리보기 설정 조정하기.\n\n미리보기 탭 / 미리보기 설정 섹션:\n\n<div class=\"content-ad\"></div>\n\n- 프리셋 — 기본값 선택.\n\n![이미지](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_7.png)\n\n- 설정 탭➡노드 레이블 ➡ 레이블 표시 선택 ➡ 새로 고침\n\n![이미지](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_8.png)\n\n<div class=\"content-ad\"></div>\n\n- 렌더러 탭 관리하기 ➡ \"기본 노드 라벨\"을 가장 먼저 위치로 이동 ⬆ ➡ 새로 고침.\n\n![이미지](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_9.png)\n\n- 설정 탭 ➡ 엣지 ➡ 가중치 재조정 선택 ➡ 두께 조절 (0.5) ➡ 새로고침.\n\n![이미지](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_10.png)\n\n<div class=\"content-ad\"></div>\n\n🎦 이 단계를 보여주는 동영상입니다 - 미리보기 설정 조정.\n\n![동영상](https://miro.medium.com/v2/resize:fit:1400/1*i70FOt41lKGSLGLUHxw2FQ.gif)\n\n# 단계 5. 네트워크 저장하기.\n\n미리보기 탭\n\n<div class=\"content-ad\"></div>\n\n- **Export를 클릭하세요 (SVG / PDF / PNG).**\n\n![이미지](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_11.png)\n\n- 네트워크 이름을 지정하세요 ➡ 옵션 클릭 ➡ 이미지의 폭과 높이 조정 ➡ 확인\n\n![이미지](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_12.png)\n\n<div class=\"content-ad\"></div>\n\n🎦 아래는 이번 단계의 데모입니다 - 귀하의 네트워크를 저장하세요.\n\n![Demo](https://miro.medium.com/v2/resize:fit:1400/1*rBJ8w588EVdHLNcr5t6Oow.gif)\n\n😉 첫 번째 네트워크가 이제 준비되었습니다!\n\n![Network](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_13.png)\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 튜토리얼에서는 Gephi에서 첫 번째 네트워크를 만드는 방법을 살펴보았습니다. 여기에 표시된 단계는 Gephi가 제공하는 기능에 익숙해지기 위한 예제였습니다.\n\n위에서 언급했듯이, 귀하의 네트워크 파일에 따라이 튜토리얼에서 검토했던 매개변수를 다시 조정해야 할 수도 있습니다. 예를 들어 파일에 있는 다른 속성으로 노드에 색상을 입히는 것을 시도해보세요. 또한 파일에 따라 최소 및 최대 숫자 값을 조정하여 다른 속성에 따라 노드 크기와 레이블을 순위 지정할 수도 있습니다.\n\n귀하의 파일을 업로드하고 검토했던 다양한 매개변수를 조정해보며 실험해 보기를 장려합니다. 또한 다른 레이아웃으로 전환하여 네트워크가 어떻게 보이는지 확인할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n또한 미리보기 탭에서 파일을 보기에 적합하다고 생각되는 모든 조정 사항을 시도해보세요.\n\n특정한 화면 조정에 따라 매개변수 설정이 달라질 수 있으니 유념해주세요.\n\n당신의 프로젝트에 이 멋진 도구를 활용하기 시작하는 데 도움이 되었기를 바랍니다.\n\n😉이 이야기를 읽어 주셔서 감사합니다.\n\n<div class=\"content-ad\"></div>\n\n👉 내가 쓴 더 많은 이야기를 찾아보세요\n\n✔ 트위터에서 나를 팔로우해요 (X) @Verukita1\n\n✔ LinkedIn: Dra. Verónica Espinoza\n\n✔ 웹사이트: www.nethabitus.org\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_14.png)\n\n# Resources\n\n🌐 Gephi website.\n\n💠 Do you want to continue learning more about Gephi? Check out all the stories I’ve written about Gephi here.\n\n\n<div class=\"content-ad\"></div>\n\n📕 이야기에서 네트워크 과학에 관한 무료 자료를 찾아보세요: Network Science: Open access resources (books, chapters, articles, tools & more)\n\n📄 다음 논문을 읽어보세요: Fast unfolding of communities in large networks \n\n✅ 깃허브: Modularity Github-Gephi \n\n🗄️ 데이터셋 찾기: Gephi 샘플 데이터셋을 다양한 형식(GEXF, GDF, GML, NET, GraphML, DL, DOT)으로 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n👨‍💻 Gephi 커뮤니티를 팔로우하세요! Gephi FB 그룹, 트위터, Reddit 등 다양한 소셜 네트워크에서 만나보세요.\n\n![image](/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_15.png)\n\n참고 자료\n\n[1] Bastian M., Heymann S., Jacomy M. (2009). Gephi: exploring and manipulating networks을 위한 오픈 소스 소프트웨어. 웹로그 및 소셜 미디어 국제 AAAI 컨퍼런스\n\n<div class=\"content-ad\"></div>\n\n[2] Gephi - 오픈 그래프 시각화 플랫폼 [인터넷]. [2024년 6월 15일에 확인]. 이용 가능한 링크: https://gephi.org/","ogImage":{"url":"/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_0.png"},"coverImage":"/assets/img/2024-06-20-AreyouabeginnerinGephiMakeyourfirstnetworknow_0.png","tag":["Tech"],"readingTime":6},{"title":"포켓몬 세계 매핑 서식지 기반 만남의 네트워크 분석","description":"","date":"2024-06-20 15:01","slug":"2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters","content":"\n\n\n![Network Analysis](/assets/img/2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters_0.png)\n\n# 소개\n\n네트워크 분석은 다양한 개체의 관계, 연결 및 그룹화를 의미 있게 이해하기 위한 견고하면서도 직관적인 접근법입니다. 소셜 미디어 관점에서는 네트워크 분석을 사용하여 가장 의미 있는 연결을 가진 프로필을 이해할 수 있고, 전자 상거래 회사는 제품 간의 탐색 관계를 이해하기 위해 웹 분석을 활용할 수 있으며, 기업은 이메일 교신을 분석하여 어떤 팀이 자주 협업하는지 이해할 수 있습니다. 여러분이 작업 중인 데이터가 어떤 네트워크에 닮아 있다면, 네트워크 분석을 확실히 적용할 수 있습니다.\n\n이 글에서는 Python을 통한 네트워크 분석, 네트워크 분석에서 얻을 수 있는 실용적인 통찰력, 그리고 인기 TV 및 게임 시리즈인 포켓몬과 함께 하는 재미있는 프로젝트에 대해 소개하겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 네트워크 분석이란\n\n![이미지](/assets/img/2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters_1.png)\n\n이 주제에는 여러 정의가 있지만, 헬스 심리학 및 행동 의학 저널에는 이 주제에 대한 관점을 요약하는 정의가 포함된 기사가 있습니다. 이 기사에서 언급된 대로, 네트워크 분석(NA)을 수행하는 방법을 이해하게 해주는 수학적으로 강화된 시각화 접근 방법입니다.\n\n다시 말해, NA는 데이터 세트 내 관측 사이의 복잡한 관계를 이해할 수 있게 해주는 수학적으로 강화된 시각화 접근 방법입니다. 시각화 자체는 서로 연결된 노드 집합입니다. 노드는 사람, 장소, 동물, 제품 등을 나타낼 수 있습니다. 이들을 연결하는 선은 두 노드 사이의 관계를 나타냅니다. 이는 모서리로 알려져 있습니다. 시각화에 추가로, 우리는 어떤 노드가 가장 중심화되어 있는지, 어떤 모서리가 노드 사이에 가장 많은 연결을 만들며, 주요 네트워크 내에서 서브네트워크(또는 커뮤니티)를 격리하는 데에 어떤 알고리즘 및 메트릭을 사용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 파이썬 시작하기\n\n먼저, Networkx 라이브러리를 가져와서 Networkx 그래프 객체를 생성하고 가상 데이터로 네트워크 그래프를 만들 것입니다. 만약 따라오시면서 아직 설치하지 않은 라이브러리가 있다면 본 글에서 언급된 라이브러리들을 설치해 주세요. 아래 이미지를 살펴보세요:\n\n```python\nimport networkx as nx\n\nG = nx.Graph()\nG.add_edges_from([('A', 'B'), ('A', 'C'),('A','D'),('C','E'),\n                  ('C','F'),('B','H'),('H','I'),('D','J'),\n                  ('A','K'),('D','K'),('B','I'),('J','A'),\n                  ('F','E'),('G','C'),('G','E')])\n\nnx.draw(G, with_labels=True,node_color='lightblue', font_color='black', font_weight='bold')\n```\n\n![그림](/assets/img/2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters_2.png)\n\n<div class=\"content-ad\"></div>\n\n이 그래프에서 무엇을 알 수 있나요? 기본적인 부분부터 시작해 봅시다. 파란 원 내부에 있는 글자는 데이터에서 노드를 나타냅니다. 상호 연결된 선들은 간선입니다. 더 실용적인 측면에서, 이 데이터가 소셜 미디어 사이트를 나타낸다고 가정해 봅시다. 노드는 개별 프로필을 나타낼 수 있고, 간선은 소셜 미디어에서 서로 친구인 두 프로필을 연결하는 것을 나타낼 수 있습니다.\n\n기본 개념을 숙지했으니, 더 나아가 봅시다. 어떤 노드나 간선이 가장 중요한지 어떻게 알 수 있을까요? 노드나 간선의 중요성을 어떻게 양적으로 표현할 수 있을까요? 이 그래프를 보면, 서브네트워크나 커뮤니티를 뚜렷하게 확인할 수 있을까요? 이러한 개념들을 아래에서 자세히 살펴봅시다.\n\n## 근접 중심성 (Closeness Centrality)\n\n노드의 중요성을 어떻게 결정할 수 있을까요? 한 가지 방법은 근접 중심성이라는 측정치를 사용하는 것입니다. NetworkX 문서에 따르면, 노드(u)의 근접 중심성은 다음과 같이 정의됩니다:\n\n<div class=\"content-ad\"></div>\n\n![포켓몬 월드에 대한 매핑 및 네트워크 분석 결과](/assets/img/2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters_3.png)\n\n간단히 말해, 가장 높은 근접 중심성 점수를 가진 노드는 해당 노드에서 다른 노드까지 이동할 때 평균적으로 가장 많이 통과하는 노드입니다.\n\n소셜 미디어 관점에서 생각해보죠. 가령, 여러분이 팔로워 수를 최대한 확보하려고 노력하는 인플루언서라고 상상해 봅시다. 최대한 많은 연결을 만들고 싶을 것이며, 그 방법 중 하나는 특정 프로필 그룹 내에서 중심성이 높은 다른 사람들과 연결을 만드는 것일 수도 있습니다. 이 중심적인 연결을 목표로 삼는다면 프로필 가시성이 극대화되어 더 많은 프로필에게 친구나 연결로 추천될 가능성이 높아집니다.\n\n앞서 소개한 모의 네트워크를 다시 살펴보면, 가장 높은 근접 중심성 점수를 가진 노드는 무엇인가요? 제 의견으로는 노드 A가 모든 다른 노드들의 가운데에 위치하고 있는 것으로 보여 가장 높은 근접 중심성 점수를 가지고 있다고 주장합니다. 파이썬의 closeness_centrality 메서드를 사용하여 아래의 점수를 확인해 보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nnx.closeness_centrality(G)\n```\n\n![image](/assets/img/2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters_4.png)\n\n## 엣지 중심성\n\n노드 사이의 일부 연결 또는 엣지가 다른 것들보다 중요한가요? 우리 그래프를 다시 살펴보면 어떤 엣지가 두드러지나요? A ~ B 및 A ~ C의 엣지는 특정 노드 클러스터를 연결하기 때문에 두드러집니다. 중요성을 정량화하는 원래의 점으로 돌아오면, NetworkX에서 정의한 엣지 중심성이라는 측정을 통해 이를 수행할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters_5.png)\n\n좀 더 실용적으로 말하자면, 엣지 중심성(edge betweenness centrality)이 높을수록 해당 엣지가 모든 노드 사이의 최단 경로를 볼 때 자주 지나간다는 뜻입니다. 이들은 우리 네트워크를 유지하는 주요 다리 역할을 합니다.\n\n엣지 중심성이 어떻게 유용하게 활용될 수 있는지 실제 예시를 살펴보겠습니다. 다양한 엔티티 간 거래 데이터를 살펴보고 있다고 가정해봅시다. 이 데이터를 가져와 엔티티를 나타내는 네트워크를 만들어 보면, 엣지는 서로 정기적으로 거래하는 엔티티들을 나타냅니다. 엣지 중심성이 가장 높은 엣지를 살펴보면, 본질적으로 이 준 금융 시스템을 연결하는 주요 연결점을 찾을 수 있습니다. 어떤 엔티티나 기관이 가장 많은 영향력을 가지는지 이해할 수 있으며, 그들을 제거하면 자금 흐름이 방해될 수 있습니다.\n\n엣지 중심성을 어떻게 계산할까요? 원래의 예시로 돌아가서, NetworkX의 edge_betweenness_centrality 메서드를 사용할 수 있습니다. A~B 및 A~C 엣지에 대해 제 예측이 맞았는지 확인해보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\nnx.edge_betweenness_centrality(G)\n```\n\n![Image](/assets/img/2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters_6.png)\n\n## 커뮤니티\n\n우리의 그래프는 아주 쉽게 읽을 수 있고 상대적으로 작지만, 실제 데이터는 매우 견고하고 큽니다(보통 빅데이터라고 합니다). 이로 인해 네트워크 그래프가 매우 크고 읽기 어려울 수 있습니다. 그러므로 네트워크 내의 네트워크나 커뮤니티를 살펴보는 것이 도움이 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n저희 그래프를 보면 노드 군집이 어떻게 커뮤니티를 나타내는지 비교적 간단하게 볼 수 있을 거에요. 예를 들어 노드 H, I 및 B가 한 커뮤니티를 나타내는 것을 쉽게 알 수 있습니다. 그러나 실제 데이터를 적절하게 확장하기 위해서는 알고리즘적으로 해야 해요. 그래서, 이번에는 기르반-뉴먼 알고리즘을 통해 독자를 안내할 거에요.\n\nNetworkX 문서에는 이 알고리즘이 어떻게 작동하는지에 대한 매우 실용적인 정의가 나와 있어요.\n\n앞서 말한 대로, 이 알고리즘은 반복적으로 작동합니다. 따라서 우리가 이를 구현할 때는 최고 엣지 중심성을 가진 엣지를 하나씩 제거하면서 의미 있는 커뮤니티 그래프가 남을 때까지 진행할 거에요. 이 알고리즘을 효과적으로 사용하는 핵심은 의미 없는 커뮤니티를 너무 적게 만들지 않으면서, 반대로 우리의 데이터에 더 많은 잡음을 만드는 커뮤니티르 너무 많이 만들지 않는 것이에요.\n\n다시 한번, 이를 Python으로 구현해 봅시다. 이에는 몇 가지 단계가 더 필요하지만, 하나씩 나눠서 설명할 거에요. 먼저, Pyvis와 Matplotlib을 가져올 거에요. Pyvis 라이브러리는 NetworkX로 생성된 네트워크 그래프 객체와 함께 작동하여 더 멋진 네트워크 그래프를 만들 수 있게 해줍니다. Matplotlib은 커뮤니티용 컬러 맵을 생성하는 데 사용됩니다. 이 라이브러리들로 우리는 그래프의 모든 노드를 반복하면서 식별된 커뮤니티별로 색칠할 겁니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 데이터 내에서 커뮤니티를 찾기 위해 NetworkX의 girvan_newman() 함수를 사용할 것입니다. 여기서 이해해야 할 주요 기능은 이 함수가 반복자를 반환한다는 것입니다. 따라서 Python의 next() 함수를 사용하여 알고리즘으로 식별된 커뮤니티를 반복 처리할 것입니다. 우리의 네트워크 그래프를 다시 살펴보면, 개인적으로는 세 개의 명확한 커뮤니티를 보입니다. 따라서 세 번 반복할 것입니다. 실제 데이터를 다룰 때에는 여러 번의 시행착오가 필요할 수 있음을 유의해주세요.\n\n마지막으로, 앞서 설명한 내용을 바탕으로 그래프에서 여러 요소를 변경할 수 있는 위젯이 포함된 HTML 파일이 최종 결과물임을 유의해주세요. 함께 따라오시는 경우, 이를 즐기는 데 즐겁게 활용해보세요!\n\n<div class=\"content-ad\"></div>\n\n위의 커뮤니티가 이해됩니까? 그렇다고 생각해요! A~B와 A~C 엣지가 커뮤니티를 서로 연결하는 키포인트 엣지라는 것을 유의해보세요. 다시 한 번 Girvan-Newman 알고리즘을 사용하여 네트워크를 추가하거나 제거할 때 어떤 일이 발생하는지 살펴보세요.\n\n# 포켓몬 네트워크\n\n포켓몬 프로젝트를 시작할 시간입니다! 이 프로젝트에서는 포켓몬 게임 시리즈의 데이터를 살펴보겠습니다. 만약 포켓몬이 무엇인지, 특히 게임 시리즈가 무엇인지 익숙하지 않다면 걱정하지 마세요. 여기서 간단히 설명하겠습니다. 포켓몬 세계는 포켓몬이라고 불리는 생물과 사람들로 이루어져 있습니다. 일부 사람들은 트레이너라고 불리며 다른 트레이너와 함께 포켓몬을 잡고 키우고 싸웁니다. 게임 시리즈의 큰 부분이죠. 게임에서 포켓몬은 물, 풀, 숲, 동굴 등과 같은 여러 서식지에서 발견됩니다. 이 프로젝트에서는 게임 내에서 어느 서식지에서 발견될 수 있는지에 기반한 포켓몬의 네트워크 분석을 수행할 것입니다.\n\n## 데이터\n\n<div class=\"content-ad\"></div>\n\n데이터에는 포켓몬 게임과 관련된 거의 모든 데이터 포인트가 포함된 포켓몬API를 사용할 것입니다. 이 프로젝트에서는 주로 몇몇 포켓몬이 게임에서 어디에서 발견될 수 있는지 제공하는 충돌 엔드포인트에 관심을 가질 것입니다. 이 정보를 사용하여 여러 포켓몬 간의 연결을 합치고 만들어 네트워크를 생성할 수 있습니다!\n\n현재 수천 가지의 포켓몬을 선택할 수 있지만, 각 게임은 일반적으로 하나의 세대에서만 포켓몬을 포함하고 이전 세대에서 몇몇을 선택합니다. 이것은 이전 세대의 포켓몬이 이어지는 게임에 계속 등장할 수 있기 때문에 우리의 네트워크를 초기 세대의 포켓몬 쪽으로 편향시킬 수 있습니다. 게임 중 하나인 그리고 내 어릴 적 즐겨했던 포켓몬 크리스탈 버전의 데이터를 살펴봅시다. 이 게임은 1세대와 2세대의 포켓몬을 가지고 있으므로 이 세대의 포켓몬 이름을 가져오도록 하는 함수를 편리하게 사용할 수 있도록 만들었습니다. 다음으로 1세대와 2세대의 모든 포켓몬 이름을 반복하고 등록지역 엔드포인트에서 여러 세부 정보를 추출하여 마스터 데이터 프레임을 만들 것입니다. 해당 데이터 프레임의 세부 정보를 포켓몬 크리스탈 버전을 위해 격리할 것입니다. 마지막으로, 각 행에 게임에서 적어도 하나의 공통 서식지에서 발견된 두 포켓몬을 가진 num_of_habitats 열이 있는 데이터 프레임을 만들기 위해 자체 조인을 수행할 것입니다. 최종 출력 형식은 Network Analysis 객체를 구축할 때 매우 중요합니다. 이 흐름을 편리성을 위해 아래의 세 가지 함수로 집합화했습니다!\n\n```js\nimport requests\nimport pandas as pd\n\ndef get_pokemon_by_gen(gen):\n  try:\n    url = f'https://pokeapi.co/api/v2/generation/{gen}/'\n    response = requests.get(url)\n    data = response.json()\n    pokemon_list = [pokemon['name'] for pokemon in data['pokemon_species']]\n  except:\n    print(f'세대 {gen}는 존재하지 않습니다.')\n  return pokemon_list\n\ndef import_pokemon_multi_gen(gen_list):\n  pokemon_list_for_df = []\n  location_area_list = []\n  version_details_list = []\n\n  poke_lists = []\n  for gen in gen_list:\n    pokemon_list = get_pokemon_by_gen(gen=gen)\n    poke_lists.extend(pokemon_list)\n\n  for pokemon in poke_lists:\n    encounter_url = f'https://pokeapi.co/api/v2/pokemon/{pokemon.lower()}/encounters'\n    response = requests.get(encounter_url)\n    encounter_data = response.json()\n    for encounter in range(len(encounter_data)):\n      location = encounter_data[encounter]\n      location_name = location['location_area']['name']\n      version_details = location['version_details']\n      for version in range(len(version_details)):\n        version_name = version_details[version]['version']['name']\n        pokemon_list_for_df.append(pokemon)\n        location_area_list.append(location_name)\n        version_details_list.append(version_name)\n\n  master_pokemon_df = pd.DataFrame({'Pokemon': pokemon_list_for_df,\n                                    'Location_Area': location_area_list,\n                                    'Location_Version': version_details_list})\n  return master_pokemon_df\n\ndef create_pokemon_edgelist_df(pokemon_df):\n  # Self-join을 사용하여 포켓몬 쌍을 생성하고 공통 서식지를 계산합니다\n  common_habitats_edges = (\n      pokemon_df.merge(pokemon_df_crystal, on='Location_Area', suffixes=('_1', '_2'))  # Location_Area로 Self-join을 수행합니다\n      .query('Pokemon_1 != Pokemon_2')  # 동일한 포켓몬 쌍을 제외합니다\n      .groupby(['Pokemon_1', 'Pokemon_2']).size().reset_index(name='num_of_habitats')  # 각 쌍의 고유 서식지를 계산합니다\n  )\n\n  # 열 이름 변경\n  common_habitats_edges.columns = ['pokemon_1', 'pokemon_2', 'num_of_habitats']\n\n  # 중복 제거\n  common_habitats_edges['pair'] = common_habitats_edges.apply(lambda row: tuple(sorted([row['pokemon_1'], row['pokemon_2']])), axis=1)\n  common_habitats_edges = common_habitats_edges.drop_duplicates(subset='pair').drop(columns='pair')\n  common_habitats_edges = common_habitats_edges.reset_index(drop=True)\n\n  return common_habitats_edges\n```\n\n```js\nmaster_pokemon_df = import_pokemon_multi_gen(gen_list=[1, 2])\npokemon_df_crystal = master_pokemon_df[master_pokemon_df['Location_Version'] == 'crystal']\npokemon_edgelist = create_pokemon_edgelist_df(pokemon_df=pokemon_df_crystal)\npokemon_edgelist.head()\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Network Mapping](/assets/img/2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters_8.png)\n\n## 네트워크 구축\n\n이미 Python에서 네트워크 그래프를 빌드하고 다양한 측정을 수행하는 방법을 검토했습니다. 이제 위의 데이터프레임과 같은 데이터를 입력으로 받아 네트워크 분석을 end-to-end로 수행하는 단일 객체를 만들겠습니다.\n\n이 네트워크 분석 객체에는 다음을 수행하는 메서드가 포함될 것입니다:\n\n\n<div class=\"content-ad\"></div>\n\n- NetworkX Graph 객체를 생성합니다.\n- 우리가 논의한 중심성 점수의 정렬된 데이터프레임을 반환합니다.\n- 주어진 개수의 Girvan-Newman 커뮤니티로 Pyvis 네트워크 그래프를 구축합니다.\n- 노드 크기를 노드가 가지는 연결 수에 따라 조정하는 로직을 포함합니다.\n\n이 섹션에서는 독자가 객체 지향 프로그래밍(OOP)에 대한 초급 수준의 이해를 가지고 있다고 가정합니다. OOP에 익숙하지 않다면 걱정하지 마세요. 각 객체를 개별적으로 다룰 것이며, 코드를 따라하면서 OOP를 학습했다는 것을 깨달을 것이라고 생각합니다!\n\n## 초기화 함수\n\n모든 객체와 마찬가지로, 새 객체를 생성할 때 호출되는 초기화 함수로 시작합니다. 여기서 우리는 초기 속성을 설정하는 곳인데, 특히 edgelist_df라고 부르는 초기 속성을 설정할 것입니다. 이전에 common_habitats_edges라는 데이터프레임을 만들었습니다. 이 데이터프레임은 사실 Pandas edge list 형식이라고 부르는 형식입니다. 우리는 이 형식의 데이터프레임을 사용하여 from_pandas_edgelist 메서드를 통해 NetworkX Graph 객체를 생성할 수 있습니다. 이 객체가 만들 수 있는 Network Graph를 위해 남은 속성은 예약되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nclass NetworkGraph():\n  def __init__(self, edgelist_df, width, height, bgcolor, font_color):\n\n    self.edgelist_df = edgelist_df\n    self.width = width\n    self.height = height\n    self.bgcolor = bgcolor\n    self.font_color = font_color\n    self.G = None\n\n    ## 중심성 데이터프레임\n    self.betweenness_df = None\n    self.closeness_df = None\n\n    ## 커뮤니티\n    self.community_map = None\n```\n\n## create_network_graph_object 메서드\n\n이 메서드는 edgelist_df 속성을 사용하여 NetworkX 그래프 객체를 생성합니다. 또한 우리가 이전에 논의한 에지 매개 중심성 및 근접 중심성 점수를 DataFrame 형식으로 가져옵니다. 노드 및 엣지에 대한 이러한 점수를 빠르게 확인할 수 있게 됩니다. 아직 검토하지 않은 내용이 있을 수 있습니다: 노드 차수입니다. 노드 차수는 노드가 다른 노드에 연결된 모든 연결을 나타냅니다. 이 차수 점수를 사용하여 노드의 크기를 조절할 것입니다. 다시 말해, 더 많은 연결을 가진 노드는 최종 네트워크 그래프에서 더 크게 표시됩니다.\n\n```js\n def community_graph_html(self, num_communities, html_filename):\n    if self.G == None:\n      raise ValueError(\"네트워크 그래프 객체가 아직 생성되지 않았습니다.\")\n    else:\n\n      # 지정된 레벨의 커뮤니티 가져오기\n      communities = get_communities_at_level(G=self.G, level=num_communities)\n\n      # 노드에 커뮤니티 ID 할당\n      community_map = {}\n      for community_id, community in enumerate(communities):\n          for node in community:\n              community_map[node] = community_id\n      self.community_map = community_map\n\n      # PyVis 네트워크 생성\n      net = Network(notebook=True)\n      net.from_nx(self.G)\n\n      # matplotlib에서 컬러맵 가져오기\n      cmap = plt.get_cmap('tab20')\n      norm = mcolors.Normalize(vmin=0, vmax=len(communities)-1)\n\n      # 노드 속성 사용자 정의\n      for node in net.nodes:\n          node_id = node['id']\n          community_id = community_map[node_id]\n          color = mcolors.rgb2hex(cmap(norm(community_id)))  # 컬러맵 값을 16진수 색상으로 변환\n          node['color'] = color\n          node['size'] = self.G.degree[node_id]  # 가시성을 높이기 위한 크기 조정\n\n      net.show_buttons(filter_=['nodes', 'edges', 'physics'])\n\n      # 네트워크 그래프 생성 및 표시\n      net.show(html_filename)\n```\n\n\n<div class=\"content-ad\"></div>\n\n## community_graph_html 메서드\n\n마지막으로, community_graph_html 메서드가 있습니다. 네트워크 그래프를 생성하는 것 외에, 이 메서드는 Girvan-Newman 알고리즘에 의해 식별된 커뮤니티에 따라 노드를 색상으로 코딩할 것입니다. 언급했듯이, 이 알고리즘은 반복적이기 때문에 얼마나 많은 커뮤니티가 합리적인지를 시행착오를 통해 결정해야 합니다. 이 단계에서는 community_map 속성을 채우기도 합니다. 이는 네트워크 내의 모든 포켓몬과 해당 커뮤니티를 나타내는 사전입니다.\n\n## 모두 함께 살펴보기\n\n우리의 데이터가 가져오되고, 네트워크 객체가 생성되었습니다. 가장 밀접도 및 가장 많은 매개 중심성 점수를 가진 노드 (포켓몬) 및 엣지 (포켓몬 간 연결)를 검토하여 네트워크 분석을 시작해보죠.\n\n<div class=\"content-ad\"></div>\n\n```js\npokemon_na = NetworkAnalysis(edgelist_df=pokemon_edgelist, width=\"100%\", height=\"1200px\", bgcolor='white', font_color='black')\npokemon_na.create_network_graph_object()\n```\n\n## 중심성\n\n```js\npokemon_na.closeness_df.sort_values(by='centrality', ascending=False).head()\n```\n\n![이미지](/assets/img/2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters_9.png)\n\n\n<div class=\"content-ad\"></div>\n\n매직카프는 저희의 가장 중심적인 노드입니다. 여기서 중심적인 것은 게임에서 다른 포켓몬과 거의 모든 서식지에 높은 경향성이 있다는 것을 의미합니다. 우리 목록에서 다음 네 마리 포켓몬에 대해서도 동일한 이야기를 할 수 있습니다.  \n크리스탈 버전 포켓몬을 수없이 플레이한 사람들에게는 이것이 놀라운 점은 아닐 것입니다. 매직카프는 게임의 거의 모든 물 서식지에서 발견할 수 있습니다. 또한 랏타와 같은 포켓몬은 거의 모든 풀과 같은 서식지에서 발견됩니다.  \n놀랍게도, 이 두 포켓몬은 중심성 점수 목록 상단에 위치하고 있습니다.\n\n## 엣지 중심성\n\n```js\npokemon_na.betweenness_df.sort_values(by='centrality', ascending=False).head()\n```\n\n![Image](/assets/img/2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters_10.png)\n\n<div class=\"content-ad\"></div>\n\n가장 높은 엣지 중심성 점수는 예외적으로 낮습니다. 이것은 즉시 이 네트워크가 매우 상호 연결되어 있으며 한 커뮤니티를 다른 커뮤니티로 연결하는 단일 엣지가 없다는 것을 알려줍니다. 이것은 데이터 내에서 커뮤니티를 찾을 때 문제가 될 수 있습니다. 그 통찰을 얻었지만, 이제 상위 점수를 살펴 보겠습니다. 다시 한번, 여기서 제 개인적인 도메인 지식이 도움이 될 수 있습니다. 포켓몬 스윈럽, 스니저, 루주라, 델리버드는 포켓몬 크리스탈 게임 버전의 특정 동굴에서만 발견됩니다. 또한, 골뱃은 이 동굴과 게임의 여러 다른 서식지에서 발견됩니다. 따라서 이 골뱃 엣지들은 다른 네 개의 포켓몬을 네트워크의 나머지 부분에 연결하는 중요한 다리 역할을 합니다.\n\n## 네트워크 시각화 및 커뮤니티 찾기\n\n우리는 마침내 기다려온 순간에 도달했습니다. 이제 포켓몬 네트워크 그래프를 시각화할 시간입니다. 앞서 생성한 create_network_graph_object를 사용할 것이지만, 특정 수의 커뮤니티를 지정해야 합니다. 엣지 중심성 결과를 기반으로, 많은 구분된 커뮤니티를 볼 수 없을 수 있습니다. 따라서 Girvan-Newman 알고리즘을 사용하여 데이터를 두 개의 커뮤니티로 분할할 것입니다. num_communities 매개변수를 1로 설정하여 이를 수행합니다. 따라서 여는 중인 경우, 그래프 이미지 아래에 여러 위젯이 있습니다. 그래프의 미적 요소를 최적화하기 위해 옵션들을 살펴보는 것을 잊지 마세요!\n\n```js\npokemon_na.community_graph_html(num_communities=1,html_filename='Pokemon_comm_graph.html')\n```\n\n<div class=\"content-ad\"></div>\n\n<!DOCTYPE html>\n<html>\n<body>\n\n<h1>Welcome to our website!</h1>\n<p>This is a paragraph.</p>\n\n</body>\n</html>\n\n<div class=\"content-ad\"></div>\n\n일부 시행착오 끝에, 일반 서식지 상위 90% 이상의 가장자리를 필터링했습니다. 이것은 그래프가 훨씬 더 가독성있다면 좋은 지점입니다. 게다가, 그래프가 여전히 추가적인 구분된 커뮤니티를 보여주지 않기 때문에 데이터가 어떻게 작용하는지 알아보기 위해 한 개의 더 커뮤니티를 추가했습니다. 데이터가 어떻게 분할되는지 살펴볼 수 있도록 커뮤니티 수를 다양하게 조정해보는 것을 독자에게 권장합니다!\n\n```js\nimport numpy as np\npokemon_edgelist_filtered = pokemon_edgelist[pokemon_edgelist.num_of_habitats > np.percentile(pokemon_edgelist.num_of_habitats, 90)].reset_index(drop=True)\n\npokemon_na = NetworkAnalysis(edgelist_df = pokemon_edgelist_filtered,width = \"100%\",height = \"100%\",bgcolor = 'white',font_color = 'black')\npokemon_na.create_network_graph_object()\npokemon_na.community_graph_html(num_communities=2,html_filename='Pokemon_comm_graph_filtered.html')\n```\n\n<img src=\"/assets/img/2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters_12.png\" />\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n네트워크 분석에 대한 제 이야기를 즐겨주셨기를 바라며 포켓몬 세계를 탐험하는 데 즐거움을 느꼈기를 바랍니다! 네트워크 분석은 끝없는 가능성을 제공하며, 이 이야기에서 논의된 기술만으로 얻을 수 있는 독특한 통찰력을 제공합니다. 다른 데이터 세트에서도 이를 시도해 보는 데 두려워하지 마세요!\n\n이 이야기가 마음에 드셨다면, 더 많은 데이터 과학, Python, 기계 학습, 금융, A/B 테스팅 등에 대한 이야기를 위해 여기에서 제 팔로우를 눌러주시기 바랍니다!\n\nBSD 3-Clause “New” or “Revised” License\n\nCopyright © © 2013–2023 Paul Hallett and PokéAPI contributors (https://github.com/PokeAPI/pokeapi#contributing). 포켓몬 및 포켓몬 캐릭터 이름은 닌텐도의 상표입니다.\n\n<div class=\"content-ad\"></div>\n\n**저작권 보호됨.**\n\n## 참고 자료\n\n- Hevey, David. “Network Analysis: A Brief Overview and Tutorial.” Health Psychology and Behavioral Medicine, 미국 국립의학도서관, 2018년 9월 25일, www.ncbi.nlm.nih.gov/pmc/articles/PMC8114409/.\n- NetworkX. (n.d.). 중심성 계층. In NetworkX Documentation. 2024년 6월 11일 조회, https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.closeness_centrality.html#networkx.algorithms.centrality.closeness_centrality.\n- NetworkX. (n.d.). 엣지 중심성 계층. In NetworkX Documentation. 2024년 6월 11일 조회, https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.closeness_centrality.html#networkx.algorithms.centrality.closeness_centrality.\n- NetworkX. (n.d.). Girvan-Newman. In NetworkX Documentation. 2024년 6월 11일 조회, https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.centrality.closeness_centrality.html#networkx.algorithms.centrality.closeness_centrality.","ogImage":{"url":"/assets/img/2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters_0.png"},"coverImage":"/assets/img/2024-06-20-MappingthePokmonWorldANetworkAnalysisofHabitat-BasedEncounters_0.png","tag":["Tech"],"readingTime":18},{"title":"데이터 스토리텔링이 당신의 새로운 슈퍼파워인 이유","description":"","date":"2024-06-20 14:59","slug":"2024-06-20-WhyDataStorytellingisYourNewSuperpower","content":"\n\n![이미지](/assets/img/2024-06-20-WhyDataStorytellingisYourNewSuperpower_0.png)\n\n데이터 스토리텔링은 가능한 한 넓은 관객 대상으로 데이터 세트를 이해할 수 있는 이야기 형식으로 변환합니다.\n\n현재 사용 가능한 고급 데이터 분석 도구의 보급으로 누구나 데이터 세트를 가져와서 시각적 그래프로 나타낼 수 있습니다.\n\n그러나 데이터와 효과적으로 소통하는 방법을 학습하지 못하는 현대 교육 방법에 따르면, 데이터와 함께 이야기를 만드는 학습자들에게 가르치는 것은 없다고 Storytelling with Data의 저자이자 전문가인 Cole Nussbaumer-Knaflic이 말합니다.\n\n<div class=\"content-ad\"></div>\n\n우리 중 많은 사람들이 숫자와 언어에 대해 형식 교육을 수 년 동안 받지만, 이를 결합하여 우리 언어 기술을 사용하여 숫자 세트에 대한 이야기를 전하는 방식은 거의 없습니다.\n\n우리 인간은 자연스러운 이야기꾼이지만, 데이터에 대한 이야기를 전하는 것에는 자연스럽지 않습니다.\n\n결과는 제대로 설명되지 않고 혼란스러운 차트와 그래프들로 가득합니다.\n\n더 잘할 수 있는 방법은 무엇일까요? 우리는 숫자를 이야기와 결합하는 방법을 이해하는 것부터 시작할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 우리에게는 다양한 사고 방식이 있습니다\n\n현대 교육의 격차가 존재하지만, 우리의 두뇌는 양적(무엇, 얼마나)과 질적(왜, 어떻게) 사고를 할 수 있도록 진화했습니다.\n\n현대 교육은 종종 양적 데이터를 서술과 결합하는 데 실패하지만, 다양한 문화적 접근법은 그것을 하는 가치를 상기시킵니다.\n\n컴퓨터 과학, 토착 지식, 교육의 교차로에서의 제 박사 연구 동안, 저는 다양한 문화가 의사 결정을 위해 양적과 질적 사고를 어떻게 통합하는지 연구했습니다. 데이터와 서술의 혼합은 효과적인 데이터 스토리텔링을 보여주며, 다양한 사고 방식을 결합하는 모델을 제시합니다.\n\n<div class=\"content-ad\"></div>\n\n강력한 숫자는 우리가 절대적으로 다룰 때 잘 작동합니다. 이것들은 데이터 집합에 대한 정적이고 추상적인 관점을 제공합니다. 그러나 이는 흔히 추상적인 것들과 거의 다루지 않는 사람들의 현실로의 전환이 항상 이루어지지는 않습니다.\n\n예를 들어 원주민 어부는 많은 다양한 입력 값들의 근사치에 기반하여 어떻게, 어디서, 무엇을 어떻게 낚아야 하는지 결정할 것입니다.\n\n날씨, 온도, 물 깊이, 연간 시기 및 이러한 변수들에 기반한 과거 결과에 대한 내부 지식 등을 고려합니다. 적응적 사고가 필수적입니다. 어제의 데이터는 오늘 내려야 할 결정과 아무런 관련이 없을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n베르켓과 그랜트(2007)의 연구에 따르면, 그레나다 어부들의 질적 사고는 의사 결정에 있어 적응적이고 실시간 질적 사고의 실용성을 강조합니다. 사실, 많은 지방주민들은 서구 과학자가 모든 것을 극도로 상세하게 양적화해야 한다는 필요성에 당혹스러워합니다. 이 서구적 방법론은 종종 데이터의 서로 다른 조각들 간의 근본적인 관계를 놓치곤 합니다.\n\n지식체계는 이야기를 통해 복잡한 환경 데이터를 해석하는 인간의 본능적 능력을 보여줍니다. 이 접근법은 데이터 이야기의 본질을 반영하는 것으로, 질적 인사이트와 양적 데이터를 결합함으로써 우리의 지식의 깊이와 폭을 향상시킵니다.\n\n현대적인 방법은 이러한 지식이 어떻게 수집, 보급 및 관련되는지를 개선했지만, 서로 다른 문화들이 지식 전파에 접근하는 방식은 고려되어야 합니다. 많은 사람들에게는 이것이 전통적으로 실용적인 질적 방법이었습니다.\n\n다양한 사고 방식을 통합하는 것을 이해하는 것은, 전통적인 방법과 현대적인 필요가 교차하는 양적 이야기의 도전에 직면할 수 있도록 준비시켜줍니다.\n\n<div class=\"content-ad\"></div>\n\n# 양적 이야기의 도전\n\n전통적으로, 질적 사고(즉, 이야기)를 사용하고 근사치를 적용하여 결과(특정 조건 하에서 잡힌 물고기 수)를 달성하는 데 사용했습니다.\n\n이 지식은 다음 세대의 어부들에게 전수되었습니다. 이것이 대부분의 원주민 지식이 시간이 흘러도 유지되던 방식입니다 — 종종 문서화된 언어의 대신.\n\n이 전통은 가치에 이야기를 부착하려는 자연인의 성향을 강조하는데, 이는 현대 교육에서 충분히 적용되지 않아 데이터 시각화가 이야기 요소를 간과하는 결과를 낳게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n우리 많은 사람들은 가치에 이야기를 첨부하기 위해 선천적으로 프로그래밍되어 있습니다. 그러나 많은 학교 시스템은 이를 결합하지 않습니다. 따라서 많은 데이터 시각화에 이야기가 포함되지 않습니다 — 그런데 그것들이 포함되어야 합니다.\n\n데이터 시각화의 선구자인 에드워드 터프트는 자신의 고전적인 서적인 \"양적 정보의 시각적 표현\"에서 \"단어와 그림은 함께 속한다\"고 언급합니다. 그는 또한 두 가지의 분리가 \"희소한 공간\"을 위해 오랜 논쟁을 벌인 예술가와 작가들의 결과라고 언급했습니다.\n\n데이터의 풍부함에 접근할 수 있는 설명은 그래픽을 시청자에게 더 잘 전달할 수 있게 만듭니다.\n\n# 복잡성을 접근하기 쉽게 만드는 것\n\n<div class=\"content-ad\"></div>\n\n시청자들은 종종 단어가 제공하는 지원이 필요합니다. 그 반대로, 많은 시청자는 단어와 숫자를 설명하는 그래픽을 필요로 합니다.\n\n데이터 스토리텔링은 이러한 영역 사이의 다리 역할을 합니다. 시각화를 통해 효과적으로 생각하는 우리에게는 차트나 그래프가 명확히 설명해 줄 수 있습니다.\n\n시각화를 해석할 수 없는 우리에게는 캡션과 주석을 통한 텍스트 통합이 공백을 메울 수 있습니다.\n\n간단한 예시를 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n## CO₂ 당 인구당 배출량의 글로벌 트렌드:\n\n지구 온난화는 뜨거운 이슈이며, 과학적으로는 시간이 흐름에 따라 전 세계적인 CO₂ 배출량이 증가함과 연결되어 있습니다.\n\n이러한 트렌드를 선 그래프로 시각화하면, 전 세계적인 배출량이 전반적으로 상승하는 방향을 더욱 쉽게 파악할 수 있습니다 — 1830년대 이후로 명확히 상승세를 유지하고 있습니다. 이를 어떻게 질적 사고를 가진 사람들에게 효과적으로 전달할 수 있을까요?\n\n선 그래프의 활용은 다년간의 데이터 트렌드를 해석하는 것을 단순화하여, 중요한 변화 또는 안정 기간을 강조할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-20-WhyDataStorytellingisYourNewSuperpower_2.png)\n\n두 시기에 대한 주석이 초기 산업화의 영향과 제2차 세계 대전 이후의 발전에 대한 이야기를 전합니다. 선 그래프의 사용은 중요한 변화 기간을 강조합니다.\n\n질적 사고자에게는 종종 급격한 증가로 인해 그래프가 하키 스틱처럼 모양이 변한다고 합니다.\n\n이러한 질적 관찰은 순수한 데이터에서 양적 추상화와 세부 사항을 제거하여 필요한 사람들에게 더 관련성있는 맥락을 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n데이터를 시각화물로 변환하면 다음을 할 수 있어요:\n\n- 중요한 통찰력 강조: 시각화는 데이터 표에서 쉽게 알아보기 힘든 중요한 추세, 비교 및 변화에 주목을 끌어줘요.\n- 이해도 향상: 시각적 표현은 순수 데이터보다 해석하기 쉬울 수 있어요.\n- 소통 용이: 효과적인 시각화는 발표에서 정보를 전달하는데 사용돼요. 예를 들어, \"하키 스틱\" 차트는 데이터를 더 dramatic하고 관련성 있게 만들어줘요.\n\nA Markdown 형식으로 표를 변경할 수도 있어요. \n\n# 데이터에서 이야기 찾는 도구\n\n<div class=\"content-ad\"></div>\n\n데이터에서 이야기를 찾을 수 있는 수많은 도구들이 있어요. 그 중에서도 인기 있는 몇 가지는 다음과 같아요:\n\n## 기술적 사용자를 위한 도구:\n\n- Tableau: 복잡한 분석을 위한 대화형 데이터 시각화를 제공해요.\n- Power BI: 대화형 보고서 및 대시보드를 만들 수 있고, Microsoft 제품과 웰매칭되는 기능을 제공해요.\n- D3.js: 웹 기반 데이터 시각화를 위한 사용자 정의 가능한 JavaScript 라이브러리에요.\n\n## 비기술적 사용자를 위한 도구:\n\n<div class=\"content-ad\"></div>\n\n- Google Charts: 웹사이트나 프레젠테이션에 삽입하기 쉬운 차트 및 그래프를 생성할 수 있습니다.\n- Canva: 인포그래픽 및 데이터 그래픽을 디자인하는 데 편리한 플랫폼입니다. \n- Flourish: 코딩 없이 상호 작용하는 시각화물을 만들어 내는 데 적합하며, 어떤 대상에게나 적합합니다.\n\n# 요약하자면...\n\n데이터 스토리텔링은 \"복잡성을 접근 가능하게 만드는 것\"에 관한 것입니다. (터프트)\n\n데이터부터 시작해보세요. 어떤 이야기를 전달하나요? 이 이야기를 다른 사람이 이해하고 공감할 수 있도록 어떻게 공유할 수 있을까요?\n\n<div class=\"content-ad\"></div>\n\n데이터에서 이야기를 찾는 데 도움이 되는 많은 도구들이 있습니다: Tableau,\n\n이야기를 묘사할 때 단어와 그림을 결합하면 시청자에게 더 깊은 이야기를 전달할 수 있어요. 명료성을 제공하기 위해, 시청자는 단어가 제공하는 도움이 필요할 수도 있고, 반대로 단어를 명확하게 해주는 시각적인 도움이 필요할 수도 있어요.\n\n시각화의 목적이 데이터를 명확하게 설명하는 것이라는 것을 기억해주세요.\n\n만일 시각적인 표현이 명확하지 않다면 완전한 실패입니다.\n\n<div class=\"content-ad\"></div>\n\n위 글 읽어 주셔서 감사합니다.\n\n## 참고 자료\n\nTufte, E. R. (2001). The visual display of quantitative information (2nd ed.). Graphics Press.\n\nNussbaumer Knaflic, C. (2015). Storytelling with data: A data visualization guide for business professionals. Wiley.\n\n<div class=\"content-ad\"></div>\n\nBerkes, F., & Grant, S. (2007). Fisher knowledge as expert system: A case from the longline fishery of Grenada, the Eastern Caribbean. Fisheries Research, 84(2), 162–17.\n\n만약 이러한 유형의 이야기가 당신에게 딱 맞고 저를 작가로 지원하고 싶다면, 제 Substack을 구독해주세요.\n\nSubstack에서는 나의 생산물이 있는 다른 플랫폼에서 찾을 수 없는 매주 두 번의 뉴스레터와 기사들을 발행합니다.","ogImage":{"url":"/assets/img/2024-06-20-WhyDataStorytellingisYourNewSuperpower_0.png"},"coverImage":"/assets/img/2024-06-20-WhyDataStorytellingisYourNewSuperpower_0.png","tag":["Tech"],"readingTime":6},{"title":"데이터 시각화 101 효과적인 대시보드와 보고서를 위한 색채 심리 활용하기","description":"","date":"2024-06-20 14:57","slug":"2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports","content":"\n\n## 이 기사에서는 색상 심리학과 데이터 시각화에서의 적용을 탐구합니다.\n\n![이미지](/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_0.png)\n\n## 서문\n\n색상 심리학은 색상이 우리에게 미치는 영향과 그 지식을 다양한 상황(이 경우 데이터 시각화)에서 어떻게 활용할 수 있는지 이해하는 데 도움을 줍니다. 이는 색상이 인간의 행동, 감정 및 인식에 어떻게 영향을 미치는지에 대한 연구입니다. 다양한 색조가 우리에게 특정 감정적 반응을 유발할 수 있으며, 이러한 반응이 연령, 문화적 배경 및 문맥과 같은 다양한 요소에 의해 영향을 받을 수 있다는 것을 탐구합니다. 이 중요한 측면 중 일부는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 색상과 감정: 다른 색상은 다른 감정과 관련이 있습니다. 예를 들어, 빨강은 흥분이나 열정을 자아내고, 파랑은 평화와 안정을 촉진할 수 있습니다.\n- 문화적 영향: 색상의 의미는 문화에 따라 달라질 수 있습니다. 예를 들어, 서양 문화에서 흰색은 순수함과 새로운 시작을 상징하지만, 동양 문화에서는 애도를 나타낼 수 있습니다.\n- 생리적 효과: 연구에 따르면 색상은 우리의 생리에도 영향을 줄 수 있습니다. 빨강은 심박수를 높일 수 있고, 녹색은 진정 효과가 있을 수 있습니다.\n\n아름다움 넘어선 색채 심리학은 데이터 시각화에서 차트와 보고서 테마의 색상 선택을 안내합니다. 이를 통해 인사이트를 청중이나 이해권자에게 효과적으로 전달할 수 있습니다. 그들의 배경을 이해하는 것이 강력한 색상을 선택하는 열쇠입니다.\n\n## 파트 1: 회색의 힘\n\n이 기사에서는 데이터 시각화에서 회색의 중요성에 대해 논의했습니다. 요점은, 회색이 기초를 제공하고 시청자의 주의를 이끄는 역할을 하며, 데이터가 전하는 이야기를 흐트리지 않고 명확성을 보장합니다. 다시 한번 요약하면:\n\n<div class=\"content-ad\"></div>\n\n- 강조를 줄이는 요소: 회색은 주목을 받지 않는 중립적인 색상입니다. 그렇기 때문에 그리드 선, 배경 또는 강조하고 싶지 않은 데이터 포인트와 같은 중요하지 않은 요소에 이상적입니다. 이러한 요소에 회색을 사용함으로써 색상이 돋보이고 시각화의 가장 중요한 측면에 관중의 시선을 집중시킬 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_1.png)\n\n- 맥락 제공: 더 밝은 회색으로 배경 정보나 큰 그림을 이해하는 데 도움이 되는 콘텍스트 데이터를 표시할 수 있습니다. 이는 색상으로 관중을 압도하지 않고 추세나 기준선을 보여줄 때 유용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_2.png)\n\n<div class=\"content-ad\"></div>\n\n- 등급 구조 생성하기: 다양한 회색 색조를 사용하여 데이터 시각화 내에서 시각적 등급 구조를 만들 수 있습니다. 예를 들어, 차트 레이블에는 더 어두운 회색 색조를 사용하고, 그리드선에는 더 밝은 색조를 사용할 수 있습니다. 이는 뷰어가 서로 다른 요소들을 구별하고 정보 구조를 이해하는 데 도움이 됩니다.\n\n![이미지](/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_3.png)\n\n- 눈 피로 감소: 너무 많은 색상, 특히 밝은 색상을 사용하는 것은 데이터 시각화를 오랫동안 보는 뷰어에게 눈 피로를 일으킬 수 있습니다. 회색은 눈의 중립적인 휴식 지점을 제공하여 전체 시각화를 더 피로감 없이 볼 수 있게 합니다.\n\n![이미지](/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_4.png)\n\n<div class=\"content-ad\"></div>\n\n- 섬세한 구분: 더 밝은 회색을 사용하여 대시 보드 또는 보고서의 다른 섹션을 섬세하게 구분할 수 있습니다. 이는 뷰어가 정보를 탐색하고 데이터 조각들이 서로 어떻게 관련되는지 이해하는 데 도움이 됩니다.\n\n![이미지](/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_5.png)\n\n## 파트 2: 산업 색상\n\nTowergate 보험은 520개 회사의 로고를 분석하여 그들의 색상 선호도와 해당 색상이 유발할 수 있는 감정적 반응을 이해하기 위해 노력했습니다. 그들의 연구 결과는 동일한 색상이 산업에 따라 다른 반응을 유발할 수 있다는 것을 시사합니다. 예를 들어, 파란색은 의사 소통 산업에서 인기 있는 선택지로, 명확한 의사 소통과 정신적 초점을 전달하려는 데 사용됩니다. 그에 반해, 제약 산업은 청결과 건강과의 연관성을 활용하기 위해 파란색을 종종 웰빙을 상징하는 데 사용합니다. 이 연구는 보고서나 대시보드를 위한 테마 색상을 선택할 때 유용한 통찰을 제공하며, 특히 특정 브랜드 가이드라인 외부에서 작업할 때 중요한 역할을 합니다. 관련 산업에 맞춰 색 팔레트를 맞춤으로써 보고서나 대시보드가 관련성을 유지하고 청중과 공감할 수 있도록 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n유용한 팁: 보고서나 대시보드를 디자인할 때 특정 브랜드의 公式 색상 코드를 사용하면 브랜드 일관성을 유지할 수 있습니다. 일반적으로 이러한 색상은 공식 웹사이트나 온라인 검색을 통해 확인할 수 있습니다. 또한, 그들의 브랜드 가이드라인을 주의 깊게 살펴봄으로써 로고나 색상 사용 정책을 위반하는 일을 피할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_6.png)\n\n색채심리를 활용하여, 저는 #DataDNA 2024년 5월 챌린지 보고서의 테마 색상으로 통신 업계(기술 지원) 에이전트 성과에 파란색을 선택했습니다. 그 이유는 다음과 같습니다:\n\n- 신뢰와 안정성: 파란색은 안정감을 불러일으키고 안정성을 나타내는데 좋아 신뢰와 안정성을 전달하는 데 좋은 선택입니다.\n- 명확한 커뮤니케이션과 집중: 파란색은 정신적 명확성과 집중력과 연관이 있어 명확한 커뮤니케이션을 촉진하고 이해하기 쉬운 메시지를 홍보하는 데 이상적입니다.\n- 전문성과 신뢰성: 신뢰와 명확성에 대한 연관은 커뮤니케이터나 브랜드에 대한 전문성과 신뢰성감을 전달합니다.\n- 안전과 안정: 파란색은 안전감과 안정감을 조성할 수도 있어 커뮤니케이션 환경에서 사용자가 불안하거나 불확실해 느낄 수 있는 상황에 유용할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_7.png\" />\n\n## 파트 3: 데이터 시각화에서의 공통 색상 지각\n\n문화를 넘어서 특정 색상은 일반적으로 공통된 지각을 일으킵니다. 여기 몇 가지 예시가 있습니다:\n\n- 빨간색은 사랑, 열정, 분노, 위험과 같은 강렬한 감정과 관련이 있습니다.\n- 파란색은 평온함, 평화, 신뢰, 슬픔과 연관되는 경우가 많습니다.\n- 녹색은 일반적으로 자연, 성장, 조화 및 때로는 질투를 나타내는 것으로 인식됩니다.\n- 노란색은 행복, 낙관주의, 에너지, 때로는 주의를 불러일으킵니다.\n- 검은색은 일반적으로 권력, 세련미, 격식, 명복(일부 문화에 따라)와 관련이 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\nMarkdown 형식의 표로 변경해주시면 됩니다.\n\n\n| ![Data Visualization101 - Leveraging Color Psychology for Effective Dashboards and Reports](/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_8.png) |\n|:--:|\n| 이미지 1 |\n  \n| ![Data Visualization101 - Leveraging Color Psychology for Effective Dashboards and Reports](/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_9.png) |\n|:--:|\n| 이미지 2 |\n\n\n그러나 컨텍스트에 따라 색상의 의미가 다를 수 있다는 점을 기억하는 것이 중요합니다. 예를 들어, 빨강은 일부 동양 문화에서 행운을 상징할 수 있지만, 흰색은 아시아 일부 지역에서 애도에 사용됩니다. 이 원칙은 데이터 시각화에도 동일하게 적용됩니다. 여기에서 빨강과 같은 색상은 종종 부정적인 값을 나타내거나 감소하는 추세를 나타냅니다, 반면 초록색은 일반적으로 긍정적인 값을 나타내거나 증가하는 추세를 나타냅니다. 그러나 이 규칙은 모든 경우에 적용되지 않습니다. 그 이유는 색상이 특정 컨텍스트에 따라 다른 의미를 갖을 수 있기 때문입니다.\n\n아래 차트로 나타낸 주가 상승은 회사와 이해관계자들에게 긍정적인 소식을 알리는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_10.png\" />\n\n또 다른 예에서는 상슨하는 유가가 소비자들에게 나쁜 뉴스로 전환되는 방법을 강조합니다. 그래서 여기에서 빨간색은 긍정적인 가치를 나타내는 것을 의미합니다 - 소비자에게 부정적인 영향을 뜻합니다.\n\n<img src=\"/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_11.png\" />\n\n독서해 주셔서 감사합니다! 이 글이 유익하게 느껴졌으면 좋겠습니다. 궁금한 점이 있으시면 언제든지 문의해 주세요.","ogImage":{"url":"/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_0.png"},"coverImage":"/assets/img/2024-06-20-DataVisualization101LeveragingColorPsychologyforEffectiveDashboardsReports_0.png","tag":["Tech"],"readingTime":6},{"title":"윈도우에서 NVIDIA GPU 가속을 활용해 llama-cpp-python 설치하기 간단 안내","description":"","date":"2024-06-20 14:56","slug":"2024-06-20-Installingllama-cpp-pythonwithNVIDIAGPUAccelerationonWindowsAShortGuide","content":"\n\n<img src=\"/assets/img/2024-06-20-Installingllama-cpp-pythonwithNVIDIAGPUAccelerationonWindowsAShortGuide_0.png\" />\n\n개발자이신가요? 로컬 LLM 개발을 위해 Windows에서 하드웨어 가속된 llama-cpp-python의 성능을 끌어올리고 싶으신가요? 더 이상 찾지 마세요! 이 안내서에서는 스텝별로 안내하여 본인이 설치하는 동안 겪은 문제점을 피할 수 있도록 도와드리겠습니다.\n\n# Prerequisites:\n\n- Visual Studio 설치:\n\n<div class=\"content-ad\"></div>\n\n- Windows용 C++ CMake 도구.\n- C++ 핵심 기능\n- Windows 10/11 SDK.\n\n![이미지](/assets/img/2024-06-20-Installingllama-cpp-pythonwithNVIDIAGPUAccelerationonWindowsAShortGuide_1.png)\n\n2. CUDA Toolkit:\n\n- NVIDIA 공식 웹사이트에서 CUDA Toolkit 12.2를 다운로드하고 설치합니다.\n- nvcc --version 및 nvidia-smi로 설치 여부 확인합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-Installingllama-cpp-pythonwithNVIDIAGPUAccelerationonWindowsAShortGuide_2.png\" />\n\n- 환경 변수에 CUDA_PATH (C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.2)를 추가하세요.\n\n## 설치 단계:\n\n새 명령 프롬프트를 열고 Python 환경을 활성화하세요 (예: conda 사용). 다음 명령을 실행하세요:\n\n<div class=\"content-ad\"></div>\n\n```shell\nCMAKE_ARGS=-DLLAMA_CUBLAS=on을 설정합니다.\nFORCE_CMAKE=1로 설정합니다.\npip install llama-cpp-python --force-reinstall --upgrade --no-cache-dir\n\n# 컴파일 시 cuBLAS가 사용되고 있는지 확인하려면 --verbose를 사용하세요.\n```\n\n설치 중 --verbose 옵션을 추가하면 CUDA가 컴파일에 사용되는지 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-Installingllama-cpp-pythonwithNVIDIAGPUAccelerationonWindowsAShortGuide_3.png)\n\nCUDA가 올바르게 구성되지 않았다면, llama-cpp-python은 하드웨어 가속을 사용하지 않고 설치됩니다.\n\n<div class=\"content-ad\"></div>\n\n만약 Cuda가 감지되지만 No CUDA toolset founderror가 발생한다면 다음을 수행하세요:\n\n- 파일을 복사합니다: C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.2\\extras\\visual_studio_integration\\MSBuildExtensions 에서 아래 경로로:\n(Enterprise 버전 인 경우) C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\MSBuild\\Microsoft\\VC\\v170\\BuildCustomizations\n또는\n(Community 버전인 경우) C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\MSBuild\\Microsoft\\VC\\v170\\BuildCustomizations\n\n```js\ncopy \"C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v12.2\\extras\\visual_studio_integration\\MSBuildExtensions\" \"C:\\Program Files\\Microsoft Visual Studio\\2022\\Enterprise\\MSBuild\\Microsoft\\VC\\v170\\BuildCustomizations\"\n```\n\n(설치에 기반하여 경로를 조정하세요)\n\n<div class=\"content-ad\"></div>\n\n# 테스트\n\n- 다음의 Python 코드를 실행하여 설치를 확인하세요:\n\n```js\nfrom llama_cpp import Llama\nllm = Llama(model_path=\"model.gguf\", n_gpu_layers=30, n_ctx=3584, n_batch=521, verbose=True)\n# GPU 및 모델에 맞게 n_gpu_layers를 조정하세요\noutput = llm(\"Q: 태양계의 행성을 말해주세요? A: \", max_tokens=32, stop=[\"Q:\", \"\\n\"], echo=True)\nprint(output)\n```\n\n![링크 텍스트](/assets/img/2024-06-20-Installingllama-cpp-pythonwithNVIDIAGPUAccelerationonWindowsAShortGuide_4.png)\n\n<div class=\"content-ad\"></div>\n\n만약 설치가 올바르게 되었다면, 모델 속성에서 BLAS = 1 지표가 표시될 것입니다.\n\n# 결론:\n\n이 단계를 따르면, Windows 기기에 cuBLAS 가속을 사용하여 llama-cpp-python을 성공적으로 설치했을 것입니다. 이 안내서는 과정을 간소화하고 흔한 문제를 피할 수 있도록 돕는 것을 목표로 합니다.\n\n이제 향상된 성능을 갖는 로컬 llama 개발에 뛰어들 준비가 되었습니다. GPU 오프로딩에 행운을 빕니다!","ogImage":{"url":"/assets/img/2024-06-20-Installingllama-cpp-pythonwithNVIDIAGPUAccelerationonWindowsAShortGuide_0.png"},"coverImage":"/assets/img/2024-06-20-Installingllama-cpp-pythonwithNVIDIAGPUAccelerationonWindowsAShortGuide_0.png","tag":["Tech"],"readingTime":3},{"title":"차원이 다른 창문, 문 최고의 창문 또는 문을 찾는 데 도움이 될 5가지 팁, 설치가 제대로 이루어졌는지 확인하는 방법","description":"","date":"2024-06-20 14:55","slug":"2024-06-20-Top-TierWindowsDoors5FastFactsForFindingTheBestWindowsorDoorsHowToMakeSureTheyreInstalledProperly","content":"\n\n얼마 전에 아내가 문자를 보내와서 창문이 얼었다고 했어요.\n\n그래서 따뜻한 물을 쏟고 기다리라고 했더니, 떨어질 거예요… 문제없어.\n\n그러다가 컴퓨터가 아마 더 이상 작동하지 않을 거라고 했대요.\n\n물론 농담이죠 — 제 아내는 컴퓨터와 공예 천재에요. 그녀 덕분에 이 기사를 쓰게 되었어요. 창문과 문에 대해 올바른 선택을 하는 방법을 알려드릴게요.\n\n<div class=\"content-ad\"></div>\n\n창문은 빛이나 공기의 원천 이상일 수 있다는 것을 보여 주었어요 — 그리고 문에 대해 이야기하자니... 선택 사항, 스타일, 그리고 고급 디자인들이 정말 다양하답니다.\n\n걱정하지 마세요, 모든 옵션을 하나씩 살펴볼 생각은 없어요 — 만약 그렇게 하고 싶다면, 지역 전문가와 상의하여 평면도와 디자인에 가장 적합한 것을 찾아보세요.\n\n![image](/assets/img/2024-06-20-Top-TierWindowsDoors5FastFactsForFindingTheBestWindowsorDoorsHowToMakeSureTheyreInstalledProperly_0.png)\n\n우리가 다루게 될 것은 구매 전 알아야 할 5가지 핵심 정보입니다.\n\n<div class=\"content-ad\"></div>\n\n## 1. 옛 기술, 새로운 디자인\n\n창문과 문 전문가를 찾기 시작했을 때 문제가 발생했어요.\n\n경험 많은 전문가들이 많이 있는 기업들은 옛 스타일의 문에만 초점을 맞추고 있었는데, 새로운 스타일의 문은 새로운 회사에서만 구할 수 있었는데, 그 회사들에 대해 충분히 신뢰할 만한 정보를 알지 못했어요.\n\n그래서 제 조언은 중간 길을 찾아 최선의 방법을 선택하는 거예요.\n\n<div class=\"content-ad\"></div>\n\n여러분은 경험 많은 비즈니스를 원하시는 것 같은데, 그것이 가능하면서도 어려운 일입니다.\n\n## 2. 맞춤형 솔루션\n\n여러분의 집이 이웃 집이나 거리 반대편의 집과 똑같나요?\n\n만약 그렇다면 아마 여러분도 모두와 똑같은 문을 원하실 겁니다.\n\n<div class=\"content-ad\"></div>\n\n만약 그렇다면, 왜 이제 모두를 똑같이 만들기 시작하나요?\n\n선반에서 문을 가져오는 대신 집에 맞춤형 문을 받아보세요. 사용자 정의 소재, 색상, 마감 또는 스타일 - 그것들을 할 수 있어요.\n\n귀하의 비즈니스나 집을 위해 특별히 제작된 문을 받게 되면 이웃들과 일치하지 않음을 확신할 수 있지만, 분명히 그들을 빛낼 수 있을 거에요.\n\n![이미지](/assets/img/2024-06-20-Top-TierWindowsDoors5FastFactsForFindingTheBestWindowsorDoorsHowToMakeSureTheyreInstalledProperly_1.png)\n\n<div class=\"content-ad\"></div>\n\n## 3. 모든 옵션\n\n큰 문이 필요하신가요, 리프트 앤 슬라이드 옵션을 찾으시나요, 아니면 대부분 유리로 이루어진 것이나 커스텀 창문이 있는 것을 원하시나요?\n\n원하는 것을 얻을 수 있어야 합니다. 특별한 것을 원하더라도 상관없어야 합니다.\n\n이는 맞춤형 작업을 넘어서 모두 구비한 것을 얻는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이렇게 생각해 볼 수 있어요: 자신만의 디자인을 만들어가는 것은 멋지지만, 소재, 크기, 스타일 등에 제한이 있는 경우 그리 멀리 나아갈 수 없어요.\n\n따라서 단순히 사용자 정의 디자인을 제작해 주는 비즈니스를 찾는 것이 아니라, 모든 옵션을 제공해 제한이 없는 선택을 할 수 있는 곳을 찾아보세요.\n\n## 4. 전문성을 기대하세요\n\n결국 모든 사람이 창문 및 문 전문가가 아니라는 사실이 안타까운 일이에요.\n\n<div class=\"content-ad\"></div>\n\n가끔은 최선의 옵션이 무엇인지, 어떻게 결정해야 하는지 알기 어려울 때가 있죠. 그럴 땐 쉬운 방법을 택하라고 말하죠.\n\n전문가에게 물어보고, 어떤 생각을 갖고 있는지와 당신의 옵션을 비교한 후에 결정하세요.\n\n그래서 전문가들을 스며들게 하는 거죠. 그들을 최대한 잘 활용하고, 필요한 모든 조언을 사전에 얻어보세요.\n\n## 5. 타협하지 마세요\n\n<div class=\"content-ad\"></div>\n\n자주 듣는 최악의 소식 중 하나는 누군가가 문이나 창문에 덜 투자했다는 것이고, 그들이 영원히 후회할 것이라는 것입니다.\n\n문은 하루에 여러 차례 통과하는 것이며, 모든 손님들도 그렇습니다.\n\n집의 큰 특징이자 당신의 성을 소개하는 요소이며, 사람들이 떠날 때 경험하는 마지막 것입니다.\n\n그러니 가치 있게, 웅장하게, 그리고 당신만의 것으로 만드세요.\n\n<div class=\"content-ad\"></div>\n\n창문은 여러분이 집 안으로 그것을 들여보내고 싶을 때 더 넓은 세상으로의 창구입니다.\n\n매일 보거나 상호 작용할 수 있기 때문에 원하는 옵션을 선택하는 것이 가치가 있습니다.\n\n![창문 이미지](/assets/img/2024-06-20-Top-TierWindowsDoors5FastFactsForFindingTheBestWindowsorDoorsHowToMakeSureTheyreInstalledProperly_2.png)\n\n적절한 창문과 문은 집이나 비즈니스에서 모든 차이를 만들어줄 수 있습니다 - 그들은 실내와 실외의 세계 사이의 인터페이스입니다.\n\n<div class=\"content-ad\"></div>\n\n내 리틀 스타트업에 오신 걸 환영합니다! 테이블 태그를 마크다운 형식으로 변경하시려면 다음과 같이 하시면 됩니다:","ogImage":{"url":"/assets/img/2024-06-20-Top-TierWindowsDoors5FastFactsForFindingTheBestWindowsorDoorsHowToMakeSureTheyreInstalledProperly_0.png"},"coverImage":"/assets/img/2024-06-20-Top-TierWindowsDoors5FastFactsForFindingTheBestWindowsorDoorsHowToMakeSureTheyreInstalledProperly_0.png","tag":["Tech"],"readingTime":3},{"title":"네오빔, 하지만 윈도우에서 실행하기","description":"","date":"2024-06-20 14:53","slug":"2024-06-20-NeovimbutitsinWindows","content":"\n\n![Neovim in Windows](/assets/img/2024-06-20-NeovimbutitsinWindows_0.png)\n\n얼마 전, 저는 아마도 다시는 Neovim에 관한 글을 쓰지 않을 것이라고 스스로에게 말했습니다... 그러나 여기 있군요.\n\n![Neovim in Windows](/assets/img/2024-06-20-NeovimbutitsinWindows_1.png)\n\n하지만 이전 포스트와 달리, 이번엔 10분 미만으로 읽을 수 있도록 이 포스트를 작성할 거에요. 그리고 이번에는 윈도우용 Neovim 설정에 대해 이야기할 걵니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-NeovimbutitsinWindows_2.png\" />\n\n# 놀랍도록 쉬웠어요\n\n본래 Neovim을 내장된 Windows 환경에 설정하는 것이 Linux와 비교해 상당히 어렵고 일관성이 없을 것이라고 믿었었어요. 하지만 Ubuntu에서 구성된 Neovim 설정을 몇 분 만에 복제한 후, 전체 프로세스가 매우 간단하다는 사실을 발견해서 매우 기뻤어요.\n\n그래서 이곳에서 시간을 많이 절약한 것은 이미 준비된 설정 파일 세트가 있기 때문이지만, 이것은 윈도우즈에서 Neovim을 처음부터 설정하는 것이 리눅스에서 하는 것과 거의 같은 프로세스라는 것을 보여주기도 합니다. 이에 대해서는 이 기사에서 언급했었어요:\n\n<div class=\"content-ad\"></div>\n\nVim 기반 편집기를 사용해 본 적이 없다면, 위에 링크된 기사를 포함하여 몇 가지 자료를 찾아보시는 것을 강력히 권장합니다. 결국 여기서 우리가 하는 것은 이미 존재하는 Neovim 구성을 복제하는 작업이니 말이죠. 하지만 대부분의 사람들이 fully-fledged 코드 편집기를 즐기기 때문에, 여러분이 사용하시는 것에 더 힘을 줍시다.\n\n# Chocolatey 설치하기\n\n![이미지](/assets/img/2024-06-20-NeovimbutitsinWindows_3.png)\n\nLinux와는 다르게 macOS와 유사하게, Windows에는 내장된 패키지 관리자가 없습니다 (winget에 대해 언급하지 마세요). Ubuntu 사용자는 apt를 기본으로 사용하고, Arch 사용자는 pacman을 선호하며, macOS 사용자는 대부분 brew를 선택하는 반면, Windows의 패키지 관리자인 choco (또는 Chocolatey)가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n네오빔을 설치하기 위해 Chocolatey를 사용하겠습니다. \n\n- 관리자 권한으로 실행한 명령 프롬프트 또는 PowerShell을 엽니다 (마우스 오른쪽 버튼 - \"관리자 권한으로 실행\")\n- Get-ExecutionPolicy를 실행합니다. Restricted가 반환되면 Set-ExecutionPolicy AllSigned 또는 Set-ExecutionPolicy Bypass -Scope Process 중 하나를 실행합니다.\n- 다음을 실행합니다:\n\n```js\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n```\n\n그리고 이제 Chocolatey가 설치되어 있어야 합니다! choco를 실행하면 다음과 같은 출력이 표시될 것입니다:\n\n<div class=\"content-ad\"></div>\n\n![Neovim in Windows](/assets/img/2024-06-20-NeovimbutitsinWindows_4.png)\n\n# Neovim 설치 및 PATH에 추가\n\n이제 Chocolatey가 준비되었으니, choco install neovim을 사용하여 Neovim을 설치할 수 있습니다. Chocolatey가 Neovim을 설치하면, 바로 작동하지 않을 수 있습니다(nvim을 실행하면 인식되지 않는 명령어 오류가 표시될 수 있습니다). 이 경우, Neovim을 PATH 환경 변수에 추가해야 합니다.\n\n이를 위해 Windows 키를 누르고 \"시스템 환경 변수 편집\" 옵션을 찾아야 합니다.\n\n<div class=\"content-ad\"></div>\n\n아래 화면에 있을 때 \"환경 변수...\"를 선택하면 다른 창이 열립니다.\n\nPATH 환경 변수를 선택한 다음 그 아래에 있는 \"편집...\" 버튼을 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n아래 Markdown 형식을 이용하여 표 태그를 변경해주세요.\n\n\n![Neovim을 Windows에 설치하는 이미지 1](/assets/img/2024-06-20-NeovimbutitsinWindows_7.png)\n\n여기서 \"새로 만들기\"를 선택하고 Neovim이 설치된 경로를 추가하세요. 저의 경우, C:\\tools\\neovim\\nvim-win64\\bin에 설치되었는데, 다른 경로도 조금씩 다를 수 있으니 확인해보세요.\n\n말할 필요도 없이, 이미 열려 있는 터미널에서는 여전히 nvim을 사용할 수 없습니다. 새로운 터미널을 열기보다는 Chocolatey를 통해 환경 변수를 새로 고칠 수 있는 이 명령어를 실행하세요: RefreshEnv.cmd. 이제 nvim 명령어를 실행하면 Neovim이 열릴 것입니다!\n\n![Neovim을 Windows에 설치하는 이미지 2](/assets/img/2024-06-20-NeovimbutitsinWindows_8.png)\n\n\n<div class=\"content-ad\"></div>\n\n# 복제하기\n\n이제 Neovim 설정을 복제할 때입니다. 적절한 경로는 Win + R (Windows 실행)를 눌러 %appdata%를 입력하고 ENTER 키를 눌러 탐색할 수 있습니다. Roaming에서 한 디렉토리 뒤로 이동한 후 Local로 이동하세요.\n\n![이미지](/assets/img/2024-06-20-NeovimbutitsinWindows_9.png)\n\nLocal에서 Neovim은 nvim이라는 이름의 폴더를 찾을 것이므로 지금 할 일은 현재 디렉토리에서 터미널을 열고 선택한 깃허브 저장소를 복제한 다음, 복제된 폴더의 이름을 이미 nvim으로 지정하지 않았다면 nvim으로 변경하는 것뿐입니다.\n\n<div class=\"content-ad\"></div>\n\n만약 내 설정을 원한다면, 다음을 실행해보세요:\n\n```js\ngit clone https://github.com/kevinfengcs88/neovim-config\n```\n\n그러면 neovim-config라는 폴더가 생성됩니다. 해당 폴더를 nvim으로 변경하고, 다음에 Neovim을 열 때 모든 것이 제대로 로드되어야 합니다.\n\n![이미지](/assets/img/2024-06-20-NeovimbutitsinWindows_10.png)\n\n<div class=\"content-ad\"></div>\n\n하지만 작은 문제가 하나 있어요... 우리 멋진 아이콘들은 어디에 있나요? Nerd 폰트가 없으면 Neovim을 정리하고 깔끔하게 보이게 하는 멋진 글리프와 기호들을 렌더링할 수 없겠어요. 파일 트리 탐색기가 특히 싫어 보이네요...\n\n![Neovim in Windows](/assets/img/2024-06-20-NeovimbutitsinWindows_11.png)\n\n# Windows 터미널 설치하기\n\n![Installing Windows Terminal](/assets/img/2024-06-20-NeovimbutitsinWindows_12.png)\n\n<div class=\"content-ad\"></div>\n\n네드 폰트를 설치하기 전에는 네드 폰트와 호환되는 터미널이 필요합니다. 안타깝게도 명령 프롬프트와 파워쉘은 네드 폰트를 지원하지 않을 뿐만 아니라 조금 못생겼어요 (죄송해요).\n\nWindows 터미널은 멀티탭 터미널 에뮬레이터로 파워쉘, 명령 프롬프트, 심지어 Azure 클라우드 쉘을 실행할 수 있습니다. 무엇보다도, 네드 폰트를 지원합니다. Microsoft Store에 액세스할 수 있다면, GUI를 사용하여 간단히 설치할 수 있습니다. 안타깝게도 제 데스크탑은 Microsoft Store에 문제가 있어서 약간의 조사를 해야 했어요.\n\nWindows 터미널의 GitHub 릴리스로 이동하여 \"Latest\" 릴리스를 찾아보세요.\n\n![Windows Terminal Latest Release](/assets/img/2024-06-20-NeovimbutitsinWindows_13.png)\n\n<div class=\"content-ad\"></div>\n\n“에셋” 섹션으로 스크롤하여 .msixbundle로 끝나는 파일을 다운로드하세요. 파일을 다운로드했다면 Windows 터미널을 설치하는 몇 가지 다른 방법이 있습니다.\n\n하나는 .msixbundle 파일을 실행하는 것인데, 이를 통해 GUI를 통해 Windows 터미널을 설치할 수 있어요:\n\n![이미지](/assets/img/2024-06-20-NeovimbutitsinWindows_14.png)\n\n다른 방법은 PowerShell 명령어를 사용하는 것인데 (물론 “Downloads” 디렉토리에 있는 경우):\n\n<div class=\"content-ad\"></div>\n\n```js\nAdd-AppxPackage [이름]\n```\n\n다운로드한 .msixbundle 파일의 전체 이름으로 [이름]을 대체하세요.\n\nWindows 터미널을 설치한 후에는 Windows 시작 메뉴를 열 때 \"최근 추가된\" 섹션에서 찾을 수 있습니다. 쉽게 찾을 수 있도록 시작 메뉴에 고정하는 것을 추천합니다.\n\n# Nerd 폰트 설치하기\n\n\n<div class=\"content-ad\"></div>\n\n이제 Windows 터미널이 있으니 Nerd 폰트를 설치해보겠습니다. 이 작업은 여러 가지 방법으로 할 수 있는데, 하나는 nerdfonts.com을 방문하는 것이고, 다른 하나는 해당 GitHub 리포지토리를 이용하는 것입니다. 제가 이전 기사의 한 부분에서 후자를 다루었기 때문에, 이번에는 Nerd Fonts 웹사이트에서 설치하겠습니다.\n\n[Nerd Fonts 웹사이트의 \"다운로드\" 페이지](https://www.nerdfonts.com)로 이동하면 다양한 폰트들이 나타납니다.\n\n<div class=\"content-ad\"></div>\n\n선호하는 글꼴을 찾아 다운로드하고 다운로드한 글꼴의 ZIP 파일로 이동한 후 글꼴의 \"regular\" 변형을 찾아보세요:\n\n![참조 이미지](/assets/img/2024-06-20-NeovimbutitsinWindows_17.png)\n\n해당 파일을 열어서 Windows에 글꼴을 설치하세요.\n\n![참조 이미지](/assets/img/2024-06-20-NeovimbutitsinWindows_18.png)\n\n<div class=\"content-ad\"></div>\n\n폰트가 설치되었는지 확인하려면 Windows의 \"폰트 설정\"으로 이동하여 검색할 수 있어요.\n\n![이미지](/assets/img/2024-06-20-NeovimbutitsinWindows_19.png)\n\n# 마무리하며\n\n마지막으로, Nerd Fonts를 지원하는 터미널과 Nerd 폰트가 설치된 상태에서 몇 가지 더 실행 단계만 거치면 Neovim을 그 모든 영광으로 볼 수 있어요.\n\n<div class=\"content-ad\"></div>\n\nWindows Terminal을 열고 창 헤더 어디든 마우스 오른쪽 버튼을 클릭하세요:\n\n![image](/assets/img/2024-06-20-NeovimbutitsinWindows_20.png)\n\n“Settings”를 클릭한 후 사이드바에서 “Defaults” 탭으로 전환하세요:\n\n![image](/assets/img/2024-06-20-NeovimbutitsinWindows_21.png)\n\n<div class=\"content-ad\"></div>\n\n\"외형\"으로 스크롤을 내려주세요:\n\n\n<img src=\"/assets/img/2024-06-20-NeovimbutitsinWindows_22.png\" />\n\n\n마지막으로 \"글꼴\" 옵션을 변경해주세요:\n\n\n<img src=\"/assets/img/2024-06-20-NeovimbutitsinWindows_23.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n그리고 마침내 끝났어요!\n\n![Neovim in Windows](/assets/img/2024-06-20-NeovimbutitsinWindows_24.png)\n\n# 결론\n\nWindows용 Neovim 설정은 Linux 환경에서 Neovim을 경험한 사람으로서 매우 원활한 경험입니다. 대부분의 것들이 동일합니다. 단지 설정 파일을 저장하는 경로가 약간 다를 뿐입니다.\n\n<div class=\"content-ad\"></div>\n\nWindows에서 Neovim은 Linux 환경과 비교하여 시작 시 약 3배 정도 느립니다. 그리고 \"차가운\" 시작(수 시간 동안 Neovim을 열지 않아 리소스가 할당되지 않은 상태)에서는 10배 이상 느립니다.\n\n저의 Linux에서의 차가운 시작은 대략 200 또는 250밀리초이며, 일반적인 시작은 100밀리초 또는 그 이하입니다. 그러나 Windows에서는 일반적인 시작이 대략 280밀리초이며, 차가운 시작은 상당히 느리게 2000밀리초 이상(네, 2초 이상)이 소요됩니다. 이 부분은 확실히 확인하고 최적화할 필요가 있습니다. 왜냐하면 이제 Windows에서 작업을 할 때 Neovim을 사용할 것이기 때문입니다.\n\n읽어 주셔서 감사합니다! 다음에 또 뵙겠습니다, 친구들 :)\n\nKevin Feng || 웹사이트 || GitHub || LinkedIn || Medium (이미 여기 있으시네요!)\n\n<div class=\"content-ad\"></div>\n\n# 소스\n\n- [Windows Report](https://windowsreport.com/windows-terminal-windows-10/)\n- [Chocolatey](https://chocolatey.org/install#individual)","ogImage":{"url":"/assets/img/2024-06-20-NeovimbutitsinWindows_0.png"},"coverImage":"/assets/img/2024-06-20-NeovimbutitsinWindows_0.png","tag":["Tech"],"readingTime":8},{"title":"Windows 터미널을 더욱 향상시켜보세요 Oh My Posh와 함께하는 스텝바이스텝 설치 가이드 VSCode 설정 포함","description":"","date":"2024-06-20 14:51","slug":"2024-06-20-ImproveYourWindowsTerminalwithOhMyPoshAStep-by-StepInstallationGuidevscodesetupincluded","content":"\n<img src=\"/assets/img/2024-06-20-ImproveYourWindowsTerminalwithOhMyPoshAStep-by-StepInstallationGuidevscodesetupincluded_0.png\" />\n\n터미널에서 상당한 시간을 보내는 경우, 효율적이고 미려한 명령줄 인터페이스의 가치를 아실 것입니다. Oh My Posh는 터미널 프롬프트를 시각적으로 멋지고 매우 기능적인 작업 공간으로 변환해주는 강력한 도구입니다. 개발자, 시스템 관리자 또는 터미널 애호가이든, Oh My Posh를 통해 터미널 경험을 다음 수준으로 끌어올릴 수 있습니다.\n\n## Oh My Posh란?\n\nOh My Posh는 프롬프트 문자열을 조정할 수 있는 모든 셸에 대한 사용자 정의 프롬프트 엔진입니다.\n\n<div class=\"content-ad\"></div>\n\n## Oh My Posh를 사용해야 하는 이유\n\n- 사용자 정의: 다양한 테마 중에서 선택하거나 작업 흐름과 미적 취향에 맞게 자신만의 테마를 만들 수 있습니다.\n- 생산성: 추가 명령어를 입력하지 않고도 필수 정보에 빠르게 액세스할 수 있습니다.\n- 크로스 플랫폼: Windows, macOS 및 Linux에서 원활하게 작동합니다.\n- 커뮤니티 지원: 다양한 테마와 기능을 기여하는 활기찬 커뮤니티가 있습니다.\n\n## 설치 가이드\n\n터미널을 개선하고 싶나요? Oh My Posh를 설치하기 위해 이 간단한 단계를 따르세요:\n\n<div class=\"content-ad\"></div>\n\n**단계 1:** PowerShell 및 Microsoft 터미널을 설치합니다 (이미 설치되어 있지 않은 경우).\n\n**단계 2:** Oh My Posh 설치:\n\nOh My Posh를 설치하려면 Microsoft Store에서 설치하거나 PowerShell을 열고 다음 명령을 실행합니다:\n\n```js\nwinget install JanDeDobbeleer.OhMyPosh -s winget\n```\n\n<div class=\"content-ad\"></div>\n\n단계 3: 터미널 설정 구성\n\n설치 후 Oh My Posh를 사용하도록 터미널을 구성해야 합니다.\n\n- 네르드 폰트 설치: https://www.nerdfonts.com/\n- 터미널/편집기를 설치된 폰트를 사용하도록 구성하십시오:\n- 터미널에서 설정으로 이동하여 기본 섹션에서 font-face를 찾은 다음 설치한 네르드 폰트 중 하나로 설정하십시오:\n\n![이미지](/assets/img/2024-06-20-ImproveYourWindowsTerminalwithOhMyPoshAStep-by-StepInstallationGuidevscodesetupincluded_1.png)\n\n<div class=\"content-ad\"></div>\n\n- VS Code를 사용하려면 settings.json 파일로 이동해서 다음 코드를 추가하세요:\n\n```js\n\"terminal.integrated.fontFamily\": \"Hack Nerd Font\", // Hack Nerd Font은 내가 설치한 글꼴의 이름입니다\n```\n\n- 쉘에서 Oh My Posh를 사용하도록 구성하세요:\n- PowerShell 프로필 스크립트를 편집하세요\n\n```js\nnotepad $PROFILE\n```\n\n<div class=\"content-ad\"></div>\n\n위 명령어에서 오류가 발생하면 먼저 프로필을 만들어야 합니다:\n\n```js\nNew-Item -Path $PROFILE -Type File -Force\n```\n\n그런 다음 다음 줄을 추가하십시오:\n\n```js\noh-my-posh init pwsh | Invoke-Expression\n```\n\n<div class=\"content-ad\"></div>\n\n한 번 추가하면 변경 사항이 적용되려면 프로필을 다시로드하세요:\n\n```js\n. $PROFILE\n```\n\n위의 명령어를 입력한 후 이와 같은 오류가 발생하면:\n\n![이미지](/assets/img/2024-06-20-ImproveYourWindowsTerminalwithOhMyPoshAStep-by-StepInstallationGuidevscodesetupincluded_2.png)\n\n<div class=\"content-ad\"></div>\n\n새로운 PowerShell 세션을 관리자 권한으로 열어서 다음 코드를 추가해야 해요(자세한 내용은 이 링크에서 확인할 수 있어요):\n\n```shell\nSet-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser\n```\n\n그런 다음 실행하세요:\n\n```shell\n. $PROFILE\n```\n\n<div class=\"content-ad\"></div>\n\n만약 이와 같은 오류가 vscode에서 발생한다면:\n\n![Error](/assets/img/2024-06-20-ImproveYourWindowsTerminalwithOhMyPoshAStep-by-StepInstallationGuidevscodesetupincluded_3.png)\n\n터미널을 관리자 모드로 실행하여 다음 명령어를 실행해주세요:\n\n```js\nInstall-Module PsReadLine -Force\n```\n\n<div class=\"content-ad\"></div>\n\n만약 vscode에서 이런 식으로 나쁜 인코딩이 발생한다면:\n\n<img src=\"/assets/img/2024-06-20-ImproveYourWindowsTerminalwithOhMyPoshAStep-by-StepInstallationGuidevscodesetupincluded_4.png\" />\n\n다음 코드를 vscode 설정 파일인 setting.json에 추가해보세요:\n\n```js\n\"terminal.integrated.profiles.windows\": {\n    \"PowerShell\": {\n        \"shell_integration\": true,\n            \"source\": \"PowerShell\",\n            \"icon\": \"terminal-powershell\",\n            \"args\": [\n                \"-NoExit\",\n                \"-Command\",\n                \"oh-my-posh init pwsh | Invoke-Expression\"\n            ]\n        }\n  }\n```\n\n<div class=\"content-ad\"></div>\n\n**단계 4: 테마 선택**\n\n여기에서 테마를 찾아 설정할 수 있어요. 이것은 oh-my-posh 문서입니다.\n\n저는 이 테마를 사용하고 이렇게 보여요:\n\n![이미지](/assets/img/2024-06-20-ImproveYourWindowsTerminalwithOhMyPoshAStep-by-StepInstallationGuidevscodesetupincluded_5.png)\n\n<div class=\"content-ad\"></div>\n\n이 튜토리얼을 즐기시길 바라며, 만약 오류를 만나게 된다면 도움이 되어 문제를 해결하는 데 도움이 되기를 바랍니다 😍.\n","ogImage":{"url":"/assets/img/2024-06-20-ImproveYourWindowsTerminalwithOhMyPoshAStep-by-StepInstallationGuidevscodesetupincluded_0.png"},"coverImage":"/assets/img/2024-06-20-ImproveYourWindowsTerminalwithOhMyPoshAStep-by-StepInstallationGuidevscodesetupincluded_0.png","tag":["Tech"],"readingTime":4},{"title":"DSQuery 및 LDAPSearch를 사용한 수동 Active Directory 쿼리 소개","description":"","date":"2024-06-20 14:47","slug":"2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch","content":"\n\n# 소개\n\n정직하게 말하자면, BloodHound와 PowerView는 Active Directory(AD)를 조회하고 열거하며 조사하는 데 객관적으로 더 나은 도구입니다. 이 도구들은 더 효율적이고 직관적이며 BloodHound를 사용하면 쿼리를 쉽게 추적할 수 있습니다. 또한 파워뷰에서 -v 플래그를 사용하면 실행 중인 쿼리를 볼 수 있어 시간을 절약할 수 있습니다. 그러나 최근 평가에서 내가 한 대상에게 들을 수 없는 상황에 처했을 수도 있습니다. 그런 경우에 팀은 호스트에서 어느 도구도 실행할 수 없었고 도구를 프록시로 사용하는 데 어려움을 겪었습니다. 이 도구를 사용하기 위한 해결책을 찾느라 사투를 벌이는 동안에도 여전히 목표를 달성해야했습니다. 따라서 앞서 얻은 자격 증명을 사용하여 수동으로 쿼리를 수행하기로 결정했습니다. *nix 시스템에서는 ldapsearch를 사용하여 수동 LDAP 검색을 수행할 수 있고, Windows 시스템에서는 dsquery를 사용할 수 있습니다.\n\n이 블로그에서는 자격 증명이나 쿼리를 시작할 컨텍스트를 어떻게 얻을지에 대한 제안은 제공하지 않겠지만, 이미 필수적인 정보를 가지고 있다고 가정하겠습니다. 대신, 이 도구들로 쿼리를 작성하는 방법과 다른 해결책을 찾아내는 동안 어떻게 시작해야 하는지에 중점을 둘 것입니다.\n\n# 도구\n\n<div class=\"content-ad\"></div>\n\n좋아요, BloodHound, PowerView 및 다른 합리적인 옵션이 작동하지 않을 때 수동으로 AD 쿼리를 시작해야 하는 상황에 있습니다. 시작할 수 있는 두 가지 도구를 살펴보겠습니다. Dsquery와 ldapsearch는 AD를 쿼리하는 데 사용되는 도구이며, 공격적인 AD 상황인식에 사용할 수 있습니다.\n\n먼저, Windows 이진 파일인 dsquery에 대해 이야기하겠습니다. 따라서 목표에 (있는 경우) 이미 존재하지 않은 경우 너무 많은 경고를 일으키지 않고도 업로드할 수 있습니다. dsquery.dll은 기본적으로 대부분 또는 모든 Windows 시스템의 C:\\Windows\\System32\\dsquery.dll에 있습니다.\n\n![그림](/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_0.png)\n\n바이너리 dsquery.exe는 일부 서버에 이미 C:\\Windows\\System32\\dsquery.exe에 존재할 수 있습니다. Dsquery는 Windows 원격 서버 관리 도구(RSAT) 패키지의 일부이며 Microsoft에서 여기서 다운로드할 수 있습니다. 또한 해당 위치에서 Microsoft가 설명하길 \"Windows 10 2018년 10월 업데이트부터 RSAT는 자체 Windows 10의 \"기능 요청\" 세트로 포함되어 있습니다.\" 해당 지침에 따라 상황에 따라 목표에 필요한 항목을 얻을 수 있는 옵션이 있을 수 있습니다. Dsquery는 명령줄 유틸리티이며 다음이 필요합니다:\n\n<div class=\"content-ad\"></div>\n\n- Active Directory Domain Services (AD DS) 서버 역할이 설치되어 있어야 합니다 (즉, 쿼리할 도메인이 있어야 함)\n- 승격된 명령 프롬프트(즉, NT AUTHORITY\\SYSTEM 컨텍스트)\n\n두 번째 도구는 macOS 및 *nix 시스템에 기본으로 있으며 ldapsearch입니다. 이미 시스템에 설치되어 있을 수 있지만 ldap-utils 패키지를 설치하여 설치할 수 있습니다. macOS에서는 이미 설치되어 있지 않다면 brew를 통해 openldap 패키지를 설치할 수 있습니다. ldapsearch 쿼리를 실행하려면 AD를 쿼리할 수 있는 유효한 AD 계정의 자격 증명이 필요합니다. 제가 찾은 가장 좋은 가이드(맨 페이지 외)는 이 웹사이트에 있습니다. 여기서의 ldapsearch 쿼리 컨텍스트는 Ubuntu Windows Subsystem for Linux에 도메인 서비스 계정의 평문 자격 증명을 사용합니다.\n\n# 쿼리 구조화\n\nDsquery와 ldapsearch는 유사한 쿼리 구조를 가지고 있으므로 둘 사이를 이동하기 쉽습니다. 출력 형식은 다르지만 대부분 동일한 정보를 제공할 것입니다. 또한 동일한 결과를 얻을 수 있는 여러 가지 방법이 있지만, 제가 선호하는 방법을 설명하겠습니다. 두 도구 모두 수행할 작업에 따라 다양한 명령 줄 옵션이 있습니다. 본 블로그에서는 과거에 사용해본 일반적인 옵션 몇 가지를 다룰 것이나, 사용 사례의 빈틈을 막기 위해 문서를 참고할 것을 권장합니다.\n\n<div class=\"content-ad\"></div>\n\n## Dsquery 구조\n\ndsquery의 기본 구조는 다음과 같습니다:\n\ndsquery `대상 유형` `필터` `옵션`\n\n대상 유형에는 다음 옵션이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 컴퓨터\n- 연락처\n- 그룹\n- OU\n- 사이트\n- 서버\n- 사용자\n- 할당량\n- 파티션\n- * (와일드카드)\n\n첫 번째 매개변수로 객체 유형을 지정하거나 와일드카드 검색의 필터에 객체 유형을 지정하거나 모든 객체 유형을 열어두실 수 있습니다. 객체 유형을 지정하거나 와일드카드를 사용할 때 필터와 출력 결과가 다릅니다. 대개 다른 객체 유형은 많은 정보를 제공하지 않기 때문에 저는 객체 유형에 와일드카드 옵션을 주로 사용합니다. 이는 개인적인 선호도이며 처음 시작할 때는 둘 다 작동합니다. 아래 예시에서는 객체 유형으로 사용자가 지정된 쿼리와 객체 유형 및 테스트 도메인의 사용자에 대한 objectclass 필터가 지정된 쿼리를 확인할 수 있습니다 (PLANETEXPRESS).\n\n![이미지](/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_1.png)\n\ndsquery user\n\n<div class=\"content-ad\"></div>\n\n이 예에서는 도메인 사용자에 대한 간단한 쿼리를 사용하면 도메인의 모든 사용자의 식별 이름이 표시됩니다. 이 방법은 매우 쉽고 간결하지만 정보가 많이 부족한 점이 있습니다. 와일드카드를 사용한 예제를 살펴보고 결과를 하나의 사용자로 제한해 봅시다.\n\n![이미지](/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_2.png)\n\ndsquery * -filter \"(objectclass=user)\" -attr * -limit 1\n\n이전 것과 비교했을 때 이 필터는 훨씬 길고 비교적 복잡하지만 더 많은 정보를 얻을 수 있습니다. 예를 들어 사용자의 그룹 멤버십, 설명 및 이름을 모두 볼 수 있습니다. 두 쿼리 사이에는 조금 다른 결과가 나오지만 이에 대해 뒤에서 더 자세히 설명하겠습니다. 한 가지 빠른 팁: 대소문자 구분은 대부분 중요하지 않습니다. 원하면 적절한 형식을 사용할 수 있지만 결과에 큰 영향을 미치지 않을 것입니다. 결과에 영향을 준다고 판단되면 한 객체에 대한 모든 속성을 가져와 이름을 올바른 형식으로 복사하는 것이 좋습니다. dsquery를 사용한 쿼리의 경우 쿼리의 컨텍스트는 도메인에 가입된 호스트의 NT AUTHORITY\\SYSTEM 명령 프롬프트에 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## Ldapsearch 구조\n\nLdapsearch는 쿼리를 어떻게 구성할 지에 대해 더 많은 유연성을 제공합니다. 이 블로그 전체를 일관성 있게 유지하기 위해 사용할 형식은 다음과 같습니다:\n\nldapsearch `형식 옵션` `인증 옵션` `도메인 옵션` `쿼리 필터` `속성 목록`\n\n아마도 이것이 완전히 정확하지는 않겠지만, 이것이 내가 이 논의를 구성하고 \"시작하기\" 방법으로 생각할 것을 권장하는 방식입니다. 모든 옵션을 설명하지는 않겠지만, 모두들 매뉴얼 페이지를 읽거나 여기 추가 옵션을 검토하도록 장려합니다. 일관성을 위해 dsquery로 모든 사용자를 나열하는 동일한 쿼리를 사용합시다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_3.png\" />\n\n\nldapsearch -LLL -x -h DC-THESHIP.PLANETEXPRESS.LOCAL -p 389 -D ‘PLANETEXPRESS\\SService’ -w ‘L1feD3@thSeamlessContinuum’ -b ‘DC=PLANETEXPRESS,DC=LOCAL’ “(objectClass=user)” dn\n\n\n안녕하세요! Ldapsearch는 더 복잡할 것입니다. 종종, 필요한 옵션을 갖춘 첫 번째 쿼리를 작성한 다음 필터와 필요한 속성 목록을 조정하기 위해 마지막 두 부분을 수정합니다. 중요한 점은 이곳에서 전제로 한 것은 AD에 액세스할 수 있는 계정의 일반 텍스트 자격 증명을 가지고 있다는 것입니다. 이 쿼리에 대해, 제목 계정에 대한 일반 텍스트 사용자 이름과 암호를 사용했으며 이는 손상된 서비스 계정을 시뮬레이션합니다. 사용자 이름과 암호는 반드시 필요하지 않을 수 있지만 어떤 종류의 인증이 필요할 것입니다. 이 블로그에서는 이러한 방식으로 쿼리를 작성할 것이며, \"옵션\" 섹션에서 다른 방법에 대해 설명하겠습니다.\n\n# 쿼리 작성하기\n\n<div class=\"content-ad\"></div>\n\n## 복합 필터\n\n복합 필터는 성공적인 쿼리를 위해 꼭 필요해요. 이를 사용하면 찾고자 하는 대상의 범위를 크게 좁히고 시간을 낭비하지 않게 도와줄 수 있어요.\n\n복합 필터는 다음과 같이 보일 거에요:\n\n“(&(attribute1=value1)(attribute2=value2))”\n\n<div class=\"content-ad\"></div>\n\n여기에서 &는 복합 필터임을 나타내고, 어떤 결과도 해당 속성에 대해 두 가지 값을 가져야 합니다. ! 기호를 사용하여 필터에서 항목을 제외할 수 있지만 괄호로 감싸야 합니다. 다음과 같이 몇 가지 결과를 제외할 수도 있습니다:\n\n\"(&(attribute1=value1)(!(attribute2=value2)))\"\n\n이 필터는 attribute1에 대한 값이 value1이고 attribute2에 대한 값이 value2가 아닌 결과 목록을 생성합니다. 이러한 필터는 dsquery와 ldapsearch 간에 동일하게 작동합니다. 사용 중인 명령 줄 도구에 따라 ! 기호를 사용하는 데 어려움이 있을 수 있습니다.\n\n## 와일드카드\n\n<div class=\"content-ad\"></div>\n\n이 도구를 사용한 모든 쿼리는 와일드카드 검색입니다. 처음 시작할 때 환경에 적응하고 방향을 잡을 때 굉장히 유용합니다. 일반적으로 저의 접근 방식은 매우 넓게 시작하여 찾은 것을 기반으로 쿼리를 좁히는 것입니다. 이름이나 구절을 별표로 감싸거나 구절의 시작 또는 끝에 두는 등 여러 방법으로 쿼리를 구체화할 수 있습니다.\n\ndsquery를 사용하여, 모든 Windows 기기의 이름과 sAMAccountName을 가져오고 싶은 예시를 살펴보겠습니다.\n\n![image](/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_4.png)\n\ndsquery * -filter “(&(objectclass=computer)(name=*win*))” -attr name samaccountname -d 192.168.88.195\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_5.png)\n\nldapsearch -LLL -x -h DC-THESHIP.PLANETEXPRESS.LOCAL -p 389 -D ‘PLANETEXPRESS\\SService’ -w ‘L1feD3@thSeamlessContinuum’ -b ‘DC=PLANETEXPRESS,DC=LOCAL’ “(&(objectclass=computer)(name=*win*))” name samaccountname\n\n실제로 이를 시작할 때는 앞으로 진행하기 위해 필요한 속성만 반환하는 것이 좋습니다. 대규모 AD 환경에서는 많은 결과를 반환할 수 있으며, OPSEC 고려사항과 AD 개체를 통해 읽을 때의 주의 기준에 따라 더 적은 속성이 더 좋을 수 있습니다. 잠재적인 대상을 좁힐 때, 구체적인 결과를 얻기 위해 와일드카드를 사용하지 않고 이동할 가능성이 높습니다.\n\n와일드카드를 사용하는 또 다른 이점은 찾고 있는 내용을 알아보기 어렵게 만들기 위해 부분 단어를 사용할 수 있다는 것입니다. 예를 들어, password 또는 administrator를 검색하는 대신 *sword* 또는 *minis*와 같이 검색할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n## 사용자\n\nAD에서 사용자를 찾는 것은 복잡할 수 있습니다. 특히 도메인이 사용자 이름 대신 사용자명을 사용하지 않을 때는 더욱 그렇습니다. 많은 경우에, 사용자들은 입사할 때 이름과 직접적으로 연결되지 않는 고유한 식별자를 부여받습니다. 사용자를 쿼리할 때 명심해야 할 중요한 점은 컴퓨터 객체도 사용자로 간주된다는 것입니다. 쿼리에 따라 결과에서 컴퓨터를 제외해야 할 수도 있습니다.\n\n이 예에서는 w가 이름에 포함된 모든 사용자 객체를 반환하는 쿼리를 보여줍니다:\n\n![image](/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_6.png)\n\n<div class=\"content-ad\"></div>\n\n\ndsquery * -filter “(&(objectclass=user)(!(objectclass=computer)(name=*W*)))” -attr name samaccountname -d 192.168.88.195\n\n시스템 관리자가 관리 기능과 일상적인 사용을 위한 서로 다른 계정을 가지는 것이 일반적입니다. 이와 같은 쿼리를 사용하면 -sa 또는 -da와 같은 추가 권한을 나타내는 이름을 가진 계정을 찾을 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_7.png)\n\nldapsearch -LLL -x -h DC-THESHIP.PLANETEXPRESS.LOCAL -p 389 -D ‘PLANETEXPRESS\\SService’ -w ‘L1feD3@thSeamlessContinuum’ -b ‘DC=PLANETEXPRESS,DC=LOCAL’ “(&(objectclass=user)(name=*W*))” name samaccountname\n\n\n<div class=\"content-ad\"></div>\n\n이 ldapsearch 예제에서 보듯이 컴퓨터 개체가 사용자와 함께 반환되었습니다. ldapsearch에서 객체를 제외하는 것은 어렵기 때문에 *nix 시스템에서 ! 연산자는 특정한 의미를 갖습니다. 저는 이를 escape 하는데 성공한 방법을 찾지 못했습니다 (\\! 그리고 다른 여러 시도한 것들이 잘못된 필터를 반환했습니다).\n\n## 그룹\n\n그룹을 수동으로 찾고 추적하는 것은 매우 어려울 수 있습니다. 잘 구조화된 AD 환경에서는 세부적인 권한을 갖는 그룹들이 있을 것이며, 사용자들은 작업 요구에 따라 그룹에 배치될 것입니다. 또한, 또다른 복잡성 수준을 추가하는 중첩 그룹을 발견하기도 합니다. 특정 권한을 가진 그룹을 찾는 것은 명명 규칙과 용어를 모르는 경우 어려울 수 있습니다.\n\ndsquery에서는, 그룹 개체 유형을 사용하여 이름별로 그룹을 빠르게 찾을 수 있습니다. 와일드카드 개체 유형을 사용하면 사용자를 찾을 때 필요한 속성이 더 많이 반환됩니다. 아래는 이름에 *admin*이 포함된 그룹이 그룹 개체 유형을 사용하여 나열된 쿼리들입니다. 그런 다음, 그룹 이름에 *admin*이 포함된 그룹을 열거하는 와일드카드 유형을 사용하는 쿼리가 옵니다. 마지막으로, 특정 그룹인 Domains Admins가 선택되고 해당 그룹의 멤버가 (이 경우에는 한 명만) 나열됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_8.png)\n\ndsquery group -name *admin* -d 192.168.88.195\n\ndsquery * -filter “(&(objectclass=group)(name=*admin*))” -attr name samaccountname -d 192.168.88.195\n\ndsquery * -filter “(&(objectclass=group)(samaccountname=도메인 관리자))” -attr name samaccountname member -d 192.168.88.195\n\n\n<div class=\"content-ad\"></div>\n\nldapsearch에서는 구문이 dsquery와 매우 유사합니다. 아래는 이름에 *admin*이 포함된 그룹을 찾는 ldapsearch 구문입니다.\n\n\nldapsearch -LLL -x -h DC-THESHIP.PLANETEXPRESS.LOCAL -p 389 -D ‘PLANETEXPRESS\\SService’ -w ‘L1feD3@thSeamlessContinuum’ -b ‘DC=PLANETEXPRESS,DC=LOCAL’ “(&(objectclass=group)(name=*admin*))” name samaccountname\n\n\n그룹에 대한 운영 참고 사항으로, 목록을 좁힐 때는 적은 속성으로 시작하고 확장하는 것이 좋습니다. 또한 그룹의 설명을 확인하는 것도 좋은 아이디어입니다. 그룹 이름에 사용된 약어나 줄임말에 대한 자세한 내용이 그룹 설명에 포함되어 있는 경우가 많습니다. 그룹 설명에서 약어나 줄임말을 설명하는 경우가 종종 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 컴퓨터\n\n내 경험상, 특정 컴퓨터를 찾거나 그룹 컴퓨터를 찾을 때는 일반적으로 이미 검색을 뒷받침할 정보가 있습니다. 다행히 컴퓨터를 찾는 것은 사용자를 찾는 것보다 쉽습니다.\n\ndsquery에서 컴퓨터 객체 유형이나 와일드카드를 사용할 수 있습니다. 컴퓨터 객체 유형을 사용하면 컴퓨터를 필터링하는 데 사용할 수 있는 여러 옵션이 있지만, 이 블로그에서는 이를 자세히 다루지는 않겠습니다. 와일드카드 객체 유형을 사용하면 출력이나 필터에 운영 체제(operatingsystem 속성)를 추가하는 것이 좋습니다. 이렇게 하면 시스템을 대상으로 선택할 때 매우 유용한 정보를 얻을 수 있습니다.\n\n아래 예시는 dsquery에서 이름에 DC가 포함된 컴퓨터 객체를 검색하는 방법을 보여줍니다. 가정은 도메인 컨트롤러가 환경에 표시되어 있다는 것입니다. 이 환경은 도메인 컨트롤러가 하나뿐이지만, 더 큰 환경에서는 많은 도메인 컨트롤러가 있을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_10.png\" />\n\ndsquery computer -name *DC* -d 192.168.88.195\n\ndsquery * -filter “(&(objectclass=computer)(name=*DC*))” -attr name samaccountname operatingsystem -d 192.168.88.195\n\nLdapquery will be very similar, and again, I recommend adding the operating system attribute to the filter or output.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_11.png\" />\n\n\nldapsearch -LLL -x -h DC-THESHIP.PLANETEXPRESS.LOCAL -p 389 -D 'PLANETEXPRESS\\SService' -w 'L1feD3@thSeamlessContinuum' -b 'DC=PLANETEXPRESS,DC=LOCAL' \"(&(objectclass=computer)(name=*DC*))\" name samaccountname operatingsystem\n\n\n대부분의 쿼리와 마찬가지로, 컴퓨터에 대한 모든 속성을 나열한 후 타겟팅하는 것을 권장합니다. 또한, 컴퓨터의 sAMAccountName은 이름에 $가 추가된 것입니다. 명령행을 사용할 때, 이것이 무슨 일을 하느냐에 따라 문제를 일으킬 수 있습니다.\n\n## 설명\n\n<div class=\"content-ad\"></div>\n\n도메인에서 잠재적인 대상에 대해 자세히 알아보는 좋은 방법은 설명으로 검색하는 것입니다. 종종 약어 및 머릿글이 설명에 나온다는 것을 알면 유용하며, 제한된 정보가 주어졌을 때 도움이 됩니다. 때로는 비밀번호가 설명에 심지어 포함되어 있을 수도 있습니다.\n\n이 쿼리를 위한 필터를 만들 때, 필요한 경우가 아니라면 개체 유형을 명시적으로 지정하지 않습니다. 결과가 조금 더 열리고 예상치 못한 상황이나 설정을 발견할 수 있습니다. 또한, 해당 속성으로 출력하는 설명을 반드시 포함해야 합니다. 왜냐하면 검색 중인 키워드나 구문이 있을 수는 있지만, 도움이 되지 않는 맥락 속에 있을 수도 있기 때문입니다.\n\n다음은 dsquery에서 password와 admin이 설명에 포함된 개체를 검색하는 몇 가지 예시입니다.\n\n![이미지](/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_12.png)\n\n<div class=\"content-ad\"></div>\n\n아래는 표와 동일한 내용을 Markdown 형식으로 작성한 것입니다.\n\n\ndsquery * -filter “(description=*password*)” -attr name description -d 192.168.88.195\n\ndsquery * -filter “(description=*admin*)” -attr name description -d 192.168.88.195\n\n주의할 점은 출력물이 조금 더 길어진다는 점입니다. 이제 같은 쿼리를 ldapsearch로 살펴봅시다.\n\n\n위 내용을 참고해주시고, 필요하시면 질문해주시기 바랍니다.\n\n<div class=\"content-ad\"></div>\n\n\nldapsearch -LLL -x -h DC-THESHIP.PLANETEXPRESS.LOCAL -p 389 -D ‘PLANETEXPRESS\\SService’ -w ‘L1feD3@thSeamlessContinuum’ -b ‘DC=PLANETEXPRESS,DC=LOCAL’ “(description=*password*)” name description\n\n![이미지](/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_14.png)\n\n![이미지](/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_15.png)\n\nldapsearch -LLL -x -h DC-THESHIP.PLANETEXPRESS.LOCAL -p 389 -D ‘PLANETEXPRESS\\SService’ -w ‘L1feD3@thSeamlessContinuum’ -b ‘DC=PLANETEXPRESS,DC=LOCAL’ “(description=*admin*)” name description\n\n\n<div class=\"content-ad\"></div>\n\n상황에 따라서 약어만 주어지고 전체 이름을 알고 싶다면 그 설명에 약어가 나와있지 않을 수 있습니다.\n\n## 비밀번호 마지막 설정\n\npwdLastSet 속성은 대상이 되는 계정을 찾을 때 도움이 될 수 있습니다. 서비스 계정은 때때로 특정 기능에 필요하며 해당 기능에 따라 변경하기 어려울 수 있으므로 오래되고 간단한 암호를 가지고 있을 수도 있습니다. 이는 조직의 암호 정책이 제대로 시행되었는지를 빠르게 확인할 때도 유용합니다.\n\nDsquery 및 ldapsearch는 동일(=)이외의 비교를 허용합니다. 이 경우에는 pwdLastSet 속성이 특정한 양보다 작은 개체를 찾아야 합니다. 이 값은 에포크 시간에 저장돼 있기 때문에 읽기가 어렵습니다.\n\n<div class=\"content-ad\"></div>\n\n비록 이 도메인이 새롭지만, 여전히 dsquery에서 이 쿼리가 어떻게 보이는지 살펴볼 수 있습니다. 단순히 `를 사용한 쿼리는 작동하지 않으므로 `=가 필요합니다.\n\n![image](/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_16.png)\n\ndsquery * -filter “(&(objectclass=user)(pwdlastset`=132655849658851779))” -attr name pwdlastset -d 192.168.88.195\n\nldapsearch에서도 쿼리를 수행할 때 `=를 사용해야 할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_17.png\" />\n\nldapsearch -LLL -x -h DC-THESHIP.PLANETEXPRESS.LOCAL -p 389 -D ‘PLANETEXPRESS\\SService’ -w ‘L1feD3@thSeamlessContinuum’ -b ‘DC=PLANETEXPRESS,DC=LOCAL’ “(&(objectclass=user)(pwdlastset`=132655849658851779))” name pwdlastset\n\n설명: 주로 시간을 얻는 데 관련된 운영 참고 사항이 있습니다. 온라인 변환기를 사용하여 시간을 얻고 변환할 수 있습니다. 또한 PowerShell 또는 Windows 명령 줄 (dsquery 예제에 표시된대로 w32tm.exe /ntte `에포크 시간`)을 사용하여 사람이 읽을 수 있는 버전을 얻을 수도 있습니다. 이전에 언급된 바와 같이, 이것은 클라이언트의 결과를 개선하는 데 확인하는 빠른 확인 사항이 될 수도 있습니다.\n\n## Member Of\n\n\n<div class=\"content-ad\"></div>\n\n멤버오브 속성으로 검색하는 것은 이미 약간의 정보가 있는 경우에 가장 적합합니다. 그룹 멤버십에 기반한 사용자를 찾는 데 매우 도움이 됩니다. 이미 그룹의 이름을 알고 있다면 당연히 속성에 그룹의 구성원을 나열할 수 있습니다. 그러나 필터를 결합하여 여러 그룹의 구성원인지 사용자를 확인할 수도 있습니다. 예를 들어 Domain Admins 및 Server Operators와 같이 여러 그룹의 구성원인 사용자가 있는지 확인할 수 있습니다.\n\ndsquery를 사용하여 그룹의 구성원인 사용자를 쿼리하는 방법은 다음과 같습니다:\n\n\n<img src=\"/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_18.png\" />\n\ndsquery * -filter “(&(memberof=CN=Staff,DC=PLANETEXPRESS,DC=LOCAl)(memberof=CN=ShipCrew,DC=PLANETEXPRESS,DC=LOCAL))” -attr name memberof -d 192.168.88.195\n\n\n<div class=\"content-ad\"></div>\n\n쿼리를 위해 그룹의 완전한 distinguishedName이 필요할 수 있습니다. ldapsearch에서 비슷한 쿼리를 작성할 것입니다.\n\n![image](/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_19.png)\n\n```plaintext\nldapsearch -LLL -x -h DC-THESHIP.PLANETEXPRESS.LOCAL -p 389 -D ‘PLANETEXPRESS\\SService’ -w ‘L1feD3@thSeamlessContinuum’ -b ‘DC=PLANETEXPRESS,DC=LOCAL’ “(&(memberof=CN=Staff,DC=PLANETEXPRESS,DC=LOCAl)(memberof=CN=ShipCrew,DC=PLANETEXPRESS,DC=LOCAL))” name memberof\n```\n\n쿼리 중에 이 정보를 터미널이나 어플리케이션 외부에 저장하는 것이 중요합니다. 쿼리는 많은 공간을 차지할 수 있고 정보를 저장하면 추가 쿼리를 다시 실행할 필요가 없습니다.\n\n<div class=\"content-ad\"></div>\n\n# 옵션들\n\n## Dsquery\n\n쿼리 끝에 추가할 수 있는 여러 옵션이 있습니다. 위 쿼리에서 사용된 옵션들이거나 저가 가장 자주 사용하는 옵션들입니다.\n\n-attr\n\n<div class=\"content-ad\"></div>\n\n이것은 와일드카드 유형으로 사용할 수 있는 속성 필터입니다. -attr *을 사용하면 객체의 모든 속성을 출력할 수 있습니다. 특정 속성을 얻으려면 AD의 속성 이름(예: sAMAccountName, pwdLastSet 등)을 쉼표로 구분된 목록에 사용하면 됩니다. 일반적으로 저는 매우 넓은 범위의 객체 필터로 시작하여 속성을 좁혀 나갑니다. 대상 객체의 목록을 좁히는 동안 속성을 더 개방하여 추가 정보를 얻습니다. 매우 큰 AD 환경에 있을 때, 그리고 사용하는 C2 플랫폼에 따라 실제로 시간을 절약할 수 있습니다. 일반적으로 시작할 때는 아주 넓은 범위의 네트를 던져두고 더 많은 정보를 알게 되면 좁혀나갑니다.\n\n-d\n\n이것은 도메인 플래그이며 큰 도메인 환경에서 작업할 때 매우 유용할 수 있습니다. FQDN 또는 IP 주소로 쿼리할 서버를 지정할 수 있으며 환경이 허용된다면 다른 도메인으로 쿼리하는 데 사용할 수 있습니다. 다른 도메인 컨트롤러를 쿼리하면 흥미로운 데이터 점이 제공될 수 있습니다. 대부분의 데이터가 도메인 컨트롤러 간에 복제되지만 최종 로그인은 항상 복제되지 않는 경우가 있습니다. 특정 사용자 또는 사용자가 마지막으로 로그인한 시간을 찾고 있다면, 인증한 도메인 컨트롤러에 따라 다른 답을 얻을 수 있습니다.\n\n-u -p\n\n<div class=\"content-ad\"></div>\n\n이 두 가지 플래그는 AD 쿼리에 사용할 사용자 이름과 비밀번호를 지정하는 데 사용할 수 있어요.\n\n-limit\n\n큰 도메인에서 작업할 때 유용한 다른 옵션입니다. 기본적으로 dsquery의 결과는 처음 100개로 제한됩니다. 0으로 설정하면 쿼리 결과가 모두 반환됩니다. 제가 이를 운영에 사용하는 다른 방법은 한 번에 결과를 반환하기 전에 리미트를 1로 설정해서 필터와 옵션이 올바르게 설정되었는지 확인하는 것이에요.\n\n## Ldapsearch\n\n<div class=\"content-ad\"></div>\n\nLdapsearch에는 블로그를 작성할 만큼 충분한 옵션이 있습니다. 여기에서 사용되거나 더 유용한 옵션에도 초점을 맞출 것입니다.\n\n- L(L)(L)\n\n이 옵션은 제 모든 ldapsearch 명령어의 시작 부분에 있습니다. 출력에서 일반 LDAP 정보를 제거합니다. 세 가지 레벨이 있으며, 일반적으로 모든 정보를 제거하는 것을 선택하였습니다. 정보를 제거하면 출력물이 더 간결해지기 때문입니다.\n\n- x\n\n<div class=\"content-ad\"></div>\n\n간단한 인증 (즉, 사용자 이름 및 비밀번호)을 사용하므로 Simple Authentication and Security Layer (SASL)이 아닙니다. 이 예시에서는 사용자 이름과 비밀번호를 사용해야 했지만 항상 해당 사례가 아닐 수 있습니다.\n\n-h\n\n질의를 실행할 대상 호스트를 지정하는 데 사용합니다. 예시로 사용된 환경에서는 도메인 컨트롤러가 하나만 있어 일관성이 있었습니다.\n\n-p\n\n<div class=\"content-ad\"></div>\n\n일반적으로 LDAP 서버가 청취하는 포트 번호를 지정하세요. LDAPS의 경우 보통 389 또는 636입니다만, 확인이나 문제 해결 중에는 미리 확인하는 것이 좋습니다.\n\n-D\n\n이는 LDAP 디렉토리에 바인딩할 distinguishedName입니다. -x 옵션을 사용하지 않는 경우 서버는 이 값을 무시할 것입니다.\n\n-w -W -y\n\n<div class=\"content-ad\"></div>\n\n모두 비밀번호 관련 사항입니다. 예제에서 -w를 사용한 이유는 C2를 통해 사용 중이시라면 이것이 필요한 옵션이기 때문입니다. C2를 사용할 때 비밀번호를 입력할 방법이 없는 경우가 많기 때문입니다. 명령을 통해 평문 비밀번호를 보내는 것은 좋은 실천 방법이 아니지만, 비밀번호를 입력할 수 있는 방법이 없으면 쿼리가 완료되지 않을 수 있습니다. 상호 작용하는 경우 -W 옵션을 사용하여 비밀번호를 요청할 수도 있습니다. 또는 비밀번호 파일을 사용할 수 있는 -y 옵션을 사용할 수도 있습니다.\n\n-b\n\n쿼리의 검색 베이스를 지정하는 데 사용됩니다. 일반적으로 도메인에 대한 식별 이름이겠지만 쿼리에 따라 더 세부적으로 좁힐 수도 있습니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n이것은 AD를 질의하는 가장 쉬운 방법도 가장 최적의 방법도 아닙니다. 시작부터 이렇게 말씀드리듯이 BloodHound나 PowerView와 같은 도구들이 이에 더 적합합니다. dsquery나 ldapsearch를 사용해야 하는 상황에 처했을 때, 이 안내서가 여러분이 이러한 쿼리를 어떻게 만들어야 하는지 연구하는 시간을 조금이나마 절약할 수 있도록 도와줄 것입니다. 이 두 도구에 대해서 다뤄야 할 쿼리와 옵션은 훨씬 더 많습니다. 나는 내 자신의 도메인 설정을 마무리하고 이 블로그를 쓰고 정신건강을 유지하려고 노력하는 힘든 경험을 견디고 나면, 추가 정보를 포함한 후속 글을 작성할 수도 있습니다.\n\n여기서 찾고 계신 것을 찾지 못하셨나요? 트위터로 연락 주시거나 SpecterOps에 연락 주세요. 추가 정보를 포함한 후속 블로그가 언젠가 공개될 예정이며, 여러분의 제안을 환영합니다.","ogImage":{"url":"/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_0.png"},"coverImage":"/assets/img/2024-06-20-AnIntroductiontoManualActiveDirectoryQueryingwithDsqueryandLdapsearch_0.png","tag":["Tech"],"readingTime":18},{"title":"윈도우 포렌식 USB 장치 프로파일링","description":"","date":"2024-06-20 14:45","slug":"2024-06-20-WindowsForensicsUSBDeviceProfiling","content":"\n\n# 개요:\n\nUSB 장치 프로파일링은 조사자가 숙지해야 할 전통적인 디지털 포렌식 활동 중 하나입니다. 클라우드 저장소 애플리케이션의 널리 퍼진 사용에도 불구하고, USB는 여전히 악성 소프트웨어 전달 및 데이터 유출 수단으로 사용됩니다. 이 기사에서는 USB를 식별하고, 사용 중일 때 USB와 관련된 모든 활동을 사용자에게 연관시키는 단계를 다룰 예정입니다. 다음은 USB 장치에 대해 알고 싶은 목록입니다:\n\n```js\n1. 제조업체 및 제품 ID\n2. iSerialNumber/ParentIdPrefix\n3. Friendly name, vendor, product, and version\n4. 장치가 처음/마지막으로 연결된 시간\n5. 장치가 마지막으로 제거된 시간\n6. 볼륨 이름\n7. 마지막으로 마운트된 디렉토리 드라이브 문자\n8. 볼륨 GUID, 필요한 경우\n9. 장치와 연관된 사용자 계정\n10. 볼륨 시리얼 번호\n```\n\n# 현재 구성 설정 결정하기\n\n<div class=\"content-ad\"></div>\n\n시스템 하이브에는 시스템 구성 데이터를 저장하는 ControlSet00X라는 키가 있습니다. 컴퓨터를 활용하는 동안, 현재 키의 버전은 CurrentControlSet으로 메모리에 저장되어 오프라인 하이브에 표시되지 않습니다. 올바른 데이터셋을 확인하려면 SYSTEM\\Select\\LastKnownGood를 검사하여 어떤 ControlSet을 조사해야 하는지 결정해야 합니다.\n\n![이미지](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_0.png)\n\n여기에서 LastKnownGood 값이 1로 설정되어 있어 ControlSet001과 작업할 것입니다.\n\n# SYSTEM\\CurrentControlSet\\Enum\\USB\n\n<div class=\"content-ad\"></div>\n\nUSB 키는 장치 유형과 관계없이 외부 장치에 대한 유용한 정보를 저장하는 종합물입니다.\n\n![이미지](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_1.png)\n\n레지스트리 탐색기에는 키를 분석하는 프로세스를 가속화하는 일부 내장 플러그인이 있습니다. USB 키를 살펴볼 때 이 도구는 모든 하위 키에 대한 고수준 정보를 추출하고 위의 스크린샷과 같은 테이블 형식으로 집계합니다. 다음 사항을 보고합니다:\n\n- 타임스탬프: 연결된 하위 키에 대한 마지막 쓰기 시간\n- 하위 키의 이름 (참고: 제조업체 및 제품 ID, VID/PID에 따라 이름이 지정됨)\n- 일련 번호: 이 값은 iSerialNumber이며 장치의 펌웨어에 하드 코딩되어 있습니다.\n- ParentIdPrefix: 이 값은 장치가 USB 연결 SCSI 장치 (UASP)인 경우에만 나타납니다.\n- 서비스: 장치 유형\n- 기타...\n\n<div class=\"content-ad\"></div>\n\nUSBSTOR 장치인 VID_0781 및 PID_5581을 계속 검사할 것입니다. 이전에 VID/PID를 사용하여 USB의 제조사와 모델을 DeviceHunt에서 확인해보세요.\n\n```js\n1. VID/PID: 0781, 5581\n2. iSerialNumber: 0401805d69c0bed0de932277ac861f044d10940c13885d7307a00cd7471423b\n3. 제조사: SanDisk, 제품: Ultra\n```\n\n## SYSTEM\\CurrentControlSet\\Enum\\USB\\VID_0781&PID_5581\n\n레지스트리 탐색기에 의해 보고된 고수준 정보가 유용하게 사용됩니다. 하지만 좀 더 세부적인 정보는 하위 키에 포함되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이전에 언급했듯이 각 장치는 VID와 PID로 식별된 SYSTEM\\CurrentControlSet\\Enum\\USB 하위 키를 생성합니다.\n\n![이미지](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_2.png)\n\n조사 중인 장치를 확장하면 다음 하위 키의 이름으로 장치의 iSerialNumber가 표시됩니다.\n\n![이미지](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_3.png)\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변환되어 있습니다:\n\n![이미지](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_4.png)\n\n$iSerialNumber 키를 검사하면 다음과 같은 추가 정보가 확인됩니다:\n\n- DeviceDesc: 장치는 bulk-only 전송, 대량 저장장치입니다\n- Service: USBSTOR (USB 저장 장치 프로토콜)입니다\n\n![이미지](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n흥미로운 정보 중 상세 정보는 하위 키에서 나옵니다: Properties\\'83da6326–97a6–4088–9453-a1923f573b29'. 여기서는 장치가 처음 연결된 시간, 마지막 연결된 시간 및 시스템에서 마지막으로 제거된 시간을 확인할 수 있습니다.\n\n![이미지 1](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_6.png)\n\n![이미지 2](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_7.png)\n\n![이미지 3](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_8.png)\n\n<div class=\"content-ad\"></div>\n\n```js\n1. VID/PID: 0781, 5581\n2. iSerialNumber: 0401805d69c0bed0de932277ac861f044d10940c13885d7307a00cd7471423b\n3. Vendor: SanDisk, Product: Ultra\n4. First Connect: 2024-06-13, 14:06:41\n   Last Connect:  2024-06-13, 15:22:23\n5. Last Removal Time: 2024-06-13, 20:36:31\n```\n\n## 친환경적인 이름 및 버전 번호 확인\n\n장치의 친환경적인 이름과 버전 번호를 얻으려면 USBSTOR 키 아래를 살펴보면 됩니다. 버전 번호는 HardwareID 값에 있습니다.\n\n![이미지](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_9.png)\n\n<div class=\"content-ad\"></div>\n\n```js\n1. VID/PID: 0781, 5581\n2. iSerialNumber: 0401805d69c0bed0de932277ac861f044d10940c13885d7307a00cd7471423b\n3. Friendly Name: USB SanDisk 3.2Gen 1 USB Device\n   Vendor: SanDisk, Product: Ultra, Version: 3.2Gen1\n4. First Connect: 2024-06-13, 14:06:41\n   Last Connect:  2024-06-13, 15:22:23\n5. Last Removal Time: 2024-06-13, 20:36:31\n```\n\n## 볼륨 정보 확인\n\nSOFTWARE 하이브에서 Windows Portable Devices를 찾아 볼륨 이름을 얻을 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_10.png)\n\n\n<div class=\"content-ad\"></div>\n\n볼륨 GUID를 얻으려면 SYSTEM\\MountedDevices 아래를 살펴볼 수 있습니다.\n\n![이미지](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_11.png)\n\n```js\n1. VID/PID: 0781, 5581\n2. iSerialNumber: 0401805d69c0bed0de932277ac861f044d10940c13885d7307a00cd7471423b\n3. Friendly Name: USB SanDisk 3.2Gen 1 USB Device\n   Vendor: SanDisk, Product: Ultra, Version: 3.2Gen1\n4. First Connect: 2024-06-13, 14:06:41\n   Last Connect:  2024-06-13, 15:22:23\n5. Last Removal Time: 2024-06-13, 20:36:31\n6. Volume Name: New Volume\n7. Last Mount Point/Drive letter: TBD\n8. Volume GUID: {b445a977-284b-11ef-b163-c333a7edd79a}\n```\n\n## 장치가 사용자 계정과 관련이 있는지 확인하기\n\n<div class=\"content-ad\"></div>\n\n이제 우리가 볼륙 GUID를 알았으니 해당 값과 NTUSER 하이브를 교차 참조할 수 있습니다. 이를 위해 MountPoints2 아래를 살펴봐야 합니다.\n\n![image](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_12.png)\n\n볼륙 GUID가 존재하기 때문에 두 가지 중 하나는 반드시 사실일 것입니다:\n\n- 사용자가 장치가 연결된 상태에서 활성으로 로그인되어 있었음\n- 장치가 연결된 시점에서 사용자가 마지막으로 로그인되어 있었음\n\n<div class=\"content-ad\"></div>\n\n어떤 시나리오가 유효한지 확인하려면 시스템의 보안 이벤트 로그를 확인하여 사용자가 로그인한 시간을 판단해야 합니다. 이를 위해 이벤트 ID: 4624/4647 또는 4624/4634 사이의 타임스탬프 차이를 취하여 사용자의 로그인/로그오프 시간을 확인할 수 있습니다. 로긴/로그오프 이벤트에서 LogonID가 일치하는지 확인하세요.\n\n```js\n1. VID/PID: 0781, 5581\n2. iSerialNumber: 0401805d69c0bed0de932277ac861f044d10940c13885d7307a00cd7471423b\n3. Friendly Name: USB SanDisk 3.2Gen 1 USB Device\n   - Vendor: SanDisk, Product: Ultra, Version: 3.2Gen1\n4. First Connect: 2024-06-13, 14:06:41\n   - Last Connect:  2024-06-13, 15:22:23\n5. Last Removal Time: 2024-06-13, 20:36:31\n6. Volume Name: New Volume\n7. Last Mount Point/Drive letter: TBD\n8. Volume GUID: {b445a977-284b-11ef-b163-c333a7edd79a}\n9. User Account Associated w/ the device: Ross\n10. Volume Serial Number: TBD\n```\n\n## 볼륨 일련 번호 가져오기\n\n볼륨 일련 번호(VSN)를 얻으려면 Microsoft-Windows-Partition/Diagnostic.evtx 로그를 참조하고 기기의 마지막 연결 시간을 교차 참조할 수 있습니다. 기억하세요, 레지스트리는 UTC 시간으로 기록하고 이벤트 로그는 로컬 시간으로 기록합니다. 이벤트 로그의 타임스탬프를 올바르게 해석하기 위해 SYSTEM\\CurrentControlSet\\Control\\TimezoneInformation를 확인하세요.\n\n<div class=\"content-ad\"></div>\n\nVSN은 Vbr0에 저장되어 있습니다. 또한, 분석 중인 장치가 NTFS 시스템이기 때문에 VSN을 찾으려면 offset 0x43를 살펴보아야 합니다. 바이트 순서도 잊지 말고, 리틀-엔디안 형식으로 저장되어 있을 겁니다.\n\n![이미지1](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_13.png)\n\n우리는 또한 Partition-4DiagnosticParser라는 오픈 소스 도구를 이용하여 장치의 iSerialNumber를 필터링하는 쉬운 방법을 사용할 수 있습니다.\n\n![이미지2](/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_14.png)\n\n<div class=\"content-ad\"></div>\n\n```js\n1. VID/PID: 0781, 5581\n2. iSerialNumber: 0401805d69c0bed0de932277ac861f044d10940c13885d7307a00cd7471423b\n3. Friendly Name: USB SanDisk 3.2Gen 1 USB Device\n   - Vendor: SanDisk, Product: Ultra, Version: 3.2Gen1\n4. First Connect: 2024-06-13, 14:06:41\n   - Last Connect:  2024-06-13, 15:22:23\n5. Last Removal Time: 2024-06-13, 20:36:31\n6. Volume Name: New Volume\n7. Last Mount Point/Drive letter: TBD\n8. Volume GUID: {b445a977-284b-11ef-b163-c333a7edd79a}\n9. User Account Associated w/ the device: Ross\n10. Volume Serial Number: 306B19C9\n```\n\n## Last Mount Point/Drive Letter Determination\n\n안녕하세요! 장치의 드라이브 문자를 레지스트리에서 확인하지 못했습니다. 그 드라이브 문자는 재사용되었기 때문입니다. 또한 이벤트 로그를 통해 확인할 수 없습니다. 있었던 시간의 이벤트가 덮어써졌기 때문이죠. 하지만 시스템에서 다양한 쉘 항목(예: LNK 파일)을 조사하고 그 중 일치하는 VSN을 포함하는 것이 가능한 접근 방식입니다. 토지 조사 이미지를 촬영할 때 쉘 항목을 복사해 낼 걸 그랬어요. 그때는 레지스트리와 이벤트 로그만 복사했습니다. 제 실수였죠. 여러분의 시스템에서 이를 수행하려면 이미지와 함께 LNK 아티팩트를 추출하는 것을 권장합니다.","ogImage":{"url":"/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_0.png"},"coverImage":"/assets/img/2024-06-20-WindowsForensicsUSBDeviceProfiling_0.png","tag":["Tech"],"readingTime":8}],"page":"55","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}