{"pageProps":{"posts":[{"title":"포인트 클라우드 시각화 및 렌더링을 위한 블렌더 핸드북","description":"","date":"2024-06-22 16:51","slug":"2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering","content":"\n\n## BLENDER\n\n이 튜토리얼에서는 대량의 포인트 클라우드 데이터 세트를 조작하고 시각화하는 데 최고의 3D 도구 중 하나를 활용하는 방법에 대해 채우고자 합니다.\n\n![이미지](/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_0.png)\n\n이 도구는 Blender라고 합니다. 다양한 데이터 시각화 기술을 실험하여 복잡한 분석 시나리오에 대응할 수 있습니다. 그리고 이것이 바로 저희를 함께 모이게 한 이유입니다.\n\n<div class=\"content-ad\"></div>\n\n블렌더의 확장된 데이터 시각화 능력과 결합하여 리얼리티 캡처 데이터셋(포인트 클라우드 형태)을 처리하는 최상의 기본적인 워크플로우는 무엇인가요?\n\n🦊Florent: 리얼리티 캡처는 상당히 혼란스러울 수 있는 \"새로운\" 용어로, 몇몇 소프트웨어와 회사들이 이 용어에서 이름을 딴 것을 알 수 있습니다. 이 \"전문 분야\"를 \"3D 맵핑\"의 특화된 분야로 볼 수 있으며, 목표는 LiDAR나 패시브 카메라(포토그래미터리와 3D 컴퓨터 비전을 통해)와 같은 다양한 센서를 사용하여 실제 세계의 3D 기하학을 캡처하는 것입니다. 이 과정을 보여드리는 기사는 여기에서 확인하실 수 있습니다: 포토그래메트리를 활용한 3D 재구성 가이드\n\n이 가이드에서는 아래에 설명된 9단계의 프로세스로 나누어 설명하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 데이터 시각화를 위한 분석 내용으로 여러 경로 추출 시갠 제품을 생성하도록 해줍니다. 하지만 바로 시작하기 전에, 데이터 시각화에 대해 어떻게 생각하시나요?\n\n🎵 독자분들께: 이 실전 안내서는 UTWENTE의 F. Poux 및 P. Raposo 공동 저자와 함께 작업한 결과물입니다. 트웬테 대학교 ITC 학부에서 부여된 ITC -프로젝트에서 디지털 트윈스로부터의 재정적 기여를 인정합니다. 모든 이미지는 Florent Poux의 저작권 소유입니다.\n\n# 데이터 시각화를 위한 분석\n\n<div class=\"content-ad\"></div>\n\n무언가를 생각할 때 어떤 시각적 표현을 만들어 놓는다고 느끼시나요? 희귀종인 나르월(Monodon monoceros) 같은 것을 언급한다면 이미 알고 있는 \"데이터/지식 점\"이 있다면, 바로 이 '바다의 유니콘'으로 불리는 이 생물의 긴 나선 모양의 엄니를 떠올리게 될 것입니다.\n\n🦊 Florent: 요즘 나르월에 좀 관심을 갖고 있어요 🦄. 직접 본 적은 없지만, 이제 북극 바다인 캐나다와 그린란드 인근으로 가야 이 아름다운 생물들을 발견할 수 있는 기회가 된다는 걸 알았어요. 그들은 '떼'를 이루는 사교적 동물로 발견되며 굉장한 다이빙 능력을 갖고 있다고도 배워요. 1.5분 정도 밑물에 참는다고 해도 행복한데; 나르월은 1,500m(4,921피트) 깊이까지 다이빙 하며 종종 25분 이상 숨을 참을 수 있다고 해요. 정말 멋진 힘이에요!\n\n그리고 이것은 우리에게 얼마나 본능적으로 \"데이터 시각화\"가 중요한지를 보여줍니다. 우리는 강력한 능력을 갖고 있어서 다양한 주제를 시각적으로 지원하여 종합하거나 표현할 수 있어요. 분석 작업의 경우, 아래에 나와 있는 것처럼 이러한 '지원'과 그 범위를 구체화할 수 있습니다.\n\n하지만 더욱 강력한 건 현대 컴퓨팅 시스템을 통해 실제 물체를 나타내는 3D 지오메트리와 속성을 다루는 능력입니다. 실제로, 이것은 우리가 좀더 관련성을 갖고 설정한 목표에 맞는 더 나은 시각화를 만들 수 있도록 하는 필수적인 도구로 작용합니다.\n\n<div class=\"content-ad\"></div>\n\n그리고 중요성에 대해 이야기할 때, 자크 베르탱(1918~2010)에 대해 들어보셨나요? 벨기에 가수 자크 브렐이나 프랑스 전 대통령 자크 시라크, 해군 장교 자크 쿠스토가 아니라 자크 베르탱에 관해 한 번 이야기해 보렐까요?\n\n## 베르탱의 시각 변수\n\n우리가 지리 공간 맥락에 둔 발코니 데이터 시각화에 대해 이야기하는 것은 어려운 일입니다. 그리고 베르탱의 시각 변수를 논하지 않고 싶진 않습니다. 이들은 프랑스 지도 제작자 자크 베르탱에 의해 소개된 기본적인 속성들로, 데이터를 그래픽적으로 나타내는 데 사용될 수 있습니다. 이들은 정보를 시각적으로 명확하고 효과적으로 인코딩하는 방법을 제공합니다. 아래에 이러한 변수들을 요약한 그림이 있습니다.\n\n이 시각 변수들은 매력적인 시각화를 디자인하기 위한 구조화된 프레임워크를 제공합니다. 이러한 변수들을 전략적으로 선택하고 결합함으로써, 우리는 복잡한 정보를 효과적으로 전달하는 시각적 표현물을 만들어 낼 수 있습니다. 이를 통해 시청자가 데이터를 이해하고 해석하기 쉽게 만들어줍니다.\n\n<div class=\"content-ad\"></div>\n\n🦊 플로랑: 내가 너의 마음에 이 작은 씨앗을 심음으로써, 너가 이 글을 읽으면서 다양한 렌더링 옵션들과 놀면서 변수가 데이터 시각화 제품의 목표에 전달되는 메시지에 어떻게 영향을 미치는지에 대해 어떤 평행을 유발할 수 있기를 바란다!\n\n그리고 이제, 더 이상 말미암은 것 없이, 엄청난 시각화를 만드는 시간이다. 준비되었나요?\n\n# 단계 1. 블렌더 환경 설정하기\n\n우리의 환경을 설정하는 것으로 시작해보겠습니다. 이를 위해 브라우저를 열고 Blender를 검색하세요. Blender 웹사이트에 도착하면 다운로드 섹션으로 이동하여 Blender를 다운로드하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*Duf49e4mj8YYS2Bj9S2wJg.gif)\n\nBlender의 버전은 적어도 3.6 이상이어야 합니다. 이 버전은 특히 포인트 클라우드에 대한 몇 가지 조정이 있습니다.\n\n🦊 Florent: 낮은 버전을 사용 중이라면 이 튜토리얼에서 사용할 몇 가지 포인트 클라우드 가져오기 함수를 놓칠 수 있습니다. 그러나 낮은 버전을 사용한다면 함수를 직접 작성할 수 있지만, 이로 인해 이 튜토리얼의 범위가 확장되고 다른 세션에서 보여줍니다. 더 높은 버전인 4.0과 같은 경우에는 과정이 더 간단합니다.\n\nOS에 Blender 3.6.4 이상을 성공적으로 다운로드했다면, 설치를 해보세요. 이 튜토리얼에서는 Windows를 사용하겠지만, Linux나 MacOS에서도 동일하게 작동해야 합니다. Blender를 설치했다면, 두 번째 단계로 넘어가서 3D 포인트 클라우드 데이터셋을 수집할 차례입니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 단계 2. 3D 포인트 클라우드 전처리\n\n우리는 중요한 장면의 포인트 클라우드 데이터를 수집해야 합니다. 오늘은 제가 친구 로만 로브룩과 함께 촬영한 오래된 공장을 가져왔어요. 아래의 안내서는 포토그램메트리와 LiDAR 처리를 사용하여 데이터셋을 얻는 방법을 설명합니다.\n\n데이터 전처리 단계를 돕기 위해, 이미 \"PLY\" 파일 형식으로 준비된 포인트 클라우드 데이터를 제공해드렸어요.\n\n🦚 참고: \"PLY\" 파일 형식은 \"다각형 파일 형식\"을 나타내며 3D 기하학 데이터를 저장하는 데 널리 사용됩니다. 이 형식은 Stanford 대학의 Greg Turk와 Marc Levoy에 의해 개발되었으며 3D 모델을 정점(공간상의 점)과 다각형(일반적으로 삼각형 또는 사각형이지만, 다른 다각형 유형도 사용할 수 있음)의 집합으로 표현할 수 있습니다. 이는 다양하며 각 정점 또는 면과 관련된 데이터 속성 범위를 지원하며 색상, 법선 벡터, 텍스처 좌표 등을 포함할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n포인트 클라우드의 경우, 우리는 얼굴이 없고 점만 가지고 있습니다. 이 점들은 공간에서의 x, y, z 좌표로 정의되는 3D 점들입니다. \"PLY\" 파일을 준비할 때, 각 점이 연관된 하나의 추가 속성(색상)을 가지도록 합니다.\n\n🦊Florent: \"PLY\" 파일은 ASCII 및 BINARY 형식으로 제공됩니다. ASCII PLY 형식은 데이터를 평문으로 표현하여 사람이 읽을 수 있지만 파일 크기가 커질 수 있습니다. BINARY PLY는 이진 인코딩을 사용하여 파일 크기를 줄이지만 사람이 읽을 수 없는 내용을 가지고 있습니다. 양식을 사용하면 파일이 어떤 내용을 포함하고 있는지 빠르게 파악할 수 있으며, 이는 각 정점의 수와 관련된 속성의 유형 등을 나타냅니다.\n\n그러나 데이터셋을 캡처한 후, 추가 단계를 거쳤습니다: 시나리오 내의 구성 요소를 구분하기 위해 비지도 분할 체계를 적용했습니다.\n\n![이미지](/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_2.png)\n\n<div class=\"content-ad\"></div>\n\n초기 장면을 하위 요소로 효율적으로 분할해서 관심 지점을 담고 있는 \"레이어\"로 데이터를 준비할 수 있었어요.\n\n구분된 포인트 클라우드 결과물은 드라이브 폴더에서 찾을 수 있어요. 각 클라우드는 색상이 있는 PLY 파일이에요: [드라이브 폴더](Access to the Drive Folder)에서 확인할 수 있어요. 이 폴더에는 1에서 9까지 번호가 매겨진 아홉 개의 포인트 클라우드가 들어 있어요. 각각이 장면의 일부를 갖고 있어요.\n\n![이미지](/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_3.png)\n\n이 분할된 요소를 사용하기 전에, 전체 포인트 클라우드를 하나의 entity로 내보내기도 했어요. 여기서 다운로드할 수 있어요: [포인트 클라우드 데이터 다운로드](Point Cloud Data Download).\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_4.png)\n\nStep 3 이동 전에 전체 포인트 클라우드 데이터 세트를 다운로드하여 전체 장면을 설정합니다.\n\n# Step 3. Blender에 포인트 클라우드 가져오기\n\n이제 3D 데이터 세트와 Blender가 모두 설치되었으므로 사용할 시간입니다!\n\n\n<div class=\"content-ad\"></div>\n\n🦊Florent: 블렌더 내에서 3D 포인트 클라우드를 가져오는 것은 도전적일 수 있으며, 최상의 및 가장 빠른 방법을 찾는 데 시간이 걸렸어요. 그러나, 적어도 10시간 이상의 복잡한 시행착오를 거칠 필요 없이 작동하는 방법을 발견했답니다. Blender 버전 (3.6.4+)을 사용하면 색상 정보가 포함된 포인트 클라우드를 가져올 수 있게 되었는데, 이전에는 불가능했어요.\n\nBlender 3.6을 실행하려면, 프로그램을 그냥 열어주세요. 안으로 들어가면 작은 팝업 창에 버전 번호가 표시되어 있을 거예요 (제 경우엔 3.6.4로 보였어요). 이 창을 닫으려면 화면 어디든 클릭하세요. Blender에 들어가면 3D 씬 안에 자신을 발견하게 될 겁니다. 이 씬에는 큐브, 카메라, 그리고 빛(보기 어려울 수 있어요)이 포함되어 있어요. 카메라 관점에서 씬을 탐색하려면 휠을 클릭하고 드래그하여 중심 지점 주변을 회전하세요. (카메라를 옆으로 이동시키려면) 휠을 끌면서 Shift 키를 누르세요.\n\n아래와 같이 표시된 바와 같이, 시작하기 전에 큐브를 선택하고, 이 시나리오에 사용되지 않을 것이기 때문에 삭제하세요.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*A8Ih-UvMf1OViKKcwz7k3Q.gif)\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*3Q10Ik1O01ccdsxOVjD0Sg.gif)\n\n그런 다음 `파일`로 가서 “실험적 Stanford .PLY” 옵션을 선택하여 아래와 같이 포인트 클라우드를 가져올 수 있습니다.\n\n🦊Florent [업데이트]: 최신 버전의 Blender 4.0+에서는 비실험적인 Stanford PLY (.ply)를 사용할 수 있습니다. 이제 이 실험적 기능을 통합하고 RGB 정보를 읽을 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n이제 이전에 다운로드한 .PLY 데이터 세트를 가져올 수 있습니다. 파일을 클릭하여 가져오세요. 가져온 후 1500만 점의 포인트 클라우드를 로드하는 데 몇 초만 소요됨을 알 수 있습니다. 세부 사항을 더 잘 확인하려면 휠을 사용하여 회전 및 확대할 수 있습니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*jsj7jy6NgZqnQ9eCFdSlqQ.gif\" />\n\n좋아요, 이 단계에서는 블렌더 내에 포인트 클라우드가 있습니다. 그런데 이제 어떻게 해야 하죠? 블렌더에서 3D 포인트 클라우드를 가장 잘 사용할 수 있는 템플릿 레이아웃을 제공해 드리겠습니다.\n\n# 단계 4. 3D 데이터 시각화를 위한 블렌더 UI 설정\n\n<div class=\"content-ad\"></div>\n\n블렌더 UI를 초기 레이아웃보다 더 잘 정리해 봅시다. 여기서는 조금 기술적이니 충분한 집중력과 에너지가 필요할 거에요!\n\n먼저 Geometry Node Editor를 위로 옮길 거예요. 그런 다음 화면을 두 부분으로 분할할 거에요. 이를 위해 왼쪽 모퉁이에 있는 작은 십자를 클릭하고 드래그할 거에요. 오른쪽에는 우리의 geometries에 재질을 적용하는 Shader Editor를 열거에요. 이미 Properties 메뉴가 열려 있으니 그대로 남겨둘 거에요. 왼쪽에 화면을 늘려 Text Editor와 Python Console을 열 거에요. 이렇게 하면 필요한 모든 것을 손끝에 두게 될 거에요.\n\n🦊 Florent: 그렇습니다! 잘 읽으셨어요! 우리는 Blender 내에서 Python을 사용할 수 있어요! 정말 멋진 기능이죠. 이는 이 튜토리얼의 범위를 넓혀주며 다음 집중 에피소드에서 다룰 예정이에요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*B2Bde5Z9sSLC4oojCbjkgg.gif)\n\n<div class=\"content-ad\"></div>\n\n그럼요, 이제 시작할 준비가 모두 완료되었습니다. 우리는 포인트 클라우드를 성공적으로 로드했지만 모두 검은 색으로 보입니다. 그러나 걱정하실 필요는 없어요. 곧 이 문제를 해결할 거에요. 중요한 점은 이제 카메라, 메시 및 광원이 포함된 씬 콜렉션을 갖고 있다는 것입니다.\n\n메시를 클릭하면 각 벡터의 위치 및 RGBA 또는 투명도 정보를 가진 16.3백만 개의 벡터를 포함하는 스프레드시트 뷰어에서 확인할 수 있습니다.\n\n현재 모든 포인트는 재질이 없기 때문에 메시가 검은색으로 보입니다(또는 선택한 경우 주황색으로 나타날 수 있습니다).\n\n우리의 목표는 이 메시 객체를 포인트 클라우드 객체로 변환하고 각 포인트의 색상을 읽는 것입니다. 이를 위해 지오메트리 노드를 생성할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n🦊Florent: 간단히 적어둡니다. Control+C 및 Control+V와 같은 키보드 바로 가기는 마우스 위치에만 작동합니다. 특정 영역에서 무언가를 복사하고 붙여넣기하려면 마우스가 해당 영역에 있는지 확인하세요.\n\n# 단계 5. 3D 도형을 위한 Geometry 노드\n\nBlender의 Geometry 노드는 사용자가 3D 지오메트리를 절차적으로 생성하고 조작할 수 있도록 2.93 버전에서 소개된 강력한 기능입니다. 이는 개별 정점, 에지 또는 면을 수동으로 조작하지 않고도 복잡한 3D 지오메트리를 생성, 수정 및 애니메이션화할 수 있다는 것을 의미합니다. 실제로 노드 기반 절차적 워크플로우 덕분에 전통적인 모델링 기술 대신 시각적 인터페이스를 사용하여 지오메트리를 생성하고 편집할 수 있습니다. 이제 이것을 3D 포인트 클라우드로 시험해보겠습니다.\n\n먼저 메시를 선택한 후 Geometry 노드 창으로 이동해야 합니다. 거기서 \"New\"를 클릭하여 지오메트리 노드를 생성합니다. 이를 간단히 설명하겠습니다. 그것은 geometry라는 두 개의 그룹 입력과 출력으로 구성됩니다.\n\n<div class=\"content-ad\"></div>\n\n\"지오메트리를 수정하기 위해 \"메쉬를 포인트로\" 노드를 추가할 거에요. 추가하면 노드가 자동으로 연결되어, 마법같은 일이 일어날 거예요. 모든 포인트에는 공 모양의 지오메트리가 부착되고, 각 공의 반지름을 0.01 (1센티미터)로 설정하여 수정할 수 있어요. 보시다시피, 모든 포인트가 노드에 표시돼 있어요.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*7Ycq0Rlt2b1TT712hE7xtA.gif\" />\n\n정말 멋지죠, 하지만 한 가지 문제가 있어요 - 이 모드에서는 색상을 볼 수 없어요. 걱정하지 마세요, 이건 정상이에요! 블렌더에는 쉐이딩, 솔리드, 소재 미리보기, 그리고 렌더링 표시 미리보기와 같은 다양한 디스플레이 모드가 있어요. 우리는 와이어프레임이 없기 때문에 (메쉬가 아니기 때문에), 거기를 클릭하면 벡터(포인트)만 표시될 거예요. 우리가 솔리드 렌더링을 보려면 적절한 디스플레이 모드를 선택해야 해요.\n\n<img src=\"/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_6.png\" />\"\n\n<div class=\"content-ad\"></div>\n\n렌더링된 디스플레이 미리보기는 재질을 설정한 후에 작동합니다. 하지만 우리는 아직 재질을 하나도 가지고 있지 않기 때문에 작동하지 않습니다. 따라서 논리적으로 다음 단계는 각 포인트에 재질을 부착하는 것입니다.\n\n# 단계 6. 색상을 위한 쉐이더 노드\n\nGeometry Nodes에 해당하는 것으로 Shader Nodes가 있습니다. 이들은 Blender의 재료 시스템의 기본 구성 요소입니다. 서로 다른 노드를 연결함으로써 복잡한 재료를 만들 수 있습니다. 각 노드는 재료의 외관을 나타내는 특정 측면을 대표합니다.\n\n재질은 물체가 빛과 상호 작용하는 방식을 결정하여 외관을 부여합니다. Shader Nodes는 Shader Editor에서 편집됩니다. 이는 Blender 내에서 전용 워크스페이스로, 노드를 사용하여 재료를 만들고 편집하는 시각적 인터페이스를 제공합니다. 이제 시작해보죠.\n\n<div class=\"content-ad\"></div>\n\nShader Editor에서 \"새로운 재질\"을 만듭니다. \"새로 만들기\" 버튼을 클릭하여 'material.001'이라는 이름의 재질을 만들 수 있습니다. 이 재질에는 주요 BSDF와 재질 출력이 포함되어 있습니다. 그러나 사용하기 위해서는 몇 가지 속성을 추가해야 합니다. 속성을 추가하기 위해 \"추가\" 버튼을 클릭하고 \"속성\" 옵션을 찾습니다. 그런 다음 컬러 매개변수를 선택하고 이를 우리의 주요 BSDF의 베이스 컬러 매개변수에 연결합니다.\n\n🦊 Florent: BSDF는 양방향 산란 분포 함수를 나타냅니다. 결국에는 특정한 광선이 주어진 각도에서 반사(산란)될 확률을 결정하는 수학적인 함수입니다.\n\n다음 단계는 색상에 대한 올바른 속성을 읽고 설정하는 것입니다. 스프레드시트 뷰에서는 더 이상 메쉬가 아닌 \"Col\" 속성이 있는 포인트 클라우드 유형으로 나타납니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_7.png\" />\n\n따라서 쉐이더 편집기 필드에서 그 이름(\"Col\")을 사용해야 합니다. 이 단계 이후에는 아무 변화가 없는 것처럼 보일 것입니다. 이는 우리가 추가할 두 가지 요소(포인트 클라우드에 재료 설정 및 렌더링 엔진 설정)가 아직 남아 있기 때문에 예상된 동작입니다. 재료 설정부터 시작해봅시다.\n\n## 포인트 클라우드 지오메트리 노드에 재료 추가하기\n\n우리의 지오메트리에 새 재료를 부착하려면, \"Set material\"이라는 새로운 노드를 지오메트리 노드에서 만들어야 합니다. 이 과정은 간단합니다. 노드를 가운데에 놓으면 자동으로 간격을 맞출 것입니다. 그러고나서 드롭다운에서 재료를 선택하면 끝입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*Ph-9AagMnvT_HvdXcdv0wQ.gif)\n\n이게 전부에요. 이제 두 번째 문제를 해결하는 데로 넘어가 봅시다: 3D 포인트 클라우드를 위한 적절한 렌더링 엔진을 설정하세요.\n\n## 3D 포인트 클라우드를 지원하는 렌더링 엔진 설정\n\n해당 단계를 완료했다면 여전히 화면에 아무것도 보이지 않아서 답답할 수 있습니다. 포인트 클라우드를 다루고 있기 때문에 특정 유형의 후처리 렌더러 인 Cycles가 필요합니다.\n\n\n<div class=\"content-ad\"></div>\n\n🦊 Florent: 싸이클(Cycles)은 Blender에서 사용되는 렌더링 엔진으로 현실적인 이미지를 생성하는 데 사용됩니다. 이는 빛의 행동을 시뮬레이션하는 패스 추적 렌더러로, 반사, 굴절, 그리고 전체 조명 같은 복잡한 효과를 가능하게 합니다. 싸이클은 고품질 출력으로 유명하며 Blender에서 사실적인 장면을 만드는 데 널리 사용됩니다. 저는 정말 좋아해요.\n\n싸이클로 전환하려면 속성 영역으로 이동하고 렌더 탭을 클릭하세요. 기본 렌더 엔진은 Eevee라고 불리지만, 이를 싸이클로 변경해야 합니다. 한 번 변경하면 다른 설정을 수정할 필요는 없지만, 과도한 렌더링 시간을 피하기 위해 30초의 시간 제한 설정을 권장합니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*2YlfnGW6IYTLs2C07j8fGQ.gif)\n\n이제 렌더러를 설정했으므로 최종 결과물을 보기 위해 미리보기 렌더링을 클릭할 수 있습니다. 결과가 마음에 들지 않는다면 재미있는 상황이네요. 하하, 그것은 함정이었어요!\n\n<div class=\"content-ad\"></div>\n\n시각적으로 조명이 필요합니다! 재료가 빛에 반응하는 효과를 얻기 위해 장면에 조명을 추가해야 합니다. 준비되셨나요?\n\n# 단계 7. 3D 장면 조명 및 렌더링 설정\n\nBlender에서 조명은 장면을 현실적으로 조명하기 위해 조명 소스를 배치하고 구성하는 것을 의미합니다. 포인트, 스폿, 선, 영역, 및 방출 소재와 같은 다양한 유형의 조명을 시뮬레이션할 수 있습니다. 뿐만 아니라, 조명의 세기, 색상, 감쇠 및 그림자 속성을 조절할 수도 있습니다. 현실 세계에서 빛이 어떻게 작용하는지 이해하고 이러한 설정을 실험하는 것은 Blender에서 강렬한 시각적 결과를 얻는 데 중요합니다. 그러므로 저는 장면에서 다양한 기하학 및 조명 소스를 다루는 데 도움을 드리겠습니다.\n\n먼저, 조명을 선택하고 움직이기 아이콘을 클릭하여 원하는 위치로 정확히 이동시킵니다. 이렇게 하면 모든 것이 부드럽고 더 현실적으로 보이게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![](https://miro.medium.com/v2/resize:fit:1400/1*_CNOkMDpuqilMNLkjkKJcQ.gif)\n\n🦊 Florent: 신이 가려진 장면의 경우에도 빛을 배치하여 더 아름답게 보이게 할 수 있어요. 우리는 조명을 베이크된 색상 위치에 배치함으로써 탁월한 사실적인 효과를 얻을 거에요.\n\n빛을 배치한 후, 나는 특정 각도에서 장면을 보기 위해 뷰포트 렌더링을 클릭해요. 그리고 이제.... 타다! 전체 장면이 렌더링되어 놀라운 것처럼 보여요.\n\n![](https://miro.medium.com/v2/resize:fit:1400/1*_RuwKTykijg3v-VhZ4uISQ.gif)\n\n\n<div class=\"content-ad\"></div>\n\n거기서는 이미 하얀색인 점들에 대한 빛 효과를 수정할 수 있어요. 빛을 움직이면 실시간으로 변화를 관찰할 수 있어요.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*V3x1j0z6cu7gequS7LUYpg.gif)\n\n이 흥미진진한 기능은 3D 포인트 클라우드 데이터를 메싱 단계를 거치지 않고 직접 사용할 수 있게 해줘요. 노력을 많이 들이지 않고 일관된 시간 프레임 내에서 기본으로 사용할 수 있어요. 이 마일스톤을 달성하여 축하드려요! 다음 단계는 아직 남아 있어요.\n\n# 단계 8. 스토리보드 정의\n\n<div class=\"content-ad\"></div>\n\n좋아요, 이제 무거운 주제에 들어가 봅시다. 이 새로운 기술 세트를 구체적인 응용 프로그램에 사용해 보겠습니다: 추출 경로 계획.\n\n![이미지](/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_8.png)\n\n여기가 간략한 설명입니다. 산업 연구원이 알려준 독특한 유물을 회수하기 위해 추출팀을 이끄는 중입니다. 이 고대 유물은 양 제조 공정에 대한 새로운 비밀을 밝히는 데 중요하며, 전 세계 산업 공정을 뒤집을 수 있는 가능성이 있습니다. 문제는 해당 사이트가 매우 오염되어 있으며 목표물을 회수할 시간이 60초 밖에 없다는 것입니다.\n\n당신의 연락망 덕분에 그곳의 3D 스캔 자료를 손에 넣었고, 이제 추출의 성공을 보장하기 위한 최적의 네비게이션 지도를 작성할 차례입니다. 이를 달성하기 위해 최초로 추출 계획에 포함해야 할 다섯 가지 주요 포인트를 포함한 명세서를 설정했어요:\n\n<div class=\"content-ad\"></div>\n\n- 초기 포인트 클라우드의 다양한 (3-5) 관점 뷰\n- 관심 대상의 다양한 돋보인 객체로 아티팩트의 상대적인 공간 안에 잘 배치\n- 객체를 추출하기 위한 정확한 \"강조\" (원뿔)\n- 추출 경로 정의, 위쪽에서 본 보기\n- 추출 경로의 다양한 시점을 퍼스트-퍼슨으로 본 뷰\n\n데이터 시각화 전문가로서, 자크 베르탱의 작업을 회상하고 시각 변수를 활용하여 명확한 커뮤니케이션 지원을 달성하는 데 최선을 다해보세요.\n\n# 단계 9. 3D 씬 추출 경로 계획\n\n프로세스를 시작하기 전에, 제 Step 2 (포인트 클라우드 사전 처리)에서 분해된 하위 요소들을 다운로드하는 것을 권장합니다. 그런 다음, 모든 포인트 클라우드를 로드하고 위에서 언급한 단계를 따라 각 포인트 클라우드를 다음과 같이 얻을 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_9.png\" />\n\n🦊Florent: 작업 속도를 높이기 위해 몇 가지 권장 사항을 안내해드릴게요. 먼저, 포인트 클라우드를 가져오기 전에 Scene Collection 메뉴에서 새 컬렉션을 만드세요 (우클릭 `새 컬렉션`), 그 안에 모든 포인트 클라우드를 끌어다 놓을 거에요. 가져오고 나면 전체 포인트 클라우드를 선택한 후 Geometry Node Editor에서 Geometry Nodes를 복사하세요. 그런 다음 로드된 모든 포인트 클라우드를 순차적으로 선택하여 새 Geometry Node를 만들고 미리 채워진 것을 지우고 \"템플릿\"을 붙여 넣으세요. 이를 모든 포인트 클라우드에 대해 반복하면 준비 완료입니다.\n\n준비되셨으면 명세서 항목 목록을 진행할 수 있어요\n\n## 1. 포인트 클라우드 렌더링\n\n<div class=\"content-ad\"></div>\n\n다양한 관점을 생성하기 위해서는 장면을 탐색하여 교차점을 명확히 보여줄 수 있는 최적의 장소를 찾아야 합니다. 예를 들어 먼저 아래에 표시된 대로 다양한 장소에 조명을 추가해야 할 수도 있습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*G1CAE69MWwZslrCOVymaUA.gif)\n\n이 작업을 완료하고 만족스러운 시점을 찾았다면 현재 시점을 카메라 위치로 사용하는 방식으로 Ctrl + Shift + 0을 눌러 카메라를 배치해야 합니다.\n\n🧙‍♂️ 전문가: 카메라 설정을 조정하고 싶다면 초점 거리(Focal Length)를 변경하여 할 수 있습니다. 아래 그림에서처럼 저는 25mm 초점 거리를 사용했습니다. 또한 점의 반경도 독립적으로 조절할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n거기서 Render Image 탭 버튼을 누르면 현재 카메라 위치에서 이미지를 내보낼 수 있습니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*9afTGK9vyFB7zGJ1lxhU2w.gif)\n\n좋아요, 이제 우리는 주변 상황의 주요 아이디어를 갖고 있어요. 가스로 가득 찼어요! ☣️\n\n## 2. 관심 대상\n\n<div class=\"content-ad\"></div>\n\n목표는 테이블 위의 의자, 가스 탱크, 양털 기계 및 목표물을 강조하여 공간과 목표를 보다 명확하게 전달하는 것입니다. 자크 베르탱의 작업을 따라 가능한 조정할 수 있는 매개변수를 조정할 수 있습니다. 저는 각 개별 객체에 부여한 기본 색상으로 새로운 소재를 만들었습니다:\n\n![각 객체에 대해 이렇게 함으로써 우리는 시선을 더 잘 이끄는 렌더를 생성할 수 있습니다:](/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_10.png)\n\n각 개체에 대해 이렇게 하면 눈을 더 정확히 이끌 수 있는 렌더를 생성할 수 있습니다:\n\n![각 객체에 대해 이렇게 함으로써 우리 눈을 더 잘 이끌 수 있는 렌더를 생성할 수 있습니다:](/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_11.png)\n\n<div class=\"content-ad\"></div>\n\n🌱 성장 중: 전달된 메시지를 어떻게 개선할 수 있을까요? 변수 조정(색상)의 선택이 타당하다고 생생하십니까?\n\n## 3. 추출 대상 강조\n\n멋지네요! 여기서부터, 관심 대상에 더 많은 강조를 더하고 싶어합니다. 다시 말씀드리지만, 가능성은 많습니다. 저희는 눈에 뷰 가이드 역할을 하는 3D 원뿔 메시를 사용하는 방법을 안내해 드리겠습니다.\n\n우선, 원뿔 메시 오브젝트를 생성해야 합니다. '메쉬' - '원뿔 추가' 옵션으로 이동하여 씬의 중심에 원뿔 메시를 생성할 수 있습니다. 그 다음, 해당 원뿔을 선택한 후, 크기를 조절하고 왼쪽에 있는 버튼을 사용하여 회전시키십시오. 마지막으로, 아래에 표시된 대로 목표물 위에 오브젝트의 위치를 변경하고 재료를 부여하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*73JNEOXDwlsNfg2M6xqIwg.gif)\n\nFrom these steps, and after creating a render from a camera position, you should get something looking like this:\n\nBeautiful! It's time to get onto the extraction route.\n\n## 4. Top-down Extraction Route\n\n\n<div class=\"content-ad\"></div>\n\nGrease Pencil을 사용하면 마우스로 그림을 그릴 수 있어요. 올바르게 사용하려면 먼저 `Grease Pencil`을 추가해야 해요. 그 다음 \"Top View\"로 이동해서 \"Draw Mode\"를 눌러 경로를 그릴 수 있어요. 경로를 그린 후에는 Object Mode로 돌아가서 그리스 경로를 적절한 위치로 이동시켜야 해요. 아래 이미지를 참고해주세요.\n\n![그림1](https://miro.medium.com/v2/resize:fit:1400/1*HYgQi-DuB38Piisdo1Y9IQ.gif)\n\n마지막 단계는 경로에 색상을 추가하기 위해 그리스에 텍스처를 추가하는 거에요:\n\n![그림2](https://miro.medium.com/v2/resize:fit:1400/1*mE_t1JPB6wJvlHk8ECXSzQ.gif)\n\n<div class=\"content-ad\"></div>\n\n여기 있습니다. 우리는 추출 경로의 매력적인 전경을 얻기 위해 렌더링을 실행합니다!\n\n![image](/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_12.png)\n\n## 5. POV 추출 경로\n\n마지막 단계는 경로의 일인칭 시점을 얻는 것입니다. 만약 직접 렌더링을 한다면, 다음과 같은 결과물이 나올 것입니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_13.png\" />\n\n사실 그리스 펜슬에는 깊이 테스트가 없습니다. 여기서 또 다른 꿀팁을 알려드릴게요. Z-깊이 테스트를 활성화하려면 ` 에디터 패널 ` 뷰 레이어 속성 ` 패스 -` 데이터로 이동하여 Z를 활성화하세요.\n\n<img src=\"/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_14.png\" />\n\n이렇게 하면 렌더를 다시 생성할 때 가려지는 부분 테스트를 통과할 수 있어서 포인트 클라우드를 처리하는 데 훌륭합니다!\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이것은 계속해서 발전하는 여정이었습니다! 우리는 블렌더에서 3D 포인트 클라우드를 통합하고 처리하는 과정을 분석했습니다. 포인트 클라우드 데이터의 가져오기와 내보내기부터 씬 설정과 렌더링의 복잡성까지 세심하게 다루며, 블렌더의 기능의 복잡성을 탐험하고 3D 시각화와 렌더링의 전체 잠재력을 활용할 수 있게 되었습니다.\n\n지금까지 따라오면서, 블렌더에서 포인트 클라우드 데이터를 다루는 프로젝트에 자신감을 갖고 해결할 수 있는 지식과 기술을 얻었습니다. 이를 통해 3D 작업에서 창의성과 정밀도에 대한 새로운 가능성을 열 수 있게 되었습니다.\n\n🦊 플로랑: 블렌더의 강력한 도구와 새로운 전문 지식을 바탕으로, 몰입감 있고 고품질의 실내 시각화를 위한 가능성이 이제 여러분 손안에 있습니다. 그래서 이 안내서를 들고 자신감 있게 여러분의 다음 3D 여정에 돌입해보세요. 원시 포인트 데이터를 멋진 시각적 표현으로 변환할 수 있다는 것을 인지하며, 행복한 블렌딩이 되길 바랍니다!\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료\n\n- Poux, Florent, Valembois, Q., Mattes, C., Kobbelt, L., & Billen, R. (2020). Initial user-centered design of a virtual reality heritage system: Applications for digital tourism. Remote Sensing, 12(16), 2583. [DOI](https://doi.org/10.3390/rs12162583)\n- Poux, Florent, Neuville, R., Van Wersch, L., Nys, G. A., Billen, R., Van Wersch, L., … & Billen, R. (2017). 3D Point Clouds in Archaeology: Advances in Acquisition. Processing and Knowledge Integration Applied to Quasi-Planar Objects, 96. [DOI](https://doi.org/10.3390/geosciences7040096)\n\n![이미지](/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_15.png)\n\n# 🔷기타 자료\n\n<div class=\"content-ad\"></div>\n\n- 🍇 데이터에 액세스하려면 여기를 방문하세요: 3D 데이터셋\n- 👨‍🏫 3D 온라인 데이터 과학 코스: 3D 아카데미\n- 📖 3D 자습서의 초기 액세스를 위해 구독하세요: 3D AI 자동화\n- 🧑‍🎓 석사 학위 취득: ITC Utwente\n\n# 🎓작가의 추천\n\n데이터 획득부터 가상 투어 생성까지 엔드 투 엔드 시스템을 구축하려면, 여기서 제공된 이전에 게시된 기사를 살펴보십시오. 데이터 처리에 사용되는 방법을 보여주는 것도 포함돼 있습니다. 즐거운 기술 습득되길 바랍니다!","ogImage":{"url":"/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_0.png"},"coverImage":"/assets/img/2024-06-22-TheBlenderHandbookfor3DPointCloudVisualizationandRendering_0.png","tag":["Tech"],"readingTime":19},{"title":"위성 열 영상을 1000m에서 10m로 다운스케일링하는 방법 Python","description":"","date":"2024-06-22 16:48","slug":"2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython","content":"\n\n![image](/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_0.png)\n\n# 목차\n\n- 🌅 소개\n- 💾 Sentinel-3 (1000 m) 및 Sentinel-2 이미지 다운로드\n- ⚙️ Sentinel-3 이미지 처리\n- 🌡️ 온도-NDVI 공간\n- 📐 열화상 이미지 선명화 (1000 m에서 10 m)\n- 🗺️ 선명화된 열화상 이미지 시각화\n- 📄 결론\n- 📚 참고 자료\n\n## 🌅 소개\n\n<div class=\"content-ad\"></div>\n\n위성에서 촬영한 열화상 이미지를 축소하는 연구는 열화상 이미지를 제공하는 위성들의 공간 및 시간 해상도 사이의 상충 관계 때문에 광범위하게 연구되었습니다. 예를 들어, Landsat-8의 재방문 주기는 16일이며, 원래 열 해상도는 100미터입니다. 반면에 Sentinel-3은 매일 열화상 이미지를 제공할 수 있지만, 공간 해상도는 1000미터입니다.\n\n![이미지](/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_1.png)\n\n열화상 이미지의 굵은 해상도를 해결하는 한 가지 방법은 NASA의 Landsat-9와 같은 열 센서가 장착된 추가 위성을 발사하는 것일 수 있습니다. Landsat-9의 경우, Landsat-8과 Landsat-9의 임시 해상도는 8일입니다 (하나의 위성보다는 16일), 맑은 하늘을 전제로 할 때.\n\n그러나 이 접근 방식은 수십억 달러의 투자와 몇 년의 노력이 필요합니다. 대신, 연구자들은 통계적 방법에 집중하여, 공간 해상도는 높지만 임시 해상도는 낮은 위성의 시정/근적외선 (VNIR) 밴드를 열화상 이미지와 상관시킴으로써 열화상 이미지의 낮은 공간 해상도 (하지만 높은 임시 해상도)와 연관시키는데 초점을 맞추었습니다. 예를 들어, 연구들은 Sentinel-2의 VNIR 밴드로부터 계산된 정규화 된 차이 채취 지수 (NDVI)가 Sentinel-3의 열화상 이미지와 역 상관 관계가 있음을 보여주었습니다.\n\n<div class=\"content-ad\"></div>\n\n답변을 요약하면 Sentinel-2의 NDVI와 Sentinel-3의 열화상 이미지 간의 상관 관계가 충분히 강하다면, 해당 방정식을 10m 해상도로 조정하여 10m 해상도의 열화상 이미지를 생성할 수 있습니다.\n\n위성 대역과 센서 스펙트럼에 대해 자세히 알고 싶다면 다음을 참조하십시오:\n\n이 게시물에서는 Sentinel-3로부터 낮은 공간 해상도 열화상 이미지와 Sentinel-2로부터 높은 공간 해상도 VNIR 이미지를 다운로드할 것입니다. 이 두 이미지는 각각의 위성에 의해 동시에 촬영되었습니다. 그런 다음, VNIR 대역을 사용하여 NDVI를 계산하고((NIR-Red)/(NIR+Red)), 이를 1000m로 업스케일하고 NDVI와 열대 대역 간의 상관 관계(둘 다 1000m 해상도)를 탐색할 것입니다. 마지막으로, 이 상관 관계를 사용하여 10m 해상도의 온도 지도를 생성할 것입니다.\n\n## 💾 Sentinel-3(1000 m) 및 Sentinel-2 이미지(10 m) 다운로드\n\n<div class=\"content-ad\"></div>\n\n이미 R 및 Python에서 Sentinel-2 이미지를 다운로드하는 방법에 대해 세 번의 게시물을 작성했습니다. 또한 Python에서 Sentinel-3 이미지를 다운로드하는 방법에 대한 게시물도 있습니다. 이곳에서는 해당 단계들을 반복하고 싶지 않아서 이 게시물을 참조하시기 바랍니다:\n\nR에서 Sentinel-2 이미지 다운로드:\n\nPython에서 Sentinel-2 이미지 다운로드:\n\nPython에서 Sentinel-3 이미지 다운로드:\n\n<div class=\"content-ad\"></div>\n\n만약 코드를 작성하지 않고 이미지를 다운로드하고 싶지 않다면, 다음 게시물을 확인해보세요:\n\n열화상 이미지를 축소화하기 위한 통계적 방법을 적용하는 중요한 단계는 위성에서 동시에 촬영된 선명한 이미지를 찾는 것입니다. 이미지를 다운로드하기 전에 날짜, 구름 양, 그리고 귀하의 관심 지역(AOI)에 기반하여 메타데이터를 필터링할 수 있습니다. Sentinel 메타데이터(관심 지역, 구름 양 등)를 필터링하고 처리하는 방법을 더 알고 싶다면 다음을 참조해보세요:\n\n이 게시물에서, 제 관심 지역(AOI)는 캘리포니아에 위치하며, 2023년 6월 19일에 Sentinel-2 및 Sentinel-3로 촬영된 선명한 이미지를 발견했습니다. 다른 위치나 날짜를 검색하고 싶다면 자유롭게 찾아보세요. 그러나 제가 다운로드한 이미지를 사용하길 원한다면, 다음 정보가 있습니다:\n\nSentinel-2: S2B_MSIL2A_20230620T183919_N0509_R070_T10SFG_20230620T224951\n\n<div class=\"content-ad\"></div>\n\n\nsatellite = “SENTINEL-2”\n\nlevel = “S2MSI2A”\n\nAOI = “POLYGON ((-121.0616 37.6391, -120.966 37.6391, -120.966 37.6987, -121.0616 37.6987, -121.0616 37.6391))”\n\nstart_date = “2023–06–19” ; end_date = “2023–06–21”\n\n\n<div class=\"content-ad\"></div>\n\n\nsatellite = “SENTINEL-3”\n\nlevel= “LST”\n\nAOI = “POLYGON ((-121.0616 37.6391, -120.966 37.6391, -120.966 37.6987, -121.0616 37.6987, -121.0616 37.6391))”\n\n\n<div class=\"content-ad\"></div>\n\nstart_date = “2023–06–19” ; end_date = “2023–06–21”\n\nSentinel-2에서 NIR 및 레드 밴드(NDVI를 계산하는 데 필요한 밴드)를 10m로 다운로드한 후 Sentinel-3에서 열화상 이미지를 다운로드하면 디렉토리에 이 세 파일이 있어야 합니다:\n\n![Image](/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_2.png)\n\n## ⚙️ Sentinel-3 이미지 처리\n\n<div class=\"content-ad\"></div>\n\nSentinel-3 이미지는 Sentinel-2보다 훨씬 넓은 장면을 커버합니다. 따라서 Sentinel-3 각 픽셀의 평균 NDVI 값을 필요로 하므로 Sentinel-3 이미지를 Sentinel-2 이미지의 범위에 따라 클리핑해야 합니다. 이를 위해 첫 번째 단계는 Sentinel-3 이미지를 Sentinel-2 이미지와 동일한 투영으로 재매핑하는 것입니다. 이를 수행하기 위해 다음과 같은 코드를 사용할 수 있습니다:\n\n```js\nimport numpy as np\nimport rasterio\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\nfrom pyproj import Transformer\n\ninput_raster = 'Sentinel-3_L2_LST_reproj.tif'\noutput_raster = 'Sentinel-3_L2_LST_reproj_32610.tif'\ndst_crs = 'EPSG:32610'\n\n# 입력 래스터 파일 읽기\nwith rasterio.open(input_raster) as src:\n    # 목적지 CRS에 대한 변환, 너비 및 높이 가져오기\n    transform, width, height = calculate_default_transform(src.crs, dst_crs, src.width, src.height, *src.bounds)\n\n    # 목적지 설정\n    kwargs = src.meta.copy()\n    kwargs.update({\n        'crs': dst_crs,\n        'transform': transform,\n        'width': width,\n        'height': height,\n        'dtype': np.float32,\n    })\n\n    # 목적지 생성 및 재매핑된 데이터 작성\n    with rasterio.open(output_raster, 'w', **kwargs) as dst:\n        # 재매핑 수행\n        for i in range(1, src.count + 1):\n            reproject(\n                source=src.read(1).astype(np.float32) * src.scales[0] + src.offsets[0],\n                destination=rasterio.band(dst, i),\n                src_transform=src.transform,\n                src_crs=src.crs,\n                dst_transform=transform,\n                dst_crs=dst_crs,\n                resampling=Resampling.bilinear)\n```\n\n이 스크립트에서는 이전 단계에서 다운로드한 Sentinel-3 래스터 이미지를 읽고, 지정된 CRS로 재매핑하기 위한 변환 매개변수를 계산하고, 재매핑된 데이터를 포함한 새로운 래스터 파일을 내보냅니다. 이러한 단계를 거치면 디렉토리에 다음 네 가지 파일이 있어야 합니다:\n\n![image](/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_3.png)\n\n\n<div class=\"content-ad\"></div>\n\nSentinel-3 열화상 이미지가 Sentinel-2 좌표 시스템으로 변경되었으므로 이제 Sentinel-2 데이터 범위를 기반으로 열화상 이미지를 잘라내는 작업을 할 수 있습니다. 아래 코드를 사용하여 작업할 수 있어요:\n\n```js\nimport rasterio\nimport numpy as np\n\n# 두 래스터 파일 열기\nwith rasterio.open('T10SFG_20230620T183919_B08_10m.jp2') as small_raster:\n    with rasterio.open('Sentinel-3_L2_LST_reproj_32610.tif') as big_raster:\n\n        # 더 작은 래스터의 범위 가져오기\n        min_x, min_y, max_x, max_y = small_raster.bounds\n\n        # 더 큰 래스터에서 더 작은 래스터의 범위 내의 데이터 읽기\n        window = rasterio.windows.from_bounds(min_x, min_y, max_x, max_y, big_raster.transform)\n        data = big_raster.read(window=window)\n\n        # 더 큰 래스터의 메타데이터 업데이트하여 더 작은 래스터의 범위와 일치시키기\n        clipped_meta = big_raster.meta.copy()\n        clipped_meta.update({\n            'height': window.height,\n            'width': window.width,\n            'transform': rasterio.windows.transform(window, big_raster.transform),\n            'dtype': data.dtype\n        })\n\n        # 잘라낸 데이터 쓰기\n        with rasterio.open('Sentinel-3_L2_LST_reproj_32610_clipped.tif', 'w', **clipped_meta) as clipped_raster:\n            clipped_raster.write(data)\n```\n\n이 스크립트에서는 두 래스터 파일(Sentinle-3 및 Sentinel-2 이미지)을 읽고, 더 작은 래스터의 범위(Sentinel-2)를 추출하고, 더 큰 래스터(Sentinle-3 열화상 이미지)에서 해당 데이터를 읽어와서 잘라낸 Sentinle-3의 메타데이터를 Sentinel-2 이미지와 일치하도록 업데이트한 후, 잘라낸 열화상 이미지를 새 TIFF 파일에 작성합니다.\n\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_4.png\" />\n\n<div class=\"content-ad\"></div>\n\nNDVI 및 클리핑된 온도 맵을 옆으로 나란히 플롯해 봅시다:\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport rasterio\nfrom rasterio.plot import show\n\n# 파일 경로\nred_path = '/content/T10SFG_20230620T183919_B04_10m.jp2'\nnir_path = '/content/T10SFG_20230620T183919_B08_10m.jp2'\n\nclipped_temperature_path = '/content/Sentinel-3_L2_LST_reproj_32610_clipped.tif'\n\n# 래스터 데이터 읽기\nwith rasterio.open(red_path) as red_src:\n  red = red_src.read(1)\n\nwith rasterio.open(nir_path) as nir_src:\n  nir = nir_src.read(1)\n\nwith rasterio.open(clipped_temperature_path) as clipped_temp_ds:\n  clipped_temperature = clipped_temp_ds.read(1)\n\n# NDVI 계산\nndvi = (nir - red) / (nir + red)\n\n# NDVI와 온도를 옆으로 플롯\nfig, (ax1,ax2) = plt.subplots(ncols=2, figsize=(12, 6))\n\n# NDVI 플롯\nim1 = ax1.imshow(ndvi, cmap=ndvi_cmap, vmin=0, vmax=0.6)\nax1.set_title('NDVI', fontweight='bold', fontsize=14)\nfig.colorbar(im1, ax=ax1, shrink=0.5)\n\n# 클리핑된 온도 플롯\nim2= ax2.imshow(clipped_temperature, cmap=ndvi_cmap.reversed(), vmin=300, vmax=315)\nax2.set_title('Clipped Temperature', fontweight='bold', fontsize=14)\nfig.colorbar(im2, ax=ax2, shrink=0.5)\nplt.show()\n```\n\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_5.png\" />\n\n위와 같이 Sentinel-3 열화상 이미지를 Sentinel-2 맵의 범위에 맞게 성공적으로 클립했습니다. 그러나 Sentinel-2 이미지도 잘린 상태이며, 온도 픽셀의 평균 NDVI 값을 얻기 위해 존속 통계를 실행하면 많은 NaN 값을 얻게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_6.png)\n\n다음 단계에서 데이터프레임에서 NaN 값을 제외하여 수정할 것입니다.\n\n## 🌡️ 온도-NDVI 공간\n\n같은 투영 및 범위를 갖는 두 개의 명확한 이미지, 즉 센티넬-3에서의 열화상 이미지와 센티넬-2에서의 VNIR 이미지가 있을 때, 각 온도 픽셀의 평균 NDVI 값을 얻기 위해 존 채택 통계를 실행할 수 있습니다. 기본적으로 존 채택 통계 방식을 통해 10m에서 1000m로 NDVI 지도를 집계하여 온도-NDVI 공간에서 온도 값에 대한 NDVI 값을 플로팅할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n소개에서 언급했듯이 열값은 NDVI 값과는 역상관 관계에 있어야 합니다. 높은 NDVI는 식물의 비율이 더 높은 것을 나타내며 더 차가운 픽셀에 해당하고, 낮은 NDVI는 적은 식물이나 벌거벗은 토양에 해당하여 더 따뜻한 픽셀에 해당합니다. 우리의 AOI(관심 영역)에서 열과 NDVI 값 사이의 공간을 탐색하기 위해 존솔 통계를 수행해 보겠습니다:\n\n```js\nimport rasterio\nimport rasterio.features\nimport rasterio.mask\nimport pandas as pd\nimport geopandas as gpd\nimport rasterstats\n\nimport rasterio\nfrom rasterio.features import shapes\nmask = None\n\n# 입력 래스터 열기\nwith rasterio.open('Sentinel-3_L2_LST_reproj_32610_clipped.tif') as src:\n    # 래스터 밴드 읽기\n    image = src.read(1).astype(np.float32) * src.scales[0] + src.offsets[0]\n    results = (\n        {'properties': {'Temperature': v}, 'geometry': s}\n        for i, (s, v)\n        in enumerate(\n            shapes(image, mask=mask, transform=src.transform)))\n    geoms = list(results)\n    gpd_polygonized_raster = gpd.GeoDataFrame.from_features(geoms)\n\n# 래스터 열기\nwith rasterio.open('T10SFG_20230620T183919_B08_10m.jp2') as nir_src:\n    with rasterio.open('T10SFG_20230620T183919_B04_10m.jp2') as red_src:\n\n        # 데이터를 float32로 읽기\n        nir = nir_src.read(1).astype(np.float32) * nir_src.scales[0] + nir_src.offsets[0]\n        red = red_src.read(1).astype(np.float32) * red_src.scales[0] + red_src.offsets[0]\n\n        # NDVI 계산\n        ndvi = (nir - red) / (nir + red)\n\n        # 각 다각형에 대한 존솔 통계 계산\n        stats = rasterstats.zonal_stats(gpd_polygonized_raster.geometry, ndvi, affine=nir_src.transform, stats='mean')\n\n        # NDVI의 평균값을 데이터프레임에 추가\n        gpd_polygonized_raster['NDVI'] = [s['mean'] for s in stats]\n\n# 다각형 레이어를 shapefile로 저장\ngpd_polygonized_raster.to_file('output_polygons.shp')\n\n# geodataframe로부터 pandas 데이터프레임 생성\nstats_df = pd.DataFrame(gpd_polygonized_raster.drop(columns='geometry'))\n\n# 데이터프레임 출력\nprint(stats_df)\n```\n\n이 스크립트에서는 열 래스터를 여각화하고, Sentinel-2 이미지에서 NDVI를 계산하고, 각 온도 픽셀에 대한 존솔 통계(평균 NDVI)를 계산합니다.\n\n<div class=\"content-ad\"></div>\n\n위 표와 이전에 논의한 것처럼, Sentinel-3에서 열화 데이터를 가지고 있는 일부 픽셀에는 NaN 값이 있습니다. 이는 Sentinel-2 이미지의 자른 부분 때문입니다. Sentinel-2에서 NaN 값을 가진 행을 제외하겠습니다:\n\n```python\n# NaN 값이 있는 행 삭제\ndf_clean = stats_df.dropna(subset=['NDVI'])\ndf_clean\n```\n\n결과는 다음과 같습니다:\n\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_8.png\" />\n\n<div class=\"content-ad\"></div>\n\n이 깔끔한 데이터프레임을 사용하여 온도-NDVI 공간을 그래프로 표현할 수 있어요:\n\n```js\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy.stats import linregress\n\n# 산점도 생성\nplt.figure(figsize=(8, 6))\nsns.scatterplot(x='NDVI', y='Temperature', data=df_clean, palette='coolwarm')\n\n# 그래프 제목 및 축 레이블 설정\nplt.title('NDVI 대 온도 그래프', fontsize=16, fontweight='bold')\nplt.xlabel('NDVI', fontsize=14)\nplt.ylabel('Temperature', fontsize=14)\n\n# 그래프 보여주기\nplt.show()\n```\n\n결과는 다음과 같아요:\n\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_9.png\" />\n\n<div class=\"content-ad\"></div>\n\n위 그림에서 NDVI와 온도 사이의 역상관 관계를 관찰할 수 있지만 몇 가지 점이 이상치로 나타납니다. 이는 식물 및 맨 소토 외의 다른 특징을 나타내는 이미지의 픽셀 때문일 수 있습니다. 이러한 픽셀을 제거하기 위해 NDVI 값이 0.1에서 0.6 사이이고 온도 값이 300 켈빈에서 330 켈빈 사이인 값만 유지한 다음, 그에 맞게 그림을 업데이트하겠습니다:\n\n```js\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy.stats import linregress\n\n# 지정된 조건에 기반하여 데이터프레임 필터링\nfiltered_df = df_clean[(df_clean['NDVI'] >= 0.1) & (df_clean['NDVI'] <= 0.6) &\n                 (df_clean['Temperature'] >= 300) & (df_clean['Temperature'] <= 330)]\n\n# 온도 대 NDVI의 산점도 그리기\nplt.figure(figsize=(8, 6))\nsns.scatterplot(x='NDVI', y='Temperature', data=filtered_df, palette='coolwarm')\n\n# 선형 회귀 모델 적합\nslope, intercept = np.polyfit(filtered_df['NDVI'], filtered_df['Temperature'], 1)\n\n# 적합된 선 그리기\nx_line = np.linspace(min(filtered_df['NDVI']), max(filtered_df['NDVI']), 100)\ny_line = slope * x_line + intercept\nplt.plot(x_line, y_line, 'r', label='Fitted line')\n\n# 방정식 문자열 작성\nequation_str = f'y = {slope:.2f}x + {intercept:.2f}'\n\n# 그림에 방정식 표시\nplt.text(min(filtered_df['NDVI']), max(filtered_df['Temperature']), equation_str, fontsize=12, color='red')\n\n# 그림 제목과 축 레이블 설정\nplt.title('1-1. 온도 vs NDVI 그래프', fontsize=16, fontweight='bold')\nplt.xlabel('온도', fontsize=14)\nplt.ylabel('NDVI', fontsize=14)\n\n# 그림 표시\nplt.show()\n```\n\n결과는 다음과 같습니다:\n\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_10.png\" />\n\n<div class=\"content-ad\"></div>\n\n이제는 역상관 관계가 더 잘 보이고 있으며, NDVI 값과 온도 간 관계를 설명하는 방정식도 나와 있습니다.\n\n## 📐 열화상 이미지 선명하게하기 (1000m에서 10m)\n\n이번 단계에서는 1000m 해상도에서 집계된 NDVI와 온도 간의 관계를 발견한 방정식이 10m 해상도에도 유효할 수 있다고 가정할 것입니다. 이 방정식을 원래의 NDVI 지도에 적용하여 10m 해상도에서 온도를 추정할 수 있습니다.\n\n```js\nimport rasterio\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# NIR 및 RED 파일 열기\nwith rasterio.open('T10SFG_20230620T183919_B08_10m.jp2') as src:\n    nir = src.read(1)\n    meta = src.meta\n\nwith rasterio.open('T10SFG_20230620T183919_B04_10m.jp2') as src:\n    red = src.read(1)\n\n# NDVI 계산\nndvi = (nir - red) / (nir + red)\n\n# NDVI를 사용하여 온도 추정\ntemp = -21.85 * ndvi + 314.9\n\n# NDVI를위한 컬러 램프 만들기\nndvi_cmap = plt.cm.RdYlGn\n\n# NDVI 및 온도를 나란히 그리기\nfig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(12, 6))\n\n# NDVI 그리기\nim1 = ax1.imshow(ndvi, cmap=ndvi_cmap, vmin=0, vmax=0.6)\nax1.set_title('NDVI', fontweight='bold', fontsize=14)\nfig.colorbar(im1, ax=ax1, shrink=0.7)\n\n# 온도 그리기\nim2 = ax2.imshow(temp, cmap=ndvi_cmap.reversed(), vmin=300, vmax=315)\nax2.set_title('Temperature', fontweight='bold', fontsize=14)\nfig.colorbar(im2, ax=ax2, shrink=0.7)\n\nplt.show()\n```\n\n<div class=\"content-ad\"></div>\n\nNIR 및 빨간색 대역을 읽어 NDVI를 계산하고 유도된 방정식에 기반하여 온도 값을 추정합니다. 다음으로, NDVI 및 온도에 대한 결과를 시각화하여 옆에 플롯을 표시합니다. 지도는 다음과 같습니다:\n\n![맵](/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_11.png)\n\n## 🗺️ 날카로워진 열 영상의 시각화\n\n이 섹션에서는 시각화 측면에 더욱 집중할 것입니다. 우리는 이미지의 중앙 영역을 확대하고, 이미지를 중앙을 기준으로 자릅니다. 또한 온도 차트를 제시하기 위해 Sentinel-2의 NDVI 지도, 원본 Sentinel-3 열 영상(1000m 해상도) 및 분석 결과를 기반으로한 날카로운 Sentinel-3 영상(10m 해상도)을 비교 및 자세한 검토를 위해 옆에 함께 제시할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```python\n# NDVI 및 온도를 옆으로 나란히 플로팅합니다\nfig, axs = plt.subplots(ncols=3, figsize=(15, 5))\n\n# NDVI 플로팅\nvmin, vmax = 0, 0.6\nndvi_subset = ndvi[int(0.75 * ndvi.shape[0]):, int(0.75 * ndvi.shape[1]):]\nim1 = axs[0].imshow(ndvi_subset, cmap=ndvi_cmap, vmin=vmin, vmax=vmax)\naxs[0].set_title('NDVI', fontweight='bold', fontsize=14)\naxs[0].set_xticks([])\naxs[0].set_yticks([])\nfig.colorbar(im1, ax=axs[0], shrink=0.7)\n\n# 온도 플로팅\nwith rasterio.open('Sentinel-3_L2_LST_reproj_32610_clipped.tif') as src:\n    original_temp = src.read(1)\n\nvmin, vmax = 300, 315\ntemp_subset = original_temp[int(0.75 * original_temp.shape[0]):, int(0.75 * original_temp.shape[1]):]\nim3 = axs[1].imshow(temp_subset, cmap=ndvi_cmap.reversed(), vmin=vmin, vmax=vmax)\naxs[1].set_title('Temperature', fontweight='bold', fontsize=14)\naxs[1].set_xticks([])\naxs[1].set_yticks([])\nfig.colorbar(im3, ax=axs[1], shrink=0.7)\n\nvmin, vmax = 300, 315\ntemp_subset = temp[int(0.75 * temp.shape[0]):, int(0.75 * temp.shape[1]):]\nim2 = axs[2].imshow(temp_subset, cmap=ndvi_cmap.reversed(), vmin=vmin, vmax=vmax)\naxs[2].set_title('Temperature', fontweight='bold', fontsize=14)\naxs[2].set_xticks([])\naxs[2].set_yticks([])\nfig.colorbar(im2, ax=axs[2], shrink=0.7)\n\n# 서브플롯 간 간격 조정\nfig.subplots_adjust(wspace=0.2)\n\nplt.show()\r\n```\n\n지도는:\n\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_12.png\" />\n\n## 📄 결론\n\n\n<div class=\"content-ad\"></div>\n\nVisible과 Near-Infrared (VNIR) 대역과 열 이미지 간의 직접적 상관 관계는 열 이미지의 해상도를 향상시키는 유용한 방법으로 입증되었습니다. 이 기술은 위성의 적절한 공간 해상도를 가진 위성이 없을 때 온도를 높은 공간 해상도로 추정하는 데 실용적으로 활용됩니다. 이 다운스케일링 방법은 고해상도 열지도가 필요할 때 유용한 도구로 작용하며 소규모 온도 변화에 대한 세부 정보를 제공합니다. 앞으로 더 많은 고급 열 센서를 갖춘 위성을 발사함에 따라 빈도가 더 높은 고해상도 열 이미지를 얻을 수 있게 될 것입니다. 그 전까지는 이 방법이 더 높은 해상도의 열 이미지를 구현하는 비용 효율적인 선택지로 남아 있습니다.\n\n## 📚 참고 자료\n\nCopernicus 센티넬 데이터 [2024] - 센티넬 데이터에 대한 정보\n\nCopernicus 서비스 정보 [2024] - Copernicus 서비스 정보에 관한 정보\n\n<div class=\"content-ad\"></div>\n\n아감, N., 쿠스타스, W. P., 앤더슨, M. C., 리, F., 닐, C. M. U. (2007). 열화상 이미지 공간 개선을 위한 식물 지수 기반 기술. Remote Sensing of Environment, 107(4), 545–558. ISSN 0034–4257.\n\n가오, F., 쿠스타스, W. P., 앤더슨, M. C. (2012). 육지 위의 열화상 위성 이미지 개선을 위한 데이터 마이닝 접근 방식. Remote Sensing, 4, 3287–3319.\n\n휴리나, H., 코헨, Y., 카르니엘리, A., 파노프, N., 쿠스타스, W. P., 아감, N. (2019). Sentinel-3 위성 이미지의 열화상 개선을 위한 TsHARP 유틸리티 평가. Remote Sensing, 11, 2304.\n\n📱 저와 더 다양한 콘텐츠를 공유하려면 다른 플랫폼에서 연락하세요! LinkedIn, ResearchGate, Github 및 Twitter.\n\n<div class=\"content-ad\"></div>\n\n여기 해당 링크를 통해 제공되는 관련 게시물들이 있습니다:","ogImage":{"url":"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_0.png"},"coverImage":"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_0.png","tag":["Tech"],"readingTime":17},{"title":"경기 결과 비교 에이지 그레이딩, 퍼센타일, Z-스코어 세 가지 방법","description":"","date":"2024-06-22 16:46","slug":"2024-06-22-AgeGradingPercentilesandZ-ScoresThreeWaystoCompareRaceResults","content":"\n\n\n![Image](/assets/img/2024-06-22-AgeGradingPercentilesandZ-ScoresThreeWaystoCompareRaceResults_0.png)\n\n다른 연령 그룹의 두 러너간의 경주 결과를 효과적이고 공정하게 비교하는 방법은 무엇일까요?\n\n이 질문에 대해 계속해서 다루고 있는 시리즈 기사들 중 하나입니다.\n\n현재 시스템인 연령 등급은 유용하지만 일부 결함이 있습니다. 많은 데이터를 수집하고 분석한 후, 연령 등급의 두 대체안인 백분위 및 z-점수를 제안했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n오늘은 한 걸음 물러나서 이 세 가지 다른 방법을 비교해 보고 싶었어요. 특히 연령 측정의 한 가지 문제는 어떤 그룹에 대해 다른 그룹보다 더 호의적으로 치우치는 것 같다는 점이에요. 대안들도 같은 문제를 가지고 있나요?\n\n또한 달리기 선수의 연령, 성별 및 시간을 입력할 수 있는 계산기를 설정했어요. 이를 통해 모든 세 개의 점수를 얻어 비교할 수 있어요.\n\n하지만 먼저, 지금까지 무엇을 살펴봤는지 간단히 되짚어볼까 해요. 이 주제에 대해 읽은 첫 번째 문서라면 여기서 확인하세요. 처음부터 따라오고 있다면 다음 섹션으로 스킵해도 돼요.\n\n# 이전의 연령 측정에 관한 이전 기사들 재고하기\n\n<div class=\"content-ad\"></div>\n\n이 시리즈는 한 가지 질문으로 시작했어요 — 서로 다른 연령 그룹과 성별 간의 경주 결과를 어떻게 효과적으로 비교할까요?\n\n첫 번째 기사에서는 연령 등급화의 역사에 대해 살펴보고 시스템을 기본적으로 비판했어요.\n\n이 질문은 중요하고, 연령 등급화는 아무것도 없는 것보다 훨씬 나아요. 그러나 모든 사람의 결과를 가상의 최고 결과와 비교하려는 데에는 약간 문제가 있다고 생각돼요. 그 표준을 결정하는 것은 어렵고, 그 특정 표준은 다소 임의적일 수 있어요.\n\n또한, 평균 러너에게 그들의 결과가 전반적인 상황에 어떻게 맞는지 이해하는 데에는 그리 큰 도움이 되지 않을 수도 있어요 — 왜냐하면 얼마나 잘하든 항상 그 최고 가능 시간으로부터 멀리 떨어져 있기 때문이에요.\n\n<div class=\"content-ad\"></div>\n\n연령 채정은 최고의 러너들의 통계와 연구에 기반을 두고 개발되었지만, 이 문제를 다른 시각에서 바라보고 싶었습니다. 다른 모든 러너들과 어떻게 비교할까요?\n\n통계는 여러 가지 방법을 제시하여 이러한 비교를 할 수 있지만, 먼저 함께 작업할 대규모이며 대표적인 데이터 세트가 필요했습니다. 시리즈의 두 번째 기사에서 제 작업한 샘플을 소개했습니다.\n\n간략하게 말하자면, 2010년부터 2019년까지 9월, 10월 또는 11월에 열린 미국 마라톤에 중점을 두었습니다.\n\n개별적으로 포함할 경주를 어떻게 고려할지 걱정하지 않고 전체 '시즌'의 러닝을 포착하기 위해 이 세 달을 선택했습니다. 어떤 경주는 빠를 수도 있고, 어떤 경주는 느릴 수도 있습니다. 종합적으로 말하면, 이들은 꽤 대표적입니다.\n\n<div class=\"content-ad\"></div>\n\n500명 이상의 참가자가 있는 레이스로 사정을 좁혔어요. 이로 인해 샘플 크기가 크게 줄진 않았지만, 스크레이핑 프로세스는 좀 더 쉬워졌어요.\n\n데이터를 모두 수집한 후에는 데이터셋 안에 무엇이 있는지 살펴보았어요.\n\n이 데이터셋에는 200만 명이 넘는 개별 레이스 결과가 포함되어 있어요. 가장 많은 참가자들은 35세 미만 연령 그룹에 있지만, 각 연령 그룹은 상당히 잘 대표되어 있어요 — 적어도 70대까지는요. 70~74세 남성들은 상당히 많았지만, 75~79세 남성 및 70~74세 여성은 더 작은 그룹이었어요. 75~79세 여성 그룹은 더 작았고, 80세 이상 러너들에 대해 유용한 분석을 하기에 충분한 데이터가 없었어요.\n\n손에 있는 데이터를 활용하여, 첫 번째 대안으로 백분위수를 제안할 수 있었어요.\n\n<div class=\"content-ad\"></div>\n\n본질적으로는 이 방법은 분포를 살펴보고 특정 결과가 그 분포 속 어디에 들어가는지를 알아내는 것입니다. 모든 결과를 살펴보면, 특정 시간보다 느리게 끝낸 러너들의 나이 그룹에서 어느 정도의 백분율이 되는지 말할 수 있고, 그 시간을 넘긴 백분율을 말할 수도 있습니다.\n\n이 나이 그룹 간의 시간 분포가 꽤 일관되다고 가정하면, 한 나이 그룹에서 상위 5%에 있는 러너는 대체로 다른 나이 그룹에서 상위 5%에 있는 러너와 유사할 것이라고 볼 수 있습니다.\n\n추가 기사에서는 각각의 분포를 더 자세히 살펴보아 동일하게 구성되어 있는지 확인했습니다. 대체로 그렇게 보였습니다. 작고 나이가 든 그룹에선 조금 덜 깔끔해지긴 했지만 — 분포의 일반적인 모양은 같았습니다.\n\n그러나 추가 분석 결과, 내가 개발한 현재의 표가 어떤 그룹을 다른 그룹에 비해 좀 더 선호하는 경향이 있어 보입니다 — 특히 99.9번째 백분위에서 그렇습니다. 이 부분은 미래 버전에서 수정할 수 있을 것 같지만, 그건 나중 문제가 되겠죠.\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 최근의 논문에서는 z-점수가 레이스 결과를 비교하는 더 나은 방법을 제공하는지 살펴보았어요. \n\nz-점수는 특정 데이터 포인트가 평균보다 얼마나 높거나 낮은지를 측정하는 지표에요. 간단히 말해, 각 분포의 평균과 표준 편차를 계산하고, 그런 다음 결과마다 표준화된 숫자가 할당되어 얼마나 빠르거나 느린지를 나타냅니다.\n\n일반적으로, 이 방법은 작동합니다. z-점수가 -2 이하인 결과는 분포의 외곽에 있고 분명히 인상적입니다. 그러나 이 방법은 불균형적이며, 분명히 다른 연령대의 여성보다 젊은 여성을 선호해요.\n\n퍼센타일은 더 나은 비교를 제공하기 위해 조정되고 보정될 수 있다고 생각하지만, z-점수는 그런 가능성이 없다고 생각해요. 그럼에도 불구하고, 현재 그들을 그대로 유지하여 맥락을 제공하는 데 도움을 주도록 하겠어요.\n\n<div class=\"content-ad\"></div>\n\n# 다양한 연령 그룹에 공정한가요?\n\n지금은 연령 그룹 간 레이스 결과를 비교하는 세 가지 시스템이 있습니다 — 기존 나이 등급 시스템, 각 연령 그룹의 백분위표가 있는 테이블, 그리고 주어진 결과에 대한 z-점수를 계산하는 수단입니다.\n\n이 세 가지 다른 방법 중에서 얼마나 공정한가요? 어떤 그룹을 선호하나요?\n\n이 질문을 바라보는 한 가지 방법은 각 연령 그룹을 대표하는 상위 러너들의 비율을 각 방법에 근거하여 살펴봄으로써 전체 샘플 중 각 연령 그룹의 비율을 비교하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n일반적으로, 그러한 분포가 꽤 유사할 것으로 기대됩니다. 아마도 더 많은 엘리트 선수들 때문에 보다 어린 연령 그룹이 과대표시될 것입니다. 그렇지만, 시스템이 공평하다면 — 큰 격차가 없어야 합니다.\n\n아래 시각화는 2019년에 각 등급 방법으로 상위 100명의 완주자를 보여줍니다. 또한 각 연령 그룹의 모든 참가자들의 백분율을 보여줍니다.\n\n각 연령 그룹 당 네 개의 막대 막대가 있으며, 막대 위를 가리키면 무슨 것을 나타내는지 알려줍니다.\n\n왼쪽 막대는 해당 연령 그룹의 전체 표본에서 참가자의 백분율입니다. 모든 것이 고률적으로 균등하게 분포되고 무작위로 되어 있다면, 100명의 그룹에서 몇 명의 참가자가 나타날 것으로 기대되는지를 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n두 번째 막대는 상위 100명 중 연령 등급에 따라 뛰는 사람의 수를 보여줍니다. 그런 다음 백분위수 기준으로 측정한 수, 마지막으로 Z-점수에 따른 숫자입니다.\n\n먼저, 연령 등급과 전반적인 분포 간의 비교부터 시작해봅시다. 35세 미만의 남성이 여기서 큰 이상점을 형성합니다. 이들은 100명의 러너 중 약 18명을 차지합니다. 그러나 상위 연령 등급 점수의 38명은 35세 미만의 남성입니다. 한편, 35-39세 남성, 40-44세 남성, 그리고 35세 미만의 여성은 모두 상당히 소외됐습니다.\n\n이제 가장 젊은 연령 그룹이 과대표되이 될 수 있는 것은 합리적인 결과일 수 있습니다 — 그 연령 그룹에는 프로러너가 더 많고, 다른 그룹에는 덜할 수 있습니다. 그러나 왜 젊은 남성이 과도하게 대표됐는지, 반면 젊은 여성은 그렇지 않은지 설명할 수 없습니다.\n\n한 칸 더 옮겨서 백분위수를 전반적인 분포와 비교하면 문제가 반대로 전환됩니다. 35세 이하의 여성은 과대표되어 있습니다. 35세 미만의 남성은 여전히 과대표이지만, 다소 균형이 맞습니다. 다른 연령 그룹에 대해서는 그렇게 나쁘지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n드디어, 전체 그래프에서 가장 부조화스러운 막대는 z-점수로 측정된 35세 미만 여성들입니다. 내가 그 글에서 언급한 것처럼, 그들은 그 모델에서 크게 유리합니다. 샘플의 모든 러너 중에 여성들이 35세 미만인 것은 100명 중 17명뿐인데, z-점수로 측정한 상위 완주자 중 53명이 그 나이 그룹에 속합니다. 이것은 문제입니다.\n\n탑 100은 소수 그룹이기 때문에 특이치에 더 취약합니다. 그래서 우리가 탑 500까지 확대해보면 어떻게 될까요?\n\n나이 평가를 보면, 남성은 여전히 현실과 거리가 멀어 보입니다. 그리고 여성들 중에서 35세 미만인 그룹은 여전히 매우 부족하게 표시됩니다. 다른 남성 연령 그룹들은 그리 부조화스럽지 않아 보이지만, 다른 젊은 여성들(35-39세 및 40-44세)도 상당히 부족하게 표시됩니다.\n\n백분위를 보면, 35세 미만의 남성들은 현실적인 위치로 돌아오지만, 35세 미만 여성들은 이제 과대표시되어 있습니다. 35-39세 여성들도 꽤 잘 하고 있습니다. 여성들 35-39세도 꽤 잘 하고 있습니다. 35세 미만의 남성들은 과대표시되어 있지만, 다시 말하지만, 차이는 그리 크지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n또 다른 문제는 이전에 주목하지 못했던 것인데, 45-49세, 50-54세 및 55-59세의 남성들이 여기에 상당히 소수를 차지하고 있습니다. 그들은 표본의 큰 부분을 차지하지만 상위 500명 중에는 매우 적습니다.\n\n상위 1000명으로 돌아가면 더 부드럽고 일관된 그림이 나타납니다.\n\n다시 한 번, 연령 등급은 젊은 남성을 매우 선호하며 젊은 여성을 불리하게 대우합니다. Z-점수는 젊은 여성들을 매우 선호하고 나이 든 남성을 불리하게 대우합니다.\n\n이 정밀도 수준에서 백분위수에 따른 달리기자들의 분포가 가장 균등해 보입니다. 젊은 남성과 여성 모두 과다 표시되어 있지만 그 정도는 크지 않습니다. 반면 50대의 달리기자들은 그렇게 잘 나오지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n하루가 끝날 때, 이 데이터를 통해 세 가지 방법 모두 어떤 측면에서 균형이 잡히지 않았다고 생각합니다. 연령 성적은 어린 남성의 결과를 선호하는 경향이 있고, Z-점수는 어린 여성을 매우 선호합니다. 백분위수는 자체적인 불균형이 있지만 조금 더 정확하게 보정할 수도 있습니다.\n\n또한 주목할 점은 최고의 러너 사이를 구별하는 것 — 상위 1,000명은 표본에서 상위 0.5% 정도에 해당합니다 — 이 백분위수에는 강점이 없다는 것입니다.\n\n# 이 온라인 계산기를 사용하여 자신만의 연령 성적을 계산하세요\n\n이 분석을 수행하기 위해 Python과 Pandas 패키지를 사용하여 많은 작업을 해왔습니다. 큰 샘플 집합을 준비하고, 룩업 테이블과 계산을 바탕으로 각 시스템에 기반한 결과를 빠르게 도출할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 그것이 독자인 당신을 돕지는 않아요.\n\n그것을 해결하고자, 여기에서 사용할 수 있는 온라인 계산기를 제작해 보았어요.\n\n참고로, 이 계산기는 여전히 베타 버전이고 몇 가지 개선이 필요해요. 특히, 어떠한 종류의 오류 처리도 구현하지 않았기 때문에 시간을 제대로 입력하지 않거나 예상치 못한 값이 입력되면 결과가 표시되지 않을 수 있어요.\n\n하지만, 이것을 통해 세 가지를 입력할 수 있어요 — 러너의 나이, 성별, 그리고 완주 시간 — 그리고 그들의 점수를 각각 세 가지 등급 시스템에 기반하여 볼 수 있어요. 나이 등급화된 시간, 나이 등급 점수, 동료들 사이에서의 백분위 순위, 그리고 결과의 Z-점수를 볼 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n미래에 조금 더 발전시킬 계획이지만, 지금은 초안 시스템이 있어서 여러분과 공유하는 것이 중요하다고 생각했어요.\n\n# 다음 단계는?\n\n지금까지 가장 큰 장애물 중 하나는 온라인 계산기를 만드는 것이었습니다. 그것이 해결되었으니, 프로젝트의 마지막 부분에 대해 앞으로 관리할 수 있게 되었습니다: 새 데이터 수집 및 모델 업데이트가 남아 있습니다.\n\n기술적 문제들에 대처하고자 2010년부터 2019년을 다루는 예전 (크고 더 많은) 데이터셋으로 시작하려고 했습니다. 이제 이 일을 하는 방법에 대해 잡았으니, 2023년부터 새 데이터를 수집하고 백분위 모델과 z-점수 모델을 업데이트할 계획입니다. 또한 이를 2023년 연령별 테이블과 비교할 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n그것은 다음 주 또는 그 다음 주 중순쯤 되실 예정입니다. 새 데이터를 수집한 뒤에 공유할 계획이에요.\n\n그 후에는 이를 마무리하는 것이 시기적으로 적절하다고 생각하고 있어요. 그러나 작업이 완료되면 Kaggle에 전체 데이터 세트를 공유할 계획이기 때문에 다른 분들이 자신만의 분석을 할 수 있도록 도와드릴 거에요.\n\n따라서 이 시리즈의 마지막 부분은 아마도 제시된 일부 비평에 응답하고 일반적인 결론을 도출하며 데이터 세트에 대한 접근 권한을 공유할 예정이에요.\n\n이 중에 관심 있으신 분이 있으면, 다음 몇 개의 기사를 받아보려면 이메일 업데이트를 구독하시기 바랍니다. 다음 두 주 또는 세 주 안에 게시할 예정이에요.\n\n<div class=\"content-ad\"></div>\n\n분석에 도움이 될 피드백이나 아이디어가 있다면 응답을 남겨주세요. 두 번째(또는 세 번째, 네 번째) 의견을 듣는 것이 항상 도움이 됩니다!\n\n저는 열정적인 러너이자 데이터 열정가입니다. 막 그랬더니 40살이 되었어요. 그래서 연령별 결과를 비교하는 것이 특히 흥미로워요. 제가 하는 일을 따라갈 수 있는 방법은 다음과 같습니다:\n\n- 훈련에 대한 소식을 듣고 싶다면 Running with Rock을 팔로우하세요.\n- 마라톤 훈련 계획 선택에 대한 팁을 읽어보세요.\n- Strava에서 저를 스토킹하세요.","ogImage":{"url":"/assets/img/2024-06-22-AgeGradingPercentilesandZ-ScoresThreeWaystoCompareRaceResults_0.png"},"coverImage":"/assets/img/2024-06-22-AgeGradingPercentilesandZ-ScoresThreeWaystoCompareRaceResults_0.png","tag":["Tech"],"readingTime":8},{"title":"NLP 분석을 위한 Youtube 댓글 스크래핑 방법","description":"","date":"2024-06-22 16:44","slug":"2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis","content":"\n\n![image](/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_0.png)\n\n간단한 NLP 프로젝트를 시도해보고자 했는데, 유튜브 동영상에서 댓글을 가져와 분석해보려고 합니다.\n\n사실 향수에 대해 연구 중이었는데, 인스타그램을 무심코 스크롤하다가 향수 광고에 끌려들어가게 되었습니다. 그렇게해서 향수 리뷰 동영상들을 찾게 되었고, Demi Rawling의 향수 리뷰 동영상을 발견하게 되었습니다... (너무 핫하네요).\n\n유튜브 링크 - https://youtu.be/oJqc2tLMObg\n\n<div class=\"content-ad\"></div>\n\n이 동영상은 탑 10 톰 포드 향수에 관한 것입니다. 다소 오래된 동영상이긴 하지만(4년 전 영상입니다)\n\n먼저, 만약 설치되어 있지 않다면 이곳에서 ChromeDriver를 설치해주세요. 저는 VS Code에서 실행을 시도해봤어요. 필요한 라이브러리는 다음과 같아요...\n\n```js\nimport sys\nimport time\nimport pandas as pd\nfrom datetime import datetime\nfrom selenium import webdriver\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\n```\n\n그런 다음 스크래핑 부분이 나옵니다...\n\n<div class=\"content-ad\"></div>\n\n```python\nimport pandas as pd\nfrom selenium import webdriver\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nimport time\nimport sys\nfrom datetime import datetime\n\n# WebDriver를 초기화하고 성능을 향상시키기 위한 옵션 설정\noptions = webdriver.ChromeOptions()\noptions.add_argument(\"--headless\")  # 헤드리스 모드로 실행\noptions.add_argument(\"--disable-gpu\")  # GPU 렌더링 비활성화\noptions.add_argument(\"--no-sandbox\")  # OS 보안 모델 우회\noptions.add_argument(\"--disable-dev-shm-usage\")  # 제한된 리소스 문제 극복\noptions.add_argument(\"--start-maximized\")  # 창 최대화\n\ndriver = webdriver.Chrome(options=options)\n\ndata = []\nyoutube_video_url = \"https://youtu.be/oJqc2tLMObg\"\nwait = WebDriverWait(driver, 30) \n\n# YouTube 비디오 URL 열기\ndriver.get(youtube_video_url)\nprint(\"YouTube URL을 열었습니다.\")\n\n# 댓글을 로드하기 위해 스크롤 다운\nfor item in range(150):  # 여기에 스크롤 횟수 정의\n    try:\n        body = wait.until(EC.visibility_of_element_located((By.TAG_NAME, \"body\")))\n        body.send_keys(Keys.END)\n        sys.stdout.write(f\"\\r{item + 1}번 스크롤 중\")\n        sys.stdout.flush()\n        time.sleep(1.5)  # 로딩을 위한 시간 증가\n    except Exception as e:\n        print(f\"스크롤 중 예외 발생: {e}\")\n        break\n\n# 댓글 추출\ntry:\n    wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, \"#contents #contents\")))\n    comments = driver.find_elements(By.CSS_SELECTOR, \"#content #content-text\")\n    print(f\"\\n{len(comments)}개의 댓글 요소를 찾았습니다.\")\n\n    user_id = 1  # 고유한 사용자 ID 초기화\n    for comment in comments:\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        data.append({\"사용자 ID\": user_id, \"댓글\": comment.text, \"타임스탬프\": timestamp})\n        user_id += 1\n\n    # 중복 제거\n    data = [dict(t) for t in {tuple(d.items()) for d in data}]\n    print(f\"캡처된 댓글 수: {len(data)}\")\nexcept Exception as e:\n    print(f\"댓글 추출 중 예외 발생: {e}\")\n\ndriver.quit()\n\n# DataFrame 생성\ndf = pd.DataFrame(data, columns=[\"사용자 ID\", \"댓글\", \"타임스탬프\"])\n\n# DataFrame 표시\nprint(df)\n\n# DataFrame을 CSV 파일로 저장 (선택 사항)\ndf.to_csv(\"youtube_comments.csv\", index=False)\n``` \n\n여기서 댓글을 스크래핑하기 위해 스크롤 수를 사용했어요. 댓글 수의 최대값으로 변환할 수도 있지만, 현재 이 방법이 가장 잘 작동합니다.\n\n그래서 이 몇 가지 가정과 제약들이 있어요.\n\n가정과 제약사항: 각 댓글의 사용자 이름을 스크래핑하여 하나의 작성자가 여러 번 댓글을 작성했을 때 합칠 수 있도록 시도했지만 크롬 드라이버에서 많은 시간이 소요되고 있는 것을 고려하여 무모하게 반복된 댓글이 작성되지는 않았을 것이라고 가정하고, 추출된 날짜를 추가한 각 댓글을 고유한 것으로 간주했어요.\n\n\n<div class=\"content-ad\"></div>\n\n크롬 드라이버를 헤드리스 모드로 실행하여 응답 속도를 높였어요. 코드에서 주석 처리하고 실행해보셔도 돼요. 만약 더 빠른 스크래핑 방법을 찾으시면 댓글로 알려주세요. François St-Amant의 코드를 참고했어요.\n\n링크 — [여기](https://towardsdatascience.com/how-to-scrape-youtube-comments-with-python-61ff197115d)\n\n```python\nimport pandas as pd\ndf = pd.DataFrame(data, columns=['comment'])\ndf.head()\n```\n\n![이미지](/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_1.png)\n\n<div class=\"content-ad\"></div>\n\n지금은 Perplexity.ai와 함께 이 동영상에서 언급된 향수 목록을 두 번째 데이터프레임으로 가지고 있어요. 이 목록은 수동으로 가져왔지만 파이썬을 사용하여 동영상을 구문 분석하여 수행할 수도 있지만 그것은 다른 날을 위해 저장합시다. 또한 이에 대한 YouTube 동영상 요약기를 확인할 수도 있는데, 이것은 제 친구 Priyanshu Shukla가 만들었어요 – https://medium.com/@priyanshu-shkl7/implementing-generative-ai-into-your-apps-web-scraping-with-genai-f08711a404cb\n\n![이미지](/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_2.png)\n\n이제 NLP 부분으로 넘어가볼게요. 간단히 말씀드리면, 댓글 내에서 언급된 Tom Ford의 다양한 향수들을 얻으려고 노력 중이에요. 기본적으로 언급에 따라 각 향수를 지정하고 활동이 가장 많은 순서대로 정렬 중이에요.\n\n이를 달성하기 위해 다양한 방법이 있지만, 저는 NLTK(Natural Language Toolkit)를 사용했어요. NLTK는 파이썬에서 인간의 언어 데이터를 처리하는 강력한 라이브러리예요. 이는 자연어 처리(NLP) 작업에 널리 사용되며, 의미론적 키워드 일치 및 감성 분석과 같은 작업에 적합해요.\n\n<div class=\"content-ad\"></div>\n\nHuggingFace에서 제공하는 최고의 sentence transformers 중 하나를 사용하여 의미론적 문자열 매칭을 수행하거나 사용할 수 있습니다. 또한, 동일한 작업을 수행하기 위해 사용 가능한 LLM들을 사용할 수도 있지만 대규모 데이터셋에 대한 프로덕션 배포의 경우 sentence transformers가 가장 적합할 것입니다.\n\n```python\n!pip install nltk\nimport nltk\nnltk.download('vader_lexicon')\n```\n\n```python\nimport pandas as pd\nfrom nltk.sentiment import SentimentIntensityAnalyzer\n\ndef calculate_sentiment_scores(comments, perfumes):\n    sentiment_scores = {str(perfume): [] for perfume in perfumes}\n    \n    sid = SentimentIntensityAnalyzer()\n    \n    for _, row in comments.iterrows():\n        comment = str(row['Comment'])\n        user_id = row['User ID']\n        sentiment_dict = sid.polarity_scores(comment)\n        \n        compound_score = sentiment_dict['compound']\n        \n        for perfume in perfumes:\n            if str(perfume).lower() in comment.lower():\n                sentiment_scores[str(perfume)].append((user_id, comment, compound_score))\n    \n    return sentiment_scores\n\n# Load the comments DataFrame\ndf_comments = df\n\n# Load the perfumes DataFrame\ndf_perfumes = df2\n\n# Extract perfumes from df_perfumes\nperfumes = df2.iloc[:, 0].tolist()\n\n# Calculate sentiment scores for each perfume in the comments\nsentiment_scores = calculate_sentiment_scores(df_comments, perfumes)\n\n# Create a new DataFrame with 'user_id', 'comment', 'perfume', and 'sentiment_score' columns\ndata = []\nfor perfume, user_comment_list in sentiment_scores.items():\n    for user_id, comment, sentiment_score in user_comment_list:\n        data.append([user_id, comment, perfume, sentiment_score])\n\ndf_result = pd.DataFrame(data, columns=['user_id', 'comment', 'perfume', 'sentiment_score'])\n\n# Print the resulting DataFrame\nprint(\"User Comments with Sentiment Scores:\")\ndf_result\n```\n\n![YouTube Comments](/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n위에서 보듯이, 각 댓글에는 때때로 하나 이상의 향수가 언급되어서 각 향수에 대한 점수가 계산됩니다. 그래서 \"나는 블랙 오키드를 소유하고 있다\"는 댓글은 Beau de jour를 가지고 있습니다. 그래서 Beau de jour와 black orchid 각각 한 번씩 나타납니다.\n\n하지만 이에 더해, 만일 우리가 이 감정 분석과 키워드 일치를 확인해야 한다면, 이를 위해 Tableau로 간단한 대시보드를 구축했습니다. Tableau 대시보드를 사용하면 빠르게 향수들과 그들의 감정 점수를 필터링할 수 있습니다.\n\n[![테이블로 대시보드](/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_4.png)](https://public.tableau.com/views/YoutubeSentimentAnalysis/YoutubeComments-NLPAnalysis?:language=en-GB&:sid=&:display_count=n&:origin=viz_share_link)\n\n<div class=\"content-ad\"></div>\n\n어떤 생각이든 자유롭게 공유해 주시고, 댓글을 남기셔서 제 소식을 받아보세요! 읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_0.png"},"coverImage":"/assets/img/2024-06-22-ScrapingYoutubeCommentsforNLPAnalysis_0.png","tag":["Tech"],"readingTime":7},{"title":"실시간 통합 기능이 탑재된 Python 대시보드 만들기 ","description":"","date":"2024-06-22 16:43","slug":"2024-06-22-BeautifuldashboardsinPythonwithfirst-classreal-timeintegration","content":"\n\n## deephaven.ui\n\n작성자: Alex Peters\n\n![이미지](/assets/img/2024-06-22-BeautifuldashboardsinPythonwithfirst-classreal-timeintegration_0.png)\n\n파이썬 개발자들은 실시간 데이터 혁명에 준비가 되어 있나요? 가장 일반적인 파이썬 툴킷들 중에는 필수 대시보드 패키지도 포함되어 있지 않습니다. 그래서 우리는 강력한 Deephaven 실시간 데이터 엔진 위에 구축된 실시간 대시보드 라이브러리인 deephaven.ui를 자랑스럽게 소개합니다. 파이썬에서 실시간 대시보드를 만드는 것이 이렇게 쉬워진 적이 없었습니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사에서는 deephaven.ui의 시작을 탐구하고 이를 사용하여 스트리밍 대시보드를 만드는 예제를 제시할 것입니다:\n\n![예시 이미지](https://miro.medium.com/v2/resize:fit:1400/1*4bXAHvIHjwx2tT-X1i27FQ.gif)\n\n# 왜 귀찮게 할까요?\n\nPython과 대시보드는 오랜 시간 동안 함께 해왔습니다. Python 개발자들은 종종 아이디어를 효과적이고 매력적인 방식으로 제시해야 할 필요가 있는데, 그러기 위해 필요한 모든 프론트엔드 기술을 배우는 시간이 부족합니다. Dash, Streamlit, Shiny와 같은 플랫폼은 이 문제에 대한 Pythonic한 해결책으로 등장했습니다. 개발자들은 프론트엔드 지식이 거의 없이 아름다운 대시보드를 만들고 한 번의 클릭으로 넓은 커뮤니티와 자신의 작품을 공유할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그러나 큰 문제가 하나 있습니다. 이러한 플랫폼은 매우 제한적인 실시간 지원을 제공합니다. 여기저기 살펴보면 이러한 플랫폼을 사용하여 대략 실시간 대시보드를 만드는 예제 몇 가지를 찾을 수 있지만, 그들의 실시간 지원은 여과 없이 그런 데로 납치한 것처럼 보입니다. 중요한 것이 그들이 그 실행 모델의 중심요소로 만들 계획이 전혀 없었습니다. 그들은 그저 실시간 지원을 위해 대시보드를 규칙적인 간격으로 새롭게 표시하는 스냅샷 기반 접근 방식을 취합니다. 저사양의 경우에는 작동할지 몰라도, 현대의 대용량 스트리밍 데이터에는 이를 견딜 수 없는 문제가 발생합니다.\n\n왜 이것이 중요한가요? 스트리밍 데이터는 앞으로 시장을 지배할 것으로 전망됩니다. 스트리밍 데이터 파이프라인은 연결된 장치와 빠른 통신을 가능하게 하며, 사기 탐지나 맞춤형 제안과 같은 사용 사례를 구동합니다. 포브스는 2025년까지 생성된 데이터의 거의 30%가 실시간일 것으로 추정하여, 경쟁력 유지를 위해 실시간 데이터 통합이 중요해질 것이라고 합니다. 포츈 비즈니스 인사이츠는 거대한 예측을 내놓았습니다: 2030년까지 스트리밍 분석 시장 규모는 1,250억 달러를 넘길 것으로 예상합니다.\n\n그래서 파이썬 데이터 과학자와 점점 더 필요해질 실시간 대시보드 사이에는 격차가 있습니다. 이 문제에 대한 훌륭한 해결책을 찾아나섰지만, 우선 순위 목록의 맨 위에 스트리밍 대시보드가 있는 솔루션을 찾을 수 없었습니다. 그래서 우리는 직접 제작했습니다: deephaven.ui. 이 새로운 대시보드 패러다임은 유연한 React Spectrum 기반 구문, 모듈식 구성 요소 설계, 그리고 가장 중요한, 실시간을 최우선으로 합니다.\n\ndeephaven.ui는 새롭게 출시되어 매우 열심히 개발 중인 상태이지만, 이미 최상의 플랫폼으로 자리잡고 있습니다. 곧 제공될 방대한 문서를 통해 deephaven.ui의 모든 면을 손쉽게 탐색할 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\ndeephaven.ui가 어떻게 작동하는지 보고 싶다면 데모 시스템의 새로운 deephaven.ui 노트북을 확인해보세요. 현재 이 노트북은 데모의 Code Studio 쪽에만 있습니다.\n\n# deephaven.ui로 시작하기\n\ndeephaven.ui를 시작하는 가장 쉬운 방법은 미리 설치된 Docker 이미지를 실행하는 것입니다:\n\n```js\ndocker run --rm --name deephaven-ui -p 10000:10000 --pull=always ghcr.io/deephaven/server-ui:latest\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 http://localhost:10000/ide/로 이동하여 deephaven.ui를 사용해보세요.\n\n아래는 mock 스트리밍 데이터셋 아래에 있는 상대적으로 복잡한 deephaven.ui 대시보드입니다. 이것을 IDE로 복사하여 붙여넣기하고 deephaven.ui가 얼마나 유연하고 반응성 있는지 살펴보세요:\n\n```js\nfrom deephaven import ui, agg, empty_table\n\nfrom deephaven.stream.table_publisher import table_publisher\nfrom deephaven.stream import blink_to_append_only\n\nfrom deephaven.plot import express as dx\nfrom deephaven import updateby as uby\nfrom deephaven import dtypes as dht\n\nstocks = dx.data.stocks().reverse()\n\n...\n\ndashboard = ui.dashboard(my_layout(stocks, _stocks_with_stats))\n```","ogImage":{"url":"/assets/img/2024-06-22-BeautifuldashboardsinPythonwithfirst-classreal-timeintegration_0.png"},"coverImage":"/assets/img/2024-06-22-BeautifuldashboardsinPythonwithfirst-classreal-timeintegration_0.png","tag":["Tech"],"readingTime":3},{"title":"럭키 참스 시리얼, 얼마나 행운을 가져다줄까","description":"","date":"2024-06-22 16:40","slug":"2024-06-22-HowLuckyisaBowlofLuckyCharms","content":"\n\ntl;dr 버전: 학생 팀이 럭키참스 시리얼 그릇이 박스 전체에 걸쳐 동일하게 \"운이 좋은지\"를 결정하기 위한 실험을 디자인하고 수행하는 데 도움을 주었습니다. 결과는 별로다. 우리는 한 그릇당 약 2.7개 정도의 전체 참을 추가함에 따라 감소한다고 추정합니다. 첫 번째 그릇부터 마지막 그릇까지의 참은 50% 이상 줄어드는 것과 일치합니다. 시리얼의 무게도 역할을 하는 것으로 나타나며, 그릇을 일정하게 유지할 때 당 1g의 시리얼마다 평균적으로 0.5개 더 많은 참이 있는 것으로 추정됩니다. 그릇과 무게 사이의 상호 작용은 통계적으로 유의하지 않습니다.\n\n데이터, 코드, 사진 등을 확인하려면 이 GitHub 저장소를 참조하세요.\n\n[![BowlofLuckyCharms Image](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_0.png)](이미지 주소)\n\n## 배경\n\n<div class=\"content-ad\"></div>\n\n2010년대 초반에는 \"더블 스탭\" 오레오가 실제로 더블 스태프인지 여부에 대한 조사로 인해 인터넷 상에서 소란이 있었습니다. (실제로는 아닙니다.) 흥미로운 아이디어였고, 그 이후로 많은 자료가 작성되었습니다. 첫걸음으로 여기를 참고해보세요. 이 토론은 충분한 주목을 받아 몇몇 교사들이 수업 활동으로 해당 실험을 반복하는 것을 글쎄요 증명했으며, 현지 학생들은 10년 이상 후에도 자신들의 학교에서 유사한 실험을 수행했다고 보고했습니다.\n\n## 소개\n\n2023년 여름 어느 아침, 아침 식사로 럭키 참스를 먹고 있었습니다. 상자는 거의 비어가고, \"새 상자를 열 수 있게 될 때까지 기다릴 수 없어...\" 하고 내게 한숨을 내쉬었습니다. 저와 비슷한 사람이거나 수백만 명의 다른 사람들처럼, 당신이 럭키 참스를 좋아하고 기억할 수 있는 한을 넘어 60년간 생산되어 온 제품이었습니다. 그들은 정말로 마법 같이 맛있어요. 그런데 그 여름 아침에 숟가락을 쥔 채 앉아서 먹고 있는 그 시리얼 그릇이 전보다 조금 덜 마법 같았습니다. 뭔가 부족해 보였어요. (물론 상징인데요.) 제 생각일까요? 이 효과가 실재성이 있을까요? 그렇다면 측정할 수 있을까요?\n\n당시 대학생 확률 및 통계 과목을 가르치고 있었고, 네 명의 학생과 함께 이를 밝혀보기로 결심했습니다.\n\n<div class=\"content-ad\"></div>\n\n# 실험과 데이터\n\n토론을 거친 후, 팀은 다음 재료와 방법을 결정했습니다.\n\n## 재료\n\n- 가족 사이즈 럭키 참스 6박스 (18.6oz, 527g)\n- 전자 주방 저울\n- 플라스틱 “그릇” 2개, A 그릇과 B 그릇 (각각 40.125g 및 28.375g)\n- 폐기물을 담을 큰 그릇, 일부 휴지봉투, 기타 용품\n\n<div class=\"content-ad\"></div>\n\n럭키 참스는 지역 소매업체인 월마트에서 구입했어요. n = 6 상자에 특별한 점은 없었는데, 이것은 한 번의 여행으로 6층 카파로 홀의 6층에 두 손으로 운반할 수 있는 상자의 수였어요. 부엌 저울은 시리얼의 무게를 측정하기 위한 것이었는데, 팀은 이것이 중요할 것이라고 생각했고, 또한 시럽을 정확히 매번 샘플링하는 데 과도하게 전념하고 싶지 않았어요.\n\n![이미지](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_1.png)\n\n# 방법\n\n이 실험의 목적을 위해 \"그릇\"은 상자에서 권장된 대로 (1컵 또는 36g) 대략적으로 1인분의 시리얼을 의미했어요. 아침 식사로 럭키 참스의 36g를 먹기에는 작은 요술사나 리틀매직나인을 제외하고는 불가능하다 고 봐도 될 만큼이나 적은 양이었어요. 팀은 그릇 크기 일치에 특별히 까다롭지 않았고, 1컵에 가까운 양이라면 충분하다고 생각했어요. 어차피 부엌 저울로 시리얼의 질량을 고려하고 있었기 때문에 우리는 건강한 범위의 관측 무게를 목표로 삼았어요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_2.png\" />\n\n시리얼 한 그릇씩은 상자에서 바로 플라스틱 용기로 붓고, 체중을 측정한 후에 토스트된 오트밀은 마시멜로와 분리되어 버려졌습니다. 그런 다음, 다음 여덟 가지 행운의 매력적인 종류가 인식되고 숫자가 기록되었습니다: 핑크 하트, 무지개, 보라색 굴초, 파란 달, 녹색 클로버, 유니콘, 맛있는 빨간 풍선, 그리고 주황색 별.\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_3.png\" />\n\n가끔 그릇 안에는 작은 마시멜로 조각이 있었습니다; 모든 매력이 100% 완전하지는 않았습니다. 이를 처리하기 위해, 팀은 조각을 매력의 종류(녹색 클로버, 파란 달 등)로 분류하려고 노력했으며, 그 종류를 확인할 수 있다면 해당 분류에서 그 조각을 1로 계산했습니다. 조각이 불명확하거나 유형 식별에 너무 작으면 버렸습니다.\n\n<div class=\"content-ad\"></div>\n\n# 데이터\n데이터는 두 차례에 걸쳐 수집되었습니다. 학생들은 캐릭터를 부어서 세는 것을 쌍으로 협력하여 수행했습니다. 저는 저울과 무게 값을 기록해 컴퓨터에 입력하기 위해 불려지는 동안 하드 복사본을 도왔습니다. 팀은 데이터 수집 분위기에 접어들었고 실험이 끝날 때까지 4명의 학생이 독립적으로 캐릭터를 부어서 세었습니다.\n\n![이미지](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_4.png)\n\n플라스틱 용기 + 시리얼은 매 라운드마다 함께 저울에 올려 차곡차곡 무게를 측정하였고 실험 초기에 측정된 용기의 무게가 관찰된 총 무게에서 빼졌습니다. 캐릭터는 각각의 열에 입력되어 총계가 계산되었습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_5.png)\n\n# 측정된 변수\n\n- 상자: 상자 번호 (1부터 6번)\n- 그릇: 각 상자의 연속 그릇 (1부터 13까지 범위)\n- 관측: 상자 전체에서 그릇의 관찰된 순서 (1부터 69까지)\n- 전체 무게: 플라스틱 용기와 시리얼의 무게(그램)\n- 무게: 용기의 무게를 뺀 시리얼의 무게(그램)\n- 하트, 별, 기타: 해당 그릇에 대한 그 매력의 개수\n- 전체 매력: 여러 매력의 총합\n\n![이미지](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_6.png)\n\n\n<div class=\"content-ad\"></div>\n\n여기 R 코드로 데이터 세트의 상위 부분(첫 6행)을 읽고 표시하는 방법이 있습니다. 이 데이터 및 모든 코드는 이 GitHub 저장소에서 공유됩니다.\n\n```R\nlibrary(readxl)\nLucky <- read_excel(\"Lucky.xlsx\")\nLucky$Box <- as.factor(Lucky$Box)\nhead(Lucky)\n```\n\n이 데이터를 사용하면 관찰된 무게의 평균은 약 46.3g이었고, 한 그릇에 특정 매력의 최대 수는 15개였습니다(분홍색 하트가 자주색 편못과 동일함). 실제로 이 데이터 집합에 대한 통계를 계산하는 데 하루 종일 할애할 수 있지만, 현재는 주로 Totcharms 및 그것이 그릇과 어느 정도 무게와 관련이 있는지에 초점을 맞추고 있습니다.\n\n다음은 그릇별 Totcharms의 그래프입니다. 상자로 색칠되었습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nLucky |> ggplot(aes(x = Bowl, y = Totcharms, color = Box)) + \n  geom_point(size = 3) +\n  labs(y = '# Charms') -> p1\np1\n```\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_7.png\" />\n\n여기서는 볼의 증가에 따라 Totcharms가 감소하는 명확한 추세를 볼 수 있으며, 패턴이 놀랍도록 선형적입니다. 약간의 곡률이 있을 수 있습니다. 색상을 구분하기 어렵기 때문에 라인 플롯을 만들고 몇 가지 시리즈를 강조해 보겠습니다:\n\n```js\nsizes <- c(2, 1, 2, 1, 1, 1)\nalphas <- c(1, 0.2, 1, 0.2, 0.2, 0.2)\nLucky |> ggplot(aes(x = Bowl, y = Totcharms)) +\n  geom_line(aes(colour = Box, linewidth = Box, alpha = Box)) +\n  scale_discrete_manual(\"linewidth\", values = sizes) +\n  scale_alpha_manual(values = alphas, guide = \"none\")\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_8.png\" />\n\n모든 시리즈가 전반적으로 하강하는 추세를 보이지만, 각 상자별로 그 경로는 다양합니다. Box 3이 높은 위치에서 시작해 몇 개의 그릇마다 높은 위치에 머물다가 10그릇까지 부드럽게 내려가다가 곧 허사로 떨어지는 모습을 주목해 보세요. Box 1은 군중 중에서 가장 낮은 위치에서 시작하여 5그릇 후에 증가하며, 8그릇에 정점을 찍은 뒤 12그릇까지 급격히 하강하는 모습을 살펴보세요. 데이터에 따르면 Box 3 꼭대기 부근에 매력을 집중시켰지만, Box 1 중간 부분에 몰려 있었습니다. 일부 상자는 왔다갔다 하고, 다른 상자는 더 일직선적으로 내려가죠. 하지만 모두를 합치면 전반적으로 감소하는 선형적인 추세를 보입니다. 모든 상자가 적어도 11그릇까지는 갔지만, 12그릇을 가진 상자는 2개 뿐이었고, 하나의 상자인 Box 4만 13그릇까지 간 것을 유의하세요.\n\n이제 Totcharms 대 Weight를 비교해 보겠습니다:\n\n```js\nLucky |> ggplot(aes(x = Weight, y = Totcharms, color = Box)) + \n  geom_point(size = 3) +\n  labs(x = 'Weight (g)', y = '# Charms') -> p2\np2\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Plot Image](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_9.png)\n\n이 플롯은 소음이 많습니다. 최소 무게가 30g 미만부터 최대 무게가 70g 근처까지 다양한 무게 범위를 갖고 있습니다. 특이하게 하나의 그릇이 예외적으로 무거운 무게를 기록했습니다. 이 이상치에는 명백한 설명이 없지만 조금 더 깊이 파고들어 Weight 대 Bowl을 플롯하면 어떤 통찰을 얻을 수 있을지도 모릅니다.\n\n```js\nLucky |> ggplot(aes(x = Bowl, y = Weight, color = Box)) + \n  geom_point(size = 3) + ylim(5, 75) +\n  labs(y = 'Weight (g)') -> p3\np3\n```\n\n![Plot Image](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_10.png)\n\n\n<div class=\"content-ad\"></div>\n\n아쉽게도 그 특정 데이터 포인트의 출처는 시간이 흘러 잊혀진 상태입니다. 하지만 팀이 처음 마무리한 상자였기 때문에 최종적으로 남은 시리얼 양을 판단하는 것이 어려웠을 수도 있으며, 아마 모든 잔여물이 그 마지막 그릇에 붓겨진 것일 수도 있습니다. 아침 식사할 때도 종종 시리얼 상자를 비우려고 할 때 비슷한 일을 하곤 합니다. 만약 그 70g의 12번째 그릇을 (예를 들어) 40g과 30g의 그릇 두 개로 나누었다면, 단 하나가 아니라 두 상자가 모두 13그릇까지 갈 수도 있었고, 아마 아래 모델들이 데이터에 조금 더 잘 맞을지도 모릅니다. 아쉽게도, 그렇게 알 수 없습니다. 과학적인 기업이란 바로 그런 것이죠.\n\n복적과 무게 자체로는 선형 관계가 크지 않지만, Totcharms, Bowl 및 Weight 간에 숨겨진 관계가 있습니다. 이 관계는 3D 시각화로 가장 잘 탐색할 수 있습니다:\n\n```js\nlibrary(plotly)\nfig <- plot_ly(Lucky, x = ~Bowl, y = ~Weight, z = ~Totcharms, color = ~Box) |>\n  add_markers() |>\n  layout(scene = list(xaxis = list(title = '그릇'),\n                                   yaxis = list(title = '무게 (g)'),\n                                   zaxis = list(title = '# 별')),\n                      legend=list(title=list(text='상자')))\nfig\n```\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_11.png\" />\n\n<div class=\"content-ad\"></div>\n\n3D 플롯은 정말 멋져요, 하지만 위의 정적 디스플레이는 데이터에 정의를 제대로 하지 못해요. 저는 대부분의 모바일/데스크톱 브라우저에서 작동하는 대화형 플롯 버전을 다음 링크에 설정했어요:\n\n거기로 가서 데이터를 돌리고, 확대 및 축소, 이동 등을 확인해보세요. 정확히 올바르게 돌리면 데이터가 3D 공간의 평면 주위에 흩뿌려진 것을 볼 수 있을 거에요. 이것이 우리가 여러 선형 회귀 모델에서 찾고 있는 관계의 정확한 종류에요 (우리는 잠시 후에 다룰 거에요).\n\n# 모델 맞추기\n\n이제 이 변수들 간의 선형 관계를 양적으로 측정해보도록 할게요. Totcharms와 Bowl 간의 단순 선형 회귀 모델부터 시작할 거에요.\n\n<div class=\"content-ad\"></div>\n\n# 그릇\n\n다음은 모델입니다:\n\n```js\nmod1 <- lm(Totcharms ~ 그릇, data = Lucky)\nsummary(mod1)\n```\n\n```js\n## \n## Call:\n## lm(formula = Totcharms ~ 그릇, data = Lucky)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -16.7629  -5.7629  -0.4327   6.2277  22.2277 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)    \n## (Intercept)  55.1309     2.1237  25.960  < 2e-16 ***\n## 그릇         -2.6698     0.2985  -8.945 4.81e-13 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 8.313 on 67 degrees of freedom\n## Multiple R-squared:  0.5442, Adjusted R-squared:  0.5374 \n## F-statistic: 80.01 on 1 and 67 DF,  p-value: 4.807e-13\n```\n\n<div class=\"content-ad\"></div>\n\n볼이 고치에 강하게 선형으로 연관되어 있음을 알 수 있습니다. 볼의 기울기는 대략 -2.7이며, 다시 말해, 럭키 참즈 한 그릇을 추가로 먹을 때마다 평균 Totcharms가 2.7개 줄어들 것으로 추정됩니다. 결정 계수(R²)는 0.5442로, Totcharms의 분산의 약 54%가 Bowl을 예측 변수로 사용한 회귀 모델에 의해 설명됨을 의미합니다. 다음으로 적절한 잔차 분석을 포함해야 하지만 일단 건너뛸 것입니다. 말 그대로, 잔차 그림이 상대적으로 잘 작동합니다. 기본값으로 회귀선에 대한 신뢰 대역이 포함된 적합된 선 그래프를 확인해 보겠습니다:\n\n```js\np1 + geom_smooth(method = \"lm\", aes(group=1), colour=\"black\")\n```\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_12.png\" />\n\n단 명확한 감소 추세가 있는 멋진 관계입니다.\n\n<div class=\"content-ad\"></div>\n\n# 무게에 대한\n\n우리는 무게에 대해 동일한 작업을 할 것이며, 일단 그릇을 무시할 것입니다. 여기서 시작합니다:\n\n```js\nmod2 <- lm(Totcharms ~ Weight, data = Lucky)\nsummary(mod2)\n```\n\n```js\n## \n## Call:\n## lm(formula = Totcharms ~ Weight, data = Lucky)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -27.0151  -8.7745   0.6901   7.8328  24.4701 \n## \n## Coefficients:\n##             Estimate Std. Error t value Pr(>|t|)  \n## (Intercept)  22.1370    10.5650   2.095   0.0399 *\n## Weight        0.3502     0.2256   1.552   0.1254  \n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 12.1 on 67 degrees of freedom\n## Multiple R-squared:  0.0347, Adjusted R-squared:  0.02029 \n## F-statistic: 2.409 on 1 and 67 DF,  p-value: 0.1254\n```\n\n<div class=\"content-ad\"></div>\n\nWeight가 단독으로 Totcharms를 예측하는 데 유용하지 않다고 생각합니다. 이는 이전에 본 산점도와 일치합니다. Weight의 기울기는 0.3502로, 행운의 매 당 1g 추가는 평균적으로 0.35 매의 Totcharms 증가에 해당합니다. 이는 합리적으로 들립니다: 시리얼이 많으면 매력도 많아집니다. 결정 계수는 상당히 낮습니다: R² = 0.0347, 즉 Totcharms의 분산 중 약 NONE%가 Weight를 예측 변수로 사용하는 회귀 모형에 의해 설명된다는 것입니다. 괜찮아요; Weight는 시리얼 양의 가변성을 조절하기 위한 보조 장치였습니다. 여기서 잔차 분석 결과는 생각했던 것보다 그리 나쁘지 않았습니다. 무엇보다 위/아래 끝의 극단적인 관측치가 포함되어 있기 때문에 일부 문제가 예상되었습니다. 완성도를 위해 또 다른 적합 선 그래플을 넣었습니다:\n\n```js\np2 + geom_smooth(method = \"lm\", aes(group=1), colour=\"black\")\n```\n\n<img src=\"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_13.png\" />\n\n원래 ggpubr 패키지를 사용하여 이러한 적합 선 그래프를 함께 놓고 토론에서 공간을 절약하려고 계획했지만, 그래프가 협소하고 정보가 나오지 않았습니다. 어쨌든, 내가 하려던 건 이거였어요:\n\n<div class=\"content-ad\"></div>\n\n```r\nlibrary(ggpubr)\nggarrange(p1 + geom_smooth(method = \"lm\", aes(group=1), colour=\"black\"),\n          p2 + geom_smooth(method = \"lm\", aes(group=1), colour=\"black\"),\n          align = 'h', labels=c('A', 'B'), legend = \"right\",\n          common.legend = TRUE)\n```\n\n# Multiple regression\n\n이제 재미있는 부분으로 넘어가 봅시다: Totcharms ~ Bowl 및 Totcharms ~ Weight 관계를 개별적으로 탐색해 보았지만, 이들을 함께 넣으면 어떻게 될까요? 알아보죠:\n\n```r\nmod3 <- lm(Totcharms ~ Bowl + Weight, data = Lucky)\nsummary(mod3)\n```\n\n<div class=\"content-ad\"></div>\n\n```js\r\n## \n## 호출:\n## lm(formula = Totcharms ~ Bowl + Weight, data = Lucky)\n## \n## 잔차:\n##      Min       1Q   Median       3Q      Max \n## -12.8825  -5.4425  -0.9975   5.2475  26.5304 \n## \n## 계수:\n##             추정치 표준 오차 t 값 유의확률    \n## (Intercept)  33.3168     6.8655   4.853 7.78e-06 ***\n## Bowl         -2.7552     0.2796  -9.855 1.35e-14 ***\n## Weight        0.4819     0.1452   3.318  0.00148 ** \n## ---\n## 유의수준:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## 잔차 표준 오차: 7.754, 자유도: 66\n## 다중 R-제곱:  0.6094, 조정 R-제곱:  0.5976 \n## F-통계량: 51.49, 자유도: 2, 66,  p값: 3.363e-14\r\n```\n\n여기 보세요! 이제 Bowl과 Weight는 Totcharms와 강한 선형 관계가 있습니다. Bowl의 기울기는 거의 이전과 같은 -2.7이지만, Weight의 추정 기울기는 거의 0.5 charms로 증가했습니다. 각각의 추가적인 1g 시리얼에 대해. (조정된) 다중 R²가 거의 60%로 상승했습니다. 이는 샘플 크기(n = 6), 데이터셋의 일반적인 잡음 수준 및 (작은 마시멜로 조각이 1로 계산된다든가 하는) 의문을 제기할만한 설계 선택에도 불구하고 주목할 만한 것입니다. 회고적으로, 데이터가 훨씬 나쁠 수 있었음에도 불구하고 꽤 놀라운 것입니다.야외에서 손수 수집된 실제 데이터는 그리 친절하지 않은 경우가 흔합니다.\n\n# 회귀 평면 추가\n\n이 시각화를 위한 코드는 다른 예제들보다 좀 더 복잡하고, 간결함을 위해 생략되었지만, 이 모든 것을 GitHub Gist에서 확인할 수 있습니다. 이제 그림을 살펴보도록 하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_14.png)\n\n다시 말해요: 정적 버전만으로는 데이터를 충분히 표현할 수 없어요. 대화형 버전을 확인해보세요:\n\n대화형 3D 플롯은 정말 재미있어요. 그래프와 놀면서 즐기시는 만큼 저도 즐겁게 살포시 플레이했어요. 마지막으로, tl;dr 문구에서 우리는 \"보울과 무게 사이의 상호작용이 중요하지 않다\"고 주장했어요. 독자는 다음과 같은 출력을 통해 확인할 수 있어요 (출력은 생략됨):\n\n```js\nsummary(lm(Totcharms ~ Bowl * Weight, data = Lucky))\n```\n\n<div class=\"content-ad\"></div>\n\n# 토론 및 질문\n\n원래 전체적으로 생각했던 것은 모든 것이 내 상상의 산물이거나 효과가 너무 작아서 'Lucky Charms'가 많이 필요할 수 있다는 것이었습니다. 두 가지 모두 잘못되었습니다. 효과는 실제로 존재하며, 손으로 두 개 상자분을 사용하여 감지할 수만 있다는 것을 깨달았습니다.\n\n# 럭키 참 드롭\n\n전체 모델을 통해 우리는 빠르게 몇 가지 놀라운 결론에 도달합니다. 예를 들어 'Lucky Charms' 상자의 첫 번째 그릇에 얼마나 많은 부적을 추정하십니까? 이 연구에서 평균 무게가 46.3g임을 앞서 확인했습니다. 상자 = 1 일 때, 모델은 평균 부적(Charms) 수를 어림잡아 추정합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n33.3168 + (-2.7552)*1 + 0.4819*46.3\n```\n\n```js\n## [1] 52.87357\n```\n\n그래서 첫 번째 시리얼 그릇에는 약 53개의 매료가 들어 있어요—음, 입맛이 벌써 돕니다. 마지막 그릇은 어떨까요? 좋아요, 모든 상자가 13그릇까지 만들지는 못했지만, 모든 상자가 11그릇까지는 만들었어요. 매료가 몇 개 들어 있을까요?\n\n```js\n33.3168 + (-2.7552)*11 + 0.4819*46.3\n```\n\n<div class=\"content-ad\"></div>\n\n\n## [1] 25.32157\n\n\n와우. 평균 25.3개의 매력이 있네요. 이것은 첫 그릇부터 열한 번째 그릇까지 매력이 52% 감소했다는 것을 의미합니다. 아니요, 제 상상력이 아닙니다. 다변수 선형 회귀 모델이나 화려한 3D 플롯은 잊어버리세요, 배고픈 유아도 눈을 가리고 이 차이를 감지할 수 있을 것입니다.\n\n다음 질문은 무엇일까요? 왜 감소하는 걸까요? 물리적인 측면에서 분석해보면 이렇게 설명할 수 있습니다: 럭키 참스를 박스 단위로 간단한 기계적인 혼합물로 간주합니다. 설탕이 올라간 구운 꺾은 꺼풀과 마시멜로우의 혼합입니다. 운송 중에 흔들림이나 가게 선반에 올려놓는 과정, 집으로 운송하는 과정, 그리고 찬장 주변의 활동 등 많은 외부 힘들이 상자를 괴롭힙니다. 그 결과 약간 밀도가 낮은 마시멜로우는 상자의 윗부분으로 이동하고, 밀도가 높은 구운 꺾은 꺼풀은 상자의 아랫부분으로 쌓입니다.\n\n이런 논리는 타당하다고 생각합니다. 하지만 이에 관련된 몇 가지 질문은 답이 없습니다:\n\n<div class=\"content-ad\"></div>\n\n- 개별 매력 유형에 대해서도 동일한 패턴이 유지되는가요? (빠르게 봤을 때 \"아니요\"라는 것을 시사합니다.)\n- 연관성이 정말 선형인가요, 아니면 더 복잡한 모델이 관계를 더 잘 설명할까요?\n- 우리가 간과한 중요한 요인은 무엇인가요?\n- 행운의 부적이 감소하는 것을 늦추는 데 사용할 수 있는 전략은 무엇인가요?\n\n- 우리는 매운맛을 더 잘 섞기 위해 상자를 똑똑하게 흔들 수 있을까요? (어떻게든)\n- 보관 방법은 어떤가요? 상자를 거꾸로 보관하는 것이 도움이 될까요?\n- 아니면 옆으로 평평하게 두는 것은요?\n- 등등.\n\n이러한 미해결된 질문들은 다음 기회로 미루어야 할 것 같습니다.\n\n# 다음 단계\n\n<div class=\"content-ad\"></div>\n\n오리지널 실험 이후 2023년 여름, 더 많은 학생 그룹들과 몇 번의 실험을 다시 진행했어요. 첫 번째는 2023년 11월 YSU 메가매쓰 데이에서 중학생들과 함께한 실험이었어요. 메가매쓰 학생들에게 매우 구체적인 지침을 주지 않아서, 상자에서 시리얼 봉지를 빼고 탁상 위로 펴진 봉지 중앙에서 스쿱을 하는 것을 발견했어요. 그들을 탓할 수 없었어요; 봉지를 펼쳐놓은 것이 중앙에서 시리얼을 스쿱하기 더 편리하니까요. 안타깝게도, 이 접근법은 존재했을 지도 하는 어떠한 천연 밀도 정렬 순서도 완전히 파괴했고, 이것이 우리가 의심하는 핵심 기저 요소인 실험의 무결성을 저해했어요. 게다가, 아무도 부모님이 든지 Lucky Charms를 그렇게 먹는 걸 허락하지 않을 거라고 생각해요.\n\n두 번째 실험은 2024년 2월 YSU 수학 축제에서 고등학생들을 대상으로 진행한 두 개의 워크샵 연속으로 진행되었어요. 이번에는 그들을 위해 준비가 돼 있었어요. 더 자세한 지침이 담긴 데이터 수집 시트를 만들어 배포했어요. 여기에서 찾아볼 수 있어요. 추가 데이터셋은 GitHub의 extraData 디렉토리에서 확인할 수 있어요.\n\n앞으로, Lucky Charm의 손실을 더 정확히 추정하기 위해 더 많은 데이터가 필요하고, 상자 안의 Charm을 더 균일하게 분배하는 전략을 테스트하는 것이 흥미로울 것 같아요. 성공한다면, 상자의 첫 번째 그릇은 그렇게 마법적이지 않을 수 있겠지만, 반면에 마지막 그릇들은 새로운 Lucky Charms 상자를 열기를 기다리는 짐 같이 느껴지지 않을 수도 있겠죠!\n\n# 감사의 글\n\n<div class=\"content-ad\"></div>\n\n이 실험과 결과는 여름 2023에 STAT 3743 수업을 듣는 Brenna Brocker, Kate Coppola, Gavin Duwe, 그리고 Haziq Rabbani 네 명의 학생들의 열정적인 도움과 섬세한 주의 덕분에 가능했습니다. 나는 그들이 이 통계적인 길을 함께 걸어준 데 대해 감사하게 생각합니다. 또한, Youngstown State University의 수학 및 통계학 부서가 이 연구와 YSU MegaMath Day 및 YSU MathFest에서의 추가 데이터 수집을 지원해 준 데에도 감사드립니다.\n\n# 공표사항\n\n이미 명백하게 나타났겠지만, 저자와 네 명의 학생 모두가 Lucky Charms 팬이라는 것을 알려드립니다. 여기서 보고된 결과는 General Mills, Inc.와 그 계열사, 공장 생산 기준, 그리고 일하는 사람들 또는 로봇들에 대한 비평이 아니며, 우리는 모두 동일한 물리 법칙에 얽힘을 알아야 합니다. 아침 식사 시리얼 상자도 포함됩니다.\n\n또한, 전체 자료를 재실행하여 수집한 이 추가 데이터를 엿보았습니다. 내가 볼 수 있는 한에, 그 영향은 여전히 존재하지만, 그 정도는 그리 극적이지 않습니다. 원래 추정한 것보다 효과가 실제로 더 작은지, 아니면 중/고등학교 설정에서의 데이터 수집 프로토콜과 어떤 관련이 있는지 알 수 없습니다. 시간과 더 많은 자료가 말해줄 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료 및 코드 예제\n\n이 문서를 작성하는 동안 필요한 그래프를 만들기 위한 코드를 찾아다니면서 대부분의 링크들을 기록해 보았습니다. 하지만 몇 가지 빠뜨린 링크들이 있을 수도 있습니다. 만약 빠진 부분이 있으면 댓글로 알려주시면 수정하도록 하겠습니다.\n\n- https://stackoverflow.com/questions/74750478/correct-syntax-for-manually-scaling-the-width-of-lines-in-ggplot\n- https://www.statology.org/ggplot-default-colors/\n- https://stackoverflow.com/questions/37348719/ggplot2-single-regression-line-when-colour-is-coded-for-by-a-variable\n- http://blog.recursiveprocess.com/2013/03/03/oreo-original-vs-double-vs-mega/\n- https://stackoverflow.com/questions/38331198/add-regression-plane-to-3d-scatter-plot-in-plotly\n- https://stackoverflow.com/questions/38593153/plotly-regression-line-r\n- https://stackoverflow.com/questions/15633714/adding-a-regression-line-on-a-ggplot","ogImage":{"url":"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_0.png"},"coverImage":"/assets/img/2024-06-22-HowLuckyisaBowlofLuckyCharms_0.png","tag":["Tech"],"readingTime":16},{"title":"치우친 분포 시각화에 유용한 데이터 시각화 기법 5가지","description":"","date":"2024-06-22 16:38","slug":"2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution","content":"\n\n## 클러스터링된 데이터에서 숨겨진 패턴을 발견하는 주요 기술\n\n왜곡된 데이터는 매우 불균형한 분포를 갖는 데이터를 가리킵니다. 대부분의 데이터 포인트가 분포의 왼쪽에 집중되어 있으며 긴 꼬리가 오른쪽 쪽으로 뻗어 나간다(오른쪽으로 치우친 경우) 또는 그 반대(왼쪽으로 치우친 경우), 더 복잡한 왜곡 패턴일 수 있습니다. 긴 꼬리(희소 데이터)가 그래픽 공간을 지배하며 대부분의 데이터 포인트를 플롯 모서리로 압축하여 클러스터링된 데이터 대다수의 근본적인 패턴을 확인하기 어렵게 만듭니다.\n\n이 글에서는 왜곡된 분포를 가진 데이터를 시각화하는 강력한 방법을 요약했습니다.\n\n# 투명도, 비어 있는 원, 색상 및 주변 분포를 사용하여 클러스터링된 데이터 패턴 드러내기\n\n<div class=\"content-ad\"></div>\n\n왼쪽의 scatterplot은 주택 판매량과 가격 간의 관계를 보여줍니다. 높은 판매량에서의 희소한 데이터 포인트는 대부분의 데이터를 플롯의 왼쪽 가장자리로 쫓아가게 합니다. 이는 중요한 데이터 포인트 클러스터링 및 겹침으로 이어지며 기저 분포 패턴을 가리게 만듭니다.\n\n![scatterplot](/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_0.png)\n\n오른쪽의 개선된 scatterplot은 데이터의 비대칭성을 진단하고 기저 데이터 구조를 드러내기 위해 몇 가지 간단한 기술을 사용합니다:\n\n- 점 크기 축소 및 윤곽 내의 모양 (속이 채워진 원 대신 열린 원과 같은)은 데이터가 겹치는 것을 완화하는 데 도움이 됩니다.\n- 데이터 포인트의 투명도는 데이터 클러스터링의 정도를 드러내는 데 도움을 줍니다.\n- 색상은 데이터 패턴을 드러내는 데 중요한 도구입니다. 이 경우 다른 도시의 점들을 다양한 색상으로 보여줌으로써 도시가 가격과 판매에 미치는 영향이 데이터 변동성의 중요한 소스임을 강조합니다.\n- 단변량 분포의 주변 시각화는 비대칭성의 원인을 보여줍니다. 여기서는 판매량 (x 축) 및 가격 (y 축)의 분포를 바코드 이미지와 밀도 플롯으로 표시했습니다. 이를 통해 판매량이 주요하게 비대칭된 변수임을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n# 데이터를 각 왜도 소스별로 서브플롯으로 분할하기\n\n위 그래프는 해당 도시가 데이터 왜도의 중요한 기여 요소임을 시사합니다. 데이터 왜도 분포에 도시의 영향을 제거하려면 여기서는 각 도시별로 서브플롯으로 그래프를 나누어 각 도시에 대한 축 스케일이 별도로 표시됩니다.\n\n![Plot](/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_1.png)\n\n도시 변수를 데이터 왜도의 중요한 소스로 식별하고, 각 도시별로 서브플롯을 만들어 데이터 왜도를 줄인 데 운이 좋았지만, 다른 데이터 시각화 작업에서 이렇게 할 수 있는 것은 항상 쉽거나 가능한 것은 아닙니다. 또한, 고집 센 이상치는 단일 변수 내에서 존재할 수 있으며, 서브플롯을 만들어 해결할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n아래 토론에서는 도시 변수의 서브플롯에 의존하지 않고, 왜곡된 데이터셋을 시각화하는 기술을 직접 시연할 것입니다.\n\n## 왜곡된 데이터 시각화를 위한 2D 히스토그램 생성\n\n2D 히스토그램은 산점도에서 마주치는 데이터 왜곡을 해결하기 위한 가장 효율적인 접근 방식 중 하나입니다. 이는 x 및 y 축을 따라 n개의 간격/바구니를 생성하고, 플롯을 n × n 셀의 그리드로 나눕니다. 각 셀 안에 떨어지는 데이터 포인트 수를 세어서 컬러 스케일에 매핑합니다. 더 높은 바구니 번호는 더 높은 해상도를 제공합니다.\n\n![2D 히스토그램으로 왜곡된 데이터 시각화하기](/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 2D 밀도 플롯 생성\n\n2D 밀도 플롯은 2D 히스토그램과 유사하지만 이산적 간격에서 카운트를 생성하는 대신에 기본 연속 데이터의 확률 밀도 함수(PDF)를 추정합니다. (밀도는 연속적 등고선 또는 이산 그리드로 그려낼 수 있습니다.)\n\n왼쪽에 있는 밀도 플롯은 플롯의 좌하단에 데이터 포인트의 극도로 집중된 것을 강조하고, 나머지는 아주 드문 데이터 포인트들이 최소 밀도값을 갖고 전혀 배경으로 완전히 섞인 것을 보여줍니다 (밀도가 0인 배경).\n\n<img src=\"/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_3.png\" />\n\n<div class=\"content-ad\"></div>\n\n💡 보다 눈에 띄게 희소한 데이터를 보기 쉽게 만들기 위해, 먼저 밀도 값을 세제곱근으로 변환했습니다. 이 값들을 색상 스케일에 매핑했습니다. 세제곱근 변환은 밀도 값을 소수점 숫자의 값으로 증가시키지만 (밀도 값의) 영(零)에는 영향을 주지 않습니다. 이러한 방식으로 변환된 데이터는 배경 위에 \"높게\" 떠 있어서 더욱 쉽게 구별할 수 있도록 해주며, 밀집된 데이터 중심과 희소한 데이터 지역을 아주 잘 드러내줍니다. (그러나 소수점 숫자의 팽창 효과는 경우에 따라 원하지 않는 시각적 효과를 초래할 수 있음을 나중 예제에서 보여드릴게요.)\n\n# 데이터를 색상에 반영한 수학적 변환\n\n오른쪽에 있는 밀도 플롯은 수학적으로 변환된 데이터를 색상에 매핑하는 방법이 어떻게 숨겨진 데이터 구조를 효과적으로 드러내는지 명확히 보여줍니다. 하지만 저의 가장 좋아하는 예제는 아래에 있답니다.\n\n히트맵은 제곤지북 반경 당 아프리카 인구를 보여줍니다: 최소 밀도는 0(지도상의 이집트 대부분 지역 등)이며, 0.0000004에서 20,000까지의 비영(非零)값 범위가 있습니다. 대부분의 밀도 값은 제한된 지리적 지역에서만 발견됩니다. 밀도는 클래식 버리디스 색상 스케일로 반영되었습니다.\n\n<div class=\"content-ad\"></div>\n\n만약 데이터 변환을 하지 않은 상태에서는 지도가 완전히 검게 나옵니다 (왼쪽 플롯 참조): 매우 흩어진 대 값들(밝은 색으로 표시되는)이 작은 숫자들의 대부분에 의해 압도당하고 무시당합니다. \n\n<img src=\"/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_4.png\" />\n\n로그 변환은 넓게 퍼진 데이터를 처리하는 흔한 방법입니다. 이 방법은 데이터를 더 정규화된 분포로 변환하여 시각화하기 쉽게 만듭니다. 이 방법은 이집트의 나일 강을 따라 밀집된 인구와 같은 더 잘 그려진 데이터 패턴을 가진 히트맵을 만듭니다. (색상 막대는 원본 데이터가 아니라 변환된 데이터로 레이블이 지정되어 있어 해석이 쉽습니다). 그러나 이집트 대부분의 지역은 회색으로 가려져 있습니다. 이곳은 0인 인구 값을 가지고 있어 로그에 정의되지 않으므로 데이터가 \"누락된 값\"(-무한대, 구체적으로)으로 처리됩니다.\n\n의사 로그 변환은 큰 수를 위한 전통적인 로그 연산을 수행하나 값이 0에 접근할 때 선형 스케일로 점진적으로 전환됩니다. 큰 값과 분수적인 값, 그리고 0(음수 값 포함)을 부드럽게 처리합니다. 이러한 변환은 주요 지리적 위치와 지도상의 광활한 사하라 사막의 가혹한 환대를 강조한 잘 정의된 데이터 패턴을 보여주는 인상적인 히트맵을 생성합니다. 놀라운 기법의 자세한 내용은 이 기사에서 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n의사로그 변환과 비교하면, 높은 베이스(예: 7 ~ 10)를 가진 루트 변환은 유사한 시각적 효과를 얻습니다. 그러나 이집트와 일부 다른 장소는 검게 처리됩니다. 이는 루트 변환 때문에 분수를 팽창시키지만 0은 영향을 받지 않기 때문입니다. 이로 인해 변환된 분수와 0 사이에 급격한 불연속성이 발생하여, 이집트와 주변 지역 사이에 갑작스러운 색상 전환으로 반영됩니다. (더 많은 토론은 위에 링크된 동일한 기사에서 찾을 수 있습니다)\n\n여담으로 말씀드리자면, 원시 데이터의 수학적 변환이 아닌, 대신 색상과 이상치의 그래픽적 조정과 어떻게 연결해야 하는지를 전략적으로 조정할 수도 있습니다. 예를 들어 다음 히트맵은 백신 도입 전후 미국의 감염병 발생 횟수를 보여줍니다 (검은 선으로 표시됨). 이 그래프는 고발별의 낮은 발생률 데이터 대부분을 나타내기 위해 짧은 범위의 파란색과 녹색만 사용하고, 협소한 데이터 영역의 높은 발생률을 강조하기 위해 초록색과 빨간색 등 경고 신호의 다양한 색상 범위를 활용합니다. 이러한 디자인은 백신의 질병 통제 능력을 효과적으로 강조했습니다.\n\n# 데이터의 수학적 변환을 축에 대칭화\n\n이제 부동산 매매 가격 예시로 다시 돌아가봅시다. 아래 그래프들에서 x축은 10을 기준으로 한 로그 스케일로 변환됩니다. 이렇게 하면 보통 매우 모여 있는 데이터 포인트들이 데이터 구조를 밝혀내기 위해 더 넓은 범위로 펼쳐집니다. 재미를 더하기 위해 같은 데이터로 두 그래프를 만들었는데, 왼쪽은 각 포인트의 이웃 번호를 색상 스케일로 선형 매핑한 산점도이며, 오른쪽 그래프는 콘투어 서클로 이산화된 2D 히스토그램이며, 연속으로 확률 밀도 함수를 그리고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Golden Methods to Visualize Data with Skewed Distribution](/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_5.png)\n\n또 다른 예로, 아래 산점도는 1800년대부터 2015년까지 GDP와 인간 수명 기대치의 증가를 보여줍니다. 이는 축 로그 변환을 사용하여 그렇지 않으면 클러스터링 된 데이터 세트를 펼치는 것을 보여줍니다. x축이 log10 스케일인 반면 라벨은 원래 데이터 값으로 주석이 달려 있음을 주목하세요.\n\n![Golden Methods to Visualize Data with Skewed Distribution](/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_6.png)\n\n수학적 변환은 분포 프로필을 항상 변경하지는 않음을 유의하세요. 예를 들어, 평균으로 중심화하고 표준 편차로 스케일링하여 표준화된 z-점수로 변환하거나 [0, 1] 범위로 정규화하여 최솟값을 뺀 다음 최대값과 최소값의 차이로 스케일링하는 것은 이러한 맥락에서 분포 패턴을 변경하지 않습니다. 이러한 방법은 (다변량 모델링 및 주성분 분석과 같은 관련 시각화에서 중요하지만) 비대칭 데이터를 시각화하는 데 효과적이지 않습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 클러스터린된 데이터 지역 확대\n\n전체 데이터셋을 먼저 표시하고, 그 다음 가장 클러스터된 지역을 확대해서 자세한 시각적 확인을 할 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_7.png)\n\n## 마지막으로, 이 유용한 전략들을 아래에 요약합니다:","ogImage":{"url":"/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_0.png"},"coverImage":"/assets/img/2024-06-22-GoldenMethodstoVisualizeDatawithSkewedDistribution_0.png","tag":["Tech"],"readingTime":6},{"title":"PowerShell을 사용한 Windows 바로가기 만들기, 커스터마이징 및 위치 지정 방법","description":"","date":"2024-06-22 16:35","slug":"2024-06-22-WindowsShortcutsWithPowerShellHowToMakeCustomizeAndPointThemToPlaces","content":"\n\n이제와서 당신이 손에 가장 흔한 작업인 것처럼 확신을 갖고 \"응, 30분 만에 끝낼 거야!\" 라고 생각할 때 상황이 발생할 것입니다. 그리고 2시간 후에 일부 희미한 문서를 찾아보며, 코드 예제를 보면서 \"이게 정말 이런 건가?\" 라고 생생히 느낄 수도 있죠.\n\n얼마 전, Windows 11의 제어판 소리 설정의 \"녹음\" 패널에 데스크톱 바로 가기를 생성하고 배포해야 하는 상황이 발생했습니다. PowerShell에는 바로 가기를 생성하는 \"기본\" 방법이 없다는 것을 이미 알고 있어서 몇 가지 쉘 방법을 탐색할 예정이었습니다. 그런데 만약에 해당 바로 가기를 제어판 항목의 하위 메뉴로 가리키고 싶거나, 이미 컴퓨터에 존재하지만 동적 라이브러리 안에 저장된 사용자 정의 아이콘을 사용하고 싶다면 어떨까요?\n\n좋아요, 친애하는 독자 여러분, 해결 방법은 있습니다. 때로는 운영 체제의 내부를 살펴 경로를 찾아야 할 때도 있습니다. Windows 바로 가기를 생성하고 사용자 정의하는 방법에 대해 자세히 알아봅시다.\n\n<div class=\"content-ad\"></div>\n\n# 단축키, 심볼릭 링크 및 PowerShell\n\n우선 중요한 것은 PowerShell에 내장된 New-Item cmdlet을 사용하여 심볼릭 링크를 만들 수 있는 방법이 있다는 것입니다.\n\n```js\nNew-Item -ItemType SymbolicLink -Path \"C:\\example-link.lnk\" -Target \"C:\\Users\\dbilanoski\\Documents\\some-text.txt\"\n```\n\n다른 곳에서 이와 같은 단축키를 생성하는 방법을 제안하는 지침을 만날 수 있습니다. 그러나 주의해야 할 점은 이러한 것들이 정확히 동일한 것이 아니라는 것입니다.\n\n<div class=\"content-ad\"></div>\n\nSymbolic links(심볼릭 링크)는 파일 시스템 자체에서 해석된 다른 파일로의 직접적인 링크입니다. 일반 파일과 다르며 크기가 없으며 응용 프로그램이 이를 내재적으로 인식합니다. 사용할 때 실제로 링크된 대상을 직접 사용하는 것처럼 사용됩니다.\n\n한편 바로 가기(Shortcuts)는 Windows 사용자 인터페이스에서 해석된 참조된 객체의 경로를 포함하는 일반 파일입니다. 크기가 있으며 아이콘으로 구성될 수 있으며 사용할 때 이를 읽고 있는 무언가와 대상 경로를 갖고 있어야 합니다(Windows 사용자 인터페이스).\n\nWindows에서 바로 가기가 필요할 때는 바로 가기를 원할 것입니다. 왜냐하면?\n\n- 바로 가기는 참조하는 파일을 추적하여 변경 사항이 발생할 때 업데이트되어 깨질 가능성이 줄어듭니다.\n- 파일과 폴더 외에도 네트워크 위치, 구성 패널, 파일 시스템에 있는 파일 경로로 존재하지 않는 특수 폴더를 엽니다.\n- 특정 폴더의 컨텍스트에서 시작되도록 구성된 바로 가기를 사용할 수 있습니다.\n- 심볼릭 링크를 사용하면 대상 경로에 실행 파일에 대한 명령줄 인수를 포함할 수 없습니다.\n- 아이콘을 심볼릭 링크에 구성할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n단축키를 친숙하고 편리하게 만드는 이유는 Windows 사용자 인터페이스(셸)에서 처리하기 때문입니다. Windows 사용자 인터페이스는 추가 기능과 편의성을 제공합니다. 그러나 PowerShell에서 이를 만들기 위해서는 셸 메소드에 접근해야 하며, 이로 인해 프로세스가 조금 더 복잡해지게 됩니다.\n\n# 서둘러야 할 때를 위해\n\nPowerShell을 사용하여 단축키를 만들고 고유 아이콘을 사용자 정의하려면 아래의 기본 예시를 참고하세요. 특정 상황에 맞게 경로와 파일 이름을 수정해야 합니다.\n\n```js\n$ShortcutTarget= \"타겟-경로\\타겟-이름\"\n$ShortcutFile = \"단축키-경로\\단축키-이름.lnk\"\n$WScriptShell = New-Object -ComObject WScript.Shell\n$Shortcut = $WScriptShell.CreateShortcut($ShortcutFile)\n$Shortcut.TargetPath = $ShortcutTarget\n$Shortcut.IconLocation = \"아이콘-경로\\아이콘-이름.ico\"\n$Shortcut.Save()\n```\n\n<div class=\"content-ad\"></div>\n\n한 줄로 된 스크립트가 필요하시면:\n\n```js\n# PowerShell 스크립트용\n$ws = New-Object -ComObject WScript.Shell; $s = $ws.CreateShortcut('실행할-바로가기-파일-경로\\바로가기-파일명.lnk'); $s.TargetPath = '대상-파일-경로\\대상-파일명'; $s.IconLocation = '아이콘-파일-경로\\아이콘-파일명.ico'; $s.Save()\n\n# 배치 (CMD) 스크립트용\npowershell -ExecutionPolicy Bypass -Command \"$ws = New-Object -ComObject WScript.Shell; $s = $ws.CreateShortcut('실행할-바로가기-파일-경로\\바로가기-파일명.lnk'); $s.TargetPath = '대상-파일-경로\\대상-파일명'; $s.IconLocation = '아이콘-파일-경로\\아이콘-파일명.ico'; $s.Save()\"\n```\n\n## 구체적인 예시\n\n서로 다른 바로가기 대상 유형에 대한 적합한 TargetPath 및 필요시 Arguments 구성.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 파일 지정하기\n$Shortcut.TargetPath = \"C:\\Windows\\System32\\notepad.exe\"\n\n# 폴더 지정하기\n$Shortcut.TargetPath = \"C:\\Users\\Public\\Documents\"\n\n# 네트워크 공유 지정하기\n$Shortcut.TargetPath = \"C:\\Windows\\explorer.exe\"\n$Shortcut.Arguments = \"\\\\192.168.10.2\\shares\"\n\n# 환경 변수를 사용하여 지정하기\n$Shortcut.TargetPath = $env:userprofile + \"\\Downloads\"\n\n# .cpl 파일을 지정하기\n$Shortcut.TargetPath = \"C:\\Windows\\System32\\mmsys.cpl\"\n\n# MS:SETTINGS URI 스킴을 사용하여 지정하기\n$Shortcut.TargetPath = \"ms-settings:installed-apps\"\n\n# 이름으로 shell 명령어를 사용하여 지정하기\n$Shortcut.TargetPath = \"C:\\Windows\\explorer.exe\"\n$Shortcut.Arguments = \"shell:NetworkPlacesFolder\"\n\n# CLSID GUID로 shell 명령어를 사용하여 지정하기\n$Shortcut.TargetPath = \"C:\\Windows\\explorer.exe\"\n$Shortcut.Arguments = \"shell:::{BB06C0E4-D293-4f75-8A90-CB05B6477EEE}\"\n\n# rundll32를 사용하여 dll 탐색으로 지정하기\n$Shortcut.TargetPath = \"C:\\Windows\\System32\\rundll32.exe\"\n$Shortcut.Arguments = \"shell32.dll,Control_RunDLL inetcpl.cpl,,4\"\r\n```\n\n# 세부 정보\n\n## Powershell로 바로 가기 생성\n\nPowerShell을 사용하여 바로 가기를 생성하려면, WScript.Shell 클래스의 인스턴스를 포함할 컨테이너로 작동할 COM 객체를 생성해야 합니다. 이는 아마도 초기에 Visual Basic 스크립트를 위해 고안된 꽤 오래된 COM 인터페이스의 일부인 WScript.Shell 클래스의 인스턴스를 담을 객체를 만들 것입니다. 즉, 코드로 바로 가기를 처리하기 위해 필요한 모든 좋은 기능이 구비된 객체를 만들 것입니다. 이는 변수와 속성을 다루는 작업을 포함하므로, 이를 단계적으로 나누어 설명하겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n컴퓨터의 각 사용자에 대해 notepad.exe(Windows에서 널리 사용되는 텍스트 편집 도구)에 대한 데스크탑 바로 가기를 만들고자 합니다.\n\n1. 먼저 대상 객체와 해당 바로 가기의 경로를 저장할 변수를 만듭니다.\n\n```js\n# 내 바로 가기가 가리키는 위치\n$ShortcutTarget = \"C:\\Windows\\System32\\notepad.exe\"\n# 내 바로 가기가 저장될 곳 및 이름 설정\n$ShortcutFile = \"C:\\Users\\Public\\Desktop\\notepad.lnk\"\n```\n\n2. New-Object cmdlet을 사용하여 COM 개체로 WScript.Shell 클래스의 인스턴스를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n\n```js\n$WScriptShell = New-Object -ComObject WScript.Shell\n```\n\n3. WScript.Shell 인스턴스에서 CreateShortcut() 메서드를 사용하여 바로 가기를 만듭니다.\n\n```js\n$shortcut = $WScriptShell.CreateShortcut($ShortcutFile)\n```\n\n자, 이제 잠시 멈추고 바로 가기 객체의 속성과 메서드를 살펴보면서 우리가 할 수 있는 작업을 살펴보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![Shortcut Image](/assets/img/2024-06-22-WindowsShortcutsWithPowerShellHowToMakeCustomizeAndPointThemToPlaces_1.png)\n\n우리는 단축키를 생성하기 위해 TargetPath 속성에 Notepad.exe를 지정하고 Save() 메서드를 사용해야 합니다.\n\n우리의 단축키에 아이콘을 할당하려면 IconLocation 속성이 관련됩니다. TargetPath에 참조된 실행 파일에 명령줄 인수를 전달하려면 Arguments 속성이 관련됩니다.\n\nWorkingDirectory는 상대 경로 사용시 때로 필요하지만, 단축키를 다룰 때 상대 경로는 피하는 것이 좋습니다.\n\n\n<div class=\"content-ad\"></div>\n\n4. 기본 사항으로 계속해서, 앞서 설정한 변수를 사용하여 Target.Path 속성을 위치와 대상의 이름에 할당하십시오.\n\n```js\n$Shortcut.TargetPath = $ShortcutTarget\n```\n\n5. ShortcutFile 변수에 지정된 경로에 바로 가기를 저장하기 위해 Save() 메서드를 호출하여 프로세스를 완료하세요.\n\n```js\n$Shortcut.Save()\n```\n\n<div class=\"content-ad\"></div>\n\n당신의 바로 가기는 $ShortcutFile 변수에 정의된 위치에 준비될 것입니다.\n\n## 장소들을 가리키는 바로 가기\n\n파워쉘을 사용하여 프로그래밍적으로 바로 가기를 만드는 방법을 알게 되었으니, 파일 이외의 것을 가리킬 때는 어떻게 보이는지 살펴보겠습니다. 불행하게도 항상 명확하지는 않습니다.\n\n한두 개의 속성만 변경할 때는 주석이 있는 코드 블록에서 실제 예제를 사용할 것입니다. — TargetPath와 Arguments가 필요할 때 변경합니다.\n\n<div class=\"content-ad\"></div>\n\n폴더로의 바로 가기\n\n```js\n$Shortcut.TargetPath = \"C:\\Users\\Public\\Documents\"\n```\n\n네트워크 공유로의 바로 가기\n\n여기서는 Arguments 속성을 사용하여 TargetPath 속성에서 구성된 explorer.exe로 UNC 형식의 경로를 전달하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n주로 단축키 생성 프로시저에서 문제를 피하기 위한 것이며, 그렇지 않으면 명령이 실행된 문맥 내에서 경로에 액세스할 수 없는 경우 프로세스가 실패할 수 있습니다.\n\n```js\n$Shortcut.TargetPath = \"C:\\Windows\\explorer.exe\"\n$Shortcut.Arguments = \"\\\\192.168.10.2\\shares\"\n```\n\n환경 변수와 함께 사용되는 단축키 대상 경로\n\n```js\n# 표준 연결 방식인 + 기호를 사용하여\n$Shortcut.TargetPath = $env:userprofile + \"\\Downloads\"\n\n# Join-Path cmdlet을 사용하여\n$Shortcut.TargetPath = Join-Path -Path $env:userprofile -ChildPath \"Downloads\"\n```\n\n<div class=\"content-ad\"></div>\n\n컨트롤 패널 파일로의 바로 가기\n\n이 파일들은 C:\\Windows\\System32 폴더에 있으며, 컨트롤 패널 항목에 접근하기가 편리합니다. 그러나 대부분 다른 방법으로 그 곳에 도달하려고 할 것입니다.\n\n```js\n$Shortcut.TargetPath = \"C:\\Windows\\System32\\mmsys.cpl\"\n```\n\nWindows 설정 앱을 통한 패널로의 바로 가기\n\n<div class=\"content-ad\"></div>\n\nWindows 설정 응용 프로그램의 특정 페이지를 지정하는 방법을 제공합니다. ms-settings:`페이지 이름` 형식을 따라 이동할 수 있습니다.\n\n```js\n$Shortcut.TargetPath = \"ms-settings:installed-apps\"\n```\n\n셸 명령을 통한 위치 바로 가기\n\nWindows의 많은 위치는 파일과 유사한 절대 경로 접근이 없어서, 특정 패널이나 폴더에 프로그래밍적으로 어떻게 도달할지가 명확하지 않을 수 있습니다. 이러한 위치를 셸 폴더 또는 가상 폴더라고 하며 알려진 이름을 사용하거나 CLSID 고유 식별자 키 (GUID)를 사용하여 접근할 수 있습니다. CLSID는 레지스트리에서 직접 항목을 열 수 있도록 사용할 수 있는 특별한 키입니다.\n\n<div class=\"content-ad\"></div>\n\n그들에 대해 더 자세히 알고 싶거나 사용 가능한 Windows 11 바로 가기의 완전한 목록을 보고 싶다면, 여기에서 더 깊게 다루었어요.\n\n```js\n# 이름으로 셸 명령어를 사용하여\n$Shortcut.TargetPath = \"C:\\Windows\\explorer.exe\"\n$Shortcut.Arguments = \"shell:NetworkPlacesFolder\"\n\n# CLSID GUID로 셸 명령어를 사용하여\n$Shortcut.TargetPath = \"C:\\Windows\\explorer.exe\"\n$Shortcut.Arguments = \"shell:::{BB06C0E4-D293-4f75-8A90-CB05B6477EEE}\"\n```\n\n## 아이콘으로 바로 가기 맞춤 설정\n\n만약 당신의 바로 가기가 이미 아이콘이 있는 항목을 가리키고 있다면, 해당 아이콘의 경로는 IconLocation 속성에 저장됩니다.\n\n<div class=\"content-ad\"></div>\n\nPowerShell을 사용하여 단축키에 사용자 정의 아이콘을 할당하려면, 단축키를 만들 때 추가 단계로 IconLocation 속성을 구성하여 기존 아이콘에 도달 가능한 경로를 설정한 후 단축키를 저장하면 됩니다.\n\n```js\n$Shortcut.IconLocation = \"\\\\path-to-your-icon.ico\"\n```\n\n이제 사용자 정의 아이콘으로 구성된 단축키를 가지고 있으므로, 스크립트가 다른 곳에 배포되어야 할 경우 아이콘의 가용성을 확인해야 할 것입니다. 항상 컴퓨터에 이미 있는 요소를 활용하는 것이 좋은 접근 방식일 것입니다.\n\nWindows OS에는 일반 UI 아이콘이 저장되고 사용되는 곳이 있습니다. 일반적으로 이러한 아이콘은 여러 프로그램에서 동시에 공유되는 데이터를 포함하는 동적 링크 라이브러리(DLL)에 패킹되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n시스템 주변에는 많은 것들이 있지만, OS에서 가장 일반적으로 사용되는 DLL에는 다음과 같은 아이콘이 포함되어 있습니다:\n\n- C:\\Windows\\system32\\imageres.dll\n- C:\\Windows\\system32\\shell32.dll\n- C:\\Windows\\system32\\ddores.dll\n\n이러한 아이콘들은 표준 파일이 아니며, 적절한 인덱스 번호를 사용하여 DLL 파일 내에서 참조해야 합니다. 이러한 아이콘들은 쉽게 볼 수 없다는 것이 함정입니다. 따라서 텍스트의 시작 부분에 있는 2시간의 줄서기가 필요합니다.\n\n서드 파티 소프트웨어를 사용하지 않고 시간을 낭비하지 않고 DLL의 중첩된 아이콘 인덱스 번호를 확인하려면, 기존 바로 가기의 \"속성\" 패널을 사용하여 DLL 파일을 검색하십시오. 그곳에서 원하는 아이콘을 선택하고 변경 내용을 저장한 다음 해당 인덱스 번호를 코드에서 사용할 수 있도록 PowerShell의 WScriptShell의 COM 인스턴스에 바로 가기를 추가하십시오. IconLocation 속성을 검사하여 코드에서 사용할 수 있는 인덱스 번호를 식별할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nDLL 아이콘 참조하기\n\n에제로 살펴보겠습니다. 제 노트패드 바로 가기를 특정 라이브러리 중 하나로부터 가져온 독특한 아이콘과 함께 배포하고 싶다고 가정해 보겠습니다. 예를 들어, imageres.dll 라이브러리의 키보드 아이콘을 사용하고 싶다면 어떨까요?\n\n제 데스크탑에 있는 크롬 바로 가기의 현재 IconLocation을 살펴보면 chrome.exe(녹색 선) 패키지 내부의 아이콘(녹색 선)이 사용되고 있으며, 해당 아이콘의 인덱스 번호는 0(분홍색 선)입니다. 이 인덱스는 경로의 일부로 표시되며, 파일 경로와 인덱스 번호는 쉼표로 구분됩니다.\n\n![이미지](/assets/img/2024-06-22-WindowsShortcutsWithPowerShellHowToMakeCustomizeAndPointThemToPlaces_2.png)\n\n<div class=\"content-ad\"></div>\n\n또한 chrome.exe 패키지 내부에는 사용할 수 있는 다른 아이콘들이 있다는 것을 알 수 있습니다.\n\n우리는 동일한 Chrome 바로 가기를 사용하여 imageres.dll 라이브러리를 살펴보고 원하는 바로 가기를 선택하고 해당 인덱스 번호를 확인할 수 있습니다.\n\n1. 속성 페이지에 액세스하여 \"아이콘 변경\" 버튼을 클릭하고 \"C:\\Windows\\system32\\imageres.dll\"로 이동한 후 \"Enter\"를 눌러 사용 가능한 아이콘을 확인할 수 있습니다.\n\n여기에서 사용하고자 하는 키보드 아이콘을 선택했습니다.\n\n<div class=\"content-ad\"></div>\n\nMarkdown 형식으로 테이블 태그를 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n$Shortcut.IconLocation = \"C:\\Windows\\system32\\imageres.dll,173\"\n```\n\n## 원라이너\n\n간단하게 사용하기 위해 이를 한 줄로 표현하려면, \"첫 번째 명령; 두 번째 명령; 세 번째 명령\"과 같이 세미콜론을 사용하여 명령을 연결할 수 있습니다. 여기서는 경로 변수를 사용하지 않고 직접 속성과 메소드에 넣어줍니다.\n\n```js\n$ws = New-Object -ComObject WScript.Shell; $s = $ws.CreateShortcut(\"C:\\Users\\Public\\Desktop\\notepad.lnk\"); $s.TargetPath = \"C:\\Windows\\System32\\notepad.exe\"; $s.IconLocation = \"C:\\Windows\\system32\\imageres.dll,173\"; $s.Save()\n```\n\n<div class=\"content-ad\"></div>\n\ncmd를 통해 작업하는 우리에게:\n\n```js\npowershell -ExecutionPolicy bypass -Command \"$ws = New-Object -ComObject WScript.Shell; $s = $ws.CreateShortcut('C:\\Users\\Public\\Desktop\\notepad.lnk'); $s.TargetPath = 'C:\\Windows\\System32\\notepad.exe'; $s.IconLocation = 'C:\\Windows\\system32\\imageres.dll,173'; $s.Save()\"\n```\n\n# 결론\n\nPowerShell을 사용하여 바로 가기를 만드는 것은 COM 객체를 사용하여 WScript.Shell 클래스를 인스턴스화하여 바로 가기 생성 기능에 액세스하는 복잡성을 도입하지만, 프로퍼티 값을 구성하는 루틴 작업으로 단순화됩니다. 배포 전 철저한 테스트, 절대 경로 정확성에 대한 주의 및 아이콘이나 특정 경로와 같은 기존 시스템 요소를 재사용하는 마인드는 중요한 고려 사항입니다.\n\n<div class=\"content-ad\"></div>\n\n당신이 시간을 쏟을 수 있는 곳은 운영 체제의 복잡성에 깊이 파고들어 특정 패널이나 가상 폴더를 대상으로 하는 방법을 알아내는 것입니다. 그러나 대부분의 경우에는 결과적으로 필요한 배포 가능한 한 줄의 코드로 축약될 수 있습니다.\n\n# 작성자의 노트\n\n여기까지 오셨네요! 잘 하셨어요 친구들 — 제가 꽤 괜찮은 작가라서 그런지, 아니면 당신이 훌륭한 독자라서 그런 건지요. 우리는 후자를 택하도록 합시다😅.\n\n나는 기업의 혼돈을 탐내는 경험 많은 IT 서비스 전달 엔지니어 다닐로입니다. 저는 스크립팅, 시스템 관리자 관련 내용, 그리고 다른 곳에서 제대로 문서화되지 않은 주제들에 대해 글을 씁니다. 지식을 공유하고 글쓰기 기술을 향상시키기 위한 목적을 가지고요.\n\n<div class=\"content-ad\"></div>\n\n만졌더니 반복의 경우 피드백을 주세요!","ogImage":{"url":"/assets/img/2024-06-22-WindowsShortcutsWithPowerShellHowToMakeCustomizeAndPointThemToPlaces_0.png"},"coverImage":"/assets/img/2024-06-22-WindowsShortcutsWithPowerShellHowToMakeCustomizeAndPointThemToPlaces_0.png","tag":["Tech"],"readingTime":11},{"title":"최고의 입력을 받는 5가지 방법","description":"","date":"2024-06-22 16:34","slug":"2024-06-22-YourInputMatters","content":"\n\n나의 사이버보안 여정을 시작하며: Day 0\n\n안녕하세요, SoulfulZeus입니다! 오늘부터 나의 사이버보안 세계로의 여정이 시작되었어요. 여러분과 함께 이것을 나눌 수 있어 너무 흥분되고 기대돼요. 나는 매일 진행 상황을 문서화하기로 결정했어요. 그래서 여러분이 이 도전적이지만 보람 있는 분야를 탐험하는 내 모습을 따를 수 있을 거예요.\n\n로드맵과 목표\n\n이 여정을 시작하며, 8개월 안에 OSCP(Offensive Security Certified Professional) 자격증을 달성하는 야심찬 목표를 세우고 상세한 로드맵을 설계했어요. 다음은 내가 따를 계획입니다:\n\n<div class=\"content-ad\"></div>\n\n1. CompTIA Network+: 네트워킹 분야의 강한 기초를 구축하는 것은 시스템과 네트워크 간에 데이터가 어떻게 이동하는지를 이해하는 데 중요합니다.\n\n2. TCM LINUX 101: 리눅스는 사이버 보안 분야에서 널리 사용되며, 그것을 숙달하는 것은 공격적 및 방어적 역할 모두에 필수적일 것입니다.\n\n3. TCM Practical Ethical Hacking: 윤리적 해킹에 대한 실용적 기술은 취약점을 이해하고 공격자가 어떻게 생각하는지를 파악하는 데 중요합니다.\n\n4. TCM Windows PrevEsc and TCM Linux PrevEsc: Windows 및 Linux 시스템에서 권한 상승에 대해 학습함으로써 시스템 보안에 대한 이해를 더욱 깊게 할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n5. TryHackMe (THM) 랩: TryHackMe의 랩은 통제된 환경에서 실용적인 경험을 제공합니다.\n\n6. 동시에 HackTheBox (HTB) 랩: 마찬가지로, Hack The Box의 랩은 더 복잡한 시나리오로 나를 도전하여 기술을 갈고 닦을 기회를 제공합니다.\n\n게다가, 이 여정 동안 취업 기회를 높이기 위해 eJPT (eLearnSecurity Junior Penetration Tester) 자격증 취득을 목표로 하고 있습니다.\n\n이것을 왜 하고 있는 걸까요?\n\n<div class=\"content-ad\"></div>\n\n사이버 보안 분야는 저를 매혹시킵니다. 이 분야는 공격에 대처하는 것뿐만 아니라 계속해서 학습하고 적응하며 잠재적 위협에 선제적으로 대비하기 위해 해커처럼 사고하는 것이기 때문입니다. 문제 해결과 기술에 열정적인 저로서는 이 분야가 도전과 혁신을 완벽하게 결합한 영역이라고 생각합니다.\n\n# 당신의 의견이 중요합니다\n\n저는 여기있는 것이 단순히 제 여정을 기록하는 것뿐만이 아니라 커뮤니티로부터 배우기 위해서 여기에 있습니다. 제가 놓친 부분이 있는지 알릴 것이 있거나 자원, 기술 또는 격려의 말씀을 제시하고 싶다면 언제든 공유해주세요. 여러분의 통찰력은 이 길을 가는 동안 저에게는 귀중한 자산이 될 것입니다.\n\n이 여정에 함께해주세요\n\n<div class=\"content-ad\"></div>\n\n경계! 당신이 경험이 풍부한 사이버 보안 전문가이든, 신참이든, 이 분야에 관심이 있는 사람이든 상관없이 함께해요. 함께 배우고, 경험을 공유하며 서로 영감을 주어 우리의 한계를 뛰어넘을 수 있게 도와줍시다.\n\n내일 나는 CompTIA Network+를 공부하기 시작할 것입니다. 내가 사용하는 자원, 공부 세션을 구성하는 방법, 그리고 마주하는 어려움들을 나눌 예정입니다.\n\n그때까지는 호기심을 유지하고, 안전을 유지하며, 더 나은 미래를 위해 해킹해 봅시다!\n\n지금은 여기서 물러나겠습니다.\n\n<div class=\"content-ad\"></div>\n\nSoulfulZeus","ogImage":{"url":"/assets/img/2024-06-22-YourInputMatters_0.png"},"coverImage":"/assets/img/2024-06-22-YourInputMatters_0.png","tag":["Tech"],"readingTime":2},{"title":"윈도우 11에서 Microsoft Defender로 전체 바이러스 검사를 실행하는 방법","description":"","date":"2024-06-22 16:33","slug":"2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11","content":"\n\nMicrosoft Defender의 전체 바이러스 스캔을 PC에서 실행하는 세 가지 쉬운 방법을 알아보세요. Windows Security 앱, Powershell 및 명령 프롬프트를 사용하는 방법이 포함되어 있습니다.\n\n![이미지](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_0.png)\n\n컴퓨터를 악성 코드로부터 보호하는 데 관한 경우, 빠른 스캔은 종종 충분하지 않아 잠재적인 위협을 간과할 수 있습니다. 여기서 전체 바이러스 스캔이 필요한데요. 이는 PC의 각 모서리와 모퉁이를 악성 침입자를 위해 철저히 검사하는 철저한 스윕입니다. 이 과정은 일반적으로 몇 시간 정도 소요되므로 약간의 인내심이 필요하지만 결과는 가치 있을 수 있습니다.\n\n다행히 Windows 11의 내장 안티바이러스 프로그램인 Microsoft Defender를 사용하여 제3자 앱이 필요하지 않은 PC에서 효과적인 전체 바이러스 스캔을 실행할 수 있습니다. 또한 Windows Security 앱, Powershell 및 명령 프롬프트를 사용하여 다양한 방법으로 스캔을 시작할 수 있습니다. 자세한 방법을 알아보려면 계속 읽어보세요.\n\n<div class=\"content-ad\"></div>\n\n# 윈도우 보안 앱에서 전체 바이러스 검사 실행하는 방법\n\n윈도우 11에서 전체 바이러스 검사를 실행하는 가장 쉬운 방법은 Windows 보안 앱을 통해 실행하는 것입니다. 다음 단계를 따라 진행해보세요:\n\n- 시작 버튼을 클릭하여 메뉴를 엽니다.\n\n![이미지](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_1.png)\n\n<div class=\"content-ad\"></div>\n\n2. \"Windows Security\"을 검색하여 앱을 엽니다.\n\n![Windows Security](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_2.png)\n\n3. 왼쪽 사이드바에서 \"Virus & threat protection\"을 선택하세요.\n\n![Virus & threat protection](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_3.png)\n\n<div class=\"content-ad\"></div>\n\n4. \"Current threats\" 섹션 아래에 있는 \"Scan options\"를 클릭하세요.\n\n![Scan options](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_4.png)\n\n5. \"Full Scan\"을 선택하고 \"Scan now\"를 클릭하세요.\n\n![Full Scan](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_5.png)\n\n<div class=\"content-ad\"></div>\n\n스캔 프로세스가 시작됩니다. 마이크로소프트 디펜더가 악성 소프트웨어를 스캔하고 감지되면 수행 중인 것을 격리하거나 제거합니다. 스캔 프로세스가 완료되면 특정 앱이나 파일을 수동으로 격리, 제거 또는 허용할 수 있습니다.\n\n참고: PC에 저장된 데이터 양에 따라 스캔 프로세스에 시간이 걸릴 수 있으니 기다려 주시기 바랍니다.\n\n# 명령 프롬프트를 사용하여 전체 바이러스 스캔하는 방법\n\n다음 단계를 따라 마이크로소프트 디펜더 전체 바이러스 스캔을 명령 프롬프트를 통해 실행하는 방법을 알아보세요:\n\n<div class=\"content-ad\"></div>\n\n- 시작 메뉴를 열고 \"명령 프롬프트\"를 검색한 후 \"관리자로 실행\"을 선택하세요.\n\n![이미지](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_6.png)\n\n2. 명령 프롬프트에서 다음 명령어를 입력하고 \"Enter\"를 눌러 Microsoft Defender 바이러스 백신에 액세스하세요:\n\n\ncd C:\\ProgramData\\Microsoft\\Windows Defender\\Platform\\4*\n\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_7.png\" />\n\n3. Next, type the following command and press “Enter” to initiate a full scan in Microsoft Defender:\n\nmpcmdrun -scan -scantype 2\n\n<img src=\"/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_8.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n이 명령들을 실행하면 Microsoft Defender가 바이러스를 스캔하고 감지된 악성 코드를 제거할 것입니다. 스캔이 완료되면 화면에 \"스캔 완료\" 메시지가 표시됩니다.\n\n# PowerShell을 사용한 전체 바이러스 스캔 실행 방법\n\n아래 단계를 따라 PowerShell을 사용하여 Microsoft Defender 전체 바이러스 스캔을 실행할 수 있습니다:\n\n- 시작 메뉴를 열고 \"PowerShell\"을 검색한 후 \"관리자 권한으로 실행\"을 클릭하십시오.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_9.png\" />\n\n2. In Powershell, input the following command and hit “Enter” to initiate a Microsoft Defender full virus scan on your PC:\n\nstart-mpscan -scantype fullscan\n\n<img src=\"/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_10.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n해당 명령을 실행하면 전체 바이러스 스캔이 시작됩니다. PowerShell 화면에서 스캔 진행 상황을 백분율 바로 알려줄 거에요.\n\n# Microsoft Defender로 특정 파일이나 폴더를 스캔하는 방법\n\n전체 바이러스 스캔은 보통 몇 시간이 걸리기 때문에, 일부 사용자는 컴퓨터에서 악성 코드를 스캔하고 제거하는 보다 빠르고 효율적인 방법을 찾습니다. 만약 당신도 그 중 하나라면, \"사용자 정의 스캔\" 기능을 사용해 어떤 파일과 위치를 악성 코드를 확인할지 선택해볼 수 있습니다. 아래 단계를 따라해보세요:\n\n- 시작 메뉴를 열고 설정 아이콘을 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변환된 내용입니다.\n\n\n![이미지1](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_11.png)\n\n2. Privacy & Security를 선택하고 Windows Security로 이동합니다.\n\n![이미지2](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_12.png)\n\n3. 그 다음, Virus & Threat protection을 클릭하고 Scan options 아래의 Customized scan을 클릭하세요.\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_13.png)\n\n4. '커스터마이즈된 스캔'을 클릭하면 탐색기 창이 열리고 특정 폴더를 선택할 수 있습니다. 창에서 개별 파일을 볼 수는 없지만 해당 폴더를 선택하고 '폴더 선택'을 클릭하여 스캔을 시작할 수 있습니다. 스캔이 완료되면 스캐닝이 시작됩니다. 해당 폴더의 모든 하위 폴더와 파일이 포함됩니다.\n\n![이미지](/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_14.png)\n\n# 데이터를 잃기 전에 데이터를 보호하세요!\n\n\n<div class=\"content-ad\"></div>\n\n귀하의 PC에서 정기 바이러스 스캔을 수행하여 파일을 훼손하고 문제를 일으킬 수 있는 악성 소프트웨어를 발견하고 제거하는 것이 매우 중요합니다. 이 가이드에서는 Windows Security 앱, 명령 프롬프트 및 PowerShell을 사용하여 Microsoft Defender 전체 바이러스 스캔을 실행하는 세 가지 간단한 방법을 소개했습니다. 전체 바이러스 스캔이 완료될 때까지 몇 시간을 기다리기 싫다면 대신 특정 파일 및 폴더를 확인하여 시간을 적게 들이고 실용적인 검사용 옵션을 고려해보세요.","ogImage":{"url":"/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoRunMicrosoftDefenderFullVirusScanonWindows11_0.png","tag":["Tech"],"readingTime":5}],"page":"38","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}