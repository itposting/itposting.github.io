{"pageProps":{"posts":[{"title":"브라우저 비교 결말 크로미움 기반 브라우저","description":"","date":"2024-06-20 14:42","slug":"2024-06-20-BrowsercomparisonfinaleChromiumbasedbrowsers","content":"\n\n![이미지](/assets/img/2024-06-20-BrowsercomparisonfinaleChromiumbasedbrowsers_0.png)\n\n브라우저 비교 시리즈의 이전 버전에서 몇 가지 인기 있는 브라우저와 최고의 Firefox 포크를 비교했고, 이번 마지막 편에서는 성능과 기능을 기반으로 최고의 Chromium 기반 브라우저들을 비교할 것입니다. 성능 벤치마크 세부 정보는 기사 말미에 제공됩니다.\n\n## 7. 오페라 & 오페라 GX\n\n![이미지](/assets/img/2024-06-20-BrowsercomparisonfinaleChromiumbasedbrowsers_1.png)\n\n<div class=\"content-ad\"></div>\n\n오페라 및 오페라 GX의 UI/UX가 최고인데, 각기 다른 대상을 위해 매력적인 독특한 외모를 가지고 있습니다. 그러나 불필요한 기능의 과도한 양과 특정 측면에서의 불안정성은 경험을 악화시킵니다.\n\n✅ 장점: 내장된 광고 차단기가 잘 작동하며, 작업 공간은 특정 유형의 사용자에게 좋을 수 있습니다. 그렇지만 PIP 모드는 이 목록의 다른 모든 브라우저와 비교할 때 매우 특별합니다. 탭을 전환할 때 현재 실행 중인 비디오가 자동으로 팝업되며, 다른 Chromium 기반 브라우저에서 누락된 시청 중 플레이어를 통해 시청하는 기능이 제공됩니다. 파일 업로드를 시도할 때 빠르게 최근 다운로드한 파일을 선택할 수 있는 빠른 대화 상자가 유용합니다. 오페라 GX의 모드(사실 장치)와 CPU 및 RAM 제한자와 같은 기능도 특정 상황에서 유용할 수 있습니다.\n\n❌ 단점: 실제로는 프록시인 VPN은 속도가 매우 느립니다. 사실, 크롬 스토어의 VPN 확장 프로그램이 더 빠른 속도를 제공합니다. 투명 모드로 인해 비디오가 과포화되고 과도하게 날카롭게 보이며, HD 비디오가 원래보다 나쁘게 보이게됩니다. 핀보드는 좋은 개념이지만 동기화에 매우 오랜 시간이 걸립니다. AI 기능은 때로는 어색할 수 있습니다. 유튜브와 같은 일부 웹 사이트가 이유를 알 수 없이 오페라에서 느리게로드됩니다.\n\n이것은 감정이 교차하는 느낌을 남기네요.\n샤프한 기능을 원한다면, UI 또는 모드 또는 CPU 및 RAM 제한이 필요하다면 오페라 GX를 선택하십시오. 그렇지 않으면 오페라가 더 나은 선택일 것입니다.\n\n성능 점수 : 오페라 GX - 977.09 | 오페라 - 957.24\n\n<div class=\"content-ad\"></div>\n\n디자인: 5/5\n성능: 2/5\n안정성: 3/5\n다이어트 체험: 2/5\n\n## 6. 토륨\n\n![이미지](/assets/img/2024-06-20-BrowsercomparisonfinaleChromiumbasedbrowsers_2.png)\n\n토륨은 멋진 프로젝트입니다. 개발자에게 큰 박수를 보냅니다.\n\n<div class=\"content-ad\"></div>\n\n✅ 장점: 정말 빠르며, 이 목록에서 성능 2위를 기록하고 있어요. 최근 논란이 있었지만, Mercury와 Thorium 브라우저는 개발자인 그들의 브라우저로서 객관적으로 매우 뛰어난 성능을 자랑해요.\n\n❌ 단점: 안정성은 항상 문제로 남아 있습니다. 유지 보수 및 업데이트를 주로 한 사람이 하고 있어서 그런데요. Thorium의 디자인은 약간 웃긴데, 이상하게 색칠된 아이콘이 있어요. (어두운 모드에서 컨트라스트 비율 안좋아요)\n\n벤치마크 점수: 1239.81\n\n디자인: 3/5\n성능: 5/5\n안정성: 2/5\n무난한 경험: 5/5\n\n<div class=\"content-ad\"></div>\n\n## 5. 크로미움 및 비구글 크로미움\n\n![크로미움 및 비구글 크로미움 비교](/assets/img/2024-06-20-BrowsercomparisonfinaleChromiumbasedbrowsers_3.png)\n\n크로미움과 비구글 크로미움의 기능에는 큰 차이가 없기 때문에 둘을 하나의 섹션으로 그룹화했습니다.\n\n✅ 장점: 두 브라우저 모두 성능이 매우 우수하지만 크로미움이 일반적으로 벤치마크에서 더 높은 점수를 받았습니다. Google 통합이 거슬리지 않는다면 크로미움을 사용해도 좋습니다. 트래킹을 완전히 떨어져 나가고 싶은 사용자를 위해 비구글 크로미움이 좋은 선택일 것입니다. 두 브라우저는 동일한 기능을 갖추고 있으며, 비구글 크로미움은 Google의 간섭 없이 제공되므로 이것이 좋을지 나쁠지는 당신에게 달렸습니다.\n\n<div class=\"content-ad\"></div>\n\n❌ 단점: 이 두 프로젝트는 Windows용으로 개발자들이 공식 빌드를 제공하지 않습니다. 그러므로 코드를 직접 컴파일해야 하며, 이는 보통 사용자를 위한 것이 아니거나 프로젝트 자체만큼 안전하지 않은 커뮤니티 빌드에 의존해야 할 수도 있습니다. 업데이트가 문제가 될 수 있습니다.\n\nUngoogled Chromium에서 벤치마크를 실행하는 동안, 브라우저를 여전히 충분히 잘 사용할 수 있었는데 예상치 못했던 점은 성능이 일부 병목 현상을 겪고 있어 실제 성능이 점수보다 약간 높아야 한다는 결론을 내리게 했습니다. 즉, Chromium과 동등한 성능이어야 합니다.\n\n벤치마크 점수: Chromium - 1125.86 | Ungoogled Chromium - 1020.86\n\n디자인: 4/5\n성능: 4/5\n안정성: 3/5\n무거운 경험 없음: 5/5\n\n<div class=\"content-ad\"></div>\n\n## 4. Microsoft Edge\n\n![image](/assets/img/2024-06-20-BrowsercomparisonfinaleChromiumbasedbrowsers_4.png)\n\n✅ 장점: Edge는 상당히 좋은 Copilot 통합 기능과 강력한 PDF 리더-편집기가 기본 제공됩니다. Windows의 Copilot은 현재 열려 있는 웹페이지나 PDF 파일에 기반하여 직접 질문에 답할 수도 있습니다. 또한 두 웹사이트를 동시에 볼 수 있는 분할 화면 모드와 세로 탭도 제공합니다. 현재 쇼핑 중인 웹사이트에서 적용 가능한 쿠폰 목록을 보여주는 강력한 쇼핑 기능도 포함되어 있습니다. 성능도 괜찮습니다.\n\n❌ 단점: 기능이 많아서 때로는 디자인이 혼잡해 보일 수 있습니다. 때때로 브라우저가 느린 느낌을 줄 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\nEdge는 여러 가지를 시도하려고 노력하지만, 그 중 많은 부분에서 꽤 괜찮습니다. 하지만, 원시적이고 깔끔한 브라우징 경험을 제공하는 데는 부족합니다. 다른 것들과 비교해 뛰어나다거나 특별한 것은 없지만 그저 그런 선행자입니다. 전반적으로, Edge는 꽤 괜찮은 브라우저입니다.\n\n벤치마크 점수: 973.92\n\n디자인: 4/5\n성능: 3/5\n안정성: 5/5\n무거운 경험: 3/5\n\n얻는 점수에 따르면 5위에 속해야 하지만, 일부 기능들 때문에 4위에 속해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n## 3. 비발디\n\n![이미지](/assets/img/2024-06-20-BrowsercomparisonfinaleChromiumbasedbrowsers_5.png)\n\n오랫동안 비발디를 사용하지 않았는데, 이제 사용해보니 상쾌한 느낌이었어요.\n\n✅ 장점: 비발디는 맞춤 설정에 대한 탁월한 성능을 보여줍니다. 브라우저를 사용자 취향에 맞게 조정하는 데 도움이 되는 다양한 설정이 있어요. 아마도 현재까지 가장 맞춤화된 Chromium 기반 브라우저일 거에요. 기본 UI의 일부 요소는 굉장히 오래된 느낌을 주고, 일부 요소는 굉장히 현대적으로 보입니다. 또한 메일 클라이언트, 캘린더 및 RSS 피드 리더가 기본으로 제공되어요. 공간 탭 탐색과 탭 쌓기 같은 독특한 기능도 있어요. 또한 매우 안정적인 브라우저입니다.\n\n<div class=\"content-ad\"></div>\n\n❌ 단점: 성능 면에서는 더 나은 것을 얻을 수 있습니다. 비발디는 웹글을 사용하는 그래픽 집중 작업에 특히 적합하지 않습니다. 또한 초기화되고 깨끗한 브라우징 경험을 제공하지 않습니다.\n\n장점이 충분히 인상적이어서 이 브라우저를 3위에 올려놓습니다. 비록 이 목록에서 가장 느린 브라우저이지만요. 우리 2위 후보와 동일한 점수를 받았다고 생각해보세요.\n\n벤치마크 점수: 939.16\n\n디자인: 5/5\n성능: 2/5\n안정성: 5/5\n무거운 경험 없음: 3/5\n\n<div class=\"content-ad\"></div>\n\n## 2. 크롬\n\n![크롬](/assets/img/2024-06-20-BrowsercomparisonfinaleChromiumbasedbrowsers_6.png)\n\n✅ 장점: 크롬은 모든 크로미움 브라우저 중에서 여전히 최고의 UI와 성능을 갖고 있으며, 대체로 모든 기준을 충족합니다. 만약 구글 계정을 광범위하게 사용한다면, 크롬은 매우 부드럽게 통합되어 현재 열려 있는 탭, 히스토리, 즐겨찾기를 동기화하고 다른 기기로 탭을 전송할 수 있습니다.\n\n❌ 단점: 장점은 사용자에 따라 단점이 될 수도 있습니다. 구글 통합 기능이 이 브라우저에 깊게 내재화되어 있습니다. 크롬을 좋아하지만 구글의 통합 기능은 별로라고 느끼는 경우, 최신 빌드를 찾아 다운로드하기 위해 조금만 노력하여 크로미움을 검토해 볼 수 있습니다. 그 외에는 크롬이 충분히 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n## 성능 평가\n\n- Benchmark 점수: 1050.76\n- 디자인: 5/5\n- 성능: 4/5\n- 안정성: 5/5\n- 블로트 없는 경험: 3/5\n\n## 1. 브레이브\n\n![이미지](/assets/img/2024-06-20-BrowsercomparisonfinaleChromiumbasedbrowsers_7.png)\n\n<div class=\"content-ad\"></div>\n\n장점: Brave는 이 목록 중에 아무것도 아닌 것처럼 벤치마킹 테스트를 훌륭하게 통과합니다, 특히 webgl 및 캔버스 렌더링에 관한 부분에서. 이 브라우저는 일상적인 사용에서 매우 빠르게 느껴지며 오픈 소스입니다. 처음에 출시됐을 때는 거들 먹거리는 것이라 여겼지만, 예상보다 훨씬 오래 지속되었고 어떠한 주요 기술 기업도 후원하지 않음에도 매우 안정적이었습니다. 선택 사항으로 세로 탭이 함께 제공됩니다.\n\n단점:\n암호화폐와 관련된 일부 기능, 사용자에 따라 미달리는지 생각될 수 있는 유료 VPN, 그리고 크롬이나 오페라의 UI와는 거리가 있는 조잡한 UI가 함께 제공됩니다.\n\n만약 이 글이 Brave에 의해 후원되었다는 생각이 들면, 그렇지 않습니다. 벤치마크를 직접 실행하여 차이를 확인할 수 있습니다.\n\n디자인: 3/5\n성능: 5/5\n안정성: 5/5\n무거운 경험: 4/5\n\n<div class=\"content-ad\"></div>\n\n여기 각 브라우저의 성능을 비교한 간략한 내용입니다 -\n\n![Browser Comparison](/assets/img/2024-06-20-BrowsercomparisonfinaleChromiumbasedbrowsers_8.png)\n\n일부 세부 정보 -\n\n벤치마킹 테스트는 AMD Ryzen 5 7535HS 및 8GB DDR4 RAM, 512GB M.2 SSD를 탑재한 Windows 11 기기에서 UBlock Origin이 모든 브라우저에 설치된 상태로 Basemark에서 수행되었습니다.\n\n<div class=\"content-ad\"></div>\n\n지금은 브라우저 비교 시리즈를 마칩니다. 다음 글은 Windows에서의 초보자를 위한 라이싱 가이드가 될 예정이에요. 기대해 주세요!\n\n브라우저를 비교한 제 글을 확인해 보세요. 특히 파이어폭스 포크에 관한 내용이 담겨 있어요.","ogImage":{"url":"/assets/img/2024-06-20-BrowsercomparisonfinaleChromiumbasedbrowsers_0.png"},"coverImage":"/assets/img/2024-06-20-BrowsercomparisonfinaleChromiumbasedbrowsers_0.png","tag":["Tech"],"readingTime":6},{"title":"Times Up, 타임랩스 HackTheBox에서 어드민으로 가는 길, 브루트포스터 해킹과 라프스 해킹으로 웃음을 전해보았어","description":"","date":"2024-06-20 14:41","slug":"2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox","content":"\n\n그 테이블 태그를 마크다운 형식으로 변경하십시오.\n\n<div class=\"content-ad\"></div>\n\n가장 먼저, 저는 어떤 것을 다루고 있는지 확인하기 위해 nmap 스캔을 실행했습니다. Nmap, 믿을 수 있는 네트워크 매퍼,는 smb, ldap 및 Kerberos와 같은 여러 개의 오픈 포트를 보여주었는데, 이는 '블루 스크린 오브 데스'보다 더 '윈도우 머신'을 크게 외치고 있습니다.\n\n![이미지](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_1.png)\n\nSMB 공유 열거\n\nSMB 포트가 열려 있어서, null 자격 증명을 사용하여 smbclient를 통해 smb 공유를 열거할 억제할 수 없는 욕구가 생겼습니다. 그리고 'Shares'라는 이름이 붙은 드문한 공유가 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n![image1](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_2.png)\n\nShares 디렉토리에 대해 궁금증을 느껴 'Shares' 디렉토리로 들어가 보았고, DEV 디렉토리 안에 winrm 백업을 찾아내었습니다. 파일을 다운로드했지만, 파일이 암호로 보호되어 있는 것을 깨닫자 흥분이 잠시 가셨어요.\n\n![image2](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_3.png)\n\n<div class=\"content-ad\"></div>\n\n집 비밀번호를 크랙하기\n\n비밀번호가 없어? 문제 없어요. 저는 zip2john을 사용하여 zip을 크랙 가능한 형식으로 변환하고 그런 다음 록유(wordlist)를 사용하여 존 더 리퍼(john the ripper)를 실행했어요. 바로 그래요! 비밀번호가 크랙되었어요.\n\n![이미지](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_4.png)\n\n![이미지](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_5.png)\n\n<div class=\"content-ad\"></div>\n\nPFX 파일 잠금 해제하기\n\nZip 파일 안에는 .pfx 파일이 있었는데, 이 파일도 비밀번호가 필요했습니다. 궁금해하는 분들을 위해 .pfx 파일은 암호화와 인증에 사용되는 인증서와 개인 키가 들어 있습니다. pfx2john을 사용하여 해시 값을 얻었고 다시 한 번 john과 rockyou를 사용하여 해독했습니다.\n\n[이미지1](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_6.png)\n\n[이미지2](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_7.png)\n\n<div class=\"content-ad\"></div>\n\n인증서 및 키 생성\n\npfx 패스워드를 손에 쥐고 openssl을 사용하여 인증서와 키를 추출했습니다.\n\n![이미지](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_8.png)\n\n\"Legacyy\"로 로그인하기\n\n<div class=\"content-ad\"></div>\n\n이 키와 인증서를 사용하여 이블 윈알엠으로 세션을 시작하여 \"legacyy\" 사용자로 액세스를 얻었습니다.\n\n\n<img src=\"/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_9.png\" />\n\n\n콘솔 히스토리 분석\n\n안으로 들어가서 PowerShell 콘솔 히스토리를 살펴보고 또 다시 행운을 가졌습니다. svc_deploy 사용자의 자격 증명을 발견했습니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변환해 보겠습니다.\n\n\n<img src=\"/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_10.png\" />\n\n<img src=\"/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_11.png\" />\n\nLogging in as svc_deploy\n\nWith new credentials, I logged in as the svc_deploy user. Now, it was time to gather some serious intel.\n\n\n<div class=\"content-ad\"></div>\n\n![/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_12.png](<img src=\"/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_12.png\" />)\n\n샤프 하운드 배포하기\n\n저는 머신에 SharpHound를 다운로드하고 데이터 수집을 위해 실행했습니다. SharpHound는 미첵된 사용자를 위한 BloodHound에 사용되는 도구로, Active Directory 데이터를 수집하는 도구입니다.\n\n![/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_13.png](<img src=\"/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_13.png\" />)\n\n<div class=\"content-ad\"></div>\n\n\n![이미지1](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_14.png)\n\nBloodHound 분석\n\nBloodHound를 실행하여 SharpHound 데이터를 업로드하고 svc_deploy 사용자를 소유로 표시했습니다. \"Outbound Object Control\"에 대한 빠른 검색에서 svc_deploy가 Timelapse 도메인의 dc01의 로컬 관리자 비밀번호를 읽을 수 있는 LAPS Readers 그룹의 구성원임을 확인했습니다.\n\n![이미지2](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_15.png)\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_16.png)\n\n다이어그램에서 svc_deploy 사용자가 LAPS_READERS 그룹의 구성원이며 DC01.TIMELAPSE.HTB의 암호를 읽을 수 있음을 보여줍니다.\n\nLAPS 악용\n\nActive Directory의 LAPS(Local Administrator Password Solution)는 도메인 가입된 컴퓨터의 로컬 관리자 암호를 관리하는 기능입니다. AdmPwd 모듈을 사용하여 LAPS Readers 그룹의 구성원이 실제로 dc01의 LAPS 암호를 읽을 수 있음을 확인했습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![image1](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_17.png)\n\n![image2](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_18.png)\n\nUsing AdmPWD module to extract password of Administrator user:\n\n![image3](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_19.png)\n\n\n<div class=\"content-ad\"></div>\n\n관리자 액세스 획들하기\n\n로컬 관리자 암호로 무장하고 마지막으로 evil-winrm을 사용했습니다. 이번에는 관리자 사용자로 로그인했습니다. 성공!\n\n![이미지](/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_20.png)\n\n루트 플래그 -`\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_21.png\" />\n\n결론:\n\nnmap 스캔부터 LAPS 이용까지, \"Timelapse\" 정복 여정은 도전과 승리의 롤러코스터였습니다. 각 단계마다 무차별 대입, 교묘한 열거 및 전략적 이용이 필요했습니다. 경험 많은 해커든 호기심 많은 초보자든, 이 가이드가 가치 있는 통찰과 재미로운 순간을 제공해줄 것으로 기대합니다. 해킹 즐겁게 하세요!","ogImage":{"url":"/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_0.png"},"coverImage":"/assets/img/2024-06-20-TimesUpTimelapseHowIBrute-ForcedLAPS-edandLaughedMyWaytoAdminonHackTheBox_0.png","tag":["Tech"],"readingTime":6},{"title":"WSL-2에서 Ubuntu를 사용하여 Gnome 데스크톱 설정하기","description":"","date":"2024-06-20 14:39","slug":"2024-06-20-GnomeDesktoponWSL-2UsingUbuntu","content":"\n\n<img src=\"/assets/img/2024-06-20-GnomeDesktoponWSL-2UsingUbuntu_0.png\" />\n\n이전에는 WSL-2에서 SystemD를 활성화한 Debain을 설정하는 방법을 보여드렸습니다. 이번에는 한 발짝 더 나아가 GNOME 데스크톱을 설치하고 WSL2 VM을 완전한 GUI로 사용해 봅시다!\n\n- 우선 다음 명령어를 사용하여 WSL2에 Ubuntu를 설치해 보세요: wsl --install -d ubuntu\n- Ubuntu를 설정한 후에는 다음 명령어를 실행하세요:\n\n```js\nsudo apt update\nsudo apt-mark hold acpid acpi-support\nsudo apt upgrade\n```\n\n<div class=\"content-ad\"></div>\n\n- 이제 유용한 systemd 설정 스크립트를 실행하여 WSL 내에서 systemd 환경을 설정할 수 있습니다. 이 스크립트는 필요한 패키지를 설치하고 스크립트를 복사하여 sudoers를 구성하며 bash.bashrc를 수정하고 Windows에서 환경 변수를 설정하여 WSL 내에서 systemd를 사용할 수 있게 합니다. 이를 통해 WSL 내에서 서비스 및 기타 기능을 활성화할 수 있습니다. 기본 이닛 시스템에서는 사용할 수 없는 기능들을 사용할 수 있습니다.\n\n```js\ncd ~\ngit clone https://github.com/DamionGans/ubuntu-wsl2-systemd-script.git\ncd ubuntu-wsl2-systemd-script/\n./ubuntu-wsl2-systemd-script.sh\n```\n\n- 이제 WSL을 종료하고 powershell이나 cmd 터미널에서 다음 명령을 실행하여 WSL을 다시 시작하고 업데이트할 수 있습니다:\n\n```js\nwsl.exe -d ubuntu --shutdown\nwsl.exe -d ubuntu\n```\n\n<div class=\"content-ad\"></div>\n\n- WSL에서 Ubuntu 명령줄에 다시 돌아오면 다음 환경 변수를 내보냅니다:\n\n```js\nexport DISPLAY=\"$(ip route | awk '{print $3; exit}')\":0;\nexport XDG_CONFIG_HOME=$HOME/.config\nexport XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg\nexport XDG_SESSION_DESKTOP=ubuntu\nexport XDG_SESSION_TYPE=x11\nexport XDG_CURRENT_DESKTOP=ubuntu:GNOME\nexport XDG_SESSION_CLASS=user\nexport XDG_DATA_DIRS=/usr/share/ubuntu:/usr/local/share/:/usr/share/:/var/lib/snapd/desktop\nexport GNOME_SHELL_SESSION_MODE=ubuntu\nexport XDG_RUNTIME_DIR=\"/run/user/1000\"\n```\n\n- 이제 다음 명령을 실행합니다:\n\n```js\nsudo mkdir -p /run/user/1000\nsudo chmod 700 /run/user/1000\nsudo chown $(whoami): /run/user/1000\n```\n\n<div class=\"content-ad\"></div>\n\n- 모든 설정이 완료되었으니 이제 GNOME 데스크톱을 설치해봅시다:\n\n```js\nsudo apt install ubuntu-desktop gnome\n```\n\n- https://sourceforge.net/projects/vcxsrv/ 에서 VcXsrv Windows X Server를 다운로드하세요. 저는 1.20.14.0 버전을 사용 중입니다. Windows에서 설치하세요.\n- Windows에서 XLaunch를 실행하여 VcXsrv를 시작하세요 (이미 실행 중인 VcXsrv가 있을 경우 종료하세요. VcXsrv의 설정이 중요합니다). 첫 번째 페이지에서 \"Fullscreen\"을 선택하세요. 세 번째 페이지의 \"VcXsrv의 추가 매개변수\" 필드에 -ac -wgl -dpms를 입력하세요.\n\n![이미지](/assets/img/2024-06-20-GnomeDesktoponWSL-2UsingUbuntu_1.png)\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-20-GnomeDesktoponWSL-2UsingUbuntu_2.png)\n\nVcXsrv를 시작하면 전체 검은 화면이 표시될 수 있습니다. 이는 아직 내용이 채워지지 않은 전체 화면의 효과입니다. Alt-Tab을 눌러 WSL의 Ubuntu 명령줄로 전환할 수 있습니다.\n\n- dbus-launch --exit-with-session gnome-session를 실행합니다.\n- 전체 화면 VcXsrv 창으로 이동합니다. 이제 Ubuntu GNOME 데스크톱이 나타날 것입니다. 즐기세요!\n- 사용하지 않을 때는 GNOME을 그냥 둘 수 있습니다. 그러나 GNOME을 종료하려면 VcXsrv 창을 닫거나 WSL의 Ubuntu 명령줄에서 Ctrl-C를 누르면 됩니다.\n\n성능이 조금 느릴 수 있습니다. 지금은 GPU 가속화를 활성화하는 방법을 모르겠지만, 이것이 시작점입니다!\n","ogImage":{"url":"/assets/img/2024-06-20-GnomeDesktoponWSL-2UsingUbuntu_0.png"},"coverImage":"/assets/img/2024-06-20-GnomeDesktoponWSL-2UsingUbuntu_0.png","tag":["Tech"],"readingTime":3},{"title":"SQL 윈도우 함수","description":"","date":"2024-06-20 14:38","slug":"2024-06-20-sqlwindowfunctions","content":"\n\n\n<img src=\"/assets/img/2024-06-20-sqlwindowfunctions_0.png\" />\n\nSQL 윈도우 함수는 현재 행과 관련된 일련의 테이블 행 전체에서 계산을 수행하는 강력한 도구입니다. 이러한 함수는 결과 집합을 단일 행으로 그룹화하지 않고, 순위, 러닝 합계, 이동 평균 등을 포함한 복잡한 쿼리를 실행하는 방법을 제공합니다. 여기에 일반적으로 사용되는 SQL 윈도우 함수 중 일부가 있습니다:\n\n# 1. ROW_NUMBER()\n\n결과 집합의 각 파티션 내에서 행에 고유한 연속 정수를 할당하며, 각 파티션의 첫 번째 행에 대해 1부터 시작합니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n```js\nSELECT \n    column1,\n    ROW_NUMBER() OVER (PARTITION BY column2 ORDER BY column3) AS row_num\nFROM \n    table_name;\n```\n\n# 2. RANK()\n\nAssigns a rank to each row within a partition of a result set. The rank of a row is one plus the number of ranks that come before it. Ties receive the same rank, and the next rank(s) are skipped.\n\n```js\nSELECT \n    column1,\n    RANK() OVER (PARTITION BY column2 ORDER BY column3) AS rank\nFROM \n    table_name;\n``` \n\n\n<div class=\"content-ad\"></div>\n\n# 3. DENSE_RANK()\n\nRANK()과 유사하지만 랭킹 시퀀스에 갭이 없습니다. 동점인 경우 동일한 순위를 받고, 다음 순위는 1씩 증가합니다.\n\n```js\nSELECT \n    column1,\n    DENSE_RANK() OVER (PARTITION BY column2 ORDER BY column3) AS dense_rank\nFROM \n    table_name;\n```\n\n# 4. NTILE(n)\n\n<div class=\"content-ad\"></div>\n\n결과 집합을 대략적으로 n개의 동일한 부분으로 나누고 각 행에 1부터 n까지 버킷 번호를 할당합니다.\n\n```js\nSELECT \n    column1,\n    NTILE(4) OVER (ORDER BY column2) AS quartile\nFROM \n    table_name;\n```\n\n**5. LAG()**\n\n결과 집합 내 현재 행 이전에 있는 주어진 물리적 오프셋의 행에 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```sql\nSELECT \n    column1,\n    LAG(column2, 1) OVER (ORDER BY column3) AS prev_value\nFROM \n    table_name;\n```\n\n## 6. LEAD()\n\n현재 행 다음에 나오는 주어진 물리적 오프셋 위치의 행에 대한 액세스를 제공합니다.\n\n```sql\nSELECT \n    column1,\n    LEAD(column2, 1) OVER (ORDER BY column3) AS next_value\nFROM \n    table_name;\n```\n\n<div class=\"content-ad\"></div>\n\n# 7. FIRST_VALUE()\n\n주어진 값들의 정렬된 세트에서 첫 번째 값을 반환합니다.\n\n```js\nSELECT \n    column1,\n    FIRST_VALUE(column2) OVER (PARTITION BY column3 ORDER BY column4) AS first_val\nFROM \n    table_name;\n```\n\n# 8. LAST_VALUE()\n\n<div class=\"content-ad\"></div>\n\n주어진 값들의 정렬된 세트에서 마지막 값을 반환합니다.\n\n```js\nSELECT \n    column1,\n    LAST_VALUE(column2) OVER (PARTITION BY column3 ORDER BY column4 ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS last_val\nFROM \n    table_name;\n```\n\n## 9. SUM()\n\n지정된 윈도우 프레임에서 값들의 합을 계산합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nSELECT \n    column1,\n    SUM(column2) OVER (PARTITION BY column3 ORDER BY column4) AS running_total\nFROM \n    table_name;\n```\n\n# 10. AVG()\n\nCalculates the average of values in a specified window frame.\n\n```js\nSELECT \n    column1,\n    AVG(column2) OVER (PARTITION BY column3 ORDER BY column4) AS running_avg\nFROM \n    table_name;\n```\n\n<div class=\"content-ad\"></div>\n\n# 11. MIN() 및 MAX()\n\n지정된 창 프레임 내에서 최소값 및 최대값을 반환합니다.\n\n```js\nSELECT \n    column1,\n    MIN(column2) OVER (PARTITION BY column3 ORDER BY column4) AS min_val,\n    MAX(column2) OVER (PARTITION BY column3 ORDER BY column4) AS max_val\nFROM \n    table_name;\n```\n\n# 창 명세화\n\n<div class=\"content-ad\"></div>\n\nOVER 절은 세 부분으로 구성될 수 있습니다:\n\n- PARTITION BY: 윈도우 함수가 적용되는 파티션으로 결과 세트를 분할합니다.\n- ORDER BY: 각 파티션 내 행의 논리적 순서를 정의합니다.\n- Window Frame: 함수가 적용되는 파티션의 하위 집합을 지정합니다 (예: 1 PRECEDING부터 현재 행까지의 ROWS).\n\n완전한 윈도우 명세를 사용한 예시:\n\n```js\nSELECT \n    column1,\n    SUM(column2) OVER (PARTITION BY column3 ORDER BY column4 ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS running_total\nFROM \n    table_name;\n```\n\n<div class=\"content-ad\"></div>\n\n이러한 함수들을 사용하면 복잡한 계산을 처리하는 더 효율적이고 가독성이 좋은 방법을 제공하여 SQL 내에서 고급 데이터 분석을 수행할 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-20-sqlwindowfunctions_0.png"},"coverImage":"/assets/img/2024-06-20-sqlwindowfunctions_0.png","tag":["Tech"],"readingTime":4},{"title":"맥OS 풀 높이 사이드바 창","description":"","date":"2024-06-20 14:37","slug":"2024-06-20-macOSfullheightsidebarwindow","content":"\n\n요즘, macOS 앱에서 전체 높이 사이드바와 풍부한 툴바 및 타이틀바를 원했어요.\n\n그럴 때 SwiftUI의 NavigationSplitView와 AppKit API의 NSSplitViewController를 사용하면 됩니다.\n\n# SwiftUI 앱 라이프사이클에서\n\nWindowGroup와 샘플 프로젝트에서 NavigationSplitView를 빠르게 경험했는데, 아주 쉽게 작동했어요:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*H0R5oiWQVLVOyNl686y6RA.gif\" />\n\n# 앱킷 앱 라이프사이클에서\n\n하지만 NSHostingController를 사용하거나 심지어 AppKit 및 NSSplitViewController를 사용하여 실제 프로젝트로 돌아가면 (내 앱이 SwiftUI 앱 라이프사이클로 완전히 이관되지 않았기 때문에) 기본적으로 다른 동작을 하며 처음부터 왜 그런 건지 이해할 수 없습니다.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1200/1*KeIibd3zjL-7Twq6vfFHtQ.gif\" />\n\n<div class=\"content-ad\"></div>\n\n저는 먼저 Xcode에서 창 보기 계층을 비교해 보려고 합니다:\n\n![Window view hierarchy](/assets/img/2024-06-20-macOSfullheightsidebarwindow_0.png)\n\n하지만 거의 비슷해 보입니다.\n\n많은 연구 끝에 다음을 발견하고 시청했습니다:\n- [SwiftUI 네비게이션 분할 보기에서 사이드바 버튼 사용하는 방법](https://stackoverflow.com/questions/78604429/using-sidebar-button-jump-in-swiftui-navigationsplitview-with-nshostingcontrolle/78615176#78615176)\n- [Apple 개발자 비디오](https://developer.apple.com/videos/play/wwdc2020/10104/)\n\n<div class=\"content-ad\"></div>\n\n저와 같이 프로젝트가 아직 SwiftUI 앱 라이프사이클로 전환되지 않았다면 다음과 같이 할 수 있습니다:\n\n```js\n// SwiftUI.NavigationSplitView를 NSHostingView 또는 NSHostingController와 함께 사용\n// 👀 .fullSizeContentView를 살펴봅니다\nlet window = NSWindow(contentRect: .init(origin: .zero, size: .init(width: 800, height: 600)), styleMask: [.closable, .miniaturizable, .titled, .resizable, .fullSizeContentView], backing: .buffered, defer: false)\nwindow.contentView = NSHostingView(rootView: ContentView())\nwindow.center()\nwindow.title = \"Hello world\"\nlet controller = NSWindowController(window: window)\ncontroller.showWindow(nil)\n\n...\nstruct ContentView: View {\n    var body: some View {\n        NavigationSplitView {\n            Text(\"A\")\n        } content: {\n            Text(\"B\")\n        } detail: {\n            Text(\"C\")\n        }\n    }\n}\n```\n\n```js\n// 👀 NSSplitViewController 사용\nwindow = NSWindow(\n    contentRect: NSRect(x: 0, y: 0, width: 800, height: 600),\n    // 👀 .fullSizeContentView를 살펴봅니다\n    styleMask: [.titled, .closable, .resizable, .miniaturizable, .fullSizeContentView],\n    backing: .buffered,\n    defer: false\n)\nwindow.center()\nwindow.title = \"Hello world\"\nwindow.titlebarAppearsTransparent = true\nlet toolbar = NSToolbar(identifier: \"my-identifier\")\ntoolbar.delegate = self\ntoolbar.allowsUserCustomization = false\ntoolbar.displayMode = .iconOnly\nself.window?.toolbar = toolbar\n\n// 👀 sidebarWithViewController를 살펴봅니다\nlet sidebarItem = NSSplitViewItem(sidebarWithViewController: SidebarViewController())\nsidebarItem.allowsFullHeightLayout = true\nsidebarItem.minimumThickness = 200\nsidebarItem.maximumThickness = 300\nsidebarItem.canCollapse = true\nsidebarItem.isCollapsed = false\nsplitViewController.addSplitViewItem(sidebarItem)\n\n// 👀 contentListWithViewController를 살펴봅니다\nlet mainContentItem = NSSplitViewItem(contentListWithViewController: MainContentViewController())\nmainContentItem.allowsFullHeightLayout = true\nsplitViewController.addSplitViewItem(mainContentItem)\n\nlet windowController = NSWindowController(window: window)\nwindowController.contentViewController = splitViewController\nwindowController.showWindow(nil)\n\n...\n\nprivate extension NSToolbarItem.Identifier {\n    static let searchItem: NSToolbarItem.Identifier = NSToolbarItem.Identifier(rawValue: \"SearchItem\")\n}\n\nextension AppDelegate: NSToolbarDelegate {\n    func toolbarDefaultItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {\n        return [\n            .toggleSidebar,\n            // 👀 sidebarTrackingSeparator를 살펴봅니다\n            .sidebarTrackingSeparator,\n            .flexibleSpace,\n            .searchItem\n        ]\n    }\n\n    func toolbarAllowedItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {\n        return toolbarDefaultItemIdentifiers(toolbar)\n    }\n\n    func toolbar(_ toolbar: NSToolbar, itemForItemIdentifier itemIdentifier: NSToolbarItem.Identifier, willBeInsertedIntoToolbar flag: Bool) -> NSToolbarItem? {\n        var toolbarItem: NSToolbarItem?\n\n        switch itemIdentifier {\n            case .toggleSidebar:\n                let item = NSToolbarItem(itemIdentifier: .toggleSidebar)\n                item.image = NSImage(systemSymbolName: \"sidebar.left\", accessibilityDescription: nil)\n                toolbarItem = item\n            case .sidebarTrackingSeparator:\n                let item = NSToolbarItem(itemIdentifier: .sidebarTrackingSeparator)\n                toolbarItem = item\n            case .searchItem:\n                let searchToolbarItem = NSSearchToolbarItem(itemIdentifier: .searchItem)\n                searchToolbarItem.searchField = .init()\n                toolbarItem = searchToolbarItem\n            default:\n                toolbarItem = nil\n        }\n        toolbarItem?.isBordered = true\n\n        return toolbarItem\n    }\n}\n```\n\nAppKit에서 NSSplitViewController를 사용하는 경우 코드가 조금 더 구체적이지만 윈도우의 styleMask에 .fullSizeContentView를 사용하고 sidebarTrackingSeparator를 사용하는 것이 주요 포인트입니다. AppKit은 sidebarTrackingSeparator를 이용하여 타이틀 바 내에 구분선을 배치하고 전체 높이의 바를 효과적으로 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n그럼, 이제 yourNavigationSplitView가 WindowGroup를 사용했을 때와 동일한 스타일과 동작을 갖게 되었습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1200/1*s28vqaok0sNDgQZdjF4qKA.gif)\n\n앞으로 다른 사람들에게 도움이 되길 바랍니다. 정말 이 부분에 꽤 많은 시간을 소비했었거든 :(","ogImage":{"url":"/assets/img/2024-06-20-macOSfullheightsidebarwindow_0.png"},"coverImage":"/assets/img/2024-06-20-macOSfullheightsidebarwindow_0.png","tag":["Tech"],"readingTime":6},{"title":"우분투를 macOS처럼 만드는 방법","description":"","date":"2024-06-20 14:36","slug":"2024-06-20-MakeUbuntulooklikeMacOS","content":"\n\n<img src=\"/assets/img/2024-06-20-MakeUbuntulooklikeMacOS_0.png\" />\n\n개발자들이 윈도우 시스템보다 맥북을 선호한다는 사실은 무시한다면, 모두가 맥북을 사용하는 것을 좋아합니다. 그 주된 이유는 제공되는 사용자 인터페이스 때문입니다. 우분투 OS를 사용하는 가장 큰 장점은 우리의 요구에 맞게 사용자 정의할 수 있다는 것입니다. \n\n이 기사에서는 우분투 OS를 MacOS Big Sur처럼 보이게 만드는 방법을 살펴볼 것입니다.\n\n아래 단계를 따라 하면 끝에 시스템이 맥북(OS)처럼 보이게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n# GNOME TWEAKS 설치하기\n\n```js\nsudo apt install gnome-tweaks\n```\n\n![이미지](/assets/img/2024-06-20-MakeUbuntulooklikeMacOS_1.png)\n\n# WhiteSur GTK 테마 설치하기\n\n<div class=\"content-ad\"></div>\n\n우선, WhiteSur GTK 테마를 설치해야 합니다. 이 테마는 macOS Big Sur와 동일한 애플리케이션 창, 창 버튼, 상단 패널 및 독을 제공합니다. 테마를 설치하려면 먼저 몇 가지 명령을 실행해야 합니다. 터미널에서 다음 명령을 실행하세요.\n\n```js\nsudo apt install gtk2-engines-murrine gtk2-engines-pixbuf\n```\n\n다음으로, 다음을 실행하세요.\n\n```js\nsudo apt install sassc optipng inkscape libglib2.0-dev-bin\n```\n\n<div class=\"content-ad\"></div>\n\n위의 2개 명령어는 필요한 종속성을 설치합니다. 종속성을 설치하면 WhiteSur GTK 테마를 설치할 수 있습니다. 그럴 때는 다음 명령어 세트를 실행하세요.\n\n```js\ngit clone https://github.com/vinceliuice/WhiteSur-gtk-theme\ncd WhiteSur-icon-theme/\n./install.sh\n```\n\n![이미지](/assets/img/2024-06-20-MakeUbuntulooklikeMacOS_2.png)\n\n![이미지](/assets/img/2024-06-20-MakeUbuntulooklikeMacOS_3.png)\n\n<div class=\"content-ad\"></div>\n\nhttps://chrome.google.com/webstore/detail/gnome-shell-integration/gphhapmejobijbbhgpjhcjognlahblep\n\n이제 GNOME TWEAKS로 이동해주세요.\n\nTweaks에서 외관 탭으로 이동하고, Applications 및 Shell 값을 \"WhiteSur-dark\"로 변경해주세요. 다른 WhiteSur 테마들도 여러 개 있으니, 다른 테마 중 하나를 시도해보세요.\n\n![이미지](/assets/img/2024-06-20-MakeUbuntulooklikeMacOS_4.png)\n\n<div class=\"content-ad\"></div>\n\n# 아이콘 테마\n\n와이트서 아이콘 테마는 동일한 와이트서 테마 디자이너에 의해 생성되었습니다. 설치 과정도 매우 유사하며 아래는 설치 명령어입니다.\n\n```js\ngit clone https://github.com/vinceliuice/WhiteSur-icon-theme.git\ncd WhiteSur-icon-theme/\n./install.sh\n```\n\n<img src=\"/assets/img/2024-06-20-MakeUbuntulooklikeMacOS_5.png\" />\n\n<div class=\"content-ad\"></div>\n\n이제 GNOME TWEAKS로 이동해 주세요.\n\nGNOME Tweaks에서 외모 탭으로 이동해서 Icons의 값을 BigSur-dark로 변경해 주세요. BigSur라는 옵션이 있고, 이는 밝은 테마와 함께 사용할 수 있습니다.\n\n# Dash to Dock\n\n다음에는 Ubuntu Dock에 마지막 손짓을 해야 합니다. Ubuntu는 이미 도크를 하단으로 이동할 수 있는 옵션을 제공하고 있습니다. 그러나 도크의 폭과 아이콘 크기를 수정할 수 있는 옵션이 없습니다.\n\n<div class=\"content-ad\"></div>\n\n그러므로, 우리는 인기 있는 타사 확장 프로그램인 \"Dash to Dock\"을 사용할 것입니다. 이는 도크를 하단으로 옮길 수 있을 뿐만 아니라 열린 응용 프로그램의 수에 따라 도크의 크기를 조정할 수 있습니다. 게다가 저는 도크 상의 아이콘 크기를 수정하여 macOS 도크와 유사하게 55픽셀로 유지했습니다.\n\n다운로드 링크: [https://extensions.gnome.org/extension/307/dash-to-dock/](https://extensions.gnome.org/extension/307/dash-to-dock/)\n\n![이미지](/assets/img/2024-06-20-MakeUbuntulooklikeMacOS_6.png)\n\n# 마법 램프 효과\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 매직 램프 효과를 적용해야 합니다. 이는 macOS에서 창을 최소화할 때 트리거되는 애니메이션입니다. 이 효과는 Ubuntu의 GNOME 데스크톱 환경으로도 이식되었습니다. 이를 설치하려면 단순히 \"Compix alike magic lamp effect\"라는 GNOME 익스텐션을 설치하면 됩니다. 익스텐션을 설치한 후에는 전체 macOS 룩을 완성할 수 있습니다.\n\n다운로드 링크: [https://extensions.gnome.org/extension/3740/compiz-alike-magic-lamp-effect/](https://extensions.gnome.org/extension/3740/compiz-alike-magic-lamp-effect/)\n\n![매직 램프 효과](/assets/img/2024-06-20-MakeUbuntulooklikeMacOS_7.png)\n\n# 배경화면\n\n<div class=\"content-ad\"></div>\n\n\n![Make Ubuntu look like MacOS 8](/assets/img/2024-06-20-MakeUbuntulooklikeMacOS_8.png)\n\n![Make Ubuntu look like MacOS 9](/assets/img/2024-06-20-MakeUbuntulooklikeMacOS_9.png)\n\n![Make Ubuntu look like MacOS 10](/assets/img/2024-06-20-MakeUbuntulooklikeMacOS_10.png)\n\nAnd that is it, Congratulations!!!\n\n\n<div class=\"content-ad\"></div>\n\n시스템이 이제 빅 서를 사용하는 맥북처럼 보일 것입니다.\n\n질문이 있으시면 댓글로 남겨주세요!","ogImage":{"url":"/assets/img/2024-06-20-MakeUbuntulooklikeMacOS_0.png"},"coverImage":"/assets/img/2024-06-20-MakeUbuntulooklikeMacOS_0.png","tag":["Tech"],"readingTime":4},{"title":"맥OS 앱을 업데이트하는 데 도움이 되는 무료 앱들을 소개합니다","description":"","date":"2024-06-20 14:34","slug":"2024-06-20-KeepyourmacOSappsupdatedwiththesefreeapps","content":"\n\n![image](/assets/img/2024-06-20-KeepyourmacOSappsupdatedwiththesefreeapps_0.png)\n\n저는 제 macOS 소프트웨어에 문제가 있어요, 아마도 그게 병일지도 몰라요. 원인:\n\n내 모든 앱을 최신 상태로 유지해야 해요\n\n많은 앱을 가지려 하지 않지만, 설치한 앱들은 최신 업데이트가 필요해요. 어떻게 해야 할까요? 그 임무를 도와주는 앱들이 있어요. 어떤 앱들인지 알고 싶나요? 계속 읽어보세요!\n\n<div class=\"content-ad\"></div>\n\n# 최신 정보\n\n![최신 정보 이미지](/assets/img/2024-06-20-KeepyourmacOSappsupdatedwiththesefreeapps_1.png)\n\n최신 정보는 모든 앱이 최신 상태인지 확인해 주는 무료 오픈 소스 앱입니다. 설치된 모든 앱과 최신 버전을 보여주는 간단한 앱입니다.\n\n한 번에 한 번의 클릭으로 업데이트하거나 하나씩 업데이트할 수 있습니다. Mac App Store에서 다운로드한 앱과 업데이트를 위해 Sparkle을 사용하는 앱을 지원하며, 시장의 대부분의 앱을 커버합니다.\n\n<div class=\"content-ad\"></div>\n\n앱이 지원되지 않을 경우 Latest를 통해 앱을 열어 수동으로 업데이트를 확인할 수 있습니다.\n\n링크: [github.com](github.com) ` Latest\n\n# Cork\n\n![이미지](/assets/img/2024-06-20-KeepyourmacOSappsupdatedwiththesefreeapps_2.png)\n\n<div class=\"content-ad\"></div>\n\n그것은 홈브루 앱을 빠르게 관리할 수 있는 GUI입니다!\n\n과거에는 터미널을 사용하여 앱을 업데이트했지만, Cork를 사용하면 한 번의 클릭으로 처리할 수 있습니다 (심지어 터미널을 사랑해도요).\n\n유료 앱이지만 무료로 컴파일하고 사용할 수 있는 기회가 있습니다. 시각적으로 홈브루 앱을 관리할 수 있는 다른 다양한 기능을 제공합니다: 검색, 수정, 설치, 삭제,...\n\n그냥 잘 작동합니다 & 앱을 최신 상태로 유지하는 훌륭한 도구입니다. 점.\n\n<div class=\"content-ad\"></div>\n\n링크: github.com ` Cork\n\n# macOS용 Python 정리 스크립트\n\n![이미지](/assets/img/2024-06-20-KeepyourmacOSappsupdatedwiththesefreeapps_3.png)\n\nmac-cleanup-py는 macOS용 강력한 정리 스크립트입니다. 다음 작업에서 도움을 줍니다: 휴지통 비우기, 불필요한 로그 및 파일 삭제, OS 또는 일부 앱에서 캐시 지우기. Xcode나 Android Studio와 같은 특정 앱들을 지우도록 설정할 수 있습니다. 실행하기 전에 무엇을 할 지 미리 보는 매우 유용한 dry 모드가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n링크: github.com ` mac-cleanup-py\n\n# 사용자 정의 함수\n\n저는 모든 개발자가 자신의 .*rc 파일에 가져야 할 것 같은 간단한 함수가 있다고 생각해요: 설치된 앱들의 업데이트 가능 여부를 확인하는 함수. 예를 들어, 저는 이 함수를 제 .zshrc 파일에서 사용해요:\n\n```js\nupdate_all() {\n    if [[ -f /usr/local/bin/composer ]]; then\n        composer self-update\n        composer global update\n    fi\n\n    softwareupdate --all --install --force\n    brew outdated && brew update && brew upgrade && brew cleanup\n    ## 여기에 본인 것을 추가하세요!\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이제 macOS를 최신 상태로 유지할 핑계는 없어졌어요. 물론 수동 방식을 계속 사용할 수 있지만, 이러한 앱들을 사용하면 더 적은 시간 안에 프로세스를 더 잘 제어할 수 있어요. 당신은 이 목적을 달성하기 위해 다른 앱을 사용하나요? 알려주세요! 😃\n\n이 기사는 라즈베리 파이, 리눅스, macOS, 데브옵스, 개발과 같은 주제에 관한 뉴스/튜토리얼을 읽을 수 있는 블로그 misapuntesde.com에서 처음으로 발행되었습니다. 저는 취직을 찾고 있으니 제 LinkedIn 프로필을 방문해주세요! 감사합니다!","ogImage":{"url":"/assets/img/2024-06-20-KeepyourmacOSappsupdatedwiththesefreeapps_0.png"},"coverImage":"/assets/img/2024-06-20-KeepyourmacOSappsupdatedwiththesefreeapps_0.png","tag":["Tech"],"readingTime":3},{"title":"콜리마 에센셜 개발자 안내","description":"","date":"2024-06-20 14:33","slug":"2024-06-20-ColimaEssentialsDeveloperGuide","content":"\n\n## macOS에서 Colima 컨테이너 런타임을 사용하는 개발자 안내서.\n\n![Colima Essentials Developer Guide](/assets/img/2024-06-20-ColimaEssentialsDeveloperGuide_0.png)\n\nColima 세계에 뛰어들어 시작하는 데 완벽한 필수 안내서입니다.\n\n쉬운 설치 단계부터 편리한 명령줄 트릭까지, macOS 또는 Linux 기기에서 로컬 컨테이너 런타임을 설정하는 방법을 배울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nColima를 사용하여 개발 환경을 더 스무스하고 효율적으로 만들어 보세요!\n\n# 콜리마란?\n\n콜리마는 macOS(및 Linux)에서 사용할 수 있는 무료 컨테이너 런타임으로, Lima VM에서 Docker 컨테이너 런타임을 설정할 수 있는 최소한의 설정이 필요합니다. Colima는 간단하고 쉽게 사용할 수 있는 명령줄 인터페이스(CLI)를 제공하며, Intel 및 M1 프로세서를 모두 지원합니다.\n\nColima의 다른 기능으로는 docker 및 containerd 런타임 지원, 포트 전달, 볼륨 마운트, 쿠버네티스 및 여러 인스턴스 지원이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n콜리마는 Docker Desktop의 대체로 사용할 수 있습니다. 특히 특정 조건에서 Docker Desktop은 무료가 아닙니다.\n\n# 리마(Lima)란?\n\n리마는 콜리마가 기능을 달성하는 데 사용하는 기술입니다. 리마는 macOS에서 리눅스 가상 머신(VM)을 만들어주는 오픈 소스 프로젝트입니다. 이를 통해 Mac에서 리눅스 환경을 제공합니다.\n\n리마는 자동 파일 공유, 포트 포워딩 및 컨테이너드를 지원하는 리눅스 가상 머신을 시작합니다. 리마의 목적은 사용자들에게 네르드컨테이너(nerdctl)를 포함한 컨테이너드를 소개하는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n리마는 컨테이너가 아닌 애플리케이션에도 사용할 수 있어요. 리마는 게스트 머신을 실행하는 qemu 및 vz를 지원하며, 이는 인스턴스 생성 중에만 지정될 수 있어요.\n\n# 설치\n\n콜리마는 Homebrew에서 제공되며 macOS에 다음 명령어로 설치할 수 있어요:\n\n```js\n# Homebrew를 사용하여 Colima 설치\n$ brew install colima\n```\n\n<div class=\"content-ad\"></div>\n\nColima를 설치하려면 MacPorts, Nix, Arch, 이진 파일 또는 소스에서 빌드하는 방법을 사용하여 공식 Colima Github 페이지의 설치 안내를 따르세요.\n\nColima를 Docker Desktop 대체로 사용할 수 있으므로 다음 소프트웨어가 필요합니다:\n\n```js\n$ brew install docker \n$ brew install docker-compose \n$ brew install docker-credential-helper\n$ brew install kubectl\n```\n\n# Colima 구성\n\n<div class=\"content-ad\"></div>\n\n## Colima 기본 구성\n\n기본 구성을 편집하는 두 가지 방법이 있습니다. 첫 번째는 colima를 --edit 플래그와 함께 시작하여 일회성 구성을 하는 것이며, 두 번째는 새로운 인스턴스의 기본 구성 템플릿을 편집하는 것입니다.\n\n일회성 구성\n\n```js\n# 시작하기 전에 기본 구성을 일회성으로 사용자 정의합니다\n$ colima start --edit\n```\n\n<div class=\"content-ad\"></div>\n\n구성 파일은 $HOME/.colima/default/colima.yaml에 있습니다. 이 파일은 수동으로 구성할 수 있습니다. 다른 프로필의 구성은 $HOME/.colima/`프로필명`/colima.yaml에서 찾을 수 있습니다.\n\n기본 구성용 템플릿\n\n```js\n# 새로운 인스턴스의 기본 구성 템플릿을 편집하세요.\n$ colima template\n```\n\n템플릿 파일은 $HOME/.colima/_templates/default.yaml에 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 도커 로그인 구성\n\n도커 로그인이 올바르게 구성되어 있는지 확인하려면 docker-credential-helper를 설치해야 합니다. docker-credential-helpers는 도커 자격 증명을 안전하게 보관하기 위해 네이티브 저장소를 사용하는 프로그램 모음입니다.\n\n이미 이 작업을 수행하지 않았다면 macOS에서 다음 명령을 사용하여 docker-credential-helper를 설치할 수 있습니다.\n\n```js\n$ brew install docker-credential-helper\n```\n\n<div class=\"content-ad\"></div>\n\n/usr/local/bin에 심볼릭 링크가 생성되었습니다. 심볼릭 링크를 확인하고 올바르게 구성되었는지 확인하려면 다음 명령을 실행하면 됩니다. 아래와 같이 표시되어야 합니다:\n\n```js\n$ ls -l /usr/local/bin/docker-credential-osxkeychain\n/usr/local/bin/docker-credential-osxkeychain -> ../Cellar/docker-credential-helper/0.7.0/bin/docker-credential-osxkeychain\n```\n\n다음 단계는 ~/.docker/config.json 구성 파일 내에서 credstore 속성을 사용하려는 프로그램의 접미사로 설정하는 것입니다. 예를 들어, docker-credential-osxkeychain을 사용하려면 osxkeychain으로 설정하십시오. desktop과 같은 다른 값으로 설정할 수도 있습니다.\n\n속성을 설정한 후, 구성은 다음과 같이 보여야 합니다:\n\n<div class=\"content-ad\"></div>\n\n```json\n{\n  \"credsStore\": \"osxkeychain\"\n}\n```\n\n## 도커 컴포즈 및 볼륨 구성\n\n도커 컴포즈가 올바르게 구성되도록 하려면 다음 명령어를 사용하여 cli-plugin 폴더를 만들어주십시오:\n\n```sh\n$ mkdir -p $HOME/.docker/cli-plugins\n$ ln -sfn /usr/local/opt/docker-compose/bin/docker-compose $HOME/.docker/cli-plugins/docker-compose\n```\n\n<div class=\"content-ad\"></div>\n\n## 구성 확인\n\nColima가 성공적으로 설치되고 구성되었는지 확인하려면 다음 명령을 사용하여 구성을 검증할 수 있습니다.\n\n지정된 컨테이너 런타임과 함께 Colima를 시작하고 Colima에서 상태 명령어를 실행합니다. Colima가 성공적으로 시작된 후, 도커 버전 명령을 실행하여 도커가 colima 런타임으로 작동하는지 확인합니다.\n\n자격 증명 설정이 작동하는지 확인하려면 도커 로그인 명령을 실행하세요. 도커 Compose가 작동하는지 확인하려면 도커-컴포즈 버전 명령을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n```sh\n$ colima start; colima status\n$ docker version\n$ docker login\n$ docker-compose version\n```\n\n## Colima 사용 시나리오\n\n### 기본적인 Colima 사용\n\n기본적인 사용 시나리오는 colima를 통해 컨테이너 런타임을 시작하는 것입니다. 이것이 colima를 사용하는 첫 번째 경우라면, 모든 기본 구성이 템플릿에 따라 새로운 기본 프로필로 생성됩니다.\n\n<div class=\"content-ad\"></div>\n\n가상 머신에 할당되는 기본 구성 속성은 다음과 같습니다:\n\n```js\n# 가상 머신에 할당되는 CPU 개수.\ncpu: 2\n# 가상 머신에 할당되는 디스크 크기(기가바이트).\ndisk: 60\n# 가상 머신에 할당되는 메모리 크기(기가바이트).\nmemory: 2\n# 가상 머신의 아키텍처(x86_64, aarch64, host).\narch: host\n# 사용할 컨테이너 런타임(docker, containerd).\nruntime: docker\n# 가상 머신을 위한 Kubernetes 구성.\nkubernetes:\n  enabled: false\n```\n\nDocker를 처음 사용하는 경우 Docker 레지스트리에도 로그인해야 합니다. docker run 명령어를 사용하여 'hello-world' 도커 이미지를 기반으로 실행할 수 있습니다.\n\nDocker 사용이 끝나면 colima stop 명령어를 사용하여 Docker 런타임을 중지해야 합니다. colima list 명령어를 실행하여 모든 colima 인스턴스가 정지되었는지 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다음 명령어는 Colima의 기본 사용법을 수행하는 데 사용됩니다:\n\n```js\n# 기본 colima 인스턴스 시작 또는 새로운 기본 생성\n$ colima start\n\n# 모든 Colima 인스턴스 목록\n$ colima status\n\n# Docker 레지스트리에 로그인\n$ docker login\n\n# hello-world라는 이름의 Docker 컨테이너 실행\n$ docker run hello-world\n\n# 기본 colima 인스턴스 중지\n$ colima stop\n\n# 모든 colima 인스턴스 목록\n$ colima list\n```\n\n# Lima CLI를 통해 Colima 관리\n\nColima 도구가 응답하지 않을 경우 limactl을 사용하여 linux 가상 머신 내에서 colima 컨테이너 런타임을 관리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n# 리눅스 가상 머신의 인스턴스 목록을 나열합니다.\n$ limactl ls\n\n# Colima 리눅스 가상 머신을 중지합니다.\n$ limactl stop colima\n\n# Colima 리눅스 가상 머신을 삭제합니다.\n$ limactl delete colima\n\n# Lima에 대한 도움말 정보를 표시합니다.\n$ limactl --help\n\n\n# Colima 명령어\n\n다음 명령어는 colima 버전 0.5.2를 기반으로 합니다. 이 섹션의 목적은 기존 colima 명령어 설명을 대체하는 것이 아니라 저가 자주 사용하는 명령어로 구성된 명령어 집합으로 제공하는 것입니다.\n\n이 섹션에는 예제와 함께 colima 명령어 목록이 포함되어 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n- colima completion - 다양한 쉘용 완성 스크립트 생성.\n- colima delete - Colima 및 모든 설정 삭제 및 해체.\n- colima help - 다양한 colima 명령어에 대한 도움말 정보 표시.\n- colima kubernetes - Kubernetes 클러스터 관리.\n- colima list - 생성된 모든 인스턴스 나열.\n- colima nerdctl - containerd 런타임이 필요한 nerdctl을 실행하여 상호작용.\n- colima ssh - VM으로 SSH하는 데 사용하거나 추가 명령어를 추가하여 해당 명령어를 실행.\n- colima ssh-config - VM으로의 SSH 연결 구성 표시.\n- colima start - 지정된 컨테이너 런타임 및 선택적 쿠버네티스로 Colima 시작.\n- colima status - Colima의 상태 표시.\n- colima stop - 자원을 해제하기 위해 Colima 인스턴스 중지. VM의 상태는 중지될 때 유지됨.\n- colima template - 새로운 인스턴스의 기본 구성을 위한 템플릿 수정.\n- colima version - Colima 버전 출력.\n\n# 요약\n\n마침내, 당신은 Colima의 상세 탐험에 착수하여 macOS에 컨테이너 런타임을 효율적으로 설정할 지식을 얻었습니다.\n\n이 안내서는 동반자 역할을 하며, Colima의 전체 잠재력을 발휘하여 컨테이너화 노력에서 발생하는 모든 개발적인 어려움을 보다 쉽고 자신감 있게 극복하는 데 도움을 줄 것입니다.\n\n<div class=\"content-ad\"></div>\n\n이 기사에 열 번 👏을 치면서 공유 🤝해 주시고 도움을 받을 수 있는 사람들에게 알려주세요. 더 이상 이와 같은 게시물을 보려면 저(👥 André Maré)를 팔로우해 주세요.","ogImage":{"url":"/assets/img/2024-06-20-ColimaEssentialsDeveloperGuide_0.png"},"coverImage":"/assets/img/2024-06-20-ColimaEssentialsDeveloperGuide_0.png","tag":["Tech"],"readingTime":7},{"title":"맥에서 GTA 5를 하는 방법","description":"","date":"2024-06-20 14:32","slug":"2024-06-20-HowtoPlayGTA5onMac","content":"\n\n## GTA 5을 맥에서 하는 방법을 안내할게요\n\n![이미지](/assets/img/2024-06-20-HowtoPlayGTA5onMac_0.png)\n\n맥에서 GTA 5를 하는 다양한 방법을 시도해 봤어요. 저는 64GB RAM, 38 GPU, 12코어 CPU를 갖춘 맥 스튜디오 M2를 사용 중이에요.\n\n제 맥 구성이 높다고 해서 낮은 구성의 여러분이 맥에서 GTA 5를 즐기지 못하는 건 아니에요.\n\n<div class=\"content-ad\"></div>\n\n## macOS에서 게임을 플레이할 수 있는 세 가지 방법이 있어요.\n\n- Whisky (무료)\n- Crossover (유료)\n- Parallels (유료)\n\n이제 macOS에서 GTA 5를 플레이하기 위해 이 세 가지 방법을 모두 시도해 봤는데, Crossover에서만 작동했어요. Crossover는 여기서 구할 수 있어요.\n\nCrossover는 매우 저렴해요. 연간 20달러에 구매할 수 있어요. 저는 지난 2년 동안 사용해 왔는데, 1년이 지나도 갱신하지 않아도 계속 사용할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n만약 갱신을 하지 않으면 지원을 받을 수 없습니다. 저는 2년 동안 사용했는데, 솔직히 지원이 필요한 적은 없었어요. 그러니 여기서 Crossover를 구매하고 즐기세요.\n\n## 플레이 방법 + GTA 5 설치\n\n지금까지 유튜브 비디오에서 어떻게 맥에서 GTA 5를 플레이하는 방법을 가르쳐드렸어요.\n\n아래에는 이를 도와줄 단계별 튜토리얼이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n위의 비디오를 보시면 맥에서 GTA 5를 플레이하는 데 정말 도움이 될 거에요.\n\n만약 이 이야기를 좋아하신다면 반드시 박수를 보내주시고, 팔로우도 꼭 해주세요 :)","ogImage":{"url":"/assets/img/2024-06-20-HowtoPlayGTA5onMac_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoPlayGTA5onMac_0.png","tag":["Tech"],"readingTime":1},{"title":"맥 macOS  Apple Silicon M1, M2 에 Java 21을 설치하고 JAVA_HOME 경로를 설정하는 방법","description":"","date":"2024-06-20 14:31","slug":"2024-06-20-HowtoinstallJava21andsetupJAVA_HOMEPathinmacOSAppleSiliconM1M2","content":"\n\nApple Silicon M1 또는 M2 Mac의 자랑스러운 소유자라면 Java를 설치하고 JAVA_HOME 경로를 설정하는 방법에 대해 궁금할 수 있습니다. Java는 다양한 애플리케이션에서 사용되는 유연한 프로그래밍 언어로, macOS에 올바르게 설치하는 것은 개발자와 기술 애호가들에게 필수적입니다. 이 안내서에서는 Apple Silicon Mac에서 Java를 설치하고 실행하는 단계를 안내해 드리겠습니다.\n\n![Java 설치 및 JAVA_HOME 경로 설정 가이드](/assets/img/2024-06-20-HowtoinstallJava21andsetupJAVA_HOMEPathinmacOSAppleSiliconM1M2_0.png)\n\n# 단계 1: 적합한 Java 버전 다운로드 ☕\n\nApple Silicon Mac은 Intel 기반 이전 제품과 다른 아키텍처를 사용합니다. 따라서 Apple Silicon과 호환되는 Java 버전을 다운로드해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n- 웹 브라우저를 열고 오라클 웹 사이트의 Java 다운로드 섹션을 엽니다.\n- macOS용 \"최신 Java 릴리스\"를 선택합니다.\n- ARM64 DMG 설치 프로그램 다운로드 링크를 클릭하여 파일을 컴퓨터에 저장합니다.\n\n![이미지](/assets/img/2024-06-20-HowtoinstallJava21andsetupJAVA_HOMEPathinmacOSAppleSiliconM1M2_1.png)\n\n# 단계 2: Java 설치하기 🛠️\n\n적절한 Java 버전을 다운로드했으므로, 이제 Mac에 설치하는 시간입니다.\n\n<div class=\"content-ad\"></div>\n\n- 다운로드한 파일을 찾으세요 (보통 \"Downloads\" 폴더에 있습니다) 그리고 두 번 클릭하여 설치 패키지를 엽니다.\n- 설치 프로세스를 완료하기 위해 화면에 나타나는 지침에 따라주세요. 이 과정에는 라이센스 동의가 포함됩니다.\n\n# 단계 3: Java 설치 확인하기 ✔️\n\nJava가 올바르게 설치되었는지 확인하려면 터미널을 열어서 다음을 입력하세요:\n\n```js\njava --version\n```\n\n<div class=\"content-ad\"></div>\n\n화면에 Java 버전이 표시되어 있어야 합니다.\n\n![Java Version](/assets/img/2024-06-20-HowtoinstallJava21andsetupJAVA_HOMEPathinmacOSAppleSiliconM1M2_2.png)\n\n# 단계 4: JAVA_HOME 설정 🏠\n\n개발 목적으로 Java를 쉽게 이용할 수 있도록 하려면 JAVA_HOME 환경 변수를 설정해야 합니다. macOS에서 JAVA_HOME 경로를 설정하는 단계를 따라주세요.\n\n<div class=\"content-ad\"></div>\n\n- 터미널 애플리케이션을 엽니다(\"Applications\" 폴더 내 \"Utilities\" 폴더에 있습니다).\n- zShell 환경 파일을 만들어보세요. 환경 파일은 맥의 루트 디렉토리에 있어야 하며 이름은 \".zshenv\" 여야 합니다. 아래 코드를 사용하여 zShell 환경 파일을 만드세요.\n\n```js\ntouch ~/.zshenv\n```\n\n- 아래 코드를 사용하여 zShell 환경 파일을 열어보세요.\n\n```js\nopen ~/.zshenv\n```  \n\n<div class=\"content-ad\"></div>\n\n- 아래 경로를 zShell 환경 파일에 추가하고 저장해주세요.\n\n```js\nexport JAVA_HOME=$(/usr/libexec/java_home)\n```\n\n![이미지](/assets/img/2024-06-20-HowtoinstallJava21andsetupJAVA_HOMEPathinmacOSAppleSiliconM1M2_3.png)\n\n- 환경 파일을 저장하고 닫은 후에 아래 코드를 터미널에 입력하여 변경 사항을 적용하고 프로필을 새로 고침해주세요.\n\n<div class=\"content-ad\"></div>\n\n\nsource ~/.zshenv\n\n\n자바 홈 경로가 zShell 환경 파일에 성공적으로 설정되었습니다. 건배🍻\n\n# 단계 5: JAVA_HOME 설정 확인 ✔️\n\nJava가 올바르게 설치되었고 JAVA_HOME 경로가 설정되었는지 확인하려면 터미널을 열고 다음을 입력하세요:\n\n\n<div class=\"content-ad\"></div>\n\n```js\necho $JAVA_HOME\n```\n\n![Java Installation Guide](/assets/img/2024-06-20-HowtoinstallJava21andsetupJAVA_HOMEPathinmacOSAppleSiliconM1M2_4.png)\n\n# 결론 🎉\n\n축하합니다! Java를 성공적으로 설치하고 Apple Silicon M1 또는 M2 Mac에서 JAVA_HOME 경로를 설정했습니다. 이제 쉽게 Java 응용 프로그램을 개발하고 코딩할 준비가 되었습니다.\n\n<div class=\"content-ad\"></div>\n\nJava 설치를 최신 상태로 유지하고 강력한 Apple Silicon Mac에서 Java 개발의 흥미로운 세계를 탐험해보세요! 💻🍏✨\n\n설치 과정 중 궁금한 점이나 문제가 발생하면 Java 커뮤니티에 문의하거나 공식 문서를 참고하여 도움을 받을 수 있습니다. 즐거운 코딩하세요! 🚀👨‍💻👩‍💻","ogImage":{"url":"/assets/img/2024-06-20-HowtoinstallJava21andsetupJAVA_HOMEPathinmacOSAppleSiliconM1M2_0.png"},"coverImage":"/assets/img/2024-06-20-HowtoinstallJava21andsetupJAVA_HOMEPathinmacOSAppleSiliconM1M2_0.png","tag":["Tech"],"readingTime":3}],"page":"56","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":2},"__N_SSG":true}