{"pageProps":{"posts":[{"title":"파스칼의 삼각형을 간단하고 빠르게 이해하는 방법","description":"","date":"2024-06-23 18:26","slug":"2024-06-23-AShortandDirectWalkwithPascalsTriangle","content":"\n\n## 경로 탐색 알고리즘을 세는 것으로 개선할 수 있다면?\n\n![이미지](/assets/img/2024-06-23-AShortandDirectWalkwithPascalsTriangle_0.png)\n\n다익스트라(Dijkstra) 알고리즘과 A*와 같은 고전적인 경로 탐색 알고리즘은 비디오 게임, 모바일 로봇공학 및 건축 설계와 같은 응용 프로그램에서 여행 경로를 생성하는 데 사용됩니다. 이러한 알고리즘의 인기에도 불구하고, 그들이 생성하는 경로는 거의 직선으로 이어지지 않습니다. 이 문서에서는 Pascal의 삼각형에서 영감을 받은 계산 기술을 사용하여 매우 직접적인 경로를 계산하는 방법에 대해 배울 수 있습니다. 이는 제 동료들과 제가 개발한 아이디어로, 최근 인공지능 연구 저널에 발표되었습니다. 전통적인 경로 탐색의 오래된 문제를 극복할 수 있는 쉬운 경로 수 세기 단계를 통해 경로를 계산할 수 있습니다.\n\n# 미관코의 경로 문제\n\n<div class=\"content-ad\"></div>\n\n다양한 분야에서 짧고 직접적인 경로를 계산해야 하는 필요성이 발생합니다. 건물 설계자들은 길찾기 도구를 사용하여 사람들이 가장 가까운 비상구에 도달하기 위해 얼마나 걷어야 하는지 분석합니다. 일부 건축가들은 한 걸음 더 나아가 건물을 대피하는 사람들의 군중을 시뮬레이션하며, 이는 모든 건물 거주자를 위한 대피 경로를 생성해야 합니다. 비디오 게임 개발자들은 AI가 제어하는 에이전트가 맵 상에서 어떻게 이동해야 하는지 결정하기 위해 경로 탐색 알고리즘을 활용합니다.\n\n경로 찾기를 구현하는 가장 간단하고 인기 있는 방법 중 하나는 맵을 그리드 형식으로 표현한 다음, Dijkstra's Algorithm이나 A*와 같은 고전적인 검색 방법을 적용하여 가능한 최단 거리의 그리드 경로를 찾는 것입니다. 아래 애니메이션은 시작 위치 A에서 목적지 B까지의 최단 그리드 경로의 예시를 보여줍니다. 그림자가 있는 그리드 셀은 피해야 할 벽 또는 다른 장애물을 나타냅니다. 일단은 그리드 경로를 따라 이동할 때 각 이동이 북쪽, 남쪽, 동쪽 또는 서쪽 중 하나의 방향으로 한 걸음이라고 가정하겠습니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*L-is8Tk78R2rCC1vOPsc7g.gif)\n\n위 경로는 A에서 B로 가는 400개의 최단 그리드 경로 중 하나입니다. 또한 매우 간접적인 경로입니다. 명백한 직선 최단거리를 활용하지 않습니다. 만약 그리드에 따라 걷어야 하는 의무가 없는 경우 실제로 사람이 따르는 직접적인 경로와는 크게 다릅니다. Amit Patel의 Red Blob Games 튜토리얼에서 A*를 구현하는 방법에 대해 설명한 내용에 따르면 이러한 \"못생긴 경로\"는 널리 발생하는 문제라고 합니다.\n\n<div class=\"content-ad\"></div>\n\nThe ugly path problem can be tackled in a brute force manner by testing up to hundreds of thousands of possible straight-line shortcuts during an A* path search. An algorithm called Theta*, which was published in 2010, uses this approach. In order to avoid all these line-of-sight tests, our strategy is to select a shortest grid path that happens to approximate a direct route. Of the 400 shortest grid paths in our example, the path below is the one we would select.\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*82ROrH4W04_B9M5apco4Jg.gif)\n\nThis central grid path isn’t actually shorter than the indirect grid path we saw previously. Both paths require 15 grid moves, and each move is one grid spacing in length. However, the central path is a better approximation of the smooth path a person would take in real life. One way to solve the ugly path problem is to find a simple and efficient method for producing central grid paths. Enter Pascal’s Triangle.\n\n# Pascal’s Triangle\n\n<div class=\"content-ad\"></div>\n\n1655년에 프랑스 수학자 블레즈 파스칼이 '삼각수열에 관한 논문'을 발표했습니다. 이후 이 수열은 파스칼의 삼각형으로 알려지게 되었습니다.\n\n파스칼의 삼각형에 대한 분석은 니윗의 이항정리에 대한 기여뿐만 아니라 라이프니츠의 미적분학에도 영감을 주었습니다. 그러나 이 패턴을 처음 발견한 사람은 파스칼이 아니었습니다. 오리엔트(페르시아 및 중국), 인도에서 1000년 넘게 전 발견되었습니다.\n\n파스칼의 삼각형은 정점과 두 변이 다른 위치에 1을 둠으로써 형성됩니다. 나머지 숫자는 이전 두 숫자를 더하여 생성됩니다. 아래 애니메이션은 처음 5행에 대한 작업을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-AShortandDirectWalkwithPascalsTriangle_2.png\" />\n\n파스칼의 삼각형은 매력적인 여러 성질로 유명합니다. 그 중 하나는 파스칼의 삼각형의 각 숫자를 경로 수로 해석할 수 있다는 점입니다: 삼각형 정점에서 해당 숫자의 위치까지의 가장 짧은 격자 경로 수입니다. 예를 들어, 애니메이션의 중앙 하단에 있는 육각형 격자 셀에는 숫자 6이 있으며, 삼각형의 맨 위 셀에서 해당 중앙 하단 셀까지의 정확히 6개의 가장 짧은 격자 경로가 있습니다. 이 애니메이션은 육각 격자를 보여줍니다만, 파스칼의 삼각형이 블레즈 파스칼의 이전 다이어그램처럼 사각 격자에 그려져 있을 때에도 이 성질은 유지됩니다.\n\n파스칼의 삼각형을 사용하여 격자 상의 경로 수를 세는 방법을 설명하는 온라인 기사와 비디오들이 많이 있습니다. 놀랍게도 우리는 한 단계 더 나아갈 수 있습니다. 파스칼의 삼각형은 우리에게 모든 가능한 경로 수를 세는 방법 뿐만 아니라 이러한 경로 중에서 가장 직접적인 경로 중 하나를 선택하는 방법도 보여줍니다.\n\n# Counting을 통한 Pathfinding\n\n<div class=\"content-ad\"></div>\n\n새로운 경로 탐색 접근 방식은 각 그리드 셀을 통과하는 최단 경로의 수를 세고, 그 중 가장 높은 수를 가진 그리드 셀을 선택합니다.\n\n첫 번째 단계는 순방향으로 경로를 세는 것입니다. 아래 그림에서 보듯이 시작 위치 A에 숫자 1을 할당하는 것부터 시작합니다. 그리드 셀에 숫자가 할당되면, 해당 숫자는 최단 그리드 경로를 따라 다음 셀로 복사됩니다. 여러 경로가 만나는 경우, 숫자가 추가됩니다. Pascal의 삼각형과 유사하게, 결과적으로 각 그리드 셀은 A에서 해당 셀로의 최단 그리드 경로 수를 포함하게 됩니다. 예를 들어, 애니메이션에서 A와 12로 표시된 셀 사이에는 12개의 최단 그리드 경로가 있습니다. A와 B 사이에는 400개의 최단 그리드 경로가 있다는 사실에 주목해주세요.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*1rFU420fm5kfktpcMJigvQ.gif)\n\n그런 다음, 역방향으로 절차를 반복합니다. 이제 B에 숫자 1을 할당하고, A에 도달할 때까지 숫자를 복사하고 추가합니다. 결과적으로 모든 그리드 셀은 B에서 해당 셀로의 최단 그리드 경로 수를 포함하게 됩니다. 방향을 반전했지만 두 끝점 사이에 여전히 400개의 최단 그리드 경로가 있다는 점에 주목해주세요.\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*pX75tvt6Iu0HdwlRIdvP7w.gif)\n\n다음 단계는 이 두 개의 경로 수 세트를 가져와 곱하여 단일 탐색 횟수 세트를 만드는 것입니다. 이 개념을 이해하려면 위의 애니메이션을 보고 A로부터 12개의 경로 수와 B로부터 20개의 경로 수를 가진 고유한 그리드 셀을 찾으십시오. 한 쪽에서의 12개 경로와 다른 쪽에서의 20개 경로는 12×20 개의 서로 다른 조합으로 결합될 수 있어서 A에서 B로 가는 도중에 이 그리드 셀을 통해 통과하는 경로가 240개 있다는 것을 의미합니다. 아래에서 볼 수 있듯이 이 셀의 탐색 횟수는 240입니다. 이 애니메이션은 각 그리드 셀에 대해 탐색 횟수가 계산되는 과정을 보여줍니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*PpM5hzKpMgrcwQk1M5Of6Q.gif)\n\n마지막 단계는 A에서 시작한 다음 B로 향하는 다음 그리드 셀을 반복해서 선택하고 가장 높은 탐색 횟수를 갖는 그리드 셀을 선택하는 것입니다. 아래의 애니메이션은 탐색 횟수를 표시하고 경로가 생성되는 과정을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*bd3lyPgJHvHpT0Gsbp8w-w.gif)\n\n특정 방식으로 접근한 결과는 중심 그리드 경로입니다. 이는 사람이 걸어다닐 것으로 예상되는 경로를 근사한 직접적인 최단 그리드 경로입니다.\n\n# 경로 계산의 장점\n\n경로 계산이 미치는 영향을 살펴보려면, 아래에 일반적인 A* 구현체에 의해 생성된 임의 또는 \"추악한\" 최단 그리드 경로를 보면 됩니다. 이 맵은 Dragon Age: Origins 벤치마크 데이터셋에서 가져왔습니다. 이 그리드 경로는 큰 불필요한 지그재그를 보이며, 경로의 부드럽게 만든 버전조차 명백한 결함을 가지고 있습니다. 이미지를 클릭하여 자세히 살펴보세요.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-AShortandDirectWalkwithPascalsTriangle_3.png\" />\n\nA*가 경로 카운팅과 함께 확장되면, 중심 그리드 경로가 지도의 빈 영역을 가로지를 때 시야선을 따라가게 됩니다. 아래 그림에서 보듯이, 지그재그가 가능한 한 작아졌으며, 부드럽게 만들 수 있습니다. 중심 그리드 경로를 계산하는 데 평균적으로 임의의 그리드 경로보다 약 40% 더 오래 걸립니다. 반면, A*에서 Theta*로 전환하면 계산 시간이 세 배로 증가할 것입니다. 본문에서 보는 것처럼, 경로를 계산하는 단계를 추가함으로써 결과 품질이 크게 향상됩니다.\n\n<img src=\"/assets/img/2024-06-23-AShortandDirectWalkwithPascalsTriangle_4.png\" />\n\n위의 중심 경로는 가까운 평행한 경로를 근사하고 있는 것을 알 수 있습니다. 이러한 관찰은 중심 그리드 경로의 이론적 특성과 일치합니다. 같은 끝 점 사이에서 중심 경로를 계속해서 계산하지만 그리드 해상도를 점점 세밀하게 해본다고 상상해보십시오. 중심 극한 정리에 따르면, 이 중심 경로가 최종적으로는 어떠한 직선 단축을 활용하고 있다고 재경로화되며 다크한 경로에 수렴할 것입니다. 다시 말해, 중심 그리드 경로는 궁극적으로 완벽하게 직접적이게됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 실용적인 고려사항\n\n새로운 접근 방식은 중앙 그리드 경로 계획, 중앙 그리드 기반 경로 탐색 또는 카운팅에 의한 경로 탐색으로 언급될 수 있습니다. 이 기술을 구현에 관심이 있다면, 아래에 주의해야 할 몇 가지 실용적인 고려사항이 있습니다. 더 자세한 안내사항은 오픈 액세스 저널 논문 \"그리드 기반 네비게이션을 위한 경로 카운팅\" [1]에서 확인할 수 있습니다.\n\n- 먼저 Dijkstra 또는 A* 알고리즘을 사용한 후에 경로를 계산합니다. 이 논문의 애니메이션 예시는 모든 도달 가능한 그리드 셀이 최단 그리드 경로의 일부인 특수한 경우입니다. 일반적으로 Dijkstra 알고리즘 또는 A*를 사용하여 최단 그리드 경로의 방향성 비순환 그래프(DAG)를 생성하는 것이 좋습니다. 이 작업이 완료되면 경로 카운팅 작업은 원래 맵이 아닌 DAG에서 수행됩니다. 자세한 내용은 논문의 3.1 및 3.2절에서 확인할 수 있습니다. 결론적으로, 경로 계산은 Dijkstra 또는 A* 대안이 아니라 이러한 고전적인 경로 탐색 방법을 개선하는 방법입니다.\n- 큰 경로 횟수를 계산하기 위해 로그를 사용하세요. 경로 횟수는 그리드의 크기와 기하학적으로 증가합니다. 따라서 애니메이션 예시에서는 400개의 최단 그리드 경로가 있지만, 실제 응용 프로그램에서는 10의 400승 이상의 경로가 있을 수 있습니다. 이는 경로 횟수를 직접 나타내기 위해 64비트 부동 소수점 숫자를 사용하면 오버플로우할 수 있음을 의미합니다. 다행히 로그를 사용하여 간접적으로 경로 횟수를 처리할 수 있습니다. 논문의 3.2절은 이 접근 방식의 작은 것이지만 극도로 중요한 세부 조정을 설명합니다.\n- 가능한 경우 대각선 이동을 허용하세요. 애니메이션 예시에서 그리드 이동은 4개의 주요 이동(north, south, east, west)으로 제한됩니다. 더 나은 결과를 위해 4개의 대각선 이동(ne)으로도 허용하는 것이 최선입니다. 이 경우, 대각선 이동은 주이동보다 대략 40% 길다는 것을 기억해야 합니다. 또한 대각선 이동을 허용하는 경우, 두 그리드 셀 간의 등장 수에 따라 약간의 차이가 나타날 수 있는 반올림 오차에 주의해야 합니다. 논문의 예시에서는 주요 및 대각선 이동이 허용된 경우를 가정합니다.\n- 원하는 경우 최종 경로를 부드럽게 만드세요. 그리드 경로를 후처리 단계에서 부드럽게 만들어 원치 않는 지그재그를 제거하고 경로를 줄이는 것이 일반적인 방법입니다. 경로 계산과 경로 부드러움이 잘 결합된다는 것이 밝혀졌습니다. 논문의 3.3절은 중앙 그리드 경로를 부드럽게 만드는 것이 임의의 최단 그리드 경로를 부드럽게 만드는 것보다 더 짧은 이동 경로를 생성한다는 것을 보여줍니다.\n- 기존의 구현과 결과를 비교하세요. 작성 시점에서 중앙 그리드 기반 경로 찾기 도구가 하나 이상 존재합니다. SpaceAnalysis라는 저와 동료들이 개발한 건축 설계 도구가 그 예입니다. 더 많은 사람들이 이 기술에 대해 배우면 다른 구현이 나타날 것입니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n경로 계산은 파스칼의 삼각형의 핵심에서 잘 알려진 절차입니다. 또한 클래식한 경로 탐색 알고리즘에서 더 직접적이고 직선적인 이동 경로를 얻는 실용적인 방법입니다. 비디오 게임, 분석 도구 또는 심지어 모바일 로봇을 위한 간단한 내비게이션 방법이 필요하다면 논문을 확인하고 경로 계산을 시작해보세요!\n\n업데이트: 본문이 이제 3부작 시리즈의 첫 번째 글이 되었습니다. Grid-Based Visibility에서 볼 수 있는 영역을 계산하는 데 경로 계산을 어떻게 활용할 수 있는지 알아보세요. 그런 다음 배운 내용을 적용하여 3D 그리드 이웃을 다루는 A Sharp and Solid Outline of 3D Grid Neighborhoods를 확인하세요. 또한 이제 중앙 그리드 기반 경로 탐색의 오픈 소스 구현체가 있어 여러분의 프로젝트에서 사용할 수 있습니다. GitHub의 Central64 C++ 라이브러리를 확인해보세요.\n\n# 참고 자료\n\n[1] R. Goldstein, K. Walmsley, J. Bibliowicz, A. Tessier, S. Breslav, A. Khan, Path Counting for Grid-Based Navigation (2022), 인공지능 연구 저널, vol. 74, pp. 917–955\n\n<div class=\"content-ad\"></div>\n\n[2] K. Daniel, A. Nash, S. Koenig, A. Felner, Theta*: Any-Angle Path Planning on Grids (2010), 인공 지능 연구 저널, 제39권, 553–579쪽\n\n[3] C. Cobeli, A. Zaharescu, Pascal의 삼각형을 따라 산책 — 숫자 동기 (2013) [PDF], 루마니아 수학 과학 협회 보고서, 제56권, 제104호, 73–98쪽\n\n[4] N. R. Sturtevant, 그리드 기반 경로 탐색을 위한 벤치마크 (2012) [PDF], 게임에서의 계산 지능과 AI에 관한 Transactions, 제4권, 제2호, 144–148쪽","ogImage":{"url":"/assets/img/2024-06-23-AShortandDirectWalkwithPascalsTriangle_0.png"},"coverImage":"/assets/img/2024-06-23-AShortandDirectWalkwithPascalsTriangle_0.png","tag":["Tech"],"readingTime":9},{"title":"애플의 부활부터 교황의 봇에 대한 생각까지 기술과 AI의 현재 트렌드 분석","description":"","date":"2024-06-23 18:26","slug":"2024-06-23-FromApplesRevivaltothePopesThoughtsonBots","content":"\n\n- 애플은 세계에서 가장 가치 있는 회사로 자리를 다시 차지했어요. 마이크로소프트와 엔비디아를 능가했답니다.\n- 이 테크 자이언트의 부활은 주로 ChatGPT를 다양한 제품에 통합한 데 기인합니다.\n- 이러한 움직임으로 애플의 생태계 전반에 걸쳐 사용자 경험을 혁신하고 생산성을 높이는 것으로 예상됩니다.\n\n## AI가 안드로이드에게 인간적인 느낌을 불어넣다\n\n- 중국에서 X Robots은 안드로이드의 현실적인 얼굴 표정을 보여주는 능력을 향상시킴으로써 안드로이드의 진보를 이끌고 있어요.\n- 이 로봇들은 주변 환경을 감지하고 인간다운 방식으로 반응하는 것이 설계되었어요.\n- 목표는 더 생동감 있고 반응성이 뛰어난 로봇을 만들어, 인간-로봇 상호작용을 혁신적으로 바꾸는 것입니다.\n\n## 교황의 AI에 대한 관점\n\n<div class=\"content-ad\"></div>\n\n- G7 정상 회의 도중 교황은 인공지능에 대한 우려를 표명했습니다.\n- 그는 기술에 대한 인간의 통제를 유지하는 중요성을 강조했습니다.\n- 교황은 기계가 인간의 선택을 지배하는 미래에 대해 경고하며, AI의 윤리적 거버넌스 필요성을 강조했습니다.\n\n## 일론 머스크의 법적 후퇴\n\n- 일론 머스크가 ChatGPT 창조자인 OpenAI에 대한 소송을 의외로 철회했습니다.\n- 머스크는 이전에 OpenAI를 인류의 이익을 위해 AI를 개발하는 미션에서 벗어나 이윤에 집중하고 있다고 비난했습니다.\n- 머스크의 철회 이유는 공개되지 않았으며, 추측의 여지를 남겨 두었습니다.\n\n## 고양이 건강 관리의 AI\n\n<div class=\"content-ad\"></div>\n\n- 일본에서는 \"Cats Me\"라는 AI 기반 앱이 애완동물 건강 관리 분야에서 큰 반향을 일으키고 있습니다.\n- 이 앱은 수천 개의 고양이 이미지를 분석하여 고양이의 통증을 감지할 수 있습니다.\n- \"Cats Me\"은 출시 이후 23만 명 이상의 사용자를 확보하여 인기와 효과적임을 반영하고 있습니다.\n\n## 결론\n\nAI 기술은 Apple과 같은 주요 기술 기업부터 일본의 애완동물 건강 관리 분야에 이르기까지 다양한 분야에서 큰 발전을 이루고 있습니다. 이러한 발전은 흥미로운 가능성을 제시하지만 중요한 윤리적 문제도 제기합니다. AI를 받아들이는 동안 기술이 인류의 이익을 위해 봉사할 수 있도록 하는 것이 중요하며, 교황의 경고적인 말이 강조한 바와 같습니다. 누가 알았겠습니까, AI가 심지어 우리의 고양이 친구들에게도 도움을 줄 수 있다는 것을? 이것은 미래를 위한 혁신과 조심이 완벽하게 균형 잡힌 조화입니다.","ogImage":{"url":"/assets/img/2024-06-23-FromApplesRevivaltothePopesThoughtsonBots_0.png"},"coverImage":"/assets/img/2024-06-23-FromApplesRevivaltothePopesThoughtsonBots_0.png","tag":["Tech"],"readingTime":2},{"title":"28살에 수학 배우기","description":"","date":"2024-06-23 18:25","slug":"2024-06-23-Learningmathat28","content":"\n\n3학년 수학부터 시작하면 되겠네요. 두려워하고 흥분되는 일에 도전하는 건 시기를 놓친 일이 아닙니다.\n\n안녕하세요!\n\n저는 두려움과 흥분 속에서 당신에게 글을 씁니다. 지난 10년 동안 제게 잠재웠던 두려움에 마주하고 있습니다.\n\n5월에 소프트웨어 회사의 기술 컨설팅 직을 그만 두고 인생을 돌아보는 시간을 가졌어요. 지금 28살이고 한 가지 삶의 목표를 완수한 것 같아요. 저는 항상 컨설턴트가 되길 원했고 기술적으로 말하자면 그렇게 된 적이 있어요. 저는 기술 컨설턴트로 일하며 병원이 전자 건강 기록 소프트웨어를 도입하는 데 도움을 주었습니다. 그런데 그것이 제가 생각했던 컨설턴트의 이미지와는 조금 달랐어요. 저는 경영 컨설턴트가 되길 원했었죠. 그래서 어떻게 된 걸까요?\n\n<div class=\"content-ad\"></div>\n\n## 지난 10년 동안의 경력 발전 소개.\n\n우리는 원점으로 돌아가야 해요. 대학교에 지원할 때, 경제학 전공을 희망했어요. 첫 경제학 수업을 듣고 학기를 끝내면 성적표에 큰 C가 있어 놀랐어요. 장학생으로서 저는 공포에 사로잡혔고 급히 더 편안한 심리학 전공으로 전과 했죠. 그 후 10년간의 경력 동안 수학을 피해왔어요. 졸업 이후부터 7개의 직장을 경험했는데, 언제나 내 전문 기술을 최대한 발휘하지 못하는 느낌이 들었어요. 승진을 시도하거나 부서 이동을 하려 할 때마다 수학과 데이터 분석 능력을 요구해서 현재의 역할에 갇히게 되었죠.\n\n삶의 궤적을 바꾸려던 다른 시도로 2년 전 MBA 프로그램에 지원했어요. 수학 실력이 좋지 않은 저에게도 놀랍게도 두 프로그램에 합격했어요. 저는 UNC Keanan-Flagler의 온라인 MBA와 University of Miami의 이중 학위 MBA 및 지속가능성 석사과정에 합격했어요. 아무도 놀랄 일이 아니겠지만 부분 장학금만 받았고 프로그램 시작 전에 수학 수업을 들어야 하는 보충 수학 트랙에 배정되었어요. 하지만 수업료를 감당할 수 없어서 거절하고 평범한 경력을 이어나가게 되었어요.\n\n지난 10년을 돌아보면, 다양한 산업과 직업에 흥미를 가졌지만 그 어느 것도 할 수 없었던 이유를 생각해봐요. 대학 시절에는 경영 컨설턴트가 되길 희망했고 졸업 한 해 뒤에는 소프트웨어 엔지니어가 되고 나중에는 데이터 과학자가 되길 원했어요. 졸업 6년 후에는 항공우주 공학을 시도하고 생명공학과 로보틱스를 거쳐했어요. 추세를 보이죠? 모든 분야에서 좋은 수학 실력이 도움이 되는 것 같아요.\n\n<div class=\"content-ad\"></div>\n\n그럼 이제 어떻게 하면 좋을까요?\n\n## 계획을 실행에 옮겨봅시다.\n\n저는 28살이고 일자리가 없어요. 앞으로 1년 9개월 정도는 시간이 있어요. 제 계획은 수학을 배우는 것이에요. 저는 3학년부터 시작해서 수학을 배우고 있어요. 네, 맞아요. 28살인 저는 3학년 수학 문제집과 칸 아카데미로 수학을 공부하고 있어요. 목표는 대학 수준의 미적분학을 배울 때까지 이어가는 것이고, 그 후에 잠시 중단하고 반성할 거에요.\n\n왜 3학년 수학부터 시작하느냐구요? 저는 쿠바에서 미국으로 이사와서 5학년 때 ESOL 수업을 받았어요. 그 당시에 배운 내용은 기억도 안나요. 해야 할 일이 참 많아졌네요.\n\n<div class=\"content-ad\"></div>\n\n로봇 공학과 전자에 대한 관심이 여전히 많아요. 우주 과학과 여성 건강을 위한 웨어러블 기기 내의 전자기기에 관심이 많아합니다. 수학에 자신감을 갖게 되면, 이러한 분야를 깊게 탐구할 수 있을 것 같아요.\n\n## 내 독자들에 대한 희망 ♥︎\n\n내 이야기를 따라가고 관심 있는 분들께, 당신들이 두렵고 흥분되는 일에 대처하는 데 영감을 받길 바래요. 두려워하는 건 너무 늦은 일이 아니에요. 오랫동안 하고 싶었지만, 두려움 때문에 기회를 놓친다고 믿거나, 더 이상 필요하지 않다고 생각하거나, 더 나쁜 경우에는 더 이상 관심이 없다고 생각한 일에 대해 생각해보세요. 그런 다음, 시작해야 할 단계가 무엇이든 두려움을 극복할 수 있는 행동 계획을 세워보세요.\n\n행복한 하루 보내세요 🌙,\n\n<div class=\"content-ad\"></div>\n\ndataprincess\n\n![Learning Math at 28](/assets/img/2024-06-23-Learningmathat28_0.png)","ogImage":{"url":"/assets/img/2024-06-23-Learningmathat28_0.png"},"coverImage":"/assets/img/2024-06-23-Learningmathat28_0.png","tag":["Tech"],"readingTime":3},{"title":"맥도날드 자동화 매장 미래 패스트푸드의 핵심인가","description":"","date":"2024-06-23 18:24","slug":"2024-06-23-AreyoulovinitYoubetterMcDonaldsautomatedrestaurantisthefutureoffastfood","content":"\n\n<img src=\"/assets/img/2024-06-23-AreyoulovinitYoubetterMcDonaldsautomatedrestaurantisthefutureoffastfood_0.png\">\n\n맥도날드가 텍사스주 포트워스에 오픈한 새 햄버거 가게는 바깥에서 볼 때는 다른 가게와 별반 다르게 보입니다. 하지만 한 가지 근본적인 차이가 있습니다: 거기에는 손님을 맞는 사람이 없습니다. 거기서 일하는 유일한 사람은 주방에 숨어 있는 작은 요리사팀뿐입니다.\n\n차를 주차한 후에 손님들은 들어가서 오랜 시간 동안 익숙해질 대형 터치 스크린 중 하나에 주문을 하고, 주문은 컨베이어 벨트에 도착하는 계산대에서 수령합니다. 현재는 테이크아웃만 가능하며, 의자나 테이블이 없습니다. 드라이브스루 주문 및 수령도 가능하며, 앱을 이용하여 사전 주문하고 도착 시간을 약속하는 것도 가능합니다. 그리고 Order Ahead 차선을 통해 주행하다가 차 한 대만 멈추는 규칙이 있습니다. 차를 정지시키고 창문을 내리고 팔을 조금 내밀면 끝이죠. 다음으로 넘어갑니다.\n\n이 기술을 사용한 회사에서 시험해본 첫 번째, 그리고 지금까지 유일한 레스토랑입니다. 이 기술이 빠르게 확산되어 곧 급식 패스트푸드 레스토랑 산업을 혁신할 것이라고 믿는 사람도 있습니다. 비판가들은 자동화로 인해 더 많은 일자리가 사라진다는 점, 주문이 잘못되었을 때나 누락된 물건이 있을 때, 또는 손님이 좀 더 케첩 봉지나 여분의 냅킨을 원할 때 어떤 일이 벌어질 지에 대해 언급합니다.\n\n<div class=\"content-ad\"></div>\n\n기계로 사람을 대체하는 안정적인 교체는 돈을 절약하는 것과 관련이 있습니다. 이 경우, 텍사스의 시간당 7.25달러의 최저임금이나 다른 곳에서는 최대 15달러까지 절약 가능합니다. 이제는 코로나 이후 시나리오이며, 사람들이 점포에 발을 딛지 않고 음식을 배달 받거나 픽업하려고 하는 경향이 점점 늘어나고 있습니다. 더불어 높은 인플레이션, 낮은 임금으로 인해 낮은 임금의 기계적인 업무를 하려는 사람들이 줄어들고 있으며 임금 상승 압력도 있습니다…\n\n먼저 화면을 통해 주문하다가 이제는 스마트폰 앱을 통해 주문하는 것이 되었습니다. 이제 계산대 직원을 제거하여 자동화 과정을 진행했고, 다음 단계는 분명히 주방을 완전히 자동화하는 것이 될 것입니다. 이미 매우 효율적인 생산라인인 주방은 사람들이 청소와 유지보수 업무를 밖에서 수행하도록 하여 남깁니다. 자율주행식 음식점, 수시로 공급품을 전달하는 단 한 명의 직원.\n\n모든 것이 매우 디스토피아적으로 들리지만, 누가 음식을 제공하는 것이 반드시 사람에게 제한되어야 한다고 말했을까요? 사람이 그 작업에 어떤 가치를 더하는 걸까요? 주목을 받고 싶다면, 즐거운 곳에서 조용히 앉아 있거나 인사를 받거나 무엇을 먹고 있는지 설명을 들으려 한다면 맥도날드에 가지 마세요. 지금은 다른 사람들이 아직은 예전 방식대로 일을 하는 곳이 있을 겁니다. 하지만 햄버거를 찾는 많은 사람들에게는 화면과 컨베이어 벨트만으로도 충분할 것 같네요.","ogImage":{"url":"/assets/img/2024-06-23-AreyoulovinitYoubetterMcDonaldsautomatedrestaurantisthefutureoffastfood_0.png"},"coverImage":"/assets/img/2024-06-23-AreyoulovinitYoubetterMcDonaldsautomatedrestaurantisthefutureoffastfood_0.png","tag":["Tech"],"readingTime":2},{"title":"파이썬으로 간단한 ROS2 장애물 회피 로봇 만들기 방법","description":"","date":"2024-06-23 18:23","slug":"2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython","content":"\n\n<img src=\"/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png\" />\n\n이 튜토리얼에서는 ROS2 (로봇 운영 시스템 2) 및 Python을 사용하여 간단한 물체 회피 로봇을 구축할 것입니다. 이 로봇은 장애물을 감지하기 위해 LIDAR 센서를 사용하고, 이동을 조정하여 주변을 피해 이동합니다. 이 프로젝트는 ROS2를 시작하는 좋은 방법이며, 센서를 사용하고 로봇의 이동을 제어하는 방법을 배우는 데 도움이 될 것입니다.\n\n# 준비물\n\n시작하기 전에 다음을 갖추고 있는지 확인하세요:\n\n<div class=\"content-ad\"></div>\n\n- ROS2 설치 (Foxy, Galactic 또는 그 이후 버전).\n- Python 프로그래밍에 대한 기본 지식.\n- ROS2를 사용하여 제어되는 LIDAR 센서가 장착된 시뮬레이션된 또는 실제 로봇.\n\n# 프로젝트 개요\n\n우리 프로젝트의 주요 구성 요소는 다음과 같습니다:\n\n- LIDAR 센서: 로봇 주변의 장애물을 감지하는 데 사용됩니다.\n- LaserScan 메시지: LIDAR에서의 거리 데이터를 포함하는 ROS 메시지 유형.\n- Twist 메시지: 로봇의 선형 및 각속도를 제어하는 ROS 메시지 유형.\n- 노드: LIDAR 데이터를 구독하고 속도 명령을 게시하는 ROS2 노드.\n\n<div class=\"content-ad\"></div>\n\n# 코드 설명\n\n아래는 우리의 객체 회피 노드에 대한 완전한 코드입니다:\n\n```python\n#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom geometry_msgs.msg import Twist\n\nclass ObjectAvoidanceNode(Node):\n    def __init__(self):\n        super().__init__('object_avoidance_node')\n        self.subscription = self.create_subscription(\n            LaserScan,\n            'scan',\n            self.lidar_callback,\n            10)\n        self.publisher = self.create_publisher(Twist, 'cmd_vel', 10)\n        self.safe_distance = 0.5  # 미터\n        self.get_logger().info('Object Avoidance Node Started')\n\n    def lidar_callback(self, msg):\n        ranges = msg.ranges\n        min_distance = min(ranges)\n        \n        twist_msg = Twist()\n\n        if min_distance < self.safe_distance:\n            # 장애물 감지, 로봇을 회전시킵니다\n            twist_msg.linear.x = 0.0\n            twist_msg.angular.z = 0.5  # 시계 반대방향으로 회전\n        else:\n            # 장애물 감지되지 않음, 전진합니다\n            twist_msg.linear.x = 0.2\n            twist_msg.angular.z = 0.0\n\n        self.publisher.publish(twist_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ObjectAvoidanceNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Keyboard Interrupt (SIGINT)')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n```\n\n# 코드 설명\n\n<div class=\"content-ad\"></div>\n\n- Imports: 필요한 모듈을 rclpy, sensor_msgs.msg 및 geometry_msgs.msg에서 가져옵니다.\n- 노드 초기화: Node를 상속하는 ObjectAvoidanceNode 클래스를 정의합니다. 생성자에서는 LaserScan 메시지를 수신할 /scan 토픽에 대한 구독 및 Twist 메시지를 보낼 /cmd_vel 토픽에 대한 게시자를 설정합니다.\n- LIDAR 콜백: lidar_callback 메서드는 수신된 LaserScan 메시지를 처리합니다. LIDAR가 감지한 장애물까지의 최소 거리를 찾습니다. 이 거리가 self.safe_distance(0.5 미터)보다 작으면 로봇은 전진을 멈추고 장애물을 피하기 위해 회전을 시작합니다. 안전 거리 내에 장애물이 없으면 로봇은 전진합니다.\n- 명령 게시: 감지된 거리에 따라 Twist 메시지에 적절한 선형 및 각속도를 할당하고 /cmd_vel 토픽으로 게시합니다.\n- 메인 함수: 메인 함수는 ROS2 Python 클라이언트 라이브러리를 초기화하고 ObjectAvoidanceNode의 인스턴스를 생성한 다음 (콜백을 처리하며) 스핀을 시작합니다. 노드가 (예: Ctrl+C를 눌러) 중단되면 깔끔하게 종료됩니다.\n\n# 노드 실행\n\nROS2 환경이 정상적으로 소스로드되고 필요한 토픽 (/scan 및 /cmd_vel)이 사용 가능한지 확인하세요.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*XNR1_8EGSFbgsAnJUJ05FQ.gif\" />\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 튜토리얼은 ROS2와 Python을 사용하여 객체 회피 로봇의 기본 프레임워크를 제공합니다. 이 코드를 확장하여 장애물 맵핑, 경로 계획 및 다른 센서 통합과 같은 고급 기능을 구현할 수 있습니다. ROS2의 모듈식 아키텍처와 방대한 커뮤니티 지원으로 로봇 개발에 우수한 선택지입니다. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png"},"coverImage":"/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png","tag":["Tech"],"readingTime":4},{"title":"Docker와 QEMU 엣지 컴퓨팅 개발 가속화 및 코드 컴파일 최적화를 위한 강력한 조합","description":"","date":"2024-06-23 18:22","slug":"2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation","content":"\n\n![Docker & QEMU: 강력한 조합](/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png)\n\nQEMU는 호스트 시스템에서 가상 머신을 실행할 수 있는 타입-2 하이퍼바이저입니다. x86 및 ARM을 포함한 다양한 아키텍처를 에뮬레이트할 수 있습니다. qemu-system-aarch64 패키지는 AArch64 (ARM64) 시스템 에뮬레이터를 제공하며 CPU 및 다양한 주변장치를 에뮬레이트할 수 있습니다.\n\nRaspberry Pi용 코드를 컴파일하거나 테스트할 때, QEMU를 사용하여 x86 머신에서 AArch64 시스템을 모의 실행할 수 있습니다. 이는 개발자가 실제 Raspberry Pi를 가지고 있지 않아도 해당 코드를 컴파일하고 테스트할 수 있다는 것을 의미합니다. 이는 Jetson, Beaglebone 등 다른 엣지 디바이스에도 적용됩니다.\n\nRaspberry Pi용 코드를 컴파일하기 위해 QEMU를 사용하는 프로세스에는 qemu-system-aarch64 패키지를 사용하여 가상 머신을 설정한 다음 가상 머신에 필요한 도구 및 종속성을 설치하는 과정이 포함됩니다. ARM 아키텍처용 코드를 컴파일하는 데 필요한 GCC 컴파일러 및 기타 도구가 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n라즈베리 파이용 코드를 컴파일하기 위해 QEMU를 사용하는 장점 중 하나는 일반적으로 라즈베리 파이보다 강력한 x86 머신에서 코드를 테스트하고 디버깅할 수 있다는 것입니다.\n\n![이미지](/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_1.png)\n\n도커 이미지 내에서 QEMU를 사용하면 라즈베리 파이용 코드를 컴파일하고 테스트하는 방법이 더욱 효율적이고 효율적해질 수 있습니다.\n\n도커 이미지는 가벼우며 휴대 가능하며 독립적인 컨테이너로, 어떤 머신에서도 쉽게 배포하고 실행할 수 있습니다. 라즈베리 파이용 코드를 컴파일하기 위한 필수 도구 및 종속성을 포함한 QEMU와 함께 도커 이미지를 생성하면 Docker가 설치된 모든 머신에서 이미지를 쉽게 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, PyTorch의 C++ 인터페이스 인 libtorch와 같은 대규모 라이브러리를 컴파일하는 것은 Raspberry Pi나 다른 엣지 장치에서 자원이 제한되기 때문에 상당한 시간이 소요될 수 있습니다. QEMU를 사용하여 Docker 이미지 내에서 AArch64 시스템을 x86 머신에서 에뮬레이션함으로써, 개발자는 x86 머신에서 사용 가능한 빠른 처리 속도와 코어 수를 활용하여 컴파일 시간을 크게 줄일 수 있습니다.\n\n예를 들어, 고속 CPU를 탑재한 10코어 x86 머신에서 Raspberry Pi에서 보통 4~5시간 소요되는 libtorch의 컴파일 시간이 30분으로 단축될 수 있습니다. 이는 개발자들에게 상당한 시간을 절약해줄 수 있습니다.\n\n이제 Raspberry Pi 4를 위한 libtorch 라이브러리 빌드 프로세스 예제를 살펴보겠습니다.\n\n호스트 머신 설정:\nDocker 설치\n\n<div class=\"content-ad\"></div>\n\n```js\n# QEMU 및 크로스 플랫폼 패키지 설치\nsudo apt-get install -y gcc-arm-linux-gnueabihf libc6-dev-armhf-cross qemu-user-static qemu-system-i386\n```\n\n```js\nFROM arm64v8/ubuntu:focal\n# 참고:\n# /usr/bin/qemu-system-aarch64를 로컬 bin 폴더로 복사\nCOPY ./bin/qemu-system-aarch64 /usr/bin/qemu-system-aarch64\n\nARG DEBIAN_FRONTEND=noninteractive\n\n# 기본적인 apt 업데이트\nRUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends locales ca-certificates \n \n# 로캘을 en_US.UTF-8로 설정(로캘이 없으면 Yocto 빌드 실패함)\nRUN locale-gen en_US.UTF-8 && update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nENV LANG en_US.UTF-8\nENV LC_ALL en_US.UTF-8\n\n# 기본 패키지 설치\nRUN apt-get update && apt-get install -y \\\n    apparmor \\\n    aufs-tools \\\n    automake \\\n    bash-completion \\\n    build-essential \\\n    cmake \\\n    curl \\\n    dpkg-sig \\\n    g++ \\\n    gcc \\\n    git \\\n    iptables \\\n    jq \\\n    libapparmor-dev \\\n    libc6-dev \\\n    libcap-dev \\\n    libsystemd-dev \\\n    libyaml-dev \\\n    mercurial \\\n    net-tools \\\n    parallel \\\n    pkg-config \\\n    golang-go \\\n    iproute2 \\\n    iputils-ping \\\n    vim-common \\\n    vim \\\n    --no-install-recommends \\\n    && apt-get clean \\\n    && rm -rf /var/lib/apt/lists/*\n\nRUN apt-get update && apt install -y software-properties-common && add-apt-repository main && add-apt-repository universe && add-apt-repository restricted && add-apt-repository multiverse\n\n# libtorch 의존성 설치\nRUN apt-get install -y clang ninja-build git cmake libjpeg-dev libopenmpi-dev libomp-dev ccache \\\n    libopenblas-dev libblas-dev libeigen3-dev \nRUN apt-get install -y python3-pip\nRUN pip3 install -U --user wheel mock pillow\nRUN pip3 install setuptools==58.3.0\n\n# 소스 코드 다운로드\nRUN mkdir ~/torch/ && cd ~/torch/ && \\\n    git clone -b v1.13.0 --depth=1 --recursive https://github.com/pytorch/pytorch.git && \\\n    cd pytorch && pip3 install -r requirements.txt\n\n# 컴파일 환경 변수 설정\nENV BUILD_CAFFE2_OPS=OFF\nENV USE_FBGEMM=OFF\nENV USE_FAKELOWP=OFF\nENV BUILD_TEST=OFF\nENV USE_MKLDNN=OFF\nENV USE_NNPACK=ON\nENV USE_XNNPACK=ON\nENV USE_QNNPACK=ON\nENV MAX_JOBS=12\nENV USE_NUMPY=ON\nENV USE_OPENCV=OFF\nENV USE_NCCL=OFF\nENV BUILD_SHARED_LIBS=ON\nENV PATH=/usr/lib/ccache:$PATH\nENV CC=clang\n\n# C++ torch 인터페이스 라이브러리(.so) 파일 빌드\nRUN cd ~/torch/pytorch/ && python3 tools/build_libtorch.py\n```\n\n```js\n# Docker 이미지 빌드\nsudo docker build --rm --tag arm64v8_libtorch -f arm64v8.Dockerfile .\n\n# 터미널 1\n# 컴파일된 패키지 실행 및 복사\nmkdir libtorch\nsudo docker run -v /etc/localtime:/etc/localtime:ro --rm -it -e http_proxy -e https_proxy -e ftp_proxy -v `pwd`:/work arm64v8_libtorch\n\n# 터미널 2\n# 실행 중인 컨테이너 ID 가져오기\nsudo docker ps\n\n# 터미널 3\n# 컨테이너에서 호스트 머신으로 파일 복사\nsudo docker cp 389143f92f85:~/torch/pytorch/torch/bin/ libtorch/\nsudo docker cp 389143f92f85:~/torch/pytorch/torch/lib/ libtorch/\nsudo docker cp 389143f92f85:~/torch/pytorch/torch/include/ libtorch/\nsudo docker cp 389143f92f85:~/torch/pytorch/torch/share/ libtorch/\n\n# 권한 설정\nsudo chmod -R 755 libtorch/* \n\n# 소유자 변경(scp용)\nsudo chown -R username:username libtorch\n\n# 이제 libtorch 폴더를 RPI로 복사할 수 있습니다\nscp -r libtorch/ ubuntu@static_ip_address:/home/ubuntu/\n``` \n\nDocker 이미지인 \"arm64v8_libtorch\"를 \"arm64v8.Dockerfile\" 파일을 사용하여 빌드합니다. \"--rm\" 플래그는 컨테이너가 종료될 때 자동으로 제거되도록 사용됩니다.\n\n터미널 1:\n\"arm64v8_libtorch\"이라는 빌드된 Docker 이미지를 실행하고 현재 디렉토리를 컨테이너 내의 볼륨으로 마운트합니다.\n\n터미널 2:\n실행 중인 컨테이너의 ID를 가져옵니다.\n\n터미널 3:\n1. 컨테이너에서 호스트 머신으로 파일을 복사합니다.\n2. \"libtorch\" 폴더 내의 모든 파일의 권한을 755로 변경합니다.\n3. \"libtorch\" 폴더 내의 모든 파일의 소유권을 현재 사용자 이름으로 변경합니다.\n\n터미널 4:\n\"libtorch\" 폴더를 scp를 통해 원격 머신[RPI4]으로 복사합니다.\n\n\n<div class=\"content-ad\"></div>\n\nROS2를 X86 호스트 시스템에서 RPI용으로 빌드하는 또 다른 예제를 확인해보세요.\n\n```js\nFROM arm64v8/ubuntu:focal\nCOPY ./bin/qemu-system-aarch64 /usr/bin/qemu-system-aarch64\n\nARG DEBIAN_FRONTEND=noninteractive\n\n# 기본적인 apt 업데이트\nRUN apt-get update && DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends locales ca-certificates \n \n# Yocto 빌드에 로캘이 설정되어 있지 않으면 빌드에 실패할 수 있으므로 로캘이 en_US.UTF-8로 설정됩니다.\nRUN locale-gen en_US.UTF-8 && update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nENV LANG en_US.UTF-8\nENV LC_ALL en_US.UTF-8\n\n# 기본 패키지 가져오기\nRUN apt-get update && apt-get install -y \\\n    apparmor \\\n    aufs-tools \\\n    automake \\\n    bash-completion \\\n    build-essential \\\n    cmake \\\n    curl \\\n    dpkg-sig \\\n    g++ \\\n    gcc \\\n    git \\\n    iptables \\\n    jq \\\n    libapparmor-dev \\\n    libc6-dev \\\n    libcap-dev \\\n    libsystemd-dev \\\n    libyaml-dev \\\n    mercurial \\\n    net-tools \\\n    parallel \\\n    pkg-config \\\n    golang-go \\\n    iproute2 \\\n    iputils-ping \\\n    vim-common \\\n    vim \\\n    --no-install-recommends \\\n    && apt-get clean \\\n    && rm -rf /var/lib/apt/lists/*\n\n...\n\n# 전체 흐름을 간략하게 말하자면, Docker와 QEMU는 엣지 컴퓨팅 개발을 가속화하고 코드 컴파일을 최적화하는 강력한 조합입니다. 이 설정을 통해 개발자들은 x86 기계의 빠른 처리 능력과 리소스를 활용하면서도 라즈베리파이나 젯슨과 같은 ARM 기반 에뮬레이터에서 코드를 테스트하고 디버깅할 수 있습니다. 이 접근 방식은 컴파일 시간을 크게 단축하고 개발 주기를 가속화할 수 있습니다.\n```\n\n<div class=\"content-ad\"></div>\n\n제가 몇 가지 도커 예제를 여기에 만들어 놨어요. 참고용으로 활용하시면 좋을 것 같아요! 설정 프로세스에 대해 궁금한 점이 있거나 추가 도움이 필요하면 언제든지 알려주세요.\n\n흥미로운 기사나 업데이트는 항상 LinkedIn에 공유하고 있어요. 최신 소식을 받아보고 싶으시면 편하게 저를 팔로우해주세요!","ogImage":{"url":"/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png"},"coverImage":"/assets/img/2024-06-23-DockerandQEMUAPowerfulCombinationforAcceleratingEdgeComputingDevelopmentandOptimizingCodeCompilation_0.png","tag":["Tech"],"readingTime":7},{"title":"Ubuntu에서 웹사이트 구축하는 방법","description":"","date":"2024-06-23 18:21","slug":"2024-06-23-BuildingyourownwebsiteinUbuntu","content":"\n\n요즘 오렌지 파이를 샀는데 취미로 웹 서버를 만들어보기로 결정했어요. 만약 당신의 ISP가 공인 IP를 허용한다면, 온라인으로 접속할 수도 있을 거에요.\n\n# 프레임워크\n\n첫 번째로 해야 할 일은 서버를 실행할 웹 프레임워크를 설정하는 것이에요. 이 경우 빠른 테스트를 위해 파이썬을 사용하여 플라스크를 선택했어요. 다른 프레임워크인 장고, 노드.js나 다른 것을 이미 알고 계시다면 그것을 사용해도 돼요.\n\n저는 루트 디렉토리에 폴더를 만들어 시작하는 것부터 시작해요.\n\n<div class=\"content-ad\"></div>\n\n```shell\ncd /\nsudo mkdir sww\ncd /sww\nmkdir scripts\ncd /sww/scripts\nmkdir webserver\ncd /sww/scripts/webserver\n```\n\n다음으로 아래를 실행하여 파이썬 가상 환경을 만들 수 있어요\n\n```shell\npython3 -m venv .venv\n```\n\n다음으로 원하는 IDE(통합 개발 환경)나 텍스트 편집기를 사용할 수 있어요. 저는 Visual Studio Code를 사용해서 폴더를 여는 게 좋아요.\n\n<div class=\"content-ad\"></div>\n\n```js\ncode .\n```\n\n방금 만든 Python 가상 환경을 사용하도록 vscode를 설정할 거에요. ctrl+shift+p를 눌러 Python: Select Interpreter를 선택하면 이렇게 선택 목록이 열릴 거예요.\n\n![image](/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_0.png)\n\n현재 폴더에 있는 가상 환경을 선택한 후 터미널을 열면 (ctrl+shift+`) 이 접두사가 나와야 해요 (.venv)\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 표현된 코드입니다.\n\n\n<img src=\"/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_1.png\" />\n\n다음은 터미널에서 이 코드를 실행하여 flask를 설치하는 방법입니다.\n\n```python\npython -m pip install flask\n```\n\n이 가이드를 따라하여 hello.py 파일을 생성합니다. 파일 내용은 아래와 같습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello_world():\n    return \"<p>Hello, World!</p>\"\n```\n\n그런 다음 이 명령어를 실행하여 플라스크를 시작하십시오.\n\n```bash\nflask run --app hello\n```\n\n웹 브라우저에서 localhost:5000을 열어주세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_2.png\" />\n\n대박! 잘 됐어요! 안녕, 세계여!\n\n# Nginx\n\n다음으로는 Nginx를 설정하여 역방향 프록시를 처리할 거에요\n\n<div class=\"content-ad\"></div>\n\n첫 번째 단계는 Nginx를 설치하는 것입니다.\n\n```js\nsudo apt update\nsudo apt install nginx\nsudo nginx -V\n```\n\n또한 웹 브라우저에서 localhost 또는 로컬 IP를 열어서 작동 여부를 확인할 수도 있습니다.\n\n![이미지](/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_3.png)\n\n<div class=\"content-ad\"></div>\n\n반드시 보안을 위해 방화벽을 설치하는 것을 잊지 마세요.\n\n```js\nsudo apt install ufw\nsudo ufw enable\nsudo ufw allow from <router_ip> to any port 80\nsudo ufw allow from <router_ip> to any port 443\n```\n\n라우터 IP를 입력해야 보안을 높일 수 있지만, 확실하지 않다면 'any'로 설정할 수 있어요. 어쨌든 나중에 액세스하려면 라우터 IP가 필요하답니다.\n\n다음으로, 서버를 온라인에서 액세스할 수 있도록 포트를 열어야 해요. 라우터 IP 주소로 이동해서 로컬 머신 IP 주소를 찾으세요. 저의 경우에는 192.168.20.4예요.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_4.png\" />\n\n그런 다음 라우터가 가지고 있는 포트 포워딩 또는 NAT(라우터에 따라 다를 수 있음) 중 하나로 이동합니다.\n\n<img src=\"/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_5.png\" />\n\n서비스 이름, 로컬 머신 IP 주소 및 포트를 입력한 후 저장을 누릅니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![Screenshot](/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_6.png)\n\nOnce done, it should look like this. Please note that the display may vary depending on the router and brand.\n\n# Test\n\nAfter setting up nginx and opening the port, you can test accessing your machine online by searching for your public IP on Google as shown below:\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_7.png)\n\n만약 작동하면 nginx 환영 페이지를 가리켜야합니다.\n\n# Nginx 사이트\n\nNginx가 작동하면 사이트를 설정할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n```js\ncd /etc/nginx/sites-enabled\nsudo touch webserver\nsudo gedit webserver\n```\n\n위 명령을 입력하면 gedit 텍스트 편집기에서 webserver 파일이 열릴 겁니다. 아래 코드를 입력하고 저장하세요.\n\n```js\nserver {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n    server_name _;\n\n    root /sww/scripts/webserver;\n\n    location / {\n        proxy_pass http://localhost:5000/;\n        proxy_buffering off;\n        proxy_http_version 1.1;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection $http_connection;\n    }\n}\n```\n\n그런 다음 Nginx 서버를 재시작하고 브라우저를 새로고침하세요.\n\n\n<div class=\"content-ad\"></div>\n\n\nsudo systemctl restart nginx.service\n\n\n![Building your own website in Ubuntu](/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_8.png)\n\n지금은 플라스크 웹 서버를 가리키도록 설정되어 있습니다. 그러면 계속 작업을 계속할 수 있어요 :)\n\n다음 단계는 기억에 남을 주소로 이를 도메인에 연결하는 것인데, 이에 대해 다른 문서에서 다룰 것입니다. 그때까지 안녕히 계세요! 👋\n","ogImage":{"url":"/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_0.png"},"coverImage":"/assets/img/2024-06-23-BuildingyourownwebsiteinUbuntu_0.png","tag":["Tech"],"readingTime":5},{"title":"Raspberry Pi 5 온도 측정 가이드","description":"","date":"2024-06-23 18:20","slug":"2024-06-23-GuidetoMeasureRaspberryPi5Temperature","content":"\n\n라즈베리 파이 5의 온도를 이해하는 것은 중요합니다, 특히 고부하 작업 중일 때에는 더욱 중요합니다. 라즈베리 파이 5의 온도를 측정하는 데 도움이 되는 단계별 안내서가 여기 있습니다:\n\n# 소개:\n\n- 라즈베리 파이 5는 일반적으로 자주 사용하는 조건 하에서 이전 모델인 라즈베리 파이 4보다 더 적게 발열합니다. 그러나 지속적인 고부하 과업 시에는 열 쓰로틀링이 발생할 수 있습니다.\n- 열 쓰로틀링은 소프트웨어가 일정한 온도 이상일 때 CPU 속도를 제한하는 기능입니다. 쓰로틀링 상태에서도 라즈베리 파이 5는 라즈베리 파이 4보다 우수한 성능을 발휘합니다.\n\n# CPU 온도 측정 방법:\n\n<div class=\"content-ad\"></div>\n\nvcgencmd 명령어 사용하기:\n\n- vcgencmd 명령어를 사용하면 Raspberry Pi의 성능에 관한 소중한 정보를 얻을 수 있습니다.\n- Python 바인딩을 사용하면 온도를 포함한 다양한 매개변수를 프로그래밍 방식으로 모니터링할 수 있습니다.\n\nPython 스크립트:\n\n- 제공된 코드를 사용하여 온도, CPU 클록 속도 및 현재 쓰로틀링 상태를 모니터링하고 기록하는 Python 스크립트를 작성합니다.\n- 이 스크립트는 readings.txt라는 파일에 측정값을 저장합니다.\n\n<div class=\"content-ad\"></div>\n\n```python\nimport sys\nimport os\nimport time\nfrom vcgencmd import Vcgencmd\n\ndef main():\n    start_time = time.time()\n    fb = open(\"/home/pi/readings.txt\",\"a+\")\n    fb.write(\"경과 시간 (초),온도 (°C),클럭 속도 (MHz),쓰로틀\\n\")\n    vcgm = Vcgencmd()\n    while True:\n        temp = vcgm.measure_temp()\n        clock = int(vcgm.measure_clock('arm')/1000000)\n        throttled = vcgm.get_throttled()['breakdown']['2']\n\n        string = '%.0f,%s,%s,%s\\n' % ((time.time() - start_time),temp,clock,throttled)\n        print(string, end='')\n        fb.write(string)\n        time.sleep(1)\n\nif __name__ == '__main__':\n    main()\n```\n\n스트레스 테스팅:\n\n- 터미널 창을 열고 스크립트를 실행합니다.\n- 다른 터미널 창에서 stress 도구를 사용하여 모든 CPU 코어에 대한 스트레스 테스트를 시작합니다:\n\n```bash\n$ sudo apt install stress\n$ stress --cpu 4\n```  \n\n<div class=\"content-ad\"></div>\n\n이것은 무거운 작업을 가하며 CPU 온도가 증가합니다.\n\n쓰로틀링 제한:\n\n- 라즈베리 파이 보드는 프로세서를 80°C에서 쓰로틀링합니다.\n- 85°C에서 추가 쓰로틀링이 발생하여 손상을 방지합니다.\n\n냉각 없는 경우 관측:\n\n<div class=\"content-ad\"></div>\n\n- 냉각 없이 Raspberry Pi 5의 유휴 온도는 약 65°C 정도입니다.\n- 스트레스 테스트와 같은 강도 높은 활동 중에는 온도가 상승하여 85°C 열 한계를 약간 넘어서 안정화되기도 합니다. 이는 지속적인 열 추소를 유발할 수 있습니다.\n\n# 결론:\n\n동영상 시청 또는 데스크톱 작업과 같은 일반적인 활동은 CPU에 크게 부담을주지 않을 수 있지만, 냉각 없이 중대하고 지속적인 부하를 가할 경우 Raspberry Pi 5를 열 한계에 끌어올릴 수 있습니다. 온도를 모니터링하면 냉각 솔루션을 추가할 필요가 있는지에 대한 판단을 내릴 수 있습니다.\n\n본문의 저자는 Amazon Services LLC Associates Program의 참여자로, 이는 광고 수익을 제공하기 위해 디자인된 제품을 Amazon.com에 광고하고 링크하는 제휴 광고 프로그램입니다. 이 말은 우리의 링크를 통해 제품을 구매할 때마다 추가 비용없이 소액의 커미션을 벌 수 있다는 뜻입니다.","ogImage":{"url":"/assets/img/2024-06-23-GuidetoMeasureRaspberryPi5Temperature_0.png"},"coverImage":"/assets/img/2024-06-23-GuidetoMeasureRaspberryPi5Temperature_0.png","tag":["Tech"],"readingTime":3},{"title":"Raspberry Pi 5와 Coral TPU로 컴퓨터 비전 가속화 Part 1","description":"","date":"2024-06-23 18:18","slug":"2024-06-23-AcceleratingCVwithaRaspberryPi5andCoralTPUPart1","content":"\n\nRaspberry Pi 5은 PCIe 인터페이스를 갖추고 있어 주변 장치에 고속 하드웨어 연결이 가능합니다. 이는 이제 Google의 Coral TPU를 Pi에 연결하고 초고속 컴퓨터 비전을 얻는 것이 가능하다는 것을 의미합니다. 이 튜토리얼에서는 TPU를 구성하고 TPU에 MobileNet을 배포하여 224x224 크기의 이미지에 대한 추론 속도를 2.5밀리초(!)로 얻는 과정을 안내해 드리겠습니다.\n\n우리는 pineboard의 Hat AI 보드를 사용하여 TPU를 Pi에 PCIe로 연결했습니다:\n\n![이미지](/assets/img/2024-06-23-AcceleratingCVwithaRaspberryPi5andCoralTPUPart1_0.png)\n\n이 첫 번째 튜토리얼에서는 Pi가 Coral TPU를 인식할 수 있도록 커널을 구성하는 과정을 안내해 드리겠습니다. 이 내용은 Jeff Geerling의 작업을 요약한 것이며 저 자신이 작동시키기 위해 몇 가지 조정이 필요했습니다. 그의 작업이 없었더라면 저는 결코 이것을 이해하지 못했을 것입니다!\n\n<div class=\"content-ad\"></div>\n\n코랄 TPU는 호스트 OS가 4K 페이지 크기여야한다고 요구합니다. 나는 그 이유가 코랄이 직접 메모리 액세스(DMA)를 수행할 수 있어서 Pi의 RAM에 CPU 개입없이 직접 접근할 수 있기 때문일 것으로 의심합니다. 이는 고정된 페이지 크기가 필요하기 때문에 발생합니다. 기본 라즈베리 파이 OS는 16k 페이지 크기로 제공되지만, 다음 명령어로 확인할 수 있습니다: getconf PAGE_SIZE .\n\n이제 4K 커널을 설치하기 위해 여러 옵션이 있습니다:\n\n- 아마도 4K 커널은 이미 Pi에 16K 커널과 함께 설치되어 있을 것이므로, /boot/firmware에 kernel8.img 파일이 있는지 확인할 수 있습니다. 이 파일이 있다면, /boot/firmware/config.txt 파일 가장 아래에 kernel=kernel8.img 라인을 추가하여 Pi가 이 커널을 부팅하도록 지시할 수 있습니다. 다음으로 시스템에 커널 헤더를 설치해야 합니다: 나중에 gasket 드라이버를 컴파일하기 위해 sudo apt install linux-headers-$(uname -r) 명령어를 실행해 주세요.\n- 또는 공식 지침을 따라 Pi에 새로운 4K 커널을 다운로드, 빌드 및 설치할 수 있습니다. 이 옵션은 Pi 내에서 언제든지 커널을 빌드할 수 있어 가장 유연합니다. 나중에 TPU 드라이버를 빌드하기 위해 필요한 커널 헤더도 자동으로 설치됩니다.\n- 마지막으로, PI 웹 사이트에서 설명하는 대로 커널을 크로스 컴파일할 수도 있습니다. 작동하는 커널을 얻지만, 데비안 도커 컨테이너 내에서 크로스 컴파일할 때 컴파일러 불일치로 인해 나중에 TPU 드라이버를 컴파일하는 데 문제가 있었습니다. 크로스 컴파일 중에 정확히 동일한 컴파일러를 사용해도 형식 실행 오류로 인해 드라이버를 성공적으로 컴파일할 수 없었습니다. 이 옵션을 작동시킨 경우 댓글로 남겨주세요 :)\n\n라즈베리 파이는 하드웨어를 커널에 설명하기 위해 디바이스 트리를 사용합니다. 우리는 커널에 PCIe 인터페이스를 사용하고 싶다고 알리기 위해 dtparam(디바이스 트리 매개변수)를 설정해야합니다. 다음과 같은 라인을 /boot/firmware/config.txt 파일에 추가하여 이 작업을 수행할 수 있습니다(가장 아래에 추가):\n\n<div class=\"content-ad\"></div>\n\n\n해당 테이블은 마크다운 형식으로 변경되었습니다.\n\n```js\ndtparam=pciex1\ndtparam=pciex1_gen=2 # 이는 속도를 설정합니다. 최대 3까지 설정할 수 있습니다.\n```\n\nTPU를 위해 활성 상태 전원 관리(ASPM)를 비활성화해야 한다고 하는군요. 이를 위해 /boot/firmware/cmdline.txt 파일에서 rootwait 바로 앞에 pcie_aspm=off를 추가하여 수행할 수 있습니다.\n\n재부팅한 후 lspci 명령을 실행하면 TPU가 목록에 표시될 것입니다.\n\n이제 커널이 TPU의 존재를 인식했지만, 상호 작용하려면 커널 드라이버가 필요합니다. 이는 사용자 응용 프로그램이 안전 상의 이유로 하드웨어와 직접 통신하는 것을 허용하지 않기 때문에 필요한 조치입니다. 모든 하드웨어 상호 작용은 시스템 호출을 통과해야 하며, 이를 통해 프로그램 실행이 커널 모드로 이동하여 하드웨어에 안전하게 액세스할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n코랄 TPU 드라이버는 Google Gasket(Google ASIC 소프트웨어, 커널 익스텐션 및 도구) 드라이버와 TPU 드라이버 소프트웨어인 libedgetpu로 구성됩니다.\n\nLibedgetpu는 APT(Advanced Package Tool) 패키지 관리자를 통해 설치할 수 있습니다. libedgetpu의 소스를 소스 목록 파일에 추가하면 apt가 패키지를 찾을 때 스캔하는 것이 필요합니다. 또한 패키지의 무결성을 확인하기 위해 SHA 키를 추가해야 합니다:\n\n```bash\nsudo apt update\necho \"deb https://packages.cloud.google.com/apt coral-edgetpu-stable main\" | sudo tee /etc/apt/sources.list.d/coral-edgetpu.list\ncurl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -\nsudo apt-get update\nsudo apt-get install libedgetpu1-std\n```\n\n그런 다음 시스템에 Gasket 커널 모듈을 설치해야 합니다. 이를 위한 하나의 방법은 커널 소스 트리에 소스 코드를 추가하고 커널 드라이버로 컴파일하는 것입니다(이 방법으로 성공하지 못했지만 가능할 것으로 생각됩니다). 그러나 이를 수행하는 선호되는 방법은 DKMS(Dynamic Kernel Support Module)를 사용하는 것입니다. DKMS를 사용하면 소스 코드가 기본적인 커널 소스 외부에 있는 커널 모듈을 빌드할 수 있습니다. 이 방법의 추가적인 장점은 새 커널이 설치될 때 자동으로 모듈을 다시 빌드한다는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo apt install -y devscripts debhelper  # dkms 종속성 설치\nsudo apt install dkms \nsudo apt-get install dh-dkms # dkms 도우미 모듈\n```\n\n이제 공식 가스켓 드라이버를 다운로드하고 설치하기 위해 필요한 모든 종속성이 준비되었습니다:\n\n```js\n# 가스켓 드라이버 리포지토리 복제\nsudo git clone https://github.com/google/gasket-driver.git\ncd gasket-driver\nsudo debuild -us -uc -tc -b # 가스켓 드라이버 패키지 빌드\ncd .. \nsudo dpkg -i gasket-dkms_1.0-18_all.deb\n```\n\nexec 포맷 오류(컴파일러 불일치)로 .deb 패키지를 여러 번 설치하는 데 문제가 생겼다고 해요. 나는 Pi에서 커널을 빌드하고 로컬로 설치하여 이 문제를 해결했다고 해요.\n\n<div class=\"content-ad\"></div>\n\n커널 드라이버는 하드웨어를 응용 프로그램에 노출시켜 /dev 하위에 장치로 노출시킴으로써 하드웨어를 노출합니다. TPU에 대한 사용자 프로그램의 액세스를 수동으로 허용해야 합니다. /dev/apex 장치를 통해 TPU에 접근할 수 있도록 해야 합니다. (왜 'apex'이라고 불리는지 전혀 모르겠습니다):\n\n```js\nsudo sh -c \"echo 'SUBSYSTEM==\\\"apex\\\", MODE=\\\"0660\\\", GROUP=\\\"apex\\\"' >> /etc/udev/rules.d/65-apex.rules\"\nsudo groupadd apex\nsudo adduser $USER apex\n```\n\n이 과정의 마지막 단계는 TPU로부터 인터럽트를 처리하는 인터럽트 컨트롤러를 변경하는 것입니다. TPU는 MSI (Message Signaled Interrupts)를 사용하는데, 이는 일반적인 인터럽트 (IRQ)와 다르게 인터럽트 레지스터가 CPU의 IO 레지스터로 메모리 매핑된다는 면에서 다릅니다 (제대로 이해했다면요). 커널 6.6.30부터는 이를 /boot/firmware/config.txt 파일에 추가할 dtoverlay를 통해 쉽게 변경할 수 있습니다: dtoverlay=pineboards-hat-ai . 재부팅하면 CV 모델을 TPU에 배포할 준비가 끝납니다!\n\n그러나 이전 버전의 커널을 사용하고 있다면, 장치 트리 소스 코드에서 msi-parent 속성을 수동으로 변경해야 합니다. 커널을 처음부터 컴파일했다면 커널 소스 코드에서 직접 소스 코드를 변경할 수 있지만, 그렇지 않으면 먼저 컴파일된 .dtb (장치 트리 바이너리) 파일을 .dts (장치 트리 소스) 파일로 디컴파일해야 합니다. 그런 다음 msi-parent를 phandle의 값으로 변경해야 합니다. 제 경우에는 0x6e였지만, 이 값은 변경될 수 있습니다. 소스 코드를 찾아보면 해당 값이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-23-AcceleratingCVwithaRaspberryPi5andCoralTPUPart1_1.png)\n\n```js\nsudo cp /boot/firmware/bcm2712-rpi-5-b.dtb /boot/firmware/bcm2712-rpi-5-b.dtb.bak\nsudo dtc -I dtb -O dts /boot/firmware/bcm2712-rpi-5-b.dtb -o ~/test.dts\nsudo sed -i '/pcie@110000 {/,/};/{/msi-parent = <[^>]*>;/{s/msi-parent = <[^>]*>;/msi-parent = <0x6e>;/}' ~/test.dts\nsudo dtc -I dts -O dtb ~/test.dts -o ~/test.dtb\nsudo mv ~/test.dtb /boot/firmware/bcm2712-rpi-5-b.dtb\nsudo reboot now\n```\n\n다음 튜토리얼에서 TPU에서 Mobilenet을 훈련하고 실행할 거에요.\n\n소스:\n\n\n<div class=\"content-ad\"></div>\n\n- [https://gist.github.com/dataslayermedia/714ec5a9601249d9ee754919dea49c7e](https://gist.github.com/dataslayermedia/714ec5a9601249d9ee754919dea49c7e)\r\n- [https://www.jeffgeerling.com/blog/2023/pcie-coral-tpu-finally-works-on-raspberry-pi-5](https://www.jeffgeerling.com/blog/2023/pcie-coral-tpu-finally-works-on-raspberry-pi-5)","ogImage":{"url":"/assets/img/2024-06-23-AcceleratingCVwithaRaspberryPi5andCoralTPUPart1_0.png"},"coverImage":"/assets/img/2024-06-23-AcceleratingCVwithaRaspberryPi5andCoralTPUPart1_0.png","tag":["Tech"],"readingTime":6},{"title":"포트 포워딩 없이 어디서든 라즈베리 파이에 원격 접속하는 방법","description":"","date":"2024-06-23 18:17","slug":"2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding","content":"\n\n<img src=\"/assets/img/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding_0.png\" />\n\n안녕하세요! 이 블로그에서는 포트 포워딩 없이 인터넷을 통해 어디서나 안전하게 Raspberry Pi나 IoT 장치에 원격으로 연결하는 방법에 대해 알아보겠습니다. 이를 통해 장치를 더 효과적으로 원격으로 관리할 수 있습니다.\n\nRaspberry Pi는 인기 있는 싱글 보드 컴퓨터(SBC)로 다양한 프로젝트에 적합한 소형, 저전력 장치입니다.\n\n하지만 제대로 관리되지 않으면 이러한 장치는 부담이 될 수 있고 고객 이탈을 야기하여 수익 손실로 이어질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nNAT 라우터나 방화벽을 통한 포트 포워딩은 외부 네트워크에서 인터넷을 통해 라즈베리 파이에 원격으로 액세스하는 것에 안전하지 않은 방법입니다. 포트 스캐너와 해커들이 당신의 라즈베리 파이나 IoT 디바이스에 접근할 수도 있습니다.\n\n이 글에서는 다음을 설정하지 않고 원격 액세스를 위한 라즈베리 파이를 구성하는 방법을 설명하겠습니다:\n\n- 포트 포워딩 없이 인터넷을 통해 SSH를 이용한 라즈베리 파이 원격 액세스\n- 포트 포워딩 없이 VNC를 이용한 라즈베리 파이 GUI 데스크톱 원격 액세스\n- 포트 포워딩 없이 RDP를 이용한 라즈베리 파이 GUI 데스크톱 원격 액세스\n- 포트 포워딩 없이 웹 애플리케이션을 통한 라즈베리 파이 원격 액세스\n- 포트 포워딩 없이 라즈베리 파이에 원격으로 명령어 실행\n- 포트 포워딩 없이 라즈베리 파이에 원격으로 명령어 실행\n\n우리는 SocketXP IoT 관리 및 원격 액세스 플랫폼을 사용하여 포트 포워딩 없이 인터넷을 통해 라즈베리 파이에 원격으로 연결할 것입니다.\n\n<div class=\"content-ad\"></div>\n\nSocketXP를 사용하면 NAT 라우터 및 방화벽 뒤에 있는 Raspberry Pi에 대해 외부 네트워크(인터넷과 같은)에서 원격으로 연결할 수 있어요.\n\n# SocketXP란\n\nSocketXP는 Raspberry Pi, Nvidia Jetson 또는 IoT 기기와 같은 임베디드 리눅스 장치를 인터넷을 통해 엑세스, 관리 및 디버그할 수 있도록 하는 클라우드 기반 안전한 원격 액세스 솔루션입니다. SocketXP는 안전한 SSL/TLS 연결을 통해 Raspberry Pi에 안전한 원격 액세스를 제공해요.\n\nSocketXP 솔루션을 작동시키려면 집이나 사무실 라우터에서 구성 변경이 필요하지 않아요. 공용 IP가 필요하지 않아요.\n\n<div class=\"content-ad\"></div>\n\n그냥 상자에서 작동합니다.\n\nSocketXP는 SSL/TLS 역방향 프록시 터널을 만들어 원격 장치에 안전하게 연결합니다.\n\nSocketXP는 라즈베리 파이에 원격 액세스를 제공하기 위해 포트 포워딩 기술이나 다이내믹 DNS(DDNS)와 같은 보안이 취약한 방법을 사용하지 않습니다.\n\nSocketXP는 안정된 원격 액세스를 제공하기 위해 전 세계 수천 명의 고객에게 신뢰받는 기업용 IoT 원격 액세스 및 관리 플랫폼입니다.네트워크 외부의 어디에서나 인터넷을 통해 라즈베리 파이에 안전하게 원격 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n시작해 봅시다.\n\n## 1. NAT 라우터 또는 방화벽 뒤에 있는 Raspberry Pi에 SSH를 사용하여 인터넷을 통해 원격으로 연결하기\n\n**Secure Shell (SSH)**는 인터넷과 같은 보안되지 않은 네트워크를 통해 라즈베리 파이의 터미널에 안전하게 연결할 수 있는 네트워크 프로토콜입니다.\n\nSSH는 클라이언트 서버 모델을 따릅니다. SSH 서버는 라즈베리 파이에서 실행되고 SSH 클라이언트는 사용자 노트북이나 PC에서 실행됩니다. SSH 서버는 기본적으로 TCP 포트 22에서 수신 대기합니다.\n\n<div class=\"content-ad\"></div>\n\nOpenSSH은 SSH 서버 및 클라이언트 소프트웨어의 오픈 소스 구현을 제공합니다.\n\n참고: 라즈베리 파이에는 SSH 서버 소프트웨어가 설치되어 있습니다.\n\nSSH 클라이언트는 SSH 서버가 실행되는 기기의 IP 주소를 알아야하므로 해당 기기에 연결할 수 있습니다.\n\n인터넷에서 라즈베리 파이의 터미널에 SSH를 통해 원격으로 연결하려면 NAT 라우터와 방화벽 뒤에 설치된 라즈베리 파이 장치는 인터넷에서 액세스할 수 없습니다. SocketXP 라즈베리 파이 원격 액세스 솔루션을 사용하여 어디서든 인터넷을 통해 라즈베리 파이 터미널에 원격으로 연결할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding_1.png)\n\n자세한 내용을 알아보려면 인터넷을 통해 Raspberry Pi에 대한 원격 SSH 액세스를 설정하고 구성하는 방법을 참조하십시오.\n\n# 2. VNC를 사용하여 인터넷을 통해 Raspberry Pi에 원격으로 연결하기\n\n가상 네트워크 연결(VNC)은 Raspberry Pi의 그래픽 사용자 인터페이스(GUI) 또는 데스크톱에 안전하게 액세스하는 프로토콜입니다. VNC는 일반적으로 Raspberry Pi와 같은 Linux 기반 플랫폼의 GUI에 원격으로 액세스하는 데 사용됩니다.\n\n<div class=\"content-ad\"></div>\n\nVNC은 클라이언트 서버 모델을 따릅니다. VNC 서버는 라즈베리 파이에서 실행되고 VNC 클라이언트는 사용자 노트북이나 PC에서 실행됩니다. VNC 서버는 기본적으로 TCP 포트 5901에서 수신 대기합니다.\n\nTightVNC은 라즈베리 파이에 설치할 수 있는 오픈 소스 기반 VNC 소프트웨어입니다. 원격 데스크톱 액세스를 위해 사용됩니다.\n\n인터넷에서 어디에서나 VNC를 통해 라즈베리 파이 GUI 데스크톱에 원격으로 연결하려면 네트워크 주소 변환 라우터(NAT router)와 방화벽 뒤에 설치된 라즈베리 파이 장치에 대한 액세스를 SocketXP 라즈베리 파이 원격 액세스 솔루션을 사용하여 실행해야 합니다.\n\n![이미지](/assets/img/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding_2.png)\n\n<div class=\"content-ad\"></div>\n\n아래와 같이 참조하세요: Raspberry Pi를 인터넷을 통해 원격 VNC 접속을 설정하고 구성하는 방법에 대해 알아보세요.\n\n# 3. xrdp를 사용하여 인터넷을 통해 Raspberry Pi 원격 데스크톱(RDP)에 연결하기\n\n원격 데스크톱 프로토콜(RDP)은 마이크로소프트에서 발명한 프로토콜로, 지역 네트워크에서 한 Windows 기기의 Windows 데스크톱에 다른 Windows 기기에서 액세스하는 데 사용됩니다.\n\nRDP는 클라이언트-서버 모델을 따릅니다 - RDP 서버는 라즈베리 파이에서 실행되며 RDP 클라이언트는 사용자의 노트북이나 PC에서 실행됩니다. RDP 서버는 기본적으로 TCP 포트 3389에서 수신 대기합니다.\n\n<div class=\"content-ad\"></div>\n\n마이크로소프트가 타사가 동일한 것을 구현할 수 있도록 RDP를 개방했습니다. xrdp는 Microsoft RDP의 오픈 소스 구현입니다. xrdp는 주로 라즈베리 파이와 같은 리눅스 기반 플랫폼의 GUI 데스크톱에 원격으로 접속하는 데 사용됩니다.\n\n인터넷에서 Raspberry Pi 장치에 액세스 할 수 없는 NAT 라우터 및 방화벽 뒤에 설치된 경우, SocketXP Raspberry Pi 원격 액세스 솔루션을 사용하여 어디에서나 인터넷을 통해 xrdp를 사용하여 Raspberry Pi GUI 데스크톱에 원격으로 연결할 수 있습니다.\n\n자세한 내용은 다음을 참조하십시오: xrdp를 사용하여 인터넷을 통한 라즈베리 파이 원격 데스크톱 액세스 설정 및 구성 방법\n\n<div class=\"content-ad\"></div>\n\n# 4. 웹 앱을 사용하여 NAT 라우터 또는 방화벽 뒤에 있는 Raspberry Pi 원격 제어하기\n\n라즈베리 파이에 IoT 웹 애플리케이션을 설치하고 실행하면 웹 클라이언트를 사용하여 Raspberry Pi에 원격으로 연결하고 제어할 수 있습니다.\n\n예를 들어, 간단한 파이썬 Flask 웹 서버 애플리케이션을 작성하여 원격으로 파일에 액세스할 수 있습니다. 이미지, 웹캠에서 비디오, 구성 파일, 로그 파일 등을 가져올 수 있습니다.\n\n```js\n$ cat get_files.py\nfrom flask import Flask, send_from_directory\n\napp = Flask(__name__) @app.route('/')\n\ndef send_report(path):\n    return send_from_directory('/', path)\n\nif __name__ == '__main__':\n    app.run(host='127.0.0.1', port=3000, debug=True)\n```\n\n<div class=\"content-ad\"></div>\n\n라즈베리 파이에서 실행 중인 웹 서버 애플리케이션에 로컬 네트워크에서 웹 브라우저를 사용하여 액세스할 수 있습니다. http://localhost:3000 주소로 브라우저를 열어보세요.\n\n다만, NAT 라우터와 방화벽 뒤에 설치된 라즈베리 파이는 인터넷에서 액세스할 수 없습니다.\n\nSocketXP 라즈베리 파이 원격 액세스 솔루션을 사용하여 어디서나 인터넷을 통해 파이썬 플라스크 웹 서버 애플리케이션에 원격으로 연결할 수 있습니다.\n\nSocketXP는 라즈베리 파이에서 실행 중인 로컬 웹 앱을 위한 안전한 공개 웹 URL(HTTPS)을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변경되었습니다.\n\n\n![Raspberry Pi Remote Access](/assets/img/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding_4.png)\n\nTo learn more, refer to: [how to remote access Raspberry Pi web app over the internet]\n\n## 5. Send Remote Commands to Raspberry Pi over the Internet from Outside Network\n\nRemote Command Execution: the ability to send one-off shell commands to your Raspberry Pi to quickly fetch crucial information or take some corrective action on your remote Raspberry Pi is immensely important.\n\n\n<div class=\"content-ad\"></div>\n\n라즈베리 파이에 항상 로그인하고 명령이나 프로그램을 실행하기 위해 로그인과 비밀번호를 사용하는 것은 번거로울 수 있습니다.\n\n특히 라즈베리 파이 편대에 동일한 스크립트나 명령을 실행해야 하는 경우 더욱 귀찮아집니다.\n\nSocketXP 라즈베리 파이 원격 액세스 솔루션을 통해 인터넷을 통해 하나의 라즈베리 파이나 라즈베리 파이 편대에 대해 원격으로 셸 스크립트, 명령 또는 Python 프로그램을 실행할 수 있습니다.\n\n자세한 내용은 인터넷을 통한 원격 명령 실행을 위해 라즈베리 파이를 설정하고 구성하는 방법을 참조하세요.\n\n<div class=\"content-ad\"></div>\n\n# 결론:\n\n이 글에서는 SSH, VNC, RDP, 웹 앱 및 원격 명령 실행을 사용하여 포트 포워딩 없이 어디서든 Raspberry Pi에 원격으로 액세스할 수 있는 5가지 다양한 옵션을 살펴보았습니다.\n\n또한 SocketXP의 Raspberry Pi 원격 액세스 솔루션이 포트 포워딩을 활성화하지 않고 Raspberry Pi 기기를 원격으로 관리하고 제어하는 안전하고 강력하며 편리한 방법을 제공한다는 것에 대해 논의했습니다.\n\n사용하기 쉬운 인터페이스, 고급 기능 및 타의 추종을 불허하는 유연성을 갖춘 이 혁신적인 솔루션은 Raspberry Pi 애호가에게 꼭 필요한 도구입니다.\n\n<div class=\"content-ad\"></div>\n\n이 절삭 즉석 솔루션을 활용하고 Raspberry Pi 장치의 모든 잠재력을 발휘해보세요. 어디에서나 Raspberry Pi 프로젝트를 제어할 수 있는 SocketXP의 Raspberry Pi 원격 액세스 솔루션을 시도해보세요.\n\n원문은 https://www.socketxp.com/iot/access-raspberry-pi-remotely-over-the-internet/에서 확인하실 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding_0.png"},"coverImage":"/assets/img/2024-06-23-AccessRaspberryPiRemotelyFromAnywhereWithoutPortForwarding_0.png","tag":["Tech"],"readingTime":7}],"page":"11","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":0},"__N_SSG":true}