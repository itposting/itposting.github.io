{"pageProps":{"posts":[{"title":"내 차가운 차 상자에서 만든 DIY 목 장식 상자 프로젝트","description":"","date":"2024-06-19 02:39","slug":"2024-06-19-MyDIYWoodChestProjectfromaTeaBox","content":"\n\n## THE DIY DIARIES/JAPANESE/TEA BOXES/RECYCLING\n\n여러 해 전에 일본에서 살았을 때 샤바코 선박 상자를 두 개 샀어요. 우리는 신혼 부부였고, 처음으로 만든 집을 저렴한 가격으로 꾸미려고 했어요.\n\n버려진 나무와 시멘트 블록이 책장이 되었고, 우유 상자로 레코드 음반을 저장했으며, 중고 가구 소판이 우리의 품안에서 자리를 차지했어요.\n\n사람들은 여전히 \"spoon(스푼)\"이라고 말할까요?\n\n<div class=\"content-ad\"></div>\n\n우리 작은 일본집 근처에서 Chabako를 판매하는 곳을 발견했어요. Chabako는 루즈 티를 배송하는 데 사용되는 일본 목재 상자에요.\n\n각 상자에 약 스물 미국 달러 정도 지불한 것 같아요. 나는 배송 라벨을 제거하고 목재를 연마하여 마무리를 하고 차고 세일용 소파의 엔드 테이블로 만들 계획이에요.\n\n일본인들이 차고 세일을 하는지는 모르겠지만, 미국인들은 하는 걸로 알아요. 미국으로 돌아가는 명령을 받으면, 그들은 종종 짐이 너무 무거워지는 것을 막기 위해 물건을 팔곤 했는데, 물론 새롭게 도착한 사람들이 이들 물건을 사곤 했어요.\n\n우리 소파는 우리가 일본을 떠나고 난 후 동일한 가격에 도착한 부부에게 팔렸어요. 꽤 좋았어요 — 우리는 차도 그렇게 했거든.\n\n<div class=\"content-ad\"></div>\n\n우드는 잣목입니다. 배송 라벨을 제거한 후 상자를 갈아내고 다듬어서 아름답고 러스틱한 모습의 수납 상자들을 만들었어요. 이것들은 오늘까지 사용 중이며, 45년 전에는 멋진 엔드 테이블로 사용되었죠.\n\n내부는 주석이나 아연도가 되어 있으며, 뚜껑이 아주 잘 만들어져서 상자가 거의 밀폐됩니다. 이 상자들은 양모 담요나 재킷을 보관하는 데 훌륭했어요.\n\n<img src=\"/assets/img/2024-06-19-나의 DIY 목공상자 프로젝트에서_0.png\" />\n\n측면의 건설 세부사항에 주목해주세요. 연결 부분은 나누어 놓았고, 상자는 매우 튼튼하여 국제적이고 국내적인 여러 번의 이사를 고르게 견디었습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![My DIY Wood Chest Project from a Tea Box](/assets/img/2024-06-19-MyDIYWoodChestProjectfromaTeaBox_1.png)\n\n구매할 때, 나의 상자들은 위 상자와 비슷했다. 이 상자가 현재 이베이에서 $200.00에 판매 중이니, 아마 제가 45년 전에 $20.00을 썼던 것은 잘 한 선택이었을지도 모르겠다.\n\n하지만 비슷한 차 상자를 $75.00 정도에 판매하고 있는 것도 보았다.\n\n만약 한 개를 보게 되면, 그냥 사 버리세요.\n\n\n<div class=\"content-ad\"></div>\n\n품질이 아주 좋아요. 아연 메탈 안쪽은 담는 물건을 안전하게 보호해주고 벌레가 들어가는 것을 막아줘요.\n\n최근에는 손님용 침실 창가에 하나를 두기로 결정했어요. 황동 코너와 전면용 잠금장치를 달아보았는데, 아마존에서 저렴하게 구입할 수 있어요. 분위기를 더해주는 좋은 장식품이죠.\n\n상자나 중고 가구 등 여러 가지 물건에 이 장식용 코너를 붙여서 간단하게 꾸밀 수 있어요.\n\n그리고 저렴하게 구입할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n청동 모서리는 4개에 $9.59이었고 레트로 청동 잠금장치는 아마존에서 2개에 $7.99였어요.\n\n나무 차바코 상자는 오늘날 한 제조업체에서만 생산됩니다. 기업들은 더 현대적인 운송 방법으로 이동했어요.\n\n차바코 상자는 전 세계로 차를 발송하기 위해 사용되었고, 빈 상자가 항상 일본으로 반환되지 않았기 때문에 많은 나라에서 찾아볼 수 있어요.\n\n차바코 상자는 에도 시대에 형태를 갖추기 시작했는데, 그때부터 일본이 차를 수출 상품으로 발송하기 시작했기 때문이에요.\n\n<div class=\"content-ad\"></div>\n\n스즈오카 현은 차 수출을 위한 차 박스가 개발되었고 대부분의 상자가 만들어진 중요한 차 생산지였습니다.\n\n우리가 살던 가나가와 현과 접해 있어서 아마도 1970년대/80년대에 중고 상자를 많이 보게 된 이유일지도 모르겠어요.\n\n![이미지](/assets/img/2024-06-19-MyDIYWoodChestProjectfromaTeaBox_2.png)\n\n일본 차에 대해 많이 이야기하다보니, 제가 차를 마시기로 결심했어요. 스타벅스 컵에서 마셔도 되는 건가요?\n\n<div class=\"content-ad\"></div>\n\n적어도 도쿄 스타벅스 컵이라니요.\n\n눈을 크게 뜨고 주변을 살피면, 버림받은 물건들을 다시 활용하여 유용하고 아름답게 만들 수 있는 다양한 방법을 발견할 수 있어요.\n\n자신만의 DIY 재활용 이야기가 있나요?\n\n분명히 있을 거예요.\n\n<div class=\"content-ad\"></div>\n\n\"Amanda Laughtland의 저술 \"The DIY Diaries\"에서 발행을 고려해보세요.\n\n![이미지](/assets/img/2024-06-19-MyDIYWoodChestProjectfromaTeaBox_3.png)\"","ogImage":{"url":"/assets/img/2024-06-19-MyDIYWoodChestProjectfromaTeaBox_0.png"},"coverImage":"/assets/img/2024-06-19-MyDIYWoodChestProjectfromaTeaBox_0.png","tag":["Tech"],"readingTime":3},{"title":"애완동물 프로젝트에 적용한 제품 접근 방식, 또는 음악 웹 애플리케이션 개발 이야기","description":"","date":"2024-06-19 02:36","slug":"2024-06-19-AproductapproachtoapetprojectorhowIdevelopedamusicwebapplication","content":"\n\n<img src=\"/assets/img/2024-06-19-AproductapproachtoapetprojectorhowIdevelopedamusicwebapplication_0.png\" />\n\n음악을 좋아하고 개발을 결합하면 무엇이 일어날까요? 제 경우에는 음악 스트리밍 웹 애플리케이션을 만들기 위한 펫 프로젝트로 이어졌습니다. 저는 \"Nexway\"에서 프론트엔드 개발자로 일하는 Andrey입니다. 이제 펫 프로젝트 개발에 대한 효율적인 학습 방법을 설명하겠습니다.\n\n모든 기술을 업무를 통해 습득할 수 없다는 사실은 명확합니다. 이때 펫 프로젝트가 유용하게 활용됩니다. 펫 프로젝트를 통해 새로운 것을 시도할 수 있을 뿐만 아니라 아이디어와 기술을 제한 없이 실험할 수 있는 기회를 제공합니다.\n\n펫 프로젝트를 실험실 연습이 아닌 미래 제품으로 본다면, 전체 개발 주기를 더 잘 이해할 수 있습니다. 이 접근 방식으로 먼저 고객의 역할을 맡아 문제를 해결하는 방법과 가장 좋은 방법을 결정하고, 원하는 기술을 구현하는 데 가장 용이한 기술을 선택하는 방법을 생각할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n제품 접근 방식은 개발 프로세스를 작은 단위로 바라볼 수 있게 해줍니다. 직접 우선 순위를 정하고 작업이 어디에서 비롯되었는지 이해하는 데 도움이 됩니다. 아키텍처를 어떻게 구축할지와 새로운 기능을 추가하기 쉽게 만들기 위해 어떤 기술 스택을 선택할지에 대해 질문을 시작합니다 (응용 프로그램이 성장할수록 새로운 기능을 추가하려는 욕구도 커진다고 고려합니다).\n\n이제 제 애왽 프로젝트 개발에 대해 이 방법을 사용하여 얻은 경험에 대해 이야기하겠습니다.\n\n프로젝트 소개\n\n저는 Spotify, Apple Music 등 음악 스트리밍 애플리케이션에서 영감을 받아 이 프로젝트를 시작하기로 결심했습니다. 브라우저의 기능을 활용하여 음악 파일을 사용하기를 원했기 때문에 음악 주제가 가까웠고 zaycev.net의 나만의 버전을 만들고 싶었습니다.\n\n<div class=\"content-ad\"></div>\n\n이 시점에서는 고객이 있는 것처럼 프로젝트 요구 사항을 구체화하는 것이 중요합니다 (실제로는 본인이어도 좋습니다). 요구 사항은 업무 계획을 작성하고 자신이 관심 있는 기능을 구현하는 데 집중할 수 있도록 도와줍니다. 이렇게 하면 프로젝트를 완료하기 위한 자신에 대한 약속을 만들 수 있습니다.\n\n펫 프로젝트를 제품 프로토 타입으로 살펴보고 있기 때문에 이를 사용할 수 있는 사람들에 대해 고민하는 것이 좋습니다. 애플리케이션의 잠재적 사용자는 누구나 일 수 있고, 사용자 커뮤니티가 공통 음악 라이브러리를 확대할 수 있도록 할 예정입니다. 또한 응용 프로그램은 인디 아티스트들을 대상으로 하며, 새로운 청취자를 발견하고 광고를 무료로 진행할 수 있는 기회를 제공할 것입니다.\n\n아래에는 프로젝트에 대해 개요를 작성한 요구 사항들이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n친화적인 톤으로 번역해보겠습니다.\n\n사용성:\n\n- 직접 UI 컴포넌트 라이브러리(UI 킷)를 사용하여 인터페이스를 구현하십시오.\n- 볼륨 조절, 재생, 이전 또는 다음 트랙으로 전환하는 버튼 및 일시 정지 기능이 있는 기능적 플레이어를 구현하십시오.\n- 언어 전환 및 어두운/밝은 테마로 사용자의 기호에 맞게 인터페이스를 사용자 정의할 수 있는 기능을 추가하십시오.\n\n기술적 요구사항:\n\n- Web Audio API를 기반으로 구현된 자체 음악 플레이어를 사용하여 음악 트랙 및 라디오를 재생하십시오.\n- 사용자가 등록할 때 \"인간\"임을 확인하기 위해 확인 코드가 포함된 이메일을 보내는 방식으로 등록을 검증하십시오.\n- CI/CD를 설정하여 초기 사용자가 기능이 추가될 때 즉시 새로운 기능을 볼 수 있도록 하십시오.\n\n<div class=\"content-ad\"></div>\n\n사용자 중심:\n\n- 전 세계의 라디오 방송을들을 수 있게 합니다.\n- 사용자 커뮤니티에게 음악 라이브러리를 확장할 수 있는 기회를 제공합니다.\n- 소셜 미디어 및 메신저 앱에서 애플리케이션을 공유할 수 있는 기능 추가\n- 아티스트, 제목, 라디오 이름, 국가, 장르로 음악을 검색할 수 있는 자동완성 제안 기능 제공\n- 사용자가 선호하는 음악과 라디오 방송 추가 가능\n- 사용자가 음악 트랙을 컴퓨터로 다운로드할 수 있는 기능 추가\n- 이메일로 리셋 코드를 보내 비밀번호를 재설정할 수 있는 기능 제공\n\n아키텍처 설계\n\n컨셉을 설명하고 요구 사항을 수집한 후, 미래 응용 프로그램의 아키텍처를 설명합니다. 제 경우에는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![Web Application](/assets/img/2024-06-19-AproductapproachtoapetprojectorhowIdevelopedamusicwebapplication_2.png)\n\n기술 스택 선택\n\n프론트엔드: 어플리케이션의 클라이언트 측 구현을 위해 가장 익숙한 기술 스택을 선택했습니다 — React, Redux Tool Kit, Typescript, Webpack.\n\n그 후에는 실험을 하기로 결정하고 Webpack 대신 Vite를 사용하기로 했습니다. HMR을 통해 개발 속도가 향상되고, 빌드 구성을 몇 분 안에 작성할 수 있다는 점이 이유입니다. 다국어 처리를 위해 i18next를 사용했고, 스타일 작업에는 SCSS를 선택했습니다. Tailwind도 고려했지만, 어플리케이션의 일반 디자인 시스템을 설명하고자 했기 때문에 전역 변수와 중첩 작업이 편리했기 때문에 SCSS를 선택했습니다.\n\n\n<div class=\"content-ad\"></div>\n\nUI 킷: 컴포넌트 라이브러리의 경우, 나는 Storybook, React, Typescript, SCSS, Webpack까지만 진행하기로 결정했습니다. 라이브러리를 개발해본 경험이 없었기 때문에 빌더의 선택이 중요했는데, Webpack에서 많은 자료와 코드 예제를 찾을 수 있었습니다.\n\n백엔드: 여기서는 Express.js와 Nest.js 사이에서 오랫동않 고민했습니다. Nest.js에서는 객체 지향적인 접근 방식을 좋아했고, Express.js에서는 간단한 서버를 빠르게 작성할 수 있는 능력과 이미 약간의 경험을 가지고 있었습니다. 결과적으로 Express.js에서 결정하기로 했습니다. 또한 이전에 작업해 본 적이 없었던 클라우드가 트랙을 저장하는 데 필요할 것이라는 것도 분명했습니다. 작은 검색 결과, 클라우드와 쉽게 상호 작용할 수 있게 해주는 라이브러리를 발견했습니다. 인증에는 세션+쿠키 접근 방식을 사용하기로 결정했습니다. 파일 처리에는 multer를 사용했는데, 문서의 명확성과 클라우드로 전송하기 전에 파일을 메모리에 저장할 수 있는 기능이 마음에 들었습니다. 클라이언트와 서버 간의 통신은 REST API를 통해 이루어져야 했습니다.\n\n기술적 설계 디자인\n\n인터페이스 컴포넌트와 데이터베이스 테이블의 상호 작용을 설명합니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-AproductapproachtoapetprojectorhowIdevelopedamusicwebapplication_3.png)\n\n![이미지](/assets/img/2024-06-19-AproductapproachtoapetprojectorhowIdevelopedamusicwebapplication_4.png)\n\n사용자 디자인 설계\n\n안타깝게도 UX/UI 디자인에 대해 얕은 지식만 가지고 있어서 처음부터 사용자 인터페이스를 만들 수 없었습니다. 그래서 인터넷에서 적절한 준비된 디자인을 찾아 구현했습니다.\n\n<div class=\"content-ad\"></div>\n\n기능 구현\n\n이 섹션에서는 애플리케이션을 배포하는 모든 단계를 자세히 설명하고 싶지는 않습니다. 대신, 흥미로운 기능을 더 자세히 설명하겠습니다. 동시에 초보자들에게 더욱 유용하고 완전한 기사를 만들기 위해 프로젝트의 소스 코드 저장소 링크를 뒤에 첨부했습니다.\n\n예를 들어 Sequelize 트랜잭션을 사용하여 클라우드에 트랙을 업로드하는 Express 컨트롤러의 구현 방법은 다음과 같습니다. 먼저 클라우드 업로드 서비스를 호출한 다음 데이터베이스 쓰기 서비스를 호출하고 변경 사항을 저장하도록 합니다. 오류 발생 시 모든 변경 사항이 롤백되어 데이터가 일관되게 유지되며 작업이 원자적으로 수행됩니다.\n\n```js\ntracksController.post(\n   '/uploadTrack',\n   authChecker,\n   upload.fields([\n       { name: 'cover', maxCount: 1 },\n       { name: 'track', maxCount: 1 }\n   ]),\n   async (req, res, next) => {\n       const t = await sequelize.transaction()\n       try {\n           const { trackName, artist } = req.body\n\n           const cover = req.files?.cover[0]?.buffer\n           const track = req.files?.track[0]?.buffer\n\n           const { img, mp3 } = await cloudService.upload({\n               track,\n               cover\n           })\n           await tracksService.addTrack({\n               artist,\n               trackName,\n               img,\n               mp3,\n               moderated: false\n           })\n           await t.commit()\n           res.sendStatus(200)\n       } catch (e) {\n           await t.rollback()\n           next(e)\n       }\n   }\n)\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nconst s3 = new S3({\n   auth: {\n       accessKeyId: process.env.ACCESS_KEY_ID,\n       secretAccessKey: process.env.SECRET_ACCESS_KEY\n   },\n   Bucket: 'nirvana-tracks',\n   debug: false\n})\n\nasync function upload({ track, cover }) {\n   try {\n       let mp3 = await s3.Upload(\n           {\n               buffer: track\n           },\n           '/mp3/'\n       )\n       let img = await s3.Upload(\n           {\n               buffer: cover\n           },\n           '/img/'\n       )\n       if (mp3 && track) {\n           return { img: img.Location, mp3: mp3.Location }\n       } else {\n           throw new Error('업로드할 수 없습니다.')\n       }\n   } catch (e) {\n       console.error(e)\n       throw e\n   }\n}\n\nmodule.exports = {\n   upload\n}\n```\n\n라디오 브라우저 라이브러리를 외부 API로부터 더 독립적으로 만들기 위해 집합 요청을 수행하여 라이브러리의 모든 라디오 스테이션에 대한 단일 요청을 만들어 데이터베이스를 시드로 채웠습니다. 여기에서도 커버 링크가 유효한지 확인했습니다.\n\n```js\nconst RadioBrowser = require('radio-browser')\nconst { v4: uuidv4 } = require('uuid')\nconst checkImage = require('../../web/utils/checkImage')\n\nmodule.exports = {\n   async up(queryInterface, Sequelize) {\n       const radios = await RadioBrowser.getStations({ limit: 100 })\n       const radiosWithUsefulFields = await Promise.all(\n           radios.map(async el => {\n               return {\n                   id: uuidv4(),\n                   name: el.name,\n                   url: el.url,\n                   votes: el.votes,\n                   country: el.country,\n                   favicon: (await checkImage(el.favicon)) ? el.favicon : '',\n                   tags: el.tags,\n                   lastcheckoktime: el.lastcheckoktime\n               }\n           })\n       )\n       await queryInterface.bulkInsert('Radios', radiosWithUsefulFields, {})\n   },\n\n   async down(queryInterface, Sequelize) {\n       await queryInterface.bulkDelete('Radios', null, {})\n   }\n}\n```\n\n```js\nasync function checkImage(url) {\n   return fetch(url)\n       .then(response => {\n           if (response.ok) {\n               return true\n           } else {\n               return false\n           }\n       })\n       .catch(error => {\n           return false\n       })\n}\n\nmodule.exports = checkImage\n```\n\n<div class=\"content-ad\"></div>\n\n내가 커스텀 플레이어의 구현 방법을 설명해 줄게. 기본적으로 useRef를 사용해서 오디오 요소에 대한 참조를 가져와 웹 오디오 API에 액세스했어. 그런 다음 오디오 API에서 가져온 데이터를 React 상태와 연결해서 리렌더링을 트리거하도록 했어. 이 접근법으로 기능을 확장하기 시작했고, 트랙 전환, 드래그 앤 드롭 되감기, 볼륨 제어, 일시 정지 등을 구현했어.\n\n```js\nreturn (\n       <>\n           <audio\n               src={currentTrack?.url}\n               ref={audioElem as LegacyRef<HTMLAudioElement>}\n               onTimeUpdate={() => {\n                   onPlaying({\n                       audioElem:\n                           audioElem as MutableRefObject<HTMLAudioElement>,\n                       setCurrentTrack,\n                       currentTrack\n                   })\n               }\n           />\n```\n\n트랙 선택 시 자동으로 트랙을 시작하는 커스텀 훅 구현 예제야.\n\n```js\nimport { useLayoutEffect } from 'react'\n\n\nimport { usePlayOnMountArgs } from './types'\n\n\nexport function usePlayOnMount({\n   tracks,\n   setCurrentTrack,\n   position,\n   audioElem,\n   setIsPlaying\n}: usePlayOnMountArgs) {\n   useLayoutEffect(() => {\n       setCurrentTrack(tracks[position])\n       const timeoutId = setTimeout(() => {\n           audioElem?.current?.play()\n           setIsPlaying(true)\n       }, 500)\n       return () => {\n           clearTimeout(timeoutId)\n       }\n   }, [tracks, position])\n}\n```\n\n<div class=\"content-ad\"></div>\n\n사용자가 노래를 들으며 더 몰입할 수 있도록 레이아웃을 약간 보완하기로 했어요. 그리고 어플리케이션의 이름(Nirvana)이 정당하다는 느낌을 주도록 했어요.\n\n이를 위해, 플레이어의 배경에 트랙 커버의 색상으로 흐릿한 안개를 만들었는데, 해당 안개가 반짝거리도록 했어요. 그리고 어떤 이유로 인해 커버가 없는 경우에는 어플리케이션의 색상으로 안개를 만들었어요. 이런 효과를 이런 식으로 구현했어요:\n\n```js\n<div\n\tclassName={styles.playerBg}\n\tstyle={{\n\t\tbackgroundImage:\n\t\t\tcurrentTrack.img && `url(${currentTrack.img})`\n\t}}\n></div>\n```\n\n```js\n@import '../../constants/colors.scss';\n\n.playerBg {\n\tz-index: 0;\n\theight: 20%;\n\twidth: 120vw;\n\topacity: 0.85;\n\tposition: fixed;\n\tbottom: -5%;\n\tleft: -5vw;\n\tbackground-image: linear-gradient(\n\t\t90deg,\n\t\trgba(243, 243, 243, 1) 0%,\n\t\trgba(94, 233, 191, 1) 19%,\n\t\trgba(47, 105, 255, 1) 54%,\n\t\trgba(99, 96, 255, 1) 82%,\n\t\trgba(161, 106, 232, 1) 100%\n\t);\n\tfilter: blur(30px);\n\tbackground-repeat: no-repeat;\n\tbackground-size: 300% 300%;\n\tanimation: AnimateBG 100s ease-in-out infinite;\n}\n\n@keyframes AnimateBG {\n\t0% {\n\t\tbackground-position: 0% 50%;\n\t}\n\t50% {\n\t\tbackground-position: 100% 50%;\n\t}\n\t100% {\n\t\tbackground-position: 0% 50%;\n\t}\n}\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-AproductapproachtoapetprojectorhowIdevelopedamusicwebapplication_5.png\" />\n\nCI/CD\n\n어플리케이션에 대한 자동화된 테스트가 없었습니다. 대신에 프로젝트 링크를 모든 친구들과 지인들에게 보내어 피드백을 받고 버그를 발견하는 데 도움을 받았습니다. 이 프로세스를 가속화하기 위해 GitHub Actions를 사용한 간단한 CI 파이프라인을 작성하기로 결정했습니다.\n\n```js\nname: onPush\nrun-name: Actions on push\non: [push]\njobs:\n   init:\n       runs-on: ubuntu-latest\n       strategy:\n           matrix:\n               node-version: [21.x]\n       steps:\n           - uses: actions/checkout@v3\n           - name: Staring Node.js ${matrix.node-version}\n             uses: actions/setup-node@v3\n             with:\n                 node-version: ${matrix.node-version}\n           - name: install modules\n             run: npm install\n           - name: install prettier\n             run: npm install --global prettier\n           - name: formatting code\n             run: prettier . -w\n           - name: build project\n             run: npm run build\n```\n\n<div class=\"content-ad\"></div>\n\nRender에 배포하기로 결정했어요. 거기서 데이터베이스, 백엔드, 그리고 클라이언트를 쉽게 배포할 수 있고 Render가 GitHub 저장소에서 변경 사항도 가져온다는 점이 마음에 들었어요.\n\n내가 마주한 어려움\n\n주요 어려움은 저작권 문제에서 생겼어요. 라디오 섹션을 관리자만 이용할 수 있게 만들어야 했고, 업로드된 트랙은 관리자가 확인한 후에만 일반 피드에 추가되도록 해야 했어요 (지금은 데이터베이스를 통해서만 확인할 수 있어요).\n\n가끔씩 재생과 일시정지를 자주 바꿀 때 브라우저 API가 \"play() 요청이 pause() 호출에 의해 중단되었습니다\"라는 오류를 던지는 이유도 완전히 명확하지는 않았어요. 그러나 나는 커스텀 debounce 훅과 lodash의 해당 함수를 사용하여 이 문제를 해결할 수 있었어요. 아래는 이 문제에 대한 내 해결책이에요.\n\n<div class=\"content-ad\"></div>\n\n```js\nimport { useEffect } from 'react'\nimport { useDebounceOnPlayPauseArgs } from './types'\n\n\nexport function useDebounceOnPlayPause({\n   audioElem,\n   isPlaying\n}: useDebounceOnPlayPauseArgs) {\n   useEffect(() => {\n       const timeoutId = setTimeout(() => {\n           if (isPlaying) {\n               audioElem?.current?.play()\n           } else {\n               audioElem?.current?.pause()\n           }\n       }, 500)\n       return () => {\n           clearTimeout(timeoutId)\n       }\n   }, [isPlaying])\n}\n```\n\n그리고 모바일 적응에 많은 시간을 들였으며 UI를 과다하게 로드하지 않기 위해 일부 기능을 포기해야 했습니다. 어느 시점에서 최소한의 버튼을 사용하고 터치에 집중하기로 결정했습니다. 예를 들어, 트랙 목록을 스와이프로 스크롤하거나 캐러셀과 상호 작용할 수 있습니다. 저는 react-swipeable을 사용하여 이를 구현했습니다. 프로젝트 작업의 마지막 단계에서는 친구, 프론트엔드 및 노드.js 백엔드 개발자에게 코드 검토를 요청하여 일부 수정을 하였습니다. 새로운 관점을 통해 논리를 더 잘 분해할 수 있었습니다. 배포 후 친구들이 버그를 지적하고 UX를 개선하기 위한 조언을 해주었습니다.\n\n프로젝트의 현재 상태는 어떻습니까?\n\n이 프로젝트는 Lighthouse에 따르면 꽤 양호한 성능 지표를 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-19-AproductapproachtoapetprojectorhowIdevelopedamusicwebapplication_6.png\" />\n\n소스 코드는 GitHub를 통해 공개되어 있어 관심 있는 누구든지 확인할 수 있습니다.\n\nhttps://github.com/ABurov30/nirvana-ui\nhttps://github.com/ABurov30/nirvana-client\nhttps://github.com/ABurov30/nirvana-server\n\nUI 킷은 npm에 발행되었습니다.\n\n\n<div class=\"content-ad\"></div>\n\nhttps://www.npmjs.com/package/nirvana-uikit\n\n결론 도출\n\n이 이른바 펫 프로젝트 덕분에 고객과 실행자 모두의 역할을 맡아 제품 접근 방식을 적용하고, 독립적으로 애플리케이션 개발 프로세스를 처음부터 구축했습니다. 기술 스택을 결정하는 방법을 배우고, 클라우드와 Web Audio API를 활용했으며, 자체 UI 라이브러리를 개발하고 새로운 기술을 시도해 보았습니다.\n\n앞으로는 이 프로젝트를 기반으로 새로운 기술을 도입하여 애플리케이션에 기능을 추가해 보려고 합니다. 예를 들어, 세 가지 프로젝트로 마이크로 프론트엔드를 만들어 보려고 합니다:\n\n<div class=\"content-ad\"></div>\n\n리액트, Vite, Redux로 만든 주요 Nirvana 음악 애플리케이션\n\nNext.js로 만든 애플리케이션의 주요 프로모션 페이지\n\nVue, Socket.io, Graph Ql을 사용하여 만든 애플리케이션 내의 채팅 (jotai나 zustand와 같이 명확하지 않은 상태 관리자를 사용할 수도 있어요).\n\n그리고 사용자가 업로드한 콘텐츠를 수동으로 확인하는 것은 상당히 어려우므로 저작권 자동 유효성 검사를 추가하고 싶어요, 이 과정을 자동화하고 싶어요.","ogImage":{"url":"/assets/img/2024-06-19-AproductapproachtoapetprojectorhowIdevelopedamusicwebapplication_0.png"},"coverImage":"/assets/img/2024-06-19-AproductapproachtoapetprojectorhowIdevelopedamusicwebapplication_0.png","tag":["Tech"],"readingTime":13},{"title":"프록시목스 LXC로 마인크래프트하기","description":"","date":"2024-06-19 02:34","slug":"2024-06-19-ProxmoxMinecraftinanLXC","content":"\n\n다시 안녕하세요 여러분! 혼자 방에서 마인크래프트를 하는 것에 지루해 하셨나요? 사기를 당하거나 품질이 낮은 온라인 호스트를 사용하지 않고 친구들과 함께 플레이하고 싶으신가요? 매달 전기 요금을 두 배로 올리는 서버가 있나요? 그렇다면 정말 좋아요! 이 기사는 여러분을 위해 준비되었습니다. Proxmox의 LXC에 Minecraft(구체적으로 PaperMC)를 설치하고, 어디에서나 액세스할 수 있도록 열어 보겠습니다!\n\n![이미지](/assets/img/2024-06-19-ProxmoxMinecraftinanLXC_0.png)\n\n요구 사항:\n\n- Proxmox 서버가 실행되고 구성되어 있어야 합니다.\n- 좋은 인터넷 연결이 필요합니다.\n- 기본적인 CLI 지식이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\nLXC를 생성하는 방법:\n\n네, 서버에 원하는 만큼의 RAM을 부여할 수 있어요. 저는 개인적으로 코어 4개, RAM 8GB, 스토리지 16GB로 운영 중이고 완벽히 작동해요! 물론 더 많은 플레이어가 있을 경우 더 많은 자원이 필요할 거에요. 이 안내서의 단계를 따라 컨테이너를 설정하세요. 저는 컨테이너로 Debian 11을 사용하고 있어요. 다른 유사한 배포판을 사용할 수도 있지만, 아래의 설치 단계는 설치 환경에 따라 다를 수 있어요.\n\n서버를 외부 세계에 직접 노출시키려면 해당 가이드의 Assigning a Static IP 섹션도 읽어보셔서 컨테이너에 정적 IP 주소를 라우터에 할당하세요.\n\n<div class=\"content-ad\"></div>\n\nLXC를 설정하는 방법:\n\n마인크래프트를 실행하기 전에 Java 런타임을 설치해야 합니다. 다행히 이 작업이 꽤 쉽습니다:\n\n```js\napt install openjdk-17-jdk\n```\n\n설치가 완료되면 마인크래프트 서버를 위해 폴더를 생성해야 합니다. 제 경우에는 mkdir /opt/minecraft/ 입니다. 이 폴더의 위치를 기억해 두세요. 이 위치는 나중에 컨테이너를 시작할 때 자동으로 마인크래프트를 시작하는 서비스를 구성할 때 필요합니다.\n\n<div class=\"content-ad\"></div>\n\nPaperMC 설정하는 방법:\n\nPaperMC는 기본 Minecraft 서버보다 성능이 우수한 초경량 Minecraft 서버 패키지입니다. 이 튜토리얼에서는 Paper를 사용할 것이지만, 기본 서버나 Forge와 같이 수정된 서버를 사용해도 괜찮습니다. 수정된 서버에 대한 설치 단계는 여기서 다루는 것과 다를 수 있으니 귀하의 서버에 대한 특별한 요구 사항을 확인해주시기 바랍니다.\n\n이전에 생성한 Minecraft 폴더로 이동하여 Paper를 다운로드하세요.\n\n```js\nwget https://api.papermc.io/v2/projects/paper/versions/1.20.4/builds/435/downloads/paper-1.20.4-435.jar\n```\n\n<div class=\"content-ad\"></div>\n\n개인적으로 파일 이름을 바꾸는 것이 좀 더 나중에 쉽게 입력할 수 있도록 만드는 것을 좋아합니다. 어떤 사람들은 이렇게 하면 실행 중인 버전을 추적하기가 더 어려워진다고 언급했습니다. 이는 사실이지만, 저는 서버의 정확한 버전을 추적하는 데 신경을 쓰지 않습니다. 서버 측 모드를 사용하지 않기 때문에 실제로 중요하지 않습니다. 몇 달에 한 번씩 확인하고 서버를 업데이트하기만 합니다.\n\n```js\nmv paper-1.20.4-435.jar server.jar\n```\n\n이제 서버를 실행하세요.\n\n```js\njava -jar server.jar\n```\n\n<div class=\"content-ad\"></div>\n\n서버가 시작되는 것을 보게 될 것입니다. 폴더에 몇 가지 파일이 생성되고, EULA를 수락하지 않았다는 오류가 발생한 후에 작업이 실패할 것입니다. 이 문제를 해결하기 위해 다음과 같이 EULA를 수락하세요.\n\n```js\nnano eula.txt\n```\n\neula=false를 eula=true로 변경하고 파일을 저장하세요.\n\n이제 EULA를 수락했으므로 모든 것이 잘 작동합니다! 그러나 작은 문제가 하나 있습니다. 명령어 java -jar server.jar를 사용하여 서버를 시작하면 현재 터미널이 사용 중인 상태로 남아 있습니다. 현재 환경을 나와도 서버가 중지됩니다. 또한 현재 터미널에서 다른 명령어를 실행할 수 없으므로 매우 불편합니다. 터미널에서 스크린을 사용할 수 있지만, 저는 이것이 과도한 방법이라고 생각해요. 저에게 가장 간단한 방법은 Minecraft 서버를 실행할 서비스를 만드는 것입니다. 컨테이너를 켤 때 자동으로 시작하도록 구성하여 필요할 때마다 수동으로 켤 필요가 없도록 할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n서비스 생성하기\n\n/etc/systemd/system으로 이동하세요.\n\n서비스 파일을 생성하세요. `nano minecraft.service`\n\n다음 구성을 서비스 파일에 붙여넣으세요.\n\n<div class=\"content-ad\"></div>\n\n\n[Unit]\nDescription=Minecraft 서버\nAfter=network.target\nStartLimitIntervalSec=500\nStartLimitBurst=5\n\n[Service]\nType=simple\nRestart=on-failure\nRestartSec=5s\nWorkingDirectory=/opt/minecraft\nExecStart=java -Xms2G -Xmx8G -jar /opt/minecraft/server.jar --nogui\n\n[Install]\nWantedBy=multi-user.target\n\n\n파일을 저장합니다. 그런 다음 systemctl daemon-reload를 실행하여 새 서비스가 인식되도록하고, 부팅 시 실행되도록 systemctl enable minecraft를 사용하여 활성화한 다음 systemctl start minecraft를 사용하여 서버를 시작합니다. 이것은 수동으로 시작해야 하는 유일한 시간입니다. 이 구성에서 몇 가지 중요한 옵션을 주목합시다.\n\n- WorkingDirectory: 이전에 생성한 폴더의 절대 경로입니다.\n- -Xms2G: Minecraft 서버에 언제든지 할당되어야 하는 RAM의 최소량이며 서버의 부하 양에 관계없이 2GB입니다.\n- -Xmx8G: 서버가 사용할 수있는 RAM의 최대량입니다. 여기서는 컨테이너의 총 RAM 양으로 설정했습니다. 문제를 방지하기 위해 총 RAM 양보다 약간 작은 값으로 설정할 수 있지만, 지금까지 문제가 발생하지 않았습니다.\n- /opt/minecraft/server.jar: 서버 파일의 절대 경로입니다 (파일 및 디렉토리 이름에 따라 달라질 수 있음).\n\n집 네트워크에서만 게임을 하려면 바로 진행하면 됩니다! 그러나 아직도 연락하는 고등학교 친구와 15개 시간대가 떨어진 곳에서 게임을 하고 싶다면 Minecraft 서버를 인터넷에 노출해야 합니다. 아래에서 계속 읽어보세요.\n\n\n<div class=\"content-ad\"></div>\n\n서버 노출하기:\n\n여기서 두 가지 옵션이 있습니다. 마인크래프트 서버를 라우터를 통해 포트 포워드하거나, Minekube Connect와 같은 프록시를 사용할 수 있습니다. 여기에서 두 가지 옵션에 대해 설명하겠습니다.\n\n옵션 1: 포트 노출\n\n여기에서는 라우터를 통해 서버의 포트(보통 25565)를 포트 포워드해야 합니다. 이 방법은 가장 직접적인 방법이지만 가장 불안전합니다. 포트를 직접 인터넷에 공개하는 것은 악성 트래픽을 처리하기 위해 Paper와 같은 서비스에 완전히 신뢰를 두는 것이므로 매우 위험하다는 것은 명백합니다. 그러나 가끔씩만 플레이하고 빠른 옵션이 필요하다면 이것이 좋은 방법일 수 있습니다. 이를 수행하는 방법은 각기 다른 라우터마다 다르므로 이 안내서에서 모두 다루지는 않겠습니다.\n\n<div class=\"content-ad\"></div>\n\n저는 방화벽을 통해 포트를 직접 노출시키는 것을 선호하지 않습니다. 이런 방식은 중간에 버퍼 없이 곧바로 노출시키는 것으로, 이 접근 방식을 권장하지 않습니다. 대신에 옵션 2를 추천합니다(프록시 사용).\n\n옵션 2: 프록시 사용\n\nMinekube Connect는 무료 프록시로, 방화벽을 통해 포트를 직접 노출시키지 않고 Minecraft 서버에 연결할 수 있는 방법입니다. 이를 클라우드플레어 터널과 같이 생각해보세요. 또한, DDoS 방어 기능도 포함되어 있어, 작은 서버에는 필수적이지는 않지만 확실히 장점이 될 것입니다. 설정도 매우 쉽습니다. 함께 설정해 봅시다.\n\n- Minekube에 가서 계정을 만듭니다: https://app.minekube.com\n- 그런 다음, 왼쪽 사이드바에서 Endpoints > Add Endpoint로 이동합니다.\n- 엔드포인트에 이름을 지정합니다. 참고: 엔드포인트 이름은 생성 후 변경할 수 없습니다.\n- 실행 중인 서비스에 대해 Paper/Spigot(기본 옵션)을 선택합니다.\n- 해당 웹페이지 맨 아래로 스크롤하여 토큰을 생성합니다. 토큰을 변경하려는 의사를 확인합니다. 이 토큰은 다시 표시되지 않으니 잘 메모해 둡시다.\n- 플러그인 다운로드 링크를 복사하여 LXC 컨테이너로 돌아갑니다. (저의 경우 /opt/minecraft 디렉터리로 이동) 그리고 플러그인 폴더로 이동합니다 (cd ./plugins).\n- 플러그인 파일을 다운로드합니다: wget https://...플러그인 URL...\n- Minecraft 서비스를 재시작합니다: systemctl restart minecraft. 기본 연결 파일이 생성됩니다.\n- 플러그인 폴더 안에 있으면, 설정 파일을 엽니다: nano config.yml\n- endpoint-name을 Minekube 웹사이트에서 생성한 엔드포인트 이름으로 대체합니다. 변경한 후 파일을 저장하고 닫습니다.\n- 그런 다음, 토큰 파일을 엽니다: nano token.json\n- 토큰 문자열을 5단계에서 생성한 토큰으로 대체합니다. 파일을 저장하고 닫습니다.\n- Minecraft 서비스를 마지막으로 한 번 더 재시작합니다!\n\n<div class=\"content-ad\"></div>\n\n그게 다야! 이제 모든 준비가 끝났어요. 서버는 ENDPOINT_NAME.play.minekube.net 에서 접속 가능할 거에요.\n\n서버 업데이트 방법:\n\n서버를 업그레이드하고 싶다면:\n\n- Minecraft 서비스를 중지하려면 systemctl stop minecraft를 실행하세요.\n- 서버 폴더로 이동하세요: cd /opt/minecraft\n- 이전 서버 파일을 삭제하세요: rm server.jar\n- 새로운 서버 파일을 다운로드하세요: wget ...DOWNLOAD URL...\n- 파일 이름을 변경하세요: mv ...FILE NAME.jar... server.jar\n- 서비스를 시작하세요: systemctl start minecraft\n- 수익 창출하기!\n\n<div class=\"content-ad\"></div>\n\n이 작업을 수행할 때 \"apt update && apt upgrade\"도 실행하는 것을 추천합니다. 시스템 패키지도 컨테이너에서 최신 상태인지 확인할 수 있습니다.\n\n그것이 전부입니다! 이제 완료되었습니다! 이제 친구들과 함께 자신의 서버에서 Mincraft를 즐길 수 있습니다!\n\n면책 조항:\n\n이 문서는 제품 또는 비즈니스 환경에서 설정하는 가이드가 아닙니다. 인터넷에 노출하기 전에 노출되는 모든 서비스가 적절히 보안되어 있는지 확인하세요. VPN을 사용하더라도.\n\n<div class=\"content-ad\"></div>\n\n저는 IT 전문가가 아닙니다. 기술 지원팀도 아니에요. 대학생이자 서버를 가진 사용자입니다. 시스템에서 실행하는 모든 명령에 대한 최종 책임은 여러분에게 있습니다.\n\n질문이 있으면 댓글을 남겨주세요. 즐겨보세요!","ogImage":{"url":"/assets/img/2024-06-19-ProxmoxMinecraftinanLXC_0.png"},"coverImage":"/assets/img/2024-06-19-ProxmoxMinecraftinanLXC_0.png","tag":["Tech"],"readingTime":6},{"title":"Maytag 세탁기의 불균형을 조정하는 간단한 45 단계","description":"","date":"2024-06-19 02:33","slug":"2024-06-19-45SimpleStepstoLevelYourOff-BalanceMaytagWasher","content":"\n\n\n![image](/assets/img/2024-06-19-45SimpleStepstoLevelYourOff-BalanceMaytagWasher_0.png)\n\n마이테크 세탁기에 물건을 넣으면 요동이 시작됐다는 걸 느끼셨나요? 정말 무거운 물건은 아니에요. 세탁이 두 주 정도 쌓인 가정 3인분의 중소한 세탁물인데 시트와 이불도 포함돼 있어요.\n\n마이테크 기술자에게 전화하세요.\n\n빨리 전화 끊으세요. 이게 비싸게 나올까요? 아직 보증이 있는지 확인해보세요. 1년이 넘었으니 아마 없을 거예요.\n\n\n<div class=\"content-ad\"></div>\n\n메이태크 기술자가 필요하지 않다고 결정했군요. 이 문제를 해결할 수 있을 거에요. 망치하나면 충분해요.\n\n세탁기가 균형을 잃었는지 확인하기 위해 바닥에 누워 두건을 들어 다리 부분을 보세요. 모든 다리가 바닥에 닿아 있지만 뭔가 수평이 맞지 않는 것이 느껴질 거에요.\n\n하드웨어 가게에 가서 수평기를 구하세요. 수평기 없이 무언가가 평평한지 알 수 없어요. 미터 길이처럼 긴 큰 수평기가 필요할 거에요.\n\n수평기를 세탁기 뚜껑에 올려놓으세요. 수평 바이알 안의 거품이 중앙에 위치하지 않는 것을 확인하세요. 또한 바이알 안의 액체가 닌자 거북이를 만든 똥과 같은 색이라는 것도 주의하세요. 어쨌든 집중하세요.\n\n<div class=\"content-ad\"></div>\n\n양 끝을 잡아 세탁기를 조심스럽게 여러 번 오른쪽과 왼쪽으로 움직여 앞쪽으로 약간 이동하도록 합니다. 세탁기 뒤쪽을 보며, 잘 알고 있는 것처럼 행동하세요. 두 개의 호스와 전원 코드가 있습니다. 아마도 제자리에 있을 것입니다. 뒤쪽으로는 부품이 나와 있는 게 없습니다. 그것은 좋은 징조입니다.\n\n다시 세탁기 앞쪽으로 눕습니다. 네 귀퉁이에는 원판 모양의 밑면이 있는 나사로 조절 가능한 다리가 있습니다. 이 작업은 쉬울 것입니다. 각 다리를 돌려 세탁기가 수평이 될 때까지 조절하면 됩니다.\n\n앞쪽 왼쪽 다리를 시계 방향으로 조금 돌려주세요.\n\n앞쪽 왼쪽 다리를 반시계 방향으로 조금 돌려주세요.\n\n<div class=\"content-ad\"></div>\n\n잠시만요. 어느 게 어느게죠? 한 번은 이 방식으로 했는데, 다른 번에는 다른 방식으로 했잖아요. 오른쪽으로 돌렸어요, 마치 머리를 살짝 기울여 느낀 듯, 그러나 정상적인 머리를 상상하면, 턱이 바닥을 향하게 됩니다. 오른쪽 쪽이 나오고, 그리고 왼쪽으로 이동해서 시계 방향으로 돌아갔어요. 맞죠? 그리고 반시계 방향은 다른 방향인데, 즉 왼쪽이 오른쪽으로 간다는거죠. 여기서 왼쪽부터 오른쪽으로 읽지만, 그러면 혼란스럽게 느껴지지 마세요. 그냥 한 게 그냥 한 거예요.\n\n확실하기 위해 다시 한 번 해보세요.\n\n앞 오른쪽 세탁기 다리 옆에 위치를 조정하세요. 10단계와 11단계를 반복하세요.\n\n일어서세요. 거의 실신할 뻔했네요. 와, 머리로 향하는 혈액이 대단하군요. 이제 스무 살 시절은 아니네요, 분명히요.\n\n<div class=\"content-ad\"></div>\n\n넌자 거북이군의 수액 병이 있는 수준 맞추려면 세탁기 위에 두어봐. 거품이 여전히 최적 수준이 아님을 확인해. 다시 말해, 7단계를 반복해봐.\n\n일상에서 간단한 일이 조금 더 복잡해진다는 것에 약간 실망할 때 항상 하는 \"음\" 소리를 내뱉어봐. 하지만 괜찮아, 이 정도로 간단하지 않을 거니까?\n\n9단계에서 12단계를 반복해. 그리고 15단계와 16단계도 반복해.\n\n열정을 다해 17단계를 반복해봐.\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n뒷다리를 조립했는데 수평한 길이로 조인 것 같아? 물론 충분한 공간이 있어. 비좁아서 답답한 건 아니니까.\n\n15단계와 16단계를 반복해봐.\n\n음, 뭐야?\n\n거품이 움직이지도 않았어. 이게 가능한 일이야. 무언가가 달라졌어, 그치? 네가 한 그 모든 회전으로 말이야. 저 다리의 회전 기능은 장식용이 아니야. 올라가고 내리는 걸 봤잖아!\n\n<div class=\"content-ad\"></div>\n\n괜찮아요. 잘하고 있어요. 다리 하나씩 가보세요. 그러고 나서 측정하세요.\n\n오른쪽 앞다리로 가세요. 9~11단계를 반복하세요.\n\n안타깝게도, 12단계를 다시 반복하세요.\n\n16단계를 반복하세요. “Teenage Mutant Ninja Turtles” 노래를 멍~ 하면서요.\n\n<div class=\"content-ad\"></div>\n\n다짐을 가지고, 14단계를 반복해 주세요.\n\n31단계를 반복하세요. 괜찮아요. 부르기 멈출 수 있어요. 욕설을 해도 돼요. 이제 노래의 일부예요.\n\n22단계부터 24단계를 반복하세요. 거의 다 왔어요. 카우반가!\n\n15단계와 16단계를 반복하세요.\n\n<div class=\"content-ad\"></div>\n\n인생에 대해 다시 생각해보세요. 당신이 얼마나 많은 것을 이루었는지요? 이겁니다. 이것이 당신의 능력을 정의하는 요소로 작용하게 두지 마세요. 그렇게 하지 마세요.\n\n그런데 왜 그러죠? 왜요? 그들이 해야 할 일은 항상 수직으로 조절되지 않는 다리를 달았어야 했죠. 그러면 항상 수평을 유지할 수 있었을 텐데요. 그렇게 하면 모든 사람들에게 더 좋지 않았을까요? 당신은 똑똑하고 능력이 있으며 해결책을 찾아냈습니다. 이건 사기입니다. 이것은 당신이 Maytag 기술자를 불러서 그들이 다시 집에 와서 \"수리\"하도록 만들기 위해 한 것입니다. 그리고 이를 위해 두백 달러를 청구받습니다. 하지만 이 다리를 어떻게 튼다는 특별한 방법은 당신도 모르게요. 그리고 얼마 후에 다리가 풀려서 기술자가 다시 돌아옵니다.\n\n좋아하는 바에 가서 크랜베리와 레몬이 들어간 보드카 한 잔을 주문하세요.\n\n옆에 있는 남자에게 의심할 여지가 없는 사람들에게 이론을 설명하세요. 그의 고민을 인정해 주세요. 아내가 도망갔기 때문에 이제 그는 자신의 빨래를 어떻게 해야 할지 모릅니다. 그런데 자기 행동에 대한 책임을 지지 못하는, 굳센 남자아이인지라며. 당신은 다른 사람과 비교하지 마세요. 둘 다 낮에 술을 마시고 있는 이유가 있습니다. 왜냐하면 그래야만 하기 때문이에요.\n\n<div class=\"content-ad\"></div>\n\n칵테일 나프킨 몇 장 집어 가세요. 그것들을 앞 오른쪽 세탁기 다리 밑에 놓으세요.\n\n축하해요. 여러분에게 조금 더 보드카를 따르세요.\n\n세탁물을 돌리면서, 더러운 셔츠들이 눈책막이라고 속이고 \"반쉘에 거북이! 거북이 파워!\" 하며 눈치채기를 하세요.\n\n누워 쉬세요.\n\n<div class=\"content-ad\"></div>\n\n들리니? 그 소리는 당신의 Maytag 세탁기가 흔들리는 소리야.\n\n1단계와 2단계를 다시 반복해주세요.","ogImage":{"url":"/assets/img/2024-06-19-45SimpleStepstoLevelYourOff-BalanceMaytagWasher_0.png"},"coverImage":"/assets/img/2024-06-19-45SimpleStepstoLevelYourOff-BalanceMaytagWasher_0.png","tag":["Tech"],"readingTime":4},{"title":"베스트 부수 수입源","description":"","date":"2024-06-19 02:32","slug":"2024-06-19-BestSideHustles","content":"\n\n허슬 사이트를 시작하는 방법을 알면 오늘날의 경제 상황에서 재정 목표를 달성하는 좋은 방법입니다. 일을 하는 것과 개인적인 삶에 부정적인 영향을 미치지 않으면서 사이드허슬(부업)을 시작할 수 있다면, 시도하지 않을 이유가 없습니다.\n\n시작할 때 수익성이 높고 투자가 가장 적은 사이드 직업을 배우는 게 중요합니다. 또한 즐길 수 있는 일을 고려해보세요 - 최고의 사이드 허슬은 일 같이 느껴지지 않는 것입니다.\n\n귀하의 요구에 가장 적합한 사이드허슬을 찾는 데 도움이 되도록 다음 기준을 고려해보세요:\n\n## 열정과 관심\n\n<div class=\"content-ad\"></div>\n\n당신의 기술, 관심사 또는 취미와 일치하는 부업을 시작해보세요. 이렇게 하면 더 많은 돈을 벌면서 재미있게 부업을 할 수 있을 거예요.\n\n### 수익성\n\n어떤 분야의 수익 가능성을 평가하기 전에 꼭 확인해보세요. Firsthand나 ZipRecruiter 같은 사이트들이 연구를 시작하는 데 좋은 장소일 거예요.\n\n### 타당성\n\n<div class=\"content-ad\"></div>\n\n당신의 부업은 본업과 충돌해서는 안 됩니다. 현재 일정에 맞추어야 해요.\n\n### 성장 가능성\n\n일자리의 장기적 잠재력을 검토하고 승진 기회를 제공하는지 확인하세요.\n\n### 합법성\n\n<div class=\"content-ad\"></div>\n\n현실적이지 않은 지불 조건을 제공하는 일자리는 피하세요. 관련 기관에서 발표한 사기 주의 목록에 회사가 있는지 확인할 수 있어요.\n\n이러한 기준을 염두에 두고, 여러분이 추가 수입을 만들 수 있는 다양한 창의적인 부수 수입을 살펴봅시다.\n\n# 1. 유료 설문조사에 참여하기\n\n온라인 설문조사 참여는 여러분의 여가 시간에 할 수 있는 가장 쉬운 온라인 부수 수입 중 하나에요. 설문 웹사이트에 있는 기업과 연구 기관들은 제품과 서비스에 대한 피드백을 얻기 위해 참가자들에게 보상을 지급해요.\n\n<div class=\"content-ad\"></div>\n\n비록 이 사이드 일은 부를 쌓을 수는 없지만, 자주 하게 된다면 상당한 양의 여분 돈을 벌 수 있어요.\n\n## 2. 애완동물 돌봄 서비스 제공하기\n\nRover.com, Petbacker.com, Wagwalking.com과 같은 애완동물 돌봄 서비스의 등장으로 다른 사람들의 애완동물을 돌보는 일에서 돈을 벌 수 있는 사이드 일이 매우 인기가 있어졌어요.\n\n동물을 좋아하는 열정이 있고 기본적인 동물 돌봄 지식이 있다면 충분해요. 신뢰도와 고용율을 높이기 위해 Pet Sitters International에서 인증을 받아보기를 시도해보세요.\n\n<div class=\"content-ad\"></div>\n\n애완동물 돌보기 보험을 구입하여 사업의 책임을 보호하는 것을 고려해보세요. Pet Care Insurance 또는 KennelPro와 같은 애완동물 보험 회사는 책임과 채권 보험을 제공합니다.\n\n애완동물 입양률과 평균 동물 의료비가 증가하고 있기 때문에 애완동물 돌보기 산업은 2022년부터 2030년 사이에 10.4% 증가할 것으로 예상됩니다. 이는 향후 몇 년 동안 애완동물 돌보기 서비스에 대한 수요가 증가할 것이라는 것을 의미합니다.\n\n애완동물 돌보기 플랫폼에 가입하기 전에 세부 사항을 주의 깊게 읽고 서비스 요금을 예상해주세요. 예를 들어, Rover는 각 예약마다 15%의 서비스 요금을 부과합니다.\n\n### 3. 물품 구매 및 재판매\n\n<div class=\"content-ad\"></div>\n\n이 방법은 낮은 가격으로 물품을 구매하여 더 높은 가격에 재판매하는 것을 포함합니다. 보통 물품들은 중고 마켓이나 차고 판매 등에서 구할 수 있습니다.\n\n중고 판매자로 성공하기 위해서는 독특하거나 유명한 브랜드의 물품을 찾아 이베이(Ebay)와 같은 온라인 마켓플레이스에 판매하세요. 심지어 온라인 스토어를 만들어 의류나 하찮은 가격에 구매한 다른 물건을 판매할 수도 있습니다.\n\n물품을 구매할 때는 제품의 품질과 가격에 주의해야 합니다. 수리 비용이 높아질 수 있으므로 수리가 필요 없는 중고 물품을 찾는 것이 가장 좋습니다.\n\n마켓플레이스인 Flippa나 WebsiteBroker와 같은 곳에서 웹사이트를 판매하여 수익을 올리는 것도 좋은 방법입니다. 이 쪽 일은 물품 판매와 비슷한 원리에 기초하지만 웹사이트 최적화와 트래픽 증진이 필요하여 그 가치를 높이는 것이 요구됩니다.\n\n<div class=\"content-ad\"></div>\n\n# 4. 책 리뷰를 작성해 보세요\n\n책 리뷰어는 책에 대한 전문적인 의견을 제공하기 위해 지불을 받습니다. 책 리뷰어가 되는 것은 가장 수익성 있는 재택 부업 중 하나입니다.\n\n책 리뷰 포지션을 찾을 수 있는 몇 가지 웹사이트로는 Onlinebookclub.org, Kirkus Media 및 Women's Review of Books 등이 있습니다. 또한 책 블로거가 되어 스폰서십을 통해 돈을 벌 수도 있습니다.\n\n# 5. DIY 작업을 해 보세요\n\n<div class=\"content-ad\"></div>\n\n만일 건설이나 수리에 능숙하다면, 손수리사로서 부업을 하는 것은 돈을 벌 수 있는 좋은 방법입니다.\n\n서비스를 마케팅하는 방법에 신중히 생각해보세요. 소비자들은 전문가를 선호하는 경우가 많습니다. 그러므로 여러분의 우수한 기술을 명확하게 표시해주세요, 비록 그것이 사소할지라도요.\n\n개인 프로젝트를 완수하거나 지역사회에 도움을 주거나 직업 학교에 등록함으로써 수작업 기술을 완벽하게 향상시킬 수 있습니다. 또한 eHow나 YouTube 튜토리얼과 같은 온라인 자료도 확인해보세요.\n\n산업에 더 오래 계신 분을 알고 있다면, 그들에게 수습생이 되어달라고 부탁해보세요. 전문가의 감독 아래 실전 훈련을 받는 것은 여러분의 기술 향상에 도움을 줄 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-BestSideHustles_0.png"},"coverImage":"/assets/img/2024-06-19-BestSideHustles_0.png","tag":["Tech"],"readingTime":3},{"title":"프로젝트 proxymity 파트 III - 로봇 제어 메커니즘","description":"","date":"2024-06-19 02:31","slug":"2024-06-19-projectproxymitypartIIIRobotControlmechanism","content":"\n\n로봇을 이동시키고 제어 신호를 해석하기\n\n제어 신호 스트림을 기반으로 로봇을 이동시키기 위해 시도한 두 가지 방법이 있었습니다. 각각의 신호를 포함하는 개별 패킷들과 관련된 네트워크 속도 문제를 해소하는 것이 주요 과제였죠.\n\n두 가지 방법 중 어떤 것이 더 나은지 알아봅시다. 아래 애니메이션의 구조를 간략히 살펴보면 미묘한 차이를 이해하는 데 도움이 될 것입니다.\n\n![로봇 제어 메커니즘](/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_0.png)\n\n<div class=\"content-ad\"></div>\n\n**접근 방법 1 (구현하기 쉽지만 움직임이 떨리는 움직임을 일으킴)**\n\n첫 번째 방법은 로봇을 빵갈루루에서 제어 신호를 받을 때마다 짧은 거리만 이동시키는 것이었습니다. 따라서 로봇이 연속적으로 \"8\"을 받아 \"전진\" 명령을 20번 수신하면 조금씩 20번 전진했습니다. 이는 네트워크를 통해 수신되는 신호가 균일하게 도착하지 않아 매우 불안정한 움직임을 유발했습니다. 이것은 약간의 전진 Arduino 코드로 완화되지 않을까 생각하지만 더 탐구해봐야 할 것 같습니다.\n\n[2024-06-19-projectproxymitypartIIIRobotControlmechanism_1](/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_1.png)\n\n**접근 방법 2(조금 더 다루기 어려움이 있으나 더 부드러움이 필요함)**\n\n<div class=\"content-ad\"></div>\n\n네트워크 속도와 대역폭의 예측할 수 없는 문제를 극복하기 위한 다른 방법은 로봇을 다른 신호를 받을 때까지 계속 이동시키거나 신호를 받지 않는 상태로 유지하는 것이었습니다.\n\n![로봇 제어 메커니즘](/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_2.png)\n\n두 번째 방법이 더 나은 결과를 얻을 수 있었던 이유는 설정된 시간(예: 1초)동안 이동을 시작하고 다른 신호가 수신될 때까지 계속 이동하는 것이기 때문이었습니다. 신호를 받지 못했을 경우, 이동이 만료되고 로봇이 멈출 것이었습니다. 이 방법은 훨씬 부드럽고 더 유연한 사용자 경험을 제공했습니다.\n\n주로 다음 코드를 사용하여 C# 레이어에서 대부분 구현되었습니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 변경한 내용입니다.\n\n\n![Projects](/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_3.png)\n\n이 프로젝트에는 개선할 점이 많이 있습니다. 내 방식으로 조금씩 계속 개선해 나갈 예정입니다. 인도 휴가 동안에도 작업할 계획입니다.\n\nBuild and Introduction\n\nPart I — AI Vision Control\n\n\n<div class=\"content-ad\"></div>\n\n제 II 부 — 신호 전송\n\n제 III 부 — 로봇 제어 메커니즘 (이 이야기)","ogImage":{"url":"/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_0.png"},"coverImage":"/assets/img/2024-06-19-projectproxymitypartIIIRobotControlmechanism_0.png","tag":["Tech"],"readingTime":2},{"title":"작고 빠른 머신 러닝 TinyML  서포트 벡터 머신 분류기","description":"","date":"2024-06-19 02:27","slug":"2024-06-19-TinyMLSupportVectorMachinesClassifier","content":"\n\n수학적 기초부터 엣지 구현까지\n\n## 소셜 미디어:\n\n👨🏽‍💻 Github: thommaskevin/TinyML (github.com)\n👷🏾 Linkedin: Thommas Kevin | LinkedIn\n📽 Youtube: Thommas Kevin — YouTube\n👨🏻‍🏫 연구 그룹: Conecta.ai (ufrn.br)\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_0.png)\n\n<div class=\"content-ad\"></div>\n\n서포트 벡터 머신(SVMs) 또는 머신 러닝에서는 서포트 벡터 네트워크라고도 하는 SVMs는 학습 알고리즘을 갖춘 지도형 최대 마진 모델입니다. 이들은 분류와 회귀 분석을 위해 데이터를 분석합니다. Vladimir Vapnik과 동료들은 AT&T 벨 연구소에서 SVMs를 개발했습니다. SVMs는 Vapnik과 Chervonenkis가 1974년에 제안한 VC 이론과 통계 학습 프레임워크에 근거한 매우 연구된 모델 중 하나입니다.\n\n# 1 — 서포트 벡터 머신 이론\n\n## 1.1 — 선형 이진 분류\n\n기본적으로 SVM의 역할은 분리 가능한 데이터 집합에 대해 클래스나 레이블 간의 가장 효율적인 분리 경계를 식별하는 것입니다. SVM의 맥락에서 클래스를 완전히 분리할 수 있는 다양한 초평면들이 잠재적인 분리 경계로 간주됩니다.\n\n<div class=\"content-ad\"></div>\n\n우리는 각 입력 xi가 D개의 속성(즉, D 차원으로 구성)을 가지고 있고 -1 또는 +1 중 하나의 클래스에 속하는 값 yi를 갖는 L개의 학습 포인트가 있습니다. 즉, 우리의 훈련 데이터는 다음과 같습니다.\n\n![training data](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_1.png)\n\n여기서 데이터가 선형적으로 분리 가능하다고 가정합니다. 즉, D = 2 일 때 x1 대 x2 그래프에 두 클래스를 분리하는 선을 그릴 수 있고, D ` 2 일 때 x1, x2...xD 그래프에 초평면을 그릴 수 있습니다.\n\n이 초평면은 w · x + b = 0으로 설명할 수 있습니다. 여기서:\n\n<div class=\"content-ad\"></div>\n\n- w는 초평면에 수직입니다.\n- b/||w||은 초평면으로부터 원점까지의 수직 거리입니다.\n\n서포트 벡터(Support Vectors)는 분리 초평면에 가장 가까운 예제들을 의미하며, 서포트 벡터 머신(SVM)의 목표는 이 초평면을 가능한 한 두 클래스의 가장 가까운 멤버와 멀리떨어지도록 방향을 조절하는 것입니다.\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_2.png)\n\n그림 1을 참조하면, SVM을 구현하는 것은 변수 w와 b를 선택하여 학습 데이터를 아래와 같이 설명할 수 있도록 하는 것으로 요약됩니다:\n\n<div class=\"content-ad\"></div>\n\n- xi · w + b ≥ +1 for yi = +1\n- xi · w + b ≤ −1 for yi = −1\n\n이러한 방정식은 다음과 같이 결합될 수 있습니다:\n\nyi(xi · w + b) − 1 ≥ 0 ∀i\n\n이제 분리 초평면에 가장 가까이 있는 점, 즉 서포트 벡터(도표에서 원으로 표시됨)만 고려한다면, 이 점이 있는 두 평면 H1과 H2는 다음과 같이 나타낼 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n표를 마크다운 형식으로 변경해주세요.\n\n\n| xi · w + b = +1 for H1 |\n|------------------------|\n| xi · w + b = −1 for H2 |\n\nFigure 1을 참고하여, d1은 H1로부터 초평면까지의 거리를 나타내고, d2는 H2로부터의 거리를 나타냅니다. H1과 H2로부터의 초평면의 등거리는 d1 = d2로 정의되며, 이를 SVM의 여백이라고 합니다. 초평면을 가능한 한 Support Vectors로부터 최대한 멀리 위치시키기 위해 이 여백을 최대화해야 합니다.\n\n간단한 벡터 기하학에 따르면, 여백은 (1/||w||)와 같고, 이를 최대화하기 위해서는 (1.3)의 제약 조건 하에 찾아야 할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![TinyMLSupportVectorMachinesClassifier_3](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_3.png)\n\nkwk을 최소화하는 것은 (0.5*||w||²)을 최소화하는 것과 동일한 것이며, 이 용어의 사용은 나중에 이차 프로그래밍(QP) 최적화를 수행할 수 있게 합니다. 따라서 우리는 다음을 찾아야 합니다:\n\n![TinyMLSupportVectorMachinesClassifier_4](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_4.png)\n\n이 최소화의 제약 사항을 고려하기 위해 Lagrange 배수 α를 할당해야 합니다. 여기서 αi ≥ 0 ∀i 여야 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_5.png)\n\n우리는 최소화하는 w와 b 및 최대화하는 α를 찾고 싶습니다 (αi ≥ 0 ∀i를 유지하면서). 이를 위해 LP를 w와 b에 대해 미분하여 도함수를 0으로 설정할 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_6.png)\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_7.png)\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_8.png)\n\n이 새로운 제약 조건 LD는 주 기본 LP의 이중 형식으로 참조됩니다. 중요한 점은 이 이중 형식이 각 입력 벡터 xi의 내적만 계산하면 되므로 커널 트릭에서 중요하다는 점입니다.\n\nLP를 최소화하는 것에서 LD를 최대화하는 것으로 전환한 후, 우리는 다음을 찾아야 합니다:\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_9.png)\n\n\n<div class=\"content-ad\"></div>\n\n이것은 볼록 이차 최적화 문제이며 QP 솔버를 실행하여 α를 반환하고 (1.10)로부터 w를 제공받습니다. 남은 것은 b를 계산하는 것입니다.\n\n(1.11)을 만족하는 어떤 데이터 포인트는 지지 벡터 xs가 될 것이며 다음과 같은 형식을 갖습니다:\n\n![Support Vector](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_10.png)\n\n(1.10)을 대입하는 것입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_11.png)\n\n서포트 벡터의 지수 집합을 나타내는 S입니다. S는 αi ` 0인 지수 i를 찾아 결정됩니다. ys로 곱하고 (1.1) 및 (1.2)에서 ys² = 1을 사용하여:\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_12.png)\n\n임의의 서포트 벡터 xs를 사용하는 대신, S에 속하는 모든 서포트 벡터를 평균하는 것이 더 나은 방법입니다.\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_13.png)\n\n우리는 이제 서포트 벡터 머신을 정의하는 분리 초평면의 최적 방향을 결정하는 변수 w와 b를 가지고 있습니다.\n\n## 1.2 — 선형적으로 분리되지 않는 데이터의 분류\n\n완전히 선형적으로 분리되지 않는 데이터를 다룰 수 있도록 SVM 방법론을 확장하기 위해 (1.1)과 (1.2)의 제약 조건을 약간 완화하여 잘못 분류된 포인트를 허용합니다. 이는 긍정적인 slack 변수 ξi, i = 1, . . . L을 도입함으로써 수행됩니다:\n\n<div class=\"content-ad\"></div>\n\n아래의 내용을 다음과 같이 결합할 수 있어요:\n\n\n![img](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_15.png)\n\n![img](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_16.png)\n\n\n<div class=\"content-ad\"></div>\n\n이 소프트 마진 SVM에서, 마진 경계의 잘못된 쪽에 있는 데이터 포인트는 그로부터의 거리에 따라 증가하는 패널티를 받습니다. 우리는 오분류의 수를 줄이려고 하기 때문에, 이전의 목적 함수(1.6)를 적응하기 위한 합리적인 방법은 다음과 같습니다:\n\n![그림](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_17.png)\n\n여기서 매개변수 C는 여유 변수의 패널티와 마진의 크기 사이의 교환을 제어합니다. 라그랑지안으로 재정립하는 것은, w, b 및 ξi에 대해 최소화하고 α에 대해 최대화해야하는 함수를 찾아야 합니다 (여기서 αi ≥ 0, µi ≥ 0 ∀i):\n\n![그림](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_18.png)\n\n<div class=\"content-ad\"></div>\n\nw, b 및 ξi에 대해 미분하고 도함수를 0으로 설정합니다:\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_19.png)\n\n이를 대입하면, LD는 이전의 (1.14)와 동일한 형식을 가집니다. 그러나 (2.9)와 µi ≥ 0 ∀i 함께하면, α ≥ C를 함의합니다. 따라서 우리는 다음을 찾아야 합니다:\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_20.png)\n\n<div class=\"content-ad\"></div>\n\n그런 후에 b는 (1.6)과 동일한 방법으로 계산됩니다. 그러나 이 경우 b를 계산하기 위해 사용된 Support Vectors 집합은 0 ` αi ` C인 i의 인덱스를 찾아 결정됩니다.\n\n# 2. 하이퍼파라미터 조정: 커널, 정규화, 감마 및 마진.\n\n## 2.1 — 커널\n\n선형 분리 가능한 데이터에 SVM을 적용할 때 입력 변수의 내적으로 행렬 H를 생성하는 방식부터 시작했습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_21.png)\n\nk(xi, xj)는 Kernel Functions라는 함수 패밀리의 예시입니다 (k(xi, xj) = (xi^T)*(xj)가 선형 커널로 알려져 있습니다). 커널 함수의 집합은 두 벡터의 내적을 계산하는 것을 기반으로 하고 있어서 (4.2)의 변형으로 구성되어 있습니다. 이것은 함수들이 어떤 잠재적으로 비선형 특징 매핑 함수 x → φ(x)에 의해 더 높은 차원의 공간으로 다시 구성될 수 있다는 것을 의미합니다. 이는 매핑된 입력들의 내적만 계산하면 되기 때문에 우리는 명시적으로 φ를 계산할 필요가 없다는 것을 뜻합니다.\n\n이 커널 트릭이 유용한 이유는 입력 x의 공간에서 선형적으로 분류/회귀할 수 없는 많은 문제들이 존재하기 때문입니다. 이는 적합한 매핑 x→ φ(x)가 주어진 상태에서 더 높은 차원의 특징 공간에 있을 수 있기 때문입니다.\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_22.png)\n\n\n<div class=\"content-ad\"></div>\n\nFigure 3를 참조하면, 우리가 우리의 커널을 다음과 같이 정의한다면:\n\n![Kernel](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_23.png)\n\n그러면 2차원 데이터 공간 x에서 선형적으로 분리되지 않는 데이터 집합(그림 3의 좌측)은 이 비선형 커널 함수에 의해 암시적으로 정의된 비선형 피처 공간(그림 3의 우측)에서 분리될 수 있습니다. 이 커널 함수는 Radial Basis Kernel로 알려져 있습니다.\n\n분류 및 회귀를 위한 다른 인기 있는 커널로는 다항식 커널이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 [TinyMLSupportVectorMachinesClassifier_24.png] 이미지가 있는 표입니다.\n\n![TinyMLSupportVectorMachinesClassifier_24.png](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_24.png)\n\n아래는 Markdown 형식으로 [TinyMLSupportVectorMachinesClassifier_25.png] 이미지가 있는 표입니다.\n\n![TinyMLSupportVectorMachinesClassifier_25.png](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_25.png)\n\n여기서 a와 b는 커널의 동작을 정의하는 매개변수입니다.\n\n## 2.2 — 정규화\n\n<div class=\"content-ad\"></div>\n\n정규화 매개변수(파이썬의 sklearn 라이브러리에서 C 매개변수로 자주 표현됨)는 SVM 최적화에 각 훈련 예제를 잘못 분류하고 싶지 않은 정도를 알려줍니다.\n\nC 값이 큰 경우 최적화는 모든 훈련 포인트를 올바르게 분류하는 더 나은 작은 마진의 초평면을 선택할 것입니다. 반대로, C 값이 매우 작으면 옵티마이저는 더 큰 마진 분리 초평면을 찾아 더 많은 포인트를 잘못 분류하더라도 선택할 것입니다.\n\n아래 이미지는 두 가지 다른 정규화 매개변수의 예시입니다. 왼쪽 이미지는 낮은 정규화 값으로 인해 일부 오분류가 있습니다. 높은 값은 오른쪽 이미지와 같은 결과를 낳습니다.\n\n<div class=\"content-ad\"></div>\n\n## 2.3 — 감마\n\n감마 매개변수는 단일 학습 예제의 영향이 얼마나 멀리 미치는지를 정의하며, 낮은 값은 '멀리', 높은 값은 '가까이'를 의미합니다. 다시 말해, 낮은 감마 값에서는 확실한 분리 선에서 멀리 떨어진 점들이 분리 선 계산에 고려됩니다. 반면 높은 감마는 분리 선에 가까운 점들이 계산에 고려된다는 것을 의미합니다.\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_27.png)\n\n## 2.4 — 여백\n\n<div class=\"content-ad\"></div>\n\n표 태그를 Markdown 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n!pip install micromlgen\n```\n\n2. 라이브러리 가져오기\n\n```js\nfrom micromlgen import port\nimport pandas as pd\nimport plotly.graph_objects as go\nimport numpy as np\nimport plotly.express as px\n```\n\n```js\nfrom sklearn.svm import SVC\nfrom sklearn.calibration import LabelEncoder\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import metrics\n```\n\n<div class=\"content-ad\"></div>\n\n3 - 데이터셋 로드\n\n아이리스 데이터셋은 머신 러닝과 통계 분야에서 고전적인 데이터셋입니다. 이는 1936년 Sir Ronald A. Fisher에 의해 도입되었으며 판별 분석의 예시로 사용되었습니다. 이 데이터셋은 교육 목적으로 자주 사용되며 패턴 분류 실습의 일반적인 시작 지점입니다.\n\n속성:\n\n- 꽃받침 길이 (센티미터)\n- 꽃받침 너비 (센티미터)\n- 꽃잎 길이 (센티미터)\n\n<div class=\"content-ad\"></div>\n\n종:\n\n- 0 — 세토사\n- 1 — 버시컬러\n\n```js\n# 아이리스 데이터셋 불러오기\ndata = load_iris()\n```\n\n```js\n# 데이터프레임 생성\ndf_iris = pd.DataFrame(data.data, columns=data.feature_names)\n```\n\n<div class=\"content-ad\"></div>\n\n```js\n# DataFrame에 대상 변수를 추가합니다\ndf_iris['target'] = data.target\n```\n\n```js\n# NaN 값을 제거합니다\ndf = df_iris.dropna(axis='rows') # NaN 제거\n```\n\n```js\n# DataFrame을 표시합니다\nprint(df_iris.head())\n```\n\n```js\ndf = df_iris.iloc[:100, 1:4]\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nX=df.to_numpy()\n```\n\n```js\n# 레이블을 정수 유형으로 변환합니다: Setosa = 0, Versicolor = 1\ny=df_iris.iloc[:100,-1]\ny = LabelEncoder().fit_transform(y)\n```\n\n4 - 데이터셋 시각화\n\n```js\nfig = go.Figure()\n```\n\n<div class=\"content-ad\"></div>\n\n\n```js\nfig.add_trace(go.Scatter3d(x=df['sepal width (cm)'], y= df['petal length (cm)'], z=df['petal width (cm)'], mode='markers', marker=dict(color='blue')))\n```\n\n```js\nfig.update_layout(scene=dict(xaxis_title='꽃 받침 길이 (cm)', yaxis_title='꽃 받침 너비 (cm)', zaxis_title='꽃 잎 너비 (cm)'),\n                  scene_camera=dict(eye=dict(x=1.87, y=0.88, z=-0.64)),\n                  width=1000, height=600)\n```\n\n<img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_29.png\" />\n\n5 — 훈련 및 테스트 데이터로 분할\n\n\n<div class=\"content-ad\"></div>\n\n```js\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n```\n\n6. Create the classification model\n\n```js\nmodel = SVC(gamma=0.0000001, kernel='linear')\n```\n\n7. Train the model\n\n\n<div class=\"content-ad\"></div>\n\n```js\nmodel.fit(X_train, y_train)\n```\n\n8 — 훈련 데이터를 사용하여 모델 평가\n\n```js\ntraining_predict = model.predict(X_train)\n```\n\n```js\nprint(metrics.classification_report(y_train, training_predict, digits = 3))\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_30.png\" />\n\n```js\nprint(metrics.confusion_matrix(y_train, training_predict))\n```\n\n<img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_31.png\" />\n\n```js\nprint(f'Model accuracy: {round(metrics.accuracy_score(y_train, training_predict)*100,2)}%')\n```\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_32.png)\n\n9 — Hyperlane Train Data Visualization\n\n```js\nx_grid, y_grid = np.meshgrid(np.linspace(X_train[:, 0].min(), X_train[:, 0].max(), 100),\n                             np.linspace(X_train[:, 1].min(), X_train[:, 1].max(), 100))\nz_grid = np.zeros_like(x_grid)\n```\n\n```js\nfor i in range(len(x_grid)):\n    for j in range(len(y_grid)):\n        z_grid[i, j] = model.decision_function([[x_grid[i, j], y_grid[i, j], 0]])\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nfig = go.Figure()\n```\n\n```js\nfig.add_trace(go.Scatter3d(x=X_train[:, 0], y=X_train[:, 1], z=X_train[:, 2], mode='markers',\n                           marker=dict(size=5, color=y_train, opacity=0.7), name='Training Data'))\n```\n\n```js\nfig.add_trace(go.Surface(z=z_grid, x=x_grid, y=y_grid, opacity=0.5, colorscale='Bluered_r'))\n```\n\n```js\nfig.update_layout(scene=dict(xaxis_title='Sepal Width (cm)',\n                             yaxis_title='Petal Length (cm)',\n                             zaxis_title='Petal Width (cm)'))\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nfig.update_layout(width=1000, height=600)\n```\n\n```js\nfig.show()\n```\n\n<img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_33.png\" />\n\n10 — 테스트 데이터로 모델 평가하기\n\n<div class=\"content-ad\"></div>\n\n```js\ntest_predict = model.predict(X_test)\n```\n\n```js\nprint(metrics.classification_report(y_test, test_predict, digits = 3))\n```\n\n![Image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_34.png)\n\n```js\nprint(metrics.confusion_matrix(y_test, test_predict))\n```\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_35.png)\n\n```js\nprint(f'모델 정확도: {round(metrics.accuracy_score(y_test, test_predict)*100,2)}%')\n```\n\n![image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_36.png)\n\n11 — 하이퍼플레인 테스트 데이터 시각화\n\n\n<div class=\"content-ad\"></div>\n\n```js\nx_grid, y_grid = np.meshgrid(np.linspace(X_test[:, 0].min(), X_test[:, 0].max(), 100),\n                             np.linspace(X_test[:, 1].min(), X_test[:, 1].max(), 100))\nz_grid = np.zeros_like(x_grid)\n```\n\n```js\nfor i in range(len(x_grid)):\n    for j in range(len(y_grid)):\n        z_grid[i, j] = model.decision_function([[x_grid[i, j], y_grid[i, j], 0]])\n```\n\n```js\nfig = go.Figure()\n```\n\n```js\nfig.add_trace(go.Scatter3d(x=X_test[:, 0], y=X_test[:, 1], z=X_test[:, 2], mode='markers',\n                           marker=dict(size=5, color=y_test), name='Training Data'))\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nfig.add_trace(go.Surface(z=z_grid, x=x_grid, y=y_grid, opacity=0.5, colorscale='Bluered_r'))\n```\n\n```js\nfig.update_layout(scene=dict(xaxis_title='꽃받침 너비 (cm)',\n                             yaxis_title='꽃잎 길이 (cm)',\n                             zaxis_title='꽃잎 너비 (cm)'))\n```\n\n```js\nfig.update_layout(width=1000, height=600)\n```\n\n```js\nfig.show()\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_37.png\" />\n\n12 — 마이크로컨트롤러에 구현될 모델 얻기\n\n```js\nprint(port(model))\n```\n\n```cpp\n#pragma once\n#include <cstdarg>\nnamespace Eloquent {\n    namespace ML {\n        namespace Port {\n            class SVM {\n                public:\n                    /**\n                    * 특징 벡터에 대한 클래스 예측\n                    */\n                    int predict(float *x) {\n                        float kernels[3] = { 0 };\n                        float decisions[1] = { 0 };\n                        int votes[2] = { 0 };\n                        kernels[0] = compute_kernel(x,   3.4  , 1.9  , 0.2 );\n                        kernels[1] = compute_kernel(x,   3.3  , 1.7  , 0.5 );\n                        kernels[2] = compute_kernel(x,   2.4  , 3.3  , 1.0 );\n                        float decision = -0.833910342285;\n                        decision = decision - ( + kernels[0] * -0.31945543931  + kernels[1] * -0.240101867421 );\n                        decision = decision - ( + kernels[2] * 0.559557306731 );\n                        return decision > 0 ? 0 : 1;\n                    }\n                protected:\n                    /**\n                    * 특징 벡터와 서포트 벡터 사이의 커널 계산.\n                    * 커널 유형: 선형\n                    */\n                    float compute_kernel(float *x, ...) {\n                        va_list w;\n                        va_start(w, 3);\n                        float kernel = 0.0;\n                        for (uint16_t i = 0; i < 3; i++) {\n                            kernel += x[i] * va_arg(w, double);\n                        }\n                        return kernel;\n                    }\n                };\n            }\n        }\n    }\n```\n\n<div class=\"content-ad\"></div>\n\n다음은 테이블 태그를 마크다운 형식으로 변경합니다.\n\n13 — .h 파일에 템플릿을 저장합니다\n\n```js\nwith open('./SVMClassifier/SVMClassifier.h', 'w') as file:\n    file.write(port(model))\n```\n\n14 — 아두이노 스케치 완료\n\n아래와 같이 아두이노 스케치에 \"SVMClassifier.h\" 파일을 포함하세요:\n\n<div class=\"content-ad\"></div>\n\n\n```js\n#include \"SVMClassifier.h\"\n```\n\n```js\nEloquent::ML::Port::SVM classifier;\n```\n\n```js\nvoid setup() {\n  Serial.begin(115200);\n```\n\n\n<div class=\"content-ad\"></div>\n\n```js\nvoid loop() {\n  float X_1[] = {3.6, 1. , 0.2};\n  int result_1 = classifier.predict(X_1);\n  Serial.print(\"Result of predict with input X1:\");\n  Serial.println(result_1);\n  delay(2000);\n```\n\n```js\nfloat X_2[] = {2.9, 4.7, 1.4};\n  int result_2 = classifier.predict(X_2);\n  Serial.print(\"Result of predict with input X2:\");\n  Serial.println(result_2); \n  delay(2000);\n```\n\n```js\n}\n```\n\n결과:\n\n<div class=\"content-ad\"></div>\n\n0 — 셋토사 — 입력: '3.6, 1. , 0.2'\n\n1 — 버시컬러 — 입력: '2.9, 4.7, 1.4'\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_38.png)\n\n👀😲(보너스) 하이퍼파라미터 튜닝\n\n<div class=\"content-ad\"></div>\n\nRandomizedSearchCV는 Python의 scikit-learn 라이브러리에서 제공하는 함수로, 머신 러닝 모델의 하이퍼파라미터 튜닝을 위해 일반적으로 사용됩니다. 이 기술은 하이퍼파라미터의 다양한 값을 탐색할 때 유용하며, 가장 효과적인 조합을 식별하는 것을 목표로 합니다.\n\na) 파라미터 공간의 정의:\n\nRandomizedSearchCV를 활용하기 전에, 모델의 하이퍼파라미터를 위한 탐색 공간을 지정해야 합니다. 특정 값의 그리드를 제공하는 대신, 각 하이퍼파라미터에 대해 분포가 정의됩니다.\n\nb) 랜덤 샘플링:\n\n<div class=\"content-ad\"></div>\n\n예를 들어 GridSearchCV의 모든 가상 하이퍼파라미터 조합을 평가하는 대신, RandomizedSearchCV은 평가를 위해 일정한 하이퍼파라미터 조합을 무작위로 선택합니다. 이는 큰 탐색 공간을 다룰 때 유리합니다.\n\nc) 모델 훈련:\n\n무작위로 선택된 각 하이퍼파라미터 세트에 대해 RandomizedSearchCV는 교차 검증을 사용하여 모델을 훈련시킵니다. 데이터는 폴드로 나뉘며, 모델은 일부 폴드에서 훈련을 받고 나머지 폴드에서 평가를 받습니다.\n\nd) 성능 평가:\n\n<div class=\"content-ad\"></div>\n\n성능은 지정된 메트릭(예: 정확도, F1 점수)을 사용하여 측정됩니다. 목표는 주어진 문제에 따라 이 메트릭을 최대화하거나 최소화하는 하이퍼파라미터를 찾는 것입니다(예: 분류 문제에서 정확도를 최대화).\n\ne) 최적 모델 선택:\n\n랜덤 탐색이 완료되면, RandomizedSearchCV는 교차 검증 중 최상의 평균 성능을 보인 하이퍼파라미터 세트를 반환합니다.\n\nRandomizedSearchCV를 사용하면, 특히 큰 탐색 공간을 다룰 때 모든 가능한 조합을 평가하는 완전한 그리드 탐색(GridSearchCV)과 비교하여 계산 시간을 절약할 수 있습니다. 이 효율성은 모든 가능한 조합을 평가하는 대신 하이퍼파라미터 공간의 무작위 샘플을 탐색하는 데서 오게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n1. **라이브러리 가져오기**\n\n```python\nfrom sklearn.metrics import make_scorer, roc_auc_score\nfrom sklearn.model_selection import RandomizedSearchCV\n```\n\n2. **파라미터 조합을 위한 그리드 탐색 설정**\n\n```python\nparams = {\n    \"C\": np.arange(2, 10, 2),\n    \"gamma\": np.arange(0.1, 1, 0.01),\n    \"kernel\": ['rbf', 'linear', 'poly']}\n```\n\n<div class=\"content-ad\"></div>\n\n3- 성능 측정 지표 정의\n\n```js\nauc = make_scorer(roc_auc_score)\n```\n\n4- 최적 모델을 탐색합니다.\n\n```js\nbest_model = RandomizedSearchCV(model, param_distributions=params, random_state=42, n_iter=200, cv=3, verbose=1, n_jobs=1, return_train_score=True, scoring = auc)\nbest_model.fit(X_train, y_train)\n```\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_39.png)\n\n5-가장 좋은 모델 보고\n\n```python\ndef report_best_scores(results, n_top=3):\n    for i in range(1, n_top + 1):\n        candidates = np.flatnonzero(results['rank_test_score'] == i)\n        for candidate in candidates:\n            print(\"순위가 {0}인 모델\".format(i))\n            print(\"평균 검증 점수: {0:.3f} (표준편차: {1:.3f})\".format(\n                results['mean_test_score'][candidate],\n                results['std_test_score'][candidate]))\n            best_params = results['params'][candidate]\n            print(\"찾은 최적 파라미터:\")\n            for param, value in best_params.items():\n                print(\"  {0}: {1}\".format(param, value))\n            print(\"\")\n```\n\n```python\nreport_best_scores(best_model.cv_results_, 1)\n```\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_40.png)\n\nFull project in: [TinyML/05_support_vector_machine](https://github.com/thommaskevin/TinyML)\n\nReferences:\n\nFLETCHER, Tristan. Support vector machines explained. Tutorial paper, p. 1–19, 2009.\n","ogImage":{"url":"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_0.png"},"coverImage":"/assets/img/2024-06-19-TinyMLSupportVectorMachinesClassifier_0.png","tag":["Tech"],"readingTime":19},{"title":"프로젝트 ProxyMity","description":"","date":"2024-06-19 02:24","slug":"2024-06-19-projectproxymity","content":"\n\n프록시는 비디오 회의를 더 다이내믹하고 상호작용적으로 만들기 위해 설계된 가정용 로봇입니다. 프록시를 독특하게 만드는 것은 AI 비전 제어 메커니즘입니다. 이를 통해 사용자(나!)는 포즈 추정을 통해 로봇을 손을 사용하지 않고 제어할 수 있습니다. 이는 손짓만으로 로봇을 움직일 수 있기 때문에 경험이 더 자연스럽고 몰입적입니다.\n\n![프록시](https://miro.medium.com/v2/resize:fit:586/1*IQupuSWM3MV_m_Xn3BHCnQ.gif)\n\n## 프록시의 주요 기능\n\n- 손을 사용하지 않는 제어: 프록시는 AI 비전을 사용하여 손짓을 이해하고 로봇을 제어합니다. 이를 통해 전통적인 컨트롤러가 필요하지 않아 탐색과 상호작용이 더 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n* **실시간 연결:** Proxy는 세계 어디에서나 실시간으로 제어할 수 있습니다. 예를 들어, 캘리포니아에 있는 누군가가 인도의 Proxy를 쉽게 작동시켜 매끄러운 통신을 보장할 수 있습니다.\n\n* **비디오 통화의 추가 차원:** 전통적인 비디오 통화와는 달리, Proxy를 사용하면 원격 위치 주변을 자유롭게 이동할 수 있습니다. 이는 비디오 회의에 새로운 차원을 더해 상호작용을 더욱 매력적이고 실감나게 만들어줍니다. 가상 가족 모임에 참석할 때와 같이, Proxy를 통해 원격 위치에서 좀 더 존재하는 느낌을 받을 수 있습니다.\n\n# 프로토타입 구축\n\nProxy를 만들기 시작한 것은 몇 가지 도전에 대처하기 위한 프로토타입을 만드는 것으로 시작했습니다.\n\n<div class=\"content-ad\"></div>\n\n- 안정성: 로봇이 균형을 유지하고 안정적인 상태를 유지할 수 있도록 하는 것.\n- 민첩성과 제어: 로봇이 명령에 빠르고 정확하게 반응할 수 있도록 하는 것.\n- 네트워크 연결: 인터넷 연결의 간헐적인 문제를 처리하여 원활한 운영을 보장하는 것.\n\n프로토타입은 이러한 주요 측면을 증명한 후 로봇의 디자인을 개선하기로 이동했습니다.\n\n# 창의적인 구성\n\n프록시를 구축하는 데 일반 가정용품을 사용하여 로봇을 구축할 수 있다는 것을 보여주었습니다.\n\n<div class=\"content-ad\"></div>\n\n- 샤시: 목재 복합 패널과 엔드 테이블로 만들어졌어요.\n- 인터넷 연결: 오래된 랩탑을 활용했습니다.\n- 비디오 디스플레이: 표준 모니터를 사용했어요.\n- 웹캠: 메타의 Portal TV가 웹캠으로 사용되었지만 호환 가능한 웹캠이라면 어떤 것이든 작동할 거에요.\n- 전원 공급원: 끊김 없는 전원 공급장치(UPS)로 전원을 공급했어요.\n\n# 도전 극복하기\n\n중요한 도전 중 하나는 네트워크 중단을 처리할 수 있는 제어 시스템을 만드는 것이었어요. 시스템은 다음이 필요했어요:\n\n- 실시간으로 제어 신호를 변환하는 것.\n- 신호 중단을 감지하고 로봇을 적절하게 일시 정지시키는 것.\n- 일시적 및 지속적인 네트워크 문제를 구별하여 부드러운 사용자 경험을 보장하는 것.\n\n<div class=\"content-ad\"></div>\n\n# 개인적인 연결 향상하기\n\nProxy의 비디오 통화 중 이동 기능은 세계 각지에 사랑하는 사람들과 더 가깝게 유지할 수 있도록 도와줍니다. 이 추가된 이동성은 상호작용을 더 개인적이고 매력적으로 만듭니다.\n\n요약하면, Proxy는 원격지간 비디오 회의 경험을 변화시키는 솔루션입니다. 이동성과 무전원 제어를 추가함으로써 Proxy는 연결과 상호작용의 새로운 수준을 제공하여 원격 통신을 더 현실적이고 개인적으로 느끼게 합니다. \n\n테이블 태그를 Markdown 형식으로 바꿔주시겠어요?\n\n<div class=\"content-ad\"></div>\n\nPart I — AI 비전 제어\n\nPart II — 신호 전달\n\nPart III — 로봇 제어 메커니즘","ogImage":{"url":"/assets/img/2024-06-19-projectproxymity_0.png"},"coverImage":"/assets/img/2024-06-19-projectproxymity_0.png","tag":["Tech"],"readingTime":2},{"title":"작고 강력한 TinyML  가우시안 혼합 모델","description":"","date":"2024-06-19 02:22","slug":"2024-06-19-TinyMLGaussianMixtureModel","content":"\n\n수학적 기초부터 엣지 구현까지\n\n# 소셜 미디어:\n\n👨🏽‍💻 Github: thommaskevin/TinyML (github.com)\n👷🏾 Linkedin: Thommas Kevin | LinkedIn\n📽 Youtube: Thommas Kevin — YouTube\n👨🏻‍🏫 연구 그룹: Conecta.ai (ufrn.br)\n\n![이미지](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_0.png)\n\n<div class=\"content-ad\"></div>\n\n## 개요\n\n# 1 — 가우시안 혼합 모델 이론\n\n가우시안 혼합 모델(GMM)은 넓은 인구군 내에서 정규 분포를 따르는 하위 그룹을 묘사하기 위한 확률적인 프레임워크로 작용합니다. 기존의 모델과는 달리 혼합 모델은 데이터 점이 어떤 특정 하위 그룹에 속하는지를 확인할 필요가 없으며, 이러한 하위 그룹들을 자율적으로 학습할 수 있습니다. 이러한 특성으로 인해 GMM은 비지도 학습의 우수한 예시로 인식됩니다.\n\n예를 들어, 사람들의 키 데이터를 모델링한다고 가정해 봅시다. 일반적으로, 키는 성별별로 정규 분포로 모델링되며, 남성은 평균적으로 약 5`10\"이고 여성은 5`5\"입니다. 개별 데이터 포인트의 성별 할당을 미리 알 수 없는 경우, 모든 키의 분포는 두 개의 정규 분포의 결합으로 개념화됩니다. 각각 다르게 스케일되고(서로 다른 분산을 가짐) 이동(다른 평균을 가짐)된 두 개의 정규 분포를 포함하는 모델은 가우시안 혼합 모델(GMM)의 예시입니다. 물론, GMM은 두 가지 이상의 구성 요소를 포함할 수 있습니다. GMM을 데이터 모델링에 사용할 때, 개별 정규 분포 구성 요소의 매개변수를 추정하는 것이 핵심적인 도전입니다.\n\n<div class=\"content-ad\"></div>\n\nGMM은 음성 데이터에서의 특징 추출을 포함한 다양한 분야에서 응용 프로그램을 찾습니다. 또한 GMM은 여러 객체가 포함된 객체 추적 시나리오에서 널리 사용됩니다. 이러한 경우에서 혼합 구성 요소의 수와 각각의 평균은 비디오 시퀀스 내 각 프레임에서 객체 위치를 예측하는 데 도움이 됩니다.\n\n## 1.1 — 수학적 기초\n\n가우시안 혼합 모델은 두 세트의 매개변수로 특징 지어집니다: 혼합 구성 요소 가중치 및 구성 요소 평균 및 분산/공분산. K개의 구성 요소가 있는 가우시안 혼합 모델의 경우, k번째 구성 요소는 1차원 경우 μk의 평균과 (σ_k)²의 분산, 다변량 경우에는 평균 벡터 μk와 공분산 행렬 Σk를 가집니다. 혼합 구성 요소 가중치는 구성 요소 Ck에 대한 ϕk로 표시되며 다음 제약 조건을 갖습니다\n\n![image](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_1.png)\n\n<div class=\"content-ad\"></div>\n\n만약 구성 요소의 가중치가 학습되지 않은 경우, 그들은 구성 요소에 대한 사전 분포로 해석될 수 있으며, 데이터 점 x가 구성 요소 Ck에 의해 생성될 확률인 ϕk로 표현될 수 있습니다. 그러나 학습된 경우, 그들은 데이터를 통해 주어진 구성 요소 확률의 사후 추정치를 나타냅니다.\n\n가우시안 혼합 모델의 확률 밀도 함수 p(x)는 다음과 같이 표현될 수 있습니다:\n\n![image](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_2.png)\n\n<div class=\"content-ad\"></div>\n\n아래에 표가 있습니다:\n\n- N(x∣μi,σi)은 평균이 μi이고 표준편차가 σi인 i번째 가우시안 구성 요소의 확률 밀도 함수를 나타냅니다.\n- ϕi는 i번째 구성 요소와 관련된 가중치입니다.\n\n가우시안 확률 밀도 함수를 대체하면:\n\n<div class=\"content-ad\"></div>\n\n확률의 합이 11이 되도록 확인하였습니다:\n\n![이미지](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_4.png)\n\n## 1.2 — 모델\n\n혼합 모델의 구성 요소 K가 알려진 경우, 기대 최대화 (EM)는 모델의 매개변수를 추정하는 데 사용되는 주요 기술입니다. 빈도론적 확률 이론에서 모델은 일반적으로 최대 우도 추정 방법을 통해 학습됩니다. 이러한 방법은 모델 매개변수가 주어진 경우 데이터를 관찰할 가능성 또는 확률을 최대화하기 위해 노력합니다. 그러나 혼합 모델에 대한 최대 우도 솔루션을 로그 우도의 미분을 통해 얻고 영의 값을 구하는 것은 흔히 분석적으로 불가능합니다.\n\n<div class=\"content-ad\"></div>\n\nExpectation maximization (EM)는 최대 우도 추정을 위한 수치적 접근을 제공합니다. 해당 방법은 모델 파라미터를 업데이트하는 닫힌 형식의 표현이 유도될 때 사용됩니다. EM은 각 반복에서 데이터의 최대 우도가 꾸준히 향상되는 유리한 특성을 갖는 반복적인 알고리즘입니다. 이러한 특성은 알고리즘이 지역 최댓값 또는 안장점으로 수렴하게 함을 보장합니다.\n\n## 1.2.1— 가우시안 혼합 모델에 대한 EM\n\n혼합 모델의 Expectation maximization (EM)은 두 가지 반복 단계로 구성됩니다:\n\n- Expectation 단계 (E 단계): 이 단계에서 알고리즘은 현재의 모델 파라미터인 ϕk, μk, σk를 고려하여 각 데이터 지점 xi에 대한 구성 요소 할당의 기대값 p(Ck∣xi)을 계산합니다.\n- Maximization 단계 (M 단계): 이 단계는 E 단계에서 계산된 기대값을 모델 파라미터에 대해 최대화하는 것을 포함합니다. 이는 ϕk, μk, σk의 값을 업데이트하는 것을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n반복적인 과정은 알고리즘이 수렴할 때까지 계속되며 최대 우도 추정치를 생성합니다. 이 알고리즘의 합리적인 근거는 구성 요소 할당인 p(Ck∣xi)를 알고 있으면 ϕk, μk, σk를 해결하는 작업을 단순화하고, 이러한 매개변수를 알면 p(Ck∣xi)의 추론을 용이하게 합니다. E 단계는 후자의 경우에 해당하며, M 단계는 전자에 해당합니다. 특정 값을 고정된 값이나 이미 알려진 값으로 처리하며 알고리즘은 미지의 매개변수의 최대 우도 추정치를 효율적으로 계산합니다.\n\n## 1.2.2 — 단변량 가우시안 혼합 모델을 위한 알고리즘\n\n단변량 가우시안 혼합 모델에 대한 Expectation-Maximization (EM) 알고리즘은 다음과 같이 진행됩니다:\n\n![이미지](https://miro.medium.com/v2/resize:fit:720/0*UFmfHWAXR3iI-xz5.gif)\n\n<div class=\"content-ad\"></div>\n\n- 초기화: 데이터를 기반으로 모델 매개변수 ϕk, μk 및 σk를 합리적인 값으로 초기화합니다.\n- 반복적인 E 단계: 각 데이터 점 xi에 대해 현재 매개변수 추정치를 사용하여 각 구성 요소 Ck에 대한 사후 확률 p(Ck∣xi)를 계산합니다:\n\n![image](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_5.png)\n\n- 반복적인 M 단계: 계산된 사후 확률을 기반으로 매개변수 추정치 ϕk, μk 및 σk를 업데이트합니다:\n\n![image](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_6.png)\n\n<div class=\"content-ad\"></div>\n\n- 수렴 확인: 매개변수 추정치가 수렴할 때까지 E 단계와 M 단계를 반복합니다. 즉, 모든 매개변수 θ^t에 대해 ∣θ^t−θ^t−1∣≤ϵ이 될 때까지 반복합니다. 여기서 ϵ은 사용자가 정의한 허용 오차입니다.\n\nEM 알고리즘은 E와 M 단계 사이를 반복하면서 수렴합니다. 이는 모델 매개변수의 최대 우도 추정치를 얻습니다. 이 프로세스는 두 성분으로 구성된 이차 가우시안 혼합 모델을 나타내는 그림 우측에 그래픽으로 표시되어 있습니다.\n\n## 1.3— 평가 방법\n\n지도 학습과 달리 군집 분석에는 다양한 군집화 알고리즘의 결과를 평가하는 데 적용할 수 있는 견고한 평가 메트릭이 부족합니다.\n\n<div class=\"content-ad\"></div>\n\n## 1.3.1 - Likelihood Ratio Test\n\n우도비 검정 (Likelihood Ratio Test, LRT)은 클러스터링 모델의 맥락에서도 적용할 수 있으며, 서로 다른 클러스터링 솔루션의 적합성을 비교하는 데 사용될 수 있습니다. \n\nk개 클러스터를 갖는 하나의 클러스터링 솔루션(더 간단한 모델)과 k+1개 클러스터를 갖는 다른 클러스터링 솔루션(더 복잡한 모델)이 있다고 가정해 보겠습니다. LRT를 사용하여 더 복잡한 모델이 더 간단한 모델에 비해 데이터 적합성을 유의하게 향상시키는지 확인할 수 있습니다.\n\n다음과 같이 표기해 봅시다:\n\n<div class=\"content-ad\"></div>\n\n- k 클러스터를 갖는 더 간단한 모델의 데이터 가능성인 L(θ0).\n- k+1 클러스터를 갖는 더 복잡한 모델의 데이터 가능성인 L(θ).\n\n이 경우의 우도비 검정 통계량은 다음과 같습니다:\n\n![Likelihood Ratio Test statistic](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_7.png)\n\n이전과 마찬가지로, 어떤 가정 하에 카이제곱 분포를 따르는 통계량을 구하기 위해 -2ln을 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n- 데이터에 두 클러스터링 모델을 적합시켜 보세요.\n- 각 모델에서 데이터의 가능도를 계산하세요.\n- 위의 공식을 사용하여 가능도 비율 검정 통계량을 계산하세요.\n- 카이제곱 분포의 자유도를 결정하세요. 클러스터링 문맥에서, 이는 종종 두 모델 간의 매개변수 수의 차이로 계산됩니다.\n- 계산된 Λ값을 선택한 유의수준에서 카이제곱 분포의 임계값과 비교해 보세요. 만약 Λ 값이 임계값을 초과한다면, 더 복잡한 클러스터링 솔루션이 간단한 솔루션보다 데이터에 더 적합하다는 것을 시사합니다.\n\n클러스터링을 위한 가능도 비율 검정은 데이터가 클러스터 내에서 독립적이고 동일하게 분포되어야 하며, 특정 분포(예: 다변량 가우시안)를 따를 것으로 가정합니다. 또한 이 검정은 가능도 비율 통계의 점근 특성이 성립하기 위해 표본 크기가 충분히 크다고 가정합니다.\n\n## 1.3.2 —베이지안 정보 기준\n\n베이지안 정보 기준(BIC)은 한정된 모델 집합 사이의 모델 선택 기준입니다. 이는 모델의 적합도와 사용된 매개변수 수를 균형있게 고려합니다. BIC는 모델 내의 매개변수 수가 표본 크기에 비해 크지 않은 상황에서 특히 유용합니다.\n\n<div class=\"content-ad\"></div>\n\nBIC 공식은 다음과 같습니다:\n\n![image](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_8.png)\n\n여기서:\n\n- L은 모델의 가능도 함수의 최대화된 값입니다.\n- k는 모델 내의 매개변수 수입니다.\n- n은 샘플 크기입니다.\n\n<div class=\"content-ad\"></div>\n\nBIC은 더 많은 매개변수를 가진 모델을 벌점을 부여하여 오버피팅을 억제합니다. 벌점 항인 k⋅log(n)은 매개변수 수와 샘플 크기 둘 다에 비례하여 증가하며, 샘플 크기가 크지 않은 경우에는 간단한 모델을 선호하도록 합니다.\n\nBIC는 기준값을 최소화하는 모델을 선택하는 것을 목표로 합니다. 따라서 후보 모델 집합 중 BIC가 가장 낮은 모델이 최적으로 간주되며, 모델 적합성과 복잡성을 균형있게 고려합니다.\n\nBIC는 베이지안 원리에서 유도되었지만 베이지안 모델 선택 이론에서 나온 것이며, 실제 모델 선택 목적으로 자주 사용되는 빈도주의적 방법입니다. 회귀, 군집, 시계열 모델링을 포함한 다양한 통계 분석에서 오버피팅을 피하고 모델을 비교하는 체계적인 방법을 제공하여, 가치 있는 도구로 활용됩니다.\n\n# 2 — TinyML 구현\n\n<div class=\"content-ad\"></div>\n\n이 예시를 통해 ESP32, Arduino, Raspberry 및 기타 다양한 마이크로컨트롤러 또는 IoT 장치에서 머신러닝 알고리즘을 구현할 수 있습니다.\n\n2.1 — 라이브러리 가져오기\n\n```js\nimport numpy as np \nimport pandas as pd \nimport matplotlib.pyplot as plt \nimport seaborn as sns\nimport plotly as py\nimport plotly.graph_objs as go\nfrom sklearn.mixture import GaussianMixture\nfrom sklearn.discriminant_analysis import StandardScaler\nimport warnings\nwarnings.filterwarnings('ignore')\n```\n\n2.2 — 데이터셋 불러오기\n\n<div class=\"content-ad\"></div>\n\n```python\ndf = pd.read_csv('./data/Mall_Customers.csv')\ndf.head()\n```\n\n![Image](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_9.png)\n\n```python\ndf.info()\n```\n\n![Image](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_10.png)\n\n<div class=\"content-ad\"></div>\n\n\n---\n```js\ndf.describe()\n```\n\n![Visualization](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_11.png)\n\n### 2.3 — Dataset Visualization\n\n```python\nplt.figure(1, figsize=(15, 6))\nn = 0\nfor x in ['Age', 'Annual Income (k$)', 'Spending Score (1-100)']:\n    n += 1\n    plt.subplot(1, 3, n)\n    plt.subplots_adjust(hspace=0.5, wspace=0.5)\n    sns.distplot(df[x], bins=15)\n    plt.title('Distplot of {}'.format(x))\n    plt.grid()\nplt.show()\n```\n\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_12.png)\n\n```js\nsns.pairplot(df, vars=['Spending Score (1-100)', 'Annual Income (k$)', 'Age'])\n```\n\n![image](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_13.png)\n\n2.4 — Evaluation Methods\n\n\n<div class=\"content-ad\"></div>\n\n```js\nX = df[['나이', '지출 점수 (1-100)']].iloc[:, :].values\n```\n\n2.4.1 — 우도 비율 검정\n\n```js\n# 서로 다른 구성 요소 수로 GMM 학습\nn_components_range = range(1, 20)\nmodels = [GaussianMixture(n, random_state=42).fit(X) for n in n_components_range]\nbic_scores = [model.bic(X) for model in models]  # 베이지안 정보 기준 (BIC) 점수\n\n# 우도 비율 검정\nlrts = []\nfor i in range(len(bic_scores) - 1):\n    lr = 2 * (models[i].score(X) - models[i + 1].score(X))  # 우도 비율 통계량\n    lrts.append(lr)\n```\n\n```js\nplt.figure(figsize=(16, 6))\nplt.subplot(1, 2, 1)\nplt.plot(range(1, len(lrts) + 1), lrts, marker='o')\nplt.xlabel('구성 요소 수')\nplt.ylabel('우도 비율 검정 통계량')\nplt.title('우도 비율 검정')\nplt.grid()\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-TinyMLGaussianMixtureModel_14.png\" />\n\n2.4.2 — Bayesian Information Criterion\n\n```js\n# BIC 점수 플롯하기\nplt.figure(figsize=(16, 6))\nplt.plot(n_components_range, bic_scores, marker='o')\nplt.xlabel('구성 요소 수')\nplt.ylabel('BIC 점수')\nplt.title('베이지안 정보 기준 (BIC)')\nplt.grid()\n```\n\n<img src=\"/assets/img/2024-06-19-TinyMLGaussianMixtureModel_15.png\" />  \n\n<div class=\"content-ad\"></div>\n\n\n# 가설 검정 수행\nthreshold = 3.84 # 자유도가 1이고 유의수준 alpha=0.05 일 때 카이제곱 분포의 임계값\nnum_components = np.argmax(lrts) + 1 # 최대 우도를 갖는 구성 요소의 수\nprint(\"선택된 구성 요소(클러스터) 수:\", num_components)\n\n\n2.5 — 가우시안 혼합 모델\n\n\nalgorithm = (GaussianMixture(n_components=num_components, init_params='k-means++', max_iter=300, \n                        tol=0.0001, random_state=42))\nalgorithm.fit(X)\n\n\n![이미지](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_16.png)\n\n\n<div class=\"content-ad\"></div>\n\n```js\ny_GMM = algorithm.fit_predict(X)\n```\n\n```js\ndf['cluster'] = pd.DataFrame(y_GMM)\ndf.head()\n```\n\n<img src=\"/assets/img/2024-06-19-TinyMLGaussianMixtureModel_17.png\" />\n\n2D Visualization\n\n<div class=\"content-ad\"></div>\n\n```js\n# 클러스터 레이블 예측\n라벨 = y_GMM\n\n# 확률 밀도를 플로팅하기 위한 메시 그리드 생성\nx_min, x_max = X[:, 0].min() - 1, X[:, 0].max() + 1\ny_min, y_max = X[:, 1].min() - 1, X[:, 1].max() + 1\nxx, yy = np.meshgrid(np.linspace(x_min, x_max, 100), np.linspace(y_min, y_max, 100))\nZ = -algorithm.score_samples(np.vstack([xx.ravel(), yy.ravel()]).T)\nZ = Z.reshape(xx.shape)\n\n# 클러스터별로 색칠된 데이터 포인트 플로팅\nplt.figure(figsize=(16, 6))\nplt.scatter(X[:, 0], X[:, 1], c=라벨, s=50, cmap='viridis', alpha=0.5)\n\n# 알고리즘의 등고선 플로팅\nplt.contour(xx, yy, Z, norm=LogNorm(vmin=1.0, vmax=1000.0), levels=np.logspace(0, 3, 10), cmap='viridis')\n\n# 컴포넌트의 평균값 플로팅\nplt.scatter(algorithm.means_[:, 0], algorithm.means_[:, 1], marker='x', s=100, c='red', label='평균값')\n\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.title('클러스터링이 포함된 가우시안 혼합 모델')\nplt.colorbar(label='클러스터')\nplt.legend()\nplt.grid()\n\nplt.show()\n```\n\n<img src=\"/assets/img/2024-06-19-TinyMLGaussianMixtureModel_18.png\" />\n\n3D 시각화\n\n```js\ntrace1 = go.Scatter3d(\n    x= df['나이'],\n    y= df['소비 점수 (1-100)'],\n    z= df['연간 소득 (k$)'],\n    mode='markers',\n     marker=dict(\n        color = df['클러스터'], \n        size= 10,\n        line=dict(\n            color= df['클러스터'],\n            width= 18\n        ),\n        opacity=0.8\n     )\n)\ndata = [trace1]\nlayout = go.Layout(\n    title= '나이, 소득 및 소비 점수에 대한 클러스터',\n    scene = dict(\n            xaxis = dict(title  = '나이'),\n            yaxis = dict(title  = '소비 점수'),\n            zaxis = dict(title  = '연간 소득')\n        ),\n    width=1200,  \n    height=800,  \n)\nfig = go.Figure(data=data, layout=layout)\npy.offline.iplot(fig)\n```\n\n<div class=\"content-ad\"></div>\n\n마크다운 형식으로 코드를 옮기기 위해 테이블 태그를 변경할게요. 아래는 C++ 코드를 JavaScript로 변환하는 함수입니다. \n\n<div class=\"content-ad\"></div>\n\n```js\nmeans = algorithm.means_\ncovariances = algorithm.covariances_\ncoefficients = algorithm.weights_\ncpp_code = convert_to_cpp_code(means, covariances, coefficients)\n```\n\n```js\n#include <math.h>\nusing namespace std;\n\nconst int num_components = 7;\nconst int num_features = 2;\n\nnamespace TKSF\n{\n  namespace ML\n  {\n    namespace Port\n    {\n      class GMM\n      {\n      private:\n        float means[num_components][num_features] = {\n            {56.60931459453662, 49.92251390822188},\n            {29.264921745717615, 74.5990614961554},\n            {43.54207887008299, 10.496799818644392},\n            {41.078202034837176, 34.79082042618642},\n            {31.101406340255828, 90.2290512000496},\n            {31.37324943091291, 61.64977286632278},\n            {22.872325540804805, 49.948720505624074},\n        };\n\n        float covariances[num_components][num_features][num_features] = {\n            {83.24599787684558, 2.890435963609233}, {2.890435963609235, 35.68617486791098},\n            {29.310245867234695, -3.6811694981292513}, {-3.68116949812925, 11.065658605910743},\n            {176.1500923010437, 13.01774646138936}, {13.017746461389358, 29.65985065852867},\n            {75.42208070910617, -6.070541531090654}, {-6.0705415310906545, 97.8692020437219},\n            {29.297433369873897, 4.575820469751143}, {4.575820469751143, 23.020446452070658},\n            {33.43445449031923, -13.501586578314814}, {-13.501586578314813, 6.152388053936477},\n            {16.965821015319975, -2.507134562074277}, {-2.507134562074276, 45.30126223322478},\n        };\n\n        float coefficients[num_components] = {0.1984245445224706, 0.14337213895448095, 0.1649683239019345, 0.1911025085379841, 0.1413696101261269, 0.036998614584665225, 0.12376425937233766};\n\n        float component_pdf(float x[num_features], float mean[num_features], float covariance[num_features][num_features])\n        {\n          float det = covariance[0][0] * covariance[1][1] - covariance[0][1] * covariance[1][0];\n          float inv_cov[num_features][num_features] = {covariance[1][1] / det, -covariance[0][1] / det}, {-covariance[1][0] / det, covariance[0][0] / det};\n          float exponent = -0.5 * (inv_cov[0][0] * (x[0] - mean[0]) * (x[0] - mean[0]) + 2 * inv_cov[0][1] * (x[0] - mean[0]) * (x[1] - mean[1]) + inv_cov[1][1] * (x[1] - mean[1]) * (x[1] - mean[1]));\n          float coefficient = 1.0 / sqrt(2 * M_PI * det);\n          return coefficient * exp(exponent);\n        }\n\n      public:\n        int predict(float x[num_features])\n        {\n          float probabilities[num_components] = {0};\n          for (int i = 0; i < num_components; ++i)\n          {\n            probabilities[i] = coefficients[i] * component_pdf(x, means[i], covariances[i]);\n          }\n          int maxIndex = 0;\n          for (int i = 1; i < num_components; ++i)\n          {\n            if (probabilities[i] > probabilities[maxIndex])\n            {\n              maxIndex = i;\n            }\n          }\n          return maxIndex;\n        }\n      };\n    }\n  }\n}\n```\n\n2.7 — Saves the template in a .h file\n\n```js\nwith open('./GMM/GMM.h', 'w') as file:\n    file.write(cpp_code)\n```\n\n<div class=\"content-ad\"></div>\n\n2.8 — Arduino 스케치 완성\n\n아래와 같이 아두이노 스케치에 \"GMM.h\" 파일을 포함하세요:\n\n```cpp\n#include \"GMM.h\"\nEloquent::ML::Port::KMeans k_means;\nvoid setup() {\n  Serial.begin(9600);\n}\nvoid loop() {\n  // 입력 값\n  float input[] = {15, 39}; \n  // 예측\n  int cluster = k_means.predict(input);\n  // 찾은 클러스터 출력\n  Serial.print(\"클러스터 맴버 (실제 값은 2): \");\n  Serial.println(cluster);\n  delay(2000);\n}\n```\n\n2.9 — 결과\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-TinyMLGaussianMixtureModel_20.png\" />\n\n[TinyML/11_GMM project on GitHub](https://github.com/thommaskevin/TinyML)\n\n## If you found it helpful, how about treating me to a cup of coffee? ☕️💰 (Bitcoin)\n\nBitcoin address: bc1qzydjy4m9yhmjjrkgtrzhsgmkq79qenvcvc7qzn\n\n<div class=\"content-ad\"></div>\n\n![TinyML Gaussian Mixture Model](/assets/img/2024-06-19-TinyMLGaussianMixtureModel_21.png)","ogImage":{"url":"/assets/img/2024-06-19-TinyMLGaussianMixtureModel_0.png"},"coverImage":"/assets/img/2024-06-19-TinyMLGaussianMixtureModel_0.png","tag":["Tech"],"readingTime":15},{"title":"오디오 모듈 UART YX5300 칩을 Arduino AVR ARM, PIC과 함께 사용하기","description":"","date":"2024-06-19 02:20","slug":"2024-06-19-AudiomoduleUARTYX5300ChipforArduinoAVRARMPIC","content":"\n\n제가 발견한 가장 쉬운 오디오 재생 방법은 Serial MP3 UART 모듈을 통한 것입니다. 이 다재다능한 모듈은 MP3 및 WAV 파일 모두를 다룰 수 있어 다양한 오디오 응용 프로그램에 좋은 선택이 됩니다. 이 모듈은 사운드 잭에 직접 연결되어 스피커를 연결할 수 있게 해줍니다. 자체 앰프가 장착된 스피커는 소리 크기를 제어하여 명확하고 조절된 오디오 출력을 제공할 수 있습니다. 이 설정은 모듈이 모든 필요한 디코딩 및 재생 기능을 효율적으로 처리하기 때문에 오디오 재생을 프로젝트에 통합하는 과정을 간단하게 만듭니다.\n\n![이미지](/assets/img/2024-06-19-AudiomoduleUARTYX5300ChipforArduinoAVRARMPIC_0.png)\n\n아래 git을 다운로드하고 압축 파일을 아두이노 라이브러리에 추가하세요.\n\n다음은 SD 카드에서 첫 번째로 찾은 파일을 재생하는 코드입니다.\n\n<div class=\"content-ad\"></div>\n\n```cpp\n#include \"SerialMP3Player.h\"\n#define TX 11\n#define RX 10\n\nSerialMP3Player mp3(RX,TX);\n\nvoid setup() {\n  mp3.begin(9600);      \n  delay(500);            \n  //SD 카드 선택\n  mp3.sendCommand(CMD_SEL_DEV, 0, 2);   \n  delay(500);         \n}\n\nvoid loop() {\n  //첫 번째 파일 재생\n  mp3.play(1);    \n  delay(3000);   \n}\n```\n\n# 문제 발견\n\n이 모듈에 문제가 있습니다. 서로 다른 디지턈 입력을 사용해 보았으나 소리가 재생되지 않았습니다. 몇 번을 시도한 끝에 RX로 디지턈 입력 10을, TX로는 11을 사용하도록 결정했습니다. 이 포트들만 일관적으로 작동하는 것으로 확인되었습니다.\n\n또 다른 문제는 MP3와 WAV 파일을 섞어 사용할 때 파일 이름 순서대로 재생되지 않는 것을 발견했습니다.\n\n<div class=\"content-ad\"></div>\n\n# 파일 호출 및 재생 방법\n\n일부 지침을 살펴보니 파일 이름을 001.mp3, 002.mp3와 같이 순차적으로 지정하여 배열하는 것이 좋다는 것을 제안했습니다. 이렇게 하면 mp3.play(i)를 사용하여 파일을 호출할 수 있으며, 여기서 i는 파일의 순서에 해당합니다. 파일은 .mp3 또는 .wav 형식이 될 수 있습니다.\n\n또한 파일은 폴더 이름 01, 02 등에 배치할 수도 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-AudiomoduleUARTYX5300ChipforArduinoAVRARMPIC_0.png"},"coverImage":"/assets/img/2024-06-19-AudiomoduleUARTYX5300ChipforArduinoAVRARMPIC_0.png","tag":["Tech"],"readingTime":2}],"page":"98","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}