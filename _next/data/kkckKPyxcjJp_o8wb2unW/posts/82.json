{"pageProps":{"posts":[{"title":"SQL과 Power BI를 활용한 고객 세분화 보고서","description":"","date":"2024-06-19 09:28","slug":"2024-06-19-CustomerSegmentationReportwithSQLandPowerBI","content":"\n\n이 프로젝트에서는 RFM(Recency, Frequency, Monetary) 개념을 사용하여 판매 데이터 세트를 분석할 것입니다. 저의 목표는 고객을 세분화하여 최상위 구매자와 무시되고 있을 수 있는 고객 및 그들을 유지하기 위해 타겟 광고 노력이 더 필요한 사람들을 식별하는 것입니다.\n\nRFM 보고서는 세 가지 주요 지표를 사용하여 고객을 세분화하는 방법입니다:\n\n1. Recency(최근성): 고객의 마지막 구매가 얼마나 오래되었나요?\n   \n2. Frequency(빈도): 고객이 얼마나 자주 구매하나요?\n\n<div class=\"content-ad\"></div>\n\n3: 금액: 고객이 구매에 얼마나 지출하는가?\n\n## 프로젝트 계획\n\n- 데이터 정리\n- 데이터셋 개요\n- 분석\n- 최근성, 빈도, 금액 (RFM) 보고서\n- RFM을 사용한 고객 세분화\n- Power BI 대시보드\n\n## 1. 데이터 정리\n\n<div class=\"content-ad\"></div>\n\n데이터를 조사한 결과 특정 기능에 누락된 값이 있는 것을 발견했어요. 그래서 이를 \"없음\"으로 대체해 주었어요. 다행히도, 저가 분석할 주요 기능들에는 누락된 값이 없었어요.\n\n```js\n-- 데이터 확인하기 --\nselect*\nfrom [dbo].[sales_data];\n\n-- 데이터 정리하기 --\n\n-- Addressline2, Postalcode 및 State 열의 누락된 값 찾기\nselect *\nfrom [dbo].[sales_data]\nwhere ADDRESSLINE2 IS NULL OR STATE IS NULL OR POSTALCODE IS NULL;\n\n-- 누락된 값 처리하기\nupdate [dbo].[sales_data]\nset ADDRESSLINE2 = case when ADDRESSLINE2 IS NULL then 'None' else ADDRESSLINE2 end,\n    STATE = case when STATE IS NULL then 'Unknown States' else STATE end,\n    POSTALCODE = case when POSTALCODE IS NULL then 'None' else POSTALCODE end;\n```\n\n![이미지](/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_0.png)\n\n## 2. 데이터셋 개요\n\n<div class=\"content-ad\"></div>\n\n2.1 몇 가지 변수에서의 독특한 관찰\n\n회사는 \"Productline\" 열에서 나타나는 것처럼 열차, 오토바이, 비행기, 클래식 자동차 등의 판매에 특화되어 있습니다. 데이터는 2003년부터 2005년까지의 기간을 다룹니다.\n\n```js\n-- 일부 특성의 고유 관측치\nselect distinct STATUS from [dbo].[sales_data]\nselect distinct YEAR_ID from [dbo].[sales_data]\nselect distinct PRODUCTLINE from [dbo].[sales_data]\nselect distinct COUNTRY from [dbo].[sales_data]\nselect distinct DEALSIZE from [dbo].[sales_data]\nselect distinct TERRITORY from [dbo].[sales_data]\n```\n\n<img src=\"/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n1.2 각 연도별 고유한 월\n\n2005년의 월만 표시한 것은 그렇다고 하더라도, 2003년과 2004년은 둘 다 모든 12개월을 포함했다는 것을 기억하는 것이 중요합니다. 아래 출력에서 확인할 수 있듯이, 2005년 데이터는 5월까지만 있는 것을 알 수 있습니다.\n\n```js\n-- 각 연도별 고유한 월\nselect distinct MONTH_ID as Month_Id_2003  from [dbo].[sales_data]  where YEAR_ID = 2003 order by MONTH_ID ASC;\n\nselect MONTH_ID as Month_Id_2004 from [dbo].[sales_data]  where YEAR_ID = 2004 order by MONTH_ID ASC;\n\nselect distinct MONTH_ID  as Month_Id_2005 from [dbo].[sales_data]  where YEAR_ID = 2005 order by MONTH_ID ASC;\n```\n\n<img src=\"/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n## 2. 분석\n\n2.1 각 제품 라인에서 얼마나 벌고 있나요?\n\n클래식 자동차가 가장 많은 구매를 했고, 가장 적은 구매는 기차였습니다.\n\n```js\n--- 제품 라인별로 매출을 그룹화하여 계산해 봅시다\nselect PRODUCTLINE, SUM(sales) Revenue \nfrom   [dbo].[sales_data]\ngroup by PRODUCTLINE\norder by 2 desc\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_3.png\" />\n\n2.2 매년 매출액은 어떻게 되나요?\n\n결과를 통해 2004년이 가장 높은 매출을 기록했으며, 2003년이 이어서 나왔으며, 2005년의 매출액은 가장 낮았다는 것을 알 수 있습니다. 이 차이는 2005년이 단 5개월에 불과하기 때문에 전체 매출량이 2003년과 2004년의 연간 데이터와 비교하여 상대적으로 작기 때문입니다.\n\n```js\n-- 매년 매출액\nselect YEAR_ID, SUM(sales) Revenue \nfrom [dbo].[sales_data]\ngroup by YEAR_ID\norder by 2 desc \n```\n\n<div class=\"content-ad\"></div>\n\n\n![Customer Segmentation Report](/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_4.png)\n\n2.3. What was the best month for sales in a specific year and how much was earned that month?\n\nIn 2003\n\nThere were more purchases in November and the next highest sales was October.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n-- 2003년 정보에 대하여\nselect MONTH_ID, sum(sales) as 수익, count(ordernumber) as 빈도 \nfrom [dbo].[sales_data]\nwhere YEAR_ID = 2003\ngroup by MONTH_ID\norder by 2 desc\n```\n\n![고객 세분화 보고서](/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_5.png)\n\n2004년에도\n\n2004년에도 11월에 가장 높은 매출이 있었으며, 다음으로 10월에 높은 매출이 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n-- 2004 년도를 위한\nselect MONTH_ID, sum(sales) as Revenue, count(ordernumber) as Frequency \nfrom [dbo].[sales_data]\nwhere YEAR_ID = 2004\ngroup by MONTH_ID\norder by 2 desc\n```\n\n<img src=\"/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_6.png\" />\n\n2005년도에\n\n2005년에는 최다 구매가 5월에 발생하여 올해의 판매 정점을 나타냈습니다. 세 연도 동안의 처음 다섯 개월 구매를 비교하면, 2005년의 판매량이 비교적 높고, 그 다음이 2004년이며, 가장 낮은 것은 2003년입니다. 이는 회사의 매출이 연도를 통틀어 꾸준히 증가하고 있다는 것을 시사합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n-- 2005년 기준\nselect MONTH_ID, sum(sales) as 매출액, count(ordernumber) as 주문빈도\nfrom [dbo].[sales_data]\nwhere YEAR_ID = 2005\ngroup by MONTH_ID\norder by 2 desc\n```\n\n![이미지](/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_7.png)\n\n2.4. 회사가 11월에 일반적으로 가장 높은 매출액을 기록하는 제품은 무엇인가요?\n\n11월에는 클래식 및 빈티지 자동차의 구매가 두드러지게 증가하여 2003년부터 2004년까지 전반적인 높은 매출에 크게 기여했습니다. 반면에 기차는 동일한 달에 회사의 수익 최소화를 보여주었습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\n-- 2003년 11월\nselect MONTH_ID as November_2003, PRODUCTLINE, sum(sales) as Revenue, count(ordernumber) as Frequency \nfrom [dbo].[sales_data]\nwhere YEAR_ID = 2003 and MONTH_ID=11\ngroup by MONTH_ID, PRODUCTLINE\norder by 3 desc\n\n-- 2004년 11월\nselect MONTH_ID as November_2004,PRODUCTLINE, sum(sales) as Revenue, count(ordernumber) as Frequency \nfrom [dbo].[sales_data]\nwhere YEAR_ID = 2004 and MONTH_ID=11\ngroup by MONTH_ID, PRODUCTLINE\norder by 3 desc\n```\n\n<img src=\"/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_8.png\" />\n\n## 4. 최근성, 주파수 및 금액 (RFM) 보고서\n\n최근성은 마지막 주문 또는 구매 이후 경과한 일 수를 나타내며, Euro Shopping Channel과 La Rochelle Gifts는 데이터에서 가장 최근 구매를 한 날짜에 해당합니다(최대 날짜). 최근성 값이 높을수록 마지막 구매 이후의 기간이 길어집니다. RFM 결과에 따르면 Toys of Finland. Co는 데이터 집합에서 현재 또는 최대 날짜로부터 100일 이상이 지난 마지막 구매를 했습니다.\n또한, 주문 사이의 평균 일 수를 살펴보면 고객들이 얼마나 자주 구매를 하는지에 대한 통찰을 제공합니다. Euro Shopping Channel은 평균 3일 간격으로 가장 꾸준한 고객 중 하나로 나타납니다.\n마찬가지로, 고객 당 금액 값을 검토하면 Euro Shopping Channel이 가장 많이 지출한 것을 확인할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n```sql\n-- RFM 분석\nselect CUSTOMERNAME,\n   sum(sales) as MonetaryValue,\n   avg(sales) as AvgMonetaryValue,\n   count(*) as Frequency_of_orders,\n   count(distinct convert(DATE, orderdate)) AS Number_of_unique_order_dates,\n   convert(INT, round(cast(datediff(dd, min(ORDERDATE), max(ORDERDATE)) as decimal)/(count(*)-1),0)) as [Aveg_day_between_orders],\n   datediff(DD,max(orderdate),( select max(orderdate) from [dbo].[sales_data])) as recency \nfrom [dbo].[sales_data]\ngroup by CUSTOMERNAME\nhaving count(*)>1\norder by recency\n```\n\n![RFM Analysis](/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_9.png)\n\n## 5.0 RFM 보고서 기반의 고객 세분화\n\n제공된 결과는 RFM 기준에 따른 고객 세분화에 대한 통찰을 제공합니다. rfm_recency=1에 속한 고객은 최근 구매 이후 지난 기간이 길어서, 데이터 세트에서 최대 날짜로부터 112일까지 구매를 한 Boards & Toys Co.와 같이 특징 지어집니다. 반면, rfm_recency=4는 최근 구매를 나타내며, 데이터 세트에서 가장 최근 구매가 14일 전인 Salzburg Collectables과 같은 상황입니다. 이는 rfm_recency=1 또는 2에 속한 고객이 마지막 주문 이후 상당한 시간이 지나자 \"잠재적 이탈 고객\"일 수 있다는 것을 나타냅니다.\n\n\n<div class=\"content-ad\"></div>\n\n비슷하게, rfm_monetary에 대해서는 소비가 높은 고객이 rfm_monetary=4로 분류되며, 소비가 적은 고객은 rfm_monetary=1로 분류됩니다. rfm_frequency에 대해, rfm_frequency=4인 고객은 가장 많은 주문을 보유하고 있으며, rfm_frequency=1은 가장 적은 주문을 가진 고객을 나타냅니다.\n\n이러한 RFM 카테고리를 분석하여, 최근 구매를 보유한 최고의 고객은(rfm_recency=4), 가장 높은 금액을 지출한 고객(rfm_monetary=4) 및 가장 많은 주문을 가진 고객(rfm_frequency=4)으로 식별할 수 있습니다.\n\n\n---고객을 네 가지 세분류로 분류합니다.\n\nwith customer_segment as\n(\n select \n   CUSTOMERNAME,\n   sum(sales) as MonetaryValue,\n   count(ordernumber) as Frequency_of_orders,\n   max (orderdate) as last_order_date,\n   (select max(orderdate) from [dbo].[sales_data]) as max_order_date,\n   datediff(dd, max(orderdate),(select max(orderdate) from [dbo].[sales_data])) as Recency \n from [dbo].[sales_data]\n group by CUSTOMERNAME \n)\nselect*,\n  NTILE(4) OVER (order by Recency desc) as rfm_recency,\n  NTILE(4) OVER (order by Frequency_of_orders) as rfm_frequency,\n  NTILE(4) OVER (order by MonetaryValue) as rfm_monetary\nfrom customer_segment \n\n\n![Customer Segmentation Report](/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_10.png)\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_11.png\" />\n\n5.1 상기 Segmentation을 기반으로 고객에게 Segment 이름 할당하기.\n고객 Segmentation을 고려할 때, 복합 코드가 444인 고객이 최고의 고객을 대표합니다. 첫 번째 4는 rfm_recency 그룹 4에 속한 고객을 나타내며 최근 구매를 의미합니다. 두 번째 4는 rfm_frequency 그룹 4에 속한 고객을 나타내어 많은 주문을 했음을 의미합니다. 마지막 4는 rfm_monetary 그룹 4에 속한 고객들을 나타내어 더 많은 돈을 소비했다는 것을 의미합니다.\n\n반대로, 복합 그룹이 111인 고객들은 오랜 시간 구매를 하지 않은, 주문 수가 적고 지금까지 가장 적은 금액을 소비한 고객들입니다.\n\n```js\n-- 우리 최고의 고객은 누구인가요?\n\nDROP TABLE IF EXISTS #customer_segment; -- 테이블 #rfm 생성\nwith customer_segment as\n(\n select \n CUSTOMERNAME,\n sum(sales) as MonetaryValue,\n avg(sales) as AvgMonetaryValue,\n COUNT(ordernumber) as Frequency,\n MAX(orderdate) as last_order_date,\n (select max(orderdate) from [dbo].[sales_data]) as max_oder_date,\n DATEDIFF(DD, MAX(orderdate),(select max(orderdate) from [dbo].[sales_data])) as Recency \n from [dbo].[sales_data]\n group by CUSTOMERNAME \n),\n\nrfm_segmentation as \n  (\n  select*,\n  NTILE(4) OVER (order by Recency desc)as rfm_recency,\n  NTILE(4) OVER (order by Frequency) as rfm_frequency,\n  NTILE(4) OVER (order by MonetaryValue) as rfm_monetary\n   --(NTILE(4) OVER (order by Recency)) + (NTILE(4) OVER (order by Frequency)) + (NTILE(4) OVER (order by AvgMonetaryValue)) AS CompositeScore\n  from customer_segment \n )\n\nselect \n c.*, rfm_recency + rfm_frequency + rfm_monetary as rfm_cell,\n CAST(rfm_recency as varchar)+ CAST(rfm_frequency as varchar)+ CAST(rfm_monetary as varchar) as rfm_cell_string\n\ninto #customer_segment -- 스크립트를 실행하면서 테이블을 생성하는 데 도움이 됩니다. 맨 위에 #rfm 테이블이 이미 생성되었습니다.\nfrom rfm_segmentation c\n\n\n\nselect CUSTOMERNAME, rfm_recency,rfm_frequency, rfm_monetary,rfm_cell_string,\n  CASE\n  when rfm_cell_string in (111, 112, 121, 122, 211, 212, 114, 141, 123, 131,132,141,142,221, 231,232,242,241) then '잃어버린 나 새로운 고객'\n  when rfm_cell_string in (222,223, 233,134,143,133,144,234,232,244) then '사라져가지만 돈을 많이 쓰는 고객' -- 회사는 그들이 떠나는 것을 방치해서는 안됩니다\n  when rfm_cell_string in (411,412,421,422,342,442,322,332,311) then '정기적이지만 소비가 적은 고객'\n  when rfm_cell_string in (424,423,432,324,414,324,331) then '좋은 고객들' \n  when rfm_cell_string in (444,443,434,344,333,334, 343,433) then '최고의 고객들' \n  end rfm_segment\n\nfrom #customer_segment\n```\n\n<div class=\"content-ad\"></div>\n\n![RFM Report with Power BI](/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_12.png) \n\n![RFM Report with Power BI](/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_13.png) \n\n## 6. Power BI를 사용한 RFM 보고서\n\nPower BI 대시보드를 통해 Euro Shopping Channel이 최고의 성과를 거두었음이 명확히 드러납니다. 해당 채널은 가장 많은 고유 주문을 하여 총 25개를 달성하였고, 또한 최근 구매자 중에서도 속해 있습니다.\n\n<div class=\"content-ad\"></div>\n\n대시보드에서 주목할 만한 관찰 중 하나는 고객 세그먼트별 매출을 분석할 때 \"우수 고객\"으로 표시된 범주가 의외로 가장 낮은 매출을 보인다는 것입니다. 이는 세분화 규칙을 적용한 후 이 범주에 속하는 고객이 단 하나뿐이기 때문입니다. 따라서 이 한 명의 고객으로부터 발생한 총 매출이 다른 세그먼트에 속한 여러 고객들의 집계 매출보다 낮을 수밖에 없는 것입니다.\n\n![이미지](/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_14.png)\n\n끝\n프로젝트를 읽어 주셔서 감사합니다.\nLinkedIn: www.linkedin.com/in/kofi-duodu-siriboe-a184021b2","ogImage":{"url":"/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_0.png"},"coverImage":"/assets/img/2024-06-19-CustomerSegmentationReportwithSQLandPowerBI_0.png","tag":["Tech"],"readingTime":11},{"title":"이상치에 대해 과하게 생각하지 마세요, 대신 t-분포를 사용해보세요","description":"","date":"2024-06-19 09:24","slug":"2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead","content":"\n\n## R과 Brms를 사용한 베이지안 접근\n\n다수의 연구자들에게 이상값은 분석의 경로를 급진적으로 바꿀 수 있는 로그 파도와 동일하며 일부 예상된 효과를 \"혼란\"시킬 수 있습니다. 저는 \"극단적인 관측치\"라는 용어를 사용하여 이상값은 연구 중인 모집단의 일부가 아닌 관측치를 남깁니다. 예를 들어, 제 분야인 뇌 허혈 연구에서 이상값은 허혈이 있어야 하는 동물인데 실제로 허혈이 없는 동물이며, 극단적인 관측치는 다른 동물들과 매우 다른 작거나 큰 허혈이 있는 동물입니다.\n\n전통적 (빈도론적) 통계 모델은 가우시안 분포의 견고한 기반 위에 구축됩니다. 이에는 중심 한계 정리에 따라 모든 데이터 포인트가 중심 평균 주변에 예측 가능한 패턴으로 군집화될 것이라는 내재된 가정이 존재하는 중요한 제한 사항이 있습니다. 이것은 이상적으로는 플라톤의 이상 세계에서 사실일 수 있지만, 우리 연구자들인 생명 의학 분야의 우리는 이 가정에 의존하기 어려운 초기 샘플링(동물의 수) 때문에 도전적이라는 것을 알고 있습니다.\n\n가우시안 분포는 극단적인 관측치에 매우 민감하며, 그들의 사용은 이상적인 결과를 얻는 가장 좋은 방법은 극단적인 관측치를 제거하는 것이라는 오해를 유발합니다. 이에 대해 한번 심사위원 2로서 기사에서 언급했던 것처럼, \"문제는 귀하의 효과를 '가리게' 할 수 있는 극단적인 관측치가 아니라 귀하의 목적에 부적절하다고 믿는 통계 모델을 사용하고 있다는 사실입니다\".\n\n<div class=\"content-ad\"></div>\n\n다행히도, 가우시안 모델의 가정에 얽매이지 않아도 된다는 것 알고 계시나요? 다른 선택지가 있으니까요, 바로 스튜던트 t-분포입니다. 저는 실제 생물의 응답을 포착하기 위한 좀 더 적응 가능한 수달로 보고 있어요. 스튜던트 t-분포는 우리 데이터가 어떤 맥락에서든 예상할 수 있는 정상 생물학적 응답인 극단적 관측치로 채워질 수 있음을 인정하기 위한 강력한 대안을 제공해줘요. 어떤 환자나 동물은 치료에 반응하지 않거나 과도하게 반응할 수 있고, 모델링 접근법이 이러한 반응을 스펙트럼의 일부로 인식하는 것은 귀중하답니다. 따라서 이 튜토리얼은 R의 brms 패키지를 통해 스튜던트 t-분포를 사용한 모델링 전략을 탐색합니다. 이 패키지는 베이지안 모델링에 강력한 동반자입니다.\n\n# 스튜던트 t-분포의 밑받침에 있는 것은 무엇인가요?\n\n스튜던트 t-분포는 꼬리가 두꺼운 가우시안 분포에 불과해요. 다시 말해, 가우시안 분포는 스튜던트 t-분포의 특별한 경우라고 할 수 있어요. 가우시안 분포는 평균(μ)과 표준 편차(σ)로 정의돼요. 그러나 스튜던트 t-분포는 자유도(DF)라는 추가 매개변수가 더해진다는 점이 다르죠. 이 자유도 매개변수는 분포의 \"두께\"를 제어하며, 평균으로부터 더 먼 사건에 더 높은 확률을 할당해줘요. 이 특성은 바이오의학과 같이 정상성 가정이 의심스러운 소량의 표본 크기에서 특히 유용해요. 자유도가 증가함에 따라 스튜던트 t-분포는 가우시안 분포에 가까워져요. 이를 밀도 플롯을 이용해 시각적으로 확인할 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-너무 생각하지 마세요 아웃라이어를 생각하지 마세요. 그 대신 스튜던트 t-분포를 사용하세요_0.png\" />\n\n그림 1에서 평균 주변의 언덕이 자유도가 줄어들면서 더 작아짐을 주의하십시오. 그 결과로 미리 수집되었던 확률이 두꺼운 꼬리로 이동했습니다. 이 특성은 스튜던트 t-분포가 아웃라이어에 대한 민감도를 줄여주는 것입니다. 이에 대한 자세한 내용은 블로그를 참조해주세요.\n\n# 필요한 패키지 로드\n\n필요한 라이브러리를 로드합니다.\n\n<div class=\"content-ad\"></div>\n\n```r\nlibrary(ggplot2)\nlibrary(brms)\nlibrary(ggdist)\nlibrary(easystats)\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(ghibli)\n```\n\n# 탐색적 데이터 시각화\n\n그래서, 데이터 시뮬레이션을 건너뛰고 진지하게 할 차례입니다. 쥐들이 로타로드 테스트를 수행하는 중 획득한 실제 데이터로 작업할 것입니다.\n\n먼저, 데이터셋을 환경에 로드하고 해당 요소 수준을 설정합니다. 이 데이터셋에는 동물들의 ID, 그룹 변수(Genotype), 테스트가 수행된 두 가지 다른 날짜를 나타내는 지표(day), 같은 날짜에 대한 다양한 시도가 포함되어 있습니다. 이 문서에서는 시도 중 하나(Trial3)만 모델링합니다. 다른 시도들은 변이 모델링에 대한 미래 문서에서 저장할 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n데이터 처리를 고려하면 저희의 모델링 전략은 유전형과 일자를 Trial3의 분포의 범주형 예측변수로 사용할 것입니다.\n\n```R\ndata <- read.csv(\"Data/Rotarod.csv\")\ndata$Day <- factor(data$Day, levels = c(\"1\", \"2\"))\ndata$Genotype <- factor(data$Genotype, levels = c(\"WT\", \"KO\"))\nhead(data)\n```\n\n![image](/assets/img/2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead_1.png)\n\nGuilherme A. Franchi, 박사의 훌륭한 블로그 게시물에서 소개된 Raincloud 그림을 사용하여 데이터의 초기 전망을 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n```R\nedv <- ggplot(data, aes(x = Day, y = Trial3, fill=Genotype)) +\n  scale_fill_ghibli_d(\"SpiritedMedium\", direction = -1) +\n  geom_boxplot(width = 0.1,\n               outlier.color = \"red\") +\n  xlab('Day') +\n  ylab('Time (s)') +\n  ggtitle(\"Rorarod performance\") +\n  theme_classic(base_size=18, base_family=\"serif\")+\n  theme(text = element_text(size=18),\n        axis.text.x = element_text(angle=0, hjust=.1, vjust = 0.5, color = \"black\"),\n        axis.text.y = element_text(color = \"black\"),\n        plot.title = element_text(hjust = 0.5),\n        plot.subtitle = element_text(hjust = 0.5),\n        legend.position=\"bottom\")+\n  scale_y_continuous(breaks = seq(0, 100, by=20), \n                     limits=c(0,100)) +\n# Line below adds dot plots from {ggdist} package \n  stat_dots(side = \"left\", \n            justification = 1.12,\n            binwidth = 1.9) +\n# Line below adds half-violin from {ggdist} package\n  stat_halfeye(adjust = .5, \n               width = .6, \n               justification = -.2, \n               .width = 0, \n               point_colour = NA)\nedv\n```\n\n<img src=\"/assets/img/2024-06-19-Do not over-think about outliers, use a Student-t distribution instead_2.png\" />\n\nFigure 2은 Guilherme A. Franchi, 박사의 원본과 다릅니다. 왜냐하면 우리는 한 가지가 아닌 두 가지 요인을 그래픽 표현하고 있기 때문입니다. 그러나 그래프의 성격은 같습니다. 빨간 점들에 주목해 주세요. 이들이 중심 경향의 평균을 특정 방향으로 기울이는 극단적인 관측값으로 간주될 수 있는 것입니다. 또한 분산이 다른 것을 관찰하며, 따라서 시그마도 모델링하는 것이 더 나은 추정치를 제공할 수 있습니다. 이제 우리의 작업은 brms 패키지를 사용하여 출력을 모델링하는 것입니다.\n\n# brms를 사용하여 통계 모델 맞추기\n\n<div class=\"content-ad\"></div>\n\n저희는 Day 및 Genotype를 상호 작용하는 범주형 예측 변수로 설정하여 Trial 3의 분포에 모델을 맞추었어요. 먼저 자주 쓰이는 가우스 모델을 적합해볼게요. 이 모델은 빈도주의적 프레임워크에서의 일반적인 최소 제곱(OLS) 모델에 해당합니다. 왜냐하면 우리는 기본 평평한 brms 사전 분포를 사용하기 때문이죠. 이 기사에서는 사전 분포는 다루지 않겠지만, 약속드려요. 미래 블로그에서 다뤄볼 거에요.\n\n가우시안 모델 결과를 얻으면, 학생 t 모델의 큰 결과와 비교할 수 있어요. 그 다음, 데이터 분산의 차이를 고려하기 위해 방정식에 addsigma를 추가해요.\n\n## 가우시안 랜드에서 \"전형적인\" (빈도주의) 모델 적합\n\n우리의 가우시안 모델은 동질 분산성(3)의 전형적(그리고 종종 잘못된) 가정 하에 구축되었어요. 다시 말해, 우리는 모든 그룹이 동일한(또는 매우 유사한) 분산을 갖는다고 가정해요. 연구자로서 이를 본 적이 없어요.\n\n<div class=\"content-ad\"></div>\n\n```r\nGaussian_Fit1 <- brm(Trial3 ~ Day * Genotype, \n           data = data, \n           family = gaussian(),\n           # reproducibility를 위한 seed\n           seed = 8807,\n           control = list(adapt_delta = 0.99),\n           # 모델을 내 노트북에 저장하기 위함\n           file    = \"Models/20240222_OutliersStudent-t/Gaussian_Fit1.rds\",\n           file_refit = \"never\")\n\n# 모델 비교를 위해 loo 추가\nGaussian_Fit1 <- \n  add_criterion(Gaussian_Fit1, c(\"loo\", \"waic\", \"bayes_R2\"))\n```\n\n## 모델 진단\n\n계속하기 전에 실제 관측값과 모델의 예측을 비교하기 위해 몇 가지 간단한 모델 진단을 하는 것이 좋습니다. 이를 다양한 방법으로 수행할 수 있지만, 가장 흔한 방법은 전체 밀도를 그래픽으로 나타내는 것입니다. brms의 pp_check 함수를 사용하여 이를 달성할 수 있습니다.\n\n```r\nset.seed(8807)\n\npp_check(Gaussian_Fit1, ndraws = 100) +\n  labs(title = \"가우시안 모델\") +\n  theme_classic()\n```\n\n<div class=\"content-ad\"></div>\n\n<table> 태그를 Markdown 형식으로 바꿔보세요.\n\n<div class=\"content-ad\"></div>\n\n이제 bayestestR 패키지 (4)의 describe_posterior 함수를 사용하여 결과를 확인해 봅시다:\n\n```js\ndescribe_posterior(Gaussian_Fit1,\n                   centrality = \"mean\",\n                   dispersion = TRUE,\n                   ci_method = \"HDI\",\n                   test = \"rope\",\n                   )\n```\n\n![그림](/assets/img/2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead_4.png)\n\n여기서 'intercept'(절편)와 'GenotypeKO'(KO 동물의 같은 시간대 추정 차이)에 집중해 보겠습니다. WT 동물은 로타로드에서 약 37초를 보내는 반면, KO 동물은 한초도 안 되는 0.54초를 더 보냅니다. 이 분야의 연구자로서, 이 차이는 무의미하며 유전자형은 로타로드 성능에 영향을 미치지 않는다고 말할 수 있습니다. 또한, 모델에서 2.9인 Day의 영향도 무의미하다고 생각됩니다. 이러한 추정치를 brms의 훌륭한 conditional_effects 함수를 사용하여 쉽게 시각화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```R\n# Convex hull을 위한 그래프를 생성합니다\nGaussian_CondEffects <- \n  conditional_effects(Gaussian_Fit1)\n\nGaussian_CondEffects <- plot(Gaussian_CondEffects, \n       plot = FALSE)[[3]]\n\nGaussian_CondEffects + \n  geom_point(data=data, aes(x = Day, y = Trial3, color = Genotype), inherit.aes=FALSE) +\n  Plot_theme +\n  theme(legend.position = \"bottom\", legend.direction = \"horizontal\")\n```\n\n<img src=\"/assets/img/2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead_5.png\" />\n\nFigure 8에서 상호 작용 항목에 대한 추정치와 불확실성을 볼 수 있습니다. 여러 ggplot 요소로 플롯을 사용자 정의했으며, 원래 Quarto Notebook에서 확인할 수 있습니다. 날 1과 날 2 모두 유사한 불확실성을 보여줍니다. 날 1에 더 큰 분산이 있지만, 날 2에는 낮습니다. 이 점에 대해 이 기사 끝에 짧은 조각을 통해 다룰 예정입니다.\n\n이제 동일한 데이터를 학생 t 분포를 사용하여 모델링할 때 얼마나 우리의 이해가 얼마나 변하는지 살펴봅시다.\n\n\n<div class=\"content-ad\"></div>\n\n# 방문해 주셔서 감사합니다: 학생-t 분포를 사용한 모델 적합\n\n우리 `brms` 모델에서 학생-t 분포를 사용할 시간입니다.\n\n```js\nStudent_Fit <- brm(Trial3 ~ Day * Genotype, \n           data = data, \n           family = student,\n           # 재현성을 위한 시드\n           seed = 8807,\n           control = list(adapt_delta = 0.99),\n           # 모델을 내 노트북에 저장하기 위함\n           file    = \"Models/20240222_OutliersStudent-t/Student_Fit.rds\",\n           file_refit = \"never\")\n\n# 모델 비교를 위한 loo 추가\nStudent_Fit <- \n  add_criterion(Student_Fit, c(\"loo\", \"waic\", \"bayes_R2\"))\n```\n\n## 모델 진단\n\n<div class=\"content-ad\"></div>\n\n이전과 같이 모델 진단 결과를 그래프로 표현해봤어요:\n\n![Figure 9](/assets/img/2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead_6.png)\n\nFigure 9에서 관측값과 예측값의 평균 모양과 정점이 일치하는 것을 볼 수 있어요. 우리 모델은 0 미만의 값을 예측하는 것으로 보입니다. 이는 현재는 건너뜁니다만 중요한 연구 이슈입니다. 그러나 이는 0 이하의 값에 대한 하한선을 설정하는 정보 전제나 분포 계열(예: log_normal`,hurdle_lognormal’, or `zero_inflated_poisson’)의 사용을 함축합니다. 경우에 따라 Andrew Heiss (5)가 이와 관련한 훌륭한 예시를 제공합니다.\n\n## student-t 분포의 결과 확인\n\n<div class=\"content-ad\"></div>\n\n후방 분포를 살펴보겠습니다:\n\n```js\ndescribe_posterior(Student_Fit,\n                   centrality = \"mean\",\n                   dispersion = TRUE,\n                   ci_method = \"HDI\",\n                   test = \"rope\",\n                   )\n```\n\n<img src=\"/assets/img/2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead_7.png\" />\n\n이 모델 하에 우리의 추정치가 다소 변한 것을 볼 수 있어요. 절편(WT at 1 day)에 대한 추정치가 7초 감소했습니다. 그 이유는 무엇일까요? 초기에 발견한 극단 값들이 데이터의 중심 경향 측정에 덜 영향을 미치기 때문입니다. 따라서 이는 1일차 전형적인 WT 동물의 무게를 더 정확하게 측정한 것입니다. 또한, 일자별 영향이 상당히 증가한 것을 관찰할 수 있습니다. 거의 10초가 초기 가우시안 추정치보다 더 많이 소요되어요. 중요한 점은, KO 유전자형의 영향이 더 두드러지게 나타나며, 초기 가우시안 모델의 0.52보다 학생 t 모델에서 5.5로 약 10배 증가했습니다. 이 데이터의 맥락을 고려해볼 때, 두 모델 간의 대조가 뚜렷하다고 생각해요.\n\n<div class=\"content-ad\"></div>\n\n그래픽적으로 조건부 효과를 확인해 보겠습니다. conditional_effects를 사용해요:\n\n```js\nStudent_CondEffects <- \n  conditional_effects(Student_Fit)\n\nStudent_CondEffects <- plot(Student_CondEffects, \n       plot = FALSE)[[3]]\n\nStudent_CondEffects + \n  geom_point(data=data, aes(x = Day, y = Trial3, color = Genotype), inherit.aes=FALSE) +\n  Plot_theme +\n  theme(legend.position = \"bottom\", legend.direction = \"horizontal\")\n```\n\n<img src=\"/assets/img/2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead_8.png\" />\n\n더 나은 추정을 얻을 수 있을까요? 이 특정 예시에서는 가능하다고 생각해요. 처음부터 데이터의 분산 차이를 쉽게 알아차렸으며, 특히 첫째 날과 둘째 날의 시각화를 비교할 때 더욱 명확해졌어요. 학생 t-분포를 사용하여 추정치를 향상시켰고, residual variance를 예측하는 이분산성 모델을 개발하여 추정치를 더욱 개선했습니다.\n\n<div class=\"content-ad\"></div>\n\n요거 하나 남았네요.\n\n# 학생-t 분포를 사용하여 시그마 예측\n\n우리는 brms의 thebf 함수를 사용하여 반응 변수로 시그마를 포함시킵니다. 이 경우, 우리는 동일한 예측 변수인 Day와 Genotype을 사용하여이 매개 변수를 모델링할 것입니다.\n\n```js\nStudent_Mdl2 <- bf (Trial3 ~ Day * Genotype,\n                     sigma ~ Day * Genotype)\n\nStudent_Fit2 <- brm(\n           formula = Student_Mdl2,\n           data = data, \n           family = student,\n           # 재현성을 위한 시드\n           seed = 8807,\n           control = list(adapt_delta = 0.99),\n           # 모델을 내 노트북에 저장하기 위함\n           file    = \"Models/20240222_OutliersStudent-t/Student_Fit2.rds\",\n           file_refit = \"never\")\n\n# 모델 비교를 위해 loo 추가\nStudent_Fit2 <- \n  add_criterion(Student_Fit2, c(\"loo\", \"waic\", \"bayes_R2\"))\n```\n\n<div class=\"content-ad\"></div>\n\n## 모델 진단\n\n![Figure 11](/assets/img/2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead_9.png)\n\n피겨 11은 좋아보이지만 0 미만의 예측값이 조금 불편합니다. 이 경우, 이것이 추정치와 그들의 불확실성에 강력한 편향을 미치지는 않는다고 판단합니다. 그러나 이는 실제 연구를 할 때 고려할 부분입니다.\n\n## 예측 시그마를 사용한 학생-t 분포 결과 확인\n\n<div class=\"content-ad\"></div>\n\n이제 우리는 사후 분포를 살펴보겠습니다.\n\n![image](/assets/img/2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead_10.png)\n\n우리는 다른 두 적합된 모델에 비해 더 많은 매개변수를 볼 수 있습니다. 이는 시그마에 대한 응답이 이제 모델의 주효과로 포함되었기 때문입니다. 이 체계 아래에서 우리는 y절편이 가우시안 모델의 것에 더 가깝고 유전형 (GenotypeKO)의 영향이 반으로 줄어든 것을 볼 수 있습니다.\n\n그러나 주목해야 할 점이 하나 있습니다. 첫 번째 스튜던트-t 모델에서 y절편에 대한 불확실성은 24.1에서 37.4 사이였습니다. 그러나 마지막 모델에서 불확실성은 24.3에서 46.1로 증가했습니다. 즉, 서로 다른 분산을 고려할 때 이 (그리고 다른) 매개변수에 대한 확신이 줄어든다는 것을 의미합니다. 예를 들어, 일(day)의 경우, 1.2에서 18.9였던 범위가 -5.6에서 18.1로 변합니다. 이 경우, 이제 두 번째 날이 로터로드에 보낸 시간이 증가된다는 것에 대해 덜 확신할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 예제에서는 데이터의 다른 분산을 고려하면 결과에 대한 매우 다른 아이디어를 제공합니다.\n\n마지막으로, 우리는 로그 스케일에 표시된 시그마가 날짜와 유전형에 따라 의미 있는 변화가 있음을 확인할 수 있습니다:\n\n```js\nStudent_CondEffects2 <- \n  conditional_effects(Student_Fit2)\n\nStudent_CondEffects2 <- plot(Student_CondEffects2, \n       plot = FALSE)[[3]]\n\nStudent_CondEffects2 + \n  geom_point(data=data, aes(x = Day, y = Trial3, color = Genotype), inherit.aes=FALSE) +\n  Plot_theme +\n  theme(legend.position = \"bottom\", legend.direction = \"horizontal\")\n\n\nStudent_CondEffects3 <- \n  conditional_effects(Student_Fit2, dpar = \"sigma\")\n\nStudent_CondEffects3 <- plot(Student_CondEffects3, \n       plot = FALSE)[[3]]\n\nStudent_CondEffects3 + \n  Plot_theme +\n  theme(legend.position = \"bottom\", legend.direction = \"horizontal\")\n```\n\n<img src=\"/assets/img/2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead_11.png\" />\n\n<div class=\"content-ad\"></div>\n\n![링크 텍스트](/assets/img/2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead_12.png)\n\n두 번째 그래프에서 본 것은 시그마입니다. 이는 일자 및 유전형 간이 이 매개변수의 분산을 효과적으로 설명합니다. 특히 WT 쥐의 경우, 첫 번째 날에는 훨씬 더 불확실성이 높게 나타나는 반면, 두 번째 날에는 이 매개변수가 유사합니다.\n\n우리는 이 글을 샘플 외 예측을 위해 세 가지 모델을 비교하며 결론을 낼 수 있습니다.\n\n# 모델 비교\n\n<div class=\"content-ad\"></div>\n\nWAIC 기준을 사용하여 모델 비교를 수행합니다. WAIC는 외부 샘플 예측 오차를 추정하기 위해 사용됩니다. WAIC는 관측 데이터의 로그 우도와 유효 파라미터 수를 모두 고려하여 모델 적합성과 복잡성 사이의 균형을 제공합니다. 다른 기준과는 달리 WAIC는 포인트 추정 대신 파라미터의 사후 분포를 내재적으로 반영하므로 베이지안 분석에 특히 적합합니다.\n\n데이터 세트와 베이지안 모델이 주어졌을 때, WAIC는 다음과 같이 계산됩니다:\n\nWAIC = -2×(LLPD - pWAIC)\n\n여기서, LLPD는 로그 점별 예측 밀도로, 각 관측 데이터 지점에 대한 로그 우도를 후방 샘플 전체에 걸쳐 평균한 값입니다. WAIC는 유효 파라미터 수로, 로그 우도의 평균과 후방 샘플들 간 평균 로그 우도의 차로 계산됩니다.\n\n<div class=\"content-ad\"></div>\n\n퍼포먼스 패키지의 compare_performance 함수를 사용합니다. easystats 환경에 포함된 일부 함수입니다 (4, 7, 8).\n\n```js\nFit_Comp <- \n  compare_performance(\n    Gaussian_Fit1, \n    Student_Fit, \n    Student_Fit2, \n    metrics = \"all\")\n\nFit_Comp\n```\n\n이 출력 결과에 따르면, 아웃 오브 샘플 예측에서 시그마를 예측하는 우리의 Student-t 모델이 가장 적게 패널티를 받았습니다 (WAIC = 497). 이 모델에서 시그마에 대한 추정치가 없는 이유는 이것이 응답 변수로 포함되었기 때문입니다. 이 표는 또한 Student-t 모델이 가우시안 모델보다 잔차 분산 (시그마)이 적다는 것을 보여줍니다. 이는 분산이 예측 변수로 더 잘 설명된다는 것을 의미합니다. 동일한 결과를 그래프로 시각화할 수 있습니다.\n\n```js\nFit_Comp_W <- \nloo_compare(\n Gaussian_Fit1, \n    Student_Fit, \n    Student_Fit2,  \n  criterion = \"waic\")\n\n# WAIC 그래프 생성\nFit_Comp_WAIC <- \n  Fit_Comp_W[, 7:8] %>% \n  data.frame() %>% \n  rownames_to_column(var = \"model_name\") %>% \n  \nggplot(\n  aes(x    = model_name, \n      y    = waic, \n      ymin = waic - se_waic, \n      ymax = waic + se_waic)\n  ) +\n  geom_pointrange(shape = 21) +\n  scale_x_discrete(\n    breaks=c(\"Gaussian_Fit1\", \n             \"Student_Fit\", \n             \"Student_Fit2\"), \n            \n    labels=c(\"Gaussian_Fit1\", \n             \"Student_Fit\", \n             \"Student_Fit2\") \n             \n    ) +\n  coord_flip() +\n  labs(x = \"\", \n       y = \"WAIC (score)\",\n       title = \"\") +\n  Plot_theme\n\nFit_Comp_WAIC\n```\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead_13.png)\n\n그림 14는 우리의 마지막 모델이 샘플 외 예측에 대해 덜 처벌받는 것을 보여줍니다.\n\nGitHub 사이트에서이 게시물의 최신 버전을 찾을 수 있습니다. 이 여정이 유익했는지, 이 연습에 추가할 건설적인 의견이 있는지 알려주세요.\n\n* 별도로 표기하지 않은 경우, 모든 이미지는 R 코드를 사용하여 작성된 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 참고 자료\n\n1. M. 아산울라, B. M. G. 키브리아, M. 샤킬, Normal and student´s t distributions and their applications (Atlantis Press, 2014; [링크](http://dx.doi.org/10.2991/978-94-6239-061-4)).\n\n2. P.-C. Bürkner, Brms: An r package for bayesian multilevel models using stan. 80 (2017), doi:10.18637/jss.v080.i01.\n\n3. K. 양, J. 투, T. 첸, Homoscedasticity: an overlooked critical assumption for linear regression. General Psychiatry. 32, e100148 (2019).\n\n<div class=\"content-ad\"></div>\n\n4. D. Makowski, M. S. Ben-Shachar, D. Lüdecke, bayestestR: 베이지안 프레임워크 내에서 효과 및 불확실성, 존재 및 중요성을 설명하는 책 (2019년). 4, 1541 페이지.\n\n5. A. Heiss, 베이지안 베타 및 제로 인플레이티드 베타 회귀 모형으로 비율을 모델링하는 안내서 (2021년), (http://dx.doi.org/10.59350/7p1a4-0tw75에서 다운로드 가능).\n\n6. A. Gelman, J. Hwang, A. Vehtari, 베이지안 모델에 대한 예측 정보 기준 이해. 통계 및 컴퓨팅. 24, 997–1016 페이지 (2013년).\n\n7. D. Lüdecke, M. S. Ben-Shachar, I. Patil, P. Waggoner, D. Makowski, Performance: 통계 모형의 평가, 비교 및 테스트를 위한 R 패키지. 6, 3139 페이지 (2021년).\n\n<div class=\"content-ad\"></div>\n\n8. D. Makowski, M. Ben-Shachar, D. Lüdecke, bayestestR: 베이지안 프레임워크 내에서 효과 및 불확실성, 존재 및 유의성을 설명하는 방법. Journal of Open Source Software. 4, 1541 (2019).","ogImage":{"url":"/assets/img/2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead_0.png"},"coverImage":"/assets/img/2024-06-19-Donotover-thinkaboutoutliersuseastudent-tdistributioninstead_0.png","tag":["Tech"],"readingTime":16},{"title":"여러 브라우저 창 간에 실시간 WebSocket 데이터 공유하기","description":"","date":"2024-06-19 09:22","slug":"2024-06-19-Sharingreal-timeWebSocketdataacrossmultiplebrowserwindows","content":"\n\n# 멀티 스크린 앱이나 여러 창에서 병행하여 실행되는 앱을 만들 때, 모든 연결된 참가자가 동일한 데이터를 공유할 때 트래픽을 많이 절약할 수 있습니다.\n\n스포일러: 우리는 로컬 스토리지를 사용하지 않습니다.\n\n# 내용:\n\n- 소개\n- 데모 비디오\n- 저장소\n- 백엔드\n- RPC 정의 파일\n- 프론트엔드\n- 자식 앱용 셸\n- 브라우저 창 간 위젯 이동\n- Chrome 개발 도구로 앱 검사하기\n- 성능을 더 높일 수 있을까?\n- neo.mjs 프로젝트 업데이트\n\n<div class=\"content-ad\"></div>\n\n# 1. 소개\n\n우리의 데모 앱은 일부러 미니멀리즘한 디자인을 가지고 있습니다. 3가지 위젯(테이블, 파이 차트 및 막대 차트)이 있는 대시보드가 포함되어 있어요. 이 위젯들은 별도의 브라우저 창으로 분리할 수 있습니다.\n\n우리는 데이터 SharedWorker를 사용하여 모든 연결된 창에 대한 데이터를 한 번에 로드하고 있으며, \"스트리밍 모드\"를 사용하여 초당 60번의 새 데이터를 가져오고 있어요.\n\n또한 창을 변경하더라도 동일한 구성 요소 인스턴스를 재사용할 수 있도록 해주는 앱 SharedWorker를 사용하고 있습니다. 이를 통해 상태를 동기화하는 데 도움이 될 거예요.\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-19-Sharingreal-timeWebSocketdataacrossmultiplebrowserwindows_0.png)\n\n## 2. 데모 비디오\n\n이상적으로 큰 화면에서 비디오를 시청하세요.\n\n## 3. 저장소\n\n\n<div class=\"content-ad\"></div>\n\n다음 저장소에서 찾을 수 있습니다:\n\n데모 코드는 MIT 라이선스를 사용하므로 마음대로 사용하고 확장할 수 있습니다. README 파일에는 앱을 로컬에서 실행하기 위한 필요한 단계가 포함되어 있습니다.\n\n온라인에서 직접 테스트해보려면 배포된 버전을 보고 싶다면 미리 알려주세요!\n\n# 4. 백엔드\n\n<div class=\"content-ad\"></div>\n\n우리는 백엔드 코드를 가능한 간단하게 유지하려고 합니다.\n\n우리는 익스프레스와 ws를 사용하여 포트 3001에서 소켓 연결을 받을 수 있는 최소한의 서버를 만들고 있습니다. 또한 neo.mjs 코어를 우리의 Node.js 백엔드 코드에 가져와 내부 유틸리티 함수 및 클래스 구성 시스템을 사용할 수 있도록 합니다.\n\n전체 코드는 여기에 있습니다: ColorService.mjs\n\n우리의 서비스는 read() 메서드만 노출하며, 이 메서드는 우리가 opts 객체 내의 속성으로 전달하는 3가지 매개변수를 기반으로 무작위 데이터를 생성할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n- amountColors\n- amountColumns\n- amountRows\n\n# 5. RPC 정의 파일\n\n실제 앱에서는 각 서비스 내에서 CRUD를 사용하고, 복잡성에 따라 사용 가능한 서비스로 JSON 파일을 동적으로 생성할 것입니다. 특정 사용자 역할이나 권한에 따라 다를 수 있습니다.\n\n우리의 프론트엔드 코드는 이 파일을 fetch()하여 원하는 네임스페이스를 우리에게 노출시킬 것입니다.\n\n<div class=\"content-ad\"></div>\n\n물론 원하신다면 async / await을 사용할 수도 있어요.\n\n여기서 좋은 점은 frontend 코드베이스 내에서 JavaScript 프라미스로 Service 메소드를 직접 사용할 수 있다는 거예요.\n\n진짜 편리하죠 :)\n\n<img src=\"/assets/img/2024-06-19-Sharingreal-timeWebSocketdataacrossmultiplebrowserwindows_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n만약 애플리케이션 SharedWorker(프론트엔드 코드) 내에서 Colors.backend.ColorService.read()를 사용한다면, neo.mjs는 데이터 SharedWorker로 메시지를 보낼 것입니다. 관심사의 분리입니다. 데이터 워커는 소켓 연결이 이미 존재하는지 확인하고 필요한 경우 (재)연결합니다. 그런 다음 소켓을 통해 메시지를 보내고 백엔드 코드 내에서 ColorService.read()를 실행할 것입니다. 특정 소켓 연결 메시지의 응답은 App-Worker로 다시 전송됩니다. 초기 호출자에게 매핑된 후 우리의 Promise를 해결할 것입니다.\n\n개발자로서 여러분은 여기에서 일어나는 마법에 대해 걱정할 필요가 없습니다.\n\n# 6. 프론트엔드\n\nnpx neo-app을 사용하여 앱 셸을 자동으로 생성했습니다.\n\n<div class=\"content-ad\"></div>\n\nNeo 앱의 인덱스 파일은 MicroLoader 모듈만 포함하게 됩니다. 이 모듈은 우리 앱 폴더 안의 neo-config.json 파일을 가져와 neo 메인 스레드를 시작할 것입니다. 이 스레드는 워커 설정을 생성하고 완료되면 우리 앱 폴더 안의 app.mjs 파일을 동적으로 로드할 것입니다.\n\n우리 앱 SharedWorker에 로드되는 Viewport 파일:\n\nViewport에는 3개의 위젯과 HeaderToolbar가 직접 items 배열에 들어갑니다. 또한 view controller와 view model을 가져옵니다.\n\nNeo에서의 view model은 상태 제공자(다른 라이브러리/프레임워크에서는 \"store\"로 불림)로서, 자식 뷰가 데이터 속성에 바인딩할 수 있도록 허용합니다. 부모 체인 내에서 여러 데이터 속성에 바인딩할 수도 있습니다. 이 데모 앱에 중요한 부분은: 우리의 상태 트리가 모든 브라우저 창에서 작동한다는 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 7. 자식 앱을 위한 쉘\n\n주 앱과 마찬가지로 MicroLoader가 들어 있는 index 파일과 Viewport을 가져오는 app.mjs 파일이 있는 인덱스 파일이 있습니다:\n\nViewport은 완전히 비어 있어서, 주 앱을 로드하지 않고 앱을 열면 다음과 같이 나타날 것입니다:\n\n![이미지](/assets/img/2024-06-19-Sharingreal-timeWebSocketdataacrossmultiplebrowserwindows_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 8. 브라우저 창 간 위젯 이동\n\n저희 주 앱 ViewportController 내에서는 앱 SharedWorker에 연결된 각 브라우저 창에 대해 발생하는 connect 이벤트에 구독하고 있습니다.\n\n연결된 창이 주 앱 창이 아닌 경우 다음을 호출합니다:\n\n```javascript\nwidgetParent.remove(widget, false);\n```\n\n<div class=\"content-ad\"></div>\n\n우리는 메인 창 안의 뷰포트에서 원하는 위젯(테이블, 파이 차트 또는 바 차트)를 제거하고 있어요. 두 번째 매개변수 false는 컴포넌트 인스턴스를 파괴하지 않도록 하는 플래그입니다.\n\nmainView.add(widget);\n\n그런 다음 위젯을 메인 뷰 → 다른 브라우저 창의 뷰포트에 추가하고 있어요. 동일한 컴포넌트 인스턴스를 재사용하기 때문에 최신 상태를 손쉽게 얻을 수 있어요.\n\n정말로 이렇게 간단해요.\n\n<div class=\"content-ad\"></div>\n\n컴포넌트 인스턴스 재사용에 대한 주제는 메모리 누수를 줄이고 런타임 성능을 향상시키는 매우 강력한 기술이기 때문에 개별 블로그 게시물이 필요합니다.\n\n# 9. Chrome 개발 도구로 앱 검사하기\n\nNeo에서 단일 창 앱을 만들 때 프레임워크는 Dedicated Workers를 사용하며, 이를 주 창 콘솔에서 직접 확인할 수 있습니다.\n\n\"neo-config.json\" 파일에 \"useSharedWorkers”: true를 추가하면 프레임워크가 SharedWorkers로 전환되며, 브라우저 창 콘솔에서는 더 이상 확인할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\nNeo.mjs는 Worker를 위한 추상화 계층을 제공하여 개발자의 API가 정확히 동일하게 유지됩니다. 우리는 언제든지 1줄의 구성을 변경할 수 있습니다. SharedWorker를 검사하려면 다음을 열어야 합니다:\n\nchrome://inspect/#workers\n\n![이미지](/assets/img/2024-06-19-Sharingreal-timeWebSocketdataacrossmultiplebrowserwindows_3.png)\n\n앱의 SharedWorker를 검사하고 콘솔에 다음 코드를 입력하세요:\n\n<div class=\"content-ad\"></div>\n\n# 10. 성능을 더 향상시킬 수 있을까요?\n\n데모 앱은 매우 빠르게 느껴지지만 아직은 성능을 최적화하지 않은 상태입니다. 그러므로 이 질문에 대한 답변은 명확히 \"네!\"입니다. 여전히 우리는 AmCharts 주요 스레드 애드온을 버전 5로 업그레이드(재작성)해야 합니다. 이에 우선 순위를 부여해야 할 필요가 있다면 미리 알려주세요.\n\n또한 여러 가지 앱 설정을 시험해볼 수도 있습니다. 예를 들어, 데이터 워커 대신 앱 워커 내에서 소켓 연결을 직접 생성하여 내부 포스트 메시지의 양을 줄일 수 있습니다.\n\n# 11. neo.mjs 프로젝트 업데이트\n\n<div class=\"content-ad\"></div>\n\n1.5년 만에 올린 첫 블로그 포스트였어요. 마음에 드셨으면 좋겣어요! 궁금한 점이 있으시면 언제든지 물어보세요.\n\n그동안 프레임워크는 많이 발전했어요. 가장 중요한 업데이트는 새 제품 웹사이트를 준비 중이라는 점이에요. 이 사이트에는 오랫동안 기다리셨던 자기 학습 섹션이 첫 번째 버전으로 포함될 예정이에요. 이를 완성하는 대략적인 시간은 한 달 정도 남았어요.\n\n우리는 아직 매주 목요일 오후 5시 30분(CEST 기준)에 무료 워크숍을 진행하고 있어요. 참여하고 싶다면 슬랙 채널에서 연락해주세요.\n\n회사에서 더 많은 도움이 필요하다면, neo.mjs 코어 팀은 전문 강사가 진행하는 인도주도 훈련(40시간, 6~12명 참가자)뿐만 아니라 전문 서비스(예: 차세대 앱 개발 지원)도 제공하고 있어요.\n\n<div class=\"content-ad\"></div>\n\n피드백을 매우 환영합니다!\n\n진심으로, 즐거운 코딩하세요,\n토비아스","ogImage":{"url":"/assets/img/2024-06-19-Sharingreal-timeWebSocketdataacrossmultiplebrowserwindows_0.png"},"coverImage":"/assets/img/2024-06-19-Sharingreal-timeWebSocketdataacrossmultiplebrowserwindows_0.png","tag":["Tech"],"readingTime":6},{"title":"UEFA Euro 2024를 예측하기 위한 ML  포아송 모델","description":"","date":"2024-06-19 09:20","slug":"2024-06-19-AnMLPoissonmodeltopredictUEFAEuro2024","content":"\n\n<img src=\"/assets/img/2024-06-19-AnMLPoissonmodeltopredictUEFAEuro2024_0.png\" />\n\n2022 월드컵 이브에 제가 \"기계 학습으로 2022 FIFA 월드컵 예측\"이라는 기사를 여기에 게시했습니다. 이 기사는 제 첫 번째이자 지금까지 제가 Medium에서 가장 많이 읽힌 기사였습니다. 이 기사는 제게 매우 중요해서, 2022년 말부터 이어온 데이터 과학자로서 스포츠 분석에 중점을 둔 역할로 직업을 바꿨습니다. 하지만 긍정적인 반향이 있음에도 불구하고, 그 모델의 많은 부분을 개선할 수 있다고 믿었습니다.\n\n스포츠 분석 업무를 하면서 그 분야의 최신 동향을 많이 연구하게 되었고, 결과 예측에 대한 연구가 많았습니다. 대부분의 연구는 정확한 결과 또는 경기 승자를 예측하기 위해 포아송 분포를 사용합니다. 포아송 분포를 개선하려는 많은 연구가 있는데, 그 중에서도 최적 λ 매개변수(포아송의 기대값)를 선택하려는 연구가 많았습니다. 대부분의 연구는 간단한 골 평균/이동 평균을 사용하지 않도록 공격력과 수비력과 같은 지표를 개발했습니다. 이러한 접근법은 한계가 있다고 생각했고, 나는 직접 기계 학습 회귀 모델을 사용하여 λ 매개변수를 찾아내는 모델을 만들어, 홈팀과 원정팀 각각의 승리 확률을 계산하기로 결정했습니다.\n\n최적의 λ 매개변수를 찾기 위해, 나의 회귀 모델은 홈팀과 원정팀이 경기에서 할 골의 예상 수를 예측했습니다. 각 팀의 예측된 값은 포아송 분포에서 λ로 사용되었습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![그림](/assets/img/2024-06-19-AnMLPoissonmodeltopredictUEFAEuro2024_1.png)\n\n유로 대회에 대해 왜 그렇게 하나요? 먼저, 저는 4년마다 열리는 국제 대회를 좋아합니다. 또한, 국제 대회는 \"공격 강도\"라는 간단하고 일반적인 계산에 결합될 수 있는 매개변수가 있습니다. 이는 국가대표팀의 FIFA 순위입니다.\n\n# 데이터 출처\n\n2022년 월드컵 예측에 사용한 동일한 데이터셋을 사용했습니다: 지난 경기와 FIFA 순위. 둘 다 Kaggle에서 찾을 수 있으며, 결과는 2024년 6월 11일까지의 경기 결과가 포함되어 있습니다. 이 모델에서는 2019년 8월 1일 이후의 결과를 사용했습니다.\n\n\n<div class=\"content-ad\"></div>\n\nML 모델의 성능을 많이 향상시킬 수 있어요. 예상 골 같은 고급 축구 데이터와 슛, 코너, 그리고 프리킥과 같은 통계를 사용해 보면 좋을 거에요. 문제는 국제 경기용 이런 종류의 데이터를 구하는 것이 꽤 어렵다는 거죠.\n\n# 피쳐 엔지니어링\n\n피쳐 개발은 2022 월드컵 프로젝트에서 했던 것과 동일했어요. 거의 동일한 코드를 사용했지만 팀의 골과 랭킹 차이에 가중치를 부여하지 않고 새로운 피처 세트를 만들었어요:\n\n- home_weight_goals & away_weight_goals: 팀이 넣은 평균 골에 랭킹 차이를 곱한 값\n- home_weight_points & away_weight_points: 팀이 획득한 평균 포인트에 랭킹 차이를 곱한 값\n\n<div class=\"content-ad\"></div>\n\n또한 랭크 차이에 의한 가중치 버전의 골을 5경기 이동 평균으로 만들었습니다.\n\n이전 프로젝트인 2022 월드컵은 국제 경기에서 FIFA 랭킹이 좋은 예측 요인임을 보여줬습니다. 또한 팀 랭킹 간의 차이가 더 나은 예측자임을 알 수 있었습니다. 현재 골 수를 예측하는 문제에서는 팀 골과 상대편 골을 조합한 평균이 좋은 예측자일 가능성이 높습니다. 그래서 두 가지를 결합하기로 결정했습니다.\n\n# 데이터 분석\n\n다음 단계는 데이터를 분석하여 모델에 예측력이 있는 특성을 선택하는 것입니다. 현재 모델의 목적은 홈팀과 어웨이팀의 골 수를 예측하는 것이므로 WC 2022 예측 기사에서 만든 분석은 사용할 수 없지만, Rank 차이가 좋은 예측자임을 알 수 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n첫 번째 분석은 가능한 특징과 목표(홈/원정에서 기록한 득점) 사이의 선형 회귀 그래프를 만들 것입니다. 이를 통해 우리는 가능한 선형 관계를 찾을 수 있을 것입니다.\n\n경기에서의 득점은 매우 제한된 범위 내에서 연속 변수이므로(팀이 경기에서 기록할 수 있는 최소 득점은 0이고, 한 팀이 경기에서 6개 이상의 득점을 기록하는 것은 매우 드물다), 저는 또한 목표 수가 높은 예측력을 가질 가능성이 있는 변수의 분포에 득점 수가 어떤 영향을 미치는지 분석할 것입니다. 예를 들어 팀 득점 평균치 등.\n\n![이미지1](/assets/img/2024-06-19-AnMLPoissonmodeltopredictUEFAEuro2024_2.png)\n\n![이미지2](/assets/img/2024-06-19-AnMLPoissonmodeltopredictUEFAEuro2024_3.png)\n\n<div class=\"content-ad\"></div>\n\n아래 그림은 홈 팀에 대한 첫 번째 분석을 보여줍니다. 예상대로, 어떤 특성도 명확한 선형 관계가 없었지만, 랭크 차이와 랭크 차이로 가중된 특성이 시각적으로 가장 영향을 받은 것으로 나타났습니다. 그래서 저는 이들 특성이 경기에서의 득점 수에 어떻게 영향을 받는지 확인해 보려고 합니다.\n\n위의 그림은 랭크 차이로 가중된 홈 팀의 평균 득점을 보여줍니다. 0, 1, 2, 3골 사이를 구분할 때 주로 득점 수에 영향을 받는 분포가 명확히 보입니다. 이는 또한 랭크 차이로 가중된 원정팀이 입은 평균 골과 홈팀과 원정팀이 획득한 점수 평균에도 동일하게 나타납니다. 이러한 특성들의 5경기 이동 평균 버전은 득점 수에 크게 영향을 받지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n이것은 우리에게 어떤 일이 발생할 것인지에 대한 단서를 제공합니다. 그럼, 가중 특징으로만 가득 찬 평균만 사용하여 테스트하겠습니다.\n\n![이미지](/assets/img/2024-06-19-AnMLPoissonmodeltopredictUEFAEuro2024_6.png)\n\n결과는 상당히 유사하지만, 예상대로 반대 방향입니다. 홈 팀보다 랭킹이 낮은 원정 팀이 더 강한 팀이라고 가정할 때, 원정 모델에서 양의 피처를 가지고 있으면 원정팀이 이기고, 홈 팀 모델에는 그 반대의 기대가 있습니다.\n\n# 기계 학습 모델\n\n<div class=\"content-ad\"></div>\n\n이제 기능을 갖춘 상태이므로, 홈 골과 어웨이 골을 예측하는 두 가지 모델을 개발해야 합니다. 선형 회귀, 랜덤 포레스트 회귀 및 그래디언트 부스팅 회귀 세 가지 모델을 테스트할 것입니다. 특성과 목표 간에 선형 관계가 명확하지 않기 때문에 모델 성능은 R2 스코어 대신 평균 제곱 오차(MSE)로 평가할 것입니다. 하지만 선택한 모델을 선정하는 주요 분석은 예측값의 분포와 잔차를 확인하는 것입니다.\n\n홈 골과 어웨이 골 둘 다 랜덤 포레스트 모델을 선택했습니다.\n\n홈 팀의 경우, 선형 회귀와 랜덤 포레스트(선택한 모델)의 분석을 보여드리겠습니다. 왜 랜덤 포레스트를 선택했는지를 설명하겠습니다. 먼저 두 모델에 대한 실제 대 예측 값의 차이를 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-19-AnMLPoissonmodeltopredictUEFAEuro2024_8.png)\n\n두 플롯을 비교해 보면 오차의 유사한 패턴을 확인할 수 있습니다. 그러나 선형 회귀가 이 문제에서 실패하는 지점도 볼 수 있습니다. 말했듯이, 골의 수가 연속 변수임에도 불구하고 그 값의 범위가 매우 제한적입니다. 선형 회귀가 가끔 예측하는 것처럼 경기에서 0 골 미만은 가질 수 없습니다. 왜냐하면 선형 회귀 모델은 학습할 때 본 경계를 넘어서 예측을 할 수 있지만, 트리 기반 모델은 그렇지 못하기 때문입니다.\n\n이는 종종 트리 기반 모델의 문제로 여겨지지만, 여기서는 선형 회귀 모델과 비교했을 때 큰 장점으로 여겨집니다.\n\n물론, 선형 회귀가 예측한 값이 0 미만인 경우를 수동으로 0으로 설정할 수 있지만, 그렇게하는 것은 랜덤 포레스트보다 모델이 훨씬 좋은 성능을 발휘할 경우에만 의미가 있습니다. 그러기 위해 잔차를 분석해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n회귀 모델의 잔차는 예측값과 실제 값의 차이입니다. 우리는 위에서 볼 수 있듯 랜덤 포레스트는 홈 팀의 골을 조금 더 과소 평가합니다. 하지만 이는 음수 예측값을 해결하기 위해 선형 회귀를 사용하는데 충분한 큰 차이가 아닙니다. 그래서 저는 랜덤 포레스트를 선택했습니다.\n\n원정팀 골 모델에서도 비슷한 분석을 진행하고 다시 랜덤 포레스트를 선택했습니다. RF와 그래디언트 부스팅 중에서는 결과가 매우 유사합니다. 저는 더 복잡한 모델로는 과적합이 발생할 수 있는 작은 데이터베이스를 사용하고 있기 때문에 계속해서 RF를 선택했습니다.\n\n# 포아송 모델\n\n이제 홈팀과 원정팀 분포를 예측하는 모델을 가지고 있으므로 홈 승리, 무승부 및 원정 승리의 확률을 계산할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그것을 하기 위해, 우선 독일과 스코틀랜드의 UEFA 유로 첫 번째 경기 예시로 0~10 골에 대한 포아송 확률을 계산합니다.\n\n이제 각 팀이 0~10 골을 넣는 확률을 가지고 있으므로, 각 정확한 결과의 확률을 계산할 수 있습니다. 아래 표에 표시되어 있습니다:\n\n\n| 골 수 | 스코틀랜드 승 확률 | 독일 승 확률 | 무승부 확률 |\n|-------|-------------------|-------------|-------------|\n|   0   |      0.100        |    0.200    |   0.150     |\n|   1   |      0.150        |    0.180    |   0.100     |\n|   2   |      0.120        |    0.150    |   0.080     |\n|  ...  |       ...         |     ...     |    ...      |\n\n\n빨간색으로 표시된 것은 스코틀랜드가 이기는 시나리오의 확률입니다. 초록색으로 표시된 것은 독일이 이기는 시나리오이고, 노란색은 무승부입니다. 독일이 이기는 확률, 무승부 확률, 스코틀랜드가 이기는 확률을 알기 위해 매트릭스의 각 부분을 합산합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-AnMLPoissonmodeltopredictUEFAEuro2024_10.png)\n\n# 시뮬레이션\n\n이제 모든 모델이 준비되었으니, 재미있는 부분에 들어갈 시간이에요. 게임을 시뮬레이션하기 위해, 그룹 단계의 각 경기에 대한 골의 기대값을 예측합니다. 그러나 문제가 하나 있어요. 모델은 분명히 많은 비김을 과소 평가합니다. 그래서, 이것을 조정하기 위해 비김에 보정을 주기로 했어요. 각 팀의 확률에서 5%를 제거하고 이를 비김 확률에 추가했어요.\n\n시뮬레이션된 경기의 결과는 아래에 표시되어 있어요:\n\n\n<div class=\"content-ad\"></div>\n\n그룹 스테이지 시뮬레이션을 완료한 후, 그룹 경기 결과를 계산했습니다. 아래는 모든 그룹을 포함한 전체 테이블입니다:\n\n프랑스가 네덜란드와 이탈리아에 패배하며, 타이틀 수비자인 이탈리아가 크로아티아 뒤에 머물게 된 것이 가장 큰 놀란 점 같아요. 위에서 보시다시피, 최고의 3위 팀들을 이미 계산한 상태입니다.\n\n이제는 챔피언십 스테이지를 시뮬레이션해야 합니다. UEFA Euro는 여러분이 여기서 찾아볼 수 있는 매우 독특한 매치 조합을 가지고 있습니다. 이것은 제 분석을 위한 코드 기반이 되었고, 아래에는 WC 2022 시뮬레이션을 위해 만든 동일한 차트에 결과가 표시되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n\n![모델_스코어](/assets/img/2024-06-19-AnMLPoissonmodeltopredictUEFAEuro2024_12.png)\n\n프랑스가 예측된 우승팀이라는 것을 볼 수 있습니다. 이것은 매우 현실적이라고 생각합니다. 벨기에가 준우승했고, 특히 반 결승에서 잉글랜드를 꺾고 매우 치열한 경기를 치렀다는 점에서 놀라운 일이라고 생각합니다.\n\n# 결론\n\n프로젝트의 취지는 내가 가장 좋아하는 축구를 예측하기 위해 데이터 과학과 ML 지식을 활용하는 것이었습니다. 그러나 이번에는 제 첫 번째 모델이 갖고 있던 일부 결함도 수정하고자 했습니다. 예를 들어, 2022 월드컵 모델은 무승부를 예측하지 않았습니다!\n\n\n<div class=\"content-ad\"></div>\n\n저는 이 목표가 달성되었다고 생각해요. 이 모델은 더 많은 과학적 근거를 바탕으로 하며 축구 예측의 최신 기술을 많이 반영하고 있어요. 또한, 이 모델은 다양한 용도로 활용할 수 있어요. 예를 들어, 한 경기에서 3골 이상이 나올 확률을 얻는 것이 가능해요.\n\n자세한 코드를 보고 싶다면 GitHub 저장소를 확인해주세요. 제 LinkedIn으로 연락하고 싶다면, 그게 저의 LinkedIn이에요. 감사합니다!\n\n## AI Mind로부터의 메시지\n\n<img src=\"https://miro.medium.com/v2/resize:fit:500/0*5Wm7sOfTpe5DEbhg.gif\" />\n\n<div class=\"content-ad\"></div>\n\n우리 커뮤니티에 참여해 주셔서 감사합니다! 떠나시기 전에:\n\n- 👏 이야기에 박수를 보내고 저자를 팔로우하세요 👉\n- 📰 AI Mind 판에서 더 많은 콘텐츠를 확인하세요\n- 🧠 무료로 AI 프롬프트를 손쉽게 향상하세요\n- 🧰 직관적인 AI 도구를 발견하세요","ogImage":{"url":"/assets/img/2024-06-19-AnMLPoissonmodeltopredictUEFAEuro2024_0.png"},"coverImage":"/assets/img/2024-06-19-AnMLPoissonmodeltopredictUEFAEuro2024_0.png","tag":["Tech"],"readingTime":7},{"title":"보스턴 마라톤 예선 기준은 모든 연령 그룹에 공정한가요","description":"","date":"2024-06-19 09:17","slug":"2024-06-19-AretheBostonMarathonQualifyingTimesFairForAllAgeGroups","content":"\n\n<img src=\"/assets/img/2024-06-19-AretheBostonMarathonQualifyingTimesFairForAllAgeGroups_0.png\" />\n\n이제 2주 뒤에는 러닝 세계가 보스턴 마라톤을 주목할 것입니다.\n\n러너 중 대다수인 약 22,000명은 다른 마라톤에서 예선 시간을 통과하여 레이스에 참가했습니다.\n\n약 11,000명의 러너도 예선 시간을 달성했지만 거부당했습니다. 그리고 그 외 많은 수의 러너들이 파격적인 시간을 몇 분 초과하여 예선에 성공하지 못했을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n집에서 패트리어츠 데이를 보는 모든 러너들을 위해, 물론 내년을 향한 희망이 있습니다. 하지만 올해의 경주에서 주목이 내년에 대한 자격 취득으로 옮겨감에 따라, 대화는 자격 취득 시간을 중심으로 이루어지게 될 것이며, 깊은 컷오프 시간을 피하기 위해 변경이 필요한지에 대한 문제를 둘러싸고 진행될 것입니다.\n\n최근, 저는 연령 등급을 더 잘 이해하고 선수들 간의 경주 성적을 비교할 대안적 방법을 제공하기 위해 마라톤 시간에 대한 분석을 진행해왔습니다.\n\n이 연구의 일환으로, 저는 보스턴 자격 취득 시간에 관한 질문을 데이터를 기반으로 조사할 수 있는 방대한 결과 샘플을 수집했습니다.\n\n그렇다면 보스턴 자격 기준은 공정한가요 - 아니면 특정 그룹의 러너들을 다른 그룹보다 유리하게 만드는 경향이 있나요?\n\n<div class=\"content-ad\"></div>\n\n# 사용하는 데이터는 무엇인가요?\n\n마라톤 결과 나이 등급 시리즈의 일환으로, 분석을 위해 대규모의 마라톤 결과 샘플을 수집하고 준비했습니다.\n\n샘플에 대해 더 알고 싶다면 이곳을 참조해주세요. 하지만 여기서 간단히 요약해드리겠습니다.\n\n이 샘플에는 미국에서 진행된 2023년 미국 마라톤의 모든 결과가 포함되어 있습니다. 결과는 Marathon Guide, Athlinks 및 특정 대형 레이스의 개별 웹사이트에서 수집되었습니다.\n\n<div class=\"content-ad\"></div>\n\n이름, 성별, 나이 및 각 완주에 대한 시간을 수집했어요. 그런 다음 BAA가 자격 취득 목적으로 사용하는 연령 구간 별로 러너들을 분류했어요.\n\n이 결과를 이름과 연령 그룹으로 그룹화하여 중복 항목을 식별하기 위한 예비 시도를 했어요. 완벽하지는 않지만 대부분의 중복 항목을 포착해야 해요. 이를 통해 총 완주 횟수(약 40만 건 가까이)가 약 33만 개의 개별 러너로 좁혀졌어요.\n\n해당 연도에 여러 번 완주한 러너들의 경우, 가장 좋은 시간을 유지했어요. 그런 다음 그들의 시간을 자격 취득을 위한 Boston 기준 시간과 비교하여 차이를 기록했어요.\n\n# 그래서 몇 명의 사람들이 보스턴 자격 취득 시간을 달렸을까요?\n\n<div class=\"content-ad\"></div>\n\n큰 그림부터 시작해볼까요? 실제로 자격 시간을 달성한 러너는 몇 명이나 될까요?\n\n샘플 집합에서 식별된 336,687명의 개별 러너 중 44,059명이 자신의 연령 그룹에 해당하는 자격 시간을 달리셨어요.\n\n이는 전체의 13%에 해당합니다.\n\n보스턴 마라톤에 부여된 높은 지위를 고려했을 때, 처음 눈에 띌 정도로 놀랍게 높아 보이죠.\n\n<div class=\"content-ad\"></div>\n\n한편, 2024년 보스턴 마라톤은 기록적인 수의 자격 인정 신청자들을 보았다는 점을 감안하면, 그리 놀라운 일이 아니라고 할 수도 있습니다.\n\n요즘들어 러너들이 뚜렷하게 빨라졌다는 사실도 있습니다. 이에 관해 이전에 썼던 내용인데요. 그러니 이것이 새로운 표준이 될 수도 있습니다. 또한 BAA가 자격 기준을 재검토해야 할 필요가 있을지도 모릅니다.\n\n하지만 이 질문은 나중에 남기로 하죠. 오늘 우리가 진짜로 궁금해하는 점은 자격 기준이 연령 그룹과 성별에 공평하게 적용되는지, 그리고 그 13%의 자격 통과율이 전체 러닝 인구를 잘 대변하는지에 대한 것입니다.\n\n# 연령 채점이 자격 시간의 균형에 대해 어떤 것을 시사하나요?\n\n<div class=\"content-ad\"></div>\n\n엠퍼리컬 데이터를 살펴보기 전에, 좀 더 일반적인 전제로 시작해볼까요?\n\n이 주제가 나오면, 누군가는 대개 나이 등급이 이러한 시간들이 동등하게 어렵지 않다고 언급하는 경우가 많아요.\n\n나는 나이 등급 시스템에 몇 가지 우려가 있고, 보정에 대한 문제가 있다고 생각해요. 하지만 이는 어떤 시각을 제공하는 좋은 시작점입니다.\n\n그렇다면 서로 다른 자격 시간들은 어떻게 나이 등급에 따라 비교될까요?\n\n<div class=\"content-ad\"></div>\n\n위 시각은 각 자격 시간에 대한 연령 등급 점수를 플로팅한 것으로, 남성이 왼쪽에, 여성이 오른쪽에 위치합니다.\n\n대체로 모두 비슷한 수준에 있습니다—60에서 70 사이. 그러나 연령 그룹 사이에는 확실한 차이가 있습니다.\n\n35세 미만 남성의 시간(3:00)이 가장 높은 연령 등급을 보입니다(67.58). 그 다음 몇 개의 연령 그룹(35-39부터 55-59)은 모두 조금 낮습니다. 대략 65 정도를 유지합니다. 연령이 들어갈수록, 연령 등급은 더 낮아지는 경향을 보입니다—특히 75-79세 남성이 가장 낮은 연령 등급을 가집니다(61.74).\n\n나이가 들수록, 남성의 연령 등급은 일반적으로 낮아지는 경향이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n한편, 여성들은 어떻게 되고 있나요?\n\n35세 미만 여성들의 기준은 다음 연령 그룹들보다 약간 높습니다(63.84). 50대와 60대 여성들은 약 64의 연령 등급이 필요합니다. 실제로 70대 여성들에 대해서는 증가하며, 80세 이상 여성들은 어떤 연령 그룹보다 높은 연령 등급(68.34)이 필요합니다.\n\n2024 컷오프(-5:29)를 사용할 수 있는 시각화 내에서 드롭다운을 사용할 수도 있습니다. 이는 전체적인 패턴을 변경하지는 않지만, 올해의 컷오프 시간과 잠재적으로 낮은 자격시간으로 어떻게 다르게 보이는지 알려줍니다.\n\n연령 등급에 익숙하지 않다면, 이러한 차이가 그다지 중요하지 않다고 생각할 수 있습니다. 하지만 이 연령 등급 시스템의 특성상 중간 구간(60-70)에서 시간의 큰 차이가 연령 등급 점수의 작은 변화에 의해 알아채기 어려운 것입니다.\n\n<div class=\"content-ad\"></div>\n\n남성 75-79세의 예선 기준 시간은 4:35로, 35세 미만 남성의 예선 기준 시간(3:00)보다 단지 5포인트 낮습니다. 그러나 연령 평가 시스템에서는 3:17:03과 동등합니다. 그렇게 말하면, 상당히 큰 차이가 있습니다.\n\n위 시각화 자료는 각 표준에 대한 연령 평가 시간을 플로팅합니다 — 여성은 보라색으로 위쪽에 위치하고, 남성은 파란색으로 아래쪽에 위치합니다.\n\n남성의 연령 평가 시간이 점점 느려지는 것을 주목해 보세요. 반면 여성의 경우 35-49세 이전에서 가장 쉽고, 70대와 80대 초반에 가장 어려운 시간을 보이는 것을 알 수 있습니다.\n\n연령 평가에 따르면, 남성은 노화할수록 예선이 더 쉬워지는 것으로 보입니다. 반면 여성은 나이가 들수록 더 어려워지는 것으로 나타납니다.\n\n<div class=\"content-ad\"></div>\n\n성별을 비교해보면, 젊은 여성이 젊은 남성보다 더 쉽게 할 수 있는 것으로 보입니다 - 하지만 달리기를 하는 사람들이 60대에 이르러면 균형이 뒤바뀝니다.\n\n이것을 염두에 두어두세요. 그러나 하나의 그룹에 대해 연령 등급 자체가 잘 보정되어 있지 않을 수 있음을 알아두세요.\n\n참고: 이 예제들을 위해, 35세 미만이면 주인공이 30세라고 가정했으며, 그렇지 않으면 특정 연령 그룹에서 가장 어린 해였습니다. 연령 등급은 개별 해별로 계산되기 때문에 특정 개인에 대해 점수와 등급 시간이 약간 다를 수 있습니다. 그러나 이것들은 연령 그룹간의 관련성 큰 그림에 영향을 미치지 않습니다.\n\n# 그래서 경험적 데이터는 무엇을 말하나요?\n\n<div class=\"content-ad\"></div>\n\n이제 기본 가정이 설정되었으니, 실제 예선자 데이터가 이를 지지하는지 여부를 확인해 봅시다.\n\n위의 시각화는 예선 기준을 충족하는 러너들의 비율과 실제 인원을 모두 나타내며 성별에 따라 분류됩니다.\n\n왼쪽을 보면 남성(25,219 명)보다 여성(18,840 명)이 훨씬 더 예선을 달성합니다. 그러나 여성의 예선 비율이 더 높습니다. - 14% 대비 13%.\n\n실제 예선자 수의 격차는 그 분야 자체의 반영입니다. 남성이 여성보다 더 많이 마라톤을 뛰기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n일부는 역사적인 상품입니다. 남성 마라톤은 1896년 아테네 올림픽과 1897년 보스턴 마라톤으로 거슬러 올라갑니다.\n\n처음에는 여성이 전혀 참가할 수 없었습니다. 1960년대에 규정이 바뀌어 여성이 경쟁할 수 있게 되었지만, 마라톤의 대중 참여의 첫 파도는 남성에 의해 주도되었습니다. 미국에서의 첫 여자 마라톤 선수권은 1970년에 이루어졌으며, 올림픽에서의 경쟁은 1984년에 이뤄졌습니다.\n\n1980년대에는 보스턴 마라톤의 참가자 중 아주 소수가 여성이었습니다. 지난 50년 동안 여성 참가자가 상당히 늘어났고, 작년에는 대략 43%가 여성으로 이루어진 마라톤 참가자였습니다.\n\n이것은 내 샘플에 따르면 전체 러너들의 인구 조사에 비해 약간 더 균형잡힌 필드입니다. 2023년에는 약 59%가 남성이고 41%가 여성이었습니다.\n\n<div class=\"content-ad\"></div>\n\n그럼 아마도 BAA는 여성을 위해 표준을 약간 더 쉽게 만들기로 의도한 것일지 모릅니다. 이렇게 하면 경기장이 더 공정해지겠죠? \n\n# 나이 차이는 어떨까요?\n\n그럼 나이 그룹별로 더 자세히 살펴본다면 어떨까요?\n\n남성과 여성 사이의 작은 차이 뿐인가요? 아니면 젊은 러너와 나이 든 러너 사이에 큰 차이가 있는가요?\n\n<div class=\"content-ad\"></div>\n\n위의 시각화에서 파란 막대는 특정 연령 그룹에서 합격한 여성의 백분율을 보여주며, 보라색 막대는 남성의 백분율을 보여줍니다.\n\n각 연령 그룹에 걸쳐 여성 쪽에는 적어도 약간의 우위가 있습니다. 정확한 격차는 다르지만 전반적으로 1% 정도의 차이가 있습니다.\n\n연령 그룹을 통해 변동이 꽤 많이 있습니다.\n\n남녀 모두에서 35세 미만의 러너들이 최저 자격률을 가지고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n런너들이 30대 후반에서 40대에 접어들면서 조금씩 증가합니다. 45-49세 그룹에서 여성의 경우 17%가 자격을 얻고, 남성은 16%가 그렇습니다.\n둘 다 50대에 약간의 감소가 있지만, 이 비율은 여전히 30대와 초기 40대 러너들보다 높습니다. 60대의 러너들에게서 최고점을 찍습니다. 남녀 모두, 60대의 러너 중 약 19-20%가 자격을 얻습니다.\n70대 러너들에 대한 자격 획득 비율은 낮아지지만, 70-74세 그룹은 여전히 더 어린 러너들보다 높은 비율로 자격을 얻습니다.\n80대 여성들 사이에서는 엄청난 증가가 있습니다 - 하지만 이곳에서 중요한 점은 이것이 샘플에서 가장 적은 연령 그룹이라는 것입니다. 80세 이상 여성은 단 46명뿐입니다. 따라서 21%가 10명의 여성을 대표하며, 소수의 추가 이상점만 있어도 이 비율을 쉽게 왜곡시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 데이터를 보면 나이가 많은 러너들이 자격을 얻기 위한 기준 시간을 만족시키는 비율이 젊은 러너들보다 높다는 것을 분명히 알 수 있습니다. 성별에 관계없이요.\n\n# 이 시간 제한이 미치는 영향은 무엇일까요?\n\n만약 BAA가 엄격한 시간 제한을 시행해야 한다면 어떤 영향이 있을까요? 이로 인해 누가 자격을 얻고 누가 얻지 못하게 되는지가 변하게 될까요?\n\n위 시각화 자료는 절단 시간이 0분(제한 없음)부터 10분까지 얼마나 깊게 내려가는지에 따라 성별(파란색이 여성, 보라색이 남성)에 따른 자격 통과자를 살펴봅니다.\n\n<div class=\"content-ad\"></div>\n\n역사적으로, 가장 늦은 컷오프 시간은 2021년에 발생한 7시 47분이었습니다.\n\n컷오프 시간이 늘어날수록 전체 참가자 수는 줄어듭니다 (당연한 이야기지만, 그것이 목적이죠). 그러나 여성들의 비율이 조금씩 늘어나는 흐름이 있습니다.\n\n컷오프 시간이 없을 때, 참가자 중 42.8%가 여성이었습니다. 5분에서는 이 비율이 43.5%로 늘어났습니다. 10분에서는 더 늘어난 44.7%로 증가했습니다.\n\n그럼 연령대는 어떻게 될까요?\n\n<div class=\"content-ad\"></div>\n\n이 시각화는 연령대별로 무제한에서 10분 제한까지의 세분화를 보여줍니다. 여성과 남성 사이를 전환하기 위해 드롭다운 메뉴를 사용할 수 있습니다.\n\n양쪽 모두에서 20대와 30대의 예선자 비율이 감소합니다. 40대 이상의 비율은 증가합니다.\n\n제한 시간이 모든 분야에 적용되므로, 연령대별로 각각의 기준 시간을 동일한 시간만큼 줄였을 경우 어떤 일이 일어날지에 대한 아이디어를 얻을 수 있습니다.\n\n각 선수의 버퍼의 평균이나 중앙값을 살펴보면, 나이가 들수록 증가합니다. 평균적으로 나이가 많은 러너들은 기준보다 훨씬 더 낮은 시간으로 예선에 합격합니다.\n\n<div class=\"content-ad\"></div>\n\n이 또한 직관적으로 이해하기 쉽지요. 느린 시간대에는 해당 차이(2분, 5분 또는 10분)를 이겨내는 것이 빠른 시간대보다 쉽습니다.\n\n20대 남성의 경우, 다섯 분 차이는 3:00에서 2:55로 가는 것을 의미합니다. 이는 60대 후반 남성이 4:05에서 4:00으로 가는 것보다 훨씬 중요합니다.\n\n# 그렇다면 보스턴 예선 시간은 모든 연령 그룹의 러너에게 공평한가요?\n\n이것은 논란이 될 수 있는 질문입니다. 왜냐하면 '공정(fair)'과 '평등(equitable)'이 무엇인지는 과거의 가정에 크게 의존하기 때문이죠.\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 여자들이 마라톤 러닝에서 역사적으로 부재했던 점을 극복하려고 한다면, 그들에게 약간 더 쉬운 기준을 제공하는 것이 '공정할' 수도 있습니다.\n\n데이터는 그 더 큰 철학적인 문제에 대한 답변을 제공할 수 없습니다. 하지만 여러분의 생각을 댓글로 공유하시기를 권장합니다.\n\n하지만, 그것은 그들이 동등하게 균형있고 어려운지에 대한 더 기본적인 질문에 대한 답변을 제공할 수 있습니다. 위의 데이터를 보면 분명히 알 수 있죠:\n\n- 모든 연령 그룹에서 여성들이 남성들보다 약간 더 쉽게 자격을 취득하는 경향이 있습니다.\n- 연장된 참가자들이 젊은 참가자들보다 자격을 취득하기가 더 쉽습니다.\n- 어떤 경우에는 그격차가 상당히 큽니다 — 60대 선수가 35세 미만 선수보다 거의 두 배의 가능성으로 자격을 취득하는 경우도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 데이터는 나이 등급 보정에 무언가 이상한 점이 있다는 생각을 뒷받침합니다.\n\n이 기사를 쓰기 시작할 때, 나이 등급 시리즈의 연속으로 생각하지는 않았어요. 하지만 결국 이는 유익한 여행이 되었어요.\n\n남성의 경우, 일어나는 일은 거의 예상한 대로입니다. 젊은 남성의 기준은 가장 높은 나이 등급과 가장 낮은 합격률을 갖고 있어요. 나이 그룹이 올라갈수록 나이 등급은 내려가고 합격률은 올라가요.\n\n여성의 경우, 이와 같은 상관관계가 없어요. 35세 미만 여성은 40대 여성보다 나이 등급이 힘들지만, 40대 여성들이 훨씬 더 높은 비율로 합격해요. 50대와 60대 여성은 더 높은 나이 등급을 가지며, 더 높은 비율로 합격해요.\n\n<div class=\"content-ad\"></div>\n\n저는 그 부분에 대한 의미를 다른 날로 미루겠습니다. 아마도 나이 평가와 마라톤 시리즈를 마무리한 뒤에 이 주제로 다시 돌아올 것 같습니다.\n\n오늘은 이렇게 마무리하겠습니다.\n\n러너들 사이에는 ‘당신이 보스턴을 달리기 위해서 반드시 빨라지지 않아도 된다. 그저 나이만 먹으면 된다’는 속담이 있습니다. 얼마나 사실인지 모르지만요.\n\n만약 이와 같은 데이터 기반 분석에 관심이 있다면, 이메일 구독을 확인해주세요.\n\n<div class=\"content-ad\"></div>\n\n저는 열정적인 러너이자 데이터 열매입니다. 방금 40세가 되었고, 나이가 들면서 본스 퀄리파잉 시간을 달성하는 데에 도움이 되었습니다. 하지만 더 빠르게 달리기 위해 노력 중이에요. 제 활동을 계속해서 지켜볼 수 있는 방법은 이렇습니다:\n\n- 제 훈련 소식을 듣고 싶다면 Running with Rock을 팔로우하세요\n- 마라톤 훈련 계획 선택에 대한 팁을 읽어보세요\n- Strava에서 제 활동을 엿보세요","ogImage":{"url":"/assets/img/2024-06-19-AretheBostonMarathonQualifyingTimesFairForAllAgeGroups_0.png"},"coverImage":"/assets/img/2024-06-19-AretheBostonMarathonQualifyingTimesFairForAllAgeGroups_0.png","tag":["Tech"],"readingTime":9},{"title":"책 필기Part I","description":"","date":"2024-06-19 09:16","slug":"2024-06-19-BookNotesPartI","content":"\n\nStorytelling with Data: A Data Visualization Guide for Business Professionals을 Cole Nussbaumer Knaflic가 쓴 책을 읽고 있어요. 이 책에서 배운 내용을 정리할 수 있도록 메모를 작성해 보려고 해요.\n\n제1장: 맥락의 중요성\n\n- 탐색적 vs 설명적 분석\n\n인용: 탐색적 분석은 데이터를 이해하고 다른 사람들에게 강조하거나 흥미로운 부분을 찾아내는 것을 의미해요. 우리가 분석 내용을 청중에게 전달하는 단계에 이르렀을 때, 우리는 실제로 설명적인 공간에 있고, 다른 이에게 설명하고자 하는 특정한 것이 있거나 전하고 싶은 특정 이야기가 있어야 해요.\n\n<div class=\"content-ad\"></div>\n\n제 생각: 저자인 콜은 탐색 분석이 설명 분석보다 먼저 이루어진다고 말합니다. 먼저, 우리는 데이터에 친숙해지기 위해 탐색 분석을 수행합니다. 그 후에는 우리의 발견을 청중의 요구에 맞게 맞추기 위해 설명 분석을 수행합니다.\n\n2. 누구, 무엇 그리고 어떻게\n\n- 누구 — 누구에게 의사 소통을 하는 것입니까?\n\na) 의사 결정자를 식별하는 것은 청중을 좁히는 한 가지 방법입니다.\n\n<div class=\"content-ad\"></div>\n\nb) 내가 당신과의 관계와 당신이 어떻게 인식될 것으로 기대하는지 생각해보세요.\n\n- 무엇 — 당신의 청중이 무엇을 알고 무엇을 해야 하는지 알려주고 싶나요?\n\na) 분석을 기반으로 구체적인 관찰과 권고 사항을 제시해보세요.\n\nb) 명시적으로 행동을 권장하는 것이 적절하지 않을 때는 논의를 장려하세요.\n\n<div class=\"content-ad\"></div>\n\n- 데이터를 사용하여 주장을 도와줄 수 있는 방법은 무엇인가요?\n\n3. 문맥에 상담: 물어볼 질문\n\n4. 3분 이야기 & 큰 아이디어","ogImage":{"url":"/assets/img/2024-06-19-BookNotesPartI_0.png"},"coverImage":"/assets/img/2024-06-19-BookNotesPartI_0.png","tag":["Tech"],"readingTime":1},{"title":"윈도우에서 MAC 주소 스푸핑하는 방법","description":"","date":"2024-06-19 09:14","slug":"2024-06-19-HowtoSpoofYourMACAddressonWindows","content":"\n\n<img src=\"/assets/img/2024-06-19-HowtoSpoofYourMACAddressonWindows_0.png\" />\n\nMAC 주소 스푸핑에 대해 이야기하기 전에, MAC 주소가 정확히 무엇인지 이해해야 합니다. MAC(Media Access Control) 주소는 네트워크 상의 장치에 할당된 12자리 16진수 번호입니다(예: 02-1B-63-84-D5-E6). MAC 주소는 장치 제조 중에 인쇄되는 고유 식별자로, 일반적으로 네트워크 인터페이스 카드(NIC)에 기록되어 있습니다. 장치를 찾거나 진단하기 위해서 MAC 주소가 필요합니다. MAC 주소는 Open Systems Interconnection(OSI) 모델의 2계층인 데이터 링크 계층에 속합니다. 각 장치의 네트워크 인터페이스마다 고유 MAC 주소가 할당되므로 장치에 여러 개의 MAC 주소가 있을 수 있습니다.¹\n\n# 과정\n\n먼저, 당신의 장치에서 MAC 주소를 찾아야 합니다. Windows 운영 체제를 사용 중이라면 명령 프롬프트로 이동하여 \"ipconfig/all\"을 입력한 다음 Enter 키를 누르세요. \"물리적 주소(Physical Address)\"의 값이 장치의 MAC 주소입니다. macOS를 사용 중이라면 화면 좌측 상단의 Apple 아이콘을 클릭하고 System Preferences ` Network ` Interface ` Advanced ` Hardware을 선택하여 MAC 주소를 확인할 수 있습니다.¹\n\n<div class=\"content-ad\"></div>\n\nWindows 11과 같은 최신 버전의 Windows에서는 MAC 주소를 수동으로 다시 구성할 수 없지만 MAC 주소를 무작위로 설정하는 옵션을 사용할 수 있습니다. Wi-Fi/Ethernet 설정에서 무작위 하드웨어 주소를 사용하도록 옵션을 토글 할 수 있습니다.¹ 아래 그림 1은 메뉴에서 옵션이 켜져 있는 것을 보여줍니다.\n\n<img src=\"/assets/img/2024-06-19-HowtoSpoofYourMACAddressonWindows_1.png\" />\n\nWindows 10 이하와 같은 이전 버전의 Windows를 사용 중이라면 다음 단계로 MAC 주소를 수동으로 구성할 수 있습니다:\n\n1) 제어판으로 이동하여 \"네트워크 연결\"을 검색하면 그림 2와 같은 화면이 나타납니다. \"네트워크 연결 보기\"를 클릭하십시오.³\n\n<div class=\"content-ad\"></div>\n\n![How to Spoof Your MAC Address on Windows - Step 2](/assets/img/2024-06-19-HowtoSpoofYourMACAddressonWindows_2.png)\n\n2) 인터넷에 연결된 인터페이스를 선택하세요. 빨간 X 표시가 없어야 합니다.\n\n3) 인터페이스를 선택한 후(예시에서는 이더넷), 왼쪽 하단에 있는 속성을 클릭하면 됩니다. Figure 3에서 확인할 수 있습니다.\n\n![How to Spoof Your MAC Address on Windows - Step 3](/assets/img/2024-06-19-HowtoSpoofYourMACAddressonWindows_3.png)\n\n<div class=\"content-ad\"></div>\n\n4) 이후에는 그림 4에 표시된대로 \"구성\"을 클릭하세요.\n\n![이미지](/assets/img/2024-06-19-HowtoSpoofYourMACAddressonWindows_4.png)\n\n5) \"고급\" 탭으로 전환한 후 \"로컬 관리자 주소\"를 찾아 아래로 스크롤하세요. 값 탭을 클릭하여 12자리의 16진수 주소를 입력하면 MAC 주소를 변경할 수 있습니다.² 이는 그림 5에서 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-HowtoSpoofYourMACAddressonWindows_5.png)\n\n<div class=\"content-ad\"></div>\n\n6) \"ipconfig/all\"을 입력하여 명령 프롬프트로 이동하여, 변경한 네트워크 인터페이스 MAC 주소의 물리적 주소와 일치하는지 확인하세요.\n\n# 결론\n\n지금은 윈도우 운영 체제에서 MAC 주소를 변경하는 두 가지 방법을 배웠습니다. 하나는 무작위로 변경되며 제어가 불가능한 방식이고, 다른 하나는 수동으로 구성되어 완전한 통제를 할 수 있는 방식입니다. 네트워크에서 진단을 실행해야 하는 경우 MAC 주소 문제가 발생할 수 있으므로 유용한 지식입니다. 네트워크에서 MAC 필터링을 사용하고 있다면 기기의 MAC 주소를 변경하여 필터링이 올바르게 작동하는지 확인할 수 있습니다. 네트워크의 방어 시스템을 침투하고 테스트하려는 경우 MAC 주소 위조 방법을 알고 있는 것도 다양한 공격에 유용할 것입니다. MAC 주소는 네트워크 내에서 장치를 구별하는 데 중요하며, 인터넷 동작에 필수인 TCP/IP에 중요한 역할을 합니다.\n\n# 참고문헌\n\n<div class=\"content-ad\"></div>\n\n(1) Yasar, Kinza. (n.d.). MAC 주소 (미디어 접속 제어 주소). TechTarget. [링크](https://www.techtarget.com/searchnetworking/definition/MAC-address#:~:text=A%20MAC%20address%20(media%20access%20control%20address)%20is%20a%2012,network%20interface%20card%20(NIC)).\n\n(2) Costa, Andre. (2021, 8월 19일). 윈도우 10에서 MAC 주소를 변경하는 방법 (그리고 왜 변경해야 하는지). Groovy Post. [링크](https://www.groovypost.com/howto/change-mac-address-windows-10-why/)\n\n(3) Android Authority. (2023, 7월 21일). 거의 모든 기기에서 MAC 주소를 변경하는 방법. [링크](https://www.androidauthority.com/how-to-change-mac-address-3192669/)","ogImage":{"url":"/assets/img/2024-06-19-HowtoSpoofYourMACAddressonWindows_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoSpoofYourMACAddressonWindows_0.png","tag":["Tech"],"readingTime":3},{"title":"Qualcomm의 X Elite이 M3에 일치하지만 M4에는 미치지 못한다","description":"","date":"2024-06-19 09:14","slug":"2024-06-19-QualcommsXEliteMatchesM3LosesToM4","content":"\n\n저는 Qualcomm의 X Elite 칩에 대해 매우 회의적이었습니다. 왜냐하면 노트북에 Qualcomm 칩이 포함된 것은 처음이 아니기 때문입니다. 그들은 8cx 칩도 만들었는데 그것은 재앙이었습니다. 이전 게시물에서 말했듯이:\n\n그래서 X Elite이 나와서 벤치마크를 살펴보고 있는데, 솔직히 감명받았습니다.\n\n가장 먼저 살펴본 것은 Qualcomm의 공식 보도 자료인데, 꽤 흥미로웠습니다.\n\nApple은 최근 iPad 이벤트에서 NPU에 대해 많이 이야기했기 때문에 뉴럴 프로세싱 유닛을 비교한 것이 흥미로웠습니다. Qualcomm의 주장은 매우 의문스럽다고 생각합니다.\n\n<div class=\"content-ad\"></div>\n\n컴퓨터 칩에서 비교적 새로운 구성 요소 인 NPU는 아직 표준화되어 있지 않을 수 있습니다. 그들이 그들의 성능을 다른 방식으로 측정하는 것일 수도 있습니다. 혹은 그들의 NPU가 실행 중인 특정 벤치마크에 최적화되어 있을 수도 있습니다.\n\n하지만 모두가 알고 싶어하는 것은 순수한 숫자입니다. X 엘리트와 퀄컴이 겨냥하는 M3을 어떻게 비교하는지 알고 싶은 것입니다.\n\n이미 언급된대로 저는 매우 회의적입니다. 그러나 올해는 퀄컴이 실제로 제품을 출시할 수도 있을 것으로 보입니다. 이 첫 번째 징후는 XDA의 벤치마크에 나타납니다. 그래서 XDA는 어떤 이유로 X 엘리트를 애플의 2년 전 칩 인 M2와 비교하기로 결정했습니다. 그리고 칩은 연간 약 10%씩 빨라진다는 것을 감안하면 X 엘리트가 애플의 칩과 어떻게 비교되는지에 대해 의미 있는 얘기를 할 수가 없습니다.\n\n하지만 그들은 또한 X 엘리트를 퀄컴의 8cx와 비교했는데, 8cx는 엄청난 차이를 보입니다. Cinebench를 살펴보세요.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-19-QualcommsXEliteMatchesM3LosesToM4_0.png)\n\nX Elite가 싱글 코어 점수가 두 배 이상이고 멀티코어 점수가 5배 이상을 얻는 것 같네요.\n\n두 Qualcomm 칩이 모두 Apple보다 높은 TDP를 가지고 있음을 언급하고 있습니다. 각각 87와트와 23와트입니다.\n\n적어도 하나의 X Elite 칩이 TDP가 거의 4배나 높지만 성능은 거의 동일하다는 것을 보는 것도 놀랍군요. 왜 그런 제품을 판매하는 걸까요?\n\n<div class=\"content-ad\"></div>\n\n그럼 다른 벤치마크를 보자면 Laptop Mag은 다음과 같이 말합니다:\n\n예상했던 것보다 훨씬 좋아요. X Elite은 붕괴할 것으로 예상했는데 예상보다 훨씬 좋은 싸움을 벌이고 있어요. 하지만 Laptop Mag은 '애플은 분명히 위험에 처해있다'고 말했지만, 전 동의하지 않아요. 싱글 코어 속도는 아직도 다소 낮고 대부분의 작업은 싱글 코어로 이루어질 거에요. 몇 가지 작업에서 멀티코어가 중요하긴 하지만, 그 정도로 큰 영향을 미치진 않아요.\n\nX Elite은 멀티코어에서 M3를 이기긴 하지만, 조금밖에 차이 나지 않아요. 그리고 M4는 아마도 다시 왕좌를 차지할 것 같아요.\n\n실제로 다른 포스트에서 쓴 것을 떠올리게 해줘요.\n\n<div class=\"content-ad\"></div>\n\n그래서 2010년대는 스마트폰에서의 Qualcomm 대 Apple이 주를 이었죠. 아마 2020년대는 노트북에서의 Qualcomm 대 Apple이 주를 이겠죠. 😆 변하는 것이 많아져도, 노출하는 것은 그대로인 경우가 많죠.\n\nNotebook Check에서 좀 더 흥미로운 결과가 있더라구요. 그들은 M4 칩을 M3이 아닌 것과 비교했어요.\n\n그리고 M4은 어떤지 살펴보겠습니다. 애플은 iPad 이벤트에서 M3에 대해 많이 언급하지 않았죠. 단지 빨라졌다는 것 뿐이었어요. 그럼 얼마나 빨라진 걸까요? 결과적으로 훨씬 빨라졌어요.\n\nM4가 얼마나 개선될지 의문을 가졌었는데, 특히 iPads에 먼저 출시되었기 때문이었어요. M4가 단지 열 및 전력 효율성에 관한 것이라고 생각했었죠. 여전히 3나노미터로 만들어졌답니다. TSMC의 더 효율적인 n3e 공정에 기반하고 있고, n3b가 아닌 것이죠.\n\n<div class=\"content-ad\"></div>\n\n노트북 체크가 다르게 말하고 있어요. 그들에 따르면, 싱글코어 속도가 최대 20% 개선되었다고 합니다. 다만 멀티코어 속도는 10% 정도만 향상되었다고 하네요. GPU 속도도 최대 10% 상승했다고 합니다. 저는 이 정도면 상당히 기대 이상이었어요. GPU 개선이 좀 아쉬웠지만, 싱글코어의 향상은 매우 인상적이에요.\n\n그렇다면 X 엘리트와 비교하면 어떨까요? 음, M4가 이기네요. 하지만 X 엘리트는 제가 의심했던 것보다 훨씬 잘 했어요. M3와 비슷한 수준으로 작동했어요.\n\n그러니까 제가 퀄컴에 대해 틀렸군요. 그들도 실력 있는 랩탑 칩을 만들 수 있네요. 그러니 이 벤치마크를 믿는다면 말이죠. 노트북 체크가 이미 M4를 벤치마크 했고 잘한 것 같아 놀랐어요. 제 예상대로 아이패드가 극단적으로 제한될 줄 알았는데요.\n\nM2 칩이 극단적으로 제한되었고 겨우 M1을 앞질렀다는 내용의 게시물을 작성했는데, 발행하지 않을 것 같아요. 다시 그런 상황이 반복될 것으로 예상했는데, 아닌가봐요.\n\n<div class=\"content-ad\"></div>\n\n어쨌든 Qualcomm은 내 기대치를 능가했습니다. 하지만 그렇게 크게 변하지는 않았어요. 여전히 윈도우는 좋아하지 않아요. 하지만 윈도우를 좋아한다면, 이 제품은 매우 유용할 거예요.\n\n애플 실리콘이 출시된 이후로 몇 년 동안은 맥북이 매년 우승을 차지했어요. Dave2D는 심지어 '맥북 우승에 지쳤다면...'이라는 제목의 비디오도 게시했어요.\n\n그러나 모두가 궁금해하는 질문이 하나 있죠: 소프트웨어 지원은 어느 정도까지 될까요? 걱정할 필요는 없을 것 같아요. 대부분의 대형 앱들이 업데이트될 것으로 예상되어요. 다만 게임은 좀 걱정되는데요, 출시 이후에는 더 이상 업데이트할 동기가 거의 없어요. 그런데 게임 대신 시퀄을 만들 수 있잖아요.\n\n윈도우에게는 큰 문제가 있습니다. 윈도우에는 많은 게임이 있지만, 그 중 많은 게임들이 Arm으로 업데이트되지 않을 것 같아요. 사람들이 자랑스럽게 소개하는 게임인 'Shadow Of The Tomb Raider'도 여전히 Rosetta 2로 실행 중이에요. 그리고 그게 곧 바뀔 것 같지는 않아요.\n\n<div class=\"content-ad\"></div>\n\n비록 이것도 크게 걱정하지는 않아요. 저는 Steam Deck에서 많은 게임을 플레이하고 있는데, 그 기기는 대부분의 게임을 호환성 레이어를 통해 실행합니다. 소프트웨어 문제는 대부분 괜찮을 것 같아요. 특히 많은 앱이 웹 버전을 가지고 있기 때문에요.\n\n윈도우에서의 Arm이 성공할 것 같아요. 그래서 x86 칩을 볼 수 있는 유일한 장소는 서버일 것 같아요. 그 곳에서도 확실치 않지만요. VPS를 빌리려다가 생각해본 적이 있는데, 그 중에서도 Hetzner라는 이름이 자주 언급되더라구요 (그 회사 이름이 들어보기로는 가장 독일스러운 것 같아요). 그들은 Arm CPU 옵션을 제공하며, Arm CPU를 선택하면 더 많은 RAM과 메모리를 얻을 수 있어요.\n\n음, Intel과 AMD는 조심해야 할 것 같아요. Arm64가 당신들의 시장을 쓸어갈 거예요.","ogImage":{"url":"/assets/img/2024-06-19-QualcommsXEliteMatchesM3LosesToM4_0.png"},"coverImage":"/assets/img/2024-06-19-QualcommsXEliteMatchesM3LosesToM4_0.png","tag":["Tech"],"readingTime":4},{"title":"깃에서 의심스러운 소유권을 감지하기","description":"","date":"2024-06-19 09:13","slug":"2024-06-19-Gitdetectdubiousownershipinrepository","content":"\n\n<img src=\"/assets/img/2024-06-19-Gitdetectdubiousownershipinrepository_0.png\" />\n\n회사 환경에서 작업할 때, 우리는 일반적으로 각 인증된 사용자마다 컴퓨터에서 지정된 사용자 공간을 갖습니다. 예를 들어, Windows에서 우리의 사용자 이름이 abc이면, C:\\Users 폴더에 abc라는 이름의 폴더가 있습니다. 즉, 모든 사용자 abc의 파일을 위한 C:\\Users\\abc 폴더가 있습니다. 그리고 이 폴더에 git 리포지토리를 넣으면, git status와 같은 git 작업을 수행할 때 다음과 같은 오류 메시지가 나올 수 있습니다.\n\n```js\nfatal: detected dubious ownership in repository at 'C:/Users/abc/Projects/my-awesome-project'\n'C:/Users/abc/Projects/my-awesome-project' is owned by:\n        'S-1-5-32-544'\nbut the current user is:\n        'S-1-12-1-1347659835-1128888854-2982737882-1111120199'\nTo add an exception for this directory, call:\n        git config --global --add safe.directory C:/Users/abc/Projects/my-awesome-project\n```\n\n오류 메시지에 해결책이 내장되어 있어서 좋지만, 이게 무슨 뜻이며 왜 발생하는 걸까요? 그리고 사용자 이름에 있는 모든 숫자들은 무엇을 의미할까요?\n\n<div class=\"content-ad\"></div>\n\n먼저, 오류 메시지의 원인은 현재 사용자가 git 리포지토리 폴더의 소유자인지 확인하고, 현재 사용자가 소유자가 아닌 경우 위와 같은 오류 메시지를 생성합니다. 이는 git이 .git 폴더로 직접 이동하여 여기서 일부 파일을 실행하기 때문에 발생합니다. 예를 들어 C:\\Users\\abc\\Projects\\my-awesome-project\\.git입니다. 이는 폴더가 현재 사용자에 의해 소유되지 않으면 보안 위험이 발생할 수 있고 다른 사람으로부터 악성 파일이 여기에 배치될 수 있어 컴퓨터를 실행할 때 위험을 초래할 수 있습니다. 이는 https://github.com/git-for-windows/git/security/advisories/GHSA-gf48-x3vr-j5c3에서 설명되어 있으며, 해당 확인을 추가한 커밋은 https://github.com/git/git/commit/8959555cee7ec045958f9b6dd62e541affb7e7d9에서 확인할 수 있으며, git for windows v2.35.2 이상에서 사용할 수 있습니다.\n\n따라서 우리의 경우 C:\\Users\\abc 폴더는 시스템에 의해 생성되었으며 현재 사용자 S-1-12-1-1347659835-1128888854-2982737882-1111120199의 소유자가 아니라 S-1-5-32-544가 소유합니다. 따라서 오류 메시지가 표시됩니다.\n\ngit이 제공한 해결책은 현재 폴더를 safe.directory 전역 변수에 추가하여 git이 해당 폴더를 안전한 것으로 간주하도록하는 것입니다. 따라서 해결책은 git config --global --add safe.directory C:/Users/abc/Projects/my-awesome-project입니다. 참고로 윈도우 환경에서도 백슬래시 \\ 대신 슬래시 / 를 사용해야 합니다. 그런 다음 git config --global --list를 실행할 때 변수를 볼 수 있어야 합니다. safe directory는 멀티-value 변수이므로 필요한 모든 폴더 리포지토리를 추가할 수 있습니다.\n\n사용자 이름에 있는 숫자에 대해 알아봅시다. 이들은 사실 SID로, 사용자 계정의 ID와 같은 역할을 합니다. SID에 대한 자세한 정보는 https://www.techtarget.com/searchsecurity/definition/security-identifier에서 확인할 수 있습니다. 현재 사용자의 SID는 whoami /user 명령을 실행하여 얻을 수 있습니다. 출력물은 다음과 같이 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n사용자 정보\n----------------\n사용자 이름  SID\n========= ====================================================\nads\\abc    S-1-12-1-1347659835-1128888854-2982737882-1111120199\n\n\n그럼 S-1-5-32-544는 누구일까요? 이것은 잘 알려진 SID로 내장 관리자 그룹을 참조한다고 합니다. 또한 Microsoft 사이트에도 게시되어 있습니다.\n\n이것으로 설명이 되었기를 바랍니다! 계속해서 궁금증을 품어보세요!\n","ogImage":{"url":"/assets/img/2024-06-19-Gitdetectdubiousownershipinrepository_0.png"},"coverImage":"/assets/img/2024-06-19-Gitdetectdubiousownershipinrepository_0.png","tag":["Tech"],"readingTime":3},{"title":"커버 포함된 북마크 상자 템플릿 SVG","description":"","date":"2024-06-19 09:12","slug":"2024-06-19-BookmarkBoxTemplatewithSleeveSVG","content":"\n\n🔍 지금 Bookmark Box Template with Sleeve SVG를 확인해보세요! 이 📁 독특한 프린트 모크업을 탐색하고 여기에서 무료 다운로드를 요청하세요. 함께 공작을 시작합시다! 🚀\n\n창과 슬리브가 있는 책갈피 상자 템플릿은 훌륭하며, 내부에는 Silhouette, Cricut 및 기타 절단기와 함께 사용할 수 있는 모든 형식이 포함되어 있습니다! 이 템플릿은 8.5×11인치로 제공되며 내부에는 사용 설명서가 있는 PDF 파일이 포함되어 있습니다. 이 상자와 슬리브는 중간 사이즈에 맞습니다: 1.85 x 6.30인치 (47 x 160mm) 이 즉시 다운로드에 포함된 형식: — SVG — DXF — EPS — PNG — PDF — JPG 이것은 디지털 다운로드입니다! ZIP 파일을 다운로드하며, WinZip 또는 유사한 소프트웨어로 이를 압축해제해야 합니다. 워터마크는 없고, 배경은 포함되어 있지 않습니다. 실제 제품은 보내드리지 않습니다! 도움이 필요하시면 언제든지 연락해주세요!\n\n![이미지](/assets/img/2024-06-19-BookmarkBoxTemplatewithSleeveSVG_0.png)\n\nAleksa Popovic의 사진은 Creative Fabrica에서 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n면책 조항: 이 기사에는 제휴 링크가 포함되어 있습니다. 이는 해당 링크를 통해 구매를 하시는 경우 별도 비용 없이 수수료를 지급받을 수 있다는 것을 의미합니다.","ogImage":{"url":"/assets/img/2024-06-19-BookmarkBoxTemplatewithSleeveSVG_0.png"},"coverImage":"/assets/img/2024-06-19-BookmarkBoxTemplatewithSleeveSVG_0.png","tag":["Tech"],"readingTime":1}],"page":"82","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}