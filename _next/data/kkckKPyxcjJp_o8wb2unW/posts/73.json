{"pageProps":{"posts":[{"title":"안녕하세요, 지그비 월드 25화  OTA 펌웨어 업데이트","description":"","date":"2024-06-19 17:13","slug":"2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates","content":"\n\n<img src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_0.png\" />\n\n만약 당신의 장치에 마이크로컨트롤러가 포함되어 있다면, 언젠가는 펌웨어 업데이트를 고려할 것입니다. 장치가 USB 또는 SD 카드 업데이트와 같은 쉬운 업데이트 방법을 지원하는 경우에는 보너스입니다. 또한 플래싱 도구를 가지고 이 도구를 장치에 연결할 수 있는 가능성도 좋은 선택지입니다. 그렇지 않다면 어떻게 해야 할까요?\n\n다행히도 이에 대한 해결책이 있습니다: Zigbee의 표준화된 무선 업데이트(OTA). NXP JN5169 마이크로컨트롤러에는 OTA 펌웨어 업데이트를 구현하기에 충분한 플래시 메모리가 있습니다. 이 글에서 설명하는 지침은 Zigbee 사양을 준수하며 OTA 업데이트를 적용할 수 있지만, OTA 업데이트를 구현하는 것에는 복잡함이 딸립니다.\n\n이 글은 Hello Zigbee 시리즈를 계속해서, 바닥부터 Zigbee 장치 펌웨어를 개발하는 데 초점을 맞춘 내용입니다. 저는 NXP JN5169 마이크로컨트롤러가 장착된 EBYTE E75-2G4M10S 모듈을 활용하여, 이 시리즈 이전 글에서 구축된 코드를 기반으로 구축할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n자 이제 함께 알아봅시다.\n\n# Zigbee OTA 이론\n\n## OTA 업데이트 프로토콜\n\nOTA 클러스터는 꽤 복잡합니다. 메인 펌웨어와 다중 마이크로컨트롤러를 가진 장치의 보조 프로세서 펌웨어를 업데이트하기 위한 상세한 설정을 제공합니다. 프로세스에는 네트워크 혼잡을 피하기 위해 다운로드 속도를 관리하는 방법이 포함되어 있습니다. 또한 업데이트 절차는 다른 타임아웃 및 오류 코드에 의해 원활한 운영이 보장됩니다.\n\n<div class=\"content-ad\"></div>\n\n복잡해 보이지만 펌웨어 업데이트 프로세스는 더 높은 수준에서는 간단합니다. 다음 다이어그램으로 요약할 수 있습니다.\n\n![Hello Zigbee World Part 25 OTA Firmware Updates](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_1.png)\n\n프로세스에는 두 장치가 관여됩니다. 코디네이터가 될 수 있지만 꼭 그럴 필요는 없는 서버가 다양한 클라이언트 장치의 펌웨어를 보관합니다. 클라이언트 장치는 업데이트 준비가 되면 서버에게 이용 가능한 펌웨어 업데이트 정보 및 펌웨어 데이터의 다음 부분을 요청합니다.\n\n클라이언트가 펌웨어 업데이트 프로세스를 관리합니다. 새로운 정보를 받을 준비가 되면서 서버는 수동적인 역할을 합니다. 서버는 중간 업데이트 상태를 유지하지 않으며 모든 정보는 클라이언트에 저장됩니다. 그러나 펌웨어 업데이트 프로세스를 시작하는 것은 서버의 책임에 속할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n펌웨어 업데이트 프로세스 단계는 다음과 같습니다:\n\n- 이미지 알림 메시지를 통해 서버는 기기에 새로운 펌웨어가 사용 가능하다는 정보를 전달할 수 있습니다. 재미있는 점은 이 메시지가 펌웨어 자체에 대한 구체적인 정보를 포함하지 않을 수 있다는 것입니다. 이는 더 많이 \"알려드립니다, 나에게 궁금증이 있는 것이 있어\"라는 메시지로, 클라이언트 기기에게 정확히 무엇인지 서버에게 문의하도록 유도합니다.\n- 서버는 특정 기기 또는 특정 유형 및 제조업체의 여러 기기들에 대해 한 번에 알림을 보낼 수 있습니다. 대량 업데이트의 경우, 최종 기기들은 동시 업데이트와 네트워크 혼잡을 피하기 위해 임의 지연 후 펌웨어 업데이트를 시작합니다.\n- 쿼리 넥스트 이미지 메시지를 통해 기기는 서버로부터 펌웨어의 구체적인 정보(버전, 크기 및 기타 매개변수)를 요청할 수 있으며, 현재 펌웨어 및 하드웨어 버전을 언급합니다.\n- 특정 기기 모델 및 하드웨어 버전에 대한 새로운 펌웨어가 있으면 서버는 쿼리 넥스트 이미지 응답 메시지로 응답합니다.\n- 이미지 블록 요청 메시지를 사용하여 기기는 펌웨어의 시작으로부터의 오프셋 및 필요한 바이트 수를 지정하여 작은 데이터 청크를 요청합니다. 서버는 요청된 바이트를 이미지 블록 응답 메시지로 전송합니다.\n- Zigbee 메시지 크기 제한으로 한 번에 너무 많은 바이트를 전송하는 것을 방지합니다. NXP 기기의 경우, 전형적인 값은 48바이트입니다. 이론적으로 더 많은 바이트를 전송할 수도 있지만, 그러면 메시지가 단편화되어 조각조각 전송되어야 하며, 중간 기기가 이 전송 형식을 이해하고 단편화된 패킷을 재조립하기 위해 추가 논리 및 리소스를 사용해야 합니다. 이것은 전송 속도를 높이는 것이 아닐 수 있으므로 피하는 것이 좋습니다.\n- 펌웨어를 다운로드한 후, 기기는 업그레이드 엔드 요청 메시지로 서버에 보고합니다. 클라이언트 기기는 무결성, 체크섬 및 요청에 언급된 대로 디지털 서명을 확인해야 합니다. 메시지는 또한 기기가 업데이트할 준비가 되었는지 또는 펌웨어를 다시 다운로드해야 하는지 또는 기기의 다른 마이크로컨트롤러에 대한 추가 펌웨어를 다운로드해야 하는지를 나타냅니다.\n- 서버는 엔드 업그레이드 응답 메시지로 응답하여, 실제로 펌웨어를 플래시 메모리에 기록할 때를 지정합니다. 이는 여러 기기 간의 조정된 펌웨어 업데이트 또는 별도의 펌웨어를 필요로 하는 다중 마이크로컨트롤러가 있는 기기 내에서 업데이트를 조정하는 데 필요할 수 있습니다.\n\nZigbee2mqtt는 일반적으로 이 프로세스를 따르며, 사용 가능한 펌웨어를 확인하고 실제로 펌웨어 업데이트를 구현하는 두 가지 시나리오를 실행합니다.\n\n사용 가능한 업데이트를 확인하는 방법에 대해 이야기해 봅시다. 나는 zigbee2mqtt가 외부 서버에서만 펌웨어 업데이트를 찾는 줄 알았고, 기기 자체가 이 프로세스에 참여해야 하는 이유를 이해하지 못했습니다. 작동 방식은 다음과 같습니다.\n\n<div class=\"content-ad\"></div>\n\n기본적으로 Zigbee2mqtt(Z2M)는 장치의 현재 펌웨어 버전이나 하드웨어 버전을 알지 못합니다(다른 하드웨어 버전은 다른 펌웨어가 필요할 수 있습니다). 게다가 펌웨어 파일은 외부 서버에 위치해 있으며, Z2M은 언제든 사용 가능한 펌웨어 버전을 미리 알지 못합니다. 모든 필요한 정보를 알아내기 위해 다음과 같은 과정이 진행됩니다:\n\n- Zigbee2mqtt는 Image Notify 메시지를 장치에 보냅니다(\"장치야, 뭔가 가지고 왔는데, 이 메시지에서는 뭔지 말하지 않겠어\").\n- 장치는 현재 펌웨어 및 하드웨어 버전을 알리는 Query Next Image Request를 서버에 보냅니다.\n- Zigbee2mqtt는 응답하지 않습니다(Query Next Image Response 메시지 전송 없음)​ ​, 그리고 시간이 초과되면 장치는 초기 상태로 돌아갑니다.\n- 그러나 이제 Z2M은 장치에 설치된 펌웨어와 하드웨어를 알고, 외부 펌웨어 서버에서 업데이트를 확인할 수 있습니다.\n- 업데이트를 찾고 해당 장치의 하드웨어 버전과 호환되면 Zigbee2mqtt 대시보드에 이 정보를 빨간색 \"장치 펌웨어 업데이트\" 버튼과 함께 표시합니다.\n\n사용자가 \"장치 펌웨어 업데이트\" 버튼을 클릭하면, 설명한 과정이 진행됩니다: Image Notify - Query Next Image Request - Image Block Request - End Update Request.\n\n일반적인 OTA 펌웨어 업데이트 체계에 대한 설명을 마치며, 몇 가지 Wireshark 스크린샷을 보여드리겠습니다. 여기에는 현재 펌웨어 버전을 확인하는 부분이 포함되어 있습니다(나중에 업데이트가 있는지 확인하기 위해).\n\n<div class=\"content-ad\"></div>\n\n아래는 펌웨어 업데이트 과정에 대한 몇 개의 스크린샷이 있습니다.\n\n![image1](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_3.png)\n\n![image2](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_4.png)\n\n<div class=\"content-ad\"></div>\n\n업데이트 전체 구조는 명확해 보입니다. 그러나 사실은 그렇게 간단하지 않아요. 이제 세부 사항에 대해 자세히 살펴보려고 해요.\n\n## 속도 제한\n\n위 스크린샷에서 OTA 메시지가 일반 지그비 메시지와 동일하다는 것을 알 수 있어요. 메시지가 직접 전달되지 못할 경우 중간 라우터를 통해 전달됩니다. 펌웨어 데이터 메시지는 네트워크를 통해 일반 장치의 메시지와 함께 이동합니다. 패킷이 손실되면 메시지가 다시 전송됩니다.\n\n항상 절전 모드인 최종 장치에 대한 펌웨어 업데이트도 작동해요. 장치는 다음 메시지를 받기 위해 부모 라우터를 계속 폴링해야 해요. 이 과정은 매우 활동적이며 에너지를 많이 소비해요. 그래서 배터리 구동 장치의 경우 배터리 수준을 지속적으로 확인하고 충전량이 충분하지 않은 경우 업데이트를 시작하지 않아야 합니다.\n\n<div class=\"content-ad\"></div>\n\n또한, Zigbee 네트워크의 대역폭이 매우 높지 않다는 것을 기억해주세요. 이 네트워크는 250 kBaud 속도로 작동하지만 실제로는 실제 처리량이 낮습니다:\n\n- 여러 장치가 동일한 주파수를 공유하며, 한 장치가 업데이트되는 동안 나머지는 정상적으로 작동하여 메시지를 송수신합니다.\n- 대부분의 메시지에는 네트워크 수준의 확인 응답이 전송되며 때로는 응용 프로그램 수준의 응답도 채널을 잠시 사용합니다.\n- 데이터가 중간 라우터를 통해 전송되는 경우, 각 메시지는 적어도 두 번 전송됩니다. 발신자에서 라우터로, 그리고 라우터에서 수신자로. 이 모든 것이 동일한 대역폭을 공유합니다.\n\n펌웨어 업데이트에는 수십 또는 수백 킬로바이트로 측정되는 상당한 양의 데이터가 포함됩니다. 계속해서 스트리밍되는 경우 다른 장치들은 메시지를 보낼 수 없게 됩니다. 그래서 펌웨어 전송 중 데이터 흐름 속도를 제한하기 위한 절차가 개발되었습니다.\n\n여기 작동 방식입니다. 장치는 Image Block Request 메시지로 다음 데이터 블록을 요청합니다. 네트워크가 비교적 자유로울 때, 서버는 SUCCESS 상태와 데이터 바이트를 포함한 Image Block Response를 보냅니다. 그러나 네트워크가 현재 바쁜 상태인 경우, 서버는 기다려야 하는 시간을 나타내며 Image Block Response 메시지를 WAIT_FOR_DATA 상태로 보냅니다.\n\n<div class=\"content-ad\"></div>\n\n또한 빈 메시지를 주고 받지 않도록 하기 위해, 서버는 OTA 클러스터에서 클라이언트에게 MinBlockRequestDelay 속성을 설정할 수 있습니다. 이는 디바이스가 요청 간에 기다려야 하는 최소 시간을 지정합니다. 이를 위해 OTA 클러스터는 밀리초 타이머 메시지를 구독해야 하며, 클러스터는 필요한 시간 간격을 측정할 것입니다.\n\n그러나 패키지 속도 제한은 펌웨어 측면에서 다루지 않을 것입니다. 이 기능은 이미 zigbee2mqtt (더 정확히는 herdsman-converters)에 내장되어 있습니다. 서버 자체가 요청 빈도를 모니터링하고, Image Block Response 패킷을 간단히 지연함으로써 250ms 간격을 유지할 것입니다.\n\n## 상태 지속성\n\n패킷 간에 일시 중지를 포함한 작은 청크로 데이터를 전송하기 때문에, 펌웨어 업데이트는 수십 분 단위로 측정될 수 있는 상당한 시간이 소요될 수 있습니다. 이 기간 동안 다양한 문제가 발생할 수 있습니다 — 배터리가 소진될 수 있고, 전기가 차단될 수 있으며, 네트워크가 사라질 수도 있고, 서버가 고장날 수도 있습니다. 이러한 경우에는 마이크로컨트롤러의 EEPROM에 중간 상태를 저장하여 사용합니다. 따라서 이 상태를 복원하고 펌웨어 다운로드를 계속할 수 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n다행히도 대부분의 이 기능은 SDK에서 구현이 되어 있습니다. 우리는 상태를 저장하고 복원하기 위한 함수만 제공하면 됩니다.\n\n## [Optional] 서버 발견 업그레이드\n\n이전에 업데이트 가능 여부를 확인하고 서버에서 시작된 업데이트 프로세스를 검토한 적이 있습니다. 실제로, 디바이스가 직접 서버에 쿼리 다음 이미지 요청을 보내어 펌웨어 업데이트를 시작할 수 있는 업데이트 시나리오도 있습니다.\n\n일반적으로 OTA 업데이트 서버와 코디네이터는 같은 디바이스일 필요는 없습니다. 업데이트 서버는 다른 주소에 있을 수도 있습니다. 디바이스는 보통 업데이트 서버가 어디에 있는지 알지 못하기 때문에 클라이언트 디바이스를 구성하기 위해 몇 가지 예비 단계가 필요합니다. 이것이 업데이트 서버 발견 절차가 필요한 이유입니다.\n\n<div class=\"content-ad\"></div>\n\n일반적인 개발 과정에요. 클라이언트 기기는 OTA 서버 클러스터를 지원하는지 묻는 방송 Match Descriptor Request를 보냅니다. 서버는 Match Descriptor Response를 보내 응답합니다.\n\n하지만 여기서 끝이 아닙니다. 클라이언트 기기는 서버의 16비트 주소만 알게 되는데 이는 변경될 수 있습니다. 그래서 추가로 IEEE 주소 조회 요청이 필요합니다.\n\n이는 JavaScript 또는 Python과 같은 고수준 언어로 쉽게 구현할 수 있는 선형 알고리즘처럼 보일 수 있습니다. 그러나 펌웨어에는 await이 없기 때문에 요청, 응답 및 그들 사이의 타임아웃을 주의 깊게 처리하는 상태 기계를 만들어야 합니다. 이는 표준의 선택적 부분이며 SDK에 구현되어 있지 않습니다. NXP의 예제에서 이러한 상태 기계는 약 천 줄 정도의 코드로 구현됩니다.\n\n하지만 좋은 소식도 있습니다. 디바이스가 업데이트를 시작하는 기능을 포기하고 zigbee2mqtt가 코디네이터 및 업데이트 서버로 동작한다고 가정하면 Update Server Discovery 절차를 생략할 수 있습니다. 서버가 이미지 알림 메시지로 디바이스에 접근할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## OTA 파일 형식\n\n지그비 장치는 다양한 제조업체와 아키텍처의 마이크로컨트롤러를 사용하여 구축할 수 있습니다. 당연히, 이러한 마이크로컨트롤러용 펌웨어 형식은 다를 것입니다. 그럼에도 불구하고, zigbee2mqtt는 서로 다른 기기에 올바른 펌웨어 버전을 제공하기 위해 각 펌웨어 파일을 어떤 식으로든 구별해야 합니다.\n\n따라서 Zigbee OTA는 모든 제조업체와 마이크로컨트롤러 아키텍처를 위해 통합된 펌웨어 형식을 사용합니다. 이 형식은 Zigbee ZCL 명세서에 자세히 기술되어 있습니다.\n\n![이미지](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_5.png)\n\n<div class=\"content-ad\"></div>\n\n이 형식은 컴파일러 및 링커가 생성하는 것과 다릅니다. 게다가 OTA 펌웨어 파일을 생성할 수 있는데, 예를 들어, 장치에 여러 개의 마이크로컨트롤러가 있는 경우 해당 펌웨어를 업데이트해야 합니다.\n\n좋은 소식은 이것이 실제로 컴파일러에 의해 생성된 펌웨어 파일 위에 덧씌운 것에 불과하다는 점입니다. 그러나 이러한 래퍼를 생성하기 위해서는 여전히 약간의 노력이 필요할 것입니다.\n\n## 플래시 메모리 리매핑 기능\n\nZigbee 프로토콜 측면을 더 잘 이해하려면 JN-AN-1003: JN51xx 부트로더 동작 문서를 참조하시기 바랍니다. 이 문서는 실제로 펌웨어를 마이크로컨트롤러로 로드하는 방법과 해당 펌웨어의 형식, 그리고 UART 펌웨어 업로드 작업에 대해 설명합니다.\n\n<div class=\"content-ad\"></div>\n\n마이크로컨트롤러에는 32KB씩 16개의 섹터로 나누어진 512KB의 플래시 메모리가 포함되어 있습니다. 이 섹터 중 일부는 현재 마이크로컨트롤러의 펌웨어를 호스팅합니다. 나머지 블록은 다운로드한 펌웨어를 저장하는 데 사용될 수 있습니다. 그러나 마이크로컨트롤러를 새 펌웨어로 전환하는 방법은 무엇일까요?\n\nJN5169 마이크로컨트롤러에는 섹터 리매핑 기능이 있습니다. 현재 펌웨어가 들어 있는 섹터와 새 펌웨어를 다운로드할 위치를 지정할 수 있습니다. 새 펌웨어로 전환하는 것은 단순히 섹터를 리매핑하는 것입니다.\n\n물리적 및 논리적 섹터가 어떻게 매치되는지에 대한 예제를 살펴보겠습니다. 처음에는 물리적 및 논리적 섹터의 번호 매기기가 일치할 것입니다.\n\n![이미지](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_6.png)\n\n<div class=\"content-ad\"></div>\n\n새 firmware이 물리적 섹터 0x8부터 0xF까지 다운로드되면, 마이크로컨트롤러는 섹터 리매핑 프로시저를 수행할 수 있습니다 — 논리적 섹터 0은 그 후 물리적 섹터 8을 가리킬 것이고, 섹터 1은 섹터 9를, 이와 같이 계속됩니다 (그 반대도 마찬가지). Firmware은 논리적 주소에서 작동하기 때문에 새 firmware은 재부팅 후에 로드될 것입니다.\n\n![이미지](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_7.png)\n\n위 예시는 firmware 크기가 약 256k이고 8개 섹터를 차지하는 경우를 개요로 합니다. JN-AN-1003 문서와 JN-UG-3115 문서의 부록 F에서는 firmware 크기가 8개 섹터보다 작은 경우의 특별한 노트가 있습니다. 예를 들어, firmware 크기가 딱 6개 섹터인 경우를 살펴보겠습니다. 이 경우, 섹터 0x8부터 0xD에 다운로드되고, 0xE와 0xF 섹터는 사용되지 않습니다.\n\n![이미지](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_8.png)\n\n<div class=\"content-ad\"></div>\n\n재부팅 중에 부트로더는 섹터를 다시 매핑하지만 다운로드한 펌웨어 데이터를 포함하는 섹터에 대해서만 수행합니다 (0x8부터 0xD까지의 섹터). 이것은 섹터 0xE와 0xF에 일부 데이터를 보존하고 싶을 때 유용할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_9.png)\n\n펌웨어를 다시 업데이트하기로 결정하면, 논리적인 섹터 0x8부터 0x0F에 다운로드됩니다. 하지만, 다음 펌웨어가 더 크고 6개 대신 7개의 섹터를 사용하는 경우, 물리적인 섹터 0부터 5와 0xE에 쓰여질 것입니다. 이는 펌웨어가 연속적이지 않은 섹터에 기록될 것을 의미합니다. 먼저, 이는 보존하고 싶었던 섹터 0xE의 가치 있는 데이터를 덮어쓸 수 있습니다. 그리고 부트로더는 펌웨어가 연속적인 섹터에 위치해야 하므로, 그렇지 않으면 펌웨어가 올바르게 로드되지 않을 수 있습니다.\n\n저희 예제에서는 어떠한 데이터도 저장하기 위해 플래시 섹터를 사용하지 않을 것입니다 — 마이크로컨트롤러에는 PDM으로 지속되는 값들에 충분한 4k 이프롬이 있습니다. 우리 모델에서는 펌웨어 업데이트를 수행할 때 항상 섹터 0부터 7을 섹터 8부터 0xF로 교체할 예정입니다. 이렇게 함으로써 섹터 번호의 단편화를 피하고 펌웨어 코드를 간단하게 만들 수 있을 것입니다. 따라서 현재 펌웨어는 항상 물리적인 섹터 0부터 7까지 차지하고 있으며, 새로운 펌웨어는 섹터 8부터 0xF에 다운로드된 후 역할이 변경될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n단연코, 펌웨어는 플래시 메모리의 절반인 256 KB보다 커서는 안 됩니다. 그러나 마이크로컨트롤러(그리고 OTA 구현)는 보드에 외부 SPI 플래시 메모리가 있다면 해당 플래시 메모리로 펌웨어를 로드할 수 있습니다. 그래서 256 KB보다 많은 공간이 필요한 사람들은 이 옵션을 탐색하는 것이 유용할 수 있습니다.\n\n# 구현\n\n## OTA 클러스터 추가\n\n그래서 코드 작업을 진행해 봅시다. OTA 클러스터 자체를 추가하는 방법은 다른 클러스터를 추가하는 것과 크게 다르지 않습니다. 먼저, Zigbee 구성 편집기에 OTA 클러스터를 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n위의 GUI에서 변경된 사항은 빌드 프로세스의 일부로 실행되는 ZPSConfig 도구를 사용하여 zps_gen.c/h 파일로 변환됩니다.\n\n다음으로 zcl_options.h에서 클러스터 및 해당 설정을 활성화하세요.\n\n```js\n#define CLD_OTA\n#define OTA_CLIENT\n#define OTA_NO_CERTIFICATE\n#define OTA_CLD_ATTR_FILE_OFFSET\n#define OTA_CLD_ATTR_CURRENT_FILE_VERSION\n#define OTA_CLD_ATTR_CURRENT_ZIGBEE_STACK_VERSION\n#define OTA_MAX_BLOCK_SIZE 48\n#define OTA_TIME_INTERVAL_BETWEEN_RETRIES 10\n#define OTA_STRING_COMPARE\n#define OTA_UPGRADE_VOLTAGE_CHECK\n```\n\n<div class=\"content-ad\"></div>\n\n이제 재미있는 부분이 시작됩니다. 이러한 설정들은 몇 가지 설명이 필요합니다. 그렇지 않으면 OTA 클러스터가 컴파일되지 않습니다:\n\n- CLD_OTA 및 OTA_CLIENT는 OTA 클러스터를 클라이언트 모드로 구현하는 기능을 활성화합니다.\n- OTA_NO_CERTIFICATE — 암호화 인증서를 사용하지 않을 것입니다. 이러한 인증서가 없으며 디지털 서명 검증에 사용되는 라이브러리가 없습니다.\n- OTA_CLD_ATTR_*는 여러 OTA 클러스터 속성을 활성화합니다. zigbee2mqtt에서 사용되지 않을 수 있지만 일부 속성을 포함하겠습니다. 흥미로운 것으로 간주되는 일부 속성을 활성화했습니다.\n- OTA_MAX_BLOCK_SIZE는 다운로드 블록 크기를 48바이트로 설정합니다. 이 매개변수는 데이터를 플래시 메모리에 쓰기 위해 16의 배수여야 합니다. 또한 최대 Zigbee 패킷 크기를 초과하지 않도록 너무 크지 않아야 합니다.\n- OTA_TIME_INTERVAL_BETWEEN_RETRIES — 서버 요청 재시도 간의 간격(예: 서버와의 연결이 끊어졌을 때). 클라이언트가 너무 자주 서버에 요청을 보내지 않도록 간격을 설정합니다.\n- OTA_STRING_COMPARE는 특히 OTA 펌웨어 헤더의 32바이트 문자열 식별자를 통한 펌웨어 유효성 검사를 활성화합니다. 기대하는 값과 일치하지 않으면 펌웨어 업데이트가 오류와 함께 중지됩니다. 또한 이 검사는 펌웨어 다운로드의 맨 처음에 수행됩니다: 헤더와 함께 작은 부분이 다운로드되며 문자열 식별자가 체크되며, 일치하지 않으면 펌웨어가 심지어 다운로드되지 않습니다.\n- OTA_UPGRADE_VOLTAGE_CHECK는 펌웨어를 업데이트하기 전에 배터리 잔량을 확인하고 (배터리가 낮으면 업데이트를 방지) 적용합니다. 라우터에는 관련성이 없지만 전원이 배터리로 공급되는 장치에 유용할 수 있습니다.\n\n또한, `OTA_INTERNAL_STORAGE` 정의를 추가하십시오 — 이 설정은 마이크로콘트롤러의 내부 플래시 메모리에 쓰기를 활성화합니다 (외부 플래시 드라이브가 아닌). 이 define은 OTA 클러스터 코드에서만 사용되지만, 이 설정은 OTA 클러스터 설정이 아닌 보드 및 마이크로컨트롤러의 물리적 특성과 관련이 있다고 생각되어 CMakeList.txt에 배치하기로 결정했습니다.\n\n```js\nADD_DEFINITIONS(\n...\n        -DOTA_INTERNAL_STORAGE\n```\n\n<div class=\"content-ad\"></div>\n\n## OTA 클러스터 초기화\n\n일반 프로젝트 설정이 끝났으니, 추가적인 코드 작성을 시작해봅시다. 문서에는 초기화 프로세스에 대해 상세히 설명되어 있습니다. 흥미로운 점은 NXP 예제에서 몇 가지 측면을 약간 다르게 처리한다는 것입니다. 특히 문서와 다르게 몇 가지 부정확한 정보가 있기 때문에 우리는 문서에서 벗어나 허용하려고 합니다.\n\n문서는 초기화 프로세스를 다음과 같이 설명합니다.\n\n![2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_11.png](/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_11.png)\n\n<div class=\"content-ad\"></div>\n\n1~3단계에 문제가 없어요. 이미 Main.cpp에서 우리의 펌웨어를 처리했어요. 하지만 4번째 단계의 설명이 약간 부정확해 보여요. 문서에는 eOTA_Create()를 호출한 후에 즉시 eOTA_UpdateClientAttributes()를 호출하라고 합니다. 하지만 이 방법은 작동하지 않아요. 왜냐하면 eOTA_UpdateClientAttributes()를 호출하려면 OTA 엔드포인트가 먼저 등록되어 있어야 해요. 즉, 6단계(엔드포인트 등록)를 eOTA_Create()와 eOTA_UpdateClientAttributes() 사이에 완료해야 해요.\n\n내 구현에서 OTA 클러스터는 BasicClusterEndpoint 클래스의 다른 기본 장치 클러스터들과 함께 사용될 거예요.\n\n```js\nvoid BasicClusterEndpoint::init()\n{\n    registerBasicCluster();\n    registerIdentifyCluster();\n    registerOtaCluster();\n    registerEndpoint();\n...\n    // OTA 초기화\n    otaHandlers.initOTA(getEndpointId());\n}\n```\n\nOTA 클러스터는 eOTA_Create() 함수로 등록되어요.\n\n<div class=\"content-ad\"></div>\n\n```cpp\nvoid BasicClusterEndpoint::registerOtaCluster()\n{\n    DBG_vPrintf(TRUE, \"BasicClusterEndpoint::registerOtaCluster(): Registering ota cluster\\n\");\n    // 클라이언트로서 OTA 클러스터의 인스턴스를 생성합니다\n    teZCL_Status status = eOTA_Create(&clusterInstances.sOTAClient,\n                                      FALSE,  /* 클라이언트 */\n                                      &sCLD_OTA,\n                                      &sOTAClientCluster,  /* 클러스터 정의 */\n                                      getEndpointId(),\n                                      NULL,\n                                      &sOTACustomDataStruct);\n\n    if(status != E_ZCL_SUCCESS)\n        DBG_vPrintf(TRUE, \"BasicClusterEndpoint::registerOtaCluster(): OTA 클러스터 인스턴스 생성에 실패했습니다. 상태=%d\\n\", status);\n}\n```\n\n이제 OTA 초기화를 진행해야 합니다. OTA와 관련된 모든 것(클러스터 등록을 제외하고)를 단순히 기능을 그룹화하기 위해 별도의 클래스인 `OTAHandlers`로 이동했습니다.\n\n```cpp\nclass OTAHandlers\n{\n    uint8 otaEp;\n    PersistedValue<tsOTA_PersistedData, PDM_ID_OTA_DATA> sPersistedData;\n...\n```\n\n지침의 4단계에서 제안한 대로, OTA 클러스터 속성을 초기화해야 합니다. 언급했듯이 OTA 구현은 펌웨어 업데이트 상태가 EEPROM에 저장되고 재부팅 후에 복원될 것을 가정합니다. 저는 이를 다음과 같이 구현했습니다.\n\n<div class=\"content-ad\"></div>\n\n```cpp\nvoid resetPersistedOTAData(tsOTA_PersistedData * persistedData)\n{\n    memset(persistedData, 0, sizeof(tsOTA_PersistedData));\n}\n\nvoid OTAHandlers::restoreOTAAttributes()\n{\n    // 클러스터 속성을 초기값으로 설정합니다.\n    teZCL_Status status = eOTA_UpdateClientAttributes(otaEp, 0);\n    if(status != E_ZCL_SUCCESS)\n        DBG_vPrintf(TRUE, \"OTAHandlers::restoreOTAAttributes(): OTA 클러스터 속성 생성 실패. 상태=%d\\n\", status);\n\n    // 이전 값 복원 또는 제로 리셋\n    sPersistedData.init(resetPersistedOTAData, \"OTA 데이터\");\n    status = eOTA_RestoreClientData(otaEp, &sPersistedData, TRUE);\n    if(status != E_ZCL_SUCCESS)\n        DBG_vPrintf(TRUE, \"OTAHandlers::restoreOTAAttributes(): OTA 데이터 복원 실패. 상태=%d\\n\", status);\n}\n```\n\neOTA_UpdateClientAttributes() 함수는 클러스터 속성을 일부 초기값으로 설정합니다.\n\n펌웨어 업그레이드 진행 상황은 tsOTA_PersistedData 구조체에 저장됩니다. 이는 펌웨어 업그레이드 프로세스가 재부팅 후 일시 중지 및 재개할 수 있는 모든 정보를 포함합니다. 현재 다운로드된 펌웨어 메타데이터, 크기, 현재 파일 오프셋, 재시도 횟수 등이 포함됩니다. OTA ZCL 구현은 현재 상태를 주기적으로 EEPROM에 저장합니다.\n\n두 번째 코드 블록은 플래시 메모리에서 상태를 읽고 이 정보를 OTA 클러스터 내부 구조에 복원합니다. 첫 번째 장치 시작이며 EEPROM에 상태 레코드가 없는 경우, resetPersistedOTAData() 함수가 호출되어 구조체를 제로값으로 초기화합니다.\n\n<div class=\"content-ad\"></div>\n\n## 플래시 메모리 초기화\n\n이제 펌웨어가 다운로드될 플래시 메모리를 초기화하는 데 집중할 시간입니다.\n\n```js\nvoid OTAHandlers::initFlash()\n{\n    // 잘못된 또는 비연속적인 플래시 리매핑을 수정하고 최적화\n    if (u32REG_SysRead(REG_SYS_FLASH_REMAP) & 0xf)\n    {\n        vREG_SysWrite(REG_SYS_FLASH_REMAP,  0xfedcba98);\n        vREG_SysWrite(REG_SYS_FLASH_REMAP2, 0x76543210);\n    }\n...\n```\n\n이 코드는 논리적인 섹터 0–7 및 8–0xF가 연속적인 물리적 섹터를 사용하도록 섹터 매핑을 준비합니다. 리매핑 과정은 위의 전용 섹션에 설명되어 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다음으로, 새 펌웨어가 쓰여질 플래시 메모리 공간을 초기화하는 시간입니다. 말씀드렸듯이, 마이크로컨트롤러는 펌웨어용 외부 메모리를 지원합니다. 그러나 현재는 내부 메모리만으로도 충분합니다. (네, 이미 OTA_INTERNAL_STORAGE를 정의했지만, NXP 개발자들에게는 그게 충분하지 않은 것 같습니다).\n\nMarkdown 형식으로 표를 변경합니다.\n\n```js\n    // 다운로드된 펌웨어를 저장하기 위한 플래시 메모리 초기화\n    tsNvmDefs sNvmDefs;\n    sNvmDefs.u32SectorSize = 32*1024; // 섹터 크기 = 32K\n    sNvmDefs.u8FlashDeviceType = E_FL_CHIP_INTERNAL;\n    vOTA_FlashInit(NULL, &sNvmDefs);\n```\n\n여기 또 하나 흥미로운 코드 조각이 있습니다.\n\n```js\n    // 엔드포인트에 대한 일부 OTA 관련 레코드 작성\n    uint8 au8CAPublicKey[22] = {0};\n    uint8 u8StartSector[1] = {8};\n    teZCL_Status status = eOTA_AllocateEndpointOTASpace(\n                            otaEp,\n                            u8StartSector,\n                            OTA_MAX_IMAGES_PER_ENDPOINT,\n                            8,                                 // 이미지당 최대 섹터 수\n                            FALSE,\n                            au8CAPublicKey);\n    if(status != E_ZCL_SUCCESS)\n        DBG_vPrintf(TRUE, \"OTAHandlers::initFlash(): 엔드포인트 OTA 공간 할당 실패 (OTA 빌드가 아닌 경우 무시할 수 있습니다). status=%d\\n\", status);\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드는 새 펌웨어를 다운로드할 위치(논리 섹터 8부터 시작) 및 최대 펌웨어 크기(8개 섹터, 즉 256k)를 지정합니다.\n\n## ZCL 타이머\n\n이어서 펌웨어 업데이트 프로토콜은 외관상 간단해 보이지만 여러 잠재적인 고장 지점이 있습니다. 메시지가 도착하지 않을 수도 있고, 늦게 도착할 수도 있으며, 잘못된 데이터를 포함할 수도 있습니다. 내부 상태 기계는 이러한 상황을 처리하기 위해 가능한 신뢰성 있어야 합니다. 일관되지 않은 상태가 발생하거나 타임아웃이 발생하면 상태 기계는 장치를 정상 작동 상태로 되돌려야 합니다. 실제로 이러한 상황은 상당히 자주 발생합니다. 제 테스트 네트워크에서는 펌웨어 업데이트 중에 3~4회 발생합니다.\n\n지금까지 사용한 대부분의 클러스터는 시간과 독립적으로 작동합니다. 그들은 들어오는 요청을 처리하거나 내부 이벤트가 발생하면 상태 알림을 보냅니다. 그러나 OTA 클러스터는 타임아웃을 세어내려가기 위해 시간을 알아야 합니다. 이를 위해 OTA 클러스터는 한 번에 한 번씩 틱하는 ZCL 타이머를 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n그 전에 다음과 같이 ZCLTimer 클래스를 추가했습니다. 그래서 새로운 코드가 필요하지 않습니다. 내용은 다음과 같습니다.\n\n```js\nclass ZCLTimer: public PeriodicTask\n{\n    uint32 tick1s;\n    uint32 tick100ms;\n\npublic:\n    ZCLTimer();\n    void init();\n\nprotected:\n    virtual void timerCallback();\n};\n\nvoid ZCLTimer::init()\n{\n    PeriodicTask::init(10);\n    tick1s = 0;\n    tick100ms = 0;\n}\n\nvoid ZCLTimer::timerCallback()\n{\n    tick1s++;\n    tick100ms++;\n\n    if(tick100ms >= 10)\n    {\n        eZCL_Update100mS();\n\n        tick100ms = 0;\n    }\n\n    if(tick1s >= 100)\n    {\n        // Process ZCL timers\n        tsZCL_CallBackEvent sCallBackEvent;\n        sCallBackEvent.pZPSevent = NULL;\n        sCallBackEvent.eEventType = E_ZCL_CBET_TIMER;\n        vZCL_EventHandler(&sCallBackEvent);\n\n        tick1s = 0;\n    }\n}\n```\n\n내부 타이머는 매 10ms마다 틱하게 됩니다. 1초 주기가 도달하면 코드가 E_ZCL_CBET_TIMER를 생성하고, ZCL이 OTA 작업을 모두 처리합니다.\n\n## OTA 이벤트 처리\n\n<div class=\"content-ad\"></div>\n\nOTA 클러스터는 펌웨어 업데이트 프로세스를 완전히 구현합니다. 때때로 ZCL은 업데이트 진행 상황에 관한 알림을 보냅니다. OTA 관련 작업은 별도의 클래스에서 처리되므로 이벤트 리다이렉션을 OTAHandlers 클래스로 설정했습니다.\n\n```js\nvoid BasicClusterEndpoint::handleClusterUpdate(tsZCL_CallBackEvent *psEvent)\n{\n    uint16 clusterId = psEvent->psClusterInstance->psClusterDefinition->u16ClusterEnum;\n    switch(clusterId)\n    {\n...\n        case OTA_CLUSTER_ID:\n            handleOTAClusterUpdate(psEvent);\n            break;\n...\n\nvoid BasicClusterEndpoint::handleOTAClusterUpdate(tsZCL_CallBackEvent *psEvent)\n{\n    // OTA 메시지 파싱 및 처리\n    tsOTA_CallBackMessage *psCallBackMessage = (tsOTA_CallBackMessage *)psEvent->uMessage.sClusterCustomMessage.pvCustomData;\n    otaHandlers.handleOTAMessage(psCallBackMessage);\n}\n\n...\n\nvoid OTAHandlers::handleOTAMessage(tsOTA_CallBackMessage * pMsg)\n{\n    vDumpOTAMessage(pMsg);\n...\n}\n```\n\n이러한 이벤트 대부분은 우리에게 정보 제공을 위한 것이며 별도의 처리가 필요하지 않습니다. 실제로 이러한 이벤트에 대한 핸들러를 구현하지 않고도 안정적인 펌웨어 업데이트를 성공적으로 달성했습니다.\n\n그러나 이러한 이벤트는 사용자 정의 가능한 가능성을 제공합니다. 예를 들어, NXP의 예시는 OTA 이벤트를 사용하여 장치의 업데이트 필요 여부, 다운로드된 펌웨어의 무결성, 추가적인 타임아웃, 다운로드 상태 모니터링을 확인하는 데 사용합니다(표준 구현 위에 많이 구축하였습니다).\n\n<div class=\"content-ad\"></div>\n\n## [Optional] 컨텍스트 저장 및 복원\n\n핸들링이 필요한 유일한 이벤트는 컨텍스트 저장입니다. OTA 클러스터 구현은 때때로 상태를 저장하여 예기치 않은 재부팅 후 펌웨어 다운로드를 재개할 수 있도록 합니다.\n\n상태를 저장하는 코드는 다음과 같습니다. 상태 자체는 OTA 클러스터 인스턴스 내부에 저장되며 거기서 추출해야 합니다. NXP 예제에서는 OTA의 내부에 직접 액세스하지만, 저는 모듈 간 경계를 유지하고 예의와 존중을 유지하려고 노력했습니다.\n\n```js\nvoid OTAHandlers::saveOTAContext(tsOTA_PersistedData * pData)\n{\n    DBG_vPrintf(TRUE, \"OTA 컨텍스트 저장 중... \");\n\n    // 데이터 저장\n    sPersistedData = *pdData;\n\n    DBG_vPrintf(TRUE, \"완료\\n\");\n}\n\nvoid OTAHandlers::handleOTAMessage(tsOTA_CallBackMessage * pMsg)\n{\n    vDumpOTAMessage(pMsg);\n\n    switch(pMsg->eEventId)\n    {\n    case E_CLD_OTA_INTERNAL_COMMAND_SAVE_CONTEXT:\n        saveOTAContext(&pMsg->sPersistedData);\n        break;\n    default:\n        break;\n    }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n로딩 및 복원 상태도 일부 개선이 필요합니다 (NXP의 예시에서 영감을 받았어요).\n\n```js\nvoid OTAHandlers::restoreOTAAttributes()\n{\n    // 속성을 기본 값으로 재설정합니다\n    teZCL_Status status = eOTA_UpdateClientAttributes(otaEp, 0);\n    if(status != E_ZCL_SUCCESS)\n        DBG_vPrintf(TRUE, \"OTAHandlers::restoreOTAAttributes(): OTA 클러스터 속성 생성에 실패했습니다. status=%d\\n\", status);\n\n    // 이전 값 복원 또는 0으로 재설정\n    sPersistedData.init(resetPersistedOTAData, \"OTA 데이터\");\n\n    // 10초 후 다시 시도되도록 재시도 타이머를 수정합니다\n    if((&sPersistedData)->u32RequestBlockRequestTime != 0)\n    {\n        DBG_vPrintf(TRUE, \"OTAHandlers::restoreOTAAttriutes(): 현재 작업을 10초 후 다시 시도할 것입니다 (이전 값 %d)\\n\", (&sPersistedData)->u32RequestBlockRequestTime);\n        (&sPersistedData)->u32RequestBlockRequestTime = 10;\n    }\n\n    status = eOTA_RestoreClientData(otaEp, &sPersistedData, TRUE);\n    if(status != E_ZCL_SUCCESS)\n        DBG_vPrintf(TRUE, \"OTAHandlers::restoreOTAAttributes(): OTA 데이터 복원에 실패했습니다. status=%d\\n\", status);\n}\n```\n\nu32RequestBlockRequestTime 변수를 조정하는 코드가 추가되었습니다. 기본적으로 긴 시간 초과 (예: 1시간)으로 설정되어 있지만, 재부팅 후 펌웨어 다운로드를 더 빨리 재개하고자 합니다 (10초 이내).\n\n솔직히 말해서, 이 코드에 대해 자신감이 많이 없어요. 한 번 이 설정 전체가 일관성 없는 상태에 갇혔던 적이 있어요. 이게 어떻게 발생했는지 알려드릴게요.\n\n<div class=\"content-ad\"></div>\n\n테스트 목적으로 펌웨어 업데이트 중에 디바이스를 끄고 zigbee2mqtt에서 타임아웃이 발생할 때 어떤 일이 일어날지 확인해봤어요. 다시 켜니까, 디바이스가 이전 상태를 복원했어요. 디바이스는 다음 블록을 요청하려고 시도했지만 물론 받지 못했죠. 여러 차례 시도한 후, 디바이스는 포기하고 정상 작동으로 돌아갔어요.\n\n문제는 이 \"정상 상태\"가 EEPROM에 저장되지 않았고, 내 코드는 이에 대해 전혀 알지 못했어요. 디바이스가 재부팅되면 EEPROM에서 잘못된 상태를 다시 읽고 펌웨어 업데이트를 계속하려고 시도했어요.\n\nNXP 사에서는 이 문제를 해결하기 위해 예제에 추가적인 타임아웃을 넣었더라고 해요. 이 타임아웃이 트리거되면, OTA 클러스터 깊숙한 곳에서 무언가를 강제로 수정하여 원래 상태로 돌아가게 했어요.\n\n아직 이 행동을 처리하거나 컨텍스트 저장을 완전히 비활성화할지 결정하지 않았어요. 디바이스가 리부팅 후 깨끗한 상태로 시작하고, 단순히 펌웨어 업데이트 프로세스를 다시 시작하는게 나을지도 모르겠네요.\n\n<div class=\"content-ad\"></div>\n\n## 펌웨어 바이너리 크기 수정\n\n플래시 메모리에 쓰기 위해서는 데이터가 16바이트의 배수인 블록으로 이루어져야 합니다. 그러나 컴파일러의 펌웨어는 항상 이 크기 요구 사항을 충족시키지 않을 수 있습니다.\n\n이상적으로는 필요한 경우 코드를 조정하여 추가 바이트를 추가하는 것이 간단할 것입니다. 그러나 NXP의 OTA 구현에서 한 가지 문제가 있습니다: 펌웨어가 16바이트의 배수가 아닌 경우, 장치가 실제 크기를 넘어선 블록을 추가로 요청하는 버그가 발생합니다.\n\nOTA 코드에서 이 버그를 수정하는 것이 가능하지만, SDK 코드를 수정하는 것은 제 선택이 아니었습니다. 대신, 이진 크기를 16바이트의 배수로 반올림하는 방법을 찾았으나, 이를 달성하는 방법을 모르겠습니다 (파이썬 스크립트를 사용하여 바이트를 추가하는 방법 뿐일지도 모릅니다).\n\n<div class=\"content-ad\"></div>\n\n결국 특정 스크립트를 사용하여 링커를 조정하는 데 성공했습니다.\n\n```js\nINCLUDE AppBuildZBPro.ld\n\nSECTIONS\n{\n...\n        /*\n         * 이전 섹션이 16바이트 경계로 패딩되도록 더미 섹션을 만듭니다.\n         */\n        .pad ((LOADADDR(.text) + SIZEOF(.text) + SIZEOF(.data) + 15) & ~ 15 ):\n        {\n            . = ALIGN (16);\n            LONG(0x00000000)\n            LONG(0x00000000)\n            LONG(0x00000000)\n            LONG(0x00000000)\n        } > flash\n}\n```\n\n펌웨어 크기를 조정하는 마법은 SDK의 AppBuildZBPro.ld 스크립트를 먼저 실행하는 데 있습니다. 이 스크립트는 필요한 섹션을 삽입하고 모든 것을 마이크로컨트롤러 메모리에 올바르게 배치하여 완전한 이진 파일을 빌드합니다.\n\n핵심은 16개의 0으로 구성된 \"pad\" 섹션을 추가하는 것입니다. 이 섹션은 .text 및 .data 섹션 다음에 16바이트로 정렬됩니다. 이 정렬로 링커는 .pad 섹션 앞에 충분한 바이트를 추가하여 펌웨어의 총 크기가 16바이트의 배수가 되도록합니다. OTA 업데이트용으로 파일 서명이 시작할 때 추가 4바이트도 있지만 이것은 펌웨어의 일부로 간주되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n링커 스크립트는 다음과 같이 CMakeList.txt에 포함되어 있습니다:\n\n```js\nSET(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} -T${HelloZigbee_SOURCE_DIR}/HelloZigbee.ld\")\n```\n\n컴파일러 및 링커는 .elf 파일을 생성하며, 이 파일은 마이크로컨트롤러에 직접로드할 수 없습니다. .elf 파일을 플래시 가능한 이진 파일로 변환하기 위해 `objcopy` 유틸리티를 사용합니다. 이 유틸리티를 호출하는 것은 이미 빌드 스크립트의 일부이지만, 우리는 .pad 섹션을 유지하도록 지시해야 합니다. 그렇지 않으면 섹션이 삭제되고 그 앞의 추가 바이트가 제거됩니다. 이를 objcopy 명령에 \" -j .ota\" 옵션을 추가하여 해결합니다.\n\n## OTA 헤더 추가하기\n\n<div class=\"content-ad\"></div>\n\n모두 해결되었다고 생각했을 때, 그 이상이 있습니다! 이 코드가 작동하려면 또 다른 링커 매직이 필요합니다.\n\nOTA 업데이트 서버는 마이크로컨트롤러에 로드된 펌웨어를 식별해야 합니다. 이는 펌웨어 버전, 하드웨어 버전, 펌웨어 파일 유형 및 기타 세부 정보를 포함합니다. 이 모든 정보를 상수나 정의로 컴파일하여 펌웨어에 포함시킬 수 있지만, NXP 개발자들은 펌웨어에 완전한 OTA 헤더를 포함하기로 선택했습니다. 이 구조의 모든 필드가 컴파일 시간에 알려지지 않기 때문에 펌웨어 코드는 .ro_ota_header 섹션에 구조체에 대한 공간을 예약하여 이를 처리합니다. 이 구조체는 완성된 펌웨어 이진 파일에서 외부 Jennic 암호화 도구(JET)를 통해 직접 채워집니다.\n\n하지만 문제가 있습니다. JET은 펌웨어 내 OTA 구조의 정확한 위치를 알아야 합니다. 이를 위해 링커는 파일 시작점으로부터 특정 오프셋에 .ro_ota_header 섹션을 배치해야 합니다.\n\n그 외에도 이 섹션 앞에 다른 섹션이 필요합니다. 즉, .ro_mac_address가 있어야 합니다. 각 칩은 공장에서 고유한 MAC 주소가 할당되지만 때로는 JET 도구를 사용하여 이 주소를 재정의해야 할 수도 있습니다. 재정의 MAC 주소 기능을 사용하지는 않지만, .ro_mac_address 섹션이 펌웨어에 있어야 합니다. 그렇지 않으면 JET이 .ro_ota_header를 놓칠 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n사용되지 않더라도 파일에 모든 섹션이 유지되도록 하려면 다른 링커 기술을 사용할 수 있습니다. 링커 스크립트의 KEEP 키워드는 모든 필요한 섹션을 보존하여 이를 달성하는 데 도움을 줍니다.\n\n```js\nSECTIONS\n{\n        .ro_mac_address :\n        {\n            KEEP(*(.ro_mac_address));\n        } > flash\n\n        .ro_ota_header :\n        {\n            KEEP(*(.ro_ota_header));\n        } > flash\n        \n        .ro_se_lnkKey :\n        {\n            KEEP(*(.ro_se_lnkKey));\n        } > flash\n...\n```\n\n이전에 결과 이진 파일에서 모든 섹션을 유지하도록 objcopy 유틸리티에 알려야 한다고 언급했습니다. 이를 위해 \"objcopy\"의 command line 옵션에 \"-j .ro_mac_address -j .ro_ota_header\"를 추가합니다.\n\nSDK에 포함된 JET 유틸리티에 대해 이해해야 합니다. 해당 작업은 JN-UG-3081 문서에 자세히 설명되어 있습니다. 불행히도 이 문서는 내재적인 프로세스를 충분히 명확히 하지 않습니다. 기존 지식을 전제로 한 세부 정보를 생략합니다. 그래서 올바른 설정을 찾기 위해 시행착오 방법을 사용해야 했습니다.\n\n<div class=\"content-ad\"></div>\n\n\nC:\\NXP\\bstudio_nxp\\sdk\\JN-SW-4170\\Tools\\OTAUtils\\JET.exe -m otamerge --embed_hdr -c HelloZigbee.bin -o HelloZigbee.ota.bin -v JN516x -n 1 -t 1 -u 0x1037 -j \"HelloZigbee2021                 \"\n\n\n위 명령어에서 각 옵션의 의미는 다음과 같습니다:\n\n- -m otamerge는 다양한 OTA 정보를 단일 이진 파일로 병합하는 모드를 활성화합니다.\n- --embed_hdr는 OTA 헤더를 이진 파일에 포함하는 서브 모드를 활성화합니다.\n- -c HelloZigbee.bin은 objcopy에서 얻은 소스 펌웨어 파일을 지정합니다. -c는 펌웨어가 OTA 클라이언트용으로 빌드되었음을 나타냅니다.\n- -o HelloZigbee.ota.bin은 결과 파일의 이름을 지정합니다. 이 파일은 아직 서버에 배치될 수 없지만 이미 마이크로컨트롤러에 플래시될 수 있습니다.\n- -v JN516x는 마이크로컨트롤러 패밀리명을 나타냅니다 (다른 마이크로컨트롤러는 다른 펌웨어 형식을 갖습니다).\n- -n 1은 펌웨어 파일 버전을 설정합니다.\n- -t 1은 펌웨어 파일 유형을 설정합니다 (보드에 여러 마이크로컨트롤러가 있고 각각이 자체 펌웨어를 필요로 하는 경우 해당됨. 여기서는 하나의 유형만 사용할 것입니다).\n- -u 0x1037은 제조사 ID를 지정합니다. 현재는 NXP의 ID를 사용합니다.\n- -j “HelloZigbee2021 “ (위 명령줄과 같이 정확히 많은 공백이 있는 상태) — OTA 헤더에 32바이트 문자열을 플래시합니다. 이 문자열은 펌웨어 업데이트 중에 확인되며 (업데이트할 펌웨어는 동일한 헤더 문자열을 가져야 함) 펌웨어가 로드되지 않습니다.\n\n참고로, OTA 헤더에 포함된 펌웨어 버전은 기본 클러스터에서 보고되고 Z2M 장치 정보 페이지에 표시되는 펌웨어 버전 문자열과 동일하지 않습니다. 이는 단순히 업데이트 프로세스에 참여하지 않는 문자열일 뿐입니다.\n\n\n<div class=\"content-ad\"></div>\n\n## OTAP 펌웨어\n\n이러한 단계를 따르면 마이크로컨트롤러에 플래시할 준비가 된 적절한 펌웨어를 생성할 수 있습니다. 완료되면 펌웨어 내부의 OTAP 헤더에 액세스해야 하는 모든 기능이 의도대로 작동합니다. 그러나 올바른 펌웨어를 생성하는 것만으로는 서버에 업로드하여 OTAP 업데이트를 할 수 없습니다.\n\n이전에 설명했듯이 OTAP 업데이트용 펌웨어의 구조는 지그비 표준에 의해 지정됩니다. 이 펌웨어는 주요 마이크로컨트롤러 펌웨어 주변을 감싸며 무선 업데이트에 적합한 형식을 제공합니다.\n\n이러한 유형의 파일을 준비하기 위해 JET 유틸리티를 다시 사용하지만 다른 설정으로 사용합니다. 이전에 사용한 -- embed_hdr 대신 -- ota 옵션을 사용합니다. 이 방법을 통해 펌웨어가 OTAP 배포를 위한 올바른 형식으로 되어 있음을 보장합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nJET.exe -m otamerge --ota -v JN516x -n 2 -t 1 -u 0x1037 -p 1 -c HelloZigbee.bin -o HelloZigbee.ota\n```\n\n다음은 매개변수 설명입니다.\n\n- -m otamerge는 서로 다른 OTA 정보를 하나의 이진 파일로 병합하는 모드를 활성화합니다.\n- --ota는 하나 또는 여러 이진 파일에서 OTA 형식 펌웨어를 컴파일하는 하위 모드를 활성화합니다.\n- -c HelloZigbee.bin은 이전 단계에서 얻은 소스 펌웨어 파일을 지정합니다. (임베디드 OTA 헤더가 포함됨). -c는 OTA 클라이언트용이므로 사용됩니다.\n- -o HelloZigbee.ota는 생성된 파일의 이름을 지정하며, 이후 서버에 배치할 수 있습니다.\n- -v JN516x는 마이크로컨트롤러 패밀리 이름을 나타냅니다. (다른 마이크로컨트롤러는 다른 펌웨어 형식을 가지고 있습니다).\n- -n 2는 펌웨어 파일 버전을 설정합니다.\n- -t 1은 펌웨어 파일 유형을 설정합니다 (보드에 여러 마이크로컨트롤러가 있고 각각의 펌웨어가 필요한 경우 해당됩니다. 여기서는 하나의 유형만 사용합니다).\n- -u 0x1037은 제조사 ID를 지정합니다. 현재는 NXP의 ID를 사용합니다.\n- -p 1은 매우 중요한 스위치입니다. 파일의 시작 부분에 4바이트 서명을 추가합니다. 이를 사용하지 않으면 zigbee2mqtt가 이러한 펌웨어를 거부합니다.\n\n이상적으로는 빌드마다 증가하는 버전 번호를 자동으로 생성하는 CI를 설정하는 것이 좋습니다. 하지만 현재 CI를 설정하기 귀찮아서 다음과 같은 해킹을 사용합니다. 플래시 도구를 통해 플래시될 펌웨어를 빌드할 때는 버전 #1을 지정하고, 서버에 배치할 펌웨어를 컴파일할 때는 #2를 포함합니다 (-n 2 키를 보십시오). 이렇게 하면 서버의 버전이 마이크로컨트롤러의 버전보다 항상 최신 상태가 됩니다. 물론 실제 장치에 대해서는 더 전문적으로 처리해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n저는 상기 설명된 모든 마법같은 기능들을 여러 개의 CMake 함수로 캡슐화했습니다.\n\n```js\nFUNCTION(ADD_HEX_BIN_TARGETS TARGET)\n    IF(EXECUTABLE_OUTPUT_PATH)\n      SET(FILENAME \"${EXECUTABLE_OUTPUT_PATH}/${TARGET}\")\n    ELSE()\n      SET(FILENAME \"${TARGET}\")\n    ENDIF()\n    ADD_CUSTOM_TARGET(OUTPUT \"${TARGET}.hex\"\n        DEPENDS ${TARGET}\n        COMMAND ${CMAKE_OBJCOPY} -Oihex ${FILENAME} ${FILENAME}.hex\n    )\n    ADD_CUSTOM_TARGET(\"${TARGET}.bin\"\n        DEPENDS ${TARGET}\n        COMMAND ${CMAKE_OBJCOPY} -j .version -j .bir -j .flashheader -j .vsr_table -j .vsr_handlers -j .rodata -j .text -j .data -j .bss -j .heap -j .stack -j .ro_mac_address -j .ro_ota_header -j .pad -S -O binary ${FILENAME} ${FILENAME}.tmp.bin\n        COMMAND \"${SDK_PREFIX}\\\\Tools\\\\OTAUtils\\\\JET.exe\" -m otamerge --embed_hdr -c ${FILENAME}.tmp.bin -v JN516x -n 1 -t 1 -u 0x1037 -o ${FILENAME}.bin\n    )\nENDFUNCTION()\n\nFUNCTION(ADD_OTA_BIN_TARGETS TARGET)\n    IF(EXECUTABLE_OUTPUT_PATH)\n      SET(FILENAME \"${EXECUTABLE_OUTPUT_PATH}/${TARGET}\")\n    ELSE()\n      SET(FILENAME \"${TARGET}\")\n    ENDIF()\n    ADD_CUSTOM_TARGET(${TARGET}.ota\n        DEPENDS ${TARGET}.bin\n # HACK/TODO: setting file version to 2 (-n 2), so that OTA image is always newer than current version\n        COMMAND \"${SDK_PREFIX}\\\\Tools\\\\OTAUtils\\\\JET.exe\" -m otamerge --ota -v JN516x -n 2 -t 1 -u 0x1037 -p 1 -c ${FILENAME}.bin -o ${FILENAME}.ota\n    )\nENDFUNCTION()\n```\n\n생성된 OTA 파일에는 두 개의 OTA 헤더가 포함되어 있는 점을 중요하게 고려해야 합니다:\n\n- 첫 번째는 Zigbee 표준을 준수하는 펌웨어를 보장하는 외부 래퍼입니다. 이 헤더는 zigbee2mqtt에게 펌웨어 파일의 특성에 대한 정보를 제공합니다.\n- 두 번째는 펌웨어 자체에 내장된 헤더입니다. OTA 업데이트 과정에서 외부 래퍼는 삭제되고, 내장 OTA 헤더가 펌웨어가 자체 세부 사항을 이해하는 소스로 남게 됩니다. 버전, 이름 문자열, 제조업체 코드 등에 대한 정보가 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n## OTA 펌웨어 업데이트 with zigbee2mqtt\n\nzigbee2mqtt 대시보드를 통해 OTA 펌웨어 업그레이드를 시작하려면, 먼저 장치 변환기를 구성하여 해당 장치가 OTA 업데이트를 지원함을 인식하도록 설정해야 합니다. 이를 위해 herdsman-converter가 제공하는 표준 OTA 프로시저를 활용할 것입니다.\n\n```js\nconst ota = require('zigbee-herdsman-converters/lib/ota')\n\nconst device = {\n...\n    ota: ota.zigbeeOTA\n};\n```\n\nOTA 펌웨어 업데이트는 z2m 대시보드의 OTA 탭에서 수행됩니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_12.png\" />\n\n지그비2mqtt 대시보드에서 '새 업데이트 확인' 버튼을 클릭하면, 지그비 허즈맨이 온라인 목록을 쿼리하여 사용 가능한 펌웨어 업데이트를 확인합니다. 당연히, 이 목록에는 사용자 정의 펌웨어가 포함되지 않을 것입니다. 그러나 지그비 허즈맨은 인덱스 오버라이드 파일의 사용을 허용하여 로컬 파일을 지정할 수 있습니다. 이러한 로컬 파일의 경우, 모든 세부 정보를 입력할 필요는 없습니다 — 파일 위치만 필요합니다. 따라서, 우리의 인덱스 파일은 이에 맞게 설정될 것입니다.\n\n```js\n[\n    {\n        \"url\": \"HelloZigbee.ota\",\n        \"force\": true\n    }\n]\n```\n\n지그비2mqtt는 서버에 있는 펌웨어 버전을 기기에 현재 있는 버전과 비교하여 업그레이드가 제안되는지 확인하고, 서버 버전이 더 최신일 때에만 업그레이드 제안을 합니다. 개발 중에는 버전 비교와 관계없이 특정 펌웨어로 업그레이드를 강제로 실행하는 것이 유용할 수 있습니다. 이를 위해, 인덱스 파일에 \"force\": true 옵션을 포함합니다. 이 설정은 기기에 있는 버전이 서버에 있는 버전과 동일하거나 더 최신해도 zigbee2mqtt가 업데이트를 계속 진행하도록 지시합니다.\n\n<div class=\"content-ad\"></div>\n\n이제 이 인덱스가 configuration.yaml에서 활성화되어야 합니다.\n\n```yaml\nota:\n    zigbee_ota_override_index_location: index.json\n```\n\nHelloZigbee.ota 펌웨어 파일과 index.json 파일은 데이터 디렉토리 안에 configuration.yaml 파일과 함께 위치해야 합니다. 다시 시작한 후, zigbee2mqtt는 인덱스 파일을 인식하고 사용 가능한 업데이트 목록에 펌웨어를 포함시킵니다.\n\n'새 업데이트 확인' 버튼을 클릭하면 zigbee2mqtt가 디바이스의 현재 펌웨어 버전을 문의합니다. 서버의 펌웨어가 디바이스의 것보다 최신이거나 \"force\" 옵션이 활성화된 경우, zigbee2mqtt는 펌웨어 업데이트를 제안할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## 요약\n\n우후, 아마도 가장 어려운 부분이었을 것 같아요. 정보가 부족하다는 게 아니에요 — 오히려, 한꺼번에 너무 많은 정보를 소화해야 했어요. 그러나 이해하고 모든 것이 정리되면 그리 어려운 게 아니라는 걸 알게 되었죠.\n\n이 기사에서는 Zigbee 기기에 대한 무선 펌웨어 업데이트를 수행하는 방법을 보여드렸어요. 단계별 안내뿐만 아니라 각 단계의 목적과 다르게 처리할 경우 어떤 일이 발생할지에 대해서도 설명하려고 노력했어요.\n\n# 링크\n\n<div class=\"content-ad\"></div>\n\n- 깃허브 프로젝트\n- JN-UG-3115 지그비 클러스터 라이브러리 (지그비 3.0용) 사용자 가이드\n- JN-UG-3113 지그비 3.0 스택 사용자 가이드\n- 응용 프로그램 노트: JN-AN-1003: JN51xx 부트로더 작동\n- JN-UG-3081 JN51xx 암호화 도구 (JET) 사용자 가이드\n- 지그비 클래스 라이브러리 명세서\n- 지그비 트래픽을 스니핑하는 방법\n- zigbee2mqtt에 새 기기 추가\n\n# 지원\n\n이 프로젝트는 취미 프로젝트로 무료로 개발 중입니다. 동시에 작은 기부로 프로젝트를 지원해주시면 감사하겠습니다.\n\n<img src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_13.png\" />","ogImage":{"url":"/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_0.png"},"coverImage":"/assets/img/2024-06-19-HelloZigbeeWorldPart25OTAFirmwareUpdates_0.png","tag":["Tech"],"readingTime":32},{"title":"조시ai, 커스텀 설치자들의 작업 흐름을 간소화하는 Specifi 파트너 ","description":"","date":"2024-06-19 17:11","slug":"2024-06-19-JoshaiSpecifiPartnertoStreamlineWorkflowsforCustomInstallers","content":"\n\n<img src=\"/assets/img/2024-06-19-JoshaiSpecifiPartnertoStreamlineWorkflowsforCustomInstallers_0.png\" />\n\n댄버 — 2024년 6월 11일 — AI 기반 스마트 홈 제어 분야의 선두주자인 Josh.ai가, 전문 설치자를 위한 시스템 설계, 제안 및 프로젝트 관리 소프트웨어를 제공하는 신속히 성장 중인 Specifi와의 파트너십을 발표했습니다. 이 협업은 Specifi 딜러들을 위한 설계 및 제안 워크플로우를 간소화하며, Josh.ai 제품에 쉽게 접근할 수 있게 함과 동시에 고객을 위한 설득력 있는 제안서를 작성할 수 있게 지원합니다.\n\nSpecifi와의 이번 파트너십은 Josh.ai가 딜러들에게 최고 수준의 영업 지원 도구를 제공하는 데 대한 의지를 보여줍니다. 본 파트너십을 통해 Specifi 사용자들은 다음과 같은 혜택을 누릴 수 있습니다:\n\n- 모든 시스템 설계와 제안서에 Josh.ai 제품을 효율적으로 추가할 수 있습니다.\n- 견적 작성 시 Josh.ai 대표 및 기술 지원팀과 실시간 협업이 가능합니다.\n- Josh.ai 솔루션을 효과적으로 전시하는 전문적이고 시각적으로 매력적인 제안서를 작성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-JoshaiSpecifiPartnertoStreamlineWorkflowsforCustomInstallers_1.png\" />\n\n## Specifi IO 소개\n\nSpecifi IO는 2021년에 북아일랜드 벨파스트에서 설립되었습니다. 이 프로젝트 관리 및 제안 플랫폼은 특히 맞춤형 인테그레이터를 위해 설계되었습니다. Specifi IO의 클라우드 기반 플랫폼을 통해 인테그레이터들은 업무 흐름을 최적화하고 효율성을 향상시킬 수 있습니다. 전 세계 주요 인테그레이터들이 사용하는 Specifi IO는 최근 출시된 Specifi WebBuilder로 온라인 존재감을 향상시키는 데도 도움을 줍니다. (https://www.specifi.io/website-builder).\n\n## Josh.ai 소개\n\n<div class=\"content-ad\"></div>\n\n2015년에 설립된 Josh.ai는 덴버를 기반으로 하는 회사로, 일상생활에서 기술과 진정한 자연스러운 상호 작용을 가능하게 하는 플랫폼과 제품을 만들고 있습니다. AI, 기계 학습 및 직관적인 디자인에 초점을 맞춰, Josh.ai의 미션은 우리가 환경 속에서 살아가는 방식을 변화시키는 것입니다. Josh.ai가 제공하는 간단하고 비공개적이며 마법같은 스마트 홈 경험에 대해 더 알아보려면 www.josh.ai을 방문하거나 hello@josh.ai로 이메일을 보내주세요.","ogImage":{"url":"/assets/img/2024-06-19-JoshaiSpecifiPartnertoStreamlineWorkflowsforCustomInstallers_0.png"},"coverImage":"/assets/img/2024-06-19-JoshaiSpecifiPartnertoStreamlineWorkflowsforCustomInstallers_0.png","tag":["Tech"],"readingTime":2},{"title":"안녕하세요, 지그비 세계, 18부 - 사용자 정의 zigbee2mqtt 외부 변환기","description":"","date":"2024-06-19 17:08","slug":"2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter","content":"\n\n이전 두 편의 글에서는 스마트 스위치에 여러 작업을 지원하는 기능을 구현하여, 멀티스테이트 입력 클러스터를 통해 단일/더블/트리플/롱 프레스를 처리하고 보고할 수 있게 되었습니다. 또한 On/Off 스위치 설정 클러스터의 사용자 정의 확장을 통해 장치의 설정을 제어하는 기능도 구현했습니다. 이러한 추가 기능으로 사용자들은 Zigbee 시설을 이용하여 런타임에서 장치를 구성할 수 있게 됩니다.\n\n그러나 한 가지 문제가 있습니다: 우리는 장치 측면에서 이를 구현했지만, zigbee2mqtt와 같은 다른 시스템들은 이러한 추가 기능과 어떻게 작동해야 하는지 알지 못합니다. 이 글에서는 우리의 장치를 지원하기 위해 zigbee2mqtt용의 외부 컨버터 — 특별한 플러그인을 작성하는 방법을 상세히 설명하고 있습니다.\n\n일반적으로, 나의 코드는 이전 글에서 만든 코드를 기반으로 합니다. 개발 보드로는 NXP JN5169 마이크로컨트롤러를 기반으로 한 EBYTE E75-2G4M10S 모듈을 사용할 것입니다. 이 글은 Hello Zigbee 시리즈에 훌륭한 추가 내용이 되며, 처음부터 Zigbee 장치 펌웨어를 구축하는 방법을 설명하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Zigbee2mqtt 외부 컨버터\n\n안타깝게도 외부 컨버터에 대한 문서화가 매우 미흡하며, 정확히 함수가 무엇을 해야 하는지에 대한 좋은 설명을 찾지 못했습니다. 조금 모호한 예제 몇 개가 있지만, 이에 대해 많은 의문이 듭니다.\n\n우리의 사용자 정의 On/Off Switch Configuration Cluster를 지원하기로 시작합시다. 저는 직접 `poke` 메서드를 사용하여 내 컨버터를 작성해야 했고, 그들이 어떻게 동작해야 하는지 파악하기 위해 수십 개의 기존 컨버터를 살펴보았습니다. 제가 제작 중일 때 컨버터에 대해 공부한 내용은 다음과 같습니다.\n\n모든 컨버터는 `imports`로 시작합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst fz = require('zigbee-herdsman-converters/converters/fromZigbee');\nconst tz = require('zigbee-herdsman-converters/converters/toZigbee');\nconst exposes = require('zigbee-herdsman-converters/lib/exposes');\nconst reporting = require('zigbee-herdsman-converters/lib/reporting');\nconst e = exposes.presets;\nconst ea = exposes.access;\n```\n\n우리가 맞춤 필드를 여러 개 추가했기 때문에, 그들과 관련된 유형 및 데이터 구조를 설명해야 합니다. Herdsman converters 프로젝트에서 정의된 모든 가능한 유형이 있습니다. 불행하게도, TypeScript에서 구조체를 JavaScript 코드로 가져오는 방법을 찾지 못해 필요한 유형의 값을 중복해서 작성해야 했습니다.\n\n```js\nconst DataType = {\n    uint16: 0x21,\n    enum8: 0x30,\n}\n```\n\n새로운 속성에 대한 열거형 값들을 정의해봅시다. 값들의 순서는 펌웨어 코드에 설명된 것과 동일하며, 변환기 코드는 목록에서 위치 번호를 해당 값과 일치시키기만 하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst switchTypeValues = ['toggle', 'momentary', 'multifunction'];\nconst switchActionValues = ['onOff', 'offOn', 'toggle'];\nconst relayModeValues = ['unlinked', 'front', 'single', 'double', 'tripple', 'long'];\n```\n\n제조업체별 속성을 참조할 때에는 속성 식별자 뿐만 아니라 제조업체 코드도 명시해야 합니다. 그렇지 않으면 ZCL 펌웨어 코드에서 요청을 거부합니다.\n\n```js\nconst manufacturerOptions = {\n    jennic: {manufacturerCode: 0x1037}\n}\n```\n\n이제 z2m 웹 양식에 해당 필드를 등록해야 합니다. 이러한 필드는 디바이스의 Exposes 탭에 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nfunction genSwitchEndpoint(epName) {\n   return [\n       e.switch().withEndpoint(epName),\n       exposes.enum('switch_mode', ea.ALL, switchModeValues).withEndpoint(epName),\n       exposes.enum('switch_actions', ea.ALL, switchActionValues).withEndpoint(epName),\n       exposes.enum('relay_mode', ea.ALL, relayModeValues).withEndpoint(epName),\n       exposes.numeric('max_pause', ea.ALL).withEndpoint(epName),\n       exposes.numeric('min_long_press', ea.ALL).withEndpoint(epName),\n   ]\n}\n\nfunction genSwitchEndpoints(endpoinsCount) {\n   let features = [];\n\n   for (let i = 1; i <= endpoinsCount; i++) {\n       const epName = `button_${i}`;\n       features.push(...genSwitchEndpoint(epName));\n   }\n\n   return features;\n}\n```\n\n주어진 엔드포인트 수에 대해 첫 번째 함수는 스위치 위젯 (e.switch())과 구성 필드 시리즈를 생성합니다. 결과물은 다음과 같습니다.\n\n<img src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_1.png\" />\n\n2~3개 값으로 이루어진 열거형 필드는 버튼으로, 다른 필드(relay_mode)는 드롭다운 목록으로 변환되었습니다. 마지막 두 숫자 필드는 증가/감소 화살표가 있는 입력 필드입니다.\n\n<div class=\"content-ad\"></div>\n\n이제 이에 생명을 불어넣고, 3개의 변환 함수를 작성해야 합니다. 이 3개의 함수는 toZigbee 및 fromZigbee라는 코드명으로 구성되어야 합니다. 정확히 무슨 의미인지는 아래에서 설명하겠습니다.\n\n양식을 변경할 때 zigbee2mqtt는 toZigbee 구조에서 convertSet() 함수를 호출합니다. key 필드는 또한 우리의 컨버터가 처리할 수있는 매개변수 목록을 지정합니다.\n\n```js\nconst toZigbee_OnOffSwitchCfg = {\n   key: ['switch_mode', 'switch_actions', 'relay_mode', 'max_pause', 'min_long_press'],\n\n   convertSet: async (entity, key, value, meta) => {\n       let payload = {};\n       let newValue = value;\n\n       switch(key) {\n           case 'switch_mode':\n               newValue = switchModeValues.indexOf(value);\n               payload = {65280: {'value': newValue, 'type': DataType.enum8};\n               await entity.write('genOnOffSwitchCfg', payload, manufacturerOptions.jennic);\n               break;\n\n           case 'switch_actions':\n               newValue = switchActionValues.indexOf(value);\n               payload = {switchActions: newValue};\n               await entity.write('genOnOffSwitchCfg', payload);\n               break;\n\n           case 'relay_mode':\n               newValue = relayModeValues.indexOf(value);\n               payload = {65281: {'value': newValue, 'type': DataType.enum8};\n               await entity.write('genOnOffSwitchCfg', payload, manufacturerOptions.jennic);\n               break;\n\n           case 'max_pause':\n               payload = {65282: {'value': value, 'type': DataType.uint16};\n               await entity.write('genOnOffSwitchCfg', payload, manufacturerOptions.jennic);\n               break;\n\n           case 'min_long_press':\n               payload = {65283: {'value': value, 'type': DataType.uint16};\n               await entity.write('genOnOffSwitchCfg', payload, manufacturerOptions.jennic);\n               break;\n\n           default:\n               break;\n       }\n\n       result = {state: {[key]: value}\n       return result;\n   },\n```\n\ntoZigbee_OnOffSwitchCfg::convertSet() 함수는 텍스트 속성 이름과 설정할 속성 값들을 받습니다. 이 함수의 목표는 이를 네트워크로 전송할 수 있는 구조로 변환하는 것입니다. 표준 속성 (예: switch_actions)의 경우, 단순히 속성 키-값 쌍이 될 것이지만, 값은 숫자로 변환됩니다. herdsman 변환기 코드는 표준 속성 및 이들의 형식, 네트워크로 전달하는 방법 등을 알고 있습니다. 비표준 속성 (예: relay_mode)의 경우, 세 개의 값으로 변환해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n- 숫자 속성 식별자 (10진 형식으로 설정해야 함 — 예: 65280)\n- 속성 유형 (유형 식별자)\n- 값 (열거형의 경우 값 색인)\n\n이러한 값들은 낮은 수준의 Zigbee 메시지로 묶여 네트워크를 통해 전송됩니다. 엔티티 객체는 읽기 및 쓰기 명령이 실행되는 엔드포인트입니다. 비표준 속성을 위해 제조사별 코드를 지정하는 것이 필수적입니다 (manufacturerOptions.jennic 사용).\n\n함수는 속성의 새로운 상태를 반환해야 합니다. 그 결과는 꼼꼼한 종류의 구조로 구성되어야 하며, 그렇지 않으면 웹 양식의 버튼 값이 변경되지 않습니다.\n\n새로운 속성 값을 보내는 스니퍼는 다음과 같이 보일 것입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_2.png\" />\n\n디바이스 측에서는 ZCL 구현이 들어오는 요청을 파싱하고, 자동으로 새 값을 해당 필드에 설정합니다.\n\n```js\nZPS_EVENT_APS_DATA_INDICATION: SrcEP=1 DstEP=2 SrcAddr=0000 Cluster=0007 () Status=0\nZCL Write Attribute: Clustter 0007 Attrib ff00\nZCL Endpoint Callback: Write attributes completed\nZPS_EVENT_APS_DATA_CONFIRM: SrcEP=2 DstEP=1 DstAddr=0000 Status=0\nZPS_EVENT_APS_DATA_ACK: SrcEP=1 DrcEP=2 DstAddr=0000 Profile=0104 Cluster=0007 ()\n```\n\n속성을 읽는 것이 더 어려워 보입니다. 기본적으로 zigbee2mqtt UI는 현재 속성 값을 표시하지 않습니다. 속성 중 하나 옆의 \"업데이트\" 버튼을 클릭하면 toZigbeeConverter::convertGet() 함수가 호출됩니다.\n\n<div class=\"content-ad\"></div>\n\n처음에는 이름인 toZigbee::converterGet()에 매우 혼동을 겪었어요. 왜 fromzigbee가 아니지? 네트워크에서 데이터를 받는 거 아니면서도 말이죠? 그런데 코드를 더 정확하게 살펴보니까 더 명확해졌어요: toZigbee 구성 요소는 (읽기 요청이더라도) 네트워크로 요청을 준비하는 역할을 담당하고 있어요. 장치는 나중에 읽기 속성 응답 메시지를 포함한 읽기 값이 들어있는 응답을 보내줄 거예요. 그럼 fromZigbee 구성 요소는 네트워크로부터 도착한 내용을 구문 분석하게 됩니다 (하지만 이에 대해서는 나중에 더 자세히 이야기할게요).\n\n대부분의 변환기 구현은 한 번에 모든 속성을 가져오기 위해 일괄 요청을 사용해요 - Zigbee 사양이 이를 허용하기 때문이죠. 안타깝게도, 표준 속성('switchActions')과 제조사별 속성을 사용하고 있기 때문에 이들을 한 번에 가져오기가 불가능해요. 따라서 제 구현은 한 번에 하나의 속성을 가져올 거에요. 물론, 표준이 아닌 속성을 읽는 것은 제조사 코드가 필요할 거에요.\n\n스니퍼에서 읽기 요청이 어떻게 보이는지 살펴보세요.\n\n<div class=\"content-ad\"></div>\n\n이것이 테이블 태그이며, 이것이 답변입니다.\n\n\n![이미지](/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_4.png)\n\n\n단말기에서 패킷을 수신한 코디네이터는 fromZigbee 구성 요소가 요청의 구문 분석을 수행합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst getKey = (object, value) => {\n    for (const key in object) {\n        if (object[key] == value) return key;\n    }\n};\n\nconst fromZigbee_OnOffSwitchCfg = {\n   cluster: 'genOnOffSwitchCfg',\n   type: ['attributeReport', 'readResponse'],\n\n   convert: (model, msg, publish, options, meta) => {\n\n       const ep_name = getKey(model.endpoint(msg.device), msg.endpoint.ID);\n       const result = {};\n\n       // switch type\n       if(msg.data.hasOwnProperty('65280')) {\n           result[`switch_mode_${ep_name}`] = switchModeValues[msg.data['65280']];\n       }\n\n       // switch action\n       if(msg.data.hasOwnProperty('switchActions')) { // use standard 'switchActions' attribute identifier\n           result[`switch_actions_${ep_name}`] = switchActionValues[msg.data['switchActions']];\n       }\n\n       // relay mode\n       if(msg.data.hasOwnProperty('65281')) {\n           result[`relay_mode_${ep_name}`] = relayModeValues[msg.data['65281']];\n       }\n\n\n       // Maximum pause between button clicks in a multiclick\n       if(msg.data.hasOwnProperty('65282')) {\n           result[`max_pause_${ep_name}`] = msg.data['65282'];\n       }\n\n       // Minimal duration for the long press\n       if(msg.data.hasOwnProperty('65283')) {\n           result[`min_long_press_${ep_name}`] = msg.data['65283'];\n       }\n\n       return result;\n   },\n}\n```\n\n이 함수는 해당 보고서에서 속성 값들을 파싱하고, 이를 Z2M 구조로 `attribute_name`_`endpoint_name` 레코드로 분해하려고 노력합니다.\n\n거의 다 끝났어요. 마지막 구조 하나만 더 남았는데, 이것은 모든 것을 함께 모을 것입니다.\n\n```js\nconst device = {\n    zigbeeModel: ['Hello Zigbee Switch'],\n    model: 'Hello Zigbee Switch',\n    vendor: 'NXP',\n    description: 'Hello Zigbee Switch',\n    fromZigbee: [fz.on_off, fromZigbee_OnOffSwitchCfg],\n    toZigbee: [tz.on_off, toZigbee_OnOffSwitchCfg],\n    exposes: genEndpoints(2),\n    configure: async (device, coordinatorEndpoint, logger) => {\n        device.endpoints.forEach(async (ep) => {\n            await ep.read('genOnOff', ['onOff']);\n            await ep.read('genOnOffSwitchCfg', ['switchActions']);\n            await ep.read('genOnOffSwitchCfg', [65280, 65281, 65282, 65283], manufacturerOptions.jennic);\n        });\n    },\n    endpoint: (device) => {\n        return {button_1: 2, button_2: 3};\n    },\n};\n\nmodule.exports = device;\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드는 새로운 장치를 등록하고 해당 장치에 대한 컨버터를 등록합니다. On/Off 기능에는 표준 fz/tz.on_off 컨버터가 사용되며, 우리의 함수인 to/fromZigbee_OnOffSwitchCfg가 스위치 구성을 처리합니다.\n\n이 장치는 이미 2개의 스위치 엔드포인트를 지원하므로, 컨버터는 2개의 설정 세트를 등록합니다. 또한, 기본 채널이 endpoint #1에 있고, 스위치 엔드포인트는 endpoint #2부터 시작한다는 점을 기억하십시오. 모든 것이 올바르게 보여지고 작동되도록 endpoint-to-buttons 재번호 매핑을 추가해야 했습니다.\n\n또한 configure() 함수를 강조하고 싶습니다. Z2M을 시작할 때는 스위치의 현재 상태나 설정 값이 알려져 있지 않습니다 — 설정 섹션의 모든 필드는 비어 있을 것입니다. 제가 연구한 대부분의 컨버터는 속성 보고를 설정하며, 장치는 예를 들어 1분마다 상태와 속성을 보고합니다. 따라서 일부 장치는 시작 시 값이 즉시 표시되지 않지만 나중에 값이 나타납니다. 이는 온도 센서와 같은 장치에 적합한 옵션입니다. 저의 컨버터 버전에서는 시작 시에 실제 값을 간단히 읽기로 결정했습니다.\n\n마지막 단계는 zigbee2mqtt에서 컨버터를 등록하는 것입니다. configuration.yaml에 다음 라인을 추가하고 Z2M을 다시 시작하면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n```yaml\nexternal_converters:\n  - myswitch.js\n```\n\n장치가 가입할 때, zigbee2mqtt는 장치 이름을 요청하고 해당하는 컨버터를 사용할 것입니다.\n\n# 다중 액션 지원\n\n기억하시다시피, 우리는 장치에 다중 입력 클러스터를 추가하여 단일/이중/삼중/긴 눌림을 보고할 수 있도록 했습니다. 이러한 이벤트들은 속성 변경 보고서로 제공됩니다. 하지만 이제는 Z2M이 이러한 보고서를 이해하고 적절한 액션을 생성할 수 있도록 가르쳐 주어야 합니다. 이를 위해 fromZigbee 컨버터를 또 추가해보죠. 이 클러스터에 뭔가를 장치에 쓰지 않을 것이므로 toZigbee 컨버터를 추가할 필요는 없습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nconst fromZigbee_MultistateInput = {\n   cluster: 'genMultistateInput',\n   type: ['attributeReport', 'readResponse'],\n\n   convert: (model, msg, publish, options, meta) => {\n       const actionLookup = {0: 'release', 1: 'single', 2: 'double', 3: 'tripple', 255: 'hold'};\n       const value = msg.data['presentValue'];\n       const action = actionLookup[value];\n\n       const result = {action: utils.postfixWithEndpointName(action, msg, model)};\n       return result;\n   },\n}\n```\n\n이 컨버터는 ptvo_multistate_action 컨버터에서 영감을 받았습니다. presentValue 클러스터 속성을 간단히 추출하여 해당 작업 텍스트로 변환합니다.\n\n이 컨버터는 장치가 생성할 수 있는 작업도 광고할 수 있어서 Home Assistant와 같은 다른 시스템이 준비할 수 있습니다.\n\n```js\nfunction genSwitchActions(endpoinsCount) {\n   let actions = [];\n\n   for (let i = 1; i <= endpoinsCount; i++) {\n       const epName = `button_${i}`;\n       actions.push(... ['single', 'double', 'triple', 'hold', 'release'].map(action => action + \"_\" + epName));\n   }\n\n   return actions;\n}\n\n...\n\nconst device = {\n...\n   fromZigbee: [fz.on_off, fromZigbee_OnOffSwitchCfg, fromZigbee_MultistateInput],\n...\n   exposes: [\n       e.action(genSwitchActions(2)),\n       ...genSwitchEndpoints(2)\n   ],\n...\n```\n\n<div class=\"content-ad\"></div>\n\n제가 원했던 것은 각 엔드포인트에서의 작업이 나머지 엔드포인트 정보와 함께 선언되기를 했지만(zigbee2mqtt 아키텍처는 이를 허용하지 않습니다), 이를 위한 genSwitchEndpoint() 함수에서 정의할 수 없습니다. 모든 작업은 exposes 필드에서 e.action() 함수를 사용하여 한 번만 정의해야 합니다(여기에 설명이 나와 있습니다).\n\n자, 이제 버튼을 눌러서 zigbee2mqtt 쪽에서 어떻게 작동하는지 확인해 봅시다.\n\n```js\nZigbee2MQTT:debug 2021-10-19 22:31:53: Received Zigbee message from 'TestSwitch', type 'attributeReport', cluster 'genMultistateInput', data '{\"presentValue\":255}' from endpoint 3 with groupID 0\nZigbee2MQTT:info  2021-10-19 22:31:53: MQTT publish: topic 'zigbee2mqtt2/TestSwitch', payload '{\"action\":\"hold_button_2\",\"last_seen\":1634671913843,\"linkquality\":70,\"max_pause_button_1\":null,\"max_pause_button_2\":null,\"min_long_press_button_1\":null,\"min_long_press_button_2\":null,\"relay_mode_button_1\":\"front\",\"relay_mode_button_2\":\"unlinked\",\"state_button_1\":\"OFF\",\"state_button_2\":\"OFF\",\"switch_actions_button_1\":null,\"switch_actions_button_2\":null,\"switch_type_button_1\":null,\"switch_type_button_2\":\"momentary\"}'\nZigbee2MQTT:info  2021-10-19 22:31:53: MQTT publish: topic 'zigbee2mqtt2/TestSwitch', payload '{\"action\":\"\",\"last_seen\":1634671913843,\"linkquality\":70,\"max_pause_button_1\":null,\"max_pause_button_2\":null,\"min_long_press_button_1\":null,\"min_long_press_button_2\":null,\"relay_mode_button_1\":\"front\",\"relay_mode_button_2\":\"unlinked\",\"state_button_1\":\"OFF\",\"state_button_2\":\"OFF\",\"switch_actions_button_1\":null,\"switch_actions_button_2\":null,\"switch_type_button_1\":null,\"switch_type_button_2\":\"momentary\"}'\nZigbee2MQTT:info  2021-10-19 22:31:53: MQTT publish: topic 'zigbee2mqtt2/TestSwitch/action', payload 'hold_button_2'\n```\n\n우리는 genMultistateInput 클러스터 메시지가 정상적으로 처리되고 MQTT 메시지로 전환된 것을 볼 수 있습니다. 마지막 메시지가 간결하고 중요한데, 두 번째 버튼이 눌린 이벤트가 있었습니다. MQTT 이벤트를 구독할 수 있는 어떤 시스템이든 이러한 메시지를 쉽게 처리할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다른 두 개의 메시지가 조금 혼란스러울 수 있어요 — \"action\":\"hold_button_2\"를 보내고, 곧바로 \"action\":\"\"를 보내죠. 하지만 이는 Zigbee2mqtt FAQ에 설명된 정상적인 동작인 걸 알게 된 것이죠.\n\n팁:\n\n이전에도 언급했듯이 Multistate 입력 클러스터는 일반적인 방식과는 조금 다르게 사용되어요 — 값 자체보다는 값 변경 이벤트에 관심이 있는 것이죠. 주요 속성이 다양한 값들을 취할 수 있는 편리한 클러스터일 뿐입니다.\n\n하지만 Multistate 입력이 다양한 버튼 이벤트를 신호로 지시하는 유일한 방법은 아닙니다. 그래서 샤오미 WXKG01LM 스위치는 OnOff 클러스터의 비표준 확장을 구현합니다. 상태 속성의 표준 0 및 1 값 이외에도 클릭 수를 나타내는 다른 값을 사용할 수 있어요. 다른 디바이스들도 On/Off 클러스터의 비표준 확장을 구현하고 다양한 이벤트를 나타내는 추가 속성을 추가합니다.\n\n<div class=\"content-ad\"></div>\n\n일부 디바이스는 펌웨어 측면에서 다중 클릭 로직을 전혀 구현하지 않을 수 있습니다. 반면, 절대 표준적인 OnOff 클러스터가 사용되며, 다중 클릭은 z2m 컨버터에서 타이머를 사용하여 계산됩니다.\n\n마지막으로 제조업체는 매우 사용자 정의된 클러스터를 개발하여 선호하는 형식으로 정보를 전송할 수도 있습니다.\n\n# Home Assistant 자동화\n\nHome Assistant에 노출된 스위치는 거의 자동으로 통합되지만 몇 가지 문제점이 있습니다. 먼저, 기본적으로 대부분의 설정이 비활성화되어 Home Assistant에 숨겨져 있습니다. 각 설정을 수동으로 활성화한 후 Home Assistant를 다시 시작해야 합니다. 매개변수를 활성화한 후에는 기기 페이지가 다음과 같이 보입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_5.png\" />\n\n둘째, 숫자 매개변수는 편집할 수 없습니다. 안타깝게도 이 문제를 전혀 해결할 방법을 찾지 못했습니다. 이를 해결하기 위한 임시방편으로, 이러한 매개변수는 zigbee2mqtt 대시보드에서 편집하거나 해당 mqtt 메시지를 보내는 방법으로 편집할 수 있습니다.\n\n작업에 대해 말하자면, 여기서는 조금 원할한 상황이 아닙니다. 변환기가 가능한 작업 목록을 광고하지만, Home Assistant는이 목록을 무시합니다. 자동화를 생성하려고 하면 HA가 더블/트리플/롱 프레스를 자동화 트리거로 제안하지 않습니다... 해당 작업이 최소한 한 번 발생할 때까지입니다. 그런 다음 해당 작업이 목록에 나타나며 자동화 마법사에서 사용할 수 있게 됩니다.\n\n자, 이제 유용한 일을 해보고 흥미로운 자동화를 작성해 봅시다. 현재 나는 내 Xiaomi 스위치로 커튼을 부분적으로 열거나 닫을 수 있는 기능이 정말 그립습니다. 보통 매우 어렵게 깨어납니다. 커튼이 한꺼번에 완전히 열리면 눈에 매우 충격을 줍니다. 커튼의 정도를 동일한 스위치로 제어할 수 있는 기능이 있으면 좋겠습니다.\n\n<div class=\"content-ad\"></div>\n\n단 몇 분 만에, 홈 어시스턴트 시각적 편집기에서 몇 가지 자동화 규칙을 만들었어요.\n\n첫 번째 자동화는 버튼 더블 클릭으로 커튼을 완전히 열거나 닫습니다.\n\n```js\n- id: '1635018171508'\n  alias: TestSwitch Open/Close curtain\n  description: 'TestSwitch Open/Close curtain'\n  trigger:\n  - platform: mqtt\n    topic: zigbee2mqtt2/TestSwitch/action\n    payload: double_button_1\n  condition: []\n  action:\n  - service: cover.toggle\n    target:\n      entity_id: cover.living_room_curtain\n  mode: single\n```\n\n두 번째 자동화는 버튼을 세 번 클릭하면 커튼을 50%로 엽니다.\n\n<div class=\"content-ad\"></div>\n\n```yaml\n- id: '1635017708545'\n  alias: TestSwitch Half-open curtains\n  description: 'TestSwitch Half-open curtains'\n  trigger:\n  - platform: mqtt\n    topic: zigbee2mqtt2/TestSwitch/action\n    payload: triple_button_1\n  condition: []\n  action:\n  - service: cover.set_cover_position\n    target:\n      entity_id: cover.living_room_curtain\n    data:\n      position: 50\n  mode: single\n```\n\n다음 두 가지 자동화는 길게 누르는 것을 사용합니다 — 버튼을 누르면 커튼이 움직이기 시작하고, 버튼을 놓으면 멈춥니다.\n\n```yaml\n- id: '1635017908150'\n  alias: TestSwitch toggle curtain on button press\n  description: 'TestSwitch toggle curtain on button press'\n  trigger:\n  - platform: mqtt\n    topic: zigbee2mqtt2/TestSwitch/action\n    payload: hold_button_1\n  condition: []\n  action:\n  - service: cover.toggle\n    target:\n      entity_id: cover.living_room_curtain\n  mode: single\n\n- id: '1635017981037'\n  alias: TestSwitch stop curtain\n  description: 'TestSwitch stop curtain'\n  trigger:\n  - platform: mqtt\n    topic: zigbee2mqtt2/TestSwitch/action\n    payload: release_button_1\n  condition: []\n  action:\n  - service: cover.stop_cover\n    target:\n      entity_id: cover.living_room_curtain\n  mode: single\n```\n\n위와 같이 간단한 자동화를 사용하면 단일 버튼으로 커튼을 제어할 수 있습니다 — 열기, 닫기, 특정 개도로 설정하는 것도 가능합니다. 게다가, 버튼의 일반적인 단추도 주 조명을 전환할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 요약\n\n축하해요, 우리는 방금 Xiaomi Aqara 스위치를 새롭게 만들었어요! 음, 비슷한 스마트 스위치예요. 아마도 우리 장치는 좀 더 다양한 설정을 제공할지도 모르지만, 전반적으로 모든 것이 거의 같아요. 그래도 뭔가 다른 목표가 있었죠 — 사용자 정의 클러스터, genOnOffSettingCfg 및 genMultistateInput 클러스터를 생성하고 zigbee2mqtt를 위한 외부 컨버터를 작성해보는 것이었어요.\n\n자신만의 클러스터를 만들거나 기존 클러스터를 확장하는 데 별로 어려운 점이 없다는 것이 밝혀졌어요. zigbee2mqtt를 다루는 데에는 조금 골치가 아팠지만, 그건 대부분 명쾌한 문서의 부재 때문이었어요. 이제 이 빈칸은 채워졌어요 :)\n\n# 링크\n\n<div class=\"content-ad\"></div>\n\n- JN-UG-3113 ZigBee 3.0 스택 사용자 가이드\n- JN-UG-3114 ZigBee 3.0 디바이스 사용자 가이드\n- JN-UG-3076 ZigBee 홈 오토메이션 사용자 가이드\n- ZigBee 클래스 라이브러리 사양\n- Zigbee 트래픽을 감지하는 방법\n- zigbee2mqtt에 새로운 장치 추가\n- 깃허브 프로젝트\n\n# 지원\n\n이 프로젝트는 품앗이 프로젝트로 무료로 개발 중입니다. 동시에 작은 기부로 프로젝트를 지원하는 것을 고려해볼 수 있습니다.\n\n![HelloZigbeeWorld](/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_6.png)","ogImage":{"url":"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_0.png"},"coverImage":"/assets/img/2024-06-19-HelloZigbeeWorldPart18Customzigbee2mqttexternalconverter_0.png","tag":["Tech"],"readingTime":18},{"title":"나노리프 라이트 파이터 크래프트 번들 리뷰 - MacSources","description":"","date":"2024-06-19 17:07","slug":"2024-06-19-NanoleafLightFighterCraftBundleREVIEWMacSources","content":"\n\n# 나놀리프 라이트 패널 번들로 공간을 변신시키세요.\n\n![이미지](/assets/img/2024-06-19-NanoleafLightFighterCraftBundleREVIEWMacSources_0.png)\n\n스타워즈 데이인 5월 4일은 지나갔지만, 나놀리프의 멋진 조명으로 영화에 대한 사랑을 표현하는 것은 언제든지 가능합니다. 저는 지난 7년 동안 나놀리프 제품의 팬이었습니다. 2017년에 첫 번째 나놀리프 조명 프로젝트를 설치했는데, 설정하는 가장 어려운 부분은 디자인을 고민하는 것이었습니다. 영구적인 설치이므로 오랫동안 만족할 수 있는 디자인을 선택해야 합니다. 우리는 21개의 패널을 사용할 수 있었지만 벽에 어떤 디자인을 하고 싶은지 전혀 감이 오지 않았습니다. '게' 모양을 선택했고, 처음 시작한 벽에는 아니지만 우리는 그 디자인을 계속 유지했습니다.\n\n오늘 나놀리프의 환경은 많이 바뀌었습니다. 온라인에서 공유되는 수많은 아이디어가 있고, 나놀리프는 특정 디자인을 얻는 편리한 방법으로 일부 디자인 번들을 제작했습니다. 이러한 번들 중에서 특히 내가 눈여겨 보았던 것은 라이트 파이터와 다크 파이터 크래프트 번들입니다.\n\n<div class=\"content-ad\"></div>\n\n\n![NanoleafLightFighterCraftBundleREVIEWMacSources_1](/assets/img/2024-06-19-NanoleafLightFighterCraftBundleREVIEWMacSources_1.png)\n\n![NanoleafLightFighterCraftBundleREVIEWMacSources_2](/assets/img/2024-06-19-NanoleafLightFighterCraftBundleREVIEWMacSources_2.png)\n\n# Light Fighter Craft Bundle 소개\n\nLight Fighter Craft Bundle은 스타 워즈 프랜차이즈에 헌정된 Nanoleaf 세트의 일부입니다. 더 오래된 형제인 Dark Fighter Craft Bundle은 Light Fighter보다 조금 더 큰 전투기로 만드는 2개의 추가 삼각 패널을 제공합니다. Ultra Black Triangles와 패널 수를 제외하면 두 세트 사이의 유일한 차이점입니다. 이 키트는 다른 모든 Nanoleaf 제품과 마찬가지로 Apple HomeKit, Google Home, Amazon Alexa뿐만 아니라 Razer Chroma 또는 Signal RGB와 같은 일부 PC 소프트웨어와 완전히 호환됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n- Connect+ 기술\n- 레이아웃 어시스턴트\n- 음악 시각화\n- 화면 미러링\n- 터치 컨트롤\n- 16M+ 색상\n- 간편한 설정\n- 스레드 보더 라우터로 작동\n- SmartThings와 호환\n- 모바일 기기 또는 데스크톱 컴퓨터에서 사용자 정의 및 제어 가능함\n\n![이미지](/assets/img/2024-06-19-NanoleafLightFighterCraftBundleREVIEWMacSources_3.png)\n\n# 주요 기능\n\n다크 파이터 크래프트 번들 → $349.97 $314.98 번들 가격\n\n<div class=\"content-ad\"></div>\n\n- Shapes 한정판 울트라 블랙 삼각형 스마터 키트 (9 패널) $199.99\n- Shapes 한정판 울트라 블랙 삼각형 확장 세트 (3 패널) $59.99\n- 한정판 울트라 블랙 미니 삼각형 확장 세트 (10 패널) $89.99\n\n라이트 파이터 세트 (번들로 현재 제공되지 않음) → $329.97\n\n- Shapes 삼각형 스마터 키트 (7 패널) $179.99\n- Shapes 삼각형 확장 세트 (3 패널) $59.99\n- Shapes 미니 삼각형 스마터 키트 (9 패널) $89.99\n\n![이미지](/assets/img/2024-06-19-NanoleafLightFighterCraftBundleREVIEWMacSources_4.png)\n\n<div class=\"content-ad\"></div>\n\n# 요금 및 가용성\n\n나놀리프 제품은 아마존이나 베스트 바이와 같은 유통업체를 통해 구매할 수 있지만 번들은 나놀리프 닷 엠 이베이 사이트를 통해서만 설정됩니다. 자체적으로 번들을 구성할 수도 있지만, 나놀리프에서 구매할 때 패키지된 가격이 있습니다. 이 라이트 파이터 크래프트 번들은 현재 번들로 제공되지 않지만, 다크 파이터 크래프트 번들은 있습니다. 각 세트에 대한 요금 표가 여기에 있습니다.\n\n![나놀리프 번들 가격](/assets/img/2024-06-19-NanoleafLightFighterCraftBundleREVIEWMacSources_5.png)\n\n# 사용자 경험\n\n<div class=\"content-ad\"></div>\n\n아래와 같이 생각하시듯이 인생에서도 나노리프 설치를 시작할 때 끝을 목표로 설정하는 것이 좋습니다. 이 번들은 실제로 세 가지 다른 종류의 조명 패널이 섞여 있는 것이기 때문에 벽에 부착하기 전에 모든 패널을 개봉해 바닥에 펼쳐놓고 나서 작업을 시작했습니다. 레이아웃이 준비되면 벽에 패널을 배치할 위치를 정하기 위해 정확한 치수를 측정했습니다. 내 책상 근처의 모서리에 동작할 것이라는 것을 발견해서 정말 기쁠 때가 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n패널을 설치하기 위해 공간을 준비하기 위해 인형 선반을 제거하고 부드러운 만능 세정제로 벽을 닦아내었습니다. 그런 제품이 없다면 촉촉한 천으로도 충분할 것 같아요. 목표는 벽에 밀착 스트립이 확실히 벽에 고정되지 않게 하는 먼지를 제거하는 것이에요.\n\n벽 준비가 완료되었을 때 전원 케이블이 어디에 위치할지 계획을 세웠어요. 이게 정말 중요한데요, 제 생각에는 전선을 최대한 숨기고 싶어하기 때문이에요. 책상 모퉁이에 선반 스피커 하나를 두고 있었는데, 거기에 케이블을 가리는데 대부분 도움이 될 것 같아요. 저는 절대 메건 전원 어댑터/플러그 크기에 관한 유일한 불만이 있어요. 그것은 거대하고 거의 숨길 수 없어요. 전원 스트립에서 더 많은 콘센트 공간을 차지할 거에요.\n\n전원 원천을 배치한 후 첫 번째 패널이 위치할 곳을 결정했어요. 첫 번째와 두 번째 패널을 놓을 때 수평기를 사용해서 정확하게 배치했는데, 이들은 서로 올려놓기 때문에 전체 설치의 기반을 마련합니다. 조명이 어디에 위치할지 신중하게 계획했다면 나머지 설치는 쉽게 할 수 있을 거에요. 패널 뒷면의 회전 플레이트에 밀착 스트립을 붙이고 다른 Nanoleaf Triangle 패널 옆 벽에 붙여주세요. 패널이 벽에 붙은 후에 연결 부분이 어디로 가야 하는지도 계획해야 해요. 패널이 벽에 고정된 후에 설치하기 어렵기 때문이에요.\n\n모든 조각을 벽에 설치하는 데 약 30분 정도 걸렸고, 네트워크와 홈 앱에 연결하고 펌웨어를 업데이트하는 데 추가로 5-10분이 걸렸어요. 때로는 Nanoleaf 제품이 네트워크와 앱에 연결하는 데 약간 까다로울 수 있지만, 이번에는 아무 문제가 없었어요. 설치한 후에 켜서 공간에 잘 맞는 조명 장면으로 설정했어요.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n나노리프 라이트 패널은 공간에 개성을 더해줍니다. 그들은 섬세하면서도 매우 독특합니다. 나노리프가 협력의 창의성을 받아들이고 제품 라인업에 이러한 특별 번들을 포함시켰다는 것이 좋습니다. 나노리프 설치를 계획하기가 매우 쉬워지기 때문에 제품 제공을 계속 확장하고 이를 홍보하는 것을 바랍니다.\n\n더 많은 정보를 원하시면 nanoleaf.me를 방문해주세요.\n\n원문은 2024년 6월 13일에 https://macsources.com에서 최초 발표되었습니다.","ogImage":{"url":"/assets/img/2024-06-19-NanoleafLightFighterCraftBundleREVIEWMacSources_0.png"},"coverImage":"/assets/img/2024-06-19-NanoleafLightFighterCraftBundleREVIEWMacSources_0.png","tag":["Tech"],"readingTime":4},{"title":"샤오미 팬 분들 여기 최고 모델들을 확인해보세요","description":"","date":"2024-06-19 17:05","slug":"2024-06-19-Xiaomifanscheckthebestmodels","content":"\n\n이열을 가장 효과적으로 차단하는 방법은 무엇일까요? 특히 재택근무를 많이 하시는 경우요! 샤오미 선풍기가 여러분의 가정을 시원하게 만들어드릴 준비가 되어 있습니다. 어떤 샤오미 선풍기 모델을 선택해야 할지 고민이라면, 알려드릴게요!\n\n![샤오미 선풍기 모델 확인하기](/assets/img/2024-06-19-Xiaomifanscheckthebestmodels_0.png)\n\n## 미 스마트 스탠딩 팬 2 Lite (1C)\n\n혁신적인 샤오미 미 스마트 스탠딩 팬 2 Lite (1C)는 집 안에서 자연 바람을 완벽하게 시뮬레이션해줍니다. 이 지능형 선풍기는 정확한 속도 조절과 낮은 소음 수준(최대 63dBA)을 제공하여 홈 오피스나 수면 시간에 이상적입니다. 핸드폰의 Mi Home 앱을 통한 원격 제어 기능은 스마트 홈 환경에 완벽하게 적합합니다. 심플한 디자인은 어떤 인테리어에도 잘 어울리며, 7개의 큰 날개와 38W의 강력한 성능을 통해 제공되는 냉각 효과는 더운 여름에 필수적인 솔루션으로 안성맞춤입니다.\n\n<div class=\"content-ad\"></div>\n\n![image description](/assets/img/2024-06-19-Xiaomifanscheckthebestmodels_1.png)\n\n## 미 스마트 스탠딩 팬 2\n\n샤오미 미 스마트 스탠딩 팬 2는 에너지 효율성, 맞춤 설정 기능 및 지능형 기술로 시장에서 두각을 나타내는 현대적인 기기입니다. 샤오미 에코시스템의 일환인 이 스탠딩 팬은 Mi Home 앱을 통해 속도와 공기 흐름 방향 (140도)을 조절하여 사용자 선호에 맞게 조절할 수 있는 편의성을 제공합니다. 또한, 미 스마트 스탠딩 팬 2는 특히 조용해서(최대 58dBA) 사무실이나 침실에서 사용하기에 완벽합니다. 이 샤오미 팬의 디자인은 미니멀하고 우아하여 다양한 인테리어 스타일에 적합합니다. 미 스마트 스탠딩 팬 2는 집에서 편안함, 효율성 및 지능형 기술을 중시하는 사람들에게 탁월한 솔루션입니다.\n\n![image description](/assets/img/2024-06-19-Xiaomifanscheckthebestmodels_2.png)\n\n<div class=\"content-ad\"></div>\n\n## Mi Smart Standing Fan Pro\n\n샤오미 Mi Smart Standing Fan Pro는 지능적인 냉각 분야의 진정한 걸작입니다. 정밀한 속도 제어, 프로그램 설정, Mi Home 앱을 통한 원격 제어 등과 같은 고급 기능들이 스마트 홈에 탁월한 추가가 됩니다. Mi Smart Standing Fan Pro는 조용한 냉각 뿐만 아니라 공기 필터도 포함하여 건강한 가정 환경을 중시하는 사람들에게 이상적입니다. Google 어시스턴트와 Amazon Alexa를 통한 음성 제어를 통해, 이 선풍기는 외부 열에 관계없이 완벽한 실내 온도를 유지할 수 있습니다. 우아하고 미니멀한 디자인은 어떤 인테리어에도 완벽하게 어울리며, 고품질의 구성 재료는 내구성을 보장합니다. 덥고 습한 날에 당신의 동료인 Mi Smart Standing Fan Pro로 효율적인 냉각과 편안함을 경험해보세요.\n\n![이미지](/assets/img/2024-06-19-Xiaomifanscheckthebestmodels_3.png)\n\n## Xiaomi Smart Standing Fan 2 Pro\n\n<div class=\"content-ad\"></div>\n\n샤오미 스마트 스탠딩 팬 2 Pro의 탁월한 성능과 지능적인 기능을 발견해보세요. 이 혁신적인 바닥 선풍기는 글로벌 시장에서 인기 있는 제품으로, 24W의 성능과 에너지 효율성으로 높은 평가를 받습니다. 무브러스 모터가 장착되어 조용하고 효율적인 냉각을 제공하여 따뜻한 날에 이상적인 동반자가 됩니다. 스마트폰 앱으로 제어 가능하며 Google 어시스턴트 및 Amazon Alexa와 호환되어 사용자의 선호에 따라 쉽게 작동할 수 있습니다. 또한 140도 회전 기능을 갖추어 넓은 냉각 범위를 제공합니다. 이 모든 것 속에서도 우아하고 미니멀한 디자인은 어떠한 인테리어에도 완벽하게 통합될 수 있습니다.\n\n![샤오미 스마트 스탠딩 팬 2 Pro](/assets/img/2024-06-19-Xiaomifanscheckthebestmodels_4.png)\n\n## 샤오미 스마트 타워 팬\n\n우리 라인업의 마지막 선풍기는 기둥 디자인을 특징으로 하며 터빈을 사용하여 스마트 홈을 최대한 시원하게 유지합니다. 샤오미 스마트 타워 팬의 탁월한 성능과 우아함에 빠져보세요. 이 세련된 지능형 바닥 선풍기는 효율적인 22W 모터로 에너지를 절약하면서 우수한 성능을 제공합니다. 조용하게 작동하여(최대 63dBA) 심야에도 편안하게 사용할 수 있습니다. 유용한 140도 회전 기능으로 방 안의 공기를 고르게 분산시킬 수 있습니다. 샤오미 스마트 타워 팬은 스마트폰 앱을 통해 제어할 수 있고 Google 어시스턴트 및 Amazon Alexa와 호환되어 음성 어시스턴트를 통해 운영을 맞출 수 있습니다. 매력적인 미니멀한 디자인은 선풍기가 주변을 거슬리지 않고 인테리어와 완벽하게 어우러지도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-Xiaomifanscheckthebestmodels_5.png)","ogImage":{"url":"/assets/img/2024-06-19-Xiaomifanscheckthebestmodels_0.png"},"coverImage":"/assets/img/2024-06-19-Xiaomifanscheckthebestmodels_0.png","tag":["Tech"],"readingTime":3},{"title":"Smartmi Air Purifier E1 레뷰  MacSources","description":"","date":"2024-06-19 17:03","slug":"2024-06-19-SmartmiAirPurifierE1REVIEWMacSources","content":"\n\n# E1 에어청정기를 사용하여 작업 공간을 더 생산적으로 만드세요.\n\n![E1 에어청정기](/assets/img/2024-06-19-SmartmiAirPurifierE1REVIEWMacSources_0.png)\n\n작년 여름, 우리는 가족에 4개월 된 Fennec이라는 요키를 추가하기로 결심했습니다. 작은 강아지는 자제력이 부족할 수밖에 없으므로 집에 데려왔을 때 3~4파운드 나가구라는 염소우리는 정말 예상치 못한 일입니다. 필요없이, 화장실 훈련하는 일이 어려웠습니다. 작은 개들은 작은 방광을 가지고 있어 필시 지속적인 관찰과 빈번한 밖으로의 기회가 필요합니다.\n\n그의 습관과 신호를 배우는 데 시간이 걸렸기 때문에 제 사무실에서 일부 사고가 발생했습니다. Fennec과 5살인 형제인 우리의 모크리, 덱스터는 주로 낮에 제 집 사무실에서 시간을 보냅니다. 그래서 이 공간은 '개' 냄새가 납니다. 더러운 담요, 침구, 카펫에 사고 등의 원인 문제를 잘 처리하고 있습니다만, 여전히 공기에서 상쾌하지 못한 냄새가 납니다. 공간이 작고, 우리는 공기청정기를 추가하여 공기를 깨끗하게 만들기로 결정했습니다. Smartmi Air Purifier E1이 완벽한 선택이었습니다.\n\n<div class=\"content-ad\"></div>\n\n![Smartmi Air Purifier E1](/assets/img/2024-06-19-SmartmiAirPurifierE1REVIEWMacSources_1.png)\n\n# Smartmi Air Purifier E1 소개\n\n스마트미 공기 청정기 E1은 실내 공기 질을 개선하기 위해 설계된 소형 공기 청정기입니다. 세련된 미니멀 디자인을 갖춘 E1은 진행된 필터 시스템을 특징으로 하여 먼지, 화분, 연기, 애완동물 털 등을 효과적으로 제거합니다. 조용히 작동하여 침실, 사무실 또는 거실에서 사용하기에 적합합니다.\n\n이 청정기는 스마트 연결성을 제공하여 사용자가 스마트미 앱, Apple Home, Google Home 또는 Alexa를 통해 공기 질을 제어하고 모니터링할 수 있습니다. 절전 성능과 직관적인 제어를 통해, 스마트미 공기 청정기 E1은 건강하고 편안한 실내 환경을 유지하기에 이상적인 선택입니다.\n\n<div class=\"content-ad\"></div>\n\n# 주요 기능\n\n- 유연한 배치 - 바닥 거치대 또는 벽부착 가능\n- 다양한 필터\n- 150m3/h PCADR, 입자 효율적 여과\n- 꽃가루, 애완동물 비듬, 집진이, 연기 등 다양한 종류의 공기 오염물질 제거\n- 대장균 제거율 시간당 97.86%\n- 최대 소리 레벨 42.9dB, 가벼운 소리로 방해되지 않음\n- Homekit 앱 / WiFi 스마트 컨트롤\n- 추천 공간 크기: 194 sqft (약 14ft x 14ft)\n- 크기: 313.2 × 415.2 × 118.2 mm\n- 중량: 약 2.8 kg\n- 소음 레벨: ≤ 54 dB(A)\n- 평가 전력: 19W\n\n![이미지](/assets/img/2024-06-19-SmartmiAirPurifierE1REVIEWMacSources_2.png)\n\n# 가격 및 입수량\n\n<div class=\"content-ad\"></div>\n\n# 사용자 경험\n\n![이미지](/assets/img/2024-06-19-SmartmiAirPurifierE1REVIEWMacSources_3.png)\n\n제가 상자를 개봉하고 설정하는 과정이 직관적이고 실제로 매우 쉽다는 것에 기쁨을 느꼈습니다. 공기 청정기는 이미 조립된 상태였고, 단위에서 일부 포장재 및 테이프를 제거하는 것을 제외하고는 상자에서 바로 시작할 수 있었습니다. 공기 청정기는 바닥에 놓여져 있도록 하는 금속 스탠드와 함께 제공되었지만, Smartmi는 사용자가 필요하다면 벽걸이 방식을 사용할 수 있도록 설치 하드웨어와 설명서를 추가로 제공했습니다. 저는 필요에 따라 방에서 방으로 움직일 수 있도록 벽에 부착하지 않고 그대로 두기로 선택했습니다.\n\n<div class=\"content-ad\"></div>\n\nSmartmi Air Purifier E1의 더 독특한 기능 중 하나는 장식용 필터를 가지고 있다는 것입니다. 공기청정기와 함께 제공되는 필터는 모든 인테리어와 잘 어울리는 중립적인 회색 원단으로 되어 있습니다. 그러나 추가로 세 가지 필터 스타일을 사용하여 원래 필터를 교체할 수 있습니다. 필터를 교체하는 것은 매우 쉬운데, 그냥 유닛의 앞쪽을 당기면 되고 새 필터를 그 자리에 넣으면 됩니다.\n\n![Smartmi Air Purifier E1](/assets/img/2024-06-19-SmartmiAirPurifierE1REVIEWMacSources_4.png)\n\n원래 필터 외에도 늘어지는 고양이가 그려진 필터(Noir)를 사용하고 있습니다. 이 필터에는 주로 주황색과 검정색이 많이 들어가 있어 가을에 사용할 것 같습니다. 다른 디자인 옵션인 살모앤과 마린도 계절 스타일과 잘 어울릴 것 같습니다. 이런 종류의 기능을 가지고 있는 것은 독특하며, 특히 이 장치의 목적 중 하나가 주거 공간에 매끄럽게 통합시키는 것이라고 생각되어 매력적으로 보입니다.\n\n설명서에는 바닥 스탠드를 사용하는 것을 전제로 공기청정기 주변에 20cm의 반경을 제공하도록 안내하고 있습니다. 이렇게 하면 공기청정기의 공기 흡입구와 다른 물체 사이의 거리가 최적의 성능을 위해 충분한 것입니다. 공간을 선택한 후에는 유닛을 전원에 연결하고 켜면 됩니다.\n\n<div class=\"content-ad\"></div>\n\n![2024-06-19-SmartmiAirPurifierE1REVIEWMacSources_5.png](/assets/img/2024-06-19-SmartmiAirPurifierE1REVIEWMacSources_5.png)\n\n앱을 통해 장치를 제어할 수 있지만, 장치 자체의 버튼을 사용하여 켜고 전원을 설정할 수도 있습니다. 공기 청정기를 제어하거나 감시하는 데 스마트 앱을 사용하는 것이 가장 좋지만, 없어도 충분히 작동할 수 있습니다. 공기 청정기에 스마트 어시스턴트를 설정하려면 장치가 Wi-Fi 페어링 모드에 있는지 확인해야 합니다. 먼저 Smartmi 앱을 사용하여 공기 청정기를 설정하고 스마트 어시스턴트를 추가해야 합니다. 저는 HomeKit에 추가하기로 결정했습니다. HomeKit 코드를 입력하자마자 공기 청정기가 감지되어 문제없이 연결되었습니다.\n\nE1의 작동 방식의 간결함을 사랑하지만 좀 더 고급 기능이 있다면 더 좋을 것 같습니다. 다른 공기 청정기 중 하나는 공기 질이 떨어진 것을 감지하면 자동으로 작동하는 자동 모드가 있습니다. 이 유닛에 통합하기에 아주 좋은 기능이라고 생각하며, 공간의 원활한 부분으로 디자인되었기 때문입니다. 물론 하루 중 다른 시간에 켜고 끄도록 설정할 수 있지만, 자동 모드가 있으면 정말 훌륭할 것입니다.\n\n![2024-06-19-SmartmiAirPurifierE1REVIEWMacSources_6.png](/assets/img/2024-06-19-SmartmiAirPurifierE1REVIEWMacSources_6.png)\n\n<div class=\"content-ad\"></div>\n\n이 공기 청정기를 더 좋게 만들어 줄 또 다른 기능은 공기 질을 실시간으로 모니터링하는 기능일 것입니다. 현재는 총 공기질 지표가 있지만 E1이 어떤 것을 걸러내는지 알 수 있는 표시가 있다면 좋겠어요. 설명서에는 공기 청정기가 있는 방의 문과 창문을 닫아 두는 것이 가장 좋다고 나와 있습니다. 이렇게 하면 공기를 더 잘하고 효율적으로 청소할 수 있고, 오피스 공간에서 E1을 사용하면 공기의 냄새와 느낌에 엄청난 차이를 느낄 수 있었어요. 하지만 오피스의 공기에 공기 청정기가 미치는 영향을 정확히 보고 싶어요.\n\n우리 오피스 문 바로 밖에 Ecobee 스마트 서모스탯이 있어서 그것도 공기 질을 감지하는 데 도움이 됩니다. 그 앱에 따르면 낮은 VOC 수준과 공기의 깨끗함을 표시합니다. Smartmi 앱에서는 공기질이 '훌륭하다'만을 표시합니다. E1은 앱으로 AQI 번호를 제공하지 않기 때문에 나오지 않습니다.\n\nE1 공기청정기는 매우 조용합니다. 일반적으로 낮에는 레벨 2로 운전하는데 소리는 들리지만 그냥 선풍기 소리 같아요. 주변의 주변 소음과 어우러져 소음이 뭉개져 들리는 정도죠. 배경에서 부르르 소리를 내며 대부분의 시간에는 전혀 몰랐어요.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n스마트미 에어 퓨라이저 E1은 제 집 사무실에 완벽한 추가품이라고 생각해요. 조용하고 사용하기 전과 후의 공기 질 사이에 뚜렷한 차이를 느꼈어요. 더 상쾌한 분위기가 편안하게 느껴지고 이로 인해 우리 모두에게 더 건강한 공기가 되었다는 걸 알아요. 매일 사용함으로써 알레르기원과 오염물질을 줄이는 데 효과적임을 입증했고, 편안한 생활 및 작업 공간에 기여했습니다.\n\n더 많은 정보는 smartmi.io에서 확인해주세요.\n\n원문은 2024년 6월 14일에 https://macsources.com에서 게재되었습니다.","ogImage":{"url":"/assets/img/2024-06-19-SmartmiAirPurifierE1REVIEWMacSources_0.png"},"coverImage":"/assets/img/2024-06-19-SmartmiAirPurifierE1REVIEWMacSources_0.png","tag":["Tech"],"readingTime":5},{"title":"리즈 SDK를 활용한 스마트 홈 설정 도우미 구축","description":"","date":"2024-06-19 17:01","slug":"2024-06-19-BuildingaSmartHomeSetupAssistantusingLyzrSDK","content":"\n\n가정 자동화의 미래에 오신 것을 환영합니다! 최첨단 AI 기술과 실용적인 가정 기술이 교차하는 곳에서 저희 Smart Home Setup Assistant가 여러분이 스마트 디바이스를 가정에 통합하는 방식을 혁신하려고 합니다. 기술 애호가든 스마트 홈 세계에 처음 발을 딛은 분이든, 우리 어시스턴트는 여러분의 경험을 쉽고, 원활하고, 즐겁게 만들도록 설계되었습니다.\n\n![이미지](/assets/img/2024-06-19-BuildingaSmartHomeSetupAssistantusingLyzrSDK_0.png)\n\nSmart Home Setup Assistant는 AI 기술을 활용한 도구로, 여러분이 스마트 홈 디바이스의 설정, 통합, 자동화를 안내받을 수 있습니다. OpenAI의 GPT-4와 같은 고급 AI 모델의 힘을 활용하여, 당신의 특정한 요구에 맞게 맞춤형 단계별 설명을 제공하여 가정의 모든 디바이스가 조화롭게 함께 작동하도록 보장합니다.\n\nLyzr SDK를 사용하는 이유는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nLyzr.ai SDK를 사용하면 자체 GenAI 어플리케이션을 만드는 것이 매우 간단합니다. 빠르게 설정하고 실행하기 위해 몇 줄의 코드만 필요합니다.\n\nLyzr SDK를 확인해보세요.\n\n디바이스 식별: 집을 변신시키는 첫 번째 단계는 설정하려는 스마트 디바이스를 식별하는 것입니다. 스마트 조명, 온도 조절기, 보안 카메라 또는 음성 어시스턴트이든 상관없이, 저희 어시스턴트가 모두 처리해 드릴 수 있습니다.\n\n```python\ninput = st.text_input(\"걱정사항을 입력해주세요:\", placeholder=\"여기에 입력하세요\")\n```\n\n<div class=\"content-ad\"></div>\n\n이 코드 조각은 스마트홈 기기나 특정 걱정 사항을 나열할 수 있는 텍스트 입력 필드를 생성합니다. 이 입력을 기반으로 어시스턴트가 당신의 요구에 맞게 자문을 제공할 것입니다.\n\n원활한 연결: 당신의 기기를 집의 Wi-Fi 네트워크나 필요한 허브에 연결하는 것은 당사 어시스턴트와 매우 쉽습니다. 각 단계를 안내해 원활하고 안정적인 연결을 보장합니다.\n\n자동화 루틴 만들기: 기본 자동화 루틴을 설정하여 스마트홈 경험을 향상시키세요. 아침 깨워주는 루틴이든 아무도 집에 없을 때 에너지를 절약하는 설정이든, 우리 어시스턴트가 당신의 라이프스타일에 맞는 루틴을 만드는 데 도움을 줍니다.\n\n```js\nopen_ai_text_completion_model = OpenAIModel(\n    api_key=st.secrets[\"apikey\"],\n    parameters={\n        \"model\": \"gpt-4-turbo-preview\",\n        \"temperature\": 0.2,\n        \"max_tokens\": 1500,\n    },\n)\n```\n\n<div class=\"content-ad\"></div>\n\n이 스니펫은 OpenAI 모델을 구성하는 부분인데, 이 모델은 어시스턴트를 구동합니다. 온도와 최대 토큰과 같은 매개변수를 지정하여, 어시스턴트가 일관되고 간결한 응답을 제공할 수 있도록 설정하고 있어요.\n\n우리 어시스턴트는 스마트 홈이 안전하고 데이터가 보호받는지 확인하도록 조언과 최상의 실천 방법을 제공합니다.\n\n```js\ndef generation(input):\n    generator_agent = Agent(\n        role=\"전문가 스마트 홈 설치 어시스턴트\",\n        prompt_persona=\"사용자가 특정 기기의 설치, 자동화 루틴 생성, 이러한 기기를 원활하게 통합하는 과정을 안내하는 것이 당신의 임무입니다.\")\n    prompt = \"\"\"\n    당신은 전문가 스마트 홈 설치 어시스턴트입니다. 사용자가 특정 기기의 설치, 자동화 루틴 생성 및 이러한 기기를 완벽하게 통합하는 과정을 안내하는 것이 당신의 임무입니다.\n[여기에 프롬프트를 추가해주세요]\n\"\"\"\n        name=\"Generation\",\n        model=open_ai_text_completion_model,\n        agent=generator_agent,\n        instructions=prompt,\n        default_input=input,\n        output_type=OutputType.TEXT,\n        input_type=InputType.TEXT,\n    ).execute()\n  return generator_agent_task\n```\n\n이 함수는 사용자가 제공한 입력을 기반으로 어시스턴트의 응답을 생성합니다. 특정 역할과 페르소나로 에이전트를 설정하고, 응답 생성 프로세스를 안내하기 위해 자세한 프롬프트를 작성합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nif st.button(\"도와주세요!\"):\n    solution = generation(input)\n    st.markdown(solution)\n```\n\n이 코드 조각은 \"도와주세요!\" 버튼이 클릭될 때의 동작을 정의합니다. 사용자 입력과 함께 generation 함수를 호출하고 생성된 솔루션을 표시합니다.\n\n스마트 홈으로 변신하는 것이 이제 더 쉽습니다. 저희의 스마트 홈 설정 도우미는 고급 AI와 사용자 친화적인 가이드를 결합하여 원활하고 효율적인 설정 과정을 보장합니다. 일상적인 루틴 자동화, 보안 강화 또는 스마트 디바이스의 편의성을 즐기려는 경우, 저희 도우미가 도와드릴 준비가 되어 있습니다.\n\n앱 링크: https://smarthomeassistant-lyzr.streamlit.app/\n\n\n<div class=\"content-ad\"></div>\n\n소스 코드: https://github.com/isakshay007/Smart_Home_Assistant\n\n스마트 홈 설정 도우미는 Lyzr Automata Agent에 의해 제공되며, OpenAI의 GPT-4 Turbo 기술을 활용하고 있습니다. 문의 사항이나 문제가 있을 경우 Lyzr에 문의해주시기 바랍니다. Lyzr 및 그들의 제품에 대해 더 알아보려면 다음 링크를 통해 확인하실 수 있습니다:\n\n- 웹 사이트: Lyzr.ai\n- 데모 예약: 데모 예약\n- 디스코드: Discord 커뮤니티에 가입하기\n- 슬랙: Slack 채널에 가입하기","ogImage":{"url":"/assets/img/2024-06-19-BuildingaSmartHomeSetupAssistantusingLyzrSDK_0.png"},"coverImage":"/assets/img/2024-06-19-BuildingaSmartHomeSetupAssistantusingLyzrSDK_0.png","tag":["Tech"],"readingTime":4},{"title":"휴대용 에어컨 냉방이 되지 않을 때 어떻게 고칠까요 5가지 해결책","description":"","date":"2024-06-19 16:59","slug":"2024-06-19-HowtoFixaPortableAirConditionerThatsNotCooling5Solutions","content":"\n\n![Portable Air Conditioner](/assets/img/2024-06-19-HowtoFixaPortableAirConditionerThatsNotCooling5Solutions_0.png)\n\n안녕하세요\n\n휴대용 에어컨은 여름에 집을 시원하게 유지하는 인기 있는 방법입니다. 그러나 다른 가전제품들과 마찬가지로 고장 날 수도 있습니다. 휴대용 에어컨이 정상적으로 냉방되지 않는 일반적인 문제가 발생할 수 있습니다.\n\n이 기사에서는 휴대용 에어컨이 왜 제대로 냉방되지 않을 수 있는지와 문제를 해결하는 방법에 대해 알아보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n휴대용 에어컨이 왜 냉방이 안될까요?\n\n휴대용 에어컨이 적절히 냉각되지 않을 수 있는 이유는 여러 가지가 있습니다. 가장 흔한 몇 가지 원인은 다음과 같습니다:\n\n- 기기가 깨끗하지 않거나 필터가 더러운 경우입니다. 휴대용 에어컨이 제대로 냉각되지 않는 가장 흔한 이유 중 하나입니다. 휴대용 에어컨의 필터는 공기 중의 먼지와 오염물질을 제거하여 기기가 효과적으로 냉각되는 것을 돕습니다. 필터가 더러우면 깨끗이 청소하거나 교체해야 합니다.\n- 응축 팬이 가득 찬 경우입니다. 휴대용 에어컨의 응축 팬은 공기 중에서 응축된 물을 수집합니다. 응축 팬이 가득 차 있는 경우 제대로 냉각되지 않을 수 있습니다. 정기적으로 응축 팬을 비워야 합니다.\n- 기기가 과부하 상태에 있는 경우입니다. 휴대용 에어컨은 특정 크기의 방을 냉각하기 위해 설계되었습니다. 기기를 과부하시키면 제대로 냉각되지 않을 수 있습니다.\n- 적절한 환기가 이루어지지 않는 곳에 기기가 위치한 경우입니다. 휴대용 에어컨은 제대로 작동하기 위해 적절하게 환기되어야 합니다. 기기가 좁거나 밀폐된 공간에 위치하면 효과적으로 냉각되지 않을 수 있습니다.\n- 온도 조절기가 너무 높게 설정된 경우입니다. 휴대용 에어컨의 온도 조절기가 너무 높게 설정되어 있는 경우 기기가 제대로 냉각되지 않을 수 있습니다. 온도 조절기를 편안한 온도로 설정해야 합니다.\n- 기기가 제대로 작동하지 않는 경우입니다. 만약 위의 모든 조치를 취했음에도 휴대용 에어컨이 여전히 제대로 냉각되지 않는다면, 즉시 자격 있는 기술자에게 문제를 진단해 달라고 요청해야 합니다.\n\n휴대용 에어컨이 냉각되지 않는 문제를 해결하는 방법\n\n<div class=\"content-ad\"></div>\n\n휴대용 에어컨이 제대로 냉방되지 않는다면 문제를 해결할 수 있는 몇 가지 방법이 있습니다:\n\n- 필터를 확인하고 깨끗한지 확인하세요.\n\n휴대용 에어컨이 제대로 냉방되지 않을 때 먼저 확인해야 할 것입니다. 휴대용 에어컨의 필터는 공기 중의 먼지와 더러움을 제거하는 데 도움을 주어 유닛이 효과적으로 냉방되는 것을 방지합니다. 필터가 더러우면 청소하거나 교체해야 합니다.\n\n- 응축수 팬을 비워주세요.\n\n<div class=\"content-ad\"></div>\n\n휴대용 에어컨의 응축판은 공기에서 응축된 물을 수거합니다. 응축판이 가득 차면 유닛이 제대로 냉각되지 않을 수 있습니다. 정기적으로 응축판을 비워주세요.\n\n- 온도 조절기를 낮은 온도로 설정해주세요.\n\n휴대용 에어컨의 온도 조절기가 너무 높게 설정되어 있으면, 유닛이 올바르게 냉각되지 않을 수 있습니다. 온도 조절기를 편안한 온도로 설정했는지 확인해주세요.\n\n- 코일을 청소해주세요.\n\n<div class=\"content-ad\"></div>\n\n휴대용 에어컨의 코일은 공기에서 열을 외부로 전달하는 데 도움을 줍니다. 코일이 더러우면 열을 효과적으로 전달할 수 없어 유닛이 제대로 냉각되지 않을 수 있습니다. 코일은 약간의 비누와 물로 청소할 수 있어요.\n\n- 자격 있는 기사에게 전화하세요.\n\n위의 모든 방법을 시도해 봤지만 휴대용 에어컨이 여전히 제대로 냉각되지 않는다면 문제를 진단할 자격 있는 기사에게 전화하는 것이 좋습니다.\n\n휴대용 에어컨 문제 예방하기\n\n<div class=\"content-ad\"></div>\n\n휴대용 에어컨의 문제를 미연에 예방하는 가장 좋은 방법은 깨끗하고 잘 유지하는 것입니다. 다음은 휴대용 에어컨을 좋은 상태로 유지하는 데 도움이 되는 몇 가지 팁입니다:\n\n- 정기적으로 필터 청소하기. 휴대용 에어컨의 필터는 매달 또는 두 달에 한 번 정도 청소해야 합니다.\n- 응축판 정기적으로 배수하기. 휴대용 에어컨의 응축판은 매일 또는 이틀에 한 번씩 배수해야 합니다.\n- 편안한 온도로 온도 조절기 설정하기. 온도 조절기를 너무 높게 설정하면 유닛에 불필요한 부담을 줄 수 있고 문제를 초래할 수 있습니다.\n- 잘 통풍되는 곳에 유닛 배치하기. 휴대용 에어컨은 제대로 작동하기 위해 잘 통풍되는 곳에 있어야 합니다.\n- 유닛을 정기적으로 점검하기. 매년 자격있는 기술자에게 휴대용 에어컨을 점검해 주는 것이 좋습니다.\n\n이러한 팁을 따르면 휴대용 에어컨을 좋은 상태로 유지하고 문제를 예방할 수 있습니다.\n\n마무리\n\n<div class=\"content-ad\"></div>\n\n결론적으로, \"휴대용 에어컨이 냉방을 하지 않는 이유\"를 이해하는 것은 더운 날씨에 편안한 실내 환경을 유지하는 데 중요합니다. 냉방 문제의 근본적인 원인을 이해함으로써 불필요한 답답함을 피하고 수리 및 유지에 관해 정보를 얻을 수 있습니다. 냉방이 되지 않는 것은 온도 설정 오류, 적절하지 않은 배치, 또는 더러운 필터와 같이 간단한 문제에서 비롯될 수 있습니다. 이러한 문제들은 전문가의 도움 없이 해결할 수 있는 경우도 많습니다.\n\nFAQs:\n\n휴대용 에어컨을 냉기가 더 나오도록 하는 방법은 무엇인가요?\n\n휴대용 에어컨이 냉기를 더 내도록 하는 몇 가지 방법이 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 유닛이 깨끗하고 이물질이 없는지 확인하세요.\n- 정기적으로 필터를 교체하세요.\n- 결로 팬을 정기적으로 비워 주세요.\n- 유닛을 과다하게 사용하지 마세요.\n- 잘 환기되는 공간에서 유닛을 사용하세요.\n- 열린 문이나 창문을 닫으세요.\n- 바람 통로를 방 안의 가장 따뜻한 지역 쪽으로 돌리세요.\n- 선풍기 속도를 높이세요.\n- 온도 조절기를 낮은 온도로 설정하세요.\n\n휴대용 에어컨이 왜 따뜻한 공기를 내뿜을까요?\n\n휴대용 에어컨이 따뜻한 공기를 내뿜을 수 있는 몇 가지 이유가 있습니다:\n\n- 유닛이 깨끗하지 않거나 필터가 더러운 경우.\n- 결로 팬이 가득 찬 경우.\n- 유닛이 과부하인 경우.\n- 유닛이 잘 환기되지 않은 공간에 있는 경우.\n- 온도 조절기가 너무 높게 설정된 경우.\n- 유닛이 제대로 작동하지 않는 경우.\n\n<div class=\"content-ad\"></div>\n\n휴대용 에어컨이 왜 뜨거운 공기를 내뿜는지 확신이 안 서신다면, 문제를 진단해 줄 자격 있는 기사를 호출하는 것이 가장 좋습니다.\n\n휴대용 에어컨을 하루 종일 켜 두는 것이 더 낫다고 생각하시나요?\n\n휴대용 에어컨을 항상 켜 둘 필요는 없을 수도 있습니다. 실제로, 집에 없을 때나 방이 너무 더울 때에는 꺼 둔 쪽이 더 효율적일 수 있습니다.\n\n만약 하루 종일 휴대용 에어컨을 켜 두신다면, 온도를 편안한 수준으로 설정하고 필터를 규칙적으로 청소해 주십시오.\n\n<div class=\"content-ad\"></div>\n\n에어컨이 차가운 바람을 내뿜지 않는다면, 몇 가지 해결 방법이 있습니다:\n\n- 필터를 확인하고 깨끗한지 확인합니다.\n- 응축 수뇌를 배출합니다.\n- 온도를 낮춘 상태에서 써모스탯을 설정합니다.\n- 코일을 청소합니다.\n- 문제를 진단할 자격을 갖춘 기술자에게 전화합니다.\n\n결론적으로\n\n<div class=\"content-ad\"></div>\n\n이 블로그 포스트의 팁을 따라서 이동식 에어컨의 문제를 해결하고 제대로 냉각되도록 할 수 있어요. 만약 스스로 문제를 해결할 수 없다면 언제든지 자격을 갖춘 기술자에게 도움을 요청할 수 있어요.\n\n여기 몇 가지 추가 팁이 있어요. 자동으로 에어컨을 유지하고 제대로 냉각되지 않게 방지하는 데 도움이 될 거예요:\n\n- 필터를 정기적으로 청소하세요: 매달 필터를 청소하여 공기 흐름이 제한되지 않도록 해야 해요. 청소기나 브러시를 사용하여 필터를 청소할 수 있어요.\n- 매년 냉매 레벨을 확인하세요: 자격을 갖춘 기술자가 냉매 레벨을 확인하고 필요하면 추가 냉매를 넣어줄 수 있어요.\n- 손상된 온도 조절기를 교체하세요: 고장난 온도 조절기는 에어컨이 자주 켜지고 꺼지게 만들어 냉각이 제대로 이루어지지 않을 수 있어요.\n- 매월 응축수 배수구를 청소하세요: 응축수 배수구는 에어컨에서 물을 멀리 보내는 호스예요. 배수구가 막히면 물이 백업되어 에어컨이 제대로 냉각되지 않을 수 있어요. 와이어 옷걸이나 브러시로 응축수 배수구를 청소할 수 있어요.\n- 에어컨을 정기적으로 서비스 받으세요: 자격을 갖춘 기술자가 에어컨을 점검하여 필요한 수리를 할 수 있어요.\n\n이러한 팁을 따르면 이동식 에어컨이 원할하게 작동하고 제대로 냉각되지 않도록 방지할 수 있어요.","ogImage":{"url":"/assets/img/2024-06-19-HowtoFixaPortableAirConditionerThatsNotCooling5Solutions_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoFixaPortableAirConditionerThatsNotCooling5Solutions_0.png","tag":["Tech"],"readingTime":5},{"title":"스마트 홈이 부동산을 형성하는 방법","description":"","date":"2024-06-19 16:57","slug":"2024-06-19-HowSmartHomesAreShapingRealEstate","content":"\n\n![How Smart Homes Are Shaping Real Estate](/assets/img/2024-06-19-HowSmartHomesAreShapingRealEstate_0.png)\n\n옛날에는 부동산 시장이 특정 위치에있는 특정 조각의 땅을 소유하는 것에만 관한 것이었습니다. 그러나 지금은 이 정의가 재정립되었습니다. 이제는 소유지 내에서 무엇을 할 수 있는지가 가장 중요합니다. 스마트 홈의 편리함이 부동산에 많은 영향을 미쳤습니다. 최신 기술 통합이 어떻게 부동산 시장을 재편형화했는지 자세히 살펴봅시다.\n\n# 스마트 홈 기술의 진화\n\n먼저, 이 홈 자동화 기술에 대해 설명하겠습니다. 이 기술을 사용하면 가정용 가전제품을 중앙 네트워크를 통해 액세스하고 제어할 수 있습니다. 이 연결을 가능하게 하려면 안정적인 인터넷 연결이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n모두가 과학 소설 영화에서 원격으로 제어되는 집의 개념을 보았을 것입니다. 정말 흥미롭지 않나요? 솔직히 말해서, 이 스마트 기술이 제공하는 편리함에 놀라고 있어요. 기술은 날이 갈수록 발전하고 있어요.\n\n몇 년 전에 스마트 홈의 개념이 소개되었죠. 처음에는 음성 명령을 통해 스마트폰을 작동하기 위해 이 개념이 도입되었어요. 나중에, 이 개념이 확장되어 가전제품을 제어할 수 있게 되었죠.\n\n이 기술이 처음 소개될 때는 아무도 이 기술이 많은 시장에서 엄청난 이해 관계자가 될 것이라는 생각을 하지 못했어요. 오늘은 이 기술이 부동산 시장에 미치는 영향에 대해 이야기해볼 거예요.\n\n# 부동산 시장에서 스마트 홈의 혜택\n\n<div class=\"content-ad\"></div>\n\n모든 사람들이 편안함을 좋아합니다. 전문가들은 매일의 고난을 줄이고 편안함을 극대화하기 위해 노력하고 있습니다. 이와 관련하여, 스마트 홈은 상당한 발전을 이뤘습니다. 그러므로, 이러한 하이테크 홈의 일부 이점을 살펴보겠습니다.\n\n✅ 에너지 효율성\n\n정확하게 프로그래밍된 온도 조절기는 집의 온도를 적절히 조절하여 공과금을 줄이는 데 많은 도움이 됩니다. 또한 최적화된 조명 조건은 탄소 배출량을 줄이는 데 중요한 역할을 합니다. 이러한 에너지 절약 조치들은 부동산 가치를 고려할 가치가 있는 기술로 만들었습니다.\n\n✅ 원격 관리\n\n<div class=\"content-ad\"></div>\n\n이 기술의 가장 큰 장점은 집 안의 일부를 원격으로 관리할 수 있는 능력입니다. 조명을 켜고 끄거나 문을 잠그고 풀거나 특정 활동을 수행하는 등 집에 없어도 가능합니다.\n\n✅ 향상된 보안\n\n사람들은 가족을 최우선으로 지키고 싶어 합니다. 고급 보안 카메라에 의한 정교한 보안 감시는 이러한 특별한 욕망을 충족할 수 있습니다. 스마트 감시 시스템을 사용해 집 바깥에서도 접근할 수 있는 경우 사람들은 이에 더 많은 비용을 지불할 의향이 있습니다. 게다가 스마트 연기 경보기와 일산화탄소 감지기를 사용하여 잠재적인 위험 상황에 즉각 대응할 수 있습니다.\n\n# 부동산 가치에 미치는 영향\n\n<div class=\"content-ad\"></div>\n\n의심의 여지 없이, 자동화 기능이 있는 집들은 보통 집들에 비해 우위를 가지고 있어요. 자동화는 부동산 가치를 결정하는 데에 케이크에 올린 아이싱처럼 작용해요. 스마트 홈이 부동산 가치에 미치는 중요한 영향 몇 가지를 살펴보도록 하죠.\n\n✅ 재판매 매력\n\n한 가지 말해 봐요, 부동산 시장에서 집의 재판매 가치를 어떻게 계산할 수 있을까요? 당연히, 그 집이 제공하는 편의시설을 고려해서요. 여기서 최고의 부분이 등장해요. 인공지능 시대에 누군가가 “내 집은 AI로 구동돼”라는 발언을 했다고 상상해보세요. 이 때 재판매 가치를 결정하는 대화는 다르게 진행되었을까요 아니면 그렇지 않을까요?\n\n분명히, 결정된 재판매 가치는 보통 집의 재판매 가치에 비해 더 높을 거에요. 무엇이 그 차이를 만들었을까요? \"스마트 기술\"이죠. 그러므로, 스마트 홈은 일반 집에 비해 높은 임대료와 재판매 가치를 가져다줄 수 있다는 것이 입증되었어요.\n\n<div class=\"content-ad\"></div>\n\n✅ 가치 유지\n\n스마트 가전 제품을 설치하는 형태로 추가된 가치는 부동산의 가치 유지율에 긍정적인 영향을 미칠 것입니다. 이 기술은 투자한 돈의 가치가 있다고 할 수 있습니다.\n\n급속한 기술 발전은 스마트 홈 기술을 항상 핫한 주제로 유지할 것입니다. 사람들은 이 기술을 기꺼이 받아들이고 있습니다. 따라서 스마트 홈의 가치 유지율은 항상 전통적인 주택보다 높을 것입니다.\n\n✅ 재판매 시기\n\n<div class=\"content-ad\"></div>\n\n부동산 분야에서는 자신의 재산이 좋은 가격에 팔리는 것을 보려면 많은 인내심이 필요합니다. 그러나 스마트 홈은 이 관행을 깨버렸어요. 사전 통합된 스마트 홈 가전제품을 갖춘 주택은 분명히 구매자로 하여금 “바로 그것이 내가 찾던 것이다!”라고 말하게 할 것입니다!\n\n✅ 평가 관행\n\n과거에는 부동산 감정사들이 위치와 면적을 고려하여 집에 대한 아이디어를 제시했습니다. 그 제안된 평가는 부동산의 실제 가치를 정확하게 반영하지 않았습니다. 스마트 홈은 그러한 평가 방법에 도전했습니다. 이제 당신의 재산은 그렇게 쉽게 저평가될 수 없어요.\n\n✅ 투자 잠재력\n\n<div class=\"content-ad\"></div>\n\n사람들은 이 기술을 열정적으로 받아들이고 있어요. 따라서, 스마트 가전제품을 설치하는 데 투자하는 것은 상호 유익한 상황이 될 것입니다. 이 기술은 장기간 relevant할 것으로 예상됩니다. 그러므로, 이에 대한 투자는 장기적으로 이득을 얻을 수 있을 것입니다.\n\n# 구매자의 선호도와 시장 동향\n\n최근에는 부동산 구매자들이 매우 요구적으로 변하고 있어요. 그들은 집에 대한 이상적인 선호도를 가지고 있어요. 그들은 자신들의 요구사항이 조금 높은 비용이 든다고 하더라도 상관하지 않아요. 더 높은 가격을 지불할 의사까지 있습니다. 이제 어떤 선호도가 있는지 살펴봅시다.\n\n✅ 보안\n\n<div class=\"content-ad\"></div>\n\n사람들은 자신의 소중한 물건과 사랑하는 사람들에 대해 매우 주의를 기울입니다. 그들은 집에서 일어나는 모든 일에 주의를 기울고 싶어합니다. 무언가 나쁜 일이 발생하면 적절한 조치를 취할 수 있는 전용 보안 시스템을 원합니다.\n\n✅ 건강\n\n일산화탄소 섭취 또는 연기로 인한 질식으로 인한 사망에 대한 뉴스를 읽어 보았을 수 있습니다. 사람들은 누출 사항에 대해 제때 알림을 받을 수 있는 스마트 감지기를 원합니다.\n\n✅ 홈 자동화\n\n<div class=\"content-ad\"></div>\n\n사람들이 게으르다. 불이 켜지거나 꺼지기 위해 침대나 소파를 떠나고 싶어하지 않는다. 그들은 목소리로 작동하는 시스템을 원한다. 반면에, 가정 자동화는 장애인들에게 은혜가 될 수 있다.\n\n# 도전과 고려사항\n\n자동화 산업에서 상당한 발전을 보았지만, 여전히 큰 개선이 필요하다. 고려해야 할 사생활 및 디지털 보안 문제가 있다. 스마트 가전 제품을 설치하는 비용은 저렴하지 않다.\n\n# 부동산의 미래에서 스마트 홈\n\n<div class=\"content-ad\"></div>\n\n기술이 계속 발전하고 있어요. 미래에는 스마트 홈이 보다 대규모로 수용될 것으로 예상됩니다. 인공지능은 그들을 새로운 수준으로 영향을 줄 것이라고 확신합니다.\n\n시간이 흐름에 따라 스마트 가전제품은 저렴해질 것이며 새로운 기술 발전을 통해 발전할 것입니다. 우리는 건축재료가 친환경적일 가능성이 있고 이는 건설 작업을 더욱 효율적으로 만들 수 있을 것입니다.\n\n굶고 무절제가 약속하는 편안함과 편리함에 주목하면 스마트 홈에 대한 수요가 증가할 것입니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n스마트 홈은 확실히 삶을 구원해주는 것 같아요. 장기 투자 가능성이 있는 것도 사실이에요. 특히 제공하는 편의성은 고려할 가치가 있어요. 몇 가지 매력적인 혜택에 대해 이야기했어요. 그 혜택들은 보통의 주택보다 더 나은 선택임을 분명히 보여줘요.\n\n이 첨단 기술은 부동산의 일부 규범에 대해 대담하게 도전했어요. 스마트 홈은 미래 세대에게도 매력인을 유지할 것 같아요. 그래서 일반 주택을 스마트 홈으로 만드는 투자는 가치 있어요.\n\n끝까지 읽어 주셔서 감사의 말씀을 전하려고요.","ogImage":{"url":"/assets/img/2024-06-19-HowSmartHomesAreShapingRealEstate_0.png"},"coverImage":"/assets/img/2024-06-19-HowSmartHomesAreShapingRealEstate_0.png","tag":["Tech"],"readingTime":5},{"title":"CoAP에 관한 필드 가이드 - 제1부","description":"","date":"2024-06-19 16:55","slug":"2024-06-19-AFieldGuidetoCoAPPart1","content":"\n\nIoT를 시작할 때 알았더라면 좋았을 제한된 응용 프로그램 프로토콜(CoAP)과 관련된 모든 것\n\n![이미지](/assets/img/2024-06-19-AFieldGuidetoCoAPPart1_0.png)\n\n나는 2010년에 IoT 세계로 처음 발을 디뀌었습니다. 전력 소비를 모니터링하고 저전력 네트워크를 통신하는 스마트 콘센트를 만들고 싶은 아이디어가 있었습니다. 문제는 네트워킹, 무선, 실시간 임베디드 시스템, 프로토콜 등에 대해 거의 아무것도 몰랐다는 점이었습니다. 그러나 그 아이디어로 인해 IoT 분야에서의 경력이 시작되었습니다. 저의 야망은 상대적으로 새로운 IoT 기술과 표준을 연구하도록 이끔으로, 저는 저전력 통신과 Sensinode(후에 Arm에 인수)의 작업에 특히 관심이 있었습니다. 그들이 개척한 기술 중 하나가 CoAP이었고, 이 기술은 내 프로젝트에 완벽해 보였습니다.\n\n많은 개발자들은 이 유연한 도구를 잘 모를 수 있습니다. HTTP나 MQTT와 같은 프로토콜에 대해 들어본 적이 있을 수 있지만, CoAP의 인식은 덜 흔한 것 같습니다. 종종 \"왜 CoAP를 사용해야 하는가?\" 또는 \"MQTT 대신 x에 사용하면 안 되는 이유를 설명해줘\"라는 질문을 받곤 합니다. 왜 일부 프로토콜이 다른 것보다 더 알려진지는 잘 모르지만, 이 게시물을 통해 그것을 바로잡는 것이 제 목표 중 하나입니다.\n\n<div class=\"content-ad\"></div>\n\n# CoAP에 대해\n\nCoAP은 제한된 응용 프로그램 프로토콜로 공식적으로 RFC 7252로 알려져있습니다. IETF에서 Constrained Resource Environments (CoRE) Working Group에 의해 개발된 전송 프로토콜입니다. CoAP은 다음 세 가지 목표를 가지고 설계되었습니다:\n\n- 제한된 환경에 적합합니다\n- 이해하기 쉽습니다\n- 구현하기 쉽습니다\n\nRFC 7228에서 \"제한된\"이 더 자세하게 정의되어 있지만 간략하게 언급하면:\n\n<div class=\"content-ad\"></div>\n\n- 제한된 메모리, 저장 공간 및 계산 능력 (100KB & 10MHz)\n- 배터리 전원\n- 낮은 대역폭 (Kbps - 킬로비트/초)\n- 보안은 중요하지만, 이완된 장치에 특화되어 있습니다.\n\n그리고 우리가 보게 될 것처럼, CoAP의 많은 기능들은 이러한 제약 조건을 충족시키기 위해 고의적으로 설계되었습니다.\n\n둘째, RFC 7252는 다이어그램이 포함된 약 100페이지의 짧은 문서로 매우 읽기 쉽습니다. 점심 시간에 한 번 읽을 수 있을 만큼 간단하며 자신의 커피를 다시 타는 시간도 충분히 남을 것입니다.\n\nCoAP의 마지막 목표는 구현하기 쉬움입니다. 디바이스 및 서버를 위한 libcoap 및 californium 라이브러리를 포함하여 사실상 디바이스 및 서버를 위한 참조 구현이 거의 모든 디바이스 및 클라우드 프로그래밍 언어에서 구현되어 있습니다. 그러나 UDP를 사용하고 페이로드 크기를 절약하기 위해 콤팩트한 메시지 형식을 사용하는 등 제한된 환경에서 구현하기 쉽게 설계된 프로토콜 내에 특정 설계 특징이 있습니다. 그러나 이러한 세부 사항은 곧 다룰 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# CoAP 기본 사항\n\nCoAP은 HTTP의 요청/응답, 클라이언트/서버 모델을 따른 것입니다. 이것이 곧 초보자들에게 쉽게 이해할 수 있게 만들어주는 요소 중 하나입니다. 실제로 CoAP는 익숙한 GET, POST, PUT, DELETE 동사를 지원하기 때문에 실제 HTTP와 상호 운용할 때 유용합니다. 이것은 RFC 8075에서 논의된 내용입니다.\n\n사실, RFC 8075를 CoAP의 확장성에 대한 수업 자료로 사용합시다. 저는 CoAP을 단일 \"개체\"로 계속 언급하는데, 사실상 RFC 7252를 기반으로 한 수십 가지의 추가 사양이 있어 CoAP로 수행할 수 있는 작업을 향상시킵니다. 그러나 가장 중요한 점은 이러한 사양이 순수주의적인 관점에서는 모두 선택 사항으로 간주된다는 것입니다. 이것이 그것들의 다이어그램입니다:\n\n앞으로 RFC 7252의 모든 것을 \"기본\"으로 간주하고, 다른 사양의 일부 공통 기능을 \"기본++\"으로 간주하고, 나머지 모든 것을 \"고급\"으로 간주할 것입니다. 걱정하지 마세요 - 우리는 곧 고급 내용에 대해 다뤄볼 것입니다.\n\n<div class=\"content-ad\"></div>\n\n다음은 CoAP 사용자로서 알아야 할 가장 유용한 정보입니다:\n\n## 메시징 모델\n\nCoAP는 더 넓은 인터넷과 HTTP와 같이 클라이언트/서버 메시징 모델을 따릅니다. 이는 센서와 데이터베이스 사이에서 메시지를 주고받는 방법을 이해하기 매우 쉽게 만듭니다. 그러나 우리는 브라우저를 클라이언트로, 클라우드 서버를 서버로 생각하지만, CoAP의 세계에서는 무엇이든 클라이언트, 서버 또는 둘 다가 될 수 있습니다. 이것은 IoT 시스템을 설계할 때 정말 유용할 수 있습니다. 예를 들어, 단일 센서 노드는 클라우드 서버에 데이터를 게시하는 클라이언트일 수 있고, 클라우드는 자는 장치의 상태를 감시하면서 일어날 때 서버 역할을 수행할 수도 있습니다. 심지어 로컬 네트워크까지 확장될 수 있습니다 — 두 장치는 직접 통신하여 클라이언트/서버 쌍으로 작동할 수 있습니다.\n\nCoAP는 다른 클라이언트/서버 모델과 마찬가지로 비동기적이며, IoT 네트워크의 특성으로 인해 그 방향으로 기울어져 있습니다. 장치는 계획된 및 예기치 않은 이유로 오프라인 상태로 전환될 수 있으며, CoAP는 이러한 사항을 Tokens(요청 일치 기능) 및 Message ID(캐싱 및 중복 제거 기능)와 같은 기능을 통해 고려합니다.\n\n<div class=\"content-ad\"></div>\n\nCoAP의 메시징 모델에 대해 이해해야 할 마지막 포인트는 모든 설계 결정이 효율성에 관한 것이라는 점입니다. 효율성은 메시지의 크기, 메시지 전송 빈도와 같은 요소뿐만 아니라 메시지가 사용하는 배터리 양이나 암호화 유형에 대한 연산 비용과 같은 심층 기술적 고려 사항까지 포함됩니다. CoAP이 효율적일 수 있도록 노력하는 몇 가지 예시는 다음과 같습니다:\n\n- 세션의 대역폭 오버헤드를 줄이기 위해 UDP를 기본으로 선택\n- 필드를 짧은 코드로 인코딩하여 크기를 줄이기\n- 핸드셰이크 횟수를 줄이기 위해 확인 메시지를 \"Piggybacking\"\n\nCoAP이 효율적으로 동작하도록 노력하는 다양한 방법이 있습니다. 이에 대한 자세한 내용은 나중 섹션에서 다루겠지만 대부분은 사양서에 상세히 기술되어 있습니다. 다행히도 당신이 프로토콜을 처음부터 구현할 의향이 없다면 이러한 세부 사항을 걱정할 필요가 없습니다.\n\n## 요청/응답 의미론\n\n<div class=\"content-ad\"></div>\n\nCoAP은 HTTP와 많은 의미론적으로 유사한 점들을 공유합니다. 중복해서 언급했듯이 많은 유사한 기능들이 있어요:\n\n- URIs: CoAP 엔드포인트는 HTTP/HTTPS처럼 URI를 통해 주소 지정할 수 있지만 COAP/COAPS 프로토콜과 포트가 분명히 다릅니다. coaps://[URI]:5684 (안전한) 및 coap://[URI]:5683 (보안되지 않은)\n- Methods & Response Codes: CoAP 변형들이 의미하는 대로 동작해요. GET, POST, PUT, DELETE는 주요 동사이고, 2xx-5xx는 응답 코드에 해당합니다.\n- Options: HTTP 헤더와 유사하지만 오버헤드가 낮아요.\n- 콘텐츠 협상: JSON 및 XML과 같은 다양한 IANA 콘텐츠 유형을 지원합니다.\n\n또한, CoAP의 의미론적인 측면 중 HTTP와 정확히 같지 않은 중요한 점이 있어요. 신뢰성은 선택 사항이에요. HTTP의 TCP 기반 전략과 다르게 CoAP은 메시지 크기 및 전체 전력 사용량을 줄이기 위해 구현되어요. CoAP은 신뢰할 수 없는 메시지를 \"NON-confirmable\"라고 부릅니다. 다른 메시지 유형으로는 CONfirmable, ACKnowledge 및 ReSeT 등이 있습니다. 이들은 piggybacking, 핑 감소, 캐싱 등을 효율적으로 처리하기 위해 사용돼요. IP 멀티캐스트는 일반적으로 HTTP에서 사용되지 않지만 CoAP의 핵심 기본 원시자료로, 특정 IoT 응용 프로그램에서 매우 유용합니다. 방(“장면”)의 모든 조명을 켜거나 시계를 동기화하는 것을 생각해보세요. 마지막으로, 클라우드에 필요한 라우팅, 혼잡 제어 및 DDoS 방지와 같은 많은 구성 요소는 일부 사항이 독자에게 달려 있으며 (및 추가 사양입니다.)\n\n## 보안\n\n<div class=\"content-ad\"></div>\n\n우리가 보안에 대해 이야기하지 않았다면 뜬금없을 것입니다. 결국, IoT의 \"S\"는 보안을 의미하죠 (농담이에요!) 이전에 말했듯이 안전한 CoAP URI에는 기본 프로토콜로 coaps://와 포트 번호로 5684가 사용됩니다. 그렇다면 보안은 어떻게 구현되는 걸까요? CoAP는 기본적으로 UDP를 사용하므로 전송 계층을 보호하기 위해 DTLS (Datagrams용 TLS)를 선택했습니다. DTLS를 기반으로 CoAP는 네 가지 보안 모드를 정의합니다:\n\n- Pre-shared keys (PSK) 이것은 미리 정의된 키를 사용하므로 구현하기 가장 간단하지만, 확장성이 가장 낮은 방법입니다. PSK를 생성, 배포 및 보호하는 것은 문제가 발생할 수 있습니다. 그렇지만, 간단한 배치에는 이 방법이 가장 일반적으로 사용되는 것으로 보입니다.\n- Raw Public Key (RPK) 이 모드는 인증서의 복잡성 없이 공개 키 쌍을 사용합니다. RPK는 일반적으로 더 나은 끝간 보안 구조(ex. 공개 키에서 키 유도)와 현대적인 공개 키 인프라와 잘 작동합니다.\n- Certificates 인증서는 엔터프라이즈급 보안으로 간주됩니다. RPK와 마찬가지로 이 모드는 X.509 인증서를 사용하며 인증서 수명주기 관리(믿음 루트, 인증서 교체 등)의 성숙한 생태계를 갖추고 있습니다. CoAP와 결합된 인증서 기반 보안은 전문화된 솔루션(+사양)으로 이어지며, 이것을 적절히 다루기 위해 별도의 포스트가 필요합니다.\n- No Security 기술적으로는 보안 모드가 아니며, 불행히도 야생에서 가장 흔한 모드입니다. 이는 종종 VPN과 같은 상위 수준의 보안을 의존하기 때문이지만, 총비용절감, 나태함 또는 개발자 무지로 인한 경우도 있습니다.\n\nRFC 7252에서 여러 보안 고려 사항이 논의되어 있습니다. 최근 CoAP를 유명하게 한 것 중 하나는 셀룰러 장치를 이용한 DDoS 공격이었습니다. 이 유형의 공격은 증폭 공격으로 알려져 있으며, 모든 UDP 기반 프로토콜에 취약합니다. 안타깝게도, 이러한 공격은 가장 기본적인 보안 방법과 양호한 클라우드 구현으로 대부분 막을 수 있습니다.\n\n보안은 매우 중요한 주제이고, 다행히도 이 분야에서 많은 좋은 노력이 벌어지고 있습니다. 이 시리즈에서 나중에 더 심층적으로 다룰 예정입니다.\n\n<div class=\"content-ad\"></div>\n\n# CoAP 시작하기\n\nCoAP을 시작하는 가장 쉬운 방법은 터미널에서 바로 시작하는 것입니다. 제가 추천하는 구현 중 일부는 다음과 같습니다:\n\n- libcoap (C/C++)\n- Californium (Java)\n- go-coap (Go)\n- aiocoap (Python)\n- node-coap (Node.js)\n\n요즘에는 Go를 선호하고 있으니, go-coap에서 간단한 클라이언트/서버 예제를 소개해 드리겠습니다:\n\n<div class=\"content-ad\"></div>\n\n도움을 받을 수 있는 좋은 장소는 Stack Overflow, Reddit, CoRE 메일링 리스트 또는 특정 라이브러리의 이슈 목록을 사용하는 것입니다.\n\n# 요약\n\n마음맵을 다시 살펴보자. 이번에는 \"basic\"이라고 부르지 않은 모든 것을 숨겨봅시다:\n\n훨씬 덜 무섭게 보이죠! 그것이 목적입니다 :) CoAP는 기본 프로토콜로 간단하고 쉽게 이해할 수 있습니다. 이 게시물만으로도 CoAP를 다음 프로젝트나 제품의 기본 구성 요소로 사용할 준비가 되었습니다. 하지만 논의할 주제가 더 많이 있습니다!\n\n<div class=\"content-ad\"></div>\n\n# 다음에 올 내용\n\n원래 CoAP 논의를 하나의 게시물로 계획했었는데... 우리가 더 얘기할 주제가 많이 생겼어요. 최소한 세 개의 게시물이 더 나올 것으로 예상돼요:\n\n- Part 2: 기본 이해 이상\n- Part 3: 고급 사용 사례\n- Part 4: CoAP 보안 자세히\n\n그러나 이 글에 대한 피드백과 커버하고 싶은 내용에 대한 의견을 주시면 정말 감사하겠어요! 아래에 댓글을 남겨주시거나 트위터/링크드인으로 메시지 보내주세요.\n\n<div class=\"content-ad\"></div>\n\n위의 텍스트를 친근한 톤으로 한국어로 번역해 드리겠습니다.\n\n와인 잔을 올려봅시다!","ogImage":{"url":"/assets/img/2024-06-19-AFieldGuidetoCoAPPart1_0.png"},"coverImage":"/assets/img/2024-06-19-AFieldGuidetoCoAPPart1_0.png","tag":["Tech"],"readingTime":7}],"page":"73","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}