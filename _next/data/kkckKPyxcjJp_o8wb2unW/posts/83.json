{"pageProps":{"posts":[{"title":"탐지 개선 ETW 패치 텔레미트리에 대한 새로운 관점","description":"","date":"2024-06-19 09:11","slug":"2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry","content":"\n\n# 소개\n\n얼마 전에 'ETW 패치 이해하기'라는 블로그를 썼는데, 그 글에서 ETW 패칭이 함수 패치의 초고도 버전이라는 내용을 설명했어. Defenders 부분에서는 프로세스 내에서 공급자 DLL이 로드되었지만 ETW 이벤트가 발생하지 않는 걸 볼 수 있는 방법에 대해 언급했어. 이 방법은 특정 공급자에 대해서만 작동해서 좋은 방법은 아니야. 이 초기 생각에 대해 더 알고 싶다면 [요 트윗](링크)을 참조해봐. 그 이후로 좀 더 깊게 파보았고, 이번 글에서는 이 접근 방식에 대해 이야기할 거야.\n\n# 로컬 ETW 패칭\n\n이전 글에서 언급했듯이, 이벤트 발생을 막는 일반적인 방법 중 하나는 ntdll 함수인 특히 EtwEventWrite 또는 NtTraceEvent에 초점을 맞추는 것이야. 이를 수행하는 단계는 다음과 같아:\n\n<div class=\"content-ad\"></div>\n\n- DLL 로딩: 이미 로드되지 않은 경우, 함수를 패치하고 싶은 DLL을 로드하세요.\n- 함수 포인터 획득: 원하는 함수에 대한 함수 포인터를 가져오세요.\n- 메모리 보호 변경: 쓰기 액세스를 허용하기 위해 메모리 영역의 보호 값을 변경하세요.\n- 패치 적용: 패치를 작성하세요.\n- 메모리 보호 복원: 선택적으로, 메모리 영역의 보호 값을 원래 설정으로 돌려놓으세요.\n\n원하는 함수에 대한 함수 포인터를 획들한 후, 이러한 바이트를 임의로 패치할 수 없다는 것을 알 수 있습니다. 각 함수의 메모리 주소의 보호 수준을 먼저 변경해야합니다. 이러한 함수가 메모리 영역에 대한 쓰기 권한이 있는 경우 가능할 것입니다. 하지만 곧 보게 될 것처럼, 그렇지 않습니다.\n\n메모리 영역은 수행할 수 있는 작업을 제한하는 보호 상수를 가지고 있습니다. 이러한 함수들에 대해서는 해당 메모리 섹션에 쓰기가 지원되지 않음을 볼 수 있습니다. 아래에서 이러한 함수들의 메모리 영역 보호 값이 표시됩니다.\n\n```js\n0:012> !vprot ntdll!EtwEventWrite\nBaseAddress: 00007ffaafbbf000\nAllocationBase: 00007ffaafb90000\nAllocationProtect: 00000080 PAGE_EXECUTE_WRITECOPY\nRegionSize: 0000000000103000\nState: 00001000 MEM_COMMIT\nProtect: 00000020 PAGE_EXECUTE_READ\nType: 01000000 MEM_IMAGE\n\n0:012> !vprot ntdll!NtTraceEvent\nBaseAddress: 00007ffaafc30000\nAllocationBase: 00007ffaafb90000\nAllocationProtect: 00000080 PAGE_EXECUTE_WRITECOPY\nRegionSize: 0000000000092000\nState: 00001000 MEM_COMMIT\nProtect: 00000020 PAGE_EXECUTE_READ\nType: 01000000 MEM_IMAGE\n```\n\n<div class=\"content-ad\"></div>\n\n위의 내용은 코드가 읽히고 실행되지만 작성되지는 않음을 의미합니다. 따라서 이러한 함수 중 하나를 수정할 때 보호 값이 변경되어야 합니다. 일반적으로 PAGE_EXECUTE_READWRITE (0x40/60)로 변경하여 VirtualProtect를 사용합니다. VirtualProtect 작업 이전에 수집된 텔레메트리는 함수 패치의 신뢰할 수 있는 지표가 아닐 수 있습니다. VirtualProtect 작업조차 직접적인 함수 패치를 나타내지는 않습니다. 그러나 VirtualProtect에 대한 텔레메트리 데이터가 있는 경우, 해당 메타데이터에서 함수 패치가 발생했는지 추측하는 데 충분한 맥락을 제공할 수 있습니다.\n\nETW 위협 인텔리전스 프로바이더 내에는 THREATINT_PROTECTVM_LOCAL (EID: 7)라는 이벤트가 있습니다. 이 이벤트는 VirtualProtect가 로컬에서 수행될 때 텔레메트리 정보를 제공하는 것으로 보입니다. TelemetrySource 프로젝트를 살펴보거나 EtwInspector를 실행하여 이를 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_0.png)\n\n더 깊이 조사한 결과로 메모리 영역의 보호 수준을 변경하는 경우에 대한 이벤트가 있음을 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n사전 패치: 보호 값이 PAGE_EXECUTE_READ(0x20)에서 PAGE_EXECUTE_READWRITE(0x40)로 변경되었습니다.\n\n![이미지](/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_1.png)\n\n이 이벤트에는 몇 가지 귀중한 정보가 있습니다:\n\n- BaseAddress — 보호 값이 변경된 메모리 주소입니다.\n- RegionSize Value — 2. 여기서는 보호가 변경된 바이트가 2개임을 보여줍니다. 이것은 보통 4096 또는 그 이상인데, 이 값이 낮은 것이 불통입니다. 또 내용을 찾아보니 이 값이 (0xc3, 0x00)으로 변경되었을 때이며 이 값은 x64 시스템에서 반환값입니다.\n- ProtectionMask — 값이 PAGE_EXECUTE_READWRITE로 변경되었음을 나타냅니다.\n- Last ProtectionMask — 값이 PAGE_EXECUTE_READ에서 변경되었음을 나타냅니다.\n- Callstack — VirtualProtect가 호출된 것을 보여줍니다.\n\n<div class=\"content-ad\"></div>\n\n포스트 패치: 페이지 보호 값을 PAGE_EXECUTE_READWRITE(0x20)에서 PAGE_EXECUTE_READ(0x40)으로 변경합니다.\n\n![이미지](/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_2.png)\n\n포스트 보호 값이 반드시 이루어질 필요는 없습니다. 그러나 보호 값이 한 값에서 다른 값으로 변경된 시기를 알고 싶어하는 사람이 있다면 좋은 신호입니다. 이는 누군가가 한 값으로 변경한 다음 다시 다른 값으로 바꾸는 것은 매우 이상하다는 것을 의미합니다. 실제로 변경된 바이트를 볼 수 없기 때문에 이것은 잘못된 양성 결과를 방지하는 데 도움이 될 수 있습니다.\n\n이제 아마도 당신은 생각할 것입니다 — 실제 바이트 패치는 어떻게 할까요? 처음에는 WriteProcessMemory 함수가 작동할 것이라고 생각했지만, C 함수를 호출할 때 — memcpy/memmove 함수가 실제로 WriteProcessMemory를 호출하지 않는다는 사실을 깨달았습니다. 원격 패치에 대해 아래에서 계속 탐구할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 탐지 아이디어:\n\n- 이벤트 ID 7을 수집합니다: Local Virtual Protect — 초기 ProtectionMask 변경\n\n- 관심 있는 함수들에서 패치된 바이트의 공통 숫자(RegionSize 값)를 찾아보세요. x64/x86의 경우 EtwEventWrite와 같은 함수에서 패치된 바이트의 수는 종종 2입니다. 이는 함수가 실행된 후 반환 값이 패치되기 때문입니다.\n- New ProtectionMask가 PAGE_READWRITE (0x04) 또는 PAGE_EXECUTE_READWRITE (0x40)로 열렸을 때를 확인해보세요.\n\n2. 이벤트 ID 7을 수집합니다: Local Virtual Protect — ProtectionMask 복원\n\n<div class=\"content-ad\"></div>\n\n- 누군가가 보호 값을 다시 원래 값으로 변경할 필요는 없지만, 일반적으로 그렇게 하는 것이 좋습니다. 보호 마스크를 더 엄격한 0x20에서 0x40로 변경한 다음 다시 0x20으로 변경되는 것을 보면 꽤 의심스럽습니다. 따라서 동일한 메모리 주소에서 보호 마스크가 계속 왔다갔다 하면 2 EID 7을 검사하는 것이 높은 결과를 얻을 수 있을 것입니다.\n\n# 원격 ETW 패치\n\n원격 패치는 더 드물지만, 듣보잡은 아니며 이에 대한 좋은 프로젝트는 RemotePatcher입니다. 이는 원격 함수 패치를 수행하는 것이 더 위험하기 때문에 감지될 가능성이 높기 때문입니다. memcpy/memmove는 원격 프로세스 내에서 바이트를 쓰는 것을 지원하지 않기 때문에 WriteProcessMemory를 사용해야 하며, RemotePatcher는 patchAMSI 함수에서 이 작업을 수행합니다.\n\n![이미지](/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_3.png)\n\n<div class=\"content-ad\"></div>\n\n지금, 우리는 NtProtectVirtualMemory가 두 번 호출된 것을 볼 수 있습니다. 한 번은 보호 값을 PAGE_READWRITE(0x04)로 변경하고 다시 원래 값으로 변경하기 위해 호출됩니다. 차이점은 NtWriteVirtualMemory가 호출된다는 것입니다. TelemetrySource 내부에서 event ID 14로 이어진다는 것을 알 수 있습니다. 이것을 살펴보겠습니다:\n\n![이미지](/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_4.png)\n\n위에 표시된 이벤트들이 멋진 점은 원격 프로세스에 액세스한 프로세스가 있고, 메모리 영역의 보호 값을 변경하고 대상 프로세스에 데이터를 쓰고 다시 보호 값을 변경했다는 것이 명백하다는 것입니다. 이러한 연산 순서는 Windows에서 빈번하게 발생하지 않습니다.\n\n# 탐지 아이디어:\n\n<div class=\"content-ad\"></div>\n\n- 이벤트 ID 2를 수집하세요: 원격 가상 보호 — 초기 ProtectionMask 변경\n\n- New ProtectionMask가 PAGE_READWRITE (0x04) 또는 PAGE_EXECUTE_READWRITE (0x40)로 열렸을 때를 찾아보세요.\n\n2. 이벤트 ID 2를 수집하세요: 원격 가상 보호 — ProtectionMask 되돌리기\n\n- 누군가는 보호 값을 원래 값으로 되돌릴 필요는 없지만, 이는 일반적인 관행입니다. 보호 마스크가 0x20처럼 더 많이 잠긴 마스크에서 0x40로 변경되고 다시 0x20으로 돌아가는 것을 보는 것은 상당히 수상합니다. 따라서 동일한 메모리 주소의 보호 마스크가 그렇게 왔다갔다하는 2개의 EID 2를 주시하면 높은 결과를 얻을 수 있을 겁니다.\n\n<div class=\"content-ad\"></div>\n\n3. 이벤트 ID 14를 수집하세요: 프로세스 메모리 쓰기 - 패치용 바이트를 기록\n\n- 이를 원격 VirtualProtect가 메모리 쓰기 전후에 수행되는 상황에서 관찰하는 것은 의심스러울 수 있습니다.\n- 이것이 ETW 패칭인지에 대해 분간하기가 어려울 수 있지만, 이것은 어쨌든 프로세스 주입 가시성에 사용될 수 있습니다. 기술적으로 이것은 데이터가 대상 프로세스에 쓰여지기 때문에 프로세스 주입으로 간주될 수 있습니다.\n\n# 결론\n\n이 포스트에서는 ETW 패칭 및 이 활동을 관찰하는 실용적인 접근 방식을 간단히 탐색하고자 했습니다. 로컬 패칭이 원격 패칭보다 훨씬 더 흔합니다. 유감스럽게도, memcpy와 memmove는 WriteProcessMemory를 호출하지 않기 때문에 로컬에서 실제 패치를 식별하는 것은 매우 어렵습니다. 그러나 패치가 발생할 메모리 영역의 보호 마스크에 대한 변경을 감지하는 것은 여전히 좋은 지표로 남아 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 보호 마스크가 읽기/실행에서 읽기/쓰기/실행으로 변경되는 것은 흔하지 않습니다. 또한, 이러한 이벤트에서 바뀌는 바이트 수는 보통 다른 일반적인 VirtualProtect 이벤트보다 낮습니다. 일반적으로 4096바이트 이상이 관련된 것들이 대부분입니다. RemotePatcher에서 볼 수 있듯이, 누군가가 4096바이트 메모리 영역의 보호 값 변경을 위해 조용히 하는 경우가 있습니다.\n\n만약 이 방식을 구현하고 싶다면, 데이터를 분석하여 연속적으로 여러 작업이 발생하는 패턴을 식별하는 것을 권장합니다. 또한, 공격자가 변경할 수 있는 모든 가능한 보호 값과 함께 쓰기 권한을 포함하는 것들을 모두 살펴보세요. 이 정보가 도움이 되었기를 바랍니다. 아이디어를 공유하거나 질문이 있으면 언제든지 연락 주세요.\n\nArash Parsa에게 연락해주고 다시 이 주제를 재방문하고 문서화하도록 하도록 도와준 것에 감사드립니다.","ogImage":{"url":"/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_0.png"},"coverImage":"/assets/img/2024-06-19-RefiningDetectionNewPerspectivesonETWPatchingTelemetry_0.png","tag":["Tech"],"readingTime":7},{"title":"사이버 브리핑 20240617","description":"","date":"2024-06-19 09:09","slug":"2024-06-19-CyberBriefing20240617","content":"\n\n<img src=\"/assets/img/2024-06-19-CyberBriefing20240617_0.png\" />\n\n👉 오늘의 사이버 보안 소식은 무엇인가요?\n\nWi-Fi 취약점, Windows, DISGOMOJI 악성 소프트웨어, 인도 정부, TIKTAG 공격, ARM MTE, ASUS 라우터, D-Link 라우터, Keytronic 데이터 유출, Victoria Racing Club, 호주, 폴란드 TVP 스포츠, 유로 2024 중계, MARINA 사이버 공격, 필리핀, 러시아 권위 선전 캠페인, 모르도바 선거, 윤리적 AI 사용, 교황 프란치스코, G7, 딥페이크, 구글의 프라이버시 샌드박스, 런던 병원, Scattered Spider, 스페인.\n\n<img src=\"/assets/img/2024-06-19-CyberBriefing20240617_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n환영합니다! 매일 업데이트되는 최신 사이버 보안 통보, 경보, 사건 및 뉴스를 제공하는 소식지인 사이버 브리핑에 오신 것을 환영합니다.\n\n처음 보시나요? 구독해주세요.\n\n## 🚨 사이버 경보\n\n1. 윈도우 사용자를 위협하는 심각한 Wi-Fi 결함\n\n<div class=\"content-ad\"></div>\n\n마이크로소프트가 윈도우의 중요한 Wi-Fi 취약점을 공개했습니다. 이 취약점은 심각성 평가에서 10점 만점 중 8.8점을 받았으며 CVE-2024-30078로 알려져 있습니다. 이 결함은 비인증된 공격자가 사용자 상호작용 없이 원격 코드를 실행할 수 있는 문제로, 모든 지원되는 Windows 버전에 영향을 미치며 물리적 근접만으로 이용할 수 있습니다. 보안 전문가들은 이 취약점이 초래하는 중요한 위험을 완화하기 위해 특히 밀도 높은 장치 연결 환경에서 패치를 즉시 적용해야 한다고 강조하고 있습니다.\n\n2. 리눅스 악성 코드 DISGOMOJI가 인도를 목표로 합니다\n\n사이버 보안 기업 Volexity는 이모티콘을 사용하여 명령을 실행하는 새로운 리눅스 악성 코드 DISGOMOJI를 발견했습니다. 파키스탄 기반 위협 행위자와 관련된 이 악성 코드는 UPX로 패킹된 ELF 실행 파일을 사용하여 인도의 정부 기관을 대상으로 하는데, 이메일을 통해 피싱을 실행합니다. DISGOMOJI는 Discord 및 이모티콘을 명령 및 제어 플랫폼으로 사용하여 전통적인 보안 소프트웨어에 의한 탐지를 회피할 수 있으므로 주목할 가치가 있습니다.\n\n3. TIKTAG 공격이 ARM MTE를 이용합니다\n\n<div class=\"content-ad\"></div>\n\n최근 발표된 연구 논문에서는 ARM의 Memory Tagging Extension (MTE)을 활용하여 높은 성공률로 메모리 태그를 노출시키는 TIKTAG 공격을 소개했습니다. 한국 팀이 개발한 이 기술은 Google Chrome 및 Linux 커널을 대상으로 하며, 추측 실행에 대한 취약점을 보여 MTE의 보안 기능을 약화시킵니다.\n\n4. ASUS 라우터 취약점 긴급 업데이트\n\n여러 ASUS 라우터 모델에 영향을 미치는 심각한 취약점이 발견되어, 원격 공격자가 인증 없이 임의의 시스템 명령을 실행할 수 있습니다. 이 취약점은 CVE-2024-3912로 할당되었으며 CVSS 점수는 9.8로 지정되어 있어 임의의 펌웨어 업로드 취약성 때문에 중대한 보안 위험을 야기합니다. ASUS는 영향을 받는 모델용 펌웨어 업데이트를 출시하여 이 심각한 문제를 완화했습니다.\n\n5. D-Link 라우터 관리자 해킹에 노출\n\n<div class=\"content-ad\"></div>\n\n여러 D-Link 무선 라우터 모델에서 식별된 중요한 취약점인 CVE-2024-6045가 미인증 공격자가 관리자 액세스를 얻을 수 있게 해줍니다. 해당 취약점은 CVSS 점수가 8.8인 고 위험도를 가지며, 공개되지 않은 공장 테스트 백도어에서 발생했습니다. D-Link는 이러한 위험을 완화하기 위해 펌웨어 업데이트를 출시했으며, 사용자들에게 잠재적인 악용에 대비하기 위해 기기를 신속히 업데이트할 것을 권장합니다.\n\n![이미지](/assets/img/2024-06-19-CyberBriefing20240617_2.png)\n\n# 💥 사이버 사건\n\n6. Keytronic 데이터 유출이 업무를 방해합니다.\n\n<div class=\"content-ad\"></div>\n\nKeytronic은 중대한 데이터 침해를 당해 영업이 중단되고 530GB의 데이터가 유출되었습니다. 블랙 바스타에 속한 사이버 공격으로 인해 Keytronic의 국내 및 멕시코 영업이 2주간 중단되었습니다. 침해로 인해 회사에는 사이버 보안 조치를 위한 상당한 비용이 발생했습니다.\n\n7. Globe Life의 사이버 보안 침해 공개\n\n텍사스 소재의 보험 홀딩 회사인 Globe Life은 최근 고객 및 증권 보유자 정보가 유출된 것으로 보이는 사이버 보안 사건을 공개했습니다. 이 침해는 주 보험 감독 기관의 조사로 인해 유도된 보안 검토 중에 발견되었습니다. 회사는 영향을 받은 포털에 대한 액세스를 철회했지만, 침해의 전체 영향은 여전히 조사 중에 있습니다.\n\n8. 호주 경마 클럽의 사이버 공격\n\n<div class=\"content-ad\"></div>\n\n빅토리아 레이싱 클럽이 사이버 공격을 당했는데, 수만 명의 회원들에 대한 우려가 증가했습니다. CEO 스티브 로직은 정상적인 운영을 보장하면서 이해관계자들 사이에서 사이버 주의를 당부했습니다. 호주 사이버 보안 센터의 지원을 받아 조사가 진행 중입니다.\n\n9. 유로 2024 중 TVP 스포츠 사이버 공격\n\n폴란드 스포츠 채널 TVP 스포츠는 폴란드와 네덜란드의 유로 2024 경기 중 DDoS 공격을 당했는데, 이로 인해 폴란드 IP 주소에서 해당 웹 사이트 접속이 차단되었습니다. 주장인 TVP 스포츠 디렉터 야쿱 크바토프스키의 확인으로, 시청자들은 첫 경기 전반을 놓친 후 두 번째 전반에 접속할 수 있었고, 네덜란드가 대회 개막전에서 폴란드를 2-1로 이기는 것을 목격했습니다.\n\n10. 마리나 사이버 공격으로 선박 데이터가 노출되었습니다.\n\n<div class=\"content-ad\"></div>\n\n2024년 6월 16일, 필리핀 해양 관리 기관 MARINA이 심각한 사이버 공격을 당했습니다. 해커 \"ph1ns\"의 공격으로 네 개의 중요한 웹 시스템이 침해당했습니다. 이로 인해 선박 소유주와 선원들의 민감한 데이터가 노출되었으며, 정부 사이버 보안의 취약성이 드러났습니다. 시스템 무결성을 6월 18일까지 복구하는 노력이 진행 중이며, 공공 부문의 디지털 방어 강화가 절실함을 강조하고 있습니다.\n\n![사이버브리핑](/assets/img/2024-06-19-CyberBriefing20240617_3.png)\n\n# 📢 사이버 뉴스\n\n11. 몰도바 선거에 대한 러시아의 개입\n\n<div class=\"content-ad\"></div>\n\n미국, 영국, 그리고 캐나다가 크렘린이 몰도바 선거와 EU 국민투표에 개입하고 선호하는 후보자들을 지지하고 현직 대통령 마야 산두에 반대하는 선동을 하고 있다고 비난했습니다. 공동 성명은 러시아의 침략에 대항하여 민주주의 가치를 지키는 데 연대를 강조했으며, 정보 조작, 비공개 활동, 그리고 프로러시아 후보자를 지원하는 사실을 강조했습니다. 동맹국들은 몰도바가 크렘린의 개입과 연관된 위협을 관리할 능력에 대한 전체 신뢰를 표명하며, 모스크바에게 몰도바의 주권과 자유롭고 공평한 선거 결과를 존중할 것을 촉구했습니다.\n\n12. 교황 프란치스코, G7에서 윤리적 AI에 대해 이야기\n\n교황 프란치스코는 G7 정상회담에 참석함으로써 역사를 만들었습니다. 그는 인공지능의 윤리적 영향에 대해 다루며, AI가 인류에 봉사하는 중요성을 강조했으며, 인간의 결정권을 기계에 양도하는 것을 경계했습니다. 프란치스코는 책임 있는 AI 개발을 촉구하며, 자율성, 투명성, 그리고 무기 시스템에서 기술 남용의 우려를 언급했습니다.\n\n13. 구글 샌드박스가 사용자 추적 혐의를 받음\n\n<div class=\"content-ad\"></div>\n\n구글의 Privacy Sandbox는 서드 파티 추적 쿠키를 대체하기 위해 고안된 것으로 사용자 추적을 여전히 가능하게 한다는 비난을 받고 있습니다. Noyb는 사용자들이 개인 정보 보호를 선택하고 있다고 믿으면서도 퍼스트 파티 광고 추적을 가능케 하도록 속여진다고 주장합니다. 이 그룹은 현재 방법보다 침투력이 낮다고는 하지만 이것이 데이터 보호 법을 위반한다고 주장합니다.\n\n14. 런던 병원들이 800건 이상의 수술을 취소\n\n가이즈 앤 세인트 토마스 NHS 재단 트러스트 및 킹스 칼리지 병원 NHS 재단 트러스트 등 런던 병원들이 Synnovis(이전 ViaPath)를 향해 Qilin에 의한 랜섬웨어 공격으로 인해 중대한 장애를 겪었습니다. 800건 이상의 수술과 700건의 예약이 연기되었으며, Synnovis가 IT 시스템 복구에 노력하는 동안 이에 대한 지속적인 서비스 영향이 예상됩니다.\n\n15. 주요 스캐터드 스파이더 사이버 범죄자가 체포되었습니다.\n\n<div class=\"content-ad\"></div>\n\nScattered Spider 사이버범죄 그룹과 연관된 영국 22세 남성이 Palma de Mallorca에서 이탈리아로 도피하려다逮捕되었습니다. Tyler라는 별명을 가진 그는 SIM 스왑퍼로 활동하여 vx-underground에 따르면 고프로필 랜섬웨어 공격에 관여했습니다. Scattered Spider 또는 0ktapus 및 UNC3944라고도 알려진 이 그룹은 정교한 사회 공학 기술로 SaaS 애플리케이션을 대상으로 암호화되지 않은 협박과 공포 유발 전술을 사용하는 것으로 악명높습니다. FBI와 스페인 경찰이 이逮捕 작업을 위해 협력했으며, 세계적인 사이버 위협과의 전투에 계속 노력하고 있습니다.\n\n구독하고 댓글을 남겨주세요.\n\nCopyright © 2024 CyberMaterial. All Rights Reserved.\n\nCyberMaterial의 팔로우하기:\n\n<div class=\"content-ad\"></div>\n\n마크다운 형식으로 table태그를 수정해주세요.\n\nLinkedIn | Twitter | Reddit | Instagram | Facebook | YouTube | Medium\n\n<img src=\"/assets/img/2024-06-19-CyberBriefing20240617_4.png\" />","ogImage":{"url":"/assets/img/2024-06-19-CyberBriefing20240617_0.png"},"coverImage":"/assets/img/2024-06-19-CyberBriefing20240617_0.png","tag":["Tech"],"readingTime":6},{"title":"기초적인 Active Directory  TryHackMe","description":"","date":"2024-06-19 09:05","slug":"2024-06-19-ActiveDirectoryBasicsTryHackMe","content":"\n\n이 방에서는 Active Directory가 제공하는 기본 개념과 기능을 소개합니다.\n\n![Active Directory Basics](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_0.png)\n\n## Task 2: Windows Domains:\n\nWindows 도메인에서 자격 증명은 ...과(와) 같은 중앙 저장소에 저장됩니다.\n\n<div class=\"content-ad\"></div>\n\n답변: 활성 디렉터리\n\n활성 디렉터리 서비스를 운영하는 서버는 다음과 같습니다...\n\n답변: 도메인 컨트롤러\n\n## 참고:  \n\n<div class=\"content-ad\"></div>\n\nAD는 무엇인가요?\n\nActive Directory는 사용자의 정보를 저장하는 디렉터리 데이터베이스/서버로, 사용자 이름, 전화 번호, 이메일 및 다른 자격 증명과 같은 정보를 저장합니다. 동일한 네트워크 사용자의 정보는 Active Directory에서 관리할 수 있습니다. 또한 사용자의 권한도 Active Directory에서 제어됩니다.\n\nActive Directory 서비스를 실행하는 서버를 도메인 컨트롤러(Domain Controller, DC)라고 합니다.\n\n각 컴퓨터를 개별적으로 방문하여 사용자를 수동으로 생성하거나 문제를 해결해야하는 등의 일부 한계를 극복하기 위해 Windows 도메인을 사용할 수 있습니다. 간단히 말해 Windows 도메인은 특정 비즈니스의 사용자 및 컴퓨터 그룹을 관리하는 것입니다. 도메인의 주요 아이디어는 Windows 컴퓨터 네트워크의 일반 구성 요소의 관리를 Active Directory(AD)라는 단일 저장소에 집중하는 것입니다. Active Directory 서비스를 실행하는 서버를 도메인 컨트롤러(DC)라고 합니다.\n\n<div class=\"content-ad\"></div>\n\n구성된 Windows 도메인을 갖는 주요 이점은 다음과 같습니다:\n\n- 중앙 집중식 식별 관리: 네트워크 전체의 모든 사용자를 최소한의 노력으로 Active Directory에서 구성할 수 있습니다.\n- 보안 정책 관리: Active Directory에서 직접 보안 정책을 구성하고 필요에 따라 네트워크 전체의 사용자 및 컴퓨터에 적용할 수 있습니다.\n\n실제 사례\n\n이것이 다소 혼란스러워 보인다면, 학교, 대학 또는 직장에서 어느 시점에서라도 Windows 도메인과 상호 작용한 적이 있을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n학교/대학 네트워크에서는 캠퍼스 내의 모든 컴퓨터에서 사용할 수 있는 사용자 이름과 비밀번호가 제공됩니다. 여러분의 자격 증명은 모든 기기에서 유효하며, 해당 기기에서 입력할 때마다 인증 프로세스가 Active Directory로 전달되어 자격 증명을 확인합니다. Active Directory 덕분에 여러분의 자격 증명은 각 기기에 개별적으로 존재할 필요 없이 네트워크 전체에서 사용할 수 있습니다.\n\n또한, Active Directory는 학교/대학이 캠퍼스의 컴퓨터에서 제어판에 접근하는 것을 제한할 수 있게 하는 구성 요소입니다. 일반적으로 정책은 네트워크 전체에 배포되어 해당 컴퓨터에 대한 관리 권한을 부여하지 않도록 설정됩니다.\n\n저는 RDP 포트를 사용하여 Remmina라는 Kali 도구를 사용하여 THM.local에 로그인했습니다. \n사용자 이름: Administrator\n비밀번호: Password321\n\n![이미지](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_1.png)\n\n<div class=\"content-ad\"></div>\n\n## 작업 3: Active Directory:\n\n도메인에서 일반적으로 모든 컴퓨터 및 자원을 관리하는 그룹은 무엇입니까?\n\n답변: 도메인 관리자\n\n기계 이름이 TOM-PC인 기계 계정의 이름은 무엇입니까?\n\n<div class=\"content-ad\"></div>\n\n답변: TOM-PC$\n\n우리 회사가 품질 보증(Quality Assurance) 부서를 신설한다고 가정해 보겠습니다. 정책이 일관되게 적용될 수 있도록 모든 품질 보증 사용자를 그룹화하기 위해 어떤 유형의 컨테이너를 사용해야 할까요?\n\n답변: 조직 단위\n\n## 참고:\n\n<div class=\"content-ad\"></div>\n\nWindows Domain의 핵심은 Active Directory Domain Service (AD DS)입니다. 이 서비스는 네트워크에 존재하는 모든 \"객체\"의 정보를 보유하는 카탈로그 역할을 합니다. AD에서 지원하는 많은 객체 중에는 사용자, 그룹, 기기, 프린터, 공유 등이 있습니다. 이 중 몇 가지를 살펴보겠습니다:\n\n사용자\n\n사용자는 Active Directory에서 가장 일반적인 객체 유형 중 하나입니다. 사용자는 보안 주체 중 하나로, 도메인에서 인증을 받을 수 있고 파일이나 프린터와 같은 리소스에 대한 권한을 할당 받을 수 있습니다. 보안 주체를 네트워크에서 리소스에 영향을 줄 수 있는 객체로 볼 수 있습니다.\n\n사용자는 두 가지 유형의 엔터티를 나타내는 데 사용될 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n- 사람: 사용자는 보통 조직 내에서 네트워크에 접속해야 하는 사람들, 즉 직원들을 대표합니다.\n- 서비스: 사용자를 IIS 또는 MSSQL 같은 서비스에서 사용하도록 정의할 수도 있습니다. 각각의 서비스는 실행에 필요한 사용자를 요구하지만 서비스 사용자는 일반 사용자와는 달리 해당 서비스를 실행하는 데 필요한 권한만 갖습니다. (여기서 사용자는 일반적인 사용자와는 다르며 이러한 종류의 사용자 계정은 Windows 운영 체제에서 특정 서비스나 응용 프로그램을 실행하기 위해 생성된 것입니다. 이 유형의 계정은 기본적으로 운영 체제에 이미 생성된 계정입니다. 그러나 필요한 경우 누구나 서비스 계정을 만들 수 있습니다. 예: 계정이 콘솔에 로그인하지 않은 경우에도 컴퓨터에서 계속 실행되는 네트워크 서비스나 서비스를 시작할 수 있게 합니다)\n\n기계 (컴퓨터 계정은 활성 디렉토리에 대한 데스크탑이나 랩톱을 나타냅니다. 컴퓨터 계정과 연관된 계정 이름과 계정 ID가 있습니다)\n\n기계는 활성 디렉토리 내에서 또 다른 객체 유형입니다. 활성 디렉토리 도메인에 참여하는 모든 컴퓨터마다 기계 객체가 생성됩니다. 기계도 \"보안 원칙\"으로 간주되며 어떤 일반 사용자와 마찬가지로 계정이 할당됩니다. 이 계정은 도메인 내에서 다소 제한된 권한을 갖습니다.\n\n기계 계정 자체는 할당된 컴퓨터의 로컬 관리자이며, 일반적으로 컴퓨터 자체를 제외한 누구에게도 액세스되어서는 안 됩니다. 그러나 다른 계정과 마찬가지로 암호를 알고 있다면 해당 계정을 사용하여 로그인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n알림: 기계 계정 암호는 자동으로 회전되며 일반적으로 120개의 무작위 문자로 구성됩니다.\n\n기계 계정 식별은 비교적 쉽습니다. 특정한 명명 체계를 따릅니다. 기계 계정 이름은 컴퓨터 이름 다음에 달러 기호가 붙은 형식을 따릅니다. 예를 들어 DC01이라는 기계의 경우 DC01$라는 기계 계정을 갖게 됩니다.\n\n보안 그룹\n\nWindows에 익숙하다면 파일이나 다른 리소스에 대한 액세스 권한을 할당하기 위해 사용자 그룹을 정의할 수 있다는 것을 알고 계실 것입니다. 이렇게 하면 단일 사용자가 아닌 전체 그룹에 대한 액세스 권한을 부여할 수 있어 관리가 더 용이해집니다. 기존 그룹에 사용자를 추가하면 그들은 해당 그룹의 모든 권한을 자동으로 상속받을 수 있습니다. 보안 그룹은 또한 보안 주체로 간주되며, 따라서 네트워크상의 리소스에 대한 권한을 가질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n그룹은 사용자와 기계를 모두 멤버로 가질 수 있습니다. 필요한 경우, 그룹은 다른 그룹을 포함할 수도 있습니다.\n\n도메인에서는 사용자에게 특정 권한을 부여하는 데 사용할 수 있는 기본적으로 여러 그룹이 생성됩니다. 예를 들어, 다음은 도메인에서 가장 중요한 몇 가지 그룹입니다:\n\n도메인 관리자: 이 그룹의 사용자는 전체 도메인에 대한 관리자 권한을 갖습니다. 기본적으로, 그들은 DC(도메인 컨트롤러)를 포함한 도메인의 모든 컴퓨터를 관리할 수 있습니다.\n\n서버 운영자: 이 그룹의 사용자는 도메인 컨트롤러를 관리할 수 있습니다. 그들은 어떤 관리 그룹 멤버십도 변경할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n백업 작업자: 이 그룹의 사용자들은 권한을 무시하고 모든 파일에 액세스할 수 있습니다. 컴퓨터의 데이터를 백업하는 데 사용됩니다.\n\n계정 운영자: 이 그룹의 사용자들은 도메인 내의 다른 계정을 생성하거나 수정할 수 있습니다.\n\n도메인 사용자: 도메인 내의 모든 기존 사용자 계정을 포함합니다.\n\n도메인 컴퓨터: 도메인 내의 모든 기존 컴퓨터를 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n도메인 컨트롤러: 해당 도메인에 있는 모든 DC를 포함합니다.\n\nActive Directory 사용자 및 컴퓨터\n\nActive Directory에서 사용자, 그룹 또는 기기를 구성하려면 도메인 컨트롤러에 로그인하여 시작 메뉴에서 \"Active Directory 사용자 및 컴퓨터\"를 실행해야 합니다:\n\n![Active Directory Users and Computers](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_2.png)\n\n<div class=\"content-ad\"></div>\n\n이를 통해 도메인에 존재하는 사용자, 컴퓨터 및 그룹의 계층 구조를 볼 수 있는 창이 열립니다. 이러한 객체들은 사용자와 기기를 구분하는 컨테이너 객체인 조직 단위(OU)에 구성되어 있습니다. OUs는 사용자와 기계를 분류할 수 있도록 허용하는 컨테이너 객체이며(OUs는 모든 다른 그룹이 별도로 유지되는 그룹으로 모든 그룹이 OU 그룹의 하위 개체임을 의미하며, 각 그룹이 OU로 별도로 지칭되기도 합니다), 주로 유사한 규제 요구 사항을 가진 사용자 그룹을 정의하는 데 사용됩니다. 예를 들어, 귀하의 기관의 영업 부서의 사람들은 IT 부서의 사람들과 다른 정책 집합을 적용받을 가능성이 높습니다. 기억해야 할 점은 사용자가 한 번에 하나의 OU에만 속할 수 있다는 것입니다.\n\n우리의 기기를 확인하면 이미 IT, 관리, 마케팅 및 영업 부서를 위한 4개의 하위 OU가 있는 THM이라는 OU가 있습니다. 기업의 구조를 모방하는 OU를 보는 것은 매우 일반적인데, 이를 통해 전체 부서에 적용되는 기본 정책을 효율적으로 배포할 수 있습니다. 대부분의 경우 이것이 기대되는 모델이 될 것이지만 필요에 따라 OUs를 임의로 정의할 수도 있습니다. 재미를 위해 THM OU를 마우스 오른쪽 버튼으로 클릭하고 그 아래에 Students라는 새 OU를 만들어 보세요.\n\n어떤 OU를 열면 해당 OU에 포함된 사용자를 볼 수 있고, 필요할 때 만들거나 삭제하거나 수정하는 등 간단한 작업을 수행할 수 있습니다. 필요할 때 비밀번호를 재설정할 수도 있습니다(도움 데스크에 매우 유용함):\n\n![이미지](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_3.png)\n\n<div class=\"content-ad\"></div>\n\n이미 THM OU 이외에도 기본 컨테이너가 있다는 것을 이미 알고 계실 것입니다. 이러한 컨테이너들은 Windows에 의해 자동으로 생성되며 다음을 포함합니다:\n\n- Builtin: Windows 호스트에 사용 가능한 기본 그룹이 포함되어 있습니다.\n- Computers: 네트워크에 가입하는 모든 기기는 여기에 자동으로 배치됩니다. 필요한 경우 이동할 수 있습니다.\n- Domain Controllers: 네트워크의 DC를 포함하는 기본 OU입니다.\n- Users: 도메인 전역 문맥에 적용되는 기본 사용자 및 그룹이 포함됩니다.\n- Managed Service Accounts: Windows 도메인 내의 서비스에서 사용하는 계정을 보관합니다.\n\n보안 그룹 대 OUs\n\n그룹과 OU가 둘 다 사용자와 컴퓨터를 분류하는데 사용된다는 것을 궁금해하실 것입니다. 두 가지 모두 사용자와 컴퓨터를 분류하지만 목적은 완전히 다릅니다:\n\n<div class=\"content-ad\"></div>\n\n- OUs는 사용자 및 컴퓨터에 정책을 적용하는 데 유용합니다. 이는 기업에서 특정 역할을 하는 사용자 그룹에 대한 구성 설정을 포함합니다. 사용자는 한 번에 하나의 OU의 구성원일 수 있으며, 단일 사용자에게 두 가지 다른 정책 집합을 적용하는 것은 의미가 없습니다.\n- 반면에 보안 그룹은 리소스에 대한 권한을 부여하는 데 사용됩니다. 예를 들어, 몇 명의 사용자가 공유 폴더나 네트워크 프린터에 액세스할 수 있도록 허용하려면 그룹을 사용합니다. 사용자는 여러 그룹의 구성원이 될 수 있으며, 여러 리소스에 액세스를 부여하는 데 필요합니다.\n\n## 작업 4: AD에서 사용자 관리:\n\nSophie의 데스크톱에서 발견된 플래그는 무엇입니까?\n\n답변: THM'thanks_for_contacting_support'\n\n<div class=\"content-ad\"></div>\n\n## Note:\n\n위임 후 RDP 포트를 사용해 Remmina를 이용하여 필립스 계정에 로그인하십시오. 사용자 이름과 비밀번호: phillip: Claire2008\n\n![이미지](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_4.png)\n\n필립스 계정으로 들어간 후 명령 프롬프트를 열고 cmd에서 PowerShell로 전환하려면 명령을 사용하십시오: cmd에서 `powershell`을 입력하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_5.png)\n\nNow to set the password, type this command:\n```bash\nSet-ADAccountPassword sophie -Reset -NewPassword (Read-Host -AsSecureString -Prompt 'New Password') -Verbose\n```\n\n![Image 2](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_6.png)\n\nHere I have set the password: abcD12345*\n\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-19-ActiveDirectoryBasicsTryHackMe_7](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_7.png)\n\n![2024-06-19-ActiveDirectoryBasicsTryHackMe_8](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_8.png)\n\n이제 우리가 플래그를 획득했어요. 그래서 우리는 소피가 우리가 제공한 비밀번호를 사용하지 못하게 하려고 해요. 소피가 계정에 로그인할 때 재설정 옵션을 표시하도록 소피의 계정을 Phillips 계정에서 다음 명령을 사용해서 설정할 거예요: Set-ADUser -ChangePasswordAtLogon $true -Identity sophie -Verbose\n\n![2024-06-19-ActiveDirectoryBasicsTryHackMe_9](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_9.png)\n\n\n<div class=\"content-ad\"></div>\n\n이미 게시한 표를 Markdown 형식으로 변환하십시오.\n\n<div class=\"content-ad\"></div>\n\n답변: 위임\n\n## 참고:\n\n새로운 도메인 관리자로 일하게 되셨군요! 사업에 일어난 최근 변경 사항을 확인하기 위해 기존의 AD OUs와 사용자들을 확인해야 합니다. 주어진 조직도를 확인하고 AD를 조정하여 일치시키는 것이 첫 번째 과제입니다.\n\n불필요한 OUs와 사용자 삭제하기\n\n<div class=\"content-ad\"></div>\n\n가장 먼저 주목해야 할 것은 현재 AD 구성에 있는 차트에 나타나지 않는 추가 부서 OU가 있다는 것입니다. 예산 삭감으로 폐쇄되었다는 이야기를 들었고 도메인에서 제거해야 합니다. OU를 마우스 오른쪽 단추로 클릭하여 삭제하려고 하면 다음 오류가 발생합니다:\n\n![image](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_12.png)\n\n기본적으로 OU는 우연한 삭제로부터 보호됩니다. OU를 삭제하려면 보기 메뉴에서 고급 기능을 활성화해야 합니다:\n\n![image](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_13.png)\n\n<div class=\"content-ad\"></div>\n\n추가 컨테이너를 표시하고 실수로 발생할 수 있는 삭제 보호를 해제할 수 있게 됩니다. 이를 위해 OU를 마우스 오른쪽 버튼으로 클릭하고 속성으로 이동하십시오. 객체 탭에 있는 확인란을 해제할 수 있는 것을 확인할 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_14.png)\n\n박스의 선택을 해제하고 OU를 다시 삭제해 보세요. OU를 삭제하려고 하면 확인 대화상자가 표시되며 그 결과로 그 하위에 있는 사용자, 그룹 또는 OU도 삭제됩니다.\n\n추가 OU를 삭제한 후 AD에서 일부 부서의 사용자가 조직도와 일치하지 않음을 알 수 있습니다. 필요한 사용자를 생성하고 삭제하여 일치시키세요.\n\n<div class=\"content-ad\"></div>\n\n대리권 (예시: IT 지원팀 구성원은 조직이 Active Directory의 대상 OU의 대리자 제어 옵션을 사용하여 그에게 부여한 권한으로 다른 그룹의 낮은 권한 구성원의 사용자 이름과 비밀번호를 변경할 수 있습니다)\n\nAD에서 할 수 있는 좋은 점 중 하나는 특정 사용자에게 일부 OU에 대한 제어 권한을 부여하는 것입니다. 이 프로세스를 위임(delegation)이라고 하며, 도메인 관리자의 개입 없이 사용자에게 OUs에서 고급 작업을 수행할 수 있는 특정 권한을 부여할 수 있습니다.\n\n이 중에서도 가장 일반적인 사용 사례 중 하나는 IT 지원팀에게 낮은 권한을 가진 사용자의 비밀번호를 재설정할 수 있는 권한을 부여하는 것입니다. 우리의 조직도를 보면 필립이 IT 지원을 담당하고 있으므로, 판매, 마케팅 및 경영 부서의 비밀번호 재설정 권한을 그에게 위임하고 싶을 것입니다.\n\n## 작업 5: AD에서 컴퓨터 관리하기:\n\n<div class=\"content-ad\"></div>\n\n사용 가능한 컴퓨터를 정리한 후에, 일반 사용자용 OU(조직 단위)에는 몇 대의 컴퓨터가 남아 있나요?\n\n답: 7\n\n![Active Directory Basics](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_15.png)\n\n서버와 일반 사용자용 컴퓨터를 위해 별도의 OU를 만드는 것이 좋은 아이디어인가요? (예/아니요)\n\n<div class=\"content-ad\"></div>\n\n정답: 와우\n\n## 작업 6: 그룹 정책:\n\n도메인 컴퓨터에 GPO를 배포하는 데 사용되는 네트워크 공유의 이름은 무엇인가요?\n\n정답: SYSVOL\n\n<div class=\"content-ad\"></div>\n\n네, GPO를 사용하여 사용자 및 컴퓨터에 설정을 적용할 수 있어요!\n\n답변: Yay\n\n## 작업 7: 인증 방법:\n\n현재 버전의 Windows는 기본적으로 NetNTLM을 기본 인증 프로토콜로 사용할까요? (yay/nay)\n\n<div class=\"content-ad\"></div>\n\n답변: nay\n\nKerberos를 참조할 때, TGS(Ticket Granting Ticket)라고 알려진 추가 티켓을 요청할 수 있는 티켓의 종류는 무엇입니까?\n\n답변: Ticket Granting Ticket\n\nNetNTLM을 사용할 때, 사용자의 비밀번호가 네트워크를 통해 어느 시점에든 전송되나요? (yay/nay)\n\n<div class=\"content-ad\"></div>\n\n답변: 아니오\n\n## 참고:\n\nWindows 도메인을 사용할 때 모든 자격 증명은 도메인 컨트롤러에 저장됩니다. 사용자가 도메인 자격 증명을 사용하여 서비스를 인증하려고 할 때, 서비스는 그 자격 증명이 올바른지 확인하기 위해 도메인 컨트롤러에 요청해야 합니다. Windows 도메인에서 네트워크 인증에 사용되는 두 프로토콜이 있습니다.\n\n- Kerberos: 최신 Windows 버전에서 사용됩니다. 이는 최근 도메인의 기본 프로토콜입니다.\n- NetNTLM: 호환성을 위해 유지되는 레거시 인증 프로토콜입니다.\n\n<div class=\"content-ad\"></div>\n\nNetNTLM을 사용하는 것은 더 이상 사용되지 않는 것으로 간주될 수 있지만, 대부분의 네트워크는 두 프로토콜 모두 활성화되어 있을 것입니다. 이제 각 프로토콜이 어떻게 작동하는지 자세히 살펴보겠습니다.\n\n인증에 Kerberos를 사용할 때는 다음과 같은 과정이 발생합니다:\n\n- 사용자가 자신의 사용자 이름과 암호로부터 파생된 키를 사용하여 암호화된 타임스탬프를 Key Distribution Center (KDC)에 전송합니다. KDC는 일반적으로 네트워크에서 Kerberos 티켓을 생성하는 주 도메인 컨트롤러에 설치된 서비스입니다.\n\nKDC는 Ticket Granting Ticket (TGT)를 생성하여 사용자에게 보내고, 이를 통해 사용자는 특정 서비스에 액세스하기 위해 추가 티켓을 요청할 수 있게 됩니다. 티켓을 받고 더 많은 티켓을 얻어야 한다는 것이 조금 이상해보일 수 있지만, 이를 통해 사용자는 서비스에 연결할 때마다 자격 증명을 전달하지 않고도 서비스 티켓을 요청할 수 있습니다. TGT와 함께 사용자에게 세션 키도 제공되며, 이 키를 사용자가 이후 요청을 생성하는 데 사용해야 합니다.\n\n<div class=\"content-ad\"></div>\n\nTGT는 krbtgt 계정의 암호 해시를 사용하여 암호화되므로 사용자는 해당 내용에 액세스할 수 없습니다. 암호화된 TGT에는 세션 키의 사본이 내용의 일부로 포함되어 있음을 알아두어야 합니다. KDC는 필요에 따라 TGT를 복호화하여 세션 키의 사본을 복원할 수 있기 때문에 세션 키를 저장할 필요가 없습니다.\n\n![이미지](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_16.png)\n\n2. 사용자가 공유, 웹사이트 또는 데이터베이스와 같은 네트워크 서비스에 연결하려는 경우, 해당 사용자는 KDC에게 티켓 부여 서비스(TGS)를 요청하기 위해 자신의 TGT를 사용합니다. TGS는 생성된 특정 서비스에만 연결을 허용하는 티켓입니다. TGS를 요청하기 위해 사용자는 세션 키로 암호화된 사용자 이름 및 타임스탬프, TGT 및 서비스 주체 이름(SPN)을 서버 이름 및 액세스할 서비스를 나타내는 서비스 주체 이름과 함께 보냅니다.\n\n결과적으로 KDC는 우리에게 서비스 세션 키와 함께 TGS를 보내줍니다. 이 서비스 세션 키는 우리가 액세스하려는 서비스에 인증하는 데 필요합니다. TGS는 서비스 소유자 해시로부터 파생된 키를 사용하여 암호화됩니다. 서비스 소유자는 서비스를 실행하는 사용자 또는 기계 계정입니다. TGS에는 서비스 세션 키의 사본이 암호화된 내용으로 포함되어 있어서 서비스 소유자는 TGS를 복호화하여 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<table>\n<tr>\n<th><img src=\"/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_17.png\" /></th>\n</tr>\n<tr>\n<td>3. TGS는 이제 원하는 서비스로 전송되어 인증되고 연결이 설정됩니다. 서비스는 구성된 계정의 비밀번호 해시를 사용하여 TGS를 해독하고 서비스 세션 키를 확인합니다.</td>\n</tr>\n<tr>\n<th><img src=\"/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_18.png\" /></th>\n</tr>\n<tr>\n<td>NetNTLM(NTLM 해시는 Windows 시스템에 저장된 사용자 암호의 암호화 형식입니다.) 인증</td>\n</tr>\n</table>\n\n<div class=\"content-ad\"></div>\n\nNetNTLM은 challenge-response 메커니즘을 사용합니다. 전체 과정은 다음과 같습니다:\n\n![image](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_19.png)\n\n- 클라이언트는 액세스하려는 서버에 인증 요청(도메인 이름 및 사용자 이름)을 보냅니다.\n- 서버는 무작위 숫자를 생성하여 클라이언트에게 도전 응답으로 보냅니다.\n- 클라이언트는 자신의 NTLM 암호 해시를 도전에(그리고 다른 알려진 데이터와 함께) 결합하여 도전에 대한 응답을 생성하고 서버로 돌려보냅니다.\n- 서버는 도전과 응답을 도메인 컨트롤러로 전송하여 확인합니다.\n- 도메인 컨트롤러는 응답을 다시 계산하고 클라이언트가 보낸 초기 응답과 비교하여 일치 여부를 확인합니다. 일치하면 클라이언트가 인증됩니다. 그렇지 않으면 액세스가 거부됩니다. 인증 결과가 서버로 다시 보내집니다.\n- 서버는 인증 결과를 클라이언트로 다시 전송합니다.\n\n사용자의 비밀번호(또는 해시)가 보안을 위해 네트워크를 통해 전송되지 않음에 유의하세요.\n\n<div class=\"content-ad\"></div>\n\n노트: 설명된 프로세스는 도메인 계정을 사용할 때 적용됩니다. 로컬 계정을 사용하는 경우, 서버는 SAM(보안 계정 관리자)에 비밀번호 해시가 로컬로 저장되어 있기 때문에 도메인 컨트롤러와의 상호 작용 없이 도전에 대한 응답을 확인할 수 있습니다.\n\n## 작업 8: 트리, 포리스트 및 트러스트:\n\nWindows 도메인의 이름 공간을 공유하는 그룹을 무엇이라고 하나요?\n\n답변: 트리\n\n<div class=\"content-ad\"></div>\n\n두 도메인 간에 사용자가 도메인 A에서 도메인 B의 리소스에 액세스하려면 구성해야 할 사항은 무엇인가요?\n\n답변: 2 신뢰 관계\n\n## 참고:\n\nTrees\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 갑자기 회사가 새로운 국가로 확장된다고 상상해 보세요. 새로운 국가는 다른 법률과 규정을 가지고 있어 GPO를 업데이트하여 준수해야 합니다. 게다가 이제 두 나라에 IT 직원이 있고 각 IT 팀은 다른 팀에 방해받지 않으면서 해당 국가에 해당하는 자원을 관리해야 합니다. 복잡한 OU 구조를 만들고 위임을 사용하여 이를 달성할 수 있지만, 방대한 AD 구조를 관리하기 어렵고 인간 실수가 발생할 수 있습니다.\n\n다행히도 Active Directory는 여러 도메인을 통합하여 네트워크를 독립적으로 관리할 수 있는 단위로 분할할 수 있습니다. 예를 들어 동일한 네임스페이스(thm.local)를 공유하는 두 도메인이 있다면 해당 도메인을 트리로 결합할 수 있습니다.\n\n만약 thm.local 도메인이 영국과 미국 지사를 위한 두 하위 도메인으로 분할되었다면 thm.local을 루트 도메인으로 하고 uk.thm.local 및 us.thm.local 두 하위 도메인을 가진 트리를 구축할 수 있습니다. 각각의 AD, 컴퓨터 및 사용자를 가지고 있죠:\n\n![이미지](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_20.png)\n\n<div class=\"content-ad\"></div>\n\n이 분할된 구조는 도메인 내에서 누가 무엇에 액세스할 수 있는지 더 잘 제어할 수 있게 해줍니다. 영국의 IT 직원은 영국 리소스만 관리하는 자체 DC를 갖게 될 것입니다. 예를 들어, 영국 사용자는 미국 사용자를 관리할 수 없을 것입니다. 이렇게 함으로써 각 지점의 도메인 관리자들은 각각의 DC에 대해 완전한 통제권을 갖지만 다른 지점의 DC에는 그런 권한이 없을 것입니다. 각 도메인에 대해 정책도 독립적으로 구성할 수 있습니다.\n\n트리와 포리스트에 대한 이야기를 할 때 새로운 보안 그룹을 소개해야 합니다. Enterprise Admins 그룹은 기업의 모든 도메인에 대한 관리자 권한을 부여할 것입니다(이 기업 관리자들은 영국과 미국 도메인 컨트롤러를 모두 제어할 수 있습니다). 각 도메인은 여전히 각자의 도메인에 대한 관리자 권한을 갖는 도메인 관리자들과 기업 관리자들을 가질 것이며, 이 기업 관리자들은 기업 내의 모든 것을 제어할 수 있게 됩니다.\n\n포리스트\n\n관리하는 도메인은 서로 다른 네임스페이스로 구성할 수도 있습니다. 회사가 계속 성장하면 언젠가는 MHT Inc라는 다른 회사를 인수할 수 있습니다. 두 회사가 합병하면 아마도 각 회사를 위한 서로 다른 도메인 트리가 있게 될 것이며, 각각 자체 IT 부서에 의해 관리될 것입니다. 서로 다른 네임스페이스를 갖는 여러 트리를 같은 네트워크로 병합하는 것을 포리스트라고 합니다.\n\n<div class=\"content-ad\"></div>\n\n<table>\n    <tr>\n        <td><img src=\"/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_21.png\" /></td>\n    </tr>\n</table>\n\n신뢰 관계\n\n트리와 포리스트로 구성된 여러 도메인을 보유하면 관리 및 자원 측면에서 좋은 칸막이된 네트워크를 구축할 수 있습니다. 그러나 언젠가는 THM UK의 사용자가 MHT ASIA 서버 중 하나에 공유 파일에 액세스해야 할 수도 있습니다. 이것이 가능하려면 트리와 포리스트로 구성된 도메인들은 신뢰 관계에 의해 결합됩니다.\n\n간단히 말해, 도메인 간에 신뢰 관계가 있으면 도메인 THM UK의 사용자가 도메인 MHT EU의 자원에 액세스 할 수 있도록 권한을 부여할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n가장 간단한 신뢰 관계는 일방적인 신뢰 관계를 설정하는 것입니다. 일방적인 신뢰 관계에서는 도메인 AAA가 도메인 BBB를 신뢰한다면, BBB의 사용자가 AAA의 리소스에 액세스할 권한을 부여받을 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_22.png)\n\n일방적인 신뢰 관계의 방향은 액세스 방향과 반대입니다.\n\n양방향 신뢰 관계도 만들어서 상호적으로 다른 쪽 도메인의 사용자를 인가할 수 있습니다. 기본적으로, 트리 또는 포리스트 아래 여러 도메인을 추가하면 양방향 신뢰 관계가 형성됩니다.\n\n<div class=\"content-ad\"></div>\n\n도메인 간 신뢰 관계를 가지고 있다고 해서 다른 도메인의 모든 리소스에 자동으로 접근할 수 있는 것은 아닙니다. 신뢰 관계가 설정되면 다른 도메인 간에 사용자를 인가할 수 있는 기회가 생깁니다. 그러나 실제로 무엇이 승인되었는지 여부는 사용자의 권한에 달려 있습니다. (즉, 신뢰 관계 도메인은 사용자가 어떤 유형의 데이터/파일에 액세스하거나 볼 수 있는 최소 권한을 갖습니다.)\n\n그래서, 즐거운 학습과 행운을 빕니다.\n\n더 많은 흥미로운 내용과 자세한 기사를 보려면 제 블로그를 팔로우해주세요.\n\n## LinkedIn\n\n<div class=\"content-ad\"></div>\n\n\n![2024-06-19-ActiveDirectoryBasicsTryHackMe_23](/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_23.png)\n","ogImage":{"url":"/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_0.png"},"coverImage":"/assets/img/2024-06-19-ActiveDirectoryBasicsTryHackMe_0.png","tag":["Tech"],"readingTime":16},{"title":"Windows 11의 추적 기능을 비활성화하는 방법","description":"","date":"2024-06-19 09:03","slug":"2024-06-19-HowToDisableWindows11sTrackingFeatures","content":"\n\nWindows 11에서 개인 정보 보호 보장: 단계별 안내서\n\n![이미지](/assets/img/2024-06-19-HowToDisableWindows11sTrackingFeatures_0.png)\n\nWindows 11은 이전의 마이크로소프트 운영 체제와 마찬가지로 광고, 진단 및 기타 목적을 위해 상당량의 사용자 데이터를 수집합니다. 개인 정보 보호를 중요시하고 마이크로소프트가 수집하는 데이터를 제한하고 싶다면, 이 안내서를 통해 Windows 11의 다양한 추적 기능을 비활성화하는 데 도움이 될 것입니다.\n\n# 맞춤 광고 비활성화하기\n\n<div class=\"content-ad\"></div>\n\n개인 맞춤형 광고를 해제하려면:\n\n- 설정 앱을 엽니다. 시작 버튼을 마우스 오른쪽으로 클릭하고 설정을 선택하거나 Windows 키 + I 단축키를 사용하여 이 작업을 수행할 수 있습니다.\n- 왼쪽 패널에서 \"개인 정보 및 보안\"을 선택합니다.\n- Windows 권한 아래에서 \"일반\"을 클릭합니다.\n- 다음 옵션을 해제합니다:\n\n  - 광고 ID를 사용하여 앱이 개인 맞춤형 광고를 표시하도록 허용\n  - 언어 목록에 액세스하여 로컬 관련 콘텐츠를 제공하는 웹사이트가 나에게 콘텐츠를 표시하도록 허용\n  - 앱 시작을 추적하여 시작 및 검색 결과를 개선하도록 Windows가 허용\n  - 설정 앱에서 제안된 콘텐츠를 표시하도록 허용\n\n위 설정을 비활성화하면 여전히 광고를 볼 수 있지만 사용자 행동에 기반한 대상 지정이 되지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n# 진닑 데이터 수집 줄이기\n\n다음 단계를 따라 진닑 데이터 수집을 제한하세요:\n\n- 설정 앱에서 개인 정보 및 보안으로 이동합니다.\n- Windows 권한 아래에서 진닑과 피드백을 선택합니다.\n- 선택 사항 진닑 데이터 보내기를 끕니다. 이것은 또한 메모와 입력 개선을 비활성화합니다.\n- 맞춤형 경험을 끄면 진닑 데이터를 사용하여 개인화 된 팁, 광고 및 추천을 받지 않게 할 수 있습니다.\n- Microsoft가 진닑 데이터의 사본을 사용하지 못하도록 하려면 진닑 데이터 삭제를 클릭하세요.\n\n# 활동 추적 비활성화하기\n\n<div class=\"content-ad\"></div>\n\n활동 추적은 개인 정보 보호에 관련된 중요한 문제가 될 수 있습니다:\n\n- 설정 앱에서 개인 정보 및 보안을 선택합니다.\n- 아래로 스크롤하여 활동 기록을 선택합니다.\n- Microsoft에 내 활동 기록 보내기를 꺼서 사용하는 앱 및 서비스, 그리고 방문하는 웹사이트에 대한 데이터 수집을 방지할 수 있습니다.\n\n# 내 기기 찾기 끄기\n\n분실된 기기를 찾는 데 유용하지만, 내 기기 찾기도 위치 데이터를 업로드합니다:\n\n<div class=\"content-ad\"></div>\n\n- 개인정보 및 보안에서 '내 기기 찾기'를 선택하세요.\n- Microsoft가 위치를 추적하지 않으려면 스위치를 끄세요.\n\n# Microsoft Edge에서 추적 줄이기\n\nEdge에서 브라우징할 때 추적기를 차단하려면:\n\n- 우측 상단에 있는 세 점 메뉴 아이콘을 클릭하세요.\n- 드롭다운 메뉴에서 설정을 선택하세요.\n- 왼쪽 패널에서 '개인정보, 검색 및 서비스'를 선택하세요.\n- 추적 방지 기능을 활성화하고 필요에 맞는 수준을 선택하세요. 일반 사용자를 위해 균형있게 권장하는 것이 바람직하지만, 엄격한 수준은 대부분의 추적기를 차단하지만 일부 웹사이트 기능을 깨뜨릴 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 마이크로소프트 계정에서 데이터 지우기\n\n마이크로소프트 계정과 연결된 데이터를 삭제하려면:\n\n- 모든 브라우저를 열고 account.microsoft.com 으로 이동합니다.\n- 계정에 로그인합니다.\n- 상단바에서 **개인정보**를 클릭합니다.\n- 활동 데이터 관리로 스크롤하여 내려갑니다.\n- 첫 네 가지 범주에 초점을 맞춥니다: 위치 활동, 브라우징 기록, 검색 기록 및 앱 및 서비스 활동.\n- 각 범주에 대해 **모두 지우기** 를 선택합니다. 예를 들어, 브라우징 기록을 지우려면, **모두 브라우징 활동 지우기** 를 클릭한 후 확인을 위해 **지우기** 를 클릭합니다. 또한 데이터를 30일마다 자동으로 지우도록 설정할 수 있습니다.\n\n이러한 단계를 따르면 Windows 11에서 개인 정보 보호를 크게 향상시킬 수 있습니다. 만약 이 안내서가 도움이 되었다면 좋아요를 눌러주시고 다른 사람들과 공유해주세요. 여전히 개인 정보 보호를 우선시하는지 또는 현대 기술의 일환으로 데이터 수집을 수용했는지를 댓글로 알려주세요. 최신 Windows 11 및 기술 관련 비디오를 업데이트하려면 채널을 구독하지 않도록 잊지 마세요.","ogImage":{"url":"/assets/img/2024-06-19-HowToDisableWindows11sTrackingFeatures_0.png"},"coverImage":"/assets/img/2024-06-19-HowToDisableWindows11sTrackingFeatures_0.png","tag":["Tech"],"readingTime":3},{"title":"윈도우 포렌식 오피스 문서","description":"","date":"2024-06-19 09:02","slug":"2024-06-19-WindowsForensicsOfficeDocuments","content":"\n\n# Windows 포렌식 - 파일/폴더 오픈, 응용프로그램 실행과 관련된 증거\n\n## 개요\n\n이 글은 프리패치 파일부터 셸 항목 및 레지스트리 분석까지 여러 가지를 다룰 것입니다. 우리는 대상 사용자가 Microsoft Office 제품을 실행하고 Word 문서와 활발히 작업한 사실을 보여줄 것입니다. 마지막으로 우리는 Word에서 사용자가 본 정확한 페이지를 확인하고 해당 페이지를 우리 자신의 기계에서 재작성하여 용의자 사용자가 마지막으로 본 것을 확인할 수 있게 될 것입니다.\n\n## 시스템에서 Microsoft Office 제품이 실행되었는지 확인하는 방법\n\n<div class=\"content-ad\"></div>\n\n## 사전 로드 파일\n\n사전 로드 파일은 응용 프로그램 실행에 대한 자세한 정보를 제공합니다. 그들의 주요 기능은 응용 프로그램의 일부 메모리를 디스크에 기록하여 사용자가 특정 응용 프로그램을 두 번째로 실행할 때 일부 데이터가 이미 캐싱되어 있어 더 빨리 시작되도록 하는 것입니다. 사전 로드가 캐시하는 정보는 다음과 같습니다:\n\n- 로드된 DLL\n- 응용 프로그램이 상호 작용한 다른 파일(다른 PE 파일 포함)\n- 응용 프로그램이 상호 작용한 디렉터리의 상대 경로\n- 응용 프로그램을 실행한 횟수\n- 응용 프로그램을 실행한 마지막 8개의 타임스탬프\n- 파일 시스템 타임스탬프(생성, 수정, 액세스)\n- 파일 크기\n- 응용 프로그램 해시\n- 볼륨 정보\n\n사전 로드 파일은 C:\\Windows\\Prefetch에 저장되며 파일 확장자는 .pf입니다. 이것이 우리가 시작할 지점이 될 것이며, 대상 시스템에서 Office 제품이 실행되었는지 확인할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n에릭 짐머만의 PECmd 도구를 사용하면 전체 디렉토리를 구문 분석하여 CSV 파일로 출력하거나 한 번에 하나의 .pf 파일을 구문 분석할 수 있습니다. 우리는 사무 문서에만 관심이 있기 때문에 Microsoft Word용 prefetch 파일 하나를 구문 분석할 것입니다.\n\n## Word Prefetch (Application Execution)\n\n```js\n# 하나의 prefetch 파일을 구문 분석하는 구문\npecmd -f $파일\n```\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_0.png)\n\n<div class=\"content-ad\"></div>\n\n가장 먼저 지적하고 싶은 것은 최근 실행된 타임스탬프와 파일 시스템 수정된 타임스탬프 간의 불일치입니다. 이론적으로는 응용 프로그램이 실행될 때 NTFS 파일 시스템에서 수정된 타임스탬프가 업데이트되므로 이러한 타임스탬프는 일치해야 합니다. 그러나 최근 실행 시간이 파일 시스템보다 2초 빠르게 기록되었습니다. 이것은 중요한 고려 사항이며 파일 시스템 타임스탬프만 놓고 보면 고려해야 할 사항입니다. 실행 후 파일 시스템이 수정된 시간을 업데이트하기까지 최대 10초가 소요될 수 있습니다.\n\n이제 우리는 컴퓨터에서 Word가 실행되었음을 알고 있으며 다음과 같은 세부 사항이 있습니다:\n\n- Word가 23번 실행되었습니다\n- 최근 실행 시간은 2024년 5월 30일 12:50:01에 있었습니다 (모든 타임스탬프는 UTC, 24시간 형식입니다)\n- 볼륨 GUID\n- 그리고 응용 프로그램이 상호 작용한 디렉토리 및 파일 목록 (스크린샷에 포함되지 않음)\n\n# 문서가 열렸는지 확인하기\n\n<div class=\"content-ad\"></div>\n\n## 바로 가기 파일 (LNK)\n\nWord가 열려 있다고 해서 그와 함께 문서가 열리는 것은 아닙니다. LNK 파일을 활용하여 어떤 문서가 열렸는지 추측하는 데 도움을 받을 수 있습니다. 이러한 증거들은 사용자의 프로필에 저장됩니다: C:\\Users\\$user\\AppData\\Roaming\\Microsoft\\Windows\\Recent.\n\nLNK 파일은 파일이나 폴더가 열릴 때 기록이 되며, 제어판 앱도 포함됩니다. 이러한 쉘 항목들은 다음을 기록합니다:\n\n- 파일 시스템 타임스탬프\n- 대상 타임스탬프 (쉘 항목은 대상 파일을 가리키며, LNK 파일은 실제로 다른 개체에 액세스하는 방법에 대한 메타데이터를 저장)\n- 파일 크기, 속성 및 플래그\n- 대상 파일의 상대 경로\n- 대상 파일의 작업 디렉토리\n- 볼륨 정보\n- 그리고 $MFT 레코드 정보\n\n<div class=\"content-ad\"></div>\n\n에릭 짐머만의 도구 중 하나인 LECmd를 사용하여 이 파일들을 구문 분석할 수 있습니다.\n\n```js\n# LECmd 사용법\nlecmd -f $file\n```\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_1.png)\n\n위 스크린샷에서 우리는 CIRT_SOP.docx라는 문서를 위한 LNK 파일을 볼 수 있습니다. 이 파일이 마지막으로 수정된 날짜는 Word가 마지막으로 실행된 날짜와 같음을 알 수 있습니다. 하나 이상의 문서가 열렸다는 것을 알기 때문에 사용자 레지스트리를 확인하여 파일이 마지막으로 열리고 닫힌 시간을 결정할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 파일 활동 기간 결정하기\n\n사용자의 NTUSER.dat 파일에서 Microsoft Office 문서와 관련된 레지스트리 키를 찾을 수 있습니다. 주로 이러한 키들은 NTUSER\\Software\\Microsoft\\Office\\16.0\\Word 경로에 있습니다.\n\n## 파일이 마지막으로 열린 날짜\n\n저는 Microsoft 365 계정을 사용하고 있기 때문에 NTUSER\\Software\\Microsoft\\Office\\16.0\\Word\\File MRU에는 문서가 나열되지 않습니다. 대신 개인 Office 365 라이선스와 관련된 키를 참조해야 합니다: NTUSER\\Software\\Microsoft\\Office\\16.0\\Word\\User MRU\\LiveId_$hash\\File MRU. 이 항목들은 가장 최근에 사용된 순서대로 나열됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지 1](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_2.png)\n\n파일이 처음 열린 시간을 나타내는 타임스탬프는 64비트 FILETIME에서, big endian 형식으로 “T” 뒤에 나오는 바이트 입니다. 아래 화면은 아이템 1에 대한 디코딩된 시간을 보여줍니다.\n\n![이미지 2](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_3.png)\n\n![이미지 3](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n## 파일 종료 날짜\n\n파일이 마지막으로 닫힌 날짜를 확인하려면 다른 레지스트리 키인 NTUSER\\Software\\Microsoft\\Office\\16.0\\Word\\Reading Locations로 전환해야 합니다. 각 문서에는 중요한 하위 키/값 쌍을 포함하는 자체 하위 키가 생성됩니다.\n\n![image](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_5.png)\n\n![image](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_6.png)\n\n<div class=\"content-ad\"></div>\n\nDatetime에 나열된 값에 유의하세요. 이 값은 시스템의 로컬 시간입니다 (정확한 시스템 프로필링이 반드시 필요함을 증명합니다). Datetime에 나열된 시간을 UTC로 변환하면 레지스트리의 마지막 쓰기 시간 (2024–05–30 20:45:56)과 일치하는 것을 볼 수 있습니다. 이것은 파일이 마지막으로 닫힌 시간입니다.\n\nPosition 값은 사용자가 마지막으로 보고 있던 문서의 위치를 기록합니다. 이것은 Word가 시행하는 \"이전에 멈췄던 곳부터 다시 시작\" 기능입니다. 이론적으로, 사용자가 마지막으로 머물렀던 정확한 페이지를 결정할 수 있습니다:\n\n- 해당 대상 파일을 우리 시스템으로 복사\n- 문서를 열기\n- 문서를 닫아 우리의 NTUSER 하이브에 기록되도록 함\n- 용의자의 NTUSER 하이브에서 Position 값 복사하여 우리 NTUSER 하이브로 이동.\n\n# 문서의 마지막 위치 결정\n\n<div class=\"content-ad\"></div>\n\n일하고 있는 문서를 추적 중이었던 것이 회사 작업을 위해 작업 중이던 것이기 때문에 사용자가 마지막으로 중지한 위치를 확인할 때 concept 확인을 위해 다른 문서로 전환할 것입니다. Reading Locations에 나열된 Document 1이라는 파일을 사용할 것입니다.\n\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_7.png)\n\n\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_8.png)\n\n\n\n![이미지](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_9.png)\n\n\n<div class=\"content-ad\"></div>\n\n이론적으로는 Position에 나열된 값과 일치하도록 변경하여 사용자가 마지막으로 보고 있던 내용을 복원할 수 있어야 합니다.\n\n![image1](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_10.png)\n\n이제 파일을 다시 열 때, 우리는 중단했던 곳부터 이어서 작업할 것을 요청받아야 합니다.\n\n![image2](/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_11.png)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_12.png\" />\n\n# 이 기사의 목적\n\n저는 이 기사를 쓴 이유는 학습하고 있는 개념을 강화하고 있는 것인데, 메모에 너무 의존하는 것을 줄이고 지식을 내재화하는 노력에 있습니다. 사용자가 마지막으로 머물렀던 정확한 페이지를 확인할 수 있는 것이 가능하다는 것을 알게 되었을 때 정말 멋있었고, HackTheBox 머신에서 사용자/루트 쉘을 얻는 것보다 더 흥미로웠습니다. 이 글을 통해 새로운 지식을 얻거나 흥미를 느낀 사람이 있다면 좋겠습니다. 배운 것들을 다른 사람들과 공유해주세요!","ogImage":{"url":"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_0.png"},"coverImage":"/assets/img/2024-06-19-WindowsForensicsOfficeDocuments_0.png","tag":["Tech"],"readingTime":6},{"title":"쉘코드 삽입 및 악성 코드 역분류에 대한 기본 소개","description":"","date":"2024-06-19 09:00","slug":"2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware","content":"\n\n안녕하세요! 이 게시물의 목적은 제가 배우고 있는 연구 및 개발 방법 중 일부를 공유하는 것입니다!\n\n오늘은 Windows 앱, 드라이버, 심지어 커널 자체에 대한 강력한 디버깅 솔루션인 WinDbg의 사용에 대해 이야기하고 싶었습니다. WinDbg를 좋아하는 한 가지 이유는 도구가 매우 유연하며 체계적인 시스템 분석을 위한 놀라운 기능이 포함되어 있다는 것입니다.\n\n몇 가지 예시를 제공하기 위해, 'AAAA'를 notepad.exe의 주소 공간에 간단히 주입하는 간단한 셸코드 주입 프로그램을 만들어 보았습니다. 선택한 프로그램이 시스템에서 실행 중이고 보호받는 프로세스가 아닌 한 사용할 수 있습니다!\n\n참고: 이러한 기술을 배우는 데 도움을 준 MalDev Academy 및 멋진 YT 채널을 운영하는 cr0w에게 감사드립니다!\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png)\n\n프로그램 실행 후에 보이는 것처럼, 이 프로그램은 PID를 매개변수로 사용하고 핸들을 획득한 다음 할당된 메모리에 쉘코드를 주입하여 코드 실행을 달성합니다!\n\n더 나아가기 전에 현대 시스템에서는 어떤 종류의 합법적인 쉘 코드도 대부분의 보안 제품을 우회하기 위해 강력하게 난독화되어야 하거나, 디스크나 메모리의 별도 위치에 저장되어야 할 것으로 강조하고 싶습니다. 이것은 단순한 개념 증명일 뿐입니다.\n\n프로그램의 기본 개요는 아마도 쉘 코드를 주입하는 가장 일반적인 방법을 따릅니다:\n\n\n<div class=\"content-ad\"></div>\n\n- 해당 PID로 프로세스를 식별하고 핸들을 획득합니다.\n- 그 프로세스의 가상 주소 공간 내에서 RWX 권한으로 메모리를 할당합니다.\n- 쉘 코드의 내용을 버퍼에 쓰고 그것을 할당된 메모리 공간에 전달합니다.\n- 생성 및 호출하여 페이로드가 실행될 스레드를 만들어 실행을 트리거합니다.\n\n![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_1.png)\n\n위는 우리 프로그램의 \"Main\"이라는 단어를 포함하는 여러 기능들의 분해입니다. 여기서 \"x `프로그램이름`!`함수이름`\" 명령을 사용하여 이를 달성합니다. \n\n주소가 a5f00으로 끝나는 곳에서 우리 main 함수의 진입점을 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_2.png)\n\n메인 함수에 중단점을 설정하고 실행을 계속한 후, 프로그램을 분해하여 현재 레지스터 값들을 검사할 수 있습니다. 여기서 소스 코드 왼쪽에 할당된 변수를 NULL로 설정했다고 알 수 있습니다. 오른쪽에는 스택에 반영된 할당이 보이며, 값 0이 스택의 기본 위치로부터 다양한 오프셋에 저장되는 것을 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_3.png)\n\n여기서 \"cmp\" 명령어를 볼 수 있는데, 이는 결국 인수 개수 함수입니다. 인수 개수가 2와 일치하면 함수가 실행되고, 그렇지 않으면 사용법 라인에 정의된 문자열을 출력합니다.\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_4.png\" />\n\n위 캡처에서는 특정 메모리 주소에 포함된 값들을 표시할 수 있습니다. 여기서는 db 명령어 뒤에 주소를 넣어 해당 내용을 바이트로 표시합니다. 하지만 \"display as ascii\"를 위해 da를 활용할 수도 있습니다.\n\n이 메모리 주소로부터 함수가 계속 실행되는 동안 어떤 문자열이 출력되는지 확인할 수 있습니다.\n\n<img src=\"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_5.png\" />\n\n<div class=\"content-ad\"></div>\n\n이제 페이로드 저장에 대해 이야기하겠습니다. 한 발 물러서서 rep movs 명령어를 강조하고 싶어요. 우리가 인자 수를 비교하기 전에 우리의 ECX 또는 카운터 레지스터에 값 5를 할당했다는 것을 주목하세요. 그리고 나서 우리는 반복적으로 스택으로 한 번에 한 바이트씩 복사합니다.\n\n우리의 페이로드는 AAAA로만 구성되어 있으므로, 왜 5라는 값이 우리의 페이로드에서 몇 바이트를 복사할지 결정하는 데 사용되는 걸까요? 이 5번째 바이트는 아마도 우리의 페이로드가 NULL 종료된 문자열이라는 사실을 고려하기 때문에, 마지막으로 복사해야 하는 바이트는 NULL 바이트일 것입니다.\n\n이와 마지막으로, 페이로드 식별에 대해서 이야기할게요. \"dd/db\" 명령을 활용하여 특정 레지스터의 내용을 표시할 수 있어요! 이렇게 멋진 걸요! 그래서 프로그램 실행을 따라가면서 레지스터가 어떻게 변하는지, 어떤 값이 저장되는지를 살펴볼 수 있고, 아마도 프로그램이 무엇을 하는지 추측할 수도 있어요.\n\n<div class=\"content-ad\"></div>\n\nRAX 레지스터에 저장된 페이로드의 바이트 및 ASCII 내용을 공개함으로써 거기에 4개의 A가 있다는 것을 확인할 수 있습니다.\n\n마지막으로: 이 WinDbg 프로그램에서 할 수 있는 작업은 스택 추적을 검토하거나 레지스터를 조작하거나 API 호출 및 그 매개변수를 찾는 등 훨씬 더 많습니다. 저는 기본적인 분석 기술을 강조하고 앞으로 더 복잡한 주제를 탐구할 것을 희망합니다. 또한, ProcessHacker2나 일부 Sysinternals 도구와 같은 도구를 사용하여 프로그램을 실행하는 동안 메모장 메모리 내용을 검토하거나 페이로드가 삽입되는 방식 및 스레드가 호출되거나 호출되는 방식을 파악할 수도 있습니다.\n\n읽어 주셔서 감사합니다!","ogImage":{"url":"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png"},"coverImage":"/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png","tag":["Tech"],"readingTime":4},{"title":"HomeBrew를 사용하여 MacOS2021에 Java JDK11을 설치하는 방법","description":"","date":"2024-06-19 08:59","slug":"2024-06-19-UsingHomeBrewtoInstallJavaJDK11onMacOS2021","content":"\n\n제목이 정확히 같은 게시물이 있지만 조금 오래됐기 때문에 최신 솔루션을 구글링하는 사람들을 위해 약간 수정된 버전을 게시하고 싶습니다.\n\n## 단계 1: Homebrew 설치 (아직 하지 않은 경우)\n\n```js\n$ /bin/bash -c “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)” \n```\n\n## 단계 2: 업데이트 (아직 하지 않은 경우)\n\n<div class=\"content-ad\"></div>\n\n```js\n$ brew update\n```\n\n## 단계 3: Java11 설치\n\n```js\n$ brew install java11\n```\n\n## 단계 4: Symlink 설정하기\n\n<div class=\"content-ad\"></div>\n\n만약 이 단계를 건너뛰면 시스템이 사용할 자바 런타임을 찾지 못할 수 있어요.\n\n```js\nsudo ln -sfn /usr/local/opt/openjdk@11/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-11.jdk\n```\n\n## 단계 5: 테스트\n\n버전 플래그를 사용하여 명령을 입력한 후 비슷한 내용을 보신다면 성공적으로 진행된 거예요! 🙂\n\n<div class=\"content-ad\"></div>\n\n```js\n$ java --version\nopenjdk 11.0.10 2021-01-19\nOpenJDK Runtime Environment (build 11.0.10+9)\nOpenJDK 64-Bit Server VM (build 11.0.10+9, mixed mode)\n```\n\n문제가 발생하면 저에게 알려주시면 이 안내서를 업데이트할 수 있습니다. 좋은 하루 보내세요!\n","ogImage":{"url":"/assets/img/2024-06-19-UsingHomeBrewtoInstallJavaJDK11onMacOS2021_0.png"},"coverImage":"/assets/img/2024-06-19-UsingHomeBrewtoInstallJavaJDK11onMacOS2021_0.png","tag":["Tech"],"readingTime":1},{"title":"Windows 10에서 DMG를 USB에 불러 넣는 모든 가능한 방법","description":"","date":"2024-06-19 08:57","slug":"2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10","content":"\n\n만일 당신이 맥 사용자이라면, DMG에 익숙할 것입니다. 사실, 이는 소프트웨어 및 OS 설치에 사용할 수 있는 가장 인기 있는 macOS 파일 형식 중 하나입니다.\n\n긴급한 경우, 맥이 고장 났거나 제대로 작동하지 않을 때 문제를 해결하는 데 매우 효과적입니다. DMG 파일로부터 부팅 가능한 macOS 부팅 USB를 만들어 문제를 해결할 수 있습니다. OS 재설치는 일반적인 문제의 대부분을 해결할 것입니다. 이는 맥에 내장된 creatinstallmedia 명령으로 쉽게 할 수 있지만, 윈도우에서는 훨씬 더 어려운 작업입니다. 이 글은 윈도우 10 PC에서 DMG를 USB 드라이브로 복사하는 방법에 대한 내용입니다.\n\n![그림](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_0.png)\n\n참고로, DMG는 Apple의 독점 디스크 이미지 형식이며, 윈도우에서 기본적으로 지원되지 않습니다. 그래서 PC에서 DMG 파일을 USB에 복사하는 것이 어려운 이유입니다.\n\n<div class=\"content-ad\"></div>\n\n좌절하지 마세요. PC에서 작업을 완료할 수 있는 몇 가지 해결책이 아직도 있습니다. 이 튜토리얼에서는 macOS DMG 파일을 macOS 또는 Windows 10에 USB에 불러오는 단계를 안내해 드릴 거예요. 먼저 쉬운 해결책으로 시작해볼게요.\n\n# UUByte DMG Editor: DMG를 USB 또는 DVD에 불러오는 크로스 플랫폼 소프트웨어\n\nUUByte DMG Editor는 데이터를 손상시키지 않고 Windows와 macOS 모두에서 DMG 파일을 USB 드라이브에 불러올 수 있게 도와주는 전문 도구에요. 이 도구가 다른 경쟁 업체와 다른 점은 사용하기 쉬운 인터페이스와 속도에 있어요. 실제로 매우 빠릅니다. 필요한 것은 몇 번의 클릭 뿐이에요.\n\n이 도구는 기술적 전문 지식이 필요하지 않아요. Windows와 macOS를 동시에 사용하고 있는 입문자를 위해 특별히 설계되었어요. UUByte DMG Editor는 macOS 부팅 가능 USB 드라이브를 만들어 macOS를 어떤 Mac 기기에도 설치할 수 있게 해줘요.\n\n<div class=\"content-ad\"></div>\n\nWin 다운로드: [다운로드 링크](https://www.uubyte.com/download/dmg-editor.exe)\n\nMac 다운로드: [다운로드 링크](https://www.uubyte.com/download/dmg-editor.dmg)\n\n단계 1: Windows 10 컴퓨터에서 도구를 다운로드하고 평소와 같이 설치하세요. 이 도구는 이제 무료 평가판과 유료 버전을 제공합니다. 무료 버전은 도구 사용에 제한이 있으므로, 더 많은 고급 기능과 안정성을 제공하는 유료 버전을 선택하는 것을 권장합니다.\n\n단계 2: 이제 USB 드라이브를 Windows 10 PC에 넣으세요. USB 드라이브의 저장 용량이 적어도 16GB 이상이어야 하며 도구를 실행하세요.\n\n<div class=\"content-ad\"></div>\n\n스텝 3: 메인 메뉴에서 Burn 버튼을 선택한 후 USB 드라이브에 복사하려는 macOS DMG 파일을 선택합니다.\n\n![이미지](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_1.png)\n\n스텝 4: Burn 버튼을 클릭하면 도구가 DMG 파일을 USB 드라이브에 복사하기 시작합니다 (본 프로세스는 완료까지 몇 초 정도 소요됩니다).\n\n![이미지](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_2.png)\n\n<div class=\"content-ad\"></div>\n\n5단계: 이제 USB 드라이브에서 Mac을 부팅하고 해당 Mac에 macOS를 설치할 수 있습니다.\n\n## 장점:\n- 훌륭한 UI 디자인을 갖춘 간단한 단계.\n- macOS Big Sur, Catalina, Mojave 및 High Sierra를 지원합니다.\n- 매우 빠른 속도로 빠르고 시간을 절약할 수 있습니다.\n- Windows 10을 완전히 지원하며 오류가 적습니다.\n\n## 단점:\n\n<div class=\"content-ad\"></div>\n\n- 유료 소프트웨어.\n\n# AnyBurn: DMG 파일을 USB로 복사하는 무료 도구\n\nAnyBurn은 Mac과 Windows 모두에서 DMG 파일을 USB에 복사하는 데에 좋은 도구입니다. 가장 좋은 점은 가정 및 비즈니스용으로 완전히 무료이므로 프리미엄 기능을 지원하면서도 돈을 내지 않아도 된다는 것입니다. UUByte DMG Editor와의 차이점은 매우 가볍지만 여전히 다양한 복사 도구를 제공한다는 것입니다. 이 경우 AnyBurn을 사용하여 macOS DMG 파일을 USB 드라이브에 복사할 수 있습니다. 아래는 진행 방법입니다:\n\n단계 1: 컴퓨터에서 AnyBurn을 실행하고 부팅 가능한 USB 드라이브 만들기를 클릭하세요.\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_3.png)\n\n단계 2: 부팅 가능한 USB 드라이브 창에서 Windows 컴퓨터의 macOS DMG 파일을 선택합니다. 도구는 현재 컴퓨터에 연결된 모든 드라이브를 나열할 것입니다. 컴퓨터에 삽입한 드라이브를 선택하고 써진 데이터 확인 옵션 옆에 체크하세요.\n\n![이미지](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_4.png)\n\n단계 3: 'Burn' 버튼을 클릭하면 도구가 DMG 파일을 삽입된 USB 드라이브에 불를 붙이기 시작합니다. 과정 중에 진행률 표시 막대가 표시됩니다.\n\n<div class=\"content-ad\"></div>\n\n## 장점:\n\n- 무료입니다.\n- 이미지 복사 및 붙여넣기를 위한 더 많은 기능이 있습니다.\n\n## 단점:\n\n- 파일 불러오기 속도가 훨씬 느립니다.\n- 실행하려면 관리자 권한이 필요합니다.\n- 사용자 인터페이스가 오래되었습니다.\n\n<div class=\"content-ad\"></div>\n\n# TransMac: Windows 전용 프로그램으로 DMG 파일을 USB 드라이브에 복원 및 불러오기\n\nTransMac는 Windows에서 DMG 파일을 USB에 불러오는 좋은 옵션이에요. 이 도구는 수년간 사용되어 왔으며, Windows 사용자들을 위한 여러 훌륭한 기능을 제공하고 있어요. DMG 파일을 만들고 압축하며 확장하고 분할하는 기능을 포함하고 있어요.\n\nTransMac는 무료가 아니에요. 현재 사용자 라이선스는 59달러로, 위에 나열된 방법보다 더 비싸요. 그러나 15일 무료 평가판을 제공하고 있으며, 평가판을 사용하려면 신용카드를 등록해야 하기 때문에 다소 귀찮을 수 있어요.\n\n시작하기 전에, 이제 16GB 저장 공간을 가진 USB 드라이브가 있고 드라이브에 중요한 것이 없는지 확인하세요. 프로세스가 드라이브의 모든 것을 삭제할 거에요.\n\n<div class=\"content-ad\"></div>\n\nTransMac을 설치하고 PC에서 실행하세요. 관리자 권한으로 실행하고 USB 드라이브를 컴퓨터에 삽입하세요.\n\n![image](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_5.png)\n\n메인 창에서 왼쪽 패널에서 USB 드라이브를 마우스 오른쪽 버튼으로 클릭한 다음, 디스크 이미지 복원 옵션을 선택하세요. 팝업에서 Yes를 클릭한 후 DMG 파일을 선택하세요. 그 후에 OK 버튼을 눌러 Windows 10 PC에 DMG 파일을 USB에 복사하는 작업을 시작하세요.\n\n## 장점:\n\n<div class=\"content-ad\"></div>\n\n- 무료 체험이 가능합니다.\n- dmg 파일을 열고 압축 해제할 수 있습니다.\n- USB를 맥 파일 시스템으로 포맷할 수 있습니다.\n\n## 단점:\n\n- 너무 비싸요.\n- 사용 중 많은 오류가 발생합니다.\n- 사용하기 어렵습니다.\n\n# VMWare Workstation: macOS 가상 머신에서 DMG를 USB에 기록하기\n\n<div class=\"content-ad\"></div>\n\nWindows 사용자라면 macOS 가상 머신을 생성한 후 내장 명령을 사용하여 DMG 파일을 USB 드라이브에 불 수 있습니다. Windows에서 macOS VM을 만드는 두 가지 방법이 있습니다. VMWare Workstation과 VirtualBox를 사용할 수 있는데, 아래 섹션에서는 VMWare 방법을 사용할 것입니다.\n\n시작하기 전에 VMWare Workstation Pro 및 macOS Unlocker V3가 설치된 컴퓨터를 준비하세요. 또한 macOS Big Sur IOS 파일이 필요합니다. 이 파일은 다음 링크에서 다운로드할 수 있습니다.\n\nmacOS Unlocker를 다운로드하고 나면 win-install.cmd를 마우스 오른쪽 버튼으로 클릭하고 \"관리자 권한으로 실행\"을 선택하세요.\n\n## Windows 10 PC에서 macOS 가상 머신 만들기\n\n<div class=\"content-ad\"></div>\n\n단계 1: 이제 컴퓨터에서 VMWare를 실행하고 새 가상 머신 만들기를 클릭한 다음 Typical (권장) 옆에 있는 상자를 선택해주세요.\n\n단계 2: 여기서 운영 체제를 나중에 설치하겠다고 선택하고 다음을 클릭해주세요. 그 후에 게스트 운영 체제 목록에서 macOS X를 선택하고 다음 버튼을 클릭해주세요.\n\n단계 3: 가상 머신에 이름을 입력해주세요. 이 경우 \"macOS Big Sur\"를 입력하고 가상 머신을 저장할 위치를 선택해주세요. 그런 다음 다음 버튼을 클릭하고 다음 단계로 진행해주세요.\n\n단계 4: 가상 머신의 디스크 크기를 지정하고 가상 디스크를 단일 파일로 저장하는 옵션 옆에 있는 상자를 선택한 후 다음을 클릭해주세요.\n\n<div class=\"content-ad\"></div>\n\n5단계: 다음 창에서 '하드웨어 사용자 정의'를 클릭한 후에 가상 머신의 메모리를 4GB에서 8GB로 조정해주세요. 윈도우에서 실행 중인 가상 머신에 대한 성능을 높일 수 있습니다.\n\n6단계: 이어서 '프로세서'를 선택한 후 CPU 프로세서를 2코어에서 4코어로 늘려주세요. 그 후 'ISO 이미지 파일 사용' 옵션 옆에 체크를 하고 '찾아보기'를 클릭해주세요.\n\n![이미지](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_6.png)\n\n7단계: 이제 macOS Big Sur ISO 파일을 선택하고 '열기'를 눌러주세요. 작업을 마치면, '닫기'를 클릭하여 하드웨어 창을 닫아주세요.\n\n<div class=\"content-ad\"></div>\n\n**단계 8:** 새 가상 머신 마법사 창에서 완료를 클릭하세요. 그 후 macOS Big Sur VM 폴더를 찾아 macOS Big Sur.vmx를 클릭하고 메모장을 통해 열어주세요.\n\n**단계 9:** 이제 메모장 아래로 스크롤하여 다음 코드를 추가한 후 저장을 클릭하세요.\n\n\nsmbios.reflectHost = “TRUE”\nhw.model = “MacBookPro14,3”\n\n\n<div class=\"content-ad\"></div>\n\nboard-id = “Mac-551B86E5744E2388”\n\nsmc.version = “0”\n\nStep 10: 이제 VMWare를 열어 macOS VM에서 Windows에서 이 가상 머신의 전원을 켜고 macOS Big Sur가 부팅 될 때까지 기다립니다.\n\n![이미지](/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_7.png)\n\n<div class=\"content-ad\"></div>\n\n**단계 11:** 초기 설정을 진행하여 디스크 유틸리티 옵션을 보게 될 때까지 이어주세요. 해당 옵션을 클릭하고 계속을 눌러주세요.\n\n**단계 12:** 이제 VMware Virtual SATA Hard Drive Media를 선택하고 지우기를 클릭하세요. 여기서 macOS Big Sur를 입력한 다음, 포맷 드롭다운 목록에서 APFS를 선택하고 지우기를 클릭하세요.\n\n**단계 13:** 완료를 클릭한 후 디스크 유틸리티를 종료하고 macOS 설치를 클릭하세요. 윈도우에서 macOS VM 설치를 완료하기 위해 단계를 따라 진행하세요.\n\n## macOS 가상 머신에서 DMG를 USB에 불러오기\n\n<div class=\"content-ad\"></div>\n\nStep 1: macOS 가상 머신이 Windows에서 실행 중이라면, 이제 터미널을 사용하여 DMG 파일을 USB에 복사할 수 있어요.\n\nStep 2: USB 드라이브를 PC에 연결하고 터미널을 열어주세요. 여기서 다음 명령을 실행해주세요:\n\nsudo /Applications/Install\\ macOS\\ Big\\ Sur.app/Contents/Resources/createinstallmedia — volume /Volumes/MyVolume\n\n· MyVolume을 USB 드라이브의 이름으로 바꿔주세요.\n\n<div class=\"content-ad\"></div>\n\n3단계: Return을 누르고 관리자 암호를 입력하세요. 그 후에 드라이브를 지우려면 y를 입력하고 OK를 클릭하세요.\n\n만일 처음 세 가지 방법이 모두 실패한다면, 가상 머신 소프트웨어를 사용하여 작업을 완료하는 것은 권장되지 않습니다. 그런데 이미 PC에 macOS 가상 머신이 있다면 이 방법을 고려해볼 수 있습니다.\n\n[업데이트] 누군가가 dmg 파일을 ISO로 변환하고 ISO를 USB에 ISO 복사 도구로 불을 수 있는 가능한 해킹 방법을 보고했습니다. 이를 무료 도구 dmg2img 명령줄 유틸리티로 수행할 수 있습니다. 그러나 저는 이 방법으로 성공한 적이 없습니다.","ogImage":{"url":"/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_0.png"},"coverImage":"/assets/img/2024-06-19-AllPossibleWaystoBurnDMGtoUSBonWindows10_0.png","tag":["Tech"],"readingTime":7},{"title":"맥을 더 빠르게 만드는 방법 macOS Ventura","description":"","date":"2024-06-19 08:56","slug":"2024-06-19-HowtoSpeedUpYourMacWithmacOSVentura","content":"\n\n## macOS 13.1 Venture에서 맥을 빠르게 하는 다섯 가지 방법\n\n<img src=\"/assets/img/2024-06-19-HowtoSpeedUpYourMacWithmacOSVentura_0.png\" />\n\n이 기사에서는 macOS Ventura 속도를 최적화하는 방법을 살펴보겠습니다. 보통 나는 내 맥을 완벽하게 만족하지만 13.1 버전으로 업데이트한 후에 부팅 중 간헐적으로 멈춤이 발생하고, 포토샵이 멈추며, 애니메이션이 느려지는 것을 알아챘습니다. 그래서 이를 고치는 방법에 대해 연구를 시작하고 다음 다섯 가지를 찾아냈습니다.\n\n## 부팅 후 애플리케이션\n\n<div class=\"content-ad\"></div>\n\n일부 설치한 애플리케이션은 시스템 부팅 후 자동으로 시작할 수 있습니다. 이는 시스템이 부팅되는 동안 macOS를 시작하는데 바쁘기 때문에 앱을 즉시 사용할 수 있지만 앱을 실행하는 것이 전체 부팅 프로세스를 늦출 수 있다는 것을 의미합니다.\n\n거기에, 대부분의 경우 부팅 후 바로 앱을 사용하지는 않습니다. 따라서 부팅을 빨리 하려면 부팅 후 자동으로 실행되는 앱을 확인하고 필요한 경우 그 목록을 줄이는 것이 좋습니다.\n\n이를 위해서는 → 시스템 환경 설정 → 일반 → 로그인으로 이동하십시오. 여기에서 상단에 있는 \"시작 시 열기\" 앱 목록을 선택하고, 필요한 경우 왼쪽 아래쪽에 있는 체크를 해제할 수 있습니다.\n\n## 디스크 오류\n\n<div class=\"content-ad\"></div>\n\n최근에 맥북이 느려지거나 종종 다시 부팅하거나 종료해야 하는 경우가 있나요? 그렇게 대답한다면, 디스크에 오류가 있을 수 있어서 이러한 문제가 발생할 수 있습니다.\n\n![맥북 속도 향상 팁](/assets/img/2024-06-19-HowtoSpeedUpYourMacWithmacOSVentura_1.png)\n\n그러나 맥에서 간단한 테스트를 실행하여 오류를 찾고 수정할 수 있습니다. 디스크 유틸리티 앱을 열고 왼쪽에 있는 내부 디스크를 강조 표시한 다음 상단의 \"고급 수리\"를 탭하고 마법사를 따라 오류를 제거할 수 있습니다.\n\n## 도전적인 응용 프로그램\n\n<div class=\"content-ad\"></div>\n\n새로운 운영 체제로 업그레이드 한 후, 우리의 경우 macOS 13.1 Ventura, 가끔 앱이 제대로 작동하지 않을 수도 있습니다.\n\n가끔은 개발자의 잘못이거나, 가끔은 시스템의 잘못일 수도 있지만, 그것을 받아들여야 합니다. 앱이 제대로 작동하지 않으면 \"루핑\"과 같은 문제를 일으킬 수 있어서 꼭 필요한 작업이 중단되고 전력이 과다 사용되어 속도가 느려질 수 있습니다. 업데이트 후 Mac이 느리게 실행되는 경우 무거운 앱을 확인해보세요.\n\nActivity Monitor 앱으로 이동하고 CPU 범주로 이동한 다음 % CPU에 따라 내림차순으로 프로세스를 정렬합니다. 그런 다음 상위 위치에 의심스러운 앱을 찾은 경우 해당 앱을 누르고, 그런 다음 상단의 X를 누릅니다. 그런 다음 강제 종료를 누릅니다.\n\n## 효과 및 애니메이션\n\n<div class=\"content-ad\"></div>\n\n맥OS에서는 앱을 열 때, 제스처를 사용할 때 등 다양한 효과와 애니메이션이 보입니다. 그러나 이러한 모든 효과와 애니메이션을 렌더링하는 데에는 일정한 성능이 필요하며, 이는 예전 맥에서는 여분으로 가지고 있지 않을 수 있습니다.\n\n다행히도, macOS에서는 효과와 애니메이션을 쉽게 제한할 수 있습니다. 시스템 설정 → 접근성 → 모니터로 이동하여 '모션 제한 활성화'를 설정할 수 있습니다. 더불어 '투명도 줄이기'도 활성화할 수 있습니다.\n\n게다가, 애니메이션 자체가 수행하는 데 시간이 걸리므로 이를 끄면 맥이 즉시 빠르게 느껴질 것이며, 이는 새로운 기계에서도 느낄 수 있을 것입니다.\n\n## 저장 공간\n\n<div class=\"content-ad\"></div>\n\n맥이 빠르고 안정적으로 작동되도록 보장하려면 저장 공간에 충분한 여유 공간이 있는지 확인해야 합니다. 물론 맥이 여유 공간이 부족하다면 알려줄 겁니다.\n\n하지만, 여유 공간이 없어진다면, 애플은 불필요한 파일을 삭제하여 저장 공간을 확보하기 위해 하드웨어 리소스를 주로 할당할 것입니다. 이는 심각한 속도 저하로 이어질 수 있습니다.\n\n맥이 저장 공간을 확보하지 못하면 종료되고 데이터를 삭제한 상태에서 다시 설치해야 할 수도 있습니다. 비슷한 문제가 발생했거나 맥 미니를 맥 이상으로 사용하고 있는 건 아닌지요?\n\n이 글을 읽어주셔서 감사합니다! 마음에 드셨다면 좋아요 👏🏻와 댓글 💬로 지지해주시면 감사하겠습니다. 그리고 더 많은 콘텐츠를 원한다면, 저를 팔로우해주시기 바랍니다! 즐거운 하루 보내세요 😊👌👋\n\n<div class=\"content-ad\"></div>\n\n제 작업을 직접적으로 지원해 주시면 감사하겠습니다: [https://ko-fi.com/jakubjirak](https://ko-fi.com/jakubjirak)","ogImage":{"url":"/assets/img/2024-06-19-HowtoSpeedUpYourMacWithmacOSVentura_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoSpeedUpYourMacWithmacOSVentura_0.png","tag":["Tech"],"readingTime":3},{"title":"맥 해독하기 macOS 커널에서 고급 CPU 메트릭스 조사하기","description":"","date":"2024-06-19 08:54","slug":"2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics","content":"\n\n<img src=\"/assets/img/2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics_0.png\" />\n\n우리의 지난 탐험에서는 인텔과 애플 실리콘 간 CPU 사용량 차이에 대해 표면을 긁었습니다. 이제는 더 깊이 파고들어볼 시간입니다. macOS 커널은 CPU 사용량을 어떻게 추적하고, 다른 커널 서브시스템들이 시간 기록에 대해 어떤 가정을 하는지 살펴봅니다. 본 글은 Mach 리카운트 서브시스템으로 빠져들어, CPU 시간의 매 틱이 면밀하게 기록되는 과정을 안내합니다.\n\n외부에서 커널 밖에서 CPU 부하를 정확히 결정하는 것은 불가능하다는 것을 이해한 뒤, 서로 다른 CPU 코어가 서로 다른 속도로 동작한다는 점에서 좋은 근사치를 찾겠다는 다짐을 하였습니다. 결국, 우리는 시스템 문제 진단을 제공하고 정확한 시스템 사용 보고서를 제공하는 대신에 도움을 제공해야 합니다.\n\nproc_pidinfo(PROC_PIDTASKINFO) 시스템 호출을 통해 프로세스별 CPU 시간 사용량을 사용할 수 있게 되었는데, 우리가 찾고 있는 것은 전체 시스템에서 (유휴 시간 포함) 사용된 CPU 시간을 결정하여 프로세스별 비율을 수립하는 방법입니다.\n\n<div class=\"content-ad\"></div>\n\n# 초기 접근 방식: host_process_info 메트릭 값을 합산하기\n\n일반적으로 가장 명백한 해결책을 먼저 시도하고, 그 후에 이를 발전시키는 편입니다. 이 경우, host_process_info() API는 이미 각 프로세서별 전체 CPU 부하를 반환하며, 여기에 idle 시간이 포함되어 있기 때문에 이를 합산하는 것은 각 프로세스를 측정할 기준을 결정하는 명백한 방법일 수 있습니다.\n\n그러나 결과를 보고 실망했습니다: 테스트 프로세스를 설정하여 전체 CPU 시간의 약 10%를 사용하도록 하였으나, 이 방법을 따르면 보고된 사용량이 약 0.01%와 같은 수준으로 표시되었습니다. 결과에 일정한 배수를 곱하면 일부 결과가 더 좋아지지만, 유감스럽게도 동일한 배수로 모든 결과를 의미 있게 변환할 수 없었습니다.\n\n점점 더 가까워지는 기분이었습니다. 이러한 차이로 인해 처음에 host_process_info()와 proc_pidinfo API에서 사용되는 시간 단위에 차이가 있을 수 있다고 생각하게 되었습니다. 내 관찰 아래에 정확히 무엇이 있는지 알아보기 위해, 시스템 질문에 대한 모든 답을 찾을 수 있는 유일한 장소인 케널 소스로 의존하게 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n# 유일한 진실의 근원\n\n리눅스를 기반으로 한 네트워크 보안 장치를 개발하던 시절, 리눅스 네트워킹 구현을 이해하기 위한 책을 추천해 줄 수 있느냐고 동료에게 물어보았어요. 그때 동료가 한 말을 절대로 잊지 못할 거예요: 왜 구식 책을 사서 읽느냐고 할 때, 커널 소스로부터 가장 정확한 답변을 받을 수 있는데?\n\n그 이후로는 언제나 코드베이스에 접근하는 방식이 바뀌었어요.\n\n커널 소스에 내 질문에 대한 답변이 반드시 포함되어 있을 것이라고 확신을 가지고, 이 버그를 최종적으로 해결하기로 결심했어요.\n\n<div class=\"content-ad\"></div>\n\n## 올바른 질문하기\n\n커널 소스를 연구하기 전에 항상 답변하고자하는 구체적인 질문을 생각해냅니다. 이러한 질문들을 프로그램이라는 복잡한 운영 체제 커널을 특징 짓는 지나치게 많은 세부 사항을 탐색하는 데 도움이 되는 지도로 생각하세요.\n\nhost_process_info()와 proc_pidinfo(PROC_PIDTASKINFO)은 아마도 서로 다른 시간 단위를 사용할 것으로 의심했기 때문에 아직 찾아야 할 것이 있었습니다:\n\n- 각 API가 사용하는 시간 단위는 무엇인가요?\n- 이러한 시간 단위를 서로 변환하는 방법은 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n세부적으로 각 API를 살펴보기 전에 Mach 커널이 리소스 회계를 수행하는 방법을 이해하려면 우회해야 합니다.\n\n# Mach 재계산 서브시스템\n\n작업 리소스 사용에 대한 카운터를 유지하는 Mach 커널의 일부는 재계산(Recount)이라고 합니다. recount_context_switch() 함수는 문맥 전환이 발생할 때 호출되며 현재 실행 중인 작업에 대한 사용량 카운터를 업데이트하는 역할을 합니다.\n\n재계산 서브시스템은 다른 리소스 유형에 대해 서로 다른 세분도를 사용하며, 청소 및 메모리 사용의 효율성 사이의 균형을 유지합니다.\n\n<div class=\"content-ad\"></div>\n\n저는 당신의 조사와 관련된 사안으로, Recount 이름이 곧 커널 소스에 나타날 것임을 확인했습니다.\n\n# 첫 번째 정착지: proc_pidinfo\n\nproc_pidinfo API를 살펴보면서 시작했습니다. 이 API는 단일 프로세스가 사용한 CPU 시간을 보고합니다.\n\n해당 함수를 검색하고 스택 추적을 따라가 보니, fill_taskprocinfo 함수가 Mach 커널에서 작업 정보를 획득하고 보고하는데 궁극적으로 관여하고 있음을 알 수 있었습니다. task_info 속성인 pti_total_system과 pti_total_user를 거슬러 올라가면 proc_pidinfo() API와 Mach Recount 서브시스템 사이의 관련성이 드러납니다:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics_1.png)\n\n해설: fill_taskprocinfo 함수에서 이 코드 조각은 CPU 시간 정보를 수집하는 방법을 보여줍니다. recount_task_times 함수는 작업에 대한 총 시스템 및 사용자 시간을 수집하며, proc_pidinfo API가 CPU 사용량을 보고하는 방법을 이해하는 데 중요합니다.\n\nrecount_task_times()로 호출 스택을 따라가면, 최종적으로 집계되는 필드는 rt_usage라는 것을 알 수 있습니다:\n\n![이미지](/assets/img/2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n설명: recount_usage 구조는 Mach 시간 단위에서 사용자 및 시스템 시간을 구체적으로 유지하는 CPU 사용 메트릭을 저장합니다. 이를 통해 proc_pidinfo API가 CPU 시간을 어떻게 검색하고 보고하는지 이해할 수 있습니다.\n\n저는 recount_usage 구조의 필드가 동일한 접미사(_time_mach)를 가지고 있는 것을 발견했습니다. 이는 사용된 시간 단위에 대한 초기 힌트로 이해했습니다.\n\n# 다음 정거장: host_process_info\n\nhost_process_info() 함수는 각 CPU 코어가 사용한 전체 CPU 시간을 보고합니다. processor_cpu_load_info() 함수가 이 정보를 보고하는 데 책임이 있다는 것을 알아보는 데 시간이 오래 걸리지 않습니다.\n\n<div class=\"content-ad\"></div>\n\n\n\n![이미지](/assets/img/2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics_3.png)\n\n설명: 이 함수에서는 recount_processor_usage가 Mach 시간의 CPU 사용률 데이터를 제공하고, hz_tick_interval을 사용하여 해당 데이터를 틱으로 변환합니다. 이 변환 단계는 서로 다른 API 간에 CPU 시간 보고에 대한 불일치를 이해하는 데 중요합니다.\n\n이것은 host_process_info와 Mach Recount 서브시스템 간의 연결이고, Recount로부터 얻은 지표가 Mach 시간으로 보고되며 반환되기 전에 상수 요소 hz_tick_interval로 나눠진다는 사실이 더 중요합니다.\n\n저는 실험 중에 이전에 관찰했던 내용이 변환 시간 단위 사이에 상수 요소가 포함되어 있다는 명백한 확인을 발견해서 기뻤습니다.\n\n\n<div class=\"content-ad\"></div>\n\n이를 통해 proc_pidinfo API가 Mach 시간 단위로 CPU 사용량을 반환하고 host_process_info API가 대신 틱을 사용한다는 것을 알았습니다. 두 단위는 hz_tick_interval 요소를 사용하여 변환할 수 있습니다. 즉, hz_tick_interval 값을 결정할 수 있다면 두 시간 단위를 변환하고 버그를 해결할 수 있을 것입니다.\n\n그러므로, 다음으로 해야 할 당연한 단계는 hz_tick_interval 값을 찾는 것입니다.\n\n## hz_tick_interval 역추적\n\n안타깝게도 hz_tick_interval은 사용자 공간에서 접근할 수 없습니다. 빠른 해결책에 대한 희망이 사라졌지만, 최소한 값을 가져와서 아이디어가 유효한지 확인할 수 있다면 좋겠습니다.\n\n<div class=\"content-ad\"></div>\n\n이 상수를 찾는 것은 커널의 어느 부분이 관련되느냐에 따라 달랜 시간 기록 가정들의 미로에 들어간 것 같았습니다. 예를 들어, hz_tick_interval의 정의를 보며 BSD 부분에서 틱이 10ms를 나타내는 것으로 예상한다는 코멘트를 보았습니다. 이것이 서로 다른 API에서 서로 다른 시간 단위가 사용되는 이유일 것입니다.\n\n사용할 수 있는 변환 루틴을 찾아보았습니다. 궁극적으로는 사용자 공간에서 접근할 수 없는 rtclock_sec_divisor 상수인 것 같습니다. 이 값은 부트로더가 시스템 부팅 시 채우는 것입니다. 따라서, 제 가정을 수동으로 확인하기 위해 이 값을 설정하는 것은 성공하지 못했습니다.\n\n이 값을 제공할 것으로 예상했던 사용자 공간 API인 mach_timebase_info가 실제로는 기대한 결과를 제공하지 않았습니다. 따라서 다시 한 번 원점으로 돌아간 것 같은 느낌이 들었습니다!\n\nproc_pidinfo와 host_process_info 간의 시간 단위 불일치를 추적하는 것은 도전적이지만 유익한 여정이었습니다. Mach Recount 하위 시스템을 면밀히 살펴보고 macOS에서의 CPU 시간 보고 복잡성을 밝혀냈습니다. 문제의 근원을 이해했지만, 사용자 공간에서 hz_tick_interval에 접근할 수 없어 해결책을 찾는 것이 쉽지 않습니다. 그러나 이 도전은 끝이 아니라 혁신적인 해결책을 찾을 기회입니다. 다음 부분에서 이러한 시간 단위를 변환하고 정확한 CPU 메트릭을 보장하는 방법을 탐색할 것입니다. 더 많은 통찰과 실용적인 응용 프로그램을 기대해 주세요!","ogImage":{"url":"/assets/img/2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics_0.png"},"coverImage":"/assets/img/2024-06-19-DecodingMachInvestigatingmacOSsKernelforAdvancedCPUMetrics_0.png","tag":["Tech"],"readingTime":6}],"page":"83","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}