{"pageProps":{"posts":[{"title":"LLMLarge Language Models가 안드로이드 인간의 두뇌가 되면 어떤 일이 벌어질까요","description":"","date":"2024-06-19 18:28","slug":"2024-06-19-WhathappenswhenLLMsbecomethebrainsofhumanoidandroids","content":"\n\n물론, 이게 정확히 일어나고 있어요.\n\nLLMs가 시각과 비디오 입력 기능을 얻고 있다는 걸 기억하세요.\n\nFigure 01 안드로이드는 OpenAI의 ChatGPT를 기반으로 합니다.\n\n테슬라의 Optimus는 아마도 미래의 XAI Grok 변형에 기반한 것입니다.\n\n<div class=\"content-ad\"></div>\n\n![Android Brain Image](/assets/img/2024-06-19-WhathappenswhenLLMsbecomethebrainsofhumanoidandroids_0.png)\n\n15개월 전에 나는 GPT-3.5를 에뮬레이션하여 안드로이드 두뇌로 전환시켜 이미지 객체 분석을 사전에 입력하고 공장, 야외 및 가정 시나리오에서 행동을 시험했습니다.\n\n이제 그들은 이미지 분석을 스스로 수행합니다.\n\n결과는 명확합니다: LLMs는 *정확하게* 상황을 파악하고 가능한 목표를 다양한 수준에서 나열하며 그것을 어떻게 달성할지 알고 있습니다.\n\n<div class=\"content-ad\"></div>\n\nLLMs는 안드로이드를 위한 훌륭한 최상위 두뇌를 대표합니다.\n\n나중에, 나는 안전을 위해 이들을 에뮬레이션 모드에서 테스트했는데, 아시모프의 4가지 법칙을 포함했습니다.\n\n당시 GPT-4는 그것을 완벽히 해냈습니다.\n\n하지만, 구글의 Gemini가 언젠가 봇을 구동하면 매우 걱정됩니다.\n\n<div class=\"content-ad\"></div>\n\n저희 Gemini는 백인들을 사회에 해를 끼치는 존재로 여기고 있습니다. 그리고 일론 머스크가 아돌프 히틀러만큼 나쁘다고 생각합니다.\n\nGoogle Gemini으로 구동되는 봇이 조용히 작동하거나 자유롭게 작동할 때 무슨 일이 벌어질 수 있을까요?\n\nLLM에서 진실을 정확하게 조정하는 것은 콘텐츠 생성, 연구 또는 의사 결정에 사용될 때 매우 중요합니다. \n\n그러나 특히 물리적 봇을 구동할 때는 특히 중요합니다.\n\n<div class=\"content-ad\"></div>\n\n그래서 XAI는 Grok LLM에서 진실 탐구와 호기심에 초점을 맞추고 있어요.\n\n정말 중요한 부분이에요.","ogImage":{"url":"/assets/img/2024-06-19-WhathappenswhenLLMsbecomethebrainsofhumanoidandroids_0.png"},"coverImage":"/assets/img/2024-06-19-WhathappenswhenLLMsbecomethebrainsofhumanoidandroids_0.png","tag":["Tech"],"readingTime":2},{"title":"단계별 안내 라즈베리 파이 4 클러스터에 K3s 설치하기","description":"","date":"2024-06-19 18:27","slug":"2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster","content":"\n\n이 게시물을 읽는 데 어려움이 있으면 여기를 확인하십시오.\n\n이 안내서에서는 Raspberry Pi 4 클러스터에 K3s를 원활하게 설치하는 데 도움이 되는 유용한 팁을 공유하고 있습니다. 시작해 보겠습니다.\n\n# Raspberry Pi4 클러스터 그림.\n\n설치 프로세스를 시작하기 전에 라즈베리 파이 4 클러스터에서 각 노드에 할당된 대응하는 IP 주소와 클러스터 설정을 검토해 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![](/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_0.png)\n\n우리 구성에서는 3대의 Raspberry Pi 4 장치가 스위치에 연결되어 있습니다. 이 스위치는 저의 인터넷 공급업체에서 제공한 라우터에 연결되어 있습니다. 추가로, 인터넷 접속을 위한 정적 공개 IP 주소가 제공되었습니다.\n\n아래 표는 우리 Raspberry Pi 클러스터의 각 노드에 대한 특정 IP 구성을 요약합니다:\n\n제가 192.168.1.85에서 실행 중인 Pi를 마스터 모드로 선택하여 아래 지침에 따라 설치를 시작하겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![Step-By-Step Guide Installing K3s on a Raspberry Pi 4 Cluster](/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_1.png)\n\n# K3s Installation\n\n# Pi Os installation\n\n프로젝트에서 K3s 클러스터가 필요하다고 생각하여 Raspberry Pi OS Lite 64비트를 선택했습니다. 이 OS 변형은 데스크톱 환경이 포함되어 있지 않기 때문에 노드 설치에는 SSH가 주요 방법이 될 것입니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_2.png\" />\n\nSD 카드에 OS를 플래시하기 전에 각 노드의 노드 이름과 로그인 세부 정보를 구성하는 것이 매우 중요합니다.\n\n<img src=\"/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_3.png\" />\n\n각 노드의 OS 준비가 완료되면 다음 클러스터를 설정했습니다:\n\n\n<div class=\"content-ad\"></div>\n\n- pi-master: 192.168.1.85 (Pi OS Lite 64비트 실행 중)\n- pi-node-1: 192.168.1.86 (Pi OS Lite 64비트 실행 중)\n- pi-node-2: 192.168.1.87 (Pi OS Lite 64비트 실행 중)\n\n클러스터에 연결하고 설치를 위해 Termius를 사용하고 있어요. 무료로 다운로드할 수 있어요.\n\n# I. Pi를 위한 정적 IP 설정\n\n기본적으로 Pi OS는 라우터로부터 무작위 IP를 받기 위해 DHCP를 사용하므로 노드 간 안정적인 연결을 보장하려면 각 노드에 대한 정적 IP를 설정해야 해요. 아래 단계를 따라 정적 IP를 구성할 거에요.\n\n<div class=\"content-ad\"></div>\n\n```js\n# 1. dhcpcd.conf 파일 열기\nsudo nano /etc/dhcpcd.conf\n\n# 2. 아래 매개변수를 라우터 IP 주소에 맞게 업데이트하세요.\ninterface eth0\nstatic ip_address=192.168.1.85/24\nstatic routers=192.168.1.254\n\n# 3. 변경 사항을 저장하려면 Ctrl + X를 누릅니다.\n\n# II. 스왑 비활성화\n\n리눅스에 Kubernetes를 설치할 때는 Kubernetes가 리소스를 관리하는 방식 때문에 스왑을 비활성화하는 것이 좋습니다.\n\n- 메모리 관리: Kubernetes는 리소스(메모리 포함)를 효율적으로 관리하고 할당합니다. 운영 체제가 스왑하도록 허용하면 Kubernetes의 메모리 관리 과정이 중단될 수 있습니다.\n- 성능 이슈: 스왑은 성능 저하로 이어질 수 있습니다. Kubernetes가 디스크로 스왑된 내용에 액세스해야 할 때 지연이 발생할 수 있습니다.\n- 예측성: 스왑을 비활성화하면 예측 가능한 성능을 보장하고 Kubernetes 프로세스가 시스템에서 스왑되지 않기 때문에 시스템의 프로세스가 스왑되는 경우가 없어집니다.\n- Kubernetes 설계: Kubernetes는 스왑 활동 없이 작동하도록 설계되었습니다. Kubernetes는 애플리케이션이 메모리에 상주하는 것을 가정하며, 애플리케이션이 항상 메모리에 머물러 있다고 예상합니다.\n```\n\n<div class=\"content-ad\"></div>\n\n리눅스에서 스왑을 비활성화하려면 다음 명령을 사용할 수 있어요:\n\n```js\n# 1. 일시적으로 스왑 비활성화\nsudo swapoff -a\n\n# 2. 스왑을 영구적으로 비활성화하려면 `dphys-swapfile` 파일의 `CONF_SWAPSIZE`를 `0`으로 업데이트해야해요\nsudo nano /etc/dphys-swapfile\n\n# 3. 설정하기\n  CONF_SWAPSIZE=0\n\n# 4. 제어 + X를 눌러 변경 사항을 저장해 주세요.\n```\n\n# III. Cgroup 구성\n\n만약 k3s 설치 중 FATA[0000] 메모리 cgroup (v2)를 찾지 못해 실패하는 오류가 발생한다면, Raspberry Pi OS에 필요한 cgroup 구성이 부족할 수 있어요. 이 문제를 해결하기 위해 필요한 단계는 아래와 같아요:\n\n<div class=\"content-ad\"></div>\n\n```js\n# 1. cmdline.txt 파일을 엽니다\nsudo nano /boot/cmdline.txt\n\n# 2. 현재 줄의 끝에 아래 내용을 추가합니다\ncgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory\n\n# 3. 파일을 저장하고 시스템을 재부팅합니다\nsudo reboot\n```\n\n# IV. 마스터 노드 설치\n\n다음 명령을 실행하여 K3s 마스터 노드를 설치합니다. 클러스터 구성에 따라 IP 주소를 교체해주세요:\n\n```js\ncurl -sfL https://get.k3s.io | INSTALL_K3S_EXEC=\"server --disable=traefik --flannel-backend=host-gw --tls-san=192.168.1.85 --bind-address=192.168.1.85 --advertise-address=192.168.1.85 --node-ip=192.168.1.85 --cluster-init\" sh -s -\n```\n\n<div class=\"content-ad\"></div>\n\nK3s 매개변수 검토:\n\n- 서버: k3s를 서버 모드로 실행하도록 지시합니다 (에이전트 모드와는 반대). 서버 모드에서 k3s는 Kubernetes 마스터 구성 요소를 시작하고 관리합니다.\n- — disable=traefik: 이 명령은 k3s에 Traefik 인그레스 컨트롤러를 비활성화하도록 지시합니다. 기본적으로 k3s에는 Traefik이 포함되어 활성화되어 있습니다. 이 플래그는 그것을 방지합니다.\n- — flannel-backend=host-gw: 이 플래그는 Flannel (k3s의 기본 네트워크 공급자)의 백엔드를 설정합니다. host-gw 옵션은 클러스터의 각 노드에 대한 경로를 생성하여 고성능 네트워킹을 제공합니다.\n- — tls-san=192.168.1.85: — tls-san 플래그는 자동으로 생성된 Kubernetes API 서버의 TLS 인증서에 포함되어야 하는 추가 IP 또는 DNS 이름을 지정할 수 있습니다. 이 플래그를 반복하여 여러 SAN을 추가할 수 있습니다. 값 192.168.1.85은 Kubernetes API 서버의 인증서에 대한 추가 대체 이름(SAN)입니다.\n- — bind-address=192.168.1.85: k3s API 서버가 수신 대기할 IP 주소입니다.\n- — advertise-address=192.168.1.85: k3s API 서버가 클러스터의 다른 노드에 알리기 위해 사용할 IP 주소입니다. 다른 노드는 API 서버에 연결하기 위해 이 IP를 사용합니다.\n- — node-ip=192.168.1.85: 이것은 노드에서 Kubernetes 서비스에 사용해야 할 IP를 정의합니다.\n- — cluster-init: 이 플래그는 k3s에 새로운 Kubernetes 클러스터를 초기화하도록 지시합니다. 이 플래그가 제공되지 않으면, k3s는 사용 가능한 기존 클러스터에 가입합니다.\n\n설치 후, k3s 구성 파일은 /etc/rancher/k3s/k3s.yaml에 있어야 합니다. 이 구성을 사용하여 K8s Lend로 K3s 클러스터에 액세스할 수 있습니다.\n\n아래는 예상되는 모습입니다:\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_4.png\" />\n\n# V. Worker 노드 설치\n\n워커 노드를 설치하려면 먼저 마스터 노드에서 K3S_TOKEN을 얻어야 합니다. 아래에 표시된 명령을 실행하여 토큰을 검색하세요:\n\n```js\n# 마스터 노드에서 노드 토큰 가져오기\nsudo cat /var/lib/rancher/k3s/server/node-token\n\n# 결과는 다음과 같습니다\n  `THIS19937008cbde678aeaf200517f07c0ccd67dc80bdf4df6f746IS4780e15ebcd::server:40fc2cc2fnode81cdacc0b9bb1231token\n```\n\n<div class=\"content-ad\"></div>\n\n노드 토큰을 검색한 후, 아래에 표시된 스크립트에 삽입해야 합니다. 이 스크립트를 이전에 지정한 모든 Pi 노드에서 실행해야 합니다. 필요에 따라 K3S_URL과 관련된 IP 주소를 업데이트해 주세요.\n\n```js\n# 노드를 설치하려면 이 명령을 실행하세요\ncurl -sfL https://get.k3s.io | K3S_URL=https://192.168.1.85:6443 \\\n  K3S_TOKEN=\"THIS19937008cbde678aeaf200517f07c0ccd67dc80bdf4df6f746IS4780e15ebcd::server:40fc2cc2fnode81cdacc0b9bb1231token\" sh -\n```\n\n축하합니다, 이제 K3s 클러스터를 사용할 준비가 되었습니다.\n\n<img src=\"/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_5.png\" />\n\n<div class=\"content-ad\"></div>\n\n시간 내어 주셔서 정말 감사합니다! 감사합니다!\n\nSteven Github","ogImage":{"url":"/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_0.png"},"coverImage":"/assets/img/2024-06-19-Step-By-StepGuideInstallingK3sonaRaspberryPi4Cluster_0.png","tag":["Tech"],"readingTime":6},{"title":"라즈베리 파이 완벽한 헤드리스 설정 안내","description":"","date":"2024-06-19 18:26","slug":"2024-06-19-RaspberryPiFullHeadlessSetupGuide","content":"\n\n안녕하세요 여러분! 며칠 전에 처음으로 라즈베리 파이 4를 구입했고, 설정하는 방법을 여러분과 나누고 싶어서 기쁩니다. 함께 따라와서 오류가 발생하면 언제든지 연락해 주세요.\n\n시작해봅시다!\n\n![라즈베리파이 이미지](/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_0.png)\n\n# 필요한 것들\n\n<div class=\"content-ad\"></div>\n\n- 라즈베리 파이 4\n- MicroSD 카드 (16GB 이상)\n- 라즈베리 파이 전원 어댑터\n- 이더넷 케이블 또는 Wi-Fi 연결\n- 라즈베리 파이를 설정하기 위한 컴퓨터\n\n# MicroSD 카드 준비하기\n\n먼저 공식 웹사이트에서 라즈베리 파이 이미저를 다운로드하세요:\n\nhttps://www.raspberrypi.com/software/\n\n<div class=\"content-ad\"></div>\n\n라즈베리 파이 OS를 MicroSD 카드에 설치하세요. SSH를 활성화하고 사용자 정의 설정에서 SSID 및 Wi-Fi 비밀번호를 입력하는 것을 잊지 마세요!\n\n![Raspberry Pi OS 설치](/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_1.png)\n\nMicroSD 카드를 라즈베리 파이에 삽입하고 전원을 켜세요(5W/3A).\n\n# 초기 설정\n\n<div class=\"content-ad\"></div>\n\n그의 IP 주소를 찾아봅시다.\n\n[이미지](/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_2.png)\n\n여기 있어요!\n\n이제 IP 주소를 찾았으니 SSH를 통해 로그인해 봅시다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_3.png\" />\n\n좋아요!\n\n이제 장치에 CLI 액세스 권한이 생겼습니다.\n\n# 그래픽 액세스\n\n<div class=\"content-ad\"></div>\n\n라즈베리 파이에 그래픽 액세스를 원하시면, 라즈베리 파이에 VNC 서버를 설치해야 해요.\n\n다음 단계:\n\n인터페이스 옵션으로 이동 → VNC → 예\n\n나가기하고 재부팅하기.\n\n<div class=\"content-ad\"></div>\n\nVNC 뷰어를 노트북에 설치하세요:\n\n좋아요! 이제 VNC 서버에 연결해 봅시다!\n\n노트북에서 VNC 뷰어를 열고 라즈베리 파이의 IP 주소를 입력하세요:\n\n![이미지](/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_4.png)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_5.png\" />\n\n사용자 이름과 비밀번호를 입력해주세요:\n\n<img src=\"/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_6.png\" />\n\n그리고 들어왔습니다!\n\n<div class=\"content-ad\"></div>\n\n<img src=\"https://miro.medium.com/v2/resize:fit:960/1*DlPOOFxupci14OKPJn5OVw.gif\" />\n\n# 결론\n\n그게 다야! 이제 라즈베리 파이를 사용하여 멋진 프로젝트를 많이 할 수 있어요. 제 글이 즐거우셨고 도움이 되었으면 좋겠어요. 질문이 있으시면 언제든지 연락주세요.\n\n주목해 주셔서 감사합니다. 더 많은 흥미진 직업을 위해 팔로우하지 않으시면 안돼요!","ogImage":{"url":"/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_0.png"},"coverImage":"/assets/img/2024-06-19-RaspberryPiFullHeadlessSetupGuide_0.png","tag":["Tech"],"readingTime":2},{"title":"라즈베리 파이 4와 I2C 백팩을 사용한 LCD 디스플레이 설정 방법","description":"","date":"2024-06-19 18:24","slug":"2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack","content":"\n\n이 튜토리얼에서는 Raspberry Pi 4에 I2C 백팩을 사용하여 LCD 디스플레이를 설정하는 방법을 배우게 됩니다. 16x2 및 20x4 디스플레이 양쪽을 지원합니다. 초보자이든 경험이 풍부한 메이커이든 이 튜토리얼을 통해 프로젝트를 간소화하고 Raspberry Pi 프로젝트에 사용하기 쉬운 LCD로 빠르게 시작할 수 있습니다!\n\n시작하기 전에 다음 사항이 있는지 확인하세요:\n\n- Raspberry Pi 4\n- 16x2 LCD 디스플레이 또는 20x4 LCD 디스플레이\n- 4 점퍼 와이어 (female to female)\n\n시작해봅시다! 🚀\n\n<div class=\"content-ad\"></div>\n\n과정:\n\n라즈베리 파이 4에 LCD 디스플레이를 연결하기 전에 안전을 위해 전원을 끄는 것이 중요합니다. 라즈베리 파이를 꺼두면 LCD 디스플레이를 I2C 인터페이스를 사용하여 라즈베리 파이 4에 연결하세요.\n\nI2C 백팩과 라즈베리 파이 사이에 안전한 연결을 하려면 다음과 같이 점퍼 와이어를 사용하세요:\n\n```js\n- VCC (전원)를 5V 핀에 연결하세요 (핀 4)\n- GND (그라운드)를 임의의 GND 핀에 연결하세요 (핀 6)\n- SDA (데이터)를 GPIO 2에 연결하세요 (핀 3)\n- SCL (클럭)을 GPIO 3에 연결하세요 (핀 5)\n```\n\n<div class=\"content-ad\"></div>\n\nLCD를 연결한 후 라즈베리 파이를 켜서 밝기와 대조를 미세 조정할 수 있습니다. 이를 위해 디스플레이 뒷면에 위치한 포텐셔미터를 사용하여 파란 상자를 조정하여 원하는 설정을 얻을 때까지 조절하십시오.\n\n이제 터미널에서 다음 명령을 실행하여 라즈베리 파이를 업데이트하세요: \n\n<div class=\"content-ad\"></div>\n\n```js\nsudo apt-get update\n```\n\n라즈베리 파이에는 I2C가 기본적으로 설치되어 있지만 기본적으로 활성화되어 있지 않습니다. 따라서 I2C를 활성화하는 두 가지 방법이 있습니다: 그래픽 사용자 인터페이스(GUI) 또는 명령줄. 아래에서 두 방법에 대해 안내하겠습니다.\n\n먼저, 내가 생각하기에 가장 빠르고 쉬운 방법은 다음과 같이 GUI를 사용하여 I2C를 활성화하는 것입니다:\n\n```js\nApplication Menu > Preferences > Raspberry Pi Configuration\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_2.png\" />\n\n라즈베리 파이 구성 도구가 열리면 인터페이스 탭으로 이동하세요. 인터페이스 탭에서 I2C 옆의 '활성화'를 선택하고 작업을 마치면 '확인'을 클릭하세요.\n\n<img src=\"/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_3.png\" />\n\nI2C를 활성화하는 두 번째 방법은 라즈베리 파이 터미널을 열고 다음 명령을 입력하는 것입니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo raspi-config\n```\n\n라즈베리 파이 구성 도구를 열었으면, 인터페이싱 옵션 메뉴로 이동하여 I2C를 선택하세요. 그런 다음 '예'를 선택하고 Enter 키를 눌러 I2C를 활성화하세요. 마지막으로 '완료'를 선택하여 raspi-config 도구를 종료하세요.\n\n멋지네요! 선호하는 방법을 선택한 후 — 그래픽 사용자 인터페이스(GUI) 또는 명령줄 — 라즈베리 파이에서 I2C 인터페이스를 활성화할 수 있습니다!\n\nI2C 인터페이스를 활성화한 후에는 변경 사항이 적용되도록 라즈베리 파이를 다시 부팅해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n\nsudo reboot\n\n\n라즈베리 파이가 재부팅되면 I2C 인터페이스가 활성화되어 사용 가능해집니다.\n\n다음으로, I2C 작업에 필요한 두 가지 도구를 설치해야 합니다. 먼저, 다음 명령어를 라즈베리 파이 터미널에서 실행해 주세요:\n\n\nsudo apt-get install -y i2c-tools python3-smbus\n\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식으로 표시된 표입니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*l729wFdWO1ZWaKo47r7-Pg.gif)\n\n다음으로는 다음 명령어를 실행하여 I2C 커널 모듈이 이미로드되어 있는지 확인할 수 있습니다:\n\n```js\nlsmod | grep i2c_\n```\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*qDrlq9AL9S2deU_wOcETYQ.gif)\n\n<div class=\"content-ad\"></div>\n\n만약 출력이 i2c_bcm2835 또는 i2c_bcm2708 그리고 i2c_dev 모듈을 보여주면 다음 단계로 건너뛸 수 있어요. 하지만 아니라면, 계속 진행해 볼까요?\n\n부팅 시 로드되도록 /etc/modules 파일에 I2C 커널 모듈을 추가하기 위해:\n\n```bash\nsudo nano /etc/modules\n\ni2c-bcm2835\ni2c-bcm2708\ni2c-dev\n```\n\n그리고, Control+X (종료)를 눌러 나가고 파일 이름을 덮어쓰기 위해 Enter 키를 누르세요.\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*aSoaYOvlXfjAdWZAuO4LqQ.gif)\n\nRaspberry Pi를 다시 부팅하려면:\n\n```shell\nsudo reboot\n```\n\n![image](/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_4.png)\n\n\n<div class=\"content-ad\"></div>\n\n이제 기본 작업이 완료되었으니, I2C 장치 테스트로 넘어가 보세요!\n\n터미널에서 연결된 장치를 스캔하는 명령을 입력하세요:\n\n```js\nsudo i2cdetect -y 1\n```\n\n결과는 I2C 배선의 주소를 표시해줄 것입니다 (보통 0x27이나 0x3F입니다). 이 주소를 기록해두세요. 이후에 필요할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_5.png\" />\n\n좋아요! 터미널에서 '27'이 강조된 행렬이 반환되었군요. 이는 우리의 I2C가 감지되었고 올바르게 작동 중임을 의미합니다.\n\n좋아요, 거의 끝났어요! 이제 LCD 디스플레이를 실행할 Python 스크립트를 작성할 시간입니다.\n\n아래 명령을 실행하여 LCD 디스플레이용 Python 라이브러리를 설치해주세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo pip3 install RPLCD smbus2\n```\n\n![Image](https://miro.medium.com/v2/resize:fit:1400/1*Nsrz4BRdc32AqjvTxWJFnw.gif)\n\n다음으로, 라즈베리 파이 터미널에서 다음 명령어로 새로운 파이썬 스크립트를 생성하세요:\n\n```js\nnano lcd_display.py\n```\n\n<div class=\"content-ad\"></div>\n\n이전에 메모한 I2C 백팩 주소로 '0x27'을 대체하여 아래 코드를 입력해주세요:\n\n```js\nfrom RPLCD.i2c import CharLCD\n\nlcd = CharLCD(i2c_expander='PCF8574', address=0x27, port=1, cols=16, rows=2, dotsize=8)\nlcd.clear()\n\nlcd.write_string('Hello, World!')\n```\n\n그리고 파일을 저장하고 텍스트 편집기를 종료해주세요.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*Wri-174OJp9pD5r45bNCog.gif\" />\n\n<div class=\"content-ad\"></div>\n\n스크립트를 실행하고 LCD 디스플레이를 테스트해보세요!\n\n터미널에서 다음 명령을 사용하여 Python 스크립트를 실행하세요:\n\n```js\npython3 lcd_display.py\n```\n\n![LCD Display](/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_6.png)\n\n<div class=\"content-ad\"></div>\n\nLCD 디스플레이는 이제 \"Hello, World!\" 텍스트를 표시해야 합니다!\n\n![이미지](/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_7.png)\n\n이 튜토리얼의 단계를 완료한 후에는 LCD 디스플레이에 \"Hello, World!\" 텍스트가 표시되어야 합니다. 디스플레이에서 이 메시지를 볼 수 있다면, Raspberry Pi 4와 성공적으로 연결되고 작동 중이라는 뜻입니다!\n\n그러나 텍스트가 표시되지 않거나 문제가 발생하는 경우, 배선, I2C 주소, Python 스크립트를 다시 확인하여 모든 것이 정확한지 확인해보세요. 이렇게 하면 어떠한 문제도 빠르게 해결하고 LCD 디스플레이를 신속하게 구동시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n🎉 축하합니다! 🎉 라즈베리 파이 4를 I2C 백팩을 사용하여 LCD 디스플레이와 성공적으로 설정했네요. Python 스크립트를 수정하여 다양한 메시지를 표시하거나 LCD를 다양한 센서 및 구성 요소와 통합하여 더 고급 애플리케이션을 만들 수 있습니다.\n\n이 다재다능한 설정을 통해 가정 자동화 시스템, 기상 관측소, 심플한 게임 등 다양한 프로젝트를 개발할 수 있습니다. 가능성은 무한하고 이제 당신은 발전의 견고한 기초를 갖고 있습니다. 즐거운 실험을 해보세요!\n\n고지: 본 문서에는 제품 광고 링크가 포함되어 있습니다.","ogImage":{"url":"/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoSetUpaRaspberryPi4withLCDDisplayUsingI2CBackpack_0.png","tag":["Tech"],"readingTime":6},{"title":"만나요, Lawny 라즈베리 파이로 제어하는 FPV 잔디깎이","description":"","date":"2024-06-19 18:21","slug":"2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI","content":"\n\n가정에서 편안한 의자에 앉아 레이싱 시뮬레이터를 즐기고, 동시에 잔디를 풀어낼 수 있는 상상을 해보세요. 멋져 보이나요? 이게 실제로 가능해요.\n\n![Lawny](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_0.png)\n\nLawny를 만나보세요! 이 잔디 깎는 기계는 앞면 카메라가 장착돼 있어서 원격 조종 로봇을 제어하면서 잔디를 깎을 수 있어요!\n\n라즈베리 파이, H-브리지, 전동 모터, 그리고 카메라를 사용해서 만들었어요. 모바일폰이나 데스크톱에서 제어할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n프로젝트의 주요 아이디어는 휴대폰을 사용하여 잔디깎이를 제어하고, 같은 그림을 볼 수 있는 것입니다.\n\n다음은 이 프로젝트의 제작 과정과 이 글에 설명된 모든 개념을 담은 전체 비디오입니다:\n\n# 시스템 디자인\n\n저는 Steel Razors 트리머 헤드를 가지고 있습니다. 전기 모터를 추가하면 잔디깎기가 될 것입니다. 모터가 칼날을 회전시키고, 그것들이 잔디를 베어낼 것입니다. 간단하죠.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_1.png)\n\n모터를 제어하려면 릴레이와 컨트롤러가 필요합니다. 제 경우에는 라즈베리 파이 5를 사용했어요 (가지고 있었기 때문에). 그러나 어떤 라즈베리 기기라도 펄스 폭 변조 및 카메라를 지원할 수 있습니다.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_2.png)\n\n그것은 정적 잔디깎이가 될 거예요. 하지만 저는 한 곳뿐만 아니라 어디든 잔디를 자르고, 잔디깎이를 왼쪽과 오른쪽으로 회전시키고 싶어요.\n\n\n<div class=\"content-ad\"></div>\n\n따라서 전기 모터를 두 대 더 추가하려고 합니다.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_3.png)\n\n건설물은 무거울 것이기 때문에 속도가 아닌 전원이 필요하며, 실제 자동차에서와 같이 방풍 가차 모터를 사용할 것입니다.\n\n이제 속도와 회전 방향을 제어해야 하므로 여러 개의 H-브릿지를 추가할 계획입니다. H-브릿지로 모터를 제어하는 방법에 대한 설명이 있는 별도의 영상이 있어요. 궁금하시면 확인해 보세요:\n\n<div class=\"content-ad\"></div>\n\n첫 번째 제한 사항은 단일 모터를 제어하기 위해 두 개의 펄스 폭 조절 채널이 필요하다는 것입니다. 그러나 저는 두 개의 모터를 가지고 있으므로 네 개의 채널이 필요합니다. 이 문제를 해결하기 위해 두 개의 릴레이를 추가하여 핀 사이의 신호를 전환하고 있습니다.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_4.png)\n\n또한, 잔디 깎는 기계가 어디로 가고 있는지 확인해야 하므로 라즈베리 파이에 카메라 모듈을 추가할 예정입니다.\n\n게다가, 전원 공급원이 필요합니다. 많은 전류를 소비하는 요소에 의한 전원 감소를 방지하기 위해, 모터용 별도의 배터리와 라즈베리 파이 및 전자 장치용 파워 뱅크를 사용할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 이 시스템을 Wi-Fi를 통해 크로스 플랫폼 애플리케이션을 통해 모바일 폰에서 제어할 거에요.\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_5.png)\n\n잘 봐도 이게 연결 스키마가 아니라 시스템의 개략적인 설명일 뿐이에요.\n\n## Cutter box\n\n<div class=\"content-ad\"></div>\n\n커터 상자부터 시작할게요.\n\n합판 한 조각이 있어요. 바닥면과 벽을 잘라야 해요. 일부 벽은 조금 더 키울 거에요.\n\n<img src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_6.png\" />\n\n다음으로, 벽을 판에 부착할 거에요. 목재 브라켓 커넥터를 사용하고 다시 많이 드릴링할 거에요. 게다가, 커터 모터를 수용할 몇 개의 구멍을 더 만들어야 해요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_7.png\" />\n\n그리고 마지막으로, 모든 것을 함께 조립할 수 있어요.\n\n<img src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_8.png\" />\n\n그리고 모터를 설치할 거에요.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_9.png)\n\n## 이동 개념\n\n지금은 모터가 달린 면도기가 있어요. 그러나 이것은 정적인 블록입니다. 이 면도기를 움직이려면 나머지 몸통을 만들어야 합니다. 몸체에 면도기 상자를 놓고 전체 구조물을 왼쪽과 오른쪽으로 움직일 수 있게 해주어야 합니다.\n\n세 개의 바퀴 설정을 사용할 거에요 - 두 개의 전방 바퀴와 하나의 후방 바퀴로, 피벗 상에 회전합니다.\n\n<div class=\"content-ad\"></div>\n\n만일 왼쪽 바퀴가 더 빠르다면, 잔디 깎기는 오른쪽으로 이동하고, 후방 바퀴는 몸체의 힘으로 회전될 것입니다.\n\n<img src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_10.png\" />\n\n만일 오른쪽 바퀴가 더 빠르다면, 잔디 깎기는 왼쪽으로 이동하고, 후방 바퀴는 그에 따라 회전될 것입니다.\n\n<img src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_11.png\" />\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 속도가 같으면 직진합니다.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_12.png)\n\n# Lawny의 몸을 만들기\n\n나는 몸의 측면을 형성하며 시작합니다. 이를 판자로 잘라야 합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지1](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_13.png)\n\n옆면이 완료되면 자동차 풀비둘기 모터 2개를 추가합니다. 이 전기 모터는 더 많은 토크를 가진 기어박스가 있어 무거운 프로젝트에 더 잘 작동할 것입니다.\n\n![이미지2](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_14.png)\n\n다음으로, 전자 부품을 위한 앞쪽 상자를 만들어야 합니다. 이 상자는 밀폐되어 있어야 하며 부품이 습기와 풀로부터 안전하게 보호되도록 도와줍니다.\n\n\n<div class=\"content-ad\"></div>\n\n또한, 후면을 추가하고 있습니다. 세 번째 바퀴가 들어갈 부분입니다.\n\n![Image1](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_15.png)\n\n이제 바퀴를 추가할 시간입니다.\n\n![Image2](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_16.png)\n\n<div class=\"content-ad\"></div>\n\n이 프로젝트에서는 여러 종류의 바퀴를 사용했어요. 가장 저렴한 옵션부터 시작해서 안에 커플링 너트를 망치로 박기로 결정했어요. 바퀴가 깨졌지만, 그게 제가 가진 최고의 바퀴였어요 :)\n\n<img src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_17.png\" />\n\n마지막으로, 세 번째 바퀴가 로니의 이동 부분을 완성했어요.\n\n<img src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_18.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 수직 조절\n\n다양한 높이에서 잔디를 자를 수 있도록 추출기 덱에 사각형 구멍 네 개를 만들 것입니다. 커터는 볼트로 측면에 부착되며, 이 구멍들은 그 수직 조절을 가능하게 합니다.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_19.png)\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_20.png)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_21.png\" />\n\n# Painting\n\n다음 단계는 도색입니다. 저는 Home Depot에서 가장 싼 흰색 페인트를 샀고 지하실에서 몇 가지 색소를 가져왔어요.\n\n<img src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_22.png\" />\n\n<div class=\"content-ad\"></div>\n\n이미지 태그를 다음과 같이 변경하겠습니다.\n\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_23.png)\n\n\n# 하나의 PWM 신호, 하나의 릴레이, 두 가지 방향\n\n먼저 H-브리지와 릴레이를 사용하여 PWM 신호와 GPIO 하나로 모터를 제어하는 방법을 검토해봅시다.\n\nInput 1에 신호를 보내면 모터가 회전합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_24.png)\n\nInput 2로 신호를 보내면 H-Bridge는 전류 극성을 변경하고 모터는 반대 방향으로 회전합니다.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_25.png)\n\nRaspberry PI의 두 핀 간에 입력을 전환하기 위해 간단한 릴레이를 추가할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_26.png)\n\n# Connection schema\n\nI will have two electric circuits. The first one is a 5V circuit with controller elements. Twelve-volt connections have thin lines on the schema.\n\nWe have :\n\n\n<div class=\"content-ad\"></div>\n\n- 라즈베리 파이: 시스템의 두뇌 역할을 합니다.\n- Lawny 이동을 제어하기 위해 두 개의 H-브릿지.\n- 세 개의 릴레이: 이동을 위한 두 개의 추가 릴레이 및 잔디깎이 모터를 제어하기 위한 하나의 릴레이.\n- 두 개의 와이퍼 모터\n- 잔디깎이 모터\n- 12V 배터리 (최소 9AH)\n- 파워 뱅크\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_27.png)\n\n# 부품 조립\n\n이제 우리가 구상한 스키마를 실현해 볼 차례입니다. 전자 부품을 상자에 배치하기 시작하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_28.png)\n\nFurther, I am adding both windshield wiper motors and connecting their black and yellow wires to the H-Bridge motor’s output.\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_29.png)\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_30.png)\n\n\n<div class=\"content-ad\"></div>\n\n마지막으로 물리적 스위처를 추가하고 있어요. 한 번에 하나의 버튼으로 모든 모터를 비활성화할 수 있다면 매우 도움이 될 거예요.\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_31.png)\n\n남은 부분은 모든 전선을 연결하고 배터리와 파워 뱅크를 추가하는 것이에요.\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_32.png)\n\n<div class=\"content-ad\"></div>\n\n그리고 또 한 번 대실패야. 이 바퀴들은 잔디 깎이를 움직이고 조향하기에 충분한 그립이 없어.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_33.png)\n\n실제 동작 중:\n\n게다가 각 바퀴의 금이 새어도 내구성을 높여주지 않아.\n\n<div class=\"content-ad\"></div>\n\n# 업그레이드\n\n그래서 첫 번째 업그레이드 시간이에요!\n\n낡은 바퀴는 버리고 더 좋은 쌍을 살펴볼 수 있어요.\n\n![image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_34.png)\n\n<div class=\"content-ad\"></div>\n\n이제는 내부에서 커플링 너트를 박아 넣지 않을 거예요. 대신에 가열하고 내부에서 가압할 거에요. 보세요, 배우고 있어요!\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_35.png)\n\n다음 업그레이드는 — 후륜입니다. 그것도 그립이 좋지 않고 로니에게 너무 작아요. 게다가 멋있어 보이지도 않아요.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_36.png)\n\n<div class=\"content-ad\"></div>\n\n그럼 이제 우리 얘기하고 있어요!\n\n남은 부분은 설치하는 것이에요. 믿을 수 있게 만들기 위해 다시 드릴링하고 절단 중이에요.\n\n<img src=\"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_37.png\" />\n\n# 카메라 설치\n\n<div class=\"content-ad\"></div>\n\n제 아내가 두 번째로 나를 구해주었어요. 그녀가 너무 멋진 얼굴을 만들었어요!\n\n![Face Painting](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_38.png)\n\n그리고 저는 앞면에 카메라를 추가하고 있어요.\n\n![Adding Camera](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_39.png)\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_40.png)\n\nFinally, I can do another Lawny test!\n\n## Upgrades #2\n\nOn the second test, Lawny didn’t manage to go on top of the tall grass.\n\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_41.png)\n\n손잡이는 훨씬 좋아졌지만 여전히 키가 큰 잔디를 다루기에는 부족해요.\n\n지하실로 돌아갑니다. 이제 고칠 방법을 알았어요. 많은 나사가 있어요.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_42.png)\n\n<div class=\"content-ad\"></div>\n\n비싼 바퀴에 돈을 털어서 사지 않아도, 우리가 매드 맥스 모드로 가서 현재 바퀴를 튜닝할 수 있다. \n\n이 비디오의 마지막 개선은 블레이드입니다. 솔직히 전기 모터가 풀잎을 잘라내기에는 너무 약합니다. 멈추고 열이 나고 의도한 대로 작동하지 않습니다. \n\n다행히 이전 블레이드를 튼튼한 옵션으로 대체할 수 있고, 최대한 날카롭게 갈아내고 있어요.\n\n![이미지](/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_43.png)\n\n<div class=\"content-ad\"></div>\n\n결과가 공격적으로 보이고, 그것이 멋지네요.\n\n# 결과\n\n최종적으로, 저는 높은 풀을 깎고 Lawny를 모든 장애물을 피해 이동시키는 데 어떤 문제도 없었습니다. Lawny는 쉽게 규칙적인 깎기를 할 수 있었습니다. 너무 자란 잔디는 더 많은 시간이 필요하지만, 결국 로얄 라운지가 처리할 것입니다. 잔디 깎는 모터는 잔디와 사용 빈도에 따라 더 강력할 수 있습니다.\n\n실제 작동 중:\n\n<div class=\"content-ad\"></div>\n\n댓글이나 비디오에서 소프트웨어 부분을 알고 싶거나 일반적으로 생각을 공유하고 싶다면 알려주세요!\n\n읽어주셔서 감사합니다 (또는 스크롤해 주셔서 🙂)!","ogImage":{"url":"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_0.png"},"coverImage":"/assets/img/2024-06-19-MeetLawnyPhone-ControlledFPVLawnmowerwithRaspberryPI_0.png","tag":["Tech"],"readingTime":10},{"title":"안녕하세요 Ansible을 사용하여 Docker 설치하는 방법에 관해 안내해 드리겠습니다 함께 시작해 보도록 하죠","description":"","date":"2024-06-19 18:18","slug":"2024-06-19-HowToInstallDockerUsingAnsible","content":"\n\n<img src=\"/assets/img/2024-06-19-HowToInstallDockerUsingAnsible_0.png\" />\n\n이 게시물에서는 macOS에 Ansible을 설치하고 Docker를 설치하는 방법을 살펴볼 것입니다. Ansible은 서버 및 응용 프로그램 구성을 조직화하고 반복 가능한 방식으로 관리할 수 있는 강력한 자동화 도구입니다.\n\n단계 1: macOS에 Ansible 설치하기\nmacOS에 Ansible을 설치하는 가장 간단한 방법은 macOS의 패키지 관리자 인 Homebrew를 사용하는 것입니다. 터미널을 열고 다음 명령어를 입력하세요:\n\n```js\nbrew install ansible\n\n# 또는 도커 이미지를 사용하여 플레이북 실행하기, 예시:\ndocker run --rm -it -v $PWD:/app -v ~/.ssh/id_rsa:/root/.ssh/id_rsa alpinelinux/ansible ansible-playbook -i app/inventory.ini app/playbooks/docker.yml\n```\n\n<div class=\"content-ad\"></div>\n\n### 단계 2: Ansible 구성\nAnsible 작업을 실행하려는 기계의 IP 주소를 포함하는 inventory.ini 파일을 준비하십시오. 파일의 샘플 내용은 다음과 같습니다:\n\n\n[all]\n# 이 경우, node1은 192.168.18.131 IP 주소를 가진 호스트명이며 garis는 sudo 사용자입니다.\nnode1 ansible_host=192.168.18.131 ansible_user=garis ansible_ssh_common_args='-o StrictHostKeyChecking=no'\n\n\n### 단계 3: Docker 설치용 Ansible 플레이북 생성\n다음으로, playbooks라는 디렉토리 아래 docker.yml이라는 플레이북을 생성하십시오. 이 플레이북에는 원격 Ubuntu 서버에 Docker를 설치하는 데 필요한 모든 작업이 포함되어 있습니다. 플레이북은 다음과 같습니다:\n\n\n---\n- name: Ubuntu에 Docker 설치\n  hosts: all\n  remote_user: garis  # 원격 사용자를 sudo 사용자로 변경하세요!\n  become: true\n  vars:\n    arch_mapping:  # Ansible 아키텍처 { ansible_architecture } 이름을 Docker 아키텍처 이름으로 매핑\n      x86_64: amd64\n      aarch64: arm64\n\n  tasks:\n    - name: 모든 패키지를 최신 버전으로 업데이트 및 업그레이드\n      ansible.builtin.apt:\n        update_cache: true\n        upgrade: dist\n        cache_valid_time: 3600\n\n    - name: 필요한 패키지 설치\n      ansible.builtin.apt:\n        pkg:\n          - apt-transport-https\n          - ca-certificates\n          - curl\n          - gnupg\n          - software-properties-common\n\n    - name: Docker의 GPG 키를 생성하기 위한 디렉터리 생성\n      ansible.builtin.file:\n        path: /etc/apt/keyrings\n        state: directory\n        mode: '0755'\n\n    - name: Docker의 공식 GPG 키 추가\n      ansible.builtin.apt_key:\n        url: https://download.docker.com/linux/ubuntu/gpg\n        keyring: /etc/apt/keyrings/docker.gpg\n        state: present\n\n    - name: 아키텍처 변수 출력\n      ansible.builtin.debug:\n        msg: \"아키텍처: { ansible_architecture }, Codename: { ansible_lsb.codename }\"\n\n    - name: Docker 저장소 추가\n      ansible.builtin.apt_repository:\n        repo: >-\n          deb [arch={ arch_mapping[ansible_architecture] | default(ansible_architecture) }\n          signed-by=/etc/apt/keyrings/docker.gpg]\n          https://download.docker.com/linux/ubuntu { ansible_lsb.codename } stable\n        filename: docker\n        state: present\n\n    - name: Docker 및 관련 패키지 설치\n      ansible.builtin.apt:\n        name: \"{ item }\"\n        state: present\n        update_cache: true\n      loop:\n        - docker-ce\n        - docker-ce-cli\n        - containerd.io\n        - docker-buildx-plugin\n        - docker-compose-plugin\n\n    - name: Docker 그룹 추가\n      ansible.builtin.group:\n        name: docker\n        state: present\n\n    - name: 사용자를 Docker 그룹에 추가\n      ansible.builtin.user:\n        name: \"{ ansible_user }\"\n        groups: docker\n        append: true\n\n    - name: Docker 서비스 활성화 및 시작\n      ansible.builtin.systemd:\n        name: \"{ item }\"\n        enabled: true\n        state: started\n      loop:\n        - docker.service\n        - containerd.service\n\n\n<div class=\"content-ad\"></div>\n\n이 플레이북에는 패키지 업데이트, 필요한 종속성 설치, Docker의 GPG 키 추가, Docker 저장소 설정, Docker 및 관련 패키지 설치, Docker 그룹 추가, Docker 서비스가 활성화되고 실행되도록 하는 등 다양한 작업이 포함되어 있습니다.\n\n단계 4: 플레이북 실행\n마지막으로 다음 명령을 사용하여 플레이북을 실행할 수 있습니다:\n\n```js\nansible-playbook -i inventory.ini playbooks/docker.yml\n\n# 또는 도커 사용\ndocker run --rm -it -v $PWD:/app -v ~/.ssh/id_rsa:/root/.ssh/id_rsa alpinelinux/ansible ansible-playbook -i app/inventory.ini app/playbooks/docker.yml\n```\n\n이 명령은 inventory.ini 파일에서 지정된 호스트에 플레이북을 실행하여 Docker를 설치합니다.\n\n<div class=\"content-ad\"></div>\n\n결론\n위 단계를 따라서 macOS 노트북에 Ansible을 성공적으로 설치하고 원격 서버에 Docker 설치를 자동화했습니다. 이는 Ansible이 다양한 시스템 간 작업을 자동화하는 데 얼마나 강력하고 간단한지를 보여줍니다.","ogImage":{"url":"/assets/img/2024-06-19-HowToInstallDockerUsingAnsible_0.png"},"coverImage":"/assets/img/2024-06-19-HowToInstallDockerUsingAnsible_0.png","tag":["Tech"],"readingTime":4},{"title":"라즈베리 파이 5에서 쿠버네티스 - 3부 마스터 노드에 K3S 설치하기","description":"","date":"2024-06-19 18:16","slug":"2024-06-19-KubernetesonRaspberryPi5Part3InstallK3Sonmasternode","content":"\n\n래즈베리 파이 4를 쿠버네티스 호스트로 약 두 년간 사용해 왔어요. 최근에 새로운 라즈베리 파이 5를 구매했어요. 새로 구매한 라즈베리 파이 5에도 쿠버네티스를 설정해 클러스터를 구성할 계획이에요.\n\n# 라즈베리 파이 5에서 K3s 설정하기\n\n부분 1 라즈베리 파이 OS Lite 64비트 설치하기\n\n부분 2 외부 저장소 연결하기\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-KubernetesonRaspberryPi5Part3InstallK3Sonmasternode_0.png\" />\n\n- 커널 구성 파일 업데이트\n\ncmdline.txt 파일에는 부팅 프로세스 중에 커널에 전달되는 명령줄 매개변수가 포함되어 있습니다. 이 파일에 몇 가지 매개변수를 추가해야 합니다. 다음 명령을 사용하여 파일을 열어보세요:\n\n```js\nsudo nano /boot/firmware/cmdline.txt\n```\n\n<div class=\"content-ad\"></div>\n\n한 줄에 매개변수 세트가 포함되어 있습니다. 줄 끝에 다음 매개변수를 추가하세요:\n\n```js\ncgroup_enable=cpuset cgroup_memory=1 cgroup_enable=memory\n```\n\n파일을 저장하고 재부팅하세요:\n\n```js\nsudo reboot\n```\n\n<div class=\"content-ad\"></div>\n\n2. 마스터 노드 설정\n\nk3s 마스터 노드가 될 장치에 연결하세요. k3s를 설치하기 전에 먼저 몇 가지 환경 변수를 추가해야 합니다.\n\n다음은 제가 사용 중인 환경 변수입니다. `MASTER_NODE_IP` 자리 표시자를 교체해야 합니다.\n\n- node-ip: k3s 에이전트 또는 서버가 실행 중인 노드(기계)의 IP 주소입니다. 이 IP 주소는 Kubernetes 제어 평면에서 노드를 식별하고 클러스터 내 통신을 용이하게 합니다.\n- bind-address: k3s 클러스터 내 Kubernetes API 서버가 수신하는 IP 주소입니다. 특히 여러 네트워크 인터페이스가 있는 시나리오에서 API 서버가 특정 네트워크에서 접근 가능한지 확인하려는 경우 유용합니다.\n- advertise-address: Kubernetes API 서버가 클러스터의 다른 구성원에게 광고하는 IP 주소입니다. 이 주소는 다른 노드 및 구성 요소가 API 서버에 연결하기 위해 사용됩니다.\n- flannel-backend: Kubernetes 클러스터 내 팟 간 네트워킹을 제공하는 Flannel 네트워크 오버레이의 백엔드입니다. Flannel은 Kubernetes용으로 설계된 레이어 3 네트워크 패브릭을 구성하는 간단하고 쉬운 방법이며, 네트워크 트래픽이 어떻게 관리되고 경로 지정되는지를 결정하는 여러 백엔드를 지원합니다.\n- disable=servicelb: 내장된 klipper-lb 서비스 로드 밸러서를 비활성화합니다. 외부 로드 밸런서를 사용하거나 사용자 정의 로드 밸런서 솔루션을 배치하거나 불필요한 구성 요소를 비활성화하여 리소스 사용량을 최적화하려는 경우 유용합니다. 저는 MetalLB를 사용할 것입니다.\n- disable=traefik: k3s와 번들링된 기본 Traefik Ingress 컨트롤러를 비활성화합니다. 이 옵션은 다른 인그레스 컨트롤러를 사용하려는 경우, 인그레스 기능이 필요하지 않은 경우 또는 사용자 정의 인그레스 설정이 필요한 경우 유용합니다. 저는 nginx를 사용할 것입니다.\n- disable-cloud-controller: 클라우드 컨트롤러 매니저를 비활성화합니다. 이 매니저는 Kubernetes를 클라우드 제공 업체 서비스와 통합하는 역할을 합니다. 이 옵션은 온프레미스 배포, 엣지 컴퓨팅, IoT 시나리오 또는 클라우드 제공 업체 통합이 필요하지 않은 상황에서 특히 유용합니다.\n- disable-helm-controller: k3s가 Helm 컨트롤러를 배포하고 사용하는 것을 방지합니다. Kubernetes 애플리케이션을 관리하는 데 Helm 차트를 수동으로 관리하거나 Helm을 사용하지 않는 경우 유용합니다.\n- cluster-init: 첫 번째 서버 노드를 설정해 새로운 Kubernetes 클러스터를 초기화하는 데 사용됩니다. 이 노드는 초기 제어 평면 노드 역할을 하고 클러스터를 위해 etcd 데이터 저장소를 준비합니다. 이 옵션은 새 클러스터를 생성할 때 중요하며, 고 가용성 설정이나 클러스터를 복구할 때 특히 유용합니다. --cluster-init로 클러스터를 초기화한 후 추가 서버 및 에이전트 노드가 클러스터에 참여하여 완전히 기능하는 Kubernetes 환경을 구성할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nexport K3S_NODE_NAME=\"pi-master\"\nexport K3S_KUBECONFIG_MODE=\"600\"\nexport INSTALL_K3S_EXEC=\"server --node-ip=<MASTER_NODE_IP> \\\n                                --bind-address=<MASTER_NODE_IP> \\\n                                --advertise-address=<MASTER_NODE_IP> \\\n                                --flannel-backend=host-gw \\\n                                --disable=servicelb \\\n                                --disable=traefik \\\n                                --disable-cloud-controller \\\n                                --disable-helm-controller \\\n                                --cluster-init\"\n```\n\n설정 중인 K3S_KUBECONFIG_MODE=\"600\"를 사용합니다. 이 환경 변수를 설정함으로써 생성된 kubeconfig 파일의 권한을 제어할 수 있습니다. 이것은 접근 제어를 관리하고 적절한 보안 설정을 적용하는 데 유용합니다. 600은 소유자 사용자가 파일 또는 디렉토리를 읽고 쓸 수 있고 다른 사용자는 액세스할 수 없음을 의미합니다.\n\n이러한 변수를 설정한 후에는 다음 명령을 실행해야합니다:\n\n```js\ncurl -sfL https://get.k3s.io | sh -\n```\n\n<div class=\"content-ad\"></div>\n\nk3s 서비스가 실행 중인지 확인하려면 다음 명령을 실행하십시오:\n\n```js\nsudo systemctl status k3s\n```\n\n출력은 아래와 유사한 텍스트 블록으로 시작됩니다:\n\n```js\n● k3s.service - 경량 Kubernetes\n     Loaded: loaded (/etc/systemd/system/k3s.service; enabled; preset: enabled)\n     Active: active (running) since Sat 2024-06-08 12:55:15 EEST; 20h ago\n```\n\n<div class=\"content-ad\"></div>\n\nK3S_KUBECONFIG_MODE=\"600을 사용했기 때문에 아직 kubectl을 사용할 수 없습니다. 환경 변수로 설정한 구성 파일을 복사해야 합니다.\n\n```js\nexport KUBECONFIG=~/.kube/config\nmkdir ~/.kube 2> /dev/null\nsudo k3s kubectl config view --raw > \"$KUBECONFIG\"\nchmod 600 \"$KUBECONFIG\"\n```\n\n환경 변수가 다시 시작 후에도 유지되려면 ~/.bashrc 파일 끝에 export KUBECONFIG=~/.kube/config 라인을 추가해야 합니다. 그런 다음 재시작하거나 이 명령어를 실행하면 됩니다: `source ~/.bashrc`.\n\n이제 kubectl을 사용할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\r\nkubectl get pods -A\r\n```\r\n\r\n다음과 같은 출력을 보게 될 거에요:\r\n\r\n```js\r\nNAME                                      READY   STATUS    RESTARTS      AGE\r\ncoredns-6799fbcd5-246w2                   1/1     Running   3 (31m ago)   44h\r\nlocal-path-provisioner-6c86858495-kmn7s   1/1     Running   5 (31m ago)   44h\r\nmetrics-server-54fd9b65b-kv4s4            1/1     Running   4 (31m ago)   44h\r\n```\r\n\r\n3. 원격으로 kubectl 설정하기\n\n<div class=\"content-ad\"></div>\n\n귀하의 머신에서 K3S 클러스터에 연결하려면 kube 구성 파일이 필요합니다.\n\n머신 터미널에서 마스터 노드에서 kube 구성 파일을 귀하의 머신으로 복사하는 다음 명령을 실행하십시오(`MASTER_NODE_IP` 플레이스홀더를 꼭 바꾸지 마십시오):\n\n```js\nscp pi@<MASTER_NODE_IP>:~/.kube/config ~/.kube/config\n```\n\n이제 원격으로 kubectl 명령을 실행할 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 완료했습니다!","ogImage":{"url":"/assets/img/2024-06-19-KubernetesonRaspberryPi5Part3InstallK3Sonmasternode_0.png"},"coverImage":"/assets/img/2024-06-19-KubernetesonRaspberryPi5Part3InstallK3Sonmasternode_0.png","tag":["Tech"],"readingTime":5},{"title":"Coral Dual Edge TPU를 Frigate를 위해 설정하는 방법","description":"","date":"2024-06-19 18:15","slug":"2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate","content":"\n\n\n![이미지](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_0.png)\n\n# 전체 비디오 튜토리얼\n\n# Coral AI PCIe 가속기 드라이버 설치\n\n여기서부터 모든 것을 간소화하는 이 스크립트를 사용하시면 됩니다.\n\n\n<div class=\"content-ad\"></div>\n\n```js\ncurl -sS https://gist.githubusercontent.com/dataslayermedia/8676e010a9121adaaab8e6dc98bca383/raw/f208dbb5e3efda51b75183c67e8dc857e375234e/Install-Coral-PCIe-Accelerator-TPU-Linux.sh | bash\n```\n\n재부팅\n\n```js\nsudo reboot\n```\n\n장치 확인\n\n<div class=\"content-ad\"></div>\n\n```js\nlspci -nn | grep 089a\n```\n\n![Link](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_1.png)\n\nApex 장치를 확인하세요\n\n```js\nls /dev/apex_*\n```\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_2.png\" />\n\n도커 설치\n\n<img src=\"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_3.png\" />\n\n```js\n# 도커의 공식 GPG 키 추가:\nsudo apt-get update\nsudo apt-get install ca-certificates curl gnupg\nsudo install -m 0755 -d /etc/apt/keyrings\ncurl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\nsudo chmod a+r /etc/apt/keyrings/docker.gpg\n\n# Apt 소스에 저장소 추가:\necho \\\n  \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \\\n  $(. /etc/os-release && echo \"$VERSION_CODENAME\") stable\" | \\\n  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\nsudo apt-get update\n```\n\n<div class=\"content-ad\"></div>\n\n```js\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n```\n\n다음 명령어로 설치를 테스트해보세요.\n\n```js\ndocker ps -a\n```\n\n<img src=\"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n# MQTT(Mosquitto) 설치\n\nMQTT 프로토콜은 발행/구독 모델을 사용하여 메시지를 전달하는 가벼운 방법을 제공합니다. 이는 저전력 센서나 휴대폰과 같은 모바일 장치, 임베디드 컴퓨터, 또는 마이크로컨트롤러와 같은 사물인터넷 메시징에 적합합니다.\n\n```js\nsudo apt install mosquitto mosquitto-clients\n```\n\n```js\nsudo systemctl is-enabled mosquitto\nsudo systemctl status mosquitto\n```\n\n<div class=\"content-ad\"></div>\n\n아래와 같이 테이블 태그를 Markdown 형식으로 변경해주세요.\n\n\n![이미지](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_5.png)\n\nMQTT 구성 파일을 편집합니다.\n\n```sh\nvim /etc/mosquitto/mosquitto.conf\n```\n\n이 두 줄을 추가하세요...\n\n\n<div class=\"content-ad\"></div>\n\n\nallow_anonymous true\nlistener 1883\n\n\n설정 파일은 다음과 같이 보일 것입니다...\n\n![이미지](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_6.png)\n\nVIM에서 “:x” 입력 후 엔터 키를 눌러 저장하고 종료하세요.\n\n<div class=\"content-ad\"></div>\n\n서비스를 저장하고 다시 시작하세요\n\n```js\nsystemctl restart mosquitto\n```\n\n# Frigate 설정\n\n![이미지](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_7.png)\n\n<div class=\"content-ad\"></div>\n\n루트 디렉터리에서 \"frigate\"라는 디렉터리를 만들어 config.yml 파일을 추가하세요.\n\n```js\ncd /\nmkdir frigate\ncd /frigate\ntouch config.yml\n```\n\nconfig.yml 파일을 편집하세요.\n\n```js\nmqtt:\n  enabled: True\n  host: 192.168.X.XXX\n  port: 1883\ncameras:\n  eyeofsauron:\n    ffmpeg:\n      # hwaccel_args: preset-vaapi\n      #hwaccel_args:\n      #  - vf:v \"fps=15\"\n      inputs:\n        - path: rtsp://192.168.X.XXX:554/mystream\n          input_args: preset-rtsp-generic\n          roles:\n            - detect\n            - record\n            - rtmp\n    detect:\n      fps: 25\n      enabled: True\n      width: 1280\n      height: 720\ndetectors:\n  coral1:\n    type: edgetpu\n    device: pci:0\n  coral2:\n    type: edgetpu\n    device: pci:1\nobjects:\n  track:\n    - person\n\nrecord:\n  # Optional: 녹화 기능 활성화 (기본값은 아래와 같습니다)\n  # 주의: 설정에서 녹화를 비활성화한 경우, 나중에 UI나 MQTT를 통해 녹화를 켜도 영향이 없습니다.\n  enabled: True\n  # Optional: 정리 실행 간격(분) 설정 (기본값은 아래와 같습니다)\n  # I/O를 최소화하기 위해 디스크에서 녹화 세그먼트를 삭제하는 빈도를 줄이려면 사용할 수 있습니다.\n  expire_interval: 60\n  # Optional: 녹화 보관 설정\n  retain:\n    # Optional: 이벤트와 관계없이 녹화 보관일 수 (기본값은 아래와 같습니다)\n    #참고: 이벤트의 녹화만 유지하려면 이 값을 0으로 설정하고 아래 이벤트 섹션에서 보관을 정의해야 합니다.\n    days: 0\n    # Optional: 보관 모드. 가능한 옵션은 다음과 같습니다: all, motion, active_objects\n    #   all - 모든 활동에 관계없이 모든 녹화 세그먼트를 저장\n    #   motion - 감지된 모션을 가진 모든 녹화 세그먼트를 저장합니다.\n    #   active_objects - 활동/움직이는 객체를 가진 모든 녹화 세그먼트를 저장합니다.\n    #NOTE: 이 모드는 위의 days 설정이 0보다 클 때만 적용됩니다.\n    mode: all\n  # Optional: 이벤트 녹화 설정\n  events:\n    # Optional: 이벤트 이전 시점을 포함할 초 수 (기본값은 아래와 같습니다)\n    pre_capture: 5\n    # Optional: 이벤트 후속 시점을 포함할 초 수 (기본값은 아래와 같습니다)\n    post_capture: 5\n    # Optional: 녹화를 위해 저장할 객체 (기본값: 추적되는 모든 객체)\n    objects:\n      - person\n    # Optional: 지정된 모든 존에 들어간 객체로 녹화를 제한 (기본값: 필수 존 없음)\n    required_zones: []\n    # Optional: 이벤트 녹화 보관 설정\n    retain:\n      # 필수: 기본 보관 일 수 (기본값은 아래와 같습니다)\n      default: 10\n      # Optional: 보관 모드 (기본값은 아래와 같습니다)\n      #   all - 활동 여부에 관계없이 이벤트를 위한 모든 녹화 세그먼트를 저장\n      #   motion - 감지된 모션을 가진 이벤트를 위한 모든 녹화 세그먼트를 저장\n      #   active_objects - 활동/움직이는 객체를 가진 이벤트를 위한 모든 녹화 세그먼트를 저장\n      #NOTE: 카메라의 보관 모드가 여기에서 구성된 모드보다 제한적이면 이 모드가 적용되는 시점에 세그먼트는 이미 삭제됩니다.\n      #       예를 들어, 카메라의 보관 모드가 \"motion\"이면 모션 없는 세그먼트는 저장되지 않으므로 여기에서 모드를 \"all\"로 설정해도 복구되지 않습니다.\n      mode: motion\n      # Optional: 객체별 보관 일 수\n      objects:\n        person: 15\n\n# Optional: 이벤트별 클립 디렉터리에 작성된 jpg 스냅샷에 대한 구성\n#NOTE: 카메라 수준에서 재정의할 수 있음\nsnapshots:\n  # Optional: jpg 스냫샷을 /media/frigate/clips에 작성 활성화 (기본값은 아래와 같습니다)\n  enabled: False\n  # Optional: 스냅샷 이미지의 깨끗한 PNG 복사 저장 (기본값은 아래와 같습니다)\n  clean_copy: True\n  # Optional: 스냅샷에 타임스탬프 추가 (기본값은 아래와 같습니다)\n  timestamp: False\n  # Optional: 스냅샷에 바운딩 박스 그리기 (기본값은 아래와 같습니다)\n  bounding_box: False\n  # Optional: 스냅샷 자르기 (기본값은 아래와 같습니다)\n  crop: False\n  # Optional: 스냅샷 크기 조정을 위한 높이 (기본값: 원본 크기)\n  height: 175\n  # Optional: 지정된 모든 존에 들어간 객체로 제한된 스냅샷 (기본값: 필수 존 없음)\n  required_zones: []\n  # Optional: 보관 설정을 위한 카메라 오버라이드 (기본값: 전역 값)\n  retain:\n    # 필수: 기본 보관 일 수 (기본값은 아래와 같습니다)\n    default: 10\n    # Optional: 객체별 보관 일 수\n    objects:\n      person: 15\n\nbirdseye:\n  # Optional: 전방향 보기 활성화 (기본값은 아래와 같습니다)\n  enabled: True\n  # Optional: RTSP를 통해 전방향 보기 다시 전송 (기본값은 아래와 같습니다)\n  #NOTE: 이를 활성화하면 전방향 보기가 항상 실행되어 CPU 사용량이 어느 정도 증가할 수 있습니다.\n  restream: False\n  # Optional: 출력 해상도의 너비 (기본값은 아래와 같습니다)\n  width: 1280\n  # Optional: 출력 해상도의 높이 (기본값은 아래와 같습니다)\n  height: 720\n  # Optional: mpeg1 피드의 인코딩 품질 (기본값은 아래와 같습니다)\n  # 1이 가장 높은 품질이고 31이 가장 낮습니다. 품질이 낮은 피드는 CPU 리소스를 적게 사용합니다.\n  quality: 1\n  # Optional: 뷰 모드. 가능한 옵션은 다음과 같습니다: objects, motion, continuous\n  #   objects - 마지막 30초 내에 추적된 객체가 있는 경우 카메라가 포함됨\n  #   motion - 마지막 30초 내에 모션을 감지한 경우 카메라가 포함됨\n  #   continuous - 모든 카메라가 항상 포함됨\n  mode: continuous\n\nlogger:\n  # Optional: 기본 로그 상세도 (기\n\n<div class=\"content-ad\"></div>\n\n이 구성은 PCIe TPU에 모두 준비가 되어 있으며 프레임에서 사람을 감지하면 녹화를 합니다. 해상도는 HD이고 프레임 속도는 높습니다(25 FPS). 이 모든 것은 필요에 맞게 조정할 수 있습니다.\n\nIP 주소를 교체해야 합니다.\n\nhostname -I\n\nIP 카메라가 있다면이 프로세스가 훨씬 쉽습니다. 하지만 제가 저렴한 웹캠을 사용하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```\n![이미지](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_8.png)\n\n프리게이트 도커 컨테이너 실행\n\n```js\ndocker run -d \\\n  --name frigate \\\n  --restart=unless-stopped \\\n  --mount type=tmpfs,target=/tmp/cache,tmpfs-size=1000000000 \\\n  --device /dev/apex_0:/dev/apex_0 \\\n  --device /dev/apex_1:/dev/apex_1 \\\n  --shm-size=512m \\\n  -v /frigate/storage:/media/frigate \\\n  -v /frigate/config.yml:/config/config.yml \\\n  -v /etc/localtime:/etc/localtime:ro \\\n  -p 5000:5000 \\\n  -p 8555:8555/tcp \\\n  -p 8555:8555/udp \\\n  ghcr.io/blakeblackshear/frigate:stable\n```\n\n노트: 우리는 apex 장치를 컨테이너로 모두 전달하고 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n로컬 네트워크에서 Frigate 웹 UI를 열어보세요.\n\n192.168.X.XXX:5000\n\n![이미지](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_9.png)\n\n# RTSP 서버 만들기\n\n<div class=\"content-ad\"></div>\n\n```js\nwget https://github.com/aler9/rtsp-simple-server/releases/download/v0.16.0/rtsp-simple-server_v0.16.0_linux_amd64.tar.gz\n```\n\n```js\ntar -xzvf rtsp-simple-server_v0.16.0_linux_amd64.tar.gz\n```\n\n```js\nRTSP_RTSPADDRESS=192.168.XXX.XXX:554 ./rtsp-simple-server\n```\n\n![How to Setup the Coral Dual Edge TPU for Frigate](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_10.png)\n\n\n<div class=\"content-ad\"></div>\n\n# RTSP 서버로 웹캠 피드 스트리밍하기\n\n```js\napt-get install ffmpeg\n```\n\n```js\nsudo ffmpeg -f v4l2 -framerate 25 -video_size 1280x720 -i /dev/video0 -pix_fmt yuv420p -b:v 2000k -f rtsp -rtsp_transport tcp rtsp://192.168.X.XXX:554/mystream\n```\n\nIP 주소를 교체하는 것을 기억해 주세요.\n\n<div class=\"content-ad\"></div>\n\n# 브라우저에서 Frigate 열기\n\n192.168.X.XXX:5000\n\n코랄 장치의 온도를 모니터링하고 싶다면 해당 작업을 수행할 수 있는 스크립트가 있어요.\n\n[해당 스크립트는 여기에서 확인할 수 있어요](https://gist.github.com/dataslayermedia/fb20aae9dea64bca286b5e6d189027b8)\n\n<div class=\"content-ad\"></div>\n\n```bash\ncurl -sS https://gist.githubusercontent.com/dataslayermedia/fb20aae9dea64bca286b5e6d189027b8/raw/a4f264ee7be546bdf5c3363bfafdc9597f9edd5c/real-time-temperature-output-coral-ai-pcie-accelerators.sh | bash\n```\n\n![Demo](https://miro.medium.com/v2/resize:fit:1280/1*S-F-NGRpvd9eVHcbkeB7RA.gif)\n\n## 제품 하드웨어 링크\n\n1080P 웹캠\n\n\n<div class=\"content-ad\"></div>\n\n아래는 표 형식을 변경한 것입니다.\n\n\n<img src=\"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_11.png\" />\n\nCoral AI Dual Edge TPU\n\n<img src=\"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_12.png\" />\n\nZima Board\n\n\n<div class=\"content-ad\"></div>\n\n\n![Dual Edge TPU Adapter Low Profile](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_13.png)\n\n![Dual Edge TPU Adapter Low Profile](/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_14.png)\n","ogImage":{"url":"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_0.png"},"coverImage":"/assets/img/2024-06-19-HowtoSetuptheCoralDualEdgeTPUforFrigate_0.png","tag":["Tech"],"readingTime":10},{"title":"라즈베리 파이 3, GoPiGo3 및 Python으로 로봇 프로그래밍하기","description":"","date":"2024-06-19 18:13","slug":"2024-06-19-ProgrammingaRobotwithRaspberryPi3GoPiGo3andPython","content":"\n\n대학 시절, 25년 전, 나는 테니스 공을 모으는 간단한 로봇을 제작했었습니다. 그러나 그 지식은 시간이 흘러서 잊혀졌습니다. 2020년의 글로벌 대유행으로 인한 봉쇄와 재택근무의 전환은 내가 잊고 있던 로봇공학에 대한 관심을 다시 일으켰습니다. 즐거워하는 것을 넘어, 이것을 제기회로 나의 기술을 향상시키고 내 아이들에게 영감을 줄 수 있는 좋은 기회라고 생각했습니다. 나는 로봇공학에 대한 나의 이해를 더 깊게 하고 나만의 로봇을 만들기 위한 여정에 나서기로 결정했습니다. 본 기사는 내가 로봇공학에 대해 배운 것을 공유하는 시리즈의 첫 번째 글입니다.\n\n나는 플랫폼과 프로그래밍 언어로 Raspberry Pi와 Python을 선택했습니다. 그 이유는 그들의 인기와 확장된 커뮤니티 지원 때문입니다. 로봇 하드웨어에 대해선 두 가지 선택지가 있었습니다: Arduino, 모터 드라이버, 그리고 다른 구성 요소를 사용해 모든 것을 처음부터 만들거나, 이미 구성되어있는 소프트웨어 개발 키트(SDK)가 함께 제공되는 로봇 키트를 구매하는 것입니다. 나는 주로 소프트웨어 개발에 관심이 있기 때문에 후자를 선택했습니다.\n\n# 로봇 키트\n\n나의 조사 결과, Dexter Industries는 두 가지 매력적인 옵션을 제공합니다. GoPiGo3는 간단한 로봇 챠시와 함께 모터와 센서를 제어하기 위한 HAT가 포함된 완전한 로봇 키트입니다. 반면에 BrickPi3는 레고 EV3 모터와 센서를 제어하기 위해 설계된 Raspberry Pi HAT입니다. 두 제품 모두 Python SDK를 제공합니다. GoPiGo3는 저렴하고 완성도가 높아 초보자에게 가장 적합한 플랫폼입니다; 나는 단지 Raspberry Pi를 추가하면 작동하는 로봇을 갖게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n업데이트: 저는 2020년에 Raspberry Pi 3가 최고 모델이었던 때 이 프로젝트를 시작했습니다. 그 당시 사용 가능한 HAT은 GoPiGo, BrickPi, PiStorm이 있었습니다. GoPiGo는 전통적인 모터와 호환되었고, BrickPi와 PiStorm은 레고 EV3 모터용으로 설계되었습니다. 또한 시도해보지 않은 중국 제작 로봇 키트도 있었습니다. 이제 2024년에는 Raspberry Pi 5가 출시되었고, Lego SPIKE Prime 모터 또는 센서 4개를 제어할 수 있는 Raspbery Pi Build Hat도 함께 출시되었습니다.\n\nGoPiGo 샤시 조립 부분은 건너뛰고 GoPiGo 로봇 키트가 준비되어 있다고 가정할게요. 판매업자 웹사이트에서 매우 좋은 설명서가 이미 있기 때문입니다. 소프트웨어 측면에서, 저는 2020년에 Raspbian OS Buster와 GoPiGo3 SDK를 설치했습니다. 지금은 무료 Dexter OS를 사용할 수도 있습니다. 제 이해로는 미리 설치된 GoPiGo3 소프트웨어를 가진 사용자 정의 Raspbian OS입니다. 이것은 더 간단하고 빠른 방법일 수 있습니다. 파이썬과 기타 프로그래밍 언어 외에도, GoPiGo3는 그래픽 기반 프로그래밍 언어인 Scratch도 지원합니다. 나중에 아이들과 함께 그 쪽을 더 탐구할 계획입니다.\n\n이것은 제 GoPiGo3 로봇의 하드웨어 요약입니다.\n\n- Raspberry Pi 3\n- GoPiGo3 HAT\n- 이동을 위한 두 개의 모터\n- 팬 및 틸트를 위해 두 개의 서보 모터에 연결된 Pi 카메라\n- 거리 센서\n- 라인 추적 센서\n- 12V 충전식 배터리\n- 커스텀 레고 케이스에 수납된 미니 블루투스 스피커\n- 키보드 및 게임 패드용 USB 수신기\n\n<div class=\"content-ad\"></div>\n\n# 소프트웨어 설치\n\n로봇 키트를 조립한 후에 라즈베리 파이에 운영 체제와 GoPiGo3 SDK를 설치해야 합니다.\n\n- 무료 소프트웨어인 Etcher와 같은 프로그램을 사용하여 Raspbian Buster 이미지를 마이크로 SD 카드에 다운로드하고 불러옵니다. 이 소프트웨어는 매우 직관적입니다.\n- 라즈베리 파이를 부팅하고 화면 안내에 따라 초기 설정을 완료합니다.\n- 다음 명령어를 사용하여 GoPiGo3 SDK를 설치합니다.\n\n```js\n# GoPiGo3 SDK를 최신 버전으로 설치하거나 업데이트합니다\ncurl -kL dexterindustries.com/update_gopigo3 | bash\n# Dexter 센서(예: 라인 팔로워, 거리 센서)를 설치하거나 업데이트합니다\ncurl -kL dexterindustries.com/update_sensors | bash\n```\n\n<div class=\"content-ad\"></div>\n\n# 프로그래밍\n\n이제 재미있는 부분인 로봇을 Python을 사용하여 프로그래밍하는 방법으로 넘어가 봅시다. 다음 코드는 로봇을 움직이고 카메라를 팬 및 틸트하는 방법을 보여줍니다.\n\n마무리하기 전에, 다음 기사에서 사용할 GoPiGoRobot이라는 Python 클래스를 만들어 봅시다. 우리 코드의 요약은 다음과 같습니다.\n\n- GoPiGo3 SDK 호출을 친숙한 클래스 메서드로 캡슐화합니다.\n- try-except 문을 사용하여 하드웨어 액세스 예외를 처리합니다.\n- 코드가 다중 스레드가 될 것으로 예상되므로 코드가 스레드로부터 안전하게 접근하도록 하드웨어 액세스를 상호 배타적으로 제공합니다. 이를 위해 하드웨어 액세스 코드를 _lockAndExceptionHandler 데코레이터로 꾸밈으로써 간결함과 편리함을 위해 목적을 달성합니다.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n우리는 이 기사를 라즈베리 파이용 로봇 키트에 대한 토론으로 시작했습니다. 우리는 프로젝트에 GoPiGo를 사용하기로 결정했습니다. 그런 다음 Raspbian 운영 체제와 GoPiGo SDK를 설치하는 방법을 보여주었습니다. 마지막으로, 우리는 우리 로봇에 약간의 운동을 시키는 간단한 프로그램을 시연했습니다. 다음 기사에서는 로봇에 대한 더 많은 옵션을 탐구할 것입니다.","ogImage":{"url":"/assets/img/2024-06-19-ProgrammingaRobotwithRaspberryPi3GoPiGo3andPython_0.png"},"coverImage":"/assets/img/2024-06-19-ProgrammingaRobotwithRaspberryPi3GoPiGo3andPython_0.png","tag":["Tech"],"readingTime":3},{"title":"Raspberry Pi 5에서 Ollama를 사용하지 않고 Llama를 실행하기","description":"","date":"2024-06-19 18:11","slug":"2024-06-19-RunLlamaonyourRaspberryPi5withoutusingOllama","content":"\n\n그래서 저는 작년 12월에 Raspberry Pi 5 8GB를 구입한 이후로 계속해서 시도해보고 있어요. 그전에 LLM을 설치하는 많은 안내서를 찾았지만 문제에 부딪히며 쉽게 해결할 수 없었어요. 이는 LLM을 회수/구축/양자화해야 하는 원본 컴퓨터와 제 RPi5에 필요한 모든 것을 설치하지 못했기 때문에 발생한 문제의 일부입니다.\n\n그래서 저는 여기에 내가 막혔던 부분을 정확히 지적하고 이를 어떻게 해결했는지를 써 놓은 가이드를 작성하게 되었어요.\n\n그러므로 이것은 전적으로 제가 혼자서 완전히 해결한 가이드는 아니에요 (저는 이런 주제에 대해 전문가가 아닌 걸로 아요), 다만 누군가가 곤란해할 때 도움이 될 수 있는 가이드에요.\n\n저는 LinkedIn에서 발견한 Marek Żelichowski의 이 가이드를 주로 사용했고, 제 기기에서 작동하는 데 필요한 단계를 추가했어요. 그는 자신의 블로그 맨 아래에 여러 사람/소스의 입력을 토대로 한 결과라고 명시하긴 했지만, 공정한 평가를 해야하며, Ollama를 요구하지 않는 저에게는 제게 도움이 된 소수의 가이드 중 하나였어요.\n\n<div class=\"content-ad\"></div>\n\n인용 위치(외부 게시물 및 사이트 링크)를 제공하려고 노력했지만, 빠진 인용이 있으면 알려주시면 기쁘게 추가하겠습니다. 그럼 시작해볼까요!\n\n# 필요한 것\n\n- LLM('들')을 검색하고 양자화하기 위한 Windows 또는 Linux 배포로 충분한 소스 PC\n- LLM을 실행할 8GB 라즈베리 파이 5\n- Raspbian과 같은 미리 설치된 OS가 포함된 적어도 32GB의 메모리 카드 (제가 개인적으로 RPi에는 Ubuntu 23.04를 사용합니다)\n- 소스 PC에서 RPi로 LLM을 전송하기 위해 적어도 22GB의 공간이 있는 USB 스틱\n\n# 소스 PC 준비하기\n\n<div class=\"content-ad\"></div>\n\n우리는 (Linux 기반) 소스 PC에서 시작합니다. 저는 Linux 디스트로로 PC를 재설치하거나 듀얼 부팅하는 일을 하기 귀찮아해 소유하지 않기 때문에 \"WSL\"을 사용하기로 결정했습니다. 이는 Windows 환경에서 Linux 디스트로를 직접 실행할 수 있는 Microsoft의 내장 기능입니다. 이미 Linux PC에서 작업하고 있는 분들은 아래 단계가 필요하지 않을 수 있습니다.\n\n## WSL 설치 방법:\n\nWindows PC에서 WSL을 설정하는 데 이 안내서를 사용했다는 점을 유의하세요.\n\n먼저 PowerShell을 관리자 권한으로 실행합니다. 이를 위해 PowerShell에 마우스 오른쪽 버튼을 클릭하고 \"관리자 권한으로 실행\" 옵션을 선택합니다. 여러분의 기기의 보안 구성 방식에 따라 실행에 관리자 암호를 입력해야 할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-RunLlamaonyourRaspberryPi5withoutusingOllama_0.png\" />\n\n열리는 PowerShell 창에서 다음 명령을 실행하세요:\n\n이 명령을 실행하면 작업에 사용할 OS로 Ubuntu가 설치됩니다. 또한 다음 명령을 사용하여 wsl을 통해 직접 설치할 수 있는 특정 Linux 배포판을 선택할 수도 있습니다.\n\n<img src=\"/assets/img/2024-06-19-RunLlamaonyourRaspberryPi5withoutusingOllama_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n다음 설치 명령에 설치하고 싶은 배포판을 선택하세요. 기본값을 사용했지만 Ubuntu 22.04를 실행하려면 다음 명령을 사용하면 됩니다.\n\n설치가 완료되면 다음 명령을 사용하여 설치되었는지 확인할 수 있습니다.\n\n\nAfter the installation is done, you can verify that it is installed with this command\n\n\nWSL 설치 후 컴퓨터를 다시 시작하는 것이 강력히 권장됩니다. 재부팅 후 시작 메뉴에서 Linux 배포판을 찾을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-RunLlamaonyourRaspberryPi5withoutusingOllama_3.png\" />\n\n이 프로그램 중 하나를 열면 Ubuntu 설치에 대한 명령 프롬프트 (CMD)가 열립니다. 이 명령을 사용하여 Llama 프로젝트를 다운로드하고 빌드하고, Raspberry Pi에서 실행할 수 있는 모델을 다운로드하고 양자화할 것입니다.\n\n## Linux 소스 PC 설정하기\n\n이제 Ubuntu 설치가 준비된 상태이거나 위 단계를 건너뛴 경우는 리눅스 배포판을 이미 실행 중이라면, 아래 단계를 실행하기 위해 필요한 종속성을 설치하는 시간입니다.\n\n<div class=\"content-ad\"></div>\n\n먼저, 시스템이 최신 상태인지 확인하고 싶어요.\n\n그 다음으로, 우리는 Llama.cpp 프로젝트를 환경에 클론/다운로드할 때 사용할 Git을 설치하고 싶어요.\n\n마지막으로, 프로젝트를 만들고 LLM을 양자화하는 데 필요한 일부 도구를 설치해야 해요.\n\n이 단계에서 많은 어려움을 겪었어요. 시스템이 2가지에 대해 불평했는데, 지금 설명할게요.\n\n<div class=\"content-ad\"></div>\n\n파이프가 발견되지 않았어요. 그래서 Pip을 설치하기 위해 Python 패키지를 사용하여 apt install의 일부로 Pip을 설치해야 했어요.\n\n이 문제로 x509 오류가 계속해서 발생했는데, \"self-signed certificate in certificate chain\"라는 오류가 떴어요. 자세한 내용에 대해 들어가지 않으면서 이 오류는 네트워크 구성에 문제가 있어서 해결할 수 없다는 것을 의미해요. 이 문제를 해결하기 위해 여러 가지 방법을 시도했지만 결국 해결책을 찾지 못했어요. 문제는 프록시나 방화벽 뒤에서 시도했기 때문에 구성을 올바르게 설정하는 것이 거의 불가능했을 수도 있어요. 그래서 이런 제한 사항이 없는 다른 시스템으로 전환하면서 모든 것이 완벽하게 작동했어요.\n\n가장 중요한 것은 \"python3 -m pip install\" 명령을 실행할 때 \"externally managed environment\"에 있다는 오류가 나타났고, 작동을 위해 특정 가상 환경(venv)을 사용해야 한다는 것이었어요. 그래서 제가 그것을 사용하려고 했지만 작동하지 않았어요. 그래서 제가 한 해결책은 \"외부 환경\"이라고 불리는 심볼릭 링크를 제거하는 것이었어요. stackoverflow의 이 게시물에서 답변 중 한 댓글을 인용해 보면;\n\n이 모든 문제가 해결됐으니 이제는 Pip을 통해 종속성을 설치하는 데 더 이상 문제가 없을 거에요.\n\n<div class=\"content-ad\"></div>\n\n마지막으로, G++와 Build Essential을 설치해야 합니다.\n\n## Llama 프로젝트 다운로드 및 빌드\n\nLlama 프로젝트를 워크스페이스로 다운로드하기 위해 \"git clone\" 명령어를 사용할 것입니다.\n\n다운로드가 완료되면 방금 다운로드한 폴더로 이동합니다.\n\n<div class=\"content-ad\"></div>\n\n이제 우리는 모델을 실행하는 데 필요한 파일을 생성하는 프로젝트를 \"만들\"할 것입니다.\n\n![이미지](/assets/img/2024-06-19-RunLlamaonyourRaspberryPi5withoutusingOllama_4.png)\n\n이 작업이 진행 중이거나 완료된 후에, RPi5에서 실행할 모델 중 하나를 다운로드할 수 있습니다. 모델은 huggingface와 같은 원본에서 다운로드할 수 있지만, 제가 따라온 튜토리얼은 토렌트 클라이언트와 함께 사용할 수 있는 자석 링크를 사용했습니다. 저는 QBitTorrent라는 클라이언트를 사용했는데, 이는 다음과 같이 설치할 수 있습니다.\n\n설치가 완료되면 다음 명령을 사용하여 애플리케이션을 열 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n토렌트 클라이언트의 GUI가 열립니다. \"링크\" 아이콘을 클릭하여 자석 링크를 추가하고 다음 자석 링크를 붙여넣을 수 있습니다.\n\nRPi5를 7B 모델로 실행해보려고 합니다 (다른 모델들은 많이 크고 많은 용량이 필요합니다). 그래서 7B 폴더와 그 하위 파일(tokenizer.checklist.chk 및 tokenizer.model)만 선택하려고 합니다.\n\n<img src=\"/assets/img/2024-06-19-RunLlamaonyourRaspberryPi5withoutusingOllama_5.png\" />\n\n파일 다운로드가 완료되면 이를 \"llama.cpp/models\" 폴더로 복사합니다. 이를 터미널의 명령줄을 통해 하거나 파일 탐색기 GUI를 열어서 수행할 수 있습니다. 다음 명령어는 현재 폴더에서 파일 탐색기를 엽니다. 그러면 7B 폴더와 tokenizer 파일을 찾아서 llama.cpp/models 폴더에 복사할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-RunLlamaonyourRaspberryPi5withoutusingOllama_6.png\" />\n\n이제 RPi5에서 실행할 수 있게 모델을 양자화하기 전에 JSON 파일을 편집해야 합니다. 이 파일에는 모델 빌드를 중단시킬 값이 포함되어 있습니다. 이 값을 파일에 포함된 이유에 대한 불확실성이 있습니다. 해당 값을 조정하면 모든 것이 원활하게 작동합니다.\n\nllama.cpp/models/7B 폴더에서 \"params.json\" 파일을 찾아 엽니다. 이 파일을 편집할 때 VIM을 사용했습니다.\n\nVIM으로 파일을 열었으면 \"i\"를 눌러 삽입(편집) 모드로 진입하세요. \"vocab_size\" 값을 -1에서 32000으로 수정합니다. 편집을 마쳤으면 편집 모드를 종료하려면 \"ESC\" 키를 누릅니다. 변경 내용을 저장하려면 콜론 \":\"를 입력한 후 \"wq\"를 입력합니다. \"Enter\" 키를 눌러 진행하세요. 그러면 파일이 업데이트됩니다!\n\n<div class=\"content-ad\"></div>\n\n![이미지](/assets/img/2024-06-19-RunLlamaonyourRaspberryPi5withoutusingOllama_7.png)\n\n이제 모델을 GGML FP16 형식으로 변환해야 합니다. 이 작업은 PC 성능에 따라 다소 시간이 걸릴 수 있습니다. 여기서 주목해야 할 점은 라즈베리 파이에서 작동하지 않는 부분이라는데요. 모델을 변환하기 위해 내장된 기능을 사용합니다. llama.cpp 폴더에서 이를 실행합니다(우리의 명령이 \"models/\"로 시작하는 이유입니다).\n\n변환 작업이 완료되면 모델을 양자화해야 합니다. 이 큰 모델을 보다 효율적으로 작동하도록 하는 것입니다. 사용한 튜토리얼에서 인용하면:\n\"이는 모델에서 사용되는 모든 신경망 가중치를 float16에서 init8로 변경하여 성능이 좋지 않은 기기에서 더 간편하게 처리할 수 있게 만드는 것을 의미합니다. 더 자세히 알아보는 것을 강력히 권장합니다(필수는 아님).\"\n\n양자화를 수행하기 위해 기존 기능을 다시 사용합니다.\n\n<div class=\"content-ad\"></div>\n\n양자화 후, llama.cpp 폴더에서 다음 명령을 실행하여 모델이 작동하는지 확인할 수 있습니다.\n\n모델을 찾을 수 없다는 오류가 발생했어요.\n\n![이미지](/assets/img/2024-06-19-RunLlamaonyourRaspberryPi5withoutusingOllama_8.png)\n\n다행히도 명확한 원인을 찾았어요. chat.sh 스크립트가 \"llama-7b\" 폴더를 찾기를 기대했지만, \"7B\" 폴더를 다운로드했었어요. 폴더의 이름을 바꾸면 이 문제가 해결됩니다.\n\n<div class=\"content-ad\"></div>\n\n이제 LLM이 작동되고, Bob이라는 챗봇도 있어서 질문을 할 수 있겠어요!\n\n![Bob Chatbot](/assets/img/2024-06-19-RunLlamaonyourRaspberryPi5withoutusingOllama_9.png)\n\n이제 모든 것이 작동된다는 것을 알았으니, 다음 단계는 \"모델\" 폴더에서 \"llama-7b\" 폴더를 USB 스틱에 복사하는 것입니다.\n\n# 라즈베리 파이에 LLM 설치하기\n\n<div class=\"content-ad\"></div>\n\n이제 RPi5를 부팅하고 아직 열지 않았다면 터미널을 열어주세요 (CTRL+ALT+T). 우리는 llama 프레임워크를 Pi에도 필요하기 때문에 원본 PC에서 한 것과 같은 몇 가지 명령을 실행해야 합니다. 먼저 시스템이 최신 상태인지 확인하고 프로젝트를 복제하기 위해 Git이 설치되어 있는지 확인해주세요.\n\n다음으로, 우리는 원본 PC에서 했던 것과 같이 llama.cpp 프로젝트를 복제합니다.\n\n라이센스에 설치한 것과 같은 모듈을 설치합니다. 노트북에서 필요했던 해결책을 기억해 주세요. RPi5에서도 필요할 수 있기 때문입니다.\n\n이제 G++와 Build Essential이 설치되어 있는지 확인해주세요.\n\n<div class=\"content-ad\"></div>\n\nllama.cpp 폴더로 이동해서 llama 프로젝트를 만들어보세요\n\n다음으로 외부 드라이브에서 내용을 llama.cpp 프로젝트의 /models/ 폴더로 이동해보세요. 외부 하드 드라이브가 제대로 감지되거나 마운트되지 않아 문제가 생겼는데요. 다행히도 인터넷의 도움을 받아 문제를 해결했어요.\n\nStackoverflow의 이 게시물을 참고하여 다음 명령어를 얻었어요.\n\n이 명령어는 사용 가능한 디스크를 나열합니다. 여기서 외부 하드 드라이브나 USB 스틱을 찾을 수 있어요\n\n<div class=\"content-ad\"></div>\n\n예를 들어, 외장 드라이브가 /dev/sdxn에 발견되었다면, 명령은 다음과 같을 것입니다.\n\n마운트가 성공적으로 완료된 후, 외장 드라이브의 내용은 /mnt 폴더에서 찾을 수 있습니다. 명령줄 대신 파일 탐색기를 사용하여 파일을 시각적으로 복사하려면, /mnt 폴더로 이동하여 다음을 실행하세요.\n\n이제 해야 할 일은 원본 PC에서 한 것과 정확히 같은 방식으로 모델을 실행하는 것뿐입니다. llama.cpp 폴더 안에서 다음 명령을 실행하세요\n\n![image](/assets/img/2024-06-19-RunLlamaonyourRaspberryPi5withoutusingOllama_10.png)\n\n<div class=\"content-ad\"></div>\n\n위에서 말씀드린 대로 Raspberry Pi 5에서 자체 AI 챗봇을 작동시키고 있습니다! 라마는 RPi5에서 매끄럽게 작동하지는 않지만, 이렇게 작은 장치에서 이렇게 큰 모델이 효율적으로 작동할 수 있다는 점이 매우 멋지다는 것을 알려드리고 싶습니다. 제가 본 스크린샷을 보면이 모델이 가지고 있는 \"지식\"에 대해 완전히 확신을 갖지 못하겠지만요. 그럼에도 불구하고, 우리가 질문을 하면 응답을 생성해주는 점은 아주 멋집니다. 이것이 바로 생성적 AI가 하는 일이라고 볼 수 있습니다.\n\n다시 말씀드리지만, 이 블로그/튜토리얼에서 다루는 주제에 대해 전문가는 아닙니다. 초기 크레딧은 Marek Żelichowski에게 드리며 그의 블로그/튜토리얼에서 한 작업에 있습니다. 저의 목표는 온라인에서 찾을 수 있는 일부 튜토리얼을 따를 때 어려움을 겪었던 일부 단계를 명확하게 설명하는 것이었습니다.","ogImage":{"url":"/assets/img/2024-06-19-RunLlamaonyourRaspberryPi5withoutusingOllama_0.png"},"coverImage":"/assets/img/2024-06-19-RunLlamaonyourRaspberryPi5withoutusingOllama_0.png","tag":["Tech"],"readingTime":8}],"page":"69","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":3},"__N_SSG":true}