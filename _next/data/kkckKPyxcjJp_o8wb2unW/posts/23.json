{"pageProps":{"posts":[{"title":"Mac에서 NVM과 Nodejs 설치하는 방법  영구적인 솔루션","description":"","date":"2024-06-23 15:41","slug":"2024-06-23-HowtoinstallNVMNodeJsinMacOsPermanentSolution","content":"\n\n참고: 생각 많이 하지 마세요, 그냥 복사해서 붙여 넣으세요.\n\n먼저 아래 명령어를 사용하여 Homebrew를 설치해야합니다:\n\n```js\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n```\n\n이 명령어가 작동하지 않으면 네트워크를 변경해보세요.\n이미 Homebrew가 설치되어있는 경우에는 위의 명령어를 무시하세요.\n\n<div class=\"content-ad\"></div>\n\n이제 다음 명령어를 실행해주세요 :\n\n```js\nbrew install nvm\n```\n\n그 다음에는 다음 명령어를 실행하여 NVM을 위한 디렉토리를 생성해주세요 :\n\n```js\nmkdir ~/.nvm\n```\n\n<div class=\"content-ad\"></div>\n\n디렉터리를 생성한 후에는 다음의 라인을 셸 구성 파일에 추가해주세요 (nano ~/.zshrc 또는 nano ~/.bashrc) :\n\n```js\nexport NVM_DIR=\"$HOME/.nvm\"\n[ -s \"/usr/local/opt/nvm/VERSION/nvm.sh\" ] && . \"/usr/local/opt/nvm/VERSION/nvm.sh\"\n```\n\n위 코드에서 VERSION 부분을 원하는 버전으로 바꾼 후 ctrl O를 눌러 저장하고, 그런 다음 ctrl X로 종료하세요.\n\n오류 없이 작업하기 위해서 usr/local/opt/nvm 으로 이동한 후, 특정 버전이 있는지 확인하고 VERSION을 실제 버전으로 교체하세요.\n\n<div class=\"content-ad\"></div>\n\n만약 버전이 없고 nvm.sh가 nvm 폴더 안에 있으면 상단 명령어에서 VERSION을 제거하세요.\n\n아직 작동하지 않는다면 nvm.sh를 수동으로 찾아보세요 (보통 /usr/local/opt/에 남아 있습니다) 그리고 해당 경로를 찾아서 상단 명령어의 경로로 대체하세요.\n\n그리고 터미널을 다시 시작하세요.\n\nNode Js를 설치하려면 이렇게 입력하세요:\n\n<div class=\"content-ad\"></div>\n\n```js\nnvm 20 설치\n```\n\n실제로 설치하려는 버전으로 \"버전\"을 대체하여 특정 버전을 설치할 수 있습니다 (안정적이고 기본 값인 20을 사용하고 있습니다) :\n\n```js\nnvm install <version>\n```\n\n이제 노드 JS 및 NVM 버전 또는 설치를 확인하려면 다음을 사용하세요 :\n\n<div class=\"content-ad\"></div>\n\n```js\nnvm ls\n```\n\n또한 nvm -v 또는 node -v을 사용할 수 있습니다. 이 명령어들은 NVM 또는 Node의 버전 정보만 표시할 것입니다. 하지만 nvm ls 명령어는 모든 정보를 표시할 것입니다.\n\n<img src=\"/assets/img/2024-06-23-HowtoinstallNVMNodeJsinMacOsPermanentSolution_0.png\" />","ogImage":{"url":"/assets/img/2024-06-23-HowtoinstallNVMNodeJsinMacOsPermanentSolution_0.png"},"coverImage":"/assets/img/2024-06-23-HowtoinstallNVMNodeJsinMacOsPermanentSolution_0.png","tag":["Tech"],"readingTime":2},{"title":"프로그래머를 위한 더 나은 MacOS 터미널 iTerm2 없이 zsh 사용하는 방법","description":"","date":"2024-06-23 15:40","slug":"2024-06-23-BetterMacOSTerminalforProgrammersUsezshwithoutinstallingiTerm2","content":"\n\n![이미지](/assets/img/2024-06-23-BetterMacOSTerminalforProgrammersUsezshwithoutinstallingiTerm2_0.png)\n\n# 👋 소개\n\n터미널 애플리케이션은 MacOS에서 가장 중요한 애플리케이션 중 하나이며 아마도 가장 중요한 애플리케이션입니다. MacOS에는 여러 내장 셸이 있지만 대부분의 사용자는 zsh 또는 bash 셸을 사용합니다. Mac에서 사용 중인 터미널을 확인하려면 터미널을 열고 다음을 입력하십시오.\n\n```js\necho $SHELL\n```\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 MacOS의 내장 zsh 터미널을 구성하는 방법을 살펴볼 것입니다. Mac에서 zsh 터미널이 설치되어 있는지 확인하려면 다음 명령을 입력하십시오.\n\n```js\ncat /etc/shells | grep \"zsh\"\n```\n\nMac에 zsh 셸이 설치되어 있는지 확인했다면 Mac 터미널을 다양하게 활용할 수 있습니다. 그러나 그렇지 않다면 zsh 터미널을 설치해야 합니다. Homebrew가 설치되어 있어야만 zsh 터미널을 설치할 수 있습니다. Homebrew는 MacOS용 패키지 관리자 도구이며 우리는 zsh 셸을 변경하기 위해 이 도구가 필요합니다.\n\n# 🍺 Homebrew 설치하기\n\n<div class=\"content-ad\"></div>\n\n홈브루를 설치하려면 아래 안내에 따라 간단히 설치할 수 있어요.\n\n- 홈브루를 설치하려면 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"를 실행하세요.\n- 설치 후, 터미널에서 화면에 표시된 지침대로 두 개의 명령을 실행하게 됩니다.\n  1번 명령 → echo `eval \"$(/opt/homebrew/bin/brew shellenv)\"` `` /Users/`사용자명`/.zprofile\n  2번 명령 → eval \"$(/opt/homebrew/bin/brew shellenv)\"\n- 홈브루가 올바르게 설치되었는지 확인하려면 터미널에 brew를 입력하세요.\n\n# 💻 zsh 설치하기\n\nzsh 터미널이 없다면 cat /etc/shells | grep \"zsh\"를 실행했을 때, zsh가 나오지 않는다면 Homebrew로 zsh를 설치할 수 있어요. brew install zsh를 입력하여 zsh를 설치한 후, 다시 cat /etc/shells | grep \"zsh\"를 입력하여 zsh 터미널이 정상적으로 설치되었는지 확인하세요.\n\n<div class=\"content-ad\"></div>\n\n그 후 아래 명령어를 입력하여 기본 터미널을 zsh 터미널로 변경하세요.\n\n```js\nchsh -s /bin/zsh\n```\n\n변경 사항이 올바르게 적용되었는지 확인하려면 터미널을 다시 시작하세요.\n\n# 🎨 oh-my-zsh\n\n<div class=\"content-ad\"></div>\n\n이제 터미널에 색을 입혀봐요 🎨 아래 지시 사항을 따라주세요.\n\n- git 설치하기 → brew install git\n- oh-my-zsh 설치하기 → sh -c \"$(curl -fsSLhttps://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"\n- 터미널에 필요한 글꼴 다운로드 및 설치하기 → https://github.com/Falkor/dotfiles/blob/master/fonts/SourceCodePro%2BPowerline%2BAwesome%2BRegular.ttf\n- powerlevel10k 테마 설치하기 → git clonehttps://github.com/romkatv/powerlevel10k.git$ZSH_CUSTOM/themes/powerlevel10k\n- .zshrc 파일 열기 → open ~/.zshrc, 그리고 $ZSH_THEME을 powerlevel10k로 업데이트하기 → ZSH_THEME=\"powerlevel10k/powerlevel10k\"\n- 터미널을 다시 시작하고 화면 안내에 따라 터미널을 아름답게 꾸며보세요 🌈✨\n\n# 🤔 자동 제안\n\n터미널을 아름답게 만드는 것 외에도, zsh 터미널에서도 자동 제안 기능을 사용할 수 있어요. 자동 제안 기능을 사용하려면 아래 지시 사항을 따라주세요.\n\n<div class=\"content-ad\"></div>\n\n- git 저장소를 복제하고 설치하세요 → git clone https://github.com/zsh-users/zsh-autosuggestions $'ZSH_CUSTOM:-~/.oh-my-zsh/custom'/plugins/zsh-autosuggestions \n- .zshrc 파일을 업데이트하세요 → plugins=(zsh-autosuggestions) (이미 플러그인 섹션에 git이 있는 경우에는 plugins=(git zsh-autosuggestions)로 작성)\n- .zshrc 파일을 소스하세요 → source ~/.zshrc\n\n이제 멋지고 더 나은 터미널을 사용해서 프로젝트를 작업할 수 있게 되었습니다! 😊\n\n# 📚참고 자료\n\n- Gastón Festari의 Zsh로 셸 스크립팅 배우기\n- Joe Kissell의 터미널로 Mac 명령줄 제어하기, 3판","ogImage":{"url":"/assets/img/2024-06-23-BetterMacOSTerminalforProgrammersUsezshwithoutinstallingiTerm2_0.png"},"coverImage":"/assets/img/2024-06-23-BetterMacOSTerminalforProgrammersUsezshwithoutinstallingiTerm2_0.png","tag":["Tech"],"readingTime":3},{"title":"하루하루 유용한 도구들, 2024 최신판","description":"","date":"2024-06-23 15:39","slug":"2024-06-23-DaytoDayToolsthe2024edition","content":"\n\n2017년부터 내가 매일 사용하는 도구에 대해 쓴 것 같아; 얼마나 많이 변했는지 궁금하네. 🤔\n\n내가 macOS 사용자라는 건 이미 알고 있을 거라 생각해, 그래서 이 포스트에서 다루는 모든 도구들은 주로 맥에서 돌아가. 🍎\n\n# 데스크톱 앱 💻\n\n- Visual Studio Code : 여전히 내 기본 IDE야; 인프라스트럭처 코드뿐만 아니라 작성하고 디버그해야 하는 모든 코드에 사용해, 정말로 대부분의 시간이 디버깅에 쓰이는 중이야. 🐛\n- Sublime Text : 원시 텍스트 편집을 위해, 꽤 기본적인 Sublime Text를 사용해.\n- Paste : 몇 년 동안 Paste를 사용해왔어. 장치 간에 복사한 모든 것을 손쉽게 찾아볼 수 있는 데이터베이스에 저장하는 건 훌륭해 — 지금은 없으면 어떡하지 모르겠어, 모든 게 빠르게 [CMD]+[Shift]+V로 해결돼 af.\n- 1Password : 1Password는 내 비밀번호 관리자로 선택했고, 블로그를 시작한 지 열 년이 넘었는데도 그 데로 사용하고 있어! 🔒\n- Draw.io : MacOS 사용자로서, 아마 Visio의 \"멋있음\"을 경험하지 못할 거야 — 다행히도, 이 도구는 그걸 압도해. 😃 🎨\n- Bear Notes : 노트 애플리케이션들이 왔다갔다하지만, Bear Notes는 여전히 내 최고 앱이야. 깔끔한 인터페이스, 강력한 마크다운 지원, 그리고 장치 간에 원활한 동기화를 제공해. 🐻📝\n- Ivory : 이 앱은 강력하고 기능이 풍부하며 Tweetbot처럼 Mastodon 클라이언트를 필요로 하는 사람들에게 완벽해. Ivory는 부드럽고 사용자 정의 가능한 사용자 경험을 제공해, 소셜 미디어에서 연결되어 있고 참여하는 게 쉽게 해줘. 🐘💬\n- iTerm2 : iTerm이 내 최선의 터미널 에뮬레이터야. 기본 터미널 앱보다 더 많은 기능과 사용자 정의 옵션을 제공해, 분할 창, 사용자 정의 색 구성표, 그리고 포괄적인 키보드 바로 가기를 포함해. 💻\n\n<div class=\"content-ad\"></div>\n\n# 터미널 앱 ⌨️\n\n- **OpenCommit**: 이 CLI 도구는 AI를 사용하여 코드 변경 사항에 대한 의미 있는 커밋 메시지를 자동으로 생성합니다. 이 글에 대한 커밋 메시지를 생성했습니다. 여기서 확인해보세요. 🤖💬\n- **Homebrew**: 내가 사용하는 도구 중 하나인 이것은 macOS를 위한 유일한 실제 패키지 관리자입니다. 소프트웨어와 도구를 설치하는 것을 간단하게 만들어주어 개발 환경을 갱신하는 것을 쉽게 만들어줍니다. 🍺\n- **Terraform**은 고수준 구성 언어를 사용하여 클라우드 리소스를 정의하고 프로비저닝할 수 있게 해주는 인프라 코드 도구입니다. 집과 직장에서 모두 사용하며 여기 더 자세히 설명되어 있고 여기서 책을 썼습니다. ☁️🏗️\n- **Ansible**은 구성 관리와 응용 프로그램 배포를 위한 자동화 도구로, 간단하고 에이전트리스 아키텍처로 다중 서버에서 작업을 관리하고 자동화하기 쉽게 만들어줍니다. 오, 그리고 이에 관한 책도 방금 출간했습니다. 🤖📚\n- **Conda**는 오픈 소스 패키지 관리 및 환경 관리 시스템으로, 자세한 정보는 여기를 참조하세요. 🐍📦\n- **Ollama**는 대규모 언어 모델 (LLM)을 로컬에서 실행하고 관리하는 다재다능한 도구입니다. Llama 3, Mistral 등과 같은 다양한 모델을 지원하여 사용자 정의 및 효율적인 LLM을 커스터마이징하고 머신에서 효율적으로 실행할 수 있습니다. 이에 대해 자세히 다룬 내용이 여기 있습니다. 🦙🧠\n\n# 서비스 🌐\n\n- **Grammarly**는 실시간으로 문법, 철자 및 스타일 제안을 제공하여 글쓰기를 개선하는 고급 AI 기반 작성 보조 도구입니다. 이메일부터 블로그 글까지 모든 문서가 명료하고 간결하며 오류가 없도록 보장하는 데 필수적입니다. 2016년 11월 6일 가입한 이후로 Grammarly에 의해 분석된 단어는 21,657,835개 이상입니다. ✍️🤖\n- **OpenAI의 ChatGPT**는 제공된 입력을 기반으로 인간과 유사한 텍스트를 생성하는 대화형 AI 모델입니다. 아이디어 떠올리기, 콘텐츠 작성, 코딩 지원 등에 유용하여 창의적인 작업과 기술적 작업에 모두 필수적인 도구입니다. 이 블로그 글의 일부 부분을 작성하는 데도 도움이 되었습니다. 💬🤖\n- **Midjourney**는 텍스트 프롬프트로부터 화려한 시각 자료를 생성하는 AI 기반 이미지 생성 서비스입니다. 다양한 프로젝트 및 프레젠테이션을 위해 독특한 그래픽, 시각 콘텐츠 및 창의적인 일러스트레이션을 제작하는 데 유용한 도구입니다. 이 블로그 글의 헤더를 만드는 데 사용되었습니다. 🖼️🤖\n- **Kagi**는 빠르고 광고 없는 개인 정보 중심 검색 엔진으로, 광고나 추적 없이 정확한 정보를 제공하여 웹 브라우징 경험을 향상시켜줍니다. 🔍🕵️\n- **Cloudflare Pages**는 빠르고 안전한 정적 웹 사이트를 배포하는 플랫폼입니다. 개발 흐름에 완벽히 통합되어 편리하게 웹 프로젝트를 신속하게 발행하고 관리할 수 있습니다. 이 블로그와 레코드 수집 페이지를 포함하여 내 웹 프로젝트를 쉽게 관리하고 게시할 수 있도록 해줍니다. 🌩️🕸️\n\n<div class=\"content-ad\"></div>\n\n현재 AI 기술의 발전을 감안하면, 이 목록이 앞으로 12개월 동안 얼마나 변할지 궁금하네요!!!! 🤯🔮\n\n원문은 2024년 6월 16일에 https://www.russ.foo에서 게시되었습니다.","ogImage":{"url":"/assets/img/2024-06-23-DaytoDayToolsthe2024edition_0.png"},"coverImage":"/assets/img/2024-06-23-DaytoDayToolsthe2024edition_0.png","tag":["Tech"],"readingTime":3},{"title":"2023년 최신 Mac Mini M2 쇼핑 가이드 완벽한 구매 방법","description":"","date":"2024-06-23 15:36","slug":"2024-06-23-ThecompleteMacMiniM2shoppingguide2023","content":"\n\n## 돈을 아끼고 싶은 분들을 위해\n\n새로운 Mac Mini는 매우 좋은 컴퓨팅 기기입니다. 비교적 저렴하면서 효율적이고 강력합니다. 요즘 최고의 가치 제안을 하고 있기 때문에 Reddit와 Twitter에서 \"어떤 것을 선택해야 할까\"라는 순간들이 많이 있었어요. 그런데 그에 대한 메모를 공유하고 싶어서 이 쇼핑 가이드를 제공하게 되었어요.\n\n구매를 고려해야 하는 Mac Mini 모델은 네 가지입니다. 예산에 맞게 관심 있는 섹션으로 이동한 다음 액세서리 부분으로 넘어갈 수 있어요.\n\n- Mac Mini 8GB / 256GB (가격: $599, 교육용: $499)\n- Mac Mini 16GB / 256GB (가격: $799, 교육용: $679)\n- Mac Mini 24GB / 512GB (가격: $1,199, 교육용: $1,059)\n- Mac Mini 32GB / 512GB (가격: $1,699, 교육용: $1,559)\n\n<div class=\"content-ad\"></div>\n\n파고들기 전에 중요한 세 가지를 경고하고 싶어요:\n\n만약 휴대성이 필요하다면 맥 미니를 선택하지 마세요. 맥북 에어나 맥북 프로가 더 나은 작업 환경을 제공할 거에요. 극도로 이동성이 필요하다면 아이패드가 더 저렴하게 나올 것이고, 맥 미니를 가방에 넣고 콘센트를 찾느라 수고스럽게 할 필요 없을 거에요.\n\n만약 주방 싱크 대신 모든 것이 필요하다면, 할인된 중고나 리퍼비시된 아이맥 M1을 찾아보세요. 뉴 아플 M2 프로세서가 포함될 때까지 전가를 지불하지 마세요. 또한, 100달러어치의 애플 키보드와 매직 마우스, 500달러어치의 4.5K 스크린과 함께 프리미엄 스피커가 포함된 가격으로 다른 곳을 찾아다닐 필요가 없겠죠.\n\n마지막으로 3D 렌더링이나 가상화를 위해 맥을 선택하지 마세요. PC가 더 저렴하고 성능면에서 더 우수할 것이고, 이러한 작업에 대해 완성도 있을 거에요. 이에 대한 노트는 이 글의 끝 부분에서 읽을 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n위에 언급한 모든 것을 고려할 때, 데스크톱 사용자들은 Mac Mini으로 빠져들어봅시다!\n\n# 기본 Mac Mini 8GB / 256GB ($599)\n\n기본 Mac Mini는 단연 최고입니다. 성능, 효율성 및 공간 측면에서 이 가격에 제안된 것과 비교할 만한 것이 없습니다. 모든 면에서 좋은 입문용 머신입니다. 문제는 제한되지 않고, 오힀을 받는 것입니다.\n\n기본 모델은 적당히 가벼운 머신이며, macOS에 익숙하지 않거나 컴퓨팅 세계에 낯선 사람들을 위한 것임이 명확합니다. 대형 문서 작성, 사진 정리, 프레젠테이션 제작, 포스터 또는 전단지 디자인 등 마우스, 키보드 및 큰 화면과 함께 하는 작업에 최적입니다. 여러 가족 구성원 간에 공유되더라도 문제없이 작동할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n함께 사는 룸메이트나 가족과 비용을 나눠 부담을 줄이면, 매일 오후에 사용하는 데 서로 싸우지 않는다면 좋은 결정이 될 수 있어요.\n\n![이미지](/assets/img/2024-06-23-ThecompleteMacMiniM2shoppingguide2023_0.png)\n\n이것은 가벼운 소프트웨어에만 제한되는 것을 의미하는 것은 아닙니다. 여전히 GarageBand, iMovie, iPhoto와 Apple Silicon을 위해 최적화된 일부 게임(희망적으로)과 같은 소프트웨어를 사용할 수 있어요. 단지 대규모 프로젝트에 지나치게 집착하지 않는 한입니다. 8GB의 RAM은 모든 작업에서 성능을 유지할 때 매우 제한적일 수 있어요. 이는 고부하의 멀티태스킹을 조심하거나, Logic Pro, Final Cut, Adobe Lightroom 또는 일부 Intel 기반 앱에서 대규모 프로젝트를 처리할 때 성능이 항상 당신편일 것이라는 것을 경계해야 한다는 것을 의미해요.\n\n저장 공간에 대해서는 일상적인 작업에는 빠르게 처리될 것이므로 일반 사용자는 전혀 차이를 느끼지 못할 것이에요. 다만 엄청난 운영에 대한 블레이징 속도나 지속적인 쓰기를 기대하지 마세요. 256GB 저장 버전은 최대 1,500 MB/s의 읽기와 쓰기를 지원하는 단일 NAND 플래시 칩을 사용해요.\n\n<div class=\"content-ad\"></div>\n\n이 기기는 RAM 및 저장 공간이 가장 필요한 무거운 전문 작업에는 적합하지 않습니다. 적어도 매일 그렇지는 않지만, 긴 여유로운 시간이 있다면 다른 컴퓨터와 마찬가지로 쓸모가 있을 것입니다.\n\n적합한 사용법:\n\n- 가정 및 사무실 업무\n- 가벼운 비디오 게임\n- 가끔 또는 드물게 발생하는 과부하 작업 또는 다중 작업\n\n# Mac Mini 16GB / 256GB (￡799)\n\n<div class=\"content-ad\"></div>\n\n믿거나 말거나, 16GB RAM을 탑재한 맥 미니는 일부 엔트리 레벨 전문 업무에 대해 놀라운 성능을 발휘할 거예요. 예를 들어, 그래픽 디자인, 비디오 편집, 음악 제작 또는 소프트웨어 개발에 시작하는 사람들에게 유용할 거예요.\n\n업그레이드된 RAM의 주 목적은, 많은 것들을 메모리에 보관해야 하는 작업을 지원하는 것이에요. 기본 맥 미니도 할 수는 있지만, 더 큰 RAM 크기는 SSD를 메모리로 자주 바꾸지 않고도 시스템이 보다 빠르게 작동하도록 해줍니다. 보다 적은 비치볼을 보는 것이 더 나은 이유죠.\n\nMax Tech의 형편없고 가장치는 RAM 비교 영상은 폐기하고 더 나은 것을 제안하겠어요. 결론은 간단해요: 하나의 업그레이드만 선택해야 한다면, 더 많은 RAM이 더 많은 저장 공간보다 항상 나은 선택이에요.\n\n자, 공정한 점도 얘기해 볼게요. 그들은 최근에 다양한 벤치마크를 포함한 맥 미니 비교를 했다는 점을 부정하지 않겠어요.\n\n<div class=\"content-ad\"></div>\n\n방안에 큰 코끼리는 포트의 수입니다. Mac Mini를 어디에 사용할 지에 따라 포트의 수를 확장하기 위해 허브를 구입해야 할 수도 있습니다. 이렇게 하면 Mac Mini를 M2 Pro 프로세서가 탑재된 Mac Mini로 업그레이드하거나 포트의 수만으로 Mac Studio로 업그레이드하는 것보다 훨씬 저렴합니다.\n\n이전 단락과 비슷한 어조로, 외부 저장소는 내부 저장소 업그레이드보다 저렴합니다. Mac Mini에 연결된 드라이브에서 프로젝트를 작업할 준비를 해보세요. 사용 사례에 따라 큰 HDD를 얻을 수도 있고 작지만 빠른 SSD를 얻을 수도 있습니다. 그 중 어느 것이든 내부 저장소를 $200으로 업그레이드하는 것보다 나을 것입니다.\n\nMac Mini 허브 중 일부는 포트를 확장하고 NVMe나 SSD를 훌륭한 속도로 사용할 수 있는 저장소 케이스로도 작동합니다.\n\n어쨌든, 저장소와 허브에 대해 더 많은 세부 정보는 \"컴퓨터의 나머지 부분\" 섹션을 확인해주세요.\n\n<div class=\"content-ad\"></div>\n\n좋은 점:\n\n- Xcode, JetBrains, VS Code 및 유사한 앱 개발\n- 일부 4K 영상이 포함된 Final Cut\n- 소량의 음원 뱅크와 몇 개의 FX 플러그인이 있는 Logic Pro\n- 중간 크기 파일의 Photoshop 또는 Affinity Design\n\n# Mac Mini 24GB / 512GB ($1,199)\n\n이 모델의 사용 사례는 이전 Mac Mini 16GB / 256GB와 동일합니다. 정말 필요하다면 1TB를 추가 $200에 구입할 수 있지만, 더 싼 외부 저장 장치에 그 돈을 쓸 수 있는 경우에는 그것을 추천하지 않습니다. $999에 맞출 수 있도록 256GB로 줄이는 것이 더 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Mac Mini M2 Shopping Guide](/assets/img/2024-06-23-ThecompleteMacMiniM2shoppingguide2023_1.png)\n\n24GB의 RAM을 탑재한 모델을 선택하는 두 가지 이유가 있습니다. 첫 번째 이유는 간단합니다: 최대 RAM이 $1,700에 32GB로 뛰어넘지 않는 한 가장 가성비가 좋습니다. CPU 부담이 많지 않지만 많은 메모리가 필요한 소프트웨어가 있습니다. 예를 들어 멀티 플러그인과 사운드 뱅크가 풍부한 Logic Pro와 같은 소프트웨어가 있습니다.\n\n두 번째 이유는 조금 더 오래 사용할 수 있기 때문입니다.\n\n기계를 낡을 때까지 사용하는 사람 중 한 명이라면, Mac Mini 업그레이드는 완전히 새로 사야하기 때문에 명백한 선택입니다. 그때 새 모델은 성능 면에서 훨씬 앞설 것입니다. 기계가 낡을 때까지 사용하지 않을 계획이라면 이것은 논외입니다.\n\n\n<div class=\"content-ad\"></div>\n\n현재인 2023년에는 16GB RAM이 장착된 기기가 대부분의 작업에 충분하며 요구되는 작업 및 멀티태스킹이 많이 필요한 소프트웨어에 여유를 남겨줍니다. 24GB RAM을 갖는 것은 기계를 몇 년 동안 관련성을 유지하는 데 도움이 될 수 있습니다. 심지어 CPU가 여전히 4×4 코어 구성 - 네 개의 \"성능\" 코어, 네 개의 \"효율성\" 코어인 경우에도요.\n\n전반적으로 볼 때, 이 모델은 M2 Pro 이전의 좋은 중간 지점입니다. 처리 성능이 부족한 상태가 아닌 한 - 그 때가 올 거에요. 이 모델은 RAM을 많이 가지고 있고, 가능하다면 더 큰 SSD를 장착하는 좋은 방법이며, 이로 인해 비용 면에서 40% 더 비싼 M2 Pro에 들어가기 전의 좋은 선택입니다. 이전 더 저렴한 모델에 따르면, 허브와 외부 저장소를 고려해보세요.\n\n\n좋은 점:\n\n- Mac Mini 16GB / 256GB와 같은 용법들.\n\n<div class=\"content-ad\"></div>\n\n# Mac Mini (M2 Pro) 32GB / 512GB ($1,699)\n\n이 모델을 \"지갑을 털지 않고도 Mac Studio\"로 생각하고 싶어요. 다시 말해서, 여기서부터는 Mac Studio 지역에 접근하고 있으며, 적어도 5년 동안 동일한 가격으로 업그레이드하고 싶지는 않을 겁니다. 당연히 성능에 상당한 도약이 없는 이상 말이에요.\n\n![Mac Mini M2 Pro](/assets/img/2024-06-23-ThecompleteMacMiniM2shoppingguide2023_2.png)\n\n이전 문장으로 볼 때, Mac Mini 32GB / 512GB의 M2 Pro는 Mac Studio에 대비해서 가성비가 좋은 제안 같아 보이지만, 그렇지 않아요. 이것은 RAM이 32GB인 가장 저렴한 모델이며, 스토리지를 256GB로 다운그레이드하면 $200을 저장할 수 없어요.\n\n<div class=\"content-ad\"></div>\n\n어쨌든, 이 모델이 이전 저렴한 Mac Mini 모델보다 선택되어야 하는 세 가지 시나리오가 있습니다:\n\n- 네 개의 썬더볼트 4 포트가 필요한 경우.\n- 삼중 모니터 지원이 필요한 경우.\n- 더 많은 메모리와 처리 능력이 필요한 경우.\n\nM2 Pro (6×4 CPU, 16코어 GPU, 200GB/s)는 처음에는 성능의 거대한 도약처럼 들리지 않을 수 있지만 실제로는 그렇습니다. 60% 더 강력한 GPU, 두 개의 추가 성능 코어, 32GB의 RAM을 고려해보면 병렬 처리 및 중첩된 다중 작업을 손쉽게 처리할 수 있습니다.\n\n성능의 도약에 대해 이야기할 때, 이 Mac Mini을 꼭 가져야 할 제품으로 생각하세요. 더 많은 포트와 M2 Max(8×4 CPU, 30코어 GPU, 400GB/s)가 있는 기본 Mac Studio ($1,999)을 선택하는 것이 더 나은 선택이라고 주장할지 모릅니다만, 300달러의 차이가 납니다. 저는 이에 반박하겠습니다: 그 금액으로는 64GB RAM이 탑재된 Mac Studio ($2,399)를 목표로 해야 합니다. 기본 모델보다 20% 더 비싸기 때문에 평생 사용할 수밖에 없습니다.\n\n<div class=\"content-ad\"></div>\n\n물론 16GB RAM이 장착된 M2 Pro를 목표로 삼지 마세요. 대신 저렴한 맥 미니를 구입하세요. RAM이 부족한 느낌은 무겁고 복잡한 소프트웨어를 한꺼번에 실행할 때 느껴질 거예요. 새벽 3시에 포토샵, 일러스트레이터, 인디자인, 피그마, 왓츠앱, 그리고 크롬을 함께 사용하는 모습을 봤어요.\n\n제 생각에 16GB와 32GB 사이의 400달러 차이는 가치가 있어요. 적어도 5년 동안은 이 기기를 업그레이드하지 않을 계획이라면요. 그 가격을 고려한다면요.\n\n좋은 점:\n\n- 두 개 이상의 외장 SSD 드라이브에서 4K 영상을 읽기\n- 많은 양의 상세한 사진 및 일러스트와 작업하기\n- 3D 디자인, 프로토타이핑, 모델링\n- 코드 작성, 미리보기, 소프트웨어 디버깅을 위해 3개의 모니터 사용\n\n<div class=\"content-ad\"></div>\n\n# 컴퓨터의 나머지는 어디에 있나요?\n\n맥 미니인만큼, 여러분만의 모니터, 키보드, 그리고 마우스, 아마도 허브를 가져와야 합니다.\n\n이것이 iMac을 선호하는 이유 중 하나입니다. 모든 것이 함께 제공되기 때문에 완벽한 액세서리를 인터넷에서 찾을 필요가 없으며, 각각이 도착하길 기다릴 필요도 없습니다. iMac M2가 나오기 전에, 우리는 이러한 것들을 스스로 찾아야 할 것이지만, 다행히도 여러분을 위해 저는 맥 미니 액세서리를 쉽게 구매할 수 있는 괜찮은 옵션들을 준비해 두었습니다.\n\n## 좋은 모니터, 잘못된 모니터\n\n<div class=\"content-ad\"></div>\n\n그래픽 작업을 하는 사용자들은 큰, 정확한 색상을 보여주는 모니터를 고려할 것입니다. 만약 macOS와 인증된 프로페셔널급 옵션을 이미 선택했거나 쇼핑카트에 넣었다면, 그만두시고 다음 단계로 넘어가세요.\n\n모니터를 찾는 나머지 사용자들을 위해, 아주 간단한 팁을 알려드릴게요:\n\n- 20인치 이상의 1080p 모니터면 어느 것이든 괜찮습니다. RTINGS의 최고의 1080p 모니터를 확인해 보세요.\n- 21:9 비율의 26인치 울트라 와이드 1080p 모니터면 훌륭합니다.\n- 27인치 1440p 모니터면 훌륭합니다. RTINGS의 최고의 1440p 27인치 모니터를 확인하세요.\n- 27인치 2560p/4K 모니터면 대부분 괜찮지만, 심각한 그래픽 작업에는 적합하지 않을 수 있습니다.\n\n1080p 모니터는 Mac Mini에 매우 잘 작동할 것이지만, 더 큰 모니터를 원하거나 두 대를 사용하길 원할 수도 있습니다. 대부분의 1080p 모니터는 $100 정도에 구매할 수 있지만, ASUS VG246H ($150)를 강력히 추천합니다. 1080p 울트라 와이드 모니터인 LG 26WQ500 ($130)와 더 큰 LG 29WQ600 ($200)도 매력적이며, 가치 있는 선택이라고 생각합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![사진](/assets/img/2024-06-23-ThecompleteMacMiniM2shoppingguide2023_3.png)\n\n만약 34인치 1440p 초광각 화면이 필요하다면, Gigabyte M34WQ ($400)는 거의 완벽한 선택지입니다. 좀 더 저렴하면서 괜찮은 옵션은 ViewSonic VA3456-MHDJ ($330)입니다.\n\n27인치 iMac 이용자들은 Mac Mini로 이동하는 방법에 대한 MacAddress 비디오를 확인할 수 있습니다. 물론 그래픽 작업을 계획 중이라면 ASUS의 유료 4K 모니터를 고려하지 말고, 1440p 27인치 버전이나 RTING의 추천 중 하나를 고려해보세요. 원하는 모델이 27인치부터 시작하는지 확인하세요.\n\n이게 쉬운 부분입니다. 여기서부터 모니터를 선택하는 것은 복잡해집니다. Mac을 위한 좋은 모니터를 선택하는 데 도움이 될 내 기사를 참고해주세요.\n\n\n<div class=\"content-ad\"></div>\n\n## 좋은 케이블, 나쁜 포트\n\n모니터에 연결할 때 HDMI 케이블을 사용하려고 노력해보세요. 그렇게 하면 Thunderbolt 4 포트를 다른 장치(또는 허브)에 남길 수 있어요.\n\nHDMI가 없는 모니터는 드물지만, 그런 경우에는 신뢰할 수 있는 DisplayPort-to-HDMI 또는 USB-C-to-HDMI 케이블을 사용할 수 있어요. 다만, 기본 M2 프로세서는 HDMI를 통해 4K@60Hz를 넘어서는 해상도를 지원하지 않는다는 점에 주의하세요. M2 Pro는 8K@60Hz까지 지원할 수 있어요.\n\n일부 모니터는 고급 기능을 사용하기 위해 Thunderbolt 4 연결을 요구할 수 있어요. 고주사율, 데이지 체인(MST) 또는 추가 USB 포트와 같은 기능이 그 중 하나에요. 의심이 들 경우 구입하기 전에 사용 설명서를 확인하세요. 대부분의 경우 제조사 사이트에서 항상 확인할 수 있어요.\n\n<div class=\"content-ad\"></div>\n\n애플 지원 페이지에는 모니터 구성에 관한 자세한 내용이 더 많이 있습니다. 몇 대의 모니터를 연결할 수 있는지, 그리고 어떤 해상도가 선택지 상단에 있는지 알고 싶다면 참조하십시오.\n\n## 싸고 좋은 주변 기기, 비싼 주변 기기\n\n이미 수천 달러를 마우스와 키보드에 투자했다면, 필요하다면 USB 동글을 꽂아서 끝내세요. 그렇지 않으면 Logitech K380 키보드와 M350 Pebble Mouse를 구입하세요.\n\n이 키보드 및 마우스 콤보 세트는 대략 $60에 판매되며, 때로는 인터넷을 깊게 찾아보고 쿠폰을 가져오면 더 싸게 구입할 수 있습니다. 품질을 고려하면 정말 좋은 가치라고 할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Mac Mini M2 shopping guide](/assets/img/2024-06-23-ThecompleteMacMiniM2shoppingguide2023_4.png)\n\nApple also sells you this stuff. I would recommend the Apple TouchID Keyboard ($150) if you prefer TouchID for everything, like Passkeys. The Magic Mouse ($100) is a matter of personal preference: some don’t like it, and some have brain damage. The MX Keys S Combo ($200) is the furthest I would go on the premium tier, because at that price I’ll happily mash potatoes for a RAM upgrade on a hot Sunday.\n\nAny other alternative should (hopefully) be Bluetooth, so that way you can keep the back USB-A ports free for anything else.\n\n## Fast storage, big storage\n\n\n<div class=\"content-ad\"></div>\n\n인터넷에는 외부 저장소에 대한 많은 안내서가 있지만, 여러분의 이용 가능한 옵션을 두 가지 범주로 요약할 수 있어요:\n\n- 저장 용량 장점으로만 고전 HDD(회전 디스크) 입니다.\n- 우수한 읽기 및 쓰기 속도를 제공하는 2.5인치 SSD입니다.\n\nWD Elements 2TB, Seagate Portable 2TB 그리고 Toshiba Canvio Basics 2TB와 같이 60달러에 2TB 드라이브를 구입할 수 있지만, 이들은 읽기 속도가 60MB/초, 쓰기 속도가 약 30MB/초로 USB 2.0의 한계에 머물러 있습니다. 하지만 속도보다는 용량이 필요한 경우 유효한 옵션입니다.\n\n저장 용량 측면에서 성능 대비 가장 탁월한 선택은 120달러에 제공되는 WD_BLACK 5TB P10이지만, 이 제품을 구할 수 없다면 100달러에 WD Elements 5TB를 살펴보는 것도 좋아요.\n\n<div class=\"content-ad\"></div>\n\n다음 단계는 SSD입니다. 저는 Samsung T7 Portable 1TB를 $80에 (1,000MB/s), Samsung T7 Portable 2TB를 $120에 (1,000MB/s), 그리고 Kingston XS200 4TB를 $240에 (2000MB/s) 구매할 수 있는 세 가지 옵션이 있습니다.\n\n기억해 주세요. $200 이상은 조심스럽게 다뤄야 합니다. 그런 돈이 있다면 Mac Mini의 RAM을 업그레이드하고 추후 외부 저장소에 대해서 고민해 보는 것이 좋습니다.\n\n## 빠르고 강력한 저장소\n\n저장 속도가 중요한 경우, 그것은 상황에 따라 다릅니다. 현재 3,000MB/s 이상의 전송 속도를 갖는 제품은 다른 Mac Mini 한 대의 가격을 넘거나 2TB 내부 저장 공간이 필요합니다.\n\n<div class=\"content-ad\"></div>\n\n최대 전송 속도를 달성하려면 Apple Tax를 지불하지 않고 NVMe 케이스를 사용해야 합니다. 이 문제에 대해 훌륭한 동영상을 소개해 드리겠습니다:\n\n예를 들어, ACASIS ($130)와 ORICO ($150) 케이스는 2700MB/s까지 도달할 수 있습니다. 또한, 케이스와 동일한 속도의 NVMe 드라이브가 필요합니다. 예를 들어 Crucial P3 Plus 4TB ($230)나 Corsair MP600 CORE XT 4TB ($220)와 같은 제품이 있습니다.\n\n4TB 용량에 합리적인 속도를 내는 데 약 $350 정도를 투자하는 것은 상식적인 선택입니다. 이는 Mac Mini 내부 저장소를 업그레이드하는 것과 비교할 때 매우 유리합니다.\n\n내부 속도를 더 깊이 파헤쳐보면 몇 가지 유의해야 할 점이 있습니다.\n\n<div class=\"content-ad\"></div>\n\n만약 정말 7,000MB/s의 속도가 필요하다면, 최소 2TB의 M2 Pro가 필요합니다. 왜냐하면 기본 M2는 2TB에서 5,000MB/s로 제한되기 때문입니다. 이 속도는 1,500MB/s로 작동하는 4 × 512GB 칩을 사용하여 얻어지며, Max Tech 팀에서 제공한 iBoff 수리 비디오에서 확인할 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-ThecompleteMacMiniM2shoppingguide2023_5.png)\n\n나는 정말 그런 종류의 속도가 반드시 필요하다면, 메모리 내에서 처리되어야 하는 방대한 데이터셋으로 작업하거나 MATLAB을 사용하여 별도로 처리해야 하는 경우에는 Mac Studio 또는 Mac Pro를 고려해야 한다고 생각합니다. Mac Mini 대신 그런 옵션들을 고려해 보는 것이 좋을 것 같지만, 이에 대한 결정은 나중에 내가 생각할 것입니다.\n\n## 간단한 허브, 스위스 아미 나이프 허브\n\n<div class=\"content-ad\"></div>\n\n파티티에 USB 장치들이 없다니 정말 다행이네요! 제가 드릴 유일한 조언은 몇 개의 싼 USB-A에서 USB-C 어댑터와 그 반대를 구입해서 한 장치를 포기할 필요가 없도록 하는 것입니다. 커넥터 맞지 않아 일어나는 문제를 해결할 수 있어요.\n\n허브를 찾고 있다면 가격대가 다양한 것을 찾을 수 있습니다. $15에 간단한 USB 동글부터 $300 이상의 과도한 솔루션까지 많이 있어요. MacWorld에 있는 이 리스트는 상세하게 나와 있어서 소비를 아꼈을 때 정확히 필요한 것을 찾을 수 있을 거예요.\n\n저는 개인적으로 Mac Mini 형태의 일부분처럼 느껴지는 것을 좋아해요. 이 카테고리에서 제가 선호하는 것은 세 가지입니다:\n\n- Hagibis MC25 허브 ($50~$100)\n- Elecife 허브 ($70)\n- Satechi 스탠드 허브 ($100)\n\n<div class=\"content-ad\"></div>\n\n이 중 모든 허브는 SATA 또는 M.2 드라이브를 부착할 수 있는 케이스를 가지고 있으며, 두 번째 Thunderbolt 4 포트 사용 대신 듀얼 모니터 설정을 위한 추가 HDMI 또는 DisplayPort를 가질 수 있습니다.\n\nSATA 또는 M.2 드라이브 슬롯이 있는 허브를 찾고 있다면, 구매 전에 해당 제품의 매뉴얼을 꼭 살펴보세요. 이들 중 대부분은 2.5인치 SATA 드라이브를 USB 3.0 (5Gbps, 625MB/s)를 통해 연결하며, 이것은 가장 빠른 SSD에도 적합할 것입니다. M.2 포트가 NVMe 드라이브용 USB 3.1 (10Gbps, 1250MB/s)를 사용한다면 행운을 누릴 수 있지만 보장되는 것은 아닙니다.\n\n시장에는 더 많은 기능과 포트를 갖춘 다른 Thunderbolt 3/4 허브들이 있을 거라 확신하지만, 무엇을 약속하든 $100 이상을 허브에 낭비하지 말아야 합니다.\n\n가격을 세 배로 높여 본다면 기억해야 할 점은 우리가 Mac Mini의 나라에 있다는 것입니다: $200은 영구적인 RAM 또는 저장소 업그레이드를 의미하므로 꾸준히 Mac Mini를 더 빠르게 만드는 것을 우선시해야 합니다. SSD/NVMe가 장착된 멋진 허브보다 다양한 크기의 포트가 12개가 있는 허브를 구하는 것보다요.\n\n<div class=\"content-ad\"></div>\n\n## 나를 위한 소리, 모두를 위한 소리\n\n음악을 만드는 사람이거나 오디오파일이라면 이미 좋은 스피커, DAC 또는 헤드폰을 이미 상상하고 있거나 귀로 듣고 있을 것입니다. 그러므로 여러분에게 추천할 것은 없습니다.\n\n다른 사람들을 위해서는 소리 품질보다는 편의가 중요할 것입니다.\n\n솔직히 말해서, 어떤 블루투스 스피커, 무선 헤드셋 또는 이어버드라도 대부분 문제없이 사용할 수 있을 것입니다. 블루투스 지연을 피하고 싶다면 유선 헤드셋을 사용해야 할 것입니다. 최신 Airpods Pro 2도 예외는 아니며, 가까운 경쟁을 보여주고 있습니다.\n\n<div class=\"content-ad\"></div>\n\nRTINGS의 헤드폰 리뷰와 스피커 리뷰를 참고하시면, 저렴한 블루투스 스피커, 노이즈 캔슬링 기능이 있는 마이크가 달린 헤드셋, 또는 출퇴근용으로 오래가는 이어버드 중 어떤 것이 더 좋을지 선택할 수 있습니다.\n\n음악 프로듀서는 오디오 인터페이스를 선택해야 하는데, 이를 위해 리어 USB-A 포트를 하나 비워두는 것이 왜 중요한지 알려드릴게요. 음악 및 악기의 종류에 따라 옵션은 매우 다양할 것입니다. 시작 단계라면, M-Audio M-Track Solo($50)에 AKAI LPD8($60) 또는 AKAI MPK Mini MK3($100)를 조합하여 싸게 DAW에 치여 플러그인을 왼쪽 오른쪽으로 밀고 갈 수 있습니다. 그럴 때 16GB의 RAM이 유용하게 쓰입니다.\n\n# PC는 어떨까요?\n\n만약 PC에서 할 수 있는 일에 대해 궁금해하신다면, 예산이 제한되어 있기 때문일 수 있어요. 직접 제작한 커스텀 PC는 동일 가격대의 맥 미니나 사전 구성된 PC보다 더 많은 RAM과 저장 공간을 제공할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n올바른 부품을 선택하고 Windows를 구축하고 설치하며 해당 드라이버를 설정하는 데는 시간과 인내가 필요합니다. 만약 무언가 잘못되었을 때 스스로 문제를 해결해야 할 수도 있습니다. 누군가가 어리석은 실수를 한 것이든 하드웨어 부품에 운이 나쁜 경우든 말이죠. LTT는 이 분야에서 최고의 비디오 튜토리얼을 제공하고 있으니 관심이 있다면 확인해보세요.\n\n아직 망설이고 있다면 PC를 맥 미니보다 선택해야 하는 두 가지 주요 이유가 있습니다.\n\n- 가능한 한 많은 RAM 및/또는 저장 공간이 필요합니다.\n- 3D 렌더링을 위해 NVIDIA 카드가 필요합니다.\n\n첫 번째 항목부터 시작해보죠: 맥 미니는 PC와 비교해 RAM 및 저장 공간이 달러 당 더욱 뛰어날 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n작은 예시로, 비슷한 가격대의 PC와 비교할 수 있는 기본 맥 미니 8GB / 256GB를 사용해 보겠습니다. 가격은 $600입니다. 작은 케이스를 사용한 PCPartPicker 목록이 만들어졌고 다음과 같은 사양입니다:\n\n- 통합 그래픽과 8코어(16 스레드) AMD Ryzen 5700G\n- 대역폭 약 40GB/s의 64GB RAM\n- 읽기 속도 7,000MB/s, 쓰기 속도 5,000MB/s의 1TB 저장 공간\n- USB 3.2 및 USB-C 포함 12개의 USB 포트\n- 듀얼 디스플레이 지원\n- 2.5G 이더넷\n\n기본 맥 미니에 비해 PC의 가치가 크다는 것은 부인할 수 없습니다: RAM 8배, (업그레이드 가능한) 저장 공간 4배, 저장 속도 5배, USB 포트 6배, 듀얼 디스플레이, 빠른 이더넷. 이는 무거운 작업에 충분합니다.\n\n이 PC에 대한 사소한 단점 몇 가지가 있습니다: CPU 및 GPU 성능이 논란이 될 수 있고, 에너지를 3배 더 소비할 수 있으며, iGPU는 메모리에서 2GB를 차지하며, 메모리 대역폭은 40% 입니다. 또한 해당 컴퓨터에는 단일 신경엔진이 없으며 썬더볼트 4 포트도 없습니다. 이는 일부 사용자에게 결정적인 문제가 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 가상화 및 3D 렌더링에 관한 이야기\n\n이제 두 번째 항목으로 가서 가상화는 별로이고 PC에서 3D 렌더링이 더 저렴하다고 해봅시다.\n\n가상화가 사용할 수 없다는 것은 아닙니다만, 아직 따라잡느라 애를 먹고 있습니다. Apple Silicon에서 가상 머신을 만들거나 소프트웨어를 개발하기 위해 도커를 사용하는 것은 여전히 귀찮은 일입니다. 왜냐하면 Apple Silicon에서 전체 도구 체인은 ARM64여야 하기 때문입니다. PC에 비해 Apple Silicon 가상화는 괜찮을 수도 있지만, 특히 개발자들이 사용할 소프트웨어에 ARM64 빌드가 없는 경우는 좀 까다로울 수 있습니다.\n\nApple Silicon이 까다롭지 않은 분야는 3D 모델링입니다. 사실, 거의 모든 M2 프로세서는 Blender, ZBrush, Unreal Engine, Cinema 4D, Fusion 360, SketchUp 또는 3D 개체를 만들기 위한 어떤 소프트웨어든 잘 다룰 수 있습니다. 문제는 렌더링입니다.\n\n<div class=\"content-ad\"></div>\n\n성능 대비 가격을 고려해보면, 렌더링을 위한 NVIDIA 카드 중 어떤 것이건 맥을 완벽히 제압할 것입니다. PC의 나머지 부분에 대한 비용을 고려하지 않아도 맥보다 좋은 성능을 얻을 수 있습니다.\n\n최대한 아픔을 주기 위해 예산을 늘려보겠습니다. 맥 미니 16GB / 512GB와 가까운 1,000달러에 PC를 구입하면, 더 강력한 프로세서, 더 큰 케이스, RTX 3060 12GB 그래픽카드를 얻을 수 있어서 삼중 모니터 지원, 빠른 3D 렌더링 및 멋진 게임 지원이 가능합니다.\n\n이러한 유형의 유연성은 일부 PC 애호가가 맥 미니를 포기할 수 없는 이유입니다. Apple 실리콘은 일부 작업에 적합하지 않으며, PC는 더 나은 결과와 덜한 머리 아픔을 유발할 것입니다.\n\n2023년 6월 26일 업데이트: 최근 Sandisk Extreme 모델의 개발을 고려하여 외장 SSD 추천을 변경하였습니다. - KudzuCastaway님 감사합니다!\n\n<div class=\"content-ad\"></div>\n\n2023년 06월 26일 업데이트: 제 의견을 명확히 나타내기 위해 기사의 여러 부분을 다시 작성했습니다. dclive1님 감사합니다!\n\n2023년 06월 27일 업데이트: 저장 속도와 SSD 수명 부분을 다시 작성하여 이 기계들이 곧 손상되지 않을 것임을 명확히 했습니다.\n\n2023년 06월 28일 업데이트: M2 Pro 성능에 대한 더 나은 맥락을 추가했습니다. dclive1님 감사합니다!\n\n2023년 06월 28일 업데이트: 기술적 모니터 부분을 독립적인 기사로 옮겼습니다.\n\n<div class=\"content-ad\"></div>\n\n2023년 06월 30일 업데이트: \"빠르고 격렬한 저장\" 섹션을 수정했습니다.\n\n2023년 07월 04일 업데이트: 내부 SSD 속도에 대한 맥락을 추가했습니다. 가상화 및 3D 렌더링 섹션을 명확히했습니다.\n\n이 이야기를 좋아하셨나요? 제게 팁을 주시려면 Medium이 제 나라에서 작동할 때까지 PayPal에서 저에게 팁을 보내실 수 있습니다.","ogImage":{"url":"/assets/img/2024-06-23-ThecompleteMacMiniM2shoppingguide2023_0.png"},"coverImage":"/assets/img/2024-06-23-ThecompleteMacMiniM2shoppingguide2023_0.png","tag":["Tech"],"readingTime":16},{"title":"MacOS에서 우클릭으로 SVG를 PNG로 변환하는 방법","description":"","date":"2024-06-23 15:34","slug":"2024-06-23-ConvertanSVGtoPNGwithRightClickonMacOS","content":"\n\n## 맥용 바로 가기(Mac Shortcut)를 만들었습니다. 이제는 SVG 파일을 오른쪽 클릭하면 쉽게 변환할 수 있어요.\n\nApple Shortcuts은 매우 강력합니다. 특히\n\n- 접근성: Finder 안에서 어떤 파일이든 오른쪽 클릭해서 호출할 수 있어요.\n- 확장성: Apple이 허용하는 것에 한정되지 않고, 바로 가기로 쉘 스크립트를 실행할 수 있어요.\n\n저는 일상적인 작업 흐름에서 만나는 모든 큰 작업과 작은 작업에 대해 한계까지 테스트해보았어요. 최근에는 제 스타트업의 로고를 개인 웹사이트(instanceofma.com)에 넣어야 했는데, 해당 웹사이트는 JPG와 PNG 형식의 이미지만 허용했어요. (SVG 형식은 허용 안 한다네요. mmm.page, 기능 요청?). 가장 빠른 방법은 스타트업 웹사이트(grandeur.dev)에서 SVG 로고를 다운로드하여 PNG로 변환하는 것이었어요.\n\n<div class=\"content-ad\"></div>\n\n이전에는 온라인 SVG를 PNG로 변환하는 도구를 사용했었는데, SVG 파일을 먼저 업로드하고 PNG 파일을 다운로드하는 것이 번거로워졌어요. 그래서 Mac에서 네이티브로 변환하는 방법을 찾기 시작했어요. 선호할 만한 완전한 서드파티 앱을 설치하지 않고요.\n\n# 함께 찾아봐요\n\n간단한 Google 검색 \"svg to png mac terminal\"으로 이 스택익스체인지 쓰레드로 이동할 수 있었어요. 저는 당연히 받아들여진 답변을 테스트해보았어요:\n\n```js\nqlmanage -t -s 1000 -o . picture.svg\n```\n\n<div class=\"content-ad\"></div>\n\n이 명령은 MacOS의 내장 Quick Look 유틸리티를 사용하여 picture.svg를 1000픽셀 폭의 picture.svg.png로 변환합니다. 동작했다면 이상적인 해결책일 것입니다.\n\n하지만 동작하지 않았습니다!\n\n로고를 1000픽셀로 크기 조정하는 것이 아니라, 작은 로고가 왼쪽 상단에 있는 1000픽셀 크기의 잘라내기 이미지를 만들고 있었습니다. 브라우저에서 SVG를 열고 전체 페이지 스크린샷을 찍은 것과 같은 결과였죠.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*n_bXjdTKI9A9A7a6G1BJqw.gif)\n\n<div class=\"content-ad\"></div>\n\n댓글을 읽어보다가 교환소에서 두 번째로 투표를 많이 받은 답변을 발견했어요.\n\n```js\nrsvg-convert -h 32 icon.svg > icon-32.png\n```\n\n이 방법의 작은 불편함은 먼저 rsvg-convert 유틸리티를 설치해야 한다는 점이었어요. 저는 Homebrew를 사용하고 있어서 쉽게 설치했지만, 사용하시는 분이 Homebrew를 사용하지 않는다면 curl을 이용해 설치할 수 있어요:\n\n```js\ncurl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh\n```\n\n<div class=\"content-ad\"></div>\n\n잠시 걸릴 거에요, 그러나 작업이 완료되면 아래 명령을 실행할 수 있어요:\n\n```js\nbrew install librsvg\n```\n\n이 작업도 완료되면 테스트할 수 있어요:\n\n```js\nrsvg-convert -h 32 icon.svg > icon-32.png\n```\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*a0Cymm6wqoRodfEsCVT_iQ.gif)\n\nIT WORKED!\n\nWe could increase the size of the image by increasing the height from 32 to 512.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*t6BVyI5R-zLMPZaD70ROUA.gif)\n\n\n<div class=\"content-ad\"></div>\n\n이제 깔끔한 단축키로 묶어 보겠습니다.\n\n# SVG를 PNG로 변환하는 단축키 만들기\n\nCmd+Space를 눌러 검색하고 Shortcuts를 입력한 후 Enter 키를 누릅니다. Plus(+) 아이콘을 클릭하여 새로운 단축키를 만듭니다. 단축키의 이름을 PNG으로 지정하세요.\n\n![Shortcut](https://miro.medium.com/v2/resize:fit:1400/1*KbLuV8j8xg-fktSLzRIFnA.gif)\n\n<div class=\"content-ad\"></div>\n\n이 용어표를 마크다운 형식으로 변경해보세요.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*yfomL8jWK4wrdeHkhXML3Q.gif)\n\n이제 단축키 라이브러리에서 \"터미널\"을 검색하고 에디터에 있는 \"Run Shell Script\" 작업을 드롭하세요. 다음 쉘 코드를 붙여넣으세요:\n\n```js\n# SVG를 PNG로 변환\n\nread filePath\nfilename=\"${filePath%.*}\"\necho $filename\n\n/opt/homebrew/bin/rsvg-convert -h 512 \"$filePath\" > \"$filename.png\"\n```\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*mAEu_4-WakO1GczRiwq26A.gif)\n\n만약 zsh에 대해 이해하지 못한다면, 이 코드는 이미지의 전체 경로를 읽어옵니다 (/Downloads/logo-revamp.svg), 확장자를 제거하여 (.svg), \"logo.svg\"를 \"logo.png\"로 변환하고 높이가 512 픽셀이 되게 합니다. \"echo $filename\"은 파일 이름을 다음 블록에 출력합니다.\n\n만약 Run Shell Script 작업에서 아래와 같은 오류가 표시된다면:\n\n![error](/assets/img/2024-06-23-ConvertanSVGtoPNGwithRightClickonMacOS_0.png)\n\n\n<div class=\"content-ad\"></div>\n\n친구야, Open Preferences를 클릭하고 Allow Running Scripts 확인란을 체크해주세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*q2SLFqNm8z2o8VFPdQI07w.gif)\n\n다른 Run Shell Script 작업을 추가하고 다음 코드를 붙여넣으세요:\n\n```js\n# QuickLook에서 PNG 파일 열기\n\nread filename\nqlmanage -p \"$filename.png\"\n```\n\n<div class=\"content-ad\"></div>\n\n이전 단계에서 생성된 PNG 이미지의 미리보기를 Quick Look에서 엽니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*f28-_BTXBui4Gih_wCgWPg.gif)\n\n마지막으로, 변환에 성공하면 알림을 보여주기 위해 \"Show Notification\" 액션을 추가합니다.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*0jh21cRZJH9D0Ne7gvAalg.gif)\n\n<div class=\"content-ad\"></div>\n\n테스트해 보세요. SVG를 마우스 오른쪽 버튼으로 클릭하고 빠른 작업에서 PNG로 변환을 클릭하세요. 선택한 이미지를 바로가기에 보내 PNG로 변환하고 첫 번째 쉘 스크립트로 PNG의 미리 보기를 여는 두 번째 쉘 스크립트를 실행합니다. 미리 보기를 닫으면 성공적으로 변환되었다는 알림이 표시됩니다.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*gP54WRqkXTP2gtRjC5DhIw.gif)\n\n빠른 작업에서 바로가기를 보지 못한다면, 사용자 정의를 클릭하고 PNG로 변환 확인란을 선택하세요.\n\n![이미지](https://miro.medium.com/v2/resize:fit:1400/1*8IxUrfQzoPlCtwppPwRjtQ.gif)\n\n<div class=\"content-ad\"></div>\n\n여러 개의 SVG를 한꺼번에 PNG로 변환할 수도 있습니다. 이를 위해 단축키를 조금 수정해야 합니다.\n\n반복 실행 동작을 추가하고 실행할 셸 스크립트를 넣어주세요.\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*06_OAoE-ajIH2WQqBRx2zA.gif)\n\n이렇게 하면 선택한 모든 SVG를 PNG로 변환하지만 첫 번째 PNG만 미리보기할 수 있습니다(모든 PNG가 아닙니다). 그리고 50개의 변환된 PNG를 각각 미리보기에서 열면 현명한 선택이 아닐 수 있습니다. 그래서 한 이미지인 경우 (변환 후에 미리보기 표시)와 여러 이미지인 경우 (알림만 표시)에 따라 다른 동작을 설정했습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](https://miro.medium.com/v2/resize:fit:1400/1*_vJG-e_eUOTTuk-R4IJDBw.gif)\n\nThat’s it! You can now convert as many SVGs to PNGs in two clicks.\n\n![Image 2](https://miro.medium.com/v2/resize:fit:1400/1*lMt8PxVXiY4zwbx-AsPakA.gif)\n\n# Install the full shortcut 👇\n\n\n<div class=\"content-ad\"></div>\n\n원하는 만큼의 바로 가기를 만들고 싶지 않다면, 제가 만든 것을 설치하고 하루를 계속하세요: [https://www.icloud.com/shortcuts/e9e0496605d343f7bb50fd93c5905164](https://www.icloud.com/shortcuts/e9e0496605d343f7bb50fd93c5905164)\n\n터미널에서 다음 명령어를 실행하여 librsvg를 설치해야 합니다:\n\n```js\nbrew install librsvg\n```\n\n당신의 바로 가기가 스크립트를 실행하도록 허용하는 문제와 rsvg-convert의 경로(/opt/homebrew/bin이 대부분입니다만 시스템에 따라 확인해 주세요)만 문제가 될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 어떡하지?\n\n단축키는 생산성을 높이는 훌륭한 방법이에요. 그래서 현재의 작업 흐름을 떠나지 않고도 사소한 작업을 처리할 수 있어요. 다음 글에서는 비디오를 GIF로 변환하는 단축키, 그리고 mp4를 webm으로 변환하는 ffmpeg을 사용한 단축키를 만들 거에요.\n\n그때까지!","ogImage":{"url":"/assets/img/2024-06-23-ConvertanSVGtoPNGwithRightClickonMacOS_0.png"},"coverImage":"/assets/img/2024-06-23-ConvertanSVGtoPNGwithRightClickonMacOS_0.png","tag":["Tech"],"readingTime":6},{"title":"맥에서 게임 즐기는 방법","description":"","date":"2024-06-23 15:34","slug":"2024-06-23-GamingonAMac","content":"\n\n## Mac 게임 경험담\n\n![Mac Gaming](/assets/img/2024-06-23-GamingonAMac_0.png)\n\n저는 64GB RAM, 38 GPU, 12코어 CPU를 장착한 Mac Studio M2를 사용하고 있어요.\n\n제 Mac 구성이 높다고 해서 낮은 구성의 Mac으로 게임을 즐길 수 없다는 건 아니에요.\n\n<div class=\"content-ad\"></div>\n\n맥에서 게임을 많이 했어요\n\n아래에 몇 가지 게임을 나열해볼게요, 하지만 언제든지 맥에서 다양한 게임을 하는 방법을 가르치는 유튜브 채널을 팔로우할 수 있어요.\n\n맥에서 게임을 하려고 할 때, 항상 염두에 두셔야 할 점은 맥은 게임용이 아닌 생산성 작업을 위한 것이라는 것이에요.\n\n그래서 제와 같이 맥에서 작업 중에 게임으로 어떤 즐거움을 느끼고 싶다면, 언제든지 맥 게임을 환영합니다.\n\n<div class=\"content-ad\"></div>\n\n맥 머신을 사용하더라도 자신을 프로 게이머로 생각하지 마세요, 마음을 맑게 유지하는 것에 좋을 뿐입니다.\n\n# 맥에서 게임하는 방법?\n\n## 맥에서 게임하는 세 가지 방법이 있습니다.\n\n- Whisky (무료)\n- Crossover (유료)\n- Parallels (유료)\n\n<div class=\"content-ad\"></div>\n\n위 소프트웨어는 Mac App Store에 없는 게임을 플레이하는 데 도움이 될 것입니다.\n\nGTA, 컨터스트라이크, 배틀필드, 콜 오브 듀티 등과 같은 게임은 앱 스토어에서 제공되지 않지만, Whisky, Crossover 및 Parallels을 사용하여 플레이할 수 있습니다.\n\n## 맥용 Crossover\n\nCrossover는 Windows 애플리케이션 또는 게임을 맥에서 실행하는 데 도움이 됩니다. 맥 자원을 완전히 활용하여 게임을 원활하게 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n여기서 크로스오버를 구할 수 있어요.\n\n이제 맥에서 크로스오버를 사용하여 GTA 5를 하는 방법을 알려 드릴게요. 이제 동일한 방법으로 다른 게임도 할 수 있어요.\n\n위의 비디오를 보시면 크로스오버로 게임하는 방법을 배울 수 있어요.\n\n크로스오버로 지원되는 게임 목록을 확인해 보세요.\n\n<div class=\"content-ad\"></div>\n\n## Parallels For Mac\n\nParallels는 맥에서 윈도우 애플리케이션이나 게임을 실행하는 데 도움이 됩니다. 맥OS 안에 가상 윈도우 OS 머신을 만들어줍니다.\n\n맥OS 및 윈도우 가상 머신 간에 자원을 할당해 주면 됩니다.\n\n게임을 위한 Parallels 설정 방법을 가르쳐 주는 동영상을 아래에서 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n여기서 Parallels를 구입할 수 있어요.\n\nParallels를 설정한 후에, 이제 아래에 있는 Battlefield 4 튜토리얼을 제공할 테니, 단계별로 Parallels를 이용해 Battlefield 4를 설정하는 방법을 배울 수 있어요.\n\n위의 동영상을 주의 깊게 보면, Call of Duty, Amra 등과 같은 다른 게임도 이와 같은 방법으로 플레이할 수 있어요.\n\nParallels에서 지원되는 게임 목록을 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n맥 게임 경험은 정말 좋았어요. 왜냐하면 게임을 거의 안 해서 그런 거겠지요. 대부분의 시간을 사업에 바쁘게 보내요.\n\n가끔 마음을 새롭게 해주고 싶을 때는 맥에서 게임을 하죠.\n\n게임플레이가 정말 멋지고 매우 부드럽게 이루어져서 기분이 좋아요. 또한 제 맥북의 성능도 높아서요.\n\n<div class=\"content-ad\"></div>\n\n하지만 맥북에서도 꽤 재미있는 게임을 즐길 수 있어요.\n\n이 이야기를 좋아하셨다면 박수를 보내주시고 저를 팔로우해주세요 :)\n\n저는 맥북 게이밍 채널을 운영하고 있어요. 거기서 맥북에서 여러 게임을 시험해보고 있어요. 그래서 구독도 해주시면 좋겠어요. 맥북 게이밍을 더 높은 수준으로 끌어올리고 싶으시다면요.\n\n💰 맥북에 게임 기탁해주세요\n\n<div class=\"content-ad\"></div>\n\n- 여러분의 기부금으로, 저는 Mac에서 다양한 게임을 구매하고 테스트할 것입니다.\n- 그 다음 그 게임을 단계별로 설정하는 방법에 대한 YouTube 자습서를 만들 것입니다.","ogImage":{"url":"/assets/img/2024-06-23-GamingonAMac_0.png"},"coverImage":"/assets/img/2024-06-23-GamingonAMac_0.png","tag":["Tech"],"readingTime":3},{"title":"macOS M1 M2 ARM64 CPU에서 Docker Desktop을 Podman으로 바꾸는 방법","description":"","date":"2024-06-23 15:31","slug":"2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU","content":"\n\n## 친절한 쿠버네티스 클러스터와 함께\n\n![이미지](/assets/img/2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU_0.png)\n\n# 배경\n\n이전 글에서는 macOS에서 이전 AMD64 아키텍처 기반 머신에 Minikube와 Hyperkit을 사용하여 Docker Desktop을 대체하는 방법에 대해 논의했습니다. 그러나 ARM64 아키텍처 CPU를 사용하는 새로운 M1/M2 머신이 등장하면서 Hyperkit은 이러한 새로운 머신과 호환되지 않습니다. 이 문제를 해결하기 위해 macOS M1/M2 머신에서 Docker Desktop을 Podman으로 대체하고 Kind를 사용하여 쿠버네티스 로컬 클러스터를 생성했습니다.\n\n<div class=\"content-ad\"></div>\n\n# macOS M1/M2 ARM64 아키텍처\n\nmacOS M1/M2는 최신 Apple 맥인토시 컴퓨터 라인으로, ARM64 아키텍처를 기반으로 합니다. ARM64 아키텍처는 컴퓨팅 세계에서 점차 인기를 끌고 있는 새로운 유형의 프로세서 아키텍처입니다. 대부분의 데스크톱 및 랩톱 컴퓨터에서 사용되는 전통적인 x86 아키텍처와 비교하면, ARM64 아키텍처는 저전력을 위해 설계되었으며 모바일 기기용으로 최적화되어 있습니다.\n\nARM64 아키텍처의 주요 장점 중 하나는 와트 당 성능 향상입니다. 이는 ARM64 아키텍처를 기반으로 한 컴퓨터가 더 적은 전력을 사용하면서도 유사하거나 더 나은 성능을 제공할 수 있음을 의미합니다. 이는 노트북의 배터리 수명 연장 및 데스크탑의 에너지 소비 감소로 이어질 수 있습니다. 또한, ARM64 아키텍처는 머신러닝과 같은 특정 작업을 위한 하드웨어 가속화와 같은 기능을 포함하고 있어, 이러한 작업 부하의 성능을 향상시킬 수 있습니다.\n\nAMD64/x86 인텔 아키텍처와 비교하면, ARM64 아키텍처는 더 새롭고 확립되지 않은 아키텍처입니다. AMD64/x86은 많은 해 동안 주도적인 아키텍처이지만, ARM64는 특히 모바일 기기와 서버에서 더 많은 인기를 얻고 있습니다. 그러나 ARM64 아키텍처에 대한 더 많은 응용 프로그램과 소프트웨어의 최적화가 이루어지면, 앞으로 더 많은 ARM64 기반 컴퓨터를 볼 수 있을 것입니다. 성능 측면에서, ARM64 아키텍처는 특정 작업 부하에 대해 AMD64/x86 아키텍처와 비교 가능하거나 더 빠를 수 있지만, 이는 구체적인 사용 사례 및 소프트웨어 최적화에 따라 다를 수 있습니다. 최종적으로 두 아키텍처 모두 강점과 약점을 가지고 있으며, 그것들 사이의 선택은 사용자나 조직의 구체적인 요구 사항에 달려 있습니다.\n\n<div class=\"content-ad\"></div>\n\n맥OS M1/M2 기기는 ARM64 아키텍처에서 실행되도록 특별히 설계되었으며, 이 아키텍처에 최적화된 소프트웨어와 도구가 필요하여 효율적으로 실행할 수 있습니다. x86 아키텍처에서 실행되도록 설계된 일부 소프트웨어는 macOS M1/M2 기기에서 제대로 작동하지 않을 수 있으므로, 개발자와 사용자는 호환성과 최적 성능을 보장하기 위해 ARM64 아키텍처용 도구와 소프트웨어를 사용해야 합니다.\n\n# Docker Desktop\n\nmacOS에서 Docker Desktop은 Docker 컨테이너를 사용하여 애플리케이션을 쉽게 빌드, 테스트 및 배포할 수 있도록 합니다. 컨테이너, 이미지 및 네트워크를 관리하기 위한 간단하고 사용자 친화적인 인터페이스를 제공하며, 다양한 플랫폼 및 운영 체제에서 사용할 수 있습니다. ARM64 아키텍처 기반의 최신 macOS M1/M2 기기가 출시된 가운데, Docker는 ARM64 아키텍처에 최적화된 새로운 Docker Desktop 버전을 출시했습니다. 이 버전은 Apple의 Hypervisor.framework를 활용하여 가상화 환경에서 컨테이너를 실행하며, 이를 통해 Docker Desktop을 사용하는 개발자와 IT 전문가에게 매끄러운 경험을 제공합니다.\n\nDocker Desktop은 컨테이너화에 강력한 도구를 제공하지만, 단점도 있습니다. Docker Desktop 사용의 주요 단점 중 하나는 백그라운드에서 실행되는 별도의 데몬 프로세스를 필요로 한다는 점인데, 이는 상당한 시스템 리소스를 소비할 수 있습니다. 또한, Docker Desktop은 일부 애플리케이션 및 운영 체제와 가끔 호환성 문제가 있어 사용자들에게 다운타임과 귀찮음을 초래할 수 있습니다. 게다가, 최근 Docker Desktop의 라이선스 요구사항 변경으로 많은 사용자가 대안을 찾고 있습니다. 결과적으로, Podman과 같은 대체 솔루션들이 이 기기에서 컨테이너화 요구를 충족하는 데 더 인기를 얻고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# Podman\n\nPodman은 빌드, 관리 및 실행을 위한 Docker의 대체제로 제공되는 인기 있는 컨테이너 관리 도구입니다. ARM64 아키텍처 기반의 새로운 macOS M1/M2 기계가 출시되면서, Podman은 컨테이너화 요구 사항에 대한 Docker Desktop의 대안으로 나타나고 있습니다.\n\nPodman은 ARM64 아키텍처에 최적화되어 개발자와 IT 전문가들에게 뛰어난 경험을 제공합니다. Docker와 달리, Podman은 Linux 커널의 컨테이너화 기능을 사용하므로 별도의 백그라운드 데몬 프로세스가 실행되어야 하는 필요가 없습니다. 이는 성능 향상과 리소스 소비의 감소로 이어질 수 있습니다.\n\nmacOS M1/M2 기계에서 Podman을 사용하는 주요 이점 중 하나는 가상 머신을 사용하지 않아도 된다는 점입니다. 대신, Podman은 ARM64 아키텍처의 네이티브 컨테이너화 기능을 활용하여 더 효율적이고 간소화된 경험을 제공합니다. Podman은 ARM64 아키텍처를 기반으로 하는 macOS M1/M2 기계에서 Docker Desktop에 대한 유망한 대안입니다. 최적화된 성능과 간소화된 컨테이너화 기능을 갖춘 Podman은 이러한 기계에서 컨테이너를 빌드, 관리 및 실행해야 하는 개발자와 IT 전문가들에게 강력한 도구를 제공합니다.\n\n<div class=\"content-ad\"></div>\n\n새로운 macOS M1/M2 기기에서 ARM64 아키텍처를 사용하는 Podman을 설정하는 가이드입니다. 이를 통해 더 가벼우면서도 효율적인 컨테이너화 도구로 Docker 및 Docker Desktop을 대체할 수 있습니다.\n\n## 1. Podman 설치 및 구성\n\nmacOS에는 Homebrew 패키지 관리자를 사용하여 Podman을 설치할 수 있습니다. 설치한 후, Podman을 루트 없는 컨테이너와 함께 사용할 수 있도록 구성할 수 있습니다. 이때 주의해야 할 점은 Linux 시스템과는 달리 macOS(그리고 Windows)에서는 Podman 사용 시 가상 머신을 사용해야 한다는 것입니다. 가상 머신은 QEMU 에뮬레이터를 사용하여 Linux 런타임 환경을 제공합니다. MacOS와 Windows는 Podman이 의존하는 Linux 네임스페이스 및 cgroups를 네이티브로 지원하지 않기 때문입니다.\n\n```js\n# Podman 설치\n❯❯ brew install podman\n\n# 새로운 Linux 런타임 환경 초기화 (이를 'podman machine'이라고 합니다)\n# Podman은 quem 에뮬레이터를 사용하여 Linux 런타임 환경을 제공합니다\n# --cpus 4 (CPU 코어 수 지정)\n# --memory=6144 (메모리 용량 지정)\n❯❯ podman machine init --cpus 4 --memory=6144\n\n# Podman 머신 목록 표시\n# 기본 Podman 머신은 `podman-machine-default*`입니다\n❯❯ podman machine ls\nNAME                     VM TYPE     CREATED     LAST UP     CPUS        MEMORY      DISK SIZE\npodman-machine-default*  qemu        4 days ago  4 days ago  2           2.147GB     107.4GB\n\n# 런타임 시작\n# Podman은 /Users, /private, /var/folders 디렉터리에 볼륨 매핑을 사용합니다\n❯❯ podman machine start\n\"podman-machine-default\" 머신 시작 중\nVM 대기 중...\n볼륨 마운트... /Users:/Users\n볼륨 마운트... /private:/private\n볼륨 마운트... /var/folders:/var/folders\n\n현재 이 머신은 루트 없는 모드로 구성되어 있습니다. 컨테이너에 루트 권한이 필요한 경우(예: 포트 < 1024) 또는 비-Podman 클라이언트와의 호환성 문제가 발생한 경우, 다음 명령을 사용하여 전환할 수 있습니다:\n\n podman machine set --rootful\n\nAPI 전달 Listening: /Users/lambda.eranga/.local/share/containers/podman/machine/podman-machine-default/podman.sock\n\n시스템 도우미 서비스가 설치되어 있지 않습니다; podman에서는 기본 Docker API 소켓 주소를 사용할 수 없습니다. 설치하려면 다음 명령을 실행하세요:\n\n sudo /opt/homebrew/Cellar/podman/4.4.2/bin/podman-mac-helper install\n podman machine stop; podman machine start\n\n터미널 세션에서 다음 몤령을 사용하여 여전히 Docker API 클라이언트에 연결할 수 있습니다:\n\n export DOCKER_HOST='unix:///Users/lambda.eranga/.local/share/containers/podman/machine/podman-machine-default/podman.sock'\n\n\"podman-machine-default\" 머신이 성공적으로 시작되었습니다\npodman machine start\n\n# Podman 머신이 실행 중\n❯❯ podman machine ls\nNAME                     VM TYPE     CREATED     LAST UP            CPUS        MEMORY      DISK SIZE\npodman-machine-default*  qemu        4 days ago  Currently running  2           2.147GB     107.4GB\n\n# 정보 확인\n❯❯ podman info\n\n# Podman 연결\n❯❯ podman system connection ls\nName                         URI                                                         Identity                                          Default\npodman-machine-default       ssh://core@localhost:50985/run/user/501/podman/podman.sock  /Users/lambda.eranga/.ssh/podman-machine-default  true\npodman-machine-default-root  ssh://root@localhost:50985/run/podman/podman.sock           /Users/lambda.eranga/.ssh/podman-machine-default  false\n\n# 머신 정지\n❯❯ podman machine stop\n\n# 머신 재시작\n❯❯ podman machine stop; podman machine start\n\n# Podman 머신에 SSH 접속\n❯❯ podman machine ssh\n\n# 머신 제거\n❯❯ podman machine rm -f podman-machine-default\n```\n\n<div class=\"content-ad\"></div>\n\n## 2. Podman Commands\n\nPodman은 Docker와 유사한 명령줄 인터페이스를 제공합니다. 사실, Podman에서 사용하는 많은 명령어는 Docker에서 사용하는 것과 동일하여 Docker에 익숙한 사용자가 Podman으로 쉽게 전환할 수 있습니다. Podman에서 다양한 명령어를 실행하려면 원하는 특정 명령어 뒤에 podman 명령어를 사용할 수 있습니다. 예를 들어, 모든 실행 중인 컨테이너를 나열하려면 podman ps 명령어를 사용할 수 있습니다. 마찬가지로 Dockerfile에서 이미지를 빌드하려면 podman build -t image_name -f Dockerfile_path와 같은 명령어를 사용할 수 있습니다. Podman은 컨테이너 시작 및 중지, 실행 중인 컨테이너에 연결 및 이미지 및 볼륨 관리와 같은 일반적인 컨테이너화 작업을 지원합니다.\n\n```js\n# 이미지 목록\n❯❯ podman images\nREPOSITORY                           TAG             IMAGE ID      CREATED       SIZE\ndocker.io/hashicorp/envconsul        0.13.0          42307d16e023  8 months ago  18.7 MB\ndocker.io/library/vault              <none>          aac433bb6835  2 years ago   147MB\n\n# PostgreSQL 이미지 다운로드\n❯❯ podman pull postgres:latest\n...\n\n# PostgreSQL 실행\n❯❯ podman run --name postgres -e POSTGRES_PASSWORD=admin -p 5432:5432 -d postgres\n6ee93adb00d1f1a468308b50a044002e2f7da116614ebb8d092d8236ae6542d6\n\n# 실행 중인 컨테이너 목록\n❯❯ podman ps\nCONTAINER ID  IMAGE                              COMMAND     CREATED        STATUS        PORTS                   NAMES\n6ee93adb00d1  docker.io/library/postgres:latest  postgres    4 seconds ago  Up 4 seconds  0.0.0.0:5432->5432/tcp  postgres\n\n# 명령어 실행 시 디버그 로그 보기\n❯❯ podman --log-level=debug ps\n...\n\n## 3. Create Docker Alias\n```\n\n<div class=\"content-ad\"></div>\n\nPodman은 Docker와 매우 유사한 명령줄 인터페이스를 제공하여 Docker에서 Podman으로 쉽게 전환할 수 있습니다. 실제로 Podman과 Docker를 동일하게 사용할 수 있도록 Docker에 대한 별칭을 Podman으로 만들 수 있습니다. 예를 들어, 다음 Alias를 ~/.zshrc 파일에 추가하여 Podman의 docker alias를 만들 수 있습니다.\n\n```js\n# alias to docker, run podman commands as docker\nalias docker=podman\n```\n\n별칭을 설정한 후에는 docker 명령을 podman 명령처럼 사용할 수 있으며, docker 명령을 사용하여 Podman 명령을 실행할 수 있습니다. Docker에서 작업하는 데 익숙하고 새로운 명령어를 배우지 않고 Podman으로 전환하려는 경우 도움이 될 수 있습니다. 그러나 Docker와 Podman 사이에 동작에 차이가 있을 수 있으므로 docker alias를 Podman과 함께 사용할 때 작업 흐름을 충분히 테스트해야 합니다.\n\n```js\n# list images with docker alias\n❯❯ docker images\nREPOSITORY                           TAG             IMAGE ID      CREATED       SIZE\ndocker.io/library/postgres           latest          61d0571c2f7b  2 weeks ago   368 MB\ndocker.io/hashicorp/envconsul        0.13.0          42307d16e023  8 months ago  18.7 MB\ndocker.io/library/vault              <none>          aac433bb6835  2 years ago   147 MB\n\n# list containers\n❯❯ docker ps\nCONTAINER ID  IMAGE                              COMMAND     CREATED        STATUS        PORTS                   NAMES\n6ee93adb00d1  docker.io/library/postgres:latest  postgres    4 minutes ago  Up 4 minutes  0.0.0.0:5432->5432/tcp  postgres\n```\n\n<div class=\"content-ad\"></div>\n\n## 4. Podman REST API에 액세스하기\n\npodman.sock은 Podman 데몬이 Podman 클라이언트로부터 요청을 수신하기 위해 사용하는 유닉스 도메인 소켓입니다. Podman 명령을 실행할 때 Podman 클라이언트는 podman.sock 소켓을 통해 Podman 데몬에 요청을 보내고, 데몬은 요청을 처리하고 클라이언트에 응답을 보냅니다. 기본적으로 podman.sock 소켓은 Podman이 실행 중인 기기에서 로컬로만 액세스할 수 있습니다. 그러나 socat을 사용하여 podman.sock 소켓을 TCP 소켓에 바인딩하여 HTTP REST API를 통해 Podman에 원격 액세스할 수 있도록 설정할 수 있습니다.\n\n다음 예제에서는 podman.sock 유닉스 소켓을 socat을 사용하여 TCP 포트 2375에 바인딩하는 방법을 보여줍니다. 이를 통해 호스트 기기에서 이 포트에 연결하고 podman REST API를 외부에 노출시킬 수 있습니다. 설정이 완료되면 REST 클라이언트가 포트 2375에 연결하여 Podman REST API에 액세스할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## 5. ARM64 CPU 아키텍처 이미지 실행하기\n\nPodman을 사용하여 컨테이너 이미지를 실행할 때, 컨테이너는 호스트 머신과 동일한 CPU 아키텍처에서 실행됩니다. 즉, 호스트 머신이 ARM64 CPU 아키텍처를 가지고 있다면, Podman은 ARM64 아키텍처를 사용하여 컨테이너를 실행합니다. 만약 호스트 머신이 AMD64 또는 x86 아키텍처를 가지고 있다면, 컨테이너는 해당 아키텍처로 실행됩니다.\n\n주의할 점은 호스트 머신의 아키텍처와 다른 아키텍처의 컨테이너 이미지를 실행하려고 한다면, Podman이 해당 컨테이너를 실행할 수 없다는 것입니다. 예를 들어, AMD64 또는 x86 아키텍처를 가진 호스트 머신에서 ARM64 컨테이너 이미지를 실행하려고 하면, Podman은 해당 컨테이너를 실행할 수 없습니다.\n\n이 제한을 극복하기 위해, multi-architecture 컨테이너 이미지를 사용할 수 있습니다. 이러한 이미지에는 여러 CPU 아키텍처의 이진 파일과 라이브러리가 포함되어 있어, 동일한 이미지가 다른 아키텍처의 머신에서 실행될 수 있습니다. Docker와 Podman은 모두 multi-architecture 이미지를 지원합니다. multi-architecture 이미지를 가져올 때, Podman은 자동으로 호스트 머신에 맞는 올바른 아키텍처를 선택하고 해당 아키텍처로 컨테이너를 실행합니다.\n\n<div class=\"content-ad\"></div>\n\nmquery 도구를 사용하면 공개 컨테이너 저장소의 모든 공개 이미지를 쿼리하여 미디어 유형, 다이제스트 및 플랫폼 지원을 확인할 수 있습니다. 또한 도커 이미지의 사용 가능한 CPU 아키텍처를 확인하는 데 사용할 수 있습니다. 이 도구는 estesp/mquery라는 이름의 Docker 이미지로 제공됩니다. 해당 이미지를 실행하여 어떤 도커 이미지의 CPU 아키텍처를 확인할 수 있습니다. 결과에는 이미지를 지원하는 플랫폼이 표시되며, 해당 아키텍처, 운영 체제 및 버전이 포함됩니다. 시스템의 CPU 아키텍처와 호환되는지 확인하는 데 유용할 수 있습니다.\n\n```js\n# postgres:latest 이미지의 사용 가능한 CPU 아키텍처 보기\n# postgres:latest 이미지는 arm64를 포함한 모든 CPU 아키텍처로 제공됩니다\n# macOS M1에서 postgres:latest를 실행하는 경우 arm64 이미지가 선택됩니다\n❯❯ docker run --rm mplatform/mquery postgres:latest\nImage: postgres:latest (digest: sha256:50a96a21f2992518c2cb4601467cf27c7ac852542d8913c1872fe45cd6449947)\n * Manifest List: Yes (Image type: application/vnd.docker.distribution.manifest.list.v2+json)\n * Supported platforms:\n   - linux/amd64\n   - linux/arm/v5\n   - linux/arm/v7\n   - linux/arm64/v8\n   - linux/386\n   - linux/mips64le\n   - linux/ppc64le\n   - linux/s390x\n\n# 실행 중인 postgres:latest 이미지의 CPU 아키텍처 보기\n# macOS M1에서 postgres:latest를 실행하는 경우 arm64 이미지가 선택됩니다\n❯❯ docker image inspect postgres:latest | grep Architecture\n          \"Architecture\": \"arm64\",\n```\n\n## 6. AMD64 CPU 아키텍처 이미지 실행\n\nPodman에서 AMD64와 같은 다른 CPU 아키텍처용으로 빌드된 도커 이미지를 macOS M1/M2 ARM64 CPU에 실행하려고 하면 에러가 발생하여 실패할 것입니다. 이는 이미지가 호스트 머신의 CPU 아키텍처와 호환되지 않기 때문입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# mysql:8.0.23은 amd64 아키텍처 이미지만 사용 가능합니다\n❯❯ docker run --rm mplatform/mquery mysql:8.0.23\n이미지: mysql:8.0.23 (다이제스트: sha256:6e0014cdd88092545557dee5e9eb7e1a3c84c9a14ad2418d5f2231e930967a38)\n * Manifest List: Yes (이미지 유형: application/vnd.docker.distribution.manifest.list.v2+json)\n * 지원하는 플랫폼:\n   - linux/amd64\n\n# mac m1 arm64 머신에서 mysql:8.0.23 실행 시 발생하는 오류입니다\n❯❯ docker run mysql:8.0.23\n\"mysql\"을 미지정 검색 레지스트리를 사용하여 해석 중 (/etc/containers/registries.conf.d/999-podman-machine.conf)\ndocker.io/library/mysql:8.0.23에서 가져오려고 시도 중...\n오류: 아키텍처 arm64, 변형 \"v8\", OS linux에 대한 매니페스트 목록에서 이미지를 찾을 수 없음\n\n그러나 Podman은 이 문제에 대한 다중 아키텍처 지원으로 해결책을 제공합니다. --arch 옵션을 사용하여 실행하려는 플랫폼을 지정할 수 있고, 해당 플랫폼에 대해 사용 가능한 경우 Podman은 자동으로 이미지의 올바른 버전을 가져옵니다. 이를 통해 macOS M1/M2 ARM64 CPU에서 다른 CPU 아키텍처용 이미지를 문제 없이 실행할 수 있습니다.\n\n# amd64 아키텍처를 지정하여 mysql 이미지 실행\n# 그럼 podman은 amd64 아키텍처로 docker 이미지를 가져와 실행합니다\n❯❯ docker run --arch=amd64 mysql:8.0.23\n\"mysql\"을 미지정 검색 레지스트리를 사용하여 해석 중 (/etc/containers/registries.conf.d/999-podman-machine.conf)\ndocker.io/library/mysql:8.0.23에서 가져오려고 시도 중...\n이미지 소스 서명 가져옴\nblob sha256:15f235e0d7eefe6c5153946a57daebaf2d0744fb1d0676642f269554fc68ba2a 복사 중\n(중략)\nconfig sha256:cbe8815cbea8fb86ce7d3169a82d05301e7dfe1a8d4228941f23f4f115a887f2 복사 중\n이미지 목적지에 매니페스트 쓰는 중\n서명 저장 중\n2023-03-18 01:58:56+00:00 [Note] [Entrypoint]: MySQL Server 8.0.23-1debian10용 입구점 스크립트 시작됨.\n(중략)\n2023-03-18 01:58:57+00:00 [ERROR] [Entrypoint]: 데이터베이스가 초기화되지 않았으며 암호 옵션이 지정되지 않았습니다\n    다음 중 하나를 지정해야 합니다:\n    - MYSQL_ROOT_PASSWORD\n    - MYSQL_ALLOW_EMPTY_PASSWORD\n    - MYSQL_RANDOM_ROOT_PASSWORD\n\n--arch 옵션이 작동하지 않는 경우, multiarch/qemu-user-static을 사용한 해결책이 있습니다. 이 글에서 그 해결책에 대해 자세히 설명합니다.\n``` \n\n<div class=\"content-ad\"></div>\n\n```js\r\npodman machine ssh\nsudo -i\nrpm-ostree install qemu-user-static\nsystemctl reboot\r\n```\n\n## 7. 다른 CPU 아키텍처로 이미지 빌드하기\n\nPodman으로 이미지를 빌드할 때 --arch 플래그를 사용하여 이미지에 원하는 CPU 아키텍처를 선택할 수 있습니다. 기본적으로 Podman은 실행 중인 기기의 CPU 아키텍처를 사용합니다. 이를 통해 Podman을 사용하여 멀티 아키텍처 이미지를 빌드할 수 있으며, 동일한 응용 프로그램을 다양한 CPU 아키텍처에서 실행하는 데 유용할 수 있습니다. 아래는 다른 아키텍처 이미지를 빌드하는 데 사용되는 예시 golang 응용프로그램(main.go)과 Dockerfile입니다.\n\n```js\r\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n fmt.Println(\"vim-go\")\n}\r\n```\n\n<div class=\"content-ad\"></div>\n\n```js\r\nFROM golang:1.16-alpine as builder\nWORKDIR /app\nCOPY . .\n\nRUN go build -o main *.go\n\nFROM alpine:latest\nWORKDIR /root/\nCOPY --from=builder /app/main .\nCMD [ \"./main\" ]\r\n```\n\nAMD64 아키텍처를 사용하여 이미지를 빌드하려면 Podman을 사용하여 다음 명령을 --arch=amd64 매개변수와 함께 사용할 수 있습니다. 이는 AMD64 아키텍처 기본 이미지를 사용하고 그 위에 새 이미지를 빌드합니다.\n\n```js\r\n# amd64 cpu 아키텍처로 도커 이미지 빌드\n# 빌드할 때 주어진 cpu 아키텍처의 기반 이미지 및 라이브러리를 가져옵니다\n❯❯ docker build --arch=amd64 --rm -t erangaeb/hello .\n[1/2] 단계 1/4: FROM golang:1.16-alpine AS builder\n\"golang\"를 unqualified-search 레지스트리(../../containers/registries.conf.d/999-podman-machine.conf)를 사용하여 해석 중\ndocker.io/library/golang:1.16-alpine를 가져오려는 중...\n이미지 소스 서명 가져오는 중\nblob sha256:0435e09637941e35cccdf9cf9171571811d2fdfe72c27e39543a718d38d28668 복사 중\nblob sha256:59bf1c3509f33515622619af21ed55bbe26d24913cedbca106468a5fb37a50c3 복사 중\nblob sha256:666ba61612fd7c93393f9a5bc1751d8a9929e32d51501dba691da9e8232bc87b 복사 중\nblob sha256:8ed8ca4862056a130f714accb3538decfa0663fec84e635d8b5a0a3305353dee 복사 중\nblob sha256:ca4bf87e467a8cacf62c9b01c7d6d43f6ca4bb9b0fc9146fbb906b05aee56cc1 복사 중\nconfig sha256:7642119cd16177d874dcbfe1c550affd336dbe4cabb3339ef685ac1d6ec71ccc 복사 중\n이미지 목적지에 매니페스트 작성 중\n서명 저장 중\n[1/2] 단계 2/4: WORKDIR /app\n--> 캐시 푸시 []:220abc07870fcc2e449b7b03384b2e4c219f7c32b28546f90067c1488ea63ba0\n--> 663c9d6f7ea\n[1/2] 단계 3/4: COPY . .\n--> 캐시 푸시 []:e7db7815e4762b218ab81c3f93cdf789c4961c783825470c3c2edb55000b1844\n--> ce3d882f4c8\n[1/2] 단계 4/4: RUN go build -o main *.go\n--> 캐시 푸시 []:95b5a69b661a646895b2a2bc6b313e0f5fd2cc83a4d7dcd1e5f2594be34c3d4d\n--> 54d84331cf2\n사용자 정의 erangaeb/hello 이미지가 성공적으로 빌드되었습니다\nc1329ead22a2cf66cd4a47b06aa0d406aba34798d26e79d666e1d855cd920028\n\n# 이미지 실행\n# 이미지를 arm64 cpu로 빌드한 후 --arch=amd64를 명시해야 함\n# 그렇지 않으면 amd64 cpu 아키텍처 이미지를 가져와 실패할 것입니다\n❯❯ docker run --arch=amd64 localhost/erangaeb/hello\n경고: 이미지 플랫폼(리눅스/amd64)이 예상 플랫폼(리눅스/arm64)과 일치하지 않습니다\nvim-go\r\n```\n\n다음은 Podman을 사용하여 arm64 아키텍처로 이미지를 빌드하는 예제 명령입니다. 이 명령은 --arch 플래그를 사용하여 ARM64 아키텍처를 지정합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n# arm64 CPU 아키텍처로 도커 이미지 빌드\n❯❯ docker build --arch=arm64 --rm -t erangaeb/hello:arm64 .\n[1/2] 단계 1/4: golang:1.16-alpine을 빌드 중\n... (중략) ...\n[2/2] 단계 1/4: alpine:latest으로 빌드 중\n... (중략) ...\nerangaeb/hello:arm64 이미지 구축 완료\n4d98d25ec13db2b9c25c149a0c3f5996829029026a6fd295e55c78acc9cef89e\n\n# arm64 이미지 실행\n# CPU 아키텍처와 일치하여 경고 없이 실행됩니다.\n❯❯ docker run localhost/erangaeb/hello:arm64\nvim-go\n```\n\n## 8. 쿠버네티스 클러스터 실행\n\n로컬 쿠버네티스 클러스터를 생성하기 위해 Kind와 Podman을 함께 사용했습니다. Kind는 로컬 머신에서 도커 컨테이너로 작동하는 클러스터 노드로서 쿠버네티스 클러스터를 운영할 수 있게 해주는 오픈소스 도구입니다. 아래는 Podman을 활용하여 Kind 클러스터를 설정하는 단계입니다.\n\n```js\n# asdf를 사용하여 kind 설치\n❯❯ asdf plugin add kind\n❯❯ asdf install kind 0.17.0\n❯❯ asdf global kind 0.17.0\n\n# ~/.zshrc 파일에 아래 구성 추가하여 rootless podman으로 kind 실행\nKIND_EXPERIMENTAL_PROVIDER=podman\n\n# 클러스터 생성\n# 클러스터 이름은 'kind'로 지정됩니다.\n❯❯ kind create cluster \n\n# kubectl 컨텍스트인 kind-kind가 추가됩니다.\n❯❯ kubectl config get-contexts\n... (중략) ...\n\n# kind 클러스터 조회\n❯❯ kind get clusters\n... (중략) ...\n\n# 클러스터 노드에 이미지 로드\n# 비공개 도커 레지스트리(예: Google Container Registry/GCR)에 있는 이미지 실행에 도움이 됩니다.\n❯❯ kind load docker-image eu.gcr.io/rahasak-build/lambdaops:1.0\n\n# kind-kind 컨텍스트로 kind 클러스터 사용\n❯❯ kubectl --context=kind-kind get pods\n\n# 클러스터 삭제\n❯❯ kind delete cluster\n```\n\n<div class=\"content-ad\"></div>\n\n## 9. Google Container Registry 인증\n\nGoogle Container Registry(GCR)와 통합하고 싶을 수 있습니다. 이는 Google Cloud가 제공하는 Docker 이미지를 저장하고 관리하는 호스팅 서비스입니다. GCR 문서에는 Docker와의 인증에 대한 훌륭한 안내가 제공됩니다. 첫 번째 인증 방법은 gcloud 자격 증명 도우미를 사용하는 것인데, 이는 gcloud CLI를 사용하여 Cloud Shell 또는 Google Cloud CLI가 설치된 모든 환경에서 인증을 구성합니다. Docker의 gcloud 자격 증명 도우미 방법을 통해 한 번 인증을 받으면 같은 인증 방법을 Podman에서도 사용할 수 있습니다. 먼저 Google Cloud 계정으로 gcloud auth login 명령을 실행하여 인증하십시오. 다음으로, gcloud auth configure-docker `registry host` 명령을 사용하여 Docker가 GCR과 인증하도록 구성하십시오. 이 작업이 완료되면 Podman은 Docker 자격 증명을 재사용할 수 있습니다.\n\n```js\n# 웹 플로우를 통해 gcloud 서비스에 로그인\n❯❯ gcloud auth login\n\n# 자격 증명을 ~/.config/gcloud/credentials.db SQLite 데이터베이스에 저장합니다\n❯❯ sqlite3 credentials.db \"SELECT value FROM credentials\"\n{\n  \"client_id\": \"<id>.apps.googleusercontent.com\",\n  \"client_secret\": \"<secret>\",\n  \"refresh_token\": \"<token>\",\n  \"revoke_uri\": \"https://accounts.google.com/o/oauth2/revoke\",\n  \"scopes\": [\n    \"openid\",\n    \"https://www.googleapis.com/auth/userinfo.email\",\n    \"https://www.googleapis.com/auth/cloud-platform\",\n    \"https://www.googleapis.com/auth/appengine.admin\",\n    \"https://www.googleapis.com/auth/sqlservice.login\",\n    \"https://www.googleapis.com/auth/compute\",\n    \"https://www.googleapis.com/auth/accounts.reauth\"\n  ],\n  \"token_uri\": \"https://oauth2.googleapis.com/token\",\n  \"type\": \"authorized_user\"\n}\n\n# Docker가 GCR과 인증하도록 구성\n# 그럼 Podman이 해당 자격 증명을 재사용할 수 있습니다\n# 명령어\n❯❯ gcloud auth configure-docker <registry host>\n\n# 예시\n❯❯ gcloud auth configure-docker eu.gcr.io\nAdding credentials for: eu.gcr.io\n업데이트 후 다음이 Docker 구성 파일에 작성될 것입니다\n[/Users/lambda.eranga/.docker/config.json]:\n {\n  \"credHelpers\": {\n    \"eu.gcr.io\": \"gcloud\"\n  }\n}\n계속하시겠습니까 (Y/n)?  Y\n\n# 원하는 경우 더 많은 레지스트리 호스트를 추가할 수 있습니다\n❯❯ gcloud auth configure-docker europe-docker.pkg.dev\n❯❯ gcloud auth configure-docker europe-north1-docker.pkg.dev\n\n# 생성된 구성은 홈 디렉토리 ~/.docker/config.json에 저장됩니다\n❯❯ cat ~/.docker/config.json\n{\n  \"credHelpers\": {\n    \"eu.gcr.io\": \"gcloud\",\n    \"europe-docker.pkg.dev\": \"gcloud\",\n    \"europe-north1-docker.pkg.dev\": \"gcloud\"\n  }\n}\n\n# 이제 Podman은 Docker 자격 증명을 사용하여 credential helper gcloud를 통해 GCR에 접근할 수 있습니다\n❯❯ docker pull eu.gcr.io/rahasak-build/aplos:0.1 --log-level=debug\nINFO[0000] podman filtering at log level debug\n⋮\n```\n\n이전 방법은 Podman이 Docker GCR 인증 구성을 사용하여 Google Container Registry와 인증하는 방법을 설명했습니다. 그러나 Podman은 직접 컨테이너 레지스트리에 로그인하기 위한 podman login이라는 명령도 제공합니다. 이 명령은 Container Registry와 함께 사용할 수 있는 단기간의 OAuth 액세스 토큰을 사용하여 인증합니다. 이 토큰은 60분 동안만 유효하므로 Container Registry에 연결하기 전 1시간 이전에 요청해야 합니다. 토큰이 만료되면 다시 로그인해야 하며, 그렇지 않으면 권한 없음: 인증 실패 오류가 발생할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n```yaml\n# 웹 플로우를 통해 gcloud 서비스에 로그인해주세요\n❯❯ gcloud auth login\n\n# 이전에 생성된 도커 자격 증명을 제거해주세요\n❯❯ rm -rf ~/.docker\n\n# 짧게 유지되는 액세스 토큰을 생성하고 sqlite db ~/.config/gcloud/access_tokens.db에 저장됩니다\n❯❯ sqlite3 access_tokens.db \"select * from access_tokens\"\n\n# 액세스 토큰 확인\n❯❯ gcloud auth print-access-token\n\n# 액세스 토큰으로 gcr에 로그인\n# 이렇게 짧게 유지되는 OAuth 액세스 토큰을 사용하여 Container Registry와 인증합니다. \n# 토큰은 60분 동안 유효하며, Container Registry에 연결하기 전에 한 시간 이내에 요청해야 합니다.\n# 토큰 만료 시, 아래 명령어를 다시 실행하고 다시 로그인해야 합니다. 그렇지 않으면 권한이 없음: 인증 실패 오류가 발생합니다.\n❯❯ gcloud auth print-access-token | podman login -u oauth2accesstoken --password-stdin eu.gcr.io\n\n# ~/.config/containers/auth.json에 인증 파일이 생성됩니다\n❯❯ cat .config/containers/auth.json\n```\n{\n \"auths\": {\n  \"eu.gcr.io\": {\n   \"auth\": \"<액세스 토큰>\"\n  }\n }\n}\n\n# 이제 podman은 docker 자격 증명을 사용하여 gcr에 액세스할 수 있습니다(자격 증명 도우미 gcloud 사용)\n❯❯ docker pull eu.gcr.io/rahasak-build/aplos:0.1 --log-level=debug\nINFO[0000] log level debug에서 podman 필터링\nDEBU[0000] pull.PersistentPreRunE(podman pull eu.gcr.io/rahasak-build/aplos:0.1 --log-level=debug) 호출\nDEBU[0000] DoRequest 메서드: GET URI: http://d/v4.4.2/libpod/_ping\nDEBU[0000] \"/etc/containers/registries.conf\"에서 레지스트리 구성로드\nDEBU[0000] 자격 증명 도우미 containers-auth.json에서 /Users/lambda.eranga/.config/containers/auth.json 파일의 eu.gcr.io 자격 증명 찾음\nDEBU[0000] DoRequest 메서드: POST URI: http://d/v4.4.2/libpod/images/pull\neu.gcr.io/rahasak-build/aplos:0.1 끌어오기 시도 중...\n이미지 소스 서명 가져오는 중\nblob sha256:9fa0fafc404b18044192115d295424237056a9296da9fe07f3f493f714d7c6fb 복사 중\nblob sha256:b9fd7cb1ff8f489cf082781b0e1fe0c13b840e20147e8fc8204b4592da7c2f70 복사 중\nblob sha256:f25ad21146dc80e14a651d9f59707ccab21bd3749aee1177faf72329661f19eb 복사 중\nblob sha256:e92ed755c008afc1863a616a5ba743b670c09c1698f7328f05591932452a425f 복사 중\nblob sha256:53e3366ec435596bed2563cc882ba47ec25df6be2b1027e3243e83589c667c1e 복사 중\nblob sha256:ee690f2d57a128744cf4c5b52646ad0ba7a5af113d9d7e0e02b62c06d35fd14c 복사 중\nblob sha256:e83609f677899ddd7e01f03fd3f797d98fb18e3307a236b55b218a59f5cf7b9b 복사 중\nblob sha256:88c7c603b3faedd122305543eb17d6968a16399c7a93f67b3486196b2440c846 복사 중\n\n# 로그인 취소\n❯❯ podman logout eu.gcr.io\r\n\n\n# 참고\n\n- https://medium.com/rahasak/replace-docker-desktop-with-minikube-and-hyperkit-on-macos-783ce4fb39e3\r\n- https://dev.to/docker/choosing-the-right-docker-image-for-your-apple-m1-pro-440l\r\n- https://zenn.dev/sbk0716/articles/d9235b78b97615\r\n- https://itnext.io/using-minikube-on-m1-macs-416da593ba0c\r\n- https://itnext.io/goodbye-docker-desktop-hello-minikube-3649f2a1c469\r\n- https://0to1.nl/post/minikube-m1-pro-issues/\r\n- https://www.redhat.com/sysadmin/podman-python-bash\r\n- https://edofic.com/posts/2021-09-12-podman-m1-amd64/\r\n- https://xphyr.net/post/podman_on_osx/\r\n- https://www.redhat.com/sysadmin/specify-architecture-pulling-podman-images\r\n- https://itnext.io/kubernetes-kind-cheat-shee-2605da77984\r\n","ogImage":{"url":"/assets/img/2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU_0.png"},"coverImage":"/assets/img/2024-06-23-SwitchingfromDockerDesktoptoPodmanonmacOSM1M2ARM64CPU_0.png","tag":["Tech"],"readingTime":23},{"title":"VeraCrypt로 언제 어디서나 데이터를 암호화하는 방법","description":"","date":"2024-06-23 15:29","slug":"2024-06-23-EncryptYourDataAnytimeandAnywherewithVeraCrypt","content":"\n\n<img src=\"/assets/img/2024-06-23-EncryptYourDataAnytimeandAnywherewithVeraCrypt_0.png\" />\n\n눈에 띄는 개발자님! 민감한 정보를 안전하게 보호하는 것은 매우 중요합니다. 이 기사에서는 암호화된 볼륨을 만드는 실용적인 측면에 초점을 맞추어 몇 가지 명령만 있으면 매우 쉽게 가능하다는 것을 보여드릴 거에요.\n\n가능한 사용 사례:\n\n- 클라우드에 업로드하기 전 개인 사진, 비디오 데이터, 문서를 암호화하기;\n- 비밀 정보, 예를 들어 비밀번호나 기타 민감한 데이터가 포함된 메모를 암호화하기;\n- 특히 사용자 프로필 데이터가 있는 데이터베이스 백업을 암호화하기.\n\n<div class=\"content-ad\"></div>\n\n# VeraCrypt 설치\n\n오늘은 GUI가 아닌 터미널 버전에 초점을 맞추고 있습니다. 이는 개념을 더 잘 이해하고 그래픽 및 비그래픽 인터페이스 모두에 적용하는 데 도움이 될 것입니다.\n\n또한, 올바른 명령을 얻은 후에는 UI 버튼을 클릭하는 것보다 메모에서 터미널로 복사하여 붙여넣는 것이 훨씬 빠릅니다.\n\n## 설치 프로그램 다운로드\n\n<div class=\"content-ad\"></div>\n\n우분투 / 데비안 예시\n\n```js\n# From https://launchpad.net/veracrypt/\n# Arm version\nwget https://launchpad.net/veracrypt/trunk/1.25.9/+download/veracrypt-console-1.25.9-Debian-10-arm64.deb\n# Amd / Intel version\nwget https://launchpad.net/veracrypt/trunk/1.25.9/+download/veracrypt-console-1.25.9-Ubuntu-22.04-amd64.deb\n```\n\n맥OS의 경우 GUI 버전을 설치하고 명령줄 호출을 위한 별칭을 추가하세요. 아래 내용을 참고해주세요 ⤵️\n\n```js\necho \"alias veracrypt='/Applications/VeraCrypt.app/Contents/MacOS/VeraCrypt --text'\" >> ~/.zshrc\nsource ~/.zshrc\n```\n\n<div class=\"content-ad\"></div>\n\n# 암호화된 볼륨 생성하기 (데이터를 담는 그릇)\n\n우선, 여기서 볼륨이란 무엇인가요? 그저 암호화된 형식으로 모든 데이터를 포함하는 파일(일반적으로 50GB 이상이며 필요에 따라 다르겠지요)입니다.\n\n암호화된 파일에 접근하거나 새로운 파일을 추가하려면 해당 볼륨을 폴더에 마운트해야 합니다. 그렇게 하면 모든 데이터가 자동으로 복호화되어 일반적인 PC 폴더처럼 작업할 수 있습니다.\n\n```js\n# 100 기가바이트 크기의 볼륨 생성 및 \n# 현재 폴더에 my_100gb_secured라는 파일명으로 저장\nveracrypt --text --create my_100gb_secured --size 100G --encryption AES --hash SHA-256 --random-source /dev/random --pim 0 --volume-type normal --keyfiles=\"\" --filesystem exfat \n# 볼륨에 대한 암호를 입력하라는 메시지가 나타납니다...\n```\n\n<div class=\"content-ad\"></div>\n\n이 명령을 조각조각 나눠보겠습니다:\n\n- --text — 터미널에서 창이 뜨지 않고 텍스트 모드로 실행하고 싶습니다.\n- --create my_100gb_secured — my_100gb_secured라는 이름의 볼륨(파일)을 생성합니다.\n- --size 100G — 데이터를 저장할 용량으로 100G이 필요하다고 알려줍니다. 따라서 볼륨 파일도 100G의 크기가 될 것입니다. 하드 드라이브에 충분한 공간이 있는지 확인하세요.\n- --encryption AES --hash SHA-256 — 암호화 유형은 AES입니다(비밀번호를 사용하여 데이터를 암호화하기 위해 암호학에서 널리 사용되는 알고리즘입니다). SHA-256은 흔히 사용되는 해싱 함수 이름이며 SHA-512를 선택할 수도 있지만 더 느리게 작동합니다.\n- --random-source /dev/random — 암호화를 개선하기 위한 임의의 기호입니다. 이 명령에서 --random-source /dev/random 부분을 제거하면 Vera Crypt는 키보드로 임의의 기호를 입력하도록 강요할 것입니다.\n- --pim 0 — 이 값은 해싱 함수에 의해 사용되는 반복 횟수를 증가시킵니다. 이는 보안을 높일 수 있지만 마운트 시간이 길어지는 대가로 이루어집니다. 0은 기본 권장 값을 사용한다는 것을 의미합니다.\n- --volume-type normal — 전통적인 파일 기반의 볼륨입니다. 숨겨진 볼륨 모드도 있지만 이 글에서 다루지 않겠습니다. 숨겨진 옵션을 사용하면 명시적인 파일 작성 없이 하드 드라이브의 일부를 암호화할 수 있습니다. 그러나 클라우드나 로컬 장치와 작업할 때는 단순히 이동하거나 삭제할 수 있는 평범한 파일로서의 볼륨으로 작업하는 것이 훨씬 쉽고 명확합니다.\n- --keyfiles=\"\" — 추가적인 보안층으로, 비밀번호를 해제할 때 키 파일이 필요하게 지정할 수 있습니다. 그러나 여기서는 필요하지 않고 비밀번호만으로 의존할 것입니다.\n- --filesystem exfat — 중요한 부분으로 이 곳에서 볼륨을위한 파일 시스템을 지정해야하기 때문에 현명한 선택을 해야합니다. 가능한 값들은 다음과 같습니다…\n\n![이미지](/assets/img/2024-06-23-EncryptYourDataAnytimeandAnywherewithVeraCrypt_1.png)\n\n## 파일 시스템 선택\n\n<div class=\"content-ad\"></div>\n\nfat32은 호환성이 좋고 모든 운영 체제에서 기본 지원되는 파일 시스템입니다. 이는 휴대폰과 카메라의 SD 및 microSD 카드에 사용되는 동일한 파일 시스템입니다. 단점은 fat32의 각 파일의 최대 크기가 4GB로 제한된다는 것입니다.\n\nexfat은 좋고 호환성이 좋은 파일 시스템으로, 파일 크기 제한이 없으며 대용량의 SD 및 microSD 카드에도 사용됩니다. 단점은 Docker 환경에서 일부 드물게 지원되지 않는 경우가 있다는 것입니다.\n\nNTFS는 macOS에서 지원되지 않는 유일한 단점이 있지만, 뛰어난 파일 시스템입니다.\n\n다른 옵션들도 있지만 특정 운영 체제에 특화되어 있으므로 macOS와 얼마나 자주 작업하는지에 따라 exfat과 NTFS 중 선택하는 것이 좋습니다. Windows 및 Linux가 기본 장치인 경우 NTFS가 좋은 선택이 될 수 있습니다. 확실하지 않고 가능한 한 유연하게 사용하고 싶다면 exfat을 선택하는 것이 좋습니다.\n\n<div class=\"content-ad\"></div>\n\n암호화된 볼륨을 마운트하기\n\n우리의 볼륨을 사용하려면 폴더에 마운트해야 합니다.\n\n```js\n# 마운팅에 사용할 디렉토리 생성\nmkdir ~/my_100gb_directory\n```\n\n```js\n# 현재 폴더에 있는 my_100gb_secured 파일을 my_100gb_directory로 마운트\nveracrypt --text --mount --keyfiles=\"\" --pim 0 my_100gb_secured ~/my_100gb_directory\n```\n\n<div class=\"content-ad\"></div>\n\n폴더를 건너뛰고 VeraCrypt가 볼륨을 하드 드라이브로 마운트합니다 (폴더에 마운트하는 것이 작동하지 않으면, 특히 macOS에서 일부 ~/my_100gb_directory를 제외하고 다시 시도해보세요)\n\n![이미지](/assets/img/2024-06-23-EncryptYourDataAnytimeandAnywherewithVeraCrypt_2.png)\n\n# 비밀 상자를 분리하세요\n\n작업을 마친 후 — 모든 마운트된 볼륨을 비활성화하려면 다음을 입력하세요:\n\n<div class=\"content-ad\"></div>\n\n```bash\r\nveracrypt -d\r\n```\r\n\r\n![VeraCrypt](/assets/img/2024-06-23-EncryptYourDataAnytimeandAnywherewithVeraCrypt_3.png)\r\n\r\n여기까지입니다. 이제 VeraCrypt를 사용하여 암호화된 볼륨을 생성하고 관리하여 민감한 데이터를 안전하게 저장하는 방법을 배웠습니다.\r\n\r\n보너스로, 필요할 경우에 대비해 몇 가지 더 많은 VeraCrypt 명령어 플래그를 여기에 나열해두었습니다:\n\n<div class=\"content-ad\"></div>\n\n테이블 태그를 마크다운 형식으로 변경해주세요.","ogImage":{"url":"/assets/img/2024-06-23-EncryptYourDataAnytimeandAnywherewithVeraCrypt_0.png"},"coverImage":"/assets/img/2024-06-23-EncryptYourDataAnytimeandAnywherewithVeraCrypt_0.png","tag":["Tech"],"readingTime":5},{"title":"DevOps 엔지니어를 위한 기본적인 리눅스 쉘 스크립팅 Day 4","description":"","date":"2024-06-23 15:28","slug":"2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4","content":"\n\n안녕하세요 여러분!\n이전 토론에서는 AWS에서 데브옵스 엔지니어를 위한 Linux를 다루었습니다. 아직 확인하지 않으셨다면 [여기]에서 확인해보세요.\n\n오늘은 Linux 셸 스크립팅에 대해 알아볼 것입니다. 지금은 SSH를 사용하여 내 로컬 머신에서 원격으로 AWS의 Ubuntu Linux 서버(프리티어)에 접속하고 있습니다. Secure Shell Protocol (SSH)을 통해 원격 Linux 서버에 안전하게 접속하고 관리할 수 있습니다.\n\n## 데브옵스를 위한 셸 스크립팅이란?\n\n데브옵스를 위한 셸 스크립팅은 Bash (Bourne Again Shell) 또는 다른 호환되는 셸과 같은 셸 언어를 사용하여 개발 및 운영과 관련된 작업을 자동화하는 스크립트를 작성하는 것을 말합니다. 이러한 작업은 시스템 구성 및 관리부터 배포 및 모니터링 프로세스까지 데브옵스 환경에서 가능합니다.\n\n<div class=\"content-ad\"></div>\n\n## #!/bin/bash은 무엇인가요?\n\n#!/bin/bash은 셰뱅 또는 해시뱅 라인이라고 불립니다. 이는 스크립트의 시작 부분에 사용되며 스크립트를 실행하기 위해 사용되어야 하는 해석기를 지정하는 데 사용됩니다. 이 경우, #!/bin/bash은 스크립트가 Bash 쉘에 의해 해석되어야 함을 나타냅니다. 네, #!/bin/sh를 작성하여 시스템의 기본 쉘에 의해 (Bash 또는 Bourne 쉘과 호환되는 다른 쉘일 수도 있음) 스크립트가 해석되도록 할 수도 있습니다.\n\n# Day 4-Task: Linux Shell Scripting:-\n\n오늘은 AWS Ubuntu Linux 서버에서 실행된 명령어 몇 가지를 살펴보겠습니다. 여기에 몇 가지 예시가 있습니다:\n\n<div class=\"content-ad\"></div>\n\n## 메시지 출력:\n\n간단한 셸 스크립트입니다. \"내가 #90DaysOfDevOps 챌린지를 완료할 것이다\"를 출력합니다.\n\n```js\n#!/bin/bash\necho \"I will complete #90DaysOfDevOps challenge\"\n```\n\n예시\n\n<div class=\"content-ad\"></div>\n\n\n![이미지1](/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_0.png)\n\n![이미지2](/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_1.png)\n\n## 사용자 입력 및 인수\n\n사용자 입력과 인수를 활용하여 Shell Script를 작성하고 변수를 출력합니다.\n\n\n<div class=\"content-ad\"></div>\n\n```bash\n#!/bin/bash\n# 이것은 셰뱅 라인입니다. 시스템에 이 스크립트를 해석할 때 Bash 쉘을 사용하라는 것을 나타냅니다.\n\necho \"나는 #90DaysOfDevOps 챌린지를 완료할 것입니다.\"\n\n# 변수:\nname=\"Araiz\"\necho \"안녕하세요 ${name}, 나이를 입력해 주세요.\"\n\n# 사용자 입력 받기:\nread age\necho \"나의 나이는 ${age}세 입니다.\"\n\n# 첫 번째 인자 전달($1):\necho \"안녕하세요, 저는 $1입니다.\"\n```\n\n예시\n\n![image1](/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_2.png)\n\n![image2](/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n## If-Else Example\n\n두 숫자를 비교하여 쉘 스크립팅에서 If else 예제를 작성해보세요.\n\n```js\n#!/bin/bash\n\nnum1=5\nnum2=10\n\nif [ $num1 -gt $num2 ]; then\n    echo \"$num1가 $num2보다 큽니다\"\nelif [ $num1 -lt $num2 ]; then\n    echo \"$num1가 $num2보다 작습니다\"\nelse\n    echo \"$num1와 $num2는 같습니다\"\nfi\n```\n\n예제\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_4.png)\n\n![Image 2](/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_5.png)\n","ogImage":{"url":"/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_0.png"},"coverImage":"/assets/img/2024-06-23-BasicLinuxShellScriptingforDevOpsEngineersDay4_0.png","tag":["Tech"],"readingTime":3},{"title":"Hack The Box - Responder 초반 해결 방법","description":"","date":"2024-06-23 15:27","slug":"2024-06-23-HackTheBoxStartingPointResponderSolution","content":"\n\n\n![image](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_0.png)\n\nResponder는 Hack The Box 플랫폼의 Starting Point 시리즈에서 Tier 1 중 4번째 머신입니다. 랩 중에는 Penetration Testing 능력을 향상시키기 위해 일부 중요하고 최신 도구들을 활용했습니다. 이 중에는 Responder, John the Ripper 및 evil-winrm이 있습니다.\n\n하나의 머신을 더 pwed해 봅시다!\n\nTASK 1 — IP 주소를 사용하여 웹 서비스를 방문할 때, 우리가 리디렉트되는 도메인은 무엇입니까?\n\n\n<div class=\"content-ad\"></div>\n\n웹 브라우저를 통해 IP 주소에 액세스하려고 하면 unika.htb로 리디렉션되지만 연결이 성공하지 않을 것입니다.\n\n\n![image1](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_1.png)\n\n\n웹 페이지를 보려면 대상 IP를 /etc/hosts 파일에 추가해야 합니다. 그런 다음 터미널에서 텍스트 파일 편집기를 열고 페이지의 호스트 이름과 IP 주소를 입력하십시오.\n\n\n![image2](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n아래는 Markdown 형식의 텍스트입니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_3.png)\n\n웹 브라우저에서 페이지가 불러와집니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_4.png)\n\nTASK 2 — 서버에서 웹페이지를 생성하는데 사용된 스크립팅 언어는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\nNmap 스캔을 실행하여 사용 가능한 포트 목록을 생성 중입니다. 결과에 따르면, 웹 서비스용 포트 80이 활성화되어 있으며 서비스에 대한 세부 정보가 제공되었습니다. 또한, 아파치가 PHP를 사용하여 웹 페이지를 생성하고 있다고 언급했습니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_5.png)\n\n작업 3 - 웹페이지의 다른 언어 버전을로드하는 데 사용되는 URL 매개 변수 이름은 무엇입니까?\n\n다른 언어로 전환하려면 페이지 매개 변수를 사용합니다. 언어가 변경되면 주소 표시줄의 URL이 변경되는 것을 확인할 수 있습니다. 아래 예시를 참고하세요.\n\n<div class=\"content-ad\"></div>\n\n![2024-06-23-HackTheBoxStartingPointResponderSolution_6.png](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_6.png)\n\n### TASK 4 — 다음 `page` 매개변수 값 중 로컬 파일 포함(LFI) 취약점을 악용할 수 있는 예시는 무엇인가요?: “french.html,” “//10.10.14.6/somefile”, “../../../../../../../../windows/system32/drivers/etc/hosts”, “minikatz.exe”\n\n로컬 파일 포함 취약점을 악용하려면 ../../../../../../../../windows/system32/drivers/etc/hosts와 같은 매개변수를 사용해야 합니다. \" ../ /\"을 이용하면 \"etc/hosts\"에 액세스할 수 있습니다.\n\n![2024-06-23-HackTheBoxStartingPointResponderSolution_7.png](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_7.png)\n\n<div class=\"content-ad\"></div>\n\n**TASK 5** — `page` 매개변수에 다음 중 어떤 값이 원격 파일 포함(Remote File Include, RFI) 취약점을 악용한 예시인가요: “french.html,” “//10.10.14.6/somefile”, “../../../../../../../../windows/system32/drivers/etc/hosts”, “minikatz.exe”?\n\n원격 파일 포함을 악용하기 위해서는 대상 기계의 IP 주소를 가져야 하며, 이 경우에는 //10.10.14.6/somefile이 있어야 합니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_8.png)\n\n**TASK 6** — NTLM은 무엇의 약자인가요?\n\n<div class=\"content-ad\"></div>\n\nNTLM은 Microsoft Windows를 위해 설계된 보안 프로토콜 그룹인 New Technology LAN Manager의 약자입니다. NTLM은 클라이언트 및 서버를 인증하기 위해 도전-응답 메커니즘을 사용합니다. 그러나 현재의 응용 프로그램에서는 암호화 부족 때문에 NTLM 사용을 권장하지 않습니다.\n\nTASK 7 — Responder 유틸리티에서 네트워크 인터페이스를 지정하는 데 사용하는 플래그는 무엇인가요?\n\nResponder는 네트워킹 인터페이스를 지정하기 위해 -I로 표시된 플래그를 사용하며 인터페이스 이름이 이어집니다.\n\n![Resonder Flag](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_9.png)\n\n<div class=\"content-ad\"></div>\n\n먼저, \"ip a |grep + 네트워크 인터페이스\" 명령어를 사용하여 IP를 확인하세요.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_10.png)\n\nResponder가 제대로 작동하는지 확인하기 위해 Responder가 이벤트를 잡았는지 확인할 수 있습니다. 이를 위해 IP와 공유 폴더 이름을 사용하여 웹 브라우저에서 공유 파일을 열어보세요. 그러나 이 작업은 폴더가 사용 가능하고 권한이 필요하기 때문에 거부될 가능성이 높습니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_11.png)\n\n<div class=\"content-ad\"></div>\n\nResponder가 작동 중인 터미널에서 NTLM 정보에는 클라이언트의 IP, 사용자 이름 및 암호 해시가 포함되어 있습니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_12.png)\n\n태스크 8 - NetNTLMv2 챌린지/응답을 이용하여 수백만 개의 암호를 시도하여 같은 응답을 생성하는지 확인하는 여러 도구들이 있습니다. 이러한 도구 중 하나는 종종 `john`이라고 불리지만, 전체 이름은 무엇인가요?\n\n암호 해독 도구 John의 전체 이름은 John the Ripper입니다. 이 랩에서 사용자 암호를 찾는 데 곧 사용될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n해시를 복사한 후 \"echo\" 명령어를 사용하여 파일로 전송하세요. 그런 다음 \"ls\" 명령어를 사용하여 디렉터리를 확인하여 파일이 저장되었는지 확인하세요.\n\n![image](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_13.png)\n\n다음으로 \"RockYou\" 워드리스트 파일을 압축 해제하는 단계를 따르세요.\n\n![image](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_14.png)\n\n<div class=\"content-ad\"></div>\n\n\"john\" 명령을 사용하여 워드리스트를 실행하고 해당 패스워드 해시 파일과 일치시켰어요.\n\n\n![image](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_15.png)\n\n\n할일 9 — 관리자 사용자의 비밀번호는 뭔가요?\n\n1단계에서 착안한 단계별 지시 사항을 통해 관리자 사용자의 비밀번호는 \"badminton\"이에요.\n\n<div class=\"content-ad\"></div>\n\n**TASK 10** — 윈도우 서비스(즉, 상자에서 실행 중인)를 사용하여 복구한 비밀번호를 사용하여 Responder 머신에 원격으로 액세스할 것입니다. 이 서비스가 청취하는 TCP 포트는 무엇인가요?\n\n이 TCP 포트는 5985이며, Nmap으로 스캔하면 쉽게 정보를 얻을 수 있습니다.\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_16.png)\n\n**플래그 제출**\n\n<div class=\"content-ad\"></div>\n\n악성-winrm을 활용하여 플래그 사냥을 진행해봅시다. 해당 패키지에는 대상 컴퓨터에 액세스하기 위한 Windows 원격 관리가 포함되어 있습니다. 마침내 IP 주소, 사용자 이름 및 비밀번호를 포함한 모든 필요한 정보를 모았습니다.\n\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_17.png)\n\n\n디렉터리 및 폴더 간 이동에는 \"cd\" 명령을 사용할 수 있으며, 폴더 내용은 \"dir\"을 사용하여 나열할 수 있습니다. 사용자 Mike에게 숨겨진 플래그가 있습니다.\n\n\n![이미지](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_18.png)\n\n\n<div class=\"content-ad\"></div>\n\n깃발을 확인하려면 \"type\" 명령어를 사용하세요.\n\n![flag1](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_19.png)\n\n![flag2](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_20.png)\n\n제공된 이미지의 모든 작업에 대한 답안을 가지고 있어요. Pweding Responder 머신은 정말 재미있는 경험이었습니다!\n\n<div class=\"content-ad\"></div>\n\n\n![HackTheBoxStartingPointResponderSolution_21.png](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_21.png)\n\n![HackTheBoxStartingPointResponderSolution_22.png](/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_22.png)\n","ogImage":{"url":"/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_0.png"},"coverImage":"/assets/img/2024-06-23-HackTheBoxStartingPointResponderSolution_0.png","tag":["Tech"],"readingTime":6}],"page":"23","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}