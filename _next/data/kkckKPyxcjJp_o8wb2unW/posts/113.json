{"pageProps":{"posts":[{"title":"맥OS 공격 매트릭스 IOPlatformExpertDevice를 사용하여 시스템 정보 수집하기 파트  2","description":"","date":"2024-05-27 12:24","slug":"2024-05-27-MacOSAttackMatrixGatheringSystemInformationusingIOPlatformExpertDevicePart2","content":"\n\n![Screenshot](/assets/img/2024-05-27-MacOSAttackMatrixGatheringSystemInformationusingIOPlatformExpertDevicePart2_0.png)\n\nmacOS 시스템의 복잡한 미로를 헤쳐 나가는 레드팀 오퍼레이터들은 현대의 디지털 탐험가로, 가치 있는 데이터를 찾기 위해 모든 구석구석을 탐색합니다. 그들의 사용 가능한 도구 가운데, ioreg 명령어는 어두운 방에서 플래시라이트처럼 반짝이며, 정확하고 명확한 방법으로 기기 하드웨어의 숨겨진 세부 정보를 밝혀내줍니다.\n\n# ioreg 명령어 마스터하기\n\nmacOS 시스템 진단의 핵심에는 ioreg 명령어가 있습니다. 이 명령어는 I/O Kit 레지스트리의 광대하고 상세한 세계를 해제하는 열쇠 역할을 합니다. 이 레지스트리는 macOS 시스템에 연결된 모든 장치의 정보를 카탈로그화한 대규모 도서관 역할을 합니다.\n\n\n<div class=\"content-ad\"></div>\n\n`ioreg` 명령을 효과적으로 다루는 방법을 이해하는 것은 고고학자가 발굴 작업을 위해 적절한 도구를 선택하는 것과 유사합니다. 가장 자세한 통찰을 끄집어내기 위해 설정하는 방법은 다음과 같습니다:\n\n```js\nioreg -c IOPlatformExpertDevice -d 2\n```\n\n## 데이터 미로를 탐색하기 위한 필수 플래그\n\n- `ioreg`: 하드웨어 레지스트리의 심층을 탐색하는 것을 시작합니다.\n- `-c 클래스`: 특정 클래스의 장치를 대상으로 지정합니다. 방대한 도서관에서 특정 장르를 선택하는 것과 유사합니다. 깊은 시스템 통찰을 얻기 위해 IOPlatformExpertDevice를 찾아보세요.\n- `-d 깊이`: 장치 트리를 얼마나 깊게 파고들지 설정하며, 깊이 2로 설정하면 통찰을 얻을 정도로 충분하지만 압도적이지는 않습니다.\n- `-l`: 장치의 모든 가능한 세부 정보를 펼쳐서 속성의 매우 상세한 내러티브를 제공합니다.\n- `-r`: 하드웨어 트리의 관련 가지에 대해 검색을 집중시켜 불필요한 혼란을 피합니다.\n\n<div class=\"content-ad\"></div>\n\n# 예시 및 샘플 출력 설명\n\n가장 기본적인 명령어를 실행할 때 예상할 수 있는 샘플 출력은 다음과 같습니다:\n\n```js\n+-o IOPlatformExpertDevice <class IOPlatformExpertDevice, id 0x100000000,\nregistered, matched, active, busy 0 (0 ms), retain 10>\n{\n  \"IOPlatformUUID\" = \"12345678-1234-1234-1234567890AB\"\n  \"model\" = <\"MacBookPro15,1\">\n  \"serial-number\" = <\"C02XXXXXXXD1\">\n  \"IOPlatfomSerialNumber\" = \"C02XXXXXXXD1\"\n  ...\n}\n```\n\n이 명령어를 실행하면 IOPlatformExpertDevice에 대한 자세한 정보가 나타나며, 중요하고 종종 숨겨진 속성을 강조해 줍니다.\n\n<div class=\"content-ad\"></div>\n\n- IOPlatformUUID: 시스템을 고유하게 식별하는 디지털 지문 역할을 합니다.\n- Model: Mac의 청사진을 공개하여 특정 취약점을 정확히 파악하는 데 중요합니다.\n- Serial-Number: 기기의 새겨진 서명으로, 추적 및 인증에 중요합니다.\n- IOPlatformSerialNumber: 특수 하드웨어 확인에 사용되는 식별의 보조 기호입니다.\n- IOPlatformExpert: 하드웨어 구성 뒤에 숨은 설계자의 이름을 밝혀, 사용자 정의 설정을 알려줍니다.\n\n# Red Team 작전에서의 실제 시나리오\n\nioreg 명령어를 이용해 레드 팀은 디지털 자물쇠 제작자로 변신할 수 있습니다. 이를 통해 하드웨어 비밀을 밝히고, 시스템의 방어 메커니즘을 우회하거나 악용하는 키를 만들어낼 수 있습니다.\n\n- 대상 프로파일링: 대상 시스템의 특정 아키텍처에 대한 공격을 정밀하게 튜닝하는 것은 특수한 정교한 수트를 만드는 것과 같습니다.\n- 자산 무결성 확인: 하드웨어가 변조되지 않았는지 확인하는 것은 금고 속 금의 순도를 확인하는 것과 유사합니다.\n- 사용자 정의 악용 개발: 일부 악용은 시스템 하드웨어의 정확한 형태가 필요한데, 이는 자물쇠 디자인을 기반으로 열쇠를 만들어내는 것과 유사합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-05-27-MacOSAttackMatrixGatheringSystemInformationusingIOPlatformExpertDevicePart2_1.png)\n\n# 빠른 참조용 치트 시트\n\n- 명령 개요: ioreg -c IOPlatformExpertDevice -d 2: 시스템 하드웨어의 영혼에 대한 손전등.\n- 주요 플래그:\n  -c: 검사할 장치의 클래스를 선택합니다.\n  -d: 탐사 깊이를 설정합니다.\n  -l: 각 장치에 대한 상세 설명을 제공합니다.\n  -r: 초점을 선명하고 관련성 있게 유지합니다.\n- 중요한 출력물:\n  IOPlatformUUID: 고유 식별자.\n  Model: 장치 모델에 대한 세부 정보.\n  SerialNumber: 장치 일련 번호에 대한 정보.\n  IOPlatformSerialNumber: 점검 및 균형을 위해 필수적입니다.\n  IOPlatformExpert: 장치 구성 전문가에 대한 통찰.\n\n# 결론\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-05-27-MacOSAttackMatrixGatheringSystemInformationusingIOPlatformExpertDevicePart2_2.png)\n\nThe `ioreg` command is not just a tool; it's a gateway to the hidden chambers of macOS hardware information. For security professionals, mastering this command is akin to mastering the art of map-making, charting unknown territories, and uncovering secrets that lie beneath the surface of every macOS device.\n\n","ogImage":{"url":"/assets/img/2024-05-27-MacOSAttackMatrixGatheringSystemInformationusingIOPlatformExpertDevicePart2_0.png"},"coverImage":"/assets/img/2024-05-27-MacOSAttackMatrixGatheringSystemInformationusingIOPlatformExpertDevicePart2_0.png","tag":["Tech"],"readingTime":4},{"title":"화면 녹화를 GIF로 변환하는 방법 macOS에서  생산성 1","description":"","date":"2024-05-27 12:23","slug":"2024-05-27-HowtoconvertyourscreenrecordingstoGIFonmacOSProductivity1","content":"\n프론트엔드 개발자로서, Pull/Merge Requests, 이슈 또는 Slack에서 종종 스크린샷이나 비디오 녹화를 공유해야 할 때가 많습니다.\n\n그리고 Bitbucket과 같은 플랫폼은 이미지만 받아들이고 비디오는 받아들이지 않기 때문에 GIF가 좋은 대안이 될 수 있습니다.\n\n그래서 저는 최근에 비디오 화면 녹화를 GIF로 쉽게 변환하는 도구를 만들었습니다. 이 도구는 빠르게 작동하며 Bitbucket에서 허용되는 크기의 작은 GIF를 생성하면서도 고해상도를 유지합니다.\n\n결과물을 직접 확인해 보세요:\n\n<div class=\"content-ad\"></div>\n\n\n![image](https://miro.medium.com/v2/resize:fit:1400/1*m8Y5EaajsmCXSZuswBiHCw.gif)\n\n# 설치\n\n라이브러리를 몇 개만 설치하면 됩니다:\n\n```js\nbrew install ffmpeg imagemagick\n# 만약 macOS 실리콘을 사용 중이라면\narch -arm64 brew install ffmpeg imagemagick\n```\n\n<div class=\"content-ad\"></div>\n\n그럼 해당 Apple 바로 가기를 설치해주세요: [https://www.icloud.com/shortcuts/ec417cfcb32941f7aa9316b3c44c32ff](https://www.icloud.com/shortcuts/ec417cfcb32941f7aa9316b3c44c32ff)\n\n# 즐기세요!\n\nmacOS에서는 CMD+Shift+5를 사용하여 화면을 쉽게 녹화할 수 있어요.\n\n화면을 녹화하고 .MOV 비디오를 가지고 있다면, Finder의 컨텍스트 메뉴를 사용하여 GIF로 바꿀 수 있어요:\n\n<div class=\"content-ad\"></div>\n\n<div>\n  <img src=\"/assets/img/2024-05-27-HowtoconvertyourscreenrecordingstoGIFonmacOSProductivity1_0.png\" />\n</div>\n\n배시 스크립트에서 GIF로 변환하는 옵션이 있습니다.\n\n자세한 내용은 여기에서 확인하실 수 있습니다: [https://github.com/friedrith/productivity/blob/master/convert-video-to-gif.md](https://github.com/friedrith/productivity/blob/master/convert-video-to-gif.md)\n\n만약 이 도구가 유용하다고 생각된다면, 이 저장소에 스타를 부탁드리거나 이 게시물 아래에 댓글을 남겨주세요.\n\n<div class=\"content-ad\"></div>\n\n![image](https://miro.medium.com/v2/0*n3UdPtw5l6xSikMW.gif)\n\n안녕하세요! 제 이름은 티볼트이고, Ux 엔지니어로 일하고 있습니다. Ux, 코드 기술, 생산성, 과학 소설 등에 열정을 가지고 있습니다. 매달 새로운 기사를 게시하고 있어요. 이런 주제에 관심이 있다면, 제 Medium 페이지를 팔로우해주세요: https://medium.com/@thibault-friedrich.\n","ogImage":{"url":"/assets/img/2024-05-27-HowtoconvertyourscreenrecordingstoGIFonmacOSProductivity1_0.png"},"coverImage":"/assets/img/2024-05-27-HowtoconvertyourscreenrecordingstoGIFonmacOSProductivity1_0.png","tag":["Tech"],"readingTime":2},{"title":"이상한 선택과 큰 숫자 어제 애플이 무엇을 했는지","description":"","date":"2024-05-27 12:22","slug":"2024-05-27-WeirdChoicesandBigNumbersWhatAppleGotuptoYesterday","content":"\n\n아래의 표 태그를 마크다운 형식으로 변경해주세요.\n\n<div class=\"content-ad\"></div>\n\n애플이 하는 일입니다. 다음 이벤트에서 몇 개의 제품을 발표할지를 고민하며 앉아 있는 동안, 그들은 실제로 발표할 두 개나 세 개의 제품을 준비하고 있습니다.\n\n나머지는 모두 기다릴 수 있어요 - 심지어 그게 계획 안에 있는 것이라면 말이죠.\n\n어제는 맥 이벤트가 될 것이라는 것은 이미 예상됐어요. 미안해요.\n\n어제의 급속한 이벤트에서 이 방식은 새로운 세 개의 칩, 새로운 맥북 프로, 마침내 업데이트된 24인치 아이맥을 가져왔습니다. 아, 그리고 전체적으로 어젠트의 가장 인상적인 것 중 하나인 아이폰으로 촬영된 쇼도 있었습니다.\n\n<div class=\"content-ad\"></div>\n\n지난 몇 주 동안 풀어야 할 것이 많지만, 새로운 M3 칩과 그 안에 들어간 기계에 대한 내 초기 생각은 다음과 같아요.\n\n## 인텔 팬들\n\n어제, 내가 가장 좋아하는 커피숍 중 한 군데에서 빛나는 Apple 로고가 두 개가 아닌 한 개만 보았던 것을 분명히 기억해요.\n\n저는 이것을 좋아해요; 사람들이 가능한 한 오랫동안 자신의 맥을 유지하는 것을 좋아해요. 제가 이것을 직업으로 하고 있지 않았더라면, 제가도 똑같이 할 것 같아요. 맥은 끝이 다소 끝날 때까지 많이 지지 않을까요. 게다가 맥은 천문학적으로 비싸요. 그들은 또한 몇 년 동안 그대로 남아 있고, 일반적으로, 윈도우 기반 경쟁 상품을 훨씬 뛰어넘어요. 실제로 내 비디오의 댓글 섹션에 들어오는 대부분의 사람들은 그들의 인텔 맥을 애플의 자체 칩이 돌아가는 것으로 업그레이드해야 하는지 여부를 물었어요. 어젯밤의 라이브스트림에서 누군가가 2009년식 맥 프로를 아직 사용 중이라고 알려줬어요. 놀라워요.\n\n<div class=\"content-ad\"></div>\n\n애플은 이에 대해 과도하게 알고 있습니다; 공식 숫자는 찾을 수 없었지만 트위터에서는 설치된 맥의 50% 이상이 아직도 인텔 기계를 사용하고 있다는 이야기가 나왔습니다.\n\n제가 주로 보는 커피숍에서의 경험을 고려하면, 이것은 전혀 놀라운 일이 아닙니다. 그것이 어제 저녁에 애플이 계속해서 인텔 맥 사용자들을 언급한 이유도 설명해 주죠.\n\n\"M3 맥으로 업그레이드하는 것을 진지하게 고려해야 합니다.\" 계속 그렇게 말하더라구요. 부디.\n\n애플이 직면한 과제는 인텔 맥이 여전히 그 사람들에게 유용하게 사용되고 있으며, 새 맥 하드웨어의 천문학적인 가격 때문에 업그레이드를 요청하는 것이 매우 어려운 부분입니다. (나중에 그것에 대해서 이야기하겠습니다.)\n\n<div class=\"content-ad\"></div>\n\n나는 당신이 인텔 Mac 사용자인 경우 M3에 유혹을 받나요? 아래에서 참여해주세요!\n\n## 13인치 MacBook Pro와 Touch Bar, 안녕\n\n어젯밤, 우리는 마침내 13인치 MacBook Pro와 Touch Bar에 작별 인사를 했어요.\n\n더 이상 애플 웹사이트에 없어요. 없어져 버렸어요. 역사책에 넣었어요. 완전히 끝났어요.\n\n<div class=\"content-ad\"></div>\n\n좋은 소식이 있어요.\n\n그 자리를 대신해 새로운 14인치 M3 MacBook Pro 변형이 출시되었어요. 그 전 13인치 버전보다 $100 저렴한 가격에 8코어 CPU, 10코어 GPU, 8GB의 통합 메모리, 그리고 512GB SSD가 탑재되어 있어요. 또한 ProMotion 장착된 Liquid Retina 디스플레이를 갖추고 있는데, 이는 이전 베이스 모델 MacBook Pro보다 상당한 업그레이드예요.\n\n그 메모리 선택에 대한 우려는 제쳐두고, 3나노미터 기반 MacBook Pro의 시작 가격이 £1,699/$1,599 정도라니 꽤 괜찮은 가격이죠. 제 생각에는 13인치 버전만큼 인기가 많을거야, 아니면 그 이상의 인기를 끌지도 몰라요.\n\n## 이상한 선택들\n\n<div class=\"content-ad\"></div>\n\n팀과 사람들한테 정말 이상한 선택지 없이 Apple 이벤트는 없을거에요, 맞죠?\n\n어젠 그랬어요. 전혀 실망시키지 않았죠.\n\n크게는 중요하지 않을 수도 있는 작은 디테일이 있었어요. 예를 들어, 기본 사양인 M3 Pro는 M2 Pro 버전보다 GPU 코어가 두 개 더 적고, 업그레이드된 M3 Pro는 GPU 코어가 하나 더 적었어요.\n\n그리고 더 크고 머리 아픈 일들도 있었죠. 우리는 새로운 MacBook Pro와 업그레이드된 24인치 iMac을 갖고 있지만, Mac mini, Mac Studio, MacBook Air, 그리고 Mac Pro는 여전히 M2 플랫폼을 사용하고 있어요.\n\n<div class=\"content-ad\"></div>\n\n언제쯤 업데이트를 받을 거죠, Tim? 지금 그 기계 중 하나를 사는 건 정말 긴장되는 느낌이 들어요.\n\n하지만 애플이 한 가장 크고 이상한 결정 중, 그리고 이번 아침 소셜 미디어에서 모든 관심을 받고 있는 결정은 새로운 iMac에 여전히 Lightning 기반 주변장치를 포함한 것입니다. 맞아요 – Magic Mouse, Magic Trackpad 및 Magic Keyboard는 아직 USB-C 충전을 지원하도록 업데이트되지 않았어요.\n\n음?\n\n## 내가 산 것\n\n<div class=\"content-ad\"></div>\n\n애플 제품 출시 때 가장 짜증나는 일 중 하나는 새 제품이 얼마나 더 비싼지 알려고 할 때인데 (솔직히 말하면 요즘은 대게 그렇죠). 구 버전은 즉시 애플 스토어 웹사이트에서 제거되어, 옛 기억력이 우수하고 기록을 잘 보관한 소수만이 이전 가격을 기억할 수 있는 행운을 누릴 수 있게 됩니다.\n\n나는 단지 4시간의 잠만 자고 깼는데, 솔직히 오늘은 제대로 알아보기 귀찮아요. 하지만 새 MacBook Pro는 명백히 상위 사양 옵션으로 넘어갈수록 더 비싸게 느껴집니다.\n\n어젯밤, 나는 우주 블랙 (당연히) 14인치 MacBook Pro를 주문했어요. M3 Max 칩 (16코어 CPU 및 40코어 GPU)이 완전히 적용된 제품이고, 통합 메모리 48GB와 2TB SSD를 갖췄어요. 그 결과로 나타난 은행 잔고를 탕감시키는 총액은 4,199 파운드예요.\n\n누군가 구급차를 불러주세요.\n\n<div class=\"content-ad\"></div>\n\n그리고, 네, 나는 지금 다른 ￡200을 쓰는 게 좋았을까 생각 중이에요 (결국 몬폴리 머니잖아요)그리고 통합 메모리의 64GB로 업그레이드해야 했을지도 모르겠네요.\n\n어쨌든, 새로운 MacBook Pro가 11월에 내게로 날아올 예정이에요. 제 전체적인 생각은 그 때에 밝히겠죠. 또한, 최신 올인원 iMac 24인치 기본 제원을 주문했어요, 애플의 최신 기술로 900일 이상 어느 정도 발전했는지 살펴볼 겁니다.\n\n어제 이벤트 후에 많은 사람들이 궁금해할 질문은 올해 비싼 M2 기반 MacBook Pro를 구입한 것이 후회되는지 아닌지일 것이에요. 그 플랫폼이 오래 가지 않았군요.\n\n음, 긍정적인 마무리를 지어보죠. 구매한 것에 대해 기분 좋아해야 해요. 솔직히요. 그 이유로 구입했고, 여전히 슈퍼 빠른 머신이잖아요. 누가 알아요, 아마도 10년 후에도 M2를 사용하고 있는 사람으로써 커피숍에서 발견되는 사람이 될 수도 있으니까요!\n\n\n<div class=\"content-ad\"></div>\n\n# 가기 전에\n\n테크 콘텐츠 크리에이터의 주간 비하인드 신간 비디오를 보기 위해 뉴스레터 목록에 가입하세요!\n\n원문은 2023년 10월 31일에 https://markellisreviews.com에서 게시되었습니다.","ogImage":{"url":"/assets/img/2024-05-27-WeirdChoicesandBigNumbersWhatAppleGotuptoYesterday_0.png"},"coverImage":"/assets/img/2024-05-27-WeirdChoicesandBigNumbersWhatAppleGotuptoYesterday_0.png","tag":["Tech"],"readingTime":4},{"title":"맥북 MacOS 키보드 단추로 스플릿 화면 창을 화면 왼쪽 또는 오른쪽으로 정렬","description":"","date":"2024-05-27 12:21","slug":"2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen","content":"\nWindows 운영 체제는 창을 분할 화면으로 이동하는 단축키를 Windows 키 + 왼쪽/오른쪽 화살표를 사용하여 수행할 수 있습니다. MacOS에서는 어떤 창의 전체 화면(녹색) 버튼 위에 마우스 포인터를 가져다 놓고 옵션을 선택하여 이 작업을 수행할 수 있습니다.\n\n![MacOS Keyboard Shortcuts for Split Screen](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_0.png)\n\n그러나 Mac OS에서는 유료 서드 파티 앱을 사용하지 않고는 이에 대한 키보드 단축키를 찾지 못했습니다. 하지만 직접 키보드 단축키를 만들 수 있다는 사실을 알게 되었습니다. 다음은 그 방법입니다:\n\n# 1. 키보드 설정으로 이동하기.\n\n<div class=\"content-ad\"></div>\n\nMac에서는 Apple 메뉴를 선택한 후 `시스템 환경 설정`을 클릭하고, 키보드를 클릭한 다음 가운데에 있는 `키보드 단축키` 탭을 클릭하세요.\n\n![이미지](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_1.png)\n\n![이미지](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_2.png)\n\n## 2. 앱 단축키 추가\n\n<div class=\"content-ad\"></div>\n\n왼쪽의 앱 단축키를 선택한 다음, 추가 버튼 +을 클릭하세요.\n\n![이미지](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_3.png)\n\n# 3. 화면 왼쪽에 타일 창 단축키 추가\n\n애플리케이션: \"모든 애플리케이션\" 유지합니다.\n메뉴 제목: \"화면 왼쪽에 타일 창\"을 입력합니다(모든 애플리케이션의 창 메뉴에있는 메뉴 항목 텍스트이기 때문에 정확히 그렇게 입력해야 합니다).\n키보드 단축키: Control, Command, 왼쪽 화살표 키 조합을 동시에 누릅니다. 아래 스크린샷을 참조하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![img](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_4.png)\n\n(참고: 다른 단축키를 선택할 수 있지만, 우리는 Command, 왼쪽 화살표 조합이 작동하지 않고 Option, Command, 왼쪽 화살표 조합도 Chrome 애플리케이션에서 작동하지 않는다는 것을 발견했습니다. 또한 시프트를 사용하지 마십시오. 그렇게 하면 창 타일링 효과가 슬로우 모션으로 발생합니다.)\n\n지금 이렇게 되어 있어야 합니다:\n\n![img](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_5.png)\n\n\n<div class=\"content-ad\"></div>\n\n# 4. 화면 오른쪽에 타일 창 추가하기 바로 가기\n\n단계 #2와 #3을 다시 반복하세요. 이번에는 Left를 Right로 바꿉니다.  \n애플리케이션: \"모든 애플리케이션\" 유지합니다.  \n메뉴 제목: \"화면 오른쪽에 타일 창\"을 입력하세요 (이는 모든 애플리케이션의 창 메뉴 아래의 메뉴 항목 텍스트이기 때문에 정확히 그대로 입력해야 합니다).  \n키보드 바로 가기: 동시에 Control, Command, 오른쪽 화살표를 누르세요. 스크린샷은 아래에서 확인하세요.\n\n![스크린샷](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_6.png)\n\n(참고: 다른 바로 가기를 선택할 수 있지만, Command, 오른쪽 화살표 조합은 작동하지 않고 Chrome 애플리케이션에 대해서는 Option, Command, 오른쪽 화살표 조합도 작동하지 않는 것으로 확인되었습니다. 또한 Shift 사용을 피하십시오. 왜냐하면 Shift를 사용하면 타일 창 효과가 느리게 재생되기 때문입니다.)\n\n<div class=\"content-ad\"></div>\n\n이렇게 수정해 보세요:\n\n![Image](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_7.png)\n\n## 5. 단축키 테스트\n\nSafari 또는 Chrome과 같은 응용 프로그램을 엽니다. 창 메뉴를 선택합니다. 메뉴 항목에 키보드 단축키가 추가되었는지 확인하면 (\"Title Window to Left of Screen\" 및 \"Tile Window to Right of Screen\"), 단축키가 성공적으로 추가된 것입니다.\n\n<div class=\"content-ad\"></div>\n\n![image](/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_8.png)\n\n이제 한 번 시도해 보세요! Control, Command, 왼쪽/오른쪽 화살표를 누르면 창이 왼쪽이나 오른쪽으로 타일될 것입니다.\n\n축하합니다! 이제 Mac OS 창을 화면 왼쪽이나 오른쪽에 타일하는 키보드 단축키를 성공적으로 추가했습니다.\n\n기술, 비즈니스 및 리더십 관련 팁을 얻으려면 제 팔로우를 해주세요.\n","ogImage":{"url":"/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_0.png"},"coverImage":"/assets/img/2024-05-27-MacbookMacOSKeyboardShortcutsforSplitScreenTileWindowstoLeftorRightofScreen_0.png","tag":["Tech"],"readingTime":3},{"title":"내 첫 번째 홈 서버 만들기","description":"","date":"2024-05-27 12:19","slug":"2024-05-27-Creatingmyfirsthomeserver","content":"\n\n소프트웨어 및 제품 개발자로 일하고 있는데, 최근 몇 달간 컴퓨팅의 하드웨어/인프라 구성 요소에 대해 더 많이 배우고 있어요. 지식이 직접적인 영향을 미치지 않더라도, 일상적인 업무에 굉장히 중요한 컴퓨팅에 대한 일반적인 이해를 가지는 것이 도움이 될 것 같아요.\n\n집에서 예산에 맞는 서버를 만들어보기로 결심했어요.\n\n처음 떠오른 생각은 Raspberry Pi Zero 2 W를 Pi-hole 서버로 사용하는 것이었어요. 기술적으로는 작동했지만, 느리고 번잡스럽고 다른 서비스를 실행하기 힘들었어요. 하나의 서비스를 위해 심지어 Pi Zero만큼 작은 기기를 전용으로 사용하는 것은 말이 되지 않았어요.\n\n그래서 저는 주변에 버려져 있는 고장난 노트북을 살펴보기로 결정했어요. i5가 장착된 오래된 HP 노트북 g5 250이 있었어요. 몇 년 동안 사용하지 않은 이유는 배터리가 고장나고 두 번째 교체 배터리도 망가지고 하드 드라이브도 망가졌기 때문이에요. 그 노트북은 상태가 좋지 않아 보였어요. 하지만 가동시킬 수 있다면, 여러 서비스를 운영할 수 있는 저전력 서버로 완벽하지 않을까 생각했어요. 그래서 수리에 도전했죠!\n\n<div class=\"content-ad\"></div>\n\n# 노트북 수리하기\n\n## 하드 드라이브 교체하기\n\n운 좋게도 주변에 고장난 노트북이 하나 더 있었어요, 에이서 V5 (버리기 아까운 기술 무덤에 살고 있는데요, 죄송해요). 에이서에서 2.5인치 SATA 드라이브를 꺼내 HP 노트북에 꽂았어요. 그러면서 서버 구축에 또 다른 용도를 더할 수 있게 됐어요... 드라이브에서 옛날 영화들을 발견해서 백업하고, 이후 서버 구축에 활용할 거예요 (자세한 내용은 이따가요!)\n\n## 우분투로 윈도우 교체하기\n\n<div class=\"content-ad\"></div>\n\n이것은 조금 논란적인 의견이 될 것 같아요... HP에 꽂은 드라이브에는 Windows 8이 설치되어 있었어요. 저는 Windows 운영 체제(OS)를 업데이트하거나 버전 8을 유지할 수도 있었지만, 나이가 든 하드웨어와 750GB 하드 드라이브만 가진 노트북을 위해 가벼운 OS가 필요했어요. 특히 하드 드라이브 한 개가 저장소와 OS 부팅 모두로 사용된다는 점을 감안하면요. 그래서 리눅스 길을 선택하기로 결정했어요. 리눅스를 사용해 본 적이 없어서 Ubuntu를 선택했어요. 초보자에게 좋은 선택인 것 같았거든요.\n\n과정은 간단했어요. Ubuntu용 ISO 파일을 다운로드하고, Rufus를 사용해 USB 드라이브에 플래시 메모리하고, 그 USB 드라이브를 노트북에 꽂고, 노트북 BIOS로 부팅한 후 OS를 설치했어요.\n\n여러분 중 기술에 능통한 분들은 이미 Ubuntu 서버가 아닌 Ubuntu 데스크탑을 선택한 이유에 궁금해할 수도 있어요. 단순한 답은 저는 처음 시도하는 것이라 GUI를 통해 쉽게 설정하고 유지보수하기 위해서였어요. 예전에 소프트웨어 공학 강의 중 한 교수님으로부터 소중한 약어를 배운 적이 있어요. 그것을 자주 뇌물에 하죠: KISS. Keep it simple, stupid.\n\n<div class=\"content-ad\"></div>\n\n## 배터리를 완전히 제거하는 것\n\n조금 위험한 결정일 수 있지만, 이전에 싸게 구입한 써드 파티 배터리가 잘 안 되었던 경험이 있어서 공식 HP 배터리로 교체하는 것은 이번 빌드에 예산적으로 부담스러웠습니다. 이미 가지고 있는 것을 활용하고 싶었고, 그래서 서버를 계속 24시간 7일 가동할 예정이기 때문에 계속해서 전원을 사용했습니다.\n\n# 서버 설정하기\n\n작은 서버 구성을 연구하던 중 Zima Board라는 제품과 그 GUI 시스템인 CasaOS라는 오픈 소스 소프트웨어를 발견했습니다. 이 소프트웨어는 쉽게 Linux에서 실행할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nCasa는 서버 관리에 대한 완벽한 초보자용 안내서입니다. 노트북 구성이 24/7 전원으로 설정되었으며, Casa를 터미널에 설치했습니다 (추가 정보: 리눅스의 터미널 및 명령어의 편리함은 윈도우즈와 비교할 때 매우 인상적입니다).\n\n처음에 약간의 어려움이 있었는데, Casa의 설치는 끝날 때 사용할 수 있는 IP 주소를 알려줘야 한다고 합니다. 나에게는 터미널에서 이러한 정보가 어떤 이유로든 표시되지 않았지만, 운 좋게도 라우터의 이벤트 로그에서 IP를 찾을 수 있었습니다.\n\n이제 Casa가 내 시스템에 설치되어 실행 중이었고, 내가 다운로드할 앱을 선택하고 다른 것을 연구하기만 하면 됐습니다. Casa는 기본적으로 Docker 컨테이너의 시각화입니다. 이전에 Docker에 대한 기본 경험을 해봤는데, 가벼우면서도 간단하게 서비스를 실행할 수 있는 Docker의 방법을 좋아합니다. Casa는 이를 더 쉽게 만들어줍니다.\n\n![이미지](/assets/img/2024-05-27-Creatingmyfirsthomeserver_1.png)\n\n<div class=\"content-ad\"></div>\n\n저도 Casa의 대시보드가 매끄럽고 초보자 친화적이라는 점을 좋아해요. 그리고 독립된 IP에서 호스팅되어 있어서 집 내 모든 기기에서 대시보드(그에 따라 서버에서 실행 중인 모든 서비스)에 접속할 수 있어요. 시스템을 설정하고 나서, 스마트 TV에서 IP에 접속하여 소파에서 편안하게 나머지 설정을 마쳤어요!\n\n![이미지](/assets/img/2024-05-27-Creatingmyfirsthomeserver_2.png)\n\n## 실행 중인 서비스들\n\n- Pi-hole — 네트워크 전체 광고 차단 프로그램.\n- Jellyfin — 자신의 미디어 파일에 대한 Netflix 스타일 경험을 제공하는 미디어 플레이어. 하드 드라이브에 있던 옛 영화 파일들에 대해 진정한 게임 체인저가 되었어요. 이 서비스를 통해 미디어 서버로 사용할 수 있다는 것에 정말 만족해요.\n- qBittorent — 파일을 토렌트하는 데 사용돼요.\n- Wireguard — VPN 프로토콜이지만 설정에 문제가 있어서 다시 시도해봐야 할 것 같아요.\n\n<div class=\"content-ad\"></div>\n\n## 향후 개선 사항\n\n- 반드시 Wireguard를 재구성하거나 대체할 수 있는 방법을 찾아야 할 것 같아요.\n- 이 기기의 저장 공간을 늘리거나 저장을 위한 별도의 NAS를 구매하는 사이에서 고민 중이에요.\n- Docker의 세계를 더 탐험해보려고 해요. Casa에는 쉽게 Docker 컨테이너를 설정해주는 '앱'이 묶여 있지만, 원하는 Docker 서비스를 원하는대로 설치할 수도 있어요.\n- 서버에서 웹 사이트를 호스팅하는 것이 좋을 것 같아요!","ogImage":{"url":"/assets/img/2024-05-27-Creatingmyfirsthomeserver_0.png"},"coverImage":"/assets/img/2024-05-27-Creatingmyfirsthomeserver_0.png","tag":["Tech"],"readingTime":4},{"title":"해킹 보안 대전  티어 0미야옹","description":"","date":"2024-05-27 12:18","slug":"2024-05-27-HackTheBoxTIER0Meow","content":"\n## 소개\n\n## 작업 1\n\nVM 약자는 무엇을 나타내나요?\n\n답: 가상 머신\n\n<div class=\"content-ad\"></div>\n\n## 작업 2\n\n운영 체제와 상호 작용하기 위해 명령 줄을 통해 명령을 내릴 때 사용하는 도구는 무엇인가요? 이것은 콘솔 또는 셸로도 알려져 있습니다.\n\n답: 터미널\n\n## 작업 3\n\n<div class=\"content-ad\"></div>\n\nHTB 랩으로의 VPN 연결을 구성하는 데 어떤 서비스를 사용하나요?\n\n답: OpenVpn\n\n## TASK 4\n\n대상에 대한 연결을 테스트하기 위해 ICMP echo 요청을 사용하는 도구는 무엇인가요?\n\n<div class=\"content-ad\"></div>\n\n표 태그를 Markdown 형식으로 변경해주세요.\n\nAns: ping\n\n## TASK 5\n\n대상의 열린 포트를 찾는 데 가장 일반적인 도구의 이름은 무엇인가요?\n\nAns: nmap\n\n<div class=\"content-ad\"></div>\n\n## 작업 6\n\n저희의 스캔 중에 23/tcp 포트에서 식별한 서비스는 무엇인가요?\n\n답변: Telnet\n\n![이미지](/assets/img/2024-05-27-HackTheBoxTIER0Meow_0.png)\n\n<div class=\"content-ad\"></div>\n\n## 작업 7\n\n빈 암호로 대상에 텔넷을 통해 로그인할 수 있는 사용자 이름은 무엇인가요?\n\n답변: root\n\n![이미지](/assets/img/2024-05-27-HackTheBoxTIER0Meow_1.png)\n\n<div class=\"content-ad\"></div>\n\n\n![HackTheBoxTIER0Meow_2](/assets/img/2024-05-27-HackTheBoxTIER0Meow_2.png)\n\nSUBMIT FLAG\n\nAns: b40abdfe23665f766f9c61ecba8a4c19\n\n![HackTheBoxTIER0Meow_3](/assets/img/2024-05-27-HackTheBoxTIER0Meow_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n프로세스 요약\n","ogImage":{"url":"/assets/img/2024-05-27-HackTheBoxTIER0Meow_0.png"},"coverImage":"/assets/img/2024-05-27-HackTheBoxTIER0Meow_0.png","tag":["Tech"],"readingTime":2},{"title":"bashrc, bash-profile, 그리고 profile의 차이점","description":"","date":"2024-05-27 12:17","slug":"2024-05-27-DifferenceBetweenbashrcbash-profileandprofile","content":"\n\n<img src=\"/assets/img/2024-05-27-DifferenceBetweenbashrcbash-profileandprofile_0.png\" />\n\n# 1. 개요\n\nBash 쉘은 환경을 설정하기 위해 몇 가지 시작 파일을 사용합니다. 이러한 파일은 쉘 자체와 시스템 사용자를 위한 일부 Bash 쉘 구성을 결정합니다.\n\n이 튜토리얼에서는 .bashrc, .bash-profile 및 .profile과 같은 시작 파일 및 그들의 차이에 대해 알아보겠습니다.\n\n\n<div class=\"content-ad\"></div>\n\n# 2. 대화형 쉘과 비대화형 쉘\n\nBash는 대화형 쉘에서 두 가지 모드 옵션을 제공합니다: 로그인과 비로그인입니다.\n\nssh를 사용하여 시스템에 로그인하면 대화형 로그인 쉘을 얻게 됩니다. 이 쉘은 호출될 때 시작 파일을 읽습니다.\n\n그러나 이미 로그인한 쉘에서 새 쉘을 호출하면 대화형 비로그인 쉘을 얻게 됩니다. 이 유형의 쉘은 .bashrc 파일만 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n명령을 실행하기 위해 인간의 개입이 필요하지 않은 셸을 비대화(non-interactive) 셸이라고 부릅니다. 예를 들어, 스크립트가 명령을 실행하기 위해 자식 셸을 생성할 때, 그 자식 셸은 비대화 셸입니다. 이 셸은 시작 파일을 실행하지 않습니다. 그것은 생성된 셸로부터 환경 변수를 상속합니다.\n\n## 3. Bash 시작 파일\n\n시작 파일은 셸 시동 시 실행되어야 하는 명령을 포함합니다. 결과적으로, 셸은 이 파일에 있는 명령을 셸을 설정하기 위해 자동적으로 실행합니다. 이는 명령 프롬프트를 표시하기 전에 발생합니다.\n\n## 3.1. .bash_profile의 중요성\n\n<div class=\"content-ad\"></div>\n\n.bash_profile 파일에는 환경 변수를 설정하는 명령이 포함되어 있습니다. 따라서 이러한 변수는 이후의 쉘에서 상속됩니다.\n\n대화식 로그인 쉘에서 Bash는 먼저 /etc/profile 파일을 찾습니다. 발견되면 Bash는 해당 파일을 현재 쉘에서 읽고 실행합니다. 결과적으로 /etc/profile은 모든 사용자를 위한 환경 설정을 구성합니다.\n\n마찬가지로, Bash는 그 다음 홈 디렉토리에 .bash_profile 파일이 있는지 확인합니다. 존재한다면 Bash는 현재 쉘에서 .bash_profile을 실행합니다. 그러면 Bash는 .bash_login이나 .profile과 같은 다른 파일을 찾지 않습니다.\n\n만약 Bash가 .bash_profile을 찾지 못하면, .bash_login과 .profile 순으로 찾아 첫 번째로 읽을 수 있는 파일을 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n샘플 .bash_profile 파일을 살펴보겠습니다. 여기서는 PATH 변수를 설정하고 내보내고 있습니다:\n\n```js\necho \"Bash_profile execution starts..\"\nPATH=$PATH:$HOME/bin;\nexport PATH;\necho \"Bash_profile execution stops..\"\n```\n\n대화식 로그인 셸에서 명령 프롬프트 바로 앞에 다음과 같은 출력이 표시됩니다:\n\n```js\nBash_profile execution starts..\nBash_profile execution stops..\n[dsuser@cygnus ~]$\n```\n\n<div class=\"content-ad\"></div>\n\n# 3.2. .bashrc의 중요성\n\n.bashrc에는 Bash 쉘에 특정한 명령이 포함되어 있습니다. 모든 대화형 비로그인 쉘은 일반적으로 먼저 .bashrc를 읽습니다. 보통 .bashrc는 별칭(alias)과 Bash 관련 함수를 추가하는 가장 좋은 장소입니다.\n\nBash 쉘은 홈 디렉토리에서 .bashrc 파일을 찾아서 source를 사용하여 현재 쉘에서 실행합니다.\n\n이제 샘플 .bashrc 파일 내용을 살펴보겠습니다:\n\n<div class=\"content-ad\"></div>\n\n```bash\necho \"Bashrc 실행 시작..\"\nalias elui='top -c -u $USER'\nalias ll='ls -lrt'\necho \"Bashrc 실행 종료..\"\n```\n\n인터랙티브 비로그인 셸에서 명령 프롬프트 바로 앞에 아래 출력을 볼 수 있습니다:\n\n```bash\n[dsuser@server ~]$ bash\nBashrc 실행 시작..\nBashrc 실행 종료..\n[dsuser@server ~]$\n```\n\n# 3.3. .profile 파일의 중요성\n\n<div class=\"content-ad\"></div>\n\n대화형 쉘 로그인 중 홈 디렉토리에 .bash_profile이 없으면 Bash는 .bash_login을 찾습니다. 발견되면 Bash가 실행합니다. 만일 홈 디렉토리에 .bash_login이 없다면 Bash는 .profile을 찾아 실행합니다.\n\n.profile에는 .bash_profile 또는 .bash_login에 있는 것과 동일한 구성을 저장할 수 있습니다. 이 파일은 프롬프트 모양, 키보드 소리, 열 쉘 및 /etc/profile 파일에서 설정한 변수를 무시하고 개별 프로필 설정을 제어합니다.\n\n# 4. 차이점\n\n대화형 로그인 시마다 Bash 쉘은 .bash_profile을 실행합니다. 만일 홈 디렉토리에 .bash_profile이 없다면 Bash는 .bash_login과 .profile 중 첫 번째로 읽을 수 있는 파일을 실행합니다. 한편, 대화형 비 로그인 쉘 시작 시마다 Bash는 .bashrc를 실행합니다.\n\n<div class=\"content-ad\"></div>\n\n일반적으로 환경 변수는 .bash_profile에 넣습니다. 대화식 로그인 쉘은 첫 번째 쉘이므로 환경 설정에 필요한 모든 기본 설정을 .bash_profile에 넣습니다. 결과적으로 이러한 설정은 한 번만 설정되지만 모든 하위 쉘에서 상속됩니다.\n\n마찬가지로 별칭 및 함수는 항상 기존 환경에서 셸을 시작할 때 로드되도록 .bashrc에 넣습니다.\n\n그러나 로그인 및 비로그인 대화식 셸 설정 차이를 피하기 위해 .bash_profile에서 .bashrc를 호출합니다. 결과적으로 아래 코드 조각이 .bash_profile에 삽입되어 매 대화식 로그인 셸에서 .bashrc도 동일한 셸에서 실행되도록 합니다:\n\n```js\nif [ -f ~/.bashrc ];\nthen\n    .  ~/.bashrc;\nfi\nPATH=$PATH:$HOME/bin export PATH\n```\n\n<div class=\"content-ad\"></div>\n\n# 5. 결론\n\n결론적으로, 쉘은 환경을 설정하기 위해 시작 파일이 필요합니다. 환경을 사용하기 전에 쉘 환경을 구성해야 합니다.\n\n이 글에서는 다양한 쉘 모드를 확인했습니다. 그리고 다양한 Bash 시작 파일의 중요성을 배웠습니다. 마지막으로 이러한 시작 파일 간의 차이를 확인했습니다.\n","ogImage":{"url":"/assets/img/2024-05-27-DifferenceBetweenbashrcbash-profileandprofile_0.png"},"coverImage":"/assets/img/2024-05-27-DifferenceBetweenbashrcbash-profileandprofile_0.png","tag":["Tech"],"readingTime":4},{"title":"모든 개발자를 위해 도움이 되는 5가지 Bash 문자열 조작 방법","description":"","date":"2024-05-27 12:16","slug":"2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper","content":"\n![Bash String Manipulation Methods](/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png)\n\n배시는 모든 유닉스류 또는 유닉스 기반 운영 체제의 기본 자동화 언어가 되었습니다. 시스템 관리자, 데브옵스 엔지니어 및 프로그래머는 일반적으로 반복적인 명령 시퀀스를 사용하여 셸 스크립트를 작성하는 데 Bash를 사용합니다. Bash 스크립트에는 일반적으로 다른 프로그램 이진 파일을 실행하는 명령이 포함되어 있습니다. 대부분의 시나리오에서 데이터를 처리하고 셸 스크립트 내에서 논리적 흐름을 생성해야 할 수 있습니다. 따라서 우리는 종종 셸 스크립트에 조건문과 텍스트 조작 문을 추가해야 합니다.\n\n전통적인 Bash 스크립트와 이전 버전의 Bash 해석기를 사용한 이전 프로그래머들은 텍스트 조작을 위해 awk, sed, tr 및 cut 명령을 일반적으로 사용했습니다. 이들은 별개의 프로그램입니다. 이 텍스트 처리 프로그램들은 좋은 기능을 제공하지만 각 명령마다 상당한 프로세스 생성 시간이 소요되기 때문에 Bash 스크립트를 느리게 만듭니다. 현대의 Bash 버전은 잘 알려진 매개변수 확장 기능을 통해 내장된 텍스트 처리 기능을 제공합니다.\n\n본 기사에서는 Bash 스크립트에서 효율적으로 텍스트를 처리하는 데 사용할 수 있는 내장 문자열 조작 구문 몇 가지에 대해 설명하겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# 부분 문자열 추출 및 대체\n\n부분 문자열은 특정 문자열의 연속된 세그먼트 또는 일부를 가리킵니다. 다양한 스크립팅 시나리오에서 문자열 세그먼트에서 부분 문자열을 추출해야 하는 경우가 있습니다. 예를 들어, 파일 확장자가 포함된 완전한 파일 이름에서 파일 이름 세그먼트만 얻어야 하는 경우가 있습니다. 또한 부분 문자열을 특정 문자열 세그먼트로 대체해야 할 수도 있습니다 (즉, 파일 이름의 확장자를 변경하는 경우).\n\n문자의 위치와 길이를 제공함으로써 부분 문자열을 추출하는 것은 매우 쉽습니다:\n\n```js\n#!/bin/bash\n\nstr=\"2023-10-12\"\n\necho \"${str:5:2}\" # 10\necho \"${str::4}\" # 2023\necho \"2022-${str:5}\" # 2022-10-12\n```\n\n<div class=\"content-ad\"></div>\n\n다음과 같이 오른쪽 기준으로 부분 문자열 계산도 할 수 있습니다.\n\n```js\n#!/bin/bash\n\nstr=\"backup.sql\"\n\necho \"original${str:(-4)}\" # original.sql\n```\n\nBash는 부분 문자열을 대체하는 데 유용한 내장 구문도 제공합니다.\n\n```js\n#!/bin/bash\n\nstr=\"obin-linux_x64_bin\"\n\necho \"${str/x64/armhf}\" # obin-linux_armhf_bin\necho \"${str/bin/dist}\" # odist-linux_x64_bin\necho \"${str//bin/dist}\" # odist-linux_x64_dist\n```\n\n<div class=\"content-ad\"></div>\n\n일부 문자열(예: 파일 이름, 경로 등)을 작업할 때는 문자열의 접두사와 접미사를 대체해야 할 수도 있습니다. 파일 확장자를 다른 확장자로 바꾸는 것이 좋은 예시입니다. 다음 예시를 살펴보세요:\n\n```bash\n#!/bin/bash\n\nstr=\"db_config_backup.zip\"\n\necho \"${str/%.zip/.conf}\" # db_config_backup.conf\necho \"${str/#db/settings}\" # settings_config_backup.zip\n```\n\n위의 부분 문자열 대체 예시에서 일치시키기 위해 정확한 부분 문자열 세그먼트를 사용했지만, 다음과 같이 '\\*' 와일드카드 문자를 사용하여 부분 문자열을 사용할 수도 있습니다:\n\n```bash\n#!/bin/bash\n\nstr=\"db_config_backup.zip\"\n\necho \"${str/%.*/.bak}\" # db_config_backup.bak\necho \"${str/#*_/new}\" # newbackup.zip\n```\n\n<div class=\"content-ad\"></div>\n\n위의 방법은 정확한 부분 문자열을 모를 때 도움이 됩니다.\n\n# 정규 표현식 일치, 추출 및 치환\n\n이미 많은 유닉스 또는 GNU/Linux 사용자들이 알고 있는 대로, grep과 sed를 사용하여 정규 표현식 기반 텍스트 검색이 가능합니다. sed는 우리에게 정규 표현식 치환을 도와줍니다. 당신은 내장된 Bash 정규 표현식 기능을 사용하여 이러한 외부 이진 파일보다 빠르게 텍스트 처리를 처리할 수 있습니다.\n\n다음의 코드 스니펫에서 보여지는 것처럼, if 조건문과 =~ 연산자를 사용하여 정규 표현식 일치를 수행할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\n#!/bin/bash\n\nstr=\"db_backup_2003.zip\"\n\nif [[ $str =~ 200[0-5]+ ]]; then\n    echo \"regex_matched\"\nfi\n```\n\n만약 원하시면 if 문을 인라인 조건문으로 바꿀 수도 있어요:\n\n```js\n[[ $str =~ 200[0-5]+ ]] && echo \"regex_matched\"\n```\n\nBash 해석기가 정규 표현식을 찾은 후에는 일반적으로 모든 일치 항목을 BASH_REMATCH 쉘 변수에 저장합니다. 이 변수는 읽기 전용 배열이며, 전체 일치 데이터를 첫 번째 인덱스에 저장합니다. 서브 패턴을 사용하는 경우, Bash는 그에 해당하는 일치 항목을 다른 인덱스에 차례대로 보관합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n#!/bin/bash\n\nstr=\"db_backup_2003.zip\"\n\nif [[ $str =~ (200[0-5])(.*)$ ]]; then\n    echo \"${BASH_REMATCH[0]}\" # 2003.zip\n    echo \"${BASH_REMATCH[1]}\" # 2003\n    echo \"${BASH_REMATCH[2]}\" # .zip\nfi\n```\n\n이전에 substring matching을 wildcard와 함께 사용했던 것을 기억하시나요? 비슷하게, 다음 예시에서 보여지는 것처럼 파라미터 확장 내에서 regex 정의를 사용할 수 있습니다.:\n\n```js\n#!/bin/bash\n\nstr=\"db_backup_2003.zip\"\nre=\"200[0-3].zip\"\n\necho \"${str/$re/new}.bak\" # db_backup_new.bak\n```\n\n# Substring Removal Techniques\n\n\n\n<div class=\"content-ad\"></div>\n\n자주 텍스트 처리 요구 사항에서는 원하는 부분 문자열을 제거하여 텍스트 세그먼트를 사전 처리해야 할 때가 있습니다. 예를 들어, v 접두사와 일부 빌드 번호를 포함한 버전 번호를 추출하고 주 버전 번호를 찾으려면 일부 부분 문자열을 제거해야 합니다. 똑같은 부분 문자열 교체 구문을 사용할 수 있지만, 문자열 제거를 위해 교체 문자열 매개변수를 생략할 수도 있습니다.\n\n```js\n#!/bin/bash\n\nstr=\"ver5.02-2224.e2\"\n\nver=\"${str#ver}\"\necho $ver # 5.02-2224.e2\n\nmaj=\"${ver/.*}\"\necho $maj # 5\n```\n\n위 예제에서는 정확한 부분 문자열과 와일드카드를 사용하여 부분 문자열을 제거했지만, 정규 표현식을 사용할 수도 있습니다. 과도한 문자 없이 깔끔한 버전 번호를 추출하는 방법을 확인해보세요.\n\n```js\n#!/bin/bash\n\nstr=\"ver5.02-2224_release\"\n\nver=\"${str//[a-z_]}\"\necho $ver # 5.02-2224\n```\n\n<div class=\"content-ad\"></div>\n\n# 대 소문자 변환 및 대 소문자 기반 변수\n\n심지어 표준 C 언어에는 문자의 대 소문자를 변환하는 함수가 있습니다. 대부분의 현대적인 프로그래밍 언어들은 대소문자 변환을 위한 내장 함수를 제공합니다. 셸 스크립트 언어인 Bash는 대소문자 변환을 위한 함수를 제공하지는 않지만, 매개변수 확장과 변수 선언을 통해 대소문자 변환 기능을 제공합니다.\n\n다음 예제를 살펴보세요. 이 예제는 글자의 대소문자를 변환합니다:\n\n```bash\n#!/bin/bash\n\nstr=\"안녕 Bash!\"\n\nlower=\"${str,,}\"\nupper=\"${str^^}\"\n\necho $lower # 안녕 bash!\necho $upper # 안녕 BASH!\n```\n\n<div class=\"content-ad\"></div>\n\n다음처럼 특정 문자열의 첫 글자만 대문자 또는 소문자로 변경할 수도 있습니다:\n\n```js\n#!/bin/bash\n\nver1=\"V2.0-release\"\nver2=\"v4.0-release\"\n\necho \"${ver1,}\" # v2.0-release\necho \"${ver2^}\" # V4.0-release\n```\n\n만약 특정 변수를 엄격하게 대문자 또는 소문자로 만들어야 할 경우에는 매번 케이스 변환 함수를 실행할 필요가 없습니다. 대신, 다음 예시와 같이 내장된 declare 명령을 사용하여 특정 변수에 케이스 속성을 추가할 수 있습니다:\n\n```js\n#!/bin/bash\n\ndeclare -l ver1\ndeclare -u ver2\n\nver1=\"V4.02.2\"\nver2=\"v2.22.1\"\n\necho $ver1 # v4.02.2\necho $ver2 # V2.22.1\n```\n\n<div class=\"content-ad\"></div>\n\n위의 ver1 및 ver2 변수는 선언 시 case 속성을 받기 때문에 특정 변수에 값을 할당할 때마다 Bash는 변수 속성을 기반으로 텍스트 case를 변환합니다.\n\n# 문자열 분할 (문자열을 배열로 변환하기)\n\nBash는 declare 내장을 사용하여 색인 배열과 연관 배열을 정의할 수 있습니다. 대부분의 범용 프로그래밍 언어는 문자열 객체의 분할 메서드나 표준 라이브러리 함수를 통해 분할 기능을 제공합니다 (예: Go의 strings.Split 함수). Bash에서는 다양한 방법으로 문자열을 분할하고 배열을 생성할 수 있습니다. 예를 들어 필요한 구분 기호를 IFS로 변경하고 read 내장을 사용할 수 있습니다. 또는 tr 명령어를 루프와 함께 사용하여 배열을 구성할 수도 있습니다. 내장 매개변수 확장을 사용하는 방법도 있습니다. Bash에서는 문자열을 분할하는 다양한 방법이 있습니다.\n\nIFS와 read를 사용하는 것은 문자열을 분할하는 가장 간단하고 오류가 적은 방법 중 하나입니다.\n\n<div class=\"content-ad\"></div>\n\n```bash\n#!/bin/bash\n\nstr=\"C,C++,JavaScript,Python,Bash\"\n\nIFS=',' read -ra arr <<< \"$str\"\n\necho \"${#arr[@]}\" # 5\necho \"${arr[0]}\" # C\necho \"${arr[4]}\" # Bash\n```\n\n위의 코드 스니펫은 쉼표를 구분자로 사용하며 read 내장 명령어를 사용하여 IFS를 기반으로 배열을 생성합니다.\n\nread를 사용하지 않고 쉽게 분할할 수 있는 방법이 있더라도, 숨겨진 문제가 없는지 확인해야 합니다. 예를 들어, 다음 분할 구현은 매우 간단하지만 \\* (현재 디렉토리의 내용으로 확장)을 요소로 포함하고 구분 기호로 공백을 사용하는 경우에 작동하지 않습니다:\n\n```bash\n#!/bin/bash\n\n# 경고: 이 코드에는 여러 숨겨진 문제가 있습니다.\n\nstr=\"C,Bash,*\"\n\narr=(${str//,/ })\n\necho \"${#arr[@]}\" # 현재 디렉토리의 내용이 포함되어 있음\n```\n\n<div class=\"content-ad\"></div>\n\n\n지금까지 읽어 주셔서 감사합니다.\n\n# 레벨 업 코딩\n\n우리 커뮤니티의 일원이 되어 주셔서 감사합니다! 마지막으로 하고 가기 전에:\n\n\n<div class=\"content-ad\"></div>\n\n- 👏 이야기에 박수를 보내고 저자를 팔로우하세요 👉\n- 📰 Level Up Coding 게시물에서 더 많은 콘텐츠 확인하기\n- 💰 무료 코딩 면접 코스 ⇒ 코스 보기\n- 🔔 팔로우하기: Twitter | LinkedIn | 뉴스레터\n\n🚀👉 Level Up 팀의 멤버가 되어 멋진 직업을 찾아보세요\n","ogImage":{"url":"/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png"},"coverImage":"/assets/img/2024-05-27-5BashStringManipulationMethodsThatHelpEveryDeveloper_0.png","tag":["Tech"],"readingTime":7},{"title":"리눅스에서 Windows 가상 머신Docker을 실행하는 대안적인 방법","description":"","date":"2024-05-27 12:15","slug":"2024-05-27-AlternativewaytorunWindowsVMonLinuxDocker","content":"\n\n리눅스 사용자로서 주로 윈도우용 소프트웨어를 실행하거나 다양한 윈도우 전용 애플리케이션을 테스트해야 하는 경우가 많이 있어요.\n\n안타깝게도 VMware와 VirtualBox를 사용해 윈도우 가상 머신을 실행하는 것이 이상적이지 않다고 느꼈습니다. 제 노트북에서 이러한 애플리케이션을 사용할 때 성능이 꽤 느린 것을 경험했는데, 부드러운 경험을 보장하기에 필요한 자원이 부족했거든요. 그래서 리눅스에서 윈도우를 실행하기 위한 대안적인 방법을 찾기 시작했습니다.\n\n# 해결책\n\n그래서 발견한 해결책을 소개하려고 해요: 도커(Docker)에서 윈도우를 실행하는 방법이 바로 그것이에요.\n\n<div class=\"content-ad\"></div>\n\n## 도커\n\n도커는 컨테이너화 기술을 사용하여 애플리케이션을 격리된 환경인 컨테이너에서 실행하는 플랫폼입니다. 전통적인 가상 머신과 달리 도커 컨테이너는 호스트 시스템의 커널을 공유하므로 무게가 가볍고 효율적이며 최소한의 오버헤드로 애플리케이션을 실행할 수 있습니다. 시스템에 설치하려면:\n\n```js\n# Debian / Ubuntu\nsudo apt install docker.io\n# 저는 아치를 사용합니다\nyay -S docker\n# 다른 배포판의 경우, 다음 링크를 확인하세요\n# https://docs.docker.com/engine/install/\n```\n\n그리고 다음 이미지를 사용할 것입니다:\n\n<div class=\"content-ad\"></div>\n\n- https://hub.docker.com/r/dockurr/windows\n\n도커 컨테이너 내에서 실행되는 Windows!\n\n## Windows 설치\n\ndocker-compose.yml이라는 파일을 만든 다음 (선택 사항으로) Windows 이미지 파일을 저장할 storage 폴더를 만들고 호스트 및 가상 머신간에 공유되는 폴더를 위한 shared 폴더를 만듭니다.\n\n<div class=\"content-ad\"></div>\n\n다음으로, docker-compose.yml을 수정해야 합니다. 제 구성은 아래와 같습니다:\n\n```js\nservices:\n  windows:\n    image: dockurr/windows\n    container_name: windows\n    environment:\n      VERSION: \"win10\" # 실행할 Windows 버전을 지정합니다\n      DISK_SIZE: \"25G\" # 선택 사항입니다. 할당할 디스크 크기를 지정할 수 있습니다\n      RAM_SIZE: \"3G\" # RAM도 마찬가지로 지정할 수 있습니다\n      CPU_CORES: \"2\" # CPU 코어도 지정 가능합니다\n    devices:\n      - /dev/kvm # KVM이 있을 경우\n    volumes:\n      - ./storage:/storage # 윈도우 이미지는 이 폴더에 저장됩니다 (호스트 머신과 컨테이너 모두)\n      - ./shared:/shared # 공유 폴더도 동일합니다\n    cap_add:\n      - NET_ADMIN # 컨테이너에 네트워크 관련 작업을 위한 관리자 권한을 부여합니다\n    ports:\n      - 8006:8006 # 웹 인터페이스\n      - 3389:3389/tcp # 원격 데스크톱 연결 (RDP)\n      - 3389:3389/udp\n    stop_grace_period: 2m\n```\n\n다음 명령어로 실행해 주세요:\n\n```js\ndocker compose up -d\n```\n\n<div class=\"content-ad\"></div>\n\n( 이 테이블 태그를 Markdown 형식으로 변경하세요. )\n\n개발자가 되신 것을 축하드립니다! 여기서는 한국어 번역을 지원해 드립니다.\n\n<div class=\"content-ad\"></div>\n\n웹에서 머신을 사용하거나 더 선호되는 RDP로 연결할 수 있습니다. 도커로 머신의 IP를 가져오려면 도커 inspect 47bb78f908a0 | grep IPAddress를 사용하시면 됩니다.\n\n![이미지](/assets/img/2024-05-27-AlternativewaytorunWindowsVMonLinuxDocker_0.png)\n\n저는 xfreerdp 도구를 사용하여 RDP를 통해 연결할 것입니다. 사용자 이름은 docker이며, 아래 명령어를 사용하세요:\n\n```js\nxfreerdp /u:docker /v:172.18.0.2 /dynamic-resolution\n```\n\n<div class=\"content-ad\"></div>\n\n여기, 도커 컨테이너에서 Windows를 실행하는 법입니다:\n\n![Image](/assets/img/2024-05-27-AlternativewaytorunWindowsVMonLinuxDocker_1.png)\n\n공유 폴더는 \\\\host.lan 입니다.\n\n# 결론\n\n<div class=\"content-ad\"></div>\n\n마지막으로, 다른 구성을 위한 도커 이미지의 설명서를 확인하는 것을 제안합니다. 또한, Windows를 시작 및 중지하는 두 개의 스크립트를 포함하는 https://github.com/ElnurBDa/win10dockerconfig 레포지토리를 확인해보세요. 이를 키보드 단축키에 바인딩할 수 있습니다.\n\n읽어 주셔서 감사합니다!! Linux에서 Windows를 실행하는 다른 대안이 있다면 댓글로 알려주세요 :)","ogImage":{"url":"/assets/img/2024-05-27-AlternativewaytorunWindowsVMonLinuxDocker_0.png"},"coverImage":"/assets/img/2024-05-27-AlternativewaytorunWindowsVMonLinuxDocker_0.png","tag":["Tech"],"readingTime":3},{"title":"Traefik 역방향 프록시 만들기 쉽게 이해하기 - 궁극의 안내","description":"","date":"2024-05-27 12:08","slug":"2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide","content":"\n![Traefik 설치하기 쉽게 만든 Reverse Proxy의 최종 가이드](/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_0.png)\n\n셀프 호스팅 세계에서 많은 사람들이 Traefik의 설정이 어렵고 문서를 이해하기 어렵다고 불평한다는 것을 알았어요. 또한 기존 가이드 중 많은 것들이 Traefik가 어떻게 작동하는지 설명하지 않고 구성 예시만 제공하는 것을 알았어요.\n\nTraefik 가이드에 대한 저의 접근 방식은 ELI5 스타일로 Traefik에 대해 절대 모든 것을 이해하게 해줄 테니 기대해주세요.\n\nMedium 유료 회원이 아니신가요? 무료로 여기서 읽어보세요.\n\n<div class=\"content-ad\"></div>\n\n## 기초로 돌아가 — 반전 프록시란 무엇인가요?\n\n반전 프록시는 다른 서버들 앞에 위치한 서버로, 요청을 이러한 서버들로 전달할 수도 있고 수정하거나 거부할 수도 있습니다.\n\n예를 들어, 밥이가 있습니다. 밥이는 라즈베리 파이에 웹사이트를 배포했습니다. 그 라즈베리의 IP는 192.168.0.50이며, 그의 사이트는 http://192.168.0.50:8080 페이지로 접속할 수 있습니다. 그러나 그는 https://mysite.imbob.com을 입력하여 접속하고 싶어합니다. \"imbob.com\" 도메인을 소유하고 있다면, 반전 프록시를 이용하여 이를 할 수 있습니다. 더불어 IP를 화이트리스트로 추가하거나 인증을 추가하는 등의 보안 메커니즘을 추가할 수도 있습니다.\n\n<img src=\"/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_1.png\" />\n\n<div class=\"content-ad\"></div>\n\n역방향 프록시는 로드 밸런서 역할을 할 수도 있습니다. 단일 서버가 처리할 수 있는 트래픽보다 많은 트래픽을 받으면, 역방향 프록시는 요청을 다른 서버들 사이에 분배할 수 있습니다.\n\n## Traefik 최소 구성\n\n당신이 Traefik을 설정할 때 Docker Compose를 사용한다고 가정하겠습니다. 여기 Traefik 문서에서 가져온 최소 예제가 있습니다:\n\nservices:\nreverse-proxy: # The official v3 Traefik docker image\nimage: traefik:v3.0 # Enables the web UI and tells Traefik to listen to docker\ncommand: --api.insecure=true --providers.docker\nports: # The HTTP port - \"80:80\" # The Web UI (enabled by --api.insecure=true) - \"8080:8080\"\nvolumes: # So that Traefik can listen to the Docker events - /var/run/docker.sock:/var/run/docker.sock\n\n<div class=\"content-ad\"></div>\n\n여기, 이해해야 할 몇 가지 사항이 있어요. --api.insecure=true은 API를 traefik 엔트리포인트에서 사용 가능하게 만들고 (--entrypoint에 대한 더 자세한 내용은 몇 분 후에 있습니다), --providers.docker은 도커 프로바이더를 활성화시켜 호스트에서 도커 서비스를 자동으로 발견할 수 있게 합니다. 이를 위해 Traefik 컨테이너에 도커 소켓을 마운트해야 하는데, 이는 볼륨 섹션에서 수행됩니다. 마지막으로 몇 가지 포트를 노출해야도 해요:\n\n- 80: 표준인 포트 80에서 HTTP 트래픽을 전달하기 위해\n- 8080: 웹 UI에 액세스하기 위해\n\n모든 것이 작동하는지 확인할 수 있어요. 웹 UI를 열어 http://your-ip:8080 (http://192.168.0.50:8080은 Bob의 경우)으로 접속할 수 있어요.\n\n## 설정 파일\n\n<div class=\"content-ad\"></div>\n\nTraefik을 구성하는 방법은 많이 있어요. 여기서 우리는 설정 매개변수를 컨테이너에 명령으로 전달했음을 볼 수 있어요. 이를 구성 파일을 통해 전달하거나 환경 변수를 통해 전달할 수도 있어요.\n\n우리의 간단한 예제를 위한 구성 파일은 다음과 같아요:\n\n```js\napi: insecure: true;\n\nproviders: docker: endpoint: \"unix:///var/run/docker.sock\";\n```\n\n이건 YAML 파일이에요. 이 파일을 사용하려면 간단히 컨테이너에 마운트하시면 돼요:\n\n<div class=\"content-ad\"></div>\n\n```yaml\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n```\n\n그리고 모든 것이 이전과 같이 작동해야 합니다. 설정을 원하는대로 자유롭게 할 수 있으며, 이를 컨테이너 설정 파일을 통해하거나 Traefik 설정 파일을 통해하거나 환경 변수를 통해 할 수 있습니다. 개인적으로 Traefik 설정 파일을 통해 하는 것을 선호하므로 그대로 진행할 겁니다.\n\n그런데 말이야, 지금 이야기하고 있는 설정은 정적 설정이라고 알려져 있어요. 이 설정을 변경할 때마다 Traefik을 재시작해야 합니다. 나중에 동적 설정에 대해 이야기할 거에요.\n\n## EntryPoints\n\n<div class=\"content-ad\"></div>\n\nEntryPoints의 역할은 특정 포트의 트래픽을 캡처하는 것입니다. 일반적인 Traefik 설치에서는 보통 포트 80과 포트 443의 트래픽을 캡처하고 싶을 것입니다. 하지만 가능한 모든 것이 있습니다. 예를 들어, 저는 포트 222를 통해 통과하는 SSH 트래픽을 리다이렉트하는 데에도 Traefik을 사용합니다.\n\nEntryPoints는 정적 구성에서 정의됩니다. 예를 들어:\n\n```js\nentryPoints: web: address: \":80\";\n\nwebsecure: address: \":443\";\n\nssh: address: \":222\";\n```\n\nEntryPoints의 이름은 원하는 대로 지정할 수 있습니다. 표준은 없습니다. EntryPoints를 구성하는 다양한 옵션들이 많이 있습니다. 이 안내서에서 모든 세부 내용을 다룰 수는 없으니, 기본 사항을 설명해 드리겠습니다. 더 알고 싶다면 문서를 참조해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n일반적으로 HTTP 트래픽을 모두 HTTPS 트래픽으로 리디렉션하여 연결을 보안하는 것이 좋습니다. 이를 수행하는 한 가지 방법은 EntryPoint에 리디렉션을 추가하는 것입니다:\n\n```js\nentryPoints: web: address: \":80\";\nhttp: redirections: entryPoint: to: websecure;\n```\n\n여기서 모든 HTTP 트래픽이 websecure EntryPoint로 리디렉션되어야 함을 나타냅니다. 현재 TLS 인증서를 구성하지 않았으므로 이것을 구성에 유지하지 않는 것이 좋습니다.\n\n또한, 각 EntryPoint에 대해 컴퓨터의 포트를 열어야 합니다. 그래서 우리의 새로운 docker-compose.yml 파일은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```yaml\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\" # web\n      - \"443:443\" # websecure\n      - \"1234:222\" # ssh\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n```\n\n알 수 있듯이, ssh 엔트리 포인트의 포트 매핑은 1234입니다. 즉, 포트 1234로 전송된 트래픽은 ssh 엔트리 포인트를 통해 전송됩니다. 제가 보여주려는 것은 포트를 원하는 대로 매핑할 수 있으며, 다른 포트를 80번 포트와 443번 포트로 매핑할 수도 있지만, 이는 표준이 아니므로 서비스에 액세스할 때 포트를 지정해야 합니다. 예를 들어, https://radarr.imbob.com:4430이라고 지정해야 하며, 443번 포트가 아닌 다른 포트로 매핑한 경우에는 https://radarr.imbob.com 대신에 이렇게 지정해야 할 것입니다.\n\n## DNS 레코드\n\n도메인을 소유하고 있다고 가정하겠습니다. 소유하고 있지 않다면, PiHole과 같은 DNS 서버로 자체 도메인을 만들고 여기에 DNS 레코드를 추가할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\"저는 원하는 것이 'something.mydomain'을 입력하면 Traefik이 호스팅된 머신에 도달하도록 하고 싶어요. 어디에서든 서비스를 이용할지, 또는 집에서만 이용할지에 따라 사용해야 하는 IP가 다릅니다. 예를 들어, 저는 집에서만 서비스에 접속하고 싶다고 가정해봅시다.\n\n해야 할 일은 로컬로 서버에 접속할 때 사용하는 IP를 가져와서 도메인 호스트에서 이 IP를 가리키는 A 레코드를 생성하는 것뿐입니다.\n\n예를 들어, Bob은 DNS에 다음 레코드를 가지고 있습니다:\n\n```js\nA  *.imbob.com  192.168.0.50\n\n<div class=\"content-ad\"></div>\n\n만약 Bob이 자신의 서비스를 어디서든 접근할 수 있게 하고 싶다면, 공용 IP를 사용하고 라우터 구성에서 포트 80 및 443을 전달해야 했을 것입니다. 예를 들어 다음과 같은 결과가 나오게 됩니다:\n\nA  *.imbob.com  84.154.65.110\n\n84.154.65.110이 그의 공용 IP인 것으로 가정합니다.\n\n또 다른 예를 들어보겠습니다. 저는 VPN을 사용합니다. 이 VPN에 연결되어 있을 때, VPN에 할당된 다른 IP를 통해 내 기기에 접근할 수 있습니다. VPN에서 연결될 때 보이는 IP를 사용하여 내 서비스를 VPN에 속한 누구에게든 접근 가능하게 하고 싶다면, 다음과 같이 할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\nA  *.imbob.com  100.81.0.50\n\n## 첫 번째 서비스 추가하기\n\n예를 들어, Dozzle를 사용해보겠습니다. Dozzle에 http://dozzle.imbob.com에서 액세스하고 싶습니다.\n\n이제 docker-compose.yml에 Dozzle를 추가하겠습니다:\n\n<div class=\"content-ad\"></div>\n\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n      - \"1234:222\"\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n\n  dozzle:\n    container_name: dozzle\n    image: amir20/dozzle:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    ports:\n      - 8081:8080\n    labels:\n      - traefik.enable=true # 해당 서비스를 위해 Traefik를 활성화합니다\n      - traefik.http.routers.dozzle.entrypoints=web # 엔트리포인트를 명시합니다\n      - traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`) # 서비스에 액세스하는 규칙을 명시합니다\n\n또한, Traefik 구성 파일을 아래에서 확인하실 수 있습니다:\n\napi:\n  insecure: true\n\nentryPoints:\n  web:\n    address: \":80\"\n\n  websecure:\n    address: \":443\"\n\n  ssh:\n    address: \":222\"\n\nproviders:\n  docker:\n    endpoint: \"unix:///var/run/docker.sock\"\n\n이제 http://dozzle.imbob.com을 열어 사용하실 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n하지만 왜 이것이 작동하는 걸까요? 저희 서비스는 Traefik 서비스와 동일한 파일에 있기 때문에 동일한 Docker 네트워크에 속합니다. 이 네트워크는 포트 80과 443을 통해 노출되어 있습니다. 따라서 우리가 컴퓨터의 포트 80으로 요청을 보내면, 이는 Dozzle이 속한 Docker 네트워크로 진입하게 됩니다.\n\n이제 우리가 우리의 서비스를 해당 서비스를 자체 파일로 옮기고 싶다고 상상해 봅시다. 이 서비스를 Traefik의 Docker 네트워크에 연결해야 합니다. 다음과 같이 생성해 시작해 보죠:\n\ndocker network create traefik\n\n이제 우리의 두 서비스, Traefik과 Dozzle이 이 네트워크에 속한다는 것을 밝혀야 합니다:\n\n<div class=\"content-ad\"></div>\n\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n      - \"1234:222\"\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n    networks:  # required\n      - traefik\n\nnetworks:\n  traefik:\n    external: true\n\nservices:\n  dozzle:\n    container_name: dozzle\n    image: amir20/dozzle:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    ports:\n      - 8081:8080\n    labels:\n      - traefik.enable=true  # 해당 서비스에 대해 Traefik을 활성화합니다.\n      - traefik.http.routers.dozzle.entrypoints=web  # 엔트리포인트를 지정합니다.\n      - traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`)  # 서비스에 액세스하는 규칙을 지정합니다.\n    networks:  # required\n      - traefik\n\nnetworks:\n  traefik:\n    external: true\n\n그러면 작동합니다. 그렇지 않으면, Traefik은 Dozzle 컨테이너의 IP로 리다이렉팅하겠지만, 이 IP는 서버에서 노출된 네트워크 바깥에 있는 Dozzle 컨테이너로 이어지지 않습니다.\n\n## 라우터\n\n<div class=\"content-ad\"></div>\n\n라우터는 적절한 서비스로 요청을 전달하는 역할을 합니다. 이는 동적 구성의 일환입니다.\n\n도즐(Dozzle)의 경우, 다음 라우터를 정의했습니다:\n\n- traefik.http.routers.dozzle.entrypoints=web  # 우리는 엔트리포인트를 지정합니다\n- traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`)  # 저희 서비스에 접근하는 규칙을 지정합니다\n\n또한 Docker 레이블 대신 파일에서도 구성할 수 있습니다:\n\n<div class=\"content-ad\"></div>\n\nhttp: routers: dozzle: entrypoints: -web;\nrule: Host(`dozzle.imbob.com`);\n\n그런 다음 정적 구성 파일에서 파일 제공자로 추가하십시오:\n\nproviders:\n  docker:\n    ...\n  file:\n    filename: /dynamic.yml\n\n당연히 이 파일을 컨테이너에 마운트해야 합니다:\n\n<div class=\"content-ad\"></div>\n\nservices:\n  reverse-proxy:\n    ...\n    volumes:\n      - ./dynamic.yml:/dynamic.yml:ro\n\nTraefik을 사용하는 것은 Docker 레이블을 사용하는 큰 장점이죠. 그러니 일단 이것을 사용하도록 하겠습니다. Middleware를 정의할 때 이 파일을 다시 살펴볼 거에요.\n\nEntryPoints와 마찬가지로, Routers에도 많은 구성 옵션이 있습니다. 가장 중요한 것은 Rule 옵션입니다. 이 옵션을 사용하면 라우터가 요청을 서비스로 전달하기 위한 규칙을 정의할 수 있습니다.\n\nDozzle에 사용한 규칙은 다음과 같았습니다:\n\n<div class=\"content-ad\"></div>\n\n호스트(`dozzle.imbob.com`);\n\n예를 들어 다음과 같이 사용할 수 있습니다:\n\n호스트(`dozzle1.imbob.com`) || 호스트(`dozzle2.imbob.com`);\n\nDozzle에 http://dozzle1.imbob.com 또는 http://dozzle2.imbob.com에서 액세스할 수 있습니다. 규칙에 대한 자세한 내용은 Traefik 문서를 참조하십시오.\n\n<div class=\"content-ad\"></div>\n\n## 미들웨어\n\n미들웨어는 서비스로 전송되기 전에 요청을 조정하는 데 사용됩니다. 미들웨어는 동적 구성에 정의됩니다.\n\n도즐에 인증을 추가해 보겠습니다. 먼저, 패키지 apache2-utils에 포함된 htpasswd를 사용하여 비밀번호를 생성해야 합니다.\n\nhtpasswd -nB test\n새 암호:\n새 암호 다시 입력:\ntest:$2y$05$kLDHhc5ntBoHwAyp5S48U.wN.u2eQJYWpfYvRWSilayuAe5oF2xqy\n\n<div class=\"content-ad\"></div>\n\n참고: docker-compose.yml에서 사용할 때 해시 내의 모든 달러 기호는 이스케이핑을 위해 두 배로 사용되어야 합니다. 따라서 대신 다음 명령을 사용하여 이를 자동으로 수행할 수 있습니다:\n\necho $(htpasswd -nB test) | sed -e s/\\\\$/\\\\$\\\\$/g\n새 암호:\n새 암호 다시 입력:\ntest:$$2y$$05$$uo7dTQpudzoJtmAhXLesxudke9edoGlxC6oaOL9zStHVayoVZ6xwm\n\n이제 docker-compose.yml 파일에 인증 미들웨어를 추가할 수 있습니다:\n\nservices:\n  dozzle:\n    ...\n    labels:\n      ...\n        # 패스워드는 \"test\" 입니다\n      - traefik.http.middlewares.my-middleware.basicauth.users=test:$$2y$$05$$x4VT4lRFCy2.z/Ic3BQYbOgEzDILEqyhaStkuzykurT9KAuWKTSF.\n\n<div class=\"content-ad\"></div>\n\n여기서는 미들웨어를 만들라고만 되어 있어요. 라우터에 그것을 사용하도록 지시해야 해요. 그래서 다음 레이블을 추가해요:\n\n- traefik.http.routers.dozzle.middlewares=my-middleware\n\n참고로 동적 구성 파일을 사용해서도 똑같은 작업을 할 수 있어요.\n\n전체 Docker compose 파일은 다음과 같아요:\n\n<div class=\"content-ad\"></div>\n\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n      - \"8080:8080\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n\n  dozzle:\n    container_name: dozzle\n    image: amir20/dozzle:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    ports:\n      - 8081:8080\n    labels:\n      - traefik.enable=true\n      - traefik.http.routers.dozzle.entrypoints=web\n      - traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`)\n      - traefik.http.middlewares.my-middleware.basicauth.users=test:$$2y$$05$$x4VT4lRFCy2.z/Ic3BQYbOgEzDILEqyhaStkuzykurT9KAuWKTSF.\n      - traefik.http.routers.dozzle.middlewares=my-middleware\n\n그리고 이제 http://dozzle.imbob.com 으로 이동하여 웹앱에 액세스하려면 기본 HTTP 인증을 요구할 것입니다.\n\n참고: Traefik이 이해하는 설정을 언제든지 웹 UI를 통해 확인할 수 있습니다:\n\n![Traefik Reverse Proxy 설정 화면](/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_2.png)\n\n<div class=\"content-ad\"></div>\n\n## HTTPS 활성화\n\n오늘날, 사용자들에게 신뢰감을 줄 수 있는 가장 기본적인 작업은 암호화된 연결을 제공하는 것입니다. Traefik을 사용하면 HTTPS 트래픽을 쉽게 제공할 수 있습니다.\n\nTraefik을 구성하여 정적 인증서를 사용하거나 ACME 공급자에 의해 자동으로 생성된 인증서를 사용하도록 설정할 수 있습니다.\n\n두 번째 옵션인 자동 생성 인증서를 사용하는 것이 가장 좋고 간단합니다. 그러니 이렇게 설정해 봅시다. Traefik의 정적 구성에 추가할 구성은 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\ncertificatesResolver:\n  letsEncrypt:\n    acme:\n      email: bob@gmail.com  # 여러분의 이메일을 입력해주세요\n      storage: /tls/acme.json\n      httpChallenge:\n        entryPoint: web\n\n여기서 \"letsEncrypt\"라는 인증서 리졸버를 선언하고 있습니다. 우리는 이를 위해 이메일 주소, 인증서를 저장할 위치 및 이 리졸버와 관련된 엔트리포인트를 제공해야 합니다.\n\n기본적으로 우리는 무료이면서 접근성이 좋은 Let's Encrypt를 사용하고 있습니다. 위의 구성은 일반적으로 여러분의 도메인에 관계없이 작동할 것입니다. 하지만 Porkbun과 같은 다른 제공업체를 지정할 수도 있습니다:\n\ncertificatesResolvers:\n  porkbun:\n    acme:\n      email: bob@gmail.com\n      storage: /tls/porkbun.json\n      dnsChallenge:\n        provider: porkbun\n        delayBeforeCheck: 0\n\n<div class=\"content-ad\"></div>\n\n사용하는 공급업체에 따라 특정 옵션을 수정할 수 있어요. 예를 들어 Porkbun의 경우 환경 변수로 전달하는 API 키와 비밀 값을 제공해야 해요:\n\nservices:\n  reverse-proxy:\n    ...\n    environment:\n      PORKBUN_SECRET_API_KEY: my-secret\n      PORKBUN_API_KEY: my-key\n\n자세한 내용은 문서에서 확인해주세요.\n\n컨테이너가 종료되어도 인증서가 유지되어야 여러 API에서 제한을 받지 않아요. 그래서 docker-compose.yml 파일에 볼륨을 추가해봅시다:\n\n<div class=\"content-ad\"></div>\n\n서비스:\n  reverse-proxy:\n    ...\n    볼륨:\n      - tls:/tls\n\n볼륨:\n  tls:\n\n마지막으로, 우리는 인증서 리졸버를 사용하고자 한다고 명시해야 합니다 (이것은 자동으로 이루어지지 않습니다). 그리고 우리의 EntryPoint를 HTTPS 트래픽과 관련된 하나를 사용하도록 수정해야 합니다 (우리의 경우에는 websecure), 그래서 우리의 라우터를 수정합니다:\n\n서비스:\n  dozzle:\n    ...\n    레이블:\n    ...\n      - traefik.http.routers.dozzle.entrypoints=websecure\n      - traefik.http.routers.dozzle.tls.certresolver=letsEncrypt\n\n그래서 이제, 여기가 전체 파일이에요, docker-compose.yml:\n\n<div class=\"content-ad\"></div>\n\nservices:\n  reverse-proxy:\n    image: traefik:latest\n    ports:\n      - \"80:80\"\n      - \"8080:8080\"\n      - \"443:443\"\n    volumes:\n      - ./traefik.yml:/traefik.yml:ro\n      - /var/run/docker.sock:/var/run/docker.sock\n      - tls:/tls\n\n  dozzle:\n    container_name: dozzle\n    image: amir20/dozzle:latest\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n    ports:\n      - 8081:8080\n    labels:\n      - traefik.enable=true\n      - traefik.http.routers.dozzle.entrypoints=websecure\n      - traefik.http.routers.dozzle.rule=Host(`dozzle.imbob.com`)\n      - traefik.http.routers.dozzle.middlewares=my-middleware\n      - traefik.http.middlewares.my-middleware.basicauth.users=test:$$2y$$05$$x4VT4lRFCy2.z/Ic3BQYbOgEzDILEqyhaStkuzykurT9KAuWKTSF.\n      - traefik.http.routers.dozzle.tls.certresolver=letsEncrypt\n\nvolumes:\n  tls:\n\n그리고 traefik.yml:\n\napi:\n  insecure: true\n\nentryPoints:\n  web:\n    address: \":80\"\n\n  websecure:\n    address: \":443\"\n\n  ssh:\n    address: \":222\"\n\nproviders:\n  docker:\n    endpoint: \"unix:///var/run/docker.sock\"\n\ncertificatesResolver:\n  letsEncrypt:\n    acme:\n      email: bob@gmail.com\n      storage: /tls/acme.json\n      httpChallenge:\n        entryPoint: web\n\n## 마무리하는 손짓\n\n<div class=\"content-ad\"></div>\n\n완료하려면 먼저 Traefik을 우리 도메인 이름을 통해 쉽게 접근할 수 있도록 만들어야 합니다. 몇 가지 레이블을 추가하겠습니다:\n\nservices:\n  reverse-proxy:\n    ...\n    labels:\n      - traefik.enable=true\n      - traefik.http.routers.traefik-secure.entrypoints=websecure\n      - traefik.http.routers.traefik-secure.rule=Host(`traefik.imbob.com`)\n      - traefik.http.routers.traefik-secure.service=api@internal\n      - traefik.http.routers.traefik-secure.tls.certresolver=letsEncrypt\n\nTraefik의 장점은 초기 구성이 완료된 후 리버스 프록시 뒤에 서비스를 쉽게 추가할 수 있다는 것입니다. 몇 가지 Docker 레이블로 가능합니다.\n\ntraefik.yml에서 api.insecure를 비활성화하고 api.dashboard를 활성화할 수도 있습니다:\n\n<div class=\"content-ad\"></div>\n\napi:\n  insecure: false\n  dashboard: true\n\n마지막으로, HTTP 트래픽을 HTTPS로 리디렉션하는 설정 블록을 추가해봅시다. traefik.yml에서 web 엔트리포인트를 수정하면 됩니다:\n\nweb:\n  address: \":80\"\n  http:\n    redirections:\n      entryPoint:\n        to: websecure\n\n## TCP 트래픽 전달하기\n\n<div class=\"content-ad\"></div>\n\n시작 부분의 예시를 다시 가져오겠습니다. SSH EntryPoint와 함께:\n\nentrypoints: ssh: address: \":222\";\n\n도메인 이름 뒤에 SSH 트래픽을 전달하려고 합니다. EntryPoint가 있습니다. 호스트에서 포트를 노출해야 합니다:\n\nservices:\n  reverse-proxy:\n    ...\n    ports:\n      - 222:222\n\n<div class=\"content-ad\"></div>\n\n이제, 우리는 SSH 서버를 정의하는 docker-compose.yml 파일에 TCP 라우터를 정의할 수 있습니다:\n\nservices:\n  server:\n    ...\n    ports:\n      - 222:22\n    labels:\n      - traefik.enable=true\n      - traefik.tcp.routers.ssh.entrypoints=ssh\n      - traefik.tcp.routers.ssh.rule=HostSNI(`*`)\n\nHostSNI(\\*)은 모든 요청을 일치시킬 것이라고 말합니다. 올바른 엔트리 포인트로 전송된다면 모든 요청을 일치시킵니다. 따라서 이는 example.mydomain.com:222뿐만 아니라 anything.mydomain.com:222도 일치시킵니다. 이는 TCP 트래픽에 대해 TLS를 사용하지 않는 경우 필수적이며, HTTP 및 HTTPS 포트가 아닌 표준 TCP 포트를 사용하지 않는 경우에는 실제로 문제가 되지 않습니다.\n\n이것으로 끝입니다! 참고로, 저는 이를 Gitea와 함께 사용하여 다음과 같은 원격 URL을 가지고 있습니다: ssh://git@gitea.mydomain.com:222/estebanthi/my-repo.git.\n\n<div class=\"content-ad\"></div>\n\n아무것이나 원하는 대로 할 수 있습니다. 저는 SQL 데이터베이스와 함께도 이를 사용해요.\n\n## 보너스: 여러 호스트\n\n이 부분은 여러 대의 서버를 사용하는 사람들에게만 관련됩니다.\n\n서비스가 Traefik을 통해 접근 가능하도록 하려면 도커 네트워크에 속해 있어야 한다고 말씀드렸죠? 만약 여러 대의 서버를 가지고 있다면 이것이 문제가 될 수 있습니다. 적어도 도커 레이블을 더 이상 사용할 수 없게 되며, 서비스를 노출하고 파일 공급자를 통해 Traefik에 추가해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n대안으로 traefik-kop을 사용할 수 있습니다. 이제 \"서버 1\" (192.168.0.50)에 Traefik이 있고 \"서버 2\" (192.168.0.51)에 Dozzle이 있다고 가정해 봅시다.\n\n먼저 Traefik에 Redis 공급자를 추가해 보겠습니다.\n\nproviders:\n  docker:\n    ...\n  redis:\n    endpoints:\n      - \"redis:6379\"\n\n여기에서 Traefik을 실행 중인 호스트와 동일한 호스트에 Redis를 만들어 보겠습니다.\n\n<div class=\"content-ad\"></div>\n\nservices:\n  reverse-proxy: ...\n\n  redis:\n    image: redis:latest\n    restart: unless-stopped\n    ports:\n      - \"6379:6379\"\n\n이제 \"서버 2\"에서 traefik-kop을 배포할 것입니다.\n\nservices:\n  traefik-kop:\n    image: \"ghcr.io/jittering/traefik-kop:latest\"\n    restart: unless-stopped\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n    environment:\n      - \"REDIS_ADDR=192.168.0.50:6379\" # Redis 호스트의 IP\n      - \"BIND_IP=192.168.0.51\" # 현재 호스트의 IP\n\n그러면 이제 \"server 2\"에서 계속해서 사용해오던 라벨들을 사용할 수 있게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n그런데 Redis 호스트의 TCP 트래픽을 노출하고 redis.mydomain.com:6379을 통해 접근할 수 있도록 설정할 수 있어요. 그러면 \"REDIS_ADDR\"이 \"redis.mydomain.com:6379\"로 변경돼요 (저는 이렇게 했어요). 이제는 알고 계시잖아요.\n\n## 마지막으로\n\n제가 설명을 명확히 전달했기를 바랍니다. Traefik은 처음에는 조금 혼란스러울 수 있지만 최대한 간단하게 설명하려고 노력했어요. 이해에 어려움이 있다면 언제든지 댓글을 달아 주세요!\n\n읽어 주셔서 감사합니다! 더 많은 내용을 보고 싶으시다면 아래에서 제 모든 게시물을 찾아보세요.\n","ogImage":{"url":"/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_0.png"},"coverImage":"/assets/img/2024-05-27-TraefikReverseProxyMadeEasyUltimateGuide_0.png","tag":["Tech"],"readingTime":18}],"page":"113","totalPageCount":113,"totalPageGroupCount":6,"lastPageGroup":13,"currentPageGroup":5},"__N_SSG":true}