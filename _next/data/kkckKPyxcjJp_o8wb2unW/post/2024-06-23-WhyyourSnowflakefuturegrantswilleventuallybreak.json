{"pageProps":{"post":{"title":"Snowflake의 미래 부여가 결국 실패할 이유","description":"","date":"2024-06-23 16:32","slug":"2024-06-23-WhyyourSnowflakefuturegrantswilleventuallybreak","content":"\n\n<img src=\"/assets/img/2024-06-23-WhyyourSnowflakefuturegrantswilleventuallybreak_0.png\" />\n\n여기 설정이 있어요...\n\n방금 MyFirstRole이라는 새 역할을 만들었습니다.\n\n```js\ncreate role MyFirstRole;\n```\n\n<div class=\"content-ad\"></div>\n\n계획은 이 역할에 대해 MyDatabase 라는 데이터베이스에 대해 완전한 읽기 액세스 권한을 부여하는 것입니다. MyDatabase 내의 모든 스키마의 모든 현재 테이블 및 뷰를 선택할 수 있도록하고 싶습니다.\n\n```js\ngrant usage on database MyDatabase to role MyFirstRole;\ngrant usage on all schemas in database MyDatabase to role MyFirstRole;\ngrant select on all tables in database MyDatabase to role MyFirstRole;\ngrant select on all views in database MyDatabase to role MyFirstRole;\n```\n\n위 명령문을 설정하면 우리의 역할은 이제 MyDatabase의 모든 항목을 선택할 수 있습니다.\n\n그러나 시간이 흐른다면 데이터베이스에 새로운 테이블 및 뷰가 생성될 것입니다. 새로운 개체가 생성될 때마다 MyFirstRole에게 수동으로 선택 권한을 부여하는 것은 비현실적입니다. 다행히도 미래의 권한 부여가 이 문제를 해결해 줄 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n미래 스키마에서 MyDatabase 내의 향후 역할에 대한 사용 권한을 MyFirstRole 역할에 부여합니다.\n미래 테이블에서 MyDatabase 내의 향후 테이블에 대한 선택 권한을 MyFirstRole 역할에 부여합니다.\n미래 뷰에서 MyDatabase 내의 향후 뷰에 대한 선택 권한을 MyFirstRole 역할에 부여합니다.\n```\n\n이제 MyFirstRole은 앞으로 생성되는 테이블이나 뷰에서 select 문을 실행할 수 있습니다.\n\n모든 것이 잘 되고 예상대로 작동하고 있습니다. MyFirstRole에 대한 select 권한을 수동으로 업데이트할 필요가 없으며, 새롭게 생성된 테이블과 뷰에 액세스를 부여해야 하는 경우를 제외하고는요. 이때, MyDatabase에 제한적인 액세스를 갖는 새로운 역할인 MySecondRole을 생성해야 할 때가 올 것입니다.\n\nMyDatabase에는 MySchema라는 스키마가 있다고 가정합시다. MySecondRole은 MySchema 내의 현재 및 향후 테이블 및 뷰에서만 선택할 수 있고 다른 작업은 제한되어야 한다고 합니다.\n\n<div class=\"content-ad\"></div>\n\n조금만 더 해야겠어요...\n\n```js\ncreate role MySecondRole;\ngrant usage on database MyDatabase to role MySecondRole;\ngrant usage on schema MyDatabase.MySchema to role MySecondRole;\ngrant select on all tables in schema MyDatabase.MySchema to role MySecondRole;\ngrant select on future tables in schema MyDatabase.MySchema to role MySecondRole;\ngrant select on all views in schema MyDatabase.MySchema to role MySecondRole;\ngrant select on future views in schema MyDatabase.MySchema to role MySecondRole;\n```\n\n다시 한 번, MySecondRole에 대한 새 테이블 및 뷰가 MySchema에 생성되는 것처럼 모든 것이 예상대로 작동하는 것처럼 보입니다. 그러나 몇 주 후에 MyFirstRole이 MySecondRole에 대한 그랜트 이후에 생성된 테이블 또는 뷰에 더 이상 액세스 권한이 없다는 것을 깨닫게 됩니다.\n\n그리고 이것이 미래의 권한이 결국 망가지게 되는 이유입니다...\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-23-WhyyourSnowflakefuturegrantswilleventuallybreak_1.png\" />\n\n간단한 영어로, MyFirstRole은 데이터베이스 수준에서 미래 객체에 권한을 부여받았습니다. ... 데이터베이스에서 미래 테이블을 부여했습니다. 그와 반대로, MySecondRole은 스키마 수준에서 미래 부여를 받았습니다. ... 스키마 수준의 부여는 동일한 데이터베이스 내에서 데이터베이스 수준의 부여보다 우선합니다. 이는 MyFirstRole이 MySecondRole의 미래 부여가 실행된 시점에 테이블 및 뷰에 대한 미래 부여가 무효화되었음을 의미합니다.\n\n이에 대한 해결책은 없습니다. 동일한 데이터베이스에서 데이터베이스 및 스키마 수준에서 미래 부여가 동시에 존재하는 세계에서 살 수 없습니다. 해결책은 데이터베이스의 액세스 패턴을 사전에 파악하고 이에 맞게 부여하는 것입니다. 액세스 요구 사항이 복잡하고 여러 역할 간에 맞춤형인 경우 스키마 수준에서 미래 부여가 적합합니다. 더 간단하고 단일 목적의 데이터베이스(스테이징이 좋은 예시입니다)의 경우에는 데이터베이스 수준의 부여를 사용할 수도 있습니다.\n\n읽어 주셔서 감사합니다!\n\n<div class=\"content-ad\"></div>\n\n안녕하세요! 부담 가지지 마시고 언제든지 인사해주세요 👋\n\n트위터 — https://x.com/jduran9987\n\n링크드인 — https://www.linkedin.com/in/jonathan-duran-80974a183/","ogImage":{"url":"/assets/img/2024-06-23-WhyyourSnowflakefuturegrantswilleventuallybreak_0.png"},"coverImage":"/assets/img/2024-06-23-WhyyourSnowflakefuturegrantswilleventuallybreak_0.png","tag":["Tech"],"readingTime":3},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-06-23-WhyyourSnowflakefuturegrantswilleventuallybreak_0.png\">\n<p>여기 설정이 있어요...</p>\n<p>방금 MyFirstRole이라는 새 역할을 만들었습니다.</p>\n<pre><code class=\"hljs language-js\">create role <span class=\"hljs-title class_\">MyFirstRole</span>;\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>계획은 이 역할에 대해 MyDatabase 라는 데이터베이스에 대해 완전한 읽기 액세스 권한을 부여하는 것입니다. MyDatabase 내의 모든 스키마의 모든 현재 테이블 및 뷰를 선택할 수 있도록하고 싶습니다.</p>\n<pre><code class=\"hljs language-js\">grant usage on database <span class=\"hljs-title class_\">MyDatabase</span> to role <span class=\"hljs-title class_\">MyFirstRole</span>;\ngrant usage on all schemas <span class=\"hljs-keyword\">in</span> database <span class=\"hljs-title class_\">MyDatabase</span> to role <span class=\"hljs-title class_\">MyFirstRole</span>;\ngrant select on all tables <span class=\"hljs-keyword\">in</span> database <span class=\"hljs-title class_\">MyDatabase</span> to role <span class=\"hljs-title class_\">MyFirstRole</span>;\ngrant select on all views <span class=\"hljs-keyword\">in</span> database <span class=\"hljs-title class_\">MyDatabase</span> to role <span class=\"hljs-title class_\">MyFirstRole</span>;\n</code></pre>\n<p>위 명령문을 설정하면 우리의 역할은 이제 MyDatabase의 모든 항목을 선택할 수 있습니다.</p>\n<p>그러나 시간이 흐른다면 데이터베이스에 새로운 테이블 및 뷰가 생성될 것입니다. 새로운 개체가 생성될 때마다 MyFirstRole에게 수동으로 선택 권한을 부여하는 것은 비현실적입니다. 다행히도 미래의 권한 부여가 이 문제를 해결해 줄 것입니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">미래 스키마에서 <span class=\"hljs-title class_\">MyDatabase</span> 내의 향후 역할에 대한 사용 권한을 <span class=\"hljs-title class_\">MyFirstRole</span> 역할에 부여합니다.\n미래 테이블에서 <span class=\"hljs-title class_\">MyDatabase</span> 내의 향후 테이블에 대한 선택 권한을 <span class=\"hljs-title class_\">MyFirstRole</span> 역할에 부여합니다.\n미래 뷰에서 <span class=\"hljs-title class_\">MyDatabase</span> 내의 향후 뷰에 대한 선택 권한을 <span class=\"hljs-title class_\">MyFirstRole</span> 역할에 부여합니다.\n</code></pre>\n<p>이제 MyFirstRole은 앞으로 생성되는 테이블이나 뷰에서 select 문을 실행할 수 있습니다.</p>\n<p>모든 것이 잘 되고 예상대로 작동하고 있습니다. MyFirstRole에 대한 select 권한을 수동으로 업데이트할 필요가 없으며, 새롭게 생성된 테이블과 뷰에 액세스를 부여해야 하는 경우를 제외하고는요. 이때, MyDatabase에 제한적인 액세스를 갖는 새로운 역할인 MySecondRole을 생성해야 할 때가 올 것입니다.</p>\n<p>MyDatabase에는 MySchema라는 스키마가 있다고 가정합시다. MySecondRole은 MySchema 내의 현재 및 향후 테이블 및 뷰에서만 선택할 수 있고 다른 작업은 제한되어야 한다고 합니다.</p>\n<div class=\"content-ad\"></div>\n<p>조금만 더 해야겠어요...</p>\n<pre><code class=\"hljs language-js\">create role <span class=\"hljs-title class_\">MySecondRole</span>;\ngrant usage on database <span class=\"hljs-title class_\">MyDatabase</span> to role <span class=\"hljs-title class_\">MySecondRole</span>;\ngrant usage on schema <span class=\"hljs-title class_\">MyDatabase</span>.<span class=\"hljs-property\">MySchema</span> to role <span class=\"hljs-title class_\">MySecondRole</span>;\ngrant select on all tables <span class=\"hljs-keyword\">in</span> schema <span class=\"hljs-title class_\">MyDatabase</span>.<span class=\"hljs-property\">MySchema</span> to role <span class=\"hljs-title class_\">MySecondRole</span>;\ngrant select on future tables <span class=\"hljs-keyword\">in</span> schema <span class=\"hljs-title class_\">MyDatabase</span>.<span class=\"hljs-property\">MySchema</span> to role <span class=\"hljs-title class_\">MySecondRole</span>;\ngrant select on all views <span class=\"hljs-keyword\">in</span> schema <span class=\"hljs-title class_\">MyDatabase</span>.<span class=\"hljs-property\">MySchema</span> to role <span class=\"hljs-title class_\">MySecondRole</span>;\ngrant select on future views <span class=\"hljs-keyword\">in</span> schema <span class=\"hljs-title class_\">MyDatabase</span>.<span class=\"hljs-property\">MySchema</span> to role <span class=\"hljs-title class_\">MySecondRole</span>;\n</code></pre>\n<p>다시 한 번, MySecondRole에 대한 새 테이블 및 뷰가 MySchema에 생성되는 것처럼 모든 것이 예상대로 작동하는 것처럼 보입니다. 그러나 몇 주 후에 MyFirstRole이 MySecondRole에 대한 그랜트 이후에 생성된 테이블 또는 뷰에 더 이상 액세스 권한이 없다는 것을 깨닫게 됩니다.</p>\n<p>그리고 이것이 미래의 권한이 결국 망가지게 되는 이유입니다...</p>\n<div class=\"content-ad\"></div>\n<img src=\"/assets/img/2024-06-23-WhyyourSnowflakefuturegrantswilleventuallybreak_1.png\">\n<p>간단한 영어로, MyFirstRole은 데이터베이스 수준에서 미래 객체에 권한을 부여받았습니다. ... 데이터베이스에서 미래 테이블을 부여했습니다. 그와 반대로, MySecondRole은 스키마 수준에서 미래 부여를 받았습니다. ... 스키마 수준의 부여는 동일한 데이터베이스 내에서 데이터베이스 수준의 부여보다 우선합니다. 이는 MyFirstRole이 MySecondRole의 미래 부여가 실행된 시점에 테이블 및 뷰에 대한 미래 부여가 무효화되었음을 의미합니다.</p>\n<p>이에 대한 해결책은 없습니다. 동일한 데이터베이스에서 데이터베이스 및 스키마 수준에서 미래 부여가 동시에 존재하는 세계에서 살 수 없습니다. 해결책은 데이터베이스의 액세스 패턴을 사전에 파악하고 이에 맞게 부여하는 것입니다. 액세스 요구 사항이 복잡하고 여러 역할 간에 맞춤형인 경우 스키마 수준에서 미래 부여가 적합합니다. 더 간단하고 단일 목적의 데이터베이스(스테이징이 좋은 예시입니다)의 경우에는 데이터베이스 수준의 부여를 사용할 수도 있습니다.</p>\n<p>읽어 주셔서 감사합니다!</p>\n<div class=\"content-ad\"></div>\n<p>안녕하세요! 부담 가지지 마시고 언제든지 인사해주세요 👋</p>\n<p>트위터 — <a href=\"https://x.com/jduran9987\" rel=\"nofollow\" target=\"_blank\">https://x.com/jduran9987</a></p>\n<p>링크드인 — <a href=\"https://www.linkedin.com/in/jonathan-duran-80974a183/\" rel=\"nofollow\" target=\"_blank\">https://www.linkedin.com/in/jonathan-duran-80974a183/</a></p>\n</body>\n</html>\n"},"__N_SSG":true}