{"pageProps":{"post":{"title":"위성 열 영상을 1000m에서 10m로 다운스케일링하는 방법 Python","description":"","date":"2024-06-22 16:48","slug":"2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython","content":"\n\n![image](/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_0.png)\n\n# 목차\n\n- 🌅 소개\n- 💾 Sentinel-3 (1000 m) 및 Sentinel-2 이미지 다운로드\n- ⚙️ Sentinel-3 이미지 처리\n- 🌡️ 온도-NDVI 공간\n- 📐 열화상 이미지 선명화 (1000 m에서 10 m)\n- 🗺️ 선명화된 열화상 이미지 시각화\n- 📄 결론\n- 📚 참고 자료\n\n## 🌅 소개\n\n<div class=\"content-ad\"></div>\n\n위성에서 촬영한 열화상 이미지를 축소하는 연구는 열화상 이미지를 제공하는 위성들의 공간 및 시간 해상도 사이의 상충 관계 때문에 광범위하게 연구되었습니다. 예를 들어, Landsat-8의 재방문 주기는 16일이며, 원래 열 해상도는 100미터입니다. 반면에 Sentinel-3은 매일 열화상 이미지를 제공할 수 있지만, 공간 해상도는 1000미터입니다.\n\n![이미지](/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_1.png)\n\n열화상 이미지의 굵은 해상도를 해결하는 한 가지 방법은 NASA의 Landsat-9와 같은 열 센서가 장착된 추가 위성을 발사하는 것일 수 있습니다. Landsat-9의 경우, Landsat-8과 Landsat-9의 임시 해상도는 8일입니다 (하나의 위성보다는 16일), 맑은 하늘을 전제로 할 때.\n\n그러나 이 접근 방식은 수십억 달러의 투자와 몇 년의 노력이 필요합니다. 대신, 연구자들은 통계적 방법에 집중하여, 공간 해상도는 높지만 임시 해상도는 낮은 위성의 시정/근적외선 (VNIR) 밴드를 열화상 이미지와 상관시킴으로써 열화상 이미지의 낮은 공간 해상도 (하지만 높은 임시 해상도)와 연관시키는데 초점을 맞추었습니다. 예를 들어, 연구들은 Sentinel-2의 VNIR 밴드로부터 계산된 정규화 된 차이 채취 지수 (NDVI)가 Sentinel-3의 열화상 이미지와 역 상관 관계가 있음을 보여주었습니다.\n\n<div class=\"content-ad\"></div>\n\n답변을 요약하면 Sentinel-2의 NDVI와 Sentinel-3의 열화상 이미지 간의 상관 관계가 충분히 강하다면, 해당 방정식을 10m 해상도로 조정하여 10m 해상도의 열화상 이미지를 생성할 수 있습니다.\n\n위성 대역과 센서 스펙트럼에 대해 자세히 알고 싶다면 다음을 참조하십시오:\n\n이 게시물에서는 Sentinel-3로부터 낮은 공간 해상도 열화상 이미지와 Sentinel-2로부터 높은 공간 해상도 VNIR 이미지를 다운로드할 것입니다. 이 두 이미지는 각각의 위성에 의해 동시에 촬영되었습니다. 그런 다음, VNIR 대역을 사용하여 NDVI를 계산하고((NIR-Red)/(NIR+Red)), 이를 1000m로 업스케일하고 NDVI와 열대 대역 간의 상관 관계(둘 다 1000m 해상도)를 탐색할 것입니다. 마지막으로, 이 상관 관계를 사용하여 10m 해상도의 온도 지도를 생성할 것입니다.\n\n## 💾 Sentinel-3(1000 m) 및 Sentinel-2 이미지(10 m) 다운로드\n\n<div class=\"content-ad\"></div>\n\n이미 R 및 Python에서 Sentinel-2 이미지를 다운로드하는 방법에 대해 세 번의 게시물을 작성했습니다. 또한 Python에서 Sentinel-3 이미지를 다운로드하는 방법에 대한 게시물도 있습니다. 이곳에서는 해당 단계들을 반복하고 싶지 않아서 이 게시물을 참조하시기 바랍니다:\n\nR에서 Sentinel-2 이미지 다운로드:\n\nPython에서 Sentinel-2 이미지 다운로드:\n\nPython에서 Sentinel-3 이미지 다운로드:\n\n<div class=\"content-ad\"></div>\n\n만약 코드를 작성하지 않고 이미지를 다운로드하고 싶지 않다면, 다음 게시물을 확인해보세요:\n\n열화상 이미지를 축소화하기 위한 통계적 방법을 적용하는 중요한 단계는 위성에서 동시에 촬영된 선명한 이미지를 찾는 것입니다. 이미지를 다운로드하기 전에 날짜, 구름 양, 그리고 귀하의 관심 지역(AOI)에 기반하여 메타데이터를 필터링할 수 있습니다. Sentinel 메타데이터(관심 지역, 구름 양 등)를 필터링하고 처리하는 방법을 더 알고 싶다면 다음을 참조해보세요:\n\n이 게시물에서, 제 관심 지역(AOI)는 캘리포니아에 위치하며, 2023년 6월 19일에 Sentinel-2 및 Sentinel-3로 촬영된 선명한 이미지를 발견했습니다. 다른 위치나 날짜를 검색하고 싶다면 자유롭게 찾아보세요. 그러나 제가 다운로드한 이미지를 사용하길 원한다면, 다음 정보가 있습니다:\n\nSentinel-2: S2B_MSIL2A_20230620T183919_N0509_R070_T10SFG_20230620T224951\n\n<div class=\"content-ad\"></div>\n\n\nsatellite = “SENTINEL-2”\n\nlevel = “S2MSI2A”\n\nAOI = “POLYGON ((-121.0616 37.6391, -120.966 37.6391, -120.966 37.6987, -121.0616 37.6987, -121.0616 37.6391))”\n\nstart_date = “2023–06–19” ; end_date = “2023–06–21”\n\n\n<div class=\"content-ad\"></div>\n\n\nsatellite = “SENTINEL-3”\n\nlevel= “LST”\n\nAOI = “POLYGON ((-121.0616 37.6391, -120.966 37.6391, -120.966 37.6987, -121.0616 37.6987, -121.0616 37.6391))”\n\n\n<div class=\"content-ad\"></div>\n\nstart_date = “2023–06–19” ; end_date = “2023–06–21”\n\nSentinel-2에서 NIR 및 레드 밴드(NDVI를 계산하는 데 필요한 밴드)를 10m로 다운로드한 후 Sentinel-3에서 열화상 이미지를 다운로드하면 디렉토리에 이 세 파일이 있어야 합니다:\n\n![Image](/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_2.png)\n\n## ⚙️ Sentinel-3 이미지 처리\n\n<div class=\"content-ad\"></div>\n\nSentinel-3 이미지는 Sentinel-2보다 훨씬 넓은 장면을 커버합니다. 따라서 Sentinel-3 각 픽셀의 평균 NDVI 값을 필요로 하므로 Sentinel-3 이미지를 Sentinel-2 이미지의 범위에 따라 클리핑해야 합니다. 이를 위해 첫 번째 단계는 Sentinel-3 이미지를 Sentinel-2 이미지와 동일한 투영으로 재매핑하는 것입니다. 이를 수행하기 위해 다음과 같은 코드를 사용할 수 있습니다:\n\n```js\nimport numpy as np\nimport rasterio\nfrom rasterio.warp import calculate_default_transform, reproject, Resampling\nfrom pyproj import Transformer\n\ninput_raster = 'Sentinel-3_L2_LST_reproj.tif'\noutput_raster = 'Sentinel-3_L2_LST_reproj_32610.tif'\ndst_crs = 'EPSG:32610'\n\n# 입력 래스터 파일 읽기\nwith rasterio.open(input_raster) as src:\n    # 목적지 CRS에 대한 변환, 너비 및 높이 가져오기\n    transform, width, height = calculate_default_transform(src.crs, dst_crs, src.width, src.height, *src.bounds)\n\n    # 목적지 설정\n    kwargs = src.meta.copy()\n    kwargs.update({\n        'crs': dst_crs,\n        'transform': transform,\n        'width': width,\n        'height': height,\n        'dtype': np.float32,\n    })\n\n    # 목적지 생성 및 재매핑된 데이터 작성\n    with rasterio.open(output_raster, 'w', **kwargs) as dst:\n        # 재매핑 수행\n        for i in range(1, src.count + 1):\n            reproject(\n                source=src.read(1).astype(np.float32) * src.scales[0] + src.offsets[0],\n                destination=rasterio.band(dst, i),\n                src_transform=src.transform,\n                src_crs=src.crs,\n                dst_transform=transform,\n                dst_crs=dst_crs,\n                resampling=Resampling.bilinear)\n```\n\n이 스크립트에서는 이전 단계에서 다운로드한 Sentinel-3 래스터 이미지를 읽고, 지정된 CRS로 재매핑하기 위한 변환 매개변수를 계산하고, 재매핑된 데이터를 포함한 새로운 래스터 파일을 내보냅니다. 이러한 단계를 거치면 디렉토리에 다음 네 가지 파일이 있어야 합니다:\n\n![image](/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_3.png)\n\n\n<div class=\"content-ad\"></div>\n\nSentinel-3 열화상 이미지가 Sentinel-2 좌표 시스템으로 변경되었으므로 이제 Sentinel-2 데이터 범위를 기반으로 열화상 이미지를 잘라내는 작업을 할 수 있습니다. 아래 코드를 사용하여 작업할 수 있어요:\n\n```js\nimport rasterio\nimport numpy as np\n\n# 두 래스터 파일 열기\nwith rasterio.open('T10SFG_20230620T183919_B08_10m.jp2') as small_raster:\n    with rasterio.open('Sentinel-3_L2_LST_reproj_32610.tif') as big_raster:\n\n        # 더 작은 래스터의 범위 가져오기\n        min_x, min_y, max_x, max_y = small_raster.bounds\n\n        # 더 큰 래스터에서 더 작은 래스터의 범위 내의 데이터 읽기\n        window = rasterio.windows.from_bounds(min_x, min_y, max_x, max_y, big_raster.transform)\n        data = big_raster.read(window=window)\n\n        # 더 큰 래스터의 메타데이터 업데이트하여 더 작은 래스터의 범위와 일치시키기\n        clipped_meta = big_raster.meta.copy()\n        clipped_meta.update({\n            'height': window.height,\n            'width': window.width,\n            'transform': rasterio.windows.transform(window, big_raster.transform),\n            'dtype': data.dtype\n        })\n\n        # 잘라낸 데이터 쓰기\n        with rasterio.open('Sentinel-3_L2_LST_reproj_32610_clipped.tif', 'w', **clipped_meta) as clipped_raster:\n            clipped_raster.write(data)\n```\n\n이 스크립트에서는 두 래스터 파일(Sentinle-3 및 Sentinel-2 이미지)을 읽고, 더 작은 래스터의 범위(Sentinel-2)를 추출하고, 더 큰 래스터(Sentinle-3 열화상 이미지)에서 해당 데이터를 읽어와서 잘라낸 Sentinle-3의 메타데이터를 Sentinel-2 이미지와 일치하도록 업데이트한 후, 잘라낸 열화상 이미지를 새 TIFF 파일에 작성합니다.\n\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_4.png\" />\n\n<div class=\"content-ad\"></div>\n\nNDVI 및 클리핑된 온도 맵을 옆으로 나란히 플롯해 봅시다:\n\n```js\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport rasterio\nfrom rasterio.plot import show\n\n# 파일 경로\nred_path = '/content/T10SFG_20230620T183919_B04_10m.jp2'\nnir_path = '/content/T10SFG_20230620T183919_B08_10m.jp2'\n\nclipped_temperature_path = '/content/Sentinel-3_L2_LST_reproj_32610_clipped.tif'\n\n# 래스터 데이터 읽기\nwith rasterio.open(red_path) as red_src:\n  red = red_src.read(1)\n\nwith rasterio.open(nir_path) as nir_src:\n  nir = nir_src.read(1)\n\nwith rasterio.open(clipped_temperature_path) as clipped_temp_ds:\n  clipped_temperature = clipped_temp_ds.read(1)\n\n# NDVI 계산\nndvi = (nir - red) / (nir + red)\n\n# NDVI와 온도를 옆으로 플롯\nfig, (ax1,ax2) = plt.subplots(ncols=2, figsize=(12, 6))\n\n# NDVI 플롯\nim1 = ax1.imshow(ndvi, cmap=ndvi_cmap, vmin=0, vmax=0.6)\nax1.set_title('NDVI', fontweight='bold', fontsize=14)\nfig.colorbar(im1, ax=ax1, shrink=0.5)\n\n# 클리핑된 온도 플롯\nim2= ax2.imshow(clipped_temperature, cmap=ndvi_cmap.reversed(), vmin=300, vmax=315)\nax2.set_title('Clipped Temperature', fontweight='bold', fontsize=14)\nfig.colorbar(im2, ax=ax2, shrink=0.5)\nplt.show()\n```\n\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_5.png\" />\n\n위와 같이 Sentinel-3 열화상 이미지를 Sentinel-2 맵의 범위에 맞게 성공적으로 클립했습니다. 그러나 Sentinel-2 이미지도 잘린 상태이며, 온도 픽셀의 평균 NDVI 값을 얻기 위해 존속 통계를 실행하면 많은 NaN 값을 얻게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_6.png)\n\n다음 단계에서 데이터프레임에서 NaN 값을 제외하여 수정할 것입니다.\n\n## 🌡️ 온도-NDVI 공간\n\n같은 투영 및 범위를 갖는 두 개의 명확한 이미지, 즉 센티넬-3에서의 열화상 이미지와 센티넬-2에서의 VNIR 이미지가 있을 때, 각 온도 픽셀의 평균 NDVI 값을 얻기 위해 존 채택 통계를 실행할 수 있습니다. 기본적으로 존 채택 통계 방식을 통해 10m에서 1000m로 NDVI 지도를 집계하여 온도-NDVI 공간에서 온도 값에 대한 NDVI 값을 플로팅할 수 있습니다.\n\n\n<div class=\"content-ad\"></div>\n\n소개에서 언급했듯이 열값은 NDVI 값과는 역상관 관계에 있어야 합니다. 높은 NDVI는 식물의 비율이 더 높은 것을 나타내며 더 차가운 픽셀에 해당하고, 낮은 NDVI는 적은 식물이나 벌거벗은 토양에 해당하여 더 따뜻한 픽셀에 해당합니다. 우리의 AOI(관심 영역)에서 열과 NDVI 값 사이의 공간을 탐색하기 위해 존솔 통계를 수행해 보겠습니다:\n\n```js\nimport rasterio\nimport rasterio.features\nimport rasterio.mask\nimport pandas as pd\nimport geopandas as gpd\nimport rasterstats\n\nimport rasterio\nfrom rasterio.features import shapes\nmask = None\n\n# 입력 래스터 열기\nwith rasterio.open('Sentinel-3_L2_LST_reproj_32610_clipped.tif') as src:\n    # 래스터 밴드 읽기\n    image = src.read(1).astype(np.float32) * src.scales[0] + src.offsets[0]\n    results = (\n        {'properties': {'Temperature': v}, 'geometry': s}\n        for i, (s, v)\n        in enumerate(\n            shapes(image, mask=mask, transform=src.transform)))\n    geoms = list(results)\n    gpd_polygonized_raster = gpd.GeoDataFrame.from_features(geoms)\n\n# 래스터 열기\nwith rasterio.open('T10SFG_20230620T183919_B08_10m.jp2') as nir_src:\n    with rasterio.open('T10SFG_20230620T183919_B04_10m.jp2') as red_src:\n\n        # 데이터를 float32로 읽기\n        nir = nir_src.read(1).astype(np.float32) * nir_src.scales[0] + nir_src.offsets[0]\n        red = red_src.read(1).astype(np.float32) * red_src.scales[0] + red_src.offsets[0]\n\n        # NDVI 계산\n        ndvi = (nir - red) / (nir + red)\n\n        # 각 다각형에 대한 존솔 통계 계산\n        stats = rasterstats.zonal_stats(gpd_polygonized_raster.geometry, ndvi, affine=nir_src.transform, stats='mean')\n\n        # NDVI의 평균값을 데이터프레임에 추가\n        gpd_polygonized_raster['NDVI'] = [s['mean'] for s in stats]\n\n# 다각형 레이어를 shapefile로 저장\ngpd_polygonized_raster.to_file('output_polygons.shp')\n\n# geodataframe로부터 pandas 데이터프레임 생성\nstats_df = pd.DataFrame(gpd_polygonized_raster.drop(columns='geometry'))\n\n# 데이터프레임 출력\nprint(stats_df)\n```\n\n이 스크립트에서는 열 래스터를 여각화하고, Sentinel-2 이미지에서 NDVI를 계산하고, 각 온도 픽셀에 대한 존솔 통계(평균 NDVI)를 계산합니다.\n\n<div class=\"content-ad\"></div>\n\n위 표와 이전에 논의한 것처럼, Sentinel-3에서 열화 데이터를 가지고 있는 일부 픽셀에는 NaN 값이 있습니다. 이는 Sentinel-2 이미지의 자른 부분 때문입니다. Sentinel-2에서 NaN 값을 가진 행을 제외하겠습니다:\n\n```python\n# NaN 값이 있는 행 삭제\ndf_clean = stats_df.dropna(subset=['NDVI'])\ndf_clean\n```\n\n결과는 다음과 같습니다:\n\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_8.png\" />\n\n<div class=\"content-ad\"></div>\n\n이 깔끔한 데이터프레임을 사용하여 온도-NDVI 공간을 그래프로 표현할 수 있어요:\n\n```js\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy.stats import linregress\n\n# 산점도 생성\nplt.figure(figsize=(8, 6))\nsns.scatterplot(x='NDVI', y='Temperature', data=df_clean, palette='coolwarm')\n\n# 그래프 제목 및 축 레이블 설정\nplt.title('NDVI 대 온도 그래프', fontsize=16, fontweight='bold')\nplt.xlabel('NDVI', fontsize=14)\nplt.ylabel('Temperature', fontsize=14)\n\n# 그래프 보여주기\nplt.show()\n```\n\n결과는 다음과 같아요:\n\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_9.png\" />\n\n<div class=\"content-ad\"></div>\n\n위 그림에서 NDVI와 온도 사이의 역상관 관계를 관찰할 수 있지만 몇 가지 점이 이상치로 나타납니다. 이는 식물 및 맨 소토 외의 다른 특징을 나타내는 이미지의 픽셀 때문일 수 있습니다. 이러한 픽셀을 제거하기 위해 NDVI 값이 0.1에서 0.6 사이이고 온도 값이 300 켈빈에서 330 켈빈 사이인 값만 유지한 다음, 그에 맞게 그림을 업데이트하겠습니다:\n\n```js\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy.stats import linregress\n\n# 지정된 조건에 기반하여 데이터프레임 필터링\nfiltered_df = df_clean[(df_clean['NDVI'] >= 0.1) & (df_clean['NDVI'] <= 0.6) &\n                 (df_clean['Temperature'] >= 300) & (df_clean['Temperature'] <= 330)]\n\n# 온도 대 NDVI의 산점도 그리기\nplt.figure(figsize=(8, 6))\nsns.scatterplot(x='NDVI', y='Temperature', data=filtered_df, palette='coolwarm')\n\n# 선형 회귀 모델 적합\nslope, intercept = np.polyfit(filtered_df['NDVI'], filtered_df['Temperature'], 1)\n\n# 적합된 선 그리기\nx_line = np.linspace(min(filtered_df['NDVI']), max(filtered_df['NDVI']), 100)\ny_line = slope * x_line + intercept\nplt.plot(x_line, y_line, 'r', label='Fitted line')\n\n# 방정식 문자열 작성\nequation_str = f'y = {slope:.2f}x + {intercept:.2f}'\n\n# 그림에 방정식 표시\nplt.text(min(filtered_df['NDVI']), max(filtered_df['Temperature']), equation_str, fontsize=12, color='red')\n\n# 그림 제목과 축 레이블 설정\nplt.title('1-1. 온도 vs NDVI 그래프', fontsize=16, fontweight='bold')\nplt.xlabel('온도', fontsize=14)\nplt.ylabel('NDVI', fontsize=14)\n\n# 그림 표시\nplt.show()\n```\n\n결과는 다음과 같습니다:\n\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_10.png\" />\n\n<div class=\"content-ad\"></div>\n\n이제는 역상관 관계가 더 잘 보이고 있으며, NDVI 값과 온도 간 관계를 설명하는 방정식도 나와 있습니다.\n\n## 📐 열화상 이미지 선명하게하기 (1000m에서 10m)\n\n이번 단계에서는 1000m 해상도에서 집계된 NDVI와 온도 간의 관계를 발견한 방정식이 10m 해상도에도 유효할 수 있다고 가정할 것입니다. 이 방정식을 원래의 NDVI 지도에 적용하여 10m 해상도에서 온도를 추정할 수 있습니다.\n\n```js\nimport rasterio\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# NIR 및 RED 파일 열기\nwith rasterio.open('T10SFG_20230620T183919_B08_10m.jp2') as src:\n    nir = src.read(1)\n    meta = src.meta\n\nwith rasterio.open('T10SFG_20230620T183919_B04_10m.jp2') as src:\n    red = src.read(1)\n\n# NDVI 계산\nndvi = (nir - red) / (nir + red)\n\n# NDVI를 사용하여 온도 추정\ntemp = -21.85 * ndvi + 314.9\n\n# NDVI를위한 컬러 램프 만들기\nndvi_cmap = plt.cm.RdYlGn\n\n# NDVI 및 온도를 나란히 그리기\nfig, (ax1, ax2) = plt.subplots(ncols=2, figsize=(12, 6))\n\n# NDVI 그리기\nim1 = ax1.imshow(ndvi, cmap=ndvi_cmap, vmin=0, vmax=0.6)\nax1.set_title('NDVI', fontweight='bold', fontsize=14)\nfig.colorbar(im1, ax=ax1, shrink=0.7)\n\n# 온도 그리기\nim2 = ax2.imshow(temp, cmap=ndvi_cmap.reversed(), vmin=300, vmax=315)\nax2.set_title('Temperature', fontweight='bold', fontsize=14)\nfig.colorbar(im2, ax=ax2, shrink=0.7)\n\nplt.show()\n```\n\n<div class=\"content-ad\"></div>\n\nNIR 및 빨간색 대역을 읽어 NDVI를 계산하고 유도된 방정식에 기반하여 온도 값을 추정합니다. 다음으로, NDVI 및 온도에 대한 결과를 시각화하여 옆에 플롯을 표시합니다. 지도는 다음과 같습니다:\n\n![맵](/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_11.png)\n\n## 🗺️ 날카로워진 열 영상의 시각화\n\n이 섹션에서는 시각화 측면에 더욱 집중할 것입니다. 우리는 이미지의 중앙 영역을 확대하고, 이미지를 중앙을 기준으로 자릅니다. 또한 온도 차트를 제시하기 위해 Sentinel-2의 NDVI 지도, 원본 Sentinel-3 열 영상(1000m 해상도) 및 분석 결과를 기반으로한 날카로운 Sentinel-3 영상(10m 해상도)을 비교 및 자세한 검토를 위해 옆에 함께 제시할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n```python\n# NDVI 및 온도를 옆으로 나란히 플로팅합니다\nfig, axs = plt.subplots(ncols=3, figsize=(15, 5))\n\n# NDVI 플로팅\nvmin, vmax = 0, 0.6\nndvi_subset = ndvi[int(0.75 * ndvi.shape[0]):, int(0.75 * ndvi.shape[1]):]\nim1 = axs[0].imshow(ndvi_subset, cmap=ndvi_cmap, vmin=vmin, vmax=vmax)\naxs[0].set_title('NDVI', fontweight='bold', fontsize=14)\naxs[0].set_xticks([])\naxs[0].set_yticks([])\nfig.colorbar(im1, ax=axs[0], shrink=0.7)\n\n# 온도 플로팅\nwith rasterio.open('Sentinel-3_L2_LST_reproj_32610_clipped.tif') as src:\n    original_temp = src.read(1)\n\nvmin, vmax = 300, 315\ntemp_subset = original_temp[int(0.75 * original_temp.shape[0]):, int(0.75 * original_temp.shape[1]):]\nim3 = axs[1].imshow(temp_subset, cmap=ndvi_cmap.reversed(), vmin=vmin, vmax=vmax)\naxs[1].set_title('Temperature', fontweight='bold', fontsize=14)\naxs[1].set_xticks([])\naxs[1].set_yticks([])\nfig.colorbar(im3, ax=axs[1], shrink=0.7)\n\nvmin, vmax = 300, 315\ntemp_subset = temp[int(0.75 * temp.shape[0]):, int(0.75 * temp.shape[1]):]\nim2 = axs[2].imshow(temp_subset, cmap=ndvi_cmap.reversed(), vmin=vmin, vmax=vmax)\naxs[2].set_title('Temperature', fontweight='bold', fontsize=14)\naxs[2].set_xticks([])\naxs[2].set_yticks([])\nfig.colorbar(im2, ax=axs[2], shrink=0.7)\n\n# 서브플롯 간 간격 조정\nfig.subplots_adjust(wspace=0.2)\n\nplt.show()\r\n```\n\n지도는:\n\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_12.png\" />\n\n## 📄 결론\n\n\n<div class=\"content-ad\"></div>\n\nVisible과 Near-Infrared (VNIR) 대역과 열 이미지 간의 직접적 상관 관계는 열 이미지의 해상도를 향상시키는 유용한 방법으로 입증되었습니다. 이 기술은 위성의 적절한 공간 해상도를 가진 위성이 없을 때 온도를 높은 공간 해상도로 추정하는 데 실용적으로 활용됩니다. 이 다운스케일링 방법은 고해상도 열지도가 필요할 때 유용한 도구로 작용하며 소규모 온도 변화에 대한 세부 정보를 제공합니다. 앞으로 더 많은 고급 열 센서를 갖춘 위성을 발사함에 따라 빈도가 더 높은 고해상도 열 이미지를 얻을 수 있게 될 것입니다. 그 전까지는 이 방법이 더 높은 해상도의 열 이미지를 구현하는 비용 효율적인 선택지로 남아 있습니다.\n\n## 📚 참고 자료\n\nCopernicus 센티넬 데이터 [2024] - 센티넬 데이터에 대한 정보\n\nCopernicus 서비스 정보 [2024] - Copernicus 서비스 정보에 관한 정보\n\n<div class=\"content-ad\"></div>\n\n아감, N., 쿠스타스, W. P., 앤더슨, M. C., 리, F., 닐, C. M. U. (2007). 열화상 이미지 공간 개선을 위한 식물 지수 기반 기술. Remote Sensing of Environment, 107(4), 545–558. ISSN 0034–4257.\n\n가오, F., 쿠스타스, W. P., 앤더슨, M. C. (2012). 육지 위의 열화상 위성 이미지 개선을 위한 데이터 마이닝 접근 방식. Remote Sensing, 4, 3287–3319.\n\n휴리나, H., 코헨, Y., 카르니엘리, A., 파노프, N., 쿠스타스, W. P., 아감, N. (2019). Sentinel-3 위성 이미지의 열화상 개선을 위한 TsHARP 유틸리티 평가. Remote Sensing, 11, 2304.\n\n📱 저와 더 다양한 콘텐츠를 공유하려면 다른 플랫폼에서 연락하세요! LinkedIn, ResearchGate, Github 및 Twitter.\n\n<div class=\"content-ad\"></div>\n\n여기 해당 링크를 통해 제공되는 관련 게시물들이 있습니다:","ogImage":{"url":"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_0.png"},"coverImage":"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_0.png","tag":["Tech"],"readingTime":17},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p><img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_0.png\" alt=\"image\"></p>\n<h1>목차</h1>\n<ul>\n<li>🌅 소개</li>\n<li>💾 Sentinel-3 (1000 m) 및 Sentinel-2 이미지 다운로드</li>\n<li>⚙️ Sentinel-3 이미지 처리</li>\n<li>🌡️ 온도-NDVI 공간</li>\n<li>📐 열화상 이미지 선명화 (1000 m에서 10 m)</li>\n<li>🗺️ 선명화된 열화상 이미지 시각화</li>\n<li>📄 결론</li>\n<li>📚 참고 자료</li>\n</ul>\n<h2>🌅 소개</h2>\n<div class=\"content-ad\"></div>\n<p>위성에서 촬영한 열화상 이미지를 축소하는 연구는 열화상 이미지를 제공하는 위성들의 공간 및 시간 해상도 사이의 상충 관계 때문에 광범위하게 연구되었습니다. 예를 들어, Landsat-8의 재방문 주기는 16일이며, 원래 열 해상도는 100미터입니다. 반면에 Sentinel-3은 매일 열화상 이미지를 제공할 수 있지만, 공간 해상도는 1000미터입니다.</p>\n<p><img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_1.png\" alt=\"이미지\"></p>\n<p>열화상 이미지의 굵은 해상도를 해결하는 한 가지 방법은 NASA의 Landsat-9와 같은 열 센서가 장착된 추가 위성을 발사하는 것일 수 있습니다. Landsat-9의 경우, Landsat-8과 Landsat-9의 임시 해상도는 8일입니다 (하나의 위성보다는 16일), 맑은 하늘을 전제로 할 때.</p>\n<p>그러나 이 접근 방식은 수십억 달러의 투자와 몇 년의 노력이 필요합니다. 대신, 연구자들은 통계적 방법에 집중하여, 공간 해상도는 높지만 임시 해상도는 낮은 위성의 시정/근적외선 (VNIR) 밴드를 열화상 이미지와 상관시킴으로써 열화상 이미지의 낮은 공간 해상도 (하지만 높은 임시 해상도)와 연관시키는데 초점을 맞추었습니다. 예를 들어, 연구들은 Sentinel-2의 VNIR 밴드로부터 계산된 정규화 된 차이 채취 지수 (NDVI)가 Sentinel-3의 열화상 이미지와 역 상관 관계가 있음을 보여주었습니다.</p>\n<div class=\"content-ad\"></div>\n<p>답변을 요약하면 Sentinel-2의 NDVI와 Sentinel-3의 열화상 이미지 간의 상관 관계가 충분히 강하다면, 해당 방정식을 10m 해상도로 조정하여 10m 해상도의 열화상 이미지를 생성할 수 있습니다.</p>\n<p>위성 대역과 센서 스펙트럼에 대해 자세히 알고 싶다면 다음을 참조하십시오:</p>\n<p>이 게시물에서는 Sentinel-3로부터 낮은 공간 해상도 열화상 이미지와 Sentinel-2로부터 높은 공간 해상도 VNIR 이미지를 다운로드할 것입니다. 이 두 이미지는 각각의 위성에 의해 동시에 촬영되었습니다. 그런 다음, VNIR 대역을 사용하여 NDVI를 계산하고((NIR-Red)/(NIR+Red)), 이를 1000m로 업스케일하고 NDVI와 열대 대역 간의 상관 관계(둘 다 1000m 해상도)를 탐색할 것입니다. 마지막으로, 이 상관 관계를 사용하여 10m 해상도의 온도 지도를 생성할 것입니다.</p>\n<h2>💾 Sentinel-3(1000 m) 및 Sentinel-2 이미지(10 m) 다운로드</h2>\n<div class=\"content-ad\"></div>\n<p>이미 R 및 Python에서 Sentinel-2 이미지를 다운로드하는 방법에 대해 세 번의 게시물을 작성했습니다. 또한 Python에서 Sentinel-3 이미지를 다운로드하는 방법에 대한 게시물도 있습니다. 이곳에서는 해당 단계들을 반복하고 싶지 않아서 이 게시물을 참조하시기 바랍니다:</p>\n<p>R에서 Sentinel-2 이미지 다운로드:</p>\n<p>Python에서 Sentinel-2 이미지 다운로드:</p>\n<p>Python에서 Sentinel-3 이미지 다운로드:</p>\n<div class=\"content-ad\"></div>\n<p>만약 코드를 작성하지 않고 이미지를 다운로드하고 싶지 않다면, 다음 게시물을 확인해보세요:</p>\n<p>열화상 이미지를 축소화하기 위한 통계적 방법을 적용하는 중요한 단계는 위성에서 동시에 촬영된 선명한 이미지를 찾는 것입니다. 이미지를 다운로드하기 전에 날짜, 구름 양, 그리고 귀하의 관심 지역(AOI)에 기반하여 메타데이터를 필터링할 수 있습니다. Sentinel 메타데이터(관심 지역, 구름 양 등)를 필터링하고 처리하는 방법을 더 알고 싶다면 다음을 참조해보세요:</p>\n<p>이 게시물에서, 제 관심 지역(AOI)는 캘리포니아에 위치하며, 2023년 6월 19일에 Sentinel-2 및 Sentinel-3로 촬영된 선명한 이미지를 발견했습니다. 다른 위치나 날짜를 검색하고 싶다면 자유롭게 찾아보세요. 그러나 제가 다운로드한 이미지를 사용하길 원한다면, 다음 정보가 있습니다:</p>\n<p>Sentinel-2: S2B_MSIL2A_20230620T183919_N0509_R070_T10SFG_20230620T224951</p>\n<div class=\"content-ad\"></div>\n<p>satellite = “SENTINEL-2”</p>\n<p>level = “S2MSI2A”</p>\n<p>AOI = “POLYGON ((-121.0616 37.6391, -120.966 37.6391, -120.966 37.6987, -121.0616 37.6987, -121.0616 37.6391))”</p>\n<p>start_date = “2023–06–19” ; end_date = “2023–06–21”</p>\n<div class=\"content-ad\"></div>\n<p>satellite = “SENTINEL-3”</p>\n<p>level= “LST”</p>\n<p>AOI = “POLYGON ((-121.0616 37.6391, -120.966 37.6391, -120.966 37.6987, -121.0616 37.6987, -121.0616 37.6391))”</p>\n<div class=\"content-ad\"></div>\n<p>start_date = “2023–06–19” ; end_date = “2023–06–21”</p>\n<p>Sentinel-2에서 NIR 및 레드 밴드(NDVI를 계산하는 데 필요한 밴드)를 10m로 다운로드한 후 Sentinel-3에서 열화상 이미지를 다운로드하면 디렉토리에 이 세 파일이 있어야 합니다:</p>\n<p><img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_2.png\" alt=\"Image\"></p>\n<h2>⚙️ Sentinel-3 이미지 처리</h2>\n<div class=\"content-ad\"></div>\n<p>Sentinel-3 이미지는 Sentinel-2보다 훨씬 넓은 장면을 커버합니다. 따라서 Sentinel-3 각 픽셀의 평균 NDVI 값을 필요로 하므로 Sentinel-3 이미지를 Sentinel-2 이미지의 범위에 따라 클리핑해야 합니다. 이를 위해 첫 번째 단계는 Sentinel-3 이미지를 Sentinel-2 이미지와 동일한 투영으로 재매핑하는 것입니다. 이를 수행하기 위해 다음과 같은 코드를 사용할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> rasterio\n<span class=\"hljs-keyword\">from</span> rasterio.<span class=\"hljs-property\">warp</span> <span class=\"hljs-keyword\">import</span> calculate_default_transform, reproject, <span class=\"hljs-title class_\">Resampling</span>\n<span class=\"hljs-keyword\">from</span> pyproj <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Transformer</span>\n\ninput_raster = <span class=\"hljs-string\">'Sentinel-3_L2_LST_reproj.tif'</span>\noutput_raster = <span class=\"hljs-string\">'Sentinel-3_L2_LST_reproj_32610.tif'</span>\ndst_crs = <span class=\"hljs-string\">'EPSG:32610'</span>\n\n# 입력 래스터 파일 읽기\n<span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-title function_\">open</span>(input_raster) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">src</span>:\n    # 목적지 <span class=\"hljs-variable constant_\">CRS</span>에 대한 변환, 너비 및 높이 가져오기\n    transform, width, height = <span class=\"hljs-title function_\">calculate_default_transform</span>(src.<span class=\"hljs-property\">crs</span>, dst_crs, src.<span class=\"hljs-property\">width</span>, src.<span class=\"hljs-property\">height</span>, *src.<span class=\"hljs-property\">bounds</span>)\n\n    # 목적지 설정\n    kwargs = src.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-title function_\">copy</span>()\n    kwargs.<span class=\"hljs-title function_\">update</span>({\n        <span class=\"hljs-string\">'crs'</span>: dst_crs,\n        <span class=\"hljs-string\">'transform'</span>: transform,\n        <span class=\"hljs-string\">'width'</span>: width,\n        <span class=\"hljs-string\">'height'</span>: height,\n        <span class=\"hljs-string\">'dtype'</span>: np.<span class=\"hljs-property\">float32</span>,\n    })\n\n    # 목적지 생성 및 재매핑된 데이터 작성\n    <span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-title function_\">open</span>(output_raster, <span class=\"hljs-string\">'w'</span>, **kwargs) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">dst</span>:\n        # 재매핑 수행\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">range</span>(<span class=\"hljs-number\">1</span>, src.<span class=\"hljs-property\">count</span> + <span class=\"hljs-number\">1</span>):\n            <span class=\"hljs-title function_\">reproject</span>(\n                source=src.<span class=\"hljs-title function_\">read</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">astype</span>(np.<span class=\"hljs-property\">float32</span>) * src.<span class=\"hljs-property\">scales</span>[<span class=\"hljs-number\">0</span>] + src.<span class=\"hljs-property\">offsets</span>[<span class=\"hljs-number\">0</span>],\n                destination=rasterio.<span class=\"hljs-title function_\">band</span>(dst, i),\n                src_transform=src.<span class=\"hljs-property\">transform</span>,\n                src_crs=src.<span class=\"hljs-property\">crs</span>,\n                dst_transform=transform,\n                dst_crs=dst_crs,\n                resampling=<span class=\"hljs-title class_\">Resampling</span>.<span class=\"hljs-property\">bilinear</span>)\n</code></pre>\n<p>이 스크립트에서는 이전 단계에서 다운로드한 Sentinel-3 래스터 이미지를 읽고, 지정된 CRS로 재매핑하기 위한 변환 매개변수를 계산하고, 재매핑된 데이터를 포함한 새로운 래스터 파일을 내보냅니다. 이러한 단계를 거치면 디렉토리에 다음 네 가지 파일이 있어야 합니다:</p>\n<p><img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_3.png\" alt=\"image\"></p>\n<div class=\"content-ad\"></div>\n<p>Sentinel-3 열화상 이미지가 Sentinel-2 좌표 시스템으로 변경되었으므로 이제 Sentinel-2 데이터 범위를 기반으로 열화상 이미지를 잘라내는 작업을 할 수 있습니다. 아래 코드를 사용하여 작업할 수 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> rasterio\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n\n# 두 래스터 파일 열기\n<span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">'T10SFG_20230620T183919_B08_10m.jp2'</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">small_raster</span>:\n    <span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">'Sentinel-3_L2_LST_reproj_32610.tif'</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">big_raster</span>:\n\n        # 더 작은 래스터의 범위 가져오기\n        min_x, min_y, max_x, max_y = small_raster.<span class=\"hljs-property\">bounds</span>\n\n        # 더 큰 래스터에서 더 작은 래스터의 범위 내의 데이터 읽기\n        <span class=\"hljs-variable language_\">window</span> = rasterio.<span class=\"hljs-property\">windows</span>.<span class=\"hljs-title function_\">from_bounds</span>(min_x, min_y, max_x, max_y, big_raster.<span class=\"hljs-property\">transform</span>)\n        data = big_raster.<span class=\"hljs-title function_\">read</span>(<span class=\"hljs-variable language_\">window</span>=<span class=\"hljs-variable language_\">window</span>)\n\n        # 더 큰 래스터의 메타데이터 업데이트하여 더 작은 래스터의 범위와 일치시키기\n        clipped_meta = big_raster.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-title function_\">copy</span>()\n        clipped_meta.<span class=\"hljs-title function_\">update</span>({\n            <span class=\"hljs-string\">'height'</span>: <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">height</span>,\n            <span class=\"hljs-string\">'width'</span>: <span class=\"hljs-variable language_\">window</span>.<span class=\"hljs-property\">width</span>,\n            <span class=\"hljs-string\">'transform'</span>: rasterio.<span class=\"hljs-property\">windows</span>.<span class=\"hljs-title function_\">transform</span>(<span class=\"hljs-variable language_\">window</span>, big_raster.<span class=\"hljs-property\">transform</span>),\n            <span class=\"hljs-string\">'dtype'</span>: data.<span class=\"hljs-property\">dtype</span>\n        })\n\n        # 잘라낸 데이터 쓰기\n        <span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">'Sentinel-3_L2_LST_reproj_32610_clipped.tif'</span>, <span class=\"hljs-string\">'w'</span>, **clipped_meta) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">clipped_raster</span>:\n            clipped_raster.<span class=\"hljs-title function_\">write</span>(data)\n</code></pre>\n<p>이 스크립트에서는 두 래스터 파일(Sentinle-3 및 Sentinel-2 이미지)을 읽고, 더 작은 래스터의 범위(Sentinel-2)를 추출하고, 더 큰 래스터(Sentinle-3 열화상 이미지)에서 해당 데이터를 읽어와서 잘라낸 Sentinle-3의 메타데이터를 Sentinel-2 이미지와 일치하도록 업데이트한 후, 잘라낸 열화상 이미지를 새 TIFF 파일에 작성합니다.</p>\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_4.png\">\n<div class=\"content-ad\"></div>\n<p>NDVI 및 클리핑된 온도 맵을 옆으로 나란히 플롯해 봅시다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> matplotlib.<span class=\"hljs-property\">pyplot</span> <span class=\"hljs-keyword\">as</span> plt\n<span class=\"hljs-keyword\">import</span> rasterio\n<span class=\"hljs-keyword\">from</span> rasterio.<span class=\"hljs-property\">plot</span> <span class=\"hljs-keyword\">import</span> show\n\n# 파일 경로\nred_path = <span class=\"hljs-string\">'/content/T10SFG_20230620T183919_B04_10m.jp2'</span>\nnir_path = <span class=\"hljs-string\">'/content/T10SFG_20230620T183919_B08_10m.jp2'</span>\n\nclipped_temperature_path = <span class=\"hljs-string\">'/content/Sentinel-3_L2_LST_reproj_32610_clipped.tif'</span>\n\n# 래스터 데이터 읽기\n<span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-title function_\">open</span>(red_path) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">red_src</span>:\n  red = red_src.<span class=\"hljs-title function_\">read</span>(<span class=\"hljs-number\">1</span>)\n\n<span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-title function_\">open</span>(nir_path) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">nir_src</span>:\n  nir = nir_src.<span class=\"hljs-title function_\">read</span>(<span class=\"hljs-number\">1</span>)\n\n<span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-title function_\">open</span>(clipped_temperature_path) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">clipped_temp_ds</span>:\n  clipped_temperature = clipped_temp_ds.<span class=\"hljs-title function_\">read</span>(<span class=\"hljs-number\">1</span>)\n\n# <span class=\"hljs-variable constant_\">NDVI</span> 계산\nndvi = (nir - red) / (nir + red)\n\n# <span class=\"hljs-variable constant_\">NDVI</span>와 온도를 옆으로 플롯\nfig, (ax1,ax2) = plt.<span class=\"hljs-title function_\">subplots</span>(ncols=<span class=\"hljs-number\">2</span>, figsize=(<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">6</span>))\n\n# <span class=\"hljs-variable constant_\">NDVI</span> 플롯\nim1 = ax1.<span class=\"hljs-title function_\">imshow</span>(ndvi, cmap=ndvi_cmap, vmin=<span class=\"hljs-number\">0</span>, vmax=<span class=\"hljs-number\">0.6</span>)\nax1.<span class=\"hljs-title function_\">set_title</span>(<span class=\"hljs-string\">'NDVI'</span>, fontweight=<span class=\"hljs-string\">'bold'</span>, fontsize=<span class=\"hljs-number\">14</span>)\nfig.<span class=\"hljs-title function_\">colorbar</span>(im1, ax=ax1, shrink=<span class=\"hljs-number\">0.5</span>)\n\n# 클리핑된 온도 플롯\nim2= ax2.<span class=\"hljs-title function_\">imshow</span>(clipped_temperature, cmap=ndvi_cmap.<span class=\"hljs-title function_\">reversed</span>(), vmin=<span class=\"hljs-number\">300</span>, vmax=<span class=\"hljs-number\">315</span>)\nax2.<span class=\"hljs-title function_\">set_title</span>(<span class=\"hljs-string\">'Clipped Temperature'</span>, fontweight=<span class=\"hljs-string\">'bold'</span>, fontsize=<span class=\"hljs-number\">14</span>)\nfig.<span class=\"hljs-title function_\">colorbar</span>(im2, ax=ax2, shrink=<span class=\"hljs-number\">0.5</span>)\nplt.<span class=\"hljs-title function_\">show</span>()\n</code></pre>\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_5.png\">\n<p>위와 같이 Sentinel-3 열화상 이미지를 Sentinel-2 맵의 범위에 맞게 성공적으로 클립했습니다. 그러나 Sentinel-2 이미지도 잘린 상태이며, 온도 픽셀의 평균 NDVI 값을 얻기 위해 존속 통계를 실행하면 많은 NaN 값을 얻게 됩니다.</p>\n<div class=\"content-ad\"></div>\n<p><img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_6.png\" alt=\"이미지\"></p>\n<p>다음 단계에서 데이터프레임에서 NaN 값을 제외하여 수정할 것입니다.</p>\n<h2>🌡️ 온도-NDVI 공간</h2>\n<p>같은 투영 및 범위를 갖는 두 개의 명확한 이미지, 즉 센티넬-3에서의 열화상 이미지와 센티넬-2에서의 VNIR 이미지가 있을 때, 각 온도 픽셀의 평균 NDVI 값을 얻기 위해 존 채택 통계를 실행할 수 있습니다. 기본적으로 존 채택 통계 방식을 통해 10m에서 1000m로 NDVI 지도를 집계하여 온도-NDVI 공간에서 온도 값에 대한 NDVI 값을 플로팅할 수 있습니다.</p>\n<div class=\"content-ad\"></div>\n<p>소개에서 언급했듯이 열값은 NDVI 값과는 역상관 관계에 있어야 합니다. 높은 NDVI는 식물의 비율이 더 높은 것을 나타내며 더 차가운 픽셀에 해당하고, 낮은 NDVI는 적은 식물이나 벌거벗은 토양에 해당하여 더 따뜻한 픽셀에 해당합니다. 우리의 AOI(관심 영역)에서 열과 NDVI 값 사이의 공간을 탐색하기 위해 존솔 통계를 수행해 보겠습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> rasterio\n<span class=\"hljs-keyword\">import</span> rasterio.<span class=\"hljs-property\">features</span>\n<span class=\"hljs-keyword\">import</span> rasterio.<span class=\"hljs-property\">mask</span>\n<span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n<span class=\"hljs-keyword\">import</span> geopandas <span class=\"hljs-keyword\">as</span> gpd\n<span class=\"hljs-keyword\">import</span> rasterstats\n\n<span class=\"hljs-keyword\">import</span> rasterio\n<span class=\"hljs-keyword\">from</span> rasterio.<span class=\"hljs-property\">features</span> <span class=\"hljs-keyword\">import</span> shapes\nmask = <span class=\"hljs-title class_\">None</span>\n\n# 입력 래스터 열기\n<span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">'Sentinel-3_L2_LST_reproj_32610_clipped.tif'</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">src</span>:\n    # 래스터 밴드 읽기\n    image = src.<span class=\"hljs-title function_\">read</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">astype</span>(np.<span class=\"hljs-property\">float32</span>) * src.<span class=\"hljs-property\">scales</span>[<span class=\"hljs-number\">0</span>] + src.<span class=\"hljs-property\">offsets</span>[<span class=\"hljs-number\">0</span>]\n    results = (\n        {<span class=\"hljs-string\">'properties'</span>: {<span class=\"hljs-string\">'Temperature'</span>: v}, <span class=\"hljs-string\">'geometry'</span>: s}\n        <span class=\"hljs-keyword\">for</span> i, (s, v)\n        <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title function_\">enumerate</span>(\n            <span class=\"hljs-title function_\">shapes</span>(image, mask=mask, transform=src.<span class=\"hljs-property\">transform</span>)))\n    geoms = <span class=\"hljs-title function_\">list</span>(results)\n    gpd_polygonized_raster = gpd.<span class=\"hljs-property\">GeoDataFrame</span>.<span class=\"hljs-title function_\">from_features</span>(geoms)\n\n# 래스터 열기\n<span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">'T10SFG_20230620T183919_B08_10m.jp2'</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">nir_src</span>:\n    <span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">'T10SFG_20230620T183919_B04_10m.jp2'</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">red_src</span>:\n\n        # 데이터를 float32로 읽기\n        nir = nir_src.<span class=\"hljs-title function_\">read</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">astype</span>(np.<span class=\"hljs-property\">float32</span>) * nir_src.<span class=\"hljs-property\">scales</span>[<span class=\"hljs-number\">0</span>] + nir_src.<span class=\"hljs-property\">offsets</span>[<span class=\"hljs-number\">0</span>]\n        red = red_src.<span class=\"hljs-title function_\">read</span>(<span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">astype</span>(np.<span class=\"hljs-property\">float32</span>) * red_src.<span class=\"hljs-property\">scales</span>[<span class=\"hljs-number\">0</span>] + red_src.<span class=\"hljs-property\">offsets</span>[<span class=\"hljs-number\">0</span>]\n\n        # <span class=\"hljs-variable constant_\">NDVI</span> 계산\n        ndvi = (nir - red) / (nir + red)\n\n        # 각 다각형에 대한 존솔 통계 계산\n        stats = rasterstats.<span class=\"hljs-title function_\">zonal_stats</span>(gpd_polygonized_raster.<span class=\"hljs-property\">geometry</span>, ndvi, affine=nir_src.<span class=\"hljs-property\">transform</span>, stats=<span class=\"hljs-string\">'mean'</span>)\n\n        # <span class=\"hljs-variable constant_\">NDVI</span>의 평균값을 데이터프레임에 추가\n        gpd_polygonized_raster[<span class=\"hljs-string\">'NDVI'</span>] = [s[<span class=\"hljs-string\">'mean'</span>] <span class=\"hljs-keyword\">for</span> s <span class=\"hljs-keyword\">in</span> stats]\n\n# 다각형 레이어를 shapefile로 저장\ngpd_polygonized_raster.<span class=\"hljs-title function_\">to_file</span>(<span class=\"hljs-string\">'output_polygons.shp'</span>)\n\n# geodataframe로부터 pandas 데이터프레임 생성\nstats_df = pd.<span class=\"hljs-title class_\">DataFrame</span>(gpd_polygonized_raster.<span class=\"hljs-title function_\">drop</span>(columns=<span class=\"hljs-string\">'geometry'</span>))\n\n# 데이터프레임 출력\n<span class=\"hljs-title function_\">print</span>(stats_df)\n</code></pre>\n<p>이 스크립트에서는 열 래스터를 여각화하고, Sentinel-2 이미지에서 NDVI를 계산하고, 각 온도 픽셀에 대한 존솔 통계(평균 NDVI)를 계산합니다.</p>\n<div class=\"content-ad\"></div>\n<p>위 표와 이전에 논의한 것처럼, Sentinel-3에서 열화 데이터를 가지고 있는 일부 픽셀에는 NaN 값이 있습니다. 이는 Sentinel-2 이미지의 자른 부분 때문입니다. Sentinel-2에서 NaN 값을 가진 행을 제외하겠습니다:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-comment\"># NaN 값이 있는 행 삭제</span>\ndf_clean = stats_df.dropna(subset=[<span class=\"hljs-string\">'NDVI'</span>])\ndf_clean\n</code></pre>\n<p>결과는 다음과 같습니다:</p>\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_8.png\">\n<div class=\"content-ad\"></div>\n<p>이 깔끔한 데이터프레임을 사용하여 온도-NDVI 공간을 그래프로 표현할 수 있어요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> matplotlib.<span class=\"hljs-property\">pyplot</span> <span class=\"hljs-keyword\">as</span> plt\n<span class=\"hljs-keyword\">import</span> seaborn <span class=\"hljs-keyword\">as</span> sns\n<span class=\"hljs-keyword\">from</span> scipy.<span class=\"hljs-property\">stats</span> <span class=\"hljs-keyword\">import</span> linregress\n\n# 산점도 생성\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>))\nsns.<span class=\"hljs-title function_\">scatterplot</span>(x=<span class=\"hljs-string\">'NDVI'</span>, y=<span class=\"hljs-string\">'Temperature'</span>, data=df_clean, palette=<span class=\"hljs-string\">'coolwarm'</span>)\n\n# 그래프 제목 및 축 레이블 설정\nplt.<span class=\"hljs-title function_\">title</span>(<span class=\"hljs-string\">'NDVI 대 온도 그래프'</span>, fontsize=<span class=\"hljs-number\">16</span>, fontweight=<span class=\"hljs-string\">'bold'</span>)\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'NDVI'</span>, fontsize=<span class=\"hljs-number\">14</span>)\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'Temperature'</span>, fontsize=<span class=\"hljs-number\">14</span>)\n\n# 그래프 보여주기\nplt.<span class=\"hljs-title function_\">show</span>()\n</code></pre>\n<p>결과는 다음과 같아요:</p>\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_9.png\">\n<div class=\"content-ad\"></div>\n<p>위 그림에서 NDVI와 온도 사이의 역상관 관계를 관찰할 수 있지만 몇 가지 점이 이상치로 나타납니다. 이는 식물 및 맨 소토 외의 다른 특징을 나타내는 이미지의 픽셀 때문일 수 있습니다. 이러한 픽셀을 제거하기 위해 NDVI 값이 0.1에서 0.6 사이이고 온도 값이 300 켈빈에서 330 켈빈 사이인 값만 유지한 다음, 그에 맞게 그림을 업데이트하겠습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> matplotlib.<span class=\"hljs-property\">pyplot</span> <span class=\"hljs-keyword\">as</span> plt\n<span class=\"hljs-keyword\">import</span> seaborn <span class=\"hljs-keyword\">as</span> sns\n<span class=\"hljs-keyword\">from</span> scipy.<span class=\"hljs-property\">stats</span> <span class=\"hljs-keyword\">import</span> linregress\n\n# 지정된 조건에 기반하여 데이터프레임 필터링\nfiltered_df = df_clean[(df_clean[<span class=\"hljs-string\">'NDVI'</span>] >= <span class=\"hljs-number\">0.1</span>) &#x26; (df_clean[<span class=\"hljs-string\">'NDVI'</span>] &#x3C;= <span class=\"hljs-number\">0.6</span>) &#x26;\n                 (df_clean[<span class=\"hljs-string\">'Temperature'</span>] >= <span class=\"hljs-number\">300</span>) &#x26; (df_clean[<span class=\"hljs-string\">'Temperature'</span>] &#x3C;= <span class=\"hljs-number\">330</span>)]\n\n# 온도 대 <span class=\"hljs-variable constant_\">NDVI</span>의 산점도 그리기\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>))\nsns.<span class=\"hljs-title function_\">scatterplot</span>(x=<span class=\"hljs-string\">'NDVI'</span>, y=<span class=\"hljs-string\">'Temperature'</span>, data=filtered_df, palette=<span class=\"hljs-string\">'coolwarm'</span>)\n\n# 선형 회귀 모델 적합\nslope, intercept = np.<span class=\"hljs-title function_\">polyfit</span>(filtered_df[<span class=\"hljs-string\">'NDVI'</span>], filtered_df[<span class=\"hljs-string\">'Temperature'</span>], <span class=\"hljs-number\">1</span>)\n\n# 적합된 선 그리기\nx_line = np.<span class=\"hljs-title function_\">linspace</span>(<span class=\"hljs-title function_\">min</span>(filtered_df[<span class=\"hljs-string\">'NDVI'</span>]), <span class=\"hljs-title function_\">max</span>(filtered_df[<span class=\"hljs-string\">'NDVI'</span>]), <span class=\"hljs-number\">100</span>)\ny_line = slope * x_line + intercept\nplt.<span class=\"hljs-title function_\">plot</span>(x_line, y_line, <span class=\"hljs-string\">'r'</span>, label=<span class=\"hljs-string\">'Fitted line'</span>)\n\n# 방정식 문자열 작성\nequation_str = f<span class=\"hljs-string\">'y = {slope:.2f}x + {intercept:.2f}'</span>\n\n# 그림에 방정식 표시\nplt.<span class=\"hljs-title function_\">text</span>(<span class=\"hljs-title function_\">min</span>(filtered_df[<span class=\"hljs-string\">'NDVI'</span>]), <span class=\"hljs-title function_\">max</span>(filtered_df[<span class=\"hljs-string\">'Temperature'</span>]), equation_str, fontsize=<span class=\"hljs-number\">12</span>, color=<span class=\"hljs-string\">'red'</span>)\n\n# 그림 제목과 축 레이블 설정\nplt.<span class=\"hljs-title function_\">title</span>(<span class=\"hljs-string\">'1-1. 온도 vs NDVI 그래프'</span>, fontsize=<span class=\"hljs-number\">16</span>, fontweight=<span class=\"hljs-string\">'bold'</span>)\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'온도'</span>, fontsize=<span class=\"hljs-number\">14</span>)\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'NDVI'</span>, fontsize=<span class=\"hljs-number\">14</span>)\n\n# 그림 표시\nplt.<span class=\"hljs-title function_\">show</span>()\n</code></pre>\n<p>결과는 다음과 같습니다:</p>\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_10.png\">\n<div class=\"content-ad\"></div>\n<p>이제는 역상관 관계가 더 잘 보이고 있으며, NDVI 값과 온도 간 관계를 설명하는 방정식도 나와 있습니다.</p>\n<h2>📐 열화상 이미지 선명하게하기 (1000m에서 10m)</h2>\n<p>이번 단계에서는 1000m 해상도에서 집계된 NDVI와 온도 간의 관계를 발견한 방정식이 10m 해상도에도 유효할 수 있다고 가정할 것입니다. 이 방정식을 원래의 NDVI 지도에 적용하여 10m 해상도에서 온도를 추정할 수 있습니다.</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> rasterio\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> matplotlib.<span class=\"hljs-property\">pyplot</span> <span class=\"hljs-keyword\">as</span> plt\n\n# <span class=\"hljs-variable constant_\">NIR</span> 및 <span class=\"hljs-variable constant_\">RED</span> 파일 열기\n<span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">'T10SFG_20230620T183919_B08_10m.jp2'</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">src</span>:\n    nir = src.<span class=\"hljs-title function_\">read</span>(<span class=\"hljs-number\">1</span>)\n    meta = src.<span class=\"hljs-property\">meta</span>\n\n<span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-title function_\">open</span>(<span class=\"hljs-string\">'T10SFG_20230620T183919_B04_10m.jp2'</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-attr\">src</span>:\n    red = src.<span class=\"hljs-title function_\">read</span>(<span class=\"hljs-number\">1</span>)\n\n# <span class=\"hljs-variable constant_\">NDVI</span> 계산\nndvi = (nir - red) / (nir + red)\n\n# <span class=\"hljs-variable constant_\">NDVI</span>를 사용하여 온도 추정\ntemp = -<span class=\"hljs-number\">21.85</span> * ndvi + <span class=\"hljs-number\">314.9</span>\n\n# <span class=\"hljs-variable constant_\">NDVI</span>를위한 컬러 램프 만들기\nndvi_cmap = plt.<span class=\"hljs-property\">cm</span>.<span class=\"hljs-property\">RdYlGn</span>\n\n# <span class=\"hljs-variable constant_\">NDVI</span> 및 온도를 나란히 그리기\nfig, (ax1, ax2) = plt.<span class=\"hljs-title function_\">subplots</span>(ncols=<span class=\"hljs-number\">2</span>, figsize=(<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">6</span>))\n\n# <span class=\"hljs-variable constant_\">NDVI</span> 그리기\nim1 = ax1.<span class=\"hljs-title function_\">imshow</span>(ndvi, cmap=ndvi_cmap, vmin=<span class=\"hljs-number\">0</span>, vmax=<span class=\"hljs-number\">0.6</span>)\nax1.<span class=\"hljs-title function_\">set_title</span>(<span class=\"hljs-string\">'NDVI'</span>, fontweight=<span class=\"hljs-string\">'bold'</span>, fontsize=<span class=\"hljs-number\">14</span>)\nfig.<span class=\"hljs-title function_\">colorbar</span>(im1, ax=ax1, shrink=<span class=\"hljs-number\">0.7</span>)\n\n# 온도 그리기\nim2 = ax2.<span class=\"hljs-title function_\">imshow</span>(temp, cmap=ndvi_cmap.<span class=\"hljs-title function_\">reversed</span>(), vmin=<span class=\"hljs-number\">300</span>, vmax=<span class=\"hljs-number\">315</span>)\nax2.<span class=\"hljs-title function_\">set_title</span>(<span class=\"hljs-string\">'Temperature'</span>, fontweight=<span class=\"hljs-string\">'bold'</span>, fontsize=<span class=\"hljs-number\">14</span>)\nfig.<span class=\"hljs-title function_\">colorbar</span>(im2, ax=ax2, shrink=<span class=\"hljs-number\">0.7</span>)\n\nplt.<span class=\"hljs-title function_\">show</span>()\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>NIR 및 빨간색 대역을 읽어 NDVI를 계산하고 유도된 방정식에 기반하여 온도 값을 추정합니다. 다음으로, NDVI 및 온도에 대한 결과를 시각화하여 옆에 플롯을 표시합니다. 지도는 다음과 같습니다:</p>\n<p><img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_11.png\" alt=\"맵\"></p>\n<h2>🗺️ 날카로워진 열 영상의 시각화</h2>\n<p>이 섹션에서는 시각화 측면에 더욱 집중할 것입니다. 우리는 이미지의 중앙 영역을 확대하고, 이미지를 중앙을 기준으로 자릅니다. 또한 온도 차트를 제시하기 위해 Sentinel-2의 NDVI 지도, 원본 Sentinel-3 열 영상(1000m 해상도) 및 분석 결과를 기반으로한 날카로운 Sentinel-3 영상(10m 해상도)을 비교 및 자세한 검토를 위해 옆에 함께 제시할 것입니다.</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-comment\"># NDVI 및 온도를 옆으로 나란히 플로팅합니다</span>\nfig, axs = plt.subplots(ncols=<span class=\"hljs-number\">3</span>, figsize=(<span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">5</span>))\n\n<span class=\"hljs-comment\"># NDVI 플로팅</span>\nvmin, vmax = <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.6</span>\nndvi_subset = ndvi[<span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">0.75</span> * ndvi.shape[<span class=\"hljs-number\">0</span>]):, <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">0.75</span> * ndvi.shape[<span class=\"hljs-number\">1</span>]):]\nim1 = axs[<span class=\"hljs-number\">0</span>].imshow(ndvi_subset, cmap=ndvi_cmap, vmin=vmin, vmax=vmax)\naxs[<span class=\"hljs-number\">0</span>].set_title(<span class=\"hljs-string\">'NDVI'</span>, fontweight=<span class=\"hljs-string\">'bold'</span>, fontsize=<span class=\"hljs-number\">14</span>)\naxs[<span class=\"hljs-number\">0</span>].set_xticks([])\naxs[<span class=\"hljs-number\">0</span>].set_yticks([])\nfig.colorbar(im1, ax=axs[<span class=\"hljs-number\">0</span>], shrink=<span class=\"hljs-number\">0.7</span>)\n\n<span class=\"hljs-comment\"># 온도 플로팅</span>\n<span class=\"hljs-keyword\">with</span> rasterio.<span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">'Sentinel-3_L2_LST_reproj_32610_clipped.tif'</span>) <span class=\"hljs-keyword\">as</span> src:\n    original_temp = src.read(<span class=\"hljs-number\">1</span>)\n\nvmin, vmax = <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">315</span>\ntemp_subset = original_temp[<span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">0.75</span> * original_temp.shape[<span class=\"hljs-number\">0</span>]):, <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">0.75</span> * original_temp.shape[<span class=\"hljs-number\">1</span>]):]\nim3 = axs[<span class=\"hljs-number\">1</span>].imshow(temp_subset, cmap=ndvi_cmap.<span class=\"hljs-built_in\">reversed</span>(), vmin=vmin, vmax=vmax)\naxs[<span class=\"hljs-number\">1</span>].set_title(<span class=\"hljs-string\">'Temperature'</span>, fontweight=<span class=\"hljs-string\">'bold'</span>, fontsize=<span class=\"hljs-number\">14</span>)\naxs[<span class=\"hljs-number\">1</span>].set_xticks([])\naxs[<span class=\"hljs-number\">1</span>].set_yticks([])\nfig.colorbar(im3, ax=axs[<span class=\"hljs-number\">1</span>], shrink=<span class=\"hljs-number\">0.7</span>)\n\nvmin, vmax = <span class=\"hljs-number\">300</span>, <span class=\"hljs-number\">315</span>\ntemp_subset = temp[<span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">0.75</span> * temp.shape[<span class=\"hljs-number\">0</span>]):, <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">0.75</span> * temp.shape[<span class=\"hljs-number\">1</span>]):]\nim2 = axs[<span class=\"hljs-number\">2</span>].imshow(temp_subset, cmap=ndvi_cmap.<span class=\"hljs-built_in\">reversed</span>(), vmin=vmin, vmax=vmax)\naxs[<span class=\"hljs-number\">2</span>].set_title(<span class=\"hljs-string\">'Temperature'</span>, fontweight=<span class=\"hljs-string\">'bold'</span>, fontsize=<span class=\"hljs-number\">14</span>)\naxs[<span class=\"hljs-number\">2</span>].set_xticks([])\naxs[<span class=\"hljs-number\">2</span>].set_yticks([])\nfig.colorbar(im2, ax=axs[<span class=\"hljs-number\">2</span>], shrink=<span class=\"hljs-number\">0.7</span>)\n\n<span class=\"hljs-comment\"># 서브플롯 간 간격 조정</span>\nfig.subplots_adjust(wspace=<span class=\"hljs-number\">0.2</span>)\n\nplt.show()\n</code></pre>\n<p>지도는:</p>\n<img src=\"/assets/img/2024-06-22-DownscalingaSatelliteThermalImagefrom1000mto10mPython_12.png\">\n<h2>📄 결론</h2>\n<div class=\"content-ad\"></div>\n<p>Visible과 Near-Infrared (VNIR) 대역과 열 이미지 간의 직접적 상관 관계는 열 이미지의 해상도를 향상시키는 유용한 방법으로 입증되었습니다. 이 기술은 위성의 적절한 공간 해상도를 가진 위성이 없을 때 온도를 높은 공간 해상도로 추정하는 데 실용적으로 활용됩니다. 이 다운스케일링 방법은 고해상도 열지도가 필요할 때 유용한 도구로 작용하며 소규모 온도 변화에 대한 세부 정보를 제공합니다. 앞으로 더 많은 고급 열 센서를 갖춘 위성을 발사함에 따라 빈도가 더 높은 고해상도 열 이미지를 얻을 수 있게 될 것입니다. 그 전까지는 이 방법이 더 높은 해상도의 열 이미지를 구현하는 비용 효율적인 선택지로 남아 있습니다.</p>\n<h2>📚 참고 자료</h2>\n<p>Copernicus 센티넬 데이터 [2024] - 센티넬 데이터에 대한 정보</p>\n<p>Copernicus 서비스 정보 [2024] - Copernicus 서비스 정보에 관한 정보</p>\n<div class=\"content-ad\"></div>\n<p>아감, N., 쿠스타스, W. P., 앤더슨, M. C., 리, F., 닐, C. M. U. (2007). 열화상 이미지 공간 개선을 위한 식물 지수 기반 기술. Remote Sensing of Environment, 107(4), 545–558. ISSN 0034–4257.</p>\n<p>가오, F., 쿠스타스, W. P., 앤더슨, M. C. (2012). 육지 위의 열화상 위성 이미지 개선을 위한 데이터 마이닝 접근 방식. Remote Sensing, 4, 3287–3319.</p>\n<p>휴리나, H., 코헨, Y., 카르니엘리, A., 파노프, N., 쿠스타스, W. P., 아감, N. (2019). Sentinel-3 위성 이미지의 열화상 개선을 위한 TsHARP 유틸리티 평가. Remote Sensing, 11, 2304.</p>\n<p>📱 저와 더 다양한 콘텐츠를 공유하려면 다른 플랫폼에서 연락하세요! LinkedIn, ResearchGate, Github 및 Twitter.</p>\n<div class=\"content-ad\"></div>\n<p>여기 해당 링크를 통해 제공되는 관련 게시물들이 있습니다:</p>\n</body>\n</html>\n"},"__N_SSG":true}