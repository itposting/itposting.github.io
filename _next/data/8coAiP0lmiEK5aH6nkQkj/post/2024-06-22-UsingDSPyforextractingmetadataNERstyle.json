{"pageProps":{"post":{"title":"DSPy를 사용하여 메타데이터 추출하는 방법 - NER 스타일 가이드","description":"","date":"2024-06-22 20:47","slug":"2024-06-22-UsingDSPyforextractingmetadataNERstyle","content":"\n\nDSPy는 프로그래밍을 장려하는 \"선언적\" 방식을 통해 LLMs를 가르치는 것을 선호하여 커뮤니티에서 빠르게 큰 관심을 얻었습니다. 이 글에서는 DSPy를 사용하여 Named Entity Recognition (NER) 또는 구조화된 데이터 추출을 얼마나 쉽게 할 수 있는지 살펴보겠습니다. 이를 통해 자신감을 가지고 기능을 활용할 수 있습니다.\n\n자세한 내용은 아래의 원문을 확인해주세요:\n\n시작해봅시다 😎!\n\n# 소개\n\n<div class=\"content-ad\"></div>\n\n요즘 대형 언어 모델(Large Language Models, LLM)과 작업한 사람들은 프롬프트(prompt)의 중요성을 강조할 것입니다. 프롬프트를 조금만 바꿔도 출력물에 예상치 못한 변화가 연쇄적으로 발생할 수 있습니다. 또한 다른 LLM 제공업체 간에 프롬프트를 이전하거나 재사용하는 일이 까다로운 경우도 많습니다. 예를 들어, OpenAI에서 Claude 3를 통해 Antrophic을 사용하는 함수 호출 로직을 이동하는 경우 프롬프트를 재설계해야 할 필요가 있죠 😅.\n\n따라서 프롬프트를 다시 작성하고, 평가를 재평가하며, 출력물을 디버깅하는 데 많은 시간 ⏰을 투자해야 합니다. 이를 보다 똑똑하게 처리할 수 있는 방법이 있다면 좋을텐데요? 다행히도, DSPs와 같은 흥미로운 프레임워크는 LLM 제공자에 관계없이 프로그래밍에 중점을 둡니다. 자세한 내용은 참조할 자료에서 DSPy에 대해 더 깊이있게 알아볼 수 있습니다.\n\n# Declarative Self-Improving Language Programs (DSPy)\n\nDSPy 또는 선언적 자기 개선 언어 프로그램(Declarative Self-improving Language Programs, Khattab et al, 2023)은 처음으로 [2]에서 소개되었습니다. DSPy는 PyTorch와 같은 신경망 프레임워크에서 영감을 받아, 프롬프트보다는 프로그래밍에 중점을 둡니다.\n\n<div class=\"content-ad\"></div>\n\n간단히 말하자면, DSPy 프로그래밍 모델은 다음과 같은 추상화를 가지고 있습니다:\n\n- 필요한 손쓰기 프롬프트/세밀 조정을 대체할 서명.\n- Cot, REACT 등 다양한 프롬프트 엔지니어링 기술을 구현한 모듈.\n- 주어진 메트릭스를 기반으로 한 수동 프롬프트 엔지니어링을 자동화하는 옵티마이저\n\n더 자세한 설명은 참조 사항 중 [1]을 참고하십시오.\n\n# 음식 관련 엔티티에 DSPy를 사용한 NER\n\n<div class=\"content-ad\"></div>\n\n다음 섹션에서는 DSPy를 사용하여 NER 사용 사례를 살펴볼 것입니다.\n\n## 데이터\n\n사용할 데이터는 라면 🍜 한 그릇을 만들기 위한 차슈 돼지고기 레시피입니다. 아래 게시물에서 자세한 내용을 확인하세요:\n\n예시 데이터:\n\n<div class=\"content-ad\"></div>\n\n```js\n### 차슈 돼지고기 (라면 및 기타 용도)\n차슈 돼지고기는 라멘과 같은 일본 요리에 사용되는 돼지 배를 준비하는 전통적인 방법입니다.\n다소 시간이 걸릴 수 있지만 비교적 손쉽고 맛있는 결과물이 나옵니다.\n\n### 재료\n2 파운드의 돼지 배 또는 조금 더/적게\n2개의 대파 또는 작은 경우 3개\n1인치 크기의 생 생강 (약 4-6조각 나오는 양)\n2쪽의 마늘\n⅔컵의 사케\n⅔컵의 간장\n¼컵의 미린\n½컵의 설탕\n필요에 따라 조절 가능한 2컵의 물\n### 요령\n돼지고기를 준비하기 전에 줄 또는 부엌 실을 준비하고 가위 한 켤레를 준비하세요.\n해당 사항이 있다면 돼지고기의 외부 지방을 다듬어주세요. 그럼에도 불구하고 이후에는 여전히\n...\n```\n\n위의 데이터 외에도 TypedPredictor와 함께 사용할 Pydantic 데이터 모델을 설정해야 합니다:\n\n```js\nclass FoodMetaData(BaseModel):\n    reasoning: str = Field(description=\"엔티티가 정확한 이유\")\n    value: Union[str, int] = Field(description=\"엔티티의 값\")\n    entity: str = Field(description=\"실제 엔티티 즉, 돼지고기, 양파 등\")\n\nclass FoodMetaDatas(BaseModel):\n    context: List[FoodMetaData]\n```\n\n```js\nclass FoodEntity(BaseModel):\n    food: str = Field(description=\"유체 및 고체 음식, 즉 고기, 채소, 주류 등이 될 수 있습니다.\")\n    quantity: int = Field(description=\"레시피에 사용해야 하는 실제 양 또는 양\")\n    unit: str = Field(description=\"사용 중인 단위, 예를 들어 그램, 밀리리터, 파운드 등\")\n    physical_quality: Optional[str] = Field(description=\"재료의 특성\")\n    color: str = Field(description=\"음식의 색상\")\nclass FoodEntities(BaseModel):\n    entities: List[FoodEntity]\n```  \n\n<div class=\"content-ad\"></div>\n\n- FoodMetadatas는 각 엔티티의 컨텍스트 추출 + 추론 흐름의 일부입니다.\n- FoodEntities는 우리가 원하는 엔티티를 추출하는 데 사용됩니다.\n\n마지막으로, DSPy 프로그램이 옵티마이저를 위해 컴파일될 때, 우리는 dspy.Examplemodule을 사용하여 일부 훈련 예제를 만들 것입니다:\n\n```js\ntrainset = [\n    dspy.Example(\n        recipe=\"2개의 계란, 500그램 버터 및 10그램 그리르치즈로 프렌치 오믈렛 만들기\", \n        entities=[\n            FoodEntity(food=\"계란\", quantity=2, unit=\"\", physical_quality=\"\", color=\"흰색\"),\n            FoodEntity(food=\"버터\", quantity=500, unit=\"그램\", physical_quality=\"\", color=\"노랑\"),\n            FoodEntity(food=\"치즈\", quantity=10, unit=\"그램\", physical_quality=\"그리레\", color=\"노랑\")\n        ]\n    ).with_inputs(\"recipe\"),\n        ...\n    dspy.Example(\n        recipe=\"250g 밀가루, 1큰술 베이킹 파우더, 1그램 소금, 10g 설탕, 100ml 신선우유로 아메리칸 팬케이크 만들기\", \n        entities=[\n            FoodEntity(food=\"밀가루\", quantity=250, unit=\"그램\", physical_quality=\"\", color=\"흰색\"),\n            FoodEntity(food=\"베이킹 파우더\", quantity=1, unit=\"큰술\", physical_quality=\"\", color=\"흰색\"),\n            FoodEntity(food=\"소금\", quantity=1, unit=\"그램\", physical_quality=\"짠맛\", color=\"흰색\"),\n            FoodEntity(food=\"우유\", quantity=100, unit=\"밀\", physical_quality=\"지방\", color=\"흰색\"),\n        ]\n    ).with_inputs(\"recipe\")\n]\r\n```\n\n## 서명\n\n<div class=\"content-ad\"></div>\n\n데이터셋을 만들거나 수집한 후의 다음 단계는 DSPy 프로그램에 대한 서명을 작성하는 것입니다. 이것을 입력/출력 동작에 대한 선언적 명세로 생각할 수 있습니다:\n\n```js\nclass RecipeToFoodContext(dspy.Signature):\n    \"\"\"당신은 음식 AI 어시스턴트입니다. 엔티티, 엔티티의 값 및 추출된 값이 올바른 값인 이유를 추출하는 작업을 수행해야 합니다. \n    엔티티를 추출할 수 없는 경우 null을 추가하십시오\"\"\"\n    recipe: str = dspy.InputField()\n    context: FoodMetaDatas = dspy.OutputField()\n```\n\n```js\nclass RecipeToFoodEntities(dspy.Signature):\n    \"\"\"당신은 음식 AI 어시스턴트입니다. 레시피에서 음식과 관련된 메타데이터를 추출해야 합니다.\"\"\"\n    recipe: str = dspy.InputField()\n    entities: FoodEntities = dspy.OutputField()\n```\n\n- RecipeToFoodContext은 문맥 + 추론 호출에 사용되는 서명입니다. 여기에서 문자열 설명을 사용하여 LLM에 초기 지침을 제공했다는 점에 유의하십시오.\n- RecipeFoodEntities는 실제로 식별된 엔티티를 추출하는 서명에 해당합니다.\n\n<div class=\"content-ad\"></div>\n\n지금까지는 특별한 공학 작업이 아니라 Python 클래스/객체를 명시하는 것이었습니다 🐍. 코드는 또한 이해하기 비교적 쉽습니다. 무엇을 하는지, 입력이나 출력 등이 뭔지 잘 알 수 있죠.\n\n## Modules\n\n데이터셋을 생성하고 서명을 지정한 후에는 모듈을 작성할 준비가 되었습니다. 각 모듈은 Chain-of-Thought, ReAct 등 다양한 프롬프팅 기술을 \"추상화\"하는 멋진 기능이 있습니다. 또한 신경망 프레임워크에 익숙한 독자들을 위해 아래의 forward 메서드에 주목해주세요:\n\n```js\nclass ExtractFoodEntities(dspy.Module):\n    def __init__(self, temperature: int = 0, seed: int = 123):\n        super().__init__()\n        self.temperature = temperature\n        self.seed = seed\n        self.extract_food_context = dspy.TypedPredictor(RecipeToFoodContext)\n        self.extract_food_context_cot = dspy.TypedChainOfThought(RecipeToFoodContext)\n        self.extract_food_entities = dspy.TypedPredictor(RecipeToFoodEntities)\n        \n    def forward(self, recipe: str) -> FoodEntities:\n        food_context = self.extract_food_context(recipe=recipe).context\n        parsed_context = parse_context(food_context.context)\n        food_entities = self.extract_food_entities(recipe=parsed_context)\n        return food_entities.entities\n```\n\n<div class=\"content-ad\"></div>\n\n위 모듈은 dspy.Module 인터페이스를 사용하고 있습니다. dspy.Functional 인터페이스를 사용하여 모듈을 지정할 수도 있습니다:\n\n```js\nfrom dspy.functional import FunctionalModule, predictor, cot\n\nclass ExtractFoodEntitiesV2(FunctionalModule):\n    def __init__(self, temperature: int = 0, seed: int = 123):\n        super().__init__()\n        self.temperature = temperature\n        self.seed = seed\n    @predictor\n    def extract_food_context(self, recipe: str) -> FoodMetaData:\n        \"\"\"당신은 음식 AI 어시스턴트입니다. 엔티티, 엔티티의 값 및 추출된 값이 올바른 값인 이유를 추출하는 것이 작업입니다. \n        엔티티를 추출할 수 없는 경우 null을 추가하세요.\"\"\"\n        pass\n    @cot\n    def extract_food_context_cot(self, recipe: str) -> FoodMetaData:\n        \"\"\"당신은 음식 AI 어시스턴트입니다. 엔티티, 엔티티의 값 및 추출된 값이 올바른 값인 이유를 추출하는 것이 작업입니다. \n        엔티티를 추출할 수 없는 경우 null을 추가하세요.\"\"\"\n        pass\n    \n    @predictor\n    def extract_food_entities(self, recipe: str) -> FoodEntities:\n        \"\"\"당신은 음식 AI 어시스턴트입니다. 작업은 레시피에서 음식 엔티티를 추출하는 것입니다.\"\"\"\n        pass\n        \n    def forward(self, recipe: str) -> FoodEntities:\n        food_context = self.extract_food_context(recipe=recipe)\n        parsed_context = parse_context(food_context.context)\n        food_entities = self.extract_food_entities(recipe=parsed_context)\n        return food_entities\n```\n\n이를 통해 데코레이터 함수를 사용하여 표준 프롬프트 엔지니어링 기술을 지정할 수 있으며, 이는 매우 깔끔합니다. 또한 모듈에서 사용된 parse_context 메서드는 결과 JSON 콘텍스트를 문자열로 구문 분석하는 유틸리티 함수이며, 체인의 다음 단계에 대한 입력으로 사용될 것입니다.\n\n## DSPy 프로그램 실행하기\n\n<div class=\"content-ad\"></div>\n\n프로그램을 실행하려면 모듈의 인스턴스를 만들고 입력값을 사용하여 호출하십시오. 그러나 DSPy의 또 다른 멋진 기능은 모듈에 대한 dspy.Context를 지정할 수 있다는 것입니다:\n\n```js\nextract_food_entities = ExtractFoodEntities()\n\nwith dspy.context(lm=gpt4):\n    entities = extract_food_entities(recipe=\"Ten grams of orange dutch cheese,  \\\n    2 liters of water and 5 ml of ice\")\n    pprint(entities)\n```\n\n위의 프로그램은 다음 출력을 보여줍니다:\n\n```js\nFoodEntities(\n    entities=[\n        FoodEntity(\n            food='orange dutch cheese',\n            quantity=10,\n            unit='grams',\n            physical_quality=None,\n            color='orange',\n        ),\n        FoodEntity(\n            food='water',\n            quantity=2000,\n            unit='milliliters',\n            physical_quality=None,\n            color='clear',\n        ),\n        FoodEntity(\n            food='ice',\n            quantity=5,\n            unit='milliliters',\n            physical_quality=None,\n            color='clear',\n        ),\n    ],\n)\n```\n\n<div class=\"content-ad\"></div>\n\n이것은 다른 LLM(모델 상의 큰 언어 모델)을 시험해보거나, 예를 들어 DEV에는 gpt-3.5-turbo를 사용하고, PROD에서는 더 강인한 모델인 gpt-4-turbo-preview를 사용한다면 유용할 것입니다.\n\n## DSPy 프로그램 최적화하기\n\n이제 프로그램을 최적화하는 데 필요한 모든 구성 요소가 준비되었습니다 🎉. DSPy에서 최적화자는 DSPy 프로그램의 매개변수인 프롬프트와/또는 LM(언어 모델) 가중치를 조정할 수 있는 알고리즘입니다. 프로그램을 최적화하려면 최대화할 메트릭을 제공합니다.\n\n최적화 단계에서는 BootstrapFewShot 최적화자를 사용합니다. 그리고 최대화하려는 메트릭(어떤 파이썬 함수도 될 수 있음)은 아래에 표시되어 있습니다:\n\n<div class=\"content-ad\"></div>\n\n```python\ndef validate_entities(example, pred, trace=None):\n    \"\"\"두 객체가 동일한지 확인합니다.\"\"\"\n    return example.entities == pred\n```\n\n최적화를 실행하려면 compile 메서드를 사용합니다:\n\n```python\nfrom dspy.teleprompt import BootstrapFewShot\n\nteleprompter = BootstrapFewShot(metric=validate_entities)\ncompiled_ner = teleprompter.compile(ExtractFoodEntitiesV2(), trainset=trainset)\n```\n\n저희 데이터셋에서 컴파일된 프로그램을 실행한 결과는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n```js\nFoodEntities(\n    entities=[\n        FoodEntity(\n            food='삼겹살',\n            quantity=2,\n            unit='lb',\n            physical_quality=None,\n            color='',\n        ),\n        FoodEntity(\n            food='파',\n            quantity=2,\n            unit='개',\n            physical_quality='작을 경우 3개',\n            color='',\n        ),\n        FoodEntity(\n            food='생강',\n            quantity=1,\n            unit='인치',\n            physical_quality='한 조각',\n            color='',\n        ),\n        FoodEntity(\n            food='마늘',\n            quantity=2,\n            unit='쪽',\n            physical_quality=None,\n            color='',\n        ),\n        FoodEntity(\n            food='술',\n            quantity=2,\n            unit='⅔ 컵',\n            physical_quality=None,\n            color='',\n        ),\n        FoodEntity(\n            food='간장',\n            quantity=2,\n            unit='⅔ 컵',\n            physical_quality=None,\n            color='',\n        ),\n        FoodEntity(\n            food='미린',\n            quantity=1,\n            unit='¼ 컵',\n            physical_quality=None,\n            color='',\n        ),\n        FoodEntity(\n            food='설탕',\n            quantity=1,\n            unit='½ 컵',\n            physical_quality=None,\n            color='',\n        ),\n        FoodEntity(\n            food='물',\n            quantity=2,\n            unit='컵',\n            physical_quality='필요에 따라 약간 더',\n            color='',\n        ),\n    ],\n)\r\n```\n\n프롬프트 엔지니어링에 반이나하 며 살짝 봐두 시간 정도만 투자한 것에 대해서 꽤 괜찮지 않나요? 💪!\n\n## LLM 검사\n\n프로그램을 이렇게 선언하는 것도 좋지만 LLM이 사용하는 기본 프롬프트를 확인하려면 어떻게 해야 할까요? 걱정 마세요. inspect_history를 사용해 보세요:\n\n\n<div class=\"content-ad\"></div>\n\n```js\r\ngpt4.inspect_history(n=1)\r\n```\r\n\r\n아래와 같은 출력이 나왔습니다:\r\n\r\n```js\r\n당신은 음식 AI 어시스턴트입니다. 레시피에서 음식 엔티티를 추출하는 것이 당신의 임무입니다.\r\n\r\n---\r\n\r\n다음 형식을 따르세요.\r\n레시피: ${recipe}\r\n음식 엔티티 추출: ${extract_food_entities}. 단일 JSON 객체로 응답하세요. JSON 스키마: {\"$defs\": {\"FoodEntity\": {\"properties\": {\"food\": {\"description\": \"고기, 채소, 주류 등과 같이 고체 및 액체 음식일 수 있습니다\", \"title\": \"음식\", \"type\": \"string\"}, \"quantity\": {\"description\": \"레시피에 사용해야 하는 음식의 정확한 양 또는 분량\", \"title\": \"분량\", \"type\": \"integer\"}, \"unit\": {\"description\": \"사용 중인 단위 (예: 그램, 밀리리터, 파운드 등)\", \"title\": \"단위\", \"type\": \"string\"}, \"physical_quality\": {\"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}], \"description\": \"재료의 특성\", \"title\": \"물리적 품질\"}, \"color\": {\"description\": \"음식의 색깔\", \"title\": \"색깔\", \"type\": \"string\"}, \"required\": [\"food\", \"quantity\", \"unit\", \"physical_quality\", \"color\"], \"title\": \"FoodEntity\", \"type\": \"object\"}, \"properties\": {\"entities\": {\"items\": {\"$ref\": \"#/$defs/FoodEntity\"}, \"title\": \"Entities\", \"type\": \"array\"}, \"required\": [\"entities\"], \"title\": \"FoodEntities\", \"type\": \"object\"}\r\n---\r\n레시피:\r\npork belly:\r\n{\r\n\"reasoning\": \"차슈 포크의 주 재료로 2 파운드의 삼겹살을 사용하도록 레시피에서 명시되어 있습니다.\",\r\n\"value\": \"2 파운드\",\r\n\"entity\": \"삼겹살\"\r\n}\r\ngreen onions:\r\n{\r\n\"reasoning\": \"2개의 대파가 필요하며, 작은 대파인 경우 3개를 사용합니다.\",\r\n\"value\": \"2 또는 3\",\r\n\"entity\": \"대파\"\r\n}\r\nfresh ginger:\r\n{\r\n\"reasoning\": \"레시피에는 신선한 생강 1인치가 필요하며, 이는 레시피에 대략 4~6개의 조각을 제공합니다.\",\r\n\"value\": \"1인치\",\r\n\"entity\": \"생강\"\r\n}\r\ngarlic:\r\n{ \r\n\"reasoning\": \"재료 중에는 마늘 2쪽이 필요합니다.\",\r\n\"value\": \"2쪽\",\r\n\"entity\": \"마늘\"\r\n}\r\nsake:\r\n{\r\n\"reasoning\": \"풍미를 위해 요리 액체에 ⅔컵의 사케가 사용됩니다.\",\r\n\"value\": \"⅔컵\",\r\n\"entity\": \"사케\"\r\n}\r\nsoy sauce:\r\n{\r\n\"reasoning\": \"요리 액체에 ⅔컵의 간장이 추가되어 요리의 맛을 더합니다.\",\r\n\"value\": \"⅔컵\",\r\n\"entity\": \"간장\"\r\n}\r\nmirin:\r\n{\r\n\"reasoning\": \"달콤하고 깊은 맛을 위해 레시피에 ¼컵의 미린이 포함됩니다.\",\r\n\"value\": \"¼컵\",\r\n\"entity\": \"미린\"\r\n}\r\nsugar:\r\n{\r\n\"reasoning\": \"요리 액체를 달게하기 위해 ½컵의 설탕을 사용합니다.\",\r\n\"value\": \"½컵\",\r\n\"entity\": \"설탕\"\r\n}\r\nwater:\r\n{\r\n\"reasoning\": \"삼겹살을 위한 요리 액체를 만들기 위해 2컵의 물(필요에 따라 더 추가 가능)이 필요합니다.\",\r\n\"value\": \"2컵\",\r\n\"entity\": \"물\"\r\n}\r\n음식 엔티티 추출: json\r\n{\r\n\"entities\": [\r\n{\r\n\"food\": \"삼겹살\",\r\n\"quantity\": 2,\r\n\"unit\": \"파운드\",\r\n\"physical_quality\": null,\r\n\"color\": \"\"\r\n},\r\n{\r\n\"food\": \"대파\",\r\n\"quantity\": 2,\r\n\"unit\": \"개\",\r\n\"physical_quality\": \"작으면 3개\",\r\n\"color\": \"\"\r\n},\r\n{\r\n\"food\": \"생강\",\r\n\"quantity\": 1,\r\n\"unit\": \"인치\",\r\n\"physical_quality\": \"조각\",\r\n\"color\": \"\"\r\n},\r\n{\r\n\"food\": \"마늘\",\r\n\"quantity\": 2,\r\n\"unit\": \"쪽\",\r\n\"physical_quality\": null,\r\n\"color\": \"\"\r\n},\r\n{\r\n\"food\": \"사케\",\r\n\"quantity\": 2,\r\n\"unit\": \"⅔컵\",\r\n\"physical_quality\": null,\r\n\"color\": \"\"\r\n},\r\n{\r\n\"food\": \"간장\",\r\n\"quantity\": 2,\r\n\"unit\": \"⅔컵\",\r\n\"physical_quality\": null,\r\n\"color\": \"\"\r\n},\r\n{\r\n\"food\": \"미린\",\r\n\"quantity\": 1,\r\n\"unit\": \"¼컵\",\r\n\"physical_quality\": null,\r\n\"color\": \"\"\r\n},\r\n{\r\n\"food\": \"설탕\",\r\n\"quantity\": 1,\r\n\"unit\": \"½컵\",\r\n\"physical_quality\": null,\r\n\"color\": \"\"\r\n},\r\n{\r\n\"food\": \"물\",\r\n\"quantity\": 2,\r\n\"unit\": \"컵\",\r\n\"physical_quality\": \"필요에 따라 추가\",\r\n\"color\": \"\"\r\n}\r\n]\r\n}\r\n``\r\n```\r\n\r\n# 마무리말\n\n<div class=\"content-ad\"></div>\n\n이 게시물의 목적은 DSPy 라이브러리를 익히고 TypedPredictor 클래스를 주로 NER 사용 사례에 사용하는 방법을 살펴보는 것이었습니다. 이제 여러분도 더 나은 이해를 하셨으면 좋겠습니다!\n\n첫 인상을 요약하면 다음과 같습니다:\n\n- DSPy는 사용하기 쉽고 시작하기 쉽습니다 ✅\n- 프롬프트 엔지니어링에 시간을 낭비하는 대신, 프레임워크가 대신 처리해 주는 것이 아주 좋습니다 ✅\n- LLM을 최적화 및 PyTorch와 같은 아이디어를 사용하여 \"전형적인\" ML 문제로 다루는 것이 매우 좋습니다 ✅\n- 여전히 발전 중이며 아마도 \"운영\"에 준비가 되지는 않았습니다 ❌\n- 프로그램을 디버깅할 때 무슨 일이 일어나고 있는지 이해하기 쉽도록 더 나은 로깅/추적이 필요합니다 ❌\n\n그러나 프롬프트를하는 대신 LLM을 프로그래밍하는 접근 방식을 좋아합니다. 이것은 분야에서 흥미로운 발전이며 예를 들어, 미래의 복합 AI 시스템에 대한 것입니다.\n\n<div class=\"content-ad\"></div>\n\nDSPY의 채택 및 추가 개발을 기대하고 있어요.\n\n# 참고 자료\n\n- 💻 DSPy 소개: 인사 대신 프로그래밍으로!\n- 💻 DSPy: 선언형 언어 모델 호출을 자가 개선 파이프라인으로 컴파일하기\n- 💻 DSPy 심층 탐구","ogImage":{"url":"/assets/img/2024-06-22-UsingDSPyforextractingmetadataNERstyle_0.png"},"coverImage":"/assets/img/2024-06-22-UsingDSPyforextractingmetadataNERstyle_0.png","tag":["Tech"],"readingTime":15},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>DSPy는 프로그래밍을 장려하는 \"선언적\" 방식을 통해 LLMs를 가르치는 것을 선호하여 커뮤니티에서 빠르게 큰 관심을 얻었습니다. 이 글에서는 DSPy를 사용하여 Named Entity Recognition (NER) 또는 구조화된 데이터 추출을 얼마나 쉽게 할 수 있는지 살펴보겠습니다. 이를 통해 자신감을 가지고 기능을 활용할 수 있습니다.</p>\n<p>자세한 내용은 아래의 원문을 확인해주세요:</p>\n<p>시작해봅시다 😎!</p>\n<h1>소개</h1>\n<div class=\"content-ad\"></div>\n<p>요즘 대형 언어 모델(Large Language Models, LLM)과 작업한 사람들은 프롬프트(prompt)의 중요성을 강조할 것입니다. 프롬프트를 조금만 바꿔도 출력물에 예상치 못한 변화가 연쇄적으로 발생할 수 있습니다. 또한 다른 LLM 제공업체 간에 프롬프트를 이전하거나 재사용하는 일이 까다로운 경우도 많습니다. 예를 들어, OpenAI에서 Claude 3를 통해 Antrophic을 사용하는 함수 호출 로직을 이동하는 경우 프롬프트를 재설계해야 할 필요가 있죠 😅.</p>\n<p>따라서 프롬프트를 다시 작성하고, 평가를 재평가하며, 출력물을 디버깅하는 데 많은 시간 ⏰을 투자해야 합니다. 이를 보다 똑똑하게 처리할 수 있는 방법이 있다면 좋을텐데요? 다행히도, DSPs와 같은 흥미로운 프레임워크는 LLM 제공자에 관계없이 프로그래밍에 중점을 둡니다. 자세한 내용은 참조할 자료에서 DSPy에 대해 더 깊이있게 알아볼 수 있습니다.</p>\n<h1>Declarative Self-Improving Language Programs (DSPy)</h1>\n<p>DSPy 또는 선언적 자기 개선 언어 프로그램(Declarative Self-improving Language Programs, Khattab et al, 2023)은 처음으로 [2]에서 소개되었습니다. DSPy는 PyTorch와 같은 신경망 프레임워크에서 영감을 받아, 프롬프트보다는 프로그래밍에 중점을 둡니다.</p>\n<div class=\"content-ad\"></div>\n<p>간단히 말하자면, DSPy 프로그래밍 모델은 다음과 같은 추상화를 가지고 있습니다:</p>\n<ul>\n<li>필요한 손쓰기 프롬프트/세밀 조정을 대체할 서명.</li>\n<li>Cot, REACT 등 다양한 프롬프트 엔지니어링 기술을 구현한 모듈.</li>\n<li>주어진 메트릭스를 기반으로 한 수동 프롬프트 엔지니어링을 자동화하는 옵티마이저</li>\n</ul>\n<p>더 자세한 설명은 참조 사항 중 [1]을 참고하십시오.</p>\n<h1>음식 관련 엔티티에 DSPy를 사용한 NER</h1>\n<div class=\"content-ad\"></div>\n<p>다음 섹션에서는 DSPy를 사용하여 NER 사용 사례를 살펴볼 것입니다.</p>\n<h2>데이터</h2>\n<p>사용할 데이터는 라면 🍜 한 그릇을 만들기 위한 차슈 돼지고기 레시피입니다. 아래 게시물에서 자세한 내용을 확인하세요:</p>\n<p>예시 데이터:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">### 차슈 돼지고기 (라면 및 기타 용도)\n차슈 돼지고기는 라멘과 같은 일본 요리에 사용되는 돼지 배를 준비하는 전통적인 방법입니다.\n다소 시간이 걸릴 수 있지만 비교적 손쉽고 맛있는 결과물이 나옵니다.\n\n### 재료\n<span class=\"hljs-number\">2</span> 파운드의 돼지 배 또는 조금 더/적게\n<span class=\"hljs-number\">2</span>개의 대파 또는 작은 경우 <span class=\"hljs-number\">3</span>개\n<span class=\"hljs-number\">1</span>인치 크기의 생 생강 (약 <span class=\"hljs-number\">4</span>-<span class=\"hljs-number\">6</span>조각 나오는 양)\n<span class=\"hljs-number\">2</span>쪽의 마늘\n⅔컵의 사케\n⅔컵의 간장\n¼컵의 미린\n½컵의 설탕\n필요에 따라 조절 가능한 <span class=\"hljs-number\">2</span>컵의 물\n### 요령\n돼지고기를 준비하기 전에 줄 또는 부엌 실을 준비하고 가위 한 켤레를 준비하세요.\n해당 사항이 있다면 돼지고기의 외부 지방을 다듬어주세요. 그럼에도 불구하고 이후에는 여전히\n...\n</code></pre>\n<p>위의 데이터 외에도 TypedPredictor와 함께 사용할 Pydantic 데이터 모델을 설정해야 합니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FoodMetaData</span>(<span class=\"hljs-title class_\">BaseModel</span>):\n    <span class=\"hljs-attr\">reasoning</span>: str = <span class=\"hljs-title class_\">Field</span>(description=<span class=\"hljs-string\">\"엔티티가 정확한 이유\"</span>)\n    <span class=\"hljs-attr\">value</span>: <span class=\"hljs-title class_\">Union</span>[str, int] = <span class=\"hljs-title class_\">Field</span>(description=<span class=\"hljs-string\">\"엔티티의 값\"</span>)\n    <span class=\"hljs-attr\">entity</span>: str = <span class=\"hljs-title class_\">Field</span>(description=<span class=\"hljs-string\">\"실제 엔티티 즉, 돼지고기, 양파 등\"</span>)\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FoodMetaDatas</span>(<span class=\"hljs-title class_\">BaseModel</span>):\n    <span class=\"hljs-attr\">context</span>: <span class=\"hljs-title class_\">List</span>[<span class=\"hljs-title class_\">FoodMetaData</span>]\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FoodEntity</span>(<span class=\"hljs-title class_\">BaseModel</span>):\n    <span class=\"hljs-attr\">food</span>: str = <span class=\"hljs-title class_\">Field</span>(description=<span class=\"hljs-string\">\"유체 및 고체 음식, 즉 고기, 채소, 주류 등이 될 수 있습니다.\"</span>)\n    <span class=\"hljs-attr\">quantity</span>: int = <span class=\"hljs-title class_\">Field</span>(description=<span class=\"hljs-string\">\"레시피에 사용해야 하는 실제 양 또는 양\"</span>)\n    <span class=\"hljs-attr\">unit</span>: str = <span class=\"hljs-title class_\">Field</span>(description=<span class=\"hljs-string\">\"사용 중인 단위, 예를 들어 그램, 밀리리터, 파운드 등\"</span>)\n    <span class=\"hljs-attr\">physical_quality</span>: <span class=\"hljs-title class_\">Optional</span>[str] = <span class=\"hljs-title class_\">Field</span>(description=<span class=\"hljs-string\">\"재료의 특성\"</span>)\n    <span class=\"hljs-attr\">color</span>: str = <span class=\"hljs-title class_\">Field</span>(description=<span class=\"hljs-string\">\"음식의 색상\"</span>)\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FoodEntities</span>(<span class=\"hljs-title class_\">BaseModel</span>):\n    <span class=\"hljs-attr\">entities</span>: <span class=\"hljs-title class_\">List</span>[<span class=\"hljs-title class_\">FoodEntity</span>]\n</code></pre>\n<div class=\"content-ad\"></div>\n<ul>\n<li>FoodMetadatas는 각 엔티티의 컨텍스트 추출 + 추론 흐름의 일부입니다.</li>\n<li>FoodEntities는 우리가 원하는 엔티티를 추출하는 데 사용됩니다.</li>\n</ul>\n<p>마지막으로, DSPy 프로그램이 옵티마이저를 위해 컴파일될 때, 우리는 dspy.Examplemodule을 사용하여 일부 훈련 예제를 만들 것입니다:</p>\n<pre><code class=\"hljs language-js\">trainset = [\n    dspy.<span class=\"hljs-title class_\">Example</span>(\n        recipe=<span class=\"hljs-string\">\"2개의 계란, 500그램 버터 및 10그램 그리르치즈로 프렌치 오믈렛 만들기\"</span>, \n        entities=[\n            <span class=\"hljs-title class_\">FoodEntity</span>(food=<span class=\"hljs-string\">\"계란\"</span>, quantity=<span class=\"hljs-number\">2</span>, unit=<span class=\"hljs-string\">\"\"</span>, physical_quality=<span class=\"hljs-string\">\"\"</span>, color=<span class=\"hljs-string\">\"흰색\"</span>),\n            <span class=\"hljs-title class_\">FoodEntity</span>(food=<span class=\"hljs-string\">\"버터\"</span>, quantity=<span class=\"hljs-number\">500</span>, unit=<span class=\"hljs-string\">\"그램\"</span>, physical_quality=<span class=\"hljs-string\">\"\"</span>, color=<span class=\"hljs-string\">\"노랑\"</span>),\n            <span class=\"hljs-title class_\">FoodEntity</span>(food=<span class=\"hljs-string\">\"치즈\"</span>, quantity=<span class=\"hljs-number\">10</span>, unit=<span class=\"hljs-string\">\"그램\"</span>, physical_quality=<span class=\"hljs-string\">\"그리레\"</span>, color=<span class=\"hljs-string\">\"노랑\"</span>)\n        ]\n    ).<span class=\"hljs-title function_\">with_inputs</span>(<span class=\"hljs-string\">\"recipe\"</span>),\n        ...\n    dspy.<span class=\"hljs-title class_\">Example</span>(\n        recipe=<span class=\"hljs-string\">\"250g 밀가루, 1큰술 베이킹 파우더, 1그램 소금, 10g 설탕, 100ml 신선우유로 아메리칸 팬케이크 만들기\"</span>, \n        entities=[\n            <span class=\"hljs-title class_\">FoodEntity</span>(food=<span class=\"hljs-string\">\"밀가루\"</span>, quantity=<span class=\"hljs-number\">250</span>, unit=<span class=\"hljs-string\">\"그램\"</span>, physical_quality=<span class=\"hljs-string\">\"\"</span>, color=<span class=\"hljs-string\">\"흰색\"</span>),\n            <span class=\"hljs-title class_\">FoodEntity</span>(food=<span class=\"hljs-string\">\"베이킹 파우더\"</span>, quantity=<span class=\"hljs-number\">1</span>, unit=<span class=\"hljs-string\">\"큰술\"</span>, physical_quality=<span class=\"hljs-string\">\"\"</span>, color=<span class=\"hljs-string\">\"흰색\"</span>),\n            <span class=\"hljs-title class_\">FoodEntity</span>(food=<span class=\"hljs-string\">\"소금\"</span>, quantity=<span class=\"hljs-number\">1</span>, unit=<span class=\"hljs-string\">\"그램\"</span>, physical_quality=<span class=\"hljs-string\">\"짠맛\"</span>, color=<span class=\"hljs-string\">\"흰색\"</span>),\n            <span class=\"hljs-title class_\">FoodEntity</span>(food=<span class=\"hljs-string\">\"우유\"</span>, quantity=<span class=\"hljs-number\">100</span>, unit=<span class=\"hljs-string\">\"밀\"</span>, physical_quality=<span class=\"hljs-string\">\"지방\"</span>, color=<span class=\"hljs-string\">\"흰색\"</span>),\n        ]\n    ).<span class=\"hljs-title function_\">with_inputs</span>(<span class=\"hljs-string\">\"recipe\"</span>)\n]\n</code></pre>\n<h2>서명</h2>\n<div class=\"content-ad\"></div>\n<p>데이터셋을 만들거나 수집한 후의 다음 단계는 DSPy 프로그램에 대한 서명을 작성하는 것입니다. 이것을 입력/출력 동작에 대한 선언적 명세로 생각할 수 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RecipeToFoodContext</span>(dspy.<span class=\"hljs-property\">Signature</span>):\n    <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\"당신은 음식 AI 어시스턴트입니다. 엔티티, 엔티티의 값 및 추출된 값이 올바른 값인 이유를 추출하는 작업을 수행해야 합니다. \n    엔티티를 추출할 수 없는 경우 null을 추가하십시오\"</span><span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-attr\">recipe</span>: str = dspy.<span class=\"hljs-title class_\">InputField</span>()\n    <span class=\"hljs-attr\">context</span>: <span class=\"hljs-title class_\">FoodMetaDatas</span> = dspy.<span class=\"hljs-title class_\">OutputField</span>()\n</code></pre>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RecipeToFoodEntities</span>(dspy.<span class=\"hljs-property\">Signature</span>):\n    <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\"당신은 음식 AI 어시스턴트입니다. 레시피에서 음식과 관련된 메타데이터를 추출해야 합니다.\"</span><span class=\"hljs-string\">\"\"</span>\n    <span class=\"hljs-attr\">recipe</span>: str = dspy.<span class=\"hljs-title class_\">InputField</span>()\n    <span class=\"hljs-attr\">entities</span>: <span class=\"hljs-title class_\">FoodEntities</span> = dspy.<span class=\"hljs-title class_\">OutputField</span>()\n</code></pre>\n<ul>\n<li>RecipeToFoodContext은 문맥 + 추론 호출에 사용되는 서명입니다. 여기에서 문자열 설명을 사용하여 LLM에 초기 지침을 제공했다는 점에 유의하십시오.</li>\n<li>RecipeFoodEntities는 실제로 식별된 엔티티를 추출하는 서명에 해당합니다.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<p>지금까지는 특별한 공학 작업이 아니라 Python 클래스/객체를 명시하는 것이었습니다 🐍. 코드는 또한 이해하기 비교적 쉽습니다. 무엇을 하는지, 입력이나 출력 등이 뭔지 잘 알 수 있죠.</p>\n<h2>Modules</h2>\n<p>데이터셋을 생성하고 서명을 지정한 후에는 모듈을 작성할 준비가 되었습니다. 각 모듈은 Chain-of-Thought, ReAct 등 다양한 프롬프팅 기술을 \"추상화\"하는 멋진 기능이 있습니다. 또한 신경망 프레임워크에 익숙한 독자들을 위해 아래의 forward 메서드에 주목해주세요:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ExtractFoodEntities</span>(dspy.<span class=\"hljs-property\">Module</span>):\n    def <span class=\"hljs-title function_\">__init__</span>(self, <span class=\"hljs-attr\">temperature</span>: int = <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">seed</span>: int = <span class=\"hljs-number\">123</span>):\n        <span class=\"hljs-variable language_\">super</span>().<span class=\"hljs-title function_\">__init__</span>()\n        self.<span class=\"hljs-property\">temperature</span> = temperature\n        self.<span class=\"hljs-property\">seed</span> = seed\n        self.<span class=\"hljs-property\">extract_food_context</span> = dspy.<span class=\"hljs-title class_\">TypedPredictor</span>(<span class=\"hljs-title class_\">RecipeToFoodContext</span>)\n        self.<span class=\"hljs-property\">extract_food_context_cot</span> = dspy.<span class=\"hljs-title class_\">TypedChainOfThought</span>(<span class=\"hljs-title class_\">RecipeToFoodContext</span>)\n        self.<span class=\"hljs-property\">extract_food_entities</span> = dspy.<span class=\"hljs-title class_\">TypedPredictor</span>(<span class=\"hljs-title class_\">RecipeToFoodEntities</span>)\n        \n    def <span class=\"hljs-title function_\">forward</span>(self, <span class=\"hljs-attr\">recipe</span>: str) -> <span class=\"hljs-title class_\">FoodEntities</span>:\n        food_context = self.<span class=\"hljs-title function_\">extract_food_context</span>(recipe=recipe).<span class=\"hljs-property\">context</span>\n        parsed_context = <span class=\"hljs-title function_\">parse_context</span>(food_context.<span class=\"hljs-property\">context</span>)\n        food_entities = self.<span class=\"hljs-title function_\">extract_food_entities</span>(recipe=parsed_context)\n        <span class=\"hljs-keyword\">return</span> food_entities.<span class=\"hljs-property\">entities</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>위 모듈은 dspy.Module 인터페이스를 사용하고 있습니다. dspy.Functional 인터페이스를 사용하여 모듈을 지정할 수도 있습니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">from</span> dspy.<span class=\"hljs-property\">functional</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">FunctionalModule</span>, predictor, cot\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ExtractFoodEntitiesV2</span>(<span class=\"hljs-title class_\">FunctionalModule</span>):\n    def <span class=\"hljs-title function_\">__init__</span>(self, <span class=\"hljs-attr\">temperature</span>: int = <span class=\"hljs-number\">0</span>, <span class=\"hljs-attr\">seed</span>: int = <span class=\"hljs-number\">123</span>):\n        <span class=\"hljs-variable language_\">super</span>().<span class=\"hljs-title function_\">__init__</span>()\n        self.<span class=\"hljs-property\">temperature</span> = temperature\n        self.<span class=\"hljs-property\">seed</span> = seed\n    @predictor\n    def <span class=\"hljs-title function_\">extract_food_context</span>(self, <span class=\"hljs-attr\">recipe</span>: str) -> <span class=\"hljs-title class_\">FoodMetaData</span>:\n        <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\"당신은 음식 AI 어시스턴트입니다. 엔티티, 엔티티의 값 및 추출된 값이 올바른 값인 이유를 추출하는 것이 작업입니다. \n        엔티티를 추출할 수 없는 경우 null을 추가하세요.\"</span><span class=\"hljs-string\">\"\"</span>\n        pass\n    @cot\n    def <span class=\"hljs-title function_\">extract_food_context_cot</span>(self, <span class=\"hljs-attr\">recipe</span>: str) -> <span class=\"hljs-title class_\">FoodMetaData</span>:\n        <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\"당신은 음식 AI 어시스턴트입니다. 엔티티, 엔티티의 값 및 추출된 값이 올바른 값인 이유를 추출하는 것이 작업입니다. \n        엔티티를 추출할 수 없는 경우 null을 추가하세요.\"</span><span class=\"hljs-string\">\"\"</span>\n        pass\n    \n    @predictor\n    def <span class=\"hljs-title function_\">extract_food_entities</span>(self, <span class=\"hljs-attr\">recipe</span>: str) -> <span class=\"hljs-title class_\">FoodEntities</span>:\n        <span class=\"hljs-string\">\"\"</span><span class=\"hljs-string\">\"당신은 음식 AI 어시스턴트입니다. 작업은 레시피에서 음식 엔티티를 추출하는 것입니다.\"</span><span class=\"hljs-string\">\"\"</span>\n        pass\n        \n    def <span class=\"hljs-title function_\">forward</span>(self, <span class=\"hljs-attr\">recipe</span>: str) -> <span class=\"hljs-title class_\">FoodEntities</span>:\n        food_context = self.<span class=\"hljs-title function_\">extract_food_context</span>(recipe=recipe)\n        parsed_context = <span class=\"hljs-title function_\">parse_context</span>(food_context.<span class=\"hljs-property\">context</span>)\n        food_entities = self.<span class=\"hljs-title function_\">extract_food_entities</span>(recipe=parsed_context)\n        <span class=\"hljs-keyword\">return</span> food_entities\n</code></pre>\n<p>이를 통해 데코레이터 함수를 사용하여 표준 프롬프트 엔지니어링 기술을 지정할 수 있으며, 이는 매우 깔끔합니다. 또한 모듈에서 사용된 parse_context 메서드는 결과 JSON 콘텍스트를 문자열로 구문 분석하는 유틸리티 함수이며, 체인의 다음 단계에 대한 입력으로 사용될 것입니다.</p>\n<h2>DSPy 프로그램 실행하기</h2>\n<div class=\"content-ad\"></div>\n<p>프로그램을 실행하려면 모듈의 인스턴스를 만들고 입력값을 사용하여 호출하십시오. 그러나 DSPy의 또 다른 멋진 기능은 모듈에 대한 dspy.Context를 지정할 수 있다는 것입니다:</p>\n<pre><code class=\"hljs language-js\">extract_food_entities = <span class=\"hljs-title class_\">ExtractFoodEntities</span>()\n\n<span class=\"hljs-keyword\">with</span> dspy.<span class=\"hljs-title function_\">context</span>(lm=gpt4):\n    entities = <span class=\"hljs-title function_\">extract_food_entities</span>(recipe=<span class=\"hljs-string\">\"Ten grams of orange dutch cheese,  \\\n    2 liters of water and 5 ml of ice\"</span>)\n    <span class=\"hljs-title function_\">pprint</span>(entities)\n</code></pre>\n<p>위의 프로그램은 다음 출력을 보여줍니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">FoodEntities</span>(\n    entities=[\n        <span class=\"hljs-title class_\">FoodEntity</span>(\n            food=<span class=\"hljs-string\">'orange dutch cheese'</span>,\n            quantity=<span class=\"hljs-number\">10</span>,\n            unit=<span class=\"hljs-string\">'grams'</span>,\n            physical_quality=<span class=\"hljs-title class_\">None</span>,\n            color=<span class=\"hljs-string\">'orange'</span>,\n        ),\n        <span class=\"hljs-title class_\">FoodEntity</span>(\n            food=<span class=\"hljs-string\">'water'</span>,\n            quantity=<span class=\"hljs-number\">2000</span>,\n            unit=<span class=\"hljs-string\">'milliliters'</span>,\n            physical_quality=<span class=\"hljs-title class_\">None</span>,\n            color=<span class=\"hljs-string\">'clear'</span>,\n        ),\n        <span class=\"hljs-title class_\">FoodEntity</span>(\n            food=<span class=\"hljs-string\">'ice'</span>,\n            quantity=<span class=\"hljs-number\">5</span>,\n            unit=<span class=\"hljs-string\">'milliliters'</span>,\n            physical_quality=<span class=\"hljs-title class_\">None</span>,\n            color=<span class=\"hljs-string\">'clear'</span>,\n        ),\n    ],\n)\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이것은 다른 LLM(모델 상의 큰 언어 모델)을 시험해보거나, 예를 들어 DEV에는 gpt-3.5-turbo를 사용하고, PROD에서는 더 강인한 모델인 gpt-4-turbo-preview를 사용한다면 유용할 것입니다.</p>\n<h2>DSPy 프로그램 최적화하기</h2>\n<p>이제 프로그램을 최적화하는 데 필요한 모든 구성 요소가 준비되었습니다 🎉. DSPy에서 최적화자는 DSPy 프로그램의 매개변수인 프롬프트와/또는 LM(언어 모델) 가중치를 조정할 수 있는 알고리즘입니다. 프로그램을 최적화하려면 최대화할 메트릭을 제공합니다.</p>\n<p>최적화 단계에서는 BootstrapFewShot 최적화자를 사용합니다. 그리고 최대화하려는 메트릭(어떤 파이썬 함수도 될 수 있음)은 아래에 표시되어 있습니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">validate_entities</span>(<span class=\"hljs-params\">example, pred, trace=<span class=\"hljs-literal\">None</span></span>):\n    <span class=\"hljs-string\">\"\"\"두 객체가 동일한지 확인합니다.\"\"\"</span>\n    <span class=\"hljs-keyword\">return</span> example.entities == pred\n</code></pre>\n<p>최적화를 실행하려면 compile 메서드를 사용합니다:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">from</span> dspy.teleprompt <span class=\"hljs-keyword\">import</span> BootstrapFewShot\n\nteleprompter = BootstrapFewShot(metric=validate_entities)\ncompiled_ner = teleprompter.<span class=\"hljs-built_in\">compile</span>(ExtractFoodEntitiesV2(), trainset=trainset)\n</code></pre>\n<p>저희 데이터셋에서 컴파일된 프로그램을 실행한 결과는 다음과 같습니다:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-title class_\">FoodEntities</span>(\n    entities=[\n        <span class=\"hljs-title class_\">FoodEntity</span>(\n            food=<span class=\"hljs-string\">'삼겹살'</span>,\n            quantity=<span class=\"hljs-number\">2</span>,\n            unit=<span class=\"hljs-string\">'lb'</span>,\n            physical_quality=<span class=\"hljs-title class_\">None</span>,\n            color=<span class=\"hljs-string\">''</span>,\n        ),\n        <span class=\"hljs-title class_\">FoodEntity</span>(\n            food=<span class=\"hljs-string\">'파'</span>,\n            quantity=<span class=\"hljs-number\">2</span>,\n            unit=<span class=\"hljs-string\">'개'</span>,\n            physical_quality=<span class=\"hljs-string\">'작을 경우 3개'</span>,\n            color=<span class=\"hljs-string\">''</span>,\n        ),\n        <span class=\"hljs-title class_\">FoodEntity</span>(\n            food=<span class=\"hljs-string\">'생강'</span>,\n            quantity=<span class=\"hljs-number\">1</span>,\n            unit=<span class=\"hljs-string\">'인치'</span>,\n            physical_quality=<span class=\"hljs-string\">'한 조각'</span>,\n            color=<span class=\"hljs-string\">''</span>,\n        ),\n        <span class=\"hljs-title class_\">FoodEntity</span>(\n            food=<span class=\"hljs-string\">'마늘'</span>,\n            quantity=<span class=\"hljs-number\">2</span>,\n            unit=<span class=\"hljs-string\">'쪽'</span>,\n            physical_quality=<span class=\"hljs-title class_\">None</span>,\n            color=<span class=\"hljs-string\">''</span>,\n        ),\n        <span class=\"hljs-title class_\">FoodEntity</span>(\n            food=<span class=\"hljs-string\">'술'</span>,\n            quantity=<span class=\"hljs-number\">2</span>,\n            unit=<span class=\"hljs-string\">'⅔ 컵'</span>,\n            physical_quality=<span class=\"hljs-title class_\">None</span>,\n            color=<span class=\"hljs-string\">''</span>,\n        ),\n        <span class=\"hljs-title class_\">FoodEntity</span>(\n            food=<span class=\"hljs-string\">'간장'</span>,\n            quantity=<span class=\"hljs-number\">2</span>,\n            unit=<span class=\"hljs-string\">'⅔ 컵'</span>,\n            physical_quality=<span class=\"hljs-title class_\">None</span>,\n            color=<span class=\"hljs-string\">''</span>,\n        ),\n        <span class=\"hljs-title class_\">FoodEntity</span>(\n            food=<span class=\"hljs-string\">'미린'</span>,\n            quantity=<span class=\"hljs-number\">1</span>,\n            unit=<span class=\"hljs-string\">'¼ 컵'</span>,\n            physical_quality=<span class=\"hljs-title class_\">None</span>,\n            color=<span class=\"hljs-string\">''</span>,\n        ),\n        <span class=\"hljs-title class_\">FoodEntity</span>(\n            food=<span class=\"hljs-string\">'설탕'</span>,\n            quantity=<span class=\"hljs-number\">1</span>,\n            unit=<span class=\"hljs-string\">'½ 컵'</span>,\n            physical_quality=<span class=\"hljs-title class_\">None</span>,\n            color=<span class=\"hljs-string\">''</span>,\n        ),\n        <span class=\"hljs-title class_\">FoodEntity</span>(\n            food=<span class=\"hljs-string\">'물'</span>,\n            quantity=<span class=\"hljs-number\">2</span>,\n            unit=<span class=\"hljs-string\">'컵'</span>,\n            physical_quality=<span class=\"hljs-string\">'필요에 따라 약간 더'</span>,\n            color=<span class=\"hljs-string\">''</span>,\n        ),\n    ],\n)\n</code></pre>\n<p>프롬프트 엔지니어링에 반이나하 며 살짝 봐두 시간 정도만 투자한 것에 대해서 꽤 괜찮지 않나요? 💪!</p>\n<h2>LLM 검사</h2>\n<p>프로그램을 이렇게 선언하는 것도 좋지만 LLM이 사용하는 기본 프롬프트를 확인하려면 어떻게 해야 할까요? 걱정 마세요. inspect_history를 사용해 보세요:</p>\n<div class=\"content-ad\"></div>\n<pre><code class=\"hljs language-js\">gpt4.<span class=\"hljs-title function_\">inspect_history</span>(n=<span class=\"hljs-number\">1</span>)\n</code></pre>\n<p>아래와 같은 출력이 나왔습니다:</p>\n<pre><code class=\"hljs language-js\">당신은 음식 <span class=\"hljs-variable constant_\">AI</span> 어시스턴트입니다. 레시피에서 음식 엔티티를 추출하는 것이 당신의 임무입니다.\r\n\r\n---\r\n\r\n다음 형식을 따르세요.\r\n레시피: ${recipe}\r\n음식 엔티티 추출: ${extract_food_entities}. 단일 <span class=\"hljs-title class_\">JSON</span> 객체로 응답하세요. <span class=\"hljs-title class_\">JSON</span> 스키마: {<span class=\"hljs-string\">\"$defs\"</span>: {<span class=\"hljs-string\">\"FoodEntity\"</span>: {<span class=\"hljs-string\">\"properties\"</span>: {<span class=\"hljs-string\">\"food\"</span>: {<span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"고기, 채소, 주류 등과 같이 고체 및 액체 음식일 수 있습니다\"</span>, <span class=\"hljs-string\">\"title\"</span>: <span class=\"hljs-string\">\"음식\"</span>, <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"string\"</span>}, <span class=\"hljs-string\">\"quantity\"</span>: {<span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"레시피에 사용해야 하는 음식의 정확한 양 또는 분량\"</span>, <span class=\"hljs-string\">\"title\"</span>: <span class=\"hljs-string\">\"분량\"</span>, <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"integer\"</span>}, <span class=\"hljs-string\">\"unit\"</span>: {<span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"사용 중인 단위 (예: 그램, 밀리리터, 파운드 등)\"</span>, <span class=\"hljs-string\">\"title\"</span>: <span class=\"hljs-string\">\"단위\"</span>, <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"string\"</span>}, <span class=\"hljs-string\">\"physical_quality\"</span>: {<span class=\"hljs-string\">\"anyOf\"</span>: [{<span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"string\"</span>}, {<span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"null\"</span>}], <span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"재료의 특성\"</span>, <span class=\"hljs-string\">\"title\"</span>: <span class=\"hljs-string\">\"물리적 품질\"</span>}, <span class=\"hljs-string\">\"color\"</span>: {<span class=\"hljs-string\">\"description\"</span>: <span class=\"hljs-string\">\"음식의 색깔\"</span>, <span class=\"hljs-string\">\"title\"</span>: <span class=\"hljs-string\">\"색깔\"</span>, <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"string\"</span>}, <span class=\"hljs-string\">\"required\"</span>: [<span class=\"hljs-string\">\"food\"</span>, <span class=\"hljs-string\">\"quantity\"</span>, <span class=\"hljs-string\">\"unit\"</span>, <span class=\"hljs-string\">\"physical_quality\"</span>, <span class=\"hljs-string\">\"color\"</span>], <span class=\"hljs-string\">\"title\"</span>: <span class=\"hljs-string\">\"FoodEntity\"</span>, <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"object\"</span>}, <span class=\"hljs-string\">\"properties\"</span>: {<span class=\"hljs-string\">\"entities\"</span>: {<span class=\"hljs-string\">\"items\"</span>: {<span class=\"hljs-string\">\"$ref\"</span>: <span class=\"hljs-string\">\"#/$defs/FoodEntity\"</span>}, <span class=\"hljs-string\">\"title\"</span>: <span class=\"hljs-string\">\"Entities\"</span>, <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"array\"</span>}, <span class=\"hljs-string\">\"required\"</span>: [<span class=\"hljs-string\">\"entities\"</span>], <span class=\"hljs-string\">\"title\"</span>: <span class=\"hljs-string\">\"FoodEntities\"</span>, <span class=\"hljs-string\">\"type\"</span>: <span class=\"hljs-string\">\"object\"</span>}\r\n---\r\n레시피:\r\npork <span class=\"hljs-attr\">belly</span>:\r\n{\r\n<span class=\"hljs-string\">\"reasoning\"</span>: <span class=\"hljs-string\">\"차슈 포크의 주 재료로 2 파운드의 삼겹살을 사용하도록 레시피에서 명시되어 있습니다.\"</span>,\r\n<span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"2 파운드\"</span>,\r\n<span class=\"hljs-string\">\"entity\"</span>: <span class=\"hljs-string\">\"삼겹살\"</span>\r\n}\r\ngreen <span class=\"hljs-attr\">onions</span>:\r\n{\r\n<span class=\"hljs-string\">\"reasoning\"</span>: <span class=\"hljs-string\">\"2개의 대파가 필요하며, 작은 대파인 경우 3개를 사용합니다.\"</span>,\r\n<span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"2 또는 3\"</span>,\r\n<span class=\"hljs-string\">\"entity\"</span>: <span class=\"hljs-string\">\"대파\"</span>\r\n}\r\nfresh <span class=\"hljs-attr\">ginger</span>:\r\n{\r\n<span class=\"hljs-string\">\"reasoning\"</span>: <span class=\"hljs-string\">\"레시피에는 신선한 생강 1인치가 필요하며, 이는 레시피에 대략 4~6개의 조각을 제공합니다.\"</span>,\r\n<span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"1인치\"</span>,\r\n<span class=\"hljs-string\">\"entity\"</span>: <span class=\"hljs-string\">\"생강\"</span>\r\n}\r\n<span class=\"hljs-attr\">garlic</span>:\r\n{ \r\n<span class=\"hljs-string\">\"reasoning\"</span>: <span class=\"hljs-string\">\"재료 중에는 마늘 2쪽이 필요합니다.\"</span>,\r\n<span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"2쪽\"</span>,\r\n<span class=\"hljs-string\">\"entity\"</span>: <span class=\"hljs-string\">\"마늘\"</span>\r\n}\r\n<span class=\"hljs-attr\">sake</span>:\r\n{\r\n<span class=\"hljs-string\">\"reasoning\"</span>: <span class=\"hljs-string\">\"풍미를 위해 요리 액체에 ⅔컵의 사케가 사용됩니다.\"</span>,\r\n<span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"⅔컵\"</span>,\r\n<span class=\"hljs-string\">\"entity\"</span>: <span class=\"hljs-string\">\"사케\"</span>\r\n}\r\nsoy <span class=\"hljs-attr\">sauce</span>:\r\n{\r\n<span class=\"hljs-string\">\"reasoning\"</span>: <span class=\"hljs-string\">\"요리 액체에 ⅔컵의 간장이 추가되어 요리의 맛을 더합니다.\"</span>,\r\n<span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"⅔컵\"</span>,\r\n<span class=\"hljs-string\">\"entity\"</span>: <span class=\"hljs-string\">\"간장\"</span>\r\n}\r\n<span class=\"hljs-attr\">mirin</span>:\r\n{\r\n<span class=\"hljs-string\">\"reasoning\"</span>: <span class=\"hljs-string\">\"달콤하고 깊은 맛을 위해 레시피에 ¼컵의 미린이 포함됩니다.\"</span>,\r\n<span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"¼컵\"</span>,\r\n<span class=\"hljs-string\">\"entity\"</span>: <span class=\"hljs-string\">\"미린\"</span>\r\n}\r\n<span class=\"hljs-attr\">sugar</span>:\r\n{\r\n<span class=\"hljs-string\">\"reasoning\"</span>: <span class=\"hljs-string\">\"요리 액체를 달게하기 위해 ½컵의 설탕을 사용합니다.\"</span>,\r\n<span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"½컵\"</span>,\r\n<span class=\"hljs-string\">\"entity\"</span>: <span class=\"hljs-string\">\"설탕\"</span>\r\n}\r\n<span class=\"hljs-attr\">water</span>:\r\n{\r\n<span class=\"hljs-string\">\"reasoning\"</span>: <span class=\"hljs-string\">\"삼겹살을 위한 요리 액체를 만들기 위해 2컵의 물(필요에 따라 더 추가 가능)이 필요합니다.\"</span>,\r\n<span class=\"hljs-string\">\"value\"</span>: <span class=\"hljs-string\">\"2컵\"</span>,\r\n<span class=\"hljs-string\">\"entity\"</span>: <span class=\"hljs-string\">\"물\"</span>\r\n}\r\n음식 엔티티 추출: json\r\n{\r\n<span class=\"hljs-string\">\"entities\"</span>: [\r\n{\r\n<span class=\"hljs-string\">\"food\"</span>: <span class=\"hljs-string\">\"삼겹살\"</span>,\r\n<span class=\"hljs-string\">\"quantity\"</span>: <span class=\"hljs-number\">2</span>,\r\n<span class=\"hljs-string\">\"unit\"</span>: <span class=\"hljs-string\">\"파운드\"</span>,\r\n<span class=\"hljs-string\">\"physical_quality\"</span>: <span class=\"hljs-literal\">null</span>,\r\n<span class=\"hljs-string\">\"color\"</span>: <span class=\"hljs-string\">\"\"</span>\r\n},\r\n{\r\n<span class=\"hljs-string\">\"food\"</span>: <span class=\"hljs-string\">\"대파\"</span>,\r\n<span class=\"hljs-string\">\"quantity\"</span>: <span class=\"hljs-number\">2</span>,\r\n<span class=\"hljs-string\">\"unit\"</span>: <span class=\"hljs-string\">\"개\"</span>,\r\n<span class=\"hljs-string\">\"physical_quality\"</span>: <span class=\"hljs-string\">\"작으면 3개\"</span>,\r\n<span class=\"hljs-string\">\"color\"</span>: <span class=\"hljs-string\">\"\"</span>\r\n},\r\n{\r\n<span class=\"hljs-string\">\"food\"</span>: <span class=\"hljs-string\">\"생강\"</span>,\r\n<span class=\"hljs-string\">\"quantity\"</span>: <span class=\"hljs-number\">1</span>,\r\n<span class=\"hljs-string\">\"unit\"</span>: <span class=\"hljs-string\">\"인치\"</span>,\r\n<span class=\"hljs-string\">\"physical_quality\"</span>: <span class=\"hljs-string\">\"조각\"</span>,\r\n<span class=\"hljs-string\">\"color\"</span>: <span class=\"hljs-string\">\"\"</span>\r\n},\r\n{\r\n<span class=\"hljs-string\">\"food\"</span>: <span class=\"hljs-string\">\"마늘\"</span>,\r\n<span class=\"hljs-string\">\"quantity\"</span>: <span class=\"hljs-number\">2</span>,\r\n<span class=\"hljs-string\">\"unit\"</span>: <span class=\"hljs-string\">\"쪽\"</span>,\r\n<span class=\"hljs-string\">\"physical_quality\"</span>: <span class=\"hljs-literal\">null</span>,\r\n<span class=\"hljs-string\">\"color\"</span>: <span class=\"hljs-string\">\"\"</span>\r\n},\r\n{\r\n<span class=\"hljs-string\">\"food\"</span>: <span class=\"hljs-string\">\"사케\"</span>,\r\n<span class=\"hljs-string\">\"quantity\"</span>: <span class=\"hljs-number\">2</span>,\r\n<span class=\"hljs-string\">\"unit\"</span>: <span class=\"hljs-string\">\"⅔컵\"</span>,\r\n<span class=\"hljs-string\">\"physical_quality\"</span>: <span class=\"hljs-literal\">null</span>,\r\n<span class=\"hljs-string\">\"color\"</span>: <span class=\"hljs-string\">\"\"</span>\r\n},\r\n{\r\n<span class=\"hljs-string\">\"food\"</span>: <span class=\"hljs-string\">\"간장\"</span>,\r\n<span class=\"hljs-string\">\"quantity\"</span>: <span class=\"hljs-number\">2</span>,\r\n<span class=\"hljs-string\">\"unit\"</span>: <span class=\"hljs-string\">\"⅔컵\"</span>,\r\n<span class=\"hljs-string\">\"physical_quality\"</span>: <span class=\"hljs-literal\">null</span>,\r\n<span class=\"hljs-string\">\"color\"</span>: <span class=\"hljs-string\">\"\"</span>\r\n},\r\n{\r\n<span class=\"hljs-string\">\"food\"</span>: <span class=\"hljs-string\">\"미린\"</span>,\r\n<span class=\"hljs-string\">\"quantity\"</span>: <span class=\"hljs-number\">1</span>,\r\n<span class=\"hljs-string\">\"unit\"</span>: <span class=\"hljs-string\">\"¼컵\"</span>,\r\n<span class=\"hljs-string\">\"physical_quality\"</span>: <span class=\"hljs-literal\">null</span>,\r\n<span class=\"hljs-string\">\"color\"</span>: <span class=\"hljs-string\">\"\"</span>\r\n},\r\n{\r\n<span class=\"hljs-string\">\"food\"</span>: <span class=\"hljs-string\">\"설탕\"</span>,\r\n<span class=\"hljs-string\">\"quantity\"</span>: <span class=\"hljs-number\">1</span>,\r\n<span class=\"hljs-string\">\"unit\"</span>: <span class=\"hljs-string\">\"½컵\"</span>,\r\n<span class=\"hljs-string\">\"physical_quality\"</span>: <span class=\"hljs-literal\">null</span>,\r\n<span class=\"hljs-string\">\"color\"</span>: <span class=\"hljs-string\">\"\"</span>\r\n},\r\n{\r\n<span class=\"hljs-string\">\"food\"</span>: <span class=\"hljs-string\">\"물\"</span>,\r\n<span class=\"hljs-string\">\"quantity\"</span>: <span class=\"hljs-number\">2</span>,\r\n<span class=\"hljs-string\">\"unit\"</span>: <span class=\"hljs-string\">\"컵\"</span>,\r\n<span class=\"hljs-string\">\"physical_quality\"</span>: <span class=\"hljs-string\">\"필요에 따라 추가\"</span>,\r\n<span class=\"hljs-string\">\"color\"</span>: <span class=\"hljs-string\">\"\"</span>\r\n}\r\n]\r\n}\r\n<span class=\"hljs-string\">``</span>\n</code></pre>\n<h1>마무리말</h1>\n<div class=\"content-ad\"></div>\n<p>이 게시물의 목적은 DSPy 라이브러리를 익히고 TypedPredictor 클래스를 주로 NER 사용 사례에 사용하는 방법을 살펴보는 것이었습니다. 이제 여러분도 더 나은 이해를 하셨으면 좋겠습니다!</p>\n<p>첫 인상을 요약하면 다음과 같습니다:</p>\n<ul>\n<li>DSPy는 사용하기 쉽고 시작하기 쉽습니다 ✅</li>\n<li>프롬프트 엔지니어링에 시간을 낭비하는 대신, 프레임워크가 대신 처리해 주는 것이 아주 좋습니다 ✅</li>\n<li>LLM을 최적화 및 PyTorch와 같은 아이디어를 사용하여 \"전형적인\" ML 문제로 다루는 것이 매우 좋습니다 ✅</li>\n<li>여전히 발전 중이며 아마도 \"운영\"에 준비가 되지는 않았습니다 ❌</li>\n<li>프로그램을 디버깅할 때 무슨 일이 일어나고 있는지 이해하기 쉽도록 더 나은 로깅/추적이 필요합니다 ❌</li>\n</ul>\n<p>그러나 프롬프트를하는 대신 LLM을 프로그래밍하는 접근 방식을 좋아합니다. 이것은 분야에서 흥미로운 발전이며 예를 들어, 미래의 복합 AI 시스템에 대한 것입니다.</p>\n<div class=\"content-ad\"></div>\n<p>DSPY의 채택 및 추가 개발을 기대하고 있어요.</p>\n<h1>참고 자료</h1>\n<ul>\n<li>💻 DSPy 소개: 인사 대신 프로그래밍으로!</li>\n<li>💻 DSPy: 선언형 언어 모델 호출을 자가 개선 파이프라인으로 컴파일하기</li>\n<li>💻 DSPy 심층 탐구</li>\n</ul>\n</body>\n</html>\n"},"__N_SSG":true}