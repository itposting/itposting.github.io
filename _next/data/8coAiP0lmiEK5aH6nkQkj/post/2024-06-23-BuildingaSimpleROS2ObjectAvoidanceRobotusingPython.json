{"pageProps":{"post":{"title":"파이썬으로 간단한 ROS2 장애물 회피 로봇 만들기 방법","description":"","date":"2024-06-23 18:23","slug":"2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython","content":"\n\n<img src=\"/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png\" />\n\n이 튜토리얼에서는 ROS2 (로봇 운영 시스템 2) 및 Python을 사용하여 간단한 물체 회피 로봇을 구축할 것입니다. 이 로봇은 장애물을 감지하기 위해 LIDAR 센서를 사용하고, 이동을 조정하여 주변을 피해 이동합니다. 이 프로젝트는 ROS2를 시작하는 좋은 방법이며, 센서를 사용하고 로봇의 이동을 제어하는 방법을 배우는 데 도움이 될 것입니다.\n\n# 준비물\n\n시작하기 전에 다음을 갖추고 있는지 확인하세요:\n\n<div class=\"content-ad\"></div>\n\n- ROS2 설치 (Foxy, Galactic 또는 그 이후 버전).\n- Python 프로그래밍에 대한 기본 지식.\n- ROS2를 사용하여 제어되는 LIDAR 센서가 장착된 시뮬레이션된 또는 실제 로봇.\n\n# 프로젝트 개요\n\n우리 프로젝트의 주요 구성 요소는 다음과 같습니다:\n\n- LIDAR 센서: 로봇 주변의 장애물을 감지하는 데 사용됩니다.\n- LaserScan 메시지: LIDAR에서의 거리 데이터를 포함하는 ROS 메시지 유형.\n- Twist 메시지: 로봇의 선형 및 각속도를 제어하는 ROS 메시지 유형.\n- 노드: LIDAR 데이터를 구독하고 속도 명령을 게시하는 ROS2 노드.\n\n<div class=\"content-ad\"></div>\n\n# 코드 설명\n\n아래는 우리의 객체 회피 노드에 대한 완전한 코드입니다:\n\n```python\n#!/usr/bin/env python3\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom geometry_msgs.msg import Twist\n\nclass ObjectAvoidanceNode(Node):\n    def __init__(self):\n        super().__init__('object_avoidance_node')\n        self.subscription = self.create_subscription(\n            LaserScan,\n            'scan',\n            self.lidar_callback,\n            10)\n        self.publisher = self.create_publisher(Twist, 'cmd_vel', 10)\n        self.safe_distance = 0.5  # 미터\n        self.get_logger().info('Object Avoidance Node Started')\n\n    def lidar_callback(self, msg):\n        ranges = msg.ranges\n        min_distance = min(ranges)\n        \n        twist_msg = Twist()\n\n        if min_distance < self.safe_distance:\n            # 장애물 감지, 로봇을 회전시킵니다\n            twist_msg.linear.x = 0.0\n            twist_msg.angular.z = 0.5  # 시계 반대방향으로 회전\n        else:\n            # 장애물 감지되지 않음, 전진합니다\n            twist_msg.linear.x = 0.2\n            twist_msg.angular.z = 0.0\n\n        self.publisher.publish(twist_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = ObjectAvoidanceNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        node.get_logger().info('Keyboard Interrupt (SIGINT)')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n```\n\n# 코드 설명\n\n<div class=\"content-ad\"></div>\n\n- Imports: 필요한 모듈을 rclpy, sensor_msgs.msg 및 geometry_msgs.msg에서 가져옵니다.\n- 노드 초기화: Node를 상속하는 ObjectAvoidanceNode 클래스를 정의합니다. 생성자에서는 LaserScan 메시지를 수신할 /scan 토픽에 대한 구독 및 Twist 메시지를 보낼 /cmd_vel 토픽에 대한 게시자를 설정합니다.\n- LIDAR 콜백: lidar_callback 메서드는 수신된 LaserScan 메시지를 처리합니다. LIDAR가 감지한 장애물까지의 최소 거리를 찾습니다. 이 거리가 self.safe_distance(0.5 미터)보다 작으면 로봇은 전진을 멈추고 장애물을 피하기 위해 회전을 시작합니다. 안전 거리 내에 장애물이 없으면 로봇은 전진합니다.\n- 명령 게시: 감지된 거리에 따라 Twist 메시지에 적절한 선형 및 각속도를 할당하고 /cmd_vel 토픽으로 게시합니다.\n- 메인 함수: 메인 함수는 ROS2 Python 클라이언트 라이브러리를 초기화하고 ObjectAvoidanceNode의 인스턴스를 생성한 다음 (콜백을 처리하며) 스핀을 시작합니다. 노드가 (예: Ctrl+C를 눌러) 중단되면 깔끔하게 종료됩니다.\n\n# 노드 실행\n\nROS2 환경이 정상적으로 소스로드되고 필요한 토픽 (/scan 및 /cmd_vel)이 사용 가능한지 확인하세요.\n\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*XNR1_8EGSFbgsAnJUJ05FQ.gif\" />\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n이 튜토리얼은 ROS2와 Python을 사용하여 객체 회피 로봇의 기본 프레임워크를 제공합니다. 이 코드를 확장하여 장애물 맵핑, 경로 계획 및 다른 센서 통합과 같은 고급 기능을 구현할 수 있습니다. ROS2의 모듈식 아키텍처와 방대한 커뮤니티 지원으로 로봇 개발에 우수한 선택지입니다. 즐거운 코딩되세요!","ogImage":{"url":"/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png"},"coverImage":"/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png","tag":["Tech"],"readingTime":4},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<img src=\"/assets/img/2024-06-23-BuildingaSimpleROS2ObjectAvoidanceRobotusingPython_0.png\">\n<p>이 튜토리얼에서는 ROS2 (로봇 운영 시스템 2) 및 Python을 사용하여 간단한 물체 회피 로봇을 구축할 것입니다. 이 로봇은 장애물을 감지하기 위해 LIDAR 센서를 사용하고, 이동을 조정하여 주변을 피해 이동합니다. 이 프로젝트는 ROS2를 시작하는 좋은 방법이며, 센서를 사용하고 로봇의 이동을 제어하는 방법을 배우는 데 도움이 될 것입니다.</p>\n<h1>준비물</h1>\n<p>시작하기 전에 다음을 갖추고 있는지 확인하세요:</p>\n<div class=\"content-ad\"></div>\n<ul>\n<li>ROS2 설치 (Foxy, Galactic 또는 그 이후 버전).</li>\n<li>Python 프로그래밍에 대한 기본 지식.</li>\n<li>ROS2를 사용하여 제어되는 LIDAR 센서가 장착된 시뮬레이션된 또는 실제 로봇.</li>\n</ul>\n<h1>프로젝트 개요</h1>\n<p>우리 프로젝트의 주요 구성 요소는 다음과 같습니다:</p>\n<ul>\n<li>LIDAR 센서: 로봇 주변의 장애물을 감지하는 데 사용됩니다.</li>\n<li>LaserScan 메시지: LIDAR에서의 거리 데이터를 포함하는 ROS 메시지 유형.</li>\n<li>Twist 메시지: 로봇의 선형 및 각속도를 제어하는 ROS 메시지 유형.</li>\n<li>노드: LIDAR 데이터를 구독하고 속도 명령을 게시하는 ROS2 노드.</li>\n</ul>\n<div class=\"content-ad\"></div>\n<h1>코드 설명</h1>\n<p>아래는 우리의 객체 회피 노드에 대한 완전한 코드입니다:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-comment\">#!/usr/bin/env python3</span>\n\n<span class=\"hljs-keyword\">import</span> rclpy\n<span class=\"hljs-keyword\">from</span> rclpy.node <span class=\"hljs-keyword\">import</span> Node\n<span class=\"hljs-keyword\">from</span> sensor_msgs.msg <span class=\"hljs-keyword\">import</span> LaserScan\n<span class=\"hljs-keyword\">from</span> geometry_msgs.msg <span class=\"hljs-keyword\">import</span> Twist\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ObjectAvoidanceNode</span>(<span class=\"hljs-title class_ inherited__\">Node</span>):\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-built_in\">super</span>().__init__(<span class=\"hljs-string\">'object_avoidance_node'</span>)\n        self.subscription = self.create_subscription(\n            LaserScan,\n            <span class=\"hljs-string\">'scan'</span>,\n            self.lidar_callback,\n            <span class=\"hljs-number\">10</span>)\n        self.publisher = self.create_publisher(Twist, <span class=\"hljs-string\">'cmd_vel'</span>, <span class=\"hljs-number\">10</span>)\n        self.safe_distance = <span class=\"hljs-number\">0.5</span>  <span class=\"hljs-comment\"># 미터</span>\n        self.get_logger().info(<span class=\"hljs-string\">'Object Avoidance Node Started'</span>)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">lidar_callback</span>(<span class=\"hljs-params\">self, msg</span>):\n        ranges = msg.ranges\n        min_distance = <span class=\"hljs-built_in\">min</span>(ranges)\n        \n        twist_msg = Twist()\n\n        <span class=\"hljs-keyword\">if</span> min_distance &#x3C; self.safe_distance:\n            <span class=\"hljs-comment\"># 장애물 감지, 로봇을 회전시킵니다</span>\n            twist_msg.linear.x = <span class=\"hljs-number\">0.0</span>\n            twist_msg.angular.z = <span class=\"hljs-number\">0.5</span>  <span class=\"hljs-comment\"># 시계 반대방향으로 회전</span>\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-comment\"># 장애물 감지되지 않음, 전진합니다</span>\n            twist_msg.linear.x = <span class=\"hljs-number\">0.2</span>\n            twist_msg.angular.z = <span class=\"hljs-number\">0.0</span>\n\n        self.publisher.publish(twist_msg)\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\">args=<span class=\"hljs-literal\">None</span></span>):\n    rclpy.init(args=args)\n    node = ObjectAvoidanceNode()\n\n    <span class=\"hljs-keyword\">try</span>:\n        rclpy.spin(node)\n    <span class=\"hljs-keyword\">except</span> KeyboardInterrupt:\n        node.get_logger().info(<span class=\"hljs-string\">'Keyboard Interrupt (SIGINT)'</span>)\n    <span class=\"hljs-keyword\">finally</span>:\n        node.destroy_node()\n        rclpy.shutdown()\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">'__main__'</span>:\n    main()\n</code></pre>\n<h1>코드 설명</h1>\n<div class=\"content-ad\"></div>\n<ul>\n<li>Imports: 필요한 모듈을 rclpy, sensor_msgs.msg 및 geometry_msgs.msg에서 가져옵니다.</li>\n<li>노드 초기화: Node를 상속하는 ObjectAvoidanceNode 클래스를 정의합니다. 생성자에서는 LaserScan 메시지를 수신할 /scan 토픽에 대한 구독 및 Twist 메시지를 보낼 /cmd_vel 토픽에 대한 게시자를 설정합니다.</li>\n<li>LIDAR 콜백: lidar_callback 메서드는 수신된 LaserScan 메시지를 처리합니다. LIDAR가 감지한 장애물까지의 최소 거리를 찾습니다. 이 거리가 self.safe_distance(0.5 미터)보다 작으면 로봇은 전진을 멈추고 장애물을 피하기 위해 회전을 시작합니다. 안전 거리 내에 장애물이 없으면 로봇은 전진합니다.</li>\n<li>명령 게시: 감지된 거리에 따라 Twist 메시지에 적절한 선형 및 각속도를 할당하고 /cmd_vel 토픽으로 게시합니다.</li>\n<li>메인 함수: 메인 함수는 ROS2 Python 클라이언트 라이브러리를 초기화하고 ObjectAvoidanceNode의 인스턴스를 생성한 다음 (콜백을 처리하며) 스핀을 시작합니다. 노드가 (예: Ctrl+C를 눌러) 중단되면 깔끔하게 종료됩니다.</li>\n</ul>\n<h1>노드 실행</h1>\n<p>ROS2 환경이 정상적으로 소스로드되고 필요한 토픽 (/scan 및 /cmd_vel)이 사용 가능한지 확인하세요.</p>\n<img src=\"https://miro.medium.com/v2/resize:fit:1400/1*XNR1_8EGSFbgsAnJUJ05FQ.gif\">\n<div class=\"content-ad\"></div>\n<h1>결론</h1>\n<p>이 튜토리얼은 ROS2와 Python을 사용하여 객체 회피 로봇의 기본 프레임워크를 제공합니다. 이 코드를 확장하여 장애물 맵핑, 경로 계획 및 다른 센서 통합과 같은 고급 기능을 구현할 수 있습니다. ROS2의 모듈식 아키텍처와 방대한 커뮤니티 지원으로 로봇 개발에 우수한 선택지입니다. 즐거운 코딩되세요!</p>\n</body>\n</html>\n"},"__N_SSG":true}