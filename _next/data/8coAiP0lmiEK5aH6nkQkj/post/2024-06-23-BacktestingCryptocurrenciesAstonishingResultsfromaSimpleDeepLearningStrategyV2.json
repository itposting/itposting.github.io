{"pageProps":{"post":{"title":"간단한 딥러닝 전략으로 암호화폐 백테스팅 결과 공개 버전 2","description":"","date":"2024-06-23 18:42","slug":"2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2","content":"\n\n과거 글이 많은 댓글을 유발하고 의심스럽다는 점을 감안해 코드를 수정하고 결과를 보여드렸어요. 만약 수정할 부분을 발견하시면 알려주세요. 코드나 ONNX 모델이 필요하면 Github 페이지 링크를 남겨드릴게요.\n\n수정한 코드 결과는 다음과 같아요:\n\n![image](/assets/img/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2_0.png)\n\n```js\n평균 절대 오차(MAE): 3.343354936528137\n제곱근 평균 제곱 오차(RMSE): 4.441722762531883\nR-제곱(R2): 0.980843427945431\n평균 절대 백분율 오차(MAPE): 0.023306784351538545\n'SOL_USDT_price_prediction.png'로 저장된 그래프\n실제 가격과 예측 가격의 상관 관계: 0.9927086445091788\n'Estrategia Original'의 샤프 비율: -5.9404285882999135\n'New Strategy'의 샤프 비율: 18.33714244833774\n'New Strategy'의 Sortino Ratio: 117.31843386969027\n'New Strategy'의 Beta: 0.09456945402128551\n'New Strategy'의 Alpha: 0.03367816559565025\nCross-Validation 평균 절대 오차: 91.0050376257974 ± 41.98080676345999\nSMA 평균 절대 오차(MAE): 21.129903598484848\nSMA 제곱근 평균 제곱 오차(RMSE): 30.88072668067209\nSMA R-제곱(R2): 0.6086608043283657\n```\n\n<div class=\"content-ad\"></div>\n\n이것은 설명 동영상입니다:\n\n다음은 수정된 코드입니다:\n\n```js\nimport ccxt\nimport pandas as pd\nimport numpy as np\nimport onnx\nimport onnxruntime as ort\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score, mean_absolute_percentage_error\nfrom sklearn.model_selection import TimeSeriesSplit\n\n# 바이낸스 거래소의 인스턴스 생성\nbinance = ccxt.binance()\n\n# 시장 심볼과 시간 간격 설정\nsymbol = 'SOL/USDT'\ntimeframe = '1d'\nlimit = 1000  # 120일의 데이터 윈도우를 보장하기 위한 충분한 데이터 다운로드\n\n# 과거 데이터 다운로드\nohlcv = binance.fetch_ohlcv(symbol, timeframe, limit=limit)\n\n# 데이터를 판다스 DataFrame으로 변환\ndf = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\ndf['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')\n\n# 데이터를 CSV 파일로 저장\ndf.to_csv('binance_data.csv', index=False)\nprint(\"'binance_data.csv'에 다운로드 및 저장된 데이터\")\n\n# 다운로드된 데이터 로드\ndata = pd.read_csv('binance_data.csv')\n\n# 'timestamp' 열을 날짜 형식으로 변경\ndata['timestamp'] = pd.to_datetime(data['timestamp'])\n\n# 정규화 값 (사용한 값에 맞게 조정)\nmin_close = data['close'].min()\nmax_close = data['close'].max()\n\n# 종가 데이터를 정규화\ndata['close_normalized'] = (data['close'] - min_close) / (max_close - min_close)\n\n# ONNX 모델 로드\nmodel = onnx.load('model_solusdt.onnx')\nonnx.checker.check_model(model)\n\n# 런타임 세션 생성\nort_session = ort.InferenceSession('model_solusdt.onnx')\n\n# 슬라이딩 윈도우 형태로 모델에 입력할 데이터 준비\ninput_name = ort_session.get_inputs()[0].name\nsequence_length = 120  # 모델에 따라 조정\n\n# 예측값 저장할 리스트 생성\npredictions_list = []\n\n# 예측 시작 날짜 설정\nstart_date = pd.Timestamp('2024-01-01')\nend_date = pd.Timestamp.today()\n\n# 하루씩 추론 실행\ncurrent_date = start_date\nwhile current_date < end_date:\n    # 현재 날짜 이전 120일 데이터 선택\n    end_idx = data[data['timestamp'] < current_date].index[-1]\n    start_idx = end_idx - sequence_length + 1\n    \n    if start_idx < 0:\n        print(f\"{current_date}일에 대한 충분한 데이터가 없습니다.\")\n        break\n    \n    # 정규화된 데이터 윈도우 가져오기\n    window = data['close_normalized'].values[start_idx:end_idx+1]\n    \n    if len(window) < sequence_length:\n        print(f\"{current_date}일에 대한 충분한 데이터가 없습니다.\")\n        break\n    \n    # 모델을 위한 데이터 준비\n    input_window = np.array(window).astype(np.float32)\n    input_window = np.expand_dims(input_window, axis=0)  # 배치 사이즈 차원 추가\n    input_window = np.expand_dims(input_window, axis=2)  # 특성 차원 추가\n    \n    # 추론 실행\n    output = ort_session.run(None, {input_name: input_window})\n    prediction = output[0][0][0]\n    \n    # 예측값 역정규화\n    prediction = prediction * (max_close - min_close) + min_close\n    \n    # 예측값 저장\n    predictions_list.append({'date': current_date, 'prediction': prediction})\n    \n    # 날짜 증가\n    current_date += pd.Timedelta(days=1)\n\n# 예측값 리스트를 DataFrame으로 변환\npredictions_df = pd.DataFrame(predictions_list)\n\n# 예측값을 CSV 파일로 저장\npredictions_df.to_csv('predicted_data.csv', index=False)\nprint(\"'predicted_data.csv'에 저장된 예측값\")\n\n# 예측값과 실제값 비교\ncomparison_df = pd.merge(predictions_df, data[['timestamp', 'close']], left_on='date', right_on='timestamp')\ncomparison_df = comparison_df.drop(columns=['timestamp'])\ncomparison_df = comparison_df.rename(columns={'close': 'actual'})\n\n# 에러 메트릭스 계산\nmae = mean_absolute_error(comparison_df['actual'], comparison_df['prediction'])\nrmse = np.sqrt(mean_squared_error(comparison_df['actual'], comparison_df['prediction'])\nr2 = r2_score(comparison_df['actual'], comparison_df['prediction'])\nmape = mean_absolute_percentage_error(comparison_df['actual'], comparison_df['prediction'])\nprint(f'Mean Absolute Error (MAE): {mae}')\nprint(f'Root Mean Squared Error (RMSE): {rmse}')\nprint(f'R-squared (R2): {r2}')\nprint(f'Mean Absolute Percentage Error (MAPE): {mape}')\n\n# 그래프 그리기\nplt.figure(figsize=(14, 7))\nplt.plot(comparison_df['date'], comparison_df['actual'], label='실제 가격', color='blue')\nplt.plot(comparison_df['date'], comparison_df['prediction'], label='예측된 가격', color='red')\nplt.fill_between(comparison_df['date'], comparison_df['prediction'] - mae, comparison_df['prediction'] + mae, color='gray', alpha=0.2, label='에러 밴드 (MAE)')\nplt.xlabel('날짜')\nplt.ylabel('가격')\nplt.title(f'{symbol} 가격 예측 대 비교')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_price_prediction.png\")\nplt.show()\nprint(f\"'{symbol.replace('/', '_')}_price_prediction.png'로 그래프 저장됨\")\n\n# 잔차 분석\nresiduals = comparison_df['actual'] - comparison_df['prediction']\nplt.figure(figsize=(14, 7))\nplt.plot(comparison_df['date'], residuals, label='잔차', color='purple')\nplt.axhline(0, color='black', linestyle='--', linewidth=0.8)\nplt.xlabel('날짜')\nplt.ylabel('잔차')\nplt.title(f'{symbol} 예측 잔차')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_residuals.png\")\nplt.show()\nprint(f\"'{symbol.replace('/', '_')}_residuals.png'로 잔차 그래프 저장됨\")\n\n# 상관 관계 분석\ncorrelation = comparison_df['actual'].corr(comparison_df['prediction'])\nprint(f'실제 가격과 예측 가격 간 상관 관계: {correlation}')\n\n# 투자 전략 시뮬레이션 (기존 전략)\ninvestment_df = comparison_df.copy()\ninvestment_df['strategy_returns'] = (investment_df['prediction'].shift(-1) - investment_df['actual']) / investment_df['actual']\ninvestment_df['buy_and_hold_returns'] = (investment_df['actual'].shift(-1) - investment_df['actual']) / investment_df['actual']\n\nstrategy_cumulative_returns = (investment_df['strategy_returns'] + 1).cumprod() - 1\nbuy_and_hold_cumulative_returns = (investment_df['buy_and_hold_returns'] + 1).cumprod() - 1\n\nplt.figure(figsize=(14, 7))\nplt.plot(investment_df['date'], strategy_cumulative_returns, label='전략 누적 수익', color='green')\nplt.plot(investment_df['date'], buy_and_hold_cumulative_returns, label='보유 및 보유 누적 수익', color='orange')\nplt.xlabel('날짜')\nplt.ylabel('누적 수익')\nplt.title(f'{symbol} 투자 전략 대 보유 및 보유')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_investment_strategy.png\")\nplt.show()\nprint(f\"'{symbol.replace('/', '_')}_investment_strategy.png'로 투자 전략 그래프 저장됨\")\n\n# 손실 표시 계산\ninvestment_df['drawdown'] = strategy_cumulative_returns.cummax() - strategy_cumulative_returns\ninvestment_df['max_drawdown'] = investment_df['drawdown'].max()\n\nplt.figure(figsize=(14, 7))\nplt.plot(investment_df['date'], investment_df['drawdown'], label='손실', color='red')\nplt.xlabel('날짜')\nplt.ylabel('손실')\nplt.title(f'{symbol} 전략 손실')\nplt.legend()\nplt.savefig(f\"{symbol.replace('/', '_')}_drawdown.png\")\nplt.show()\nprint(f\"'{symbol.replace\n\n<div class=\"content-ad\"></div>\n\n```\nimport ccxt\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom sklearn.preprocessing import MinMaxScaler\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Conv1D, MaxPooling1D, Dropout, Flatten\nimport tf2onnx\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom tensorflow.keras import callbacks\nfrom tensorflow.keras.callbacks import ModelCheckpoint\n\n# Binance 데이터를 다운로드하는 함수\ndef descargar_datos(symbol, timeframe='1d', start_date='2000-01-01T00:00:00Z', end_date='2024-01-01T00:00:00Z'):\n    exchange = ccxt.binance({'enableRateLimit': False})\n    since = exchange.parse8601(start_date)\n    end_date_timestamp = pd.to_datetime(end_date, utc=True)\n    all_data = []\n\n    while since < end_date_timestamp.timestamp() * 1000:\n        ohlc = exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=since)\n        all_data.extend(ohlc)\n        since = ohlc[-1][0] + 1  # `since`를 1밀리초 증가\n\n    df = pd.DataFrame(all_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\n    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')\n    df.set_index('timestamp', inplace=True)\n\n    # 두 시간대가 timezone-aware하지 않으면 변환\n    if df.index.tz is None:\n        df.index = df.index.tz_localize('utc')\n    \n    df = df[df.index <= end_date_timestamp]\n    print(df)\n    return df['close'].values\n\n# 데이터 불러오기\ndata = descargar_datos('SOL/USDT')\n\n# 데이터 정규화\nscaler = MinMaxScaler(feature_range=(0, 1))\ndata = scaler.fit_transform(data.reshape(-1, 1))\n\n# 시퀀스에서 샘플을 생성하는 함수\ndef crear_muestras(dataset, pasos_de_tiempo=120):\n    X, y = [], []\n    for i in range(pasos_de_tiempo, len(dataset)):\n        X.append(dataset[i-pasos_de_tiempo:i, 0])\n        y.append(dataset[i, 0])\n    return np.array(X), np.array(y)\n\n# 훈련 및 테스트 데이터 준비\npasos_de_tiempo = 120\nX, y = crear_muestras(data, pasos_de_tiempo)\nX = X.reshape(X.shape[0], X.shape[1], 1)  # LSTM에 맞게 재구성\n\n# 데이터 분할 (훈련용 80%)\nsplit = int(0.8 * len(X))\nX_train, X_test = X[:split], X[split:]\ny_train, y_test = y[:split], y[split:]\n\n# 모델 훈련\n\nmodel = Sequential()\nmodel.add(Conv1D(filters=256, kernel_size=2, activation='relu',padding = 'same',input_shape=(X_train.shape[1],1)))\nmodel.add(MaxPooling1D(pool_size=2))\nmodel.add(LSTM(100, return_sequences = True))\nmodel.add(Dropout(0.3))\nmodel.add(LSTM(100, return_sequences = False))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(units=1, activation = 'sigmoid'))\nmodel.compile(optimizer='adam', loss= 'mse' , metrics = [tf.keras.metrics.RootMeanSquaredError(name='rmse')])\n\n# 조기 종료 설정\nearly_stopping = callbacks.EarlyStopping(\n    monitor='val_loss',\n    patience=5,\n    restore_best_weights=True,\n)\n# 가장 좋은 모델 저장\ncheckpoint = ModelCheckpoint(\n    'best_model.h5', \n    monitor='val_loss', \n    save_best_only=True, \n    save_weights_only=False\n)\n\n\n# 300 에포크로 모델 훈련\nhistory = model.fit(X_train, y_train, epochs = 300 , validation_data = (X_test,y_test), batch_size=32, callbacks=[early_stopping, checkpoint], verbose=2)\n\n# 훈련 이력 그래프\nplt.figure(figsize=(10, 5))\nplt.plot(history.history['loss'], label='Train Loss')\nplt.plot(history.history['val_loss'], label='Validation Loss')\nplt.plot(history.history['rmse'], label='Train RMSE')\nplt.plot(history.history['val_rmse'], label='Validation RMSE')\nplt.title('Model Training History')\nplt.xlabel('Epochs')\nplt.ylabel('Loss/RMSE')\nplt.legend()\nplt.savefig('SOLUSDT.png')  # 그래프를 이미지 파일로 저장\n\n# 모델을 ONNX로 변환\nonnx_model, _ = tf2onnx.convert.from_keras(model, opset=13, output_path=\"model_solusdt.onnx\")\nprint(\"ONNX 모델을 'model_solusdt.onnx'로 저장했습니다.\")\n\n# 모델 평가\ntrain_loss, train_rmse = model.evaluate(X_train, y_train, verbose=0)\ntest_loss, test_rmse = model.evaluate(X_test, y_test, verbose=0)\nprint(f\"train_loss={train_loss:.3f}, train_rmse={train_rmse:.3f}\")\nprint(f\"test_loss={test_loss:.3f}, test_rmse={test_rmse:.3f}\")\n\n\ngithub: Back-testing Cryptocurrencies Astonishing Results from a Simple Deep Learning Strategy\n\nyoutube explanation: [여기를 클릭하여 유튜브 설명 보기](https://youtu.be/z_taWHp_HaI)\n","ogImage":{"url":"/assets/img/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2_0.png"},"coverImage":"/assets/img/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2_0.png","tag":["Tech"],"readingTime":12},"content":"<!doctype html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta content=\"width=device-width, initial-scale=1\" name=\"viewport\">\n</head>\n<body>\n<p>과거 글이 많은 댓글을 유발하고 의심스럽다는 점을 감안해 코드를 수정하고 결과를 보여드렸어요. 만약 수정할 부분을 발견하시면 알려주세요. 코드나 ONNX 모델이 필요하면 Github 페이지 링크를 남겨드릴게요.</p>\n<p>수정한 코드 결과는 다음과 같아요:</p>\n<p><img src=\"/assets/img/2024-06-23-BacktestingCryptocurrenciesAstonishingResultsfromaSimpleDeepLearningStrategyV2_0.png\" alt=\"image\"></p>\n<pre><code class=\"hljs language-js\">평균 절대 오차(<span class=\"hljs-variable constant_\">MAE</span>): <span class=\"hljs-number\">3.343354936528137</span>\n제곱근 평균 제곱 오차(<span class=\"hljs-variable constant_\">RMSE</span>): <span class=\"hljs-number\">4.441722762531883</span>\nR-제곱(<span class=\"hljs-variable constant_\">R2</span>): <span class=\"hljs-number\">0.980843427945431</span>\n평균 절대 백분율 오차(<span class=\"hljs-variable constant_\">MAPE</span>): <span class=\"hljs-number\">0.023306784351538545</span>\n<span class=\"hljs-string\">'SOL_USDT_price_prediction.png'</span>로 저장된 그래프\n실제 가격과 예측 가격의 상관 관계: <span class=\"hljs-number\">0.9927086445091788</span>\n<span class=\"hljs-string\">'Estrategia Original'</span>의 샤프 비율: -<span class=\"hljs-number\">5.9404285882999135</span>\n<span class=\"hljs-string\">'New Strategy'</span>의 샤프 비율: <span class=\"hljs-number\">18.33714244833774</span>\n<span class=\"hljs-string\">'New Strategy'</span>의 <span class=\"hljs-title class_\">Sortino</span> <span class=\"hljs-title class_\">Ratio</span>: <span class=\"hljs-number\">117.31843386969027</span>\n<span class=\"hljs-string\">'New Strategy'</span>의 <span class=\"hljs-title class_\">Beta</span>: <span class=\"hljs-number\">0.09456945402128551</span>\n<span class=\"hljs-string\">'New Strategy'</span>의 <span class=\"hljs-title class_\">Alpha</span>: <span class=\"hljs-number\">0.03367816559565025</span>\n<span class=\"hljs-title class_\">Cross</span>-<span class=\"hljs-title class_\">Validation</span> 평균 절대 오차: <span class=\"hljs-number\">91.0050376257974</span> ± <span class=\"hljs-number\">41.98080676345999</span>\n<span class=\"hljs-variable constant_\">SMA</span> 평균 절대 오차(<span class=\"hljs-variable constant_\">MAE</span>): <span class=\"hljs-number\">21.129903598484848</span>\n<span class=\"hljs-variable constant_\">SMA</span> 제곱근 평균 제곱 오차(<span class=\"hljs-variable constant_\">RMSE</span>): <span class=\"hljs-number\">30.88072668067209</span>\n<span class=\"hljs-variable constant_\">SMA</span> R-제곱(<span class=\"hljs-variable constant_\">R2</span>): <span class=\"hljs-number\">0.6086608043283657</span>\n</code></pre>\n<div class=\"content-ad\"></div>\n<p>이것은 설명 동영상입니다:</p>\n<p>다음은 수정된 코드입니다:</p>\n<pre><code class=\"hljs language-js\"><span class=\"hljs-keyword\">import</span> ccxt\n<span class=\"hljs-keyword\">import</span> pandas <span class=\"hljs-keyword\">as</span> pd\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">import</span> onnx\n<span class=\"hljs-keyword\">import</span> onnxruntime <span class=\"hljs-keyword\">as</span> ort\n<span class=\"hljs-keyword\">import</span> matplotlib.<span class=\"hljs-property\">pyplot</span> <span class=\"hljs-keyword\">as</span> plt\n<span class=\"hljs-keyword\">from</span> sklearn.<span class=\"hljs-property\">metrics</span> <span class=\"hljs-keyword\">import</span> mean_absolute_error, mean_squared_error, r2_score, mean_absolute_percentage_error\n<span class=\"hljs-keyword\">from</span> sklearn.<span class=\"hljs-property\">model_selection</span> <span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">TimeSeriesSplit</span>\n\n# 바이낸스 거래소의 인스턴스 생성\nbinance = ccxt.<span class=\"hljs-title function_\">binance</span>()\n\n# 시장 심볼과 시간 간격 설정\nsymbol = <span class=\"hljs-string\">'SOL/USDT'</span>\ntimeframe = <span class=\"hljs-string\">'1d'</span>\nlimit = <span class=\"hljs-number\">1000</span>  # <span class=\"hljs-number\">120</span>일의 데이터 윈도우를 보장하기 위한 충분한 데이터 다운로드\n\n# 과거 데이터 다운로드\nohlcv = binance.<span class=\"hljs-title function_\">fetch_ohlcv</span>(symbol, timeframe, limit=limit)\n\n# 데이터를 판다스 <span class=\"hljs-title class_\">DataFrame</span>으로 변환\ndf = pd.<span class=\"hljs-title class_\">DataFrame</span>(ohlcv, columns=[<span class=\"hljs-string\">'timestamp'</span>, <span class=\"hljs-string\">'open'</span>, <span class=\"hljs-string\">'high'</span>, <span class=\"hljs-string\">'low'</span>, <span class=\"hljs-string\">'close'</span>, <span class=\"hljs-string\">'volume'</span>])\ndf[<span class=\"hljs-string\">'timestamp'</span>] = pd.<span class=\"hljs-title function_\">to_datetime</span>(df[<span class=\"hljs-string\">'timestamp'</span>], unit=<span class=\"hljs-string\">'ms'</span>)\n\n# 데이터를 <span class=\"hljs-variable constant_\">CSV</span> 파일로 저장\ndf.<span class=\"hljs-title function_\">to_csv</span>(<span class=\"hljs-string\">'binance_data.csv'</span>, index=<span class=\"hljs-title class_\">False</span>)\n<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"'binance_data.csv'에 다운로드 및 저장된 데이터\"</span>)\n\n# 다운로드된 데이터 로드\ndata = pd.<span class=\"hljs-title function_\">read_csv</span>(<span class=\"hljs-string\">'binance_data.csv'</span>)\n\n# <span class=\"hljs-string\">'timestamp'</span> 열을 날짜 형식으로 변경\ndata[<span class=\"hljs-string\">'timestamp'</span>] = pd.<span class=\"hljs-title function_\">to_datetime</span>(data[<span class=\"hljs-string\">'timestamp'</span>])\n\n# 정규화 값 (사용한 값에 맞게 조정)\nmin_close = data[<span class=\"hljs-string\">'close'</span>].<span class=\"hljs-title function_\">min</span>()\nmax_close = data[<span class=\"hljs-string\">'close'</span>].<span class=\"hljs-title function_\">max</span>()\n\n# 종가 데이터를 정규화\ndata[<span class=\"hljs-string\">'close_normalized'</span>] = (data[<span class=\"hljs-string\">'close'</span>] - min_close) / (max_close - min_close)\n\n# <span class=\"hljs-variable constant_\">ONNX</span> 모델 로드\nmodel = onnx.<span class=\"hljs-title function_\">load</span>(<span class=\"hljs-string\">'model_solusdt.onnx'</span>)\nonnx.<span class=\"hljs-property\">checker</span>.<span class=\"hljs-title function_\">check_model</span>(model)\n\n# 런타임 세션 생성\nort_session = ort.<span class=\"hljs-title class_\">InferenceSession</span>(<span class=\"hljs-string\">'model_solusdt.onnx'</span>)\n\n# 슬라이딩 윈도우 형태로 모델에 입력할 데이터 준비\ninput_name = ort_session.<span class=\"hljs-title function_\">get_inputs</span>()[<span class=\"hljs-number\">0</span>].<span class=\"hljs-property\">name</span>\nsequence_length = <span class=\"hljs-number\">120</span>  # 모델에 따라 조정\n\n# 예측값 저장할 리스트 생성\npredictions_list = []\n\n# 예측 시작 날짜 설정\nstart_date = pd.<span class=\"hljs-title class_\">Timestamp</span>(<span class=\"hljs-string\">'2024-01-01'</span>)\nend_date = pd.<span class=\"hljs-property\">Timestamp</span>.<span class=\"hljs-title function_\">today</span>()\n\n# 하루씩 추론 실행\ncurrent_date = start_date\n<span class=\"hljs-keyword\">while</span> current_date &#x3C; <span class=\"hljs-attr\">end_date</span>:\n    # 현재 날짜 이전 <span class=\"hljs-number\">120</span>일 데이터 선택\n    end_idx = data[data[<span class=\"hljs-string\">'timestamp'</span>] &#x3C; current_date].<span class=\"hljs-property\">index</span>[-<span class=\"hljs-number\">1</span>]\n    start_idx = end_idx - sequence_length + <span class=\"hljs-number\">1</span>\n    \n    <span class=\"hljs-keyword\">if</span> start_idx &#x3C; <span class=\"hljs-number\">0</span>:\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"{current_date}일에 대한 충분한 데이터가 없습니다.\"</span>)\n        <span class=\"hljs-keyword\">break</span>\n    \n    # 정규화된 데이터 윈도우 가져오기\n    <span class=\"hljs-variable language_\">window</span> = data[<span class=\"hljs-string\">'close_normalized'</span>].<span class=\"hljs-property\">values</span>[<span class=\"hljs-attr\">start_idx</span>:end_idx+<span class=\"hljs-number\">1</span>]\n    \n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-title function_\">len</span>(<span class=\"hljs-variable language_\">window</span>) &#x3C; <span class=\"hljs-attr\">sequence_length</span>:\n        <span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"{current_date}일에 대한 충분한 데이터가 없습니다.\"</span>)\n        <span class=\"hljs-keyword\">break</span>\n    \n    # 모델을 위한 데이터 준비\n    input_window = np.<span class=\"hljs-title function_\">array</span>(<span class=\"hljs-variable language_\">window</span>).<span class=\"hljs-title function_\">astype</span>(np.<span class=\"hljs-property\">float32</span>)\n    input_window = np.<span class=\"hljs-title function_\">expand_dims</span>(input_window, axis=<span class=\"hljs-number\">0</span>)  # 배치 사이즈 차원 추가\n    input_window = np.<span class=\"hljs-title function_\">expand_dims</span>(input_window, axis=<span class=\"hljs-number\">2</span>)  # 특성 차원 추가\n    \n    # 추론 실행\n    output = ort_session.<span class=\"hljs-title function_\">run</span>(<span class=\"hljs-title class_\">None</span>, {<span class=\"hljs-attr\">input_name</span>: input_window})\n    prediction = output[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>]\n    \n    # 예측값 역정규화\n    prediction = prediction * (max_close - min_close) + min_close\n    \n    # 예측값 저장\n    predictions_list.<span class=\"hljs-title function_\">append</span>({<span class=\"hljs-string\">'date'</span>: current_date, <span class=\"hljs-string\">'prediction'</span>: prediction})\n    \n    # 날짜 증가\n    current_date += pd.<span class=\"hljs-title class_\">Timedelta</span>(days=<span class=\"hljs-number\">1</span>)\n\n# 예측값 리스트를 <span class=\"hljs-title class_\">DataFrame</span>으로 변환\npredictions_df = pd.<span class=\"hljs-title class_\">DataFrame</span>(predictions_list)\n\n# 예측값을 <span class=\"hljs-variable constant_\">CSV</span> 파일로 저장\npredictions_df.<span class=\"hljs-title function_\">to_csv</span>(<span class=\"hljs-string\">'predicted_data.csv'</span>, index=<span class=\"hljs-title class_\">False</span>)\n<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">\"'predicted_data.csv'에 저장된 예측값\"</span>)\n\n# 예측값과 실제값 비교\ncomparison_df = pd.<span class=\"hljs-title function_\">merge</span>(predictions_df, data[[<span class=\"hljs-string\">'timestamp'</span>, <span class=\"hljs-string\">'close'</span>]], left_on=<span class=\"hljs-string\">'date'</span>, right_on=<span class=\"hljs-string\">'timestamp'</span>)\ncomparison_df = comparison_df.<span class=\"hljs-title function_\">drop</span>(columns=[<span class=\"hljs-string\">'timestamp'</span>])\ncomparison_df = comparison_df.<span class=\"hljs-title function_\">rename</span>(columns={<span class=\"hljs-string\">'close'</span>: <span class=\"hljs-string\">'actual'</span>})\n\n# 에러 메트릭스 계산\nmae = <span class=\"hljs-title function_\">mean_absolute_error</span>(comparison_df[<span class=\"hljs-string\">'actual'</span>], comparison_df[<span class=\"hljs-string\">'prediction'</span>])\nrmse = np.<span class=\"hljs-title function_\">sqrt</span>(<span class=\"hljs-title function_\">mean_squared_error</span>(comparison_df[<span class=\"hljs-string\">'actual'</span>], comparison_df[<span class=\"hljs-string\">'prediction'</span>])\nr2 = <span class=\"hljs-title function_\">r2_score</span>(comparison_df[<span class=\"hljs-string\">'actual'</span>], comparison_df[<span class=\"hljs-string\">'prediction'</span>])\nmape = <span class=\"hljs-title function_\">mean_absolute_percentage_error</span>(comparison_df[<span class=\"hljs-string\">'actual'</span>], comparison_df[<span class=\"hljs-string\">'prediction'</span>])\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">'Mean Absolute Error (MAE): {mae}'</span>)\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">'Root Mean Squared Error (RMSE): {rmse}'</span>)\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">'R-squared (R2): {r2}'</span>)\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">'Mean Absolute Percentage Error (MAPE): {mape}'</span>)\n\n# 그래프 그리기\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">7</span>))\nplt.<span class=\"hljs-title function_\">plot</span>(comparison_df[<span class=\"hljs-string\">'date'</span>], comparison_df[<span class=\"hljs-string\">'actual'</span>], label=<span class=\"hljs-string\">'실제 가격'</span>, color=<span class=\"hljs-string\">'blue'</span>)\nplt.<span class=\"hljs-title function_\">plot</span>(comparison_df[<span class=\"hljs-string\">'date'</span>], comparison_df[<span class=\"hljs-string\">'prediction'</span>], label=<span class=\"hljs-string\">'예측된 가격'</span>, color=<span class=\"hljs-string\">'red'</span>)\nplt.<span class=\"hljs-title function_\">fill_between</span>(comparison_df[<span class=\"hljs-string\">'date'</span>], comparison_df[<span class=\"hljs-string\">'prediction'</span>] - mae, comparison_df[<span class=\"hljs-string\">'prediction'</span>] + mae, color=<span class=\"hljs-string\">'gray'</span>, alpha=<span class=\"hljs-number\">0.2</span>, label=<span class=\"hljs-string\">'에러 밴드 (MAE)'</span>)\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'날짜'</span>)\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'가격'</span>)\nplt.<span class=\"hljs-title function_\">title</span>(f<span class=\"hljs-string\">'{symbol} 가격 예측 대 비교'</span>)\nplt.<span class=\"hljs-title function_\">legend</span>()\nplt.<span class=\"hljs-title function_\">savefig</span>(f<span class=\"hljs-string\">\"{symbol.replace('/', '_')}_price_prediction.png\"</span>)\nplt.<span class=\"hljs-title function_\">show</span>()\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"'{symbol.replace('/', '_')}_price_prediction.png'로 그래프 저장됨\"</span>)\n\n# 잔차 분석\nresiduals = comparison_df[<span class=\"hljs-string\">'actual'</span>] - comparison_df[<span class=\"hljs-string\">'prediction'</span>]\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">7</span>))\nplt.<span class=\"hljs-title function_\">plot</span>(comparison_df[<span class=\"hljs-string\">'date'</span>], residuals, label=<span class=\"hljs-string\">'잔차'</span>, color=<span class=\"hljs-string\">'purple'</span>)\nplt.<span class=\"hljs-title function_\">axhline</span>(<span class=\"hljs-number\">0</span>, color=<span class=\"hljs-string\">'black'</span>, linestyle=<span class=\"hljs-string\">'--'</span>, linewidth=<span class=\"hljs-number\">0.8</span>)\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'날짜'</span>)\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'잔차'</span>)\nplt.<span class=\"hljs-title function_\">title</span>(f<span class=\"hljs-string\">'{symbol} 예측 잔차'</span>)\nplt.<span class=\"hljs-title function_\">legend</span>()\nplt.<span class=\"hljs-title function_\">savefig</span>(f<span class=\"hljs-string\">\"{symbol.replace('/', '_')}_residuals.png\"</span>)\nplt.<span class=\"hljs-title function_\">show</span>()\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"'{symbol.replace('/', '_')}_residuals.png'로 잔차 그래프 저장됨\"</span>)\n\n# 상관 관계 분석\ncorrelation = comparison_df[<span class=\"hljs-string\">'actual'</span>].<span class=\"hljs-title function_\">corr</span>(comparison_df[<span class=\"hljs-string\">'prediction'</span>])\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">'실제 가격과 예측 가격 간 상관 관계: {correlation}'</span>)\n\n# 투자 전략 시뮬레이션 (기존 전략)\ninvestment_df = comparison_df.<span class=\"hljs-title function_\">copy</span>()\ninvestment_df[<span class=\"hljs-string\">'strategy_returns'</span>] = (investment_df[<span class=\"hljs-string\">'prediction'</span>].<span class=\"hljs-title function_\">shift</span>(-<span class=\"hljs-number\">1</span>) - investment_df[<span class=\"hljs-string\">'actual'</span>]) / investment_df[<span class=\"hljs-string\">'actual'</span>]\ninvestment_df[<span class=\"hljs-string\">'buy_and_hold_returns'</span>] = (investment_df[<span class=\"hljs-string\">'actual'</span>].<span class=\"hljs-title function_\">shift</span>(-<span class=\"hljs-number\">1</span>) - investment_df[<span class=\"hljs-string\">'actual'</span>]) / investment_df[<span class=\"hljs-string\">'actual'</span>]\n\nstrategy_cumulative_returns = (investment_df[<span class=\"hljs-string\">'strategy_returns'</span>] + <span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">cumprod</span>() - <span class=\"hljs-number\">1</span>\nbuy_and_hold_cumulative_returns = (investment_df[<span class=\"hljs-string\">'buy_and_hold_returns'</span>] + <span class=\"hljs-number\">1</span>).<span class=\"hljs-title function_\">cumprod</span>() - <span class=\"hljs-number\">1</span>\n\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">7</span>))\nplt.<span class=\"hljs-title function_\">plot</span>(investment_df[<span class=\"hljs-string\">'date'</span>], strategy_cumulative_returns, label=<span class=\"hljs-string\">'전략 누적 수익'</span>, color=<span class=\"hljs-string\">'green'</span>)\nplt.<span class=\"hljs-title function_\">plot</span>(investment_df[<span class=\"hljs-string\">'date'</span>], buy_and_hold_cumulative_returns, label=<span class=\"hljs-string\">'보유 및 보유 누적 수익'</span>, color=<span class=\"hljs-string\">'orange'</span>)\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'날짜'</span>)\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'누적 수익'</span>)\nplt.<span class=\"hljs-title function_\">title</span>(f<span class=\"hljs-string\">'{symbol} 투자 전략 대 보유 및 보유'</span>)\nplt.<span class=\"hljs-title function_\">legend</span>()\nplt.<span class=\"hljs-title function_\">savefig</span>(f<span class=\"hljs-string\">\"{symbol.replace('/', '_')}_investment_strategy.png\"</span>)\nplt.<span class=\"hljs-title function_\">show</span>()\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"'{symbol.replace('/', '_')}_investment_strategy.png'로 투자 전략 그래프 저장됨\"</span>)\n\n# 손실 표시 계산\ninvestment_df[<span class=\"hljs-string\">'drawdown'</span>] = strategy_cumulative_returns.<span class=\"hljs-title function_\">cummax</span>() - strategy_cumulative_returns\ninvestment_df[<span class=\"hljs-string\">'max_drawdown'</span>] = investment_df[<span class=\"hljs-string\">'drawdown'</span>].<span class=\"hljs-title function_\">max</span>()\n\nplt.<span class=\"hljs-title function_\">figure</span>(figsize=(<span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">7</span>))\nplt.<span class=\"hljs-title function_\">plot</span>(investment_df[<span class=\"hljs-string\">'date'</span>], investment_df[<span class=\"hljs-string\">'drawdown'</span>], label=<span class=\"hljs-string\">'손실'</span>, color=<span class=\"hljs-string\">'red'</span>)\nplt.<span class=\"hljs-title function_\">xlabel</span>(<span class=\"hljs-string\">'날짜'</span>)\nplt.<span class=\"hljs-title function_\">ylabel</span>(<span class=\"hljs-string\">'손실'</span>)\nplt.<span class=\"hljs-title function_\">title</span>(f<span class=\"hljs-string\">'{symbol} 전략 손실'</span>)\nplt.<span class=\"hljs-title function_\">legend</span>()\nplt.<span class=\"hljs-title function_\">savefig</span>(f<span class=\"hljs-string\">\"{symbol.replace('/', '_')}_drawdown.png\"</span>)\nplt.<span class=\"hljs-title function_\">show</span>()\n<span class=\"hljs-title function_\">print</span>(f<span class=\"hljs-string\">\"'{symbol.replace\n\n&#x3C;div class=\"</span>content-ad<span class=\"hljs-string\">\">&#x3C;/div>\n\n</span></code></pre>\n<p>import ccxt\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom sklearn.preprocessing import MinMaxScaler\nimport tensorflow as tf\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense, LSTM, Conv1D, MaxPooling1D, Dropout, Flatten\nimport tf2onnx\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom tensorflow.keras import callbacks\nfrom tensorflow.keras.callbacks import ModelCheckpoint</p>\n<h1>Binance 데이터를 다운로드하는 함수</h1>\n<p>def descargar_datos(symbol, timeframe='1d', start_date='2000-01-01T00:00:00Z', end_date='2024-01-01T00:00:00Z'):\nexchange = ccxt.binance({'enableRateLimit': False})\nsince = exchange.parse8601(start_date)\nend_date_timestamp = pd.to_datetime(end_date, utc=True)\nall_data = []</p>\n<pre><code>while since &#x3C; end_date_timestamp.timestamp() * 1000:\n    ohlc = exchange.fetch_ohlcv(symbol, timeframe=timeframe, since=since)\n    all_data.extend(ohlc)\n    since = ohlc[-1][0] + 1  # `since`를 1밀리초 증가\n\ndf = pd.DataFrame(all_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])\ndf['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')\ndf.set_index('timestamp', inplace=True)\n\n# 두 시간대가 timezone-aware하지 않으면 변환\nif df.index.tz is None:\n    df.index = df.index.tz_localize('utc')\n\ndf = df[df.index &#x3C;= end_date_timestamp]\nprint(df)\nreturn df['close'].values\n</code></pre>\n<h1>데이터 불러오기</h1>\n<p>data = descargar_datos('SOL/USDT')</p>\n<h1>데이터 정규화</h1>\n<p>scaler = MinMaxScaler(feature_range=(0, 1))\ndata = scaler.fit_transform(data.reshape(-1, 1))</p>\n<h1>시퀀스에서 샘플을 생성하는 함수</h1>\n<p>def crear_muestras(dataset, pasos_de_tiempo=120):\nX, y = [], []\nfor i in range(pasos_de_tiempo, len(dataset)):\nX.append(dataset[i-pasos_de_tiempo:i, 0])\ny.append(dataset[i, 0])\nreturn np.array(X), np.array(y)</p>\n<h1>훈련 및 테스트 데이터 준비</h1>\n<p>pasos_de_tiempo = 120\nX, y = crear_muestras(data, pasos_de_tiempo)\nX = X.reshape(X.shape[0], X.shape[1], 1)  # LSTM에 맞게 재구성</p>\n<h1>데이터 분할 (훈련용 80%)</h1>\n<p>split = int(0.8 * len(X))\nX_train, X_test = X[:split], X[split:]\ny_train, y_test = y[:split], y[split:]</p>\n<h1>모델 훈련</h1>\n<p>model = Sequential()\nmodel.add(Conv1D(filters=256, kernel_size=2, activation='relu',padding = 'same',input_shape=(X_train.shape[1],1)))\nmodel.add(MaxPooling1D(pool_size=2))\nmodel.add(LSTM(100, return_sequences = True))\nmodel.add(Dropout(0.3))\nmodel.add(LSTM(100, return_sequences = False))\nmodel.add(Dropout(0.3))\nmodel.add(Dense(units=1, activation = 'sigmoid'))\nmodel.compile(optimizer='adam', loss= 'mse' , metrics = [tf.keras.metrics.RootMeanSquaredError(name='rmse')])</p>\n<h1>조기 종료 설정</h1>\n<p>early_stopping = callbacks.EarlyStopping(\nmonitor='val_loss',\npatience=5,\nrestore_best_weights=True,\n)</p>\n<h1>가장 좋은 모델 저장</h1>\n<p>checkpoint = ModelCheckpoint(\n'best_model.h5',\nmonitor='val_loss',\nsave_best_only=True,\nsave_weights_only=False\n)</p>\n<h1>300 에포크로 모델 훈련</h1>\n<p>history = model.fit(X_train, y_train, epochs = 300 , validation_data = (X_test,y_test), batch_size=32, callbacks=[early_stopping, checkpoint], verbose=2)</p>\n<h1>훈련 이력 그래프</h1>\n<p>plt.figure(figsize=(10, 5))\nplt.plot(history.history['loss'], label='Train Loss')\nplt.plot(history.history['val_loss'], label='Validation Loss')\nplt.plot(history.history['rmse'], label='Train RMSE')\nplt.plot(history.history['val_rmse'], label='Validation RMSE')\nplt.title('Model Training History')\nplt.xlabel('Epochs')\nplt.ylabel('Loss/RMSE')\nplt.legend()\nplt.savefig('SOLUSDT.png')  # 그래프를 이미지 파일로 저장</p>\n<h1>모델을 ONNX로 변환</h1>\n<p>onnx_model, _ = tf2onnx.convert.from_keras(model, opset=13, output_path=\"model_solusdt.onnx\")\nprint(\"ONNX 모델을 'model_solusdt.onnx'로 저장했습니다.\")</p>\n<h1>모델 평가</h1>\n<p>train_loss, train_rmse = model.evaluate(X_train, y_train, verbose=0)\ntest_loss, test_rmse = model.evaluate(X_test, y_test, verbose=0)\nprint(f\"train_loss={train_loss:.3f}, train_rmse={train_rmse:.3f}\")\nprint(f\"test_loss={test_loss:.3f}, test_rmse={test_rmse:.3f}\")</p>\n<p>github: Back-testing Cryptocurrencies Astonishing Results from a Simple Deep Learning Strategy</p>\n<p>youtube explanation: <a href=\"https://youtu.be/z_taWHp_HaI\" rel=\"nofollow\" target=\"_blank\">여기를 클릭하여 유튜브 설명 보기</a></p>\n</body>\n</html>\n"},"__N_SSG":true}