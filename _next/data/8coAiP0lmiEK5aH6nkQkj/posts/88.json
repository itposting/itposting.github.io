{"pageProps":{"posts":[{"title":"사물 인터넷 프로토콜  HTTP 2, WebSocket, MQTT, Zigbee, Matter 및 Thread","description":"","date":"2024-06-19 05:42","slug":"2024-06-19-IoTProtocolsHTTP2WebSocketMQTTZigbeeMatterandThread","content":"\n\n<img src=\"/assets/img/2024-06-19-IoTProtocolsHTTP2WebSocketMQTTZigbeeMatterandThread_0.png\" />\n\nIoT 장치는 우리 삶 속에 어디에나 존재합니다. 직장에서, 집에서, 도시에서 모두 사용됩니다. 그들은 상태와 업무에 따라 데이터를 송수신하기 위해 사설 네트워크 또는 인터넷을 사용합니다. Amazon Echo와 Google Home 같은 인기 있는 예시를 고려하면 IoT가 스마트폰과 같이 우리 삶을 최종적으로 지배할 것임을 알 수 있습니다. 이 기술이 발전함에 따라 작동하는 프로토콜도 발전해야 합니다.\n\n이 게시물에서 오늘날 사용 가능한 IoT 프로토콜에 대한 개요를 제공하겠습니다!\n\n각 프로토콜의 주요 기능을 ChatGPT가 요약한 것을 주의해 주세요 :)\n\n<div class=\"content-ad\"></div>\n\n# HTTP/2\n\nHTTP/2는 그 전 버전인 HTTP/1.1을 향상시킨 월드 와이드 웹 프로토콜입니다. 웹 통신의 성능과 효율성을 향상시키기 위해 설계되었습니다. 대기 시간을 줄이고 페이지 로드 시간을 더 빠르게 하며 리소스 전달을 최적화함으로써 웹 통신을 개선하는 것이 목표입니다.\n\nHTTP/2는 IoT 통신에 여러 가지 개선 사항을 가져왔습니다. 다중화를 도입하여 단일 TCP 연결을 통해 여러 요청과 응답을 보낼 수 있도록 하여 여러 연결이 필요 없어지고 효율성이 향상되었습니다. 이는 HTTP/1.1에서 사용되는 텍스트 형식보다 더 간결하고 효율적인 바이너리 프로토콜을 채택하여 통신을 더 빠르고 신뢰할 수 있도록 했습니다. HTTP/2는 HPACK 알고리즘을 사용하여 헤더 압축을 채택하여 중복되거나 불필요한 헤더가 많은 요청에 대한 데이터 전송 오버헤드를 줄이는 장점을 가졌습니다. 또한, 서버 푸시를 도입하여 서버가 클라이언트 캐시로 리소스를 미리 전송함으로써 왕복 시간을 줄이고 페이지 로드 시간을 높일 수 있습니다.\n\n[HTTP/2 (github.com)](https://github.com)\n\n<div class=\"content-ad\"></div>\n\n# 웹소켓\n\nHTTP/1의 전통적인 요청-응답 모델과는 다르게 웹소켓은 클라이언트와 서버 간에 실시간, 양방향 통신을 하나의 TCP 연결을 통해 가능하게 합니다. 이는 HTTP/2와 유사한 풀-듀플렉스 형태를 띠고 있습니다. 웹소켓은 클라이언트와 서버 간의 연결을 유지하며 오버헤드와 지연 시간을 줄여줍니다. 웹소켓은 경량 헤더를 사용하여 HTTP/1에 비해 오버헤드가 낮습니다. 이는 작은 데이터 패킷을 자주 보내는 것에 효율적이며 특히 실시간 애플리케이션에 유용합니다. \n\nHTTP/2와 웹소켓 사이의 유사점을 주목하고 묻는 것이 좋습니다: 왜 새로운 기술인 HTTP/2를 사용하지 않는 대신에 웹소켓을 사용해야 하는 것일까요? 핵심은 HTTP/2에 소개된 서버 푸시가 데이터를 클라이언트에게 직접이 아닌 클라이언트 애플리케이션으로 전송하는 것이라는 점입니다. 따라서 많은 기기는 웹소켓에서 제공하는 추가적인 핸드쉐이크와 유사한 것이 여전히 필요할 것입니다.\n\n[http2 — Does HTTP/2 make websockets obsolete? — Stack Overflow](#)\n\n<div class=\"content-ad\"></div>\n\n웹소켓/ws: Node.js를 위한 사용하기 쉽고 빠르며 철저히 테스트된 WebSocket 클라이언트 및 서버입니다. (github.com)\n\n# MQTT\n\n메시지 큐잉 텔레메트리 전송은 제한된 자원 환경에서의 경량 IoT 프로토콜입니다. 발행-구독 패턴에서 효율적인 기계 간 통신을 위해 설계되었습니다.\n\n다음은 MQTT의 주요 기능 중 일부입니다:\n\n<div class=\"content-ad\"></div>\n\n- 가볍고 효율적인: MQTT는 가벼우며 효율적으로 설계되어, 리소스가 제한된 기기와 저대역폭 네트워크에 적합합니다. 작은 메시지 헤더와 이진 페이로드 형식을 사용하여 데이터 오버헤드를 최소화합니다.\n- 서비스 품질(QoS) 수준: MQTT는 신뢰할 수 있는 메시지 전달을 보장하기 위해 다양한 수준의 서비스 품질을 지원합니다. 세 가지 QoS 수준은 \"최대 한 번\" (발송 및 소멸), \"적어도 한 번\" (확인) 및 \"정확히 한 번\" (보증 전달)입니다. 적절한 수준은 응용 프로그램 요구 사항에 기반하여 선택할 수 있습니다.\n- 지속적인 연결: MQTT는 기기와 브로커 간의 지속적인 연결을 허용합니다. 연결이 설정되면 기기는 열어 둘 수 있어 각 메시지마다 새로운 연결을 설정하는 오버헤드를 최소화할 수 있습니다.\n- 유언과 테스터먼트 (LWT): MQTT는 기기가 예상치 못한 연결 해제 시 브로커가 발행할 메시지를 지정할 수 있는 유언과 테스터먼트라는 기능을 제공합니다. 이 기능을 통해 오프라인 기기의 감지와 처리가 가능해집니다.\n\neclipse/mosquitto: Eclipse Mosquitto — 오픈 소스 MQTT 브로커 (github.com)\n\n# 지그비\n\n지그비는 무선 통신 프로토콜입니다. 스마트 홈, 건물 자동화, 산업 자동화 및 무선 센서 네트워크를 포함한 다양한 분야에서 응용되었습니다. 저전력 소비, 망 네트워킹 및 신뢰성에 중점을 둔 지그비는 배터리 구동 기기가 로컬 네트워크 내에서 무선으로 통신해야 하는 시나리오에 적합합니다.\n\n<div class=\"content-ad\"></div>\n\nZigbee의 주요 특성과 기능은 다음과 같습니다:\n\n- 저전력 소비: Zigbee는 저전력 수면 모드를 활용하여 기기가 데이터를 전송하거나 수신하지 않을 때 전력을 절약할 수 있습니다. 이는 Zigbee를 사용하는 기기들이 오랜 배터리 수명을 가질 수 있도록 합니다.\n- 메시 네트워킹: Zigbee는 메시 네트워킹 토폴로지를 사용하여 기기가 종단 장치 및 라우터 역할을 할 수 있습니다. 각 기기는 무선 범위 내의 다른 기기들과 직접 통신하거나 이웃 기기를 중계로 사용하여 메시지를 전달할 수 있습니다. 이는 자가 치유 및 자가 구성 네트워크를 형성하여 확장된 커버리지를 제공하고 네트워크의 내구성을 높일 수 있습니다.\n- 신뢰성 및 간섭 회피: Zigbee는 다른 무선 장치들의 간섭을 피하기 위해 주파수 호핑 기술을 사용합니다. 이는 통신 신뢰성을 유지하기 위해 동적으로 채널을 변경하며 간섭이 발생해도 통신이 유지됩니다.\n- 낮은 데이터 전송 속도: Zigbee는 몇 킬로비트에서 몇 백 킬로비트까지의 낮은 데이터 전송 속도를 필요로 하는 응용 프로그램에 최적화되어 있습니다. 이는 에너지 효율성과 오랜 배터리 수명을 우선시하는 응용 프로그램에 적합합니다.\n\nSmartThingsCommunity/SmartThingsPublic: SmartThings 오픈 소스 DeviceType Handlers 및 SmartApps 코드 (github.com)\n\n# Matter\n\n<div class=\"content-ad\"></div>\n\nMatter 프로토콜은 Apple, Google, Amazon 및 Zigbee Alliance를 포함한 주요 기술 회사들을 결합한 오픈 소스, 로열티 없는 연결 프로토콜입니다. Matter의 목표는 서로 다른 제조업체의 스마트 홈 기기들이 어떤 기술을 기반으로 하든 상호 운용성과 쉬운 설정을 가능케 하는 것입니다.\n\n다음은 Matter 프로토콜의 주요 측면 몇 가지입니다:\n\n- 상호 운용성: Matter는 스마트 기기가 브랜드나 소프트웨어 생태계와 관계없이 서로 매끄럽게 작동할 수 있도록 하는 공통 표준을 수립하는 것을 목표로 합니다.\n- 연결에 중립적: Matter는 기술적인 네트워크 기술과 독립적으로 설계되었습니다. Wi-Fi, 이더넷, Thread 및 심지어 Zigbee 및 Bluetooth Low Energy (BLE)와 같은 저전력 무선 프로토콜 등 다양한 연결 프로토콜에서 작동할 수 있습니다.\n- 쉬운 설정 및 구성: Matter는 스마트 홈 기기의 설정 및 구성 과정을 간소화합니다. 다양한 스마트 홈 플랫폼 및 앱이 장치를 쉽게 찾아내고 추가하고 제어할 수 있는 통합 설정 경험을 소개합니다.\n- 개발자 친화적: Matter 프로토콜은 표준화된 API 및 도구를 제공하여 스마트 홈 기기의 개발 및 통합을 간소화하는 개발자 친화적 환경을 제공합니다.\n\n프로젝트-chip/connectedhomeip: Matter (이전 Project CHIP)는 더 많은 객체 간 더 많은 연결을 만들어 제조업체들에게 개발을 단순화하고 소비자들에게 호환성을 높이도록 안내되는 Connectivity Standards Alliance의 지도 아래 놓인 것입니다. (github.com)\n\n<div class=\"content-ad\"></div>\n\n# 쓰레드\n\n쓰레드는 IoT와 스마트 홈 애플리케이션을 위해 특별히 설계된 무선 네트워킹 프로토콜입니다. IPv6을 기반으로하며 저전력 무선 네트워크에서 작동합니다. 서로 다른 쓰레드 인증을 받은 장치들 간의 상호 운용성을 보장하여 쓰레드 네트워크 내에서 원활한 통신과 통합을 가능하게 합니다.\n\n다음은 쓰레드 프로토콜의 주요 기능과 특성입니다:\n\n- 망공예: 쓰레드는 망공예 네트워킹 토폴로지를 활용하여, 장치들이 라우터 및 중계기로 작동하여 네트워크 범위를 확장할 수 있습니다. 네트워크의 각 장치는 이웃하는 장치와 직접 통신하거나 중간 장치를 이용하여 메시지를 중계함으로써, 스스로 치유 기능을 가진 견고한 네트워크 인프라를 생성합니다.\n- IP 기반 프로토콜: 쓰레드는 대규모 주소 공간을 제공하는 IPv6에 기초하여, 인터넷을 통한 장치 간의 직접 통신을 가능하게 합니다.\n- 저전력 소비: 쓰레드는 에너지 효율적으로 설계되어, 장치들이 장기간 배터리 전원으로 작동할 수 있도록 합니다. 저전력 주기 운영, 수면 모드 및 효율적인 라우팅 프로토콜과 같은 메커니즘을 통해 전력 소비를 최소화합니다.\n- 쉬운 설정 및 인가: 쓰레드는 네트워크 내에서 장치를 설정하고 인가하는 프로세스를 간단화합니다. 사용자 경험을 향상시키기 위해, 장치의 쉬운 발견, 온보딩 및 구성을 제공하여 배포의 복잡성을 줄입니다.\n\n<div class=\"content-ad\"></div>\n\nopenthread/openthread: 구글에서 공개한 OpenThread은 Thread 네트워킹 프로토콜의 오픈 소스 구현입니다 (github.com)\n\n# 요약\n\n프로토콜의 선택은 확장성, 전력 소비, 상호 운용성 및 응용프로그램 도메인과 같은 구체적 요구 사항에 따라 다릅니다. IoT 생태계 내에서 다양한 요구 사항을 충족하기 위해 여러 프로토콜을 결합한 구현체를 찾는 것이 일반적입니다.\n\nHTTP/2 및 WebSocket은 주로 웹 기반 응용프로그램에 사용되며, HTTP/2는 효율적이고 다중화된 통신을 제공하며, WebSocket은 클라이언트와 서버 간 실시간 양방향 통신을 가능하게 합니다.\n\n<div class=\"content-ad\"></div>\n\nMQTT, Matter, Thread, 그리고 Zigbee는 IoT 애플리케이션을 위해 특별히 설계된 프로토콜로, 메시징, 상호 운용성, 메시 네트워킹, 그리고 저전력 기능에 중점을 둡니다.\n\n- MQTT는 IoT 장치 및 시스템 간 확장 가능하고 실시간 통신에 적합한 일반적인 목적의 메시징 프로토콜입니다.\n- Matter는 스마트 홈 장치를 위한 상호 운용 가능한 표준을 만드는 데 중점을 둠으로써 다른 브랜드 간에 간편한 설정 및 원활한 통신을 가능하게 합니다.\n- Thread는 IoT 및 스마트 홈 애플리케이션을 위해 설계된 메시 네트워킹 프로토콜으로 신뢰성, 보안, 그리고 저전력 소비를 강조합니다.\n- Zigbee는 저전력, 저 데이터 전송 속도 애플리케이션에 최적화된 무선 프로토콜로, 홈 오토메이션 및 산업 제어에서 상호 운용성을 위한 메시 네트워킹 및 표준화된 프로필을 제공합니다.","ogImage":{"url":"/assets/img/2024-06-19-IoTProtocolsHTTP2WebSocketMQTTZigbeeMatterandThread_0.png"},"coverImage":"/assets/img/2024-06-19-IoTProtocolsHTTP2WebSocketMQTTZigbeeMatterandThread_0.png","tag":["Tech"],"readingTime":6},{"title":"홈 어시스턴트에서 AppDaemon을 사용하여 투야Tuya 기기 문제 해결하기","description":"","date":"2024-06-19 05:41","slug":"2024-06-19-FixingTuyaDeviceProblemsinHomeAssistantwithAppDaemon","content":"\n\n![2024-06-19-FixingTuyaDeviceProblemsinHomeAssistantwithAppDaemon_0.png](/assets/img/2024-06-19-FixingTuyaDeviceProblemsinHomeAssistantwithAppDaemon_0.png)\n안녕하세요! 스마트 홈 열정가들에게 이상적인 솔루션으로 떠오르는 홈 어시스턴트는 다양한 생태계의 장치를 연결하는 자유를 찾는 분들에게 완벽한 선택지입니다. 상품 특정 허브와 소프트웨어의 제한에 얽매이지 않고 장치 간 원활한 통신을 가능케 하며 종종 비교할 수 없는 수준의 맞춤 설정과 제어를 제공합니다. 하지만 잘 알려진 안드로이드 vs. iOS 논쟁과 같이, 이 자유는 별도의 어려움을 동반합니다. 주요 단점 중 하나는 홈 어시스턴트가 지원하는 장치에 엄격한 품질 통제가 없다는 점입니다. 때로는 제대로 설계되지 않은 장치 통합이 시스템에 슬쩍 들어가 사용자들에게 많은 당혹감을 야기할 수 있습니다.\n\n본 문서에서는 홈 어시스턴트의 Tuya 통합에서 마주한 특정 문제와 AppDaemon을 사용하여 해결한 경험을 공유하겠습니다.\n\n# 문제: 결함이 있는 Tuya 도어벨\n\n<div class=\"content-ad\"></div>\n\n알리익스프레스에서 싸게 구입한 Wi-Fi 비디오 도어벨이 있어요. 네, 알아요, 조금은 도박 같은 느낌이긴 하죠. 하지만 리뷰가 나쁘지 않았고, 더 인기 있는 대안들처럼 월 구독비를 내고 싶지 않았어요.\n\n도어벨 성능이 실망스러웠어요. 비디오 스트리밍이 느리고, 문을 누르면 홈 어시스턴트에 알림이나 센서가 없었어요. 도어벨이 배터리로 작동하다보니, 배터리가 완전히 소진되기 전에 충전할 방법이 필요했어요. 아쉽게도 홈 어시스턴트의 투야(Tuya) 통합은 배터리 수준을 부정확하게 표시했어요. 백분율이 아니라 100%에 대해 10.0, 65%에 대해 6.5와 같은 값으로 표시되었죠.\n\n홈 어시스턴트 설정에 저의 저전력 경고를 관리하는 자동화가 있어요. 저는 이전에 홈 어시스턴트 템플릿에 관한 글에서 자세히 설명했어요. 이 도어벨 배터리를 위해 별도의 자동화를 만들 수도 있었지만, 9.0이나 6.5와 같은 이상한 배터리 수준을 보는 건 내성적인 제 자신에게 짜증났어요. 그래서 이 문제를 해결하기 위해 다른 옵션을 탐색하기로 결정했어요. \n\n# 간단한 해결책 시도: 템플릿 센서 사용\n\n<div class=\"content-ad\"></div>\n\n배터리 표시 문제를 해결하는 한 가지 간단한 방법은 홈 어시스턴트에 중복 템플릿 센서를 만드는 것이었습니다. 이 센서는 잘못된 배터리 값들을 가져와 값을 정수로 변환한 다음 10을 곱하여 올바른 백분율을 표시했습니다. 이를 수행하는 코드 일부를 제공해드리겠습니다:\n\n```js\n템플릿:\n  센서:\n    - 이름: '도어벨 배터리'\n      단위: '%'\n      기기_클래스: 배터리\n      상태_클래스: \"측정\"\n      상태: >\n        { 배터리_상태 = 상태('센서.smart_video_doorbell_battery') }\n        { 만약 배터리_상태 }\n          { (배터리_상태 | int(default=0)) * 10 }\n        { 그렇지 않다면 }\n          0\n        { 끝만약 }       \n      아이콘: >\n        { 배터리_상태 = 상태('센서.smart_video_doorbell_battery') }\n        { 만약 배터리_상태 }\n          { 새_상태 = (배터리_상태 | int(default=0)) * 10 }\n          { 만약 새_상태 > 75 }\n            mdi:battery-high\n          { 그렇지 않고 새_상태 > 50 }\n            mdi:battery-medium\n          { 그렇지 않고 새_상태 > 25 }\n            mdi:battery-low\n          { 그 외에 }\n            mdi:battery-outline\n          { 끝만약 }                                            \n        { 그렇지 않다면 }\n          mdi:battery-outline\n        { 끝만약 }   \n```\n\n이 방법으로 문제를 해결할 수는 있었지만, 원래 센서의 잘못된 값들을 실제로 수정하지는 못했습니다.\n\n# 더 나은 해결책: AppDaemon을 사용하여 센서 수정하기\n\n<div class=\"content-ad\"></div>\n\nAppDaemon은 이러한 문제를 처리하는 더 유연하고 동적인 방법을 제공합니다. AppDaemon 문서에 따르면, AppDaemon 앱에서 Home Assistant 엔티티의 값을 설정할 수 있습니다. 이 기능을 사용하여 실시간으로 센서 값을 수정하는 앱을 개발했습니다.\n\n다음은 코드입니다:\n\n```js\nimport appdaemon.plugins.hass.hassapi as hass\n\nclass SensorMultiplier(hass.Hass):\n\n    def initialize(self):\n        self.battery_entity = \"sensor.smart_video_doorbell_battery\"\n        self.listen_state(self.sensor_changed, self.battery_entity)\n\n    def sensor_changed(self, entity, attribute, old, new, kwargs):\n        try:\n            battery_value = float(new)\n            if battery_value <= 10:\n                new_value = battery_value * 10\n\n                if new_value > 75:\n                    icon = \"mdi:battery-high\"\n                elif new_value > 50:\n                    icon = \"mdi:battery-medium\"\n                elif new_value > 25:\n                    icon = \"mdi:battery-low\"\n                else:\n                    icon = \"mdi:battery-outline\"\n\n                # Write back the new value to another sensor\n                self.set_state(entity, state=new_value,\n                    attributes={\n                        \"icon\": icon,\n                        \"device_class\": \"battery\"\n                    }\n                )\n                self.set_state(entity, state=new_value)\n        except ValueError:\n            self.log(f\"Invalid sensor value: {new}\")\n```\n\n```js\nsensor_multiplier:\n  module: sensor_multiplier\n  class: SensorMultiplier\n```\n\n<div class=\"content-ad\"></div>\n\n이 앱은 초인종 배터리 센서의 변경 사항을 감지합니다. 변경 사항이 감지되면 배터리 값을 10배로 곱하고 이 변경된 값을 사용하여 센서를 업데이트합니다. 또한 새로운 배터리 레벨에 따라 아이콘을 변경하여 배터리 상태를 빠르게 확인할 수 있습니다.\n\n이 수정으로 배터리 센서가 이제 올바른 값을 표시합니다. Home Assistant에서 기기와 관련된 비슷한 문제를 겪고 있다면 AppDaemon을 시도해 보는 것을 권장합니다.\n\nAppDaemon에 익숙하지 않다면 다른 문서에서 자세히 다룬 내용을 확인할 수 있습니다.\n\n스마트한 가정을 만들어 주세요!","ogImage":{"url":"/assets/img/2024-06-19-FixingTuyaDeviceProblemsinHomeAssistantwithAppDaemon_0.png"},"coverImage":"/assets/img/2024-06-19-FixingTuyaDeviceProblemsinHomeAssistantwithAppDaemon_0.png","tag":["Tech"],"readingTime":5},{"title":"앱데몬 마스터하기 홈 어시스턴트 캘린더 이벤트 생성을 위해 텔레그램 데이터 수집하기","description":"","date":"2024-06-19 05:39","slug":"2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents","content":"\n\n<img src=\"/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_0.png\" />\n\n요크라이나에서 살면서, 저희 가족은 계속되는 전력 공급 차단 문제를 해결하는 데 익숙해져 왔습니다. 계속되는 갈등과 러시아의 에너지 인프라를 향한 공격 속에서 혹독한 현실이 가정됩니다. 2022년 겨울은 특히 전기 공급이 빈번하고 긴급했던 어려운 시기였습니다. 얼마 동안은 상황이 나아졌지만, 최근 새로운 공격이 시작되면서 전기 공급 차단이 다시 복귀되었습니다.\n\n특히 피크 시간에 전기 부하를 관리하고, 이용 가능한 전력을 가정과 기업 간에 공정하게 나눠주기 위해 당국은 일정을 마련했습니다. 소비자들은 각 그룹으로 나누어져 고정 시간대에 전력 차단을 받게 됩니다. 이러한 일정은 일반적으로 운영자들의 웹사이트나 공개 텔레그램 채널을 통해 하루 전에 발표됩니다.\n\n<div class=\"content-ad\"></div>\n\n스마트 홈 애호가로서 당연히 이 정전 정보를 내 Home Assistant 시스템에 통합하고 싶었어요. 가능성을 상상해보세요: 수전중이던 전기 온수기 같은 전력 소모 가전제품을 자동으로 끄어 백업 배터리 전력을 절약하거나, 가족에게 \"주의! 30분 후 정전 예정입니다! 핸드폰을 충전하는 시간이에요!\" 라고 음성으로 미리 알려주기도 해봤어요.\n\n하지만 가장 중요한 점은 이 시간표가 매일 동적으로 바뀌며 고정된 발행 시간이 없다는 것이에요. 즉, Home Assistant를 최신 상태로 유지하려면 웹사이트나 텔레그램 채널을 지속적으로 모니터링해야 한다는 것이죠.\n\n# 해결책\n\n제가 선택한 해결책은 Home Assistant의 로컬 캘린더를 사용하여 이 정전 시간표를 처리하는 것이었어요. 저는 이 정전 데이터를 텔레그램 채널에서 스크래핑하기로 결정했는데, 그 이유는 메시지 구조가 제 요구 사항에 딱 맞았기 때문이에요.\n\n<div class=\"content-ad\"></div>\n\n홈 어시스턴트에는 내장된 스크래이프 통합 및 더 고급 HACS 구성 요소인 Multiscrape(여기서 확인하세요)가 있습니다. 하지만 이러한 도구들을 사용하여 내 문제를 해결하는 방법을 찾지 못했습니다. 아마 가능할지도 모르지만, 제가 Jinja 템플릿과 복잡한 구성에 대한 기술이 부족해서 그렇습니다. 그래서 홈 어시스턴트의 AppDaemon 통합으로 돌아가기로 결정했습니다.\n\n공식 문서에 따르면, \"AppDaemon은 홈 어시스턴트의 자동화 및 스크립팅 구성 요소를 보완하는 하위 시스템입니다.\" 더 간단히 말하면, 이를 통해 Python 코드(앱)를 작성하여 홈 어시스턴트를 제어하고 자동화할 수 있습니다.\n\n다른 프로그래밍 언어에 대한 경험이 있지만, Python은 제게는 새로운 영역이었습니다. 그래서 최신 기술 센세이션이라고 불리는 ChatGPT에 의지했습니다. \"이 인공지능이 분명히 도와줄 것이다!\"라고 생각했지만, 솔직히 말하면 결과는 성공과 실패가 섞였습니다. 옳은 방향으로 나아갈 수 있게 도와줬지만 항상 순조롭지는 않았습니다. 가끔씩 존재하지 않는 함수와 서비스를 제안하기도 했거든요. 올바른 서비스 호출 방법, 변수 전달 방법 및 변수 형식화 방법을 이해하는 데 많은 시간을 소요했습니다.\n\n가장 큰 골칫거리 중 하나는 AppDaemon으로부터 홈 어시스턴트 캘린더에 이미 전원 차단 일정이 있는지 확인하는 방법을 찾는 것이었습니다. 중복된 이벤트를 방지하기 위해서였죠. ChatGPT는 \"calendar.get_events\" 서비스를 사용하여 시간을 지정하여 이미 있는 이벤트를 확인하라고 제안했습니다. 안타깝게도, 이 방법은 AppDaemon 내에서의 제약 사항으로 작동하지 않았습니다. 여러 차례 검색하고 몇 번의 좌절한 한숨 뒤에, Markus Ressel의 매우 유익한 기사(https://markusressel.de/blog/post/calendar-integration-between-home-assistant-and-appdaemon)를 우연히 발견했습니다. 이 기사는 문제의 근본 원인을 이해하게 해주었고, 결국 캘린더 중복 없는 해결책을 찾는 데 도움이 되었습니다.\n\n<div class=\"content-ad\"></div>\n\n홈 어시스턴트에 AppDaemon을 사용하여 전원 차단 스케줄을 통합하는 방법을 단계별로 안내해 드릴게요.\n\n# 단계 1: 로컬 캘린더 설정\n\n가장 먼저, \"powercuts\"라는 이름의 로컬 캘린더를 홈 어시스턴트에 생성하여 스케줄을 가져올 수 있어요. 다음 방법으로 진행할 수 있어요:\n\n- \"장치 및 서비스\" 페이지로 이동합니다.\n- \"통합 추가\"를 클릭하세요.\n- \"로컬 캘린더\"를 검색하고 선택하세요.\n- 새 캘린더를 설정하고 이름을 \"powercuts\"로 지정하는 안내에 따라 진행하세요.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_1.png\" />\n\n# 단계 2: AppDaemon 설치\n\n홈 어시스턴트 애드온 스토어로 이동하여 AppDaemon 통합을 설치하세요.\n\n# 단계 3: AppDaemon 구성\n\n<div class=\"content-ad\"></div>\n\n통합을 시작하기 전에, 앱에서 필요한 Python 패키지를 포함하도록 구성해야 합니다. 제 프로젝트에서는 datetime, requests 및 beautifulsoup4를 추가했습니다. 이러한 패키지를 AppDaemon의 구성 섹션에 추가한 후, 통합을 시작하세요.\n\n![이미지](/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_2.png)\n\n# 단계 4: 올바른 폴더 찾기\n\n홈 어시스턴트의 상위 디렉터리로 이동합니다. 그 안에는 addon_configs라는 폴더가 있습니다. addon_configs 안에는 일반적으로 글자와 숫자의 조합 뒤에 _Appdaemon이 붙은 abcd123_Appdaemon과 같은 이름의 폴더를 찾습니다. 이 폴더 안에 apps라는 다른 폴더가 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 5: Python 앱 만들기\n\napps 폴더에 새 Python 파일(.py)을 만드세요. 여기에 코드를 작성할 거에요. 이 파일의 이름과 내부에 사용하는 클래스 이름은 중요합니다. 나중에 apps.yaml 파일에서 이들을 참조할 거니까요.\n\n예를 들어, powercut_scraper.py라는 파일을 만들고 PowercutScraper 클래스를 사용하면, AppDaemon을 구성할 때 코드를 찾을 위치를 알려줄 때 이 이름들을 사용해야 합니다.\n\n```js\n# apps/powercut_scraper_web.py\n\nimport appdaemon.plugins.hass.hassapi as hass\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\nfrom datetime import datetime, timedelta\n\nclass PowercutScraperWeb(hass.Hass):\n\n    def initialize(self):\n        # Configuration\n        self.url = \"https://t.me/s/pat_cherkasyoblenergo\"\n        self.queue_number = 3  # 확인해야 할 대기 번호\n        self.calendar_entity = \"calendar.powercuts\"\n        self.months_uk = {\n            \"січня\": \"01\", \"лютого\": \"02\", \"березня\": \"03\", \"квітня\": \"04\", \n            \"травня\": \"05\", \"червня\": \"06\", \"липня\": \"07\", \"серпня\": \"08\", \n            \"вересня\": \"09\", \"жовтня\": \"10\", \"листопада\": \"11\", \"грудня\": \"12\"\n        }\n        self.current_year = datetime.now().year\n\n        # homeassistant 이벤트 청취\n        self.listen_event(self.scrape_messages, \"tele_powercut_scraper_event\")\n        # self.run_every(self.scrape_messages, \"now\", 3600)\n        \n    def scrape_messages(self, event_name, data, kwargs):\n        # 웹페이지 가져오기\n        response = requests.get(self.url)\n        if response.status_code != 200:\n            self.error(f\"웹페이지 가져오기 실패: {response.status_code}\")\n            return\n\n        # 웹페이지 내용 파싱\n        soup = BeautifulSoup(response.content, 'html.parser')\n        messages = soup.find_all('div', class_='tgme_widget_message_text')\n\n        for message in messages:\n            date = self.extract_date(message.get_text())\n            schedules = self.extract_schedules(message.get_text())\n            if date and schedules:\n                self.update_calendar(date, schedules)\n\n    \n    def extract_schedules(self, message):\n        pattern = re.compile(r'(\\d{2}:\\d{2}-\\d{2}:\\d{2})\\s*([0-9\\sта,.;:!?]*черг[а|и])')\n        matches = pattern.findall(message)\n        relevant_schedules = []\n\n        for match in matches:\n            time_range = match[0]\n            queue_info = match[1]\n\n            # queue_info에서 모든 숫자 추출\n            queue_numbers = re.findall(r'\\d+', queue_info)\n\n            # 대기 번호 중 하나라도 self.queue_number와 일치하는지 확인\n            if any(int(queue_number) == self.queue_number for queue_number in queue_numbers):\n                relevant_schedules.append(time_range)\n        self.log(relevant_schedules)\n        return relevant_schedules\n    \n    def extract_date(self, message):\n        date_pattern = re.compile(r'(\\d{2})\\s([а-я]+)')\n        match = date_pattern.search(message)\n        if match:\n            day = match.group(1)    \n            month_uk = match.group(2)\n            if month_uk in self.months_uk:\n                month = self.months_uk[month_uk]\n                return f\"{day}.{month}.{self.current_year}\"\n        return None\n\n    def update_calendar(self, date, time_slots):\n        # 오늘 이후인지 확인하는 날짜 비교\n        date_obj = datetime.strptime(date, \"%d.%m.%Y\")\n        today = datetime.today().replace(hour=0, minute=0, second=0, microsecond=0)\n        if date_obj >= today:\n            # 시간 슬롯 결합\n            combined_slots = self.combine_time_slots(date, time_slots)\n            for slot in combined_slots:\n                start_time, end_time = slot.split('-')\n                event_start = datetime.strptime(f\"{date} {start_time}\", \"%d.%m.%Y %H:%M\").strftime(\"%Y-%m-%dT%H:%M:%S\")\n                event_end = datetime.strptime(f\"{date} {end_time}\", \"%d.%m.%Y %H:%M\").strftime(\"%Y-%m-%dT%H:%M:%S\")\n\n                self.call_service(\n                    \"script/create_powercut_calendar_events\", \n                    start_date_time=event_start, \n                    end_date_time=event_end\n                    \n                )\n        else:\n            self.log(f\"과거 날짜에 대한 캘린더 업데이트 건너뛰기: {date}\")\n\n    def combine_time_slots(self, date, time_slots):\n            if not time_slots:\n                self.log(f\"{date}에 결합할 시간 슬롯이 없어요.\")\n                return []\n\n            # 시간 슬롯 구문 분석 및 정렬\n            slots = []\n            for slot in time_slots:\n                start_time, end_time = slot.split('-')\n                if end_time == \"24:00\":\n                    end_time = \"23:59\"\n                start = datetime.strptime(f\"{date} {start_time}\", \"%d.%m.%Y %H:%M\")\n                end = datetime.strptime(f\"{date} {end_time}\", \"%d.%m.%Y %H:%M\")\n                slots.append((start, end))\n\n            slots.sort()\n\n            # 겹치거나 연속된 시간 슬롯 병합\n            merged_slots = []\n            current_start, current_end = slots[0]\n\n            for start, end in slots[1:]:\n                if start <= current_end:\n                    # 현재 시간 슬롯 확장\n                    current_end = max(current_end, end)\n                else:\n                    # 겹침 없음, 현재 시간 슬롯 추가 및 새로 시작\n                    merged_slots.append((current_start, current_end))\n                    current_start, current_end = start, end\n\n            # 마지막 시간 슬롯 추가\n            merged_slots.append((current_start, current_end))\n\n            # 병합된 시간 슬롯을 다시 문자열로 변환\n            combined_slots = [f\"{start.strftime('%H:%M')}-{end.strftime('%H:%M')}\" for start, end in merged_slots]\n            return combined_slots\n```\n\n<div class=\"content-ad\"></div>\n\n# 단계 6: apps.yaml에서 앱 구성하기\n\napps 폴더 안에 apps.yaml 파일이 있을 것입니다. 이 파일은 AppDaemon에게 사용자 정의 앱에 대해 알려줍니다. 다음과 같이 항목을 추가해보세요:\n\n```js\npowercut_scraper_web:\n  module: powercut_scraper_web  # .py 확장자를 제외한 파일명입니다\n  class: PowercutScraperWeb # 파일 내부의 클래스 이름입니다\n```\n\n이 구성은 AppDaemon에 앱을 연결하여 코드를 찾고 실행할 위치를 알려줍니다.\n\n<div class=\"content-ad\"></div>\n\n# 단계 7: 코드 흐름 이해하기\n\n- 코드 트리거: 코드는 \"tele_powercut_scraper_event\"라는 이벤트에 의해 트리거되며, 이 이벤트는 Multiscrape 구성 요소를 사용하여 생성된 이진 센서가 켜졌을 때 발생합니다. 제가 이 센서를 이전에 설정했으므로 트리거로 사용했습니다. 원하는 경우 앱을 몇 분마다 실행하도록 예약할 수도 있습니다.\n- 텔레그램 채널 스크랩: 코드는 텔레그램 채널의 메시지를 통해 날짜와 일정을 찾습니다. 둘 다 발견되면 캘린더를 업데이트하는 함수를 호출합니다.\n- 캘린더 업데이트: 이 함수는 먼저 오늘보다 이전인 전력 공급 차단 날짜를 무시합니다 (과거 이벤트에 대해 걱정할 필요가 없습니다). 관련 메시지의 경우 연속된 시간 단위 슬롯을 더 큰 블록으로 결합합니다 (일정은 1시간 간격으로 제공됨).\n\n![이미지](/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_3.png)\n\n- 중복 확인: 이 단계에서 이상적으로는 calendar.get_events 서비스를 호출하여 캘린더에 이미 이벤트가 있는지 확인해야 합니다. 그러나 이전에 언급했듯이 AppDaemon은이 서비스를 지원하지 않습니다. 따라서 필요한 경우 기존 항목을 확인하고 필요한 경우 새 항목을 만드는 Home Assistant 스크립트를 호출함으로써 이 문제를 해결했습니다.\n\n<div class=\"content-ad\"></div>\n\n요약하면, AppDaemon 앱은 텔레그램 채널에서 데이터를 스크랩하고 정리한 후 HA에 관련 시간 슬롯을 전송하여 캘린더에 새 이벤트를 생성합니다. 아래는 이진 센서와 스크립트 코드입니다:\n\n```js\n  multiscrape:\n    - name: Cherkasy powercut alert\n      resource: https://t.me/s/pat_cherkasyoblenergo\n      scan_interval: 30\n      list_separator: \"|||\"\n      binary_sensor:\n        - unique_id: energy_sensor_powercut_alert_oblenergo\n          name: Cherkasy powercut alert\n          icon: mdi:transmission-tower-export\n          device_class: power\n          select_list: \".js-message_text\"\n          value_template: >-\n            { set message = value.split(\"|||\") | last | lower }\n            { \"годин\" in message and \"відсутност\" in message and \"електропостача\" in message}\n          attributes:         \n            - name: latest_message_date\n              select_list: \".js-message_text\"\n              value_template: >-\n                { set message = value.split('|||') | last }\n                { set date_match = message | regex_findall_index(\"(\\d{1,2}\\s(?:січня|лютого|березня|квітня|травня|червня|липня|серпня|вересня|жовтня|листопада|грудня))\", 0) }\n                { set months_uk = {\n                            'січня': '01', 'лютого': '02', 'березня': '03', 'квітня': '04', \n                            'травня': '05', 'червня': '06', 'липня': '07', 'серпня': '08', \n                            'вересня': '09', 'жовтня': '10', 'листопада': '11', 'грудня': '12'\n                          } }\n                { if date_match }\n                  { set day = date_match.split(' ')[0] }\n                  { set month_uk = date_match.split(' ')[1] }\n                  { set month = months_uk[month_uk] }\n                  { set year = now().year }\n                  {  as_datetime(strptime('{}-{}-{} 00:00:00'.format(year, month, day),'%Y-%m-%d %H:%M:%S')) } \n                { else }\n                  { 'Date not found' }\n                { endif }  \n            - name: latest_message\n              select_list: \".js-message_text\"\n              value_template: >\n                { value.split('|||') | last | regex_findall('\\d{2}:\\d{2}-\\d{2}:\\d{2}\\s*[0-9\\sта,.;:!?]*черг[а|и]')| join('\\n') }\r\n```\n\n```js\r\n  script:\n    create_powercut_calendar_events:\n      mode: parallel\n      sequence:\n        - service: calendar.get_events\n          target:\n            entity_id: calendar.powercuts\n          data:\n            start_date_time: \"{ start_date_time }\"\n            end_date_time: \"{ end_date_time }\" \n          response_variable: agenda\n        - if: \"{ not agenda['calendar.powercuts'].events| map(attribute='summary')| list| count > 0 }\" \n          then:\n            - service: calendar.create_event\n              target:\n                entity_id: calendar.powercuts\n              data:\n                summary: Power cut\n                description: >-\n                  Scheduled Powercut data from Oblenergo telegram channel, auto created from appdaemon script\n                start_date_time: \"{ start_date_time }\"\n                end_date_time: \"{ end_date_time }\"      \r\n```\n\n# 단계 8: 자동화\n\n<div class=\"content-ad\"></div>\n\nAppdaemon 스크립트를 트리거하는 자동화:\n\n```yaml\n    - alias: 새로운 전원 공급 일정 - 캘린더에 추가\n      id: \"vdgadsfwerwfsdgasdsdxxkOOcKAo\"\n      initial_state: \"on\"\n      trigger:\n        - platform: state\n          entity_id: binary_sensor.energy_sensor_powercut_alert_oblenergo\n          attribute: latest_message\n        - platform: time\n          at: '23:45:00'\n        - platform: homeassistant\n          event: start\n      mode: single\n      max_exceeded: silent\n      action:\n        - event: tele_powercut_scraper_event\n          event_data:\n            date: \"{ now().strftime('%Y-%m-%d') }\"\n```\n\n이 정보를 자동화하는 방법의 예시입니다:\n\n```yaml\n    - alias: \"전원 정전 알림\"\n      id: \"automation_notification_home_powercut_notification\"\n      trigger:\n        - platform: calendar\n          id: \"5_minute\"\n          event: start\n          entity_id: calendar.powercuts\n          offset: -00:05:00\n        - platform: calendar\n          id: \"15_minute\"\n          event: start\n          entity_id: calendar.powercuts\n          offset: -00:15:00\n        - platform: calendar\n          id: \"30_minute\"\n          event: start\n          entity_id: calendar.powercuts\n          offset: -00:30:00\n      condition:\n        condition: and\n        conditions:\n          - condition: state\n            entity_id: input_boolean.powercuts\n            state: \"on\"\n      mode: single\n      max_exceeded: silent\n      action:\n        - service: notify.telegram_home\n          data:\n            title: \"⚡*전력 공급 중단*\"\n            message: \"{ trigger.id.split('_')[0] } 분 내에 전력 공급이 중단됩니다.\"\n```\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n여러분 중 많은 분들이 국가에서 정전이나 미사일 경보로 걱정할 필요가 없을 수도 있습니다. 하지만 저는 이 기사를 공유하고 싶었습니다. 왜냐하면 제가 소개한 방법과 코드는 여러분의 스마트 홈에서 더 복잡한 자동화를 만드는데 영감을 줄 수 있기 때문입니다. 에너지 사용을 피크 시간에 관리하거나 정교한 아침 루틴을 조정하는 등, AppDaemon은 여러분의 스마트 홈을 더 똑똑하게 만드는 강력한 도구를 제공합니다.\n\n그러니 이러한 도전 없이 사는 행운한 분들이라도, 여기서 유용한 아이디어를 찾아서 여러분의 홈 자동화 프로젝트를 향상시키는 데 도움이 되기를 바랍니다. 결국, 스마트 홈은 우리가 창의적으로 해결책을 찾는 한에만 똑똑할 뿐입니다.\n\n즐거운 자동화!","ogImage":{"url":"/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_0.png"},"coverImage":"/assets/img/2024-06-19-MasteringAppDaemonScrapingTelegramDatatoCreateHomeAssistantCalendarEvents_0.png","tag":["Tech"],"readingTime":15},{"title":"조쉬ai, 2024 CE Pro 브랜드 분석 랭킹에서 최상위 자리 차지 ","description":"","date":"2024-06-19 05:38","slug":"2024-06-19-JoshaiTakesTopSpotin2024CEProBrandAnalysisRankings","content":"\n\n매년 CE Pro에서 매우 기대되는 브랜드 분석 순위를 발표합니다. 이 종합적인 보고서는 전국의 최고 매출을 올리는 사용자 정의 설치 회사들의 의견을 기반으로 합니다. 각 딜러십은 다양한 기기 카테고리에서 선호하는 제조업체를 순위 매기도록 요청받습니다. 지난 10년 동안 큰 관심을 끈 카테고리 중 하나는 음성 제어인데, 이는 역사적으로 아마존, 애플, 구글과 같은 대중 시장 솔루션을 선호했습니다.\n\n수년 동안 Josh.ai는이 경쟁적인 환경에서 꾸준한 진전을 이루어 왔습니다. 서서히 올라선 것이 첫 번째로, Josh.ai는 아마존을 제친 최상위 자리를 차지하고 음성 제어 분야의 산업 리더가 되었습니다!\n\n# 여정을 되돌아보며\n\n<div class=\"content-ad\"></div>\n\n## 2023 결과:\n\n![이미지](/assets/img/2024-06-19-JoshaiTakesTopSpotin2024CEProBrandAnalysisRankings_1.png)\n\nJosh.ai는 구글을 앞지르기 위해 두 번째 연속으로 강조된 브랜드로 등장했습니다. 2023년에는 혁신적인 JoshGPT 기능이 등장하여 생성적 인공지능을 활용하여 고객들에게 슈퍼충전된 어시스턴트 경험을 제공합니다.\n\n## 2022 Results:\n\n<div class=\"content-ad\"></div>\n\n\n![이미지](/assets/img/2024-06-19-JoshaiTakesTopSpotin2024CEProBrandAnalysisRankings_2.png)\n\nJosh.ai는 불렛 브랜드로 강조되며, Apple을 제쳐내고 세 번째 자리를 차지했습니다. Josh.ai의 영향력은 2022년에 크게 증가했으며, 미국과 캐나다 전역에 1,300명 이상의 인증된 딜러를 초과했습니다. CEDIA 2022에서 소개된 Geneva OS는 클라이언트가 연결된 환경과 상호 작용하는 방식을 혁신적으로 변화시키는 중요 업데이트였습니다.\n\n## 2021 결과:\n\n![이미지](/assets/img/2024-06-19-JoshaiTakesTopSpotin2024CEProBrandAnalysisRankings_3.png)\n\n\n<div class=\"content-ad\"></div>\n\n2021년, Josh.ai는 최고의 플레이어 중 하나로 자리를 굳히면서 맞춤 통합에 초점을 맞춘 혁신으로 입지를 다지기 시작했습니다. 루트론과의 협업을 통해 Josh.ai Ready Wallplate와 Josh Nano를 함께 선보이며 고급 주거 공간을 위한 타협 없는 디자인 솔루션을 제공했습니다.\n\n## 2020 결과:\n\n![2020 Results](/assets/img/2024-06-19-JoshaiTakesTopSpotin2024CEProBrandAnalysisRankings_4.png)\n\nJosh.ai의 힘찬 모멘텀은 연이어 두 번째로 속도를 내고 있습니다. 팬데믹으로 인해 재택근무 상태였음에도 불구하고, Josh.ai 팀은 업계 최대 규모의 자금 조달 및 첫 번째 키포인트 프레젠테이션에서 Josh Nano와 Josh Core를 공개하는 중요한 성과를 이뤘습니다.\n\n<div class=\"content-ad\"></div>\n\n## 2019 결과:\n\n![이미지](/assets/img/2024-06-19-JoshaiTakesTopSpotin2024CEProBrandAnalysisRankings_5.png)\n\nJosh.ai의 급격한 성장이 시작되었습니다. 인증 딜러 네트워크를 400명 이상으로 두 배로 늘리고 CEDIA Expo에서 핵심 통합을 전시하며 사용자 개인 정보 보호에 대한 결연한 입장을 내비칩니다. Josh.ai의 비전에 대한 흥미가 이 회사를 새로운 높이로 발전시켰습니다.\n\n## 2018 Results:\n\n<div class=\"content-ad\"></div>\n\n![Josh.ai](/assets/img/2024-06-19-JoshaiTakesTopSpotin2024CEProBrandAnalysisRankings_6.png)\n\n조시.에이는 Josh Micro를 출시한 후 음성 제어 공간에서 주목을 받게 되었습니다. 대화형 및 위치 인식형 음성 상호 작용으로 스마트 홈에서 사용자 경험이 혁신되었습니다.\n\n이 성취는 조시.에이 뒤에 있는 기술뿐만 아니라 잠재력을 믿고 지원하고 피드백을 제공해 온 모든 딜러의 끊임없는 지원의 증명이기도 합니다. 우리 파트너들의 헌신이 조시.에이가 산업 리더로 발전하는 데 중요한 역할을 해왔습니다.\n\n조시.에이가 이 이정표를 기념하는 동안, 우리 팀은 더 이상 커뮤니케이션과 위치 인식 기술로 스마트 홈과 상호 작용하는 방식을 변화시키는 최첨단 솔루션을 계속해서 구축하겠다는 다짐을 하고 있습니다. 여기서 여정이 끝나지 않습니다. 조시.에이는 음성 제어 카테고리를 계속해서 선도할 것이며, Josh 터치스크린과 Josh Edge가 준비 중이어서 완전한 컨트롤 경험을 강조하는 다음 단계를 기대하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## Josh.ai에 대해\n\n2015년에 설립된 Josh.ai는 덴버를 기반으로 한 회사로, 우리 주변 기술과 자연스러운 상호작용을 가능하도록 하는 플랫폼과 제품을 제작합니다. 인공지능, 기계 학습 및 직관적인 디자인에 초점을 맞추어, Josh.ai의 미션은 우리가 환경 속에서 살아가는 방식을 변화시키는 것입니다. Josh.ai가 어떻게 간단하고 개인적이며 마법 같은 스마트 홈 경험을 가능하게 하는지 자세히 알아보려면 www.josh.ai를 방문하거나 hello@josh.ai로 이메일을 보내주세요.","ogImage":{"url":"/assets/img/2024-06-19-JoshaiTakesTopSpotin2024CEProBrandAnalysisRankings_0.png"},"coverImage":"/assets/img/2024-06-19-JoshaiTakesTopSpotin2024CEProBrandAnalysisRankings_0.png","tag":["Tech"],"readingTime":3},{"title":"차량 관리 20 최상의 성능과 연료 효율 달성하기","description":"","date":"2024-06-19 05:36","slug":"2024-06-19-FleetManagement20AchievingPeakPerformanceandFuelEfficiency","content":"\n\n운전자 훈련부터 원격 기술: 비용 절감과 가용성 향상에 대한 포괄적 접근\n\n![fleet management](/assets/img/2024-06-19-FleetManagement20AchievingPeakPerformanceandFuelEfficiency_0.png)\n\n# 소개\n\n안녕하세요! 오늘은 플릿 관리 맥락에서 연료 소비에 대해 이야기할 것입니다. 대규모 플릿을 운영할 때는 서비스 수준 요구사항과 계약 의무를 충족하기 위해 그들의 가용성을 의식하는 것이 중요합니다. 저는 다양한 비즈니스에 서비스를 제공하고 필수적인 서비스를 제공하는 약 25,000대의 차량으로 구성된 플릿을 7년 이상 관리한 경험이 있습니다. 이러한 플릿을 관리하는 것은 각 차량에 대한 비용을 고려해야 하며, 서비스, 연료 소비, 수리 및 부품 조달을 위한 송장 관리 등 관리 업무를 포함합니다.\n\n<div class=\"content-ad\"></div>\n\n# 차량 관리의 중요성\n\n차량 관리는 효율성을 향상시키고 비용을 줄이며 규정을 준수하는 데 필요한 차량의 조정 및 관리를 포함합니다. 주요 장점은 다음과 같습니다:\n\n- 비용 절감: 효율적인 관리로 연료 소비, 유지 보수 비용 및 운영 비용을 줄일 수 있습니다.\n- 안전: 정기적인 유지보수로 사고 및 고장 위험을 낮출 수 있습니다.\n- 규정 준수: 차량과 운전자가 관련 법률 및 규정을 준수하는 것을 보장합니다.\n- 고객 만족도: 배송 시간과 신뢰성을 향상시킵니다.\n\n# 차량 관리에서의 연료 소비\n\n<div class=\"content-ad\"></div>\n\n연료 소비는 차량 운영에서 중요한 비용입니다. 효율적인 연료 관리는 상당한 비용 절감과 환경적 이점을 가져올 수 있습니다. 주요 측면은 다음과 같습니다:\n\n- 연료 사용량 모니터링: 텔레매틱스와 연료 카드를 사용하여 연료 소비를 추적하고 비효율성을 식별합니다.\n- 운전자 행동: 운전자들에게 원활한 가속 및 냉동 시간 감소 등 친환경 운전 기술에 대해 교육합니다.\n- 차량 유지보수: 엔진을 효율적으로 작동하도록 정기적인 유지보수를 수행합니다.\n\n![fleet management](/assets/img/2024-06-19-FleetManagement20AchievingPeakPerformanceandFuelEfficiency_1.png)\n\n# 연료 효율성 향상 전략\n\n<div class=\"content-ad\"></div>\n\n연료 효율성 향상에는 기술, 교육 및 유지 보수의 결합이 필요합니다:\n\n- 텔레매틱스 시스템: 차량 성능과 연료 소비를 모니터링하기 위해 GPS와 텔레매틱스를 도입합니다.\n- 운전자 교육 프로그램: 운전자들에게 연료 효율적인 운전 습관에 대해 교육합니다.\n- 경로 최적화: 소프트웨어를 사용하여 가장 효율적인 경로를 계획합니다.\n- 정기적인 유지 보수: 차량을 최상의 상태로 유지하여 연료 낭비를 방지합니다.\n- 연료 효율적인 차량: 연료 효율이 더 좋거나 대체 연료 옵션이 있는 차량에 투자합니다.\n\n# 운영 가용성 및 그 중요성\n\n운영 가용성은 차량이 사용 가능한 시간의 백분율입니다. 높은 운영 가용성은 다운타임을 최소화하고 생산성을 향상시킵니다. 주요 요소는 다음과 같습니다:\n\n<div class=\"content-ad\"></div>\n\n- 예방 정비: 예상치 못한 고장을 예방하기 위한 정기적인 유지보수입니다.\n- 예비 부품 재고: 필수 예비 부품을 적절히 확보합니다.\n- 효율적인 일정 관리: 차량 사용 계획을 적절히 세워 과중한 사용을 피합니다.\n- 기술 통합: 차량 상태를 모니터링하기 위해 플리트 관리 소프트웨어를 활용합니다.\n\n# 운영 가용성 향상을 위한 모범 사례\n\n높은 운영 가용성을 유지하기 위해 플리트 매니저는 다음을 해야 합니다:\n\n- 예방 정비 프로그램 시행: 정기적인 점검과 유지보수 일정을 조정합니다.\n- 예측 분석 활용: 데이터 분석을 활용하여 잠재적인 문제를 예측합니다.\n- 상세한 기록 유지: 차량 성능과 유지보수 이력에 대한 포괄적인 기록을 유지합니다.\n- 플리트 활용 최적화: 차량의 균형 잡힌 사용을 보장하여 특정 자산의 과도한 사용을 피합니다.\n\n<div class=\"content-ad\"></div>\n\n# 차량 관리를 위한 기술과 도구\n\n현대의 차량 관리는 효율성을 높이기 위해 기술에 크게 의존합니다:\n\n- 차량 관리 소프트웨어: GPS 추적, 정비 일정 및 보고서 제공 플랫폼.\n- 텔레매틱스 시스템: 차량 위치 및 성능에 대한 실시간 데이터를 제공합니다.\n- 연료 관리 시스템: 연료 사용량을 추적하고 개선할 수 있는 영역을 식별합니다.\n- 정비 관리 도구: 정비 프로세스를 자동화하고 간소화합니다.\n\n![차량 관리](/assets/img/2024-06-19-FleetManagement20AchievingPeakPerformanceandFuelEfficiency_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 사례 연구/예시\n\n실제 사례를 포함하면 효과적인 차량 관리의 혜택을 설명할 수 있습니다:\n\n## 사례 연구 1: 대규모 차량 연료 최적화\n\n배경: 3,000대의 차량을 관리하는 물류 회사가 입니다. 연간 디젤 연료 소비량이 800,000 리터에 대한 $1,000,000을 줄이기 위한 목표를 세웠습니다. 트럭, 밴, 자동차와 같은 다양한 차량 유형이 포함되어 있으며 각각이 다른 연료 효율 기준을 갖고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n도전 과제:\n\n- 과도한 연료를 소비하는 성능이 낮은 차량 식별하기.\n- 연료 도난 방지하기.\n- 연료 효율이 떨어지는 노후 차량 대응하기.\n- 운전자 성능 모니터링 및 향상하기.\n\n도입된 해결책:\n\n차량 태깅:\n\n<div class=\"content-ad\"></div>\n\n- 기능 장애 또는 적절하지 않은 서비스 기록이 있는 차량을 식별하고 태그를 지정하여 최적 수준보다 더 많은 연료를 소비하는 차량을 식별했습니다.\n- 수리 및 정기 유지를 포함한 정정 조치를 시행하여 연료 효율성을 회복했습니다.\n\n연료 소비 투명성:\n\n- 연료 탱크에 RFID 칩을 장착하고 운전자용 fob를 발급하여 각 연료 분배 이벤트를 추적했습니다.\n- 개별 차량 수준에서 연료 사용량을 모니터링하여 투명성을 확보하고 도난을 방지했습니다.\n\n차량 노후 관리:\n\n<div class=\"content-ad\"></div>\n\n- 연료 효율 기준을 충족하지 못하는 오래된 차량을 식별하기 위한 평가를 실행했습니다.\n- 이러한 차량에 대해 교체하거나 더 자주 정기 점검을 예약하여 성능을 향상시켰습니다.\n\n운전자 성과 모니터링:\n\n- 운전자 행동을 관찰하기 위해 GPS 추적기 및 차량 내 모니터링 시스템을 활용했습니다.\n- 과도한 연료 소비의 주요 요인인 과도한 가속, 냉염 및 과속을 줄이는 데 집중했습니다.\n- 연료 효율적인 운전 기술을 촉진하는 운전자 교육 프로그램을 실행했습니다.\n\n결과:\n\n<div class=\"content-ad\"></div>\n\n- 연료 절약: 연료 소비량을 15% 감소시켜 상당한 비용 절감을 이루었습니다.\n- 운영 효율성: 적극적인 유지보수를 통해 차량 성능을 향상시키고 다운타임을 줄였습니다.\n- 운전자 책임감: 운전자 행동을 개선하고 연료 도난을 줄여 효율적인 차량 운영을 이끌었습니다.\n\n## 사례 연구 2: 예측 유지보수로 운영 가용성 향상\n\n![이미지](/assets/img/2024-06-19-FleetManagement20AchievingPeakPerformanceandFuelEfficiency_3.png)\n\n배송 서비스 회사는 500대의 차량을 보유하고 운영 가용성을 개선하려고 했습니다. 이는 서비스 수준 협약을 준수하고 고객 만족도를 유지하는 데 중요했습니다.\n\n<div class=\"content-ad\"></div>\n\n도전:\n\n- 빈번한 차량 고장으로 인한 다운타임 증가.\n- 비효율적인 유지보수 일정 계획.\n- 특정 자산의 과부하를 피하기 위한 차량 사용 균형 맞추기.\n\n도입된 솔루션:\n\n예측 유지보수 프로그램:\n\n<div class=\"content-ad\"></div>\n\n- 차량 문제가 발생하기 전에 잠재적인 문제를 예측하기 위해 텔레매틱스와 데이터 분석을 활용했습니다.\n- 예측적인 통찰력에 기반한 예방 정비 일정을 계획하여 예기치 못한 고장을 줄였습니다.\n\n스페어 파트 재고 관리:\n\n- 필수적인 스페어 파트 재고를 잘 보관하여 수리 시간을 최소화했습니다.\n- 정비 활동에 대한 신속한 처리 시간을 보장했습니다.\n\n효율적인 일정 관리:\n\n<div class=\"content-ad\"></div>\n\n- 차량 사용 계획 및 균형을 위해 플릿 관리 소프트웨어 사용하였습니다.\n- 특정 차량의 과적재를 피하고, 플릿 전체에 걸친 마모를 균등하게 분배하였습니다.\n\n상세한 기록 관리:\n\n- 차량 성능 및 정비 이력에 대한 포괄적인 기록을 유지하였습니다.\n- 이 데이터를 사용하여 유지 보수 일정을 개선하고 운영 가용성을 더욱 향상시켰습니다.\n\n결과:\n\n<div class=\"content-ad\"></div>\n\n- 운영 가능성: 20% 향상되어, 언제든지 더 많은 차량을 사용할 수 있게 되었습니다.\n- 다운타임 감소: 선행적인 유지보수로 인한 예상치 못한 고장이 줄어들어 더 부드러운 운영 가능해졌습니다.\n- 서비스 수준 향상: 배송 일정 준수가 향상되어 신뢰성과 고객 만족도가 향상되었습니다.\n\n# 실용 경험 반영\n\n3,000대 이상의 차량을 관리하면서 얻은 경험 중 연로 최적화에 중점을 두었습니다. 연간 100만불의 연료 예산으로 80만 리터의 디젤을 사용할 때, 각 차량의 성능 분석이 중요했습니다. 여기 몇 가지 실용적인 통찰이 있습니다:\n\n- 문제 사례: 고장이나 부적절한 서비스로 과도하게 연료를 소비하는 성능이 낮은 차량을 식별합니다. 이러한 차량을 태깅하여 수정 조치를 취할 수 있습니다.\n- 연료 도난: 연료 소비의 투명성을 증진하여 도난을 방지하고 정확한 모니터링을 보장합니다.\n- 노후 차량: 연료 효율 기준을 충족하지 못할 수 있으며 교체나 더 자주 유지보수가 필요한 노령 차량을 인식합니다.\n- 운전자 성과: 가속, 대기, 과속으로 연료소비에 영향을 주는 운전자 행위를 감시합니다. GPS 추적기와 차량 내 모니터링 시스템을 사용하여 차량의 위치, 속도, 운전자 행동을 추적합니다. 연료 탱크에 RFID 칩을 적용하여 연료 분배를 정확히 추적합니다.\n- 교육 및 매뉴얼: 새로운 운전자 교육을 위한 운영 매뉴얼을 개발하여 일관된 안전 운전 방법을 보장하고 오류를 최소화합니다.\n- 인센티브: 우수한 운전자 행동에 대한 경제적 인센티브나 인정을 통해 최상의 실천을 장려합니다.\n\n<div class=\"content-ad\"></div>\n\n위 전략들을 채택하고 기술을 활용함으로써, 차량 운영 관리자들은 연료 소비를 최적화하고 운영 가능성을 향상시키며 전체 차량 성능을 향상시킬 수 있습니다.\n\n# 결론\n\n차량 관리는 교통 운영의 복잡하지만 필수적인 측면으로, 연료 소비, 운영 가능성 및 전반적인 효율에 영향을 미칩니다. 현대 기술을 활용하고, 최상의 사례를 실시하고, 계속해서 성과를 모니터링함으로써, 차량 관리자들은 비용 절감과 서비스 품질 모두에서 상당한 향상을 이룰 수 있습니다. 효과적인 차량 관리는 운영 효율성을 향상시키는 것 뿐만 아니라, 환경 지속가능성과 고객 만족에도 기여합니다.\n\n만약 차량 운영 관리자이거나 교통 운영에 관여하고 계신다면, 이제 여러분의 차량 관리 관행을 더 자세히 살펴보는 것이 좋습니다. 본 기사에서 논의된 전략들을 실시하여 연료 소비를 최적화하고 운영 가능성을 향상시키세요. 여러분의 경험과 통찰을 공유하고, 함께 배우고 성장합시다. 협업, 프로젝트 또는 성공 스토리 공유 등을 위해서 언제든지 저에게 연락해 주세요. claude.analyst@outlook.com 또는 LinkedIn에서 연결하세요. 함께 차량 관리의 미래를 이끌어 나가요!","ogImage":{"url":"/assets/img/2024-06-19-FleetManagement20AchievingPeakPerformanceandFuelEfficiency_0.png"},"coverImage":"/assets/img/2024-06-19-FleetManagement20AchievingPeakPerformanceandFuelEfficiency_0.png","tag":["Tech"],"readingTime":6},{"title":"Quora Plus 프로그램에서 질문에 응답만 해도 돈을 벌 수 있을까요","description":"","date":"2024-06-19 05:34","slug":"2024-06-19-CanYouMakeMoneyJustAnsweringQuestionsontheQuoraPlusprogram","content":"\n\n이 쪽 일은 신뢰할 만한가요?\n\n![image](/assets/img/2024-06-19-CanYouMakeMoneyJustAnsweringQuestionsontheQuoraPlusprogram_0.png)\n\n## 사용자들의 질문에 답변하여 돈을 벌 수 있을까요?\n\n이에 대해 연구를 한 후, 약속할만한 쪽 일을 보여드리기로 결정했습니다. 그것은 Quora.com입니다. 이 사이트에 대해 들어보셨을지도 모릅니다.\n\n<div class=\"content-ad\"></div>\n\n## 과거에는 다르던 것들이 있었습니다....\n\n한 회원이 하루에 한 시간 일하면 월 4,000달러를 번다고 말했습니다. 믿기 어려울 수도 있겠지만, 제 정보에 따르면 그 답변은 몇 년 전에 올려졌다고 합니다.\n\n그의 전략은 Reddit 사이트에 올라왔으며, 그는 Quora 파트너 프로그램의 회원이라고 주장합니다. 그는 매일 최대 25개의 질문을 올렸는데, 이는 뉴스와 다른 소셜 뉴스 사이트에서 아이디어를 가져왔다고 합니다.\n\n그는 대부분의 사람들이 묻고 싶어할 것으로 보이는 질문을 찾아서 그들의 질문에 답변함으로써 도와주려고 노력했다고 합니다.\n\n<div class=\"content-ad\"></div>\n\n그는 과학, 경제 및 다이어팅과 운동과 같은 일상적인 문제에 대해 게시합니다. 그가 언급한 한 예는 매일 1시간을 달리는 것이 좋은지 아니면 주당 세 번 체육관에 가는 것이 더 좋은지에 대한 것입니다.\n\n일반적으로 Quora와 같은 사이트에서 답변을 찾는 사용자들은 평범한 사람들이라는 점을 염두에 두세요. 그들이 전문가가 아닐 수도 있고 어떤 분야에서 학위를 가지고 있을 수도 없습니다. 또한, 건강 전문가들이 질문에 답변할 시간이 얼마나 있는지 궁금해집니다.\n\nReddit 사용자는 소득 보고서를 게시하지 않았으므로, 그가 자만하는 것인지 아니면 사람들의 희망을 고취시키고 있는지 알 수 없습니다.\n\n이 포스트는 몇 년 전에 올라갔으므로, Quora 파트너 프로그램이 변경되었습니다. 이제 이것은 Quora Plus 프로그램으로 불리며, 이제 돈을 벌 수 있는 회원이 되는 옵션과 광고 없이 답변을 찾을 수 있는 옵션을 포함하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n새 프로그램에 대해 알아보세요:\n\nQuora Plus 프로그램에는 트래픽을 활용한 금전화가 포함되어 있어서, 트래픽을 유도하여 제휴 링크에 응답할 사용자를 찾는 데 도움이 될 수 있습니다.\n\n한 리뷰어는 이 새로운 프로그램을 Medium 사이트와 비교하며, 회원으로 가입한 다른 사용자로부터 돈을 벌 수 있는 기회를 제공한다고 언급했습니다. 변경 사항 이후, 최근에 사용자들이 자신들의 수입 보고를 공유한 많은 게시물을 찾지 못했습니다.\n\n유튜브 채널을 운영하는 Odette-Rochhead-Kerr는 적극적으로 다른 사용자와 상호 작용하고, 긍정적인 평가를 받고 훌륭한 콘텐츠를 만드는 방식과 같은 팁을 포함하여 사용자가 $15,000 미국 달러를 벌 수 있는 방법에 대해 긍정적으로 포스팅하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n다른 유튜브 블로거, 코라 월레(African Giant By Kolawole)가 몇 가지 팁을 포함한 긴 비디오를 공유했어요.\n\n그는 사용자들에게 특정 분야를 선택하라고 조언하며, 초보자들은 질문에 답하는 것으로 시작할 수 있다고 말합니다. 링크를 너무 일찍 게시하는 것은 금지될 위험이 있다고 경고합니다. 신뢰성을 만드는 것이 중요하다고 말합니다. Quora를 사용하면 제휴 링크가 있는 경우 트래픽을 얻는 좋은 방법이라고 합니다. 그는 사용자들이 긴 답변을 달라고 권고하며, 500~1500단어의 콘텐츠를 제안합니다.\n\n다른 유튜브 블로거는 Quora가 과거처럼 광고 수익을 공유하지 않으며, 수익은 사용자가 이 플랫폼의 회원인 경우에만 공유된다고 지적합니다. 흥미롭고 중간적으로 중요한 점은, 마치 미디엄 파트너 프로그램과 유사하다고 합니다. 그는 76,000회 조회로 겨우 $9의 수익을 올린 것을 보여주며, 같은 양은 유튜브에서는 약 $40 또는 $70 정도 벌 수 있다고 합니다. 상당한 차이가 있죠.\n\n# 요약:\n\n<div class=\"content-ad\"></div>\n\n안타깝게도, 최근에 상당한 수익을 올린 Quora 사용자들의 수입 보고서를 아직 보지 못했습니다. 이는 최고 수익자들이 이를 보고하고 있지 않거나, 그냥 보통 사이트이며 유효한 부업 사이트가 아닐 수도 있기 때문일 수 있습니다. 누군가가 새로운 프로그램 Quora Plus를 사용하여 돈을 벌었나요? 경험을 공유해 주세요.\n\n오늘은 여기까지. 즐겁게 보셨기를 바랍니다.\n\n이메일을 통해 더 많은 내 최신 기사를 받아 보실 수도 있습니다. 저는 여러분이 인생의 큰 미스터리를 심층적으로 고찰하도록 격려하는 이야기를 제공하기 위해 노력하고 있습니다. 더 많은 사려깊은 논평을 일으키는 이야기를 드릴 수 있도록 저의 출판물을 팔로우해 주세요.\n\n이전 포스트도 확인해 보세요.","ogImage":{"url":"/assets/img/2024-06-19-CanYouMakeMoneyJustAnsweringQuestionsontheQuoraPlusprogram_0.png"},"coverImage":"/assets/img/2024-06-19-CanYouMakeMoneyJustAnsweringQuestionsontheQuoraPlusprogram_0.png","tag":["Tech"],"readingTime":3},{"title":"파키스탄의 인터넷 방화벽 개요","description":"","date":"2024-06-19 05:33","slug":"2024-06-19-TheInternetFirewallinPakistanAnOverview","content":"\n\n\n![image](/assets/img/2024-06-19-TheInternetFirewallinPakistanAnOverview_0.png)\n\n# 소개\n\n파키스탄의 인터넷 방화벽인 파키스탄 인터넷 방화벽(PIF)은 해당 국가 내의 인터넷 트래픽을 통제하고 규제하기 위해 설계된 시스템입니다. 이 시스템은 파키스탄 통신통신 규제당국(PTA)이 설정한 기준에 따라 불법이나 부적절하거나 해로운 콘텐츠에 대한 액세스를 차단하는 것을 목표로 합니다. 이 기사는 인터넷 방화벽의 개요, 시행, 영향 및 그 주변의 논쟁에 대한 포괄적인 개요를 제공합니다.\n\n## 인터넷 방화벽의 목적\n\n\n<div class=\"content-ad\"></div>\n\n파키스탄의 인터넷 방화벽의 주요 목표는 다음과 같습니다:\n\n- 불법 콘텐츠 접근 방지: 포르노그래피, 모독, 혐오 발언, 극단적인 콘텐츠와 관련된 사이트를 차단하는 것을 포함합니다.\n- 국가 안보: 국가 안보에 위협을 줄 수 있는 콘텐츠가 제한되도록 하는 것.\n- 사회 및 문화가치 유지: 파키스탄의 문화 및 사회 규범에 반하는, 모욕적이라고 여겨질 수 있는 콘텐츠의 확산을 방지하는 것.\n\n## 실행\n\nPTA가 주요 규제 기관으로서 인터넷 방화벽의 실행과 유지를 담당합니다. 방화벽은 기술적인 방법을 결합하여 운영됩니다.\n\n<div class=\"content-ad\"></div>\n\n- URL 차단: 금지된 콘텐츠를 호스팅하는 특정 URL이 차단됩니다.\n- 키워드 필터링: 특정 키워드를 포함하는 웹 페이지가 걸러집니다.\n- Deep Packet Inspection (DPI): 이 첨단 방법은 네트워크를 통해 전송되는 데이터를 검사하여 원치 않는 콘텐츠를 식별하고 차단합니다.\n\n## 법적 규정\n\n인터넷 방화벽의 법적 근거는 파키스탄의 다양한 법률과 규정으로 제공됩니다:\n\n- 파키스탄 전자 범죄법 (PECA) 2016: 이 법은 PTA에게 법을 위반하는 콘텐츠를 차단하고 제거할 권한을 부여합니다.\n- 통신 정책: 이 정책은 ISPs의 PTA를 위해 콘텐츠 규제에 도움을 주는 책임을 개요화합니다.\n\n<div class=\"content-ad\"></div>\n\n## 인터넷 사용자에 미치는 영향\n\n인터넷 방화벽의 시행은 파키스탄의 인터넷 사용자에게 중대한 영향을 미칩니다:\n\n- 정보 접근: 차단된 범주에 속한다면 교육 및 정보를 포함한 다양한 콘텐츠에 접근하기 어려울 수 있습니다.\n- 언론의 자유: 방화벽이 검열과 언론 자유 억압에 대한 우려를 증폭시켰습니다.\n- 디지털 경제: 국제적인 커뮤니케이션과 자원에 의존하는 비즈니스들은 제한된 접근으로 인해 도전에 직면할 수 있습니다.\n\n## 논란과 비판\n\n<div class=\"content-ad\"></div>\n\n파키스탄의 인터넷 방화벽은 논쟁과 비판의 대상이 되었습니다:\n\n- 과도한 통제와 검열: 비평가들은 방화벽이 반대 의견을 억압하고 정치적 논의를 제한하는 데 사용될 수 있다고 주장합니다.\n- 투명성 문제: 차단되는 내용과 이유에 대한 불투명함이 종종 발생하여 일방적이고 설명되지 않은 검열로 이어집니다.\n- 개인정보 우려: DPI와 같은 방법은 사용자 데이터를 모니터링하고 분석하기 때문에 상당한 개인정보 문제를 야기합니다.\n\n## 방화벽 우회\n\n파키스탄의 많은 사용자들은 다양한 도구와 기술을 활용하여 방화벽을 우회하고 있습니다.\n\n<div class=\"content-ad\"></div>\n\n- 가상 사설 네트워크 (VPN): VPN은 사용자의 IP 주소를 가릴 때 일반적으로 사용되며 차단된 콘텐츠에 접속할 수 있습니다.\n- 프록시 서버: 프록시 서버는 차단된 사이트에서 콘텐츠를 가져오기 위한 중개 역할을 합니다.\n- Tor 네트워크: Tor 네트워크는 익명으로 브라우징할 수 있게 하며 검열을 우회하는 데 도움이 됩니다.\n\n## 결론\n\n파키스탄의 인터넷 방화벽은 국가 법률과 문화 가치에 따라 온라인 콘텐츠를 규제하기 위한 정부의 노력을 반영합니다. 유해 콘텐츠로부터 사용자를 보호하려는 노력은 있다지만, 이는 언론의 자유, 정보 접근, 개인 정보 보호 등에 대한 중요한 우려도 불러일으킵니다. 계속되는 논의는 국가의 합법적 우려를 다룰 때 사용자 권리를 보호하는 균형있는 접근 방식의 필요성을 강조합니다.","ogImage":{"url":"/assets/img/2024-06-19-TheInternetFirewallinPakistanAnOverview_0.png"},"coverImage":"/assets/img/2024-06-19-TheInternetFirewallinPakistanAnOverview_0.png","tag":["Tech"],"readingTime":3},{"title":"ESP32를 Google의 Firebase와 연결하기","description":"","date":"2024-06-19 05:32","slug":"2024-06-19-ConnectESP32WithGooglesFirebase","content":"\n\n## 이 기사에서📜는 ESP32를 Google Firebase에 가장 빠르게⚡ 연결하는 방법을 보여드리겠습니다. 기대되시나요? 🤩\n\n# ➡️ 하드웨어 요구 사항:\n\nESP32 개발 보드, LED💡, 브레드보드,\n\n습도 센서 (DHT11)⛅\n\n<div class=\"content-ad\"></div>\n\n# ➡️ Firebase에서 백엔드 설정:\n\n우리는 백엔드로 Google의 Firebase를 사용할 것입니다. 시작하려면 Firebase로 이동해서 Google 계정으로 로그인하세요.\n\n새 프로젝트를 만들려면 프로젝트 추가 옵션을 선택하세요. 프로젝트 이름을 입력하라는 요청이 표시됩니다. 적절한 이름을 입력한 후 계속 버튼을 눌러주세요.\n\n![이미지](/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_0.png)\n\n<div class=\"content-ad\"></div>\n\n해당 프로젝트에 대해 \"Google Analytics 사용\" 옵션을 비활성화하세요. 이 프로젝트에는 필요하지 않습니다.\n\n마지막으로, '프로젝트 생성'을 선택하세요.\n\n![이미지](/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_1.png)\n\nFirebase가 프로젝트 설정을 시작합니다. 설정이 완료되면 '계속'을 선택하고, Firebase 콘솔의 프로젝트 개요 페이지로 이동하게 됩니다.\n\n<div class=\"content-ad\"></div>\n\n\n<img src=\"/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_2.png\" />\n\n# ➡️Authentication Setup :\n\n우리가 먼저 해야 할 일은 프로젝트의 인증 옵션을 설정하는 것입니다. 왼쪽 상단의 인증 메뉴 옵션을 선택하면 인증 페이지로 이동됩니다. 시작하기 버튼을 선택하세요.\n\n<img src=\"/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_3.png\" />\n\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_4.png\" />\n\n<img src=\"/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_5.png\" />\n\n우리는 ESP32 장치를 위해 익명 로그인을 사용하여 시작할 것이며, 후에 자세한 튜토리얼에서 더 스마트한 로그인 방법을 고안할 것입니다. 상단 사진과 같이 익명 로그인을 활성화하고 저장 옵션을 선택하십시오.\n\n# ➡️실시간 데이터베이스 설정:\n\n<div class=\"content-ad\"></div>\n\n다음으로는 모든 센서 데이터를 보유할 데이터베이스를 만들어야 합니다. 이를 위해 왼쪽 상단의 실시간 데이터베이스 메뉴 옵션을 선택하면 실시간 데이터베이스 페이지로 이동됩니다. 데이터베이스 생성 메뉴를 초기화하려면 데이터베이스 만들기 버튼을 선택하세요.\n\n![이미지](/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_6.png)\n\n![이미지](/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_7.png)\n\n데이터베이스 생성 메뉴에서 가장 가까운 위치를 선택하고 다음을 선택하세요. 데이터베이스를 잠긴 모드 또는 테스트 모드로 초기화할 수 있는 옵션이 표시됩니다. 일단 테스트 모드를 선택하세요. 주요 차이점은 테스트 모드에서는 30일 동안 데이터베이스에 대한 무단 액세스를 허용하는 데이터베이스 액세스 규칙이 적용된다는 것입니다. 프로젝트를 본격적으로 운용할 계획이라면 향후에 이 기능을 비활성화해야 합니다. 활성화 버튼을 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_8.png)\n\nRule을 클릭하고 아래 그림에 표시된 대로 코드를 변경하세요.\n\n그리고 Publish 버튼을 누르세요.\n\n![image](/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_9.png)\n\n\n<div class=\"content-ad\"></div>\n\n# ➡️ C 언어로 Arduino IDE 설정 및 코드 설명:\n\n우리가 해야 할 첫 번째 작업은 ESP32 개발 환경을 설정하는 것입니다. 이를 위해 Arduino IDE를 사용합니다. 이미 설치하지 않았다면 여기서 다운로드하고 설치해 주세요. 그리고 제대로 설정해 주세요.\n\n마지막으로, 우리가 프로젝트에서 사용할 모비즈트 라이브러리를 추가해야 합니다. 홈페이지에서 라이브러리 페이지로 이동하여 FirebaseESP32 라이브러리를 검색합니다.\n\n우리가 해야 할 첫 번째 작업은 응용 프로그램에서 필요한 모든 라이브러리를 가져오는 것입니다. Arduino 라이브러리는 기본적으로 이미 설치되어 있어야 합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\n#include <Arduino.h>\n#include <WiFi.h>\n#include <FirebaseESP32.h>\n```\n\n다음으로 FirebaseESP32 라이브러리에서 사용되는 몇 가지 도우미 라이브러리를 추가해야 합니다. TokenHelper 라이브러리는 토큰 생성 프로세스를 관리하는 데 사용되며, RTDBHelper 라이브러리는 Firebase Realtime Database에서 오는 데이터를 인쇄하는 도우미 함수를 제공합니다.\n\n```js\n//토큰 생성 프로세스 정보 제공.\n#include \"addons/TokenHelper.h\"\n//RTDB 페이로드 인쇄 정보 및 기타 도우미 함수 제공.\n#include \"addons/RTDBHelper.h\"\n```\n\n다음으로 Wi-Fi 자격 증명을 캡처해야 합니다. WIFI_AP를 Wi-Fi 식별자로, WIFI_PASSWORD를 Wi-Fi 암호로 대체하세요.\n\n\n<div class=\"content-ad\"></div>\n\n참고: 임베디드 애플리케이션에 패스워드 정보를 하드코딩하는 것은 좋지 않은 아이디어입니다. 실제 제품 케이스의 경우 안전한 장치 등록 프로세스를 포함한 장치 프로비저닝 전략을 적용해야 합니다.\n\n```js\n#define WIFI_SSID \"WIFI_AP\"\n#define WIFI_PASSWORD \"WIFI_PASSWORD\"\n```\n\n다음으로 API 키를 저장할 상수를 추가해야 합니다. Firebase 프로젝트 API 키는 프로젝트 설정 페이지에서 가져올 수 있습니다. API_KEY를 본인의 API 키로 바꿔주세요. 또한 Firebase 실시간 데이터베이스 URL을 포함하려면 URL을 자신의 것으로 바꿔주세요.\n\n![이미지](/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_10.png)\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_11.png\" />\n\n```js\n// Firebase 프로젝트 웹 API 키\n#define API_KEY \"API_KEY\"\n// Firebase 실시간 데이터베이스 URL\n#define DATABASE_URL \"Database_url\"\n```\n\n이제 FirebaseESP32 라이브러리에서 가져온 3개의 객체를 초기화합니다. 이 객체들은 애플리케이션을 Firebase와 연결하는 데 중요합니다.\n\n```js\nFirebaseData fbdo,fbdo_s1,fbdo_s2;\nFirebaseAuth auth;\nFirebaseConfig config;\n```\n\n<div class=\"content-ad\"></div>\n\n다음으로 유용한 몇 가지 전역 변수를 정의합니다.\n\n```js\nbool signUpOK=false;\nunsigned long sendDataPrevMillis = 0;\nbool ledStatus=false;\nfloat temp=0;\nfloat humidity=0;\n#define LED_PIN 22 // for led pin \n\n#include <DHT.h>  // for humidity sensor\nDHT dht(26,DHT11);\n```\n\n이제 setup() 함수에 다음 코드를 복사하여 붙여넣으세요:\n\n```js\nvoid setup() {\n  \n  Serial.begin(115200);\n  dht.begin();\n  pinMode(LED_PIN,OUTPUT);\n  WiFi.begin(WIFI_SSID,WIFI_PASSWORD);\n  Serial.print(\"Wi-Fi에 연결 중\");\n\n  while(WiFi.status()!= WL_CONNECTED){\n    Serial.print(\".\");\n    delay(300);\n  }\n\n  Serial.println();\n  Serial.print(\"IP 주소로 연결됨: \");\n  Serial.println(WiFi.localIP());\n  Serial.println();\n config.api_key=API_KEY;\n config.database_url=DATABASE_URL;\n\n if(Firebase.signUp(&config,&auth, \"\", \"\")){\n     Serial.println(\"가입 성공\");\n     signUpOK=true;\n }\n\nconfig.token_status_callback=tokenStatusCallback;\n\nFirebase.begin(&config,&auth);\nFirebase.reconnectWiFi(true);\n\nif(!Firebase.RTDB.beginStream(&fbdo_s1,\"/LED/digital\")){\n\n  Serial.println(\"실패: \"+fbdo_s1.errorReason());\n}\n \n}\n```\n\n<div class=\"content-ad\"></div>\n\nvoid loop() 함수 안에 아래 코드를 복사하여 붙여넣기 해주세요:\n\n```js\nvoid loop() {\n\n// DHT 센서\n    if(Firebase.ready() && signUpOK && (millis()-sendDataPrevMillis>5000 || sendDataPrevMillis == 0)){\n      sendDataPrevMillis =millis();\n  float temp = dht.readTemperature();\n  float humidity = dht.readHumidity();\n\n  if(Firebase.RTDB.setFloat(&fbdo,\"Sensor/temp_data\",temp)){\n   Serial.println();\n   Serial.print(temp);\n   Serial.println(\"-\"+fbdo.dataPath()+\"에 성공적으로 저장되었습니다.\");\n   Serial.println(\"(\"+fbdo.dataType()+\")\");\n    }\n\n    else{\n      Serial.println(\"실패 : \"+fbdo.errorReason());\n    }\n  \n    if(Firebase.RTDB.setFloat(&fbdo,\"Sensor/humidity_data\",humidity)){\n   Serial.println();\n   Serial.print(humidity);\n   Serial.println(\"-\"+fbdo.dataPath()+\"에 성공적으로 저장되었습니다.\");\n   Serial.println(\"(\"+fbdo.dataType()+\")\");\n    }\n\n    else {\n      Serial.println(\"실패 : \"+fbdo.errorReason());\n    }\n    }\n// LED를 위한 스팀 빌더    \n\nif(Firebase.ready() && signUpOK){\n\n    \n  if(!Firebase.RTDB.readStream(&fbdo_s1)){\n \n    Serial.println(\"실패 : \"+fbdo_s1.errorReason());\n  }\n     \n     if(fbdo_s1.streamAvailable()){\n     if(fbdo_s1.dataType()== \"boolean\"){\n    ledStatus=fbdo_s1.boolData();\nSerial.println(\"성공적으로 읽어왔습니다: \"+fbdo_s1.dataPath()+ \" - (\"+fbdo_s1.dataType()+\")\");\n      if(ledStatus==true){\n      digitalWrite(LED_PIN,HIGH);  \n      }\n      else{\n        digitalWrite(LED_PIN,LOW);\n      }\n\n      }\n      else{\n      Serial.println(\"실패 : \"+fbdo_s1.errorReason());\n    }\n    }\n\n    } \n\n}\n```\n\n이제 회로를 코드와 지시 사항대로 브레드보드에 연결하고,\n\nESP32에 코드를 업로드하세요.\n\n<div class=\"content-ad\"></div>\n\n# ➡️ 다음 부분:\n\n플러터 앱을 Firebase와 어떻게 연결할까요? 🙋‍♂️ 다음 글에서 설명하겠습니다.\n\n의문이 있으면 언제든지 물어보세요. 🆘","ogImage":{"url":"/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_0.png"},"coverImage":"/assets/img/2024-06-19-ConnectESP32WithGooglesFirebase_0.png","tag":["Tech"],"readingTime":7},{"title":"지능의 세계에서 AI와 IoT로 정의된 미래 관리하기","description":"","date":"2024-06-19 05:30","slug":"2024-06-19-ManaginganAIandIoT-DefinedFutureintheWorldofIntelligence","content":"\n\n지난 몇 년 동안 우리는 인공지능(AI)과 사물인터넷(IoT)의 결합된 영향으로 일상 생활, 경제 및 기업이 현저하게 변화하는 것을 목격했습니다.\n\n![이미지](/assets/img/2024-06-19-ManaginganAIandIoT-DefinedFutureintheWorldofIntelligence_0.png)\n\n이 혁신적인 발견들은 우리 삶 속에서 여러 차례 일어납니다.\n\n그래서 여기서 사물인터넷과 인공지능이 가져다주는 장애물, 비즈니스의 특정 측면에 미치는 영향 및 이 흥미로운 현대 세계를 효과적으로 탐험하기 위해 극복해야 할 윤리적 고려사항을 살펴봅시다.\n\n<div class=\"content-ad\"></div>\n\nAI와 IoT의 협력 에너지\n\n각 발명품이 자신의 맹세를 잘 이행할지는 모르지만, AI와 IoT가 결합되면 그들의 약속을 증폭시키는 함께 협력을 하게 됩니다.\n\n“제조된 통찰력”(AI)이란 데이터를 평가하고 결론을 도출하며 현명한 결정을 내릴 수 있는 알고리즘을 개발하는 것을 의미하며, 다른 한편으로 사물인터넷(IoT)은 데이터를 수집하고 교환하는 연결된 장치들의 네트워크입니다.\n\n이러한 발전이 “노련한 상황”에서 집합되면, 각 개인들이 서로 소통하고 자신의 주장을 내리는데 능숙해진다면 함께 발전할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n가정 내의 AI 센터는 등을 연결할 수 있습니다. Web of Things (IoT) 장치들에게 조명, 실내 온도 조절기, 보안 시스템 등과 같이 센터가 거주자의 선호도에 대해 거의 모든 것을 배울 수 있도록 합니다.\n\n이 센터는 에너지 활용을 향상시키고, 보안 프로토콜을 강화하며, 인간의 개입 없이 생활의 편의를 크게 향상시킬 수 있는 잠재력을 가지고 있습니다.\n\n유사하게, 제조 분야에서는 IoT 센서들이 실시간으로 기계를 모니터링하며, AI 계산이 유지 관리 요구사항을 결정하여 다운타임을 줄이고 생산성을 증가시킬 수 있습니다.\n\n산업의 변화\n\n<div class=\"content-ad\"></div>\n\n사물 인터넷(IoT)과 위조 인사이트의 영향은 다양한 산업 전반에 걸쳐 엄청납니다.\n\n이러한 의료 분야의 발전은 운영 효율성과 질을 향상시킬 잠재력을 지니고 있습니다.\n\n착용형 IoT 장치는 주요 신호를 지속적으로 모니터하며, AI 알고리즘은 이 정보를 활용하여 패턴을 식별하고 건강 문제를 예측하며 맞춤형 치료 요법을 권장할 수 있습니다.\n\n이로 인해 지속적인 결과를 더 높일 수 있으면서도 회복 전문가들의 업무 부담을 줄일 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n농업은 혜택을 창출하는 추가적인 부문입니다.\n\n목축가들은 토양 수분, 비료 수준, 그리고 가지의 건강을 모니터링하는 사물인터넷 기기로부터 실시간 데이터를 받을 수 있습니다.\n\n인공지능은 이 정보를 활용하여 해충 공격을 감지하고 수도 시스템을 관리하며 가장 적합한 시기를 추천할 수 있습니다.\n\n결과적으로 재배 기술은 더욱 관리하기 쉬워졌고 수확량도 증가했습니다.\n\n<div class=\"content-ad\"></div>\n\n지능형 도시와 무인 자동차는 교통 섹터에서 인공 지능과 사물 인터넷 덕분에 더욱 천천히 개선되고 있어요.\n\n사물 인터넷을 지원하는 활동 관리 프레임워크는 활동 스트림을 모니터링하고 제어하여 누출과 방해를 줄일 수 있어요.\n\n다양한 센서와 인공 지능(AI)의 큰 도움으로, 자율 주행 자동차는 더 높은 안전성과 생산성을 제공하고 있어요.\n\n이러한 장치들은 과학 소설 개념에 그치지 않고, 전 세계적으로 개발되고 시험 중이에요.\n\n<div class=\"content-ad\"></div>\n\n도전과 위험\n\n인공지능과 사물 인터넷을 결합하는 것은 엄청난 보증이 있더라도 위험과 문제를 야기할 수 있습니다.\n\n가장 큰 필요성은 보안입니다.\n\n사물 인터넷에 연결된 장치들은 이로 인해 사이버 공격을 받을 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n하나의 기기에서의 침입은 전체 비즈니스에 치명적인 영향을 미칠 수 있습니다.\n\n데이터 보호를 위한 지침을 수립하고 강력한 보안 프로토콜을 확보하는 것이 중요합니다.\n\n사물 인터넷은 엄청난 양의 데이터를 생성합니다. 이러한 기기들은 사람들의 개인 정보를 잠재적으로 노출시킬 수 있습니다.\n\n엄격한 정보 보안 규정이 없다면 이러한 데이터가 남용될 수 있고 보안 침해로 이어질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n강력하고 권위 있는 시스템 모니터링 정보 수집, 처리량 및 사용량 관련 시스템을 구축하여 사용자의 권리를 보호해야 합니다.\n\n또한, AI가 결정을 내릴 때 의무와 명확성에 대한 문제가 제기됩니다.\n\nAI 프레임워크는 모호할 수 있으므로 특정 결과에 도달하는 방식을 이해하기 어려울 수 있습니다.\n\n이러한 명확성에 대한 열망은 법적 인가 및 전략 선택과 같이 중요한 영역에서 선호 및 합리적이지 않은 결과를 불러올 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n도덕과 신념을 유지하기 위해 인공 지능 프레임워크는 설명할 수 있고 공정하게 처리될 수 있어야 합니다.\n\n윤리 고려 사항\n\nAI와 IoT의 적용은 도덕적 고민을 철저히 분석해야 합니다.\n\n주요한 윤리적 우려는 자동화가 일부 직업에 미칠 수 있는 잠재적인 해를 들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\nIoT 및 AI는 생산성과 수확을 높일 수 있지만 기업에서 종업원을 대체할 수 있는 잠재력을 지니고 있습니다.\n\n인력 이동 후속 정책 및 재교육 계획과 같은 선제적인 조치가 필요합니다.\n\n## 농업 분야의 무역도 여기에 이점을 봅니다.\n\n토양 수분, 식물 건강, 그리고 퇴비 수준에 대한 실시간 정보가 IoT 장치를 통해 목지 경영자에게 제공될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 데이터를 보면 인공 지능이 수자원 시스템을 개발하고 벌레 유입을 예측하며 식물 심는 날짜와 수확 날짜를 제안할 수 있을 것입니다.\n\n결과적으로 편집 생산량이 증가하고 농촌 기술이 보다 지속 가능하다는 것이 입증되었습니다.\n\n인공 지능과 사물 인터넷은 교통 부문에서 무인 자동차와 스마트 시티의 발전을 촉진하고 있습니다.\n\n사물 인터넷 기능 활동 관리 시스템은 활동 스트림을 필터링하고 제어하여 배출량과 병목 현상을 최소화할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n자율 주행 차량은 다양한 센서와 인공지능(AI) 안내 시스템 때문에 더 효율적이고 안전한 교통수단입니다.\n\n이러한 개념들은 이론적인 과학 소설이 아니며, 이러한 장치에 대한 연구 및 시험은 전 세계적으로 계속 진행 중입니다.\n\n정부, 기술자, 일반 대중이 혜택을 늘리고 위험을 줄이기 위해 함께 노력해야 합니다.\n\n다음은 고려해야 할 중요한 전략 몇 가지입니다:\n\n<div class=\"content-ad\"></div>\n\n- 안내 및 포인터: 정부는 AI 및 사물 인터넷 혁신의 개발과 사용을 위한 정밀한 법률과 지침을 수립해야 합니다. 이에는 엄격한 보안 프로토콜, 정보 보안 계획, 윤리적 AI 발전을 위한 기준이 포함되어야 합니다.\n- 교육 및 준비에 관한 추측: 사물 인터넷 및 AI 관련 능력에 대한 수요가 증가함에 따라 상당량의 자금이 교육 및 준비 작업에 할당되어야 합니다. 이는 공정한 전문화뿐만 아니라 이러한 기술에 행정 및 도덕을 적용하는 것을 포함합니다.\n- 공공·민간 협회: 공공부문과 민간부문이 협력함으로써 혁신을 촉진하고 그 윤리적 발전을 보장할 수 있습니다. 공공-민간 파트너십은 자금 지원 조사, 프레임워크 강화, 안전하고 윤리적인 혁신 계획을 만드는 데 활용될 수 있습니다.\n- 종합적 향상: IoT 및 AI의 혜택이 널리 공유되도록 하는 것이 중요합니다. 이는 모든 사회적 세그먼트에 알맞고 다양한 요구와 상황을 충족하는 혁신을 개발하는 것을 의미합니다.\n- 지속적인 윤리 감사: AI 및 사물 인터넷 기술이 발전함에 따라 윤리 문제를 식별하고 해결하는 기관들과 연결하면 도움이 될 수 있습니다. 윤리학자, 엔지니어, 다양한 사회-경제 섹터의 대표 등 다양한 협력자들을 이러한 위원회에 포함시켜야 합니다.\n\n사물 인터넷과 인공지능(AI)은 많은 약속을 지니고 있습니다.\n\n이러한 혁신은 자연 생태계 지속가능성부터 의료에 이르기까지 현재 우리 사회가 직면한 가장 중요한 문제들을 이해하는 능력을 가지고 있습니다.\n\n그러나 이러한 약속을 충분히 실현하기 위해서는 관련되는 위험과 윤리적 문제를 신중히 고려해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n미래를 만들 때 교활한 것이 아니라 공정하고 포괄적인 것을 원한다면, 사회는 강력한 리더십, 협력, 도덕적 발전에 초점을 맞춘 AI 및 IoT의 통제를 가할 수 있습니다.\n\n어떻게 생각하세요?\n\n![이야기 이미지](/assets/img/2024-06-19-ManaginganAIandIoT-DefinedFutureintheWorldofIntelligence_1.png)\n\n이 이야기는 Generative AI에서 발행되었습니다. LinkedIn에서 저희와 연락하고 최신 AI 이야기를 전해가기 위해 Zeniteq를 팔로우해주세요.\n\n<div class=\"content-ad\"></div>\n\n최신 제너레이티브 AI 뉴스와 업데이트를 받아보려면 뉴스레터를 구독해주세요. 함께 AI의 미래를 함께 만들어요!\n\n![2024-06-19-ManaginganAIandIoT-DefinedFutureintheWorldofIntelligence_2.png](/assets/img/2024-06-19-ManaginganAIandIoT-DefinedFutureintheWorldofIntelligence_2.png)","ogImage":{"url":"/assets/img/2024-06-19-ManaginganAIandIoT-DefinedFutureintheWorldofIntelligence_0.png"},"coverImage":"/assets/img/2024-06-19-ManaginganAIandIoT-DefinedFutureintheWorldofIntelligence_0.png","tag":["Tech"],"readingTime":5},{"title":"데이터 과학을 위해 필요한 SQL 지식","description":"","date":"2024-06-19 05:28","slug":"2024-06-19-SQLKnowledgeYouNeedForDataScience","content":"\n\n![SQL Knowledge](/assets/img/2024-06-19-SQLKnowledgeYouNeedForDataScience_0.png)\n\n365DataScience의 기사에 따르면, 1,000개의 LinkedIn 데이터 과학 직무 게시물 조사 결과, 60%가 SQL 요구사항이었습니다.\n\n이 정보가 우리에게 무엇을 알려주나요?\n\n음, 데이터 과학자로 취직하고 싶다면 SQL은 필수 기술이며, 이를 보유하고 있다면 취직할 기회가 더 커질 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n이 글에서는 입문 수준 데이터 과학 직무를 얻기 위해 가져야 하는 SQL 지식에 대해 이야기하고, SQL을 배울 때 도움이 된 자료 및 조언을 제공할 것입니다.\n\n# 지식\n\n내 경험 상, 많은 입문 수준 데이터 과학 직무에서 SQL 전문가일 필요는 없습니다; 단순히 쿼리를 작성하고 필요한 데이터를 분석하고 머신러닝 모델을 구축하는 방법을 알고 있어야 합니다.\n\n예를 들어, ETL(추출 변환 로드) 파이프라인을 생성하거나 데이터베이스를 관리하는 것은 일반적으로 데이터 과학자의 업무 범위를 벗어나 데이터 엔지니어의 작업입니다. 그러나 이러한 유형의 작업에 흥미가 있다면 이를 배우지 말아야 한다는 제한은 없습니다!\n\n<div class=\"content-ad\"></div>\n\n## 개요\n\n일단, 관계형 데이터베이스와 다양한 종류의 SQL 버전에 대한 이해를 얻어야 할 거예요. 버전을 꼭 배울 필요는 없어요; 그저 각각의 차이를 이해하고 특정한 이유를 파악하면 돼요. 이 내용은 본문에 깊이 파고들기 전에 간단히 읽어보는 것으로 생각해주세요!\n\n제 경험을 바탕으로 MySQL 또는 PostgreSQL을 배우는 것을 추천해요. 산업 전반에서 가장 많이 사용되는 것들이라고 할 수 있어요. 하지만 모든 SQL 버전에서 대부분의 구문과 기능이 동일하기 때문에 이에 대해 너무 걱정할 필요는 없어요. 하나를 익히면, 나머지 것들은 쉽게 배울 수 있답니다. 그러니 과하게 생각하지 마세요.\n\n## 기본 기능\n\n<div class=\"content-ad\"></div>\n\n솔직히 말해서, 일할 때 질의할 때 95%의 시간은 기본 SQL 함수를 사용해요. 이전에 말했듯이, 데이터 과학자로서 SQL을 주로 사용해서 데이터를 가져오고 기본 변환 작업을 해요.\n\n실제로 더 정교한 변환과 데이터 조작은 Pandas에서 해요. 그러면 중간에 유닛 및 통합 테스트를 통해 쉽게 테스트할 수 있거든.\n\n어쨌든, 알아야 할 주요하고 가장 중요한 SQL 명령어는 다음과 같아요:\n\n\nSELECT * FROM (표준 쿼리)\n\n\n<div class=\"content-ad\"></div>\n\n```js\nSELECT * FROM Employees\n```\n\n이 명령은 테이블에서 열을 선택합니다. * 명령어는 테이블 직원의 모든 열을 가져옵니다.\n\nALTER, INSERT, CREATE (테이블 수정)\n\n```js\n-- 테이블 생성\nCREATE TABLE Employees (\n    EmployeeID INT PRIMARY KEY,\n    FirstName NVARCHAR(50),\n    LastName NVARCHAR(50),\n    BirthDate DATE,\n    Salary DECIMAL(10, 2)\n);\n\n-- 직원 테이블에 새 레코드 삽입\nINSERT INTO Employees (EmployeeID, FirstName, LastName, BirthDate, Salary)\nVALUES (1, 'John', 'Doe', '1980-01-01', 50000.00);\n\n-- Employees 테이블을 변경하여 새 열 추가\nALTER TABLE Employees\nADD Department VARCHAR(50);\n```\n\n<div class=\"content-ad\"></div>\n\n여기서 우리는 Employees라는 테이블을 만들고 기본 키와 함께 열을 정의합니다. 그런 다음 INSERT INTO를 사용하여 이 데이터 프레임에 새로운 행을 추가합니다. 마지막으로 ALTER를 사용하여 Department라는 새 열을 추가합니다.\n\nGROUP BY, ORDER BY\n\n```js\n-- GROUP BY\nSELECT Department, COUNT(*) AS NumberOfEmployees\nFROM Employees\nGROUP BY Department;\n\n-- ORDER BY\nSELECT * FROM Employees\nORDER BY LastName ASC, FirstName ASC;\n```\n\n이 명령어들은 꽤 명확합니다. ORDER BY 명령어는 테이블을 열을 기준으로 정렬하고 GROUP BY는 열로 집계합니다. 여기서 우리는 부서별로 직원 수를 계산합니다.\n\n<div class=\"content-ad\"></div>\n\nWHERE, AND, OR, BETWEEN, IN, HAVING (테이블 필터링)\n\n```js\n-- WHERE, AND, 그리고 OR\nSELECT * FROM Employees\nWHERE Salary > 40000 AND Department = 'Sales';\n\n-- BETWEEN\nSELECT * FROM Employees\nWHERE BirthDate BETWEEN '1970-01-01' AND '1990-12-31';\n\n-- IN\nSELECT * FROM Employees\nWHERE Department IN ('Sales', 'HR');\n\n-- GROUP BY 그리고 HAVING\nSELECT Department, AVG(Salary) AS AverageSalary\nFROM Employees\nGROUP BY Department\nHAVING AVG(Salary) > 45000;\n```\n\nWHERE와 HAVING 명령문은 열을 기준으로 데이터프레임을 필터링합니다. 이 경우에는 급여, 생년월일, 그리고 부서로 필터링하고 있습니다.\n\nAVG, COUNT, MIN, MAX, SUM (집계 함수)\n\n<div class=\"content-ad\"></div>\n\n```sql\n-- AVG, COUNT, MIN, MAX, SUM\nSELECT \n    AVG(Salary) AS AverageSalary,\n    COUNT(EmployeeID) AS NumberOfEmployees,\n    MIN(Salary) AS MinimumSalary,\n    MAX(Salary) AS MaximumSalary,\n    SUM(Salary) AS TotalSalary\nFROM Employees;\n\n```\n\n이 쿼리는 데이터셋에서 통계를 생성합니다. 결과는 평균 급여, 총 직원 수, 최저 급여, 최고 급여, 그리고 총 급여가 있는 행 하나만 출력됩니다.\n\nDISTINCT\n\n```sql\nSELECT DISTINCT Department FROM Employees;\n```\n\n<div class=\"content-ad\"></div>\n\n만약 한 column에 중복된 항목이 있다면, DISTINCT 명령어를 사용하여 고유한 값만 얻을 수 있어요.\n\n날짜와 시간 함수인 DATEADD, DATEDIFF, DATEPART입니다.\n\n```js\n-- DATEADD: 생년월일에 1년을 추가합니다\nSELECT EmployeeID, FirstName, LastName, DATEADD(year, 1, BirthDate) AS BirthDatePlusOneYear\nFROM Employees;\n\n-- DATEDIFF: 직원의 나이를 계산합니다\nSELECT EmployeeID, FirstName, LastName, DATEDIFF(year, BirthDate, GETDATE()) AS Age\nFROM Employees;\n\n-- DATEPART: 출생 연도를 추출합니다\nSELECT EmployeeID, FirstName, LastName, DATEPART(year, BirthDate) AS BirthYear\nFROM Employees;\n```\n\n여기에서 DATEADD는 생일에 1년을 추가하고, DATEDIFF는 직원의 나이를 계산하며 출생일과 현재 날짜 사이의 연도 차이를 얻어내고, DATEPART는 생일로부터 출생 연도를 가져옵니다.\n\n<div class=\"content-ad\"></div>\n\nCASE (기본적으로 다른 언어에서의 if-else 문)\n\n```js\nSELECT EmployeeID, FirstName, LastName, \n    CASE \n        WHEN Salary > 60000 THEN '고'\n        WHEN Salary BETWEEN 40000 AND 60000 THEN '중간'\n        ELSE '저'\n    END AS SalaryCategory\nFROM Employees;\n```\n\nCASE는 조건부 if-else와 같이 작동합니다. 이 경우에는 급여가 60,000보다 크면 \"고\", 40,000에서 60,000 사이이면 \"중간\", 그렇지 않으면 \"저\"로 표시됩니다.\n\nFULL JOIN, LEFT JOIN, RIGHT JOIN, INNER JOIN, UNION(모든 종류의 조인)\n\n<div class=\"content-ad\"></div>\n\n```js\n-- INNER JOIN\nSELECT e.EmployeeID, e.FirstName, e.LastName, d.DepartmentName\nFROM Employees e\nINNER JOIN Departments d ON e.DepartmentID = d.DepartmentID;\n\n-- LEFT JOIN\nSELECT e.EmployeeID, e.FirstName, e.LastName, d.DepartmentName\nFROM Employees e\nLEFT JOIN Departments d ON e.DepartmentID = d.DepartmentID;\n\n-- RIGHT JOIN\nSELECT e.EmployeeID, e.FirstName, e.LastName, d.DepartmentName\nFROM Employees e\nRIGHT JOIN Departments d ON e.DepartmentID = d.DepartmentID;\n\n-- FULL JOIN\nSELECT e.EmployeeID, e.FirstName, e.LastName, d.DepartmentName\nFROM Employees e\nFULL JOIN Departments d ON e.DepartmentID = d.DepartmentID;\n\n-- UNION\nSELECT FirstName, LastName FROM Employees\nUNION\nSELECT FirstName, LastName FROM Managers;\n```\n\nJOIN 명령어는 두 테이블을 특정 열과 id에 따라 결합하는 것입니다. 여기를 참조하여 각 타입의 시각적 설명과 내부 작동 방식을 확인하세요.\n\nJOIN 작업은 아마 가장 어려울 것이므로 꼭 이해해야 합니다! 저도 여전히 실수를 com하지만 첫 직장에서 나쁜 경험을 한 후 많이 개선했습니다. 그러니 제 처럼 하지 말고 꼼꼼히 익히세요!\n\n이러한 기본 함수를 알고 있다면, SQL 연습 문제가 포함된 입사 시 데이터 과학 인터뷰에 합격할 수 있을 것입니다.\n\n<div class=\"content-ad\"></div>\n\n## 고급 기능\n\n기본 기능을 마스터하면 더 많은 시간을 투자하여 고급 함수 중 일부를 학습하는 것이 가치가 있습니다. 저는 일상 업무에서 이러한 함수들을 정기적으로 사용하기 때문에 특히 큰 데이터 세트를 구축할 때 유용합니다. SQL 웨어하우스의 연산 시간이 Python보다 빠르기 때문에 더욱 유용합니다.\n\n공통 표현식 테이블 (CTE) 및 서브쿼리\n\n```sql\n-- 공통 테이블 표현식 (CTE)\nWITH SalesCTE AS (\n    SELECT EmployeeID, SUM(SalesAmount) AS TotalSales\n    FROM Sales\n    GROUP BY EmployeeID\n)\nSELECT e.EmployeeID, e.FirstName, e.LastName, s.TotalSales\nFROM Employees e\nJOIN SalesCTE s ON e.EmployeeID = s.EmployeeID;\n\n-- 서브쿼리\nSELECT EmployeeID, FirstName, LastName, Salary\nFROM Employees\nWHERE Salary > (SELECT AVG(Salary) FROM Employees);\n```\n\n<div class=\"content-ad\"></div>\n\n여기에서 하는 일은 SalesCTE라는 새 테이블을 생성한 다음 이 새 테이블을 Employee에 조인하는 것입니다. 이것은 CTE의 예입니다.\n\n서브쿼리는 새 테이블을 생성하는 것이 아니라 테이블에서 값을 가져와서 필터링하는 것입니다. 이 경우에는 평균 급여입니다.\n\n사용자 정의 함수 (UDFs)\n\n```js\nCREATE FUNCTION dbo.GetEmployeeFullName(@EmployeeID INT)\nRETURNS NVARCHAR(100)\nAS\nBEGIN\n    DECLARE @FullName NVARCHAR(100);\n    SELECT @FullName = FirstName + ' ' + LastName\n    FROM Employees\n    WHERE EmployeeID = @EmployeeID;\n    RETURN @FullName;\nEND;\n\n-- UDF 사용\nSELECT dbo.GetEmployeeFullName(EmployeeID) AS FullName\nFROM Employees;\n```\n\n<div class=\"content-ad\"></div>\n\nUDFs(사용자 정의 함수)는 다른 언어의 일반 함수와 매우 유사하게 작동합니다. 여기에서는 직원의 전체 이름을 가져와 단일 열로 반환하는 함수를 만듭니다.\n\n윈도우 함수 (RANK, ROW_NUMBER, DENSE_RANK)\n\n```js\n-- ROW_NUMBER\nSELECT EmployeeID, FirstName, LastName, Salary,\n    ROW_NUMBER() OVER (PARTITION BY Department ORDER BY Salary DESC) AS RowNum\nFROM Employees;\n\n-- RANK\nSELECT EmployeeID, FirstName, LastName, Salary,\n    RANK() OVER (PARTITION BY Department ORDER BY Salary DESC) AS Rank\nFROM Employees;\n\n-- DENSE_RANK\nSELECT EmployeeID, FirstName, LastName, Salary,\n    DENSE_RANK() OVER (PARTITION BY Department ORDER BY Salary DESC) AS DenseRank\nFROM Employees;\n```\n\n윈도우 함수는 현재 분석 중인 행과 관련된 여러 행 전체에 대한 계산을 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n이 경우에는 ROW_NUMBER()를 사용하여 각 부서의 급여에 따라 직원들을 번호를 매깁니다.\n\nRANK()도 비슷한 작업을 하며 각 부서에서 직원을 급여 순으로 순위를 매깁니다.\n\nDENSE_RANK()는 다시 비슷하지만 동일한 급여를 받는 두 직원의 순위가 같습니다.\n\n문자열 작업 및 정규 표현식\n\n<div class=\"content-ad\"></div>\n\n```sql\n-- 문자열 조작: CONCAT, SUBSTRING, REPLACE 등.\nSELECT \n    CONCAT(FirstName, ' ', LastName) AS FullName,\n    SUBSTRING(FirstName, 1, 1) AS FirstInitial,\n    REPLACE(LastName, 'a', 'o') AS ModifiedLastName\nFROM Employees;\n\n-- LIKE를 사용한 정규 표현식\nSELECT EmployeeID, FirstName, LastName\nFROM Employees\nWHERE FirstName LIKE 'J%'; -- 이름이 'J'로 시작하는 값\n\n-- PATINDEX를 사용한 정규 표현식 (SQL Server)\nSELECT EmployeeID, FirstName, LastName\nFROM Employees\nWHERE PATINDEX('%[0-9]%', LastName) > 0; -- 성에 숫자가 포함된 값\n```\n\nCONCAT은 두 개의 문자열을 결합하고, SUBSTRING은 문자열을 필터링하며, REPLACE는 문자열 내의 문자를 바꿉니다.\n\nLIKE를 통해 `J%`는 J로 시작하는 값들을 검색합니다.\n\n마지막으로, PATINDEX(`%[0-9]%`, LastName) > 0은 LastName에 0부터 9 사이의 숫자 중 하나가 포함된 첫 번째 발생을 찾기 위한 패턴 인덱스 검색입니다.\n\n\n<div class=\"content-ad\"></div>\n\n다른 배울 것들이 많지만, 이러한 고급 기술들은 데이터 과학자로서 가장 자주 사용하는 것들입니다. 당신의 산업과 조직에 따라 다른 것들이 나타날 수 있을 거예요.\n\n## 추가적인 항목\n\n더 많은 시간이 있으시다면 SQL 주변의 인프라를 배울 수 있습니다. SQL 서버, 데이터베이스 관리, 데이터 웨어하우징, 데이터 플랫폼 확장, 쿼리 최적화, ETL 파이프라인 구축 등이 있습니다.\n\n솔직히 말해서, 이러한 주제들에 대해 깊이있는 이해가 없습니다. 왜냐하면 이것들은 데이터 엔지니어가 데이터 과학자보다 더 관리하는 주제들이기 때문입니다. 하지만 이런 것들에 흥미가 있다면, 배우는 것에 대해 편하게 생각해보세요! 나도 미래 언젠가 이를 다뤄볼 계획이 있으며, 그것은 나를 보다 폭넓은 데이터 과학자로 만들어 가치를 증대시킬 것입니다. 하지만, 항상 말했듯이, 모든 것을 배울 수는 없어요!\n\n<div class=\"content-ad\"></div>\n\n# 자료\n\n자료에 관한 사항으로 SQL을 배울 때 W3Schools와 Tutorialspoint를 사용했어요. 이 두 사이트는 완전 무료이고 SQL 기초를 아주 잘 다루고 있어요. 저는 이 사이트들을 완벽한 코스보다는 참고 자료로 생각하는 편이에요. 그러나 시작 단계로서 좋은 입문 자료로서 강추하고, 여러분이 실습할 수 있는 연습문제도 있답니다.\n\n수업 외에 더 많은 실습이 필요하다면 Hacker Rank나 Leetcode와 같은 웹사이트가 좋아요. 저는 입사면접 문제에 대답하기에 자신감이 생기기 전까지 약 50개의 SQL 질문을 Hacker Rank에서 풀었어요.\n\n이 숫자에 대해 너무 걱정하실 필요는 없어요. 각자의 속도에 따라 50개보다 더 많거나 적게 필요할 수 있어요. 중요한 건 이해에 초점을 맞추고, 여러분이 편안하다고 느낄 때 알 수 있답니다.\n\n<div class=\"content-ad\"></div>\n\n# 조언\n\nSQL을 배우기 시작하는 사람들에게 제가 주고 싶은 세 가지 조언은 다음과 같습니다:\n\n- \"적절한\" 과정 선택에 너무 많은 시간을 소비하거나 걱정하지 마세요. 당신이 좋아하는 과정을 선택하고 시작하세요. 초심자로서 어떤 입문 과정이든 도움이 되고 대부분 동일한 주제를 다룰 것입니다.\n- 매일 연습하고 SQL을 이해하기 위해 연습 문제를 해결하는 것이 중요합니다; 10,000 시간 규칙(10,000 번 반복 규칙)은 여기서도 모든 것과 마찬가지로 적용됩니다.\n- 인내심을 갖고, 모든 것이 결국 이해될 것이라고 약속드립니다. 하루에 모든 것을 배우거나 SQL을 완전히 마스터할 수는 없겠지만, 2주 안에 충분히 SQL 지식을 배워 입문 수준의 포지션을 확보할 수 있습니다. 이것이 바로 제가 한 것이며 아래 게시물에서 전체 SQL 학습 여정을 읽을 수 있습니다.\n\n이 글이 당신이 입문 수준 데이터 과학 직군을 확보할 필요한 SQL 지식을 제공했기를 바랍니다! SQL을 배우려면 파이썬보다 요구되는 기술들이 적고 배우는 데 소요되는 시간도 더 짧습니다. SQL은 다소 관리하기 쉬운 작은 언어이지만, 그래도 필수적인 언어입니다.\n\n<div class=\"content-ad\"></div>\n\n# 또 다른 것!\n\n저는 무료 뉴스레터 'Dishing the Data'를 운영하고 있어요. 매주 더 나은 데이터 과학자가 되는 데 도움이 되는 팁, 분야에서의 일반적인 경험, 그리고 지난 주에 한 생각들을 공유하고 있습니다.\n\n# 저와 소통해요!\n\n- LinkedIn, X (Twitter), 또는 Instagram\n- 나의 YouTube 채널에서 기술적인 데이터 과학 및 기계 학습 개념을 배워보세요!","ogImage":{"url":"/assets/img/2024-06-19-SQLKnowledgeYouNeedForDataScience_0.png"},"coverImage":"/assets/img/2024-06-19-SQLKnowledgeYouNeedForDataScience_0.png","tag":["Tech"],"readingTime":11}],"page":"88","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":4},"__N_SSG":true}