{"pageProps":{"posts":[{"title":"SIM800L로 Arduino에서 메시지를 보내고 전화 거는 방법","description":"","date":"2024-06-22 18:49","slug":"2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L","content":"\n\n이 기사에서는 아두이노로 문자 메시지를 보내고 전화를 거는 방법을 공유하고 싶습니다. 그 방법으로 \"SIM800L\"을 사용할 겁니다.\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_0.png)\n\nSIM800L은 세계에서 가장 작은 GSM(Global System for Mobile communication) 모듈입니다. 이 모듈은 UART(Universal Asynchronous Receiver / Transmitter)를 통해 아두이노와 데이터를 교환하는 통신 프로토콜을 사용합니다.\n\n이것은 취미 프로젝트에 아주 좋은 저렴한 가격의 솔루션이에요! 아래 링크를 통해 구입할 수 있습니다 (스폰서가 아니에요, 제가 Aliexpress에서 구입했는데 아주 잘 작동합니다!):\n\n<div class=\"content-ad\"></div>\n\n## 하드웨어 구매 링크:\n\n- SIM800L: AliExpress (4$27)\n- 아두이노 메가: AliExpress (11$31)\n- 저항 및 LED 키트: AliExpress (2$74)\n- 점퍼 케이블: AliExpress (1$07)\n- 최소 3.4V-4.4V 및 최소 2A를 제공할 수 있는 파워 뱅크.\n\n# YouTube 비디오\n\n만약 이 튜토리얼의 비디오 버전을 선호한다면, 제 YouTube 채널을 방문해 주세요:\n\n<div class=\"content-ad\"></div>\n\n# 단계 1: 보드에 솔더링하기!\n\n보드를 받았을 때 핀들이 아직 솔더링되지 않았습니다. 따라서 먼저 SIM800L 보드의 핀들을 솔더링해야 합니다. 그리고 이 모듈에는 2개의 안테나가 함께 제공됩니다: 하나는 금속 나선 모양의 안테나이고, 다른 하나는 전선이 달린 녹색 보드입니다.\n\n![이미지1](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_1.png)\n\n![이미지2](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_2.png)\n\n<div class=\"content-ad\"></div>\n\nSIM800L를 외부에서 사용할 계획이라면 나선형 안테나를 사용할 수 있어요. 나선형 안테나를 사용하기 위해서는 전자 기판에 납땜을 해야 해요.\n\n만약 SIM800L를 집 내부 또는 케이스 내부에서 사용할 계획이라면, 보드 버전 안테나를 선택하는 것이 더 나아요. 이 안테나를 사용하면 나선형 안테나에 비해 더 좋은 연결을 얻을 수 있어요. 안테나를 사용하려면 전자 기판에 끼워 넣기만 하면 돼요.\n\n핀들이 기판에 납땜되면 다음과 같이 보일 거예요:\n\n![image](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_3.png)\n\n<div class=\"content-ad\"></div>\n\n\n![SIM800L](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_4.png)\n\n# About SIM800L\n\nThe pins of SIM800L that we are going to use are:\n\n![SIM800L Pins](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_5.png)\n\n\n<div class=\"content-ad\"></div>\n\nSIM800L을 사용하여 문자 메시지를 보내려면 아래와 같이 아두이노 메가에 연결해야 합니다:\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_6.png)\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_7.png)\n\n여기서는 10 kOhm의 3개의 저항을 배선도에 사용하여 전압을 5V에서 3.3V로 나눕니다. SIM800L 모듈은 3.3V 논리 수준을 갖고 있지만 아두이노는 5V 논리 수준을 갖고 있기 때문에 모듈의 Rx 핀을 아두이노의 디지턈 핀에 직접 연결할 수 없습니다.\n\n<div class=\"content-ad\"></div>\n\n저희 프로젝트에서는 SoftwareSerial 라이브러리를 사용할 예정입니다. 이 라이브러리를 이용하면 아두이노 보드의 다른 디지털 핀을 사용하여 시리얼 통신이 가능하며, 이 기능을 소프트웨어로 구현하여 이름이 \"SoftwareSerial\"인 것입니다. 다만, 이 라이브러리에는 제약 사항이 있습니다. 메가 및 메가 2560 보드의 모든 핀이 변경 인터럽트를 지원하지 않기 때문에 RX로 사용할 수 있는 핀은 다음과 같습니다: 10, 11, 12, 13, 14, 15, 50, 51, 52, 53, A8 (62), A9 (63), A10 (64), A11 (65), A12 (66), A13 (67), A14 (68), A15 (69). 이에 따라 저희의 배선도에서 핀 10과 핀 11을 사용하고 있습니다.\n\n## LED 상태 표시등\n\n<img src=\"/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_8.png\" />\n\n코드를 테스트하기 전에 SIM800L의 LED 표시등을 확인해 보겠습니다. 이 LED는 셀룰러 네트워크의 상태를 나타내기 위해 다른 속도로 깜박입니다.\n\n<div class=\"content-ad\"></div>\n\n- 1초마다 깜빡입니다: 칩은 실행 중이지만 아직 셀룰러 네트워크에 연결되지 않았습니다.\n- 2초마다 깜빡입니다: 요청된 GPRS 데이터 연결이 활성화되었습니다.\n- 3초마다 깜빡입니다: 모듈이 셀룰러 네트워크에 연결되어 음성과 텍스트 메시지를 주고받을 수 있습니다.\n\n## 작동 전압\n\nSIM800L의 작동 전압은 3.4V - 4.4V입니다. 하지만, SMS를 보내거나 전화를 걸 때 전류가 최대 2A까지 증가할 수 있습니다. 이는 매우 중요한 기준입니다. 공급 전력이 적어도 2A와 3.4V를 제공할 수 없다면 SMS를 보내거나 전화를 걸지 못할 수 있습니다.\n\n이 프로젝트에서는 최대 5V와 3A를 제공하는 충전 보조 배터리를 사용했습니다. 보드는 잘 작동하지만, 이상적으로는 동작 전압 범위(3.4V - 4.4V) 내에 공급 전압이 들어오도록 DC-DC 컨버터를 추가하는 것이 좋습니다. 과도한 공급 전력은 보드를 손상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n## Baud Rate\n\n1200 bps부터 115200 bps까지의 속도를 지원하며 자동 속도 감지 기능이 있습니다. 저희 프로젝트에서는 9600 bps를 사용할 예정입니다.\n\n## 디버깅 팁\n\n# 연결 코드 테스트\n\n<div class=\"content-ad\"></div>\n\n이제 Arduino 보드에 다음 코드를 업로드할 수 있습니다:\n\n```js\n#include <SoftwareSerial.h>\n\n// SIM800L과 통신하기 위한 소프트웨어 시리얼 객체 생성\nSoftwareSerial sim800l(11, 10); // SIM800L Tx & Rx를 Arduino #11 및 #10에 연결\nvoid setup()\n{\n  // Arduino 및 Arduino IDE (시리얼 모니터)와의 시리얼 통신 시작\n  Serial.begin(9600);\n  \n  // Arduino 및 SIM800L과의 시리얼 통신 시작\n  sim800l.begin(9600);\n\n  Serial.println(\"초기화 중...\");\n  delay(1000);\n\n  sim800l.println(\"AT\"); // 핸드셰이크 테스트가 성공하면 'OK'로 반환됩니다.\n  updateSerial();\n  sim800l.println(\"AT+CSQ\"); // 신호 품질 테스트, 값의 범위는 0에서 31까지이며, 31이 가장 좋습니다.\n  updateSerial();\n  sim800l.println(\"AT+CCID\"); // SIM 정보를 읽어 SIM이 꽂혀 있는지 확인합니다.\n  updateSerial();\n  sim800l.println(\"AT+CREG?\"); // 네트워크에 등록되었는지 확인합니다.\n  updateSerial();\n}\n\nvoid loop()\n{\n  updateSerial();\n}\n\nvoid updateSerial()\n{\n  delay(500);\n  while (Serial.available()) \n  {\n    sim800l.write(Serial.read()); // Serial이 전달한 내용을 소프트웨어 시리얼 포트로 전달합니다.\n  }\n  while(sim800l.available()) \n  {\n    Serial.write(sim800l.read()); // 소프트웨어 시리얼이 수신한 내용을 시리얼 포트로 전달합니다.\n  }\n}\n```\n\n시리얼 모니터를 열 때 'Both NL and CR' 옵션이 선택되었는지 확인하세요!\n\nArduino IDE의 시리얼 모니터는 다음 메시지를 반환해야 합니다:\n\n<div class=\"content-ad\"></div>\n\n\n![How to send a message and make a phone call from Arduino with SIM800L - Part 9](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_9.png)\n\n![How to send a message and make a phone call from Arduino with SIM800L - Part 10](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_10.png)\n\n\"AT+CSQ\" 명령어를 입력하면 21,0이 반환됩니다. 신호의 품질이 상당히 좋음을 의미합니다.\n\n\"AT+CCID\" 명령어를 입력하면 xxxxxxxxxxxxxxxxxx (20자리 숫자)가 반환됩니다. 이 명령어는 설치된 SIM 카드의 고유 통합 회로 카드 식별자(ICCID)를 반환합니다.\n\n\n<div class=\"content-ad\"></div>\n\n\"AT+CREG?\"은 0, 1을 반환합니다. SIM800L이 홈 네트워크에 등록되었음을 의미합니다.\n\n## 자주 발생하는 문제:\n\n연결 중에 실수를 하면 (예: 선을 잊었거나 잘못된 저항을 사용한 경우), \"테스트 연결 코드\"는 Serial Monitor에 \"Initializing...\"만 출력합니다. Arduino는 SIM800L과 통신할 수 없습니다. 이 경우 배선을 다시 한 번 확인해주세요!\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_11.png)\n\n<div class=\"content-ad\"></div>\n\n만약 당신의 SIM800L의 전원 공급이 2A를 제공할 수 없다면 LED 표시등은 1초에 한 번 깜박일 것입니다. 그러나 연결 테스트는 다음과 같은 메시지를 반환할 것입니다:\n\n“AT+CSQ”를 입력하면 0, 0이 반환됩니다. 이것은 신호 품질이 매우 나쁘다는 것을 의미합니다.\n\n“AT+CREG?”를 입력하면 0, 2가 반환됩니다. 이것은 SIM800L이 어떤 네트워크에도 등록되어 있지 않다는 것을 의미합니다.\n\n<img src=\"/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_12.png\" />\n\n<div class=\"content-ad\"></div>\n\n# 단계 2: SIM800L로 텍스트 메시지 보내기\n\nSMS를 보내려면 sim800l.println(\"AT+CMGF=1\")을 사용하여 메시지 형식을 선택할 수 있습니다. sim800l.println(\"AT+CMGS=\\\"+ZZxxxxxxxxxx\\\"\")를 사용하여 괄호 안에 제공된 전화 번호로 SMS를 전송하세요. ZZ는 전화 번호의 국가 코드입니다. sim800l.print(\"Hello from Robot Amateur!!!\")를 사용하여 해당 번호로 텍스트 메시지를 보내세요.\n\n```js\n#include <SoftwareSerial.h>\n\n// SIM800L과 통신하기 위한 소프트웨어 시리얼 객체 생성\nSoftwareSerial sim800l(11, 10); //SIM800L Tx & Rx가 Arduino #11 및 #10에 연결되어 있습니다.\n\nvoid setup()\n{\n  // Arduino 및 Arduino IDE (시리얼 모니터)와의 시리얼 통신 시작\n  Serial.begin(9600);\n  \n  // Arduino 및 SIM800L과의 시리얼 통신 시작\n  sim800l.begin(9600);\n\n  Serial.println(\"초기화 중...\"); \n  delay(1000);\n\n  sim800l.println(\"AT\"); // 핸드셰이크 테스트 성공 시 OK로 돌아갑니다.\n  updateSerial();\n\n  sim800l.println(\"AT+CMGF=1\"); // 텍스트 모드 설정\n  updateSerial();\n  sim800l.println(\"AT+CMGS=\\\"+ZZxxxxxxxxxx\\\"\");//ZZ를 국가 코드로, xxxxxxxxxx를 전화 번호로 변경하여 SMS를 보냅니다.\n  updateSerial();\n  sim800l.print(\"Hello from Robot Amateur!!!\"); //텍스트 내용\n  updateSerial();\n  sim800l.write(26);\n}\n\nvoid loop()\n{\n}\n\nvoid updateSerial()  \n{\n  delay(500);\n  while (Serial.available()) \n  {\n    sim800l.write(Serial.read()); // 시리얼이 수신한 내용을 소프트웨어 시리얼 포트로 전달합니다.\n  }\n  while(sim800l.available()) \n  {\n    Serial.write(sim800l.read()); // 소프트웨어 시리얼이 수신한 내용을 시리얼 포트로 전달합니다.\n  }\n}\n```\n\n모든 것이 잘 작동하면 시리얼 모니터에서 아래 메시지를 볼 수 있어야 합니다. 모듈 LED 표시등은 3초마다 한 번씩 깜박이고 있어야 합니다. 그리고 아래와 같이 핸드폰으로 \"Hello from Robot Amateur!!!\" 텍스트 메시지를 받아야 합니다!\n\n<div class=\"content-ad\"></div>\n\n\n![Image](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_13.png)\n\n## 자주 발생하는 문제:\n\n만약 SIM 카드에 PIN 코드가 설정되어 있다면, SIM800L을 사용하기 전에 먼저 PIN 코드를 SIM800L에 전송해야 합니다.\n\n예를 들어, 제 경우에는 \"AT+CMGF= \"+전화 번호\"\" 명령어로 \"ERROR\"라는 메시지를 받고 있었습니다. 이는 텍스트 메시지가 성공적으로 전송되지 않았음을 의미합니다.\n\n\n<div class=\"content-ad\"></div>\n\n\n![Image 1](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_14.png)\n\n![Image 2](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_15.png)\n\nOne potential reason may be: your sim card is locked with a pin.\n\nYou have 2 solutions:\n\n\n<div class=\"content-ad\"></div>\n\n- SIM 카드 핀 제거하기:\n\n휴대폰에 SIM 카드를 넣고, 설정-`SIM 카드 잠금-`SIM 카드 잠금 설정으로 이동하세요. 만일 SIM 카드에 핀 코드가 설정되어 있다면, 아래 화면과 유사해야 합니다:\n\n![이미지](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_16.png)\n\n“SIM 카드 잠금 해제” 슬라이드 버튼을 클릭하여 비활성화하세요. SIM 카드의 잠금을 해제하기 위해 핀 코드를 입력해야 합니다.\n\n<div class=\"content-ad\"></div>\n\n![img1](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_17.png)\n\n한번 실행하면 아래 화면을 보게 될 거에요. 이제 SIM 카드 PIN 코드가 비활성화되었습니다.\n\n![img2](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_18.png)\n\n2. `setup()` 함수에 SIM 카드 핀을 보내요\n\n<div class=\"content-ad\"></div>\n\n대신, SIM 카드 핀을 설정() 함수에 보내어 잠금을 해제할 수도 있습니다. 예를 들어, 핀이 1234인 SIM 카드를 잠금 해제하려면 설정() 루프에 다음 코드를 추가해야 합니다:\n\n```js\nString SIM_PIN_CODE = String(\"1234\");\nsim800l.print(\"AT+CPIN=\");\nsim800l.println(SIM_PIN_CODE);\n```\n\n업데이트된 코드는 아래와 같습니다:\n\n```js\n#include <SoftwareSerial.h>\n\n// SIM800L과 통신하기 위한 소프트웨어 시리얼 객체 생성\nSoftwareSerial sim800l(11, 10); // SIM800L의 Tx 및 Rx를 아두이노 #11 및 #10에 연결\n\nvoid setup()\n{\n  // 아두이노 및 아두이노 IDE(시리얼 모니터)와의 시리얼 통신 시작\n  Serial.begin(9600);\n  \n  // 아두이노와 SIM800L 간의 시리얼 통신 시작\n  sim800l.begin(9600);\n\n  Serial.println(\"초기화 중...\");\n  delay(1000);\n\n  sim800l.println(\"AT\"); // 핸드셰이크 테스트 성공시 OK로 돌아갑니다\n  updateSerial();\n\n  String SIM_PIN_CODE = String(\"1234\");\n  sim800l.print(\"AT+CPIN=\");\n  sim800l.println(SIM_PIN_CODE);\n  updateSerial();\n\n  sim800l.println(\"AT+CMGF=1\"); // 텍스트 모드 구성\n  updateSerial();\n  sim800l.println(\"AT+CMGS=\\\"+ZZxxxxxxxxxx\\\"\"); // ZZ를 국가 코드로 변경하고 xxxxxxxxxxx를 문자 메시지로 보낼 전화번호로 변경\n  updateSerial();\n  sim800l.print(\"로봇 아마추어에서 안녕하세요!!!\"); // 텍스트 내용\n  updateSerial();\n  sim800l.write(26);\n}\n\nvoid loop()\n{\n}\n\nvoid updateSerial()\n{\n  delay(500);\n  while (Serial.available())\n  {\n    sim800l.write(Serial.read()); // 시리얼이 받은 내용을 소프트웨어 시리얼 포트로 전달\n  }\n  while (sim800l.available())\n  {\n    Serial.write(sim800l.read()); // 소프트웨어 시리얼이 받은 내용을 시리얼 포트로 전달\n  }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n만약 모든 것이 제대로 작동한다면, 시리얼 모니터는 아래와 같이 보일 것입니다:\n\n![이미지](assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_19.png)\n\n![이미지](assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_20.png)\n\n제 경우에는 SIM 카드의 PIN 코드가 1234이기 때문에 \"AT+CPIN=1234\"를 보냈습니다. 여러분은 여러분의 PIN 코드로 숫자를 조정할 수 있습니다. 이 명령은 OK를 반환하는데, 이는 PIN 코드가 성공적으로 전송되었음을 의미합니다.\n\n<div class=\"content-ad\"></div>\n\n\"AT+CMGF=1\"을 입력하고 OK가 반환되면, 텍스트 메시지를 보내는 모드가 성공적으로 설정되었음을 의미합니다.\n\n당신의 핸드폰에서는 \"문자 메시지 보내기 - 핸드폰 화면\"에서 보여지는 것과 동일한 메시지를 받아야 합니다.\n\n# 단계 3: SIM800L로 전화 걸기\n\n전화를 걸기 위해, 먼저 핸드셰이크를 위해 sim800l.println(\"AT\")을 사용합니다. 그 후에, 전화를 걸기 위해 sim800l.println(\"ATD+ +ZZxxxxxxxxxx;\")를 사용합니다. 괄호 안에 제공된 전화 번호로 전화를 걸고, 마지막으로 sim800l.println(\"ATH\")을 사용하여 전화를 끊어줍니다.\n\n<div class=\"content-ad\"></div>\n\n\n#include <SoftwareSerial.h>\n\n// SIM800L과 통신하기 위한 소프트웨어 시리얼 객체 생성\nSoftwareSerial sim800l(11, 10); // SIM800L의 Tx와 Rx를 아두이노의 11번 핀과 10번 핀에 연결\n\nvoid setup()\n{\n  // 아두이노 및 아두이노 IDE (시리얼 모니터)와의 시리얼 통신 시작\n  Serial.begin(9600);\n  \n  // 아두이노와 SIM800L 간의 시리얼 통신 시작\n  sim800l.begin(9600);\n\n  Serial.println(\"초기화 중...\"); \n  delay(1000);\n\n  sim800l.println(\"AT\"); // 핸드셰이크 테스트 성공시 OK로 돌아옵니다\n  updateSerial();\n\n  String SIM_PIN_CODE = String(\"1234\");\n  sim800l.print(\"AT+CPIN=\");\n  sim800l.println(SIM_PIN_CODE);\n  updateSerial();\n  \n  sim800l.println(\"ATD+ +ZZxxxxxxxxxx;\"); // ZZ에 국가 코드, xxxxxxxxxxx에 전화 걸 번호를 입력하세요\n  updateSerial();\n  delay(20000); // 20초 동안 대기합니다...\n  sim800l.println(\"ATH\"); // 전화 끊기\n  updateSerial();\n}\n\nvoid loop()\n{\n}\n\nvoid updateSerial()\n{\n  delay(500);\n  while (Serial.available()) \n  {\n    sim800l.write(Serial.read()); // 시리얼이 수신한 내용을 소프트웨어 시리얼 포트로 전달\n  }\n  while (sim800l.available()) \n  {\n    Serial.write(sim800l.read()); // 소프트웨어 시리얼이 수신한 내용을 시리얼 포트로 전달\n  }\n}\n\n\n이 코드를 업로드한 후 시리얼 모니터에 다음과 같은 메시지가 출력되었습니다. 모듈 LED 표시등은 3초마다 한 번 깜박여야 합니다. \"AT+CPIN=1234\" 명령이 \"ERROR\"를 반환했지만, \"ATD+ +ZZxxxxxxxxxx;\" 명령은 OK를 반환하여 전화가 성공적으로 걸렸음을 의미합니다.\n\n![아두이노 SIM800L을 사용하여 메시지 보내고 전화 걸기](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_21.png)\n\n![아두이노 SIM800L을 사용하여 메시지 보내고 전화 걸기](/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_22.png)\n\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n축하합니다! 이제 아두이노로 SMS를 보내고 전화를 걸 준비가 되었습니다! 이제 이를 집 안전 프로젝트에 적용할 수 있습니다. 예를 들어, 집 안전 프로젝트에 사용할 수 있습니다.\n\n질문이 있으시면 언제든지 댓글을 남겨주세요. DIY 프로젝트에 대한 흥미로운 아이디어가 있다면 댓글을 남겨주세요!","ogImage":{"url":"/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_0.png"},"coverImage":"/assets/img/2024-06-22-HowtosendamessageandmakeaphonecallfromArduinowithSIM800L_0.png","tag":["Tech"],"readingTime":13},{"title":"Arduino IDE와 AVRDUDESS를 사용해 기존 하드웨어로 UPDI 인터페이스를 통한 새로운 AVR 칩 프로그래밍하는 방법","description":"","date":"2024-06-22 18:47","slug":"2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS","content":"\n\n## 통합 프로그램 및 디버그 인터페이스 (UPDI) 이해하기\n\n통합 프로그램 및 디버그 인터페이스(UPDI)는 Microchip Technology가 개발한 프로프리어터리 인터페이스로서, AVR 및 SAM 마이크로컨트롤러의 프로그래밍 및 디버깅에 사용됩니다. 2016년 소개된 UPDI는 예전 AVR 마이크로컨트롤러에서 사용되던 In-System Programming (ISP) 및 Debug WIRE 인터페이스의 후속 제품입니다. UPDI는 마이크로컨트롤러와 상호작용하는 간단하고 효율적인 방법을 제공하며, 프로그래밍 및 디버깅 요구 사항에 맞는 기능을 포함하고 있습니다. 본 문서는 UPDI 프로토콜, 운영 메커니즘, 그리고 JTAG2UPDI와의 비교를 보다 자세히 살펴봅니다.\n\n## UPDI 개요\n\nUPDI는 UART (Universal Asynchronous Receiver-Transmitter) 시리얼 프로토콜을 기반으로 한 단방향, 이중 통신 프로토콜입니다. 기존의 UART 통신과 달리 별도의 Rx(수신) 및 Tx(송신) 라인을 사용하는 대신, UPDI는 데이터를 수신하고 송신하기 위한 단일 선을 활용합니다. 이 단순화는 핀 개수와 단순성이 중요한 임베디드 시스템에서 특히 유리합니다.\n\n<div class=\"content-ad\"></div>\n\nUPDI의 주요 기능:\n- 프로그래밍 및 디버깅: UPDI는 플래시, EEPROM, 퓨즈 및 잠금 비트를 포함한 비휘발성 메모리(NVM) 공간의 프로그래밍이 가능하며 온칩 디버깅을 용이하게 합니다.\n- PHY 인터페이스: UPDI의 물리적 레이어는 UART 기반으로, 통신을 위해 RESET 핀을 사용합니다. 반 이중 방식으로 작동하여 통신 방향이 데이터를 보내고 받는 것 사이에 교대로 변합니다.\n- 클럭: UPDI는 내부 발진기를 사용하여 일관된 타이밍과 동기화를 제공합니다.\n- 에러 검출: 프로토콜에는 패리티 체크 및 특수 프레임 형식을 통해 에러를 감지하고 신호화하는 메커니즘이 포함되어 있습니다.\n\n## UPDI 통신 프로토콜\n\n![이미지](/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_0.png)\n\n프로그래머 또는 디버거와 마이크로컨트롤러 간의 UPDI를 통한 통신에는 각각 특정 목적을 위해 사용되는 여러 가지 구별된 프레임 유형이 포함됩니다.\n\n<div class=\"content-ad\"></div>\n\n- 데이터 프레임: 시작 비트, 8개의 데이터 비트, 선택적 패리티 비트 및 두 개의 스톱 비트로 구성됩니다. 이 프레임은 실제 데이터를 전송하는 데 사용됩니다.\n- IDLE 프레임: 통신 라인의 유휴 상태를 나타내는 12개의 하이 비트로 구성됩니다.\n- BREAK 프레임: UPDI를 기본 상태로 재설정하는 데 사용되는 12개의 로우 비트로 구성됩니다. 일반적으로 오류 복구 목적입니다.\n- SYNCH 프레임: SYNCH 문자(0x55)는 프로그래머와 마이크로컨트롤러 간의 보드 속도를 동기화합니다.\n- ACK 프레임: UPDI에서 전송된 성공적인 명령 수신 및 실행을 확인하는 확인 프레임입니다.\n\n<img src=\"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_1.png\" />\n\n프로그래머가 UPDI 인터페이스를 재설정하기 위해 BREAK 조건을 보내는 것으로 통신이 시작됩니다. 그 후에는 보드 속도를 동기화하기 위해 SYNCH 프레임이 이어집니다. 그 다음에 프로그래밍 또는 디버깅 명령이 교환되며, 양쪽이 번갈아가면서 송신자와 수신자 역할을 교체합니다.\n\n# 아두이노 나노를 사용하여 UPDI 프로그래머 만드는 방법\n\n<div class=\"content-ad\"></div>\n\nATtiny 마이크로컨트롤러를 UPDI 인터페이스를 사용하여 프로그래밍하려면, Arduino Nano를 UPDI 프로그래머로 사용할 수 있습니다. 이 안내서는 Arduino Nano 설정, Arduino IDE 구성, 그리고 펌웨어를 업로드하여 Nano를 UPDI 프로그래머로 변환하는 방법에 대한 단계별 지침을 제공합니다.\n\n필요한 구성품\n\n- Arduino Nano\n- 10μF 캐패시터\n- 4.7kΩ 저항기\n- 브레드보드\n- 점퍼 와이어\n\nUPDI 프로그래머 구성하기\n\n<div class=\"content-ad\"></div>\n\n- 하드웨어 설정:\n- 아두이노 나노의 핀 D6과 ATtiny 마이크로컨트롤러의 UPDI 핀 사이에 4.7kΩ 저항을 연결하세요.\n- 아두이노 나노의 GND 핀과 RST 핀 사이에 10μF 커패시터를 설치하세요. 커패시터의 양극(선이나 + 기호로 표시)이 RST 핀에 연결되어 있는지 확인하세요.\n\n연결을 도와줄 다이어그램이 있습니다:\n\n```js\nArduino Nano 핀 | 부품 | ATtiny 핀\n-----------------|------|------\nGND              | 점퍼 | GND\n5V               | 점퍼 | VCC\nD6               | 4.7kΩ | UPDI\nGND              | 10μF 캡 | GND\nRST              | 10μF 캡 | + (양극 부분)\n```\n\n<img src=\"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_2.png\" />\n\n<div class=\"content-ad\"></div>\n\n2. 아두이노 IDE 준비하기:\n단계 1: 아두이노 IDE 설치\n— [아두이노 공식 웹사이트](https://www.arduino.cc/en/software)에서 아두이노 IDE를 다운로드하고 설치합니다.\n\n단계 2: megaTinyCore 패키지 추가\n— 아두이노 IDE를 열고 `File` Preferences`로 이동합니다.\n— \"Additional Board Manager URLs\" 필드에 다음 URL을 추가합니다: `http://drazzy.com/package_drazzy.com_index.json`.\n\n![이미지](/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_3.png)\n\n— 설정을 저장하려면 \"확인\"을 클릭합니다.\n— `Tools` Board` Boards Manager`로 이동합니다.\n— 검색란에 \"megaTinyCore\"를 입력하고 \"megaTinyCore by Spence Konde\"를 설치합니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-프로그래밍newAVR칩을기존하드웨어를이용해서UPDI인터페이스로바꾸기_4.png\" />\n\n3. 아두이노 나노를 UPDI 프로그래머로 변환하기:\n단계 1: UPDI 프로그래머 스케치 다운로드\n— [GitHub 저장소](https://github.com/ElTangas/jtag2updi)에서 jtag2updi 스케치를 다운로드합니다. 저장소를 ZIP 파일로 다운로드합니다.\n— ZIP 파일을 컴퓨터의 알려진 위치에 해제합니다.\n\n단계 2: 아두이노 IDE에서 스케치 열기\n— 아두이노 IDE를 열고 '파일` - '열기'를 선택합니다.\n— 압축 해제된 폴더로 이동하여 'jtag2updi.ino' 파일을 엽니다. `.ino` 파일이 비어 보일 수 있지만 괜찮습니다. 필요한 모든 코드는 동일한 폴더 내의 다른 파일에 있습니다.\n\n단계 3: 스케치를 아두이노 나노에 업로드\n— 아두이노 나노 보드를 선택합니다: `도구` - `보드` - `아두이노 나노`.\n— 올바른 프로세서를 선택합니다: `도구` - `프로세서` - `ATmega328P (이전 부트로더)` (해당하는 경우).\n— 올바른 포트를 선택합니다: `도구` - `포트` - `COM[X]` ([X]는 포트 번호입니다).\n— 아두이노 IDE에서 \"업로드\" 버튼을 클릭하여 스케치를 업로드합니다.\n\n<div class=\"content-ad\"></div>\n\n4. 아두이노 나노와 ATtiny 마이크로컨트롤러를 점퍼 와이어로 연결해 보세요:\n\n```js\n아두이노 나노 핀 | ATtiny 핀\n-----------------|-----------\nGND              | GND\n5V               | VCC\nD6               | UPDI\n```\n\n5. ATtiny에 코드 업로드하기:\n단계 1: 아두이노 IDE에서 ATtiny 보드 선택\n— `도구` `보드` `ATtiny`로 이동하고 적절한 ATtiny 모델(예: ATtiny1614)을 선택합니다.\n\n단계 2: 프로그래머 설정\n— `도구` `프로그래머`로 이동하고 `jtag2updi (megaTinyCore)`를 선택하세요.\n\n<div class=\"content-ad\"></div>\n\n단계 4: 코드 업로드하기\n- 코드를 확인하고 \"업로드\" 버튼을 클릭하여 업로드하세요.\n\nArduino IDE를 사용하여 코드를 업로드하는 방법은 매우 간단하고 쉬운 방법입니다.\n\n# AVRDUDESS를 사용하여 미리 컴파일된 펌웨어 업로드하기\n\n- Hex 파일 준비:\n만약 프로그램이 플랫폼 IO나 비슷한 플랫폼으로 작성되었다면, 코드의 컴파일된 Hex 파일을 얻을 수 있습니다.\n- AVRDUDESS 설치\n여기에서 설정을 다운로드할 수 있습니다.\n- `avrdude.conf` 수정:\n설치 디렉토리에서 `avrdude.conf` 파일을 찾으세요.\n그런 다음 VS code나 그와 유사한 플랫폼을 사용하여 구성 파일을 열고 다시 저장하고 구성 파일에 다음 부분을 추가하세요.\n\n<div class=\"content-ad\"></div>\n\n```js\n#------------------------------------------------------------\n# jtag2updi 프로그래머 정의\n#------------------------------------------------------------\n\nprogrammer\n  id    = \"jtag2updi\";\n  desc  = \"JTAGv2에서 UPDI로 변환\";\n  type  = \"jtagmkii_pdi\";\n  connection_type = serial;\n  baudrate = 115200;\n;\n```\n\n이 부분을 다음 줄 근처에 추가해주세요,\n\n<img src=\"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_5.png\" />\n\n3. AVRDUDESS 사용 방법:\n— AVRDUDESS를 엽니다.\n— 프로그래머로 `JTAGv2에서 UPDI로 변환`을 선택합니다.\n— Arduino Nano가 연결된 COM 포트를 선택합니다.\n— 생성한 `.hex` 파일을 불러옵니다.\n— 코드를 ATtiny 마이크로컨트롤러에 업로드하려면 “프로그램”을 클릭합니다.\n\n<div class=\"content-ad\"></div>\n\n\n![Programming new AVR chip with UPDI interface](/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_6.png)\n\n- 작동하지 않으면 보레이트를 낮추거나 올바른 COM 포트가 선택되었는지 확인해보세요.\n\n## 유용한 링크\n\n- jtag2updi GitHub\n- Microchip Studio\n- AVRDUDESS\n\n\n<div class=\"content-ad\"></div>\n\n프로젝트에 잘 도움이 되길 바라요. 궁금한 게 있으면 언제든 물어봐 주세요.","ogImage":{"url":"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_0.png"},"coverImage":"/assets/img/2024-06-22-ProgrammingnewAVRchipswithUPDIinterfacewithexistinghardwareUsingArduinoIDEandAVRDUDESS_0.png","tag":["Tech"],"readingTime":6},{"title":"Arduino를 사용하여 RC 수신기 신호 읽는 방법","description":"","date":"2024-06-22 18:46","slug":"2024-06-22-HowtoreadRCreceiversignalwithArduino","content":"\n\n![img](/assets/img/2024-06-22-HowtoreadRCreceiversignalwithArduino_0.png)\n\nRC 송신기와 수신기를 서보 모터 또는 비행 제어기와 함께 사용하는 방법에 대한 문서를 쉽게 찾을 수 있지만, Arduino를 사용하여 RC 신호를 읽는 예제를 찾기는 그렇게 쉽지 않습니다. 그래서 매우 직관적인 자습서를 작성하기로 결정했습니다.\n\n저는 FlySky FS-I6X 송신기와 FS-iA10B 수신기를 사용하고 있지만, PWM(Pulse With Modulation)을 지원하는 모든 수신기에서 작동해야 합니다. 이는 Arduino가 ~ 기호로 표시된 핀을 통해 아날로그 값을 출력하기 위해 사용하는 프로토콜과 동일합니다(그러나 우리는 Arduino를 사용하여 읽을 것이므로 이러한 핀만 사용할 필요는 없습니다).\n\n의도는 읽고자 하는 각 채널의 수신기 핀을 Arduino의 디지털 포트에 연결하는 것입니다. 매우 직관적입니다. Arduino 핀은 입력 포트로 작동하고 수신기도 Arduino의 5V에서 전원을 공급받아야 합니다. 이것은 수신기의 5개 채널, 짐벌을 위한 4개 채널, 그리고 온/오프 스위치를 위한 1개 채널을 읽기 위한 배선 스키마입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![How to read RC receiver signal with Arduino](/assets/img/2024-06-22-HowtoreadRCreceiversignalwithArduino_1.png)\n\nArduino 스케치에서는 사용 중인 핀을 입력 핀으로 설정해야 하며 `pinMode(pin, INPUT)`과 같이 값을 읽을 때 `pulseIn(inputPort, HIGH, 2500)` 함수를 사용하여 값을 읽을 것입니다. 이는 실전에서 1000에서 2000 사이의 숫자를 의미하는 펄스의 지속 시간을 반환합니다. 짐벌에 대한 부정적인 값의 경우 1000에서 1499까지의 숫자를 읽을 것입니다. 0의 경우 1500을 읽습니다. 양수 값의 경우 1501에서 2000까지의 숫자를 읽습니다. 물론 송신기 구성에 따라 약간 달라질 수 있습니다. 이 범위로 작업하는 대신 다음과 같은 매우 편리한 함수를 사용할 수 있습니다. `map(channelValue, 1000, 2000, -100, 100)`. 이는 수신기에서의 모든 입력을 -100에서 100 사이의 비례적인 숫자로 변환할 것입니다. 수신기가 꺼져 있으면 아마도 값이 0이 되므로 이를 방지하기 위해 코드를 보호해야 합니다.\n\n다른 주의해야 할 점은 송신기의 반전 기능입니다. 사용 가능한 스위치 중 하나에 대해 이를 사용했습니다. FlySky 송신기는 수신기에 연결하기 전에 모든 스위치를 올리도록 강제하므로 `off` 값은 실제로 최고 값인 2000입니다. 따라서 이 채널을 반전시키면 `off` 값이 최소값인 1000이 되도록 할 수 있을 것입니다. 그러나 실수로 송신기를 끈 채 수신기를 켰을 때, 신호가 읽히지 않는 `on` 상황이 발생할 수 있습니다. 송신기를 끈 채로 수신기를 켜면 절대 안 되는 것은 알지만 개발 중에는 사고가 발생하기도 합니다. 따라서 반전 신호 기능을 사용하기보다는 사전에 예방하는 것이 좋습니다.\n","ogImage":{"url":"/assets/img/2024-06-22-HowtoreadRCreceiversignalwithArduino_0.png"},"coverImage":"/assets/img/2024-06-22-HowtoreadRCreceiversignalwithArduino_0.png","tag":["Tech"],"readingTime":2},{"title":"TCS3200 센서를 이용한 NPK질소, 인산, 칼륨 검출 방법","description":"","date":"2024-06-22 18:45","slug":"2024-06-22-NPKDetectionusingTCS3200sensor","content":"\n\nNPK는 질소, 인 및 칼륨으로 토양에서 가장 기본적인 영양소입니다. 이 무기 성분들은 식물 성장에 도움이 되는 토양의 비옥도를 유지하는 데 중요합니다. 전통적인 NPK 센서는 토양 속 질소, 인 및 칼륨 함량을 결정하는 데 적합하며, 토양 내 질소, 인 및 칼륨 농도에 의해 유도된 전도도 변화를 검출하여 토양의 비옥도를 평가합니다. 그러나 이 센서의 단점은 토양에 삽입되어 값을 테스트해야 하며, 이 값은 특정 영역에만 적용되며 이 센서로 얻은 값은 토양 내 NPK 함량의 정확한 양을 측정할 수는 없지만 작농가들이 비료를 적용하는 데 도움이 되는 경험적 및 이론적 값이 제공됩니다. 따라서 현장 테스트는 수행할 수 없습니다. 이때 TCS3200 센서가 도움이 될 수 있습니다. NPK 센서보다 효율적이며 현장 토양 테스트를 쉽게 수행할 수 있습니다.\n\n# TCS3200 센서:\n\n![TCS3200](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_0.png)\n\n위 이미지는 TCS3200 색상 센서입니다. 이 센서는 기본적으로 RGB 색상 센서이며 이미지에서 볼 수 있듯이 회로 기판의 각 모서리에 4개의 흰색 조명 LED와 4개의 단자가 있지만, 실제 센서는 중앙에 위치해 있습니다.\n\n<div class=\"content-ad\"></div>\n\n\n![TCS3200 Sensor](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_1.png)\n\n이전에 언급했듯이, RGB 강도를 감지하는 데 사용되고 원리는 다음과 같습니다. TCS3200 센서는 빛 강도 및 색에 해당하는 주파수를 가진 제곱파(50% 듀티사이클)를 출력하며, 이 주파수는 빛 강도에 직접적으로 비례합니다. TCS3200D의 전형적인 출력 주파수 범위는 2Hz에서 500KHz입니다.\n\n- RGB 감지용 TCS3200 센서\n이 분석에서는 TCS3200 센서와 LED를 연결하는데 Arduino Uno를 마이크로컨트롤러 보드로 사용했습니다.\n\n![TCS3200 Sensor with Arduino Uno](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_2.png)\n\n\n<div class=\"content-ad\"></div>\n\n위의 회로는 TCS3200 센서를 통해 RGB 검출을 위한 것이며, 결과는 아두이노 Uno 마이크로컨트롤러 보드에 연결된 LED로 표시됩니다.\n\n2. NPK 검출 및 균일한 비료 분사를 위한 TCS3200 센서\n\n먼저 ppm을 기반으로 NPK 양을 분석해야 합니다. 이에 따라 많은 연구 끝에 질소, 인 및 칼륨이 아래에 나와 있는 것처럼 Blue, Green 및 Red에 민감하다는 것이 밝혀졌습니다.\n\n![NPKDetectionusingTCS3200sensor](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_3.png)\n\n<div class=\"content-ad\"></div>\n\n아래 로직에 기반하여 색 감지 및 기타 작업을 위한 분석을 수행했습니다:\n\n빨강 값:\n\nredValue=pulseIn(sensorOut, LOW)\n\n초록 값:\n\n<div class=\"content-ad\"></div>\n\ngreenValue = pulseIn(sensorOut, LOW)\n\n파란색 값:\n\nblueValue = pulseIn(sensorOut, LOW)\n\n빨간색이 우세할 때:\n\n<div class=\"content-ad\"></div>\n\n\n파란색 값을 pulseIn(sensorOut, LOW) 으로 가져옵니다.\n\nR ` B and R ` G\n\n만약 파란색이 우세하다면:\n\nblueValue=pulseIn(sensorOut, LOW)\n\n\n<div class=\"content-ad\"></div>\n\nB ` R 와 B ` G\n\nRGB 값 읽기:\n\nredValue = pulseIn(sensorOut, LOW)\n\ngreenValue = pulseIn(sensorOut, LOW)\n\n<div class=\"content-ad\"></div>\n\nblueValue = pulseIn(sensorOut, LOW)\n\nR = pulseIn(sensorOut, LOW)\n\nG = pulseIn(sensorOut, LOW)  \n\nB = pulseIn(sensorOut, LOW)\n\n<div class=\"content-ad\"></div>\n\n색상 감지:\n\n- R 밴드 R과 G ⟹ θ = 0도\n- B(R) and B(G) ⟹ θ = 90도\n- B와 G ⟹ θ = 90도\n\n<div class=\"content-ad\"></div>\n\n위 표는 탐지를 위해 수행된 연구, 분석 및 연구에 대한 내용입니다. 그러나 비료 분사 부분에는 Arduino Uno 및 3개의 서보 모터가 TCS3200 빛 센서와 통합되었습니다. 이러한 구성요소 간의 연결은 다음과 같습니다:\n\nTCS3200 및 Arduino Uno\n\n![이미지](/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_4.png)\n\nArduino Uno 및 서보 모터\n\n<div class=\"content-ad\"></div>\n\n아래는 제안된 아이디어입니다.\n\n아래의 링크에서 코드를 확인해보세요: https://github.com/SumukhJK","ogImage":{"url":"/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_0.png"},"coverImage":"/assets/img/2024-06-22-NPKDetectionusingTCS3200sensor_0.png","tag":["Tech"],"readingTime":3},{"title":"두통 없이 WiFi 모듈 ESP-01 ESP8266 사용하는 방법","description":"","date":"2024-06-22 18:43","slug":"2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache","content":"\n\n요즘, ESP32와 Arduino UNO 보드를 통합하여 스마트 홈 시스템을 만드는 것을 시도해보고 있어요. 집의 식물을 위한 보습 장치 같은 거 말이죠. 여기에는 그 여정과 그 과정에서 주요한 고충 포인트에 대해 설명하겠어요. 그리고 왜 NodeMCU의 ESP8266을 사용하게 된 이유에 대해서도 언급할게요.\n\n그래서 원하던 흐름은 다음과 같아요:\n\n- 시스템을 처음 시작할 때, 액세스 포인트 시작.\n- AP에 연결하고 로컬 네트워크의 SSID와 비밀번호를 요청하는 웹 페이지를 열기.\n- 데이터가 전달된 후, 시스템은 SSID와 비밀번호를 EEPROM에 저장하고 액세스 포인트를 중지하고 로컬 Wi-Fi에 클라이언트로 연결해야 해요.\n\n# ESP-01\n\n<div class=\"content-ad\"></div>\n\n이것을 조사하기 시작했을 때, ESP-01에 대한 아주 좋은 아이디어라고 생각했어요. 작고 저렴하면서 필요한 기능을 모두 갖추고 있거든요.\n\nESP-01은 Arduino를 이용해 RX/TX 핀을 통해 AT 프로토콜을 사용하여 제어할 수 있어요.\n\n하지만 UART AT 명령어를 사용하는 동안 약간의 조사를 한 후, Arduino의 메모리는 코딩을 끝내기 전에 사라질 것 같다는 사실을 알게 되었어요. ESP8266은 훨씬 더 많은 메모리를 가지고 있어요. 비교해 보면 ESP8266은 80kB의 메모리를 가지고 있고, Arduino Uno는 2kB를 갖고 있어요. 이는 계산기로부터 PC를 제어하려는 것과 비슷해요. 이런 방식은 작동하지 않아요.\n\n게다가, ESP 기반 컨트롤러는 IO 핀을 가지고 있어요. 이러한 핀을 Arduino에 연결하는 수고를 덜며 문제를 해결할 수 있어요. 그래서 ESP를 Arduino에서 제어해야 할까요? 그렇지 마세요! 이렇게 하지 마세요. 반드시 그렇게 해야 하는 것은 아니에요. 이 글이 다른 사람들이 제 실수를 반복하는 것을 막아줄 수 있기를 바라요.\n\n<div class=\"content-ad\"></div>\n\n아래에서 ESP를 올바르게 사용하는 방법을 볼 수 있습니다.\n\n![이미지](/assets/img/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache_0.png)\n\n# NodeMCU의 ESP8266\n\nESP-01의 사용은 Arduino와 함께 여러 문제가 위에서 설명된 것과 맞닿아 있습니다 !!!!!\n\n<div class=\"content-ad\"></div>\n\n반면에, NodeMCU의 ESP8266은 쉽게 다가갈 수 있는 친구에요. ESP 모듈이 내장되어 있고 좋은 컴퓨팅 성능을 갖추고 있습니다. 또한 배선이 필요하지 않아요.\n\n## 단계 1. 설정.\n\n가장 먼저, NodeMCU 칩과 작업할 수 있도록 Arduino IDE와 OS를 설정해야 합니다.\n\n시스템에서 시리얼을 보이도록 CH340G 드라이버를 설치해주세요.\n\n<div class=\"content-ad\"></div>\n\n- macOS\n- Linux\n- Windows\n\n도구 - 보드 - 보드 관리자로 이동하세요. esp8266 보드 관리자를 설치하세요.\n\n<img src=\"/assets/img/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache_1.png\" />\n\n그 후, ESPAsyncTCP와 ESPAsyncWebServer 라이브러리를 설치해야 합니다. 저장소를 복제하고 이름에서 \"-master\"를 제거하세요. 그 폴더들을 Arduino/libraries/ 폴더로 이동하세요.\n\n<div class=\"content-ad\"></div>\n\n코딩을 시작할 준비가 모두 완료되었어요.\n\n## 단계 2. 코딩.\n\n접속 지점 SSID/비밀번호를 설정 중입니다.\n\n```js\nconst char* ssid = \"ESP8266-Access-Point\";\nconst char* password = \"123456789\";\n```\n\n<div class=\"content-ad\"></div>\n\n서버 액세스시 반환할 HTML 페이지:\n\n```js\nconst char index_html[] PROGMEM = R\"rawliteral(\n<!DOCTYPE HTML>\n<html>\n  <head>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <style>\n      html {\n        font-family: Arial;\n        display: inline-block;\n        margin: 0px auto;\n        text-align: center;\n      }\n      h2 {\n        font-size: 3.0rem;\n      }\n      p { \n        font-size: 3.0rem;\n      }\n      .units {\n        font-size: 1.2rem;\n      }\n      .input {\n        font-size: 20px;\n        margin-bottom: 10px;\n      }\n      .wifi-form {\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: space-around;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"wifi-form\">\n      <h1>테스트</h1>\n      <input id=\"ssid\" class=\"input\" type=\"text\" maxlength=\"32\">\n      <input id=\"password\" class=\"input\" type=\"password\">\n      <button onclick=\"connectToWifi()\">연결</button>\n    </div>\n  </body>\n  <script>\n    function connectToWifi() {\n      var ssid = document.getElementById(\"ssid\").value;\n      var password = document.getElementById(\"password\").value;\n      var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"/\", true);\n      xhr.setRequestHeader('Content-Type', 'application/json');\n      xhr.send(ssid + \":\" + password);\n    }\n  </script>\n</html>)rawliteral\";\n```\n\n로컬 Wi-Fi의 SSID와 비밀번호를 요청하는 간단한 양식입니다.\n\nconnectToWifi 함수는 POST 요청으로 데이터를 서버로 전송합니다.\n\n<div class=\"content-ad\"></div>\n\n요청을 처리할 서버를 설정해 봅시다.\n\n다음을 글로벌 변수로 추가해 주세요.\n\n```js\nAsyncWebServer server(80);\n```\n\n접속 지점 함수를 만들어 주세요.\n\n<div class=\"content-ad\"></div>\n\n```js\nvoid createAccessPoint() {\n  WiFi.softAP(ssid, password);\n  IPAddress IP = WiFi.softAPIP();\n  Serial.print(\"AP IP address: \");\n  Serial.println(IP);\n  // Print ESP8266 Local IP Address\n  Serial.println(WiFi.localIP());\n  server.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request) {\n    request->send_P(200, \"text/html\", index_html);\n  });\n  server.on(\"/\", HTTP_POST, [](AsyncWebServerRequest *request){},NULL, [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {\n    ssidWifi = \"\";\n    passwordWifi = \"\";\n    String res((char *)data);\n    int sepIndex = -1;\n    for (int i = 0; i < len; ++i) {\n      if (res[i] != ':') {\n        if (sepIndex == -1) {\n          ssidWifi.concat(res[i]);\n        }\n        if (i > sepIndex && sepIndex != -1) {\n          passwordWifi.concat(res[i]);\n        }\n      }\n      else {\n        sepIndex = i;\n      }\n    }\n    writeEEPROM(ssidWifi, ssidIndex);\n    writeEEPROM(passwordWifi, passwordIndex);\n    request->send(200, \"text/plain\", \"SUCCESS\");\n  });\n  server.begin();\n}\n```\n\n우리가 이걸 살펴보자.\n\n```js\nWiFi.softAP(ssid, password);\n```\n\n이 부분은 시작 시 SSID 및 비밀번호가 전달되어 액세스 포인트를 생성합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nIPAddress IP = WiFi.softAPIP();\nSerial.print(\"AP IP 주소: \");\nSerial.println(IP);\n// ESP8266 로컬 IP 주소 출력\nSerial.println(WiFi.localIP());\n```\n\n로그 기능입니다. 디버깅에 필요합니다.\n\n```js\nserver.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request) {\n    request->send_P(200, \"text/html\", index_html);\n});\n```\n\nHTTP GET 요청을 처리하고 HTML 페이지를 반환합니다.\n\n<div class=\"content-ad\"></div>\n\n```js\nserver.on(\"/\", HTTP_POST, [](AsyncWebServerRequest *request){},NULL, [](AsyncWebServerRequest *request, uint8_t *data, size_t len, size_t index, size_t total) {\n    ssidWifi = \"\";\n    passwordWifi = \"\";\n    String res((char *)data);\n    int sepIndex = -1;\n    for (int i = 0; i < len; ++i) {\n      if (res[i] != ':') {\n        if (sepIndex == -1) {\n          ssidWifi.concat(res[i]);\n        }\n        if (i > sepIndex && sepIndex != -1) {\n          passwordWifi.concat(res[i]);\n        }\n      }\n      else {\n        sepIndex = i;\n      }\n    }\n    writeEEPROM(ssidWifi, ssidIndex);\n    writeEEPROM(passwordWifi, passwordIndex);\n    request->send(200, \"text/plain\", \"SUCCESS\");\n  });\n```\n\n위 코드는 포스트 요청을 처리합니다. AsyncWebServer 요청을 받아들이기 위해 다섯 번째 매개변수를 AsyncWebServer 요청으로 추가해야 합니다. 알고리즘은 매우 간단합니다. 글로벌 변수인 ssidWifi와 passwordWifi를 지웁니다. SSID:password를 이런 형식으로 구문 분석하고 데이터를 EEPROM에 저장합니다.\n\n그 후에 서버를 시작합니다.\n\nssidIndex는 0이며, 이는 데이터의 시작 주소입니다.\n\n<div class=\"content-ad\"></div>\n\n패스워드 인덱스는 33입니다. 이는 SSID 최대 길이가 32바이트이며, 하나의 바이트가 문자열의 길이로 예약되어 있기 때문입니다. 이를 writeEEPROM 함수에서 확인할 수 있습니다:\n\n```js\nvoid writeEEPROM(String value, int address) {\n  int len = value.length();\n  EEPROM.put(address, len);\n  for (int i = address + 1; i < len + address + 1; ++i) {\n    EEPROM.put(i, value[i - address - 1]);\n  }\n  EEPROM.commit();\n}\n```\n\n이제 이러한 데이터를 EEPROM에서 읽을 수 있어야 합니다:\n\n```js\nString readEEPROM(int address) {\n  uint8_t len = EEPROM.read(address);\n  if (len == 255) return \"\";\n  String res;\n  for (int i = address + 1; i < len + address + 1; ++i) {\n    char c = (char)EEPROM.read(i);\n    res.concat(c);\n  }\n  return res;\n}\n```\n\n<div class=\"content-ad\"></div>\n\n255- 이는 비어 있는 데이터를 나타냅니다. 여기서는 먼저 데이터 길이에 할당된 첫 번째 바이트를 받아 그 후의 데이터를 읽고 결과를 반환합니다.\n\n이제 모든 것을 함께 묶어 보겠습니다.\n\n```js\nvoid setup() {\n  Serial.begin(9600);\n  EEPROM.begin(128);\n  ssidWifi = readEEPROM(ssidIndex);\n  passwordWifi = readEEPROM(passwordIndex);\n  if (ssidWifi.length() > 0 && passwordWifi.length() > 0 && WiFi.status() != WL_CONNECTED) {\n    WiFi.softAPdisconnect(true);\n    server.end();\n    WiFi.begin(ssidWifi, passwordWifi);\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(1000);\n    }\n  }\n  else\n  {\n    createAccessPoint();\n  }\n}\nvoid loop() {\n  if (ssidWifi.length() > 0 && passwordWifi.length() > 0 && WiFi.status() != WL_CONNECTED) {\n    WiFi.softAPdisconnect(true);\n    server.end();\n    WiFi.begin(ssidWifi, passwordWifi);\n    while (WiFi.status() != WL_CONNECTED) {\n      delay(1000);\n    }\n  }\n}\n```\n\n여기까지입니다. 하드코딩 없이 wifi 자격 증명을 설정할 수 있는 웹페이지가 있는 서버를 시작하는 작동하는 시스템이 준비되었습니다.\n\n<div class=\"content-ad\"></div>\n\n그리고 GitHub의 작동 예제 링크를 변경하십시오.","ogImage":{"url":"/assets/img/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache_0.png"},"coverImage":"/assets/img/2024-06-22-HowtousewifimoduleESP-01ESP8266withouttheheadache_0.png","tag":["Tech"],"readingTime":8},{"title":"ESP32로 SD 카드 IO 성능 최적화하는 방법","description":"","date":"2024-06-22 18:42","slug":"2024-06-22-OptimizingSDCardIOPerformancewithESP32","content":"\n\n# 저에 대해\n\n안녕하세요, 저는 지위 마오입니다. 지반공학 기술자이자 IoT 시스템에 열정을 가진 사람입니다. 저는 저전력 마이크로컨트롤러와 LoRa 통신 시스템을 연구하여 취미로 사용할 수 있는 원격 모니터링 솔루션부터 산업용 모니터링 또는 제어 시스템을 구축하고 있습니다. 제 웹사이트를 방문해주세요: https://www.qiweimao.dev/blog\n\nLinkedIn | Github | Reddit | X\n\n# 많은 파일로 인해 SD 카드 I/O 속도가 느려지는 이유\n\n<div class=\"content-ad\"></div>\n\nSD 카드의 단일 폴더에 대량의 파일을 축적하면 파일 시스템(FAT32 또는 exFAT과 같은 SD 카드용)이 파일을 찾거나 열기 위해 디렉터리 항목을 검색해야 합니다. 파일이 증가함에 따라 이 디렉터리 검색 프로세스는 느려질 수 있습니다. 그 이유는 다음과 같습니다:\n\n- 디렉터리 항목: FAT32와 exFAT은 디렉터리 항목을 선형 목록에 저장합니다. 파일이 늘어날수록 이 목록을 검색하는 시간이 선형적으로 증가하므로 특정 파일을 찾거나 열 때 상당히 더 많은 시간이 걸릴 수 있습니다.\n- 단편화: 파일이 생성되고 삭제되며 수정되면 시간이 지남에 따라 단편화가 발생할 수 있습니다. 이는 파일의 일부가 SD 카드의 다른 물리적 위치에 퍼져 있을 수 있어 파일을 읽는 데 걸리는 시간을 증가시킬 수 있습니다.\n- 클러스터 할당: 각 파일 및 디렉터리 항목에는 클러스터 할당이 필요하며, 이는 파일 할당 테이블(FAT)에 의해 관리됩니다. 많은 파일을 처리할수록 이러한 할당을 업데이트하고 관리하는 과정이 더 복잡하고 시간이 많이 소요됩니다.\n\n# 입출력 테스트\n\n다음은 단일 디렉터리의 모든 파일을 기록하는 것과 하위 폴더 전략을 사용하는 것 사이의 속도 차이를 비교하는 두 테스트 프로그램에 대한 개요입니다. 이 프로그램은 각 쓰기 동작에 걸리는 시간을 기록하고 이 정보를 로그 파일에 저장할 것입니다. ESP32는 500ms마다 파일 쓰기 동작을 시작할 것입니다.\n\n<div class=\"content-ad\"></div>\n\n![Optimizing SD Card I/O Performance with ESP32](/assets/img/2024-06-22-OptimizingSDCardIOPerformancewithESP32_0.png)\n\nESP32에서 SD 카드 I/O의 성능 분석 결과, 파일을 하나의 폴더에 저장하는 것과 분 단위로 서브폴더에 구성하는 것 사이에 명확한 추세 차이가 나타납니다.\n\n하나의 폴더에 순차적으로 파일을 저장하는 경우 파일 수가 증가함에 따라 파일 I/O 시간이 선형적으로 증가하는 것을 확인할 수 있습니다. 이는 대량 디렉토리 내의 파일 접근 및 관리가 검색 및 검색 시간이 증가하여 점진적으로 느려진다는 것을 시사합니다. 반면에, 서브폴더 접근 방식은 초기에는 I/O 시간이 비슷하게 증가하지만 새 파일이 새로운 서브폴더로 이동함에 따라 접근 시간이 간헐적으로 감소합니다.\n\n이 현상은 파일을 작은 시간 기반 클러스터로 조직화하는 것이 단일 폴더 저장 과정에서 관찰된 성능 하락을 완화하는 것을 나타냅니다. 이러한 조직 전략은 액세스 속도를 최적화할 뿐만 아니라 저장 부하를 관리 가능한 하위 집합에 분산하여 전체 시스템 효율성을 향상시킬 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n### 프로그램 1: 단일 디렉토리 로깅\n\n```cpp\n#include <Arduino.h>\n#include <SD.h>\n#include <SPI.h>\n\nconst int chipSelect = 5;\nconst String dataFolder = \"/data\";\nconst String logFileName = \"/io_time_log_single.txt\";\nconst int interval = 500; // 1분 간격\nunsigned long previousMillis = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n  if (!SD.begin(chipSelect)) {\n    Serial.println(\"카드 연결 실패 또는 없음\");\n    while (1);\n  }\n  if (!SD.exists(dataFolder)) {\n    SD.mkdir(dataFolder);\n  }\n}\n\nvoid logData() {\n  unsigned long start = millis();\n  String fileName = dataFolder + \"/data_\" + String(start) + \".txt\";\n  File dataFile = SD.open(fileName, FILE_WRITE);\n\n  if (dataFile) {\n    dataFile.println(\"더미 시계열 데이터\");\n    dataFile.close();\n  }\n\n  unsigned long end = millis();\n  File logFile = SD.open(logFileName, FILE_APPEND);\n  if (logFile) {\n    logFile.println(String(start) + \",\" + String(end - start));\n    logFile.close();\n  }\n}\n\nvoid loop() {\n  unsigned long currentMillis = millis();\n  if (currentMillis - previousMillis >= interval) {\n    previousMillis = currentMillis;\n    logData();\n  }\n}\n```\n\n### 프로그램 2: 서브폴더 전략 로깅\n\n```cpp\n#include <Arduino.h>\n#include <SD.h>\n#include <SPI.h>\nconst int chipSelect = 5;\nconst String dataFolder = \"/data\";\nconst String logFileName = \"/io_time_log_subfolder.txt\";\nconst int interval = 500; // 1분 간격\nunsigned long previousMillis = 0;\nvoid setup() {\n Serial.begin(115200);\n if (!SD.begin(chipSelect)) {\n Serial.println(\"카드 연결 실패 또는 없음\");\n while (1);\n }\n if (!SD.exists(dataFolder)) {\n SD.mkdir(dataFolder);\n }\n}\nvoid createDirectories(String path) {\n String subPath = \"\";\n int start = 0;\n int end = path.indexOf('/', start);\nwhile (end != -1) {\n subPath = path.substring(0, end);\n if (!SD.exists(subPath)) {\n SD.mkdir(subPath);\n }\n start = end + 1;\n end = path.indexOf('/', start);\n }\nif (!SD.exists(path)) {\n SD.mkdir(path);\n }\n}\nvoid logData() {\n unsigned long start = millis();\n \n // 현재 밀리초 단위 시간을 기준으로 서브폴더 생성\n unsigned long totalMinutes = start / 60000;\n unsigned long totalHours = totalMinutes / 60;\n unsigned long totalDays = totalHours / 24;\nString day = String(totalDays);\n String hour = String(totalHours % 24);\n String minute = String(totalMinutes % 60);\nString subFolder = dataFolder + \"/\" + day + \"/\" + hour + \"/\" + minute;\n createDirectories(subFolder);\nString fileName = subFolder + \"/data_\" + String(start) + \".txt\";\n \n start = millis();\n File dataFile = SD.open(fileName, FILE_WRITE);\n if (dataFile) {\n dataFile.println(\"더미 시계열 데이터\");\n dataFile.close();\n }\n unsigned long end = millis();\n \n File logFile = SD.open(logFileName, FILE_APPEND);\n if (logFile) {\n logFile.println(String(start) + \",\" + String(end - start));\n logFile.close();\n }\n}\nvoid loop() {\n unsigned long currentMillis = millis();\n if (currentMillis - previousMillis >= interval) {\n previousMillis = currentMillis;\n logData();\n }\n}\n```\n\n<div class=\"content-ad\"></div>\n\n# 결론\n\n파일을 하위 디렉터리로 구성하고, 바이너리 형식을 사용하며, 메모리 내 메타데이터를 유지하고, 쓰기와 읽기 모두 최적화된 파일 구조를 사용함으로써 ESP32 데이터 로거의 I/O 성능을 크게 향상시킬 수 있습니다. 이러한 전략은 많은 수의 파일을 관리하고 LoRa 네트워크를 통해 효율적인 데이터 검색 및 전송을 보장하는 데 도움이 될 것입니다.","ogImage":{"url":"/assets/img/2024-06-22-OptimizingSDCardIOPerformancewithESP32_0.png"},"coverImage":"/assets/img/2024-06-22-OptimizingSDCardIOPerformancewithESP32_0.png","tag":["Tech"],"readingTime":5},{"title":"레진 3D 프린팅 vs 필라멘트 프린팅 장단점 비교","description":"","date":"2024-06-22 18:41","slug":"2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting","content":"\n\n![이미지](/assets/img/2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting_0.png)\n\n# I. 소개:\n\n3D 프린팅은 부가 제조라고도 하는데, 연속적인 재료 층을 쌓아 세 가지 차원의 물체를 만드는 과정입니다. 프로토타이핑, 제품 개발부터 제조 및 예술 표현까지 다양한 작업에 널리 사용되고 있습니다.\n\n3D 프린팅에 사용되는 다양한 재료 중 일반적으로 사용되는 것은 플라스틱 필라멘트와 레진입니다. 필라멘트 프린팅은 녹은 플라스틱을 노즐을 통해 압출하여 단계별로 물체를 쌓는 과정을 포함합니다. 반면 레진 프린팅은 미세한 소재로 만들어진 광반응성 액체 레진을 UV 광선(일반적으로 레이저 또는 LED)을 사용하여 층별로 경화시키고 고체화합니다. 필라멘트와 레진 프린팅은 각각 고유한 장단점이 있으며, 본 문서에서 자세히 살펴보겠습니다.\n\n<div class=\"content-ad\"></div>\n\n# II. 수지 3D 프린팅의 장점:\n\n수지 3D 프린팅의 주요 이점 중 하나는 높은 정도의 세부 사항과 섬세함을 달성할 수 있다는 것입니다. 수지 프린팅은 빔 광선을 사용하여 물질을 단계별로 경화하고 고체화하는데, 이는 필라멘트 프린팅으로는 세밀하거나 얻기 어려운 매우 섬세하고 정확한 특징을 만들기에 적합합니다. 이는 보석이나 치과 임플란트와 같이 정교하고 놀랍도록 섬세한 물체를 만드는 데 수지 프린팅이 이상적이라는 것을 의미합니다.\n\n수지 프린팅의 또다른 장점은 사용 가능한 다양한 소재의 범위입니다. 3D 프린팅에 사용할 수 있는 다양한 종류의 수지가 있으며, 각각 고유한 특성과 응용 분야를 갖고 있습니다. 예를 들어, 의료 또는 치과 수술용으로 특별히 공식화된 수지뿐만 아니라, 다양한 금속이나 세라믹 속성을 모방한 수지도 있습니다. 이를 통해 특정 요구 사항 및 운용에 가장 적합한 소재를 선택할 수 있습니다.\n\n세부 사항과 정밀성 뿐만 아니라, 수지 프린트는 강하고 내구성이 뛰어난 것으로도 알려져 있습니다. 수지가 단계별로 경화되고 고체화되므로 층 간 강력한 결합을 유발하고 파괴나 왜곡에 저항하는 프린트물을 만들어낼 수 있습니다. 이는 응력이나 마모에 시달리는 기능적인 부품이나 물체를 만드는 데 좋은 선택이 되도록 합니다.\n\n<div class=\"content-ad\"></div>\n\n# III. Resin 3D 프린팅의 단점:\n\n레진 3D 프린팅의 주요 단점 중 하나는 비용입니다. 레진 프린터는 필라멘트 프린터보다 가격이 더 비싸며, 레진 재료 자체도 일반적으로 필라멘트보다 비싸다. 이는 예산이 촉박한 사람들에게는 더 어렵게 만들 수 있습니다.\n\n비용 외에도, 레진 프린팅은 전문 장비와 레진 프린터가 필요합니다. 이 프린터는 일반적으로 필라멘트 프린터보다 더 복잡하고 유지보수가 더 많이 필요하기 때문에 일부 사용자에게는 장애물이 될 수 있습니다.\n\n레진 프린팅의 또 다른 묵시적 문제는 프린트물이 인쇄 과정 중에 왜곡되거나 수축하는 경향이 있다는 것입니다. 이는 사용되는 레진의 종류, 프린트가 이루어지는 환경 또는 물체의 디자인과 같은 여러 요인에 의해 발생할 수 있습니다. 왜곡과 수축은 변형되거나 불균일한 프린트물로 이어질 수 있으며, 원하는 결과를 얻기 위해 추가 후처리 또는 보조 구조물이 필요할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# IV. 필라멘트 프린팅의 장점:\n\n필라멘트 3D 프린팅의 주요 장점 중 하나는 널리 보급되어 비용 효율적이라는 것입니다. 필라멘트는 레진보다 훨씬 일반적이며 비용도 낮아 많은 사용자에게 더 접근하기 쉬운 옵션이 됩니다. 필라멘트 프린터는 또한 일반적으로 레진 프린터보다 더 저렴하여 3D 프린팅을 시작하는 개인 또는 소기업에게 더 쉽게 접근할 수 있습니다.\n\n필라멘트 프린팅의 또 다른 이점은 사용할 수 있는 프린터의 종류에 대한 유연성입니다. 필라멘트 프린터는 다양한 크기와 가격대로 제공되어, 특정 요구 사항과 예산에 맞는 프린터를 쉽게 찾을 수 있습니다. 또한, 필라멘트는 FDM(융착 퓨전 성형), SLA(스테레오리소그래피) 및 기타 다양한 유형의 프린터와 함께 사용할 수 있습니다.\n\n필라멘트 프린팅은 사용하기 쉽고 사용자 정의하기 쉽다는 점으로도 알려져 있습니다. 필라멘트는 프린터에서 쉽게 로드하고 언로드할 수 있으며, 다양한 색상, 속성 및 응용 프로그램을 지원하는 다양한 종류의 필라멘트가 있습니다. 이를 통해 출력물을 사용자 정의하고 다양한 제품을 생산하는 것이 쉬워집니다.\n\n<div class=\"content-ad\"></div>\n\n# V. 필라멘트 프린팅의 단점:\n\n필라멘트 프린팅의 주요 제한 사항 중 하나는 수지 프린팅과 비교하여 상세함과 섬세함의 수준이 낮다는 것입니다. 필라멘트 프린팅은 녹은 플라스틱을 노즐을 통해 내출하는 과정이 포함되기 때문에, 수지 프린팅만큼 미세한 세부 사항과 정확도를 달성하기에는 적합하지 않습니다. 이는 상세하거나 정확한 출력물이 필요한 사람들에게는 단점일 수 있습니다.\n\n상세함과 정확도가 낮다는 점 외에, 필라멘트 프린팅은 수지 프린팅과 비교하여 사용 가능한 재료 범위도 더 한정적입니다. 필라멘트의 종류는 다양하지만, 일반적으로 수지 프린팅에서 사용할 수 있는 수지와 같이 다양하거나 특수화된 것들은 아닙니다. 이는 출력물로부터 특정한 속성이나 기능이 필요한 사람들에게 제한이 될 수 있습니다.\n\n필라멘트 프린팅은 또한 출력물 사이에 얇은 플라스틱 줄이 남아있는 스트링핑(stringing)과 출력물에 갭이나 구멍이 남는 등의 결함에 취약합니다. 이러한 결함은 필라멘트의 품질, 프린터의 보정, 또는 출력하려는 제품의 설계와 같은 다양한 요소로 인해 발생할 수 있습니다. 프린터를 신중하게 설정하고 조정함으로써 이러한 결함을 최소화하거나 제거할 수는 있지만, 일부 사용자에게는 여전히 답답함을 줄 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# VI. 결론:\n\n결론적으로, 수지 인쇄와 필라멘트 인쇄는 각자 고유한 장단점을 갖고 있습니다. 수지 인쇄는 높은 정밀도와 정확성, 다양한 소재 선택, 강력하고 내구성 있는 출력물을 제공하지만, 비용이 높고 기술적인 장비가 필요할 수 있습니다. 반면에 필라멘트 인쇄는 보편적으로 사용 가능하고 가격이 덜 비싸며 다양한 프린터와 함께 사용할 수 있으며 쉽고 사용자 정의가 가능하지만, 낮은 정밀도와 정확성 및 제한된 소재 범위가 있습니다.\n\n수지 인쇄와 필라멘트 인쇄 중 어느 것을 선택할지 결정할 때, 본인의 특정 요구사항과 예산을 고려하는 것이 중요합니다. 그러나, 만약 상세하거나 정확한 출력물이 필요하고 필요한 장비와 소재에 투자할 용의가 있다면, 수지 인쇄가 더 나은 선택일 수 있습니다. 반면에, 예산이 제약되어 있거나 최고 수준의 세부 정보가 필요하지 않다면, 필라멘트 인쇄가 비용 효율적인 선택일 수 있습니다. 최종적으로, 여러분에게 가장 적합한 선택은 본인의 구체적인 목표와 상황에 달려 있을 것입니다.","ogImage":{"url":"/assets/img/2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting_0.png"},"coverImage":"/assets/img/2024-06-22-TheProsandConsofResin3DPrintingvsFilamentPrinting_0.png","tag":["Tech"],"readingTime":4},{"title":"안의 미스터리 4부","description":"","date":"2024-06-22 18:40","slug":"2024-06-22-MysteriesofAnPart4","content":"\n\n시리즈 \"Mysteries of An\"에 오신 걸 환영합니다. 각각의 디지털 아트 작품은 알 수 없는 신비한 세계를 엿보게 해주는 창을 엽니다. 신비한 대기와 매혹적인 풍경을 가진 행성 An은 이 시리즈의 영감의 원천으로서의 역할을 합니다.\n\n\"Mysteries of An\" 에서의 각 작품은 다른 작품들과 함께 일관된 흥미로운 이야기를 이루는 거대한 캔버스의 한 부분입니다. 이 그림 속에서 Anomalites들은 생명을 얻어 고대 이야기와 신비한 전설을 전합니다. 마법의 생물, 환상적인 풍경, 풀리지 않은 미스터리가 펼쳐지며 당신을 위해 마법과 기술이 조화롭게 공존하는 세계에 몰입시킵니다.\n\n각 작품은 행성 An의 탐험되지 않은 구석으로 이끄는 세부사항으로 가득차며, 그 안에 숨겨진 진리와 비밀을 발견하게 합니다. 이 시리즈에는 완성된 그림 뿐만 아니라 스케치, 초고, 그리고 미래 작품의 개별 요소도 포함돼 있어 창조와 발견의 과정을 목격할 수 있게 해줍니다. \"Mysteries of An\"을 탐험하고 디지털 캔버스마다 감춰진 마법을 발견해보고, 판타지와 경이로운 세계로 빠져들어 보세요.\n\n이 지도 상의 가이드 마크를 따라가면 여행자들은 행성 An의 숨겨진 구석을 탐험할 수 있고, 놀라운 발견과 마법적인 모험으로 가득한 곳을 발견할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n여기에 들러주셔서 너무 고마워요! 제 작품 세상에 대해 알아가셨군요!\n\n더 많은 정보는 제 웹사이트나 트위터 / 워프캐스트에서 찾아보실 수 있어요.\n\n오늘 하루도 행복하길 바라요!","ogImage":{"url":"/assets/img/2024-06-22-MysteriesofAnPart4_0.png"},"coverImage":"/assets/img/2024-06-22-MysteriesofAnPart4_0.png","tag":["Tech"],"readingTime":1},{"title":"오픈소스 IC 셀을 3D 프린터로 출력하는 방법 간단 가이드","description":"","date":"2024-06-22 18:39","slug":"2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide","content":"\n\n![이미지](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_0.png)\n\n## 아이디어와 어떤 배경:\n\n집적 회로(IC)와 오픈 소스가 한 문장에? 수십 년 동안 칩 디자인은 라이선스 수수료, 사용 요금, 비밀 유지 계약(NDA) 및 생산에 매우 높은 초기 재정적 장벽을 포함하는 폐쇄 도구의 영역이었습니다. 이것은 천천히 오픈 소스 도구 및 공유 생산 비용 방향으로 바뀌고 있지만, 여전히 오픈 소스 칩 디자인(오픈 소스 EDA)의 초기에 있습니다.\n\nGoogle과 Skywater Technology가 발표한 오픈 소스 프로세스 디자인 키트(PDK) \"SKY130\" 이후로 모든 사람이 실제 마이크로칩을 생산하기 위한 \"실제 표준 셀\"들을 더 깊이 살펴볼 수 있게 되었습니다. 여러분은 어떠한 NDA를 위반하는 걱정없이 그들에 대해 이야기하고 쓸 수 있습니다. 우리는 심지어 이 셀들을 3D 프린터로 출력할 수도 있습니다. 그리고 저는 그렇게 했습니다.\n\n<div class=\"content-ad\"></div>\n\n내가 인쇄한 3D 세포의 사진을 몇 개 트윗한 후 How-to 가이드를 작성하라는 요청을 받았어요. 이 안내서는 몇 단계로 나뉜 대략적인 계획으로, \"혼자서 아주 쉽게 5분 안에 따라 할 수 있는\" 가이드는 아니니까요. 이 점 주의하세요! 3D 프린터에 답답함을 느낄 수도 있고, 성공하기 위해 실리콘 칩의 구조에 대해 배워야 할 수도 있습니다.\n\n그리고, 제가 한 것처럼 손가락을 실수로 초고리액으로 붙이지 말아 주세요.\n\n모든 경고에도 불구하고: 즐기세요.\n\n## 테스트 완료:\n\n<div class=\"content-ad\"></div>\n\n- 노트북 우분투 22.04\n- Ultimaker S5 + 자재 창고\n\n# 1: SKY130 OpenPDK에서 셀 선택하기\n\nSKY130 PDK 문서를 살펴보세요, 특히 7개의 SKY130 셀 라이브러리 개요를 살펴보고 라이브러리 중 하나를 선택하세요. 이 안내서에서는 고밀도 라이브러리 sky130_fd_sc_hd를 선택하겠습니다.\n\n인쇄할 표준 셀을 결정하세요. 쉬운 셀부터 시작하는 것이 좋습니다. 예를 들어 인버터입니다. 간단한 CMOS 인버터 셀은 두 개의 트랜지스터를 포함하고 다음과 같이 보입니다:\n\n<div class=\"content-ad\"></div>\n\n\n![image](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_1.png)\n\nPDKs Github Repository에서 선택한 셀의 .gds 파일을 다운로드하세요. 단일 인버터의 경우 sky130_fd_sc_hd__inv_1.gds 파일입니다:\n\n# 2. GDS3D를 사용하여 셀의 .gds 파일 검토\n\n셀의 .gds 파일을 조사 가능한 3D 렌더링으로 보려면 Viewer 소프트웨어가 필요합니다. trilomix의 GDS3D를 사용하는 것을 제안합니다:\n\n\n<div class=\"content-ad\"></div>\n\n저장소를 다운로드하거나 복제하세요. /linux 폴더에는 미리 컴파일된 우분투 버전의 GDS3D가 있습니다. 실행 가능하게 만드세요:\n\n```js\nchmod +x linux/GDS3D\n```\n\nSKY130 셀과 함께 GDS3D를 실행하려면 프로세스 정의 파일이 필요합니다. 이를 위해 /techfiles 폴더 내의 sky130.txt 파일을 사용하세요. 이들을 결합하여 아래와 같은 콘솔 시작 명령어를 얻을 수 있습니다:\n\n```js\n./linux/GDS3D -p techfiles/sky130.txt -i <gds-파일_경로>\n```\n\n<div class=\"content-ad\"></div>\n\nGDS3D 창에서 인버터 셀을 3D 모델로 표시해야 합니다. 마우스로 이를 이동, 회전 및 확대할 수 있습니다. 이는 위의 3D 프린트 사진과 동일한 셀 (sky130_fd_sc_hd__inv_1.gds)입니다.\n\n<img src=\"/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_2.png\" />\n\n이제 SKY130 오픈 소스 PDK에서 표준 셀을 고르고 GDS3D에서 볼 수 있는 방법을 알게 되었습니다. 혹시 이 가이드를 계속하기 전에 화면에서 몇 가지 더 많은 셀들 (AND 게이트, XOR, 더하기기, 멀티플렉서 등)을 둘러보고 싶을 수도 있습니다.\n\n# 3. .gds를 .stl로 변환하기: gdsiistl\n\n<div class=\"content-ad\"></div>\n\n3D 프린팅을 위해서 GDS 파일을 프린트 가능한 .stl 파일 세트로 변환해야 합니다. mbalestrini가 SKY130 PDK용으로 적용한 gdsiistl 버전이 있습니다:\n\n저장소를 다운로드하거나 복제하여 README를 확인하여 gdsiistl 사용 방법을 참조하세요. 이는 Python으로 작성되어 있어 실행하기 어렵지 않을 것입니다. 저는 다음과 같이 진행했습니다 (python 3.10):\n\n```js\npip install numpy\npip install gdspy\npip install numpy-stl\npip install triangle\npython gdsiistl.py <path_to_gds_file>\n```\n\ngdsiistl을 실행한 결과는 프로세스 레이어의 일부를 이름에 접미사로 가진 .stl 파일 세트가 생성됩니다 ( _diff, _li1, _licon, _mcon, _met1, _nwell 및 _poly).\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_3.png\" />\n\n이 .stl 파일들은 이미 3D 프린트가 가능합니다. 하지만 프린트 버튼을 누르기 전에 세포의 3D 모델을 인쇄하고 조립하는 방법을 탐색해보고 싶을 것입니다.\n\n# 4: .stl 파일 쌓아서 인쇄하기\n\n여기서부터는 좋아하는 소프트웨어를 실행하여 .stl 파일을 보고, 편집하고, 슬라이스하고 인쇄해야 합니다. 저는 Tinkercad와 Cuda의 조합을 사용합니다. 하지만 이는 완전히 당신과 당신의 3D 프린터에 달렸습니다. 오픈 소스 솔루션을 선호할 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n여기는 방금 .stl 파일로 받은 레이어들과 실제 마이크로칩에 어떻게 \"쌓이는지\" 보여주는 다이어그램이 있습니다. 이 다이어그램의 출처는 SKY 130 PDK 문서입니다.\n\n![다이어그램](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_4.png)\n\n그리고 여기는 위의 다이어그램처럼 쌓인 .stl 파일들의 분해된 렌더링입니다:\n\n![렌더링](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_5.png)\n\n<div class=\"content-ad\"></div>\n\n선택을 해야 할 시점이 도래했습니다. 세포의 3D 모델에 대한 다음 단계는 실제 칩 생산 과정과 프린터의 출력 가능성 또는 제한 사항과의 정확성 등급에 달려 있습니다. 제가 그림과 함께 다음 문제를 설명하겠습니다.\n\n## 라이콘 레이어:\n\n.stl 렌더링의 라이콘 레이어를 GDS3D 렌더링과 비교하십시오. 그런 다음 내 모델에서 라이콘 레이어를 어떻게 출력했는지 살펴보십시오 (위의 사진 참조). 라이콘 레이어는 적어도 li1, poly 및 확산을 함께 연결합니다. 어떻게 출력할지 결정해야 합니다. 제 의견으로는 라이콘이 poly나 확산의 하단에서 나오지 않아야 하며(li1 레이어와만 연결), 두 레이어를 위쪽으로만 연결해야 합니다.\n\n![이미지](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_6.png)\n\n<div class=\"content-ad\"></div>\n\n## 부족한 기판층:\n\n.stl 파일 세트에 기판층이 포함되어 있지 않습니다. GDS3D에서는 큰 검은 상자로 렌더링됩니다. 내 세포 모델에서는 AND-Gate의 최상단 사진처럼 큰 흰 판을 출력합니다.\n\n![이미지](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_7.png)\n\n## 확산을 nwell로 하위 기판에 포함하시겠습니까?\n\n<div class=\"content-ad\"></div>\n\n세 낮은 층을 서로 쌓지 않고 내포된 구조로 만들었어요: 확산이 엔웰(nwell)로 스며들어 p-기판으로 들어가요.\n\n![이미지](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_8.png)\n\n내 모델에서는 확산을 엔웰로 내포시키고 그것을 기판 위에 쌓습니다.\n\n![이미지](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_9.png)\n\n<div class=\"content-ad\"></div>\n\n## 하나 또는 두 개의 프린트 헤드? 색상?\n\n프린터에 따라 한 번의 인쇄량으로 두 개의 층을 함께 출력할 수 있습니다. 두 개의 헤드와 따라서 두 색상으로 인쇄할 경우 층을 다음과 같이 병합했습니다:\n\n![image](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_10.png)\n\n각 인쇄 작업에는 두 개 이상의 색상이 없으며 서포트 채움이 없습니다. 층을 인쇄한 후에는 슈퍼 접착제를 사용하여 단일 모델로 결합합니다.\n\n<div class=\"content-ad\"></div>\n\n## 입력 및 출력 레이블:\n\n다른 프린트 작업으로 인해, 입력 및 출력, 전원 및 접지 레일에 대한 레이블이 많이 만들어졌어요.\n\n![이미지](/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_11.png)\n\n# 5: 조립\n\n<div class=\"content-ad\"></div>\n\n첫 번째: 손가락을 서로 붙이지 마세요!\n\n두 번째: AND 셀 조립의 단계별 사진 몇 장\n\n지금까지는 가이드가 이 만큼이에요. 즐겁게 만들고 인쇄된 셀로 행운을 빕니다. 만약 인쇄했다면 저에게 알려주세요 (트위터?!)!\n\n# 이제는...\n\n<div class=\"content-ad\"></div>\n\n- ...모델을 축척에 맞추어 출력하는 중입니다. 그리고 그 축척은 무엇인가요?\n- ... `SKY130 PDK에 200개 더 레이어가 있습니다.\n- ... 셀이 실리콘에서 실제로 어떻게 보이는지.\n- ... 내가 잊거나 그냥 모르는 모든 것들 (많습니다!).\n\n## 크레딧 (완벽하지는 않지만 시작):\n\n매튜 벤(Matthew Venn)과 그의 환상적인 제로에서 ASIC으로 코스.\n\nHochschule RheinMain (Ultimaker S5)\n\n<div class=\"content-ad\"></div>\n\n스테펜 라이테가 이런 미친 짓을 할 수 있도록 도와줘서 고마워요.","ogImage":{"url":"/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_0.png"},"coverImage":"/assets/img/2024-06-22-Open-sourceICcellsas3DprintsAroughhow-toguide_0.png","tag":["Tech"],"readingTime":6},{"title":"3D 모델링의 7가지 주요 용도","description":"","date":"2024-06-22 18:37","slug":"2024-06-22-Whatis3Dmodelingusedfor","content":"\n\n3D 모델은 영화, 게임, 건축, 제품 디자인 등에서 사용됩니다. 엔터테인먼트 산업과 가상 현실에서 3D 모델을 예상할 수 있지만, 많은 다른 산업에서도 3D 모델이 사용된다는 사실에 놀라실지도 모릅니다.\n\n![이미지](/assets/img/2024-06-22-Whatis3Dmodelingusedfor_0.png)\n\n# 3D 모델링이 오늘날 어디에 사용되는지\n\n다음은 일반적인 3D 모델링 예시입니다. 이러한 모델들은 때로는 너무 사실적하여 처음에 렌더링된 이미지를 보고 있다는 것을 알아차리기 어려울 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n3D 모델링 Fiverr에서 전문 프리랜서를 고용해보세요!\n\nWorkpaa에서 데이터 분석가 전문 프리랜서를 고용하세요!\n\n# 1. 엔터테인먼트 및 미디어\n\n3D 모델링은 VFX, 비디오 게임, 영화 및 TV에서 광범위하게 활용됩니다. 3D 소프트웨어를 사용하여 완전히 만들어진 제작물을 자주 볼 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 2. 건축 및 부동산\n\n건축가와 디자이너들은 건물, 실내 및 풍경의 상세한 가상 표현을 만들기 위해 3D 모델링을 활용합니다. 이러한 모델은 디자이너의 비전을 잠재 투자자, 고객 및 대중에게 전달하는 데 매우 유용합니다.\n\n# 3. 제품 디자인과 제조\n\n3D 모델링은 프로토타입을 개발하고 제품 아이디어를 시각화하며 생산 전 기능을 시뮬레이션하기 위한 효율적이고 환경 친화적인 방법입니다. 디자이너들은 제품이 확정되기 전에 아이디어를 정제하고 무수히 많은 반복을 만들 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 4. 자동차 및 항공우주 산업\n\n3D 모델링은 차량 및 그 구성 요소의 설계 및 시험, 그리고 광고 및 마케팅에서 사용됩니다. 많은 자동차 및 항공기 광고에는 거의 진짜 카메라 영상이 아닌 것으로 구별하기 거의 불가능한 3D 생성 이미지가 특징으로 나타납니다. 3D는 현실적인 시뮬레이션을 가능하게 하여 아이디어나 차량을 건설하기 전에 테스트하는 데 사용될 수 있습니다.\n\n3D 모델링 전문가를 고용하세요 on Fiverr\n\n데이터 분석가 전문가를 고용하세요 on Workpaa\n\n<div class=\"content-ad\"></div>\n\n# 5. 의료 및 보건\n\n의료 영상 및 수술 계획에 3D 모델링이 활용됩니다. 장기, 뼈 및 조직의 정확한 재현은 진단, 치료 계획, 의학 연구를 지원하는 데 사용될 수 있습니다.\n\n# 6. 가상 현실 (VR) 및 증강 현실 (AR)\n\n3D 모델링은 몰입형 경험을 만드는 데 중요합니다. VR 및 AR은 여러 산업에서 활용되며 거의 모든 분야에서 사용될 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 7. 교육 및 훈련\n\n3D 모델링은 생물학, 지리, 심지어 역사와 같은 다양한 주제의 개념을 가르치는 데 교육적 환경에서 사용됩니다. 이를 통해 학생과 전문가들은 안전하고 통제된 환경에서 가상 모델과 시뮬레이션과 상호 작용할 수 있습니다. 이의 훌륭한 예로 비행 시뮬레이터에서 비행하는 비행사들이 있습니다.\n\n![Image 1](/assets/img/2024-06-22-Whatis3Dmodelingusedfor_1.png)\n\n![Image 2](/assets/img/2024-06-22-Whatis3Dmodelingusedfor_2.png)\n\n<div class=\"content-ad\"></div>\n\n# 한눈에 보는 3D 모델링 과정.\n\n이 단계들은 3D 모델링 과정의 일반적인 개요를 제공합니다. 실제 사용하는 워크플로우는 소프트웨어나 작가의 선호도, 프로젝트의 특정 요구 사항에 따라 다를 수 있습니다. 함께 알아보겠습니다:\n\n# 개념화\n\n아이디어 떠올리기에서 시작하여 소프트웨어로 직접 들어가서 기본 모양을 사용하여 아이디어를 블록 처리하는 것이든, 이 단계에서 시간을 보내는 것은 중요합니다. 아이디어에 너무 많은 시간을 들이기 전에 해당 아이디어에 헌신할 수 있는지 확인하는 것이 매우 유용합니다.\n\n<div class=\"content-ad\"></div>\n\n3D 모델링을 위해 전문 프리랜서를 고용하세요.\n\n**Fiverr**에서 전문 프리랜서를 고용하세요.\n\n**Workpaa**에서 3D 모델링 전문가를 고용하세요.\n\n# 모델링\n\n이 단계에서는 선택한 소프트웨어를 사용하여 실제 3D 모델링 작업이 진행됩니다. 폴리곤 모델링을 사용하는 경우, 버텍스, 엣지, 그리고 면을 조작하여 면체를 구축해야 합니다. 또 다른 접근 방식은 Substance 3D Modeler와 같은 소프트웨어를 사용하는 것인데, 이를 통해 다양한 도구와 조각 방법을 사용하여 디지털 클레이를 정확하게 조각할 수 있습니다.\n\n<div class=\"content-ad\"></div>\n\n# 텍스처링\n\n모델의 형태가 완성되면, 텍스처와 재질이 모델 표면에 적용되어 현실적이거나 스타일화된 외관을 부여합니다. 텍스처에는 색상, 패턴, 그리고 돌기와 반사 같은 표면 세부 사항이 포함될 수 있습니다. 이들은 손으로 그림을 그릴 수도 있고, 절차적으로 생성되거나 고화질 사진에서 유래될 수 있습니다.\n\n# 렌더링 & 처리\n\n모델이 완성되고 텍스처가 적용되면, 3D 모델링 과정의 마지막 단계는 조립 및 렌더링입니다. 렌더링은 조명, 음영 및 다른 시각 효과를 고려한 고품질 이미지 또는 시퀀스 애니메이션을 생성하는 것을 포함합니다. 이는 계산적으로 매우 요구되는 프로세스일 수 있습니다. 후처리는 렌더 이후에 최종 출력을 더욱 향상시키기 위해 사용될 수도 있습니다.\n\n<div class=\"content-ad\"></div>\n\n<img src=\"/assets/img/2024-06-22-Whatis3Dmodelingusedfor_3.png\" />\n\n# 가능한 것을 확인해보세요.\n\n3D 모델링의 모든 단계가 결합되면 예술가와 디자이너들은 놀라운 작품을 만들어낼 수 있습니다. 다양한 산업에서 3D 모델링이 어떤 일을 할 수 있는지 보여주는 현실 세계의 예시들을 확인해보세요.\n\n<img src=\"/assets/img/2024-06-22-Whatis3Dmodelingusedfor_4.png\" />\n\n<div class=\"content-ad\"></div>\n\n프리랜서 전문가를 고용해보세요. Fiverr에서 3D 모델링을, Workpaa에서 3D 모델링을 해보세요.\n\n# 1. 패션.\n\nHugo Boss가 3D를 사용하여 프로세스를 향상하는 방법을 확인해보세요.\n\n<div class=\"content-ad\"></div>\n\n# 2. 제품 디자인.\n\nPuma와 INDG가 Substance 3D 앱과 AR을 활용하여 놀라운 신발을 디자인하는 방법을 살펴보세요.\n\n# 3. 엔터테인먼트.\n\n아름다운 프로젝트 'End of Summer'는 Adobe의 재능 있는 아티스트들이 주로 Substance 3D 도구를 사용하여 어떤 것이 가능한지 보여주는 작품입니다.\n\n<div class=\"content-ad\"></div>\n\n# 3D 모델링에 대한 팁.\n\n3D 모델링을 진행할 때 고려해야 할 몇 가지 팁입니다:\n\n# 1. 기본을 마스터하세요.\n\n기본 3D 모델링 원칙에 견고한 기반을 다지고 소프트웨어에서 제공되는 도구를 효율적으로 사용하는 법을 배우는 것은 필수적입니다. 모델이 더 깔끔해지고 시간도 더 효과적으로 사용할 수 있게 될 것입니다.\n\n<div class=\"content-ad\"></div>\n\n# 2. 키보드 단축키와 워크플로우 최적화에 대해 배워보세요.\n\n3D 소프트웨어는 매우 복잡할 수 있습니다. 창조자들에게 사용 가능한 많은 도구와 방법이 있기 때문에, 단축키에 익숙해지는 것은 창작에 있어서 삶의 질을 크게 향상시킬 것입니다. 이를 통해 작업 흐름이 빨라지고 생산성이 향상되며, 전체 과정이 더 효율적으로 느껴질 것입니다.\n\n# 3. 참조 자료 활용하기.\n\n참조 자료를 사용하는 것은 프로젝트를 계획하고 시각화하는 데 도움을 주는 좋은 방법일뿐만 아니라, 3D 모델이 현실적이고 정확한 비율, 모양 및 디테일을 갖추도록 보장하는 데도 도움이 됩니다. 참조 자료는 견고한 기반을 제공하고 시각적 충실성을 유지하는 데 도움을 줍니다. 창의성을 자극하고 아이디어 생성을 장려하기 위해 여러 다양한 참조 자료로 이루어진 모드 보드를 작성하는 것도 고려해보세요.\n\n<div class=\"content-ad\"></div>\n\n# 4. 다양한 기술들을 탐험해보세요.\n\n좋은 3D 아티스트는 끊임없이 배우고 있습니다. 3D 기술을 계속 연습하고 새로운 도구와 기술을 배우면 예술가로서와 디자이너로서成長할 수 있습니다. 포리모델링이나 조각과 같은 다양한 기술과 소프트웨어를 탐험하여 더 다양한 기술을 개발하는 데 도움이 될 것입니다.\n\n당신의 3D 모델링을 위해 전문 프리랜서를 고용하세요. Fiverr에서\n\n당신의 3D 모델링을 위해 전문 프리랜서를 고용하세요. Workpaa에서\n\n<div class=\"content-ad\"></div>\n\n# 콘텐츠를 얻고 영감을 얻고 창의성을 발휘하세요.\n\n![이미지](/assets/img/2024-06-22-Whatis3Dmodelingusedfor_5.png)\n\n3D 제작을 시작하고 싶으시거나 접근 방식을 새롭게 하고 싶으시다면 Adobe Substance 3D를 소개해 드립니다. 이 강력한 도구 세트를 통해 익숙한 Adobe 작업 환경을 경험할 수 있으며, 모델링, 질감 입히기, 소재 생성, 무대 설정 및 렌더링 등 3D 프로세스의 여러 측면을 더욱 효율적으로 처리할 수 있는 강력한 도구를 사용할 수 있습니다. Substance 3D의 가능성을 발견하고 오늘부터 모든 3D 앱의 30일 무료 평가판을 이용하여 3D 프로젝트에서 창의성을 높이세요.\n\n# 자주 묻는 질문\n\n<div class=\"content-ad\"></div>\n\n# 3D 모델링은 무엇에 사용되나요?\n\n# 3D 모델의 예시는 무엇이 있나요?\n\n# 3D 모델링의 다양한 종류는 무엇이 있나요?","ogImage":{"url":"/assets/img/2024-06-22-Whatis3Dmodelingusedfor_0.png"},"coverImage":"/assets/img/2024-06-22-Whatis3Dmodelingusedfor_0.png","tag":["Tech"],"readingTime":5}],"page":"33","totalPageCount":112,"totalPageGroupCount":6,"lastPageGroup":20,"currentPageGroup":1},"__N_SSG":true}