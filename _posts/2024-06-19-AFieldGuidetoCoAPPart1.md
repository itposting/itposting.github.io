---
title: "CoAP에 관한 필드 가이드 - 제1부"
description: ""
coverImage: "/assets/img/2024-06-19-AFieldGuidetoCoAPPart1_0.png"
date: 2024-06-19 16:55
ogImage: 
  url: /assets/img/2024-06-19-AFieldGuidetoCoAPPart1_0.png
tag: Tech
originalTitle: "A Field Guide to CoAP — Part 1"
link: "https://medium.com/@jonathanberi/a-field-guide-to-coap-part-1-75576d3c768b"
---


IoT를 시작할 때 알았더라면 좋았을 제한된 응용 프로그램 프로토콜(CoAP)과 관련된 모든 것

![이미지](/assets/img/2024-06-19-AFieldGuidetoCoAPPart1_0.png)

나는 2010년에 IoT 세계로 처음 발을 디뀌었습니다. 전력 소비를 모니터링하고 저전력 네트워크를 통신하는 스마트 콘센트를 만들고 싶은 아이디어가 있었습니다. 문제는 네트워킹, 무선, 실시간 임베디드 시스템, 프로토콜 등에 대해 거의 아무것도 몰랐다는 점이었습니다. 그러나 그 아이디어로 인해 IoT 분야에서의 경력이 시작되었습니다. 저의 야망은 상대적으로 새로운 IoT 기술과 표준을 연구하도록 이끔으로, 저는 저전력 통신과 Sensinode(후에 Arm에 인수)의 작업에 특히 관심이 있었습니다. 그들이 개척한 기술 중 하나가 CoAP이었고, 이 기술은 내 프로젝트에 완벽해 보였습니다.

많은 개발자들은 이 유연한 도구를 잘 모를 수 있습니다. HTTP나 MQTT와 같은 프로토콜에 대해 들어본 적이 있을 수 있지만, CoAP의 인식은 덜 흔한 것 같습니다. 종종 "왜 CoAP를 사용해야 하는가?" 또는 "MQTT 대신 x에 사용하면 안 되는 이유를 설명해줘"라는 질문을 받곤 합니다. 왜 일부 프로토콜이 다른 것보다 더 알려진지는 잘 모르지만, 이 게시물을 통해 그것을 바로잡는 것이 제 목표 중 하나입니다.

<div class="content-ad"></div>

# CoAP에 대해

CoAP은 제한된 응용 프로그램 프로토콜로 공식적으로 RFC 7252로 알려져있습니다. IETF에서 Constrained Resource Environments (CoRE) Working Group에 의해 개발된 전송 프로토콜입니다. CoAP은 다음 세 가지 목표를 가지고 설계되었습니다:

- 제한된 환경에 적합합니다
- 이해하기 쉽습니다
- 구현하기 쉽습니다

RFC 7228에서 "제한된"이 더 자세하게 정의되어 있지만 간략하게 언급하면:

<div class="content-ad"></div>

- 제한된 메모리, 저장 공간 및 계산 능력 (100KB & 10MHz)
- 배터리 전원
- 낮은 대역폭 (Kbps - 킬로비트/초)
- 보안은 중요하지만, 이완된 장치에 특화되어 있습니다.

그리고 우리가 보게 될 것처럼, CoAP의 많은 기능들은 이러한 제약 조건을 충족시키기 위해 고의적으로 설계되었습니다.

둘째, RFC 7252는 다이어그램이 포함된 약 100페이지의 짧은 문서로 매우 읽기 쉽습니다. 점심 시간에 한 번 읽을 수 있을 만큼 간단하며 자신의 커피를 다시 타는 시간도 충분히 남을 것입니다.

CoAP의 마지막 목표는 구현하기 쉬움입니다. 디바이스 및 서버를 위한 libcoap 및 californium 라이브러리를 포함하여 사실상 디바이스 및 서버를 위한 참조 구현이 거의 모든 디바이스 및 클라우드 프로그래밍 언어에서 구현되어 있습니다. 그러나 UDP를 사용하고 페이로드 크기를 절약하기 위해 콤팩트한 메시지 형식을 사용하는 등 제한된 환경에서 구현하기 쉽게 설계된 프로토콜 내에 특정 설계 특징이 있습니다. 그러나 이러한 세부 사항은 곧 다룰 것입니다.

<div class="content-ad"></div>

# CoAP 기본 사항

CoAP은 HTTP의 요청/응답, 클라이언트/서버 모델을 따른 것입니다. 이것이 곧 초보자들에게 쉽게 이해할 수 있게 만들어주는 요소 중 하나입니다. 실제로 CoAP는 익숙한 GET, POST, PUT, DELETE 동사를 지원하기 때문에 실제 HTTP와 상호 운용할 때 유용합니다. 이것은 RFC 8075에서 논의된 내용입니다.

사실, RFC 8075를 CoAP의 확장성에 대한 수업 자료로 사용합시다. 저는 CoAP을 단일 "개체"로 계속 언급하는데, 사실상 RFC 7252를 기반으로 한 수십 가지의 추가 사양이 있어 CoAP로 수행할 수 있는 작업을 향상시킵니다. 그러나 가장 중요한 점은 이러한 사양이 순수주의적인 관점에서는 모두 선택 사항으로 간주된다는 것입니다. 이것이 그것들의 다이어그램입니다:

앞으로 RFC 7252의 모든 것을 "기본"으로 간주하고, 다른 사양의 일부 공통 기능을 "기본++"으로 간주하고, 나머지 모든 것을 "고급"으로 간주할 것입니다. 걱정하지 마세요 - 우리는 곧 고급 내용에 대해 다뤄볼 것입니다.

<div class="content-ad"></div>

다음은 CoAP 사용자로서 알아야 할 가장 유용한 정보입니다:

## 메시징 모델

CoAP는 더 넓은 인터넷과 HTTP와 같이 클라이언트/서버 메시징 모델을 따릅니다. 이는 센서와 데이터베이스 사이에서 메시지를 주고받는 방법을 이해하기 매우 쉽게 만듭니다. 그러나 우리는 브라우저를 클라이언트로, 클라우드 서버를 서버로 생각하지만, CoAP의 세계에서는 무엇이든 클라이언트, 서버 또는 둘 다가 될 수 있습니다. 이것은 IoT 시스템을 설계할 때 정말 유용할 수 있습니다. 예를 들어, 단일 센서 노드는 클라우드 서버에 데이터를 게시하는 클라이언트일 수 있고, 클라우드는 자는 장치의 상태를 감시하면서 일어날 때 서버 역할을 수행할 수도 있습니다. 심지어 로컬 네트워크까지 확장될 수 있습니다 — 두 장치는 직접 통신하여 클라이언트/서버 쌍으로 작동할 수 있습니다.

CoAP는 다른 클라이언트/서버 모델과 마찬가지로 비동기적이며, IoT 네트워크의 특성으로 인해 그 방향으로 기울어져 있습니다. 장치는 계획된 및 예기치 않은 이유로 오프라인 상태로 전환될 수 있으며, CoAP는 이러한 사항을 Tokens(요청 일치 기능) 및 Message ID(캐싱 및 중복 제거 기능)와 같은 기능을 통해 고려합니다.

<div class="content-ad"></div>

CoAP의 메시징 모델에 대해 이해해야 할 마지막 포인트는 모든 설계 결정이 효율성에 관한 것이라는 점입니다. 효율성은 메시지의 크기, 메시지 전송 빈도와 같은 요소뿐만 아니라 메시지가 사용하는 배터리 양이나 암호화 유형에 대한 연산 비용과 같은 심층 기술적 고려 사항까지 포함됩니다. CoAP이 효율적일 수 있도록 노력하는 몇 가지 예시는 다음과 같습니다:

- 세션의 대역폭 오버헤드를 줄이기 위해 UDP를 기본으로 선택
- 필드를 짧은 코드로 인코딩하여 크기를 줄이기
- 핸드셰이크 횟수를 줄이기 위해 확인 메시지를 "Piggybacking"

CoAP이 효율적으로 동작하도록 노력하는 다양한 방법이 있습니다. 이에 대한 자세한 내용은 나중 섹션에서 다루겠지만 대부분은 사양서에 상세히 기술되어 있습니다. 다행히도 당신이 프로토콜을 처음부터 구현할 의향이 없다면 이러한 세부 사항을 걱정할 필요가 없습니다.

## 요청/응답 의미론

<div class="content-ad"></div>

CoAP은 HTTP와 많은 의미론적으로 유사한 점들을 공유합니다. 중복해서 언급했듯이 많은 유사한 기능들이 있어요:

- URIs: CoAP 엔드포인트는 HTTP/HTTPS처럼 URI를 통해 주소 지정할 수 있지만 COAP/COAPS 프로토콜과 포트가 분명히 다릅니다. coaps://[URI]:5684 (안전한) 및 coap://[URI]:5683 (보안되지 않은)
- Methods & Response Codes: CoAP 변형들이 의미하는 대로 동작해요. GET, POST, PUT, DELETE는 주요 동사이고, 2xx-5xx는 응답 코드에 해당합니다.
- Options: HTTP 헤더와 유사하지만 오버헤드가 낮아요.
- 콘텐츠 협상: JSON 및 XML과 같은 다양한 IANA 콘텐츠 유형을 지원합니다.

또한, CoAP의 의미론적인 측면 중 HTTP와 정확히 같지 않은 중요한 점이 있어요. 신뢰성은 선택 사항이에요. HTTP의 TCP 기반 전략과 다르게 CoAP은 메시지 크기 및 전체 전력 사용량을 줄이기 위해 구현되어요. CoAP은 신뢰할 수 없는 메시지를 "NON-confirmable"라고 부릅니다. 다른 메시지 유형으로는 CONfirmable, ACKnowledge 및 ReSeT 등이 있습니다. 이들은 piggybacking, 핑 감소, 캐싱 등을 효율적으로 처리하기 위해 사용돼요. IP 멀티캐스트는 일반적으로 HTTP에서 사용되지 않지만 CoAP의 핵심 기본 원시자료로, 특정 IoT 응용 프로그램에서 매우 유용합니다. 방(“장면”)의 모든 조명을 켜거나 시계를 동기화하는 것을 생각해보세요. 마지막으로, 클라우드에 필요한 라우팅, 혼잡 제어 및 DDoS 방지와 같은 많은 구성 요소는 일부 사항이 독자에게 달려 있으며 (및 추가 사양입니다.)

## 보안

<div class="content-ad"></div>

우리가 보안에 대해 이야기하지 않았다면 뜬금없을 것입니다. 결국, IoT의 "S"는 보안을 의미하죠 (농담이에요!) 이전에 말했듯이 안전한 CoAP URI에는 기본 프로토콜로 coaps://와 포트 번호로 5684가 사용됩니다. 그렇다면 보안은 어떻게 구현되는 걸까요? CoAP는 기본적으로 UDP를 사용하므로 전송 계층을 보호하기 위해 DTLS (Datagrams용 TLS)를 선택했습니다. DTLS를 기반으로 CoAP는 네 가지 보안 모드를 정의합니다:

- Pre-shared keys (PSK) 이것은 미리 정의된 키를 사용하므로 구현하기 가장 간단하지만, 확장성이 가장 낮은 방법입니다. PSK를 생성, 배포 및 보호하는 것은 문제가 발생할 수 있습니다. 그렇지만, 간단한 배치에는 이 방법이 가장 일반적으로 사용되는 것으로 보입니다.
- Raw Public Key (RPK) 이 모드는 인증서의 복잡성 없이 공개 키 쌍을 사용합니다. RPK는 일반적으로 더 나은 끝간 보안 구조(ex. 공개 키에서 키 유도)와 현대적인 공개 키 인프라와 잘 작동합니다.
- Certificates 인증서는 엔터프라이즈급 보안으로 간주됩니다. RPK와 마찬가지로 이 모드는 X.509 인증서를 사용하며 인증서 수명주기 관리(믿음 루트, 인증서 교체 등)의 성숙한 생태계를 갖추고 있습니다. CoAP와 결합된 인증서 기반 보안은 전문화된 솔루션(+사양)으로 이어지며, 이것을 적절히 다루기 위해 별도의 포스트가 필요합니다.
- No Security 기술적으로는 보안 모드가 아니며, 불행히도 야생에서 가장 흔한 모드입니다. 이는 종종 VPN과 같은 상위 수준의 보안을 의존하기 때문이지만, 총비용절감, 나태함 또는 개발자 무지로 인한 경우도 있습니다.

RFC 7252에서 여러 보안 고려 사항이 논의되어 있습니다. 최근 CoAP를 유명하게 한 것 중 하나는 셀룰러 장치를 이용한 DDoS 공격이었습니다. 이 유형의 공격은 증폭 공격으로 알려져 있으며, 모든 UDP 기반 프로토콜에 취약합니다. 안타깝게도, 이러한 공격은 가장 기본적인 보안 방법과 양호한 클라우드 구현으로 대부분 막을 수 있습니다.

보안은 매우 중요한 주제이고, 다행히도 이 분야에서 많은 좋은 노력이 벌어지고 있습니다. 이 시리즈에서 나중에 더 심층적으로 다룰 예정입니다.

<div class="content-ad"></div>

# CoAP 시작하기

CoAP을 시작하는 가장 쉬운 방법은 터미널에서 바로 시작하는 것입니다. 제가 추천하는 구현 중 일부는 다음과 같습니다:

- libcoap (C/C++)
- Californium (Java)
- go-coap (Go)
- aiocoap (Python)
- node-coap (Node.js)

요즘에는 Go를 선호하고 있으니, go-coap에서 간단한 클라이언트/서버 예제를 소개해 드리겠습니다:

<div class="content-ad"></div>

도움을 받을 수 있는 좋은 장소는 Stack Overflow, Reddit, CoRE 메일링 리스트 또는 특정 라이브러리의 이슈 목록을 사용하는 것입니다.

# 요약

마음맵을 다시 살펴보자. 이번에는 "basic"이라고 부르지 않은 모든 것을 숨겨봅시다:

훨씬 덜 무섭게 보이죠! 그것이 목적입니다 :) CoAP는 기본 프로토콜로 간단하고 쉽게 이해할 수 있습니다. 이 게시물만으로도 CoAP를 다음 프로젝트나 제품의 기본 구성 요소로 사용할 준비가 되었습니다. 하지만 논의할 주제가 더 많이 있습니다!

<div class="content-ad"></div>

# 다음에 올 내용

원래 CoAP 논의를 하나의 게시물로 계획했었는데... 우리가 더 얘기할 주제가 많이 생겼어요. 최소한 세 개의 게시물이 더 나올 것으로 예상돼요:

- Part 2: 기본 이해 이상
- Part 3: 고급 사용 사례
- Part 4: CoAP 보안 자세히

그러나 이 글에 대한 피드백과 커버하고 싶은 내용에 대한 의견을 주시면 정말 감사하겠어요! 아래에 댓글을 남겨주시거나 트위터/링크드인으로 메시지 보내주세요.

<div class="content-ad"></div>

위의 텍스트를 친근한 톤으로 한국어로 번역해 드리겠습니다.

와인 잔을 올려봅시다!