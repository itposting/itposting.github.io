---
title: "컨테이너가 스왑 공간을 사용할 수 있을까요"
description: ""
coverImage: "/assets/img/2024-06-19-CanContainersUseSwapSpace_0.png"
date: 2024-06-19 14:53
ogImage: 
  url: /assets/img/2024-06-19-CanContainersUseSwapSpace_0.png
tag: Tech
originalTitle: "Can Containers Use Swap Space?"
link: "https://medium.com/@cstoppgmr/can-containers-use-swap-space-cdf9d73d8db5"
---



![image](/assets/img/2024-06-19-CanContainersUseSwapSpace_0.png)

Linux을 잘 아시는 분이라면 스왑 공간에 익숙할 것입니다. 간단히 말하면, 스왑은 가상 메모리로 사용되는 디스크의 일부입니다. 물리적 메모리 (RAM)가 가득 찼을 때 RAM에서 드물게 사용되는 데이터를 일시적으로 스왑 공간으로 이동할 수 있습니다. 이렇게 함으로써 새로운 메모리 요구에 맞춰 RAM을 확보합니다.

스왑을 사용하는 장점은 메모리 사용량의 갑작스러운 변화를 다룰 수 있어 Out-Of-Memory(OOM) Killer가 충분한 메모리 없이 프로세스를 종료하는 것을 방지할 수 있다는 것입니다.

특히 Memory Cgroups(제어 그룹)로 관리되는 컨테이너의 경우, 다음과 같은 의문이 생깁니다. 그들은 여전히 스왑 공간을 사용할 수 있을까? 그렇다면, 어떠한 잠재적인 문제가 있을까요?


<div class="content-ad"></div>

# 문제 현상

먼저, 사용 가능한 스왑 공간이 있는 노드에 컨테이너를 시작하고 메모리 Cgroup 제한을 설정해봅시다. 이후 어떤 일이 일어나는지 관찰해보겠습니다.

만약 당신의 노드에 스왑 파티션이 없다면, 다음 명령어를 사용하여 하나를 생성할 수 있습니다.

이 예시에서 스왑 공간 크기는 20G로 설정되어 있지만, 사용 가능한 디스크 공간에 따라 조정할 수 있습니다. 이러한 명령어를 실행한 후 free 명령어를 실행하면 스왑 공간이 지금 20G임을 확인할 수 있습니다.

<div class="content-ad"></div>

아래 스크린샷을 참고하면 출력 예시를 확인할 수 있어요.

![image](/assets/img/2024-06-19-CanContainersUseSwapSpace_1.png)

자, 이제 OOM(메모리 부족) 문서의 예제와 비슷하게 512MB로 설정된 메모리 Cgroup 제한이 있는 컨테이너를 시작해보겠습니다. 컨테이너 내부의 mem_alloc 프로그램은 2GB의 메모리를 할당하려고 할 거에요.

OOM 문서에서 설명한 상황과 달리, 이번에는 OOM 이벤트로 인해 컨테이너가 종료되지 않아요. 대신, 컨테이너는 계속해서 원활하게 실행됩니다.

<div class="content-ad"></div>

위의 출력에서 우리는 mem_alloc 프로세스의 RSS (Resident Set Size) 메모리가 약 512MB(RES: 515596)로 유지되는 것을 관찰할 수 있습니다.

![이미지](/assets/img/2024-06-19-CanContainersUseSwapSpace_2.png)

이제 스왑 공간을 살펴봅시다. 1.5GB (사용 중 1542144KB)의 스왑 공간이 사용되고 있음을 관찰할 수 있습니다. 아래 그림에서 출력이 나와 있습니다. 간단한 계산으로 1.5GB + 512MB가 mem_alloc 프로그램이 요청한 2GB의 메모리와 동일함을 알 수 있습니다.

![이미지](/assets/img/2024-06-19-CanContainersUseSwapSpace_3.png)

<div class="content-ad"></div>

우리가 방금 토론한 예시를 기반으로 하면, 스왑 공간이 있는 경우 OOM-킬 당할 수 있던 컨테이너가 원활하게 실행될 것이라고 생각할 수 있습니다. 처음에는 유익해 보일 수 있지만, 좀 더 심층적으로 생각해보면, 이는 메모리 Cgroup 제한의 목적을 약화시킬 수 있다는 점을 생각해보셨나요?

더 분석해봅시다. 컨테이너 내 프로그램이 메모리 누수를 경험하는 경우, 메모리 Cgroup은 일반적으로 다른 애플리케이션들에 영향을 미치지 않도록 적시에 프로세스를 종료합니다. 그런데 이제 스왑 공간이 활성화되어 있으면, 누수되는 프로세스가 종료되지 않습니다. 대신에 계속해서 스왑 디스크에 읽고 쓰기를 계속하며 전체 노드의 성능을 저하시킬 수도 있습니다.

이 분석을 고려하면, 컨테이너를 실행하는 노드에서 스왑을 비활성화하는 것이 더 나을 수 있다고 결론짓을 수도 있습니다. 하지만 결론을 서두르지 않는 것이 중요합니다. 우리는 항상 말씀드리듯이, “구체적인 환경은 구체적인 분석이 필요합니다.” 구체적인 시나리오를 고려할 때, 처음에는 그렇게 간단하지 않을 수도 있습니다.

예를 들어 일부 종류의 프로그램은 가끔 메모리가 급증하여 OOM 킬러에 의해 종료되지 않도록하기 위해 스왑 공간이 필요할 수 있습니다. 이러한 프로그램을 재시작하는 것은 초기화 시간이 길기 때문에 비용이 들 수 있습니다. 이러한 프로그램들에 대해서는 스왑을 활성화하는 것이 의미가 있을 수 있습니다.

<div class="content-ad"></div>

이 프로그램들이 컨테이너에서 실행될 때, 같은 호스트 머신을 다른 컨테이너와 함께 공유하게 될 거예요. 하나의 컨테이너가 스왑이 필요없고 엄격한 Memory Cgroup 제한을 의존하는 경우, 두 컨테이너 간에 호스트 머신에서 충돌이 발생할 수 있어요. 그래서, 이 충돌을 어떻게 해결할 수 있을까요?

이 문제를 해결하기 위해서는 Linux의 "swappiness" 개념을 살펴볼 필요가 있어요. 이것이 매우 도움이 될 거예요.

# swappiness 매개변수를 올바르게 이해하는 방법

일반적인 Linux 시스템에서 스왑 공간을 사용한 경우, proc 파일 시스템 (/proc/sys/vm/swappiness)에서 찾을 수 있는 swappiness 매개변수를 구성했을 수 있어요. swappiness의 정의는 Linux 커널 문서에 나와 있습니다.

<div class="content-ad"></div>

고 значение은 kernel이 swap 하는 경향을 늘리고, 낮은 값은 그 경향을 줄입니다. swappiness 매개변수는 kernel이 런타임 메모리를 swap out 하는 선호도를 정의하며, 값이 100이면 kernel이 적극적으로 swap하고, 값이 0이면 kernel은 가능한 경우에는 swap을 피합니다. 기본 값은 60입니다.

이 정의를 처음 읽고 값의 범위를 알게 되었을 때, swappiness를 백분율 값으로 생각했습니다. 이는 swap 공간 사용 빈도를 나타냅니다. 값이 100이면 메모리가 충분할 때에도 항상 디스크로 swap하게 되고, 값이 0이면 디스크로 swap하지 않는다는 것을 의미합니다.

그러나 더 심층적인 고찰을 통해, 이해를 바로 잡아보자면, 이해가 완전히 잘못됐다기보다는 개념을 단순화한다는 점이 있습니다. 그래서 이 정의를 올바르게 이해하는 방법은 무엇일까요?

Linux에서 디스크 파일 접근할 때, 시스템은 파일 I/O 성능을 향상시키기 위해 쉬는 메모리를 페이지 캐시로 사용하려고 노력합니다. swap 공간이 없는 경우, 메모리가 부족해지면 페이지 캐시가 해제되지만 Resident Set Size (RSS) 메모리는 해제되지 않는다는 것을 의미합니다.

<div class="content-ad"></div>

대부분의 RSS 메모리는 malloc()에 의해 할당된 메모리와 같이 특정 디스크 파일과 연관시킬 수 없는 익명 메모리입니다. 스왑 공간이 활성화되어 있는 경우, 이 익명 메모리는 스왑 공간에 기록될 수 있습니다.

그래서 스왑 공간이 활성화된 상황에서, 메모리가 부족할 때 리눅스 시스템이 페이지 캐시를 해제할지 아니면 익명 메모리를 해제하고 스왑 공간에 기록할지 결정하는 방법이 궁금해집니다.

가능성이 높은 두 가지 시나리오를 분석해 봅시다:

- 시스템이 모든 페이지 캐시를 먼저 해제하는 경우, 자주 파일 읽기/쓰기 작업이 필요한 경우에 성능이 저하될 수 있습니다.
- 시스템이 먼저 모든 익명 메모리를 해제하고 스왑 공간에 기록하면, 그리고 즉시 해당 해제된 익명 메모리를 사용해야 할 때, 이를 스왑 공간에서 다시 읽어들여야 하므로 자주 디스크 I/O와 성능 저하가 발생할 수 있습니다.

<div class="content-ad"></div>

명확하게, Page Cache 및 익명 메모리의 릴리스를 균형 있게 유지해야 합니다. swappiness는 이 균형을 정의하는 매개변수입니다.

swappiness는 이 균형을 어떻게 제어할까요? Linux 커널 코드가 이 swappiness 매개변수를 사용하는 방법을 살펴봅시다.

swappiness 값의 범위는 0부터 100까지입니다. 하지만 이 값은 비율이지만 백분율은 아닙니다. 이 값은 릴리스되는 익명 메모리와 Page Cache 메모리 사이의 비율을 정의합니다.

커널 코드에서 이 비율은 anon_prio:file_prio로 표현됩니다. 여기서 anon_prio는 swappiness와 동일합니다. 세 가지 시나리오에 대해 논의해 봅시다:

<div class="content-ad"></div>

- 스왑니스가 100 일 때, 익명 메모리를 해제하는 비율과 페이지 캐시 메모리를 해제하는 비율은 100 : 100이며, 동일한 비율로 해제됩니다.
- 기본 스왑니스 값이 60 일 때, 익명 메모리를 해제하는 비율과 페이지 캐시 메모리를 해제하는 비율은 60 : 140으로, 페이지 캐시 메모리가 익명 메모리보다 더 적극적으로 해제됨을 나타냅니다.

```js
        /*
         * 스왑니스가 100 인 경우, 익명 및 파일에 동일한 우선 순위가 부여됩니다.
         * 이 스캔 우선 순위는 사실 IO 비용의 역입니다.
         */
        anon_prio = swappiness;
        file_prio = 200 - anon_prio;
```

한 가지 더 고려해야 할 시나리오가 있습니다: 스왑니스가 0으로 설정된 경우 무엇이 발생합니까? 이것은 Linux 가 익명 메모리를 스왑 공간에 쓰지 않도록 허용하지 않는다는 의미입니까?

스왑니스의 정의를 다시 살펴보고 스왑니스가 0 인 경우에 특히 주의 깊게 살펴봅시다.

<div class="content-ad"></div>

메모리(zone)의 "high water mark" 아래로 떨어질 때 swappiness가 0으로 설정되어 있어도 Linux는 여전히 메모리 스와핑을 수행합니다. 이는 메모리를 해제하기 위해 익명 메모리를 스왑 공간에 기록한다는 것을 의미합니다.

이 문맥에서 "zone"은 Linux에서 물리적 메모리의 영역이며, 각 zone에는 메모리 압력 수준을 나타내는 세 가지 워터 마크가 있습니다.

이 동작을 검증하기 위해 실험을 실행해 봅시다. 먼저 swappiness를 0으로 설정하는 명령어인 'echo 0 > /proc/sys/vm/swappiness'를 사용하세요. 그런 다음 이전 예제에서 사용한 mem_alloc 프로그램을 사용하여 메모리를 할당하세요. 예를 들어, 노드에 12GB의 메모리와 2GB의 스왑 공간이 있다면 mem_alloc을 사용하여 12GB의 메모리를 할당하세요.

mem_alloc을 실행하기 전에 스왑 공간 사용량을 확인하세요. 사용량은 used=0로 표시되어야 합니다. mem_alloc을 실행한 후에는 일부 메모리가 스왑 공간에 기록되었음을 나타내는 출력이 표시되어야 합니다. 이것은 swappiness가 0으로 설정되어 있더라도 Linux가 필요할 때 여전히 메모리를 스왑 공간으로 스왑한다는 것을 확인합니다.

<div class="content-ad"></div>


![이미지](/assets/img/2024-06-19-CanContainersUseSwapSpace_4.png)

mem_alloc를 호출한 후에는 교체 공간이 실제로 사용 중입니다.

![이미지](/assets/img/2024-06-19-CanContainersUseSwapSpace_5.png)

mem_alloc가 노드에서 사용 가능한 최대 메모리(12GB)를 거의 요청했기 때문에 cat /proc/zoneinfo를 확인하면 normal 존의 높은 값이 free 값과 근접함을 알 수 있습니다. 이 상황에서 free가 high보다 작을 때 시스템은 익명 메모리 페이지를 회수하고 교체 공간에 기록합니다.


<div class="content-ad"></div>

아래는 리눅스 시스템에서 swappiness 개념을 소개한 내용입니다. 이는 메모리가 부족할 때 익명 메모리와 페이지 캐시 메모리 간 재할당 비율을 결정합니다.

swappiness 값은 0부터 100까지이며, 100은 익명 메모리와 페이지 캐시 메모리 간 재할당이 동일함을 의미합니다. 기본값은 일반적으로 60이며, 페이지 캐시 재할당을 우선시합니다. 심지어 swappiness가 0으로 설정되어도 Swap 파티션 사용이 완전히 비활성화되지는 않습니다. 이는 메모리가 부족할 때 Swap이 여전히 익명 메모리를 반환하기 위해 사용된다는 것을 의미합니다.

# 문제 해결 방법

<div class="content-ad"></div>

컨테이너를 Memory Cgroup으로 실행할 때 swappiness는 어떻게 작동하나요?

Memory Cgroup 제어 그룹 아래 매개변수를 확인하면 memory.swappiness라는 매개변수가 있습니다. 이 매개변수는 무엇을 하는 걸까요?

memory.swappiness는 이 Memory Cgroup 제어 그룹 아래의 익명 메모리 및 페이지 캐시 회수를 제어하며, 범위 및 동작은 전역 swappiness와 유사합니다. 여기에는 우선 순위 순서가 있습니다: Memory Cgroup 제어 그룹에서 memory.swappiness 매개변수를 설정하면 이 그룹 내에서 전역 swappiness를 무효화시키므로 전역 swappiness가 작동하지 않게 됩니다.

하지만 여기서 주의해야 할 차이점이 있습니다: memory.swappiness = 0으로 설정하면 익명 페이지 회수가 항상 비활성화되어 Swap 공간을 사용하지 않게 됩니다.

<div class="content-ad"></div>

이 시점에서 Linux 시스템은 더 이상 영역의 높은 기준 마크와 빈 메모리를 비교하여 메모리 Cgroup의 익명 메모리를 회수해야 하는지 여부를 결정하지 않습니다.

“memory.swappiness=0”을 설정하면 메모리 Cgroup의 프로세스가 스왑 공간을 더 이상 사용하지 않습니다. 이 점을 이해하는 것이 중요합니다.

이를 확인하기 위해 스왑 공간이 있는 노드에서 여전히 컨테이너를 실행해 볼 수 있습니다. 이전 글에서와 같은 컨테이너를 실행하되, 해당 Memroy Cgroup의 memory.swappiness를 0으로 설정하는 방법으로 진행할 수 있습니다.

![이미지](/assets/img/2024-06-19-CanContainersUseSwapSpace_7.png)

<div class="content-ad"></div>

이번에는 컨테이너에 메모리를 할당한 후 스왑 공간이 사용되지 않았으며, 컨테이너가 할당된 메모리가 memory.limit_in_bytes를 초과하면 OOM Kill이 발생했습니다.

“memory.swappiness = 0”의 구성 및 기능으로 이 기사 초반에 제기한 문제를 해결할 수 있습니다.

같은 호스트에서 컨테이너 A와 컨테이너 A의 스왑 공간이 필요한 애플리케이션을 실행하는 다른 컨테이너가 있는 상황에서, 다른 컨테이너는 스왑 공간을 사용할 필요가 없습니다.

이 경우에는 호스트 노드에서 스왑 공간을 활성화하고, 다른 컨테이너에 해당하는 Memory Cgroups 제어 그룹에서 memory.swappiness 매개변수를 0으로 설정할 수 있습니다. 이렇게 함으로써 우리는 컨테이너 A의 요구 사항을 충족시키고, 다른 컨테이너가 영향을 받지 않고 여전히 Memory Cgroups의 memory.limit_in_bytes에 따라 메모리 사용량을 엄격하게 제한할 수 있습니다.

<div class="content-ad"></div>

결론적으로, memory.swappiness 매개변수는 매우 유용합니다. 이를 통해 Swap 공간을 사용해야 하는 컨테이너와 Swap 공간을 필요로 하지 않는 컨테이너가 동시에 동일한 호스트에서 실행될 수 있습니다.

# 결론

본 문서에서는 컨테이너에서 Swap 사용 여부에 대해 주로 다뤘습니다. 이 문제는 보다 간단하지 않습니다. 물론 호스트 노드에서 Swap 공간이 활성화되어 있다면 컨테이너에서 Swap을 사용할 수 있습니다. 그러나 동일한 호스트에서 Swap을 사용하지 않아도 되는 컨테이너를 위한 메모리 Cgroups 제한이 효과가 없어지는 문제가 발생할 수 있습니다.

이 문제를 해결하기 위해 Linux의 swappiness 매개변수에 대해 알아보았습니다. swappiness 매개변수는 시스템에 Swap 공간이 있고 시스템이 메모리를 회수해야 할 때 페이지 캐시에서 메모리 해제를 우선시할지 익명 메모리(즉, Swap에 기록)에서 메모리 해제를 우선시할지 결정합니다.

<div class="content-ad"></div>

swappiness 값은 0부터 100까지의 범위를 가지며, 다음 세 가지 값을 기억할 수 있습니다:

- 100의 값은 페이지 캐시와 익명 메모리의 메모리 해제에 동등한 우선 순위를 부여함을 의미합니다.
- 대부분의 Linux 시스템에서 기본값인 60의 값은 페이지 캐시에서 익명 메모리보다 메모리를 해제하는 것을 우선시합니다.
- 0의 값은 시스템의 무료 메모리가 임계 값을 초과할 때에도 익명 메모리가 여전히 해제되고 페이지가 Swap 영역에 씌워집니다.

proc 파일 시스템의 전역 swappiness 매개변수와 각 메모리 Cgroup 제어 그룹의 memory.swappiness 매개변수의 차이점은 메모리 Cgroup 제어 그룹의 swappiness 매개변수 값이 0으로 설정되면 해당 제어 그룹에서 Swap으로의 메모리 작성이 중지된다는 것입니다. memory.swappiness 매개변수를 사용하면 Swap을 사용해야 하는 컨테이너와 그렇지 않은 컨테이너가 동일한 호스트에서 실행되어 더 높은 하드웨어 자원 활용률을 이끌어냅니다.

![이미지](/assets/img/2024-06-19-CanContainersUseSwapSpace_8.png)