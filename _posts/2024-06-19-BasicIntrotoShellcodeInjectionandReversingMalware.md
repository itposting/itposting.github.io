---
title: "쉘코드 삽입 및 악성 코드 역분류에 대한 기본 소개"
description: ""
coverImage: "/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png"
date: 2024-06-19 09:00
ogImage: 
  url: /assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png
tag: Tech
originalTitle: "Basic Intro to Shellcode Injection and Reversing Malware"
link: "https://medium.com/@jakerebsaw/basic-intro-to-shellcode-injection-and-reversing-malware-951f2ab4d293"
---


안녕하세요! 이 게시물의 목적은 제가 배우고 있는 연구 및 개발 방법 중 일부를 공유하는 것입니다!

오늘은 Windows 앱, 드라이버, 심지어 커널 자체에 대한 강력한 디버깅 솔루션인 WinDbg의 사용에 대해 이야기하고 싶었습니다. WinDbg를 좋아하는 한 가지 이유는 도구가 매우 유연하며 체계적인 시스템 분석을 위한 놀라운 기능이 포함되어 있다는 것입니다.

몇 가지 예시를 제공하기 위해, 'AAAA'를 notepad.exe의 주소 공간에 간단히 주입하는 간단한 셸코드 주입 프로그램을 만들어 보았습니다. 선택한 프로그램이 시스템에서 실행 중이고 보호받는 프로세스가 아닌 한 사용할 수 있습니다!

참고: 이러한 기술을 배우는 데 도움을 준 MalDev Academy 및 멋진 YT 채널을 운영하는 cr0w에게 감사드립니다!

<div class="content-ad"></div>


![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_0.png)

프로그램 실행 후에 보이는 것처럼, 이 프로그램은 PID를 매개변수로 사용하고 핸들을 획득한 다음 할당된 메모리에 쉘코드를 주입하여 코드 실행을 달성합니다!

더 나아가기 전에 현대 시스템에서는 어떤 종류의 합법적인 쉘 코드도 대부분의 보안 제품을 우회하기 위해 강력하게 난독화되어야 하거나, 디스크나 메모리의 별도 위치에 저장되어야 할 것으로 강조하고 싶습니다. 이것은 단순한 개념 증명일 뿐입니다.

프로그램의 기본 개요는 아마도 쉘 코드를 주입하는 가장 일반적인 방법을 따릅니다:


<div class="content-ad"></div>

- 해당 PID로 프로세스를 식별하고 핸들을 획득합니다.
- 그 프로세스의 가상 주소 공간 내에서 RWX 권한으로 메모리를 할당합니다.
- 쉘 코드의 내용을 버퍼에 쓰고 그것을 할당된 메모리 공간에 전달합니다.
- 생성 및 호출하여 페이로드가 실행될 스레드를 만들어 실행을 트리거합니다.

![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_1.png)

위는 우리 프로그램의 "Main"이라는 단어를 포함하는 여러 기능들의 분해입니다. 여기서 "x `프로그램이름`!`함수이름`" 명령을 사용하여 이를 달성합니다. 

주소가 a5f00으로 끝나는 곳에서 우리 main 함수의 진입점을 볼 수 있습니다.

<div class="content-ad"></div>


![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_2.png)

메인 함수에 중단점을 설정하고 실행을 계속한 후, 프로그램을 분해하여 현재 레지스터 값들을 검사할 수 있습니다. 여기서 소스 코드 왼쪽에 할당된 변수를 NULL로 설정했다고 알 수 있습니다. 오른쪽에는 스택에 반영된 할당이 보이며, 값 0이 스택의 기본 위치로부터 다양한 오프셋에 저장되는 것을 확인할 수 있습니다.

![이미지](/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_3.png)

여기서 "cmp" 명령어를 볼 수 있는데, 이는 결국 인수 개수 함수입니다. 인수 개수가 2와 일치하면 함수가 실행되고, 그렇지 않으면 사용법 라인에 정의된 문자열을 출력합니다.


<div class="content-ad"></div>

<img src="/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_4.png" />

위 캡처에서는 특정 메모리 주소에 포함된 값들을 표시할 수 있습니다. 여기서는 db 명령어 뒤에 주소를 넣어 해당 내용을 바이트로 표시합니다. 하지만 "display as ascii"를 위해 da를 활용할 수도 있습니다.

이 메모리 주소로부터 함수가 계속 실행되는 동안 어떤 문자열이 출력되는지 확인할 수 있습니다.

<img src="/assets/img/2024-06-19-BasicIntrotoShellcodeInjectionandReversingMalware_5.png" />

<div class="content-ad"></div>

이제 페이로드 저장에 대해 이야기하겠습니다. 한 발 물러서서 rep movs 명령어를 강조하고 싶어요. 우리가 인자 수를 비교하기 전에 우리의 ECX 또는 카운터 레지스터에 값 5를 할당했다는 것을 주목하세요. 그리고 나서 우리는 반복적으로 스택으로 한 번에 한 바이트씩 복사합니다.

우리의 페이로드는 AAAA로만 구성되어 있으므로, 왜 5라는 값이 우리의 페이로드에서 몇 바이트를 복사할지 결정하는 데 사용되는 걸까요? 이 5번째 바이트는 아마도 우리의 페이로드가 NULL 종료된 문자열이라는 사실을 고려하기 때문에, 마지막으로 복사해야 하는 바이트는 NULL 바이트일 것입니다.

이와 마지막으로, 페이로드 식별에 대해서 이야기할게요. "dd/db" 명령을 활용하여 특정 레지스터의 내용을 표시할 수 있어요! 이렇게 멋진 걸요! 그래서 프로그램 실행을 따라가면서 레지스터가 어떻게 변하는지, 어떤 값이 저장되는지를 살펴볼 수 있고, 아마도 프로그램이 무엇을 하는지 추측할 수도 있어요.

<div class="content-ad"></div>

RAX 레지스터에 저장된 페이로드의 바이트 및 ASCII 내용을 공개함으로써 거기에 4개의 A가 있다는 것을 확인할 수 있습니다.

마지막으로: 이 WinDbg 프로그램에서 할 수 있는 작업은 스택 추적을 검토하거나 레지스터를 조작하거나 API 호출 및 그 매개변수를 찾는 등 훨씬 더 많습니다. 저는 기본적인 분석 기술을 강조하고 앞으로 더 복잡한 주제를 탐구할 것을 희망합니다. 또한, ProcessHacker2나 일부 Sysinternals 도구와 같은 도구를 사용하여 프로그램을 실행하는 동안 메모장 메모리 내용을 검토하거나 페이로드가 삽입되는 방식 및 스레드가 호출되거나 호출되는 방식을 파악할 수도 있습니다.

읽어 주셔서 감사합니다!