---
title: "BigQuery에서 함수형 데이터 엔지니어링 가이드"
description: ""
coverImage: "/assets/img/2024-06-22-AGuidetoFunctionalDataEngineeringinBigQuery_0.png"
date: 2024-06-22 17:17
ogImage: 
  url: /assets/img/2024-06-22-AGuidetoFunctionalDataEngineeringinBigQuery_0.png
tag: Tech
originalTitle: "A Guide to Functional Data Engineering in BigQuery"
link: "https://medium.com/decode-data/a-guide-to-functional-data-engineering-in-bigquery-9c0065d76749"
---



<img src="/assets/img/2024-06-22-AGuidetoFunctionalDataEngineeringinBigQuery_0.png" />

# 소개

## 함수형 데이터 엔지니어링이란 무엇인가요?

함수형 데이터 엔지니어링은 수학과 소프트웨어 엔지니어링의 함수 개념을 반영한 데이터 작업 방식입니다.


<div class="content-ad"></div>

막심 보셰만(Maxime Beauchemin)은 Apache Airflow 및 Apache Superset의 창립자로, 2018년 발표한 'Functional Data Engineering — a modern paradigm for batch data processing'에서 데이터에 대한 기능적 엔지니어링 원칙의 목표와 실제 적용을 설명했습니다.

명확한 목표와 제약 조건을 정의함으로써, 이 접근 방식은 데이터에서 명확함, 재현성, 안정성, 신뢰성 및 추적 가능성을 달성하려는 목표를 갖습니다. 실제적으로, 이는 도구, 개발, 테스트 및 자동화를 간소화하고, 어떠한 조직, 팀 또는 프로젝트에 대한 데이터 관련 작업의 확장 가능하고 효율적인 기초를 구축하는 데 도움이 될 수 있습니다.

# 동기

데이터 공간에서 우리는 지속적으로 엔트로피와 싸움을 벌이고 있습니다. 데이터 소스 및 도구의 증식, 데이터 번성, 문서화 흩어짐, 일관되지 않고 잘못 계획된 명명 규칙, 스파게티처럼 얽힌 의존성 맵 등. 시스템은 뒤죽박죽으로 변화할 수 있습니다.하지만 이 저항할 수 없는 진전의 반대에 에너지와 의지를 투입하지 않는 한 요구되는 엔트로피 증가에는 버팁을 세우게 됩니다.

<div class="content-ad"></div>

간단함은 엔트로피를 막기 위해 우리가 사용하는 무기입니다.

간단함은 기능적 데이터 엔지니어링의 존재 이유인데요: 아키텍처의 간단함; 프로세스의 간단함; 실행의 간단함; 쿼리 및 비용의 간단함이 중요합니다. 이러한 간단함은 증가하는 데이터 원본, 증가하는 데이터 양, 성장 중인 분산 팀 및 신속하고 신뢰할 수 있는 데이터로 의사결정을 내리고 모델을 학습하며 비즈니스 목표를 지원하는 수요를 다룰 때 필요합니다.

비용과 복잡성의 증가, 신뢰성과 정확성의 감소를 피하기 위해서는 데이터 처리, 통합 및 관리에 일관된, 규율적인 방식이 필요하며, 이러한 목표를 달성하는데 도움이 되는 것이 바로 기능적 데이터 엔지니어링 접근 방식입니다.

이 기사에서는 Google Cloud 데이터 스택에서 BigQuery를 중심으로 이를 어떻게 구현할 수 있는지 소개하고 있습니다.

<div class="content-ad"></div>

# 상황

함수형 데이터 엔지니어링의 원리를 이해하기 위해서는 해당 원리들이 유도된 수학 및 소프트웨어 엔지니어링 원리로 시작하는 것이 유익합니다.

## 함수란 무엇인가요?

수학적 함수의 정의부터 시작해보겠습니다.

<div class="content-ad"></div>

어떤 함수에 대해서 입력과 출력 사이에 1:1 매핑이 있습니다. 이건 직관적으로 이해되지만, 애플리케이션에서 '요소'가 실제로 무엇인지 정의하는 것이 중요할 것입니다.

## 함수형 프로그래밍이란?

함수형 프로그래밍의 정의로 넘어가겠습니다:

함수는 다른 함수들로 구성될 수 있으며, 값들을 다른 값들로 매핑합니다. 좀 더 자세히 읽어보면:

<div class="content-ad"></div>

동일한 입력이 제공되면 항상 동일한 출력을 반환하는 함수를 의미합니다 (즉, 결정적인 함수입니다).

## 데이터 파티셔닝

함수형 데이터 엔지니어링의 기본 원칙을 살펴보기 전에 파티션된 데이터의 개념을 소개하는 것이 중요합니다.

실제로, 데이터 파티셔닝은 데이터를 원래 수신된 시간을 기준으로 별도의 파티션으로 물리적으로 분리합니다. 이렇게 함으로써 하향 작업이 특정 쿼리나 작업에 필요한 파티션만을 대상으로 쿼리할 수 있도록 만들어줍니다. 이는 파티션 프루닝이라 불리는 작업입니다.

<div class="content-ad"></div>

파티셔닝 시간 단위는 데이터의 양과 속도에 따라 다를 수 있지만, 많은 경우 도착 날짜별로 데이터를 파티션으로 나누는 것이 합리적입니다. 이 기사에서는 날짜를 기반으로 한 데이터 배치를 다루고 있다고 가정하겠습니다.

수학적 정의에 관련해서, '요소'라는 개념을 보면 입력 데이터 소스에서 날짜로 구분된 단일 파티션을 고려할 수 있으며, 이는 한 입력 파티션이 항상 정확히 하나의 출력 파티션에 매핑된다는 것을 의미합니다.

# 해결책

기능적 데이터 엔지니어링의 본질은 어떤 데이터 엔지니어링 작업도 입력 데이터, 변환 로직 및 출력 데이터로 축소하는 것입니다.

<div class="content-ad"></div>

![AGuidetoFunctionalDataEngineeringinBigQuery_1](/assets/img/2024-06-22-AGuidetoFunctionalDataEngineeringinBigQuery_1.png)

입력 데이터, 변환 로직 및 출력 데이터를 분리하는 것이 매우 중요합니다. 로직은 시간이 지남에 따라 변경되므로 필요에 따라 새로운 로직을 기존 데이터에 적용하여 출력 데이터 테이블 파티션을 재구성할 수 있어야 합니다.

## 1. 영구적이고 변경 불가능한 입력 데이터 파티션

첫 번째 기본 원칙은 데이터 소스 파티션이 시스템에 들어오면 영구적이며 결코 삭제될 수 없다는 것입니다.

<div class="content-ad"></div>

각 날짜 파티션은 변경할 수 없는 객체로 간주되며, 행을 UPDATE, DELETE 또는 INSERT할 수 없습니다.

이는 변경되는 로직이 계속하여 변경되지 않은 입력 데이터에서 작동하기 때문에 견고한 기반을 제공해줍니다. 이로써 논리 변경의 효과를 격리시킬 수 있습니다.

## 2. 결정론적이고 아이덴포턴트한 버전 관리된 논리

결정론적 논리는 동일한 입력을 주면 항상 똑같은 응답을 반환하는 함수를 의미합니다. 이는 LLMs의 특정 상황에서 흥미로울 것입니다. 왜냐하면 LLM은 본성상 결정론적이 아니기 때문에 동일한 프롬프트라도 다른 응답을 반환합니다. 그러나 응답 구조 자체가 결정론적이라면 LLM 응답을 여전히 기능적 데이터 엔지니어링 워크플로에 활용할 수 있습니다.

<div class="content-ad"></div>

아이덴포턴시는 두 번째 중요한 제약 사항으로, 반복된 논리적 실행이 초기 실행에서 발생한 최종 상태를 변경하지 않는다는 것을 본질적으로 의미합니다. 간단한 INSERT 문을 고려해 보겠습니다: 이를 여러 번 실행하면 의도적으로든 우연히든 중복된 행이 생성되는 원치 않는 부작용이 발생합니다. 이는 INSERT가 아이덴포턴트 작업이 아님을 의미합니다. 아이덴포턴시는 특정 날짜 파티션을 작성하거나 덮어쓰기만 할 수 있도록 작업의 허용된 출력을 제한함으로써 달성됩니다.

부작용(즉, 외부 상태를 변경하지 않는)이 없는 결정론적이고 아이덴포턴트한 작업은 일반적으로 순수 작업이라고 합니다.

재현성을 달성하기 위해 버전 제어는 중요한 능력입니다: 논리적 변경으로 인해 잘못된 최종 상태가 발생하면 이전 버전의 로직으로 되돌아가거나 출력 테이블을 다시 작성하는 것이 간단하게 되어야 합니다. 결과 데이터를 이전 버전으로 롤백하여 출력 데이터를 이전 버전으로 복원하는 효과적인 방법과 거의 동일해야 합니다.

결과 데이터를 직접 버전 관리하는 것과는 다르지만, 영구적이고 변경할 수 없는 입력 데이터에 버전 관리된 로직을 적용하는 것은 출력 데이터 파티션을 버전 관리하는 것과 사실상 동일해야 합니다.

<div class="content-ad"></div>

## 3. 변경할 수 없는, 교체 가능한, 분할된 출력 데이터

출력된 데이터 파티션은 변경할 수 없는 상태로 유지되며, 한 번 생성되면 데이터 파티션을 변경할 수 없습니다. 이는 UPDATE, DELETE, INSERT 또는 MERGE 작업이 허용되지 않음을 의미합니다. 즉, 행은 데이터 파티션 내에서 변이될 수 없습니다. 이는 배포된 변환 로직을 통해 출력 데이터 추적 가능성을 보존하여 파티션 및 행 수준의 추적이 가능하게 합니다.

입력 및 출력 데이터 제약 사항 간의 주요 차이점은 출력 데이터 파티션은 영구적이지 않지만 교체 가능하다는 점입니다. 이들은 전체적으로 생성되거나 덮어쓸 수 있지만, 변환 실행 로직의 일부로 업데이트하거나 삭제할 수 없습니다.

날짜 파티션 필드의 선택은 중요하며, 트레이드오프가 필요할 수 있습니다. 출력 데이터를 입력 데이터와 동일한 필드로 분할함으로써, 메타데이터 쿼리만을 기반으로 모니터링 및 자동화 작업을 진행할 수 있습니다. 이는 효율적이고 예측 가능하며 기본 데이터의 잠재적으로 비싼 스캔이 필요하지 않습니다.

<div class="content-ad"></div>

## 구현 로직

이 기술의 실제 응용을 이해하기 위해서는 변환을 실행하기 위해 필요한 논리적 상호 작용을 명확히해야 합니다. 변환 논리가 출력 데이터 파티션을 생성하거나 대체하기 위해 실행되어야 할 작업을 결정하는 실행 논리를 제공하며, 실행 트리거는 실행 논리가 실행되는 시점을 결정합니다.

![image](/assets/img/2024-06-22-AGuidetoFunctionalDataEngineeringinBigQuery_2.png)

실행 트리거는 요청에 따라, 일정에 따라 또는 이벤트 기반(예: 새로운 들어오는 데이터 감지)일 수 있으며, 실행 논리는 그 후에 변환 논리가 어떻게 배포되며 필요 시 어떤 출력 데이터 파티션이 덮어쓰여야 하는지를 결정합니다.

<div class="content-ad"></div>

점진적 접근 방식은 메타데이터를 확인하여 입력 데이터 파티션 날짜가 아직 출력 데이터에 없는 경우를 식별하고, 그런 다음 변환 로직을 적용하여 새로운 출력 데이터 파티션을 만드는 것을 의미합니다. 그러나 이 작업은 새로 도착한 날짜 파티션에 대해서만 수행됩니다.

더 복잡한 실행 로직을 구현할 수도 있습니다. 예를 들어, 늦게 도착한 데이터를 고려하여 최근 날짜 파티션의 추가 수를 덮어쓰거나, 특정 날짜 이전 또는 이후의 모든 출력 날짜 파티션을 덮어쓸 수도 있습니다.

기술적 구현 옵션에는 천천히 변하는 차원에 대한 고려 사항이 있지만, 이는 이 기본 구현 범위를 벗어납니다.

# 실행

<div class="content-ad"></div>

위의 제약 조건과 구현 논리를 고려할 때, 이 패러다임을 BigQuery에서 구현하는 운영 프레임워크의 각 측면을 정의하는 것은 실제로 매우 간단합니다. BigQuery 및 관련 기술에 대한 맥락을 고려하면, 다음 기사는 우리가 사용할 수있는 Google Cloud 리소스에 대한 넓은 개요를 제공합니다:

이제 BigQuery에서 Functional Data Engineering 워크플로우를 구축, 실행 및 관리하기 위해 필요한 모든 리소스의 구현 옵션을 고려하고 평가하며, 다음 영역을 다루고 있습니다:

- 인바운드 데이터
- 변환 논리
- 데이터 증가
- 출력 데이터
- 실행 논리
- 실행 트리거
- 모니터링
- 버전 관리

## 1. 인바운드 데이터

<div class="content-ad"></div>

많은 BigQuery 데이터를 가져오는 메커니즘이 있지만, 입력 데이터가 분할되어야 하고 영구적이며 변경될 수 없다는 제약 조건으로 인해 다음 옵션이 선호됩니다:

날짜별 테이블

날짜별 테이블은 데이터를 효율적인 쿼리 패턴을 위해 서로 다른 물리적 파티션으로 분리하는 기본적인 방법입니다. 이를 함수형 데이터 엔지니어링 워크플로우의 입력 데이터로 사용할 수 있지만, 상류 프로세스는 변형 불가 제약 조건을 준수하고 데이터 파티션이 로드 후 변경되지 않도록 구성되어야 합니다.

이를 지원하기 위한 메커니즘 중 하나는 흡수 시간에 의한 파티셔닝이며, 특정 데이터 집합 권한을 설정하여 데이터가 삭제되지 않고 영구적이 되도록 해야 합니다. 파티션된 테이블은 BigQuery 사용자 인터페이스에서 간단한 몇 번의 클릭으로 삭제할 수 있으므로 이를 방지하기 위한 보호장치가 마련되어야 합니다.

<div class="content-ad"></div>

날짜별 샤딩된 테이블

날짜별 샤딩된 테이블은 Google에서 관리하는 가져오기 작업(예: GA4 BigQuery 내보내기)을 할 때 자주 만날 수 있습니다. 이들은 날짜별로 파티셔닝된 테이블과 유사하지만, 실제로는 접두사를 공유하고 날짜를 기반으로 한 접미사를 가진 기술적으로 별개의 테이블입니다. 이들의 주요 이점은 날짜별로 파티셔닝된 테이블에서 가능한 효율적인 쿼리 패턴을 달성할 수 있는 와일드카드 및 _TABLE_SUFFIX를 결합하여 질의할 수 있다는 것입니다.

저장소 폴더 구조

Google Cloud Storage와 BigQuery 외부 테이블을 결합한 접근 방식은 데이터 상호작용과 관리 사이의 분리를 제공하면서 불변성과 영속성 제약 조건을 달성하기에 매우 견고하고 효과적입니다. GCS 버킷에 파일로 저장된 데이터는 직접 쿼리할 수 있지만 BigQuery에서 삭제할 수는 없어 데이터 삭제에 대한 추가적인 보안 계층을 제공합니다.

<div class="content-ad"></div>

_FILE_NAME 가상 열을 변환 로직에 포함시킬 수 있습니다. 이는 추가 입력 메타데이터를 제공하기 위해 구문 분석될 수 있습니다. 이는 잘 설계된 날짜 기반 폴더 구조(서로 다른 파일 유형을 별도 계층으로 구분)와 결합되어, 이 방법은 날짜별 파티셔닝 또는 날짜별 샤딩된 테이블이 달성할 수 있는 효율적인 쿼리 패턴을 복제하는 데 사용될 수 있습니다.

## 2. 변환 로직

BigQuery 뷰는 임의의 SQL을 데이터의 기저에있는 개요 데이터의 일시적인 뷰로 작성할 수 있는 유용한 자원입니다. SQL 기반의 변환은 출력 스키마와 데이터를 결정하며, 검사 가능한 스키마를 가지고 있어 매우 유용할 수 있지만 실제로는 널리 남용됩니다.

쿼리시 뷰는 항상 모든 기저 데이터를 쿼리하고 다시 계산하므로 매우 비효율적입니다. 뷰는 종종 주기적으로 전체 하위 테이블을 다시 빌드하는 데 사용되며, 이는 불필요하게 비싼 방법이며, 입력 데이터 양이 증가함에 따라 비용이 증가할 것입니다.

<div class="content-ad"></div>

그러나 Table Functions을 사용하여 날짜 분할 기능을 추가하면 Views의 대부분의 긍정적인 특성을 활용할 수 있습니다.

Table Functions

Table Functions은 Views와 논리적으로 동일하지만 한 가지 중요한 측면에서 다릅니다. Table Functions은 인수를 취할 수 있으며, 이러한 인수는 SQL 쿼리에서 변수로 사용할 수 있습니다. 이것은 보기를 사용하면서도 날짜 파티션 하위 집합을 쿼리할 수 있는 강력한 기능을 제공합니다.

이 인수들은 Table Function SQL의 구조적 부분(예: 열 또는 테이블 이름)을 형성할 수 없다는 점에 유의하십시오.

<div class="content-ad"></div>

날짜 범위 테이블 함수

날짜 범위 테이블 함수는 정확히 두 개의 DATE 인수인 start_date와 end_date를 사용하는 테이블 함수의 구현에 불과합니다. 테이블 함수 SQL이 우리의 영구적이고 변경할 수 없는 입력 데이터를 참조할 때, 쿼리 문에 WHERE 절을 추가하여 이러한 날짜 사이의 파티션 범위에 대한 데이터만 쿼리하고 반환할 수 있습니다.

날짜 범위 테이블 함수를 연결하여 변환 로직을 별도의 단계로 분리할 수 있으며, 이로 인해 독립적으로 개발, 쿼리 및 테스트할 수 있게 됩니다.

다음 예제 논리 구조는 날짜 범위 테이블 함수의 시퀀스에서 구성됩니다:

<div class="content-ad"></div>

외부 쿼리가 최종 Table Function(TF12)을 호출할 때, 쿼리 데이터 범위를 start_date 및 end_date 인수로 전달하면 해당 인수가 Table Functions의 일련의 순서를 통해 상위로 전파되며 입력 데이터에서 특정 날짜 범위만 쿼리됩니다. 변환 로직은 이후 이 날짜 범위에만 적용되고, Table Function은 변환된 데이터 분할을 반환하여 검사, 분석 또는 출력 테이블의 기존 분할에 덮어쓸 준비가 됩니다.

## 3. 데이터 증강

변환 로직은 일반적으로 데이터 구조 변경, 조인, 집계 및 계산을 포함하나, BigQuery는 입력 데이터에서 출력 데이터 분할로 전달되는 데이터를 더욱 증강하는 강력한 도구 세트를 제공합니다.

<div class="content-ad"></div>

사용자 정의 함수 (UDF)

사용자 정의 함수는 강력하고 모듈식이며 재사용 가능한 기능으로 로직을 캡슐화하는 깔끔한 메커니즘입니다. SQL 또는 Javascript로 작성한 후에 SQL 쿼리 내에서 사용하여 데이터에 사용자 정의 분류, 계산 또는 기타 작업을 추가할 수 있습니다.

BigQuery ML: AI 함수

BigQuery ML (머신 러닝)에는 강력한 ML 모델을 바로 호출할 수 있게 하는 여러 내장 함수가 있습니다. 이 함수들은 입력부터 출력으로 흘러가는 데이터를 개선할 수 있도록 ML.UNDERSTAND_TEXT, ML.TRANSLATE, ML.ANNOTATE_IMAGE, ML.TRANSCRIBE 및 ML.PROCESS_DOCUMENT을 포함합니다.

<div class="content-ad"></div>

위의 경우에 대해 번역하면 다음과 같습니다.

이러한 것들에는 경우에 따라 상당한 추가 비용이 소요되며, API 속도 제한을 피하고 일괄 처리 전략이 필요할 수도 있습니다.

또한 ML.ANNOTATE_IMAGE 및 ML.PROCESS_DOCUMENT는 Google Cloud Storage 버킷에 호스팅된 파일로 분석해야 하며, BigQuery에서는 Object Table이 객체 인벤토리 역할을 하게 됩니다.

BigQuery ML: 생성적 AI 기능

BigQuery ML.GENERATE_TEXT 함수를 사용하면 간단한 SQL 쿼리를 통해 Google LLMs(gemini-1.5-flash, gemini-1.5-pro, gemini-pro, gemini-pro-vision,text-bison,text-bison-32,text-unicorn)에 직접 액세스할 수 있습니다.

<div class="content-ad"></div>

이 기능을 사용하면 추가 비용이 발생할 수 있으며 안정적인 성능을 얻기 위해 일괄 처리 전략이 필요할 수도 있습니다.

생성 AI 함수는 본질적으로 결정론적이지 않기 때문에 순수한 기능 데이터 엔지니어링 워크플로에 허용되지 않을 수 있습니다. 그러나 응답 구조가 결정론적인 경우, 이러한 경우처럼 변활 논리에 실제로 포함될 수 있으며 LLM의 응답은 출력 데이터에서 액세스할 수 있습니다. 다만 출력 데이터 파티션이 덮어쓰기되면 포함된 응답은 이전 응답과 다를 수 있습니다.

원격 함수

원격 함수는 Cloud Functions에 대한 액세스 포인트를 제공하여 다양한 언어로 사용자 정의 코드를 작성하고 외부 시스템과 상호 작용한 다음 BigQuery에서 응답을 인라인으로 반환할 수 있습니다. 이를 통해 BigQuery의 영역을 데이터 이상 및 자동화 사용 사례에 대한 Google 및 외부 API의 광범위한 세계에 확장할 수 있습니다. 그러나 Cloud Functions은 추가 개발, 인프라, 모니터링, 권한 및 디버깅 오버헤드가 따르므로 내장 또는 사용자 정의 함수를 사용하는 것이 더 좋습니다.

<div class="content-ad"></div>

## 4. 출력 데이터

정확하고 신뢰할 수 있는 출력 데이터를 작성하고 유지하는 것이 기능 데이터 엔지니어링 워크플로우의 주요 목표입니다. 이 출력 데이터는 일반적으로 다음과 같은 형태를 띕니다:

- 날짜별 테이블

날짜별 테이블은 기능적 데이터 엔지니어링에서 선호하는 출력 구조입니다. 필요에 따라 클러스터링된 고카디널리티 열로 구성되며, 추가 필터링이 적용될 것으로 예상되는 열로 클러스터링될 수 있습니다. 파티션 가지치기를 통해 효율적인 쿼리 수행이 가능하며 (필요한 특정 데이터 파티션만 쿼리함), 쿼리할 데이터양이 줄어듭니다.

<div class="content-ad"></div>

파티셔닝된 테이블 메타데이터는 INFORMATION_SCHEMA.PARTITIONS 뷰를 통해 조회할 수도 있습니다. 이는 모니터링 및 자동화 활동에 중요합니다.

파티셔닝된 테이블은 최대 10,000개의 파티션을 가질 수 있으며, 따라서 날짜별로 분할된 테이블은 하루 날짜 파티션을 27년 이상 보유할 수 있습니다.

클라우드 스토리지 버킷

출력 데이터는 EXPORT DATA 문을 사용하여 다양한 파일 및 압축 형식으로 Google Cloud Storage 버킷에 내보낼 수도 있습니다. 그런 다음 이 데이터는 BigQuery에서 외부 테이블을 사용하여 압축 파일의 일반적으로 더 낮은 비용의 저장소인 Cloud Storage에서 액세스할 수 있습니다.

<div class="content-ad"></div>

Google Cloud Storage 버킷 내용은 Object Tables을 사용하여 BigQuery에서 나열할 수 있습니다. 이를 통해 모니터링 및 자동화 기능의 기초로 활용해볼 수 있습니다. 그러나 모니터링 및 자동화는 URI(전역적으로 고유한 파일 경로)에서 날짜 메타데이터를 구문 분석하는 것에 따라 약간 복잡할 수 있습니다.

또한 데이터를 Amazon S3 버킷이나 Azure Blob Storage로 내보내어 안전한 크로스 클라우드 데이터 통합을 할 수도 있습니다.

## 5. 실행 로직

기능 데이터 엔지니어링 워크플로우의 논리적 실행은 두 가지 핵심 BigQuery 기능에 의해 주도됩니다: 리소스 메타데이터에 액세스하기 위한 INFORMATION_SCHEMA 뷰 및 원하는 결과에 따라 기능 작업을 실행하기 위한 PROCEDURES입니다.

<div class="content-ad"></div>

데이터 메타데이터 비교

입력 및 출력 데이터가 파티션 열을 공유하도록 제한했다면, 입력 데이터와 출력 데이터 간의 메타데이터 비교는 차이점을 식별하는 매우 간단한 방법을 제공합니다. 또한 이는 모니터링 및 자동화를 구축하는 효율적인 기반으로 작용하며, 상태를 외부 저장소(예: 최신 실행 결과를 저장하는 테이블)에 저장할 필요가 없고 기본 데이터를 쿼리할 필요도 없습니다. 이것은 운영 비용을 예측 가능하고 낮출 수 있습니다.

기능 캡슐화

입력 데이터 테이블의 날짜 파티션 또는 샤드 배열을 반환하는 데 필요한 SQL을 수동으로 작성하는 것은 가능하지만, 우리의 선호하는 접근 방식은 그 자체로 기능적입니다. SQL 사용자 정의 함수(UDF)를 활용하여 SQL 컴파일 및 프로시저를 실행하기 위한 프로시저를 사용함으로써 자동화에 기능적 데이터 엔지니어링 접근을 지원하는 일부 유틸리티 함수에 액세스할 수 있습니다. 파티션된 테이블의 최신 날짜 파티션을 가져오기 위한 예시 기능 사용 코드는 다음과 같습니다:

<div class="content-ad"></div>

```js
DECLARE source_table_id STRING;
DECLARE last_partition_date DATE;

SET source_table_id = 'myproject.mydataset.mypartitioned_table';
CALL [project].[region].get_last_partition_date (source_table_id, last_partition_date) 
```

이 예시에서 get_last_partition_date를 성공적으로 실행한 후, source_table_id로 참조된 테이블에 유효한 날짜 분할이 있는 경우, get_last_partition_date DATE 변수는 최신 날짜 값을 설정하고 후속 논리 단계에서 사용할 수 있습니다.

비교적 작은 범위의 유사한 메타데이터 함수를 사용하여 실행 로직을 간단하게 표현하고 자동화 활동에 대한 신뢰할 수 있는 기반으로 사용할 수 있습니다.

실행 모드


<div class="content-ad"></div>

기능 데이터 엔지니어링 플로우의 개발, 디버깅, 업데이트 및 유지 관리를 도와주는 여러 실행 모드가 있습니다. 첫 번째 두 가지는 다음과 같습니다:

- 전체 테이블 새로고침 — 첫 번째부터 마지막 파티션까지 모든 데이터 덮어쓰기
- 증분 새로고침 — 새 데이터가 도착했을 때 가장 최근의 n개 파티션을 덮어쓰기

이러한 것들이 기본 실행 모드이지만, 추가적으로 도움이 되는 몇 가지 실행 모드가 있으며, 가속화되고 효율적인 개발 및 디버깅을 지원합니다:

- 날짜 범위 새로고침 — 특정 날짜 범위 내의 모든 파티션 덮어쓰기
- 최신 정보 새로고침 — 특정 날짜까지의 파티션 덮어쓰기
- 시작 날짜 새로고침 — 특정 날짜부터 파티션 덮어쓰기

<div class="content-ad"></div>

이러한 실행 모드의 조합은 함수형 데이터 엔지니어링 흐름의 실행에 대한 세밀한 제어를 제공합니다.

함수형 데이터 조작

출력 날짜 파티션을 덮어쓰는 데 하드 코딩된 DML(Data Manipulation Language)을 사용할 수 있지만, 이렇게 하면 스크립트가 사용 사례별로 제한되며, 코드를 복사하고 편집하지 않으면 재사용할 수 없습니다.

메타데이터 함수에도 동일한 방식을 적용하고 SQL UDF(User-Defined Functions), 프로시저(Procedures), 트랜잭션을 결합하여 날짜 파티션을 덮어쓰는 함수를 방한 방법으로 구축합니다. 이는 덮어쓰기 함수가 사실 DELETE 및 INSERT DML 문으로 구성되지만, 이것이 TRANSACTION 내에서 발생한다는 사실은 어떤 실패가 발생하더라도 롤백되므로 트랜잭션이 방한적이라는 것을 의미합니다.

<div class="content-ad"></div>

기능 권한

함수 및 프로시저에 대한 액세스 권한을 허용할 때 주의해야 할 두 가지 중요한 기능이 있습니다:

- 사용자 권한 — 사용자는 이메일, Google 그룹 또는 서비스 계정을 통해 지정된 데이터 세트에서 함수를 실행할 수 있는 권한을 부여받을 수 있습니다.
- 루틴 권한 — 루틴에는 지정된 데이터 세트에서 함수를 실행할 수 있는 권한이 부여될 수 있습니다.

즉, 사용자는 외부 프로젝트의 단일 데이터 세트에 대한 BigQuery Viewer 액세스를 부여받을 수 있으며, 해당 데이터 세트에 대한 권한만 있으면 데이터 세트 함수와 그에 허용된 종속 함수를 성공적으로 실행할 수 있습니다.

<div class="content-ad"></div>

6. 트리거 로직

실행 함수는 데이터의 신선도에 따라 여러 가지 다른 메커니즘을 통해 트리거될 수 있습니다.

요청 시

실행 함수는 필요에 따라 호출될 수 있으며, 후속 활동 직전에 BigQuery 콘솔에서 배포된 함수를 실행함으로써 실행할 수 있습니다.

<div class="content-ad"></div>

**예약된 쿼리**

예약된 쿼리는 주기적인 일정에 맞게 실행 함수를 트리거하는 가벼운 방법으로, 실패 시 내장된 이메일 알림(간단한 경보 시스템을 위해 Slack로 자동 전달될 수 있음)이 제공됩니다. 쿼리 레이블을 추가하면 특정 쿼리 레이블을 기반으로 필터링하여 처리량 및 추정 비용별로 분석할 수 있습니다.

예약된 쿼리는 복잡한 코드를 작성하기에는 권장되지 않으며, 해당 코드는 BigQuery에서 볼 수 없습니다. 예약된 쿼리의 결과를 테이블에 삽입하는 것은 비멱득 연산이며, 따라서 기능형 데이터 엔지니어링 흐름에서 피해야 합니다. 쓰기/잘라내기 연산은 멱득 연산이지만 전체 테이블 덮어쓰기의 처리 비용이 시간이 지남에 따라 증가하므로 일반적으로 비효율적입니다.

이벤트 기반 트리거

<div class="content-ad"></div>

빅쿼리에 데이터가 도착할 때 함수나 쿼리를 트리거하는 간단하고 기본 메커니즘이 없습니다. 이상적으로는 PubSub 주제를 테이블이나 데이터 세트에 연결하여 새 테이블이나 파티션에 도착할 때 트리거되고, 다른 임의의 함수 실행을 트리거할 수 있으면 좋을 것입니다. 그러나 현재는 이를 외부 도구 없이 실행할 수 없으므로 일반적으로 출력 데이터의 원하는 데이터 신선도와 일치하는 빈도로 예약된 실행 쿼리를 배포합니다.

## 7. 모니터링

빅쿼리에서 데이터 워크플로우를 모니터링하는 것은 다양한 방법을 결합하여 구현할 수 있습니다.

메타데이터 모니터링

<div class="content-ad"></div>

The INFORMATION_SCHEMA views can be used to monitor resource metadata in order to manage and optimize resource, partition, and storage infrastructure.

Log Monitoring

The INFORMATION_SCHEMA.JOBS view is used to monitor query patterns, compute volume and associated costs, and to isolate unnecessary compute-related expenses.

Query Labelling

<div class="content-ad"></div>

테이블 태그를 Markdown 형식으로 변경해 주세요.

<div class="content-ad"></div>

저장된 쿼리는 BigQuery 내에서 버전 관리를 구현하는 초보자용 방법이지만, 정의된 프로세스를 엄격히 준수하여 사용해야 합니다. 현재 BigQuery에서 코드 버전을 관리하는 강인한 독립형 솔루션이 아닙니다.

Git 저장소 통합

지금까지 BigQuery에서 코드를 버전 관리하는 것은 매우 어려웠지만, Git 저장소 통합이 현재 시험 중이므로 주목해 주세요! 일부 테스팅을 거친 후에 이 새로운 (그리고 매우 환영받는) BigQuery 기능을 함수형 데이터 엔지니어링 워크플로에 어떻게 사용하는지에 대한 업데이트를 올릴 수 있을 것입니다.

# 구현

<div class="content-ad"></div>

여기까지 오신 여러분은 BigQuery에서의 기능적 데이터 엔지니어링에 관심이 있는 분들이시군요... 멋지네요!

우리가 구현하고 확장하며 기능적 데이터 엔지니어링 워크플로우를 관리하기 위해 사용하는 기능 라이브러리에 대한 문서는 여기에서 확인할 수 있습니다: bqtools.

또한, 이 기능적 데이터 엔지니어링 접근 방식을 활용하여 Google Analytics 4 데이터의 자동 전처리 및 증강을 실행하는 첫 번째 제품을 개발했습니다. 자세한 내용은 여기에서 확인할 수 있습니다: Decode Data for GA4.

이 자료에서 여러분이 BigQuery 여정에서 도움이 될만한 유용한 자료가 있다면, 저희에게 문의해 주세요. 도움이 필요한 사항이 있다면 언제든지 연락해 주세요.

<div class="content-ad"></div>

행복한 기능성 데이터 엔지니어링!

🔎 변환 플로우에 대해:

저희는 기업 및 기관들이 Google Cloud에서 빅쿼리를 중심으로 데이터 기능을 설계, 배포 및 관리할 수 있도록 지원합니다.

빅쿼리 프로그래밍에 대한 깊은 전문 지식을 가지고 있기 때문에, 기능적 데이터 엔지니어링, 빠른 능력 개발 및 비용/보안 감사를 지원하기 위해 빅쿼리 기능을 확장하는 라이브러리를 구축합니다.

<div class="content-ad"></div>

우리는 내부 원격 함수 라이브러리에서 배포할 수도 있고, 사용 사례에 맞춰 BigQuery 기능을 확장하기 위해 사용자 정의 함수를 개발할 수도 있습니다.

당신의 BigQuery 여정이 어디에 있든 우리가 도와드릴 수 있어요. 여기까지 읽으셨다면 직접 jim@transformationflow.io 로 연락하시거나 여기에서 상담 예약해주세요! 🔎