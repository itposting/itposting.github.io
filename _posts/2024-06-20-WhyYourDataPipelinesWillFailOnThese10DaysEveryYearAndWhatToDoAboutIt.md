---
title: "왜 매년 이 10일에 데이터 파이프라인이 실패할 것이며 그리고 대처하는 방법"
description: ""
coverImage: "/assets/img/2024-06-20-WhyYourDataPipelinesWillFailOnThese10DaysEveryYearAndWhatToDoAboutIt_0.png"
date: 2024-06-20 15:28
ogImage: 
  url: /assets/img/2024-06-20-WhyYourDataPipelinesWillFailOnThese10DaysEveryYearAndWhatToDoAboutIt_0.png
tag: Tech
originalTitle: "Why Your Data Pipelines Will Fail On These 10 Days Every Year (And What To Do About It)"
link: "https://medium.com/pipeline-a-data-engineering-resource/why-your-data-pipelines-will-fail-on-these-10-days-every-year-and-what-to-do-about-it-406a202e9053"
---


취업 준비 중이세요? 무료 5페이지 프로젝트 기획 안내서를 활용하여 개인 프로젝트를 개발하여 경쟁력을 확보하세요.

오래 전에 역사 채널에서 아직 역사를 보여주던 시절, 내가 가장 좋아했던 쇼 중 하나는 '사람들 사라진 뒤의 삶'이었습니다. 다른 어떤 역사 채널의 프로그램과 달리 이 시리즈는 한 명의 사람도 등장하지 않습니다. 대신, 시리즈는 어떤 일이 발생할지를 상상합니다. 어느 날 사람들이 그저 사라진다면 문명에 어떤 일이 벌어질지를 상상합니다.

각 에피소드가 1시간이었기 때문에, 이 프로그램은 미래로 꽤 멀리 확장될 수 있었습니다. 각 세그먼트는 동일하게 시작했는데, "(숫자) 년 후 사람들이 없는 세상"에서부터 시작했습니다. 나는 포기된 센트럴 파크가 잡초로 덮여지는 시간이 빠르게 흘러가는 것부터 고장난 펌프로 인해 수조에 갇힌 물고기들에게 불가피한 일이 벌어지는 것까지 모든 것을 지켜보았습니다.

이 프로그램의 주요 주장은, 인류 문명의 복잡성과 규모에도 불구하고, 대부분의 인프라가 방치되면 30일 이내에 실패할 것이라는 것이었습니다.

<div class="content-ad"></div>

시간은 자동화된 코드 또는 데이터 엔지니어링 파이프라인에도 유사한 영향을 미칠 수 있어요. 상류 검사를 추가하거나 단위 테스트를 끝없이 견디더라도, 때로는 지구가 계속 회전하고 시간이 선형적으로 흘러가기로 결정했기 때문에 파이프라인이 실패할 수 있어요.

내 생각에, 신중한 엔지니어들도 예견해야 할 세 가지 중요한 시간 제약 사항이 있어요:

- 일광 절약 시간제 (양일 모두)
- 윤년
- "31" 문제

![파이프라인 실패 이유와 대처 방법](/assets/img/2024-06-20-WhyYourDataPipelinesWillFailOnThese10DaysEveryYearAndWhatToDoAboutIt_0.png)

<div class="content-ad"></div>

# DST

데이터 엔지니어로 거의 3년을 일한 후에는, 논란이 되는 미국의 일광 절약 시간 조정과 관련된 최악의 날들을 쉽게 기억할 수 있어요.

일정이 엉망이 되고, 조정이 다시 고려되어야 하며, 더 심각한 것은 모든 것이 놀랍지 않다는 것이예요.

특히 어렵고 힘든 일광 절약 시간이 지난 후, 나는 이제 그런 끔찍한 날들 중 하나에도 데이터가 계속 흐를 수 있도록 견고한 파이프 라인을 구축하기 위해 취하는 조치에 대해 썼어요.

<div class="content-ad"></div>

이번 과제를 해결하는 것은 코딩 조치와 설계적 사고의 결합이 필요합니다.

일광 절약시간제 대책 중 하나는 개발할 때 확고한 습관을 길러야 합니다. 가장 중요한 것은 환경이나 시간 변화에도 일정한 출력을 유지할 수 있도록 논리를 포함한 stateful 파이프라인을 구축하는 것입니다.

게다가, 메타데이터에 적절하게 접근하고 가시성을 확보하는 것은 예상치 못한 실행을 신뢰성 있게 추적하고 처리하며, 필요한 경우 중복을 제거할 수 있도록 도와줍니다.

특정 조건에 대한 안전장치가 없는 시나리오에 직면했을 때, 예를 들어 시간 변경과 같은 상황에는 프로세스 전반에 걸쳐 투명성을 높이는 것이 가장 좋은 대안입니다. 더 많은 로그, 더 많은 타임스탬프, 더 명확하고 더 자주 발생하는 경고가 필요합니다.

<div class="content-ad"></div>

만약 조정이나 재구축이 필요하다면, 가능한 빨리 알아내는 것이 좋습니다. 이미 한 시간 늦거나 빠르기 때문에요.

내가 한 말을 인용해보면:

일관된 피플라인에 대한 DST 영향에 대해 좀 더 자세히 알아보려면, 더 읽어보세요:

## 또 다른 네 해

<div class="content-ad"></div>

DST만큼 빈번하지는 않지만 동일하게 귀찮은 문제인 윤년도 있습니다. 일할 때 하류로부터 시간에 기반한 논리를 수정할 때 "4년 후에 나를 감사해줄 사람이 있을 거야"라고 말했습니다.

기술적으로는 이 사안을 내버려둘 수도 있었고 파이프라인은 3월 1일에 작동했을 것입니다. 그러나 다운타임과 같은 지표에 대한 평가를 받을 때는 가능한 정확해질 필요가 있습니다.

숫자가 개인 및 팀 업적에 어떤 영향을 미치는지를 고려하면, 데이터를 일관되고 신뢰성 있게 제공할 수 있는 능력은 팀의 신뢰성과 조직 내 영향력을 향상(또는 유지)시키는 데 도움이 됩니다.

Python 스크립트에서 윤년을 고려하면 많은 번거로운 if/elif 논리가 포함된 이상한 과정으로 느껴질 것 같습니다.

<div class="content-ad"></div>

일반적으로 사용 사례에 따라 그렇지 않습니다.

사실, 2024년 윤일에 푸시한 수정은 5 줄 미만이었습니다.

문제의 핵심은 Python의 datetime 모듈이 일과 날짜만으로 연도를 유추할 수 없다는 것입니다.

따라서 월/일 형식만 사용하는 파이프라인이 있다면:

<div class="content-ad"></div>

```js
dt_var = date_var.strptime("%m/%d")

if dt_var.day == datetime.now():
  
  # 뭔가를 수행합니다
```

2월 29일에는 파이프라인이 3월 1일로 기본 설정됩니다.

그러나 연도를 제공하면 datetime 모듈이 올바른 하루 증분으로 증가시키는 데 필요한 모든 컨텍스트를 가지고 있습니다. 예를 들어 2/29/24는 올바른 증분입니다.

```js
dt_var = date_var.strptime("%m/%d/%y")

if dt_var.day == datetime.now():
  
  # 뭔가를 수행합니다
```

<div class="content-ad"></div>


리프 데이 수정은 몇 분 동안 머리를 갈구었다가 과도하게 생각해서 자신을 탓한 일 중 하나입니다.

일반적으로 가능하고 논리적인 경우, 완전한 날짜 문자열을 포함하십시오.

변수를 정의한 후에는 항상 다양한 날짜 부분에 액세스할 수 있습니다.

# 31 문제

<div class="content-ad"></div>

마지막으로 가장 흔하고 복잡한 날짜 문제를 남겼습니다.

이 문제를 '31 문제'라고 부릅니다.

최근 파일 이름 문자열에 포함된 날짜를 검색해야 했던 파이프라인의 문제를 해결하고 있었습니다. 예를 들어 "내 파일 2024년 3월 10일" 같은 형식이었습니다.

이를 위해 이전 타임스탬프 변수를 기반으로 월을 추론했지만, 불행히도 그렇게 할 수밖에 없었습니다.

<div class="content-ad"></div>

```python
from datetime import datetime

prev = datetime.now() - timedelta(days=1)

prev_day = prev.day

prev_month = prev.month

if f"{prev_month}/{prev_day}" in file_str:
  
  # Proceed
```

이 스크립트를 새로운 달인 4월의 첫째 날에 실행했을 때 출력이 "April 31"로 나왔던 이유는 datetime.now()이 추가 일이 있는 경우 prev에 제시될 때 현재 월을 검색하도록 알고 있는 게 아니기 때문입니다. 

이 문제를 해결하기 위한 두 단계가 필요합니다.

- 스크립트에 31일이 있는 월을 알려주는 논리 작성
- 이전 논리에 따라 이전 월 값 또는 현재 월 값을 반환할지 확인하는 논리 작성


<div class="content-ad"></div>

아래와 같이 접근 방식을 취합니다:

```js
# 31일 함수

def month_31(month: int):

  if month in [1, 3, 5, 7, 8, 10, 12]:
    day = 31

    return day

  else:
    day = 30

    return day

def return_prev_month(day: str):
  
  if day in list(range(29, 32)):
    
    month_days = month_31(month_int)
  
    if month_days == 30 or month_days == 31:
        
        month = prev.month

        return month

    else:

        month = now.month

        return month
```

저에게는 이것이 매 스크립트에 넣어야 하는 논리가 아닙니다. 하지만 조금 장황한 것이기는 하지만, 이는 바로 문제를 해결하고, “31 문제"에 견딜 수 있게 파이프라인을 1년 중 7개월 동안 더 견고하게 만드는 데 도움이 되었습니다.

데이터 수집의 여러 측면과 마찬가지로 날짜는 민감한 구성 요소입니다. 파이프라인이 실행 중에 많은 단계에서 실패할 수 있을 때, 저에게는 시간의 경과와 특정 날짜의 도착을 예상하고 최적화하는 것이 합리적으로 보입니다.

<div class="content-ad"></div>

비록 날짜 논리가 ETL 또는 데이터 인프라의 가장 흥미로운 측면은 아니지만, 그것은 시간이 지남에 따라 악화될 수 있는 그런 섬세한 문제 중 하나에요.

더군다나 버전이 만료되는 가능성, 플랫폼 변경 및 조직적 선호도의 변화가 더해지면 파이프라인이 망가질 수도 있어요.

사람 없는 세상(Life After People)과는 달리, 데이터 파이프라인의 천천히 떨어지는 변화는 지켜보기가 재미없을 거에요.

도와주시길 원해요. 이 블로그 외에서 어떻게 도울 수 있는지 알려주실 3가지 질문에 답해주시면 됩니다. 모든 응답자에게 무료 선물이 제공됩니다.