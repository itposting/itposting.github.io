---
title: "리눅스 프로세스 분석"
description: ""
coverImage: "/assets/img/2024-06-19-LinuxProcessAnalysis_0.png"
date: 2024-06-19 14:58
ogImage: 
  url: /assets/img/2024-06-19-LinuxProcessAnalysis_0.png
tag: Tech
originalTitle: "Linux Process Analysis"
link: "https://medium.com/@sukarn001/linux-process-analysis-34582bed68e8"
---


리눅스 시스템의 내부 작동을 이해하는 데에는 프로세스, 서비스, 그리고 cron 작업에 대한 이해가 필수적입니다. 각 구성 요소는 시스템 전반적인 기능에서 고유한 역할을 갖고 있으며, 정해진 작업을 실행하거나 루틴한 작업을 자동화하고 사용자 상호 작용을 가능하게 함으로써 서비스를 제공합니다. 그러나 이러한 중요한 역할로 인해 시스템에 침투한 악의적인 사용자들에 의해 악용될 수 있습니다. 공격자들은 취약점이나 잘못된 구성으로 특권을 상승시키고 측면으로 이동하거나 영구적인 손목들을 수립하거나 백도어를 설치하여 시스템의 무결성과 보안을 더욱 훼손할 수 있습니다. 이에 따라, 이러한 구성 요소에 대한 위협을 효과적으로 탐지하고 완화하기 위해 검증 분석 기술의 견고한 아카데미를 구축하는 것이 점점 더 중요해지고 있습니다.

리눅스에서 프로세스는 프로그램의 실행 중인 인스턴스를 말합니다. 리눅스에서 프로그램이나 명령을 실행할 때, 운영 체제는 해당 프로그램을 실행하기 위한 프로세스를 생성합니다. 각 프로세스는 고유한 식별자인 프로세스 ID (PID)를 가지고 있으며, 운영 체제가 이를 관리하고 추적하는 데 도움을 줍니다.

프로세스는 부모-자식 관계를 가질 수 있어서 계층적인 구조를 형성합니다. 한 프로세스가 다른 프로세스를 생성할 때 (예: 한 쉘 세션에서 하위 쉘에서 추가 프로세스를 생성하는 경우), 새로운 프로세스는 그것을 만든 프로세스의 자식이 되며, 부모로부터 생성된다고 합니다. 이 관계는 운영 체제에서 프로세스와 자원 할당을 관리하는 데 중요합니다.

시스템에서 실행 중인 프로세스를 검사하는 데에 다양한 도구와 유틸리티를 사용할 수 있습니다. 이 열거를 통해 악성 활동이나 의심스러운 부모-자식 프로세스 관계를 식별할 수 있습니다.

<div class="content-ad"></div>

# ps

ps 명령어는 UNIX류 운영 체제에서 활성 프로세스에 대한 스냅샷을 보고하는 다재다능한 유틸리티입니다. 기본적으로 현재 (활성 실행 중인) 콘솔 세션과 관련된 프로세스에 대한 정보를 표시하지만 시스템 전반 및 다른 사용자의 프로세스 정보를 수집하는 데도 사용할 수 있습니다. 이 유틸리티는 /proc 가상 파일 시스템의 파일을 읽어 해당 정보를 검색합니다. 이 가상 파일 시스템은 실행 중인 시스템의 각 프로세스와 대응하는 계층적 디렉터리 구조입니다. 명령어를 실행하려면 간단히 ps를 입력하십시오:

![ps command output](/assets/img/2024-06-19-LinuxProcessAnalysis_0.png)

위에서 볼 수 있듯이 해당 명령어는 다음 열을 포함하는 테이블 형식으로 출력을 제공합니다:

<div class="content-ad"></div>

PID: 각 프로세스에 대한 고유 식별자 (프로세스 ID)입니다.
TTY: 프로세스와 연결된 터미널입니다.
TIME: 프로세스가 소비한 누적 CPU 시간입니다.
CMD: 프로세스와 관련된 명령어입니다.

또한 사용자(Janice)에 대한 프로세스를 보려면 -u 또는 --user 옵션을 사용한 후 사용자의 사용자 이름을 입력하면 됩니다.

ps 명령어와 함께 제공할 수 있는 유용한 옵션 세트는 -eFH입니다. 이 옵션 세트는 시스템에서 실행 중인 모든 프로세스에 대한 전체 개요를 계층적 형식으로 반환하므로, 그들이 연결되어 있는 터미널이나 세션과 관계없이 사용 가능합니다. 이 옵션 세트는 시스템 모니터링 및 포렌식 분석에 유용한 도구로 사용됩니다.

<div class="content-ad"></div>

![이미지](/assets/img/2024-06-19-LinuxProcessAnalysis_1.png)

위 명령어에서 볼 수 있듯이, -e를 사용하여 모든 프로세스를 선택하고, 결과를 -F(extra full) 형식으로 반환하며, 프로세스 계층도(포레스트) -H를 보여줍니다.

# lsof

실행 중인 시스템 내에서 모든 열려있는 파일과 해당 프로세스 목록을 보고하는 더 강력한 방법을 살펴봅시다. lsof (List Open Files)는 시스템에서 프로세스에 의해 열린 파일에 대한 정보를 나열하는 유틸리티입니다. 이 경우, 앞서 식별한 Netcat 프로세스가 열어둔 파일을 보려면 lsof를 실행하고 PID를 제공하면 됩니다:

<div class="content-ad"></div>

```markdown
<img src="/assets/img/2024-06-19-LinuxProcessAnalysis_2.png" />

# Advanced Usage

- Network Files with Specific Protocol:

- Explains how to filter network connections by protocol (TCP/UDP).
```

<div class="content-ad"></div>

- 특정 포트로 네트워크 파일:

- 해당 포트 번호로 필터링하여 해당 포트를 사용 중인 프로세스를 확인하는 방법을 보여줍니다.

2. 특정 명령어로 열린 파일:

- 특정 명령어로 열린 파일을 나열하는 방법을 보여줍니다.

<div class="content-ad"></div>

앞으로 pstree를 사용하여 부모-자식 관계 프로세스의 과정을 더 자세히 분석해보는 것이 좋을 것 같아요. 그렇게 하면 프로세스의 발원지를 파악하고 잠재적인 공격 경로에 대한 통찰을 얻을 수 있을 거에요.

# pstree

pstree는 프로세스를 트리 형식으로 시각적으로 표시하는 명령줄 유틸리티로, 프로세스 간의 부모-자식 관계를 보여줍니다. 이 도구를 사용하면 의심스러운 프로세스의 발원지를 식별하고 시스템 내의 다른 프로세스와의 관계를 이해하는 데 도움이 될 수 있어요.

![LinuxProcessAnalysis_3](/assets/img/2024-06-19-LinuxProcessAnalysis_3.png)

<div class="content-ad"></div>

우리가 pstree를 사용하여 식별한 부모 프로세스의 심층적인 프로세스 분석을 수행할 수 있으며, 이를 위해 해당 부모 프로세스의 부모 프로세스(-s)와 해당 프로세스의 PID(-p)를 나열하는 옵션을 제공할 수 있습니다:

![Linux Process Analysis](/assets/img/2024-06-19-LinuxProcessAnalysis_4.png)

-p 옵션과 함께 pstree 명령어를 사용합니다.

# cron 작업

<div class="content-ad"></div>

Cronjobs은 미리 정의된 간격으로 자동으로 실행되는 예약된 작업입니다. Cron 데몬은 이러한 작업을 관리하는 백그라운드 프로세스로, crontab이라는 설정 파일을 기반으로 합니다. 사용자는 /var/spool/cron/crontabs 디렉토리에 crontab 파일을 저장할 수 있습니다. 시스템 전역 cronjob을 관리하는 주요 crontab 파일은 /etc/crontab에 있습니다.

Cron 항목은 공백으로 구분된 필드로 구성된 특정 형식을 따릅니다. 먼저 Bob이라는 사용자를 위한 예제 crontab 파일을 살펴보겠습니다. 일반적으로 이 파일은 /var/spool/cron/crontabs/bob에 있을 것입니다.

예시 Cron 항목

```js
10 05 * * * /home/bob/backup_tmp.sh
```

<div class="content-ad"></div>

이 cron 스케줄은 실행할 명령어가 뒤를 따라오는 다섯 가지 필드로 구성되어 있습니다:

- 분(10): 첫 번째 필드는 명령어가 실행될 분을 지정합니다. 이 경우 10으로, 시간의 10분에 명령어가 실행됨을 나타냅니다.
- 시(05): 두 번째 필드는 명령어가 실행될 시간을 지정합니다. 05로, 새벽 5시 10분에 명령어가 실행됩니다.
- 요일(*): 세 번째 필드는 명령어가 실행될 달의 일을 지정합니다. 여기서는 ****로, 와일드카드 값으로 매 달 모든 날에 실행됩니다. 날짜를 구체적으로 지정하려면 1에서 31까지의 숫자를 사용할 수 있습니다. 예를 들어 매월 15일에 명령을 실행하려면 15를 사용합니다.
- 월(*): 네 번째 필드는 명령어가 실행될 달을 지정합니다. 또한 ****로, 매달 명령어가 실행됨을 나타냅니다. 숫자(1은 1월, 2는 2월 등)나 약어(Jan은 1월, Feb은 2월 등)로 월을 지정할 수 있습니다. 예를 들어 2나 Feb를 사용하여 명령어를 2월에만 실행할 수 있습니다.
- 요일(*): 다섯 번째 필드는 명령어가 실행될 요일을 지정합니다. 여기서는 ****로, 매주 모든 요일에 실행됩니다. 0부터 7까지 숫자로 요일을 지정할 수 있으며, 0과 7은 일요일, 1은 월요일 등으로 대응됩니다. 또는 약어(Sun, Mon, Tue 등)를 사용할 수도 있습니다. 예를 들어 1이나 Mon을 사용할 수 있습니다.
- 명령어(/home/bob/backup_tmp.sh): 마지막 필드에는 실행할 명령어가 포함됩니다.

또한 시스템 레벨의 /etc/crontab은 사용자 레벨의 crontab과 다릅니다. 시스템 전역 crontab에는 명령이 실행될 사용자(root 또는 www-data 등)를 지정하는 추가 필드가 포함됩니다.

모두 합쳐서 이 cron 스케줄은 매일 새벽 5시 10분에 명령어 /home/bob/backup_tmp.sh가 실행되도록 구성되어 있습니다.

<div class="content-ad"></div>

다음으로, 철저한 분석에 중요한 추가 시스템 cron 작업 디렉토리가 있습니다. 이러한 디렉토리는 /etc/ 디렉토리 아래에서 다음과 같은 네이밍 컨벤션으로 찾을 수 있습니다:

- /etc/cron.hourly/ — 한 시간마다 실행되는 시스템 cron 작업.
- /etc/cron.daily/ — 매일 한 번 실행되는 시스템 cron 작업.
- /etc/cron.weekly/ — 매주 한 번 실행되는 시스템 cron 작업.
- /etc/cron.monthly/ — 매월 한 번 실행되는 시스템 cron 작업.
- /etc/cron.d/ — 추가적인 사용자 정의 시스템 cron 작업.

시스템 수준의 cron 작업을 조사한 후에 시스템 사용자가 시스템에 구성한 다양한 사용자 수준의 cron 작업을 살펴볼 수 있습니다. 사용자 수준의 cron 작업은 개별 사용자 구성 파일에 특화되어 있으며 시스템 전역 cron 작업과는 별도로 관리됩니다. /var/spool/cron/crontabs/ 디렉토리로 이동할 수 있습니다. cron을 사용할 수 있는 권한을 갖춘 각 사용자는 이 디렉토리 안에 자신의 사용자 이름으로 된 파일을 갖게 됩니다.

이 정보를 나열하는 여러 가지 방법이 있습니다. 가장 쉬운 방법은 관리자 권한으로 디렉토리 내용을 나열하는 것입니다:

<div class="content-ad"></div>

<img src="/assets/img/2024-06-19-LinuxProcessAnalysis_5.png" />

큰 아이디어로 한 줄짜리 명령어를 사용하여 시스템의 사용자를 빠르게 순환하고 사용자 수준의 크론 작업이 구성되어 있는지 식별할 수 있습니다. 그렇다면 크론 작업 항목의 내용을 터미널에 출력할 수 있습니다. 이 유형의 혼합 자동화는 조사 속도를 높이고 철저한 커버리지를 보장할 수 있습니다.

이 명령을 분해해 보면, /etc/passwd의 항목을 필터링하여 시스템의 모든 사용자를 반복하는 중입니다. 이 반환된 각 사용자에서, 각 사용자를 반복하고 앞서 실행한 crontab 명령을 사용하여 그들의 crontab 항목을 가져옵니다. 해당 사용자에 대한 crontab 항목이 있으면, 그들의 사용자 이름과 crontab 파일에서 해당 항목을 반환합니다.

위 출력에서 여러 사용자의 crontab 항목 값들을 빠르게 확인할 수 있습니다.

<div class="content-ad"></div>

# Cron Execution Logs

Cron 로그는 cron 데몬에 의해 관리되는 예약된 작업의 실행을 기록하며, cron 작업이 실행된 시간과 연관된 출력 또는 오류 메시지의 연대기적 기록을 제공합니다. 수사적 관점에서 이러한 로그는 cron 작업의 실행 흔적을 발견하고 의심스러운 활동이나 시스템 침해를 발견하는 데 귀감이 될 수 있습니다. 예를 들어, 악의적인 사용자가 기존 cron 작업을 남용하거나 악의적인 cron 작업을 생성하고 자신의 흔적을 감추려고 시도한 경우, 로그는 실행의 이상한 패턴이나 예상치 못한 명령어 실행을 드러낼 수 있습니다.

Debian 기반 시스템에서는 cron 실행 로그가 일반적으로 /var/log/syslog에 저장됩니다. 이 파일은 cron 데몬의 메시지를 포함하여 시스템 로그를 집계합니다. Red Hat Enterprise Linux (RHEL) 및 CentOS와 같은 일부 Linux 배포판에서는 이러한 로그를 적절히 /var/log/cron에서 찾을 수 있습니다.

조사 중인 시스템이 syslog 파일에 cron 로그를 저장하기 때문에 우리는 내용을 grep하여 cron과 관련된 로그를 필터링할 수 있습니다.

<div class="content-ad"></div>

위의 명령은 많은 양의 출력물을 생성할 수 있습니다. 특정 기준에 따라 결과를 더 필터링하여 관련 정보에 집중하는 것이 좋습니다. 필터링 아이디어로는 다음과 같은 예시가 있습니다:

# Pspy

Pspy는 루트 권한이 필요하지 않고 리눅스 프로세스를 모니터링하는 강력한 오픈 소스 도구입니다. 실행 중인 프로세스에 대한 실시간 정보를 캡처하고 표시하는 데 사용되며, 실행 명령, 사용자 ID, 프로세스 ID (PID), 부모 프로세스 ID (PPID), 타임스탬프 및 기타 관련 세부 정보를 제공합니다. /proc 가상 파일 시스템에서 데이터를 직접 읽어와 시스템 파일을 수정하거나 상위 권한을 요구하지 않고 프로세스 활동에 대한 실시간 통찰력을 제공합니다.

열거 목적에 용이하지만 사건 대응자들은 실행 아티팩트를 수집하고 단기간 실행되는 프로세스를 포착하는 능력을 활용할 수 있습니다. 실시간 모니터링 덕분에 시스템을 통해 생성된 다양한 cron 작업에 의해 생성된 프로세스를 감지할 수 있어 cron 작업이 실행될 때 어떤 프로세스가 발생하는지에 대한 더 많은 통찰력을 제공할 수도 있습니다.

<div class="content-ad"></div>

이 시스템에서는 Pspy가 이미 사전 설치되어 있으며 사용 중인 바이너리와 함께 마운트되어 있습니다. 따라서 경로에 있으며 pspy64를 실행하여 간단히 호출할 수 있습니다. 실시간 모니터링을 시작하고 몇 분 동안 실행하여 이벤트를 캡처해야 합니다. Ctrl + C를 눌러 중지할 수 있습니다:

![Pspy Image](/assets/img/2024-06-19-LinuxProcessAnalysis_6.png)

# 추가적인 팁:

- 인내심을 갖고 철저히 작업하세요. 어떤 프로세스는 가끔만 나타나거나 특정 시스템 이벤트 중에만 나타날 수 있습니다.
- 특정 프로세스나 사용자를 필터링하기 위해 pspy와 함께 grep 명령을 사용하세요.

<div class="content-ad"></div>

# 요약

리눅스 프로세스, 서비스 및 cron 작업을 이해하는 것은 시스템 무결성과 보안에 중요합니다. 각각 고유한 프로세스 ID (PID)를 가진 프로세스는 부모-자식 관계를 가질 수 있습니다. ps 및 lsof와 같은 도구는 실행 중인 프로세스와 열려 있는 파일을 검사할 수 있습니다. pstree 유틸리티는 프로세스를 트리로 표시하여 부모-자식 관계를 보여줍니다. 크론 작업은 크론 데몬에 의해 실행되는 예약된 작업이며, 크론 로그는 이러한 작업의 실행을 기록합니다. pspy 도구는 리얼타임으로 리눅스 프로세스를 모니터링하여 실행 아티팩트를 캡처하고 크론 작업에 의해 생성된 프로세스를 감지합니다.