---
title: "CVE-202120090 취약점을 이용한 Arcadyan 라우터 인증 우회 및 Buffalo 라우터 루팅 방법"
description: ""
coverImage: "/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_0.png"
date: 2024-06-22 18:04
ogImage: 
  url: /assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_0.png
tag: Tech
originalTitle: "Bypassing Authentication on Arcadyan Routers with CVE-2021–20090 and rooting some Buffalo"
link: "https://medium.com/tenable-techblog/bypassing-authentication-on-arcadyan-routers-with-cve-2021-20090-and-rooting-some-buffalo-ea1dd30980c2"
---


얼마 전에 아마존 일본을 둘러보다가 베스트셀러인 네트워킹 장비/라우터를 찾아보았습니다(사람들이 하는 일종의 활동이죠). 라우터의 안을 열어본 적도 없고 취약점을 찾아본 적도 없는데, 한번 시도해보고 싶다는 생각이 들었습니다. 리스트에서 세 번째로 잘 팔리는 Buffalo WSR-2533DHP3를 발견했습니다. 하지만 판매자가 캐나다로 배송을 해주지 않아서, 관련된 Buffalo WSR-2533DHPL2를 구매했어요(결국 WSR-2533DHP3도 손에 넣었습니다).

다음 장에서는 Buffalo 장비를 해체하는 과정, 그리고 조금 건드린 솔더 작업과 함께 UART에서 제공된 셸을 사용해서 웹 인터페이스의 인증 우회 및 텔넷에서 루트 BusyBox 셸을 활성화할 수 있는 버그를 찾는 과정을 살펴볼 것입니다.

마지막으로, Buffalo 라우터에만 해당되지 않는 인증 우회 취약점의 발견과 열 년 이상의 기간에 걸쳐 다양한 공급업체의 적어도 12개 모델에 영향을 미치는 것을 발견한 과정도 짧게 살펴보겠습니다.

# UART에서 루트 셸

<div class="content-ad"></div>

이러한 Buffalo 라우터와 같은 기기들이 회로 기판의 Universal Asynchronous Receiver/Transmitter (UART)를 통해 시리얼 연결을 통해 쉘을 제공하는 것은 상당히 일반적입니다. 제조업체들은 주로 제조 과정 중에 기기를 디버깅하거나 테스트하는 데 사용하기 위해 UART에 액세스하기 위한 테스트 포인트나 비파괴된 패드를 회로 기판에 남겨 둡니다. 이러한 방법들은 제조 도중에 기기를 테스트하거나 디버깅할 때 자주 사용됩니다. 이번 경우에는, 몇 가지 마찰로 인해 실종된 후에 WSR-2533DHPL2가 BusyBox 쉘을 루트로 UART를 통해 제공하게 되었다면서 우리는 굉장히 운이 좋았습니다.

이 내용이 처음이면, 이 과정을 빠르게 알아보겠습니다 (하드웨어 해킹 및 UART 쉘에 대한 더 자세한 안내가 있는 웹 사이트들도 많이 있습니다).

첫 번째 단계는 라우터의 케이스를 열고 UART에 액세스할 방법이 있는지 확인하는 것입니다.

![이미지](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_0.png)

<div class="content-ad"></div>

우리는 J4로 레이블링된 헤더를 볼 수 있습니다. 아마도 우리가 찾고 있는 것일지도 모릅니다. 다음 단계는 멀티미터를 사용하여 접촉을 테스트하여 전원(VCC), 접지(GND), 그리고 전송/수신(TX/RX) 핀을 식별하는 것입니다. 이러한 것들을 식별하면 핀을 몇 개 납땜하고 JTAGulator와 같은 도구에 연결하여 통신할 핀과 속도를 식별할 수 있습니다.

![이미지](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_1.png)

다른 방법으로도 식별할 수 있지만, JTAGulator를 사용하면 훨씬 쉬워집니다. 우리가 사용할 전압(이전에 멀티미터를 사용하여 찾은 3.3V)을 설정한 후 UART 스캔을 실행할 수 있습니다. 이를 통해 개별 핀에서 캐리지 리턴(또는 다른 지정된 바이트)을 전송하고 다양한 속도로 수신하여, 어떤 조합이 디바이스와의 통신을 가능하게 할지 식별할 수 있습니다.

![이미지](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_2.png)

<div class="content-ad"></div>

UART 스캔 결과, TX로 핀 0을 통해 캐리지 리턴을 보내고, RX로 핀 2를 사용하며, 속도는 57600으로 설정하면, BusyBox v1 출력이 나타납니다. 이는 셸을 획득한 것 같습니다.

![이미지](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_3.png)

확실한 증거로, JTAGulator를 UART 통과 모드로 설정한 후 (이를 통해 UART 포트와 통신할 수 있음), UART 스캔으로 찾은 설정을 사용하여 기기의 루트 셸에 진입하게 됩니다.

![이미지](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_4.png)

<div class="content-ad"></div>

이제이 쉘을 사용하여 장치를 탐색하고 장치의 웹 인터페이스를 제공하는 httpd 이진 파일과 같은 흥미로운 이진 파일을 다른 기계로 전송할 수 있습니다.

# Httpd 및 웹 인터페이스 인증

httpd 이진 파일에 액세스할 수있는 것은 웹 인터페이스의 취약점을 찾는 작업을 훨씬 쉽게 만들어 줍니다. 이를 Ghidra에 넣어서 코드의 흥미로운 부분을 식별할 수 있습니다. 웹 응용 프로그램이나 인터페이스를 분석할 때 가장 먼저 검토하는 항목 중 하나는 인증 정보가 처리되는 방식입니다.

웹 인터페이스를 검토하는 동안 로그인 한 후에도 세션 쿠키가 설정되지 않고 로컬/세션 스토리지에 토큰이 저장되지 않는 것을 발견했습니다. 그래서 인증된 사용자를 추적하는 방법은 무엇일까요? Ghidra에서 httpd를 열어보면 evaluate_access()라는 함수를 찾을 수 있으며, 이 함수는 다음 스니펫으로 이어집니다:

<div class="content-ad"></div>

위의 스크린샷에서 FUN_0041f9d0()는 현재 요청을 하는 호스트의 IP가 이전 유효한 로그인의 IP와 일치하는지 확인합니다.

evaluate_access()가 무엇을 하는지 알게 되었으니, 이를 우회할 수 있는지 살펴봅시다. Ghidra에서 언급된 위치를 검색해보면, 이 함수가 들어오는 HTTP 요청을 처리하는 다른 함수 process_request()에서만 호출된다는 것을 알 수 있습니다.

아래 화면 스크린샷에서 확인할 수 있듯이, 큰 if 문 안에 논리 OR이 있고 (스크린샷 상의 45~48 라인), uVar1의 값을 확인함에 있어 evaluate_access()의 출력을 확인하기 전에 uVar1의 값을 확인합니다(43 라인에 설정됨). 이는 bypass_check(__dest)의 출력이 0이 아닌 다른 값이 반환된다면 인증이 필요 없이 요청이 처리되어 process_get() 또는 process_post()로 전달될 수 있다는 것을 의미합니다.

<div class="content-ad"></div>

bypass_check()을 살펴봅시다.

# bypass_check()으로 체크 우회하기

위 스크린샷에서 bypass_check()를 살펴보면 bypass_list를 순회하며 _dest의 처음 n바이트를 bypass_list에서 가져온 문자열과 비교하는 것을 볼 수 있습니다. 여기서 n은 bypass_list에서 가져온 문자열의 길이입니다. 일치하는 것이 없으면 0을 반환하고 evaluate_access()에서 체크를 통과해야 합니다. 그러나 문자열이 일치하면 evaluate_access()의 결과가 중요하지 않으며 서버는 우리 요청을 예상대로 처리할 것입니다.

우회 목록을 살펴보면 login.html, loginerror.html 및 다른 경로/페이지가 있습니다. 인증되지 않은 사용자도 해당 URL에 액세스할 수 있어야 하기 때문에 이는 합리적으로 보입니다.

<div class="content-ad"></div>

여기에 버그를 이미 발견하신 것 같아요. bypass_check() 함수는 bypass_list 문자열에 있는 바이트 수만큼만 확인하고 있습니다. 이는 사용자가 http://router/images/someimage.png에 액세스하려고 할 때, 비교가 일치할 것이라는 것을 의미합니다. 왜냐하면 /images/가 bypass 리스트에 있기 때문에 우리가 액세스하려는 URL은 /images/로 시작하기 때문이에요. 그러나 bypass_check() 함수는 "someimage.png"과 같이 이후에 오는 문자열에는 신경쓰지 않아요. 그래서 우리가 /images/../`somepagehere`에 도달하려고 하면 어떻게 될까요? 예를 들어, /images/..%2finfo.html을 시도해 봅시다. 일반적으로 /info.html URL은 우리가 기기에 처음 로그인할 때의 모든 LAN/WAN 정보를 포함하고 있으나 인증되지 않은 사용자들을 로그인 화면으로 돌려보냅니다. 특별한 URL로 우리는 인증 요구사항을 우회할 수 있을지도 모르겠어요.

상대 경로를 고려한 일부 매치/치환 후에도 여전히 별로 흥미로운 내용이 나타나지 않아요. 우리는 경로 트래버설을 사용하여 인증을 우회했지만 뭔가 부족한 것 같아요.

Burp 트래픽을 살펴보면, /cgi/`various_nifty_cgi`.js로의 여러 요청이 404를 반환하는 것을 볼 수 있는데, 일반적으로 우리가 원하는 모든 정보를 반환합니다. 또한 이 파일들에 대한 요청을 만들 때 전달되는 몇 가지 매개변수도 볼 수 있어요.

그 중 하나인 (_t)은 날짜 및 시간 스탬프에요. 다른 하나는 CSRF 토큰처럼 작동하는 httoken인데, 이러한 토큰들이 어디에서 어떻게 생성되는지 알아내는 것은 다음 섹션에서 논의할 것입니다. 지금은 이 특정 요청들이 실패하는 이유에 초점을 맞춰봅시다.

<div class="content-ad"></div>

아래의 텍스트를 Markdown 형식으로 변경하세요.

<div class="content-ad"></div>

지금까지의 빠른 요약:

- 인증을 우회하여 인증된 사용자만 액세스할 수 있는 페이지에 액세스할 수 있습니다.
- 해당 페이지에는 민감한 정보를 요청하거나 포스트 요청을 만들 수 있는 httoken에 액세스할 수 있습니다. 그리고 설정 변경을 할 수 있는 권한을 부여받을 수 있습니다.
- 우리는 httoken이 수락되기 위해 Referer 헤더를 적절히 설정해야 한다는 것을 알고 있습니다.

# 적절한 httoken을 얻는 모험

우리는 접근한 페이지에서 어느 시점에서 httoken이 얻어진다는 것을 알지만, 그들이 어디서 나오는지 또는 어떻게 생성되는지는 알지 못합니다. 이것은 장치에서 민감한 작업을 수행하거나 액세스하기 위해 필요한 요소이기 때문에, 이 부정행위를 더 이어나가고 싶다면 이러한 토큰이 어디서 발급되어지는지를 파악하는 것이 중요할 것입니다. 웹 인터페이스가 이 토큰을 생성하는 방법을 추적하는 것은 Capture-the-Flag 이벤트에서 하는 것처럼 느껴졌습니다.

<div class="content-ad"></div>

우리가 경로 순회로 접근한 info.html 페이지는 /cgi/ 디렉토리 아래에 있는 .js 파일에서 데이터를 가져와 정보 테이블을 채우고 있었으며, 두 개의 매개변수를 전달하고 있었습니다. 하나는 날짜 및 시간 스탬프(_t)이고, 다른 하나는 파악하려는 httoken입니다.

/cgi/에서 정보를 가져오기 위해 사용되는 링크들이 URLToken() 함수를 사용하여 생성되고 있음을 알 수 있습니다. 이 함수는 httoken을 설정하고(get_token()을 이용하여) 있는데, 페이지에서 사용된 스크립트 중 어디에도 get_token() 함수가 정의되어 있지 않은 것 같습니다.

URLToken()이 정의된 바로 위에는 아래와 같이 이상한 문자열이 정의되어 있는 것을 볼 수 있습니다.

<img src="/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_8.png" />

<div class="content-ad"></div>

해당하는 위치를 살펴보면 다음과 같은 조각을 찾을 수 있습니다.

위 코드를 실행하면 페이지에 다음 스크립트가 추가됩니다:

getToken() 함수를 찾았지만 여기로 이어진 스니펫들과 마찬가지로 뭔가 이상한 일을 하고 있습니다. 모든 페이지에 존재하는 이미지 태그에서 또 다른 인코딩된 문자열을 가져 오고 있습니다 (인코딩된 문자열이 다릅니다). 여기에서 무슨 일이 벌어지고 있는 걸까요?

<div class="content-ad"></div>

"이 공간 화상 img src 문자열에서 httoken이 가져와져 민감한 리소스에 요청을 만드는 데 사용됩니다.

Ghidra에서 httoken이 img 태그에 삽입되는 함수를 찾을 수 있습니다.

<img src="/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_10.png" />

httoken의 설정/반환 및 GET 및 POST 요청에 대한 검사에 대한 모든 세부 정보에 대해 다루지 않고, 다음과 같이 말할 수 있습니다:"

<div class="content-ad"></div>

- 웹 인터페이스의 다양한 부분에 GET 및 POST 요청을 보내기 위해 필요한 httokens은 서버 측에서 생성됩니다.
- 페이지가 로드될 때 img 태그에 인코딩되어 저장됩니다.
- 그런 다음 클라이언트 측 자바스크립트에서 디코딩됩니다.

요청 중에 사용되는 토큰과 Referer가 일치하는 한 원하는 요청에 토큰을 사용할 수 있습니다. 로그인.html에서 얻은 토큰을 사용하여 민감한 페이지로 요청을 보낼 수 있지만 구성 변경과 같은 일부 작업에 액세스하려면 여전히 인증 우회가 필요합니다.

특히 WSR-2533DHPL2에서 토큰의 이러한 지식만으로도 장치의 관리자 암호에 액세스할 수 있습니다. 같은 시기에 출시된 펌웨어를 가진 WSR-2533DHP3에서는 이미 수정된 취약점이 있는 것으로 보입니다.

이제 인증되지 않고 기기에서 어떤 작업이든 효과적으로 수행할 수 있다는 것을 알게 되었으니, 그것으로 무엇을 할 수 있는지 살펴봅시다.

<div class="content-ad"></div>

# 설정 옵션을 삽입하고 telnetd를 활성화합니다

웹 인터페이스 또는 애플리케이션에서 핑 기능과 같은 유틸리티를 갖고 있는 경우, 저희가 먼저 확인하는 곳 중 하나는 이러한 유틸리티가 어떻게 구현되었는지입니다. 왜냐하면 단순히 Google에서 라우터 핑 유틸리티가 명령 삽입 취약점에 취약하다는 많은 사례들이 나옵니다.

핑 명령에서 쉽게 취약한 명령 삽입이 없었지만, 핑 명령이 웹 인터페이스에서 실행될 때 핑할 호스트의 입력을 받게 됩니다. 이것이 어떻게 실행되는지 살펴보는 것으로 다른 취약점을 발견했습니다.

![이미지](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_11.png)

<div class="content-ad"></div>

요청이 성공적으로 이루어지면, ARC_ping_ipaddress가 전역 구성 파일에 저장됩니다. 이를 기억하며, 제가 먼저 해본 것은 새 줄/개행 문자(%0A로 URL 인코딩)를 삽입한 후 일부 텍스트를 입력하여 구성 설정을 주입할 수 있는지 확인하는 것이었습니다. 확인 결과, 구성 파일을 확인할 때 %0A 뒤에 입력한 텍스트가 새 줄에 나타납니다.

![image](/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_12.png)

이를 고려하여, 우리는 볼 수 있는 흥미로운 구성 설정을 살펴보고, ARC_ping_ipaddress 매개변수를 주입하여 그 값을 덮어쓸 수 있기를 희망합니다. 구성 파일에서 여러 옵션을 볼 수 있지만, 내 관심을 끈 하나는 ARC_SYS_TelnetdEnable=0이었습니다. Telnetd를 활성화하는 것은 기기에 원격 쉘을 획들할 수 있는 좋은 후보로 보였습니다.

ARC_SYS_TelnetdEnable=1로 구성 파일에 간단히 주입해도 ARC_SYS_TelnetdEnable=0이 파일 끝부분에 나타나기 때문에 충돌 설정이 발생할 수 있을지 애매했습니다. 하지만, Burp Suite에서 다음 요청을 보낸 후 재부팅 요청을 보내면 (일부 구성 변경이 적용되려면 필요합니다).

<div class="content-ad"></div>

<img src="/assets/img/2024-06-22-BypassingAuthenticationonArcadyanRouterswithCVE-202120090androotingsomeBuffalo_13.png" />

재부팅이 완료되면 텔넷이 수신 대기 중인 포트 23에서 장치에 연결할 수 있고, UART를 통해 얻는 것과 마찬가지로 root BusyBox 쉘로 환영받습니다.

# 전부 함께

만약 우리가 이 쉽게 악용할 수 있는 기회를 이용하려면, 파이썬 스크립트에서 함께 조합해야 할 부분들은 다음과 같습니다:

<div class="content-ad"></div>

- 페이지의 img 태그에서 올바른 httokens을 가져옵니다.
- 이러한 httokens을 경로 이탈과 결합하여 apply_abstract.cgi에 유효한 요청을 보냅니다.
- apply_abstract.cgi에 ARC_SYS_TelnetdEnable=1 설정 옵션을 삽입합니다.
- 장치를 다시 부팅하기 위해 또 다른 유효한 요청을 보냅니다.

![이미지](https://miro.medium.com/v2/resize:fit:1400/1*qT0xv6hfMHDf0BDm5bqAqw.gif)

# 놀라운 사실: 더 많은 영향을 받는 장치

이 블로그에서 논의된 취약점의 90일 공개 날짜 직전에 Shodan 및 BinaryEdge를 통해 온라인에서 보이는 잠재적으로 영향을 받을 수 있는 장치 수를 결정하려고 했습니다. 검색 중에 버팔로 장치에서 본 것과 유사한 웹 인터페이스를 갖춘 여러 장치를 발견했습니다. 사실상 똑같았는데, 거의 모든 img 태그에서 동일한 이상한 방법으로 httokens을 숨기고 "enkripsi" 문자열에 은식화된 자바스크립트 함수를 사용하는 것으로 보였습니다.

<div class="content-ad"></div>

공통점은 모든 장치가 Arcadyan에 의해 제조되었다는 것입니다. 사실, 버팔로 제품 라인 외의 영향을 받는 장치를 찾기 위해 더 많이 살펴볼 필요가 있었을 것으로 생각됩니다. 왜냐하면 버팔로 펌웨어의 많은 부분이 Arcadyan에 의해 제작되었다는 것이 분명했기 때문입니다. 그러나 일련의 Arcadyan 제조 장치를 입수하고 테스트한 결과, 모든 장치가 동일하게 작성되지 않았으며 장치들이 항상 정확히 동일한 방식으로 영향을 받는 것은 아니라는 것도 분명했습니다.

그럼에도 불구하고, 우리가 테스트할 수 있었거나 제3자를 통해 테스트된 모든 장치들이 적어도 하나의 취약성을 공유했습니다: 공격자가 인증을 우회할 수 있는 경로 이동(CVE-2021-20090로 할당됨)입니다. 이는 거의 모든 Arcadyan 제조 라우터/모뎀에서 발견된 것으로 보이며, 이는 원래 2008년까지 판매된 장치들도 포함하여 찾을 수 있었습니다.

2021년 4월 21일, Tenable은 CVE-2021-20090를 4개 추가 업체(Hughesnet, O2, Verizon, Vodafone)에 보고하였으며, 이 문제를 4월 22일에 Arcadyan에 보고하였습니다. 시간이 흘러간 결과로 많은 업체들이 영향을 받았고, 모든 업체들과 연락을 취하고 추적하는 것은 매우 어려워졌습니다. 그래서 5월 18일, Tenable은 이 문제를 처리하기 위해 CERT 조정 센터에 문제를 보고하였습니다. 영향을 받는 장치 목록은 Tenable의 고발서 또는 문제를 추적하는 CERT 페이지에서 확인할 수 있습니다.

Arcadyan 펌웨어의 이러한 취약성이 최소 10년 동안 존재했으며, 그 결과 공급망을 통해 적어도 17개의 다른 제조업체의 20개 모델에 이르기까지 길을 찾았다는 점에 대해 훨씬 더 큰 대화가 있을 수 있으며, 이에 대한 논의는 Tenable이 발표한 백서에서 짚여져 있습니다.

<div class="content-ad"></div>

# 배운 점

버팔로 WSR-2533DHPL2는 취약점을 발견하기 위해 구매한 첫 번째 라우터였는데, 정말 재미있는 경험이었어요. 이상한 가려움 작업과 버그의 단순함으로 인해 내 소중한 CTF처럼 느껴졌어요. 하나의 취약점(CVE-2021–20090)이 얼마나 널리 퍼져 있는지 알게 되어 예상 이상의 것을 얻었지만, 이는 소비자 전자제품에 대한 연구 방법을 접근하는 방법에 대한 중요한 교훈이었어요: 기기를 판매하는 공급 업체가 제조한 것은 아니라는 것, 소비자 라우터의 펌웨어에 버그를 발견하면 단지 연구 중인 기기만이 아니라 수많은 업체와 기기에 영향을 줄 수 있다는 점을 알 수 있었어요.

또한, 20개 이상의 영향을 받는 기기 중 하나를 손에 넣을 수 있는 보안 연구자들이 구성 주입과 같은 사후 인증 취약성을 찾아보고(보고)하는 것을 장려하고 싶어요. 이 기기 세트에서 더 많은 문제가 발견될 것으로 의심하지만, 각 기기는 약간 다르며 해당 국가에 거주하지 않는 연구원들에게 구하기 어렵다는 점을 알 수 있어요.

읽어주셔서 감사합니다. 해킹 즐기세요!